{"pr_number": 3203, "pr_title": "Clean up `HttpDeframer` and gRPC", "pr_createdAt": "2020-11-27T20:02:20Z", "pr_url": "https://github.com/line/armeria/pull/3203", "timeline": [{"oid": "859273fead0b617c025e10b35ad91537b2ceea54", "url": "https://github.com/line/armeria/commit/859273fead0b617c025e10b35ad91537b2ceea54", "message": "Clean up `HttpDeframer` and gRPC\n\n- Split `HttpDeframer` into an interface and an implementation.\n  - We can save some extra object allocation.\n  - We can hide the implementation detail, like extending\n    `DefaultStreamMessage`.\n- Added `@UnstableApi` wherever applicable.\n- Fixed a bug where `HttpDeframer` sometimes increases the upstream\n  demand to a value greater than 1.\n- Removed redundant code from the gRPC code base.\n- Miscellaneous:\n  - Fix a bug where `DefaultDnsQueryLifecycleObserver` does not strip\n    the scope ID from an IP address.", "committedDate": "2020-11-27T20:00:44Z", "type": "commit"}, {"oid": "b978b7256a488c35f87eb66dc6480f398fb2c5cc", "url": "https://github.com/line/armeria/commit/b978b7256a488c35f87eb66dc6480f398fb2c5cc", "message": "Renames / Use abort() in lieu of close() in the test", "committedDate": "2020-11-27T20:10:57Z", "type": "commit"}, {"oid": "29150cbbfd5ee28d39223eeb1815f699e173ce62", "url": "https://github.com/line/armeria/commit/29150cbbfd5ee28d39223eeb1815f699e173ce62", "message": "Strip scope ID for the tests, too", "committedDate": "2020-11-27T20:37:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTc4MjM2MQ==", "url": "https://github.com/line/armeria/pull/3203#discussion_r531782361", "bodyText": "Any idea to use an other way? This is the last reference to HttpDeframer.close().", "author": "trustin", "createdAt": "2020-11-27T20:48:35Z", "path": "grpc/src/main/java/com/linecorp/armeria/server/grpc/ArmeriaServerCall.java", "diffHunk": "@@ -502,10 +502,22 @@ public void transportReportStatus(Status status, Metadata unused) {\n     private void closeListener(Status newStatus) {\n         if (!listenerClosed) {\n             listenerClosed = true;\n+\n             ctx.logBuilder().responseContent(GrpcLogUtil.rpcResponse(newStatus, firstResponse), null);\n+\n             final boolean ok = newStatus.isOk();\n-            setClientStreamClosed(ok);\n-            messageFramer.close();\n+            if (!clientStreamClosed) {\n+                clientStreamClosed = true;\n+                if (ok) {\n+                    requestDeframer.close();", "originalCommit": "29150cbbfd5ee28d39223eeb1815f699e173ce62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTk5NjA5NA==", "url": "https://github.com/line/armeria/pull/3203#discussion_r531996094", "bodyText": "I think it is safe to call HttpDeframer.abort() here", "author": "ikhoon", "createdAt": "2020-11-28T07:43:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTc4MjM2MQ=="}], "type": "inlineReview"}, {"oid": "d2c945ee4b6a3527a46812d4267e6f1b1d5e9d0c", "url": "https://github.com/line/armeria/commit/d2c945ee4b6a3527a46812d4267e6f1b1d5e9d0c", "message": "Remove HttpDeframer.close()", "committedDate": "2020-11-28T04:38:28Z", "type": "commit"}, {"oid": "8fafdd12ac516c3608ca25554d07bf512458ebda", "url": "https://github.com/line/armeria/commit/8fafdd12ac516c3608ca25554d07bf512458ebda", "message": "Fix another flakiness in DnsMetricsTest", "committedDate": "2020-11-28T04:48:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTk1MDAwNg==", "url": "https://github.com/line/armeria/pull/3203#discussion_r531950006", "bodyText": "nit: Remove redundant cast?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            final ByteBuf byteBuf = byteBufConverter.apply((HttpData) data);\n          \n          \n            \n                            final ByteBuf byteBuf = byteBufConverter.apply(data);", "author": "ikhoon", "createdAt": "2020-11-28T06:43:12Z", "path": "core/src/main/java/com/linecorp/armeria/common/stream/DefaultHttpDeframer.java", "diffHunk": "@@ -0,0 +1,313 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.stream;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Subscription;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.HttpObject;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.util.concurrent.EventExecutor;\n+\n+/**\n+ * The default {@link HttpDeframer} implementation.\n+ */\n+final class DefaultHttpDeframer<T>\n+        extends DefaultStreamMessage<T>\n+        implements HttpDeframer<T>, HttpDeframerOutput<T> {\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<DefaultHttpDeframer, Subscription> upstreamUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(DefaultHttpDeframer.class, Subscription.class, \"upstream\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicIntegerFieldUpdater<DefaultHttpDeframer> initializedUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(DefaultHttpDeframer.class, \"initialized\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicIntegerFieldUpdater<DefaultHttpDeframer> askedUpstreamForElementUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(DefaultHttpDeframer.class, \"askedUpstreamForElement\");\n+\n+    private final HttpDeframerHandler<T> handler;\n+    private final ByteBufDeframerInput input;\n+    private final Function<? super HttpData, ? extends ByteBuf> byteBufConverter;\n+\n+    private boolean handlerProduced;\n+    private boolean sawLeadingHeaders;\n+\n+    @Nullable\n+    private volatile EventExecutor eventLoop;\n+    @Nullable\n+    private volatile Subscription upstream;\n+    private volatile int initialized;\n+    private volatile int askedUpstreamForElement;\n+\n+    @Nullable\n+    private volatile Throwable cause;\n+    private volatile boolean cancelled;\n+    private volatile boolean completing;\n+\n+    /**\n+     * Returns a new {@link DefaultHttpDeframer} with the specified {@link HttpDeframerHandler},\n+     * {@link ByteBufAllocator} and {@code byteBufConverter}.\n+     */\n+    DefaultHttpDeframer(HttpDeframerHandler<T> handler, ByteBufAllocator alloc,\n+                        Function<? super HttpData, ? extends ByteBuf> byteBufConverter) {\n+        this.handler = requireNonNull(handler, \"handler\");\n+        input = new ByteBufDeframerInput(requireNonNull(alloc, \"alloc\"));\n+        this.byteBufConverter = requireNonNull(byteBufConverter, \"byteBufConverter\");\n+\n+        whenComplete().handle((unused1, unused2)  -> {\n+            // In addition to 'onComplete()', 'onError()' and 'cancel()',\n+            // make sure to call 'cleanup()' even when 'abort()' or 'close()' is invoked directly\n+            cleanup();\n+            return null;\n+        });\n+    }\n+\n+    @Override\n+    public void add(T e) {\n+        if (tryWrite(e)) {\n+            handlerProduced = true;\n+        }\n+    }\n+\n+    @Override\n+    SubscriptionImpl subscribe(SubscriptionImpl subscription) {\n+        final SubscriptionImpl subscriptionImpl = super.subscribe(subscription);\n+        if (subscriptionImpl == subscription) {\n+            final EventExecutor eventLoop = subscription.executor();\n+            this.eventLoop = eventLoop;\n+            deferredInit(eventLoop);\n+        }\n+        return subscriptionImpl;\n+    }\n+\n+    private void deferredInit(@Nullable EventExecutor eventLoop) {\n+        final Subscription upstream = this.upstream;\n+\n+        if (upstream != null && eventLoop != null) {\n+            if (initializedUpdater.compareAndSet(this, 0, 1)) {\n+                if (cancelled) {\n+                    upstream.cancel();\n+                    return;\n+                }\n+\n+                final Throwable cause = this.cause;\n+                if (cause != null) {\n+                    if (eventLoop.inEventLoop()) {\n+                        onError0(cause);\n+                    } else {\n+                        eventLoop.execute(() -> onError0(cause));\n+                    }\n+                    return;\n+                }\n+\n+                if (completing) {\n+                    if (eventLoop.inEventLoop()) {\n+                        onComplete0();\n+                    } else {\n+                        eventLoop.execute(this::onComplete0);\n+                    }\n+                    return;\n+                }\n+\n+                if (demand() > 0) {\n+                    askUpstreamForElement();\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    void request(long n) {\n+        // Fetch from upstream only when this deframer is initialized and the given demand is valid.\n+        if (initialized != 0 && n > 0) {\n+            askUpstreamForElement();\n+        }\n+\n+        super.request(n);\n+    }\n+\n+    private void askUpstreamForElement() {\n+        if (askedUpstreamForElementUpdater.compareAndSet(this, 0, 1)) {\n+            final Subscription upstream = this.upstream;\n+            assert upstream != null;\n+            upstream.request(1);\n+        }\n+    }\n+\n+    @Override\n+    void cancel() {\n+        cancelAndCleanup();\n+        super.cancel();\n+    }\n+\n+    @Override\n+    public void onSubscribe(Subscription subscription) {\n+        requireNonNull(subscription, \"subscription\");\n+        if (upstreamUpdater.compareAndSet(this, null, subscription)) {\n+            deferredInit(eventLoop);\n+        } else {\n+            subscription.cancel();\n+        }\n+    }\n+\n+    @Override\n+    public void onNext(HttpObject data) {\n+        final EventExecutor eventLoop = this.eventLoop;\n+        assert eventLoop != null;\n+        if (eventLoop.inEventLoop()) {\n+            onNext0(data);\n+        } else {\n+            eventLoop.execute(() -> onNext0(data));\n+        }\n+    }\n+\n+    private void onNext0(HttpObject obj) {\n+        askedUpstreamForElement = 0;\n+        handlerProduced = false;\n+        try {\n+            // Call the handler so that it publishes something.\n+            if (obj instanceof HttpHeaders) {\n+                final HttpHeaders headers = (HttpHeaders) obj;\n+                if (headers instanceof ResponseHeaders &&\n+                    ((ResponseHeaders) headers).status().isInformational()) {\n+                    handler.processInformationalHeaders((ResponseHeaders) headers, this);\n+                } else if (!sawLeadingHeaders) {\n+                    sawLeadingHeaders = true;\n+                    handler.processHeaders((HttpHeaders) obj, this);\n+                } else {\n+                    handler.processTrailers((HttpHeaders) obj, this);\n+                }\n+            } else if (obj instanceof HttpData) {\n+                final HttpData data = (HttpData) obj;\n+                final ByteBuf byteBuf = byteBufConverter.apply((HttpData) data);", "originalCommit": "8fafdd12ac516c3608ca25554d07bf512458ebda", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTk4MzUxNw==", "url": "https://github.com/line/armeria/pull/3203#discussion_r531983517", "bodyText": "\ud83d\udc4d", "author": "ikhoon", "createdAt": "2020-11-28T07:27:08Z", "path": "core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java", "diffHunk": "@@ -147,7 +154,7 @@ void timeout() {\n                         () -> client2.execute(RequestHeaders.of(HttpMethod.GET, \"http://foo.com\"))\n                                      .aggregate().join());\n                 assertThat(cause.getCause()).isInstanceOf(UnprocessedRequestException.class);\n-                assertThat(cause.getCause().getCause())\n+                assertThat(Throwables.getRootCause(cause))", "originalCommit": "8fafdd12ac516c3608ca25554d07bf512458ebda", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjAzNDI3NQ==", "url": "https://github.com/line/armeria/pull/3203#discussion_r532034275", "bodyText": "The root cause is UnknownHostException?\nhttps://ci.appveyor.com/project/line/armeria/builds/36552679/job/omd5r3ft1vwdxa44#L595", "author": "minwoox", "createdAt": "2020-11-28T12:23:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTk4MzUxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjA1NTg5Mw==", "url": "https://github.com/line/armeria/pull/3203#discussion_r532055893", "bodyText": "No, it's not? \ud83d\ude04", "author": "trustin", "createdAt": "2020-11-28T16:09:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTk4MzUxNw=="}], "type": "inlineReview"}, {"oid": "64793921920c0d7be01db28e119b661a092c8d52", "url": "https://github.com/line/armeria/commit/64793921920c0d7be01db28e119b661a092c8d52", "message": "Update core/src/main/java/com/linecorp/armeria/common/stream/DefaultHttpDeframer.java\n\nCo-authored-by: Ikhun Um <ih.pert@gmail.com>", "committedDate": "2020-11-28T07:42:46Z", "type": "commit"}]}