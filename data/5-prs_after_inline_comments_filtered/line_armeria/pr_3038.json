{"pr_number": 3038, "pr_title": "Provide a way to consume headers and data separately from HttpResponse", "pr_createdAt": "2020-08-31T13:42:38Z", "pr_url": "https://github.com/line/armeria/pull/3038", "timeline": [{"oid": "d05fcb1d6104fd656e25a64ca0cfe16f13b42fe7", "url": "https://github.com/line/armeria/commit/d05fcb1d6104fd656e25a64ca0cfe16f13b42fe7", "message": "Provide a way to consume headers and data separately from HttpResponse\n\nMotivation:\n\n`HttpResponse` publishes HTTP headers and payloads in a single `Publisher`.\nWhen subscribing `HttpResponse`, users should distinguish `HttpHeaders` and HttpData manually.\nThe single stream is also inconvenient when integrating Armeria client with others.\nSome clients only takes pre-materialized headers and body stream.\n`ArmeriaHttpClientResponseSubscriber` is a example.\nhttps://github.com/line/armeria/blob/fbe90f0f2a952578012a552c26b3f4f8bdb33c8c/spring/boot2-webflux-autoconfigure/src/main/java/com/linecorp/armeria/spring/web/reactive/ArmeriaHttpClientResponseSubscriber.java#46\n\nModifications:\n\n- Add `HttpResponseBodyStream` that publishes `HttpData` and completes `HttpHeaders` using `CompletableFuture`\n- Add `HttpResponse.toBodyStream` for easy conversion.\n\nResult:\n\nYou can now split HTTP headers from `HttpResponse` convenientely using `HttpResponse.toBodyStream`\n\nTODO:\n- Migrate ArmeriaHttpClientResponseSubscriber to use `HttpResponse.toBodyStream`", "committedDate": "2020-08-31T13:40:36Z", "type": "commit"}, {"oid": "b63f0b2a0499604c22c80d8ff0b9029a6a41a3de", "url": "https://github.com/line/armeria/commit/b63f0b2a0499604c22c80d8ff0b9029a6a41a3de", "message": "Fetch headers early", "committedDate": "2020-09-01T06:55:50Z", "type": "commit"}, {"oid": "b63f0b2a0499604c22c80d8ff0b9029a6a41a3de", "url": "https://github.com/line/armeria/commit/b63f0b2a0499604c22c80d8ff0b9029a6a41a3de", "message": "Fetch headers early", "committedDate": "2020-09-01T06:55:50Z", "type": "forcePushed"}, {"oid": "2eada31e6bf07fbc65118dab528777b83339fb0a", "url": "https://github.com/line/armeria/commit/2eada31e6bf07fbc65118dab528777b83339fb0a", "message": "Checkstyle", "committedDate": "2020-09-01T07:43:36Z", "type": "commit"}, {"oid": "f5875796ff63163a414888d58b132b494bcf1555", "url": "https://github.com/line/armeria/commit/f5875796ff63163a414888d58b132b494bcf1555", "message": "Fix flaky test", "committedDate": "2020-09-01T10:18:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTU2MDQxNA==", "url": "https://github.com/line/armeria/pull/3038#discussion_r481560414", "bodyText": "{@linkplain HttpHeaders trailers}?", "author": "minwoox", "createdAt": "2020-09-02T02:20:27Z", "path": "core/src/main/java/com/linecorp/armeria/common/HttpResponseBodyStream.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+import org.reactivestreams.Subscriber;\n+\n+import com.linecorp.armeria.common.stream.StreamMessage;\n+import com.linecorp.armeria.common.stream.SubscriptionOption;\n+\n+import io.netty.util.concurrent.EventExecutor;\n+\n+/**\n+ * An HTTP response body stream which publishes HTTP payloads as a stream of {@link HttpData}.\n+ * {@link #informationalHeaders()}, {@link #headers()} will be completed before publishing the first element of\n+ * {@link HttpData}. {@link #trailers()} might not complete until the entire {@link HttpData} has been consumed.\n+ */\n+public interface HttpResponseBodyStream extends StreamMessage<HttpData> {\n+    /**\n+     * Returns a {@link CompletableFuture} which completes a list of\n+     * <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#Information_responses\">informational\n+     * </a> {@link ResponseHeaders}.\n+     */\n+    CompletableFuture<List<ResponseHeaders>> informationalHeaders();\n+\n+    /**\n+     * Returns a {@link CompletableFuture} which completes a non-informational {@link ResponseHeaders}.\n+     */\n+    CompletableFuture<ResponseHeaders> headers();\n+\n+    /**\n+     * Returns a {@link CompletableFuture} which completes a {@link HttpHeaders trailers}.", "originalCommit": "f5875796ff63163a414888d58b132b494bcf1555", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTU2MDg2Nw==", "url": "https://github.com/line/armeria/pull/3038#discussion_r481560867", "bodyText": "ditto", "author": "minwoox", "createdAt": "2020-09-02T02:21:06Z", "path": "core/src/main/java/com/linecorp/armeria/common/HttpResponseBodyStream.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+import org.reactivestreams.Subscriber;\n+\n+import com.linecorp.armeria.common.stream.StreamMessage;\n+import com.linecorp.armeria.common.stream.SubscriptionOption;\n+\n+import io.netty.util.concurrent.EventExecutor;\n+\n+/**\n+ * An HTTP response body stream which publishes HTTP payloads as a stream of {@link HttpData}.\n+ * {@link #informationalHeaders()}, {@link #headers()} will be completed before publishing the first element of\n+ * {@link HttpData}. {@link #trailers()} might not complete until the entire {@link HttpData} has been consumed.\n+ */\n+public interface HttpResponseBodyStream extends StreamMessage<HttpData> {\n+    /**\n+     * Returns a {@link CompletableFuture} which completes a list of\n+     * <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#Information_responses\">informational\n+     * </a> {@link ResponseHeaders}.\n+     */\n+    CompletableFuture<List<ResponseHeaders>> informationalHeaders();\n+\n+    /**\n+     * Returns a {@link CompletableFuture} which completes a non-informational {@link ResponseHeaders}.\n+     */\n+    CompletableFuture<ResponseHeaders> headers();\n+\n+    /**\n+     * Returns a {@link CompletableFuture} which completes a {@link HttpHeaders trailers}.\n+     * If a {@link HttpResponse} does not contain trailers, the returned {@link CompletableFuture} completes\n+     * with an {@link HttpHeaders#of() empty headers}.", "originalCommit": "f5875796ff63163a414888d58b132b494bcf1555", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTU2MjUzNA==", "url": "https://github.com/line/armeria/pull/3038#discussion_r481562534", "bodyText": "nit: requireNonNull(executor, \"executor\");", "author": "minwoox", "createdAt": "2020-09-02T02:23:43Z", "path": "core/src/main/java/com/linecorp/armeria/common/DefaultHttpResponseBodyStream.java", "diffHunk": "@@ -0,0 +1,352 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common;\n+\n+import static com.linecorp.armeria.common.util.Exceptions.throwIfFatal;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.math.LongMath;\n+\n+import com.linecorp.armeria.common.stream.NoopSubscriber;\n+import com.linecorp.armeria.common.stream.SubscriptionOption;\n+import com.linecorp.armeria.common.util.UnmodifiableFuture;\n+import com.linecorp.armeria.internal.common.stream.NoopSubscription;\n+\n+import io.netty.util.concurrent.EventExecutor;\n+\n+final class DefaultHttpResponseBodyStream implements HttpResponseBodyStream {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultHttpResponseBodyStream.class);\n+\n+    private static final AtomicReferenceFieldUpdater<BodySubscriber, Subscription> upstreamUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(BodySubscriber.class, Subscription.class, \"upstream\");\n+\n+    private static final AtomicReferenceFieldUpdater<BodySubscriber, Subscriber> downstreamUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(BodySubscriber.class, Subscriber.class, \"downstream\");\n+\n+    private static final ResponseHeaders HEADERS_WITH_UNKNOWN_STATUS = ResponseHeaders.of(HttpStatus.UNKNOWN);\n+    private static final HeadersFuture<List<ResponseHeaders>> EMPTY_INFORMATIONAL_HEADERS;\n+    private static final HeadersFuture<HttpHeaders> EMPTY_TRAILERS;\n+\n+    static {\n+        EMPTY_INFORMATIONAL_HEADERS = new HeadersFuture<>();\n+        EMPTY_INFORMATIONAL_HEADERS.doComplete(ImmutableList.of());\n+\n+        EMPTY_TRAILERS = new HeadersFuture<>();\n+        EMPTY_TRAILERS.doComplete(HttpHeaders.of());\n+    }\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<DefaultHttpResponseBodyStream, HeadersFuture>\n+            informationalHeadersFutureUpdater = AtomicReferenceFieldUpdater\n+            .newUpdater(DefaultHttpResponseBodyStream.class, HeadersFuture.class, \"informationalHeadersFuture\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<DefaultHttpResponseBodyStream, HeadersFuture>\n+            trailersFutureUpdater = AtomicReferenceFieldUpdater\n+            .newUpdater(DefaultHttpResponseBodyStream.class, HeadersFuture.class, \"trailersFuture\");\n+\n+    private final HeadersFuture<ResponseHeaders> headersFuture = new HeadersFuture<>();\n+    private final BodySubscriber bodySubscriber = new BodySubscriber();\n+    private final HttpResponse response;\n+    private final EventExecutor executor;\n+\n+    @Nullable\n+    private volatile HeadersFuture<List<ResponseHeaders>> informationalHeadersFuture;\n+    @Nullable\n+    private volatile HeadersFuture<HttpHeaders> trailersFuture;\n+    private volatile boolean wroteAny;\n+\n+    DefaultHttpResponseBodyStream(HttpResponse response, EventExecutor executor,\n+                                  SubscriptionOption... options) {\n+        requireNonNull(response, \"response\");\n+        this.response = response;\n+        this.executor = executor;", "originalCommit": "f5875796ff63163a414888d58b132b494bcf1555", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTU2NDM0Ng==", "url": "https://github.com/line/armeria/pull/3038#discussion_r481564346", "bodyText": "How about doing this is the bodySubscriber? (e.g. setting pendingRequests to 1, etc.)", "author": "minwoox", "createdAt": "2020-09-02T02:26:26Z", "path": "core/src/main/java/com/linecorp/armeria/common/DefaultHttpResponseBodyStream.java", "diffHunk": "@@ -0,0 +1,352 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common;\n+\n+import static com.linecorp.armeria.common.util.Exceptions.throwIfFatal;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.math.LongMath;\n+\n+import com.linecorp.armeria.common.stream.NoopSubscriber;\n+import com.linecorp.armeria.common.stream.SubscriptionOption;\n+import com.linecorp.armeria.common.util.UnmodifiableFuture;\n+import com.linecorp.armeria.internal.common.stream.NoopSubscription;\n+\n+import io.netty.util.concurrent.EventExecutor;\n+\n+final class DefaultHttpResponseBodyStream implements HttpResponseBodyStream {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultHttpResponseBodyStream.class);\n+\n+    private static final AtomicReferenceFieldUpdater<BodySubscriber, Subscription> upstreamUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(BodySubscriber.class, Subscription.class, \"upstream\");\n+\n+    private static final AtomicReferenceFieldUpdater<BodySubscriber, Subscriber> downstreamUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(BodySubscriber.class, Subscriber.class, \"downstream\");\n+\n+    private static final ResponseHeaders HEADERS_WITH_UNKNOWN_STATUS = ResponseHeaders.of(HttpStatus.UNKNOWN);\n+    private static final HeadersFuture<List<ResponseHeaders>> EMPTY_INFORMATIONAL_HEADERS;\n+    private static final HeadersFuture<HttpHeaders> EMPTY_TRAILERS;\n+\n+    static {\n+        EMPTY_INFORMATIONAL_HEADERS = new HeadersFuture<>();\n+        EMPTY_INFORMATIONAL_HEADERS.doComplete(ImmutableList.of());\n+\n+        EMPTY_TRAILERS = new HeadersFuture<>();\n+        EMPTY_TRAILERS.doComplete(HttpHeaders.of());\n+    }\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<DefaultHttpResponseBodyStream, HeadersFuture>\n+            informationalHeadersFutureUpdater = AtomicReferenceFieldUpdater\n+            .newUpdater(DefaultHttpResponseBodyStream.class, HeadersFuture.class, \"informationalHeadersFuture\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<DefaultHttpResponseBodyStream, HeadersFuture>\n+            trailersFutureUpdater = AtomicReferenceFieldUpdater\n+            .newUpdater(DefaultHttpResponseBodyStream.class, HeadersFuture.class, \"trailersFuture\");\n+\n+    private final HeadersFuture<ResponseHeaders> headersFuture = new HeadersFuture<>();\n+    private final BodySubscriber bodySubscriber = new BodySubscriber();\n+    private final HttpResponse response;\n+    private final EventExecutor executor;\n+\n+    @Nullable\n+    private volatile HeadersFuture<List<ResponseHeaders>> informationalHeadersFuture;\n+    @Nullable\n+    private volatile HeadersFuture<HttpHeaders> trailersFuture;\n+    private volatile boolean wroteAny;\n+\n+    DefaultHttpResponseBodyStream(HttpResponse response, EventExecutor executor,\n+                                  SubscriptionOption... options) {\n+        requireNonNull(response, \"response\");\n+        this.response = response;\n+        this.executor = executor;\n+\n+        response.subscribe(bodySubscriber, executor, options);\n+        // Prefetch headers\n+        bodySubscriber.request(1);", "originalCommit": "f5875796ff63163a414888d58b132b494bcf1555", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTU2Nzk1MQ==", "url": "https://github.com/line/armeria/pull/3038#discussion_r481567951", "bodyText": "Do we need upstreamUpdater? Can't we just use the subscription?", "author": "minwoox", "createdAt": "2020-09-02T02:32:03Z", "path": "core/src/main/java/com/linecorp/armeria/common/DefaultHttpResponseBodyStream.java", "diffHunk": "@@ -0,0 +1,352 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common;\n+\n+import static com.linecorp.armeria.common.util.Exceptions.throwIfFatal;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.math.LongMath;\n+\n+import com.linecorp.armeria.common.stream.NoopSubscriber;\n+import com.linecorp.armeria.common.stream.SubscriptionOption;\n+import com.linecorp.armeria.common.util.UnmodifiableFuture;\n+import com.linecorp.armeria.internal.common.stream.NoopSubscription;\n+\n+import io.netty.util.concurrent.EventExecutor;\n+\n+final class DefaultHttpResponseBodyStream implements HttpResponseBodyStream {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultHttpResponseBodyStream.class);\n+\n+    private static final AtomicReferenceFieldUpdater<BodySubscriber, Subscription> upstreamUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(BodySubscriber.class, Subscription.class, \"upstream\");\n+\n+    private static final AtomicReferenceFieldUpdater<BodySubscriber, Subscriber> downstreamUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(BodySubscriber.class, Subscriber.class, \"downstream\");\n+\n+    private static final ResponseHeaders HEADERS_WITH_UNKNOWN_STATUS = ResponseHeaders.of(HttpStatus.UNKNOWN);\n+    private static final HeadersFuture<List<ResponseHeaders>> EMPTY_INFORMATIONAL_HEADERS;\n+    private static final HeadersFuture<HttpHeaders> EMPTY_TRAILERS;\n+\n+    static {\n+        EMPTY_INFORMATIONAL_HEADERS = new HeadersFuture<>();\n+        EMPTY_INFORMATIONAL_HEADERS.doComplete(ImmutableList.of());\n+\n+        EMPTY_TRAILERS = new HeadersFuture<>();\n+        EMPTY_TRAILERS.doComplete(HttpHeaders.of());\n+    }\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<DefaultHttpResponseBodyStream, HeadersFuture>\n+            informationalHeadersFutureUpdater = AtomicReferenceFieldUpdater\n+            .newUpdater(DefaultHttpResponseBodyStream.class, HeadersFuture.class, \"informationalHeadersFuture\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<DefaultHttpResponseBodyStream, HeadersFuture>\n+            trailersFutureUpdater = AtomicReferenceFieldUpdater\n+            .newUpdater(DefaultHttpResponseBodyStream.class, HeadersFuture.class, \"trailersFuture\");\n+\n+    private final HeadersFuture<ResponseHeaders> headersFuture = new HeadersFuture<>();\n+    private final BodySubscriber bodySubscriber = new BodySubscriber();\n+    private final HttpResponse response;\n+    private final EventExecutor executor;\n+\n+    @Nullable\n+    private volatile HeadersFuture<List<ResponseHeaders>> informationalHeadersFuture;\n+    @Nullable\n+    private volatile HeadersFuture<HttpHeaders> trailersFuture;\n+    private volatile boolean wroteAny;\n+\n+    DefaultHttpResponseBodyStream(HttpResponse response, EventExecutor executor,\n+                                  SubscriptionOption... options) {\n+        requireNonNull(response, \"response\");\n+        this.response = response;\n+        this.executor = executor;\n+\n+        response.subscribe(bodySubscriber, executor, options);\n+        // Prefetch headers\n+        bodySubscriber.request(1);\n+    }\n+\n+    @Override\n+    public CompletableFuture<List<ResponseHeaders>> informationalHeaders() {\n+        final HeadersFuture<List<ResponseHeaders>> informationalHeadersFuture = this.informationalHeadersFuture;\n+        if (informationalHeadersFuture != null) {\n+            return informationalHeadersFuture;\n+        }\n+\n+        informationalHeadersFutureUpdater.compareAndSet(this, null, new HeadersFuture<>());\n+        return this.informationalHeadersFuture;\n+    }\n+\n+    @Override\n+    public CompletableFuture<ResponseHeaders> headers() {\n+        return headersFuture;\n+    }\n+\n+    @Override\n+    public CompletableFuture<HttpHeaders> trailers() {\n+        final HeadersFuture<HttpHeaders> trailersFuture = this.trailersFuture;\n+        if (trailersFuture != null) {\n+            return trailersFuture;\n+        }\n+\n+        trailersFutureUpdater.compareAndSet(this, null, new HeadersFuture<>());\n+        return this.trailersFuture;\n+    }\n+\n+    @Override\n+    public boolean isOpen() {\n+        return response.isOpen();\n+    }\n+\n+    @Override\n+    public boolean isEmpty() {\n+        return !isOpen() && !wroteAny;\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> whenComplete() {\n+        return response.whenComplete();\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super HttpData> subscriber, EventExecutor unused) {\n+        requireNonNull(subscriber, \"subscriber\");\n+        if (executor.inEventLoop()) {\n+            bodySubscriber.setDownStream(subscriber);\n+        } else {\n+            executor.execute(() -> bodySubscriber.setDownStream(subscriber));\n+        }\n+    }\n+\n+    @Override\n+    public void abort() {\n+        response.abort();\n+    }\n+\n+    @Override\n+    public void abort(Throwable cause) {\n+        response.abort(cause);\n+    }\n+\n+    private final class BodySubscriber implements Subscriber<HttpObject>, Subscription {\n+\n+        @Nullable\n+        private ImmutableList.Builder<ResponseHeaders> informationalHeadersBuilder;\n+        @Nullable\n+        private Throwable cause;\n+        private boolean completing;\n+\n+        private boolean sawLeadingHeaders;\n+\n+        @Nullable\n+        volatile Subscriber<? super HttpData> downstream;\n+        @Nullable\n+        volatile Subscription upstream;\n+        private volatile long pendingRequests;\n+        private volatile boolean cancelCalled;\n+\n+        private void setDownStream(Subscriber<? super HttpData> downstream) {\n+            try {\n+                if (!downstreamUpdater.compareAndSet(this, null, downstream)) {\n+                    downstream.onSubscribe(NoopSubscription.get());\n+                    downstream.onError(new IllegalStateException(\"subscribed by other subscriber already\"));\n+                    return;\n+                }\n+                downstream.onSubscribe(this);\n+                if (cause != null) {\n+                    downstream.onError(cause);\n+                } else if (completing) {\n+                    downstream.onComplete();\n+                }\n+            } catch (Throwable t) {\n+                throwIfFatal(t);\n+                logger.warn(\"Subscriber should not throw an exception. subscriber: {}\", downstream, t);\n+            }\n+        }\n+\n+        @Override\n+        public void onSubscribe(Subscription subscription) {\n+            requireNonNull(subscription, \"subscription\");\n+            if (!upstreamUpdater.compareAndSet(this, null, subscription) || cancelCalled) {", "originalCommit": "f5875796ff63163a414888d58b132b494bcf1555", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTU3MTU4MA==", "url": "https://github.com/line/armeria/pull/3038#discussion_r481571580", "bodyText": "I think there's a race with the request method.\nFor example:\n\nA thread is in the line between 215 and 216\nB thread calls subscription.request(pendingRequests);\nA thread does pendingRequests = LongMath.saturatedAdd(n, pendingRequests);", "author": "minwoox", "createdAt": "2020-09-02T02:37:43Z", "path": "core/src/main/java/com/linecorp/armeria/common/DefaultHttpResponseBodyStream.java", "diffHunk": "@@ -0,0 +1,352 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common;\n+\n+import static com.linecorp.armeria.common.util.Exceptions.throwIfFatal;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.math.LongMath;\n+\n+import com.linecorp.armeria.common.stream.NoopSubscriber;\n+import com.linecorp.armeria.common.stream.SubscriptionOption;\n+import com.linecorp.armeria.common.util.UnmodifiableFuture;\n+import com.linecorp.armeria.internal.common.stream.NoopSubscription;\n+\n+import io.netty.util.concurrent.EventExecutor;\n+\n+final class DefaultHttpResponseBodyStream implements HttpResponseBodyStream {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultHttpResponseBodyStream.class);\n+\n+    private static final AtomicReferenceFieldUpdater<BodySubscriber, Subscription> upstreamUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(BodySubscriber.class, Subscription.class, \"upstream\");\n+\n+    private static final AtomicReferenceFieldUpdater<BodySubscriber, Subscriber> downstreamUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(BodySubscriber.class, Subscriber.class, \"downstream\");\n+\n+    private static final ResponseHeaders HEADERS_WITH_UNKNOWN_STATUS = ResponseHeaders.of(HttpStatus.UNKNOWN);\n+    private static final HeadersFuture<List<ResponseHeaders>> EMPTY_INFORMATIONAL_HEADERS;\n+    private static final HeadersFuture<HttpHeaders> EMPTY_TRAILERS;\n+\n+    static {\n+        EMPTY_INFORMATIONAL_HEADERS = new HeadersFuture<>();\n+        EMPTY_INFORMATIONAL_HEADERS.doComplete(ImmutableList.of());\n+\n+        EMPTY_TRAILERS = new HeadersFuture<>();\n+        EMPTY_TRAILERS.doComplete(HttpHeaders.of());\n+    }\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<DefaultHttpResponseBodyStream, HeadersFuture>\n+            informationalHeadersFutureUpdater = AtomicReferenceFieldUpdater\n+            .newUpdater(DefaultHttpResponseBodyStream.class, HeadersFuture.class, \"informationalHeadersFuture\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<DefaultHttpResponseBodyStream, HeadersFuture>\n+            trailersFutureUpdater = AtomicReferenceFieldUpdater\n+            .newUpdater(DefaultHttpResponseBodyStream.class, HeadersFuture.class, \"trailersFuture\");\n+\n+    private final HeadersFuture<ResponseHeaders> headersFuture = new HeadersFuture<>();\n+    private final BodySubscriber bodySubscriber = new BodySubscriber();\n+    private final HttpResponse response;\n+    private final EventExecutor executor;\n+\n+    @Nullable\n+    private volatile HeadersFuture<List<ResponseHeaders>> informationalHeadersFuture;\n+    @Nullable\n+    private volatile HeadersFuture<HttpHeaders> trailersFuture;\n+    private volatile boolean wroteAny;\n+\n+    DefaultHttpResponseBodyStream(HttpResponse response, EventExecutor executor,\n+                                  SubscriptionOption... options) {\n+        requireNonNull(response, \"response\");\n+        this.response = response;\n+        this.executor = executor;\n+\n+        response.subscribe(bodySubscriber, executor, options);\n+        // Prefetch headers\n+        bodySubscriber.request(1);\n+    }\n+\n+    @Override\n+    public CompletableFuture<List<ResponseHeaders>> informationalHeaders() {\n+        final HeadersFuture<List<ResponseHeaders>> informationalHeadersFuture = this.informationalHeadersFuture;\n+        if (informationalHeadersFuture != null) {\n+            return informationalHeadersFuture;\n+        }\n+\n+        informationalHeadersFutureUpdater.compareAndSet(this, null, new HeadersFuture<>());\n+        return this.informationalHeadersFuture;\n+    }\n+\n+    @Override\n+    public CompletableFuture<ResponseHeaders> headers() {\n+        return headersFuture;\n+    }\n+\n+    @Override\n+    public CompletableFuture<HttpHeaders> trailers() {\n+        final HeadersFuture<HttpHeaders> trailersFuture = this.trailersFuture;\n+        if (trailersFuture != null) {\n+            return trailersFuture;\n+        }\n+\n+        trailersFutureUpdater.compareAndSet(this, null, new HeadersFuture<>());\n+        return this.trailersFuture;\n+    }\n+\n+    @Override\n+    public boolean isOpen() {\n+        return response.isOpen();\n+    }\n+\n+    @Override\n+    public boolean isEmpty() {\n+        return !isOpen() && !wroteAny;\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> whenComplete() {\n+        return response.whenComplete();\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super HttpData> subscriber, EventExecutor unused) {\n+        requireNonNull(subscriber, \"subscriber\");\n+        if (executor.inEventLoop()) {\n+            bodySubscriber.setDownStream(subscriber);\n+        } else {\n+            executor.execute(() -> bodySubscriber.setDownStream(subscriber));\n+        }\n+    }\n+\n+    @Override\n+    public void abort() {\n+        response.abort();\n+    }\n+\n+    @Override\n+    public void abort(Throwable cause) {\n+        response.abort(cause);\n+    }\n+\n+    private final class BodySubscriber implements Subscriber<HttpObject>, Subscription {\n+\n+        @Nullable\n+        private ImmutableList.Builder<ResponseHeaders> informationalHeadersBuilder;\n+        @Nullable\n+        private Throwable cause;\n+        private boolean completing;\n+\n+        private boolean sawLeadingHeaders;\n+\n+        @Nullable\n+        volatile Subscriber<? super HttpData> downstream;\n+        @Nullable\n+        volatile Subscription upstream;\n+        private volatile long pendingRequests;\n+        private volatile boolean cancelCalled;\n+\n+        private void setDownStream(Subscriber<? super HttpData> downstream) {\n+            try {\n+                if (!downstreamUpdater.compareAndSet(this, null, downstream)) {\n+                    downstream.onSubscribe(NoopSubscription.get());\n+                    downstream.onError(new IllegalStateException(\"subscribed by other subscriber already\"));\n+                    return;\n+                }\n+                downstream.onSubscribe(this);\n+                if (cause != null) {\n+                    downstream.onError(cause);\n+                } else if (completing) {\n+                    downstream.onComplete();\n+                }\n+            } catch (Throwable t) {\n+                throwIfFatal(t);\n+                logger.warn(\"Subscriber should not throw an exception. subscriber: {}\", downstream, t);\n+            }\n+        }\n+\n+        @Override\n+        public void onSubscribe(Subscription subscription) {\n+            requireNonNull(subscription, \"subscription\");\n+            if (!upstreamUpdater.compareAndSet(this, null, subscription) || cancelCalled) {\n+                subscription.cancel();\n+                return;\n+            }\n+            if (pendingRequests != 0) {", "originalCommit": "f5875796ff63163a414888d58b132b494bcf1555", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTU3MjE4Mw==", "url": "https://github.com/line/armeria/pull/3038#discussion_r481572183", "bodyText": "How about just using the single thread to avoid this problem?", "author": "minwoox", "createdAt": "2020-09-02T02:38:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTU3MTU4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTY1NTU3OA==", "url": "https://github.com/line/armeria/pull/3038#discussion_r481655578", "bodyText": "How about just using the single thread to avoid this problem?\n\nThat's sounds good. It is no additional threading because the upstream.request() already is executed subscription.executor().", "author": "ikhoon", "createdAt": "2020-09-02T04:20:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTU3MTU4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTU3MzE5OQ==", "url": "https://github.com/line/armeria/pull/3038#discussion_r481573199", "bodyText": "could assign downstream to a local variable so that we remove IntelliJ warning", "author": "minwoox", "createdAt": "2020-09-02T02:40:16Z", "path": "core/src/main/java/com/linecorp/armeria/common/DefaultHttpResponseBodyStream.java", "diffHunk": "@@ -0,0 +1,352 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common;\n+\n+import static com.linecorp.armeria.common.util.Exceptions.throwIfFatal;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.math.LongMath;\n+\n+import com.linecorp.armeria.common.stream.NoopSubscriber;\n+import com.linecorp.armeria.common.stream.SubscriptionOption;\n+import com.linecorp.armeria.common.util.UnmodifiableFuture;\n+import com.linecorp.armeria.internal.common.stream.NoopSubscription;\n+\n+import io.netty.util.concurrent.EventExecutor;\n+\n+final class DefaultHttpResponseBodyStream implements HttpResponseBodyStream {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultHttpResponseBodyStream.class);\n+\n+    private static final AtomicReferenceFieldUpdater<BodySubscriber, Subscription> upstreamUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(BodySubscriber.class, Subscription.class, \"upstream\");\n+\n+    private static final AtomicReferenceFieldUpdater<BodySubscriber, Subscriber> downstreamUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(BodySubscriber.class, Subscriber.class, \"downstream\");\n+\n+    private static final ResponseHeaders HEADERS_WITH_UNKNOWN_STATUS = ResponseHeaders.of(HttpStatus.UNKNOWN);\n+    private static final HeadersFuture<List<ResponseHeaders>> EMPTY_INFORMATIONAL_HEADERS;\n+    private static final HeadersFuture<HttpHeaders> EMPTY_TRAILERS;\n+\n+    static {\n+        EMPTY_INFORMATIONAL_HEADERS = new HeadersFuture<>();\n+        EMPTY_INFORMATIONAL_HEADERS.doComplete(ImmutableList.of());\n+\n+        EMPTY_TRAILERS = new HeadersFuture<>();\n+        EMPTY_TRAILERS.doComplete(HttpHeaders.of());\n+    }\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<DefaultHttpResponseBodyStream, HeadersFuture>\n+            informationalHeadersFutureUpdater = AtomicReferenceFieldUpdater\n+            .newUpdater(DefaultHttpResponseBodyStream.class, HeadersFuture.class, \"informationalHeadersFuture\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<DefaultHttpResponseBodyStream, HeadersFuture>\n+            trailersFutureUpdater = AtomicReferenceFieldUpdater\n+            .newUpdater(DefaultHttpResponseBodyStream.class, HeadersFuture.class, \"trailersFuture\");\n+\n+    private final HeadersFuture<ResponseHeaders> headersFuture = new HeadersFuture<>();\n+    private final BodySubscriber bodySubscriber = new BodySubscriber();\n+    private final HttpResponse response;\n+    private final EventExecutor executor;\n+\n+    @Nullable\n+    private volatile HeadersFuture<List<ResponseHeaders>> informationalHeadersFuture;\n+    @Nullable\n+    private volatile HeadersFuture<HttpHeaders> trailersFuture;\n+    private volatile boolean wroteAny;\n+\n+    DefaultHttpResponseBodyStream(HttpResponse response, EventExecutor executor,\n+                                  SubscriptionOption... options) {\n+        requireNonNull(response, \"response\");\n+        this.response = response;\n+        this.executor = executor;\n+\n+        response.subscribe(bodySubscriber, executor, options);\n+        // Prefetch headers\n+        bodySubscriber.request(1);\n+    }\n+\n+    @Override\n+    public CompletableFuture<List<ResponseHeaders>> informationalHeaders() {\n+        final HeadersFuture<List<ResponseHeaders>> informationalHeadersFuture = this.informationalHeadersFuture;\n+        if (informationalHeadersFuture != null) {\n+            return informationalHeadersFuture;\n+        }\n+\n+        informationalHeadersFutureUpdater.compareAndSet(this, null, new HeadersFuture<>());\n+        return this.informationalHeadersFuture;\n+    }\n+\n+    @Override\n+    public CompletableFuture<ResponseHeaders> headers() {\n+        return headersFuture;\n+    }\n+\n+    @Override\n+    public CompletableFuture<HttpHeaders> trailers() {\n+        final HeadersFuture<HttpHeaders> trailersFuture = this.trailersFuture;\n+        if (trailersFuture != null) {\n+            return trailersFuture;\n+        }\n+\n+        trailersFutureUpdater.compareAndSet(this, null, new HeadersFuture<>());\n+        return this.trailersFuture;\n+    }\n+\n+    @Override\n+    public boolean isOpen() {\n+        return response.isOpen();\n+    }\n+\n+    @Override\n+    public boolean isEmpty() {\n+        return !isOpen() && !wroteAny;\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> whenComplete() {\n+        return response.whenComplete();\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super HttpData> subscriber, EventExecutor unused) {\n+        requireNonNull(subscriber, \"subscriber\");\n+        if (executor.inEventLoop()) {\n+            bodySubscriber.setDownStream(subscriber);\n+        } else {\n+            executor.execute(() -> bodySubscriber.setDownStream(subscriber));\n+        }\n+    }\n+\n+    @Override\n+    public void abort() {\n+        response.abort();\n+    }\n+\n+    @Override\n+    public void abort(Throwable cause) {\n+        response.abort(cause);\n+    }\n+\n+    private final class BodySubscriber implements Subscriber<HttpObject>, Subscription {\n+\n+        @Nullable\n+        private ImmutableList.Builder<ResponseHeaders> informationalHeadersBuilder;\n+        @Nullable\n+        private Throwable cause;\n+        private boolean completing;\n+\n+        private boolean sawLeadingHeaders;\n+\n+        @Nullable\n+        volatile Subscriber<? super HttpData> downstream;\n+        @Nullable\n+        volatile Subscription upstream;\n+        private volatile long pendingRequests;\n+        private volatile boolean cancelCalled;\n+\n+        private void setDownStream(Subscriber<? super HttpData> downstream) {\n+            try {\n+                if (!downstreamUpdater.compareAndSet(this, null, downstream)) {\n+                    downstream.onSubscribe(NoopSubscription.get());\n+                    downstream.onError(new IllegalStateException(\"subscribed by other subscriber already\"));\n+                    return;\n+                }\n+                downstream.onSubscribe(this);\n+                if (cause != null) {\n+                    downstream.onError(cause);\n+                } else if (completing) {\n+                    downstream.onComplete();\n+                }\n+            } catch (Throwable t) {\n+                throwIfFatal(t);\n+                logger.warn(\"Subscriber should not throw an exception. subscriber: {}\", downstream, t);\n+            }\n+        }\n+\n+        @Override\n+        public void onSubscribe(Subscription subscription) {\n+            requireNonNull(subscription, \"subscription\");\n+            if (!upstreamUpdater.compareAndSet(this, null, subscription) || cancelCalled) {\n+                subscription.cancel();\n+                return;\n+            }\n+            if (pendingRequests != 0) {\n+                subscription.request(pendingRequests);\n+            }\n+        }\n+\n+        @Override\n+        public void request(long n) {\n+            if (n <= 0) {\n+                // Just abort the publisher so subscriber().onError(e) is called and resources are cleaned up.\n+                response.abort(new IllegalArgumentException(\n+                        \"n: \" + n + \" (expected: > 0, see Reactive Streams specification rule 3.9)\"));\n+                return;\n+            }\n+            final Subscription upstream = this.upstream;\n+            if (upstream == null) {\n+                pendingRequests = LongMath.saturatedAdd(n, pendingRequests);\n+            } else {\n+                upstream.request(n);\n+            }\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            if (cancelCalled) {\n+                return;\n+            }\n+            cancelCalled = true;\n+            downstream = NoopSubscriber.get();\n+            maybeCompleteHeaders();\n+            if (upstream != null) {\n+                upstream.cancel();\n+            }\n+        }\n+\n+        @Override\n+        public void onNext(HttpObject httpObject) {\n+            final Subscription upstream = this.upstream;\n+            if (httpObject instanceof ResponseHeaders) {\n+                final ResponseHeaders headers = (ResponseHeaders) httpObject;\n+                final HttpStatus status = headers.status();\n+                if (status.isInformational()) {\n+                    if (!sawLeadingHeaders) {\n+                        if (informationalHeadersBuilder == null) {\n+                            informationalHeadersBuilder = ImmutableList.builder();\n+                        }\n+                        informationalHeadersBuilder.add(headers);\n+                    }\n+                    upstream.request(1);\n+                } else {\n+                    sawLeadingHeaders = true;\n+                    completeInformationHeaders();\n+                    completeHeaders(headers);\n+                }\n+                return;\n+            }\n+\n+            if (httpObject instanceof HttpHeaders) {\n+                final HttpHeaders trailers = (HttpHeaders) httpObject;\n+                completeTrailers(trailers);\n+                return;\n+            }\n+\n+            assert downstream != null;", "originalCommit": "f5875796ff63163a414888d58b132b494bcf1555", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1701763f874be6949c4b8f78b289206e316b6f0e", "url": "https://github.com/line/armeria/commit/1701763f874be6949c4b8f78b289206e316b6f0e", "message": "Address comments by @minwoox", "committedDate": "2020-09-02T04:38:01Z", "type": "commit"}, {"oid": "7b997183b9cdf9b878a0c247c02ab2f3720b074d", "url": "https://github.com/line/armeria/commit/7b997183b9cdf9b878a0c247c02ab2f3720b074d", "message": "Migrate ArmeriaHttpClientResponseSubscriber to ArmeriaHttpResponseBodyStream", "committedDate": "2020-09-02T09:25:32Z", "type": "commit"}, {"oid": "7b997183b9cdf9b878a0c247c02ab2f3720b074d", "url": "https://github.com/line/armeria/commit/7b997183b9cdf9b878a0c247c02ab2f3720b074d", "message": "Migrate ArmeriaHttpClientResponseSubscriber to ArmeriaHttpResponseBodyStream", "committedDate": "2020-09-02T09:25:32Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDIwNDEyOA==", "url": "https://github.com/line/armeria/pull/3038#discussion_r484204128", "bodyText": "which completes -> that is completed with  (ditto for all Javadoc comments in this pull request)", "author": "trustin", "createdAt": "2020-09-07T06:18:44Z", "path": "core/src/main/java/com/linecorp/armeria/common/HttpResponseBodyStream.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+import org.reactivestreams.Subscriber;\n+\n+import com.linecorp.armeria.common.stream.StreamMessage;\n+import com.linecorp.armeria.common.stream.SubscriptionOption;\n+\n+import io.netty.util.concurrent.EventExecutor;\n+\n+/**\n+ * An HTTP response body stream which publishes HTTP payloads as a stream of {@link HttpData}.\n+ * {@link #informationalHeaders()}, {@link #headers()} will be completed before publishing the first element of\n+ * {@link HttpData}. {@link #trailers()} might not complete until the entire {@link HttpData} has been consumed.\n+ */\n+public interface HttpResponseBodyStream extends StreamMessage<HttpData> {\n+    /**\n+     * Returns a {@link CompletableFuture} which completes a list of\n+     * <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#Information_responses\">informational\n+     * </a> {@link ResponseHeaders}.\n+     */\n+    CompletableFuture<List<ResponseHeaders>> informationalHeaders();\n+\n+    /**\n+     * Returns a {@link CompletableFuture} which completes a non-informational {@link ResponseHeaders}.\n+     */\n+    CompletableFuture<ResponseHeaders> headers();\n+\n+    /**\n+     * Returns a {@link CompletableFuture} which completes a {@linkplain HttpHeaders trailers}.", "originalCommit": "7b997183b9cdf9b878a0c247c02ab2f3720b074d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDIwNzQ0NQ==", "url": "https://github.com/line/armeria/pull/3038#discussion_r484207445", "bodyText": "'that is' could be omitted.", "author": "trustin", "createdAt": "2020-09-07T06:27:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDIwNDEyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDIwNTQ3OA==", "url": "https://github.com/line/armeria/pull/3038#discussion_r484205478", "bodyText": "If this is the case, how about making toBodyStream return a tuple of (CompletableFuture<informational headers>, CompletableFuture<headers>, StreamMessage, CompletableFuture<trailers>), for reduced ambiguity? (We'll have to rename toBodyStream() and HttpResponseBodyStream into something else, though.)", "author": "trustin", "createdAt": "2020-09-07T06:22:33Z", "path": "core/src/main/java/com/linecorp/armeria/common/HttpResponseBodyStream.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+import org.reactivestreams.Subscriber;\n+\n+import com.linecorp.armeria.common.stream.StreamMessage;\n+import com.linecorp.armeria.common.stream.SubscriptionOption;\n+\n+import io.netty.util.concurrent.EventExecutor;\n+\n+/**\n+ * An HTTP response body stream which publishes HTTP payloads as a stream of {@link HttpData}.\n+ * {@link #informationalHeaders()}, {@link #headers()} will be completed before publishing the first element of\n+ * {@link HttpData}. {@link #trailers()} might not complete until the entire {@link HttpData} has been consumed.\n+ */\n+public interface HttpResponseBodyStream extends StreamMessage<HttpData> {\n+    /**\n+     * Returns a {@link CompletableFuture} which completes a list of\n+     * <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#Information_responses\">informational\n+     * </a> {@link ResponseHeaders}.\n+     */\n+    CompletableFuture<List<ResponseHeaders>> informationalHeaders();\n+\n+    /**\n+     * Returns a {@link CompletableFuture} which completes a non-informational {@link ResponseHeaders}.\n+     */\n+    CompletableFuture<ResponseHeaders> headers();\n+\n+    /**\n+     * Returns a {@link CompletableFuture} which completes a {@linkplain HttpHeaders trailers}.\n+     * If a {@link HttpResponse} does not contain trailers, the returned {@link CompletableFuture} will complete\n+     * an {@linkplain HttpHeaders#of() empty headers}.\n+     */\n+    CompletableFuture<HttpHeaders> trailers();\n+\n+    /**\n+     * Unsupported operation, use {@link HttpResponse#toBodyStream(EventExecutor, SubscriptionOption...)}\n+     * instead.\n+     */\n+    @Override\n+    default void subscribe(Subscriber<? super HttpData> subscriber, EventExecutor executor,\n+                           SubscriptionOption... options) {\n+        throw new UnsupportedOperationException(\"Use 'HttpResponse.toBodyStream(executor, options)' instead\");", "originalCommit": "7b997183b9cdf9b878a0c247c02ab2f3720b074d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f10eb5060b5e0594bc9e29029bdc50802dd37587", "url": "https://github.com/line/armeria/commit/f10eb5060b5e0594bc9e29029bdc50802dd37587", "message": "Merge branch 'master' into body-stream", "committedDate": "2020-09-09T08:14:39Z", "type": "commit"}, {"oid": "b32036ba629320db66f2109ec3a38ce32c1a7615", "url": "https://github.com/line/armeria/commit/b32036ba629320db66f2109ec3a38ce32c1a7615", "message": "Address comments by @trustin / Need more ideas for method and class name", "committedDate": "2020-09-09T14:49:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk5NzYwNQ==", "url": "https://github.com/line/armeria/pull/3038#discussion_r485997605", "bodyText": "nit: an HttpResponse", "author": "minwoox", "createdAt": "2020-09-10T00:44:35Z", "path": "core/src/main/java/com/linecorp/armeria/common/SplitHttpResponse.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+import com.google.errorprone.annotations.CheckReturnValue;\n+\n+import com.linecorp.armeria.common.stream.StreamMessage;\n+\n+/**\n+ * An {@link HttpResponse} which splits a stream of {@link HttpObject} into HTTP headers and payloads.\n+ * {@link #informationalHeaders()}, {@link #headers()} will be completed before publishing the first element of\n+ * {@link HttpData}. {@link #trailers()} might not complete until the entire {@link HttpData} has been consumed.\n+ */\n+public interface SplitHttpResponse {\n+\n+    /**\n+     * Returns a {@link CompletableFuture} completed with a list of\n+     * <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#Information_responses\">informational\n+     * </a> {@link ResponseHeaders}.\n+     */\n+    CompletableFuture<List<ResponseHeaders>> informationalHeaders();\n+\n+    /**\n+     * Returns a {@link CompletableFuture} completed with a non-informational {@link ResponseHeaders}.\n+     */\n+    CompletableFuture<ResponseHeaders> headers();\n+\n+    /**\n+     * Returns a {@link StreamMessage} publishes HTTP payloads as a stream of {@link HttpData}.\n+     */\n+    @CheckReturnValue\n+    StreamMessage<HttpData> body();\n+\n+    /**\n+     * Returns a {@link CompletableFuture} completed with a {@linkplain HttpHeaders trailers}.\n+     * If a {@link HttpResponse} does not contain trailers, the returned {@link CompletableFuture} will be", "originalCommit": "b32036ba629320db66f2109ec3a38ce32c1a7615", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjAwMDE4MQ==", "url": "https://github.com/line/armeria/pull/3038#discussion_r486000181", "bodyText": "If so, how about rasing an exception?", "author": "minwoox", "createdAt": "2020-09-10T00:54:20Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common;\n+\n+import static com.linecorp.armeria.common.util.Exceptions.throwIfFatal;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.math.LongMath;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.HttpObject;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.SplitHttpResponse;\n+import com.linecorp.armeria.common.stream.AbortedStreamException;\n+import com.linecorp.armeria.common.stream.CancelledSubscriptionException;\n+import com.linecorp.armeria.common.stream.NoopSubscriber;\n+import com.linecorp.armeria.common.stream.StreamMessage;\n+import com.linecorp.armeria.common.stream.SubscriptionOption;\n+import com.linecorp.armeria.common.util.UnmodifiableFuture;\n+import com.linecorp.armeria.internal.common.stream.NoopSubscription;\n+\n+import io.netty.util.concurrent.EventExecutor;\n+\n+public class DefaultSplitHttpResponse implements StreamMessage<HttpData>, SplitHttpResponse {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultSplitHttpResponse.class);\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<BodySubscriber, Subscriber> downstreamUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(BodySubscriber.class, Subscriber.class, \"downstream\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<DefaultSplitHttpResponse, HeadersFuture>\n+            informationalHeadersFutureUpdater = AtomicReferenceFieldUpdater\n+            .newUpdater(DefaultSplitHttpResponse.class, HeadersFuture.class, \"informationalHeadersFuture\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<DefaultSplitHttpResponse, HeadersFuture>\n+            trailersFutureUpdater = AtomicReferenceFieldUpdater\n+            .newUpdater(DefaultSplitHttpResponse.class, HeadersFuture.class, \"trailersFuture\");\n+\n+    private static final ResponseHeaders HEADERS_WITH_UNKNOWN_STATUS = ResponseHeaders.of(HttpStatus.UNKNOWN);\n+    private static final HeadersFuture<List<ResponseHeaders>> EMPTY_INFORMATIONAL_HEADERS;\n+    private static final HeadersFuture<HttpHeaders> EMPTY_TRAILERS;\n+\n+    static {\n+        EMPTY_INFORMATIONAL_HEADERS = new HeadersFuture<>();\n+        EMPTY_INFORMATIONAL_HEADERS.doComplete(ImmutableList.of());\n+\n+        EMPTY_TRAILERS = new HeadersFuture<>();\n+        EMPTY_TRAILERS.doComplete(HttpHeaders.of());\n+    }\n+\n+    private final HeadersFuture<ResponseHeaders> headersFuture = new HeadersFuture<>();\n+    private final BodySubscriber bodySubscriber = new BodySubscriber();\n+    private final HttpResponse response;\n+    private final EventExecutor executor;\n+\n+    @Nullable\n+    private volatile HeadersFuture<List<ResponseHeaders>> informationalHeadersFuture;\n+    @Nullable\n+    private volatile HeadersFuture<HttpHeaders> trailersFuture;\n+    private volatile boolean wroteAny;\n+\n+    public DefaultSplitHttpResponse(HttpResponse response, EventExecutor executor,\n+                                    SubscriptionOption... options) {\n+        this.response = requireNonNull(response, \"response\");\n+        this.executor = requireNonNull(executor, \"executor\");\n+\n+        response.subscribe(bodySubscriber, executor, options);\n+    }\n+\n+    @Override\n+    public final CompletableFuture<List<ResponseHeaders>> informationalHeaders() {\n+        final HeadersFuture<List<ResponseHeaders>> informationalHeadersFuture = this.informationalHeadersFuture;\n+        if (informationalHeadersFuture != null) {\n+            return informationalHeadersFuture;\n+        }\n+\n+        informationalHeadersFutureUpdater.compareAndSet(this, null, new HeadersFuture<>());\n+        return this.informationalHeadersFuture;\n+    }\n+\n+    @Override\n+    public final CompletableFuture<ResponseHeaders> headers() {\n+        return headersFuture;\n+    }\n+\n+    @Override\n+    public final StreamMessage<HttpData> body() {\n+        return this;\n+    }\n+\n+    @Override\n+    public final CompletableFuture<HttpHeaders> trailers() {\n+        final HeadersFuture<HttpHeaders> trailersFuture = this.trailersFuture;\n+        if (trailersFuture != null) {\n+            return trailersFuture;\n+        }\n+\n+        trailersFutureUpdater.compareAndSet(this, null, new HeadersFuture<>());\n+        return this.trailersFuture;\n+    }\n+\n+    @Override\n+    public boolean isOpen() {\n+        return response.isOpen();\n+    }\n+\n+    @Override\n+    public boolean isEmpty() {\n+        return !isOpen() && !wroteAny;\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> whenComplete() {\n+        return response.whenComplete();\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super HttpData> subscriber, EventExecutor unused) {\n+        requireNonNull(subscriber, \"subscriber\");\n+        if (executor.inEventLoop()) {\n+            bodySubscriber.setDownStream(subscriber);\n+        } else {\n+            executor.execute(() -> bodySubscriber.setDownStream(subscriber));\n+        }\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super HttpData> subscriber, EventExecutor executor,\n+                          SubscriptionOption... unused) {\n+        // 'SubscriptionOption's are ignored, should specify the 'SubscriptionOption's when creating this class.", "originalCommit": "b32036ba629320db66f2109ec3a38ce32c1a7615", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjAwNTcxNA==", "url": "https://github.com/line/armeria/pull/3038#discussion_r486005714", "bodyText": "How about creating HeadersFuture first and complete it if this CAS succeeds?", "author": "minwoox", "createdAt": "2020-09-10T01:15:18Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common;\n+\n+import static com.linecorp.armeria.common.util.Exceptions.throwIfFatal;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.math.LongMath;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.HttpObject;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.SplitHttpResponse;\n+import com.linecorp.armeria.common.stream.AbortedStreamException;\n+import com.linecorp.armeria.common.stream.CancelledSubscriptionException;\n+import com.linecorp.armeria.common.stream.NoopSubscriber;\n+import com.linecorp.armeria.common.stream.StreamMessage;\n+import com.linecorp.armeria.common.stream.SubscriptionOption;\n+import com.linecorp.armeria.common.util.UnmodifiableFuture;\n+import com.linecorp.armeria.internal.common.stream.NoopSubscription;\n+\n+import io.netty.util.concurrent.EventExecutor;\n+\n+public class DefaultSplitHttpResponse implements StreamMessage<HttpData>, SplitHttpResponse {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultSplitHttpResponse.class);\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<BodySubscriber, Subscriber> downstreamUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(BodySubscriber.class, Subscriber.class, \"downstream\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<DefaultSplitHttpResponse, HeadersFuture>\n+            informationalHeadersFutureUpdater = AtomicReferenceFieldUpdater\n+            .newUpdater(DefaultSplitHttpResponse.class, HeadersFuture.class, \"informationalHeadersFuture\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<DefaultSplitHttpResponse, HeadersFuture>\n+            trailersFutureUpdater = AtomicReferenceFieldUpdater\n+            .newUpdater(DefaultSplitHttpResponse.class, HeadersFuture.class, \"trailersFuture\");\n+\n+    private static final ResponseHeaders HEADERS_WITH_UNKNOWN_STATUS = ResponseHeaders.of(HttpStatus.UNKNOWN);\n+    private static final HeadersFuture<List<ResponseHeaders>> EMPTY_INFORMATIONAL_HEADERS;\n+    private static final HeadersFuture<HttpHeaders> EMPTY_TRAILERS;\n+\n+    static {\n+        EMPTY_INFORMATIONAL_HEADERS = new HeadersFuture<>();\n+        EMPTY_INFORMATIONAL_HEADERS.doComplete(ImmutableList.of());\n+\n+        EMPTY_TRAILERS = new HeadersFuture<>();\n+        EMPTY_TRAILERS.doComplete(HttpHeaders.of());\n+    }\n+\n+    private final HeadersFuture<ResponseHeaders> headersFuture = new HeadersFuture<>();\n+    private final BodySubscriber bodySubscriber = new BodySubscriber();\n+    private final HttpResponse response;\n+    private final EventExecutor executor;\n+\n+    @Nullable\n+    private volatile HeadersFuture<List<ResponseHeaders>> informationalHeadersFuture;\n+    @Nullable\n+    private volatile HeadersFuture<HttpHeaders> trailersFuture;\n+    private volatile boolean wroteAny;\n+\n+    public DefaultSplitHttpResponse(HttpResponse response, EventExecutor executor,\n+                                    SubscriptionOption... options) {\n+        this.response = requireNonNull(response, \"response\");\n+        this.executor = requireNonNull(executor, \"executor\");\n+\n+        response.subscribe(bodySubscriber, executor, options);\n+    }\n+\n+    @Override\n+    public final CompletableFuture<List<ResponseHeaders>> informationalHeaders() {\n+        final HeadersFuture<List<ResponseHeaders>> informationalHeadersFuture = this.informationalHeadersFuture;\n+        if (informationalHeadersFuture != null) {\n+            return informationalHeadersFuture;\n+        }\n+\n+        informationalHeadersFutureUpdater.compareAndSet(this, null, new HeadersFuture<>());\n+        return this.informationalHeadersFuture;\n+    }\n+\n+    @Override\n+    public final CompletableFuture<ResponseHeaders> headers() {\n+        return headersFuture;\n+    }\n+\n+    @Override\n+    public final StreamMessage<HttpData> body() {\n+        return this;\n+    }\n+\n+    @Override\n+    public final CompletableFuture<HttpHeaders> trailers() {\n+        final HeadersFuture<HttpHeaders> trailersFuture = this.trailersFuture;\n+        if (trailersFuture != null) {\n+            return trailersFuture;\n+        }\n+\n+        trailersFutureUpdater.compareAndSet(this, null, new HeadersFuture<>());\n+        return this.trailersFuture;\n+    }\n+\n+    @Override\n+    public boolean isOpen() {\n+        return response.isOpen();\n+    }\n+\n+    @Override\n+    public boolean isEmpty() {\n+        return !isOpen() && !wroteAny;\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> whenComplete() {\n+        return response.whenComplete();\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super HttpData> subscriber, EventExecutor unused) {\n+        requireNonNull(subscriber, \"subscriber\");\n+        if (executor.inEventLoop()) {\n+            bodySubscriber.setDownStream(subscriber);\n+        } else {\n+            executor.execute(() -> bodySubscriber.setDownStream(subscriber));\n+        }\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super HttpData> subscriber, EventExecutor executor,\n+                          SubscriptionOption... unused) {\n+        // 'SubscriptionOption's are ignored, should specify the 'SubscriptionOption's when creating this class.\n+        subscribe(subscriber, executor);\n+    }\n+\n+    @Override\n+    public void abort() {\n+        response.abort();\n+    }\n+\n+    @Override\n+    public void abort(Throwable cause) {\n+        response.abort(cause);\n+    }\n+\n+    private final class BodySubscriber implements Subscriber<HttpObject>, Subscription {\n+\n+        @Nullable\n+        private ImmutableList.Builder<ResponseHeaders> informationalHeadersBuilder;\n+        @Nullable\n+        private Throwable cause;\n+\n+        private boolean completing;\n+        private boolean sawLeadingHeaders;\n+\n+        // 1 is used for prefetching headers\n+        private long pendingRequests = 1;\n+\n+        @Nullable\n+        volatile Subscriber<? super HttpData> downstream;\n+        @Nullable\n+        private volatile Subscription upstream;\n+\n+        private volatile boolean cancelCalled;\n+\n+        private void setDownStream(Subscriber<? super HttpData> downstream) {\n+            try {\n+                if (!downstreamUpdater.compareAndSet(this, null, downstream)) {\n+                    downstream.onSubscribe(NoopSubscription.get());\n+                    downstream.onError(new IllegalStateException(\"subscribed by other subscriber already\"));\n+                    return;\n+                }\n+                downstream.onSubscribe(this);\n+                if (cause != null) {\n+                    downstream.onError(cause);\n+                } else if (completing) {\n+                    downstream.onComplete();\n+                }\n+            } catch (Throwable t) {\n+                throwIfFatal(t);\n+                logger.warn(\"Subscriber should not throw an exception. subscriber: {}\", downstream, t);\n+            }\n+        }\n+\n+        @Override\n+        public void onSubscribe(Subscription subscription) {\n+            requireNonNull(subscription, \"subscription\");\n+            if (cancelCalled || upstream != null) {\n+                subscription.cancel();\n+                return;\n+            }\n+            upstream = subscription;\n+            subscription.request(pendingRequests);\n+        }\n+\n+        @Override\n+        public void request(long n) {\n+            if (n <= 0) {\n+                // Just abort the publisher so subscriber().onError(e) is called and resources are cleaned up.\n+                response.abort(new IllegalArgumentException(\n+                        \"n: \" + n + \" (expected: > 0, see Reactive Streams specification rule 3.9)\"));\n+                return;\n+            }\n+            if (executor.inEventLoop()) {\n+                request0(n);\n+            } else {\n+                executor.execute(() -> request0(n));\n+            }\n+        }\n+\n+        private void request0(long n) {\n+            final Subscription upstream = this.upstream;\n+            if (upstream == null) {\n+                pendingRequests = LongMath.saturatedAdd(n, pendingRequests);\n+            } else {\n+                upstream.request(n);\n+            }\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            if (cancelCalled) {\n+                return;\n+            }\n+            cancelCalled = true;\n+            downstream = NoopSubscriber.get();\n+            maybeCompleteHeaders(null);\n+            final Subscription upstream = this.upstream;\n+            if (upstream != null) {\n+                upstream.cancel();\n+            }\n+        }\n+\n+        @Override\n+        public void onNext(HttpObject httpObject) {\n+            final Subscription upstream = this.upstream;\n+            if (httpObject instanceof ResponseHeaders) {\n+                final ResponseHeaders headers = (ResponseHeaders) httpObject;\n+                final HttpStatus status = headers.status();\n+                if (status.isInformational()) {\n+                    if (!sawLeadingHeaders) {\n+                        if (informationalHeadersBuilder == null) {\n+                            informationalHeadersBuilder = ImmutableList.builder();\n+                        }\n+                        informationalHeadersBuilder.add(headers);\n+                    }\n+                    upstream.request(1);\n+                } else {\n+                    sawLeadingHeaders = true;\n+                    completeInformationHeaders();\n+                    headersFuture.doComplete(headers);\n+                }\n+                return;\n+            }\n+\n+            if (httpObject instanceof HttpHeaders) {\n+                final HttpHeaders trailers = (HttpHeaders) httpObject;\n+                completeTrailers(trailers);\n+                return;\n+            }\n+\n+            final Subscriber<? super HttpData> downstream = this.downstream;\n+            assert downstream != null;\n+            assert httpObject instanceof HttpData;\n+            final HttpData data = (HttpData) httpObject;\n+            wroteAny = true;\n+            downstream.onNext(data);\n+        }\n+\n+        /**\n+         * Completes informational headers received so far.\n+         */\n+        private void completeInformationHeaders() {\n+            if (informationalHeadersBuilder == null) {\n+                if (!informationalHeadersFutureUpdater\n+                        .compareAndSet(DefaultSplitHttpResponse.this, null,\n+                                       EMPTY_INFORMATIONAL_HEADERS)) {\n+                    informationalHeadersFuture.doComplete(ImmutableList.of());\n+                }\n+            } else {\n+                informationalHeadersFutureUpdater", "originalCommit": "b32036ba629320db66f2109ec3a38ce32c1a7615", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjAwNjExNw==", "url": "https://github.com/line/armeria/pull/3038#discussion_r486006117", "bodyText": "\ud83e\udd23", "author": "minwoox", "createdAt": "2020-09-10T01:16:59Z", "path": "spring/boot2-webflux-autoconfigure/src/main/java/com/linecorp/armeria/spring/web/reactive/ArmeriaHttpResponseBodyStream.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Copyright 2018 LINE Corporation", "originalCommit": "b32036ba629320db66f2109ec3a38ce32c1a7615", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjAwNzA2Ng==", "url": "https://github.com/line/armeria/pull/3038#discussion_r486007066", "bodyText": "We used CAS above but not here. I think we should use the same approach.", "author": "minwoox", "createdAt": "2020-09-10T01:20:27Z", "path": "spring/boot2-webflux-autoconfigure/src/main/java/com/linecorp/armeria/spring/web/reactive/ArmeriaHttpResponseBodyStream.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Copyright 2018 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.spring.web.reactive;\n+\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.internal.common.DefaultSplitHttpResponse;\n+\n+import io.netty.util.concurrent.EventExecutor;\n+import reactor.core.publisher.Mono;\n+\n+final class ArmeriaHttpResponseBodyStream extends DefaultSplitHttpResponse {\n+\n+    private static final AtomicIntegerFieldUpdater<ArmeriaHttpResponseBodyStream> subscribedUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(ArmeriaHttpResponseBodyStream.class, \"subscribed\");\n+\n+    private volatile int subscribed;\n+\n+    @Nullable\n+    private Publisher<HttpData> publisherForLateSubscribers;\n+\n+    ArmeriaHttpResponseBodyStream(HttpResponse httpResponse, EventExecutor executor) {\n+        super(httpResponse, executor);\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super HttpData> s) {\n+        if (subscribedUpdater.compareAndSet(this, 0, 1)) {\n+            // The first subscriber.\n+            super.subscribe(s);\n+        } else {\n+            // The other subscribers - notify whether completed successfully only.\n+            if (publisherForLateSubscribers == null) {\n+                @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+                final Publisher<HttpData> newPublisher =\n+                        (Publisher) Mono.fromFuture(whenComplete());\n+                publisherForLateSubscribers = newPublisher;", "originalCommit": "b32036ba629320db66f2109ec3a38ce32c1a7615", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjAwOTEzMw==", "url": "https://github.com/line/armeria/pull/3038#discussion_r486009133", "bodyText": "Can we use the eventLoop that is used for sending a request?\nIf not, how about just using response.defaultSubscriberExecutor() in DefaultSplitHttpResponse?", "author": "minwoox", "createdAt": "2020-09-10T01:28:13Z", "path": "spring/boot2-webflux-autoconfigure/src/main/java/com/linecorp/armeria/spring/web/reactive/ArmeriaClientHttpConnector.java", "diffHunk": "@@ -110,8 +109,10 @@ private ArmeriaClientHttpRequest createRequest(HttpMethod method, URI uri) {\n         return new ArmeriaClientHttpRequest(builder.build(), method, pathAndQuery, uri, factoryWrapper);\n     }\n \n-    private ArmeriaClientHttpResponse createResponse(ResponseHeaders headers,\n-                                                     ArmeriaHttpClientResponseSubscriber s) {\n-        return new ArmeriaClientHttpResponse(headers, s.toResponseBodyPublisher(), factoryWrapper);\n+    private CompletableFuture<ArmeriaClientHttpResponse> createResponse(HttpResponse response) {\n+        final ArmeriaHttpResponseBodyStream bodyStream =\n+                new ArmeriaHttpResponseBodyStream(response, CommonPools.workerGroup().next());", "originalCommit": "b32036ba629320db66f2109ec3a38ce32c1a7615", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDEyMzkwMA==", "url": "https://github.com/line/armeria/pull/3038#discussion_r494123900", "bodyText": "It is difficult to capture or pass RequestContext at this point. Let me use response.defaultSubscriberExecutor() :-)", "author": "ikhoon", "createdAt": "2020-09-24T08:14:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjAwOTEzMw=="}], "type": "inlineReview"}, {"oid": "030b0643f9005ca07c7e022a1f656f7c15b684fc", "url": "https://github.com/line/armeria/commit/030b0643f9005ca07c7e022a1f656f7c15b684fc", "message": "Address comments by @minwoox", "committedDate": "2020-09-10T06:57:06Z", "type": "commit"}, {"oid": "a00b2634f69360ae338dcea56812ff52da6fef54", "url": "https://github.com/line/armeria/commit/a00b2634f69360ae338dcea56812ff52da6fef54", "message": "Merge branch 'master' into body-stream", "committedDate": "2020-09-24T08:12:20Z", "type": "commit"}, {"oid": "541878edafb7051422354f928f86484b9af83211", "url": "https://github.com/line/armeria/commit/541878edafb7051422354f928f86484b9af83211", "message": "Address comments by @minwoox", "committedDate": "2020-09-24T08:15:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU4NTcxNA==", "url": "https://github.com/line/armeria/pull/3038#discussion_r515585714", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * An {@link HttpResponse} which splits a stream of {@link HttpObject} into HTTP headers and payloads.\n          \n          \n            \n             * An {@link HttpResponse} which splits a stream of {@link HttpObject}s into HTTP headers and payloads.", "author": "trustin", "createdAt": "2020-11-01T07:12:59Z", "path": "core/src/main/java/com/linecorp/armeria/common/SplitHttpResponse.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+import com.google.errorprone.annotations.CheckReturnValue;\n+\n+import com.linecorp.armeria.common.stream.StreamMessage;\n+\n+/**\n+ * An {@link HttpResponse} which splits a stream of {@link HttpObject} into HTTP headers and payloads.", "originalCommit": "541878edafb7051422354f928f86484b9af83211", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU4NTc2Mg==", "url": "https://github.com/line/armeria/pull/3038#discussion_r515585762", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * {@link #informationalHeaders()}, {@link #headers()} will be completed before publishing the first element of\n          \n          \n            \n             * {@link HttpData}. {@link #trailers()} might not complete until the entire {@link HttpData} has been consumed.\n          \n          \n            \n             * {@link #informationalHeaders()}, {@link #headers()} will be completed before publishing the first {@link HttpData}.\n          \n          \n            \n             * {@link #trailers()} might not complete until the response body is consumed completely.", "author": "trustin", "createdAt": "2020-11-01T07:13:50Z", "path": "core/src/main/java/com/linecorp/armeria/common/SplitHttpResponse.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+import com.google.errorprone.annotations.CheckReturnValue;\n+\n+import com.linecorp.armeria.common.stream.StreamMessage;\n+\n+/**\n+ * An {@link HttpResponse} which splits a stream of {@link HttpObject} into HTTP headers and payloads.\n+ * {@link #informationalHeaders()}, {@link #headers()} will be completed before publishing the first element of\n+ * {@link HttpData}. {@link #trailers()} might not complete until the entire {@link HttpData} has been consumed.", "originalCommit": "541878edafb7051422354f928f86484b9af83211", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU4NTg2OQ==", "url": "https://github.com/line/armeria/pull/3038#discussion_r515585869", "bodyText": "I guess we have a chance of having too many informational headers in memory. StreamMessage<ResponseHeaders> might solve the memory usage issue, but it'll make this not very user-friendly. Should we just drop all informational headers for simplicity?", "author": "trustin", "createdAt": "2020-11-01T07:14:43Z", "path": "core/src/main/java/com/linecorp/armeria/common/SplitHttpResponse.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+import com.google.errorprone.annotations.CheckReturnValue;\n+\n+import com.linecorp.armeria.common.stream.StreamMessage;\n+\n+/**\n+ * An {@link HttpResponse} which splits a stream of {@link HttpObject} into HTTP headers and payloads.\n+ * {@link #informationalHeaders()}, {@link #headers()} will be completed before publishing the first element of\n+ * {@link HttpData}. {@link #trailers()} might not complete until the entire {@link HttpData} has been consumed.\n+ */\n+public interface SplitHttpResponse {\n+\n+    /**\n+     * Returns a {@link CompletableFuture} completed with a list of\n+     * <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#Information_responses\">informational\n+     * </a> {@link ResponseHeaders}.\n+     */\n+    CompletableFuture<List<ResponseHeaders>> informationalHeaders();", "originalCommit": "541878edafb7051422354f928f86484b9af83211", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjcxODk2OA==", "url": "https://github.com/line/armeria/pull/3038#discussion_r516718968", "bodyText": "Agreed. Most users are not interested in informational headers and if many informational headers are sent, List will grow infinitely.", "author": "ikhoon", "createdAt": "2020-11-03T14:43:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU4NTg2OQ=="}], "type": "inlineReview"}, {"oid": "00db4d7daa4d04ea464665349450273136ad47c3", "url": "https://github.com/line/armeria/commit/00db4d7daa4d04ea464665349450273136ad47c3", "message": "Merge branch 'master' into body-stream", "committedDate": "2020-11-03T14:00:27Z", "type": "commit"}, {"oid": "c7e887d681cf03a9372ea3de830d602776fc1064", "url": "https://github.com/line/armeria/commit/c7e887d681cf03a9372ea3de830d602776fc1064", "message": "Remove informational headers", "committedDate": "2020-11-03T15:07:35Z", "type": "commit"}, {"oid": "e035b459759229f6365dc4f452c92a1fe29f482c", "url": "https://github.com/line/armeria/commit/e035b459759229f6365dc4f452c92a1fe29f482c", "message": "Clean up", "committedDate": "2020-11-03T15:20:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzA4Mzg5NA==", "url": "https://github.com/line/armeria/pull/3038#discussion_r517083894", "bodyText": "If thread A stay here at line 196 and the thread B executes the line 227~236, the cancel event is gone.\nSo I think we should:\nif (upstream != null) {\n    subscription.cancel();\n    return;\n}\nupstream = subscription;\nif (cancelCalled) {\n    subscription.cancel();\n    return;\n}", "author": "minwoox", "createdAt": "2020-11-04T03:54:50Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java", "diffHunk": "@@ -0,0 +1,335 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common;\n+\n+import static com.linecorp.armeria.common.util.Exceptions.throwIfFatal;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.math.LongMath;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.HttpObject;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.SplitHttpResponse;\n+import com.linecorp.armeria.common.stream.AbortedStreamException;\n+import com.linecorp.armeria.common.stream.CancelledSubscriptionException;\n+import com.linecorp.armeria.common.stream.NoopSubscriber;\n+import com.linecorp.armeria.common.stream.StreamMessage;\n+import com.linecorp.armeria.common.stream.SubscriptionOption;\n+import com.linecorp.armeria.common.util.UnmodifiableFuture;\n+import com.linecorp.armeria.internal.common.stream.NoopSubscription;\n+\n+import io.netty.util.concurrent.EventExecutor;\n+\n+public class DefaultSplitHttpResponse implements StreamMessage<HttpData>, SplitHttpResponse {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultSplitHttpResponse.class);\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<BodySubscriber, Subscriber> downstreamUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(BodySubscriber.class, Subscriber.class, \"downstream\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<DefaultSplitHttpResponse, HeadersFuture>\n+            trailersFutureUpdater = AtomicReferenceFieldUpdater\n+            .newUpdater(DefaultSplitHttpResponse.class, HeadersFuture.class, \"trailersFuture\");\n+\n+    private static final ResponseHeaders HEADERS_WITH_UNKNOWN_STATUS = ResponseHeaders.of(HttpStatus.UNKNOWN);\n+    private static final HeadersFuture<HttpHeaders> EMPTY_TRAILERS;\n+\n+    static {\n+        EMPTY_TRAILERS = new HeadersFuture<>();\n+        EMPTY_TRAILERS.doComplete(HttpHeaders.of());\n+    }\n+\n+    private final HeadersFuture<ResponseHeaders> headersFuture = new HeadersFuture<>();\n+    private final BodySubscriber bodySubscriber = new BodySubscriber();\n+    private final HttpResponse response;\n+    private final EventExecutor executor;\n+\n+    @Nullable\n+    private volatile HeadersFuture<HttpHeaders> trailersFuture;\n+    private volatile boolean wroteAny;\n+\n+    public DefaultSplitHttpResponse(HttpResponse response, EventExecutor executor,\n+                                    SubscriptionOption... options) {\n+        this.response = requireNonNull(response, \"response\");\n+        this.executor = requireNonNull(executor, \"executor\");\n+\n+        response.subscribe(bodySubscriber, executor, options);\n+    }\n+\n+    @Override\n+    public final CompletableFuture<ResponseHeaders> headers() {\n+        return headersFuture;\n+    }\n+\n+    @Override\n+    public final StreamMessage<HttpData> body() {\n+        return this;\n+    }\n+\n+    @Override\n+    public final CompletableFuture<HttpHeaders> trailers() {\n+        HeadersFuture<HttpHeaders> trailersFuture = this.trailersFuture;\n+        if (trailersFuture != null) {\n+            return trailersFuture;\n+        }\n+\n+        trailersFuture = new HeadersFuture<>();\n+        if (trailersFutureUpdater.compareAndSet(this, null, trailersFuture)) {\n+            return trailersFuture;\n+        } else {\n+            return this.trailersFuture;\n+        }\n+    }\n+\n+    @Override\n+    public boolean isOpen() {\n+        return response.isOpen();\n+    }\n+\n+    @Override\n+    public boolean isEmpty() {\n+        return !isOpen() && !wroteAny;\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> whenComplete() {\n+        return response.whenComplete();\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super HttpData> subscriber, EventExecutor unused) {\n+        requireNonNull(subscriber, \"subscriber\");\n+        if (executor.inEventLoop()) {\n+            bodySubscriber.setDownStream(subscriber);\n+        } else {\n+            executor.execute(() -> bodySubscriber.setDownStream(subscriber));\n+        }\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super HttpData> subscriber, EventExecutor executor,\n+                          SubscriptionOption... unused) {\n+        throw new UnsupportedOperationException(\"Use 'HttpResponse.split(executor, options)' instead.\");\n+    }\n+\n+    @Override\n+    public void abort() {\n+        response.abort();\n+    }\n+\n+    @Override\n+    public void abort(Throwable cause) {\n+        response.abort(cause);\n+    }\n+\n+    private final class BodySubscriber implements Subscriber<HttpObject>, Subscription {\n+\n+        @Nullable\n+        private Throwable cause;\n+\n+        private boolean completing;\n+        // 1 is used for prefetching headers\n+        private long pendingRequests = 1;\n+\n+        @Nullable\n+        volatile Subscriber<? super HttpData> downstream;\n+        @Nullable\n+        private volatile Subscription upstream;\n+\n+        private volatile boolean cancelCalled;\n+\n+        private void setDownStream(Subscriber<? super HttpData> downstream) {\n+            try {\n+                if (!downstreamUpdater.compareAndSet(this, null, downstream)) {\n+                    downstream.onSubscribe(NoopSubscription.get());\n+                    downstream.onError(new IllegalStateException(\"subscribed by other subscriber already\"));\n+                    return;\n+                }\n+                downstream.onSubscribe(this);\n+                if (cause != null) {\n+                    downstream.onError(cause);\n+                } else if (completing) {\n+                    downstream.onComplete();\n+                }\n+            } catch (Throwable t) {\n+                throwIfFatal(t);\n+                logger.warn(\"Subscriber should not throw an exception. subscriber: {}\", downstream, t);\n+            }\n+        }\n+\n+        @Override\n+        public void onSubscribe(Subscription subscription) {\n+            requireNonNull(subscription, \"subscription\");\n+            if (cancelCalled || upstream != null) {\n+                subscription.cancel();\n+                return;\n+            }", "originalCommit": "e035b459759229f6365dc4f452c92a1fe29f482c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzA4NDU0MQ==", "url": "https://github.com/line/armeria/pull/3038#discussion_r517084541", "bodyText": "I think we can remove this line not to access the memory when the httpObject is not an instance of ResponseHeaders", "author": "minwoox", "createdAt": "2020-11-04T03:57:53Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java", "diffHunk": "@@ -0,0 +1,335 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common;\n+\n+import static com.linecorp.armeria.common.util.Exceptions.throwIfFatal;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.math.LongMath;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.HttpObject;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.SplitHttpResponse;\n+import com.linecorp.armeria.common.stream.AbortedStreamException;\n+import com.linecorp.armeria.common.stream.CancelledSubscriptionException;\n+import com.linecorp.armeria.common.stream.NoopSubscriber;\n+import com.linecorp.armeria.common.stream.StreamMessage;\n+import com.linecorp.armeria.common.stream.SubscriptionOption;\n+import com.linecorp.armeria.common.util.UnmodifiableFuture;\n+import com.linecorp.armeria.internal.common.stream.NoopSubscription;\n+\n+import io.netty.util.concurrent.EventExecutor;\n+\n+public class DefaultSplitHttpResponse implements StreamMessage<HttpData>, SplitHttpResponse {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultSplitHttpResponse.class);\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<BodySubscriber, Subscriber> downstreamUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(BodySubscriber.class, Subscriber.class, \"downstream\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<DefaultSplitHttpResponse, HeadersFuture>\n+            trailersFutureUpdater = AtomicReferenceFieldUpdater\n+            .newUpdater(DefaultSplitHttpResponse.class, HeadersFuture.class, \"trailersFuture\");\n+\n+    private static final ResponseHeaders HEADERS_WITH_UNKNOWN_STATUS = ResponseHeaders.of(HttpStatus.UNKNOWN);\n+    private static final HeadersFuture<HttpHeaders> EMPTY_TRAILERS;\n+\n+    static {\n+        EMPTY_TRAILERS = new HeadersFuture<>();\n+        EMPTY_TRAILERS.doComplete(HttpHeaders.of());\n+    }\n+\n+    private final HeadersFuture<ResponseHeaders> headersFuture = new HeadersFuture<>();\n+    private final BodySubscriber bodySubscriber = new BodySubscriber();\n+    private final HttpResponse response;\n+    private final EventExecutor executor;\n+\n+    @Nullable\n+    private volatile HeadersFuture<HttpHeaders> trailersFuture;\n+    private volatile boolean wroteAny;\n+\n+    public DefaultSplitHttpResponse(HttpResponse response, EventExecutor executor,\n+                                    SubscriptionOption... options) {\n+        this.response = requireNonNull(response, \"response\");\n+        this.executor = requireNonNull(executor, \"executor\");\n+\n+        response.subscribe(bodySubscriber, executor, options);\n+    }\n+\n+    @Override\n+    public final CompletableFuture<ResponseHeaders> headers() {\n+        return headersFuture;\n+    }\n+\n+    @Override\n+    public final StreamMessage<HttpData> body() {\n+        return this;\n+    }\n+\n+    @Override\n+    public final CompletableFuture<HttpHeaders> trailers() {\n+        HeadersFuture<HttpHeaders> trailersFuture = this.trailersFuture;\n+        if (trailersFuture != null) {\n+            return trailersFuture;\n+        }\n+\n+        trailersFuture = new HeadersFuture<>();\n+        if (trailersFutureUpdater.compareAndSet(this, null, trailersFuture)) {\n+            return trailersFuture;\n+        } else {\n+            return this.trailersFuture;\n+        }\n+    }\n+\n+    @Override\n+    public boolean isOpen() {\n+        return response.isOpen();\n+    }\n+\n+    @Override\n+    public boolean isEmpty() {\n+        return !isOpen() && !wroteAny;\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> whenComplete() {\n+        return response.whenComplete();\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super HttpData> subscriber, EventExecutor unused) {\n+        requireNonNull(subscriber, \"subscriber\");\n+        if (executor.inEventLoop()) {\n+            bodySubscriber.setDownStream(subscriber);\n+        } else {\n+            executor.execute(() -> bodySubscriber.setDownStream(subscriber));\n+        }\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super HttpData> subscriber, EventExecutor executor,\n+                          SubscriptionOption... unused) {\n+        throw new UnsupportedOperationException(\"Use 'HttpResponse.split(executor, options)' instead.\");\n+    }\n+\n+    @Override\n+    public void abort() {\n+        response.abort();\n+    }\n+\n+    @Override\n+    public void abort(Throwable cause) {\n+        response.abort(cause);\n+    }\n+\n+    private final class BodySubscriber implements Subscriber<HttpObject>, Subscription {\n+\n+        @Nullable\n+        private Throwable cause;\n+\n+        private boolean completing;\n+        // 1 is used for prefetching headers\n+        private long pendingRequests = 1;\n+\n+        @Nullable\n+        volatile Subscriber<? super HttpData> downstream;\n+        @Nullable\n+        private volatile Subscription upstream;\n+\n+        private volatile boolean cancelCalled;\n+\n+        private void setDownStream(Subscriber<? super HttpData> downstream) {\n+            try {\n+                if (!downstreamUpdater.compareAndSet(this, null, downstream)) {\n+                    downstream.onSubscribe(NoopSubscription.get());\n+                    downstream.onError(new IllegalStateException(\"subscribed by other subscriber already\"));\n+                    return;\n+                }\n+                downstream.onSubscribe(this);\n+                if (cause != null) {\n+                    downstream.onError(cause);\n+                } else if (completing) {\n+                    downstream.onComplete();\n+                }\n+            } catch (Throwable t) {\n+                throwIfFatal(t);\n+                logger.warn(\"Subscriber should not throw an exception. subscriber: {}\", downstream, t);\n+            }\n+        }\n+\n+        @Override\n+        public void onSubscribe(Subscription subscription) {\n+            requireNonNull(subscription, \"subscription\");\n+            if (cancelCalled || upstream != null) {\n+                subscription.cancel();\n+                return;\n+            }\n+            upstream = subscription;\n+            subscription.request(pendingRequests);\n+        }\n+\n+        @Override\n+        public void request(long n) {\n+            if (n <= 0) {\n+                // Just abort the publisher so subscriber().onError(e) is called and resources are cleaned up.\n+                response.abort(new IllegalArgumentException(\n+                        \"n: \" + n + \" (expected: > 0, see Reactive Streams specification rule 3.9)\"));\n+                return;\n+            }\n+            if (executor.inEventLoop()) {\n+                request0(n);\n+            } else {\n+                executor.execute(() -> request0(n));\n+            }\n+        }\n+\n+        private void request0(long n) {\n+            final Subscription upstream = this.upstream;\n+            if (upstream == null) {\n+                pendingRequests = LongMath.saturatedAdd(n, pendingRequests);\n+            } else {\n+                upstream.request(n);\n+            }\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            if (cancelCalled) {\n+                return;\n+            }\n+            cancelCalled = true;\n+            downstream = NoopSubscriber.get();\n+            maybeCompleteHeaders(null);\n+            final Subscription upstream = this.upstream;\n+            if (upstream != null) {\n+                upstream.cancel();\n+            }\n+        }\n+\n+        @Override\n+        public void onNext(HttpObject httpObject) {\n+            final Subscription upstream = this.upstream;", "originalCommit": "e035b459759229f6365dc4f452c92a1fe29f482c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzA4NTA4MQ==", "url": "https://github.com/line/armeria/pull/3038#discussion_r517085081", "bodyText": "Can't this be just response.isEmpty()?", "author": "minwoox", "createdAt": "2020-11-04T04:00:05Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java", "diffHunk": "@@ -0,0 +1,335 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common;\n+\n+import static com.linecorp.armeria.common.util.Exceptions.throwIfFatal;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.math.LongMath;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.HttpObject;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.SplitHttpResponse;\n+import com.linecorp.armeria.common.stream.AbortedStreamException;\n+import com.linecorp.armeria.common.stream.CancelledSubscriptionException;\n+import com.linecorp.armeria.common.stream.NoopSubscriber;\n+import com.linecorp.armeria.common.stream.StreamMessage;\n+import com.linecorp.armeria.common.stream.SubscriptionOption;\n+import com.linecorp.armeria.common.util.UnmodifiableFuture;\n+import com.linecorp.armeria.internal.common.stream.NoopSubscription;\n+\n+import io.netty.util.concurrent.EventExecutor;\n+\n+public class DefaultSplitHttpResponse implements StreamMessage<HttpData>, SplitHttpResponse {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultSplitHttpResponse.class);\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<BodySubscriber, Subscriber> downstreamUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(BodySubscriber.class, Subscriber.class, \"downstream\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<DefaultSplitHttpResponse, HeadersFuture>\n+            trailersFutureUpdater = AtomicReferenceFieldUpdater\n+            .newUpdater(DefaultSplitHttpResponse.class, HeadersFuture.class, \"trailersFuture\");\n+\n+    private static final ResponseHeaders HEADERS_WITH_UNKNOWN_STATUS = ResponseHeaders.of(HttpStatus.UNKNOWN);\n+    private static final HeadersFuture<HttpHeaders> EMPTY_TRAILERS;\n+\n+    static {\n+        EMPTY_TRAILERS = new HeadersFuture<>();\n+        EMPTY_TRAILERS.doComplete(HttpHeaders.of());\n+    }\n+\n+    private final HeadersFuture<ResponseHeaders> headersFuture = new HeadersFuture<>();\n+    private final BodySubscriber bodySubscriber = new BodySubscriber();\n+    private final HttpResponse response;\n+    private final EventExecutor executor;\n+\n+    @Nullable\n+    private volatile HeadersFuture<HttpHeaders> trailersFuture;\n+    private volatile boolean wroteAny;\n+\n+    public DefaultSplitHttpResponse(HttpResponse response, EventExecutor executor,\n+                                    SubscriptionOption... options) {\n+        this.response = requireNonNull(response, \"response\");\n+        this.executor = requireNonNull(executor, \"executor\");\n+\n+        response.subscribe(bodySubscriber, executor, options);\n+    }\n+\n+    @Override\n+    public final CompletableFuture<ResponseHeaders> headers() {\n+        return headersFuture;\n+    }\n+\n+    @Override\n+    public final StreamMessage<HttpData> body() {\n+        return this;\n+    }\n+\n+    @Override\n+    public final CompletableFuture<HttpHeaders> trailers() {\n+        HeadersFuture<HttpHeaders> trailersFuture = this.trailersFuture;\n+        if (trailersFuture != null) {\n+            return trailersFuture;\n+        }\n+\n+        trailersFuture = new HeadersFuture<>();\n+        if (trailersFutureUpdater.compareAndSet(this, null, trailersFuture)) {\n+            return trailersFuture;\n+        } else {\n+            return this.trailersFuture;\n+        }\n+    }\n+\n+    @Override\n+    public boolean isOpen() {\n+        return response.isOpen();\n+    }\n+\n+    @Override\n+    public boolean isEmpty() {\n+        return !isOpen() && !wroteAny;", "originalCommit": "e035b459759229f6365dc4f452c92a1fe29f482c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE3NzY0OQ==", "url": "https://github.com/line/armeria/pull/3038#discussion_r517177649", "bodyText": "I wrote this code in August. Sorry, I don't remember why I added its own wroteAny. \ud83d\ude02\nLet me take some time to remind it. \ud83d\ude0e", "author": "ikhoon", "createdAt": "2020-11-04T08:42:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzA4NTA4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE4NjkyNg==", "url": "https://github.com/line/armeria/pull/3038#discussion_r517186926", "bodyText": "Now, I got it.\nDefaultSplitHttpResponse publishes only HttpData. wroteAny is set to true when a HttpData is received from upstream.\nAFAIK, wroteAny in DefaultStreamMessage which is super class of DefaultHttpResponse is set to true a headers is written.", "author": "ikhoon", "createdAt": "2020-11-04T08:58:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzA4NTA4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzgwMzMxNQ==", "url": "https://github.com/line/armeria/pull/3038#discussion_r517803315", "bodyText": "Thanks for the explanation. \ud83d\ude47", "author": "minwoox", "createdAt": "2020-11-05T05:39:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzA4NTA4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzA4NjIzNQ==", "url": "https://github.com/line/armeria/pull/3038#discussion_r517086235", "bodyText": "If subscribed with SubscriptionOptions.NOTIFY_CANCELLATION, the subscriber doesn't get notified because of this logic? Could you add a test for this?", "author": "minwoox", "createdAt": "2020-11-04T04:05:27Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java", "diffHunk": "@@ -0,0 +1,335 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common;\n+\n+import static com.linecorp.armeria.common.util.Exceptions.throwIfFatal;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.math.LongMath;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.HttpObject;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.SplitHttpResponse;\n+import com.linecorp.armeria.common.stream.AbortedStreamException;\n+import com.linecorp.armeria.common.stream.CancelledSubscriptionException;\n+import com.linecorp.armeria.common.stream.NoopSubscriber;\n+import com.linecorp.armeria.common.stream.StreamMessage;\n+import com.linecorp.armeria.common.stream.SubscriptionOption;\n+import com.linecorp.armeria.common.util.UnmodifiableFuture;\n+import com.linecorp.armeria.internal.common.stream.NoopSubscription;\n+\n+import io.netty.util.concurrent.EventExecutor;\n+\n+public class DefaultSplitHttpResponse implements StreamMessage<HttpData>, SplitHttpResponse {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultSplitHttpResponse.class);\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<BodySubscriber, Subscriber> downstreamUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(BodySubscriber.class, Subscriber.class, \"downstream\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<DefaultSplitHttpResponse, HeadersFuture>\n+            trailersFutureUpdater = AtomicReferenceFieldUpdater\n+            .newUpdater(DefaultSplitHttpResponse.class, HeadersFuture.class, \"trailersFuture\");\n+\n+    private static final ResponseHeaders HEADERS_WITH_UNKNOWN_STATUS = ResponseHeaders.of(HttpStatus.UNKNOWN);\n+    private static final HeadersFuture<HttpHeaders> EMPTY_TRAILERS;\n+\n+    static {\n+        EMPTY_TRAILERS = new HeadersFuture<>();\n+        EMPTY_TRAILERS.doComplete(HttpHeaders.of());\n+    }\n+\n+    private final HeadersFuture<ResponseHeaders> headersFuture = new HeadersFuture<>();\n+    private final BodySubscriber bodySubscriber = new BodySubscriber();\n+    private final HttpResponse response;\n+    private final EventExecutor executor;\n+\n+    @Nullable\n+    private volatile HeadersFuture<HttpHeaders> trailersFuture;\n+    private volatile boolean wroteAny;\n+\n+    public DefaultSplitHttpResponse(HttpResponse response, EventExecutor executor,\n+                                    SubscriptionOption... options) {\n+        this.response = requireNonNull(response, \"response\");\n+        this.executor = requireNonNull(executor, \"executor\");\n+\n+        response.subscribe(bodySubscriber, executor, options);\n+    }\n+\n+    @Override\n+    public final CompletableFuture<ResponseHeaders> headers() {\n+        return headersFuture;\n+    }\n+\n+    @Override\n+    public final StreamMessage<HttpData> body() {\n+        return this;\n+    }\n+\n+    @Override\n+    public final CompletableFuture<HttpHeaders> trailers() {\n+        HeadersFuture<HttpHeaders> trailersFuture = this.trailersFuture;\n+        if (trailersFuture != null) {\n+            return trailersFuture;\n+        }\n+\n+        trailersFuture = new HeadersFuture<>();\n+        if (trailersFutureUpdater.compareAndSet(this, null, trailersFuture)) {\n+            return trailersFuture;\n+        } else {\n+            return this.trailersFuture;\n+        }\n+    }\n+\n+    @Override\n+    public boolean isOpen() {\n+        return response.isOpen();\n+    }\n+\n+    @Override\n+    public boolean isEmpty() {\n+        return !isOpen() && !wroteAny;\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> whenComplete() {\n+        return response.whenComplete();\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super HttpData> subscriber, EventExecutor unused) {\n+        requireNonNull(subscriber, \"subscriber\");\n+        if (executor.inEventLoop()) {\n+            bodySubscriber.setDownStream(subscriber);\n+        } else {\n+            executor.execute(() -> bodySubscriber.setDownStream(subscriber));\n+        }\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super HttpData> subscriber, EventExecutor executor,\n+                          SubscriptionOption... unused) {\n+        throw new UnsupportedOperationException(\"Use 'HttpResponse.split(executor, options)' instead.\");\n+    }\n+\n+    @Override\n+    public void abort() {\n+        response.abort();\n+    }\n+\n+    @Override\n+    public void abort(Throwable cause) {\n+        response.abort(cause);\n+    }\n+\n+    private final class BodySubscriber implements Subscriber<HttpObject>, Subscription {\n+\n+        @Nullable\n+        private Throwable cause;\n+\n+        private boolean completing;\n+        // 1 is used for prefetching headers\n+        private long pendingRequests = 1;\n+\n+        @Nullable\n+        volatile Subscriber<? super HttpData> downstream;\n+        @Nullable\n+        private volatile Subscription upstream;\n+\n+        private volatile boolean cancelCalled;\n+\n+        private void setDownStream(Subscriber<? super HttpData> downstream) {\n+            try {\n+                if (!downstreamUpdater.compareAndSet(this, null, downstream)) {\n+                    downstream.onSubscribe(NoopSubscription.get());\n+                    downstream.onError(new IllegalStateException(\"subscribed by other subscriber already\"));\n+                    return;\n+                }\n+                downstream.onSubscribe(this);\n+                if (cause != null) {\n+                    downstream.onError(cause);\n+                } else if (completing) {\n+                    downstream.onComplete();\n+                }\n+            } catch (Throwable t) {\n+                throwIfFatal(t);\n+                logger.warn(\"Subscriber should not throw an exception. subscriber: {}\", downstream, t);\n+            }\n+        }\n+\n+        @Override\n+        public void onSubscribe(Subscription subscription) {\n+            requireNonNull(subscription, \"subscription\");\n+            if (cancelCalled || upstream != null) {\n+                subscription.cancel();\n+                return;\n+            }\n+            upstream = subscription;\n+            subscription.request(pendingRequests);\n+        }\n+\n+        @Override\n+        public void request(long n) {\n+            if (n <= 0) {\n+                // Just abort the publisher so subscriber().onError(e) is called and resources are cleaned up.\n+                response.abort(new IllegalArgumentException(\n+                        \"n: \" + n + \" (expected: > 0, see Reactive Streams specification rule 3.9)\"));\n+                return;\n+            }\n+            if (executor.inEventLoop()) {\n+                request0(n);\n+            } else {\n+                executor.execute(() -> request0(n));\n+            }\n+        }\n+\n+        private void request0(long n) {\n+            final Subscription upstream = this.upstream;\n+            if (upstream == null) {\n+                pendingRequests = LongMath.saturatedAdd(n, pendingRequests);\n+            } else {\n+                upstream.request(n);\n+            }\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            if (cancelCalled) {\n+                return;\n+            }\n+            cancelCalled = true;\n+            downstream = NoopSubscriber.get();", "originalCommit": "e035b459759229f6365dc4f452c92a1fe29f482c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzIxMDAyNA==", "url": "https://github.com/line/armeria/pull/3038#discussion_r517210024", "bodyText": "That's a good point. I've added this code to pass Reactive Streams TCK. Let me update this a lit. :-)", "author": "ikhoon", "createdAt": "2020-11-04T09:35:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzA4NjIzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzgwMzk2OQ==", "url": "https://github.com/line/armeria/pull/3038#discussion_r517803969", "bodyText": "question: Can't we just leave the downstream? (i.e. not assign the NoopSubscriber?)", "author": "minwoox", "createdAt": "2020-11-05T05:41:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzA4NjIzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzg4MTk3NA==", "url": "https://github.com/line/armeria/pull/3038#discussion_r517881974", "bodyText": "AFAIK, if Subscription.cancel() called, the publisher should drop the subscriber's reference.\nhttps://github.com/reactive-streams/reactive-streams-jvm#3.13\nIf not, required_spec313_cancelMustMakeThePublisherEventuallyDropAllReferencesToTheSubscriber in TCK was failed.", "author": "ikhoon", "createdAt": "2020-11-05T08:49:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzA4NjIzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzg4NDY4Mw==", "url": "https://github.com/line/armeria/pull/3038#discussion_r517884683", "bodyText": "Thanks for the explanation. \ud83d\ude04", "author": "minwoox", "createdAt": "2020-11-05T08:53:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzA4NjIzNQ=="}], "type": "inlineReview"}, {"oid": "a0168fed0656db0477de77679f64adb69499d0e3", "url": "https://github.com/line/armeria/commit/a0168fed0656db0477de77679f64adb69499d0e3", "message": "Address comments by @minwoox", "committedDate": "2020-11-04T09:26:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU0NzA2Ng==", "url": "https://github.com/line/armeria/pull/3038#discussion_r518547066", "bodyText": "How about doing this after downstreamUpdater.compareAndSet(this, null, downstream)?", "author": "minwoox", "createdAt": "2020-11-06T06:27:04Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common;\n+\n+import static com.linecorp.armeria.common.util.Exceptions.throwIfFatal;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.math.LongMath;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.HttpObject;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.SplitHttpResponse;\n+import com.linecorp.armeria.common.stream.AbortedStreamException;\n+import com.linecorp.armeria.common.stream.CancelledSubscriptionException;\n+import com.linecorp.armeria.common.stream.NoopSubscriber;\n+import com.linecorp.armeria.common.stream.StreamMessage;\n+import com.linecorp.armeria.common.stream.SubscriptionOption;\n+import com.linecorp.armeria.common.util.UnmodifiableFuture;\n+import com.linecorp.armeria.internal.common.stream.NoopSubscription;\n+\n+import io.netty.util.concurrent.EventExecutor;\n+\n+public class DefaultSplitHttpResponse implements StreamMessage<HttpData>, SplitHttpResponse {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultSplitHttpResponse.class);\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<BodySubscriber, Subscriber> downstreamUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(BodySubscriber.class, Subscriber.class, \"downstream\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<DefaultSplitHttpResponse, HeadersFuture>\n+            trailersFutureUpdater = AtomicReferenceFieldUpdater\n+            .newUpdater(DefaultSplitHttpResponse.class, HeadersFuture.class, \"trailersFuture\");\n+\n+    private static final ResponseHeaders HEADERS_WITH_UNKNOWN_STATUS = ResponseHeaders.of(HttpStatus.UNKNOWN);\n+    private static final HeadersFuture<HttpHeaders> EMPTY_TRAILERS;\n+\n+    static {\n+        EMPTY_TRAILERS = new HeadersFuture<>();\n+        EMPTY_TRAILERS.doComplete(HttpHeaders.of());\n+    }\n+\n+    private final HeadersFuture<ResponseHeaders> headersFuture = new HeadersFuture<>();\n+    private final BodySubscriber bodySubscriber = new BodySubscriber();\n+    private final HttpResponse response;\n+    private final EventExecutor executor;\n+    private final boolean notifyCancellation;\n+\n+    @Nullable\n+    private volatile HeadersFuture<HttpHeaders> trailersFuture;\n+    private volatile boolean wroteAny;\n+\n+    public DefaultSplitHttpResponse(HttpResponse response, EventExecutor executor,\n+                                    SubscriptionOption... options) {\n+        this.response = requireNonNull(response, \"response\");\n+        this.executor = requireNonNull(executor, \"executor\");\n+        notifyCancellation = containsNotifyCancellation(options);\n+\n+        response.subscribe(bodySubscriber, executor, options);\n+    }\n+\n+    @Override\n+    public final CompletableFuture<ResponseHeaders> headers() {\n+        return headersFuture;\n+    }\n+\n+    @Override\n+    public final StreamMessage<HttpData> body() {\n+        return this;\n+    }\n+\n+    @Override\n+    public final CompletableFuture<HttpHeaders> trailers() {\n+        HeadersFuture<HttpHeaders> trailersFuture = this.trailersFuture;\n+        if (trailersFuture != null) {\n+            return trailersFuture;\n+        }\n+\n+        trailersFuture = new HeadersFuture<>();\n+        if (trailersFutureUpdater.compareAndSet(this, null, trailersFuture)) {\n+            return trailersFuture;\n+        } else {\n+            return this.trailersFuture;\n+        }\n+    }\n+\n+    @Override\n+    public boolean isOpen() {\n+        return response.isOpen();\n+    }\n+\n+    @Override\n+    public boolean isEmpty() {\n+        return !isOpen() && !wroteAny;\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> whenComplete() {\n+        return response.whenComplete();\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super HttpData> subscriber, EventExecutor unused) {\n+        requireNonNull(subscriber, \"subscriber\");\n+        if (executor.inEventLoop()) {", "originalCommit": "a0168fed0656db0477de77679f64adb69499d0e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU0ODUwNg==", "url": "https://github.com/line/armeria/pull/3038#discussion_r518548506", "bodyText": "Isn't this if (notifyCancellation) ?", "author": "minwoox", "createdAt": "2020-11-06T06:32:17Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common;\n+\n+import static com.linecorp.armeria.common.util.Exceptions.throwIfFatal;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.math.LongMath;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.HttpObject;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.SplitHttpResponse;\n+import com.linecorp.armeria.common.stream.AbortedStreamException;\n+import com.linecorp.armeria.common.stream.CancelledSubscriptionException;\n+import com.linecorp.armeria.common.stream.NoopSubscriber;\n+import com.linecorp.armeria.common.stream.StreamMessage;\n+import com.linecorp.armeria.common.stream.SubscriptionOption;\n+import com.linecorp.armeria.common.util.UnmodifiableFuture;\n+import com.linecorp.armeria.internal.common.stream.NoopSubscription;\n+\n+import io.netty.util.concurrent.EventExecutor;\n+\n+public class DefaultSplitHttpResponse implements StreamMessage<HttpData>, SplitHttpResponse {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultSplitHttpResponse.class);\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<BodySubscriber, Subscriber> downstreamUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(BodySubscriber.class, Subscriber.class, \"downstream\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<DefaultSplitHttpResponse, HeadersFuture>\n+            trailersFutureUpdater = AtomicReferenceFieldUpdater\n+            .newUpdater(DefaultSplitHttpResponse.class, HeadersFuture.class, \"trailersFuture\");\n+\n+    private static final ResponseHeaders HEADERS_WITH_UNKNOWN_STATUS = ResponseHeaders.of(HttpStatus.UNKNOWN);\n+    private static final HeadersFuture<HttpHeaders> EMPTY_TRAILERS;\n+\n+    static {\n+        EMPTY_TRAILERS = new HeadersFuture<>();\n+        EMPTY_TRAILERS.doComplete(HttpHeaders.of());\n+    }\n+\n+    private final HeadersFuture<ResponseHeaders> headersFuture = new HeadersFuture<>();\n+    private final BodySubscriber bodySubscriber = new BodySubscriber();\n+    private final HttpResponse response;\n+    private final EventExecutor executor;\n+    private final boolean notifyCancellation;\n+\n+    @Nullable\n+    private volatile HeadersFuture<HttpHeaders> trailersFuture;\n+    private volatile boolean wroteAny;\n+\n+    public DefaultSplitHttpResponse(HttpResponse response, EventExecutor executor,\n+                                    SubscriptionOption... options) {\n+        this.response = requireNonNull(response, \"response\");\n+        this.executor = requireNonNull(executor, \"executor\");\n+        notifyCancellation = containsNotifyCancellation(options);\n+\n+        response.subscribe(bodySubscriber, executor, options);\n+    }\n+\n+    @Override\n+    public final CompletableFuture<ResponseHeaders> headers() {\n+        return headersFuture;\n+    }\n+\n+    @Override\n+    public final StreamMessage<HttpData> body() {\n+        return this;\n+    }\n+\n+    @Override\n+    public final CompletableFuture<HttpHeaders> trailers() {\n+        HeadersFuture<HttpHeaders> trailersFuture = this.trailersFuture;\n+        if (trailersFuture != null) {\n+            return trailersFuture;\n+        }\n+\n+        trailersFuture = new HeadersFuture<>();\n+        if (trailersFutureUpdater.compareAndSet(this, null, trailersFuture)) {\n+            return trailersFuture;\n+        } else {\n+            return this.trailersFuture;\n+        }\n+    }\n+\n+    @Override\n+    public boolean isOpen() {\n+        return response.isOpen();\n+    }\n+\n+    @Override\n+    public boolean isEmpty() {\n+        return !isOpen() && !wroteAny;\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> whenComplete() {\n+        return response.whenComplete();\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super HttpData> subscriber, EventExecutor unused) {\n+        requireNonNull(subscriber, \"subscriber\");\n+        if (executor.inEventLoop()) {\n+            bodySubscriber.setDownStream(subscriber);\n+        } else {\n+            executor.execute(() -> bodySubscriber.setDownStream(subscriber));\n+        }\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super HttpData> subscriber, EventExecutor executor,\n+                          SubscriptionOption... unused) {\n+        throw new UnsupportedOperationException(\"Use 'HttpResponse.split(executor, options)' instead.\");\n+    }\n+\n+    @Override\n+    public void abort() {\n+        response.abort();\n+    }\n+\n+    @Override\n+    public void abort(Throwable cause) {\n+        response.abort(cause);\n+    }\n+\n+    private final class BodySubscriber implements Subscriber<HttpObject>, Subscription {\n+\n+        @Nullable\n+        private Throwable cause;\n+\n+        private boolean completing;\n+        // 1 is used for prefetching headers\n+        private long pendingRequests = 1;\n+\n+        @Nullable\n+        volatile Subscriber<? super HttpData> downstream;\n+        @Nullable\n+        private volatile Subscription upstream;\n+\n+        private volatile boolean cancelCalled;\n+\n+        private void setDownStream(Subscriber<? super HttpData> downstream) {\n+            try {\n+                if (!downstreamUpdater.compareAndSet(this, null, downstream)) {\n+                    downstream.onSubscribe(NoopSubscription.get());\n+                    downstream.onError(new IllegalStateException(\"subscribed by other subscriber already\"));\n+                    return;\n+                }\n+                downstream.onSubscribe(this);\n+                if (cause != null) {\n+                    downstream.onError(cause);\n+                } else if (completing) {\n+                    downstream.onComplete();\n+                }\n+            } catch (Throwable t) {\n+                throwIfFatal(t);\n+                logger.warn(\"Subscriber should not throw an exception. subscriber: {}\", downstream, t);\n+            }\n+        }\n+\n+        @Override\n+        public void onSubscribe(Subscription subscription) {\n+            requireNonNull(subscription, \"subscription\");\n+            if (upstream != null) {\n+                subscription.cancel();\n+                return;\n+            }\n+            upstream = subscription;\n+            if (cancelCalled) {\n+                subscription.cancel();\n+                return;\n+            }\n+            subscription.request(pendingRequests);\n+        }\n+\n+        @Override\n+        public void request(long n) {\n+            if (n <= 0) {\n+                // Just abort the publisher so subscriber().onError(e) is called and resources are cleaned up.\n+                response.abort(new IllegalArgumentException(\n+                        \"n: \" + n + \" (expected: > 0, see Reactive Streams specification rule 3.9)\"));\n+                return;\n+            }\n+            if (executor.inEventLoop()) {\n+                request0(n);\n+            } else {\n+                executor.execute(() -> request0(n));\n+            }\n+        }\n+\n+        private void request0(long n) {\n+            final Subscription upstream = this.upstream;\n+            if (upstream == null) {\n+                pendingRequests = LongMath.saturatedAdd(n, pendingRequests);\n+            } else {\n+                upstream.request(n);\n+            }\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            if (cancelCalled) {\n+                return;\n+            }\n+            cancelCalled = true;\n+            if (!notifyCancellation) {\n+                downstream = NoopSubscriber.get();\n+            }\n+            maybeCompleteHeaders(null);\n+            final Subscription upstream = this.upstream;\n+            if (upstream != null) {\n+                upstream.cancel();\n+            }\n+        }\n+\n+        @Override\n+        public void onNext(HttpObject httpObject) {\n+            if (httpObject instanceof ResponseHeaders) {\n+                final ResponseHeaders headers = (ResponseHeaders) httpObject;\n+                final HttpStatus status = headers.status();\n+                if (status.isInformational()) {\n+                    // Ignore informational headers\n+                    upstream.request(1);\n+                } else {\n+                    headersFuture.doComplete(headers);\n+                }\n+                return;\n+            }\n+\n+            if (httpObject instanceof HttpHeaders) {\n+                final HttpHeaders trailers = (HttpHeaders) httpObject;\n+                completeTrailers(trailers);\n+                return;\n+            }\n+\n+            final Subscriber<? super HttpData> downstream = this.downstream;\n+            assert downstream != null;\n+            assert httpObject instanceof HttpData;\n+            final HttpData data = (HttpData) httpObject;\n+            wroteAny = true;\n+            downstream.onNext(data);\n+        }\n+\n+        /**\n+         * Completes the specified trailers.\n+         */\n+        private void completeTrailers(HttpHeaders trailers) {\n+            HeadersFuture<HttpHeaders> trailersFuture = DefaultSplitHttpResponse.this.trailersFuture;\n+            if (trailersFuture != null) {\n+                trailersFuture.doComplete(trailers);\n+                return;\n+            }\n+\n+            trailersFuture = new HeadersFuture<>();\n+            if (trailersFutureUpdater.compareAndSet(DefaultSplitHttpResponse.this, null, trailersFuture)) {\n+                trailersFuture.doComplete(trailers);\n+            } else {\n+                DefaultSplitHttpResponse.this.trailersFuture.doComplete(trailers);\n+            }\n+        }\n+\n+        @Override\n+        public void onError(Throwable cause) {\n+            maybeCompleteHeaders(cause);\n+            final Subscriber<? super HttpData> downstream = this.downstream;\n+            if (downstream == null) {\n+                this.cause = cause;\n+            } else {\n+                downstream.onError(cause);\n+                if (cause instanceof CancelledSubscriptionException) {", "originalCommit": "a0168fed0656db0477de77679f64adb69499d0e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU1MjQ2MA==", "url": "https://github.com/line/armeria/pull/3038#discussion_r518552460", "bodyText": "Yeah, I think that is the same effect. Otherwise, I think we can remove the if condition.\nThere is no harm to set NoopSubscriber to downstream after onError() is invoked.", "author": "ikhoon", "createdAt": "2020-11-06T06:46:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU0ODUwNg=="}], "type": "inlineReview"}, {"oid": "fdb9bb7ee3c5fa64880b279c81e2a4445dde5ca6", "url": "https://github.com/line/armeria/commit/fdb9bb7ee3c5fa64880b279c81e2a4445dde5ca6", "message": "Address comments by @minwoox", "committedDate": "2020-11-06T06:50:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTYyNjgzMA==", "url": "https://github.com/line/armeria/pull/3038#discussion_r519626830", "bodyText": "I'm not sure we need to accept SubscriptionOption here. A user will have to specify them when retrieving the response body via SplitHttpResponse.body(). Otherwise, a user will have to specify the same option twice.\nWe could subscribe to HttpResponse with both SubscriptionOptions enabled internally, and then emulate the desired behavior based on what's specified in body.subscribe(), e.g.\n\nConvert off-heap HttpData into heap HttpData if WITH_POOLED_OBJECTS option is off.\nPropagate CancelledSubscriptionException to onError() only when NOTIFY_CANCELLATION option is on.", "author": "trustin", "createdAt": "2020-11-09T08:25:50Z", "path": "core/src/main/java/com/linecorp/armeria/common/HttpResponse.java", "diffHunk": "@@ -548,4 +550,63 @@ default HttpResponseDuplicator toDuplicator(EventExecutor executor, long maxResp\n         requireNonNull(executor, \"executor\");\n         return new DefaultHttpResponseDuplicator(this, executor, maxResponseLength);\n     }\n+\n+    /**\n+     * Returns a new {@link SplitHttpResponse} which splits a stream of {@link HttpObject}s into\n+     * {@link HttpHeaders} and {@link HttpData}.\n+     * {@link SplitHttpResponse#headers()} will be\n+     * completed before publishing the first {@link HttpData}.\n+     * {@link SplitHttpResponse#trailers()} might not complete until the entire response body is consumed\n+     * completely.\n+     */\n+    @CheckReturnValue\n+    default SplitHttpResponse split() {\n+        return split(defaultSubscriberExecutor());\n+    }\n+\n+    /**\n+     * Returns a new {@link SplitHttpResponse} which splits a stream of {@link HttpObject}s into\n+     * {@link HttpHeaders} and {@link HttpData}.\n+     * {@link SplitHttpResponse#headers()} will be completed before publishing the first {@link HttpData}.\n+     * {@link SplitHttpResponse#trailers()} might not complete until the entire response body is consumed\n+     * completely.\n+     *\n+     * <p>(Advanced users only) If you want to get pooled objects from {@link SplitHttpResponse#body()},\n+     * you should call this method with {@link SubscriptionOption#WITH_POOLED_OBJECTS}.\n+     * Note that if you specify {@link SubscriptionOption}s when subscribing to\n+     * {@link SplitHttpResponse#body()}, {@link UnsupportedOperationException} will be raised.\n+     */\n+    @CheckReturnValue\n+    default SplitHttpResponse split(SubscriptionOption... options) {\n+        return new DefaultSplitHttpResponse(this, defaultSubscriberExecutor(), options);\n+    }\n+\n+    /**\n+     * Returns a new {@link SplitHttpResponse} which splits a stream of {@link HttpObject}s into\n+     * {@link HttpHeaders} and {@link HttpData}.\n+     * {@link SplitHttpResponse#headers()} will be completed before publishing the first {@link HttpData}.\n+     * {@link SplitHttpResponse#trailers()} might not complete until the entire response body is consumed\n+     * completely.\n+     */\n+    @CheckReturnValue\n+    default SplitHttpResponse split(EventExecutor executor) {\n+        return new DefaultSplitHttpResponse(this, executor);\n+    }\n+\n+    /**\n+     * Returns a new {@link SplitHttpResponse} which splits a stream of {@link HttpObject}s into\n+     * {@link HttpHeaders} and {@link HttpData}.\n+     * {@link SplitHttpResponse#headers()} will be completed before publishing the first {@link HttpData}.\n+     * {@link SplitHttpResponse#trailers()} might not complete until the entire response body is consumed\n+     * completely.\n+     *\n+     * <p>(Advanced users only) If you want to get pooled objects from {@link SplitHttpResponse#body()},\n+     * you should call this method with {@link SubscriptionOption#WITH_POOLED_OBJECTS}.\n+     * Note that if you specify {@link SubscriptionOption}s when subscribing to\n+     * {@link SplitHttpResponse#body()}, {@link UnsupportedOperationException} will be raised.\n+     */\n+    @CheckReturnValue\n+    default SplitHttpResponse split(EventExecutor executor, SubscriptionOption... options) {", "originalCommit": "fdb9bb7ee3c5fa64880b279c81e2a4445dde5ca6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2f5a5791685d692b512407a8c38fc2c416ab7767", "url": "https://github.com/line/armeria/commit/2f5a5791685d692b512407a8c38fc2c416ab7767", "message": "Address comments by @trustin / Remove subcription options from `split()`", "committedDate": "2020-11-13T07:08:25Z", "type": "commit"}, {"oid": "b3e0ae2d3bed932aaa025c2cb12a6818a0b04383", "url": "https://github.com/line/armeria/commit/b3e0ae2d3bed932aaa025c2cb12a6818a0b04383", "message": "Fix checkstyle", "committedDate": "2020-11-16T05:08:58Z", "type": "commit"}, {"oid": "c0f8108deaf18e5e4b395de3bf0f581c107f085c", "url": "https://github.com/line/armeria/commit/c0f8108deaf18e5e4b395de3bf0f581c107f085c", "message": "Merge branch 'master' into body-stream", "committedDate": "2020-11-16T09:20:29Z", "type": "commit"}, {"oid": "3b032bd18d0ba94d520b5c605a4b6f02b83bed9a", "url": "https://github.com/line/armeria/commit/3b032bd18d0ba94d520b5c605a4b6f02b83bed9a", "message": "Fix broken test", "committedDate": "2020-11-16T10:07:54Z", "type": "commit"}, {"oid": "bfc30e38c80f9534e16473d7eb65196cabe0d360", "url": "https://github.com/line/armeria/commit/bfc30e38c80f9534e16473d7eb65196cabe0d360", "message": "Address comments by @minwoox", "committedDate": "2020-11-16T12:16:22Z", "type": "commit"}]}