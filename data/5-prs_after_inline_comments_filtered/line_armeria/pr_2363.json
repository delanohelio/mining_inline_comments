{"pr_number": 2363, "pr_title": "Add examples for context propagation", "pr_createdAt": "2020-01-02T09:47:38Z", "pr_url": "https://github.com/line/armeria/pull/2363", "timeline": [{"oid": "e694a6ba436215fd76d6a5ae510d821bed0f9973", "url": "https://github.com/line/armeria/commit/e694a6ba436215fd76d6a5ae510d821bed0f9973", "message": "Add examples for context propagation using manual propagation and Dagger.", "committedDate": "2020-01-02T09:42:48Z", "type": "commit"}, {"oid": "c3f5e2a22d68c403a9b5f3eea6024b63421d8a0d", "url": "https://github.com/line/armeria/commit/c3f5e2a22d68c403a9b5f3eea6024b63421d8a0d", "message": "Squares", "committedDate": "2020-01-05T06:08:12Z", "type": "commit"}, {"oid": "6d8fd5c594182c5e81d854fb6910c8b8f7373153", "url": "https://github.com/line/armeria/commit/6d8fd5c594182c5e81d854fb6910c8b8f7373153", "message": "Indent", "committedDate": "2020-01-05T06:25:15Z", "type": "commit"}, {"oid": "fa7127b2e77c02da3605cc98ce70697bf5d72c0f", "url": "https://github.com/line/armeria/commit/fa7127b2e77c02da3605cc98ce70697bf5d72c0f", "message": "Remove too-inner import", "committedDate": "2020-01-05T06:26:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzEzODg4Ng==", "url": "https://github.com/line/armeria/pull/2363#discussion_r363138886", "bodyText": "nit: indentation.", "author": "minwoox", "createdAt": "2020-01-06T02:23:59Z", "path": "examples/context-propagation/manual/src/main/java/example/armeria/contextpropagation/manual/MainService.java", "diffHunk": "@@ -0,0 +1,109 @@\n+package example.armeria.contextpropagation.manual;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import com.google.common.base.Splitter;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Iterables;\n+import com.google.common.util.concurrent.Uninterruptibles;\n+import com.spotify.futures.CompletableFutures;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.AggregatedHttpResponse;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.server.HttpService;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+public class MainService implements HttpService {\n+\n+    private static final Splitter NUM_SPLITTER = Splitter.on(',').trimResults().omitEmptyStrings();\n+\n+    private final WebClient backendClient;\n+\n+    public MainService(WebClient backendClient) {\n+        this.backendClient = requireNonNull(backendClient, \"backendClient\");\n+    }\n+\n+    @Override\n+    public HttpResponse serve(ServiceRequestContext ctx, HttpRequest req) {\n+        final Executor ctxExecutor = ctx.contextAwareExecutor();\n+\n+        final CompletableFuture<AggregatedHttpRequest> aggregated = req.aggregate();\n+\n+        // This logic mimics using a blocking method, which would usually be something like a MySQL\n+        // database query using JDBC.\n+        final CompletableFuture<List<Long>> fetchFromFakeDb = CompletableFuture.supplyAsync(\n+                () -> {\n+                    // The context is mounted in a thread-local, meaning it is available to all logic such\n+                    // as tracing.\n+                    checkState(ServiceRequestContext.current() == ctx);\n+\n+                    Uninterruptibles.sleepUninterruptibly(Duration.ofMillis(50));\n+                    return ImmutableList.of(23L, -23L);\n+                },\n+                // Always run blocking logic on the blocking task executor. By using\n+                // ServiceRequestContext.blockingTaskExecutor, you also ensure the context is mounted inside the\n+                // logic (e.g., your DB call will be traced!).\n+                ctx.blockingTaskExecutor());\n+\n+        final CompletableFuture<List<CompletableFuture<AggregatedHttpResponse>>> fetchFromBackend =\n+                CompletableFuture.allOf(\n+                        aggregated, fetchFromFakeDb).thenApplyAsync(\n+                        unused -> {\n+                            // The context is mounted in a thread-local, meaning it is available to all logic\n+                            // such as tracing.\n+                            checkState(ServiceRequestContext.current() == ctx);\n+\n+                            final AggregatedHttpRequest request = aggregated.join();\n+\n+                            final Stream.Builder<Long> nums = Stream.builder();\n+                            for (String token : Iterables.concat(\n+                                    NUM_SPLITTER.split(request.path().substring(1)),\n+                                    NUM_SPLITTER.split(request.contentUtf8()))) {\n+                                nums.add(Long.parseLong(token));\n+                            }\n+                            fetchFromFakeDb.join().forEach(nums::add);\n+\n+                            return nums.build()\n+                                       .map(num -> backendClient.get(\"/square/\" + num).aggregate())\n+                                       .collect(toImmutableList());\n+                        },\n+                        // Unless you know what you're doing, always use then*Async type methods with the\n+                        // context executor to have the context mounted and stay on a single thread to reduce\n+                        // concurrency issues.\n+                        ctxExecutor);\n+\n+        final CompletableFuture<HttpResponse> response =\n+                // When using CompletableFuture, boiler-plate invocations to wrap / unwrap futures are sometimes\n+                // required. Such boilerplate has no chance of using Armeria's context and it is ok to not\n+                // use ctxExecutor for them. But if in doubt, it doesn't hurt too much to use it everywhere.\n+                fetchFromBackend.thenApply(CompletableFutures::allAsList)\n+                                .thenCompose(u -> u)\n+                                .thenApplyAsync(\n+                                        (backendResponse) -> {\n+                                            // The context is mounted in a thread-local, meaning it is\n+                                            // available to all logic such as tracing.\n+                                            checkState(ServiceRequestContext.current() == ctx);\n+                                            return HttpResponse.of(backendResponse.stream()\n+                                                                   .map(AggregatedHttpResponse::contentUtf8)", "originalCommit": "fa7127b2e77c02da3605cc98ce70697bf5d72c0f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "dadedd35b2ee515c726efdb100118515fd6cb14e", "url": "https://github.com/line/armeria/commit/dadedd35b2ee515c726efdb100118515fd6cb14e", "message": "Indent", "committedDate": "2020-01-06T05:27:56Z", "type": "commit"}, {"oid": "90a29b732928d0518c23350f49baef643f70844b", "url": "https://github.com/line/armeria/commit/90a29b732928d0518c23350f49baef643f70844b", "message": "Update README", "committedDate": "2020-01-06T06:32:37Z", "type": "commit"}, {"oid": "053d054de82088d18accb072dc1ad116ef78f3fb", "url": "https://github.com/line/armeria/commit/053d054de82088d18accb072dc1ad116ef78f3fb", "message": "Period", "committedDate": "2020-01-06T06:33:33Z", "type": "commit"}, {"oid": "ac5286aea75ee90739397f6e2d961c634c73f151", "url": "https://github.com/line/armeria/commit/ac5286aea75ee90739397f6e2d961c634c73f151", "message": "Add rxjava example", "committedDate": "2020-01-06T09:56:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzIzMTg4Mw==", "url": "https://github.com/line/armeria/pull/2363#discussion_r363231883", "bodyText": "One aspect of rxjava integration I noticed is methods like these are fairly ridiculously slow due to context mounting. An inevitable downside of having the integration be a single static method invocation in main I guess.", "author": "anuraaga", "createdAt": "2020-01-06T10:13:26Z", "path": "examples/context-propagation/rxjava/src/main/java/example/armeria/contextpropagation/rxjava/MainService.java", "diffHunk": "@@ -0,0 +1,88 @@\n+package example.armeria.contextpropagation.rxjava;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+import net.javacrumbs.futureconverter.java8rx2.FutureConverter;\n+\n+import com.google.common.base.Splitter;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Iterables;\n+import com.google.common.util.concurrent.Uninterruptibles;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.AggregatedHttpResponse;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.server.HttpService;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.reactivex.Observable;\n+import io.reactivex.Single;\n+\n+public class MainService implements HttpService {\n+\n+    private static final Splitter NUM_SPLITTER = Splitter.on(',').trimResults().omitEmptyStrings();\n+\n+    private final WebClient backendClient;\n+\n+    public MainService(WebClient backendClient) {\n+        this.backendClient = requireNonNull(backendClient, \"backendClient\");\n+    }\n+\n+    @Override\n+    public HttpResponse serve(ServiceRequestContext ctx, HttpRequest req) {\n+        // This logic mimics using a blocking method, which would usually be something like a MySQL\n+        // database query using JDBC.\n+        final CompletableFuture<List<Long>> fetchFromFakeDb = CompletableFuture.supplyAsync(\n+                () -> {\n+                    // The context is mounted in a thread-local, meaning it is available to all logic such\n+                    // as tracing.\n+                    checkState(ServiceRequestContext.current() == ctx);\n+\n+                    Uninterruptibles.sleepUninterruptibly(Duration.ofMillis(50));\n+                    return ImmutableList.of(23L, -23L);\n+                },\n+                // Always run blocking logic on the blocking task executor. By using\n+                // ServiceRequestContext.blockingTaskExecutor, you also ensure the context is mounted inside the\n+                // logic (e.g., your DB call will be traced!).\n+                ctx.blockingTaskExecutor());\n+\n+        final Single<HttpResponse> response = FutureConverter\n+                .toSingle(req.aggregate())\n+                .flatMapObservable(request -> {\n+                    // The context is mounted in a thread-local, meaning it is available to all logic\n+                    // such as tracing.\n+                    checkState(ServiceRequestContext.current() == ctx);\n+\n+                    final List<Long> nums = new ArrayList<>();\n+                    for (String token : Iterables.concat(\n+                            NUM_SPLITTER.split(request.path().substring(1)),\n+                            NUM_SPLITTER.split(request.contentUtf8()))) {\n+                        nums.add(Long.parseLong(token));\n+                    }\n+\n+                    return Observable.fromIterable(nums);\n+                })\n+                .mergeWith(FutureConverter.toSingle(fetchFromFakeDb)\n+                                          .flatMapObservable(Observable::fromIterable))\n+                .flatMapSingle(num -> {\n+                    // The context is mounted in a thread-local, meaning it is available to all logic\n+                    // such as tracing.\n+                    checkState(ServiceRequestContext.current() == ctx);\n+\n+                    return FutureConverter.toSingle(backendClient.get(\"/square/\" + num).aggregate());\n+                })\n+                .map(AggregatedHttpResponse::contentUtf8)", "originalCommit": "ac5286aea75ee90739397f6e2d961c634c73f151", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDU3NTM4OA==", "url": "https://github.com/line/armeria/pull/2363#discussion_r364575388", "bodyText": "By the way, I was able to confirm that the pattern with subscribeOn instead of using RequestContextAssembly does not have the performance issue. The key point I guess is RequestContextSubscriber mounts on every call to onNext\nhttps://github.com/line/armeria/blob/master/rxjava/src/main/java/com/linecorp/armeria/common/rxjava/RequestContextSubscriber.java#L38\nwhich ends up being called from every single callback in the flow.\nSubscribing on the executor though mounts the context when the thread starts to process the flow, which ends up processing as many items as it can at the time. So if the buffer has 10 items, it will go through all 10 in a single invocation of the executor, meaning just a single threadlocal push/pop for 10 invocations of onNext.\nJust an observation, I think the assembly is still useful since it is quite nice for a single global method call to be able to guarantee callbacks have context, but we do have to be aware of the cost of the convenience.", "author": "anuraaga", "createdAt": "2020-01-09T06:24:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzIzMTg4Mw=="}], "type": "inlineReview"}, {"oid": "2cb89b8a3f18042571380b8dbf2b73b06eb9bb3d", "url": "https://github.com/line/armeria/commit/2cb89b8a3f18042571380b8dbf2b73b06eb9bb3d", "message": "More idiomatic?", "committedDate": "2020-01-06T10:21:59Z", "type": "commit"}, {"oid": "99cb82cd2e71e53ac353c72bb7c06ede9ff1648e", "url": "https://github.com/line/armeria/commit/99cb82cd2e71e53ac353c72bb7c06ede9ff1648e", "message": "More idiomatic", "committedDate": "2020-01-06T10:25:05Z", "type": "commit"}, {"oid": "a9d22a9ca24dcd386ec13ed6e08b963c82534cad", "url": "https://github.com/line/armeria/commit/a9d22a9ca24dcd386ec13ed6e08b963c82534cad", "message": "Add thread assertions", "committedDate": "2020-01-06T10:37:14Z", "type": "commit"}, {"oid": "10c61933509bf0397e60098d026c0df3f4621076", "url": "https://github.com/line/armeria/commit/10c61933509bf0397e60098d026c0df3f4621076", "message": "Manual subscription instead to stay on same thread.", "committedDate": "2020-01-06T10:58:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU3NjYzNw==", "url": "https://github.com/line/armeria/pull/2363#discussion_r363576637", "bodyText": "Maybe Flowable.concatEager is more suitable comapring to other example.", "author": "kojilin", "createdAt": "2020-01-07T03:16:12Z", "path": "examples/context-propagation/rxjava/src/main/java/example/armeria/contextpropagation/rxjava/MainService.java", "diffHunk": "@@ -0,0 +1,100 @@\n+package example.armeria.contextpropagation.rxjava;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import net.javacrumbs.futureconverter.java8rx2.FutureConverter;\n+\n+import com.google.common.base.Splitter;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Iterables;\n+import com.google.common.util.concurrent.Uninterruptibles;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.AggregatedHttpResponse;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.server.HttpService;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.reactivex.Observable;\n+import io.reactivex.Scheduler;\n+import io.reactivex.Single;\n+import io.reactivex.schedulers.Schedulers;\n+\n+public class MainService implements HttpService {\n+\n+    private static final Splitter NUM_SPLITTER = Splitter.on(',').trimResults().omitEmptyStrings();\n+\n+    private final WebClient backendClient;\n+\n+    public MainService(WebClient backendClient) {\n+        this.backendClient = requireNonNull(backendClient, \"backendClient\");\n+    }\n+\n+    @Override\n+    public HttpResponse serve(ServiceRequestContext ctx, HttpRequest req) {\n+        final Scheduler contextAwareScheduler = Schedulers.from(ctx.contextAwareExecutor());\n+\n+        // This logic mimics using a blocking method, which would usually be something like a MySQL\n+        // database query using JDBC.\n+        final Observable<Long> fetchFromFakeDb =\n+                Single.fromCallable(\n+                        () -> {\n+                            // The context is mounted in a thread-local, meaning it is available to all\n+                            // logic such as tracing.\n+                            checkState(ServiceRequestContext.current() == ctx);\n+                            checkState(!ctx.eventLoop().inEventLoop());\n+\n+                            Uninterruptibles.sleepUninterruptibly(Duration.ofMillis(50));\n+                            return ImmutableList.of(23L, -23L);\n+                        })\n+                      // Always run blocking logic on the blocking task executor. By using\n+                      // ServiceRequestContext.blockingTaskExecutor, you also ensure the context is mounted\n+                      // inside the logic (e.g., your DB call will be traced!).\n+                      .subscribeOn(Schedulers.from(ctx.blockingTaskExecutor()))\n+                      // Make sure callbacks still stay on the context executor using observeOn.\n+                      .observeOn(contextAwareScheduler)\n+                      .flattenAsObservable(l -> l);\n+\n+        final Single<HttpResponse> response = FutureConverter\n+                .toSingle(req.aggregate())\n+                // Unless you know what you're doing, always use subscribeOn with the context executor to have\n+                // the context mounted and stay on a single thread to reduce concurrency issues.\n+                .subscribeOn(contextAwareScheduler)\n+                .flatMapObservable(request -> {\n+                    // The context is mounted in a thread-local, meaning it is available to all logic\n+                    // such as tracing.\n+                    checkState(ServiceRequestContext.current() == ctx);\n+                    checkState(ctx.eventLoop().inEventLoop());\n+\n+                    final List<Long> nums = new ArrayList<>();\n+                    for (String token : Iterables.concat(\n+                            NUM_SPLITTER.split(request.path().substring(1)),\n+                            NUM_SPLITTER.split(request.contentUtf8()))) {\n+                        nums.add(Long.parseLong(token));\n+                    }\n+\n+                    return Observable.fromIterable(nums);\n+                })\n+                .mergeWith(fetchFromFakeDb)", "originalCommit": "10c61933509bf0397e60098d026c0df3f4621076", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU3Njc0Mw==", "url": "https://github.com/line/armeria/pull/2363#discussion_r363576743", "bodyText": "Maybe put at chaining phase?", "author": "kojilin", "createdAt": "2020-01-07T03:16:42Z", "path": "examples/context-propagation/rxjava/src/main/java/example/armeria/contextpropagation/rxjava/MainService.java", "diffHunk": "@@ -0,0 +1,100 @@\n+package example.armeria.contextpropagation.rxjava;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import net.javacrumbs.futureconverter.java8rx2.FutureConverter;\n+\n+import com.google.common.base.Splitter;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Iterables;\n+import com.google.common.util.concurrent.Uninterruptibles;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.AggregatedHttpResponse;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.server.HttpService;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.reactivex.Observable;\n+import io.reactivex.Scheduler;\n+import io.reactivex.Single;\n+import io.reactivex.schedulers.Schedulers;\n+\n+public class MainService implements HttpService {\n+\n+    private static final Splitter NUM_SPLITTER = Splitter.on(',').trimResults().omitEmptyStrings();\n+\n+    private final WebClient backendClient;\n+\n+    public MainService(WebClient backendClient) {\n+        this.backendClient = requireNonNull(backendClient, \"backendClient\");\n+    }\n+\n+    @Override\n+    public HttpResponse serve(ServiceRequestContext ctx, HttpRequest req) {\n+        final Scheduler contextAwareScheduler = Schedulers.from(ctx.contextAwareExecutor());\n+\n+        // This logic mimics using a blocking method, which would usually be something like a MySQL\n+        // database query using JDBC.\n+        final Observable<Long> fetchFromFakeDb =\n+                Single.fromCallable(\n+                        () -> {\n+                            // The context is mounted in a thread-local, meaning it is available to all\n+                            // logic such as tracing.\n+                            checkState(ServiceRequestContext.current() == ctx);\n+                            checkState(!ctx.eventLoop().inEventLoop());\n+\n+                            Uninterruptibles.sleepUninterruptibly(Duration.ofMillis(50));\n+                            return ImmutableList.of(23L, -23L);\n+                        })\n+                      // Always run blocking logic on the blocking task executor. By using\n+                      // ServiceRequestContext.blockingTaskExecutor, you also ensure the context is mounted\n+                      // inside the logic (e.g., your DB call will be traced!).\n+                      .subscribeOn(Schedulers.from(ctx.blockingTaskExecutor()))\n+                      // Make sure callbacks still stay on the context executor using observeOn.\n+                      .observeOn(contextAwareScheduler)", "originalCommit": "10c61933509bf0397e60098d026c0df3f4621076", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA2ODg0NQ==", "url": "https://github.com/line/armeria/pull/2363#discussion_r364068845", "bodyText": "Can you provide your reasoning for that? I can add as a comment and update :) I figured it's better to be here since the reason we need to observeOn is because of the blocking subscription, so having the two close to each other seems more readable.", "author": "anuraaga", "createdAt": "2020-01-08T05:27:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU3Njc0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA5OTg5MA==", "url": "https://github.com/line/armeria/pull/2363#discussion_r364099890", "bodyText": "I usually let storage call/remote call layer does not include subscribeOn&observeOn, I think they usually don't need to care about the trigger thread or ctx and we can reuse it in non armeria-context too.\nSo in my situation we force write all observeOn at service/facade layer and check when we code do code review....", "author": "kojilin", "createdAt": "2020-01-08T07:52:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU3Njc0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDU3MjgyMA==", "url": "https://github.com/line/armeria/pull/2363#discussion_r364572820", "bodyText": "Ok I think I sort of follow - I tried writing a comment to capture that hopefully it makes sense.", "author": "anuraaga", "createdAt": "2020-01-09T06:12:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU3Njc0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDU3MzQ2MA==", "url": "https://github.com/line/armeria/pull/2363#discussion_r364573460", "bodyText": "they usually don't need to care about the trigger thread or ctx\n\nAh though I guess I really don't understand this - trigger thread yes, but isn't storage / remote call layer exactly where they do have to care about ctx or tracing won't work?", "author": "anuraaga", "createdAt": "2020-01-09T06:15:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU3Njc0Mw=="}], "type": "inlineReview"}, {"oid": "23ab20ec713ad69cfbb3fd396842ab4f0ad232bf", "url": "https://github.com/line/armeria/commit/23ab20ec713ad69cfbb3fd396842ab4f0ad232bf", "message": "Merge branch 'master' of github.com:line/armeria into context-propagation-examples", "committedDate": "2020-01-08T05:15:15Z", "type": "commit"}, {"oid": "69581a8730e18db6cd005661db8eb7e978f031a4", "url": "https://github.com/line/armeria/commit/69581a8730e18db6cd005661db8eb7e978f031a4", "message": "Flowable", "committedDate": "2020-01-08T05:25:27Z", "type": "commit"}, {"oid": "3f0007ff9049dec695d71159a0bbb467b2271987", "url": "https://github.com/line/armeria/commit/3f0007ff9049dec695d71159a0bbb467b2271987", "message": "Move observeOn to composition layer.", "committedDate": "2020-01-09T06:11:52Z", "type": "commit"}]}