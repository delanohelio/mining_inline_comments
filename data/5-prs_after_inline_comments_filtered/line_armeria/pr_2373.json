{"pr_number": 2373, "pr_title": "Provide a consistent configuration to Armeria Dropwizard", "pr_createdAt": "2020-01-04T18:22:00Z", "pr_url": "https://github.com/line/armeria/pull/2373", "timeline": [{"oid": "5ea776cf5eec378e24aa4d7ce37a075573ddddcb", "url": "https://github.com/line/armeria/commit/5ea776cf5eec378e24aa4d7ce37a075573ddddcb", "message": "Provide a consistent configuration to Armeria Dropwizard\n\nMotivation:\nArmeria's Spring Boot auto configure module offers to customize the Armeria server from JSON YAML.\nDropwizard module has been added to Armeria by #2236. It can also customize Armeria Server from YAML.\nBut the configuration style is different.\nSometimes it may confuse the user.\n\nModification:\n* Apply Spring Boot's YAML convention to the Dropwizard module.\n* Add ArmeriaConfigurationUtil for applying ArmeriaSettings to\n* ServerBuilder.\n* Copy `CustomAliasKeyManagerFactory` and `CustomAliasX509ExtendedKeyManager` from\n `amreria/spring/boot-autoconfigure` to configure TLS fluenltly.\n* Add meter exporsition for `DropwizardMeterRegistry`\n* Remove unused configuration files.\n\nResult:\nProvide a consistent configuration to Armeria Dropwizard.", "committedDate": "2020-01-04T18:18:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzE3MTMyOA==", "url": "https://github.com/line/armeria/pull/2373#discussion_r363171328", "bodyText": "a-z seems rather broad, assuming just (kMGTP)?(Bb)", "author": "OneCricketeer", "createdAt": "2020-01-06T06:23:32Z", "path": "dropwizard/src/main/java/com/linecorp/armeria/dropwizard/ArmeriaConfigurationUtil.java", "diffHunk": "@@ -0,0 +1,512 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.dropwizard;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.security.GeneralSecurityException;\n+import java.security.KeyStore;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.function.Supplier;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.annotation.Nullable;\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.codahale.metrics.MetricRegistry;\n+import com.codahale.metrics.json.MetricsModule;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n+import com.google.common.base.Ascii;\n+import com.google.common.base.Strings;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.math.LongMath;\n+\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.common.metric.DropwizardMeterRegistries;\n+import com.linecorp.armeria.dropwizard.ArmeriaSettings.AccessLog;\n+import com.linecorp.armeria.dropwizard.ArmeriaSettings.Compression;\n+import com.linecorp.armeria.dropwizard.ArmeriaSettings.Http1;\n+import com.linecorp.armeria.dropwizard.ArmeriaSettings.Http2;\n+import com.linecorp.armeria.dropwizard.ArmeriaSettings.Port;\n+import com.linecorp.armeria.dropwizard.ArmeriaSettings.Proxy;\n+import com.linecorp.armeria.server.HttpService;\n+import com.linecorp.armeria.server.ServerBuilder;\n+import com.linecorp.armeria.server.ServerPort;\n+import com.linecorp.armeria.server.encoding.EncodingService;\n+import com.linecorp.armeria.server.logging.AccessLogWriter;\n+\n+import io.micrometer.core.instrument.dropwizard.DropwizardMeterRegistry;\n+import io.netty.handler.ssl.ClientAuth;\n+import io.netty.handler.ssl.SslProvider;\n+import io.netty.handler.ssl.SupportedCipherSuiteFilter;\n+import io.netty.util.NetUtil;\n+\n+/**\n+ * A utility class which is used to configure a {@link ServerBuilder} with the {@link ArmeriaSettings}.\n+ */\n+final class ArmeriaConfigurationUtil {\n+    private static final Logger logger = LoggerFactory.getLogger(ArmeriaConfigurationUtil.class);\n+\n+    private static final String[] EMPTY_PROTOCOL_NAMES = new String[0];\n+\n+    private static final Port DEFAULT_PORT = new Port().setPort(8080)\n+                                                       .setProtocol(SessionProtocol.HTTP);\n+    /**\n+     * The pattern for data size text.\n+     */\n+    private static final Pattern DATA_SIZE_PATTERN = Pattern.compile(\"^([+]?\\\\d+)([a-zA-Z]{0,2})$\");", "originalCommit": "5ea776cf5eec378e24aa4d7ce37a075573ddddcb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzE3MTY2OQ==", "url": "https://github.com/line/armeria/pull/2373#discussion_r363171669", "bodyText": "Simplify with Math.pow?", "author": "OneCricketeer", "createdAt": "2020-01-06T06:25:32Z", "path": "dropwizard/src/main/java/com/linecorp/armeria/dropwizard/ArmeriaConfigurationUtil.java", "diffHunk": "@@ -0,0 +1,512 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.dropwizard;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.security.GeneralSecurityException;\n+import java.security.KeyStore;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.function.Supplier;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.annotation.Nullable;\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.codahale.metrics.MetricRegistry;\n+import com.codahale.metrics.json.MetricsModule;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n+import com.google.common.base.Ascii;\n+import com.google.common.base.Strings;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.math.LongMath;\n+\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.common.metric.DropwizardMeterRegistries;\n+import com.linecorp.armeria.dropwizard.ArmeriaSettings.AccessLog;\n+import com.linecorp.armeria.dropwizard.ArmeriaSettings.Compression;\n+import com.linecorp.armeria.dropwizard.ArmeriaSettings.Http1;\n+import com.linecorp.armeria.dropwizard.ArmeriaSettings.Http2;\n+import com.linecorp.armeria.dropwizard.ArmeriaSettings.Port;\n+import com.linecorp.armeria.dropwizard.ArmeriaSettings.Proxy;\n+import com.linecorp.armeria.server.HttpService;\n+import com.linecorp.armeria.server.ServerBuilder;\n+import com.linecorp.armeria.server.ServerPort;\n+import com.linecorp.armeria.server.encoding.EncodingService;\n+import com.linecorp.armeria.server.logging.AccessLogWriter;\n+\n+import io.micrometer.core.instrument.dropwizard.DropwizardMeterRegistry;\n+import io.netty.handler.ssl.ClientAuth;\n+import io.netty.handler.ssl.SslProvider;\n+import io.netty.handler.ssl.SupportedCipherSuiteFilter;\n+import io.netty.util.NetUtil;\n+\n+/**\n+ * A utility class which is used to configure a {@link ServerBuilder} with the {@link ArmeriaSettings}.\n+ */\n+final class ArmeriaConfigurationUtil {\n+    private static final Logger logger = LoggerFactory.getLogger(ArmeriaConfigurationUtil.class);\n+\n+    private static final String[] EMPTY_PROTOCOL_NAMES = new String[0];\n+\n+    private static final Port DEFAULT_PORT = new Port().setPort(8080)\n+                                                       .setProtocol(SessionProtocol.HTTP);\n+    /**\n+     * The pattern for data size text.\n+     */\n+    private static final Pattern DATA_SIZE_PATTERN = Pattern.compile(\"^([+]?\\\\d+)([a-zA-Z]{0,2})$\");\n+\n+    /**\n+     * Sets graceful shutdown timeout, health check services and for the specified\n+     * {@link ServerBuilder}.\n+     */\n+    public static void configureServer(ServerBuilder serverBuilder, ArmeriaSettings settings,\n+                                       MetricRegistry meterRegistry) {\n+        requireNonNull(serverBuilder, \"serverBuilder\");\n+        requireNonNull(settings, \"settings\");\n+        requireNonNull(meterRegistry, \"meterRegistry\");\n+\n+        if (settings.getGracefulShutdownQuietPeriodMillis() >= 0 &&\n+            settings.getGracefulShutdownTimeoutMillis() >= 0) {\n+            serverBuilder.gracefulShutdownTimeout(settings.getGracefulShutdownQuietPeriodMillis(),\n+                                                  settings.getGracefulShutdownTimeoutMillis());\n+            logger.debug(\"Set graceful shutdown timeout: quiet period {} ms, timeout {} ms\",\n+                         settings.getGracefulShutdownQuietPeriodMillis(),\n+                         settings.getGracefulShutdownTimeoutMillis());\n+        }\n+        if (settings.getMaxRequestLength() != null) {\n+            serverBuilder.maxRequestLength(settings.getMaxRequestLength());\n+        }\n+        if (settings.getMaxNumConnections() != null) {\n+            serverBuilder.maxNumConnections(settings.getMaxNumConnections());\n+        }\n+        if (!settings.isDateHeaderEnabled()) {\n+            serverBuilder.disableDateHeader();\n+        }\n+        if (!settings.isServerHeaderEnabled()) {\n+            serverBuilder.disableServerHeader();\n+        }\n+        if (settings.getDefaultHostname() != null) {\n+            serverBuilder.defaultHostname(settings.getDefaultHostname());\n+        }\n+        if (settings.isVerboseResponses()) {\n+            serverBuilder.verboseResponses(true);\n+        }\n+\n+        if (settings.getPorts().isEmpty()) {\n+            serverBuilder.port(new ServerPort(DEFAULT_PORT.getPort(), DEFAULT_PORT.getProtocols()));\n+        } else {\n+            configurePorts(serverBuilder, settings.getPorts());\n+        }\n+\n+        final DropwizardMeterRegistry dropwizardMeterRegistry =\n+                DropwizardMeterRegistries.newRegistry(meterRegistry);\n+        serverBuilder.meterRegistry(dropwizardMeterRegistry);\n+        if (settings.getMetricsPath() != null) {\n+            addExposition(serverBuilder, settings.getMetricsPath(), dropwizardMeterRegistry);\n+        }\n+\n+        if (settings.getSsl() != null) {\n+            configureTls(serverBuilder, settings.getSsl());\n+        }\n+        if (settings.getCompression() != null) {\n+            configureCompression(serverBuilder, settings.getCompression());\n+        }\n+        if (settings.getHttp1() != null) {\n+            configureHttp1(serverBuilder, settings.getHttp1());\n+        }\n+        if (settings.getHttp2() != null) {\n+            configureHttp2(serverBuilder, settings.getHttp2());\n+        }\n+        if (settings.getProxy() != null) {\n+            configureProxy(serverBuilder, settings.getProxy());\n+        }\n+        if (settings.getAccessLog() != null) {\n+            configureAccessLog(serverBuilder, settings.getAccessLog());\n+        }\n+    }\n+\n+    /**\n+     * Adds {@link Port}s to the specified {@link ServerBuilder}.\n+     */\n+    private static void configurePorts(ServerBuilder server, List<Port> ports) {\n+        requireNonNull(server, \"server\");\n+        requireNonNull(ports, \"ports\");\n+        ports.forEach(p -> {\n+            final String ip = p.getIp();\n+            final String iface = p.getIface();\n+            final int port = p.getPort();\n+            final List<SessionProtocol> protocols = firstNonNull(p.getProtocols(),\n+                                                                 ImmutableList.of(SessionProtocol.HTTP));\n+\n+            if (ip == null) {\n+                if (iface == null) {\n+                    server.port(new ServerPort(port, protocols));\n+                } else {\n+                    try {\n+                        final Enumeration<InetAddress> e = NetworkInterface.getByName(iface).getInetAddresses();\n+                        while (e.hasMoreElements()) {\n+                            server.port(new ServerPort(new InetSocketAddress(e.nextElement(), port),\n+                                                       protocols));\n+                        }\n+                    } catch (SocketException e) {\n+                        throw new IllegalStateException(\"Failed to find an iface: \" + iface, e);\n+                    }\n+                }\n+            } else if (iface == null) {\n+                if (NetUtil.isValidIpV4Address(ip) || NetUtil.isValidIpV6Address(ip)) {\n+                    final byte[] bytes = NetUtil.createByteArrayFromIpAddressString(ip);\n+                    try {\n+                        server.port(new ServerPort(new InetSocketAddress(\n+                                InetAddress.getByAddress(bytes), port), protocols));\n+                    } catch (UnknownHostException e) {\n+                        // Should never happen.\n+                        throw new Error(e);\n+                    }\n+                } else {\n+                    throw new IllegalStateException(\"invalid IP address: \" + ip);\n+                }\n+            } else {\n+                throw new IllegalStateException(\"A port cannot have both IP and iface: \" + p);\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Adds SSL/TLS context to the specified {@link ServerBuilder}.\n+     */\n+    private static void configureTls(ServerBuilder sb, ArmeriaSettings.Ssl ssl) {\n+        configureTls(sb, ssl, null, null);\n+    }\n+\n+    /**\n+     * Adds SSL/TLS context to the specified {@link ServerBuilder}.\n+     */\n+    private static void configureTls(ServerBuilder sb, ArmeriaSettings.Ssl ssl,\n+                                     @Nullable Supplier<KeyStore> keyStoreSupplier,\n+                                     @Nullable Supplier<KeyStore> trustStoreSupplier) {\n+        if (!ssl.isEnabled()) {\n+            return;\n+        }\n+        try {\n+            if (keyStoreSupplier == null && trustStoreSupplier == null &&\n+                ssl.getKeyStore() == null && ssl.getTrustStore() == null) {\n+                logger.warn(\"Configuring TLS with a self-signed certificate \" +\n+                            \"because no key or trust store was specified\");\n+                sb.tlsSelfSigned();\n+                return;\n+            }\n+\n+            final KeyManagerFactory keyManagerFactory = getKeyManagerFactory(ssl, keyStoreSupplier);\n+            final TrustManagerFactory trustManagerFactory = getTrustManagerFactory(ssl, trustStoreSupplier);\n+\n+            sb.tls(keyManagerFactory);\n+            sb.tlsCustomizer(sslContextBuilder -> {\n+                sslContextBuilder.trustManager(trustManagerFactory);\n+\n+                final SslProvider sslProvider = ssl.getProvider();\n+                if (sslProvider != null) {\n+                    sslContextBuilder.sslProvider(sslProvider);\n+                }\n+                final List<String> enabledProtocols = ssl.getEnabledProtocols();\n+                if (enabledProtocols != null) {\n+                    sslContextBuilder.protocols(enabledProtocols.toArray(EMPTY_PROTOCOL_NAMES));\n+                }\n+                final List<String> ciphers = ssl.getCiphers();\n+                if (ciphers != null) {\n+                    sslContextBuilder.ciphers(ImmutableList.copyOf(ciphers),\n+                                              SupportedCipherSuiteFilter.INSTANCE);\n+                }\n+                final ClientAuth clientAuth = ssl.getClientAuth();\n+                if (clientAuth != null) {\n+                    sslContextBuilder.clientAuth(clientAuth);\n+                }\n+            });\n+        } catch (Exception e) {\n+            throw new IllegalStateException(\"Failed to configure TLS: \" + e, e);\n+        }\n+    }\n+\n+    private static KeyManagerFactory getKeyManagerFactory(\n+            ArmeriaSettings.Ssl ssl, @Nullable Supplier<KeyStore> sslStoreProvider) throws Exception {\n+        final KeyStore store;\n+        if (sslStoreProvider != null) {\n+            store = sslStoreProvider.get();\n+        } else {\n+            store = loadKeyStore(ssl.getKeyStoreType(), ssl.getKeyStore(), ssl.getKeyStorePassword());\n+        }\n+\n+        KeyManagerFactory keyManagerFactory =\n+                KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n+        if (ssl.getKeyAlias() != null) {\n+            keyManagerFactory = new CustomAliasKeyManagerFactory(keyManagerFactory, ssl.getKeyAlias());\n+        }\n+\n+        String keyPassword = ssl.getKeyPassword();\n+        if (keyPassword == null) {\n+            keyPassword = ssl.getKeyStorePassword();\n+        }\n+\n+        keyManagerFactory.init(store, keyPassword != null ? keyPassword.toCharArray()\n+                                                          : null);\n+        return keyManagerFactory;\n+    }\n+\n+    private static TrustManagerFactory getTrustManagerFactory(\n+            ArmeriaSettings.Ssl ssl, @Nullable Supplier<KeyStore> sslStoreProvider) throws Exception {\n+        final KeyStore store;\n+        if (sslStoreProvider != null) {\n+            store = sslStoreProvider.get();\n+        } else {\n+            store = loadKeyStore(ssl.getTrustStoreType(), ssl.getTrustStore(), ssl.getTrustStorePassword());\n+        }\n+\n+        final TrustManagerFactory trustManagerFactory =\n+                TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n+        trustManagerFactory.init(store);\n+        return trustManagerFactory;\n+    }\n+\n+    @Nullable\n+    private static KeyStore loadKeyStore(\n+            @Nullable String type,\n+            @Nullable String resource,\n+            @Nullable String password) throws IOException, GeneralSecurityException {\n+        if (resource == null) {\n+            return null;\n+        }\n+        final KeyStore store = KeyStore.getInstance(firstNonNull(type, \"JKS\"));\n+        final URL url = getURL(resource);\n+        store.load(url.openStream(), password != null ? password.toCharArray()\n+                                                      : null);\n+        return store;\n+    }\n+\n+    /**\n+     * Configures a decorator for encoding the content of the HTTP responses sent from the server.\n+     */\n+    private static Function<? super HttpService, EncodingService> contentEncodingDecorator(\n+            @Nullable String[] mimeTypes, @Nullable String[] excludedUserAgents,\n+            long minBytesToForceChunkedAndEncoding) {\n+        final Predicate<MediaType> encodableContentTypePredicate;\n+        if (mimeTypes == null || mimeTypes.length == 0) {\n+            encodableContentTypePredicate = contentType -> true;\n+        } else {\n+            final List<MediaType> encodableContentTypes =\n+                    Arrays.stream(mimeTypes).map(MediaType::parse).collect(toImmutableList());\n+            encodableContentTypePredicate = contentType ->\n+                    encodableContentTypes.stream().anyMatch(contentType::is);\n+        }\n+\n+        final Predicate<HttpHeaders> encodableRequestHeadersPredicate;\n+        if (excludedUserAgents == null || excludedUserAgents.length == 0) {\n+            encodableRequestHeadersPredicate = headers -> true;\n+        } else {\n+            final List<Pattern> patterns =\n+                    Arrays.stream(excludedUserAgents).map(Pattern::compile).collect(toImmutableList());\n+            encodableRequestHeadersPredicate = headers -> {\n+                // No User-Agent header will be converted to an empty string.\n+                final String userAgent = headers.get(HttpHeaderNames.USER_AGENT, \"\");\n+                return patterns.stream().noneMatch(pattern -> pattern.matcher(userAgent).matches());\n+            };\n+        }\n+\n+        return delegate -> new EncodingService(delegate,\n+                                               encodableContentTypePredicate,\n+                                               encodableRequestHeadersPredicate,\n+                                               minBytesToForceChunkedAndEncoding);\n+    }\n+\n+    /**\n+     * Parses the data size text as a decimal {@code long}.\n+     *\n+     * @param dataSizeText the data size text, i.e. {@code 1}, {@code 1B}, {@code 1KB}, {@code 1MB},\n+     *                     {@code 1GB} or {@code 1TB}\n+     */\n+    private static long parseDataSize(String dataSizeText) {\n+        requireNonNull(dataSizeText, \"text\");\n+        final Matcher matcher = DATA_SIZE_PATTERN.matcher(dataSizeText);\n+        checkArgument(matcher.matches(),\n+                      \"Invalid data size text: %s (expected: %s)\",\n+                      dataSizeText, DATA_SIZE_PATTERN);\n+\n+        final long unit;\n+        final String unitText = matcher.group(2);\n+        if (Strings.isNullOrEmpty(unitText)) {\n+            unit = 1L;\n+        } else {\n+            switch (Ascii.toLowerCase(unitText)) {\n+                case \"b\":\n+                    unit = 1L;\n+                    break;\n+                case \"kb\":\n+                    unit = 1024L;\n+                    break;\n+                case \"mb\":\n+                    unit = 1024L * 1024L;\n+                    break;\n+                case \"gb\":\n+                    unit = 1024L * 1024L * 1024L;\n+                    break;\n+                case \"tb\":\n+                    unit = 1024L * 1024L * 1024L * 1024L;", "originalCommit": "5ea776cf5eec378e24aa4d7ce37a075573ddddcb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzE3MjEyMA==", "url": "https://github.com/line/armeria/pull/2373#discussion_r363172120", "bodyText": "Dropwizard has a resources class for something like this\nhttps://github.com/dropwizard/dropwizard/blob/master/dropwizard-util/src/main/java/io/dropwizard/util/Resources.java#L29", "author": "OneCricketeer", "createdAt": "2020-01-06T06:28:06Z", "path": "dropwizard/src/main/java/com/linecorp/armeria/dropwizard/ArmeriaConfigurationUtil.java", "diffHunk": "@@ -0,0 +1,512 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.dropwizard;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.security.GeneralSecurityException;\n+import java.security.KeyStore;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.function.Supplier;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.annotation.Nullable;\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.codahale.metrics.MetricRegistry;\n+import com.codahale.metrics.json.MetricsModule;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n+import com.google.common.base.Ascii;\n+import com.google.common.base.Strings;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.math.LongMath;\n+\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.common.metric.DropwizardMeterRegistries;\n+import com.linecorp.armeria.dropwizard.ArmeriaSettings.AccessLog;\n+import com.linecorp.armeria.dropwizard.ArmeriaSettings.Compression;\n+import com.linecorp.armeria.dropwizard.ArmeriaSettings.Http1;\n+import com.linecorp.armeria.dropwizard.ArmeriaSettings.Http2;\n+import com.linecorp.armeria.dropwizard.ArmeriaSettings.Port;\n+import com.linecorp.armeria.dropwizard.ArmeriaSettings.Proxy;\n+import com.linecorp.armeria.server.HttpService;\n+import com.linecorp.armeria.server.ServerBuilder;\n+import com.linecorp.armeria.server.ServerPort;\n+import com.linecorp.armeria.server.encoding.EncodingService;\n+import com.linecorp.armeria.server.logging.AccessLogWriter;\n+\n+import io.micrometer.core.instrument.dropwizard.DropwizardMeterRegistry;\n+import io.netty.handler.ssl.ClientAuth;\n+import io.netty.handler.ssl.SslProvider;\n+import io.netty.handler.ssl.SupportedCipherSuiteFilter;\n+import io.netty.util.NetUtil;\n+\n+/**\n+ * A utility class which is used to configure a {@link ServerBuilder} with the {@link ArmeriaSettings}.\n+ */\n+final class ArmeriaConfigurationUtil {\n+    private static final Logger logger = LoggerFactory.getLogger(ArmeriaConfigurationUtil.class);\n+\n+    private static final String[] EMPTY_PROTOCOL_NAMES = new String[0];\n+\n+    private static final Port DEFAULT_PORT = new Port().setPort(8080)\n+                                                       .setProtocol(SessionProtocol.HTTP);\n+    /**\n+     * The pattern for data size text.\n+     */\n+    private static final Pattern DATA_SIZE_PATTERN = Pattern.compile(\"^([+]?\\\\d+)([a-zA-Z]{0,2})$\");\n+\n+    /**\n+     * Sets graceful shutdown timeout, health check services and for the specified\n+     * {@link ServerBuilder}.\n+     */\n+    public static void configureServer(ServerBuilder serverBuilder, ArmeriaSettings settings,\n+                                       MetricRegistry meterRegistry) {\n+        requireNonNull(serverBuilder, \"serverBuilder\");\n+        requireNonNull(settings, \"settings\");\n+        requireNonNull(meterRegistry, \"meterRegistry\");\n+\n+        if (settings.getGracefulShutdownQuietPeriodMillis() >= 0 &&\n+            settings.getGracefulShutdownTimeoutMillis() >= 0) {\n+            serverBuilder.gracefulShutdownTimeout(settings.getGracefulShutdownQuietPeriodMillis(),\n+                                                  settings.getGracefulShutdownTimeoutMillis());\n+            logger.debug(\"Set graceful shutdown timeout: quiet period {} ms, timeout {} ms\",\n+                         settings.getGracefulShutdownQuietPeriodMillis(),\n+                         settings.getGracefulShutdownTimeoutMillis());\n+        }\n+        if (settings.getMaxRequestLength() != null) {\n+            serverBuilder.maxRequestLength(settings.getMaxRequestLength());\n+        }\n+        if (settings.getMaxNumConnections() != null) {\n+            serverBuilder.maxNumConnections(settings.getMaxNumConnections());\n+        }\n+        if (!settings.isDateHeaderEnabled()) {\n+            serverBuilder.disableDateHeader();\n+        }\n+        if (!settings.isServerHeaderEnabled()) {\n+            serverBuilder.disableServerHeader();\n+        }\n+        if (settings.getDefaultHostname() != null) {\n+            serverBuilder.defaultHostname(settings.getDefaultHostname());\n+        }\n+        if (settings.isVerboseResponses()) {\n+            serverBuilder.verboseResponses(true);\n+        }\n+\n+        if (settings.getPorts().isEmpty()) {\n+            serverBuilder.port(new ServerPort(DEFAULT_PORT.getPort(), DEFAULT_PORT.getProtocols()));\n+        } else {\n+            configurePorts(serverBuilder, settings.getPorts());\n+        }\n+\n+        final DropwizardMeterRegistry dropwizardMeterRegistry =\n+                DropwizardMeterRegistries.newRegistry(meterRegistry);\n+        serverBuilder.meterRegistry(dropwizardMeterRegistry);\n+        if (settings.getMetricsPath() != null) {\n+            addExposition(serverBuilder, settings.getMetricsPath(), dropwizardMeterRegistry);\n+        }\n+\n+        if (settings.getSsl() != null) {\n+            configureTls(serverBuilder, settings.getSsl());\n+        }\n+        if (settings.getCompression() != null) {\n+            configureCompression(serverBuilder, settings.getCompression());\n+        }\n+        if (settings.getHttp1() != null) {\n+            configureHttp1(serverBuilder, settings.getHttp1());\n+        }\n+        if (settings.getHttp2() != null) {\n+            configureHttp2(serverBuilder, settings.getHttp2());\n+        }\n+        if (settings.getProxy() != null) {\n+            configureProxy(serverBuilder, settings.getProxy());\n+        }\n+        if (settings.getAccessLog() != null) {\n+            configureAccessLog(serverBuilder, settings.getAccessLog());\n+        }\n+    }\n+\n+    /**\n+     * Adds {@link Port}s to the specified {@link ServerBuilder}.\n+     */\n+    private static void configurePorts(ServerBuilder server, List<Port> ports) {\n+        requireNonNull(server, \"server\");\n+        requireNonNull(ports, \"ports\");\n+        ports.forEach(p -> {\n+            final String ip = p.getIp();\n+            final String iface = p.getIface();\n+            final int port = p.getPort();\n+            final List<SessionProtocol> protocols = firstNonNull(p.getProtocols(),\n+                                                                 ImmutableList.of(SessionProtocol.HTTP));\n+\n+            if (ip == null) {\n+                if (iface == null) {\n+                    server.port(new ServerPort(port, protocols));\n+                } else {\n+                    try {\n+                        final Enumeration<InetAddress> e = NetworkInterface.getByName(iface).getInetAddresses();\n+                        while (e.hasMoreElements()) {\n+                            server.port(new ServerPort(new InetSocketAddress(e.nextElement(), port),\n+                                                       protocols));\n+                        }\n+                    } catch (SocketException e) {\n+                        throw new IllegalStateException(\"Failed to find an iface: \" + iface, e);\n+                    }\n+                }\n+            } else if (iface == null) {\n+                if (NetUtil.isValidIpV4Address(ip) || NetUtil.isValidIpV6Address(ip)) {\n+                    final byte[] bytes = NetUtil.createByteArrayFromIpAddressString(ip);\n+                    try {\n+                        server.port(new ServerPort(new InetSocketAddress(\n+                                InetAddress.getByAddress(bytes), port), protocols));\n+                    } catch (UnknownHostException e) {\n+                        // Should never happen.\n+                        throw new Error(e);\n+                    }\n+                } else {\n+                    throw new IllegalStateException(\"invalid IP address: \" + ip);\n+                }\n+            } else {\n+                throw new IllegalStateException(\"A port cannot have both IP and iface: \" + p);\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Adds SSL/TLS context to the specified {@link ServerBuilder}.\n+     */\n+    private static void configureTls(ServerBuilder sb, ArmeriaSettings.Ssl ssl) {\n+        configureTls(sb, ssl, null, null);\n+    }\n+\n+    /**\n+     * Adds SSL/TLS context to the specified {@link ServerBuilder}.\n+     */\n+    private static void configureTls(ServerBuilder sb, ArmeriaSettings.Ssl ssl,\n+                                     @Nullable Supplier<KeyStore> keyStoreSupplier,\n+                                     @Nullable Supplier<KeyStore> trustStoreSupplier) {\n+        if (!ssl.isEnabled()) {\n+            return;\n+        }\n+        try {\n+            if (keyStoreSupplier == null && trustStoreSupplier == null &&\n+                ssl.getKeyStore() == null && ssl.getTrustStore() == null) {\n+                logger.warn(\"Configuring TLS with a self-signed certificate \" +\n+                            \"because no key or trust store was specified\");\n+                sb.tlsSelfSigned();\n+                return;\n+            }\n+\n+            final KeyManagerFactory keyManagerFactory = getKeyManagerFactory(ssl, keyStoreSupplier);\n+            final TrustManagerFactory trustManagerFactory = getTrustManagerFactory(ssl, trustStoreSupplier);\n+\n+            sb.tls(keyManagerFactory);\n+            sb.tlsCustomizer(sslContextBuilder -> {\n+                sslContextBuilder.trustManager(trustManagerFactory);\n+\n+                final SslProvider sslProvider = ssl.getProvider();\n+                if (sslProvider != null) {\n+                    sslContextBuilder.sslProvider(sslProvider);\n+                }\n+                final List<String> enabledProtocols = ssl.getEnabledProtocols();\n+                if (enabledProtocols != null) {\n+                    sslContextBuilder.protocols(enabledProtocols.toArray(EMPTY_PROTOCOL_NAMES));\n+                }\n+                final List<String> ciphers = ssl.getCiphers();\n+                if (ciphers != null) {\n+                    sslContextBuilder.ciphers(ImmutableList.copyOf(ciphers),\n+                                              SupportedCipherSuiteFilter.INSTANCE);\n+                }\n+                final ClientAuth clientAuth = ssl.getClientAuth();\n+                if (clientAuth != null) {\n+                    sslContextBuilder.clientAuth(clientAuth);\n+                }\n+            });\n+        } catch (Exception e) {\n+            throw new IllegalStateException(\"Failed to configure TLS: \" + e, e);\n+        }\n+    }\n+\n+    private static KeyManagerFactory getKeyManagerFactory(\n+            ArmeriaSettings.Ssl ssl, @Nullable Supplier<KeyStore> sslStoreProvider) throws Exception {\n+        final KeyStore store;\n+        if (sslStoreProvider != null) {\n+            store = sslStoreProvider.get();\n+        } else {\n+            store = loadKeyStore(ssl.getKeyStoreType(), ssl.getKeyStore(), ssl.getKeyStorePassword());\n+        }\n+\n+        KeyManagerFactory keyManagerFactory =\n+                KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n+        if (ssl.getKeyAlias() != null) {\n+            keyManagerFactory = new CustomAliasKeyManagerFactory(keyManagerFactory, ssl.getKeyAlias());\n+        }\n+\n+        String keyPassword = ssl.getKeyPassword();\n+        if (keyPassword == null) {\n+            keyPassword = ssl.getKeyStorePassword();\n+        }\n+\n+        keyManagerFactory.init(store, keyPassword != null ? keyPassword.toCharArray()\n+                                                          : null);\n+        return keyManagerFactory;\n+    }\n+\n+    private static TrustManagerFactory getTrustManagerFactory(\n+            ArmeriaSettings.Ssl ssl, @Nullable Supplier<KeyStore> sslStoreProvider) throws Exception {\n+        final KeyStore store;\n+        if (sslStoreProvider != null) {\n+            store = sslStoreProvider.get();\n+        } else {\n+            store = loadKeyStore(ssl.getTrustStoreType(), ssl.getTrustStore(), ssl.getTrustStorePassword());\n+        }\n+\n+        final TrustManagerFactory trustManagerFactory =\n+                TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n+        trustManagerFactory.init(store);\n+        return trustManagerFactory;\n+    }\n+\n+    @Nullable\n+    private static KeyStore loadKeyStore(\n+            @Nullable String type,\n+            @Nullable String resource,\n+            @Nullable String password) throws IOException, GeneralSecurityException {\n+        if (resource == null) {\n+            return null;\n+        }\n+        final KeyStore store = KeyStore.getInstance(firstNonNull(type, \"JKS\"));\n+        final URL url = getURL(resource);\n+        store.load(url.openStream(), password != null ? password.toCharArray()\n+                                                      : null);\n+        return store;\n+    }\n+\n+    /**\n+     * Configures a decorator for encoding the content of the HTTP responses sent from the server.\n+     */\n+    private static Function<? super HttpService, EncodingService> contentEncodingDecorator(\n+            @Nullable String[] mimeTypes, @Nullable String[] excludedUserAgents,\n+            long minBytesToForceChunkedAndEncoding) {\n+        final Predicate<MediaType> encodableContentTypePredicate;\n+        if (mimeTypes == null || mimeTypes.length == 0) {\n+            encodableContentTypePredicate = contentType -> true;\n+        } else {\n+            final List<MediaType> encodableContentTypes =\n+                    Arrays.stream(mimeTypes).map(MediaType::parse).collect(toImmutableList());\n+            encodableContentTypePredicate = contentType ->\n+                    encodableContentTypes.stream().anyMatch(contentType::is);\n+        }\n+\n+        final Predicate<HttpHeaders> encodableRequestHeadersPredicate;\n+        if (excludedUserAgents == null || excludedUserAgents.length == 0) {\n+            encodableRequestHeadersPredicate = headers -> true;\n+        } else {\n+            final List<Pattern> patterns =\n+                    Arrays.stream(excludedUserAgents).map(Pattern::compile).collect(toImmutableList());\n+            encodableRequestHeadersPredicate = headers -> {\n+                // No User-Agent header will be converted to an empty string.\n+                final String userAgent = headers.get(HttpHeaderNames.USER_AGENT, \"\");\n+                return patterns.stream().noneMatch(pattern -> pattern.matcher(userAgent).matches());\n+            };\n+        }\n+\n+        return delegate -> new EncodingService(delegate,\n+                                               encodableContentTypePredicate,\n+                                               encodableRequestHeadersPredicate,\n+                                               minBytesToForceChunkedAndEncoding);\n+    }\n+\n+    /**\n+     * Parses the data size text as a decimal {@code long}.\n+     *\n+     * @param dataSizeText the data size text, i.e. {@code 1}, {@code 1B}, {@code 1KB}, {@code 1MB},\n+     *                     {@code 1GB} or {@code 1TB}\n+     */\n+    private static long parseDataSize(String dataSizeText) {\n+        requireNonNull(dataSizeText, \"text\");\n+        final Matcher matcher = DATA_SIZE_PATTERN.matcher(dataSizeText);\n+        checkArgument(matcher.matches(),\n+                      \"Invalid data size text: %s (expected: %s)\",\n+                      dataSizeText, DATA_SIZE_PATTERN);\n+\n+        final long unit;\n+        final String unitText = matcher.group(2);\n+        if (Strings.isNullOrEmpty(unitText)) {\n+            unit = 1L;\n+        } else {\n+            switch (Ascii.toLowerCase(unitText)) {\n+                case \"b\":\n+                    unit = 1L;\n+                    break;\n+                case \"kb\":\n+                    unit = 1024L;\n+                    break;\n+                case \"mb\":\n+                    unit = 1024L * 1024L;\n+                    break;\n+                case \"gb\":\n+                    unit = 1024L * 1024L * 1024L;\n+                    break;\n+                case \"tb\":\n+                    unit = 1024L * 1024L * 1024L * 1024L;\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Invalid data size text: \" + dataSizeText +\n+                                                       \" (expected: \" + DATA_SIZE_PATTERN + ')');\n+            }\n+        }\n+        try {\n+            final long amount = Long.parseLong(matcher.group(1));\n+            return LongMath.checkedMultiply(amount, unit);\n+        } catch (Exception e) {\n+            throw new IllegalArgumentException(\"Invalid data size text: \" + dataSizeText +\n+                                               \" (expected: \" + DATA_SIZE_PATTERN + ')', e);\n+        }\n+    }\n+\n+    /**\n+     * Resolves the given resource location to a {@link URL}.\n+     *\n+     * <p>Does not check whether the URL actually exists; simply returns\n+     * the URL that the given location would correspond to.\n+     *\n+     * @param resourceLocation the resource location to resolve: either a\n+     *                         \"classpath:\" pseudo URL, a \"file:\" URL, or a plain file path\n+     * @return a corresponding URL object\n+     * @throws FileNotFoundException if the resource cannot be resolved to a URL\n+     */\n+    private static URL getURL(String resourceLocation) throws FileNotFoundException {\n+        // Forked from Spring 5.2.2\n+        // https://github.com/spring-projects/spring-framework/blob/22a888b53df620b0905ce8beb6b0cf71981086d8/spring-core/src/main/java/org/springframework/util/ResourceUtils.java#L129\n+        if (resourceLocation.startsWith(\"classpath:\")) {\n+            final String path = resourceLocation.substring(\"classpath:\".length());\n+            final URL resource = ArmeriaConfigurationUtil.class.getClassLoader().getResource(path);\n+            if (resource == null) {", "originalCommit": "5ea776cf5eec378e24aa4d7ce37a075573ddddcb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzIwMTY0Mg==", "url": "https://github.com/line/armeria/pull/2373#discussion_r363201642", "bodyText": "That is a nice suggestion. But I do not want Dropwizard dependency here because of the future refactoring( #2373 (comment))", "author": "ikhoon", "createdAt": "2020-01-06T08:44:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzE3MjEyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzE3MjM4Ng==", "url": "https://github.com/line/armeria/pull/2373#discussion_r363172386", "bodyText": "Remove TODO below?", "author": "OneCricketeer", "createdAt": "2020-01-06T06:29:47Z", "path": "dropwizard/src/main/java/com/linecorp/armeria/dropwizard/ArmeriaServerFactory.java", "diffHunk": "@@ -15,205 +15,59 @@\n  */\n package com.linecorp.armeria.dropwizard;\n \n-import java.security.cert.CertificateException;\n-import java.time.Duration;\n import java.util.Objects;\n-import java.util.Optional;\n import java.util.concurrent.ScheduledThreadPoolExecutor;\n import java.util.concurrent.TimeUnit;\n \n import javax.annotation.Nullable;\n-import javax.net.ssl.SSLException;\n import javax.validation.Valid;\n-import javax.validation.constraints.Min;\n-import javax.validation.constraints.NotNull;\n \n import org.eclipse.jetty.server.Handler;\n import org.eclipse.jetty.server.Server;\n import org.eclipse.jetty.util.thread.ThreadPool;\n+import org.hibernate.validator.constraints.NotEmpty;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import com.codahale.metrics.MetricRegistry;\n-import com.fasterxml.jackson.annotation.JsonGetter;\n import com.fasterxml.jackson.annotation.JsonIgnore;\n import com.fasterxml.jackson.annotation.JsonProperty;\n import com.fasterxml.jackson.annotation.JsonTypeName;\n-import com.google.common.annotations.VisibleForTesting;\n import com.google.common.collect.ImmutableMap;\n \n-import com.linecorp.armeria.common.Flags;\n-import com.linecorp.armeria.common.metric.DropwizardMeterRegistries;\n import com.linecorp.armeria.common.util.ThreadFactories;\n-import com.linecorp.armeria.dropwizard.connector.ArmeriaHttpConnectorFactory;\n-import com.linecorp.armeria.dropwizard.connector.ArmeriaServerDecorator;\n-import com.linecorp.armeria.dropwizard.logging.AccessLogWriterFactory;\n-import com.linecorp.armeria.dropwizard.logging.CommonAccessLogWriterFactory;\n import com.linecorp.armeria.server.ServerBuilder;\n import com.linecorp.armeria.server.jetty.JettyService;\n-import com.linecorp.armeria.server.logging.AccessLogWriter;\n \n import io.dropwizard.jersey.setup.JerseyEnvironment;\n-import io.dropwizard.jetty.ConnectorFactory;\n import io.dropwizard.jetty.ContextRoutingHandler;\n+import io.dropwizard.server.AbstractServerFactory;\n import io.dropwizard.server.ServerFactory;\n-import io.dropwizard.server.SimpleServerFactory;\n import io.dropwizard.setup.Environment;\n-import io.dropwizard.util.Size;\n-import io.dropwizard.validation.MinSize;\n-import io.micrometer.core.instrument.MeterRegistry;\n \n /**\n  * A Dropwizard {@link ServerFactory} implementation for Armeria that replaces\n  * Dropwizard's default Jetty handler with one provided by Armeria.\n  */\n @JsonTypeName(ArmeriaServerFactory.TYPE)\n-class ArmeriaServerFactory extends SimpleServerFactory {\n+class ArmeriaServerFactory extends AbstractServerFactory {", "originalCommit": "5ea776cf5eec378e24aa4d7ce37a075573ddddcb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzE4ODM2OA==", "url": "https://github.com/line/armeria/pull/2373#discussion_r363188368", "bodyText": "Sure!", "author": "ikhoon", "createdAt": "2020-01-06T07:52:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzE3MjM4Ng=="}], "type": "inlineReview"}, {"oid": "842f337c39d26c4f9ae80572cfca2e42370ac7f2", "url": "https://github.com/line/armeria/commit/842f337c39d26c4f9ae80572cfca2e42370ac7f2", "message": "Remove verboseResponses validation because of gradle systemProperty", "committedDate": "2020-01-06T08:25:29Z", "type": "commit"}, {"oid": "1d6e732cf2d89bc62947513a0f4ca895c6961160", "url": "https://github.com/line/armeria/commit/1d6e732cf2d89bc62947513a0f4ca895c6961160", "message": "Address comments by @cricket007\n\n- Remove  `armeria` namespace in ArmeriaServerFactory\n- Document `accessLog` property\n- Add TODO commented by @cricket007", "committedDate": "2020-01-06T08:57:06Z", "type": "commit"}, {"oid": "9ed6f60911a843a26bb1588157f78674e0f083f9", "url": "https://github.com/line/armeria/commit/9ed6f60911a843a26bb1588157f78674e0f083f9", "message": "Move TODO location", "committedDate": "2020-01-06T09:18:48Z", "type": "commit"}, {"oid": "7f45a3b9a5fbe4c61fecacd61092c6d27dcaf0d9", "url": "https://github.com/line/armeria/commit/7f45a3b9a5fbe4c61fecacd61092c6d27dcaf0d9", "message": "Remove moved TODO", "committedDate": "2020-01-06T09:19:52Z", "type": "commit"}, {"oid": "77382090bac720a95de14ab140a1ebb05cf0a700", "url": "https://github.com/line/armeria/commit/77382090bac720a95de14ab140a1ebb05cf0a700", "message": "Update Javadoc and outdated YAML configuration", "committedDate": "2020-01-06T09:29:30Z", "type": "commit"}, {"oid": "ac73d7b6c12e995cdb15726395b0c350b0c3594b", "url": "https://github.com/line/armeria/commit/ac73d7b6c12e995cdb15726395b0c350b0c3594b", "message": "Merge branch 'master' into dropwizard-configure", "committedDate": "2020-01-06T13:34:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU2Mjc5Nw==", "url": "https://github.com/line/armeria/pull/2373#discussion_r363562797", "bodyText": "Grammar?", "author": "trustin", "createdAt": "2020-01-07T01:56:10Z", "path": "dropwizard/src/main/java/com/linecorp/armeria/dropwizard/ArmeriaConfigurationUtil.java", "diffHunk": "@@ -0,0 +1,514 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.dropwizard;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.security.GeneralSecurityException;\n+import java.security.KeyStore;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.function.Supplier;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.annotation.Nullable;\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.codahale.metrics.MetricRegistry;\n+import com.codahale.metrics.json.MetricsModule;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n+import com.google.common.base.Ascii;\n+import com.google.common.base.Strings;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.math.LongMath;\n+\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.common.metric.DropwizardMeterRegistries;\n+import com.linecorp.armeria.dropwizard.ArmeriaSettings.AccessLog;\n+import com.linecorp.armeria.dropwizard.ArmeriaSettings.Compression;\n+import com.linecorp.armeria.dropwizard.ArmeriaSettings.Http1;\n+import com.linecorp.armeria.dropwizard.ArmeriaSettings.Http2;\n+import com.linecorp.armeria.dropwizard.ArmeriaSettings.Port;\n+import com.linecorp.armeria.dropwizard.ArmeriaSettings.Proxy;\n+import com.linecorp.armeria.server.HttpService;\n+import com.linecorp.armeria.server.ServerBuilder;\n+import com.linecorp.armeria.server.ServerPort;\n+import com.linecorp.armeria.server.encoding.EncodingService;\n+import com.linecorp.armeria.server.logging.AccessLogWriter;\n+\n+import io.micrometer.core.instrument.dropwizard.DropwizardMeterRegistry;\n+import io.netty.handler.ssl.ClientAuth;\n+import io.netty.handler.ssl.SslProvider;\n+import io.netty.handler.ssl.SupportedCipherSuiteFilter;\n+import io.netty.util.NetUtil;\n+\n+/**\n+ * A utility class which is used to configure a {@link ServerBuilder} with the {@link ArmeriaSettings}.\n+ */\n+final class ArmeriaConfigurationUtil {\n+    private static final Logger logger = LoggerFactory.getLogger(ArmeriaConfigurationUtil.class);\n+\n+    private static final String[] EMPTY_PROTOCOL_NAMES = new String[0];\n+\n+    private static final Port DEFAULT_PORT = new Port().setPort(8080)\n+                                                       .setProtocol(SessionProtocol.HTTP);\n+    /**\n+     * The pattern for data size text.\n+     * TODO(ikhoon): a-z seems rather broad, assuming just (kMGTP)?(Bb)\n+     */\n+    private static final Pattern DATA_SIZE_PATTERN = Pattern.compile(\"^([+]?\\\\d+)([a-zA-Z]{0,2})$\");\n+\n+    /**\n+     * Sets graceful shutdown timeout, health check services and for the specified", "originalCommit": "ac73d7b6c12e995cdb15726395b0c350b0c3594b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU3MTQzNQ==", "url": "https://github.com/line/armeria/pull/2373#discussion_r363571435", "bodyText": "Oops... \ud83d\ude05", "author": "ikhoon", "createdAt": "2020-01-07T02:44:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU2Mjc5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU2MzY3Ng==", "url": "https://github.com/line/armeria/pull/2373#discussion_r363563676", "bodyText": "I wonder if we need this feature or not because this is probably not part of server settings. Thoughts?", "author": "trustin", "createdAt": "2020-01-07T02:00:49Z", "path": "dropwizard/src/main/java/com/linecorp/armeria/dropwizard/ArmeriaSettings.java", "diffHunk": "@@ -0,0 +1,972 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+/*\n+ * Copyright 2012-2018 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linecorp.armeria.dropwizard;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.Server;\n+import com.linecorp.armeria.server.VirtualHostBuilder;\n+\n+import io.netty.handler.ssl.ClientAuth;\n+import io.netty.handler.ssl.SslProvider;\n+\n+/**\n+ * Settings for armeria servers, e.g.,\n+ * <pre>{@code\n+ * metricsPath: \"/internal/metrics\"\n+ * gracefulShutdownQuietPeriodMillis: 5000\n+ * gracefulShutdownTimeoutMillis: 40000\n+ * maxRequestLength: 10485760\n+ * maxNumConnections: 5000\n+ * dateHeaderEnabled: false\n+ * serverHeaderEnabled: true\n+ * verboseResponses: false\n+ * defaultHostname: \"host.name.com\"\n+ * ports:\n+ *   - port: 8080\n+ *     protocol: HTTP\n+ *   - ip: 127.0.0.1\n+ *     port: 8081\n+ *     protocol: HTTP\n+ *   - port: 8443\n+ *     protocols:\n+ *       - HTTPS\n+ *       - PROXY\n+ * ssl:\n+ *   keyAlias: \"host.name.com\"\n+ *   keyStore: \"keystore.jks\"\n+ *   keyStorePassword: \"changeme\"\n+ *   trustStore: \"truststore.jks\"\n+ *   trustStorePassword: \"changeme\"\n+ * compression:\n+ *   enabled: true\n+ *   mimeTypes:\n+ *     - text/*\n+ *     - application/json\n+ *   excludedUserAgents:\n+ *     - some-user-agent\n+ *     - another-user-agent\n+ *   minResponseSize: 1KB", "originalCommit": "ac73d7b6c12e995cdb15726395b0c350b0c3594b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU2NTc3NQ==", "url": "https://github.com/line/armeria/pull/2373#discussion_r363565775", "bodyText": "Not sure I understand the feature myself. Would a smaller response end up throwing a 500 error?", "author": "OneCricketeer", "createdAt": "2020-01-07T02:12:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU2MzY3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU2NjE3Mw==", "url": "https://github.com/line/armeria/pull/2373#discussion_r363566173", "bodyText": "Ah, it basically tells the server not to compress the content smaller than 1KB. This is not part of core Armeria but it's from Spring Boot. Maybe we should drop this for Dropwizard if Dropwizard does not have this sort of configuration out of the box?", "author": "trustin", "createdAt": "2020-01-07T02:14:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU2MzY3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU2OTg1NQ==", "url": "https://github.com/line/armeria/pull/2373#discussion_r363569855", "bodyText": "This is not part of core Armeria but it's from Spring Boot.\n\nI didn't know that. Thanks for sharing.\n\nMaybe we should drop this for Dropwizard if Dropwizard does not have this sort of configuration out of the box?\n\nAfter your review, I found GZip compression documentation in the Dropwizard site. I think the GZip feature is similar to ArmeriaSettings' compression.", "author": "ikhoon", "createdAt": "2020-01-07T02:34:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU2MzY3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU3MDM1MQ==", "url": "https://github.com/line/armeria/pull/2373#discussion_r363570351", "bodyText": "Ah, OK. Then perhaps we can keep this section. \ud83d\ude04", "author": "trustin", "createdAt": "2020-01-07T02:37:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU2MzY3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU2MzkzMA==", "url": "https://github.com/line/armeria/pull/2373#discussion_r363563930", "bodyText": "I wonder if we need this feature or not because this is probably not part of server settings. Thoughts?", "author": "trustin", "createdAt": "2020-01-07T02:02:09Z", "path": "dropwizard/src/main/java/com/linecorp/armeria/dropwizard/ArmeriaSettings.java", "diffHunk": "@@ -0,0 +1,972 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+/*\n+ * Copyright 2012-2018 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linecorp.armeria.dropwizard;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.Server;\n+import com.linecorp.armeria.server.VirtualHostBuilder;\n+\n+import io.netty.handler.ssl.ClientAuth;\n+import io.netty.handler.ssl.SslProvider;\n+\n+/**\n+ * Settings for armeria servers, e.g.,\n+ * <pre>{@code\n+ * metricsPath: \"/internal/metrics\"", "originalCommit": "ac73d7b6c12e995cdb15726395b0c350b0c3594b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU2NTU3OQ==", "url": "https://github.com/line/armeria/pull/2373#discussion_r363565579", "bodyText": "Metrics should be served under the adminContext / servlet by default", "author": "OneCricketeer", "createdAt": "2020-01-07T02:11:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU2MzkzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU3MTM1MA==", "url": "https://github.com/line/armeria/pull/2373#discussion_r363571350", "bodyText": "I wonder if we need this feature or not because this is probably not part of server settings. Thoughts?\n\nI agree. It is an additional feature, not a server setting.\n\nMetrics should be served under the adminContext / servlet by default\n\nThat's a good point. I checked the /admin/metrics on my local Armeria Dropwizard server. Let me drop metricsPath.", "author": "ikhoon", "createdAt": "2020-01-07T02:43:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU2MzkzMA=="}], "type": "inlineReview"}, {"oid": "69d8884339f2bf188eaf1ea43177d8fa470f4e7f", "url": "https://github.com/line/armeria/commit/69d8884339f2bf188eaf1ea43177d8fa470f4e7f", "message": "Address comments by @trustin, @cricket007\n\n- Remove metricsPath from ArmeriaSettings\n- Update Javadoc", "committedDate": "2020-01-07T03:15:42Z", "type": "commit"}, {"oid": "3d6d80565550183f2d317a3068b48ad6338b6ab2", "url": "https://github.com/line/armeria/commit/3d6d80565550183f2d317a3068b48ad6338b6ab2", "message": "Update Javadoc and Documentation", "committedDate": "2020-01-07T03:46:32Z", "type": "commit"}, {"oid": "3912cd819497e9065b9ee8ce6bd191ca1dcc5b1b", "url": "https://github.com/line/armeria/commit/3912cd819497e9065b9ee8ce6bd191ca1dcc5b1b", "message": "Fix test case", "committedDate": "2020-01-07T05:05:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU3OTEyMA==", "url": "https://github.com/line/armeria/pull/2373#discussion_r363579120", "bodyText": "can remove public", "author": "minwoox", "createdAt": "2020-01-07T03:32:30Z", "path": "dropwizard/src/main/java/com/linecorp/armeria/dropwizard/ArmeriaConfigurationUtil.java", "diffHunk": "@@ -0,0 +1,481 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.dropwizard;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.security.GeneralSecurityException;\n+import java.security.KeyStore;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.function.Supplier;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.annotation.Nullable;\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.base.Ascii;\n+import com.google.common.base.Strings;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.math.LongMath;\n+\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.dropwizard.ArmeriaSettings.AccessLog;\n+import com.linecorp.armeria.dropwizard.ArmeriaSettings.Compression;\n+import com.linecorp.armeria.dropwizard.ArmeriaSettings.Http1;\n+import com.linecorp.armeria.dropwizard.ArmeriaSettings.Http2;\n+import com.linecorp.armeria.dropwizard.ArmeriaSettings.Port;\n+import com.linecorp.armeria.dropwizard.ArmeriaSettings.Proxy;\n+import com.linecorp.armeria.server.HttpService;\n+import com.linecorp.armeria.server.ServerBuilder;\n+import com.linecorp.armeria.server.ServerPort;\n+import com.linecorp.armeria.server.encoding.EncodingService;\n+import com.linecorp.armeria.server.logging.AccessLogWriter;\n+\n+import io.netty.handler.ssl.ClientAuth;\n+import io.netty.handler.ssl.SslProvider;\n+import io.netty.handler.ssl.SupportedCipherSuiteFilter;\n+import io.netty.util.NetUtil;\n+\n+/**\n+ * A utility class which is used to configure a {@link ServerBuilder} with the {@link ArmeriaSettings}.\n+ */\n+final class ArmeriaConfigurationUtil {\n+    private static final Logger logger = LoggerFactory.getLogger(ArmeriaConfigurationUtil.class);\n+\n+    private static final String[] EMPTY_PROTOCOL_NAMES = new String[0];\n+\n+    private static final Port DEFAULT_PORT = new Port().setPort(8080)\n+                                                       .setProtocol(SessionProtocol.HTTP);\n+    /**\n+     * The pattern for data size text.\n+     * TODO(ikhoon): a-z seems rather broad, assuming just (kMGTP)?(Bb)\n+     */\n+    private static final Pattern DATA_SIZE_PATTERN = Pattern.compile(\"^([+]?\\\\d+)([a-zA-Z]{0,2})$\");\n+\n+    /**\n+     * Configures the {@link ServerBuilder} with the specified {@code settings}.\n+     */\n+    public static void configureServer(ServerBuilder serverBuilder, ArmeriaSettings settings) {", "originalCommit": "69d8884339f2bf188eaf1ea43177d8fa470f4e7f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzY0MTU2MA==", "url": "https://github.com/line/armeria/pull/2373#discussion_r363641560", "bodyText": "nit: not -> nor", "author": "minwoox", "createdAt": "2020-01-07T08:42:37Z", "path": "dropwizard/src/main/java/com/linecorp/armeria/dropwizard/ArmeriaConfigurationUtil.java", "diffHunk": "@@ -0,0 +1,481 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.dropwizard;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.security.GeneralSecurityException;\n+import java.security.KeyStore;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.function.Supplier;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.annotation.Nullable;\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.base.Ascii;\n+import com.google.common.base.Strings;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.math.LongMath;\n+\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.dropwizard.ArmeriaSettings.AccessLog;\n+import com.linecorp.armeria.dropwizard.ArmeriaSettings.Compression;\n+import com.linecorp.armeria.dropwizard.ArmeriaSettings.Http1;\n+import com.linecorp.armeria.dropwizard.ArmeriaSettings.Http2;\n+import com.linecorp.armeria.dropwizard.ArmeriaSettings.Port;\n+import com.linecorp.armeria.dropwizard.ArmeriaSettings.Proxy;\n+import com.linecorp.armeria.server.HttpService;\n+import com.linecorp.armeria.server.ServerBuilder;\n+import com.linecorp.armeria.server.ServerPort;\n+import com.linecorp.armeria.server.encoding.EncodingService;\n+import com.linecorp.armeria.server.logging.AccessLogWriter;\n+\n+import io.netty.handler.ssl.ClientAuth;\n+import io.netty.handler.ssl.SslProvider;\n+import io.netty.handler.ssl.SupportedCipherSuiteFilter;\n+import io.netty.util.NetUtil;\n+\n+/**\n+ * A utility class which is used to configure a {@link ServerBuilder} with the {@code ArmeriaSettings}.\n+ */\n+final class ArmeriaConfigurationUtil {\n+    private static final Logger logger = LoggerFactory.getLogger(ArmeriaConfigurationUtil.class);\n+\n+    private static final String[] EMPTY_PROTOCOL_NAMES = new String[0];\n+\n+    private static final Port DEFAULT_PORT = new Port().setPort(8080)\n+                                                       .setProtocol(SessionProtocol.HTTP);\n+    /**\n+     * The pattern for data size text.\n+     * TODO(ikhoon): a-z seems rather broad, assuming just (kMGTP)?(Bb)\n+     */\n+    private static final Pattern DATA_SIZE_PATTERN = Pattern.compile(\"^([+]?\\\\d+)([a-zA-Z]{0,2})$\");\n+\n+    /**\n+     * Configures the {@link ServerBuilder} with the specified {@code settings}.\n+     */\n+    public static void configureServer(ServerBuilder serverBuilder, ArmeriaSettings settings) {\n+        requireNonNull(serverBuilder, \"serverBuilder\");\n+        requireNonNull(settings, \"settings\");\n+\n+        if (settings.getGracefulShutdownQuietPeriodMillis() >= 0 &&\n+            settings.getGracefulShutdownTimeoutMillis() >= 0) {\n+            serverBuilder.gracefulShutdownTimeout(settings.getGracefulShutdownQuietPeriodMillis(),\n+                                                  settings.getGracefulShutdownTimeoutMillis());\n+            logger.debug(\"Set graceful shutdown timeout: quiet period {} ms, timeout {} ms\",\n+                         settings.getGracefulShutdownQuietPeriodMillis(),\n+                         settings.getGracefulShutdownTimeoutMillis());\n+        }\n+        if (settings.getMaxRequestLength() != null) {\n+            serverBuilder.maxRequestLength(settings.getMaxRequestLength());\n+        }\n+        if (settings.getMaxNumConnections() != null) {\n+            serverBuilder.maxNumConnections(settings.getMaxNumConnections());\n+        }\n+        if (!settings.isDateHeaderEnabled()) {\n+            serverBuilder.disableDateHeader();\n+        }\n+        if (!settings.isServerHeaderEnabled()) {\n+            serverBuilder.disableServerHeader();\n+        }\n+        if (settings.getDefaultHostname() != null) {\n+            serverBuilder.defaultHostname(settings.getDefaultHostname());\n+        }\n+        if (settings.isVerboseResponses()) {\n+            serverBuilder.verboseResponses(true);\n+        }\n+\n+        if (settings.getPorts().isEmpty()) {\n+            serverBuilder.port(new ServerPort(DEFAULT_PORT.getPort(), DEFAULT_PORT.getProtocols()));\n+        } else {\n+            configurePorts(serverBuilder, settings.getPorts());\n+        }\n+\n+        if (settings.getSsl() != null) {\n+            configureTls(serverBuilder, settings.getSsl());\n+        }\n+        if (settings.getCompression() != null) {\n+            configureCompression(serverBuilder, settings.getCompression());\n+        }\n+        if (settings.getHttp1() != null) {\n+            configureHttp1(serverBuilder, settings.getHttp1());\n+        }\n+        if (settings.getHttp2() != null) {\n+            configureHttp2(serverBuilder, settings.getHttp2());\n+        }\n+        if (settings.getProxy() != null) {\n+            configureProxy(serverBuilder, settings.getProxy());\n+        }\n+        if (settings.getAccessLog() != null) {\n+            configureAccessLog(serverBuilder, settings.getAccessLog());\n+        }\n+    }\n+\n+    /**\n+     * Adds {@link Port}s to the specified {@link ServerBuilder}.\n+     */\n+    private static void configurePorts(ServerBuilder server, List<Port> ports) {\n+        requireNonNull(server, \"server\");\n+        requireNonNull(ports, \"ports\");\n+        ports.forEach(p -> {\n+            final String ip = p.getIp();\n+            final String iface = p.getIface();\n+            final int port = p.getPort();\n+            final List<SessionProtocol> protocols = firstNonNull(p.getProtocols(),\n+                                                                 ImmutableList.of(SessionProtocol.HTTP));\n+\n+            if (ip == null) {\n+                if (iface == null) {\n+                    server.port(new ServerPort(port, protocols));\n+                } else {\n+                    try {\n+                        final Enumeration<InetAddress> e = NetworkInterface.getByName(iface).getInetAddresses();\n+                        while (e.hasMoreElements()) {\n+                            server.port(new ServerPort(new InetSocketAddress(e.nextElement(), port),\n+                                                       protocols));\n+                        }\n+                    } catch (SocketException e) {\n+                        throw new IllegalStateException(\"Failed to find an iface: \" + iface, e);\n+                    }\n+                }\n+            } else if (iface == null) {\n+                if (NetUtil.isValidIpV4Address(ip) || NetUtil.isValidIpV6Address(ip)) {\n+                    final byte[] bytes = NetUtil.createByteArrayFromIpAddressString(ip);\n+                    try {\n+                        server.port(new ServerPort(new InetSocketAddress(\n+                                InetAddress.getByAddress(bytes), port), protocols));\n+                    } catch (UnknownHostException e) {\n+                        // Should never happen.\n+                        throw new Error(e);\n+                    }\n+                } else {\n+                    throw new IllegalStateException(\"invalid IP address: \" + ip);\n+                }\n+            } else {\n+                throw new IllegalStateException(\"A port cannot have both IP and iface: \" + p);\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Adds SSL/TLS context to the specified {@link ServerBuilder}.\n+     */\n+    private static void configureTls(ServerBuilder sb, ArmeriaSettings.Ssl ssl) {\n+        configureTls(sb, ssl, null, null);\n+    }\n+\n+    /**\n+     * Adds SSL/TLS context to the specified {@link ServerBuilder}.\n+     */\n+    private static void configureTls(ServerBuilder sb, ArmeriaSettings.Ssl ssl,\n+                                     @Nullable Supplier<KeyStore> keyStoreSupplier,\n+                                     @Nullable Supplier<KeyStore> trustStoreSupplier) {\n+        if (!ssl.isEnabled()) {\n+            return;\n+        }\n+        try {\n+            if (keyStoreSupplier == null && trustStoreSupplier == null &&\n+                ssl.getKeyStore() == null && ssl.getTrustStore() == null) {\n+                logger.warn(\"Configuring TLS with a self-signed certificate \" +\n+                            \"because no key or trust store was specified\");\n+                sb.tlsSelfSigned();\n+                return;\n+            }\n+\n+            final KeyManagerFactory keyManagerFactory = getKeyManagerFactory(ssl, keyStoreSupplier);\n+            final TrustManagerFactory trustManagerFactory = getTrustManagerFactory(ssl, trustStoreSupplier);\n+\n+            sb.tls(keyManagerFactory);\n+            sb.tlsCustomizer(sslContextBuilder -> {\n+                sslContextBuilder.trustManager(trustManagerFactory);\n+\n+                final SslProvider sslProvider = ssl.getProvider();\n+                if (sslProvider != null) {\n+                    sslContextBuilder.sslProvider(sslProvider);\n+                }\n+                final List<String> enabledProtocols = ssl.getEnabledProtocols();\n+                if (enabledProtocols != null) {\n+                    sslContextBuilder.protocols(enabledProtocols.toArray(EMPTY_PROTOCOL_NAMES));\n+                }\n+                final List<String> ciphers = ssl.getCiphers();\n+                if (ciphers != null) {\n+                    sslContextBuilder.ciphers(ImmutableList.copyOf(ciphers),\n+                                              SupportedCipherSuiteFilter.INSTANCE);\n+                }\n+                final ClientAuth clientAuth = ssl.getClientAuth();\n+                if (clientAuth != null) {\n+                    sslContextBuilder.clientAuth(clientAuth);\n+                }\n+            });\n+        } catch (Exception e) {\n+            throw new IllegalStateException(\"Failed to configure TLS: \" + e, e);\n+        }\n+    }\n+\n+    private static KeyManagerFactory getKeyManagerFactory(\n+            ArmeriaSettings.Ssl ssl, @Nullable Supplier<KeyStore> sslStoreProvider) throws Exception {\n+        final KeyStore store;\n+        if (sslStoreProvider != null) {\n+            store = sslStoreProvider.get();\n+        } else {\n+            store = loadKeyStore(ssl.getKeyStoreType(), ssl.getKeyStore(), ssl.getKeyStorePassword());\n+        }\n+\n+        KeyManagerFactory keyManagerFactory =\n+                KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n+        if (ssl.getKeyAlias() != null) {\n+            keyManagerFactory = new CustomAliasKeyManagerFactory(keyManagerFactory, ssl.getKeyAlias());\n+        }\n+\n+        String keyPassword = ssl.getKeyPassword();\n+        if (keyPassword == null) {\n+            keyPassword = ssl.getKeyStorePassword();\n+        }\n+\n+        keyManagerFactory.init(store, keyPassword != null ? keyPassword.toCharArray()\n+                                                          : null);\n+        return keyManagerFactory;\n+    }\n+\n+    private static TrustManagerFactory getTrustManagerFactory(\n+            ArmeriaSettings.Ssl ssl, @Nullable Supplier<KeyStore> sslStoreProvider) throws Exception {\n+        final KeyStore store;\n+        if (sslStoreProvider != null) {\n+            store = sslStoreProvider.get();\n+        } else {\n+            store = loadKeyStore(ssl.getTrustStoreType(), ssl.getTrustStore(), ssl.getTrustStorePassword());\n+        }\n+\n+        final TrustManagerFactory trustManagerFactory =\n+                TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n+        trustManagerFactory.init(store);\n+        return trustManagerFactory;\n+    }\n+\n+    @Nullable\n+    private static KeyStore loadKeyStore(\n+            @Nullable String type,\n+            @Nullable String resource,\n+            @Nullable String password) throws IOException, GeneralSecurityException {\n+        if (resource == null) {\n+            return null;\n+        }\n+        final KeyStore store = KeyStore.getInstance(firstNonNull(type, \"JKS\"));\n+        final URL url = getURL(resource);\n+        store.load(url.openStream(), password != null ? password.toCharArray()\n+                                                      : null);\n+        return store;\n+    }\n+\n+    /**\n+     * Configures a decorator for encoding the content of the HTTP responses sent from the server.\n+     */\n+    private static Function<? super HttpService, EncodingService> contentEncodingDecorator(\n+            @Nullable String[] mimeTypes, @Nullable String[] excludedUserAgents,\n+            long minBytesToForceChunkedAndEncoding) {\n+        final Predicate<MediaType> encodableContentTypePredicate;\n+        if (mimeTypes == null || mimeTypes.length == 0) {\n+            encodableContentTypePredicate = contentType -> true;\n+        } else {\n+            final List<MediaType> encodableContentTypes =\n+                    Arrays.stream(mimeTypes).map(MediaType::parse).collect(toImmutableList());\n+            encodableContentTypePredicate = contentType ->\n+                    encodableContentTypes.stream().anyMatch(contentType::is);\n+        }\n+\n+        final Predicate<HttpHeaders> encodableRequestHeadersPredicate;\n+        if (excludedUserAgents == null || excludedUserAgents.length == 0) {\n+            encodableRequestHeadersPredicate = headers -> true;\n+        } else {\n+            final List<Pattern> patterns =\n+                    Arrays.stream(excludedUserAgents).map(Pattern::compile).collect(toImmutableList());\n+            encodableRequestHeadersPredicate = headers -> {\n+                // No User-Agent header will be converted to an empty string.\n+                final String userAgent = headers.get(HttpHeaderNames.USER_AGENT, \"\");\n+                return patterns.stream().noneMatch(pattern -> pattern.matcher(userAgent).matches());\n+            };\n+        }\n+\n+        return delegate -> new EncodingService(delegate,\n+                                               encodableContentTypePredicate,\n+                                               encodableRequestHeadersPredicate,\n+                                               minBytesToForceChunkedAndEncoding);\n+    }\n+\n+    /**\n+     * Parses the data size text as a decimal {@code long}.\n+     *\n+     * @param dataSizeText the data size text, i.e. {@code 1}, {@code 1B}, {@code 1KB}, {@code 1MB},\n+     *                     {@code 1GB} or {@code 1TB}\n+     */\n+    private static long parseDataSize(String dataSizeText) {\n+        requireNonNull(dataSizeText, \"text\");\n+        final Matcher matcher = DATA_SIZE_PATTERN.matcher(dataSizeText);\n+        checkArgument(matcher.matches(),\n+                      \"Invalid data size text: %s (expected: %s)\",\n+                      dataSizeText, DATA_SIZE_PATTERN);\n+\n+        final long unit;\n+        final String unitText = matcher.group(2);\n+        if (Strings.isNullOrEmpty(unitText)) {\n+            unit = 1L;\n+        } else {\n+            switch (Ascii.toLowerCase(unitText)) {\n+                case \"b\":\n+                    unit = 1L;\n+                    break;\n+                case \"kb\":\n+                    unit = 1024L;\n+                    break;\n+                case \"mb\":\n+                    unit = 1024L * 1024L;\n+                    break;\n+                case \"gb\":\n+                    unit = 1024L * 1024L * 1024L;\n+                    break;\n+                case \"tb\":\n+                    // TODO(ikhoon): Simplify with Math.pow?\n+                    unit = 1024L * 1024L * 1024L * 1024L;\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Invalid data size text: \" + dataSizeText +\n+                                                       \" (expected: \" + DATA_SIZE_PATTERN + ')');\n+            }\n+        }\n+        try {\n+            final long amount = Long.parseLong(matcher.group(1));\n+            return LongMath.checkedMultiply(amount, unit);\n+        } catch (Exception e) {\n+            throw new IllegalArgumentException(\"Invalid data size text: \" + dataSizeText +\n+                                               \" (expected: \" + DATA_SIZE_PATTERN + ')', e);\n+        }\n+    }\n+\n+    /**\n+     * Resolves the given resource location to a {@link URL}.\n+     *\n+     * <p>Does not check whether the URL actually exists; simply returns\n+     * the URL that the given location would correspond to.\n+     *\n+     * @param resourceLocation the resource location to resolve: either a\n+     *                         \"classpath:\" pseudo URL, a \"file:\" URL, or a plain file path\n+     * @return a corresponding URL object\n+     * @throws FileNotFoundException if the resource cannot be resolved to a URL\n+     */\n+    private static URL getURL(String resourceLocation) throws FileNotFoundException {\n+        // Forked from Spring 5.2.2\n+        // https://github.com/spring-projects/spring-framework/blob/22a888b53df620b0905ce8beb6b0cf71981086d8/spring-core/src/main/java/org/springframework/util/ResourceUtils.java#L129\n+        if (resourceLocation.startsWith(\"classpath:\")) {\n+            final String path = resourceLocation.substring(\"classpath:\".length());\n+            final URL resource = ArmeriaConfigurationUtil.class.getClassLoader().getResource(path);\n+            if (resource == null) {\n+                throw new FileNotFoundException(\"class path resource [\" + path +\n+                                                \"] cannot be resolved to URL because it does not exist\");\n+            }\n+            return resource;\n+        }\n+        try {\n+            // try URL\n+            return new URL(resourceLocation);\n+        } catch (MalformedURLException ex) {\n+            // no URL -> treat as file path\n+            try {\n+                return new File(resourceLocation).toURI().toURL();\n+            } catch (MalformedURLException ex2) {\n+                throw new FileNotFoundException(\"Resource location [\" + resourceLocation +\n+                                                \"] is neither a URL not a well-formed file path\");", "originalCommit": "3912cd819497e9065b9ee8ce6bd191ca1dcc5b1b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7413d196d7920dbfd9839d6017826caa01180713", "url": "https://github.com/line/armeria/commit/7413d196d7920dbfd9839d6017826caa01180713", "message": "Address comments by @minwoox", "committedDate": "2020-01-08T03:30:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTA4MzEzMA==", "url": "https://github.com/line/armeria/pull/2373#discussion_r365083130", "bodyText": "Aren't there constants for these?", "author": "OneCricketeer", "createdAt": "2020-01-10T05:59:17Z", "path": "dropwizard/src/main/java/com/linecorp/armeria/dropwizard/ArmeriaSettings.java", "diffHunk": "@@ -0,0 +1,955 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+/*\n+ * Copyright 2012-2018 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linecorp.armeria.dropwizard;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.Server;\n+import com.linecorp.armeria.server.VirtualHostBuilder;\n+\n+import io.netty.handler.ssl.ClientAuth;\n+import io.netty.handler.ssl.SslProvider;\n+\n+/**\n+ * Settings for armeria servers, e.g.,\n+ * <pre>{@code\n+ * gracefulShutdownQuietPeriodMillis: 5000\n+ * gracefulShutdownTimeoutMillis: 40000\n+ * maxRequestLength: 10485760\n+ * maxNumConnections: 5000\n+ * dateHeaderEnabled: false\n+ * serverHeaderEnabled: true\n+ * verboseResponses: false\n+ * defaultHostname: \"host.name.com\"\n+ * ports:\n+ *   - port: 8080\n+ *     protocol: HTTP\n+ *   - ip: 127.0.0.1\n+ *     port: 8081\n+ *     protocol: HTTP\n+ *   - port: 8443\n+ *     protocols:\n+ *       - HTTPS\n+ *       - PROXY\n+ * ssl:\n+ *   keyAlias: \"host.name.com\"\n+ *   keyStore: \"keystore.jks\"\n+ *   keyStorePassword: \"changeme\"\n+ *   trustStore: \"truststore.jks\"\n+ *   trustStorePassword: \"changeme\"\n+ * compression:\n+ *   enabled: true\n+ *   mimeTypes:\n+ *     - text/*\n+ *     - application/json\n+ *   excludedUserAgents:\n+ *     - some-user-agent\n+ *     - another-user-agent\n+ *   minResponseSize: 1KB\n+ * proxy:\n+ *   maxTlvSize: 65319\n+ * http1:\n+ *   maxChunkSize: 4096\n+ *   maxInitialLineLength: 4096\n+ * http2:\n+ *   initialConnectionWindowSize: 1MB\n+ *   initialStreamWindowSize: 1MB\n+ *   maxFrameSize: 16384\n+ *   maxHeaderListSize: 8192\n+ * accessLog:\n+ *   type: custom\n+ *   format: \"Your own log format\"\n+ * ...\n+ *\n+ * }</pre>\n+ * TODO(ikhoon): Merge this DroppWizard ArmeriaSettings with c.l.a.spring.ArmeriaSettings\n+ *               to provide common API to configure Server from JSON and YAML.\n+ */\n+class ArmeriaSettings {\n+\n+    /**\n+     * The ports to listen on for requests. If not specified, will listen on\n+     * port 8080 for HTTP (not SSL).\n+     */\n+    private List<Port> ports = new ArrayList<>();\n+\n+    /**\n+     * The number of milliseconds to wait after the last processed request to\n+     * be considered safe for shutdown. This should be set at least as long as\n+     * the slowest possible request to guarantee graceful shutdown. If {@code -1},\n+     * graceful shutdown will be disabled.\n+     */\n+    private long gracefulShutdownQuietPeriodMillis = 5000;\n+\n+    /**\n+     * The number of milliseconds to wait after going unhealthy before forcing\n+     * the server to shutdown regardless of if it is still processing requests.\n+     * This should be set as long as the maximum time for the load balancer to\n+     * turn off requests to the server. If {@code -1}, graceful shutdown will\n+     * be disabled.\n+     */\n+    private long gracefulShutdownTimeoutMillis = 40000;\n+\n+    /**\n+     * The maximum allowed length of the content decoded at the session layer.\n+     */\n+    @Nullable\n+    private Integer maxRequestLength;\n+\n+    /**\n+     * The maximum allowed number of open connections.\n+     */\n+    @Nullable\n+    private Integer maxNumConnections;\n+\n+    /**\n+     * If enabled, the {@code \"Date\"} header is included in the response header.\n+     */\n+    private boolean dateHeaderEnabled = true;\n+\n+    /**\n+     * If enabled, the {@code \"Server\"} header is included in the response header.\n+     */\n+    private boolean serverHeaderEnabled;\n+\n+    /**\n+     * {@code true} if the verbose response mode is enabled.\n+     */\n+    private boolean verboseResponses;\n+\n+    /**\n+     * The default hostname of the default {@link VirtualHostBuilder}.\n+     */\n+    @Nullable\n+    private String defaultHostname;\n+\n+    /**\n+     * SSL configuration that the {@link Server} uses.\n+     */\n+    @Nullable\n+    private Ssl ssl;\n+\n+    /**\n+     * Compression configuration that the {@link Server} uses.\n+     */\n+    @Nullable\n+    private Compression compression;\n+\n+    /**\n+     * HTTP/1 configuration that the {@link Server} uses.\n+     */\n+    @Nullable\n+    private Http1 http1;\n+\n+    /**\n+     * HTTP/2 configuration that the {@link Server} uses.\n+     */\n+    @Nullable\n+    private Http2 http2;\n+\n+    /**\n+     * PROXY configuration that the {@link Server} uses.\n+     */\n+    @Nullable\n+    private Proxy proxy;\n+\n+    /**\n+     * Access Log configuration that the {@link Server} uses.\n+     */\n+    @Nullable\n+    private AccessLog accessLog;\n+\n+    /**\n+     * Returns the {@link Port}s of the {@link Server}.\n+     */\n+    List<Port> getPorts() {\n+        return ports;\n+    }\n+\n+    /**\n+     * Sets the {@link Port}s of the {@link Server}.\n+     */\n+    void setPorts(List<Port> ports) {\n+        this.ports = ports;\n+    }\n+\n+    long getGracefulShutdownQuietPeriodMillis() {\n+        return gracefulShutdownQuietPeriodMillis;\n+    }\n+\n+    void setGracefulShutdownQuietPeriodMillis(long gracefulShutdownQuietPeriodMillis) {\n+        this.gracefulShutdownQuietPeriodMillis = gracefulShutdownQuietPeriodMillis;\n+    }\n+\n+    long getGracefulShutdownTimeoutMillis() {\n+        return gracefulShutdownTimeoutMillis;\n+    }\n+\n+    void setGracefulShutdownTimeoutMillis(long gracefulShutdownTimeoutMillis) {\n+        this.gracefulShutdownTimeoutMillis = gracefulShutdownTimeoutMillis;\n+    }\n+\n+    @Nullable\n+    Integer getMaxRequestLength() {\n+        return maxRequestLength;\n+    }\n+\n+    void setMaxRequestLength(@Nullable Integer maxRequestLength) {\n+        this.maxRequestLength = maxRequestLength;\n+    }\n+\n+    @Nullable\n+    Integer getMaxNumConnections() {\n+        return maxNumConnections;\n+    }\n+\n+    void setMaxNumConnections(Integer maxNumConnections) {\n+        this.maxNumConnections = maxNumConnections;\n+    }\n+\n+    boolean isDateHeaderEnabled() {\n+        return dateHeaderEnabled;\n+    }\n+\n+    void setDateHeaderEnabled(boolean dateHeaderEnabled) {\n+        this.dateHeaderEnabled = dateHeaderEnabled;\n+    }\n+\n+    boolean isServerHeaderEnabled() {\n+        return serverHeaderEnabled;\n+    }\n+\n+    void setServerHeaderEnabled(boolean serverHeaderEnabled) {\n+        this.serverHeaderEnabled = serverHeaderEnabled;\n+    }\n+\n+    boolean isVerboseResponses() {\n+        return verboseResponses;\n+    }\n+\n+    void setVerboseResponses(boolean verboseResponses) {\n+        this.verboseResponses = verboseResponses;\n+    }\n+\n+    @Nullable\n+    String getDefaultHostname() {\n+        return defaultHostname;\n+    }\n+\n+    void setDefaultHostname(@Nullable String defaultHostname) {\n+        this.defaultHostname = defaultHostname;\n+    }\n+\n+    @Nullable\n+    Ssl getSsl() {\n+        return ssl;\n+    }\n+\n+    void setSsl(Ssl ssl) {\n+        this.ssl = ssl;\n+    }\n+\n+    @Nullable\n+    Compression getCompression() {\n+        return compression;\n+    }\n+\n+    void setCompression(Compression compression) {\n+        this.compression = compression;\n+    }\n+\n+    @Nullable\n+    Http1 getHttp1() {\n+        return http1;\n+    }\n+\n+    void setHttp1(@Nullable Http1 http1) {\n+        this.http1 = http1;\n+    }\n+\n+    @Nullable\n+    Http2 getHttp2() {\n+        return http2;\n+    }\n+\n+    void setHttp2(@Nullable Http2 http2) {\n+        this.http2 = http2;\n+    }\n+\n+    @Nullable\n+    Proxy getProxy() {\n+        return proxy;\n+    }\n+\n+    void setProxy(@Nullable Proxy proxy) {\n+        this.proxy = proxy;\n+    }\n+\n+    @Nullable\n+    AccessLog getAccessLog() {\n+        return accessLog;\n+    }\n+\n+    void setAccessLog(@Nullable AccessLog accessLog) {\n+        this.accessLog = accessLog;\n+    }\n+\n+    /**\n+     * Port and protocol settings.\n+     */\n+    static class Port {\n+        /**\n+         * IP address to bind to. If not set, will bind to all addresses, e.g. {@code 0.0.0.0}.\n+         */\n+        @Nullable\n+        private String ip;\n+\n+        /**\n+         * Network interface to bind to. If not set, will bind to the first detected network interface.\n+         */\n+        @Nullable\n+        private String iface;\n+\n+        /**\n+         * Port that {@link Server} binds to.\n+         */\n+        private int port;\n+\n+        /**\n+         * Protocol that will be used in this ip/iface and port.\n+         */\n+        @Nullable\n+        private List<SessionProtocol> protocols;\n+\n+        @Nullable\n+        String getIp() {\n+            return ip;\n+        }\n+\n+        Port setIp(String ip) {\n+            this.ip = ip;\n+            return this;\n+        }\n+\n+        @Nullable\n+        String getIface() {\n+            return iface;\n+        }\n+\n+        Port setIface(String iface) {\n+            this.iface = iface;\n+            return this;\n+        }\n+\n+        int getPort() {\n+            return port;\n+        }\n+\n+        Port setPort(int port) {\n+            this.port = port;\n+            return this;\n+        }\n+\n+        @Nullable\n+        List<SessionProtocol> getProtocols() {\n+            return protocols;\n+        }\n+\n+        Port setProtocols(List<SessionProtocol> protocols) {\n+            this.protocols = ImmutableList.copyOf(protocols);\n+            return this;\n+        }\n+\n+        Port setProtocol(SessionProtocol protocol) {\n+            protocols = ImmutableList.of(protocol);\n+            return this;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) {\n+                return true;\n+            }\n+            if (!(o instanceof Port)) {\n+                return false;\n+            }\n+            final Port that = (Port) o;\n+            return port == that.port &&\n+                   Objects.equals(ip, that.ip) &&\n+                   Objects.equals(iface, that.iface) &&\n+                   Objects.equals(protocols, that.protocols);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(ip, iface, port, protocols);\n+        }\n+    }\n+\n+    /**\n+     * Simple server-independent abstraction for SSL configuration.\n+     *\n+     * @author Andy Wilkinson\n+     * @author Vladimir Tsanev\n+     * @author Stephane Nicoll\n+     */\n+    static class Ssl {\n+        private boolean enabled = true;\n+\n+        @Nullable\n+        private SslProvider provider;\n+\n+        @Nullable\n+        private ClientAuth clientAuth;\n+\n+        @Nullable\n+        private List<String> ciphers;\n+\n+        @Nullable\n+        private List<String> enabledProtocols;\n+\n+        @Nullable\n+        private String keyAlias;\n+\n+        @Nullable\n+        private String keyPassword;\n+\n+        @Nullable\n+        private String keyStore;\n+\n+        @Nullable\n+        private String keyStorePassword;\n+\n+        @Nullable\n+        private String keyStoreType;\n+\n+        @Nullable\n+        private String keyStoreProvider;\n+\n+        @Nullable\n+        private String trustStore;\n+\n+        @Nullable\n+        private String trustStorePassword;\n+\n+        @Nullable\n+        private String trustStoreType;\n+\n+        @Nullable\n+        private String trustStoreProvider;\n+\n+        /**\n+         * Returns whether to enable SSL support.\n+         * @return whether to enable SSL support\n+         */\n+        boolean isEnabled() {\n+            return enabled;\n+        }\n+\n+        /**\n+         * Enables (or disables) SSL support.\n+         */\n+        Ssl setEnabled(boolean enabled) {\n+            this.enabled = enabled;\n+            return this;\n+        }\n+\n+        /**\n+         * Returns Netty SSL Provider.\n+         * @return Netty SSL Provider\n+         */\n+        @Nullable\n+        SslProvider getProvider() {\n+            return provider;\n+        }\n+\n+        /**\n+         * Sets Netty SSL Provider namely JDK or OPENSSL  {@link SslProvider}.\n+         * @param provider Netty SSL Provider\n+         */\n+        void setProvider(SslProvider provider) {\n+            this.provider = provider;\n+        }\n+\n+        /**\n+         * Returns whether client authentication is not wanted (\"none\"), wanted (\"want\") or\n+         * needed (\"need\"). Requires a trust store.\n+         * @return the {@link ClientAuth} to use\n+         */\n+        @Nullable\n+        ClientAuth getClientAuth() {\n+            return clientAuth;\n+        }\n+\n+        /**\n+         * Sets whether the client authentication is not none ({@link ClientAuth#NONE}), optional\n+         * ({@link ClientAuth#OPTIONAL}) or required ({@link ClientAuth#REQUIRE}).\n+         */\n+        Ssl setClientAuth(ClientAuth clientAuth) {\n+            this.clientAuth = clientAuth;\n+            return this;\n+        }\n+\n+        /**\n+         * Returns the supported SSL ciphers.\n+         * @return the supported SSL ciphers\n+         */\n+        @Nullable\n+        List<String> getCiphers() {\n+            return ciphers;\n+        }\n+\n+        /**\n+         * Sets the supported SSL ciphers.\n+         */\n+        Ssl setCiphers(List<String> ciphers) {\n+            this.ciphers = ciphers;\n+            return this;\n+        }\n+\n+        /**\n+         * Returns the enabled SSL protocols.\n+         * @return the enabled SSL protocols.\n+         */\n+        @Nullable\n+        List<String> getEnabledProtocols() {\n+            return enabledProtocols;\n+        }\n+\n+        /**\n+         * Sets the enabled SSL protocols.\n+         */\n+        Ssl setEnabledProtocols(List<String> enabledProtocols) {\n+            this.enabledProtocols = enabledProtocols;\n+            return this;\n+        }\n+\n+        /**\n+         * Returns the alias that identifies the key in the key store.\n+         * @return the key alias\n+         */\n+        @Nullable\n+        String getKeyAlias() {\n+            return keyAlias;\n+        }\n+\n+        /**\n+         * Sets the alias that identifies the key in the key store.\n+         */\n+        Ssl setKeyAlias(String keyAlias) {\n+            this.keyAlias = keyAlias;\n+            return this;\n+        }\n+\n+        /**\n+         * Returns the password used to access the key in the key store.\n+         * @return the key password\n+         */\n+        @Nullable\n+        String getKeyPassword() {\n+            return keyPassword;\n+        }\n+\n+        /**\n+         * Sets the password used to access the key in the key store.\n+         */\n+        Ssl setKeyPassword(String keyPassword) {\n+            this.keyPassword = keyPassword;\n+            return this;\n+        }\n+\n+        /**\n+         * Returns the path to the key store that holds the SSL certificate (typically a jks\n+         * file).\n+         * @return the path to the key store\n+         */\n+        @Nullable\n+        String getKeyStore() {\n+            return keyStore;\n+        }\n+\n+        /**\n+         * Sets the path to the key store that holds the SSL certificate (typically a jks file).\n+         */\n+        Ssl setKeyStore(String keyStore) {\n+            this.keyStore = keyStore;\n+            return this;\n+        }\n+\n+        /**\n+         * Returns the password used to access the key store.\n+         * @return the key store password\n+         */\n+        @Nullable\n+        String getKeyStorePassword() {\n+            return keyStorePassword;\n+        }\n+\n+        /**\n+         * Sets the password used to access the key store.\n+         */\n+        Ssl setKeyStorePassword(String keyStorePassword) {\n+            this.keyStorePassword = keyStorePassword;\n+            return this;\n+        }\n+\n+        /**\n+         * Returns the type of the key store.\n+         * @return the key store type\n+         */\n+        @Nullable\n+        String getKeyStoreType() {\n+            return keyStoreType;\n+        }\n+\n+        /**\n+         * Sets the type of the key store.\n+         */\n+        Ssl setKeyStoreType(String keyStoreType) {\n+            this.keyStoreType = keyStoreType;\n+            return this;\n+        }\n+\n+        /**\n+         * Returns the provider for the key store.\n+         * @return the key store provider\n+         */\n+        @Nullable\n+        String getKeyStoreProvider() {\n+            return keyStoreProvider;\n+        }\n+\n+        /**\n+         * Sets the provider for the key store.\n+         */\n+        Ssl setKeyStoreProvider(String keyStoreProvider) {\n+            this.keyStoreProvider = keyStoreProvider;\n+            return this;\n+        }\n+\n+        /**\n+         * Returns the trust store that holds SSL certificates.\n+         * @return the trust store\n+         */\n+        @Nullable\n+        String getTrustStore() {\n+            return trustStore;\n+        }\n+\n+        /**\n+         * Sets the trust store that holds SSL certificates.\n+         */\n+        Ssl setTrustStore(String trustStore) {\n+            this.trustStore = trustStore;\n+            return this;\n+        }\n+\n+        /**\n+         * Returns the password used to access the trust store.\n+         * @return the trust store password\n+         */\n+        @Nullable\n+        String getTrustStorePassword() {\n+            return trustStorePassword;\n+        }\n+\n+        /**\n+         * Sets the password used to access the trust store.\n+         */\n+        Ssl setTrustStorePassword(String trustStorePassword) {\n+            this.trustStorePassword = trustStorePassword;\n+            return this;\n+        }\n+\n+        /**\n+         * Returns the type of the trust store.\n+         * @return the trust store type\n+         */\n+        @Nullable\n+        String getTrustStoreType() {\n+            return trustStoreType;\n+        }\n+\n+        /**\n+         * Sets the type of the trust store.\n+         */\n+        Ssl setTrustStoreType(String trustStoreType) {\n+            this.trustStoreType = trustStoreType;\n+            return this;\n+        }\n+\n+        /**\n+         * Returns the provider for the trust store.\n+         * @return the trust store provider\n+         */\n+        @Nullable\n+        String getTrustStoreProvider() {\n+            return trustStoreProvider;\n+        }\n+\n+        /**\n+         * Sets the provider for the trust store.\n+         */\n+        Ssl setTrustStoreProvider(String trustStoreProvider) {\n+            this.trustStoreProvider = trustStoreProvider;\n+            return this;\n+        }\n+    }\n+\n+    /**\n+     * Configurations for the HTTP content encoding.\n+     */\n+    static class Compression {\n+        /**\n+         * Specifies whether the HTTP content encoding is enabled.\n+         */\n+        private boolean enabled;\n+\n+        /**\n+         * The MIME Types of an HTTP response which are applicable for the HTTP content encoding.\n+         */\n+        private String[] mimeTypes = {\n+                \"text/html\", \"text/xml\", \"text/plain\", \"text/css\", \"text/javascript\",\n+                \"application/javascript\", \"application/json\", \"application/xml\"", "originalCommit": "7413d196d7920dbfd9839d6017826caa01180713", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTY1MDczNQ==", "url": "https://github.com/line/armeria/pull/2373#discussion_r365650735", "bodyText": "Sounds good. \ud83d\udc4d", "author": "ikhoon", "createdAt": "2020-01-13T05:27:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTA4MzEzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTA4MzM2NQ==", "url": "https://github.com/line/armeria/pull/2373#discussion_r365083365", "bodyText": "nit: fields should be at top of class", "author": "OneCricketeer", "createdAt": "2020-01-10T06:00:34Z", "path": "dropwizard/src/main/java/com/linecorp/armeria/dropwizard/ArmeriaSettings.java", "diffHunk": "@@ -0,0 +1,955 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+/*\n+ * Copyright 2012-2018 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linecorp.armeria.dropwizard;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.Server;\n+import com.linecorp.armeria.server.VirtualHostBuilder;\n+\n+import io.netty.handler.ssl.ClientAuth;\n+import io.netty.handler.ssl.SslProvider;\n+\n+/**\n+ * Settings for armeria servers, e.g.,\n+ * <pre>{@code\n+ * gracefulShutdownQuietPeriodMillis: 5000\n+ * gracefulShutdownTimeoutMillis: 40000\n+ * maxRequestLength: 10485760\n+ * maxNumConnections: 5000\n+ * dateHeaderEnabled: false\n+ * serverHeaderEnabled: true\n+ * verboseResponses: false\n+ * defaultHostname: \"host.name.com\"\n+ * ports:\n+ *   - port: 8080\n+ *     protocol: HTTP\n+ *   - ip: 127.0.0.1\n+ *     port: 8081\n+ *     protocol: HTTP\n+ *   - port: 8443\n+ *     protocols:\n+ *       - HTTPS\n+ *       - PROXY\n+ * ssl:\n+ *   keyAlias: \"host.name.com\"\n+ *   keyStore: \"keystore.jks\"\n+ *   keyStorePassword: \"changeme\"\n+ *   trustStore: \"truststore.jks\"\n+ *   trustStorePassword: \"changeme\"\n+ * compression:\n+ *   enabled: true\n+ *   mimeTypes:\n+ *     - text/*\n+ *     - application/json\n+ *   excludedUserAgents:\n+ *     - some-user-agent\n+ *     - another-user-agent\n+ *   minResponseSize: 1KB\n+ * proxy:\n+ *   maxTlvSize: 65319\n+ * http1:\n+ *   maxChunkSize: 4096\n+ *   maxInitialLineLength: 4096\n+ * http2:\n+ *   initialConnectionWindowSize: 1MB\n+ *   initialStreamWindowSize: 1MB\n+ *   maxFrameSize: 16384\n+ *   maxHeaderListSize: 8192\n+ * accessLog:\n+ *   type: custom\n+ *   format: \"Your own log format\"\n+ * ...\n+ *\n+ * }</pre>\n+ * TODO(ikhoon): Merge this DroppWizard ArmeriaSettings with c.l.a.spring.ArmeriaSettings\n+ *               to provide common API to configure Server from JSON and YAML.\n+ */\n+class ArmeriaSettings {\n+\n+    /**\n+     * The ports to listen on for requests. If not specified, will listen on\n+     * port 8080 for HTTP (not SSL).\n+     */\n+    private List<Port> ports = new ArrayList<>();\n+\n+    /**\n+     * The number of milliseconds to wait after the last processed request to\n+     * be considered safe for shutdown. This should be set at least as long as\n+     * the slowest possible request to guarantee graceful shutdown. If {@code -1},\n+     * graceful shutdown will be disabled.\n+     */\n+    private long gracefulShutdownQuietPeriodMillis = 5000;\n+\n+    /**\n+     * The number of milliseconds to wait after going unhealthy before forcing\n+     * the server to shutdown regardless of if it is still processing requests.\n+     * This should be set as long as the maximum time for the load balancer to\n+     * turn off requests to the server. If {@code -1}, graceful shutdown will\n+     * be disabled.\n+     */\n+    private long gracefulShutdownTimeoutMillis = 40000;\n+\n+    /**\n+     * The maximum allowed length of the content decoded at the session layer.\n+     */\n+    @Nullable\n+    private Integer maxRequestLength;\n+\n+    /**\n+     * The maximum allowed number of open connections.\n+     */\n+    @Nullable\n+    private Integer maxNumConnections;\n+\n+    /**\n+     * If enabled, the {@code \"Date\"} header is included in the response header.\n+     */\n+    private boolean dateHeaderEnabled = true;\n+\n+    /**\n+     * If enabled, the {@code \"Server\"} header is included in the response header.\n+     */\n+    private boolean serverHeaderEnabled;\n+\n+    /**\n+     * {@code true} if the verbose response mode is enabled.\n+     */\n+    private boolean verboseResponses;\n+\n+    /**\n+     * The default hostname of the default {@link VirtualHostBuilder}.\n+     */\n+    @Nullable\n+    private String defaultHostname;\n+\n+    /**\n+     * SSL configuration that the {@link Server} uses.\n+     */\n+    @Nullable\n+    private Ssl ssl;\n+\n+    /**\n+     * Compression configuration that the {@link Server} uses.\n+     */\n+    @Nullable\n+    private Compression compression;\n+\n+    /**\n+     * HTTP/1 configuration that the {@link Server} uses.\n+     */\n+    @Nullable\n+    private Http1 http1;\n+\n+    /**\n+     * HTTP/2 configuration that the {@link Server} uses.\n+     */\n+    @Nullable\n+    private Http2 http2;\n+\n+    /**\n+     * PROXY configuration that the {@link Server} uses.\n+     */\n+    @Nullable\n+    private Proxy proxy;\n+\n+    /**\n+     * Access Log configuration that the {@link Server} uses.\n+     */\n+    @Nullable\n+    private AccessLog accessLog;\n+\n+    /**\n+     * Returns the {@link Port}s of the {@link Server}.\n+     */\n+    List<Port> getPorts() {\n+        return ports;\n+    }\n+\n+    /**\n+     * Sets the {@link Port}s of the {@link Server}.\n+     */\n+    void setPorts(List<Port> ports) {\n+        this.ports = ports;\n+    }\n+\n+    long getGracefulShutdownQuietPeriodMillis() {\n+        return gracefulShutdownQuietPeriodMillis;\n+    }\n+\n+    void setGracefulShutdownQuietPeriodMillis(long gracefulShutdownQuietPeriodMillis) {\n+        this.gracefulShutdownQuietPeriodMillis = gracefulShutdownQuietPeriodMillis;\n+    }\n+\n+    long getGracefulShutdownTimeoutMillis() {\n+        return gracefulShutdownTimeoutMillis;\n+    }\n+\n+    void setGracefulShutdownTimeoutMillis(long gracefulShutdownTimeoutMillis) {\n+        this.gracefulShutdownTimeoutMillis = gracefulShutdownTimeoutMillis;\n+    }\n+\n+    @Nullable\n+    Integer getMaxRequestLength() {\n+        return maxRequestLength;\n+    }\n+\n+    void setMaxRequestLength(@Nullable Integer maxRequestLength) {\n+        this.maxRequestLength = maxRequestLength;\n+    }\n+\n+    @Nullable\n+    Integer getMaxNumConnections() {\n+        return maxNumConnections;\n+    }\n+\n+    void setMaxNumConnections(Integer maxNumConnections) {\n+        this.maxNumConnections = maxNumConnections;\n+    }\n+\n+    boolean isDateHeaderEnabled() {\n+        return dateHeaderEnabled;\n+    }\n+\n+    void setDateHeaderEnabled(boolean dateHeaderEnabled) {\n+        this.dateHeaderEnabled = dateHeaderEnabled;\n+    }\n+\n+    boolean isServerHeaderEnabled() {\n+        return serverHeaderEnabled;\n+    }\n+\n+    void setServerHeaderEnabled(boolean serverHeaderEnabled) {\n+        this.serverHeaderEnabled = serverHeaderEnabled;\n+    }\n+\n+    boolean isVerboseResponses() {\n+        return verboseResponses;\n+    }\n+\n+    void setVerboseResponses(boolean verboseResponses) {\n+        this.verboseResponses = verboseResponses;\n+    }\n+\n+    @Nullable\n+    String getDefaultHostname() {\n+        return defaultHostname;\n+    }\n+\n+    void setDefaultHostname(@Nullable String defaultHostname) {\n+        this.defaultHostname = defaultHostname;\n+    }\n+\n+    @Nullable\n+    Ssl getSsl() {\n+        return ssl;\n+    }\n+\n+    void setSsl(Ssl ssl) {\n+        this.ssl = ssl;\n+    }\n+\n+    @Nullable\n+    Compression getCompression() {\n+        return compression;\n+    }\n+\n+    void setCompression(Compression compression) {\n+        this.compression = compression;\n+    }\n+\n+    @Nullable\n+    Http1 getHttp1() {\n+        return http1;\n+    }\n+\n+    void setHttp1(@Nullable Http1 http1) {\n+        this.http1 = http1;\n+    }\n+\n+    @Nullable\n+    Http2 getHttp2() {\n+        return http2;\n+    }\n+\n+    void setHttp2(@Nullable Http2 http2) {\n+        this.http2 = http2;\n+    }\n+\n+    @Nullable\n+    Proxy getProxy() {\n+        return proxy;\n+    }\n+\n+    void setProxy(@Nullable Proxy proxy) {\n+        this.proxy = proxy;\n+    }\n+\n+    @Nullable\n+    AccessLog getAccessLog() {\n+        return accessLog;\n+    }\n+\n+    void setAccessLog(@Nullable AccessLog accessLog) {\n+        this.accessLog = accessLog;\n+    }\n+\n+    /**\n+     * Port and protocol settings.\n+     */\n+    static class Port {\n+        /**\n+         * IP address to bind to. If not set, will bind to all addresses, e.g. {@code 0.0.0.0}.\n+         */\n+        @Nullable\n+        private String ip;\n+\n+        /**\n+         * Network interface to bind to. If not set, will bind to the first detected network interface.\n+         */\n+        @Nullable\n+        private String iface;\n+\n+        /**\n+         * Port that {@link Server} binds to.\n+         */\n+        private int port;\n+\n+        /**\n+         * Protocol that will be used in this ip/iface and port.\n+         */\n+        @Nullable\n+        private List<SessionProtocol> protocols;\n+\n+        @Nullable\n+        String getIp() {\n+            return ip;\n+        }\n+\n+        Port setIp(String ip) {\n+            this.ip = ip;\n+            return this;\n+        }\n+\n+        @Nullable\n+        String getIface() {\n+            return iface;\n+        }\n+\n+        Port setIface(String iface) {\n+            this.iface = iface;\n+            return this;\n+        }\n+\n+        int getPort() {\n+            return port;\n+        }\n+\n+        Port setPort(int port) {\n+            this.port = port;\n+            return this;\n+        }\n+\n+        @Nullable\n+        List<SessionProtocol> getProtocols() {\n+            return protocols;\n+        }\n+\n+        Port setProtocols(List<SessionProtocol> protocols) {\n+            this.protocols = ImmutableList.copyOf(protocols);\n+            return this;\n+        }\n+\n+        Port setProtocol(SessionProtocol protocol) {\n+            protocols = ImmutableList.of(protocol);\n+            return this;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) {\n+                return true;\n+            }\n+            if (!(o instanceof Port)) {\n+                return false;\n+            }\n+            final Port that = (Port) o;\n+            return port == that.port &&\n+                   Objects.equals(ip, that.ip) &&\n+                   Objects.equals(iface, that.iface) &&\n+                   Objects.equals(protocols, that.protocols);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(ip, iface, port, protocols);\n+        }\n+    }\n+\n+    /**\n+     * Simple server-independent abstraction for SSL configuration.\n+     *\n+     * @author Andy Wilkinson\n+     * @author Vladimir Tsanev\n+     * @author Stephane Nicoll\n+     */\n+    static class Ssl {\n+        private boolean enabled = true;\n+\n+        @Nullable\n+        private SslProvider provider;\n+\n+        @Nullable\n+        private ClientAuth clientAuth;\n+\n+        @Nullable\n+        private List<String> ciphers;\n+\n+        @Nullable\n+        private List<String> enabledProtocols;\n+\n+        @Nullable\n+        private String keyAlias;\n+\n+        @Nullable\n+        private String keyPassword;\n+\n+        @Nullable\n+        private String keyStore;\n+\n+        @Nullable\n+        private String keyStorePassword;\n+\n+        @Nullable\n+        private String keyStoreType;\n+\n+        @Nullable\n+        private String keyStoreProvider;\n+\n+        @Nullable\n+        private String trustStore;\n+\n+        @Nullable\n+        private String trustStorePassword;\n+\n+        @Nullable\n+        private String trustStoreType;\n+\n+        @Nullable\n+        private String trustStoreProvider;\n+\n+        /**\n+         * Returns whether to enable SSL support.\n+         * @return whether to enable SSL support\n+         */\n+        boolean isEnabled() {\n+            return enabled;\n+        }\n+\n+        /**\n+         * Enables (or disables) SSL support.\n+         */\n+        Ssl setEnabled(boolean enabled) {\n+            this.enabled = enabled;\n+            return this;\n+        }\n+\n+        /**\n+         * Returns Netty SSL Provider.\n+         * @return Netty SSL Provider\n+         */\n+        @Nullable\n+        SslProvider getProvider() {\n+            return provider;\n+        }\n+\n+        /**\n+         * Sets Netty SSL Provider namely JDK or OPENSSL  {@link SslProvider}.\n+         * @param provider Netty SSL Provider\n+         */\n+        void setProvider(SslProvider provider) {\n+            this.provider = provider;\n+        }\n+\n+        /**\n+         * Returns whether client authentication is not wanted (\"none\"), wanted (\"want\") or\n+         * needed (\"need\"). Requires a trust store.\n+         * @return the {@link ClientAuth} to use\n+         */\n+        @Nullable\n+        ClientAuth getClientAuth() {\n+            return clientAuth;\n+        }\n+\n+        /**\n+         * Sets whether the client authentication is not none ({@link ClientAuth#NONE}), optional\n+         * ({@link ClientAuth#OPTIONAL}) or required ({@link ClientAuth#REQUIRE}).\n+         */\n+        Ssl setClientAuth(ClientAuth clientAuth) {\n+            this.clientAuth = clientAuth;\n+            return this;\n+        }\n+\n+        /**\n+         * Returns the supported SSL ciphers.\n+         * @return the supported SSL ciphers\n+         */\n+        @Nullable\n+        List<String> getCiphers() {\n+            return ciphers;\n+        }\n+\n+        /**\n+         * Sets the supported SSL ciphers.\n+         */\n+        Ssl setCiphers(List<String> ciphers) {\n+            this.ciphers = ciphers;\n+            return this;\n+        }\n+\n+        /**\n+         * Returns the enabled SSL protocols.\n+         * @return the enabled SSL protocols.\n+         */\n+        @Nullable\n+        List<String> getEnabledProtocols() {\n+            return enabledProtocols;\n+        }\n+\n+        /**\n+         * Sets the enabled SSL protocols.\n+         */\n+        Ssl setEnabledProtocols(List<String> enabledProtocols) {\n+            this.enabledProtocols = enabledProtocols;\n+            return this;\n+        }\n+\n+        /**\n+         * Returns the alias that identifies the key in the key store.\n+         * @return the key alias\n+         */\n+        @Nullable\n+        String getKeyAlias() {\n+            return keyAlias;\n+        }\n+\n+        /**\n+         * Sets the alias that identifies the key in the key store.\n+         */\n+        Ssl setKeyAlias(String keyAlias) {\n+            this.keyAlias = keyAlias;\n+            return this;\n+        }\n+\n+        /**\n+         * Returns the password used to access the key in the key store.\n+         * @return the key password\n+         */\n+        @Nullable\n+        String getKeyPassword() {\n+            return keyPassword;\n+        }\n+\n+        /**\n+         * Sets the password used to access the key in the key store.\n+         */\n+        Ssl setKeyPassword(String keyPassword) {\n+            this.keyPassword = keyPassword;\n+            return this;\n+        }\n+\n+        /**\n+         * Returns the path to the key store that holds the SSL certificate (typically a jks\n+         * file).\n+         * @return the path to the key store\n+         */\n+        @Nullable\n+        String getKeyStore() {\n+            return keyStore;\n+        }\n+\n+        /**\n+         * Sets the path to the key store that holds the SSL certificate (typically a jks file).\n+         */\n+        Ssl setKeyStore(String keyStore) {\n+            this.keyStore = keyStore;\n+            return this;\n+        }\n+\n+        /**\n+         * Returns the password used to access the key store.\n+         * @return the key store password\n+         */\n+        @Nullable\n+        String getKeyStorePassword() {\n+            return keyStorePassword;\n+        }\n+\n+        /**\n+         * Sets the password used to access the key store.\n+         */\n+        Ssl setKeyStorePassword(String keyStorePassword) {\n+            this.keyStorePassword = keyStorePassword;\n+            return this;\n+        }\n+\n+        /**\n+         * Returns the type of the key store.\n+         * @return the key store type\n+         */\n+        @Nullable\n+        String getKeyStoreType() {\n+            return keyStoreType;\n+        }\n+\n+        /**\n+         * Sets the type of the key store.\n+         */\n+        Ssl setKeyStoreType(String keyStoreType) {\n+            this.keyStoreType = keyStoreType;\n+            return this;\n+        }\n+\n+        /**\n+         * Returns the provider for the key store.\n+         * @return the key store provider\n+         */\n+        @Nullable\n+        String getKeyStoreProvider() {\n+            return keyStoreProvider;\n+        }\n+\n+        /**\n+         * Sets the provider for the key store.\n+         */\n+        Ssl setKeyStoreProvider(String keyStoreProvider) {\n+            this.keyStoreProvider = keyStoreProvider;\n+            return this;\n+        }\n+\n+        /**\n+         * Returns the trust store that holds SSL certificates.\n+         * @return the trust store\n+         */\n+        @Nullable\n+        String getTrustStore() {\n+            return trustStore;\n+        }\n+\n+        /**\n+         * Sets the trust store that holds SSL certificates.\n+         */\n+        Ssl setTrustStore(String trustStore) {\n+            this.trustStore = trustStore;\n+            return this;\n+        }\n+\n+        /**\n+         * Returns the password used to access the trust store.\n+         * @return the trust store password\n+         */\n+        @Nullable\n+        String getTrustStorePassword() {\n+            return trustStorePassword;\n+        }\n+\n+        /**\n+         * Sets the password used to access the trust store.\n+         */\n+        Ssl setTrustStorePassword(String trustStorePassword) {\n+            this.trustStorePassword = trustStorePassword;\n+            return this;\n+        }\n+\n+        /**\n+         * Returns the type of the trust store.\n+         * @return the trust store type\n+         */\n+        @Nullable\n+        String getTrustStoreType() {\n+            return trustStoreType;\n+        }\n+\n+        /**\n+         * Sets the type of the trust store.\n+         */\n+        Ssl setTrustStoreType(String trustStoreType) {\n+            this.trustStoreType = trustStoreType;\n+            return this;\n+        }\n+\n+        /**\n+         * Returns the provider for the trust store.\n+         * @return the trust store provider\n+         */\n+        @Nullable\n+        String getTrustStoreProvider() {\n+            return trustStoreProvider;\n+        }\n+\n+        /**\n+         * Sets the provider for the trust store.\n+         */\n+        Ssl setTrustStoreProvider(String trustStoreProvider) {\n+            this.trustStoreProvider = trustStoreProvider;\n+            return this;\n+        }\n+    }\n+\n+    /**\n+     * Configurations for the HTTP content encoding.\n+     */\n+    static class Compression {\n+        /**\n+         * Specifies whether the HTTP content encoding is enabled.\n+         */\n+        private boolean enabled;\n+\n+        /**\n+         * The MIME Types of an HTTP response which are applicable for the HTTP content encoding.\n+         */\n+        private String[] mimeTypes = {\n+                \"text/html\", \"text/xml\", \"text/plain\", \"text/css\", \"text/javascript\",\n+                \"application/javascript\", \"application/json\", \"application/xml\"\n+        };\n+\n+        /**\n+         * The {@code \"user-agent\"} header values which are not applicable for the HTTP content encoding.\n+         */\n+        @Nullable\n+        private String[] excludedUserAgents;\n+\n+        /**\n+         * The minimum bytes for encoding the content of an HTTP response.\n+         */\n+        @Nullable\n+        private String minResponseSize;", "originalCommit": "7413d196d7920dbfd9839d6017826caa01180713", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTY0OTY0Mw==", "url": "https://github.com/line/armeria/pull/2373#discussion_r365649643", "bodyText": "I wonder why do you think this move to at top of the class? I guess because this is an important property than others?", "author": "ikhoon", "createdAt": "2020-01-13T05:17:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTA4MzM2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTA4NDAxNQ==", "url": "https://github.com/line/armeria/pull/2373#discussion_r365084015", "bodyText": "I'm not sure there's a good reason to persist this as a field. The builder is built after this method within the bundle. If anything, you could move the field within the anonymous class, but even there, I'm not sure what good it would do", "author": "OneCricketeer", "createdAt": "2020-01-10T06:04:22Z", "path": "dropwizard/src/test/java/com/linecorp/armeria/dropwizard/TestApplication.java", "diffHunk": "@@ -0,0 +1,46 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.dropwizard;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.server.ServerBuilder;\n+\n+import io.dropwizard.Application;\n+import io.dropwizard.setup.Bootstrap;\n+import io.dropwizard.setup.Environment;\n+\n+public class TestApplication extends Application<TestConfiguration> {\n+    @Nullable\n+    ServerBuilder serverBuilder;\n+\n+    @Override\n+    public void initialize(Bootstrap<TestConfiguration> bootstrap) {\n+        final ArmeriaBundle<TestConfiguration> bundle =\n+                new ArmeriaBundle<TestConfiguration>() {\n+                    @Override\n+                    public void configure(ServerBuilder builder) {\n+                        builder.service(\"/armeria\", (ctx, res) -> HttpResponse.of(\"Hello, Armeria!\"));\n+                        serverBuilder = builder;", "originalCommit": "7413d196d7920dbfd9839d6017826caa01180713", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTY0OTg1MA==", "url": "https://github.com/line/armeria/pull/2373#discussion_r365649850", "bodyText": "Thanks for pointing this. I added this for testing. It is not used anymore.", "author": "ikhoon", "createdAt": "2020-01-13T05:19:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTA4NDAxNQ=="}], "type": "inlineReview"}, {"oid": "2f77a760cd6203690c49dd6ed5d40cd0f13a4880", "url": "https://github.com/line/armeria/commit/2f77a760cd6203690c49dd6ed5d40cd0f13a4880", "message": "Address comments by @cricket007\n\n- Remove unused code\n- Use MediaType constants for compresssion", "committedDate": "2020-01-13T05:27:02Z", "type": "commit"}]}