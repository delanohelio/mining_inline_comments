{"pr_number": 2907, "pr_title": "Add client-side HAProxy support", "pr_createdAt": "2020-07-18T07:11:45Z", "pr_url": "https://github.com/line/armeria/pull/2907", "timeline": [{"oid": "13f99db570b8a72f253a2d6787b9e4e7c6226e33", "url": "https://github.com/line/armeria/commit/13f99db570b8a72f253a2d6787b9e4e7c6226e33", "message": "add failing tests", "committedDate": "2020-07-25T06:23:10Z", "type": "commit"}, {"oid": "6582e8ad60b5b14562331dba792d5cd063b0eb36", "url": "https://github.com/line/armeria/commit/6582e8ad60b5b14562331dba792d5cd063b0eb36", "message": "add minimal working implementation", "committedDate": "2020-07-25T13:33:18Z", "type": "commit"}, {"oid": "6582e8ad60b5b14562331dba792d5cd063b0eb36", "url": "https://github.com/line/armeria/commit/6582e8ad60b5b14562331dba792d5cd063b0eb36", "message": "add minimal working implementation", "committedDate": "2020-07-25T13:33:18Z", "type": "forcePushed"}, {"oid": "2c2902a774f288d72371dd46b222a3c74e43d413", "url": "https://github.com/line/armeria/commit/2c2902a774f288d72371dd46b222a3c74e43d413", "message": "fix hanging tests", "committedDate": "2020-07-25T15:09:11Z", "type": "commit"}, {"oid": "822f7c30fa65ac8ea4159799887d0b93ee43deb0", "url": "https://github.com/line/armeria/commit/822f7c30fa65ac8ea4159799887d0b93ee43deb0", "message": "refactor haproxyselector, improve tests, failure handling", "committedDate": "2020-07-26T06:26:49Z", "type": "commit"}, {"oid": "21d67faf1c9de0f729ddd26aa5dd56d37701a8ae", "url": "https://github.com/line/armeria/commit/21d67faf1c9de0f729ddd26aa5dd56d37701a8ae", "message": "flaky test, verify h1c retires, move api", "committedDate": "2020-07-26T07:14:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY0NDEzMQ==", "url": "https://github.com/line/armeria/pull/2907#discussion_r460644131", "bodyText": "Just Exception or Throwable?", "author": "trustin", "createdAt": "2020-07-27T04:45:59Z", "path": "core/src/main/java/com/linecorp/armeria/client/HAProxyHandler.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client;\n+\n+import static io.netty.handler.codec.haproxy.HAProxyCommand.PROXY;\n+import static io.netty.handler.codec.haproxy.HAProxyProtocolVersion.V2;\n+import static io.netty.handler.codec.haproxy.HAProxyProxiedProtocol.TCP4;\n+\n+import java.net.Inet4Address;\n+import java.net.Inet6Address;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.client.proxy.HAProxyConfig;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.handler.codec.haproxy.HAProxyMessage;\n+import io.netty.handler.codec.haproxy.HAProxyMessageEncoder;\n+import io.netty.handler.proxy.ProxyConnectException;\n+\n+class HAProxyHandler extends ChannelOutboundHandlerAdapter {\n+    private static final Logger logger = LoggerFactory.getLogger(HAProxyHandler.class);\n+\n+    private final HAProxyConfig haProxyConfig;\n+\n+    HAProxyHandler(HAProxyConfig haProxyConfig) {\n+        this.haProxyConfig = haProxyConfig;\n+    }\n+\n+    @Override\n+    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {\n+        ctx.pipeline().addBefore(ctx.name(), null, HAProxyMessageEncoder.INSTANCE);\n+        super.handlerAdded(ctx);\n+    }\n+\n+    @Override\n+    public void connect(ChannelHandlerContext ctx, SocketAddress remoteAddress,\n+                        SocketAddress localAddress, ChannelPromise promise) throws Exception {\n+        promise.addListener(f -> {\n+            if (!f.isSuccess()) {\n+                return;\n+            }\n+            try {\n+                ctx.write(createMessage(haProxyConfig, ctx.channel())).addListener(f0 -> {\n+                    if (f0.isSuccess()) {\n+                        ctx.pipeline().remove(HAProxyMessageEncoder.INSTANCE);\n+                    } else {\n+                        ctx.fireExceptionCaught(new ProxyConnectException(f.cause()));\n+                        ctx.close();\n+                    }\n+                });\n+            } catch (RuntimeException e) {", "originalCommit": "21d67faf1c9de0f729ddd26aa5dd56d37701a8ae", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY0NDMxNg==", "url": "https://github.com/line/armeria/pull/2907#discussion_r460644316", "bodyText": "How about throwing a ProxyConnectException instead of IAE?\nCould you include the source and destination addresses in the exception message?", "author": "trustin", "createdAt": "2020-07-27T04:46:50Z", "path": "core/src/main/java/com/linecorp/armeria/client/HAProxyHandler.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client;\n+\n+import static io.netty.handler.codec.haproxy.HAProxyCommand.PROXY;\n+import static io.netty.handler.codec.haproxy.HAProxyProtocolVersion.V2;\n+import static io.netty.handler.codec.haproxy.HAProxyProxiedProtocol.TCP4;\n+\n+import java.net.Inet4Address;\n+import java.net.Inet6Address;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.client.proxy.HAProxyConfig;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.handler.codec.haproxy.HAProxyMessage;\n+import io.netty.handler.codec.haproxy.HAProxyMessageEncoder;\n+import io.netty.handler.proxy.ProxyConnectException;\n+\n+class HAProxyHandler extends ChannelOutboundHandlerAdapter {\n+    private static final Logger logger = LoggerFactory.getLogger(HAProxyHandler.class);\n+\n+    private final HAProxyConfig haProxyConfig;\n+\n+    HAProxyHandler(HAProxyConfig haProxyConfig) {\n+        this.haProxyConfig = haProxyConfig;\n+    }\n+\n+    @Override\n+    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {\n+        ctx.pipeline().addBefore(ctx.name(), null, HAProxyMessageEncoder.INSTANCE);\n+        super.handlerAdded(ctx);\n+    }\n+\n+    @Override\n+    public void connect(ChannelHandlerContext ctx, SocketAddress remoteAddress,\n+                        SocketAddress localAddress, ChannelPromise promise) throws Exception {\n+        promise.addListener(f -> {\n+            if (!f.isSuccess()) {\n+                return;\n+            }\n+            try {\n+                ctx.write(createMessage(haProxyConfig, ctx.channel())).addListener(f0 -> {\n+                    if (f0.isSuccess()) {\n+                        ctx.pipeline().remove(HAProxyMessageEncoder.INSTANCE);\n+                    } else {\n+                        ctx.fireExceptionCaught(new ProxyConnectException(f.cause()));\n+                        ctx.close();\n+                    }\n+                });\n+            } catch (RuntimeException e) {\n+                ctx.channel().eventLoop().execute(\n+                        () -> ctx.pipeline().fireUserEventTriggered(new ProxyConnectException(e)));\n+                ctx.close();\n+            } finally {\n+                ctx.pipeline().remove(this);\n+            }\n+        });\n+        super.connect(ctx, remoteAddress, localAddress, promise);\n+    }\n+\n+    private static HAProxyMessage createMessage(HAProxyConfig haProxyConfig,\n+                                                Channel channel) throws ProxyConnectException {\n+        final InetSocketAddress srcSocketAddress =\n+                haProxyConfig.srcAddress() != null ? haProxyConfig.srcAddress()\n+                                                   : (InetSocketAddress) channel.localAddress();\n+        final InetSocketAddress destSockAddress = haProxyConfig.proxyAddress();\n+        assert destSockAddress != null;\n+\n+        final InetAddress srcAddress = srcSocketAddress.getAddress();\n+        final InetAddress destAddress = destSockAddress.getAddress();\n+\n+        if (srcAddress instanceof Inet4Address && destAddress instanceof Inet4Address) {\n+            return new HAProxyMessage(V2, PROXY, TCP4,\n+                                      srcAddress.getHostAddress(),\n+                                      destAddress.getHostAddress(),\n+                                      srcSocketAddress.getPort(), destSockAddress.getPort());\n+        } else if (srcAddress instanceof Inet6Address && destAddress instanceof Inet6Address) {\n+            return new HAProxyMessage(V2, PROXY, TCP4,\n+                                      srcAddress.getHostAddress(),\n+                                      destAddress.getHostAddress(),\n+                                      srcSocketAddress.getPort(), destSockAddress.getPort());\n+        } else {\n+            logger.warn(\"Incompatible PROXY address types. srcSocketAddress: {}, destSockAddress: {}\",\n+                        srcAddress.getClass(), destAddress.getClass());\n+            throw new IllegalArgumentException(\"incompatible addresses\");", "originalCommit": "21d67faf1c9de0f729ddd26aa5dd56d37701a8ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ4NzQ5MA==", "url": "https://github.com/line/armeria/pull/2907#discussion_r461487490", "bodyText": "How about throwing a ProxyConnectException instead of IAE\n\nThis was intentional since 1) this is a private method 2) I didn't want to deal with checking if ProxyConnectException and wrapping in the upper level.\nLet me know if you prefer otherwise though.", "author": "jrhee17", "createdAt": "2020-07-28T10:43:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY0NDMxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAyMTk4Mw==", "url": "https://github.com/line/armeria/pull/2907#discussion_r462021983", "bodyText": "I'd prefer throwing ProxyConnectException, so that we do not have to expose IAE in user's stack trace.", "author": "trustin", "createdAt": "2020-07-29T03:51:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY0NDMxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY0NDYxNg==", "url": "https://github.com/line/armeria/pull/2907#discussion_r460644616", "bodyText": "// TODO(jrhee17): <more specific action items>", "author": "trustin", "createdAt": "2020-07-27T04:48:14Z", "path": "core/src/main/java/com/linecorp/armeria/client/HttpSessionHandler.java", "diffHunk": "@@ -336,7 +336,9 @@ public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exc\n                 throw new Error(); // Should never reach here.\n             }\n \n-            if (poolKey.proxyConfig.proxyType() != ProxyType.DIRECT) {\n+            // TODO: this can be improved", "originalCommit": "21d67faf1c9de0f729ddd26aa5dd56d37701a8ae", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY0NDg5NQ==", "url": "https://github.com/line/armeria/pull/2907#discussion_r460644895", "bodyText": "sourceAddress?", "author": "trustin", "createdAt": "2020-07-27T04:49:30Z", "path": "core/src/main/java/com/linecorp/armeria/client/proxy/HAProxyConfig.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.proxy;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Objects;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.MoreObjects;\n+\n+/**\n+ * HAPROXY proxy configuration.\n+ */\n+public final class HAProxyConfig extends ProxyConfig {\n+\n+    @Nullable\n+    private final InetSocketAddress srcAddress;\n+\n+    private final InetSocketAddress destAddress;\n+\n+    HAProxyConfig(InetSocketAddress destAddress) {\n+        srcAddress = null;\n+        this.destAddress = destAddress;\n+    }\n+\n+    HAProxyConfig(InetSocketAddress srcAddress, InetSocketAddress destAddress) {\n+        checkArgument(srcAddress.getAddress().getClass() == destAddress.getAddress().getClass(),\n+                      \"srcAddress and destAddress should be the same type\");\n+        this.srcAddress = srcAddress;\n+        this.destAddress = destAddress;\n+    }\n+\n+    @Override\n+    public InetSocketAddress proxyAddress() {\n+        return destAddress;\n+    }\n+\n+    @Override\n+    public ProxyType proxyType() {\n+        return ProxyType.HAPROXY;\n+    }\n+\n+    /**\n+     * TBU.\n+     */\n+    @Nullable\n+    public InetSocketAddress srcAddress() {\n+        return srcAddress;", "originalCommit": "21d67faf1c9de0f729ddd26aa5dd56d37701a8ae", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY0NTE2Nw==", "url": "https://github.com/line/armeria/pull/2907#discussion_r460645167", "bodyText": "proxy protocol -> protocol?", "author": "trustin", "createdAt": "2020-07-27T04:50:35Z", "path": "core/src/main/java/com/linecorp/armeria/client/proxy/ProxyType.java", "diffHunk": "@@ -39,5 +39,10 @@\n     /**\n      * CONNECT proxy protocol.\n      */\n-    CONNECT\n+    CONNECT,\n+\n+    /**\n+     * HAPROXY proxy protocol.", "originalCommit": "21d67faf1c9de0f729ddd26aa5dd56d37701a8ae", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "31c2c4fa282b1b15d288516631e5dc00e2d4f369", "url": "https://github.com/line/armeria/commit/31c2c4fa282b1b15d288516631e5dc00e2d4f369", "message": "fix javadocs, rename variables", "committedDate": "2020-07-28T10:40:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTUwMTgyOQ==", "url": "https://github.com/line/armeria/pull/2907#discussion_r461501829", "bodyText": "Shouldn't we call ctx.close() after calling fireUserEventTriggered()?", "author": "minwoox", "createdAt": "2020-07-28T11:12:21Z", "path": "core/src/main/java/com/linecorp/armeria/client/HAProxyHandler.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client;\n+\n+import static io.netty.handler.codec.haproxy.HAProxyCommand.PROXY;\n+import static io.netty.handler.codec.haproxy.HAProxyProtocolVersion.V2;\n+import static io.netty.handler.codec.haproxy.HAProxyProxiedProtocol.TCP4;\n+\n+import java.net.Inet4Address;\n+import java.net.Inet6Address;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.client.proxy.HAProxyConfig;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.handler.codec.haproxy.HAProxyMessage;\n+import io.netty.handler.codec.haproxy.HAProxyMessageEncoder;\n+import io.netty.handler.proxy.ProxyConnectException;\n+\n+class HAProxyHandler extends ChannelOutboundHandlerAdapter {\n+    private static final Logger logger = LoggerFactory.getLogger(HAProxyHandler.class);\n+\n+    private final HAProxyConfig haProxyConfig;\n+\n+    HAProxyHandler(HAProxyConfig haProxyConfig) {\n+        this.haProxyConfig = haProxyConfig;\n+    }\n+\n+    @Override\n+    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {\n+        ctx.pipeline().addBefore(ctx.name(), null, HAProxyMessageEncoder.INSTANCE);\n+        super.handlerAdded(ctx);\n+    }\n+\n+    @Override\n+    public void connect(ChannelHandlerContext ctx, SocketAddress remoteAddress,\n+                        SocketAddress localAddress, ChannelPromise promise) throws Exception {\n+        promise.addListener(f -> {\n+            if (!f.isSuccess()) {\n+                return;\n+            }\n+            try {\n+                ctx.write(createMessage(haProxyConfig, ctx.channel())).addListener(f0 -> {\n+                    if (f0.isSuccess()) {\n+                        ctx.pipeline().remove(HAProxyMessageEncoder.INSTANCE);\n+                    } else {\n+                        ctx.fireExceptionCaught(new ProxyConnectException(f0.cause()));\n+                        ctx.close();\n+                    }\n+                });\n+            } catch (Exception e) {\n+                ctx.channel().eventLoop().execute(\n+                        () -> ctx.pipeline().fireUserEventTriggered(new ProxyConnectException(e)));\n+                ctx.close();", "originalCommit": "31c2c4fa282b1b15d288516631e5dc00e2d4f369", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTYyMDY2Mw==", "url": "https://github.com/line/armeria/pull/2907#discussion_r461620663", "bodyText": "\ud83e\udd85  \ud83d\udc41\ufe0f.\nI also found another place doing this:\n\n  \n    \n      armeria/core/src/main/java/com/linecorp/armeria/client/HttpClientPipelineConfigurator.java\n    \n    \n        Lines 372 to 375\n      in\n      4d417ea\n    \n    \n    \n    \n\n        \n          \n           pipeline.channel().eventLoop().execute( \n        \n\n        \n          \n                   () -> pipeline.fireUserEventTriggered( \n        \n\n        \n          \n                           new SessionProtocolNegotiationException(expected, actual, reason))); \n        \n\n        \n          \n           ctx.close(); \n        \n    \n  \n\n\nThe behavior would be only slightly less informative exception messages, so I don't think going through the code and correcting all instances of this is critical though.", "author": "jrhee17", "createdAt": "2020-07-28T14:21:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTUwMTgyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTUwNDI4MQ==", "url": "https://github.com/line/armeria/pull/2907#discussion_r461504281", "bodyText": "nit: consistency? socket or sock\nOr we could just srdAddress and destAddress", "author": "minwoox", "createdAt": "2020-07-28T11:16:58Z", "path": "core/src/main/java/com/linecorp/armeria/client/HAProxyHandler.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client;\n+\n+import static io.netty.handler.codec.haproxy.HAProxyCommand.PROXY;\n+import static io.netty.handler.codec.haproxy.HAProxyProtocolVersion.V2;\n+import static io.netty.handler.codec.haproxy.HAProxyProxiedProtocol.TCP4;\n+\n+import java.net.Inet4Address;\n+import java.net.Inet6Address;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.client.proxy.HAProxyConfig;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.handler.codec.haproxy.HAProxyMessage;\n+import io.netty.handler.codec.haproxy.HAProxyMessageEncoder;\n+import io.netty.handler.proxy.ProxyConnectException;\n+\n+class HAProxyHandler extends ChannelOutboundHandlerAdapter {\n+    private static final Logger logger = LoggerFactory.getLogger(HAProxyHandler.class);\n+\n+    private final HAProxyConfig haProxyConfig;\n+\n+    HAProxyHandler(HAProxyConfig haProxyConfig) {\n+        this.haProxyConfig = haProxyConfig;\n+    }\n+\n+    @Override\n+    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {\n+        ctx.pipeline().addBefore(ctx.name(), null, HAProxyMessageEncoder.INSTANCE);\n+        super.handlerAdded(ctx);\n+    }\n+\n+    @Override\n+    public void connect(ChannelHandlerContext ctx, SocketAddress remoteAddress,\n+                        SocketAddress localAddress, ChannelPromise promise) throws Exception {\n+        promise.addListener(f -> {\n+            if (!f.isSuccess()) {\n+                return;\n+            }\n+            try {\n+                ctx.write(createMessage(haProxyConfig, ctx.channel())).addListener(f0 -> {\n+                    if (f0.isSuccess()) {\n+                        ctx.pipeline().remove(HAProxyMessageEncoder.INSTANCE);\n+                    } else {\n+                        ctx.fireExceptionCaught(new ProxyConnectException(f0.cause()));\n+                        ctx.close();\n+                    }\n+                });\n+            } catch (Exception e) {\n+                ctx.channel().eventLoop().execute(\n+                        () -> ctx.pipeline().fireUserEventTriggered(new ProxyConnectException(e)));\n+                ctx.close();\n+            } finally {\n+                ctx.pipeline().remove(this);\n+            }\n+        });\n+        super.connect(ctx, remoteAddress, localAddress, promise);\n+    }\n+\n+    private static HAProxyMessage createMessage(HAProxyConfig haProxyConfig,\n+                                                Channel channel) throws ProxyConnectException {\n+        final InetSocketAddress srcSocketAddress =\n+                haProxyConfig.sourceAddress() != null ? haProxyConfig.sourceAddress()\n+                                                      : (InetSocketAddress) channel.localAddress();\n+        final InetSocketAddress destSockAddress = haProxyConfig.proxyAddress();", "originalCommit": "31c2c4fa282b1b15d288516631e5dc00e2d4f369", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ab500a254487d6428d182ae231c09b9bc5a73fa5", "url": "https://github.com/line/armeria/commit/ab500a254487d6428d182ae231c09b9bc5a73fa5", "message": "close after userevent, consistent naming", "committedDate": "2020-07-28T14:18:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAxOTkwOA==", "url": "https://github.com/line/armeria/pull/2907#discussion_r462019908", "bodyText": "Could move this method to ProxyType and make it a member method?", "author": "trustin", "createdAt": "2020-07-29T03:43:21Z", "path": "core/src/main/java/com/linecorp/armeria/client/HttpSessionHandler.java", "diffHunk": "@@ -446,4 +447,8 @@ static void setPendingException(ChannelHandlerContext ctx, Throwable cause) {\n             logger.warn(\"{} Unexpected suppressed exception:\", ctx.channel(), cause);\n         }\n     }\n+\n+    private static boolean isTunnelingProxy(ProxyType proxyType) {\n+        return proxyType != ProxyType.DIRECT && proxyType != ProxyType.HAPROXY;\n+    }", "originalCommit": "ab500a254487d6428d182ae231c09b9bc5a73fa5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAyMDAyNg==", "url": "https://github.com/line/armeria/pull/2907#discussion_r462020026", "bodyText": "Could add a hyperlink to the HAPROXY web page.", "author": "trustin", "createdAt": "2020-07-29T03:43:56Z", "path": "core/src/main/java/com/linecorp/armeria/client/proxy/HAProxyConfig.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.proxy;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Objects;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.MoreObjects;\n+\n+/**\n+ * HAPROXY configuration.", "originalCommit": "ab500a254487d6428d182ae231c09b9bc5a73fa5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjEyMjUwNQ==", "url": "https://github.com/line/armeria/pull/2907#discussion_r462122505", "bodyText": "nit: final class", "author": "minwoox", "createdAt": "2020-07-29T08:18:19Z", "path": "core/src/main/java/com/linecorp/armeria/client/HAProxyHandler.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client;\n+\n+import static io.netty.handler.codec.haproxy.HAProxyCommand.PROXY;\n+import static io.netty.handler.codec.haproxy.HAProxyProtocolVersion.V2;\n+import static io.netty.handler.codec.haproxy.HAProxyProxiedProtocol.TCP4;\n+\n+import java.net.Inet4Address;\n+import java.net.Inet6Address;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.client.proxy.HAProxyConfig;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.handler.codec.haproxy.HAProxyMessage;\n+import io.netty.handler.codec.haproxy.HAProxyMessageEncoder;\n+import io.netty.handler.proxy.ProxyConnectException;\n+\n+class HAProxyHandler extends ChannelOutboundHandlerAdapter {", "originalCommit": "ab500a254487d6428d182ae231c09b9bc5a73fa5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjEzMjg3MA==", "url": "https://github.com/line/armeria/pull/2907#discussion_r462132870", "bodyText": "I'm wondering if we need to complete this promise after HAProxyMessage is written successfully so that any message does not go through HAProxyMessageEncoder before it's removed. \ud83e\udd14", "author": "minwoox", "createdAt": "2020-07-29T08:34:39Z", "path": "core/src/main/java/com/linecorp/armeria/client/HAProxyHandler.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client;\n+\n+import static io.netty.handler.codec.haproxy.HAProxyCommand.PROXY;\n+import static io.netty.handler.codec.haproxy.HAProxyProtocolVersion.V2;\n+import static io.netty.handler.codec.haproxy.HAProxyProxiedProtocol.TCP4;\n+\n+import java.net.Inet4Address;\n+import java.net.Inet6Address;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.client.proxy.HAProxyConfig;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.handler.codec.haproxy.HAProxyMessage;\n+import io.netty.handler.codec.haproxy.HAProxyMessageEncoder;\n+import io.netty.handler.proxy.ProxyConnectException;\n+\n+class HAProxyHandler extends ChannelOutboundHandlerAdapter {\n+    private static final Logger logger = LoggerFactory.getLogger(HAProxyHandler.class);\n+\n+    private final HAProxyConfig haProxyConfig;\n+\n+    HAProxyHandler(HAProxyConfig haProxyConfig) {\n+        this.haProxyConfig = haProxyConfig;\n+    }\n+\n+    @Override\n+    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {\n+        ctx.pipeline().addBefore(ctx.name(), null, HAProxyMessageEncoder.INSTANCE);\n+        super.handlerAdded(ctx);\n+    }\n+\n+    @Override\n+    public void connect(ChannelHandlerContext ctx, SocketAddress remoteAddress,\n+                        SocketAddress localAddress, ChannelPromise promise) throws Exception {\n+        promise.addListener(f -> {", "originalCommit": "ab500a254487d6428d182ae231c09b9bc5a73fa5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIyMTQ3NA==", "url": "https://github.com/line/armeria/pull/2907#discussion_r462221474", "bodyText": "Even if HAProxyMessageEncoderremains in the pipeline, it is 1) stateless and 2) an MessageToByteEncoder, so I don't think it will really affect the actual http request.", "author": "jrhee17", "createdAt": "2020-07-29T11:13:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjEzMjg3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI5MTM4NA==", "url": "https://github.com/line/armeria/pull/2907#discussion_r462291384", "bodyText": "Thanks for the explanation. \ud83d\ude04", "author": "minwoox", "createdAt": "2020-07-29T13:19:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjEzMjg3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjEzNDU3Nw==", "url": "https://github.com/line/armeria/pull/2907#discussion_r462134577", "bodyText": "Can we follow the pattern?\nfinal EventLoop eventLoop = ctx.channel().eventLoop();\nif (eventLoop.inEventLoop()) {\n    ctx.pipeline().fireUserEventTriggered(new ProxyConnectException(e));\n    ctx.close();\n} else {\n    ....\n}", "author": "minwoox", "createdAt": "2020-07-29T08:37:34Z", "path": "core/src/main/java/com/linecorp/armeria/client/HAProxyHandler.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client;\n+\n+import static io.netty.handler.codec.haproxy.HAProxyCommand.PROXY;\n+import static io.netty.handler.codec.haproxy.HAProxyProtocolVersion.V2;\n+import static io.netty.handler.codec.haproxy.HAProxyProxiedProtocol.TCP4;\n+\n+import java.net.Inet4Address;\n+import java.net.Inet6Address;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.client.proxy.HAProxyConfig;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.handler.codec.haproxy.HAProxyMessage;\n+import io.netty.handler.codec.haproxy.HAProxyMessageEncoder;\n+import io.netty.handler.proxy.ProxyConnectException;\n+\n+class HAProxyHandler extends ChannelOutboundHandlerAdapter {\n+    private static final Logger logger = LoggerFactory.getLogger(HAProxyHandler.class);\n+\n+    private final HAProxyConfig haProxyConfig;\n+\n+    HAProxyHandler(HAProxyConfig haProxyConfig) {\n+        this.haProxyConfig = haProxyConfig;\n+    }\n+\n+    @Override\n+    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {\n+        ctx.pipeline().addBefore(ctx.name(), null, HAProxyMessageEncoder.INSTANCE);\n+        super.handlerAdded(ctx);\n+    }\n+\n+    @Override\n+    public void connect(ChannelHandlerContext ctx, SocketAddress remoteAddress,\n+                        SocketAddress localAddress, ChannelPromise promise) throws Exception {\n+        promise.addListener(f -> {\n+            if (!f.isSuccess()) {\n+                return;\n+            }\n+            try {\n+                ctx.write(createMessage(haProxyConfig, ctx.channel())).addListener(f0 -> {\n+                    if (f0.isSuccess()) {\n+                        ctx.pipeline().remove(HAProxyMessageEncoder.INSTANCE);\n+                    } else {\n+                        ctx.fireExceptionCaught(new ProxyConnectException(f0.cause()));\n+                        ctx.close();\n+                    }\n+                });\n+            } catch (Exception e) {\n+                ctx.channel().eventLoop().execute(() -> {", "originalCommit": "ab500a254487d6428d182ae231c09b9bc5a73fa5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIyMTk0NA==", "url": "https://github.com/line/armeria/pull/2907#discussion_r462221944", "bodyText": "Actually this is already in the event loop -- I am just rescheduling since other handlers aren't added yet.", "author": "jrhee17", "createdAt": "2020-07-29T11:14:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjEzNDU3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI5MzUwMw==", "url": "https://github.com/line/armeria/pull/2907#discussion_r462293503", "bodyText": "other handlers aren't added yet.\n\nI think I don't fully understand the flow of how handlers are added.\nCould you elaborate more on this like which handlers can be added in the meantime, please? \ud83d\ude04", "author": "minwoox", "createdAt": "2020-07-29T13:22:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjEzNDU3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjM1MTg1Ng==", "url": "https://github.com/line/armeria/pull/2907#discussion_r462351856", "bodyText": "I don't understand fully either \ud83d\ude04 , but here is my understanding:\n\nHAProxyHandler is the added as the first handler and the listener is added immediately in the same thread when invoking HttpChannelPool.bootstrap.connect.\nAfterwards, the listener is added at HttpChannelPool for adding HttpSessionHandler (same thread as 1)\n\n  \n    \n      armeria/core/src/main/java/com/linecorp/armeria/client/HttpChannelPool.java\n    \n    \n         Line 405\n      in\n      d30e82d\n    \n    \n    \n    \n\n        \n          \n           connectFuture.addListener((ChannelFuture future) -> { \n        \n    \n  \n\n\nWhen connect is successful and an exception is thrown, the HAProxyHandler listener is invoked first. At this time, HttpChannelPool listener isn't invoked yet and the HttpSessionHandler isn't in the pipeline. Consequently, userEventTriggered isn't handled by HttpSessionHandler.\n\nAlthough HttpClientPipelineConfigurator doesn't add listeners directly, I was assuming the following block is aiming for the same effect as well.\n\n  \n    \n      armeria/core/src/main/java/com/linecorp/armeria/client/HttpClientPipelineConfigurator.java\n    \n    \n         Line 348\n      in\n      d30e82d\n    \n    \n    \n    \n\n        \n          \n           pipeline.channel().eventLoop().execute(() -> pipeline.fireUserEventTriggered(protocol));", "author": "jrhee17", "createdAt": "2020-07-29T14:39:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjEzNDU3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjcwMTIwNw==", "url": "https://github.com/line/armeria/pull/2907#discussion_r462701207", "bodyText": "Ah, thanks a lot for the detailed explanation. \ud83d\ude47\u200d\u2642\ufe0f\nCould you add a comment for this?\n// Call fireUserEventTriggered in the executor to execute it after the HttpSessionHandler is added to the pipeline.", "author": "minwoox", "createdAt": "2020-07-30T02:43:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjEzNDU3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjEzOTg1Mg==", "url": "https://github.com/line/armeria/pull/2907#discussion_r462139852", "bodyText": "It's fine to add another version which only takes destinationAddress?", "author": "minwoox", "createdAt": "2020-07-29T08:46:50Z", "path": "core/src/main/java/com/linecorp/armeria/client/proxy/ProxyConfig.java", "diffHunk": "@@ -119,6 +119,21 @@ public static ConnectProxyConfig connect(\n                                       requireNonNull(password, \"password\"), useTls);\n     }\n \n+    /**\n+     * Creates a {@code ProxyConfig} configuration for HAProxy protocol.\n+     *\n+     * @param sourceAddress the source address\n+     * @param destinationAddress the destination address\n+     */\n+    public static HAProxyConfig haproxy(\n+            InetSocketAddress sourceAddress, InetSocketAddress destinationAddress) {", "originalCommit": "ab500a254487d6428d182ae231c09b9bc5a73fa5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIzNDAwMg==", "url": "https://github.com/line/armeria/pull/2907#discussion_r462234002", "bodyText": "Will address after APIs discussion is finalized \ud83d\ude05", "author": "jrhee17", "createdAt": "2020-07-29T11:38:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjEzOTg1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE0MDE5MQ==", "url": "https://github.com/line/armeria/pull/2907#discussion_r462140191", "bodyText": "How about making this as enum singleton?", "author": "minwoox", "createdAt": "2020-07-29T08:47:22Z", "path": "core/src/main/java/com/linecorp/armeria/client/proxy/HAProxyConfigSelector.java", "diffHunk": "@@ -0,0 +1,46 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.proxy;\n+\n+import java.net.InetSocketAddress;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.ProxiedAddresses;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+class HAProxyConfigSelector implements ProxyConfigSelector {", "originalCommit": "ab500a254487d6428d182ae231c09b9bc5a73fa5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9873f1edb058fe3a7887149e8276183387c88269", "url": "https://github.com/line/armeria/commit/9873f1edb058fe3a7887149e8276183387c88269", "message": "hide iae, add isTunnel, prefer singleton", "committedDate": "2020-07-29T11:02:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjM3MDg1Nw==", "url": "https://github.com/line/armeria/pull/2907#discussion_r462370857", "bodyText": "Could call ServiceRequestContext.currentOrNull() directly?", "author": "ikhoon", "createdAt": "2020-07-29T15:04:41Z", "path": "core/src/main/java/com/linecorp/armeria/client/proxy/HAProxyConfigSelector.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.proxy;\n+\n+import java.net.InetSocketAddress;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.ProxiedAddresses;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+final class HAProxyConfigSelector implements ProxyConfigSelector {\n+\n+    private HAProxyConfigSelector() {\n+    }\n+\n+    static final HAProxyConfigSelector INSTANCE = new HAProxyConfigSelector();\n+\n+    @Override\n+    public ProxyConfig select(SessionProtocol protocol, Endpoint endpoint) {\n+        // use proxy information in context if available\n+        final ClientRequestContext clientCtx = ClientRequestContext.currentOrNull();\n+        if (clientCtx != null && clientCtx.root() != null) {", "originalCommit": "9873f1edb058fe3a7887149e8276183387c88269", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzEyOTkzOA==", "url": "https://github.com/line/armeria/pull/2907#discussion_r463129938", "bodyText": "Actually if a ServiceRequestContext doesn't exist, an exception will be thrown (contrary to what the method looks like it will do \ud83e\udd14 )", "author": "jrhee17", "createdAt": "2020-07-30T16:42:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjM3MDg1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzkzMjc0NA==", "url": "https://github.com/line/armeria/pull/2907#discussion_r463932744", "bodyText": "I see. I didn't think of that. Let's keep it as it as.", "author": "ikhoon", "createdAt": "2020-08-01T07:05:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjM3MDg1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE4MTA4OQ==", "url": "https://github.com/line/armeria/pull/2907#discussion_r464181089", "bodyText": "Let's use ServiceRequestContext.currentOrNull() after #2962 is merged. \ud83d\ude09", "author": "minwoox", "createdAt": "2020-08-03T03:52:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjM3MDg1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDIwNzI2OA==", "url": "https://github.com/line/armeria/pull/2907#discussion_r464207268", "bodyText": "I'll update this after #2962  is merged \ud83d\ude04", "author": "jrhee17", "createdAt": "2020-08-03T05:55:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjM3MDg1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjM4NjY2NQ==", "url": "https://github.com/line/armeria/pull/2907#discussion_r462386665", "bodyText": "nit: Introduce a local variable for future.cause()?", "author": "ikhoon", "createdAt": "2020-07-29T15:25:55Z", "path": "core/src/main/java/com/linecorp/armeria/client/HttpChannelPool.java", "diffHunk": "@@ -531,6 +536,9 @@ private void notifyConnect(SessionProtocol desiredProtocol, PoolKey key, Future<\n                     }\n                 });\n             } else {\n+                if (future.cause() instanceof ProxyConnectException) {", "originalCommit": "9873f1edb058fe3a7887149e8276183387c88269", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c199cef542f6cbd2ac4d44e07ac0fc99142beef9", "url": "https://github.com/line/armeria/commit/c199cef542f6cbd2ac4d44e07ac0fc99142beef9", "message": "connect to proxyaddress instead of client endpoint", "committedDate": "2020-07-30T16:48:55Z", "type": "commit"}, {"oid": "c199cef542f6cbd2ac4d44e07ac0fc99142beef9", "url": "https://github.com/line/armeria/commit/c199cef542f6cbd2ac4d44e07ac0fc99142beef9", "message": "connect to proxyaddress instead of client endpoint", "committedDate": "2020-07-30T16:48:55Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE3MDY5Ng==", "url": "https://github.com/line/armeria/pull/2907#discussion_r464170696", "bodyText": "Shouldn't this come before .add()s?", "author": "trustin", "createdAt": "2020-08-03T03:01:10Z", "path": "core/src/main/java/com/linecorp/armeria/client/proxy/HAProxyConfig.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.proxy;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Objects;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.MoreObjects;\n+\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+/**\n+ * <a href=\"http://www.haproxy.org/download/1.8/doc/proxy-protocol.txt\">HAPROXY configuration.</a>\n+ */\n+public final class HAProxyConfig extends ProxyConfig {\n+\n+    private final InetSocketAddress proxyAddress;\n+\n+    @Nullable\n+    private final InetSocketAddress sourceAddress;\n+\n+    HAProxyConfig(InetSocketAddress proxyAddress) {\n+        this.proxyAddress = proxyAddress;\n+        sourceAddress = null;\n+    }\n+\n+    HAProxyConfig(InetSocketAddress proxyAddress, InetSocketAddress sourceAddress) {\n+        checkArgument(sourceAddress.getAddress().getClass() == proxyAddress.getAddress().getClass(),\n+                      \"sourceAddress and proxyAddress should be the same type\");\n+        this.proxyAddress = proxyAddress;\n+        this.sourceAddress = sourceAddress;\n+    }\n+\n+    @Override\n+    public ProxyType proxyType() {\n+        return ProxyType.HAPROXY;\n+    }\n+\n+    @Override\n+    public InetSocketAddress proxyAddress() {\n+        return proxyAddress;\n+    }\n+\n+    /**\n+     * Represents the source address. When this value is {@code null}, it will be inferred\n+     * from either the {@link ServiceRequestContext} or the local connection address.\n+     */\n+    @Nullable\n+    public InetSocketAddress sourceAddress() {\n+        return sourceAddress;\n+    }\n+\n+    @Override\n+    public boolean equals(@Nullable Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (!(o instanceof HAProxyConfig)) {\n+            return false;\n+        }\n+        final HAProxyConfig that = (HAProxyConfig) o;\n+        return proxyAddress.equals(that.proxyAddress) &&\n+               Objects.equals(sourceAddress, that.sourceAddress);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(proxyAddress, sourceAddress);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return MoreObjects.toStringHelper(this)\n+                          .add(\"proxyType\", proxyType())\n+                          .add(\"proxyAddress\", proxyAddress)\n+                          .add(\"sourceAddress\", sourceAddress)\n+                          .omitNullValues()", "originalCommit": "c199cef542f6cbd2ac4d44e07ac0fc99142beef9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDIwNjg4Nw==", "url": "https://github.com/line/armeria/pull/2907#discussion_r464206887", "bodyText": "doesn't seem to matter in guava 29 when checking, but moved for consistency", "author": "jrhee17", "createdAt": "2020-08-03T05:53:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE3MDY5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE5MDQyOA==", "url": "https://github.com/line/armeria/pull/2907#discussion_r464190428", "bodyText": "nit: Could replace with join()? Unless you intended to control a specific timeout, JUnit will do it for you.\n\n  \n    \n      armeria/testing-internal/src/main/resources/junit-platform.properties\n    \n    \n         Line 1\n      in\n      ad0350c\n    \n    \n    \n    \n\n        \n          \n           junit.jupiter.execution.timeout.default = 60s", "author": "ikhoon", "createdAt": "2020-08-03T04:39:14Z", "path": "core/src/test/java/com/linecorp/armeria/client/proxy/HAProxyClientIntegrationTest.java", "diffHunk": "@@ -0,0 +1,393 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.proxy;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static org.awaitility.Awaitility.await;\n+import static org.junit.jupiter.params.provider.Arguments.arguments;\n+\n+import java.net.ConnectException;\n+import java.net.InetSocketAddress;\n+import java.net.ServerSocket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.api.extension.RegisterExtension;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.ArgumentsProvider;\n+import org.junit.jupiter.params.provider.ArgumentsSource;\n+\n+import com.linecorp.armeria.client.ClientFactory;\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.client.UnprocessedRequestException;\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.client.logging.LoggingClient;\n+import com.linecorp.armeria.common.AggregatedHttpResponse;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.common.logging.RequestLogProperty;\n+import com.linecorp.armeria.common.util.SafeCloseable;\n+import com.linecorp.armeria.internal.testing.DynamicBehaviorHandler;\n+import com.linecorp.armeria.internal.testing.NettyServerExtension;\n+import com.linecorp.armeria.server.ProxiedAddresses;\n+import com.linecorp.armeria.server.ServerBuilder;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.testing.junit5.server.ServerExtension;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.handler.codec.haproxy.HAProxyMessage;\n+import io.netty.handler.codec.haproxy.HAProxyMessageDecoder;\n+import io.netty.handler.codec.http.DefaultFullHttpResponse;\n+import io.netty.handler.codec.http.DefaultHttpHeaders;\n+import io.netty.handler.codec.http.EmptyHttpHeaders;\n+import io.netty.handler.codec.http.FullHttpRequest;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import io.netty.handler.codec.http.HttpHeaders;\n+import io.netty.handler.codec.http.HttpObjectAggregator;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.netty.handler.codec.http.HttpServerCodec;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.handler.logging.LoggingHandler;\n+import io.netty.util.ReferenceCountUtil;\n+\n+class HAProxyClientIntegrationTest {\n+    private static final String PROXY_PATH = \"/proxy\";\n+    private static final DynamicBehaviorHandler DYNAMIC_HANDLER = new DynamicBehaviorHandler();\n+\n+    @RegisterExtension\n+    static ServerExtension backendServer = new ServerExtension() {\n+        @Override\n+        protected void configure(ServerBuilder sb) throws Exception {\n+            sb.port(0, SessionProtocol.HTTP, SessionProtocol.PROXY);\n+            sb.port(0, SessionProtocol.HTTPS, SessionProtocol.PROXY);\n+            sb.tlsSelfSigned();\n+            sb.service(PROXY_PATH, (ctx, req) -> {\n+                assertThat(ctx.proxiedAddresses().destinationAddresses()).hasSize(1);\n+                final String proxyString = String.format(\"%s-%s\", ctx.proxiedAddresses().sourceAddress(),\n+                                                         ctx.proxiedAddresses().destinationAddresses().get(0));\n+                return HttpResponse.of(proxyString);\n+            });\n+        }\n+    };\n+\n+    @RegisterExtension\n+    static NettyServerExtension http1Server = new NettyServerExtension() {\n+        @Override\n+        protected void configure(Channel ch) throws Exception {\n+            ch.pipeline().addLast(new LoggingHandler(getClass()));\n+            ch.pipeline().addLast(new HAProxyMessageDecoder());\n+            ch.pipeline().addLast(new HttpServerCodec());\n+            ch.pipeline().addLast(new HttpObjectAggregator(1024));\n+            ch.pipeline().addLast(DYNAMIC_HANDLER);\n+        }\n+    };\n+\n+    @ParameterizedTest\n+    @ArgumentsSource(ProtocolEndpointProvider.class)\n+    void testExplicitHAProxy(SessionProtocol sessionProtocol, InetSocketAddress proxyAddr) throws Exception {\n+        final InetSocketAddress srcAddr = new InetSocketAddress(\"127.0.0.2\", 82);\n+        final InetSocketAddress destAddr = new InetSocketAddress(\"127.0.0.3\", 83);\n+        final Endpoint destEndpoint = Endpoint.of(destAddr.getHostString(), destAddr.getPort());\n+\n+        try (ClientFactory clientFactory =\n+                     ClientFactory.builder()\n+                                  .proxyConfig(ProxyConfig.haproxy(proxyAddr, srcAddr))\n+                                  .tlsNoVerify()\n+                                  .useHttp2Preface(true)\n+                                  .build()) {\n+\n+            final WebClient webClient = WebClient.builder(sessionProtocol, destEndpoint)\n+                                                 .factory(clientFactory)\n+                                                 .decorator(LoggingClient.newDecorator())\n+                                                 .build();\n+            final CompletableFuture<AggregatedHttpResponse> responseFuture =\n+                    webClient.get(PROXY_PATH).aggregate();\n+\n+            final AggregatedHttpResponse response = responseFuture.get(10, TimeUnit.SECONDS);", "originalCommit": "c199cef542f6cbd2ac4d44e07ac0fc99142beef9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE5MDYyMA==", "url": "https://github.com/line/armeria/pull/2907#discussion_r464190620", "bodyText": "Ditto", "author": "ikhoon", "createdAt": "2020-08-03T04:40:00Z", "path": "core/src/test/java/com/linecorp/armeria/client/proxy/HAProxyClientIntegrationTest.java", "diffHunk": "@@ -0,0 +1,393 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.proxy;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static org.awaitility.Awaitility.await;\n+import static org.junit.jupiter.params.provider.Arguments.arguments;\n+\n+import java.net.ConnectException;\n+import java.net.InetSocketAddress;\n+import java.net.ServerSocket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.api.extension.RegisterExtension;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.ArgumentsProvider;\n+import org.junit.jupiter.params.provider.ArgumentsSource;\n+\n+import com.linecorp.armeria.client.ClientFactory;\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.client.UnprocessedRequestException;\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.client.logging.LoggingClient;\n+import com.linecorp.armeria.common.AggregatedHttpResponse;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.common.logging.RequestLogProperty;\n+import com.linecorp.armeria.common.util.SafeCloseable;\n+import com.linecorp.armeria.internal.testing.DynamicBehaviorHandler;\n+import com.linecorp.armeria.internal.testing.NettyServerExtension;\n+import com.linecorp.armeria.server.ProxiedAddresses;\n+import com.linecorp.armeria.server.ServerBuilder;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.testing.junit5.server.ServerExtension;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.handler.codec.haproxy.HAProxyMessage;\n+import io.netty.handler.codec.haproxy.HAProxyMessageDecoder;\n+import io.netty.handler.codec.http.DefaultFullHttpResponse;\n+import io.netty.handler.codec.http.DefaultHttpHeaders;\n+import io.netty.handler.codec.http.EmptyHttpHeaders;\n+import io.netty.handler.codec.http.FullHttpRequest;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import io.netty.handler.codec.http.HttpHeaders;\n+import io.netty.handler.codec.http.HttpObjectAggregator;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.netty.handler.codec.http.HttpServerCodec;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.handler.logging.LoggingHandler;\n+import io.netty.util.ReferenceCountUtil;\n+\n+class HAProxyClientIntegrationTest {\n+    private static final String PROXY_PATH = \"/proxy\";\n+    private static final DynamicBehaviorHandler DYNAMIC_HANDLER = new DynamicBehaviorHandler();\n+\n+    @RegisterExtension\n+    static ServerExtension backendServer = new ServerExtension() {\n+        @Override\n+        protected void configure(ServerBuilder sb) throws Exception {\n+            sb.port(0, SessionProtocol.HTTP, SessionProtocol.PROXY);\n+            sb.port(0, SessionProtocol.HTTPS, SessionProtocol.PROXY);\n+            sb.tlsSelfSigned();\n+            sb.service(PROXY_PATH, (ctx, req) -> {\n+                assertThat(ctx.proxiedAddresses().destinationAddresses()).hasSize(1);\n+                final String proxyString = String.format(\"%s-%s\", ctx.proxiedAddresses().sourceAddress(),\n+                                                         ctx.proxiedAddresses().destinationAddresses().get(0));\n+                return HttpResponse.of(proxyString);\n+            });\n+        }\n+    };\n+\n+    @RegisterExtension\n+    static NettyServerExtension http1Server = new NettyServerExtension() {\n+        @Override\n+        protected void configure(Channel ch) throws Exception {\n+            ch.pipeline().addLast(new LoggingHandler(getClass()));\n+            ch.pipeline().addLast(new HAProxyMessageDecoder());\n+            ch.pipeline().addLast(new HttpServerCodec());\n+            ch.pipeline().addLast(new HttpObjectAggregator(1024));\n+            ch.pipeline().addLast(DYNAMIC_HANDLER);\n+        }\n+    };\n+\n+    @ParameterizedTest\n+    @ArgumentsSource(ProtocolEndpointProvider.class)\n+    void testExplicitHAProxy(SessionProtocol sessionProtocol, InetSocketAddress proxyAddr) throws Exception {\n+        final InetSocketAddress srcAddr = new InetSocketAddress(\"127.0.0.2\", 82);\n+        final InetSocketAddress destAddr = new InetSocketAddress(\"127.0.0.3\", 83);\n+        final Endpoint destEndpoint = Endpoint.of(destAddr.getHostString(), destAddr.getPort());\n+\n+        try (ClientFactory clientFactory =\n+                     ClientFactory.builder()\n+                                  .proxyConfig(ProxyConfig.haproxy(proxyAddr, srcAddr))\n+                                  .tlsNoVerify()\n+                                  .useHttp2Preface(true)\n+                                  .build()) {\n+\n+            final WebClient webClient = WebClient.builder(sessionProtocol, destEndpoint)\n+                                                 .factory(clientFactory)\n+                                                 .decorator(LoggingClient.newDecorator())\n+                                                 .build();\n+            final CompletableFuture<AggregatedHttpResponse> responseFuture =\n+                    webClient.get(PROXY_PATH).aggregate();\n+\n+            final AggregatedHttpResponse response = responseFuture.get(10, TimeUnit.SECONDS);\n+            assertThat(response.status()).isEqualTo(HttpStatus.OK);\n+            final String expectedResponse = String.format(\"%s-%s\", srcAddr,\n+                                                          destAddr);\n+            assertThat(response.contentUtf8()).isEqualTo(expectedResponse);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @ArgumentsSource(ProtocolEndpointProvider.class)\n+    void testSourceAddrFromRootContextIfAvailable(\n+            SessionProtocol sessionProtocol, InetSocketAddress proxyAddr) throws Exception {\n+        final InetSocketAddress srcAddr = new InetSocketAddress(\"127.0.0.2\", 82);\n+        final InetSocketAddress destAddr = new InetSocketAddress(\"127.0.0.3\", 83);\n+        final Endpoint destEndpoint = Endpoint.of(destAddr.getHostString(), destAddr.getPort());\n+\n+        final ServiceRequestContext serviceRequestContext =\n+                ServiceRequestContext.builder(\n+                        HttpRequest.of(HttpMethod.GET, \"/\"))\n+                                     .proxiedAddresses(ProxiedAddresses.of(srcAddr)).build();\n+\n+        try (SafeCloseable ignored = serviceRequestContext.push();\n+             ClientFactory clientFactory =\n+                     ClientFactory.builder()\n+                                  .proxyConfig(ProxyConfig.haproxy(proxyAddr))\n+                                  .tlsNoVerify()\n+                                  .useHttp2Preface(true)\n+                                  .build()) {\n+\n+            final WebClient webClient = WebClient.builder(sessionProtocol, destEndpoint)\n+                                                 .factory(clientFactory)\n+                                                 .decorator(LoggingClient.newDecorator())\n+                                                 .build();\n+            final CompletableFuture<AggregatedHttpResponse> responseFuture =\n+                    webClient.get(PROXY_PATH).aggregate();\n+\n+            final AggregatedHttpResponse response = responseFuture.get(10, TimeUnit.SECONDS);", "originalCommit": "c199cef542f6cbd2ac4d44e07ac0fc99142beef9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE5MTU1Nw==", "url": "https://github.com/line/armeria/pull/2907#discussion_r464191557", "bodyText": "Could simplify:\nStream.concat(SessionProtocol.httpValues().stream(), SessionProtocol.httpsValues().stream())\n      .map(p -> arguments(p, backendServer.httpSocketAddress()));", "author": "ikhoon", "createdAt": "2020-08-03T04:44:33Z", "path": "core/src/test/java/com/linecorp/armeria/client/proxy/HAProxyClientIntegrationTest.java", "diffHunk": "@@ -0,0 +1,393 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.proxy;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static org.awaitility.Awaitility.await;\n+import static org.junit.jupiter.params.provider.Arguments.arguments;\n+\n+import java.net.ConnectException;\n+import java.net.InetSocketAddress;\n+import java.net.ServerSocket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.api.extension.RegisterExtension;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.ArgumentsProvider;\n+import org.junit.jupiter.params.provider.ArgumentsSource;\n+\n+import com.linecorp.armeria.client.ClientFactory;\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.client.UnprocessedRequestException;\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.client.logging.LoggingClient;\n+import com.linecorp.armeria.common.AggregatedHttpResponse;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.common.logging.RequestLogProperty;\n+import com.linecorp.armeria.common.util.SafeCloseable;\n+import com.linecorp.armeria.internal.testing.DynamicBehaviorHandler;\n+import com.linecorp.armeria.internal.testing.NettyServerExtension;\n+import com.linecorp.armeria.server.ProxiedAddresses;\n+import com.linecorp.armeria.server.ServerBuilder;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.testing.junit5.server.ServerExtension;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.handler.codec.haproxy.HAProxyMessage;\n+import io.netty.handler.codec.haproxy.HAProxyMessageDecoder;\n+import io.netty.handler.codec.http.DefaultFullHttpResponse;\n+import io.netty.handler.codec.http.DefaultHttpHeaders;\n+import io.netty.handler.codec.http.EmptyHttpHeaders;\n+import io.netty.handler.codec.http.FullHttpRequest;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import io.netty.handler.codec.http.HttpHeaders;\n+import io.netty.handler.codec.http.HttpObjectAggregator;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.netty.handler.codec.http.HttpServerCodec;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.handler.logging.LoggingHandler;\n+import io.netty.util.ReferenceCountUtil;\n+\n+class HAProxyClientIntegrationTest {\n+    private static final String PROXY_PATH = \"/proxy\";\n+    private static final DynamicBehaviorHandler DYNAMIC_HANDLER = new DynamicBehaviorHandler();\n+\n+    @RegisterExtension\n+    static ServerExtension backendServer = new ServerExtension() {\n+        @Override\n+        protected void configure(ServerBuilder sb) throws Exception {\n+            sb.port(0, SessionProtocol.HTTP, SessionProtocol.PROXY);\n+            sb.port(0, SessionProtocol.HTTPS, SessionProtocol.PROXY);\n+            sb.tlsSelfSigned();\n+            sb.service(PROXY_PATH, (ctx, req) -> {\n+                assertThat(ctx.proxiedAddresses().destinationAddresses()).hasSize(1);\n+                final String proxyString = String.format(\"%s-%s\", ctx.proxiedAddresses().sourceAddress(),\n+                                                         ctx.proxiedAddresses().destinationAddresses().get(0));\n+                return HttpResponse.of(proxyString);\n+            });\n+        }\n+    };\n+\n+    @RegisterExtension\n+    static NettyServerExtension http1Server = new NettyServerExtension() {\n+        @Override\n+        protected void configure(Channel ch) throws Exception {\n+            ch.pipeline().addLast(new LoggingHandler(getClass()));\n+            ch.pipeline().addLast(new HAProxyMessageDecoder());\n+            ch.pipeline().addLast(new HttpServerCodec());\n+            ch.pipeline().addLast(new HttpObjectAggregator(1024));\n+            ch.pipeline().addLast(DYNAMIC_HANDLER);\n+        }\n+    };\n+\n+    @ParameterizedTest\n+    @ArgumentsSource(ProtocolEndpointProvider.class)\n+    void testExplicitHAProxy(SessionProtocol sessionProtocol, InetSocketAddress proxyAddr) throws Exception {\n+        final InetSocketAddress srcAddr = new InetSocketAddress(\"127.0.0.2\", 82);\n+        final InetSocketAddress destAddr = new InetSocketAddress(\"127.0.0.3\", 83);\n+        final Endpoint destEndpoint = Endpoint.of(destAddr.getHostString(), destAddr.getPort());\n+\n+        try (ClientFactory clientFactory =\n+                     ClientFactory.builder()\n+                                  .proxyConfig(ProxyConfig.haproxy(proxyAddr, srcAddr))\n+                                  .tlsNoVerify()\n+                                  .useHttp2Preface(true)\n+                                  .build()) {\n+\n+            final WebClient webClient = WebClient.builder(sessionProtocol, destEndpoint)\n+                                                 .factory(clientFactory)\n+                                                 .decorator(LoggingClient.newDecorator())\n+                                                 .build();\n+            final CompletableFuture<AggregatedHttpResponse> responseFuture =\n+                    webClient.get(PROXY_PATH).aggregate();\n+\n+            final AggregatedHttpResponse response = responseFuture.get(10, TimeUnit.SECONDS);\n+            assertThat(response.status()).isEqualTo(HttpStatus.OK);\n+            final String expectedResponse = String.format(\"%s-%s\", srcAddr,\n+                                                          destAddr);\n+            assertThat(response.contentUtf8()).isEqualTo(expectedResponse);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @ArgumentsSource(ProtocolEndpointProvider.class)\n+    void testSourceAddrFromRootContextIfAvailable(\n+            SessionProtocol sessionProtocol, InetSocketAddress proxyAddr) throws Exception {\n+        final InetSocketAddress srcAddr = new InetSocketAddress(\"127.0.0.2\", 82);\n+        final InetSocketAddress destAddr = new InetSocketAddress(\"127.0.0.3\", 83);\n+        final Endpoint destEndpoint = Endpoint.of(destAddr.getHostString(), destAddr.getPort());\n+\n+        final ServiceRequestContext serviceRequestContext =\n+                ServiceRequestContext.builder(\n+                        HttpRequest.of(HttpMethod.GET, \"/\"))\n+                                     .proxiedAddresses(ProxiedAddresses.of(srcAddr)).build();\n+\n+        try (SafeCloseable ignored = serviceRequestContext.push();\n+             ClientFactory clientFactory =\n+                     ClientFactory.builder()\n+                                  .proxyConfig(ProxyConfig.haproxy(proxyAddr))\n+                                  .tlsNoVerify()\n+                                  .useHttp2Preface(true)\n+                                  .build()) {\n+\n+            final WebClient webClient = WebClient.builder(sessionProtocol, destEndpoint)\n+                                                 .factory(clientFactory)\n+                                                 .decorator(LoggingClient.newDecorator())\n+                                                 .build();\n+            final CompletableFuture<AggregatedHttpResponse> responseFuture =\n+                    webClient.get(PROXY_PATH).aggregate();\n+\n+            final AggregatedHttpResponse response = responseFuture.get(10, TimeUnit.SECONDS);\n+            assertThat(response.status()).isEqualTo(HttpStatus.OK);\n+            assertThat(destEndpoint.ipAddr()).isNotNull();\n+\n+            final String expectedResponse = String.format(\"%s-%s\", srcAddr, destAddr);\n+            assertThat(response.contentUtf8()).isEqualTo(expectedResponse);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @ArgumentsSource(ProtocolEndpointProvider.class)\n+    void testImplicitHAProxyWithoutRootContextUsesDefault(\n+            SessionProtocol sessionProtocol, InetSocketAddress proxyAddr) throws Exception {\n+        final InetSocketAddress destAddr = new InetSocketAddress(\"127.0.0.3\", 83);\n+        final Endpoint destEndpoint = Endpoint.of(destAddr.getHostString(), destAddr.getPort());\n+        try (ClientFactory clientFactory =\n+                     ClientFactory.builder()\n+                                  .proxyConfig(ProxyConfig.haproxy(proxyAddr))\n+                                  .tlsNoVerify()\n+                                  .useHttp2Preface(true)\n+                                  .build()) {\n+\n+            final AtomicReference<InetSocketAddress> srcAddressRef = new AtomicReference<>();\n+            final WebClient webClient =\n+                    WebClient.builder(sessionProtocol, destEndpoint)\n+                             .factory(clientFactory)\n+                             .decorator(LoggingClient.newDecorator())\n+                             .decorator((delegate, ctx, req) -> {\n+                                 final HttpResponse response = delegate.execute(ctx, req);\n+                                 await().atMost(10, TimeUnit.SECONDS).until(\n+                                         () -> ctx.log().isAvailable(RequestLogProperty.SESSION));\n+                                 srcAddressRef.set(ctx.localAddress());\n+                                 return response;\n+                             })\n+                             .build();\n+            final CompletableFuture<AggregatedHttpResponse> responseFuture =\n+                    webClient.get(PROXY_PATH).aggregate();\n+\n+            final AggregatedHttpResponse response = responseFuture.get(10, TimeUnit.SECONDS);\n+            assertThat(response.status()).isEqualTo(HttpStatus.OK);\n+            final String expectedResponse = String.format(\"%s-%s\", srcAddressRef.get(), destAddr);\n+            assertThat(response.contentUtf8()).isEqualTo(expectedResponse);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @ArgumentsSource(ProtocolEndpointProvider.class)\n+    void testDifferentIpFamily(SessionProtocol sessionProtocol, InetSocketAddress proxyAddr) throws Exception {\n+        final InetSocketAddress srcAddr = new InetSocketAddress(\"127.0.0.2\", 82);\n+        final InetSocketAddress destAddr = new InetSocketAddress(\"0:0:0:0:0:0:0:1\", 83);\n+        final Endpoint destEndpoint = Endpoint.of(destAddr.getHostString(), destAddr.getPort());\n+        try (ClientFactory clientFactory =\n+                     ClientFactory.builder()\n+                                  .proxyConfig(ProxyConfig.haproxy(proxyAddr, srcAddr))\n+                                  .tlsNoVerify()\n+                                  .useHttp2Preface(true)\n+                                  .build()) {\n+\n+            final WebClient webClient = WebClient.builder(sessionProtocol, destEndpoint)\n+                                                 .factory(clientFactory)\n+                                                 .decorator(LoggingClient.newDecorator())\n+                                                 .build();\n+            final CompletableFuture<AggregatedHttpResponse> responseFuture =\n+                    webClient.get(PROXY_PATH).aggregate();\n+\n+            final AggregatedHttpResponse response = responseFuture.get(10, TimeUnit.SECONDS);\n+            assertThat(response.status()).isEqualTo(HttpStatus.OK);\n+            final String expectedResponse = String.format(\"%s-%s\", srcAddr, destAddr);\n+            assertThat(response.contentUtf8()).isEqualTo(expectedResponse);\n+        }\n+    }\n+\n+    @Test\n+    void testConnectionFailure() throws Exception {\n+        final int unusedPort;\n+        try (ServerSocket ss = new ServerSocket(0)) {\n+            unusedPort = ss.getLocalPort();\n+        }\n+        try (ClientFactory clientFactory =\n+                     ClientFactory.builder()\n+                                  .proxyConfig(ProxyConfig.haproxy(new InetSocketAddress(unusedPort)))\n+                                  .useHttp2Preface(true)\n+                                  .build()) {\n+\n+            final WebClient webClient = WebClient.builder(SessionProtocol.H1C, backendServer.httpEndpoint())\n+                                                 .factory(clientFactory)\n+                                                 .decorator(LoggingClient.newDecorator())\n+                                                 .build();\n+            final CompletableFuture<AggregatedHttpResponse> responseFuture =\n+                    webClient.get(PROXY_PATH).aggregate();\n+\n+            assertThatThrownBy(() -> responseFuture.get(10, TimeUnit.SECONDS))\n+                    .isInstanceOf(ExecutionException.class)\n+                    .hasCauseInstanceOf(UnprocessedRequestException.class)\n+                    .hasRootCauseInstanceOf(ConnectException.class);\n+        }\n+    }\n+\n+    @Test\n+    void testHttpProxyUpgradeRequestFailure() throws Exception {\n+        final InetSocketAddress srcAddr = new InetSocketAddress(\"127.0.0.2\", 82);\n+        final InetSocketAddress destAddr = new InetSocketAddress(\"127.0.0.2\", 82);\n+        final Endpoint destEndpoint = Endpoint.of(destAddr.getHostString(), destAddr.getPort());\n+        final Endpoint proxyEndpoint = http1Server.endpoint();\n+        assert proxyEndpoint.ipAddr() != null;\n+        final InetSocketAddress proxyAddr = new InetSocketAddress(proxyEndpoint.ipAddr(), proxyEndpoint.port());\n+\n+        final AtomicReference<HAProxyMessage> msgRef = new AtomicReference<>();\n+        DYNAMIC_HANDLER.setChannelReadCustomizer((ctx, msg) -> {\n+            if (msg instanceof HAProxyMessage) {\n+                msgRef.set((HAProxyMessage) msg);\n+                return;\n+            }\n+            final FullHttpRequest request = (FullHttpRequest) msg;\n+            final DefaultFullHttpResponse response;\n+            if (\"h2c\".equals(request.headers().get(HttpHeaderNames.UPGRADE))) {\n+                // reject http2 upgrade requests\n+                final HttpHeaders headers = new DefaultHttpHeaders().add(HttpHeaderNames.CONNECTION, \"close\");\n+                response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,\n+                                                       HttpResponseStatus.NOT_IMPLEMENTED,\n+                                                       Unpooled.EMPTY_BUFFER,\n+                                                       headers,\n+                                                       EmptyHttpHeaders.INSTANCE);\n+            } else {\n+                response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,\n+                                                       HttpResponseStatus.OK,\n+                                                       Unpooled.copiedBuffer(strRepr(msgRef.get()),\n+                                                                             StandardCharsets.US_ASCII));\n+            }\n+\n+            ReferenceCountUtil.release(msg);\n+            ctx.writeAndFlush(response);\n+            ctx.close();\n+        });\n+\n+        try (ClientFactory clientFactory =\n+                     ClientFactory.builder()\n+                                  .proxyConfig(ProxyConfig.haproxy(proxyAddr, srcAddr))\n+                                  .useHttp2Preface(false)\n+                                  .build()) {\n+\n+            final WebClient webClient = WebClient.builder(SessionProtocol.HTTP, destEndpoint)\n+                                                 .factory(clientFactory)\n+                                                 .decorator(LoggingClient.newDecorator())\n+                                                 .build();\n+            final CompletableFuture<AggregatedHttpResponse> responseFuture =\n+                    webClient.get(PROXY_PATH).aggregate();\n+            final AggregatedHttpResponse response = responseFuture.get(10, TimeUnit.SECONDS);\n+            assertThat(response.status()).isEqualTo(HttpStatus.OK);\n+            final String expectedResponse = String.format(\"%s-%s\", srcAddr, destAddr);\n+            assertThat(response.contentUtf8()).isEqualTo(expectedResponse);\n+        }\n+    }\n+\n+    @Test\n+    void testHttpProxyPrefaceFailure() throws Exception {\n+        final InetSocketAddress srcAddr = new InetSocketAddress(\"127.0.0.2\", 82);\n+        final InetSocketAddress destAddr = new InetSocketAddress(\"127.0.0.2\", 82);\n+        final Endpoint destEndpoint = Endpoint.of(destAddr.getHostString(), destAddr.getPort());\n+        final Endpoint proxyEndpoint = http1Server.endpoint();\n+        assert proxyEndpoint.ipAddr() != null;\n+        final InetSocketAddress proxyAddr = new InetSocketAddress(proxyEndpoint.ipAddr(), proxyEndpoint.port());\n+\n+        final AtomicReference<HAProxyMessage> msgRef = new AtomicReference<>();\n+        DYNAMIC_HANDLER.setChannelReadCustomizer((ctx, msg) -> {\n+            if (msg instanceof HAProxyMessage) {\n+                msgRef.set((HAProxyMessage) msg);\n+                return;\n+            }\n+            final FullHttpRequest request = (FullHttpRequest) msg;\n+            final DefaultFullHttpResponse response;\n+            if (\"PRI\".equals(request.method().name())) {\n+                // reject http2 preface\n+                final HttpHeaders headers = new DefaultHttpHeaders().add(HttpHeaderNames.CONNECTION, \"close\");\n+                response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,\n+                                                       HttpResponseStatus.NOT_IMPLEMENTED,\n+                                                       Unpooled.EMPTY_BUFFER,\n+                                                       headers,\n+                                                       EmptyHttpHeaders.INSTANCE);\n+            } else {\n+                response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,\n+                                                       HttpResponseStatus.OK,\n+                                                       Unpooled.copiedBuffer(strRepr(msgRef.get()),\n+                                                                             StandardCharsets.US_ASCII));\n+            }\n+\n+            ReferenceCountUtil.release(msg);\n+            ctx.writeAndFlush(response);\n+            ctx.close();\n+        });\n+\n+        try (ClientFactory clientFactory =\n+                     ClientFactory.builder()\n+                                  .proxyConfig(ProxyConfig.haproxy(proxyAddr, srcAddr))\n+                                  .useHttp2Preface(true)\n+                                  .build()) {\n+\n+            final WebClient webClient = WebClient.builder(SessionProtocol.HTTP, destEndpoint)\n+                                                 .factory(clientFactory)\n+                                                 .decorator(LoggingClient.newDecorator())\n+                                                 .build();\n+            final CompletableFuture<AggregatedHttpResponse> responseFuture =\n+                    webClient.get(PROXY_PATH).aggregate();\n+            final AggregatedHttpResponse response = responseFuture.get(10, TimeUnit.SECONDS);\n+            assertThat(response.status()).isEqualTo(HttpStatus.OK);\n+            final String expectedResponse = String.format(\"%s-%s\", srcAddr, destAddr);\n+            assertThat(response.contentUtf8()).isEqualTo(expectedResponse);\n+        }\n+    }\n+\n+    private static class ProtocolEndpointProvider implements ArgumentsProvider {\n+        @Override\n+        public Stream<? extends Arguments> provideArguments(ExtensionContext context) {\n+            return Stream.concat(\n+                    SessionProtocol.httpValues().stream()\n+                                   .map(p -> arguments(p, backendServer.httpSocketAddress())),\n+                    SessionProtocol.httpsValues().stream()\n+                                   .map(p -> arguments(p, backendServer.httpsSocketAddress()))\n+            );", "originalCommit": "c199cef542f6cbd2ac4d44e07ac0fc99142beef9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDIwNjY0NA==", "url": "https://github.com/line/armeria/pull/2907#discussion_r464206644", "bodyText": "Actually we also need to divide backendServer.httpSocketAddress vs backendServer.httpsSocketAddress \ud83d\ude05", "author": "jrhee17", "createdAt": "2020-08-03T05:52:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE5MTU1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDIyMjc3Ng==", "url": "https://github.com/line/armeria/pull/2907#discussion_r464222776", "bodyText": "Ah... Sorry. I missed that \ud83e\udd23", "author": "ikhoon", "createdAt": "2020-08-03T06:45:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE5MTU1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE5Mjc5Mw==", "url": "https://github.com/line/armeria/pull/2907#discussion_r464192793", "bodyText": "Could use ctx.log().whenAvailable(RequestLogProperty.SESSION).thenXXX\nctx.log()\n   .whenAvailable(RequestLogProperty.SESSION)\n   .thenAccept(log ->  srcAddressRef.set(log.context().localAddress()));", "author": "ikhoon", "createdAt": "2020-08-03T04:50:57Z", "path": "core/src/test/java/com/linecorp/armeria/client/proxy/HAProxyClientIntegrationTest.java", "diffHunk": "@@ -0,0 +1,393 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.proxy;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static org.awaitility.Awaitility.await;\n+import static org.junit.jupiter.params.provider.Arguments.arguments;\n+\n+import java.net.ConnectException;\n+import java.net.InetSocketAddress;\n+import java.net.ServerSocket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.api.extension.RegisterExtension;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.ArgumentsProvider;\n+import org.junit.jupiter.params.provider.ArgumentsSource;\n+\n+import com.linecorp.armeria.client.ClientFactory;\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.client.UnprocessedRequestException;\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.client.logging.LoggingClient;\n+import com.linecorp.armeria.common.AggregatedHttpResponse;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.common.logging.RequestLogProperty;\n+import com.linecorp.armeria.common.util.SafeCloseable;\n+import com.linecorp.armeria.internal.testing.DynamicBehaviorHandler;\n+import com.linecorp.armeria.internal.testing.NettyServerExtension;\n+import com.linecorp.armeria.server.ProxiedAddresses;\n+import com.linecorp.armeria.server.ServerBuilder;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.testing.junit5.server.ServerExtension;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.handler.codec.haproxy.HAProxyMessage;\n+import io.netty.handler.codec.haproxy.HAProxyMessageDecoder;\n+import io.netty.handler.codec.http.DefaultFullHttpResponse;\n+import io.netty.handler.codec.http.DefaultHttpHeaders;\n+import io.netty.handler.codec.http.EmptyHttpHeaders;\n+import io.netty.handler.codec.http.FullHttpRequest;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import io.netty.handler.codec.http.HttpHeaders;\n+import io.netty.handler.codec.http.HttpObjectAggregator;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.netty.handler.codec.http.HttpServerCodec;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.handler.logging.LoggingHandler;\n+import io.netty.util.ReferenceCountUtil;\n+\n+class HAProxyClientIntegrationTest {\n+    private static final String PROXY_PATH = \"/proxy\";\n+    private static final DynamicBehaviorHandler DYNAMIC_HANDLER = new DynamicBehaviorHandler();\n+\n+    @RegisterExtension\n+    static ServerExtension backendServer = new ServerExtension() {\n+        @Override\n+        protected void configure(ServerBuilder sb) throws Exception {\n+            sb.port(0, SessionProtocol.HTTP, SessionProtocol.PROXY);\n+            sb.port(0, SessionProtocol.HTTPS, SessionProtocol.PROXY);\n+            sb.tlsSelfSigned();\n+            sb.service(PROXY_PATH, (ctx, req) -> {\n+                assertThat(ctx.proxiedAddresses().destinationAddresses()).hasSize(1);\n+                final String proxyString = String.format(\"%s-%s\", ctx.proxiedAddresses().sourceAddress(),\n+                                                         ctx.proxiedAddresses().destinationAddresses().get(0));\n+                return HttpResponse.of(proxyString);\n+            });\n+        }\n+    };\n+\n+    @RegisterExtension\n+    static NettyServerExtension http1Server = new NettyServerExtension() {\n+        @Override\n+        protected void configure(Channel ch) throws Exception {\n+            ch.pipeline().addLast(new LoggingHandler(getClass()));\n+            ch.pipeline().addLast(new HAProxyMessageDecoder());\n+            ch.pipeline().addLast(new HttpServerCodec());\n+            ch.pipeline().addLast(new HttpObjectAggregator(1024));\n+            ch.pipeline().addLast(DYNAMIC_HANDLER);\n+        }\n+    };\n+\n+    @ParameterizedTest\n+    @ArgumentsSource(ProtocolEndpointProvider.class)\n+    void testExplicitHAProxy(SessionProtocol sessionProtocol, InetSocketAddress proxyAddr) throws Exception {\n+        final InetSocketAddress srcAddr = new InetSocketAddress(\"127.0.0.2\", 82);\n+        final InetSocketAddress destAddr = new InetSocketAddress(\"127.0.0.3\", 83);\n+        final Endpoint destEndpoint = Endpoint.of(destAddr.getHostString(), destAddr.getPort());\n+\n+        try (ClientFactory clientFactory =\n+                     ClientFactory.builder()\n+                                  .proxyConfig(ProxyConfig.haproxy(proxyAddr, srcAddr))\n+                                  .tlsNoVerify()\n+                                  .useHttp2Preface(true)\n+                                  .build()) {\n+\n+            final WebClient webClient = WebClient.builder(sessionProtocol, destEndpoint)\n+                                                 .factory(clientFactory)\n+                                                 .decorator(LoggingClient.newDecorator())\n+                                                 .build();\n+            final CompletableFuture<AggregatedHttpResponse> responseFuture =\n+                    webClient.get(PROXY_PATH).aggregate();\n+\n+            final AggregatedHttpResponse response = responseFuture.get(10, TimeUnit.SECONDS);\n+            assertThat(response.status()).isEqualTo(HttpStatus.OK);\n+            final String expectedResponse = String.format(\"%s-%s\", srcAddr,\n+                                                          destAddr);\n+            assertThat(response.contentUtf8()).isEqualTo(expectedResponse);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @ArgumentsSource(ProtocolEndpointProvider.class)\n+    void testSourceAddrFromRootContextIfAvailable(\n+            SessionProtocol sessionProtocol, InetSocketAddress proxyAddr) throws Exception {\n+        final InetSocketAddress srcAddr = new InetSocketAddress(\"127.0.0.2\", 82);\n+        final InetSocketAddress destAddr = new InetSocketAddress(\"127.0.0.3\", 83);\n+        final Endpoint destEndpoint = Endpoint.of(destAddr.getHostString(), destAddr.getPort());\n+\n+        final ServiceRequestContext serviceRequestContext =\n+                ServiceRequestContext.builder(\n+                        HttpRequest.of(HttpMethod.GET, \"/\"))\n+                                     .proxiedAddresses(ProxiedAddresses.of(srcAddr)).build();\n+\n+        try (SafeCloseable ignored = serviceRequestContext.push();\n+             ClientFactory clientFactory =\n+                     ClientFactory.builder()\n+                                  .proxyConfig(ProxyConfig.haproxy(proxyAddr))\n+                                  .tlsNoVerify()\n+                                  .useHttp2Preface(true)\n+                                  .build()) {\n+\n+            final WebClient webClient = WebClient.builder(sessionProtocol, destEndpoint)\n+                                                 .factory(clientFactory)\n+                                                 .decorator(LoggingClient.newDecorator())\n+                                                 .build();\n+            final CompletableFuture<AggregatedHttpResponse> responseFuture =\n+                    webClient.get(PROXY_PATH).aggregate();\n+\n+            final AggregatedHttpResponse response = responseFuture.get(10, TimeUnit.SECONDS);\n+            assertThat(response.status()).isEqualTo(HttpStatus.OK);\n+            assertThat(destEndpoint.ipAddr()).isNotNull();\n+\n+            final String expectedResponse = String.format(\"%s-%s\", srcAddr, destAddr);\n+            assertThat(response.contentUtf8()).isEqualTo(expectedResponse);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @ArgumentsSource(ProtocolEndpointProvider.class)\n+    void testImplicitHAProxyWithoutRootContextUsesDefault(\n+            SessionProtocol sessionProtocol, InetSocketAddress proxyAddr) throws Exception {\n+        final InetSocketAddress destAddr = new InetSocketAddress(\"127.0.0.3\", 83);\n+        final Endpoint destEndpoint = Endpoint.of(destAddr.getHostString(), destAddr.getPort());\n+        try (ClientFactory clientFactory =\n+                     ClientFactory.builder()\n+                                  .proxyConfig(ProxyConfig.haproxy(proxyAddr))\n+                                  .tlsNoVerify()\n+                                  .useHttp2Preface(true)\n+                                  .build()) {\n+\n+            final AtomicReference<InetSocketAddress> srcAddressRef = new AtomicReference<>();\n+            final WebClient webClient =\n+                    WebClient.builder(sessionProtocol, destEndpoint)\n+                             .factory(clientFactory)\n+                             .decorator(LoggingClient.newDecorator())\n+                             .decorator((delegate, ctx, req) -> {\n+                                 final HttpResponse response = delegate.execute(ctx, req);\n+                                 await().atMost(10, TimeUnit.SECONDS).until(\n+                                         () -> ctx.log().isAvailable(RequestLogProperty.SESSION));", "originalCommit": "c199cef542f6cbd2ac4d44e07ac0fc99142beef9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE5MzI2NA==", "url": "https://github.com/line/armeria/pull/2907#discussion_r464193264", "bodyText": "Ditto", "author": "ikhoon", "createdAt": "2020-08-03T04:53:10Z", "path": "core/src/test/java/com/linecorp/armeria/client/proxy/HAProxyClientIntegrationTest.java", "diffHunk": "@@ -0,0 +1,393 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.proxy;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static org.awaitility.Awaitility.await;\n+import static org.junit.jupiter.params.provider.Arguments.arguments;\n+\n+import java.net.ConnectException;\n+import java.net.InetSocketAddress;\n+import java.net.ServerSocket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.api.extension.RegisterExtension;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.ArgumentsProvider;\n+import org.junit.jupiter.params.provider.ArgumentsSource;\n+\n+import com.linecorp.armeria.client.ClientFactory;\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.client.UnprocessedRequestException;\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.client.logging.LoggingClient;\n+import com.linecorp.armeria.common.AggregatedHttpResponse;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.common.logging.RequestLogProperty;\n+import com.linecorp.armeria.common.util.SafeCloseable;\n+import com.linecorp.armeria.internal.testing.DynamicBehaviorHandler;\n+import com.linecorp.armeria.internal.testing.NettyServerExtension;\n+import com.linecorp.armeria.server.ProxiedAddresses;\n+import com.linecorp.armeria.server.ServerBuilder;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.testing.junit5.server.ServerExtension;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.handler.codec.haproxy.HAProxyMessage;\n+import io.netty.handler.codec.haproxy.HAProxyMessageDecoder;\n+import io.netty.handler.codec.http.DefaultFullHttpResponse;\n+import io.netty.handler.codec.http.DefaultHttpHeaders;\n+import io.netty.handler.codec.http.EmptyHttpHeaders;\n+import io.netty.handler.codec.http.FullHttpRequest;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import io.netty.handler.codec.http.HttpHeaders;\n+import io.netty.handler.codec.http.HttpObjectAggregator;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.netty.handler.codec.http.HttpServerCodec;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.handler.logging.LoggingHandler;\n+import io.netty.util.ReferenceCountUtil;\n+\n+class HAProxyClientIntegrationTest {\n+    private static final String PROXY_PATH = \"/proxy\";\n+    private static final DynamicBehaviorHandler DYNAMIC_HANDLER = new DynamicBehaviorHandler();\n+\n+    @RegisterExtension\n+    static ServerExtension backendServer = new ServerExtension() {\n+        @Override\n+        protected void configure(ServerBuilder sb) throws Exception {\n+            sb.port(0, SessionProtocol.HTTP, SessionProtocol.PROXY);\n+            sb.port(0, SessionProtocol.HTTPS, SessionProtocol.PROXY);\n+            sb.tlsSelfSigned();\n+            sb.service(PROXY_PATH, (ctx, req) -> {\n+                assertThat(ctx.proxiedAddresses().destinationAddresses()).hasSize(1);\n+                final String proxyString = String.format(\"%s-%s\", ctx.proxiedAddresses().sourceAddress(),\n+                                                         ctx.proxiedAddresses().destinationAddresses().get(0));\n+                return HttpResponse.of(proxyString);\n+            });\n+        }\n+    };\n+\n+    @RegisterExtension\n+    static NettyServerExtension http1Server = new NettyServerExtension() {\n+        @Override\n+        protected void configure(Channel ch) throws Exception {\n+            ch.pipeline().addLast(new LoggingHandler(getClass()));\n+            ch.pipeline().addLast(new HAProxyMessageDecoder());\n+            ch.pipeline().addLast(new HttpServerCodec());\n+            ch.pipeline().addLast(new HttpObjectAggregator(1024));\n+            ch.pipeline().addLast(DYNAMIC_HANDLER);\n+        }\n+    };\n+\n+    @ParameterizedTest\n+    @ArgumentsSource(ProtocolEndpointProvider.class)\n+    void testExplicitHAProxy(SessionProtocol sessionProtocol, InetSocketAddress proxyAddr) throws Exception {\n+        final InetSocketAddress srcAddr = new InetSocketAddress(\"127.0.0.2\", 82);\n+        final InetSocketAddress destAddr = new InetSocketAddress(\"127.0.0.3\", 83);\n+        final Endpoint destEndpoint = Endpoint.of(destAddr.getHostString(), destAddr.getPort());\n+\n+        try (ClientFactory clientFactory =\n+                     ClientFactory.builder()\n+                                  .proxyConfig(ProxyConfig.haproxy(proxyAddr, srcAddr))\n+                                  .tlsNoVerify()\n+                                  .useHttp2Preface(true)\n+                                  .build()) {\n+\n+            final WebClient webClient = WebClient.builder(sessionProtocol, destEndpoint)\n+                                                 .factory(clientFactory)\n+                                                 .decorator(LoggingClient.newDecorator())\n+                                                 .build();\n+            final CompletableFuture<AggregatedHttpResponse> responseFuture =\n+                    webClient.get(PROXY_PATH).aggregate();\n+\n+            final AggregatedHttpResponse response = responseFuture.get(10, TimeUnit.SECONDS);\n+            assertThat(response.status()).isEqualTo(HttpStatus.OK);\n+            final String expectedResponse = String.format(\"%s-%s\", srcAddr,\n+                                                          destAddr);\n+            assertThat(response.contentUtf8()).isEqualTo(expectedResponse);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @ArgumentsSource(ProtocolEndpointProvider.class)\n+    void testSourceAddrFromRootContextIfAvailable(\n+            SessionProtocol sessionProtocol, InetSocketAddress proxyAddr) throws Exception {\n+        final InetSocketAddress srcAddr = new InetSocketAddress(\"127.0.0.2\", 82);\n+        final InetSocketAddress destAddr = new InetSocketAddress(\"127.0.0.3\", 83);\n+        final Endpoint destEndpoint = Endpoint.of(destAddr.getHostString(), destAddr.getPort());\n+\n+        final ServiceRequestContext serviceRequestContext =\n+                ServiceRequestContext.builder(\n+                        HttpRequest.of(HttpMethod.GET, \"/\"))\n+                                     .proxiedAddresses(ProxiedAddresses.of(srcAddr)).build();\n+\n+        try (SafeCloseable ignored = serviceRequestContext.push();\n+             ClientFactory clientFactory =\n+                     ClientFactory.builder()\n+                                  .proxyConfig(ProxyConfig.haproxy(proxyAddr))\n+                                  .tlsNoVerify()\n+                                  .useHttp2Preface(true)\n+                                  .build()) {\n+\n+            final WebClient webClient = WebClient.builder(sessionProtocol, destEndpoint)\n+                                                 .factory(clientFactory)\n+                                                 .decorator(LoggingClient.newDecorator())\n+                                                 .build();\n+            final CompletableFuture<AggregatedHttpResponse> responseFuture =\n+                    webClient.get(PROXY_PATH).aggregate();\n+\n+            final AggregatedHttpResponse response = responseFuture.get(10, TimeUnit.SECONDS);\n+            assertThat(response.status()).isEqualTo(HttpStatus.OK);\n+            assertThat(destEndpoint.ipAddr()).isNotNull();\n+\n+            final String expectedResponse = String.format(\"%s-%s\", srcAddr, destAddr);\n+            assertThat(response.contentUtf8()).isEqualTo(expectedResponse);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @ArgumentsSource(ProtocolEndpointProvider.class)\n+    void testImplicitHAProxyWithoutRootContextUsesDefault(\n+            SessionProtocol sessionProtocol, InetSocketAddress proxyAddr) throws Exception {\n+        final InetSocketAddress destAddr = new InetSocketAddress(\"127.0.0.3\", 83);\n+        final Endpoint destEndpoint = Endpoint.of(destAddr.getHostString(), destAddr.getPort());\n+        try (ClientFactory clientFactory =\n+                     ClientFactory.builder()\n+                                  .proxyConfig(ProxyConfig.haproxy(proxyAddr))\n+                                  .tlsNoVerify()\n+                                  .useHttp2Preface(true)\n+                                  .build()) {\n+\n+            final AtomicReference<InetSocketAddress> srcAddressRef = new AtomicReference<>();\n+            final WebClient webClient =\n+                    WebClient.builder(sessionProtocol, destEndpoint)\n+                             .factory(clientFactory)\n+                             .decorator(LoggingClient.newDecorator())\n+                             .decorator((delegate, ctx, req) -> {\n+                                 final HttpResponse response = delegate.execute(ctx, req);\n+                                 await().atMost(10, TimeUnit.SECONDS).until(\n+                                         () -> ctx.log().isAvailable(RequestLogProperty.SESSION));\n+                                 srcAddressRef.set(ctx.localAddress());\n+                                 return response;\n+                             })\n+                             .build();\n+            final CompletableFuture<AggregatedHttpResponse> responseFuture =\n+                    webClient.get(PROXY_PATH).aggregate();\n+\n+            final AggregatedHttpResponse response = responseFuture.get(10, TimeUnit.SECONDS);\n+            assertThat(response.status()).isEqualTo(HttpStatus.OK);\n+            final String expectedResponse = String.format(\"%s-%s\", srcAddressRef.get(), destAddr);\n+            assertThat(response.contentUtf8()).isEqualTo(expectedResponse);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @ArgumentsSource(ProtocolEndpointProvider.class)\n+    void testDifferentIpFamily(SessionProtocol sessionProtocol, InetSocketAddress proxyAddr) throws Exception {\n+        final InetSocketAddress srcAddr = new InetSocketAddress(\"127.0.0.2\", 82);\n+        final InetSocketAddress destAddr = new InetSocketAddress(\"0:0:0:0:0:0:0:1\", 83);\n+        final Endpoint destEndpoint = Endpoint.of(destAddr.getHostString(), destAddr.getPort());\n+        try (ClientFactory clientFactory =\n+                     ClientFactory.builder()\n+                                  .proxyConfig(ProxyConfig.haproxy(proxyAddr, srcAddr))\n+                                  .tlsNoVerify()\n+                                  .useHttp2Preface(true)\n+                                  .build()) {\n+\n+            final WebClient webClient = WebClient.builder(sessionProtocol, destEndpoint)\n+                                                 .factory(clientFactory)\n+                                                 .decorator(LoggingClient.newDecorator())\n+                                                 .build();\n+            final CompletableFuture<AggregatedHttpResponse> responseFuture =\n+                    webClient.get(PROXY_PATH).aggregate();\n+\n+            final AggregatedHttpResponse response = responseFuture.get(10, TimeUnit.SECONDS);\n+            assertThat(response.status()).isEqualTo(HttpStatus.OK);\n+            final String expectedResponse = String.format(\"%s-%s\", srcAddr, destAddr);\n+            assertThat(response.contentUtf8()).isEqualTo(expectedResponse);\n+        }\n+    }\n+\n+    @Test\n+    void testConnectionFailure() throws Exception {\n+        final int unusedPort;\n+        try (ServerSocket ss = new ServerSocket(0)) {\n+            unusedPort = ss.getLocalPort();\n+        }\n+        try (ClientFactory clientFactory =\n+                     ClientFactory.builder()\n+                                  .proxyConfig(ProxyConfig.haproxy(new InetSocketAddress(unusedPort)))\n+                                  .useHttp2Preface(true)\n+                                  .build()) {\n+\n+            final WebClient webClient = WebClient.builder(SessionProtocol.H1C, backendServer.httpEndpoint())\n+                                                 .factory(clientFactory)\n+                                                 .decorator(LoggingClient.newDecorator())\n+                                                 .build();\n+            final CompletableFuture<AggregatedHttpResponse> responseFuture =\n+                    webClient.get(PROXY_PATH).aggregate();\n+\n+            assertThatThrownBy(() -> responseFuture.get(10, TimeUnit.SECONDS))", "originalCommit": "c199cef542f6cbd2ac4d44e07ac0fc99142beef9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "dcc487f08af4fcb8c3c20a2a60f4a848acf9b58a", "url": "https://github.com/line/armeria/commit/dcc487f08af4fcb8c3c20a2a60f4a848acf9b58a", "message": "prefer join, omitNullValues first", "committedDate": "2020-08-03T05:51:39Z", "type": "commit"}, {"oid": "dcc487f08af4fcb8c3c20a2a60f4a848acf9b58a", "url": "https://github.com/line/armeria/commit/dcc487f08af4fcb8c3c20a2a60f4a848acf9b58a", "message": "prefer join, omitNullValues first", "committedDate": "2020-08-03T05:51:39Z", "type": "forcePushed"}, {"oid": "52ed8e671f56642ad10ccd707361190ae6580979", "url": "https://github.com/line/armeria/commit/52ed8e671f56642ad10ccd707361190ae6580979", "message": "Merge branch 'master' of https://github.com/line/armeria into feature/haproxy-client", "committedDate": "2020-08-03T07:00:10Z", "type": "commit"}, {"oid": "832ea638e0dcfafa3c8165d186bb2bcb26dd6506", "url": "https://github.com/line/armeria/commit/832ea638e0dcfafa3c8165d186bb2bcb26dd6506", "message": "directly use serviceReqCtx", "committedDate": "2020-08-03T07:01:26Z", "type": "commit"}, {"oid": "9422e33a330aa6384e5b8351e46555f5cff58b86", "url": "https://github.com/line/armeria/commit/9422e33a330aa6384e5b8351e46555f5cff58b86", "message": "avoid an extra instantiation if serviceCtx doesn't exist", "committedDate": "2020-08-03T08:22:01Z", "type": "commit"}]}