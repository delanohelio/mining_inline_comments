{"pr_number": 2680, "pr_title": "GH-1325 added Values convenience functions for quick IRI, Literal, BNode, and Triple creation", "pr_createdAt": "2020-11-28T00:37:35Z", "pr_url": "https://github.com/eclipse/rdf4j/pull/2680", "timeline": [{"oid": "378fbcfec2a8f0fe0a435e73171e0eb983ebe8b9", "url": "https://github.com/eclipse/rdf4j/commit/378fbcfec2a8f0fe0a435e73171e0eb983ebe8b9", "message": "GH-1325 added Values convenience functions", "committedDate": "2020-11-28T00:25:51Z", "type": "commit"}, {"oid": "9038de1bcf059a1f68361404f2a83d0dff3ed524", "url": "https://github.com/eclipse/rdf4j/commit/9038de1bcf059a1f68361404f2a83d0dff3ed524", "message": "GH-1325 updated documentation to show use of Values static factory methods", "committedDate": "2020-11-28T04:29:17Z", "type": "forcePushed"}, {"oid": "c0192e3048ebf14f02687223ad2098e8b665fdce", "url": "https://github.com/eclipse/rdf4j/commit/c0192e3048ebf14f02687223ad2098e8b665fdce", "message": "GH-1325 updated documentation to show use of Values static factory methods", "committedDate": "2020-11-28T04:34:21Z", "type": "commit"}, {"oid": "c0192e3048ebf14f02687223ad2098e8b665fdce", "url": "https://github.com/eclipse/rdf4j/commit/c0192e3048ebf14f02687223ad2098e8b665fdce", "message": "GH-1325 updated documentation to show use of Values static factory methods", "committedDate": "2020-11-28T04:34:21Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQ3Mzg3Nw==", "url": "https://github.com/eclipse/rdf4j/pull/2680#discussion_r532473877", "bodyText": "I am not a 100% sure but it may a good idea to also test for the primitive types here, i.e. byte.class.equals(object.getClass()) , similar for int, double etc\nMight also be a good idea to cover this in tests if not already done so", "author": "aschwarte10", "createdAt": "2020-11-30T10:00:08Z", "path": "core/model/src/main/java/org/eclipse/rdf4j/model/util/Values.java", "diffHunk": "@@ -0,0 +1,694 @@\n+/******************************************************************************* \n+ * Copyright (c) 2020 Eclipse RDF4J contributors. \n+ * All rights reserved. This program and the accompanying materials \n+ * are made available under the terms of the Eclipse Distribution License v1.0 \n+ * which accompanies this distribution, and is available at \n+ * http://www.eclipse.org/org/documents/edl-v10.php. \n+ *******************************************************************************/\n+package org.eclipse.rdf4j.model.util;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.time.temporal.TemporalAccessor;\n+import java.util.Date;\n+import java.util.Objects;\n+\n+import javax.xml.datatype.XMLGregorianCalendar;\n+\n+import org.eclipse.rdf4j.model.BNode;\n+import org.eclipse.rdf4j.model.IRI;\n+import org.eclipse.rdf4j.model.Literal;\n+import org.eclipse.rdf4j.model.Resource;\n+import org.eclipse.rdf4j.model.Statement;\n+import org.eclipse.rdf4j.model.Triple;\n+import org.eclipse.rdf4j.model.Value;\n+import org.eclipse.rdf4j.model.ValueFactory;\n+import org.eclipse.rdf4j.model.impl.SimpleValueFactory;\n+import org.eclipse.rdf4j.model.impl.ValidatingValueFactory;\n+import org.eclipse.rdf4j.model.vocabulary.XSD;\n+\n+/**\n+ * Factory methods to quickly create {@link Value} objects ( {@link IRI}, {@link Literal}, {@link BNode}, and\n+ * {@link Triple}) without having to create a {@link ValueFactory} first.\n+ * <p>\n+ * Example usage:\n+ * \n+ * <pre>\n+ * import static org.eclipse.rdf4j.model.util.Values.iri;\n+ * \n+ * ... \n+ * IRI foo = iri(\"http://example.org/foo\");\n+ * </pre>\n+ * <p>\n+ * \n+ * @author Jeen Broekstra\n+ * @since 3.5.0\n+ * \n+ * @see Statements\n+ */\n+public class Values {\n+\n+\t/**\n+\t * Internal shared value factory used for creating all values. We use a {@link ValidatingValueFactory} to ensure\n+\t * created values are syntactically legal.\n+\t */\n+\tprivate static final ValueFactory VALUE_FACTORY = new ValidatingValueFactory(SimpleValueFactory.getInstance());\n+\n+\t/* private constructor */\n+\n+\tprivate Values() {\n+\t}\n+\n+\t/* IRI factory methods */\n+\n+\t/**\n+\t * Create a new {@link IRI} using the supplied iri string\n+\t * \n+\t * @param iri a string representing a valid (absolute) iri\n+\t * \n+\t * @return an {@link IRI} object for the supplied iri string.\n+\t * \n+\t * @throws NullPointerException     if the suppplied iri is <code>null</code>\n+\t * @throws IllegalArgumentException if the supplied iri string can not be parsed as a legal IRI.\n+\t */\n+\tpublic static IRI iri(String iri) throws IllegalArgumentException {\n+\t\treturn iri(VALUE_FACTORY, iri);\n+\t}\n+\n+\t/**\n+\t * Create a new {@link IRI} using the supplied iri string\n+\t * \n+\t * @param vf  the {@link ValueFactory} to use for creation of the IRI.\n+\t * @param iri a string representing a valid (absolute) iri\n+\t * \n+\t * @return an {@link IRI} object for the supplied iri string.\n+\t * \n+\t * @throws NullPointerException     if any of the input parameters is <code>null</code>\n+\t * @throws IllegalArgumentException if the supplied iri string can not be parsed as a legal IRI by the supplied\n+\t *                                  {@link ValueFactory} .\n+\t */\n+\tpublic static IRI iri(ValueFactory vf, String iri) throws IllegalArgumentException {\n+\t\treturn vf.createIRI(Objects.requireNonNull(iri, \"iri may not be null\"));\n+\t}\n+\n+\t/**\n+\t * Create a new {@link IRI} using the supplied namespace and local name\n+\t * \n+\t * @param namespace the IRI's namespace\n+\t * @param localName the IRI's local name\n+\t * \n+\t * @return an {@link IRI} object for the supplied IRI namespace and localName.\n+\t * \n+\t * @throws NullPointerException     if any of the input parameters is <code>null</code>\n+\t * @throws IllegalArgumentException if the supplied iri string can not be parsed as a legal IRI.\n+\t */\n+\tpublic static IRI iri(String namespace, String localName) throws IllegalArgumentException {\n+\t\treturn iri(VALUE_FACTORY, namespace, localName);\n+\t}\n+\n+\t/**\n+\t * Create a new {@link IRI} using the supplied namespace and local name\n+\t * \n+\t * @param vf        the {@link ValueFactory} to use for creation of the IRI.\n+\t * @param namespace the IRI's namespace\n+\t * @param localName the IRI's local name\n+\t * \n+\t * @return an {@link IRI} object for the supplied IRI namespace and localName.\n+\t * \n+\t * @throws NullPointerException     if any of the input parameters is <code>null</code>\n+\t * @throws IllegalArgumentException if the supplied iri string can not be parsed as a legal IRI by the supplied\n+\t *                                  {@link ValueFactory}\n+\t */\n+\tpublic static IRI iri(ValueFactory vf, String namespace, String localName) throws IllegalArgumentException {\n+\t\treturn vf.createIRI(Objects.requireNonNull(namespace, \"namespace may not be null\"),\n+\t\t\t\tObjects.requireNonNull(localName, \"localName may not be null\"));\n+\t}\n+\n+\t/* blank node factory methods */\n+\n+\t/**\n+\t * Creates a new {@link BNode}\n+\t * \n+\t * @return a new {@link BNode}\n+\t */\n+\tpublic static BNode bnode() {\n+\t\treturn bnode(VALUE_FACTORY);\n+\t}\n+\n+\t/**\n+\t * Creates a new {@link BNode}\n+\t * \n+\t * @param vf the {@link ValueFactory} to use for creation of the {@link BNode}\n+\t * \n+\t * @return a new {@link BNode}\n+\t * \n+\t * @throws NullPointerException if any of the input parameters is <code>null</code>\n+\t */\n+\tpublic static BNode bnode(ValueFactory vf) {\n+\t\treturn vf.createBNode();\n+\t}\n+\n+\t/**\n+\t * Creates a new {@link BNode} with the supplied node identifier.\n+\t * \n+\t * @param nodeId the node identifier\n+\t * \n+\t * @return a new {@link BNode}\n+\t * \n+\t * @throws NullPointerException     if the supplied node identifier is <code>null</code>.\n+\t * @throws IllegalArgumentException if the supplied node identifier is not valid\n+\t */\n+\tpublic static BNode bnode(String nodeId) throws IllegalArgumentException {\n+\t\treturn bnode(VALUE_FACTORY, nodeId);\n+\t}\n+\n+\t/**\n+\t * Creates a new {@link BNode} with the supplied node identifier.\n+\t * \n+\t * @param vf     the {@link ValueFactory} to use for creation of the {@link BNode}\n+\t * @param nodeId the node identifier\n+\t * \n+\t * @return a new {@link BNode}\n+\t * \n+\t * @throws NullPointerException     if any of the input parameters is <code>null</code>\n+\t * @throws IllegalArgumentException if the supplied node identifier is not valid\n+\t */\n+\tpublic static BNode bnode(ValueFactory vf, String nodeId) throws IllegalArgumentException {\n+\t\treturn vf.createBNode(Objects.requireNonNull(nodeId, \"nodeId may not be null\"));\n+\t}\n+\n+\t/* Literal factory methods */\n+\n+\t/**\n+\t * Creates a new {@link Literal} with the supplied lexical value.\n+\t * \n+\t * @param lexicalValue the lexical value for the literal\n+\t * \n+\t * @return a new {@link Literal} of type {@link XSD#STRING}\n+\t * \n+\t * @throws NullPointerException if the supplied lexical value is <code>null</code>.\n+\t */\n+\tpublic static Literal literal(String lexicalValue) {\n+\t\treturn literal(VALUE_FACTORY, lexicalValue);\n+\t}\n+\n+\t/**\n+\t * Creates a new {@link Literal} with the supplied lexical value.\n+\t *\n+\t * @param vf           the {@link ValueFactory} to use for creation of the {@link Literal}\n+\t * @param lexicalValue the lexical value for the literal\n+\t * \n+\t * @return a new {@link Literal} of type {@link XSD#STRING}\n+\t * \n+\t * @throws NullPointerException if any of the input parameters is <code>null</code>\n+\t */\n+\tpublic static Literal literal(ValueFactory vf, String lexicalValue) {\n+\t\treturn vf.createLiteral(Objects.requireNonNull(lexicalValue, \"lexicalValue may not be null\"));\n+\t}\n+\n+\t/**\n+\t * Creates a new {@link Literal} with the supplied lexical value and datatype.\n+\t * \n+\t * @param lexicalValue the lexical value for the literal\n+\t * @param datatype     the datatype URI\n+\t * \n+\t * @return a new {@link Literal} with the supplied lexical value and datatype\n+\t * \n+\t * @throws NullPointerException     if the supplied lexical value or datatype is <code>null</code>.\n+\t * @throws IllegalArgumentException if the supplied lexical value is not valid for the given datatype\n+\t */\n+\tpublic static Literal literal(String lexicalValue, IRI datatype) throws IllegalArgumentException {\n+\t\treturn literal(VALUE_FACTORY, lexicalValue, datatype);\n+\t}\n+\n+\t/**\n+\t * Creates a new {@link Literal} with the supplied lexical value and datatype.\n+\t * \n+\t * @param vf           the {@link ValueFactory} to use for creation of the {@link Literal}\n+\t * @param lexicalValue the lexical value for the literal\n+\t * @param datatype     the datatype URI\n+\t * \n+\t * @return a new {@link Literal} with the supplied lexical value and datatype\n+\t * \n+\t * @throws NullPointerException     if any of the input parameters is <code>null</code>.\n+\t * @throws IllegalArgumentException if the supplied lexical value is not valid for the given datatype\n+\t */\n+\tpublic static Literal literal(ValueFactory vf, String lexicalValue, IRI datatype) throws IllegalArgumentException {\n+\t\treturn vf.createLiteral(Objects.requireNonNull(lexicalValue, \"lexicalValue may not be null\"),\n+\t\t\t\tObjects.requireNonNull(datatype, \"datatype may not be null\"));\n+\t}\n+\n+\t/**\n+\t * Creates a new {@link Literal} with the supplied boolean value\n+\t * \n+\t * @param booleanValue a boolean value\n+\t * \n+\t * @return a {@link Literal} of type {@link XSD#BOOLEAN} with the supplied value\n+\t */\n+\tpublic static Literal literal(boolean booleanValue) {\n+\t\treturn literal(VALUE_FACTORY, booleanValue);\n+\t}\n+\n+\t/**\n+\t * Creates a new {@link Literal} with the supplied boolean value\n+\t * \n+\t * @param vf           the {@link ValueFactory} to use for creation of the {@link Literal}\n+\t * @param booleanValue a boolean value\n+\t * \n+\t * @return a {@link Literal} of type {@link XSD#BOOLEAN} with the supplied value\n+\t * \n+\t * @throws NullPointerException if any of the input parameters is <code>null</code>.\n+\t */\n+\tpublic static Literal literal(ValueFactory vf, boolean booleanValue) {\n+\t\treturn vf.createLiteral(booleanValue);\n+\t}\n+\n+\t/**\n+\t * Creates a new {@link Literal} with the supplied byte value\n+\t * \n+\t * @param byteValue a byte value\n+\t * \n+\t * @return a {@link Literal} of type {@link XSD#BYTE} with the supplied value\n+\t */\n+\tpublic static Literal literal(byte byteValue) {\n+\t\treturn literal(VALUE_FACTORY, byteValue);\n+\t}\n+\n+\t/**\n+\t * Creates a new {@link Literal} with the supplied byte value\n+\t * \n+\t * @param vf        the {@link ValueFactory} to use for creation of the {@link Literal}\n+\t * @param byteValue a byte value\n+\t * \n+\t * @return a {@link Literal} of type {@link XSD#BYTE} with the supplied value\n+\t * \n+\t * @throws NullPointerException if any of the input parameters is <code>null</code>.\n+\t */\n+\tpublic static Literal literal(ValueFactory vf, byte byteValue) {\n+\t\treturn vf.createLiteral(byteValue);\n+\t}\n+\n+\t/**\n+\t * Creates a new {@link Literal} with the supplied short value\n+\t * \n+\t * @param shortValue a short value\n+\t * \n+\t * @return a {@link Literal} of type {@link XSD#SHORT} with the supplied value\n+\t */\n+\tpublic static Literal literal(short shortValue) {\n+\t\treturn literal(VALUE_FACTORY, shortValue);\n+\t}\n+\n+\t/**\n+\t * Creates a new {@link Literal} with the supplied short value\n+\t * \n+\t * @param vf         the {@link ValueFactory} to use for creation of the {@link Literal}\n+\t * @param shortValue a short value\n+\t * \n+\t * @return a {@link Literal} of type {@link XSD#SHORT} with the supplied value\n+\t * \n+\t * @throws NullPointerException if any of the input parameters is <code>null</code>.\n+\t */\n+\tpublic static Literal literal(ValueFactory vf, short shortValue) {\n+\t\treturn vf.createLiteral(shortValue);\n+\t}\n+\n+\t/**\n+\t * Creates a new {@link Literal} with the supplied int value\n+\t * \n+\t * @param intValue an int value\n+\t * \n+\t * @return a {@link Literal} of type {@link XSD#INT} with the supplied value\n+\t */\n+\tpublic static Literal literal(int intValue) {\n+\t\treturn literal(VALUE_FACTORY, intValue);\n+\t}\n+\n+\t/**\n+\t * Creates a new {@link Literal} with the supplied int value\n+\t * \n+\t * @param vf       the {@link ValueFactory} to use for creation of the {@link Literal}\n+\t * @param intValue an int value\n+\t * \n+\t * @return a {@link Literal} of type {@link XSD#INT} with the supplied value\n+\t * \n+\t * @throws NullPointerException if any of the input parameters is <code>null</code>.\n+\t */\n+\tpublic static Literal literal(ValueFactory vf, int intValue) {\n+\t\treturn vf.createLiteral(intValue);\n+\t}\n+\n+\t/**\n+\t * Creates a new {@link Literal} with the supplied long value\n+\t * \n+\t * @param longValue a long value\n+\t * \n+\t * @return a {@link Literal} of type {@link XSD#LONG} with the supplied value\n+\t */\n+\tpublic static Literal literal(long longValue) {\n+\t\treturn literal(VALUE_FACTORY, longValue);\n+\t}\n+\n+\t/**\n+\t * Creates a new {@link Literal} with the supplied long value\n+\t * \n+\t * @param vf        the {@link ValueFactory} to use for creation of the {@link Literal}\n+\t * @param longValue a long value\n+\t * \n+\t * @return a {@link Literal} of type {@link XSD#LONG} with the supplied value\n+\t * \n+\t * @throws NullPointerException if any of the input parameters is <code>null</code>.\n+\t */\n+\tpublic static Literal literal(ValueFactory vf, long longValue) {\n+\t\treturn vf.createLiteral(longValue);\n+\t}\n+\n+\t/**\n+\t * Creates a new {@link Literal} with the supplied float value\n+\t * \n+\t * @param floatValue a float value\n+\t * \n+\t * @return a {@link Literal} of type {@link XSD#FLOAT} with the supplied value\n+\t */\n+\tpublic static Literal literal(float floatValue) {\n+\t\treturn literal(VALUE_FACTORY, floatValue);\n+\t}\n+\n+\t/**\n+\t * Creates a new {@link Literal} with the supplied float value\n+\t * \n+\t * @param vf         the {@link ValueFactory} to use for creation of the {@link Literal}\n+\t * @param floatValue a float value\n+\t * \n+\t * @return a {@link Literal} of type {@link XSD#FLOAT} with the supplied value\n+\t * \n+\t * @throws NullPointerException if any of the input parameters is <code>null</code>.\n+\t */\n+\tpublic static Literal literal(ValueFactory vf, float floatValue) {\n+\t\treturn vf.createLiteral(floatValue);\n+\t}\n+\n+\t/**\n+\t * Creates a new {@link Literal} with the supplied double value\n+\t * \n+\t * @param doubleValue a double value\n+\t * \n+\t * @return a {@link Literal} of type {@link XSD#DOUBLE} with the supplied value\n+\t */\n+\tpublic static Literal literal(double doubleValue) {\n+\t\treturn literal(VALUE_FACTORY, doubleValue);\n+\t}\n+\n+\t/**\n+\t * Creates a new {@link Literal} with the supplied double value\n+\t * \n+\t * @param vf          the {@link ValueFactory} to use for creation of the {@link Literal}\n+\t * @param doubleValue a double value\n+\t * \n+\t * @return a {@link Literal} of type {@link XSD#DOUBLE} with the supplied value\n+\t * \n+\t * @throws NullPointerException if any of the input parameters is <code>null</code>.\n+\t */\n+\tpublic static Literal literal(ValueFactory vf, double doubleValue) {\n+\t\treturn vf.createLiteral(doubleValue);\n+\t}\n+\n+\t/**\n+\t * Creates a new {@link Literal} with the supplied {@link BigDecimal} value\n+\t * \n+\t * @param bigDecimal a {@link BigDecimal} value\n+\t * \n+\t * @return a {@link Literal} of type {@link XSD#DECIMAL} with the supplied value\n+\t * \n+\t * @throws NullPointerException if the supplied bigDecimal is <code>null</code>.\n+\t */\n+\tpublic static Literal literal(BigDecimal bigDecimal) {\n+\t\treturn literal(VALUE_FACTORY, bigDecimal);\n+\t}\n+\n+\t/**\n+\t * Creates a new {@link Literal} with the supplied {@link BigDecimal} value\n+\t * \n+\t * @param vf         the {@link ValueFactory} to use for creation of the {@link Literal}\n+\t * @param bigDecimal a {@link BigDecimal} value\n+\t * \n+\t * @return a {@link Literal} of type {@link XSD#DECIMAL} with the supplied value\n+\t * \n+\t * @throws NullPointerException if any of the input parameters is <code>null</code>.\n+\t */\n+\tpublic static Literal literal(ValueFactory vf, BigDecimal bigDecimal) {\n+\t\treturn vf.createLiteral(Objects.requireNonNull(bigDecimal, \"bigDecimal may not be null\"));\n+\t}\n+\n+\t/**\n+\t * Creates a new {@link Literal} with the supplied {@link BigInteger} value\n+\t * \n+\t * @param bigInteger a {@link BigInteger} value\n+\t * \n+\t * @return a {@link Literal} of type {@link XSD#INTEGER} with the supplied value\n+\t * \n+\t * @throws NullPointerException if the supplied bigInteger is <code>null</code>.\n+\t */\n+\tpublic static Literal literal(BigInteger bigInteger) {\n+\t\treturn literal(VALUE_FACTORY, bigInteger);\n+\t}\n+\n+\t/**\n+\t * Creates a new {@link Literal} with the supplied {@link BigInteger} value\n+\t * \n+\t * @param vf         the {@link ValueFactory} to use for creation of the {@link Literal}\n+\t * @param bigInteger a {@link BigInteger} value\n+\t * \n+\t * @return a {@link Literal} of type {@link XSD#INTEGER} with the supplied value\n+\t * \n+\t * @throws NullPointerException if any of the input parameters is <code>null</code>.\n+\t */\n+\tpublic static Literal literal(ValueFactory vf, BigInteger bigInteger) {\n+\t\treturn vf.createLiteral(Objects.requireNonNull(bigInteger, \"bigInteger may not be null\"));\n+\t}\n+\n+\t/**\n+\t * Creates a new {@link Literal} with the supplied {@link TemporalAccessor} value\n+\t * \n+\t * @param value a {@link TemporalAccessor} value.\n+\t * \n+\t * @return a {@link Literal} with the supplied calendar value and the appropriate {@link XSD} date/time datatype for\n+\t *         the specific value.\n+\t * \n+\t * @throws NullPointerException     if the supplied {@link TemporalAccessor} value is <code>null</code>.\n+\t * @throws IllegalArgumentException if value cannot be represented by an XML Schema date/time datatype\n+\t */\n+\tpublic static Literal literal(TemporalAccessor value) throws IllegalArgumentException {\n+\t\treturn literal(VALUE_FACTORY, value);\n+\t}\n+\n+\t/**\n+\t * Creates a new {@link Literal} with the supplied {@link TemporalAccessor} value\n+\t *\n+\t * @param vf    the {@link ValueFactory} to use for creation of the {@link Literal}\n+\t * @param value a {@link TemporalAccessor} value.\n+\t * \n+\t * @return a {@link Literal} with the supplied calendar value and the appropriate {@link XSD} date/time datatype for\n+\t *         the specific value.\n+\t * \n+\t * @throws NullPointerException     if any of the input parameters is <code>null</code>..\n+\t * @throws IllegalArgumentException if value cannot be represented by an XML Schema date/time datatype\n+\t */\n+\tpublic static Literal literal(ValueFactory vf, TemporalAccessor value) throws IllegalArgumentException {\n+\t\treturn vf.createLiteral(Objects.requireNonNull(value, \"value may not be null\"));\n+\t}\n+\n+\t/**\n+\t * Creates a new typed {@link Literal} out of the supplied object, mapping the runtime type of the object to the\n+\t * appropriate {@link XSD} datatype. If no mapping is available, the method returns a literal with the string\n+\t * representation of the supplied object as the value, and {@link XSD#STRING} as the datatype.\n+\t * <p>\n+\t * Recognized types are {@link Boolean}, {@link Byte}, {@link Double}, {@link Float}, {@link Integer}, {@link Long},\n+\t * {@link Short}, {@link XMLGregorianCalendar } , {@link TemporalAccessor} and {@link Date}.\n+\t *\n+\t * @param object an object to be converted to a typed literal.\n+\t * \n+\t * @return a typed literal representation of the supplied object.\n+\t * \n+\t * @throws NullPointerException if the input parameter is <code>null</code>..\n+\t */\n+\tpublic static Literal literal(Object object) {\n+\t\treturn literal(VALUE_FACTORY, object, false);\n+\t}\n+\n+\t/**\n+\t * Creates a new typed {@link Literal} out of the supplied object, mapping the runtime type of the object to the\n+\t * appropriate {@link XSD} datatype.\n+\t * <p>\n+\t * Recognized types are {@link Boolean}, {@link Byte}, {@link Double}, {@link Float}, {@link Integer}, {@link Long},\n+\t * {@link Short}, {@link XMLGregorianCalendar } , {@link TemporalAccessor} and {@link Date}.\n+\t *\n+\t * @param object            an object to be converted to a typed literal.\n+\t * @param failOnUnknownType If no mapping is available and <code>failOnUnknownType</code> is <code>false</code> the\n+\t *                          method returns a literal with the string representation of the supplied object as the\n+\t *                          value, and {@link XSD#STRING} as the datatype. If set to <code>true</code> the method\n+\t *                          throws an {@link IllegalArgumentException} if no mapping available.\n+\t * \n+\t * @return a typed literal representation of the supplied object.\n+\t * \n+\t * @throws NullPointerException if the input parameter is <code>null</code>..\n+\t */\n+\tpublic static Literal literal(Object object, boolean failOnUnknownType) {\n+\t\treturn literal(VALUE_FACTORY, object, failOnUnknownType);\n+\t}\n+\n+\t/**\n+\t * Creates a new typed {@link Literal} out of the supplied object, mapping the runtime type of the object to the\n+\t * appropriate {@link XSD} datatype.\n+\t * <p>\n+\t * Recognized types are {@link Boolean}, {@link Byte}, {@link Double}, {@link Float}, {@link Integer}, {@link Long},\n+\t * {@link Short}, {@link XMLGregorianCalendar }, {@link TemporalAccessor} and {@link Date}.\n+\t *\n+\t * @param valueFactory      the {@link ValueFactory}to use for creation of the {@link Literal}\n+\t * @param object            an object to be converted to a typed literal.\n+\t * @param failOnUnknownType If no mapping is available and <code>failOnUnknownType</code> is <code>false</code> the\n+\t *                          method returns a literal with the string representation of the supplied object as the\n+\t *                          value, and {@link XSD#STRING} as the datatype. If set to <code>true</code> the method\n+\t *                          throws an {@link IllegalArgumentException} if no mapping available.\n+\t * \n+\t * @return a typed literal representation of the supplied object.\n+\t * \n+\t * @throws NullPointerException     if any of the input parameters is <code>null</code>.\n+\t * @throws IllegalArgumentException if <code>failOnUnknownType</code> is set to <code>true</code> and the runtime\n+\t *                                  type of the supplied object could not be mapped.\n+\t */\n+\tpublic static Literal literal(ValueFactory vf, Object object, boolean failOnUnknownType) {\n+\t\treturn createLiteralFromObject(vf, object, failOnUnknownType);\n+\t}\n+\n+\t/* triple factory methods */\n+\n+\t/**\n+\t * Creates a new {@link Triple RDF* embedded triple} with the supplied subject, predicate, and object.\n+\t *\n+\t * @param subject   the Triple subject\n+\t * @param predicate the Triple predicate\n+\t * @param object    the Triple object\n+\t * \n+\t * @return a {@link Triple} with the supplied subject, predicate, and object.\n+\t * \n+\t * @throws NullPointerException if any of the supplied input parameters is <code>null</code>.\n+\t */\n+\tpublic static Triple triple(Resource subject, IRI predicate, Value object) {\n+\t\treturn triple(VALUE_FACTORY, subject, predicate, object);\n+\t}\n+\n+\t/**\n+\t * Creates a new {@link Triple RDF* embedded triple} with the supplied subject, predicate, and object.\n+\t * \n+\t * @param vf        the {@link ValueFactory} to use for creation of the {@link Triple}\n+\t * @param subject   the Triple subject\n+\t * @param predicate the Triple predicate\n+\t * @param object    the Triple object\n+\t * \n+\t * @return a {@link Triple} with the supplied subject, predicate, and object.\n+\t * \n+\t * @throws NullPointerException if any of the supplied input parameters is <code>null</code>.\n+\t */\n+\tpublic static Triple triple(ValueFactory vf, Resource subject, IRI predicate, Value object) {\n+\t\treturn vf.createTriple(\n+\t\t\t\tObjects.requireNonNull(subject, \"subject may not be null\"),\n+\t\t\t\tObjects.requireNonNull(predicate, \"predicate may not be null\"),\n+\t\t\t\tObjects.requireNonNull(object, \"object may not be null\")\n+\t\t);\n+\t}\n+\n+\t/**\n+\t * Creates a new {@link Triple RDF* embedded triple} using the subject, predicate and object from the supplied\n+\t * {@link Statement}.\n+\t *\n+\t * @param statement the {@link Statement} from which to construct a {@link Triple}\n+\t * \n+\t * @return a {@link Triple} with the same subject, predicate, and object as the supplied Statement.\n+\t * \n+\t * @throws NullPointerException if statement is <code>null</code>.\n+\t */\n+\tpublic static Triple triple(Statement statement) {\n+\t\tObjects.requireNonNull(statement, \"statement may not be null\");\n+\t\treturn VALUE_FACTORY.createTriple(statement.getSubject(), statement.getPredicate(), statement.getObject());\n+\t}\n+\n+\t/**\n+\t * Creates a new {@link Triple RDF* embedded triple} using the subject, predicate and object from the supplied\n+\t * {@link Statement}.\n+\t * \n+\t * @param vf        the {@link ValueFactory} to use for creation of the {@link Triple}\n+\t * @param statement the {@link Statement} from which to construct a {@link Triple}\n+\t * \n+\t * @return a {@link Triple} with the same subject, predicate, and object as the supplied Statement.\n+\t * \n+\t * @throws NullPointerException if any of the supplied input parameters is <code>null</code>.\n+\t */\n+\tpublic static Triple triple(ValueFactory vf, Statement statement) {\n+\t\tObjects.requireNonNull(statement, \"statement may not be null\");\n+\t\treturn vf.createTriple(statement.getSubject(), statement.getPredicate(), statement.getObject());\n+\t}\n+\n+\t/**\n+\t * Get a {@link ValueFactory}.\n+\t * \n+\t * @return a {@link ValueFactory}.\n+\t */\n+\tpublic static ValueFactory getValueFactory() {\n+\t\treturn VALUE_FACTORY;\n+\t}\n+\n+\t/* private methods */\n+\n+\t/**\n+\t * Creates a typed {@link Literal} out of the supplied object, mapping the runtime type of the object to the\n+\t * appropriate XML Schema type. If no mapping is available, the method throws an exception if the boolean parameter\n+\t * is true, or if it is false it returns a literal with the string representation of the supplied object as the\n+\t * value, and {@link XSD#STRING} as the datatype. Recognized types are {@link Boolean}, {@link Byte},\n+\t * {@link Double}, {@link Float}, {@link Integer}, {@link Long}, {@link Short}, {@link XMLGregorianCalendar } , and\n+\t * {@link Date}.\n+\t *\n+\t * @param valueFactory            The {@link ValueFactory} to use when creating the result.\n+\t * @param object                  an object to be converted to a typed literal.\n+\t * @param throwExceptionOnFailure If true throws a {@link LiteralUtilException} when the object is not recognised.\n+\t *                                If false it returns a string typed literal based on the objects toString method.\n+\t * @return a typed literal representation of the supplied object.\n+\t * @throws IllegalArgumentException If the literal could not be created.\n+\t * @throws NullPointerException     If the object was null.\n+\t */\n+\tprivate static Literal createLiteralFromObject(ValueFactory valueFactory, Object object,\n+\t\t\tboolean throwExceptionOnFailure)\n+\t\t\tthrows IllegalArgumentException {\n+\t\tObjects.requireNonNull(valueFactory, \"valueFactory may not be null\");\n+\t\tObjects.requireNonNull(object, \"object may not be null\");\n+\n+\t\tif (object instanceof Boolean) {\n+\t\t\treturn valueFactory.createLiteral(((Boolean) object).booleanValue());\n+\t\t} else if (object instanceof Byte) {", "originalCommit": "c0192e3048ebf14f02687223ad2098e8b665fdce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjkyMzc4OA==", "url": "https://github.com/eclipse/rdf4j/pull/2680#discussion_r532923788", "bodyText": "The argument here can never be a primitive type, since it is an Object. Instead, to cover primitives, the literal method has been overloaded with functions that explicitly expect a primitive type.\nI think most of this is covered in the tests as well.\nIt's perhaps worth pointing out that due to autoboxing, we wouldn't even need the literal(Object) method if all we wanted was to support feeding in an object that corresponds to a primitive type: having the methods accept primitives is enough for that, the compiler would take care of the rest for us.\nWhat this literal(Object) method gives us extra is that you can feed it any object, without needing to do type checking first, and you get back a literal.", "author": "jeenbroekstra", "createdAt": "2020-11-30T21:45:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQ3Mzg3Nw=="}], "type": "inlineReview"}]}