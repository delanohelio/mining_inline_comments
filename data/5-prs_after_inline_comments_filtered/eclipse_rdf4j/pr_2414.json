{"pr_number": 2414, "pr_title": "GH-2324 obsolete ArrangedWriter; move node inlining and sorting logic into TurtleWriter", "pr_createdAt": "2020-08-01T05:42:44Z", "pr_url": "https://github.com/eclipse/rdf4j/pull/2414", "timeline": [{"oid": "2ab5debc929f75fd0a9230c36051646bda575bf0", "url": "https://github.com/eclipse/rdf4j/commit/2ab5debc929f75fd0a9230c36051646bda575bf0", "message": "GH-2324 avoid stackoverflow in list writing, handle contexts properly", "committedDate": "2020-08-01T05:50:04Z", "type": "forcePushed"}, {"oid": "103f9905e685379438bdbbaee09615ccda3349a5", "url": "https://github.com/eclipse/rdf4j/commit/103f9905e685379438bdbbaee09615ccda3349a5", "message": "Revert \"GH-2324 inlining blank nodes (#2404)\"\n\nThis reverts commit d7b51c198c0d07361a7f1899d82b27fe0fc83ae2.", "committedDate": "2020-08-01T06:10:06Z", "type": "commit"}, {"oid": "fc29b7ed8a6d4fe27e64d2d08f4fda5fcc6cdaad", "url": "https://github.com/eclipse/rdf4j/commit/fc29b7ed8a6d4fe27e64d2d08f4fda5fcc6cdaad", "message": "GH-2324 handle prettyprint/inlining inside TurtleWriter itself [WIP]", "committedDate": "2020-08-01T06:10:06Z", "type": "commit"}, {"oid": "fa13be5260b2afd96dc923b276967d503d21a1fa", "url": "https://github.com/eclipse/rdf4j/commit/fa13be5260b2afd96dc923b276967d503d21a1fa", "message": "GH-2324 avoid stackoverflow in list writing, handle contexts properly", "committedDate": "2020-08-01T06:10:06Z", "type": "commit"}, {"oid": "fa13be5260b2afd96dc923b276967d503d21a1fa", "url": "https://github.com/eclipse/rdf4j/commit/fa13be5260b2afd96dc923b276967d503d21a1fa", "message": "GH-2324 avoid stackoverflow in list writing, handle contexts properly", "committedDate": "2020-08-01T06:10:06Z", "type": "forcePushed"}, {"oid": "6c817bbae4be20c144e008c1aee4e76c9e29bf9e", "url": "https://github.com/eclipse/rdf4j/commit/6c817bbae4be20c144e008c1aee4e76c9e29bf9e", "message": "GH-2324 some test debugging output options", "committedDate": "2020-08-01T06:20:20Z", "type": "commit"}, {"oid": "608f296cff1db08ae5bdc4f3229200417a9ec803", "url": "https://github.com/eclipse/rdf4j/commit/608f296cff1db08ae5bdc4f3229200417a9ec803", "message": "GH-2324 handle blank node subjects in correct order", "committedDate": "2020-08-02T01:48:08Z", "type": "commit"}, {"oid": "44b5ab81fac6fffaa06be9e9d1dede308375e77f", "url": "https://github.com/eclipse/rdf4j/commit/44b5ab81fac6fffaa06be9e9d1dede308375e77f", "message": "GH-2324 do not skip subjects if not bnode-inlining", "committedDate": "2020-08-02T02:53:55Z", "type": "commit"}, {"oid": "0ad7766d767bb39c30be01395fb494f9fd2dedbd", "url": "https://github.com/eclipse/rdf4j/commit/0ad7766d767bb39c30be01395fb494f9fd2dedbd", "message": "GH-2324 clean up TriGWriter", "committedDate": "2020-08-02T03:11:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDAyODQ1NQ==", "url": "https://github.com/eclipse/rdf4j/pull/2414#discussion_r464028455", "bodyText": "All the changes in this file are just the result of me reverting some earlier attempts to fix the inlining issues. They're not really relevant as the ArrangedWriter class is no longer used and only left in place on the off-chance that some third party uses it (unlikely but you never know).", "author": "jeenbroekstra", "createdAt": "2020-08-02T04:06:17Z", "path": "core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/ArrangedWriter.java", "diffHunk": "@@ -205,29 +203,27 @@ protected synchronized void consumeStatement(Statement st) throws RDFHandlerExce\n \t}\n \n \tprivate synchronized Statement nextStatement() {\n-\n-\t\tif (statementBySubject.isEmpty() && blanks.isEmpty()) {\n+\t\tif (stmtBySubject.isEmpty() && blanks.isEmpty()) {\n \t\t\tassert queueSize == 0;\n \t\t\treturn null;\n \t\t}\n-\t\tSet<Statement> statements = null;\n-\t\twhile (statements == null) {\n+\t\tSet<Statement> stmts = null;\n+\t\twhile (stmts == null) {", "originalCommit": "0ad7766d767bb39c30be01395fb494f9fd2dedbd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA5MzIzMQ==", "url": "https://github.com/eclipse/rdf4j/pull/2414#discussion_r464093231", "bodyText": "This looks like you've reverted quite a lot of history.", "author": "hmottestad", "createdAt": "2020-08-02T15:49:55Z", "path": "core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/ArrangedWriter.java", "diffHunk": "@@ -298,105 +294,25 @@ private boolean isStillReferenced(SubjectInContext key) {\n \n \tprivate synchronized void queueStatement(Statement st) {\n \t\tSubjectInContext key = new SubjectInContext(st);\n-\t\tSet<Statement> stmts = statementBySubject.get(key);\n+\t\tSet<Statement> stmts = stmtBySubject.get(key);\n \t\tif (stmts == null && st.getSubject() instanceof BNode && !stack.contains(key)) {\n \t\t\tblanks.add(st);\n \t\t} else {\n \t\t\tif (stmts == null) {\n-\t\t\t\tstatementBySubject.put(key, stmts = new TreeSet<>(comparator));\n+\t\t\t\tstmtBySubject.put(key, stmts = new TreeSet<>(comparator));\n \t\t\t}\n \t\t\tstmts.add(st);\n \t\t}\n \t\tqueueSize++;\n \t}\n \n \tprivate synchronized void flushStatements() throws RDFHandlerException {\n-\t\tif (!statementBySubject.isEmpty() || !blanks.isEmpty()) {\n+\t\tif (!stmtBySubject.isEmpty() || !blanks.isEmpty()) {\n \t\t\tflushNamespaces();\n-\n-\t\t\t// used to store all the statements\n-\t\t\tArrayList<Statement> statements = new ArrayList<>();\n-\n-\t\t\t// used to store blank nodes along with the number of times they are used as an object in a statement.\n-\t\t\tMap<BNode, Integer> bNodeOccurrences = new HashMap<>();\n-\n \t\t\tStatement st;\n \t\t\twhile ((st = nextStatement()) != null) {\n-\t\t\t\tstatements.add(st);\n-\n-\t\t\t\tValue obj = st.getObject();\n-\n-\t\t\t\t// if the object in the statement is a blank node, we will update its number of occurrences\n-\t\t\t\tif (obj instanceof BNode) {\n-\t\t\t\t\tbNodeOccurrences.compute(\n-\t\t\t\t\t\t\t(BNode) obj,\n-\t\t\t\t\t\t\t(key, i) -> i == null ? 1 : i + 1\n-\t\t\t\t\t);\n-\n-\t\t\t\t\tif (bNodeOccurrences.get(obj) > 1) {\n-\t\t\t\t\t\tif (st.getSubject() instanceof BNode) {\n-\t\t\t\t\t\t\tnonInlinedNodes.add(st.getSubject());\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tnonInlinedNodes.add(obj);\n-\t\t\t\t\t}\n-\t\t\t\t}\n+\t\t\t\tdelegate.handleStatement(st);", "originalCommit": "0ad7766d767bb39c30be01395fb494f9fd2dedbd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDEzMjA2Ng==", "url": "https://github.com/eclipse/rdf4j/pull/2414#discussion_r464132066", "bodyText": "It's really only two pull requests - yours and Miro's. In retrospect it wasn't really necessary but I wanted to start with a fresh perspective instead of continuing to build on patches that didn't completely solve the problems.", "author": "jeenbroekstra", "createdAt": "2020-08-02T22:43:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA5MzIzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA5MzM4NQ==", "url": "https://github.com/eclipse/rdf4j/pull/2414#discussion_r464093385", "bodyText": "These should be ArrayDeque, unless we expect them to grow very very large (since expanding the ArrayDeque gets costlier the bigger it is, talking millions of entries).", "author": "hmottestad", "createdAt": "2020-08-02T15:51:31Z", "path": "core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/TurtleWriter.java", "diffHunk": "@@ -70,12 +85,6 @@\n \tprotected Resource lastWrittenSubject;\n \tprotected IRI lastWrittenPredicate;\n \n-\t/**\n-\t * Always null\n-\t */\n-\t@Deprecated\n-\tprotected Model prettyPrintModel;\n-\n \tprivate final Deque<Resource> stack = new LinkedList<>();\n \tprivate final Deque<IRI> path = new LinkedList<>();", "originalCommit": "0ad7766d767bb39c30be01395fb494f9fd2dedbd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDEzMjEyMA==", "url": "https://github.com/eclipse/rdf4j/pull/2414#discussion_r464132120", "bodyText": "We've got a lot of pre-1.6 code in places :) Good point, will fix.", "author": "jeenbroekstra", "createdAt": "2020-08-02T22:44:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA5MzM4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA5MzQ2Mw==", "url": "https://github.com/eclipse/rdf4j/pull/2414#discussion_r464093463", "bodyText": "You could just make it protected and then others could override this method if they have a better Model implementation they want to use.", "author": "hmottestad", "createdAt": "2020-08-02T15:52:26Z", "path": "core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/TurtleWriter.java", "diffHunk": "@@ -108,6 +117,11 @@ public TurtleWriter(OutputStream out, ParsedIRI baseIRI) {\n \t\tthis.writer = new IndentingWriter(new OutputStreamWriter(out, StandardCharsets.UTF_8));\n \t}\n \n+\t// TODO make injectable\n+\tprivate ModelFactory getModelFactory() {\n+\t\treturn new LinkedHashModelFactory();\n+\t}", "originalCommit": "0ad7766d767bb39c30be01395fb494f9fd2dedbd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDEzMjQzMw==", "url": "https://github.com/eclipse/rdf4j/pull/2414#discussion_r464132433", "bodyText": "Forgot about this. I prefer making it properly injectable instead of forcing people to subclass - I'll add a setter and also make it protected.", "author": "jeenbroekstra", "createdAt": "2020-08-02T22:47:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA5MzQ2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA5NDAxMA==", "url": "https://github.com/eclipse/rdf4j/pull/2414#discussion_r464094010", "bodyText": "Btw. If you use a long for bufferSize you can just set it to be Long.MAX_VALUE and you don't have to deal with -1 as a special case. Dunno if it would help, but it's a decent approach since you would run out of memory way before reaching that limit (minimum 4 611 686  terabytes).", "author": "hmottestad", "createdAt": "2020-08-02T15:56:25Z", "path": "core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/TurtleWriter.java", "diffHunk": "@@ -145,6 +159,12 @@ public void startRDF() throws RDFHandlerException {\n \t\t\txsdStringToPlainLiteral = getWriterConfig().get(BasicWriterSettings.XSD_STRING_TO_PLAIN_LITERAL);\n \t\t\tprettyPrint = getWriterConfig().get(BasicWriterSettings.PRETTY_PRINT);\n \t\t\tinlineBNodes = getWriterConfig().get(BasicWriterSettings.INLINE_BLANK_NODES);\n+\n+\t\t\tif (isBuffering()) {\n+\t\t\t\tthis.bufferedStatements = getModelFactory().createEmptyModel();\n+\t\t\t\tthis.bufferSize = inlineBNodes ? -1 : DEFAULT_BUFFER_SIZE;", "originalCommit": "0ad7766d767bb39c30be01395fb494f9fd2dedbd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDEzMjU4MA==", "url": "https://github.com/eclipse/rdf4j/pull/2414#discussion_r464132580", "bodyText": "Good idea.", "author": "jeenbroekstra", "createdAt": "2020-08-02T22:49:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA5NDAxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA5NDI3MQ==", "url": "https://github.com/eclipse/rdf4j/pull/2414#discussion_r464094271", "bodyText": "List handling in the pretty printed turtle code has always been bad. I should make some tests for that to see if you've fixed it now.", "author": "hmottestad", "createdAt": "2020-08-02T15:58:49Z", "path": "core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/TurtleWriter.java", "diffHunk": "@@ -256,57 +276,71 @@ protected void handleStatementInternal(Statement st, boolean endRDFCalled, boole\n \t\tResource subj = st.getSubject();\n \t\tIRI pred = st.getPredicate();\n \t\tValue obj = st.getObject();\n+\n \t\ttry {\n-\t\t\tif (subj.equals(lastWrittenSubject)) {\n-\t\t\t\tif (pred.equals(lastWrittenPredicate)) {\n-\t\t\t\t\t// Identical subject and predicate\n-\t\t\t\t\twriter.write(\",\");\n-\t\t\t\t\twrapLine(prettyPrint);\n-\t\t\t\t} else {\n-\t\t\t\t\t// Identical subject, new predicate\n-\t\t\t\t\twriter.write(\";\");\n-\t\t\t\t\twriter.writeEOL();\n-\n-\t\t\t\t\t// Write new predicate\n-\t\t\t\t\twriter.decreaseIndentation();\n-\t\t\t\t\twritePredicate(pred);\n-\t\t\t\t\twriter.increaseIndentation();\n-\t\t\t\t\twrapLine(true);\n-\t\t\t\t\tpath.removeLast();\n-\t\t\t\t\tpath.addLast(pred);\n-\t\t\t\t\tlastWrittenPredicate = pred;\n-\t\t\t\t}\n+\t\t\tif (inlineBNodes && (pred.equals(RDF.FIRST) || pred.equals(RDF.REST))) {\n+\t\t\t\thandleList(st);", "originalCommit": "0ad7766d767bb39c30be01395fb494f9fd2dedbd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDEzMTkwOA==", "url": "https://github.com/eclipse/rdf4j/pull/2414#discussion_r464131908", "bodyText": "None of what I've done really touches the list handling I think - the only thing that changes is how it is invoked.", "author": "jeenbroekstra", "createdAt": "2020-08-02T22:41:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA5NDI3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA5NDY3MQ==", "url": "https://github.com/eclipse/rdf4j/pull/2414#discussion_r464094671", "bodyText": "Does this now support pretty printing TriG? That would be awesome.", "author": "hmottestad", "createdAt": "2020-08-02T16:03:04Z", "path": "core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/TurtleWriter.java", "diffHunk": "@@ -701,4 +735,109 @@ private void wrapLine(boolean space) throws IOException {\n \t\t\twriter.write(\" \");\n \t\t}\n \t}\n+\n+\t/*\n+\t * not synchronized, assumes calling method has obtained a lock on bufferLock\n+\t */\n+\tprivate void processBuffer() throws RDFHandlerException {\n+\t\tif (!isBuffering()) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tif (this.getRDFFormat().supportsContexts()) { // to allow use in Turtle extensions such a TriG\n+\t\t\t// primary grouping per context.\n+\t\t\tfor (Resource context : bufferedStatements.contexts()) {\n+\t\t\t\tModel contextData = bufferedStatements.filter(null, null, null, context);\n+\t\t\t\tSet<Resource> processedSubjects = new HashSet<>();\n+\t\t\t\tOptional<Resource> nextSubject = nextSubject(contextData, processedSubjects);\n+\t\t\t\twhile (nextSubject.isPresent()) {\n+\t\t\t\t\tprocessSubject(contextData, nextSubject.get(), processedSubjects);\n+\t\t\t\t\tnextSubject = nextSubject(contextData, processedSubjects);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else {", "originalCommit": "0ad7766d767bb39c30be01395fb494f9fd2dedbd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDEzMTg3Mw==", "url": "https://github.com/eclipse/rdf4j/pull/2414#discussion_r464131873", "bodyText": "I didn't really check beyond testing that all TriG tests still succeed - I'm pretty sure TriGWriter already supported pretty printing to some extent though.", "author": "jeenbroekstra", "createdAt": "2020-08-02T22:41:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA5NDY3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA5NDgxMw==", "url": "https://github.com/eclipse/rdf4j/pull/2414#discussion_r464094813", "bodyText": "I wonder if this could be checked in some way. To assert that we're not calling this method from multiple threads.", "author": "hmottestad", "createdAt": "2020-08-02T16:04:35Z", "path": "core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/TurtleWriter.java", "diffHunk": "@@ -701,4 +735,109 @@ private void wrapLine(boolean space) throws IOException {\n \t\t\twriter.write(\" \");\n \t\t}\n \t}\n+\n+\t/*\n+\t * not synchronized, assumes calling method has obtained a lock on bufferLock\n+\t */\n+\tprivate void processBuffer() throws RDFHandlerException {", "originalCommit": "0ad7766d767bb39c30be01395fb494f9fd2dedbd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDEzMzkzOA==", "url": "https://github.com/eclipse/rdf4j/pull/2414#discussion_r464133938", "bodyText": "It's a private method, and expectations are documented. I'm not too worried about it tbh. I'll turn it into a javadoc comment though to be a bit more in-your-face about it.", "author": "jeenbroekstra", "createdAt": "2020-08-02T23:04:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA5NDgxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA5NDk2NQ==", "url": "https://github.com/eclipse/rdf4j/pull/2414#discussion_r464094965", "bodyText": "Nice use of optional!", "author": "hmottestad", "createdAt": "2020-08-02T16:06:07Z", "path": "core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/TurtleWriter.java", "diffHunk": "@@ -701,4 +735,109 @@ private void wrapLine(boolean space) throws IOException {\n \t\t\twriter.write(\" \");\n \t\t}\n \t}\n+\n+\t/*\n+\t * not synchronized, assumes calling method has obtained a lock on bufferLock\n+\t */\n+\tprivate void processBuffer() throws RDFHandlerException {\n+\t\tif (!isBuffering()) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tif (this.getRDFFormat().supportsContexts()) { // to allow use in Turtle extensions such a TriG\n+\t\t\t// primary grouping per context.\n+\t\t\tfor (Resource context : bufferedStatements.contexts()) {\n+\t\t\t\tModel contextData = bufferedStatements.filter(null, null, null, context);\n+\t\t\t\tSet<Resource> processedSubjects = new HashSet<>();\n+\t\t\t\tOptional<Resource> nextSubject = nextSubject(contextData, processedSubjects);\n+\t\t\t\twhile (nextSubject.isPresent()) {\n+\t\t\t\t\tprocessSubject(contextData, nextSubject.get(), processedSubjects);\n+\t\t\t\t\tnextSubject = nextSubject(contextData, processedSubjects);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else {\n+\t\t\t// group by subject\n+\n+\t\t\tSet<Resource> processedSubjects = new HashSet<>();\n+\t\t\tOptional<Resource> nextSubject = nextSubject(bufferedStatements, processedSubjects);\n+\t\t\twhile (nextSubject.isPresent()) {\n+\t\t\t\tprocessSubject(bufferedStatements, nextSubject.get(), processedSubjects);\n+\t\t\t\tnextSubject = nextSubject(bufferedStatements, processedSubjects);\n+\t\t\t}\n+\t\t}\n+\t\tbufferedStatements.clear();\n+\t}\n+\n+\tprivate Optional<Resource> nextSubject(Model contextData, Set<Resource> processedSubjects) {\n+\t\tfor (Resource subject : contextData.subjects()) {\n+\t\t\tif (processedSubjects.contains(subject)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tif (subject instanceof BNode && inlineBNodes) {\n+\t\t\t\tSet<Resource> otherSubjects = contextData.filter(null, null, subject).subjects();\n+\t\t\t\tif (otherSubjects.stream().anyMatch(s -> !processedSubjects.contains(s))) {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn Optional.of(subject);\n+\t\t}\n+\t\treturn Optional.empty();\n+\t}", "originalCommit": "0ad7766d767bb39c30be01395fb494f9fd2dedbd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA5NTczOA==", "url": "https://github.com/eclipse/rdf4j/pull/2414#discussion_r464095738", "bodyText": "Since these pieces of code are so similar I'm wondering if maybe you would prefer to use the java 8 streams grouping collector (https://www.baeldung.com/java-groupingby-collector) and then sort it so that rdf:type gets preference.\nA more performant alternative would be to sort contextData.getStatements(subject, null, null) by the predicate with preference to rdf:type and then grouping could be done by looking at the previous predicate.", "author": "hmottestad", "createdAt": "2020-08-02T16:14:20Z", "path": "core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/TurtleWriter.java", "diffHunk": "@@ -701,4 +735,109 @@ private void wrapLine(boolean space) throws IOException {\n \t\t\twriter.write(\" \");\n \t\t}\n \t}\n+\n+\t/*\n+\t * not synchronized, assumes calling method has obtained a lock on bufferLock\n+\t */\n+\tprivate void processBuffer() throws RDFHandlerException {\n+\t\tif (!isBuffering()) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tif (this.getRDFFormat().supportsContexts()) { // to allow use in Turtle extensions such a TriG\n+\t\t\t// primary grouping per context.\n+\t\t\tfor (Resource context : bufferedStatements.contexts()) {\n+\t\t\t\tModel contextData = bufferedStatements.filter(null, null, null, context);\n+\t\t\t\tSet<Resource> processedSubjects = new HashSet<>();\n+\t\t\t\tOptional<Resource> nextSubject = nextSubject(contextData, processedSubjects);\n+\t\t\t\twhile (nextSubject.isPresent()) {\n+\t\t\t\t\tprocessSubject(contextData, nextSubject.get(), processedSubjects);\n+\t\t\t\t\tnextSubject = nextSubject(contextData, processedSubjects);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else {\n+\t\t\t// group by subject\n+\n+\t\t\tSet<Resource> processedSubjects = new HashSet<>();\n+\t\t\tOptional<Resource> nextSubject = nextSubject(bufferedStatements, processedSubjects);\n+\t\t\twhile (nextSubject.isPresent()) {\n+\t\t\t\tprocessSubject(bufferedStatements, nextSubject.get(), processedSubjects);\n+\t\t\t\tnextSubject = nextSubject(bufferedStatements, processedSubjects);\n+\t\t\t}\n+\t\t}\n+\t\tbufferedStatements.clear();\n+\t}\n+\n+\tprivate Optional<Resource> nextSubject(Model contextData, Set<Resource> processedSubjects) {\n+\t\tfor (Resource subject : contextData.subjects()) {\n+\t\t\tif (processedSubjects.contains(subject)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tif (subject instanceof BNode && inlineBNodes) {\n+\t\t\t\tSet<Resource> otherSubjects = contextData.filter(null, null, subject).subjects();\n+\t\t\t\tif (otherSubjects.stream().anyMatch(s -> !processedSubjects.contains(s))) {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn Optional.of(subject);\n+\t\t}\n+\t\treturn Optional.empty();\n+\t}\n+\n+\tprivate void processSubject(Model contextData, Resource subject, Set<Resource> processedSubjects) {\n+\t\tif (processedSubjects.contains(subject)) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tSet<IRI> processedPredicates = new HashSet<>();\n+\n+\t\t// give rdf:type preference over other predicates.\n+\t\tfor (Statement typeStatement : contextData.getStatements(subject, RDF.TYPE, null)) {\n+\t\t\tboolean canInlineObject = inlineValue(contextData, typeStatement.getObject());\n+\t\t\thandleStatementInternal(typeStatement, false,\n+\t\t\t\t\tinlineValue(contextData, typeStatement.getSubject()),\n+\t\t\t\t\tcanInlineObject);\n+\n+\t\t\tif (canInlineObject && typeStatement.getObject() instanceof BNode) {\n+\t\t\t\tprocessSubject(contextData, (BNode) typeStatement.getObject(), processedSubjects);\n+\t\t\t}\n+\t\t}\n+\n+\t\tprocessedPredicates.add(RDF.TYPE);\n+\n+\t\t// retrieve other statement from this context with the same\n+\t\t// subject, and output them grouped by predicate\n+\t\tfor (Statement subjectStatement : contextData.getStatements(subject, null, null)) {\n+\t\t\tIRI predicate = subjectStatement.getPredicate();\n+\t\t\tif (!processedPredicates.contains(predicate)) {\n+\t\t\t\tfor (Statement toWrite : contextData.getStatements(subject, predicate, null)) {\n+\t\t\t\t\tboolean canInlineObject = inlineValue(contextData, toWrite.getObject());\n+\t\t\t\t\thandleStatementInternal(toWrite, false, inlineValue(contextData, toWrite.getSubject()),\n+\t\t\t\t\t\t\tcanInlineObject);\n+\t\t\t\t\tif (canInlineObject && toWrite.getObject() instanceof BNode) {\n+\t\t\t\t\t\tprocessSubject(contextData, (BNode) toWrite.getObject(), processedSubjects);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tprocessedPredicates.add(predicate);\n+\t\t\t}\n+\n+\t\t}", "originalCommit": "0ad7766d767bb39c30be01395fb494f9fd2dedbd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDEzMjY2MQ==", "url": "https://github.com/eclipse/rdf4j/pull/2414#discussion_r464132661", "bodyText": "I'll take a look at DRYing this up a bit.", "author": "jeenbroekstra", "createdAt": "2020-08-02T22:50:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA5NTczOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDEzNTIxOA==", "url": "https://github.com/eclipse/rdf4j/pull/2414#discussion_r464135218", "bodyText": "I had a quick look at a streaming/sorting approach, but to be honest I'm not convinced I can easily come up with an alternative that is both more performant and also still easy to read/maintain. Not really worth investing too much time in right now I think. I have reorganized the code a little bit though to make it less repetitive.", "author": "jeenbroekstra", "createdAt": "2020-08-02T23:17:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA5NTczOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA5NTkyNQ==", "url": "https://github.com/eclipse/rdf4j/pull/2414#discussion_r464095925", "bodyText": "Maybe this should be canInlineValue to indicate that it checks if inlining is allowed.", "author": "hmottestad", "createdAt": "2020-08-02T16:16:23Z", "path": "core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/TurtleWriter.java", "diffHunk": "@@ -701,4 +735,109 @@ private void wrapLine(boolean space) throws IOException {\n \t\t\twriter.write(\" \");\n \t\t}\n \t}\n+\n+\t/*\n+\t * not synchronized, assumes calling method has obtained a lock on bufferLock\n+\t */\n+\tprivate void processBuffer() throws RDFHandlerException {\n+\t\tif (!isBuffering()) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tif (this.getRDFFormat().supportsContexts()) { // to allow use in Turtle extensions such a TriG\n+\t\t\t// primary grouping per context.\n+\t\t\tfor (Resource context : bufferedStatements.contexts()) {\n+\t\t\t\tModel contextData = bufferedStatements.filter(null, null, null, context);\n+\t\t\t\tSet<Resource> processedSubjects = new HashSet<>();\n+\t\t\t\tOptional<Resource> nextSubject = nextSubject(contextData, processedSubjects);\n+\t\t\t\twhile (nextSubject.isPresent()) {\n+\t\t\t\t\tprocessSubject(contextData, nextSubject.get(), processedSubjects);\n+\t\t\t\t\tnextSubject = nextSubject(contextData, processedSubjects);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else {\n+\t\t\t// group by subject\n+\n+\t\t\tSet<Resource> processedSubjects = new HashSet<>();\n+\t\t\tOptional<Resource> nextSubject = nextSubject(bufferedStatements, processedSubjects);\n+\t\t\twhile (nextSubject.isPresent()) {\n+\t\t\t\tprocessSubject(bufferedStatements, nextSubject.get(), processedSubjects);\n+\t\t\t\tnextSubject = nextSubject(bufferedStatements, processedSubjects);\n+\t\t\t}\n+\t\t}\n+\t\tbufferedStatements.clear();\n+\t}\n+\n+\tprivate Optional<Resource> nextSubject(Model contextData, Set<Resource> processedSubjects) {\n+\t\tfor (Resource subject : contextData.subjects()) {\n+\t\t\tif (processedSubjects.contains(subject)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tif (subject instanceof BNode && inlineBNodes) {\n+\t\t\t\tSet<Resource> otherSubjects = contextData.filter(null, null, subject).subjects();\n+\t\t\t\tif (otherSubjects.stream().anyMatch(s -> !processedSubjects.contains(s))) {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn Optional.of(subject);\n+\t\t}\n+\t\treturn Optional.empty();\n+\t}\n+\n+\tprivate void processSubject(Model contextData, Resource subject, Set<Resource> processedSubjects) {\n+\t\tif (processedSubjects.contains(subject)) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tSet<IRI> processedPredicates = new HashSet<>();\n+\n+\t\t// give rdf:type preference over other predicates.\n+\t\tfor (Statement typeStatement : contextData.getStatements(subject, RDF.TYPE, null)) {\n+\t\t\tboolean canInlineObject = inlineValue(contextData, typeStatement.getObject());\n+\t\t\thandleStatementInternal(typeStatement, false,\n+\t\t\t\t\tinlineValue(contextData, typeStatement.getSubject()),\n+\t\t\t\t\tcanInlineObject);\n+\n+\t\t\tif (canInlineObject && typeStatement.getObject() instanceof BNode) {\n+\t\t\t\tprocessSubject(contextData, (BNode) typeStatement.getObject(), processedSubjects);\n+\t\t\t}\n+\t\t}\n+\n+\t\tprocessedPredicates.add(RDF.TYPE);\n+\n+\t\t// retrieve other statement from this context with the same\n+\t\t// subject, and output them grouped by predicate\n+\t\tfor (Statement subjectStatement : contextData.getStatements(subject, null, null)) {\n+\t\t\tIRI predicate = subjectStatement.getPredicate();\n+\t\t\tif (!processedPredicates.contains(predicate)) {\n+\t\t\t\tfor (Statement toWrite : contextData.getStatements(subject, predicate, null)) {\n+\t\t\t\t\tboolean canInlineObject = inlineValue(contextData, toWrite.getObject());\n+\t\t\t\t\thandleStatementInternal(toWrite, false, inlineValue(contextData, toWrite.getSubject()),\n+\t\t\t\t\t\t\tcanInlineObject);\n+\t\t\t\t\tif (canInlineObject && toWrite.getObject() instanceof BNode) {\n+\t\t\t\t\t\tprocessSubject(contextData, (BNode) toWrite.getObject(), processedSubjects);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tprocessedPredicates.add(predicate);\n+\t\t\t}\n+\n+\t\t}\n+\n+\t\tprocessedSubjects.add(subject);\n+\t}\n+\n+\tprivate boolean inlineValue(Model contextData, Value v) {\n+\t\tif (!inlineBNodes) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tif (v instanceof BNode) {\n+\t\t\treturn (contextData.filter(null, null, v).size() <= 1);\n+\t\t}\n+\t\treturn true;\n+\t}", "originalCommit": "0ad7766d767bb39c30be01395fb494f9fd2dedbd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA5NjA0Nw==", "url": "https://github.com/eclipse/rdf4j/pull/2414#discussion_r464096047", "bodyText": "It's a nice and simple approach though. I like it a lot.", "author": "hmottestad", "createdAt": "2020-08-02T16:17:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA5NTkyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA5NjEyMA==", "url": "https://github.com/eclipse/rdf4j/pull/2414#discussion_r464096120", "bodyText": "I'm wondering what happened to the buffer size value, shouldn't it be used in some form when deciding if we are buffering or not?", "author": "hmottestad", "createdAt": "2020-08-02T16:18:58Z", "path": "core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/TurtleWriter.java", "diffHunk": "@@ -701,4 +735,109 @@ private void wrapLine(boolean space) throws IOException {\n \t\t\twriter.write(\" \");\n \t\t}\n \t}\n+\n+\t/*\n+\t * not synchronized, assumes calling method has obtained a lock on bufferLock\n+\t */\n+\tprivate void processBuffer() throws RDFHandlerException {\n+\t\tif (!isBuffering()) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tif (this.getRDFFormat().supportsContexts()) { // to allow use in Turtle extensions such a TriG\n+\t\t\t// primary grouping per context.\n+\t\t\tfor (Resource context : bufferedStatements.contexts()) {\n+\t\t\t\tModel contextData = bufferedStatements.filter(null, null, null, context);\n+\t\t\t\tSet<Resource> processedSubjects = new HashSet<>();\n+\t\t\t\tOptional<Resource> nextSubject = nextSubject(contextData, processedSubjects);\n+\t\t\t\twhile (nextSubject.isPresent()) {\n+\t\t\t\t\tprocessSubject(contextData, nextSubject.get(), processedSubjects);\n+\t\t\t\t\tnextSubject = nextSubject(contextData, processedSubjects);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else {\n+\t\t\t// group by subject\n+\n+\t\t\tSet<Resource> processedSubjects = new HashSet<>();\n+\t\t\tOptional<Resource> nextSubject = nextSubject(bufferedStatements, processedSubjects);\n+\t\t\twhile (nextSubject.isPresent()) {\n+\t\t\t\tprocessSubject(bufferedStatements, nextSubject.get(), processedSubjects);\n+\t\t\t\tnextSubject = nextSubject(bufferedStatements, processedSubjects);\n+\t\t\t}\n+\t\t}\n+\t\tbufferedStatements.clear();\n+\t}\n+\n+\tprivate Optional<Resource> nextSubject(Model contextData, Set<Resource> processedSubjects) {\n+\t\tfor (Resource subject : contextData.subjects()) {\n+\t\t\tif (processedSubjects.contains(subject)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tif (subject instanceof BNode && inlineBNodes) {\n+\t\t\t\tSet<Resource> otherSubjects = contextData.filter(null, null, subject).subjects();\n+\t\t\t\tif (otherSubjects.stream().anyMatch(s -> !processedSubjects.contains(s))) {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn Optional.of(subject);\n+\t\t}\n+\t\treturn Optional.empty();\n+\t}\n+\n+\tprivate void processSubject(Model contextData, Resource subject, Set<Resource> processedSubjects) {\n+\t\tif (processedSubjects.contains(subject)) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tSet<IRI> processedPredicates = new HashSet<>();\n+\n+\t\t// give rdf:type preference over other predicates.\n+\t\tfor (Statement typeStatement : contextData.getStatements(subject, RDF.TYPE, null)) {\n+\t\t\tboolean canInlineObject = inlineValue(contextData, typeStatement.getObject());\n+\t\t\thandleStatementInternal(typeStatement, false,\n+\t\t\t\t\tinlineValue(contextData, typeStatement.getSubject()),\n+\t\t\t\t\tcanInlineObject);\n+\n+\t\t\tif (canInlineObject && typeStatement.getObject() instanceof BNode) {\n+\t\t\t\tprocessSubject(contextData, (BNode) typeStatement.getObject(), processedSubjects);\n+\t\t\t}\n+\t\t}\n+\n+\t\tprocessedPredicates.add(RDF.TYPE);\n+\n+\t\t// retrieve other statement from this context with the same\n+\t\t// subject, and output them grouped by predicate\n+\t\tfor (Statement subjectStatement : contextData.getStatements(subject, null, null)) {\n+\t\t\tIRI predicate = subjectStatement.getPredicate();\n+\t\t\tif (!processedPredicates.contains(predicate)) {\n+\t\t\t\tfor (Statement toWrite : contextData.getStatements(subject, predicate, null)) {\n+\t\t\t\t\tboolean canInlineObject = inlineValue(contextData, toWrite.getObject());\n+\t\t\t\t\thandleStatementInternal(toWrite, false, inlineValue(contextData, toWrite.getSubject()),\n+\t\t\t\t\t\t\tcanInlineObject);\n+\t\t\t\t\tif (canInlineObject && toWrite.getObject() instanceof BNode) {\n+\t\t\t\t\t\tprocessSubject(contextData, (BNode) toWrite.getObject(), processedSubjects);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tprocessedPredicates.add(predicate);\n+\t\t\t}\n+\n+\t\t}\n+\n+\t\tprocessedSubjects.add(subject);\n+\t}\n+\n+\tprivate boolean inlineValue(Model contextData, Value v) {\n+\t\tif (!inlineBNodes) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tif (v instanceof BNode) {\n+\t\t\treturn (contextData.filter(null, null, v).size() <= 1);\n+\t\t}\n+\t\treturn true;\n+\t}\n+\n+\tprivate boolean isBuffering() {\n+\t\treturn inlineBNodes || prettyPrint;\n+\t}", "originalCommit": "0ad7766d767bb39c30be01395fb494f9fd2dedbd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDEzNDIwNA==", "url": "https://github.com/eclipse/rdf4j/pull/2414#discussion_r464134204", "bodyText": "Buffer size value only influences the choice of when we flush the buffer. This private method is just meant to check if we are in fact using a buffer (which is what we do when we are either pretty-printing or inlining). It is in fact used to initialize the buffer as well, so it couldn't check the buffer size.", "author": "jeenbroekstra", "createdAt": "2020-08-02T23:07:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA5NjEyMA=="}], "type": "inlineReview"}, {"oid": "6d15e9090fa206dbf228d9f88f93a83169e9397a", "url": "https://github.com/eclipse/rdf4j/commit/6d15e9090fa206dbf228d9f88f93a83169e9397a", "message": "GH-2324 fixes from review feedback", "committedDate": "2020-08-03T00:41:03Z", "type": "commit"}]}