{"pr_number": 2254, "pr_title": "GH-405 add alt bag seq utility functions", "pr_createdAt": "2020-05-21T15:40:48Z", "pr_url": "https://github.com/eclipse/rdf4j/pull/2254", "timeline": [{"oid": "41e694bf3f88341da1554545c3fc8ac0d061a75f", "url": "https://github.com/eclipse/rdf4j/commit/41e694bf3f88341da1554545c3fc8ac0d061a75f", "message": "#405 Add file for the new feature\n\nSigned-off-by: Reeshabh Kumar Ranjan <reeshabhkumarranjan@gmail.com>", "committedDate": "2020-05-01T18:23:32Z", "type": "commit"}, {"oid": "ea5c0febd20e54349d0976ec422946b242987ec5", "url": "https://github.com/eclipse/rdf4j/commit/ea5c0febd20e54349d0976ec422946b242987ec5", "message": "Merge branch 'master' of https://github.com/eclipse/rdf4j into GH-405-add-alt-bag-seq", "committedDate": "2020-05-21T14:10:50Z", "type": "commit"}, {"oid": "51793a2136fc54ea8fb32a5e656bed794b9cf653", "url": "https://github.com/eclipse/rdf4j/commit/51793a2136fc54ea8fb32a5e656bed794b9cf653", "message": "#405 Add code for consumeCollection for RDFContainers\n\nSigned-off-by: Reeshabh Kumar Ranjan <reeshabhkumarranjan@gmail.com>", "committedDate": "2020-05-21T15:18:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk3NzAwMg==", "url": "https://github.com/eclipse/rdf4j/pull/2254#discussion_r428977002", "bodyText": "I'd do a check with an exception thrown here, rather than an assertion.", "author": "jeenbroekstra", "createdAt": "2020-05-22T00:03:45Z", "path": "core/model/src/main/java/org/eclipse/rdf4j/model/util/RDFContainers.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Eclipse RDF4J contributors.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Distribution License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/org/documents/edl-v10.php.\n+ *******************************************************************************/\n+\n+package org.eclipse.rdf4j.model.util;\n+\n+import org.eclipse.rdf4j.model.*;\n+import org.eclipse.rdf4j.model.impl.SimpleValueFactory;\n+import org.eclipse.rdf4j.model.vocabulary.RDF;\n+import org.eclipse.rdf4j.model.vocabulary.RDFS;\n+\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+\n+/**\n+ * TODO add documentation\n+ */\n+public class RDFContainers {\n+\n+\tpublic static <C extends Collection<Statement>> C asRDF(IRI containerType, Iterable<?> values, Resource container, C sink,\n+                                                            Resource... contexts) {\n+\n+\t\tObjects.requireNonNull(sink);\n+\t\tconsumeContainer(containerType, values, container, st -> sink.add(st), contexts);\n+\t\treturn sink;\n+\t}\n+\tpublic static void consumeContainer(IRI containerType, Iterable<?> values, Resource container, Consumer<Statement> consumer,\n+\t\t\tResource... contexts) {\n+\t\tconsumeContainer(containerType, values, container, consumer, SimpleValueFactory.getInstance(), contexts);\n+\t}\n+\tpublic static void consumeContainer(IRI containerType, Iterable<?> values, Resource container, Consumer<Statement> consumer,\n+\t\t\tValueFactory vf,\n+\t\t\tResource... contexts) {\n+\t\tObjects.requireNonNull(values, \"input collection may not be null\");\n+\t\tObjects.requireNonNull(consumer, \"consumer may not be null\");\n+\t\tObjects.requireNonNull(vf, \"injected value factory may not be null\");\n+\n+\t\tResource current = container != null ? container : vf.createBNode();\n+\t\tboolean validType = Objects.equals(containerType, RDF.ALT) ||\n+\t\t\t\tObjects.equals(containerType, RDF.BAG) ||\n+\t\t\t\tObjects.equals(containerType, RDF.SEQ);\n+\n+\t\tassert validType: \"containerType should be one of ALT, BAG or SEQ\";", "originalCommit": "51793a2136fc54ea8fb32a5e656bed794b9cf653", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTA3NzA1NQ==", "url": "https://github.com/eclipse/rdf4j/pull/2254#discussion_r429077055", "bodyText": "Alright, we will replace it with throwing an exception.", "author": "reeshabhranjan", "createdAt": "2020-05-22T07:03:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk3NzAwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk3NzQ1Mg==", "url": "https://github.com/eclipse/rdf4j/pull/2254#discussion_r428977452", "bodyText": "Our formatting guidelines don't allow wildcard imports. Have a look at https://github.com/eclipse/rdf4j/blob/master/.github/CONTRIBUTING.md#code-formatting for some tips on how set up your environment and/or run a few quick maven commands to fix your formatting.", "author": "jeenbroekstra", "createdAt": "2020-05-22T00:05:41Z", "path": "core/model/src/main/java/org/eclipse/rdf4j/model/util/RDFContainers.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Eclipse RDF4J contributors.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Distribution License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/org/documents/edl-v10.php.\n+ *******************************************************************************/\n+\n+package org.eclipse.rdf4j.model.util;\n+\n+import org.eclipse.rdf4j.model.*;", "originalCommit": "51793a2136fc54ea8fb32a5e656bed794b9cf653", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTA4MTYwMg==", "url": "https://github.com/eclipse/rdf4j/pull/2254#discussion_r429081602", "bodyText": "I used the command mvn formatter:format, but the formatting checks still fail.", "author": "reeshabhranjan", "createdAt": "2020-05-22T07:15:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk3NzQ1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU4MzcxOA==", "url": "https://github.com/eclipse/rdf4j/pull/2254#discussion_r429583718", "bodyText": "You'll also need to run mvn impsort:sort. Or just run mvn compile, it will automatically fix all formatting for you.", "author": "jeenbroekstra", "createdAt": "2020-05-23T22:41:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk3NzQ1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTYyMDYxNQ==", "url": "https://github.com/eclipse/rdf4j/pull/2254#discussion_r429620615", "bodyText": "mvn impsort:sort has fixed the formatting successfully.", "author": "prince17080", "createdAt": "2020-05-24T10:13:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk3NzQ1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk3ODc2NQ==", "url": "https://github.com/eclipse/rdf4j/pull/2254#discussion_r428978765", "bodyText": "Isn't this duplicating information? having :foo rdf:_1 :bar already implies that :foo rdfs:member :bar. I don't think you need to insert the rdfs:member property explicitly. Or do you have a specific use case in mind?", "author": "jeenbroekstra", "createdAt": "2020-05-22T00:10:35Z", "path": "core/model/src/main/java/org/eclipse/rdf4j/model/util/RDFContainers.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Eclipse RDF4J contributors.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Distribution License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/org/documents/edl-v10.php.\n+ *******************************************************************************/\n+\n+package org.eclipse.rdf4j.model.util;\n+\n+import org.eclipse.rdf4j.model.*;\n+import org.eclipse.rdf4j.model.impl.SimpleValueFactory;\n+import org.eclipse.rdf4j.model.vocabulary.RDF;\n+import org.eclipse.rdf4j.model.vocabulary.RDFS;\n+\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+\n+/**\n+ * TODO add documentation\n+ */\n+public class RDFContainers {\n+\n+\tpublic static <C extends Collection<Statement>> C asRDF(IRI containerType, Iterable<?> values, Resource container, C sink,\n+                                                            Resource... contexts) {\n+\n+\t\tObjects.requireNonNull(sink);\n+\t\tconsumeContainer(containerType, values, container, st -> sink.add(st), contexts);\n+\t\treturn sink;\n+\t}\n+\tpublic static void consumeContainer(IRI containerType, Iterable<?> values, Resource container, Consumer<Statement> consumer,\n+\t\t\tResource... contexts) {\n+\t\tconsumeContainer(containerType, values, container, consumer, SimpleValueFactory.getInstance(), contexts);\n+\t}\n+\tpublic static void consumeContainer(IRI containerType, Iterable<?> values, Resource container, Consumer<Statement> consumer,\n+\t\t\tValueFactory vf,\n+\t\t\tResource... contexts) {\n+\t\tObjects.requireNonNull(values, \"input collection may not be null\");\n+\t\tObjects.requireNonNull(consumer, \"consumer may not be null\");\n+\t\tObjects.requireNonNull(vf, \"injected value factory may not be null\");\n+\n+\t\tResource current = container != null ? container : vf.createBNode();\n+\t\tboolean validType = Objects.equals(containerType, RDF.ALT) ||\n+\t\t\t\tObjects.equals(containerType, RDF.BAG) ||\n+\t\t\t\tObjects.equals(containerType, RDF.SEQ);\n+\n+\t\tassert validType: \"containerType should be one of ALT, BAG or SEQ\";\n+\n+\t\tStatements.consume(vf, current, RDF.TYPE, containerType, consumer, contexts);\n+\n+\t\tIterator<?> iter = values.iterator();\n+\t\tint elementCounter = 1;\n+\t\twhile (iter.hasNext()) {\n+\t\t\tObject o = iter.next();\n+\t\t\tValue v = o instanceof Value ? (Value) o : Literals.createLiteralOrFail(vf, o);\n+\t\t\tIRI elementCounterPredicate = vf.createIRI(RDF.NAMESPACE, \"_\" + elementCounter);\n+\t\t\telementCounter++;\n+\t\t\tStatements.consume(vf, current, elementCounterPredicate, v, consumer, contexts);\n+\t\t\tStatements.consume(vf, (Resource) v, RDFS.MEMBER, current, consumer, contexts);", "originalCommit": "51793a2136fc54ea8fb32a5e656bed794b9cf653", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTA4MDcyNQ==", "url": "https://github.com/eclipse/rdf4j/pull/2254#discussion_r429080725", "bodyText": "The :container rdf:_1 :element is for the ordering in rdf:Seq.\nThe :container rdfs:member :member is to reduce the time taken to check the membership of an element in a container. If we remove this triple, we would need to iterate over all :container rdf:_nnn :element to see if it exists. Otherwise, a single check for :container rdfs:member :element will be sufficient. It is a good tradeoff between time and space complexity.\nHowever, someone importing an ontology might not have both these information. So should I remove it and just go with the foo rdf:_nnn :bar?\nAlso, by mistake I mistakened the subject with object in the later one, I will fix it in the next PR.", "author": "reeshabhranjan", "createdAt": "2020-05-22T07:13:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk3ODc2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU4NjkyMQ==", "url": "https://github.com/eclipse/rdf4j/pull/2254#discussion_r429586921", "bodyText": "That makes sense, thanks, and well picked up on that mistake, I completely missed that!", "author": "jeenbroekstra", "createdAt": "2020-05-23T23:52:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk3ODc2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk4MDQ1OQ==", "url": "https://github.com/eclipse/rdf4j/pull/2254#discussion_r428980459", "bodyText": "Perhaps a nice addition would be to also have conversion methods that pick the container type, e.g asAlt, asSeq, and asBag.", "author": "jeenbroekstra", "createdAt": "2020-05-22T00:16:57Z", "path": "core/model/src/main/java/org/eclipse/rdf4j/model/util/RDFContainers.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Eclipse RDF4J contributors.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Distribution License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/org/documents/edl-v10.php.\n+ *******************************************************************************/\n+\n+package org.eclipse.rdf4j.model.util;\n+\n+import org.eclipse.rdf4j.model.*;\n+import org.eclipse.rdf4j.model.impl.SimpleValueFactory;\n+import org.eclipse.rdf4j.model.vocabulary.RDF;\n+import org.eclipse.rdf4j.model.vocabulary.RDFS;\n+\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+\n+/**\n+ * TODO add documentation\n+ */\n+public class RDFContainers {\n+\n+\tpublic static <C extends Collection<Statement>> C asRDF(IRI containerType, Iterable<?> values, Resource container, C sink,", "originalCommit": "51793a2136fc54ea8fb32a5e656bed794b9cf653", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTA4MjM3OQ==", "url": "https://github.com/eclipse/rdf4j/pull/2254#discussion_r429082379", "bodyText": "Actually the containerType passed into the asRDF method is for that purpose only. We will use the containerType parameter in further implementations. Should we have those separate methods as well?", "author": "reeshabhranjan", "createdAt": "2020-05-22T07:17:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk4MDQ1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUyNjQzNA==", "url": "https://github.com/eclipse/rdf4j/pull/2254#discussion_r429526434", "bodyText": "Just a comment on the use of \u201cas\u201d. Java has \u201ctoString\u201d and that\u2019s made me use \u201cto\u201d rather than \u201cas\u201d in other code.", "author": "hmottestad", "createdAt": "2020-05-23T08:19:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk4MDQ1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU4Mzg5NQ==", "url": "https://github.com/eclipse/rdf4j/pull/2254#discussion_r429583895", "bodyText": "@hmottestad I think in this case it's modeled off of the naming we use in the RDFCollections class for similar methods. I kind of agree with you that 'to' might have been a better choice ('as' to me suggests a view on an object rather than a new, converted, object), but to stay consistent I'm fine with sticking with this.", "author": "jeenbroekstra", "createdAt": "2020-05-23T22:45:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk4MDQ1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU4NjgxNQ==", "url": "https://github.com/eclipse/rdf4j/pull/2254#discussion_r429586815", "bodyText": "@hmottestad  actually, coming back to it, I think you are right, and we might as well change this. @reeshabhkumarranjan do you think you could do a fix to change all the as... method names asRDF, asValues to to... method names (toRDF, toValues, etc.)?", "author": "jeenbroekstra", "createdAt": "2020-05-23T23:49:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk4MDQ1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTYwOTU3NA==", "url": "https://github.com/eclipse/rdf4j/pull/2254#discussion_r429609574", "bodyText": "@jeenbroekstra Yes I can do this. Just to confirm, I have to do this only in RDFContainers.java, right?", "author": "reeshabhranjan", "createdAt": "2020-05-24T07:50:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk4MDQ1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY5NjE5OA==", "url": "https://github.com/eclipse/rdf4j/pull/2254#discussion_r429696198", "bodyText": "Yes, that's correct, only RDFContainers. We'll fix RDFCollections later, separately.", "author": "jeenbroekstra", "createdAt": "2020-05-25T01:09:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk4MDQ1OQ=="}], "type": "inlineReview"}, {"oid": "99f47b25bf0cbc90a038e91b9da1171c6b048710", "url": "https://github.com/eclipse/rdf4j/commit/99f47b25bf0cbc90a038e91b9da1171c6b048710", "message": "#405 Replace assertion with throwing a runtime exception, add untested code for consumeValues() method for RDFContainers.java (documentation pending)\n\nSigned-off-by: Reeshabh Kumar Ranjan <reeshabhkumarranjan@gmail.com>", "committedDate": "2020-05-22T19:02:10Z", "type": "commit"}, {"oid": "9369b054be8784eb86496fb3052c0c3e07852fc7", "url": "https://github.com/eclipse/rdf4j/commit/9369b054be8784eb86496fb3052c0c3e07852fc7", "message": "#405 Add remaining methods (as present in RDFCollection) (documentation pending)\n\nSigned-off-by: Reeshabh Kumar Ranjan <reeshabhkumarranjan@gmail.com>", "committedDate": "2020-05-22T20:18:16Z", "type": "commit"}, {"oid": "d768b869e2064b602d8d68377eaf65d9dca6a354", "url": "https://github.com/eclipse/rdf4j/commit/d768b869e2064b602d8d68377eaf65d9dca6a354", "message": "#405 Add documentation\n\nSigned-off-by: Prince Sachdeva <prince17080@iiitd.ac.in>", "committedDate": "2020-05-23T13:03:36Z", "type": "commit"}, {"oid": "bf47ea4c78be83fcd8d89e441362db7dbece69d7", "url": "https://github.com/eclipse/rdf4j/commit/bf47ea4c78be83fcd8d89e441362db7dbece69d7", "message": "#405 Format the file\n\nSigned-off-by: Prince Sachdeva <prince17080@iiitd.ac.in>", "committedDate": "2020-05-23T13:13:02Z", "type": "commit"}, {"oid": "079ef6278d1efa0788583fa5d4fc3e692b169a02", "url": "https://github.com/eclipse/rdf4j/commit/079ef6278d1efa0788583fa5d4fc3e692b169a02", "message": "#405 Correct the RDFS.Member triple in consumeContainer method\n\nSigned-off-by: Prince Sachdeva <prince17080@iiitd.ac.in>", "committedDate": "2020-05-23T16:03:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU4Njk5OQ==", "url": "https://github.com/eclipse/rdf4j/pull/2254#discussion_r429586999", "bodyText": "I think that should be '3.3.0'.", "author": "jeenbroekstra", "createdAt": "2020-05-23T23:54:11Z", "path": "core/model/src/main/java/org/eclipse/rdf4j/model/util/RDFContainers.java", "diffHunk": "@@ -0,0 +1,397 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Eclipse RDF4J contributors.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Distribution License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/org/documents/edl-v10.php.\n+ *******************************************************************************/\n+\n+package org.eclipse.rdf4j.model.util;\n+\n+import org.eclipse.rdf4j.OpenRDFUtil;\n+import org.eclipse.rdf4j.RDF4JException;\n+import org.eclipse.rdf4j.model.*;\n+import org.eclipse.rdf4j.model.impl.SimpleValueFactory;\n+import org.eclipse.rdf4j.model.vocabulary.RDF;\n+import org.eclipse.rdf4j.model.vocabulary.RDFS;\n+\n+import java.util.*;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Utilities for working with RDF Containers and converting to/from Java {@link Collection} classes.\n+ * <P>\n+ * RDF Containers are represented using 3 different types of structures:\n+ *\n+ * 1. {@link RDF#BAG} : A Bag (a resource having type rdf:Bag) represents a group of resources or literals, possibly\n+ * including duplicate members, where there is no significance in the order of the members.\n+ *\n+ * 2. {@link RDF#SEQ} : A Sequence or Seq (a resource having type rdf:Seq) represents a group of resources or literals,\n+ * possibly including duplicate members, where the order of the members is significant.\n+ *\n+ * 3. {@link RDF#ALT} : An Alternative or Alt (a resource having type rdf:Alt) represents a group of resources or\n+ * literals that are alternatives (typically for a single value of a property).\n+ *\n+ * So, in each of the above types, the container starts with a first resource node, via the rdf:_1 relation. Similarly,\n+ * the next member is connected via the rdf:_2 relation and so on.\n+ *\n+ * For eg. Bag containing three literal values \"A\", \"B\", and \"C\" looks like this as an RDF Container:\n+ *\n+ * <pre>\n+ *   _:n1 -rdf:type--> rdf:Bag\n+ *     |\n+ *     +---rdf:_1--> \"A\"\n+ *     |\n+ *     +---rdf:_2--> \"B\"\n+ *     |\n+ *     +---rdf:_3--> \"C\"\n+ * </pre>\n+ *\n+ * \n+ * @see <a href=\"https://www.w3.org/TR/rdf-schema/#ch_container\">RDF Schema 1.1 section on Collection vocabulary</a>.\n+ */\n+public class RDFContainers {\n+\n+\t/**\n+\t * Converts the supplied {@link Iterable} to an <a href=\"https://www.w3.org/TR/rdf-schema/#ch_container\">RDF\n+\t * Container</a>, using the supplied {@code head} resource as the starting resource of the RDF Containter. The\n+\t * statements making up the new RDF Containter will be added to the supplied statement collection.\n+\t *\n+\t * @param containerType defines the type of RDF Container\n+\t * @param values        an {@link Iterable} of objects (such as a Java {@link Collection} ), which will be converted\n+\t *                      to an RDF Containter. May not be {@code null}. The method attempts to convert each value\n+\t *                      that is not already an instance of {@link Value} to a {@link Literal}. This conversion will\n+\t *                      fail with a {@link LiteralUtilException} if the value's object type is not supported. See\n+\t *                      {@link Literals#createLiteralOrFail(ValueFactory, Object)} for an overview of supported\n+\t *                      types.\n+\t * @param container     a {@link Resource} which will be used as the head of the container, that is, the starting\n+\t *                      point of the created RDF Container. May be {@code null}, in which case a new resource is\n+\t *                      generated to represent the container head.\n+\t * @param sink          a {@link Collection} of {@link Statement} objects (for example a {@link Model}) to which the\n+\t *                      RDF Collection statements will be added. May not be {@code null}.\n+\t * @param contexts      the context(s) in which to add the RDF Containter. This argument is an optional vararg and\n+\t *                      can be left out.\n+\t * @return the supplied sink {@link Collection} of {@link Statement}s, with the new Statements forming the RDF\n+\t *         Collection added.\n+\t * @throws LiteralUtilException if one of the supplied values can not be converted to a Literal.\n+\t * @see <a href=\"https://www.w3.org/TR/rdf-schema/#ch_container\">RDF Schema 1.1 section on Collection\n+\t *      vocabulary</a>.\n+\t */\n+\tpublic static <C extends Collection<Statement>> C asRDF(IRI containerType, Iterable<?> values, Resource container,\n+\t\t\tC sink,\n+\t\t\tResource... contexts) {\n+\n+\t\tObjects.requireNonNull(sink);\n+\t\tconsumeContainer(containerType, values, container, st -> sink.add(st), contexts);\n+\t\treturn sink;\n+\t}\n+\n+\t/**\n+\t * Converts the supplied {@link Iterable} to an <a href=\"https://www.w3.org/TR/rdf-schema/#ch_container\">RDF\n+\t * Container</a>, using the supplied {@code head} resource as the starting resource of the RDF Containter. The\n+\t * statements making up the new RDF Containter will be added to the supplied statement collection.\n+\t *\n+\t * @param containerType defines the type of RDF Container\n+\t * @param values        an {@link Iterable} of objects (such as a Java {@link Collection} ), which will be converted\n+\t *                      to an RDF Containter. May not be {@code null}. The method attempts to convert each value\n+\t *                      that is not already an instance of {@link Value} to a {@link Literal}. This conversion will\n+\t *                      fail with a {@link LiteralUtilException} if the value's object type is not supported. See\n+\t *                      {@link Literals#createLiteralOrFail(ValueFactory, Object)} for an overview of supported\n+\t *                      types.\n+\t * @param container     a {@link Resource} which will be used as the head of the container, that is, the starting\n+\t *                      point of the created RDF Container. May be {@code null}, in which case a new resource is\n+\t *                      generated to represent the container head.\n+\t * @param sink          a {@link Collection} of {@link Statement} objects (for example a {@link Model}) to which the\n+\t *                      RDF Collection statements will be added. May not be {@code null}.\n+\t * @param vf            the {@link ValueFactory} to be used for creation of RDF model objects. May not be\n+\t *                      {@code null}.\n+\t * @param contexts      the context(s) in which to add the RDF Containter. This argument is an optional vararg and\n+\t *                      can be left out.\n+\t * @return the supplied sink {@link Collection} of {@link Statement}s, with the new Statements forming the RDF\n+\t *         Collection added.\n+\t * @throws LiteralUtilException if one of the supplied values can not be converted to a Literal.\n+\t * @see <a href=\"https://www.w3.org/TR/rdf-schema/#ch_container\">RDF Schema 1.1 section on Collection\n+\t *      vocabulary</a>.\n+\t */\n+\tpublic static <C extends Collection<Statement>> C asRDF(IRI containerType, Iterable<?> values, Resource container,\n+\t\t\tC sink,\n+\t\t\tValueFactory vf, Resource... contexts) {\n+\n+\t\tObjects.requireNonNull(sink);\n+\t\tconsumeContainer(containerType, values, container, st -> sink.add(st), vf, contexts);\n+\t\treturn sink;\n+\t}\n+\n+\t/**\n+\t * Converts an RDF Containter to a Java {@link Collection} of {@link Value} objects. The RDF Containter is given by\n+\t * the supplied {@link Model} and {@code container}. This method expects the RDF Containter to be well-formed. If\n+\t * the collection is not well-formed the method may return part of the collection, or may throw a\n+\t * {@link ModelException}.\n+\t *\n+\t * @param containerType defines the type of RDF Container\n+\t * @param m             the Model containing the collection to read.\n+\t * @param container     the {@link Resource} that represents the container head, that is the start resource of the\n+\t *                      RDF Container to be read. May not be {@code null}.\n+\t * @param collection    the Java {@link Collection} to add the collection items to.\n+\t * @param contexts      the context(s) from which to read the RDF Containter. This argument is an optional vararg\n+\t *                      and can be left out.\n+\t * @return the supplied Java {@link Collection}, filled with the items from the RDF Containter (if any).\n+\t * @throws ModelException if a problem occurs reading the RDF Containter, for example if the Collection is not\n+\t *                        well-formed.\n+\t * @see <a href=\"https://www.w3.org/TR/rdf-schema/#ch_container\">RDF Schema 1.1 section on Collection\n+\t *      vocabulary</a>.\n+\t */\n+\tpublic static <C extends Collection<Value>> C asValues(IRI containerType, final Model m, Resource container,\n+\t\t\tC collection,\n+\t\t\tResource... contexts) throws ModelException {\n+\t\tObjects.requireNonNull(collection, \"collection may not be null\");\n+\n+\t\tconsumeValues(m, container, containerType, v -> collection.add(v), contexts);\n+\n+\t\treturn collection;\n+\t}\n+\n+\t/**\n+\t * Converts the supplied {@link Iterable} to an <a href=\"https://www.w3.org/TR/rdf-schema/#ch_container\">RDF\n+\t * Container</a>, using the supplied {@code head} resource as the starting resource of the RDF Containter. The\n+\t * statements making up the new RDF Containter will be reported to the supplied {@link Consumer} function.\n+\t *\n+\t * @param containerType defines the type of RDF Container\n+\t * @param values        an {@link Iterable} of objects (such as a Java {@link Collection} ), which will be converted\n+\t *                      to an RDF Containter. May not be {@code null}. The method attempts to convert each value\n+\t *                      that is not already an instance of {@link Value} to a {@link Literal}. This conversion will\n+\t *                      fail with a {@link LiteralUtilException} if the value's object type is not supported. See\n+\t *                      {@link Literals#createLiteralOrFail(ValueFactory, Object)} for an overview of supported\n+\t *                      types.\n+\t * @param container     a {@link Resource} which will be used as the head of the container, that is, the starting\n+\t *                      point of the created RDF Containter. May be {@code null}, in which case a new resource is\n+\t *                      generated to represent the containter head.\n+\t * @param consumer      the {@link Consumer} function for the Statements of the RDF Containter. May not be\n+\t *                      {@code null}.\n+\t * @param contexts      the context(s) in which to add the RDF Containter. This argument is an optional vararg and\n+\t *                      can be left out.\n+\t * @throws LiteralUtilException if one of the supplied values can not be converted to a Literal.\n+\t * @see <a href=\"https://www.w3.org/TR/rdf-schema/#ch_container\">RDF Schema 1.1 section on Collection\n+\t *      vocabulary</a>.\n+\t * @see Literals#createLiteralOrFail(ValueFactory, Object)\n+\t */\n+\tpublic static void consumeContainer(IRI containerType, Iterable<?> values, Resource container,\n+\t\t\tConsumer<Statement> consumer,\n+\t\t\tResource... contexts) {\n+\t\tconsumeContainer(containerType, values, container, consumer, SimpleValueFactory.getInstance(), contexts);\n+\t}\n+\n+\t/**\n+\t * Converts the supplied {@link Iterable} to an <a href=\"https://www.w3.org/TR/rdf-schema/#ch_container\">RDF\n+\t * Container</a>, using the supplied {@code head} resource as the starting resource of the RDF Container. The\n+\t * statements making up the new RDF Container will be reported to the supplied {@link Consumer} function.\n+\t *\n+\t * @param containerType defines the type of RDF Container\n+\t * @param values        an {@link Iterable} of objects (such as a Java {@link Collection} ), which will be converted\n+\t *                      to an RDF Container. May not be {@code null}. The method attempts to convert each value that\n+\t *                      is not already an instance of {@link Value} to a {@link Literal}. This conversion will fail\n+\t *                      with a {@link LiteralUtilException} if the value's object type is not supported. See\n+\t *                      {@link Literals#createLiteralOrFail(ValueFactory, Object)} for an overview of supported\n+\t *                      types.\n+\t * @param container     a {@link Resource} which will be used as the head of the container, that is, the starting\n+\t *                      point of the created RDF Container. May be {@code null}, in which case a new resource is\n+\t *                      generated to represent the containter head.\n+\t * @param consumer      the {@link Consumer} function for the Statements of the RDF Container. May not be\n+\t *                      {@code null}.\n+\t * @param vf            the {@link ValueFactory} to use for creation of new model objects. May not be {@code null}\n+\t * @param contexts      the context(s) in which to add the RDF Container. This argument is an optional vararg and\n+\t *                      can be left out.\n+\t * @throws LiteralUtilException if one of the supplied values can not be converted to a Literal.\n+\t * @see <a href=\"https://www.w3.org/TR/rdf-schema/#ch_container\">RDF Schema 1.1 section on Collection\n+\t *      vocabulary</a>.\n+\t * @see Literals#createLiteralOrFail(ValueFactory, Object)\n+\t *\n+\t * @since 3.0", "originalCommit": "079ef6278d1efa0788583fa5d4fc3e692b169a02", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU4NzA0Mw==", "url": "https://github.com/eclipse/rdf4j/pull/2254#discussion_r429587043", "bodyText": "I think this should be a ModelException, rather than a generic RuntimeException.", "author": "jeenbroekstra", "createdAt": "2020-05-23T23:55:03Z", "path": "core/model/src/main/java/org/eclipse/rdf4j/model/util/RDFContainers.java", "diffHunk": "@@ -0,0 +1,397 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Eclipse RDF4J contributors.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Distribution License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/org/documents/edl-v10.php.\n+ *******************************************************************************/\n+\n+package org.eclipse.rdf4j.model.util;\n+\n+import org.eclipse.rdf4j.OpenRDFUtil;\n+import org.eclipse.rdf4j.RDF4JException;\n+import org.eclipse.rdf4j.model.*;\n+import org.eclipse.rdf4j.model.impl.SimpleValueFactory;\n+import org.eclipse.rdf4j.model.vocabulary.RDF;\n+import org.eclipse.rdf4j.model.vocabulary.RDFS;\n+\n+import java.util.*;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Utilities for working with RDF Containers and converting to/from Java {@link Collection} classes.\n+ * <P>\n+ * RDF Containers are represented using 3 different types of structures:\n+ *\n+ * 1. {@link RDF#BAG} : A Bag (a resource having type rdf:Bag) represents a group of resources or literals, possibly\n+ * including duplicate members, where there is no significance in the order of the members.\n+ *\n+ * 2. {@link RDF#SEQ} : A Sequence or Seq (a resource having type rdf:Seq) represents a group of resources or literals,\n+ * possibly including duplicate members, where the order of the members is significant.\n+ *\n+ * 3. {@link RDF#ALT} : An Alternative or Alt (a resource having type rdf:Alt) represents a group of resources or\n+ * literals that are alternatives (typically for a single value of a property).\n+ *\n+ * So, in each of the above types, the container starts with a first resource node, via the rdf:_1 relation. Similarly,\n+ * the next member is connected via the rdf:_2 relation and so on.\n+ *\n+ * For eg. Bag containing three literal values \"A\", \"B\", and \"C\" looks like this as an RDF Container:\n+ *\n+ * <pre>\n+ *   _:n1 -rdf:type--> rdf:Bag\n+ *     |\n+ *     +---rdf:_1--> \"A\"\n+ *     |\n+ *     +---rdf:_2--> \"B\"\n+ *     |\n+ *     +---rdf:_3--> \"C\"\n+ * </pre>\n+ *\n+ * \n+ * @see <a href=\"https://www.w3.org/TR/rdf-schema/#ch_container\">RDF Schema 1.1 section on Collection vocabulary</a>.\n+ */\n+public class RDFContainers {\n+\n+\t/**\n+\t * Converts the supplied {@link Iterable} to an <a href=\"https://www.w3.org/TR/rdf-schema/#ch_container\">RDF\n+\t * Container</a>, using the supplied {@code head} resource as the starting resource of the RDF Containter. The\n+\t * statements making up the new RDF Containter will be added to the supplied statement collection.\n+\t *\n+\t * @param containerType defines the type of RDF Container\n+\t * @param values        an {@link Iterable} of objects (such as a Java {@link Collection} ), which will be converted\n+\t *                      to an RDF Containter. May not be {@code null}. The method attempts to convert each value\n+\t *                      that is not already an instance of {@link Value} to a {@link Literal}. This conversion will\n+\t *                      fail with a {@link LiteralUtilException} if the value's object type is not supported. See\n+\t *                      {@link Literals#createLiteralOrFail(ValueFactory, Object)} for an overview of supported\n+\t *                      types.\n+\t * @param container     a {@link Resource} which will be used as the head of the container, that is, the starting\n+\t *                      point of the created RDF Container. May be {@code null}, in which case a new resource is\n+\t *                      generated to represent the container head.\n+\t * @param sink          a {@link Collection} of {@link Statement} objects (for example a {@link Model}) to which the\n+\t *                      RDF Collection statements will be added. May not be {@code null}.\n+\t * @param contexts      the context(s) in which to add the RDF Containter. This argument is an optional vararg and\n+\t *                      can be left out.\n+\t * @return the supplied sink {@link Collection} of {@link Statement}s, with the new Statements forming the RDF\n+\t *         Collection added.\n+\t * @throws LiteralUtilException if one of the supplied values can not be converted to a Literal.\n+\t * @see <a href=\"https://www.w3.org/TR/rdf-schema/#ch_container\">RDF Schema 1.1 section on Collection\n+\t *      vocabulary</a>.\n+\t */\n+\tpublic static <C extends Collection<Statement>> C asRDF(IRI containerType, Iterable<?> values, Resource container,\n+\t\t\tC sink,\n+\t\t\tResource... contexts) {\n+\n+\t\tObjects.requireNonNull(sink);\n+\t\tconsumeContainer(containerType, values, container, st -> sink.add(st), contexts);\n+\t\treturn sink;\n+\t}\n+\n+\t/**\n+\t * Converts the supplied {@link Iterable} to an <a href=\"https://www.w3.org/TR/rdf-schema/#ch_container\">RDF\n+\t * Container</a>, using the supplied {@code head} resource as the starting resource of the RDF Containter. The\n+\t * statements making up the new RDF Containter will be added to the supplied statement collection.\n+\t *\n+\t * @param containerType defines the type of RDF Container\n+\t * @param values        an {@link Iterable} of objects (such as a Java {@link Collection} ), which will be converted\n+\t *                      to an RDF Containter. May not be {@code null}. The method attempts to convert each value\n+\t *                      that is not already an instance of {@link Value} to a {@link Literal}. This conversion will\n+\t *                      fail with a {@link LiteralUtilException} if the value's object type is not supported. See\n+\t *                      {@link Literals#createLiteralOrFail(ValueFactory, Object)} for an overview of supported\n+\t *                      types.\n+\t * @param container     a {@link Resource} which will be used as the head of the container, that is, the starting\n+\t *                      point of the created RDF Container. May be {@code null}, in which case a new resource is\n+\t *                      generated to represent the container head.\n+\t * @param sink          a {@link Collection} of {@link Statement} objects (for example a {@link Model}) to which the\n+\t *                      RDF Collection statements will be added. May not be {@code null}.\n+\t * @param vf            the {@link ValueFactory} to be used for creation of RDF model objects. May not be\n+\t *                      {@code null}.\n+\t * @param contexts      the context(s) in which to add the RDF Containter. This argument is an optional vararg and\n+\t *                      can be left out.\n+\t * @return the supplied sink {@link Collection} of {@link Statement}s, with the new Statements forming the RDF\n+\t *         Collection added.\n+\t * @throws LiteralUtilException if one of the supplied values can not be converted to a Literal.\n+\t * @see <a href=\"https://www.w3.org/TR/rdf-schema/#ch_container\">RDF Schema 1.1 section on Collection\n+\t *      vocabulary</a>.\n+\t */\n+\tpublic static <C extends Collection<Statement>> C asRDF(IRI containerType, Iterable<?> values, Resource container,\n+\t\t\tC sink,\n+\t\t\tValueFactory vf, Resource... contexts) {\n+\n+\t\tObjects.requireNonNull(sink);\n+\t\tconsumeContainer(containerType, values, container, st -> sink.add(st), vf, contexts);\n+\t\treturn sink;\n+\t}\n+\n+\t/**\n+\t * Converts an RDF Containter to a Java {@link Collection} of {@link Value} objects. The RDF Containter is given by\n+\t * the supplied {@link Model} and {@code container}. This method expects the RDF Containter to be well-formed. If\n+\t * the collection is not well-formed the method may return part of the collection, or may throw a\n+\t * {@link ModelException}.\n+\t *\n+\t * @param containerType defines the type of RDF Container\n+\t * @param m             the Model containing the collection to read.\n+\t * @param container     the {@link Resource} that represents the container head, that is the start resource of the\n+\t *                      RDF Container to be read. May not be {@code null}.\n+\t * @param collection    the Java {@link Collection} to add the collection items to.\n+\t * @param contexts      the context(s) from which to read the RDF Containter. This argument is an optional vararg\n+\t *                      and can be left out.\n+\t * @return the supplied Java {@link Collection}, filled with the items from the RDF Containter (if any).\n+\t * @throws ModelException if a problem occurs reading the RDF Containter, for example if the Collection is not\n+\t *                        well-formed.\n+\t * @see <a href=\"https://www.w3.org/TR/rdf-schema/#ch_container\">RDF Schema 1.1 section on Collection\n+\t *      vocabulary</a>.\n+\t */\n+\tpublic static <C extends Collection<Value>> C asValues(IRI containerType, final Model m, Resource container,\n+\t\t\tC collection,\n+\t\t\tResource... contexts) throws ModelException {\n+\t\tObjects.requireNonNull(collection, \"collection may not be null\");\n+\n+\t\tconsumeValues(m, container, containerType, v -> collection.add(v), contexts);\n+\n+\t\treturn collection;\n+\t}\n+\n+\t/**\n+\t * Converts the supplied {@link Iterable} to an <a href=\"https://www.w3.org/TR/rdf-schema/#ch_container\">RDF\n+\t * Container</a>, using the supplied {@code head} resource as the starting resource of the RDF Containter. The\n+\t * statements making up the new RDF Containter will be reported to the supplied {@link Consumer} function.\n+\t *\n+\t * @param containerType defines the type of RDF Container\n+\t * @param values        an {@link Iterable} of objects (such as a Java {@link Collection} ), which will be converted\n+\t *                      to an RDF Containter. May not be {@code null}. The method attempts to convert each value\n+\t *                      that is not already an instance of {@link Value} to a {@link Literal}. This conversion will\n+\t *                      fail with a {@link LiteralUtilException} if the value's object type is not supported. See\n+\t *                      {@link Literals#createLiteralOrFail(ValueFactory, Object)} for an overview of supported\n+\t *                      types.\n+\t * @param container     a {@link Resource} which will be used as the head of the container, that is, the starting\n+\t *                      point of the created RDF Containter. May be {@code null}, in which case a new resource is\n+\t *                      generated to represent the containter head.\n+\t * @param consumer      the {@link Consumer} function for the Statements of the RDF Containter. May not be\n+\t *                      {@code null}.\n+\t * @param contexts      the context(s) in which to add the RDF Containter. This argument is an optional vararg and\n+\t *                      can be left out.\n+\t * @throws LiteralUtilException if one of the supplied values can not be converted to a Literal.\n+\t * @see <a href=\"https://www.w3.org/TR/rdf-schema/#ch_container\">RDF Schema 1.1 section on Collection\n+\t *      vocabulary</a>.\n+\t * @see Literals#createLiteralOrFail(ValueFactory, Object)\n+\t */\n+\tpublic static void consumeContainer(IRI containerType, Iterable<?> values, Resource container,\n+\t\t\tConsumer<Statement> consumer,\n+\t\t\tResource... contexts) {\n+\t\tconsumeContainer(containerType, values, container, consumer, SimpleValueFactory.getInstance(), contexts);\n+\t}\n+\n+\t/**\n+\t * Converts the supplied {@link Iterable} to an <a href=\"https://www.w3.org/TR/rdf-schema/#ch_container\">RDF\n+\t * Container</a>, using the supplied {@code head} resource as the starting resource of the RDF Container. The\n+\t * statements making up the new RDF Container will be reported to the supplied {@link Consumer} function.\n+\t *\n+\t * @param containerType defines the type of RDF Container\n+\t * @param values        an {@link Iterable} of objects (such as a Java {@link Collection} ), which will be converted\n+\t *                      to an RDF Container. May not be {@code null}. The method attempts to convert each value that\n+\t *                      is not already an instance of {@link Value} to a {@link Literal}. This conversion will fail\n+\t *                      with a {@link LiteralUtilException} if the value's object type is not supported. See\n+\t *                      {@link Literals#createLiteralOrFail(ValueFactory, Object)} for an overview of supported\n+\t *                      types.\n+\t * @param container     a {@link Resource} which will be used as the head of the container, that is, the starting\n+\t *                      point of the created RDF Container. May be {@code null}, in which case a new resource is\n+\t *                      generated to represent the containter head.\n+\t * @param consumer      the {@link Consumer} function for the Statements of the RDF Container. May not be\n+\t *                      {@code null}.\n+\t * @param vf            the {@link ValueFactory} to use for creation of new model objects. May not be {@code null}\n+\t * @param contexts      the context(s) in which to add the RDF Container. This argument is an optional vararg and\n+\t *                      can be left out.\n+\t * @throws LiteralUtilException if one of the supplied values can not be converted to a Literal.\n+\t * @see <a href=\"https://www.w3.org/TR/rdf-schema/#ch_container\">RDF Schema 1.1 section on Collection\n+\t *      vocabulary</a>.\n+\t * @see Literals#createLiteralOrFail(ValueFactory, Object)\n+\t *\n+\t * @since 3.0\n+\t */\n+\tpublic static void consumeContainer(IRI containerType, Iterable<?> values, Resource container,\n+\t\t\tConsumer<Statement> consumer,\n+\t\t\tValueFactory vf, Resource... contexts) {\n+\t\tObjects.requireNonNull(values, \"input collection may not be null\");\n+\t\tObjects.requireNonNull(consumer, \"consumer may not be null\");\n+\t\tObjects.requireNonNull(vf, \"injected value factory may not be null\");\n+\n+\t\tResource current = container != null ? container : vf.createBNode();\n+\t\tboolean validType = Objects.equals(containerType, RDF.ALT) ||\n+\t\t\t\tObjects.equals(containerType, RDF.BAG) ||\n+\t\t\t\tObjects.equals(containerType, RDF.SEQ);\n+\n+\t\tif (!validType) {\n+\t\t\tthrow new RuntimeException(\"containerType should be one of ALT, BAG or SEQ\");", "originalCommit": "079ef6278d1efa0788583fa5d4fc3e692b169a02", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU4NzEyMQ==", "url": "https://github.com/eclipse/rdf4j/pull/2254#discussion_r429587121", "bodyText": "Like @hmottestad also suggested above, I think renaming this to toRDF (and similarly, also rename asValues to toValues) is better. I realize you followed the naming we used in RDFCollections for this but I think we got this wrong there, and we might as well do it right in this one (we'll fix it in the RDFCollections later as well, but that's a separate issue).", "author": "jeenbroekstra", "createdAt": "2020-05-23T23:57:10Z", "path": "core/model/src/main/java/org/eclipse/rdf4j/model/util/RDFContainers.java", "diffHunk": "@@ -0,0 +1,397 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Eclipse RDF4J contributors.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Distribution License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/org/documents/edl-v10.php.\n+ *******************************************************************************/\n+\n+package org.eclipse.rdf4j.model.util;\n+\n+import org.eclipse.rdf4j.OpenRDFUtil;\n+import org.eclipse.rdf4j.RDF4JException;\n+import org.eclipse.rdf4j.model.*;\n+import org.eclipse.rdf4j.model.impl.SimpleValueFactory;\n+import org.eclipse.rdf4j.model.vocabulary.RDF;\n+import org.eclipse.rdf4j.model.vocabulary.RDFS;\n+\n+import java.util.*;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Utilities for working with RDF Containers and converting to/from Java {@link Collection} classes.\n+ * <P>\n+ * RDF Containers are represented using 3 different types of structures:\n+ *\n+ * 1. {@link RDF#BAG} : A Bag (a resource having type rdf:Bag) represents a group of resources or literals, possibly\n+ * including duplicate members, where there is no significance in the order of the members.\n+ *\n+ * 2. {@link RDF#SEQ} : A Sequence or Seq (a resource having type rdf:Seq) represents a group of resources or literals,\n+ * possibly including duplicate members, where the order of the members is significant.\n+ *\n+ * 3. {@link RDF#ALT} : An Alternative or Alt (a resource having type rdf:Alt) represents a group of resources or\n+ * literals that are alternatives (typically for a single value of a property).\n+ *\n+ * So, in each of the above types, the container starts with a first resource node, via the rdf:_1 relation. Similarly,\n+ * the next member is connected via the rdf:_2 relation and so on.\n+ *\n+ * For eg. Bag containing three literal values \"A\", \"B\", and \"C\" looks like this as an RDF Container:\n+ *\n+ * <pre>\n+ *   _:n1 -rdf:type--> rdf:Bag\n+ *     |\n+ *     +---rdf:_1--> \"A\"\n+ *     |\n+ *     +---rdf:_2--> \"B\"\n+ *     |\n+ *     +---rdf:_3--> \"C\"\n+ * </pre>\n+ *\n+ * \n+ * @see <a href=\"https://www.w3.org/TR/rdf-schema/#ch_container\">RDF Schema 1.1 section on Collection vocabulary</a>.\n+ */\n+public class RDFContainers {\n+\n+\t/**\n+\t * Converts the supplied {@link Iterable} to an <a href=\"https://www.w3.org/TR/rdf-schema/#ch_container\">RDF\n+\t * Container</a>, using the supplied {@code head} resource as the starting resource of the RDF Containter. The\n+\t * statements making up the new RDF Containter will be added to the supplied statement collection.\n+\t *\n+\t * @param containerType defines the type of RDF Container\n+\t * @param values        an {@link Iterable} of objects (such as a Java {@link Collection} ), which will be converted\n+\t *                      to an RDF Containter. May not be {@code null}. The method attempts to convert each value\n+\t *                      that is not already an instance of {@link Value} to a {@link Literal}. This conversion will\n+\t *                      fail with a {@link LiteralUtilException} if the value's object type is not supported. See\n+\t *                      {@link Literals#createLiteralOrFail(ValueFactory, Object)} for an overview of supported\n+\t *                      types.\n+\t * @param container     a {@link Resource} which will be used as the head of the container, that is, the starting\n+\t *                      point of the created RDF Container. May be {@code null}, in which case a new resource is\n+\t *                      generated to represent the container head.\n+\t * @param sink          a {@link Collection} of {@link Statement} objects (for example a {@link Model}) to which the\n+\t *                      RDF Collection statements will be added. May not be {@code null}.\n+\t * @param contexts      the context(s) in which to add the RDF Containter. This argument is an optional vararg and\n+\t *                      can be left out.\n+\t * @return the supplied sink {@link Collection} of {@link Statement}s, with the new Statements forming the RDF\n+\t *         Collection added.\n+\t * @throws LiteralUtilException if one of the supplied values can not be converted to a Literal.\n+\t * @see <a href=\"https://www.w3.org/TR/rdf-schema/#ch_container\">RDF Schema 1.1 section on Collection\n+\t *      vocabulary</a>.\n+\t */\n+\tpublic static <C extends Collection<Statement>> C asRDF(IRI containerType, Iterable<?> values, Resource container,", "originalCommit": "079ef6278d1efa0788583fa5d4fc3e692b169a02", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUyMzAxNQ==", "url": "https://github.com/eclipse/rdf4j/pull/2254#discussion_r429523015", "bodyText": "Here I am using regex to find properties of type rdf:_nnn and simple .equals() to check for rdfs:member.", "author": "reeshabhranjan", "createdAt": "2020-05-23T07:29:05Z", "path": "core/model/src/main/java/org/eclipse/rdf4j/model/util/RDFContainers.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Eclipse RDF4J contributors.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Distribution License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/org/documents/edl-v10.php.\n+ *******************************************************************************/\n+\n+package org.eclipse.rdf4j.model.util;\n+\n+import org.eclipse.rdf4j.OpenRDFUtil;\n+import org.eclipse.rdf4j.RDF4JException;\n+import org.eclipse.rdf4j.model.*;\n+import org.eclipse.rdf4j.model.impl.SimpleValueFactory;\n+import org.eclipse.rdf4j.model.vocabulary.RDF;\n+import org.eclipse.rdf4j.model.vocabulary.RDFS;\n+\n+import java.util.*;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * TODO add documentation\n+ */\n+public class RDFContainers {\n+\n+\tpublic static <C extends Collection<Statement>> C asRDF(IRI containerType, Iterable<?> values, Resource container, C sink,\n+                                                            Resource... contexts) {\n+\n+\t\tObjects.requireNonNull(sink);\n+\t\tconsumeContainer(containerType, values, container, st -> sink.add(st), contexts);\n+\t\treturn sink;\n+\t}\n+\n+\tpublic static <C extends Collection<Statement>> C asRDF(IRI containerType, Iterable<?> values, Resource container, C sink,\n+                                                            ValueFactory vf, Resource... contexts) {\n+\n+\t\tObjects.requireNonNull(sink);\n+\t\tconsumeContainer(containerType, values, container, st -> sink.add(st), vf, contexts);\n+\t\treturn sink;\n+\t}\n+\n+\tpublic static <C extends Collection<Value>> C asValues(IRI containerType, final Model m, Resource container, C collection,\n+\t\t\tResource... contexts) throws ModelException {\n+\t\tObjects.requireNonNull(collection, \"collection may not be null\");\n+\n+\t\tconsumeValues(m, container, containerType, v -> collection.add(v), contexts);\n+\n+\t\treturn collection;\n+\t}\n+\n+\tpublic static void consumeContainer(IRI containerType, Iterable<?> values, Resource container, Consumer<Statement> consumer,\n+\t\t\tResource... contexts) {\n+\t\tconsumeContainer(containerType, values, container, consumer, SimpleValueFactory.getInstance(), contexts);\n+\t}\n+\tpublic static void consumeContainer(IRI containerType, Iterable<?> values, Resource container, Consumer<Statement> consumer,\n+\t\t\tValueFactory vf,\n+\t\t\tResource... contexts) {\n+\t\tObjects.requireNonNull(values, \"input collection may not be null\");\n+\t\tObjects.requireNonNull(consumer, \"consumer may not be null\");\n+\t\tObjects.requireNonNull(vf, \"injected value factory may not be null\");\n+\n+\t\tResource current = container != null ? container : vf.createBNode();\n+\t\tboolean validType = Objects.equals(containerType, RDF.ALT) ||\n+\t\t\t\tObjects.equals(containerType, RDF.BAG) ||\n+\t\t\t\tObjects.equals(containerType, RDF.SEQ);\n+\n+\t\tif (!validType) {\n+\t\t\tthrow new RuntimeException(\"containerType should be one of ALT, BAG or SEQ\");\n+\t\t}\n+\n+\t\tStatements.consume(vf, current, RDF.TYPE, containerType, consumer, contexts);\n+\n+\t\tIterator<?> iter = values.iterator();\n+\t\tint elementCounter = 1;\n+\t\twhile (iter.hasNext()) {\n+\t\t\tObject o = iter.next();\n+\t\t\tValue v = o instanceof Value ? (Value) o : Literals.createLiteralOrFail(vf, o);\n+\t\t\tIRI elementCounterPredicate = getAnnotatedMemberPredicate(vf, elementCounter);\n+\t\t\telementCounter++;\n+\t\t\tStatements.consume(vf, current, elementCounterPredicate, v, consumer, contexts);\n+\t\t\tStatements.consume(vf, (Resource) v, RDFS.MEMBER, current, consumer, contexts);\n+\t\t}\n+\t}\n+\n+\tprivate static IRI getAnnotatedMemberPredicate(ValueFactory vf, int elementCounter) {\n+\t\treturn vf.createIRI(RDF.NAMESPACE, \"_\" + elementCounter);\n+\t}\n+\n+\n+\n+\tpublic static void consumeValues(final Model m, Resource container, IRI containerType, Consumer<Value> consumer, Resource... contexts)\n+\t\t\tthrows ModelException {\n+\t\tObjects.requireNonNull(consumer, \"consumer may not be null\");\n+\t\tObjects.requireNonNull(m, \"input model may not be null\");\n+\n+\t\tValueFactory vf = SimpleValueFactory.getInstance();\n+\n+\t\tGetStatementOptional statementSupplier = (s, p, o, c) -> m.filter(s, p, o, c).stream().findAny();\n+\t\tFunction<String, Supplier<ModelException>> exceptionSupplier = Models::modelException;\n+\n+\t\t// TODO add proper documentation\n+\t\tPattern annotatedMembershipPredicatePattern = Pattern.compile(\"^\" + vf.createIRI(RDF.NAMESPACE, \"_\") + \"[1-9][0-9]*$\");\n+\n+\t\textract(containerType, statementSupplier, container, st -> {\n+\t\t\tif (RDFS.MEMBER.equals(st.getPredicate()) ||\n+\t\t\t\tannotatedMembershipPredicatePattern.matcher(st.getPredicate().toString()).matches()) {\n+\t\t\t\tconsumer.accept(st.getObject());\n+\t\t\t}\n+\t\t}, exceptionSupplier, contexts);\n+\t}", "originalCommit": "9369b054be8784eb86496fb3052c0c3e07852fc7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUyMzEwMA==", "url": "https://github.com/eclipse/rdf4j/pull/2254#discussion_r429523100", "bodyText": "I will loop through the statements of the form ?s rdf:_nnn ?o until it exists.", "author": "reeshabhranjan", "createdAt": "2020-05-23T07:30:30Z", "path": "core/model/src/main/java/org/eclipse/rdf4j/model/util/RDFContainers.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Eclipse RDF4J contributors.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Distribution License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/org/documents/edl-v10.php.\n+ *******************************************************************************/\n+\n+package org.eclipse.rdf4j.model.util;\n+\n+import org.eclipse.rdf4j.OpenRDFUtil;\n+import org.eclipse.rdf4j.RDF4JException;\n+import org.eclipse.rdf4j.model.*;\n+import org.eclipse.rdf4j.model.impl.SimpleValueFactory;\n+import org.eclipse.rdf4j.model.vocabulary.RDF;\n+import org.eclipse.rdf4j.model.vocabulary.RDFS;\n+\n+import java.util.*;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * TODO add documentation\n+ */\n+public class RDFContainers {\n+\n+\tpublic static <C extends Collection<Statement>> C asRDF(IRI containerType, Iterable<?> values, Resource container, C sink,\n+                                                            Resource... contexts) {\n+\n+\t\tObjects.requireNonNull(sink);\n+\t\tconsumeContainer(containerType, values, container, st -> sink.add(st), contexts);\n+\t\treturn sink;\n+\t}\n+\n+\tpublic static <C extends Collection<Statement>> C asRDF(IRI containerType, Iterable<?> values, Resource container, C sink,\n+                                                            ValueFactory vf, Resource... contexts) {\n+\n+\t\tObjects.requireNonNull(sink);\n+\t\tconsumeContainer(containerType, values, container, st -> sink.add(st), vf, contexts);\n+\t\treturn sink;\n+\t}\n+\n+\tpublic static <C extends Collection<Value>> C asValues(IRI containerType, final Model m, Resource container, C collection,\n+\t\t\tResource... contexts) throws ModelException {\n+\t\tObjects.requireNonNull(collection, \"collection may not be null\");\n+\n+\t\tconsumeValues(m, container, containerType, v -> collection.add(v), contexts);\n+\n+\t\treturn collection;\n+\t}\n+\n+\tpublic static void consumeContainer(IRI containerType, Iterable<?> values, Resource container, Consumer<Statement> consumer,\n+\t\t\tResource... contexts) {\n+\t\tconsumeContainer(containerType, values, container, consumer, SimpleValueFactory.getInstance(), contexts);\n+\t}\n+\tpublic static void consumeContainer(IRI containerType, Iterable<?> values, Resource container, Consumer<Statement> consumer,\n+\t\t\tValueFactory vf,\n+\t\t\tResource... contexts) {\n+\t\tObjects.requireNonNull(values, \"input collection may not be null\");\n+\t\tObjects.requireNonNull(consumer, \"consumer may not be null\");\n+\t\tObjects.requireNonNull(vf, \"injected value factory may not be null\");\n+\n+\t\tResource current = container != null ? container : vf.createBNode();\n+\t\tboolean validType = Objects.equals(containerType, RDF.ALT) ||\n+\t\t\t\tObjects.equals(containerType, RDF.BAG) ||\n+\t\t\t\tObjects.equals(containerType, RDF.SEQ);\n+\n+\t\tif (!validType) {\n+\t\t\tthrow new RuntimeException(\"containerType should be one of ALT, BAG or SEQ\");\n+\t\t}\n+\n+\t\tStatements.consume(vf, current, RDF.TYPE, containerType, consumer, contexts);\n+\n+\t\tIterator<?> iter = values.iterator();\n+\t\tint elementCounter = 1;\n+\t\twhile (iter.hasNext()) {\n+\t\t\tObject o = iter.next();\n+\t\t\tValue v = o instanceof Value ? (Value) o : Literals.createLiteralOrFail(vf, o);\n+\t\t\tIRI elementCounterPredicate = getAnnotatedMemberPredicate(vf, elementCounter);\n+\t\t\telementCounter++;\n+\t\t\tStatements.consume(vf, current, elementCounterPredicate, v, consumer, contexts);\n+\t\t\tStatements.consume(vf, (Resource) v, RDFS.MEMBER, current, consumer, contexts);\n+\t\t}\n+\t}\n+\n+\tprivate static IRI getAnnotatedMemberPredicate(ValueFactory vf, int elementCounter) {\n+\t\treturn vf.createIRI(RDF.NAMESPACE, \"_\" + elementCounter);\n+\t}\n+\n+\n+\n+\tpublic static void consumeValues(final Model m, Resource container, IRI containerType, Consumer<Value> consumer, Resource... contexts)\n+\t\t\tthrows ModelException {\n+\t\tObjects.requireNonNull(consumer, \"consumer may not be null\");\n+\t\tObjects.requireNonNull(m, \"input model may not be null\");\n+\n+\t\tValueFactory vf = SimpleValueFactory.getInstance();\n+\n+\t\tGetStatementOptional statementSupplier = (s, p, o, c) -> m.filter(s, p, o, c).stream().findAny();\n+\t\tFunction<String, Supplier<ModelException>> exceptionSupplier = Models::modelException;\n+\n+\t\t// TODO add proper documentation\n+\t\tPattern annotatedMembershipPredicatePattern = Pattern.compile(\"^\" + vf.createIRI(RDF.NAMESPACE, \"_\") + \"[1-9][0-9]*$\");\n+\n+\t\textract(containerType, statementSupplier, container, st -> {\n+\t\t\tif (RDFS.MEMBER.equals(st.getPredicate()) ||\n+\t\t\t\tannotatedMembershipPredicatePattern.matcher(st.getPredicate().toString()).matches()) {\n+\t\t\t\tconsumer.accept(st.getObject());\n+\t\t\t}\n+\t\t}, exceptionSupplier, contexts);\n+\t}\n+\n+\tpublic static <C extends Collection<Statement>> C getContainer(IRI containerType, Model sourceModel, Resource head, C sink,\n+\t\t\tResource... contexts) {\n+\t\tObjects.requireNonNull(sourceModel, \"input model may not be null\");\n+\t\textract(containerType, sourceModel, head, st -> sink.add(st), contexts);\n+\t\treturn sink;\n+\t}\n+\n+\tpublic static void extract(IRI containerType, Model sourceModel, Resource container, Consumer<Statement> consumer, Resource... contexts) {\n+\t\tObjects.requireNonNull(sourceModel, \"source model may not be null\");\n+\t\tGetStatementOptional statementSupplier = (s, p, o,\n+\t\t\t\tc) -> ((Model) sourceModel).filter(s, p, o, c).stream().findAny();\n+\t\textract(containerType, statementSupplier, container, consumer, Models::modelException, contexts);\n+\t}\n+\n+\tpublic static <E extends RDF4JException> void extract(IRI containerType, GetStatementOptional statementSupplier, Resource container,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t  Consumer<Statement> collectionConsumer, Function<String, Supplier<E>> exceptionSupplier,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t  Resource... contexts) throws E {\n+\t\tOpenRDFUtil.verifyContextNotNull(contexts);\n+\t\tObjects.requireNonNull(container, \"list head may not be null\");\n+\t\tObjects.requireNonNull(collectionConsumer, \"collection consumer may not be null\");\n+\n+\t\tValueFactory vf = SimpleValueFactory.getInstance();\n+\n+\t\tResource current = container;\n+\t\tfinal Set<Value> encountered = new HashSet<>();\n+\n+\t\tfor (int annotatedMembershipPropertyCounter = 1; true ; annotatedMembershipPropertyCounter++) {\n+\n+\n+\t\t\tIRI annotatedMembershipPredicate = getAnnotatedMemberPredicate(vf, annotatedMembershipPropertyCounter);\n+\t\t\tif (statementSupplier.get(container, annotatedMembershipPredicate, null, contexts).equals(Optional.empty())) {\n+\t\t\t\tbreak;\n+\t\t\t}", "originalCommit": "9369b054be8784eb86496fb3052c0c3e07852fc7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUyMzE2OA==", "url": "https://github.com/eclipse/rdf4j/pull/2254#discussion_r429523168", "bodyText": "Only for rdf:Alt, I have added this check to make sure that distinct elements are passed. Instead of throwing the exception, should I just skip adding the duplicate elements?", "author": "reeshabhranjan", "createdAt": "2020-05-23T07:31:32Z", "path": "core/model/src/main/java/org/eclipse/rdf4j/model/util/RDFContainers.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Eclipse RDF4J contributors.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Distribution License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/org/documents/edl-v10.php.\n+ *******************************************************************************/\n+\n+package org.eclipse.rdf4j.model.util;\n+\n+import org.eclipse.rdf4j.OpenRDFUtil;\n+import org.eclipse.rdf4j.RDF4JException;\n+import org.eclipse.rdf4j.model.*;\n+import org.eclipse.rdf4j.model.impl.SimpleValueFactory;\n+import org.eclipse.rdf4j.model.vocabulary.RDF;\n+import org.eclipse.rdf4j.model.vocabulary.RDFS;\n+\n+import java.util.*;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * TODO add documentation\n+ */\n+public class RDFContainers {\n+\n+\tpublic static <C extends Collection<Statement>> C asRDF(IRI containerType, Iterable<?> values, Resource container, C sink,\n+                                                            Resource... contexts) {\n+\n+\t\tObjects.requireNonNull(sink);\n+\t\tconsumeContainer(containerType, values, container, st -> sink.add(st), contexts);\n+\t\treturn sink;\n+\t}\n+\n+\tpublic static <C extends Collection<Statement>> C asRDF(IRI containerType, Iterable<?> values, Resource container, C sink,\n+                                                            ValueFactory vf, Resource... contexts) {\n+\n+\t\tObjects.requireNonNull(sink);\n+\t\tconsumeContainer(containerType, values, container, st -> sink.add(st), vf, contexts);\n+\t\treturn sink;\n+\t}\n+\n+\tpublic static <C extends Collection<Value>> C asValues(IRI containerType, final Model m, Resource container, C collection,\n+\t\t\tResource... contexts) throws ModelException {\n+\t\tObjects.requireNonNull(collection, \"collection may not be null\");\n+\n+\t\tconsumeValues(m, container, containerType, v -> collection.add(v), contexts);\n+\n+\t\treturn collection;\n+\t}\n+\n+\tpublic static void consumeContainer(IRI containerType, Iterable<?> values, Resource container, Consumer<Statement> consumer,\n+\t\t\tResource... contexts) {\n+\t\tconsumeContainer(containerType, values, container, consumer, SimpleValueFactory.getInstance(), contexts);\n+\t}\n+\tpublic static void consumeContainer(IRI containerType, Iterable<?> values, Resource container, Consumer<Statement> consumer,\n+\t\t\tValueFactory vf,\n+\t\t\tResource... contexts) {\n+\t\tObjects.requireNonNull(values, \"input collection may not be null\");\n+\t\tObjects.requireNonNull(consumer, \"consumer may not be null\");\n+\t\tObjects.requireNonNull(vf, \"injected value factory may not be null\");\n+\n+\t\tResource current = container != null ? container : vf.createBNode();\n+\t\tboolean validType = Objects.equals(containerType, RDF.ALT) ||\n+\t\t\t\tObjects.equals(containerType, RDF.BAG) ||\n+\t\t\t\tObjects.equals(containerType, RDF.SEQ);\n+\n+\t\tif (!validType) {\n+\t\t\tthrow new RuntimeException(\"containerType should be one of ALT, BAG or SEQ\");\n+\t\t}\n+\n+\t\tStatements.consume(vf, current, RDF.TYPE, containerType, consumer, contexts);\n+\n+\t\tIterator<?> iter = values.iterator();\n+\t\tint elementCounter = 1;\n+\t\twhile (iter.hasNext()) {\n+\t\t\tObject o = iter.next();\n+\t\t\tValue v = o instanceof Value ? (Value) o : Literals.createLiteralOrFail(vf, o);\n+\t\t\tIRI elementCounterPredicate = getAnnotatedMemberPredicate(vf, elementCounter);\n+\t\t\telementCounter++;\n+\t\t\tStatements.consume(vf, current, elementCounterPredicate, v, consumer, contexts);\n+\t\t\tStatements.consume(vf, (Resource) v, RDFS.MEMBER, current, consumer, contexts);\n+\t\t}\n+\t}\n+\n+\tprivate static IRI getAnnotatedMemberPredicate(ValueFactory vf, int elementCounter) {\n+\t\treturn vf.createIRI(RDF.NAMESPACE, \"_\" + elementCounter);\n+\t}\n+\n+\n+\n+\tpublic static void consumeValues(final Model m, Resource container, IRI containerType, Consumer<Value> consumer, Resource... contexts)\n+\t\t\tthrows ModelException {\n+\t\tObjects.requireNonNull(consumer, \"consumer may not be null\");\n+\t\tObjects.requireNonNull(m, \"input model may not be null\");\n+\n+\t\tValueFactory vf = SimpleValueFactory.getInstance();\n+\n+\t\tGetStatementOptional statementSupplier = (s, p, o, c) -> m.filter(s, p, o, c).stream().findAny();\n+\t\tFunction<String, Supplier<ModelException>> exceptionSupplier = Models::modelException;\n+\n+\t\t// TODO add proper documentation\n+\t\tPattern annotatedMembershipPredicatePattern = Pattern.compile(\"^\" + vf.createIRI(RDF.NAMESPACE, \"_\") + \"[1-9][0-9]*$\");\n+\n+\t\textract(containerType, statementSupplier, container, st -> {\n+\t\t\tif (RDFS.MEMBER.equals(st.getPredicate()) ||\n+\t\t\t\tannotatedMembershipPredicatePattern.matcher(st.getPredicate().toString()).matches()) {\n+\t\t\t\tconsumer.accept(st.getObject());\n+\t\t\t}\n+\t\t}, exceptionSupplier, contexts);\n+\t}\n+\n+\tpublic static <C extends Collection<Statement>> C getContainer(IRI containerType, Model sourceModel, Resource head, C sink,\n+\t\t\tResource... contexts) {\n+\t\tObjects.requireNonNull(sourceModel, \"input model may not be null\");\n+\t\textract(containerType, sourceModel, head, st -> sink.add(st), contexts);\n+\t\treturn sink;\n+\t}\n+\n+\tpublic static void extract(IRI containerType, Model sourceModel, Resource container, Consumer<Statement> consumer, Resource... contexts) {\n+\t\tObjects.requireNonNull(sourceModel, \"source model may not be null\");\n+\t\tGetStatementOptional statementSupplier = (s, p, o,\n+\t\t\t\tc) -> ((Model) sourceModel).filter(s, p, o, c).stream().findAny();\n+\t\textract(containerType, statementSupplier, container, consumer, Models::modelException, contexts);\n+\t}\n+\n+\tpublic static <E extends RDF4JException> void extract(IRI containerType, GetStatementOptional statementSupplier, Resource container,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t  Consumer<Statement> collectionConsumer, Function<String, Supplier<E>> exceptionSupplier,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t  Resource... contexts) throws E {\n+\t\tOpenRDFUtil.verifyContextNotNull(contexts);\n+\t\tObjects.requireNonNull(container, \"list head may not be null\");\n+\t\tObjects.requireNonNull(collectionConsumer, \"collection consumer may not be null\");\n+\n+\t\tValueFactory vf = SimpleValueFactory.getInstance();\n+\n+\t\tResource current = container;\n+\t\tfinal Set<Value> encountered = new HashSet<>();\n+\n+\t\tfor (int annotatedMembershipPropertyCounter = 1; true ; annotatedMembershipPropertyCounter++) {\n+\n+\n+\t\t\tIRI annotatedMembershipPredicate = getAnnotatedMemberPredicate(vf, annotatedMembershipPropertyCounter);\n+\t\t\tif (statementSupplier.get(container, annotatedMembershipPredicate, null, contexts).equals(Optional.empty())) {\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tStatement statement = statementSupplier.get(container, annotatedMembershipPredicate, null, contexts).get();\n+\n+\t\t\tif (containerType.equals(RDF.ALT)) {\n+\t\t\t\tif (encountered.contains(statement.getObject())) {\n+\t\t\t\t\tthrow exceptionSupplier.apply(\"rdf:alt cannot contain duplicate values\").get();\n+\t\t\t\t}\n+\t\t\t\tencountered.add(statement.getObject());\n+\t\t\t}", "originalCommit": "9369b054be8784eb86496fb3052c0c3e07852fc7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY5Njk2MA==", "url": "https://github.com/eclipse/rdf4j/pull/2254#discussion_r429696960", "bodyText": "I'd actually leave this check out, completely. It may seem logical to test this, but there is nothing in the RDF specifications that says anything about the members of an rdf:Alt container having to be distinct.", "author": "jeenbroekstra", "createdAt": "2020-05-25T01:14:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUyMzE2OA=="}], "type": "inlineReview"}, {"oid": "d1d35468e3aac921a248978c79aeb5fcb1096b3b", "url": "https://github.com/eclipse/rdf4j/commit/d1d35468e3aac921a248978c79aeb5fcb1096b3b", "message": "#405 Change 'as' to 'to', Change version 3.0 to 3.3.0, Run mvn impsort:sort\n\nSigned-off-by: Prince Sachdeva <prince17080@iiitd.ac.in>", "committedDate": "2020-05-24T09:54:07Z", "type": "commit"}, {"oid": "7f5c8a1345e2e8662ae41102e1bda5c8aee2ecd9", "url": "https://github.com/eclipse/rdf4j/commit/7f5c8a1345e2e8662ae41102e1bda5c8aee2ecd9", "message": "#405 Add tests for RDF Containers in RDFContainersTest.java, Remove distinct element check for rdf:alt in RDFContainers.java\n\nSigned-off-by: Gaurav Aggarwal <gaurav17288@iiitd.ac.in>", "committedDate": "2020-05-25T17:27:31Z", "type": "commit"}]}