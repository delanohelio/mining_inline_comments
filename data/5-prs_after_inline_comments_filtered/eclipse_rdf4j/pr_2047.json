{"pr_number": 2047, "pr_title": "GH-2044 store cardinality in query model node", "pr_createdAt": "2020-03-28T16:01:49Z", "pr_url": "https://github.com/eclipse/rdf4j/pull/2047", "timeline": [{"oid": "4d38e1389fa436a050c5ae1644c2e8e81ff991d1", "url": "https://github.com/eclipse/rdf4j/commit/4d38e1389fa436a050c5ae1644c2e8e81ff991d1", "message": "GH-2044 store cardinality in query model node so that we can print it for statement patterns and for joins and other nodes in the future\n\nSigned-off-by: Ha\u030avard Ottestad <hmottestad@gmail.com>", "committedDate": "2020-03-28T16:24:21Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTczOTg2Nw==", "url": "https://github.com/eclipse/rdf4j/pull/2047#discussion_r399739867", "bodyText": "Strictly speaking this is not backward-compatible. I'm on the fence whether we can get away with by saying that any implementor who does not use the abstract base class has only themselves to blame.", "author": "jeenbroekstra", "createdAt": "2020-03-29T03:39:35Z", "path": "core/queryalgebra/model/src/main/java/org/eclipse/rdf4j/query/algebra/QueryModelNode.java", "diffHunk": "@@ -73,16 +73,27 @@\n \t/**\n \t * Returns the signature of this query model node. Signatures normally include the node's name and any parameters,\n \t * but not parent or child nodes. This method is used by {@link #toString()}.\n-\t * \n+\t *\n \t * @return The node's signature, e.g. <tt>SLICE (offset=10, limit=10)</tt>.\n \t */\n \tpublic String getSignature();\n \n \t/**\n \t * Returns a (deep) clone of this query model node. This method recursively clones the entire node tree, starting\n \t * from this nodes.\n-\t * \n+\t *\n \t * @return A deep clone of this query model node.\n \t */\n \tpublic QueryModelNode clone();\n+\n+\t/**\n+\t * Returns the number of outputs that this QueryNode predicts will be outputted. For a StatementPattern this would\n+\t * be the estimated cardinality provided by the EvaluationStatistics. For a Join the would be the resulting number\n+\t * of joined tuples.\n+\t * \n+\t * @return cardinality\n+\t */\n+\tpublic double getCardinality();\n+\n+\tpublic void setCardinality(double cardinality);", "originalCommit": "4d38e1389fa436a050c5ae1644c2e8e81ff991d1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc0MDczNw==", "url": "https://github.com/eclipse/rdf4j/pull/2047#discussion_r399740737", "bodyText": "Should we call it 'getCostEstimate` as a more generic method? Cost estimation can be done using cardinality, but it's not always the sole factor (for example a SERVICE clause has a significantly higher cost due to network latency). I know that in the current implemtation of the EvaluationStatistics we sort of mix this up, but perhaps we should start being a bit more precise.", "author": "jeenbroekstra", "createdAt": "2020-03-29T03:52:28Z", "path": "core/queryalgebra/model/src/main/java/org/eclipse/rdf4j/query/algebra/QueryModelNode.java", "diffHunk": "@@ -73,16 +73,27 @@\n \t/**\n \t * Returns the signature of this query model node. Signatures normally include the node's name and any parameters,\n \t * but not parent or child nodes. This method is used by {@link #toString()}.\n-\t * \n+\t *\n \t * @return The node's signature, e.g. <tt>SLICE (offset=10, limit=10)</tt>.\n \t */\n \tpublic String getSignature();\n \n \t/**\n \t * Returns a (deep) clone of this query model node. This method recursively clones the entire node tree, starting\n \t * from this nodes.\n-\t * \n+\t *\n \t * @return A deep clone of this query model node.\n \t */\n \tpublic QueryModelNode clone();\n+\n+\t/**\n+\t * Returns the number of outputs that this QueryNode predicts will be outputted. For a StatementPattern this would\n+\t * be the estimated cardinality provided by the EvaluationStatistics. For a Join the would be the resulting number\n+\t * of joined tuples.\n+\t * \n+\t * @return cardinality\n+\t */\n+\tpublic double getCardinality();", "originalCommit": "4d38e1389fa436a050c5ae1644c2e8e81ff991d1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5f249531d1f64554fdc4d73125b40aac15833e7b", "url": "https://github.com/eclipse/rdf4j/commit/5f249531d1f64554fdc4d73125b40aac15833e7b", "message": "GH-2044 renamed cardinality to estimated rows and made implementation optional\n\nSigned-off-by: Ha\u030avard Ottestad <hmottestad@gmail.com>", "committedDate": "2020-03-29T15:37:16Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgxNDg0NA==", "url": "https://github.com/eclipse/rdf4j/pull/2047#discussion_r399814844", "bodyText": "@jeenbroekstra Propose we use the PostgreSQL naming of \"rows\" for this cardinality. I've prefixed it with \"estimated\" to make it more obvious what we are talking about.\nIn order for this to be backwards compatible I propose that setEstimatedRows be a no-op. We can remove both default implementations in 4.0.0, I'm just a bit unsure now how we can mark these methods to make it obvious for anyone who stumbles upon them. I have marked them Experimental though, since we might want to change the name or something else in the future. I'm open to other names though, \"getEstimatedTuples\" comes to mind.", "author": "hmottestad", "createdAt": "2020-03-29T15:41:40Z", "path": "core/queryalgebra/model/src/main/java/org/eclipse/rdf4j/query/algebra/QueryModelNode.java", "diffHunk": "@@ -73,16 +75,33 @@\n \t/**\n \t * Returns the signature of this query model node. Signatures normally include the node's name and any parameters,\n \t * but not parent or child nodes. This method is used by {@link #toString()}.\n-\t * \n+\t *\n \t * @return The node's signature, e.g. <tt>SLICE (offset=10, limit=10)</tt>.\n \t */\n \tpublic String getSignature();\n \n \t/**\n \t * Returns a (deep) clone of this query model node. This method recursively clones the entire node tree, starting\n \t * from this nodes.\n-\t * \n+\t *\n \t * @return A deep clone of this query model node.\n \t */\n \tpublic QueryModelNode clone();\n+\n+\t/**\n+\t * Returns the number of tuples that this QueryNode predicts will be outputted. For a StatementPattern this would be\n+\t * the estimated cardinality provided by the EvaluationStatistics. For a Join the would be the resulting number of\n+\t * joined tuples.\n+\t *\n+\t * @return rows\n+\t */\n+\t@Experimental\n+\tdefault double getEstimatedRows() {\n+\t\treturn -1;\n+\t}\n+\n+\t@Experimental\n+\tdefault void setEstimatedRows(double rows) {\n+\t\t// no-op for backwards compatibility\n+\t}", "originalCommit": "5f249531d1f64554fdc4d73125b40aac15833e7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg1MTIzNA==", "url": "https://github.com/eclipse/rdf4j/pull/2047#discussion_r399851234", "bodyText": "Couple of things:\n\n\nRows is SQL/table-speak. SPARQL doesn't have rows or tables (certainly construct queries don't). It has solutions, and solution sequences.\n\n\nYou're interpreting cardinality/cost to always be the number of solutions. That's just not true.\n\n\nI'd stick with the more abstract 'costEstimate' for this. This gives us freedom to use any  relevant measure (including number of solutions) as a cost estimate.", "author": "jeenbroekstra", "createdAt": "2020-03-29T20:43:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgxNDg0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg1MTUyMA==", "url": "https://github.com/eclipse/rdf4j/pull/2047#discussion_r399851520", "bodyText": "Happy with the noop solution though, that makes sense.", "author": "jeenbroekstra", "createdAt": "2020-03-29T20:45:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgxNDg0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg1NDY1Nw==", "url": "https://github.com/eclipse/rdf4j/pull/2047#discussion_r399854657", "bodyText": "Rows could also be interpreted as rows of solutions. I think \u201ctuples\u201d is better.\nCost is different from tuples. Cost is a calculated field based on a cost model. It could take into account the difference between a request to disk vs network or a sort+mergejoin vs hashjoin.\nTuples is an estimated ceiling. It doesn\u2019t account for what is likely to happen, for instance based on bound variables or a limit higher up in the algebra model. A join operation should account for bound variables. Consider the tuples estimate to be what this single operation would produce if only that node with its sub tree existed.", "author": "hmottestad", "createdAt": "2020-03-29T21:12:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgxNDg0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg1NDg0MA==", "url": "https://github.com/eclipse/rdf4j/pull/2047#discussion_r399854840", "bodyText": "If we want to introduce the abstract concept of cost, we should add a new field for that.", "author": "hmottestad", "createdAt": "2020-03-29T21:13:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgxNDg0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg1ODIxMg==", "url": "https://github.com/eclipse/rdf4j/pull/2047#discussion_r399858212", "bodyText": "(Scratch what I said earlier, I had where things happened mixed in my head a bit - I deleted a previous reply because it would just have added to the confusion)\n...if the number you intend to produce here is purely the outcome of EvaluationStatics.getCardinality then yes, using something like result size estimate or estimated number of solutions is fine. In fact, if we want to avoid further naming confusion, we even just stick with cardinality. getCardinalityEstimate?\nMy impression (and perhaps I was wrong there) was that what you wanted to produce was not just the outcome of that estimator, but the outcome of the internal cost calculation that the QueryJoinOptimizer does based (partially) on that number. I think what threw me that is that its internal method getTupleExprCardinality is wrongly named - it doesn't just produce a cardinality, it produces a cost estimate.", "author": "jeenbroekstra", "createdAt": "2020-03-29T21:45:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgxNDg0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQzMTEyOA==", "url": "https://github.com/eclipse/rdf4j/pull/2047#discussion_r401431128", "bodyText": "Cardinality has a fairly strict definition in mathematics of being the number of distinct elements in a set. We need a term to represent the number of elements in a bag because we want to be able to use the same term on other nodes in the plan. Size is already commonly used in java, so we could go with that. I've had a look at other SQL databases though and rows is very common.\nFor other graph databases:\n\nNeo4J: rows\nAmazone Neptune: patternEstimate\nStardog: cardinality\nOntotext: size or iterations\nOracle: 10 minutes of googling and still couldn't figure it out\nAllegrograph: cursor-estimate\nBlazegraph: unitsOut\nMarkLogic: maybe \"result estimate\"\nJena: couldn't find any examples\n\nAt this point we could pick \"potato\" and we wouldn't be any worse off. Was really hoping for a clear winner when I started down this path of googling.", "author": "hmottestad", "createdAt": "2020-04-01T08:10:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgxNDg0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQzNzEwMA==", "url": "https://github.com/eclipse/rdf4j/pull/2047#discussion_r401437100", "bodyText": "You say potato...\nId prefer sticking with cardinality because that's what is already used in the EvaluationStatistics, but I'm also fine with size (or more specifically sizeEstimate or perhaps resultSizeEstimate). Hard no on rows for me I'm afraid, really don't want to get trapped in false equivalences with relational model.\nEdit: the more I think about it, the more I like resultSizeEstimate. Bit of a mouthful but nice and descriptive.", "author": "jeenbroekstra", "createdAt": "2020-04-01T08:20:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgxNDg0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ2MTUxNg==", "url": "https://github.com/eclipse/rdf4j/pull/2047#discussion_r401461516", "bodyText": "resultSizeEstimate it is :)", "author": "hmottestad", "createdAt": "2020-04-01T09:01:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgxNDg0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg1OTIyMA==", "url": "https://github.com/eclipse/rdf4j/pull/2047#discussion_r399859220", "bodyText": "Right, so here's where I went wrong: I somehow had it in my head that you were using the outcome of QueryJoinOptimizer.getTupleExprCardinality to set this number. Apologies for the confusion.\nBtw that might be a good thing to fix as part of this PR: rename that method to get(TupleExpr)CostEstimate.", "author": "jeenbroekstra", "createdAt": "2020-03-29T21:54:07Z", "path": "core/queryalgebra/evaluation/src/main/java/org/eclipse/rdf4j/query/algebra/evaluation/impl/QueryJoinOptimizer.java", "diffHunk": "@@ -109,7 +109,9 @@ public void meet(Join node) {\n \t\t\t\t\tMap<TupleExpr, List<Var>> varsMap = new HashMap<>();\n \n \t\t\t\t\tfor (TupleExpr tupleExpr : joinArgs) {\n-\t\t\t\t\t\tcardinalityMap.put(tupleExpr, statistics.getCardinality(tupleExpr));\n+\t\t\t\t\t\tdouble cardinality = statistics.getCardinality(tupleExpr);\n+\t\t\t\t\t\ttupleExpr.setEstimatedRows(cardinality);", "originalCommit": "5f249531d1f64554fdc4d73125b40aac15833e7b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1671cf8bc55f45dc6777c7fd51237912908404c4", "url": "https://github.com/eclipse/rdf4j/commit/1671cf8bc55f45dc6777c7fd51237912908404c4", "message": "GH-2044 store cardinality in query model node so that we can print it for statement patterns and for joins and other nodes in the future\n\nSigned-off-by: Ha\u030avard Ottestad <hmottestad@gmail.com>", "committedDate": "2020-04-01T19:34:25Z", "type": "commit"}, {"oid": "f126d07b9fe5838c47374412256311221adb58c2", "url": "https://github.com/eclipse/rdf4j/commit/f126d07b9fe5838c47374412256311221adb58c2", "message": "GH-2044 renamed cardinality to estimated rows and made implementation optional\n\nSigned-off-by: Ha\u030avard Ottestad <hmottestad@gmail.com>", "committedDate": "2020-04-01T19:34:25Z", "type": "commit"}, {"oid": "78b95429d655ae46fb42137b96cc3432b32cab38", "url": "https://github.com/eclipse/rdf4j/commit/78b95429d655ae46fb42137b96cc3432b32cab38", "message": "GH-2044 renamed variable after code review and updated tests\n\nSigned-off-by: Ha\u030avard Ottestad <hmottestad@gmail.com>", "committedDate": "2020-04-01T19:34:25Z", "type": "commit"}, {"oid": "f0a44a282fb9175de172ed2a122b3f601f14d755", "url": "https://github.com/eclipse/rdf4j/commit/f0a44a282fb9175de172ed2a122b3f601f14d755", "message": "GH-2044 rename method which is about cost and not just cardinality\n\nSigned-off-by: Ha\u030avard Ottestad <hmottestad@gmail.com>", "committedDate": "2020-04-01T19:34:26Z", "type": "forcePushed"}, {"oid": "edbc67ac52705c2267cc9fce82a6b6fea22a49eb", "url": "https://github.com/eclipse/rdf4j/commit/edbc67ac52705c2267cc9fce82a6b6fea22a49eb", "message": "GH-2044 rename method which is about cost and not just cardinality\n\nSigned-off-by: Ha\u030avard Ottestad <hmottestad@gmail.com>", "committedDate": "2020-04-01T19:41:46Z", "type": "commit"}, {"oid": "edbc67ac52705c2267cc9fce82a6b6fea22a49eb", "url": "https://github.com/eclipse/rdf4j/commit/edbc67ac52705c2267cc9fce82a6b6fea22a49eb", "message": "GH-2044 rename method which is about cost and not just cardinality\n\nSigned-off-by: Ha\u030avard Ottestad <hmottestad@gmail.com>", "committedDate": "2020-04-01T19:41:46Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk2NTc3Ng==", "url": "https://github.com/eclipse/rdf4j/pull/2047#discussion_r401965776", "bodyText": "\ud83d\udc4d", "author": "jeenbroekstra", "createdAt": "2020-04-01T23:20:59Z", "path": "core/sail/federation/src/main/java/org/eclipse/rdf4j/sail/federation/optimizers/QueryMultiJoinOptimizer.java", "diffHunk": "@@ -177,26 +177,26 @@ public void meetJoin(TupleExpr node) {\n \t\t */\n \t\tprotected TupleExpr selectNextTupleExpr(List<TupleExpr> expressions, Map<TupleExpr, Double> cardinalityMap,\n \t\t\t\tMap<TupleExpr, List<Var>> varsMap, Map<Var, Integer> varFreqMap, Set<String> boundVars) {\n-\t\t\tdouble lowestCardinality = Double.MAX_VALUE;\n+\t\t\tdouble lowestCost = Double.MAX_VALUE;\n \t\t\tTupleExpr result = null;\n \n \t\t\tfor (TupleExpr tupleExpr : expressions) {\n \t\t\t\t// Calculate a score for this tuple expression\n-\t\t\t\tdouble cardinality = getTupleExprCardinality(tupleExpr, cardinalityMap, varsMap, varFreqMap, boundVars);\n+\t\t\t\tdouble cost = getTupleExprCost(tupleExpr, cardinalityMap, varsMap, varFreqMap, boundVars);\n \n-\t\t\t\tif (cardinality < lowestCardinality) {\n+\t\t\t\tif (cost < lowestCost) {\n \t\t\t\t\t// More specific path expression found\n-\t\t\t\t\tlowestCardinality = cardinality;\n+\t\t\t\t\tlowestCost = cost;\n \t\t\t\t\tresult = tupleExpr;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\treturn result;\n \t\t}\n \n-\t\tprotected double getTupleExprCardinality(TupleExpr tupleExpr, Map<TupleExpr, Double> cardinalityMap,\n+\t\tprotected double getTupleExprCost(TupleExpr tupleExpr, Map<TupleExpr, Double> cardinalityMap,", "originalCommit": "edbc67ac52705c2267cc9fce82a6b6fea22a49eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}