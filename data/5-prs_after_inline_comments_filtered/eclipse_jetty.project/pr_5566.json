{"pr_number": 5566, "pr_title": "Tries cleanup", "pr_createdAt": "2020-11-03T13:41:44Z", "pr_url": "https://github.com/eclipse/jetty.project/pull/5566", "timeline": [{"oid": "f9a7c7f4380b7104377776e16a45b0c499a530d7", "url": "https://github.com/eclipse/jetty.project/commit/f9a7c7f4380b7104377776e16a45b0c499a530d7", "message": "replace HttpHeaderValue's Trie cache with a TreeMap cache\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-11-03T13:58:04Z", "type": "forcePushed"}, {"oid": "6b0ec6b1299e55412776031b9ba2858af91445ce", "url": "https://github.com/eclipse/jetty.project/commit/6b0ec6b1299e55412776031b9ba2858af91445ce", "message": "introduction of Index and OpaqueIndex\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-11-09T13:15:54Z", "type": "forcePushed"}, {"oid": "08d3098efaca0ae940f9108a0e5cf16b17ac4378", "url": "https://github.com/eclipse/jetty.project/commit/08d3098efaca0ae940f9108a0e5cf16b17ac4378", "message": "introduction of Index and OpaqueIndex\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-11-09T13:16:46Z", "type": "forcePushed"}, {"oid": "2a065844c2c42c82d33e6d0b03226d4a07c30507", "url": "https://github.com/eclipse/jetty.project/commit/2a065844c2c42c82d33e6d0b03226d4a07c30507", "message": "introduction of immutable Index and OpaqueIndex\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-11-09T13:25:07Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTgyODIxMg==", "url": "https://github.com/eclipse/jetty.project/pull/5566#discussion_r519828212", "bodyText": "I like this approach of a builder that just collects all the entries and then builds the trie!\nI don't so much like the interface name OpaqueIndex.   Why not just have it as part of Index:\npublic interface Index\n{\n    ...;\n    class OpaqueBuilder\n    {\n        public static string Predicate<String> build();\n    }\n}", "author": "gregw", "createdAt": "2020-11-09T13:51:11Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/OpaqueIndex.java", "diffHunk": "@@ -0,0 +1,62 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.util;\n+\n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+\n+public interface OpaqueIndex\n+{\n+\n+    boolean contains(String key);\n+\n+    class Builder", "originalCommit": "2a065844c2c42c82d33e6d0b03226d4a07c30507", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQzODUxOQ==", "url": "https://github.com/eclipse/jetty.project/pull/5566#discussion_r521438519", "bodyText": "I'm not yet decided about the Builders API, I'm considering merging them all into a single one. But the OpaqueIndex is needed because it exposes these two methods:\n    boolean contains(String key);\n    boolean contains(String key, int offset, int length);\nand it could also expose some forms of boolean containsBest(...) in the future. But I'm not thrilled by this interface's name either.", "author": "lorban", "createdAt": "2020-11-11T15:29:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTgyODIxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTgzMTIxMA==", "url": "https://github.com/eclipse/jetty.project/pull/5566#discussion_r519831210", "bodyText": "contents.size() is not really the right capacity for ArrayTrie.    Capacity is hard to estimate, as it is more character by character and will be different for [\"Foo1\",\"Foo2\",\"Foo3\"] vs [ \"Foo0\",\"Bar0\",\"Bob0\"].\nSo I think we should just probably loop here starting at a low capacity, then recreating larger and larger as need be.\nPerhaps the builder can have a maxCapacity(int) method?", "author": "gregw", "createdAt": "2020-11-09T13:55:45Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/OpaqueIndex.java", "diffHunk": "@@ -0,0 +1,62 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.util;\n+\n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+\n+public interface OpaqueIndex\n+{\n+\n+    boolean contains(String key);\n+\n+    class Builder\n+    {\n+        private Set<String> contents = new LinkedHashSet<>();\n+        private boolean caseSensitive;\n+\n+        public Builder caseSensitive(boolean caseSensitive)\n+        {\n+            this.caseSensitive = caseSensitive;\n+            return this;\n+        }\n+\n+        public Builder with(String key)\n+        {\n+            contents.add(key);\n+            return this;\n+        }\n+\n+        public OpaqueIndex build()\n+        {\n+            Trie<Boolean> result;\n+            if (caseSensitive)\n+                result = new ArrayTernaryTrie<>(false, contents.size());\n+            else\n+                result = new ArrayTrie<>(contents.size());", "originalCommit": "2a065844c2c42c82d33e6d0b03226d4a07c30507", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQzOTc4Nw==", "url": "https://github.com/eclipse/jetty.project/pull/5566#discussion_r521439787", "bodyText": "Indeed, this was a too quick'n'dirty hack. But since we know at immutable index creation what its contents are going to be, we could calculate exactly what its exact capacity should be, which was my plan.", "author": "lorban", "createdAt": "2020-11-11T15:31:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTgzMTIxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTgzMzQyNA==", "url": "https://github.com/eclipse/jetty.project/pull/5566#discussion_r519833424", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public interface Index<V> extends OpaqueIndex\n          \n          \n            \n            public interface Index<V> extends Predicate<String>", "author": "gregw", "createdAt": "2020-11-09T13:58:53Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Index.java", "diffHunk": "@@ -0,0 +1,116 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.util;\n+\n+import java.nio.ByteBuffer;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+public interface Index<V> extends OpaqueIndex", "originalCommit": "04f1b682e33f9747503a97545a6cf443a8c77d19", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ0MDExMA==", "url": "https://github.com/eclipse/jetty.project/pull/5566#discussion_r521440110", "bodyText": "See above.", "author": "lorban", "createdAt": "2020-11-11T15:31:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTgzMzQyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTgzMzg2OQ==", "url": "https://github.com/eclipse/jetty.project/pull/5566#discussion_r519833869", "bodyText": "I really like the Builder pattern applied here!", "author": "gregw", "createdAt": "2020-11-09T13:59:30Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Index.java", "diffHunk": "@@ -0,0 +1,116 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.util;\n+\n+import java.nio.ByteBuffer;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+public interface Index<V> extends OpaqueIndex\n+{\n+    @Override\n+    default boolean contains(String key)\n+    {\n+        return get(key) != null;\n+    }\n+\n+    /**\n+     * Get an exact match from a String key\n+     *\n+     * @param s The key\n+     * @return the value for the string key\n+     */\n+    V get(String s);\n+\n+    /**\n+     * Get an exact match from a String key\n+     *\n+     * @param s The key\n+     * @param offset The offset within the string of the key\n+     * @param len the length of the key\n+     * @return the value for the string / offset / length\n+     */\n+    V get(String s, int offset, int len);\n+\n+    /**\n+     * Get the best match from key in a byte buffer.\n+     * The key is assumed to by ISO_8859_1 characters.\n+     *\n+     * @param b The buffer\n+     * @param offset The offset within the buffer of the key\n+     * @param len the length of the key\n+     * @return The value or null if not found\n+     */\n+    V getBest(ByteBuffer b, int offset, int len);\n+\n+    class Builder<V>", "originalCommit": "04f1b682e33f9747503a97545a6cf443a8c77d19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTgzNDU3MA==", "url": "https://github.com/eclipse/jetty.project/pull/5566#discussion_r519834570", "bodyText": "wow that's a name!!!  why not just overload withAll?", "author": "gregw", "createdAt": "2020-11-09T14:00:28Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Index.java", "diffHunk": "@@ -0,0 +1,116 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.util;\n+\n+import java.nio.ByteBuffer;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+public interface Index<V> extends OpaqueIndex\n+{\n+    @Override\n+    default boolean contains(String key)\n+    {\n+        return get(key) != null;\n+    }\n+\n+    /**\n+     * Get an exact match from a String key\n+     *\n+     * @param s The key\n+     * @return the value for the string key\n+     */\n+    V get(String s);\n+\n+    /**\n+     * Get an exact match from a String key\n+     *\n+     * @param s The key\n+     * @param offset The offset within the string of the key\n+     * @param len the length of the key\n+     * @return the value for the string / offset / length\n+     */\n+    V get(String s, int offset, int len);\n+\n+    /**\n+     * Get the best match from key in a byte buffer.\n+     * The key is assumed to by ISO_8859_1 characters.\n+     *\n+     * @param b The buffer\n+     * @param offset The offset within the buffer of the key\n+     * @param len the length of the key\n+     * @return The value or null if not found\n+     */\n+    V getBest(ByteBuffer b, int offset, int len);\n+\n+    class Builder<V>\n+    {\n+        private Map<String, V> contents = new LinkedHashMap<>();\n+        private boolean caseSensitive;\n+\n+        public Builder<V> caseSensitive(boolean caseSensitive)\n+        {\n+            this.caseSensitive = caseSensitive;\n+            return this;\n+        }\n+\n+        public <T> Builder<V> withAllDerivate(T[] values, Function<T, Map<String, V>> function)", "originalCommit": "04f1b682e33f9747503a97545a6cf443a8c77d19", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ0MTE0Ng==", "url": "https://github.com/eclipse/jetty.project/pull/5566#discussion_r521441146", "bodyText": "This method is certainly going to be replaced with some form of withAll(), I don't like it either.", "author": "lorban", "createdAt": "2020-11-11T15:33:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTgzNDU3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTgzNDkxMg==", "url": "https://github.com/eclipse/jetty.project/pull/5566#discussion_r519834912", "bodyText": "contents.size() is not really the right capacity for ArrayTrie.    Capacity is hard to estimate, as it is more character by character and will be different for [\"Foo1\",\"Foo2\",\"Foo3\"] vs [ \"Foo0\",\"Bar0\",\"Bob0\"].\nSo I think we should just probably loop here starting at a low capacity, then recreating larger and larger as need be.\nPerhaps the builder can have a maxCapacity(int) method?", "author": "gregw", "createdAt": "2020-11-09T14:00:59Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Index.java", "diffHunk": "@@ -0,0 +1,116 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.util;\n+\n+import java.nio.ByteBuffer;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+public interface Index<V> extends OpaqueIndex\n+{\n+    @Override\n+    default boolean contains(String key)\n+    {\n+        return get(key) != null;\n+    }\n+\n+    /**\n+     * Get an exact match from a String key\n+     *\n+     * @param s The key\n+     * @return the value for the string key\n+     */\n+    V get(String s);\n+\n+    /**\n+     * Get an exact match from a String key\n+     *\n+     * @param s The key\n+     * @param offset The offset within the string of the key\n+     * @param len the length of the key\n+     * @return the value for the string / offset / length\n+     */\n+    V get(String s, int offset, int len);\n+\n+    /**\n+     * Get the best match from key in a byte buffer.\n+     * The key is assumed to by ISO_8859_1 characters.\n+     *\n+     * @param b The buffer\n+     * @param offset The offset within the buffer of the key\n+     * @param len the length of the key\n+     * @return The value or null if not found\n+     */\n+    V getBest(ByteBuffer b, int offset, int len);\n+\n+    class Builder<V>\n+    {\n+        private Map<String, V> contents = new LinkedHashMap<>();\n+        private boolean caseSensitive;\n+\n+        public Builder<V> caseSensitive(boolean caseSensitive)\n+        {\n+            this.caseSensitive = caseSensitive;\n+            return this;\n+        }\n+\n+        public <T> Builder<V> withAllDerivate(T[] values, Function<T, Map<String, V>> function)\n+        {\n+            for (T value : values)\n+            {\n+                Map<String, V> pairs = function.apply(value);\n+                contents.putAll(pairs);\n+            }\n+            return this;\n+        }\n+\n+        public Builder<V> withAll(V[] values, Function<V, String> function)\n+        {\n+            for (V value : values)\n+            {\n+                String key = function.apply(value);\n+                contents.put(key, value);\n+            }\n+            return this;\n+        }\n+\n+        public Builder<V> with(String key, V value)\n+        {\n+            contents.put(key, value);\n+            return this;\n+        }\n+\n+        public Index<V> build()\n+        {\n+            Trie<V> result;\n+            if (caseSensitive)\n+                result = new ArrayTernaryTrie<>(false, contents.size());\n+            else\n+                result = new ArrayTrie<>(contents.size());", "originalCommit": "04f1b682e33f9747503a97545a6cf443a8c77d19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTgzODA5Ng==", "url": "https://github.com/eclipse/jetty.project/pull/5566#discussion_r519838096", "bodyText": "So do we still really need Trie interface?  just for the unused method variations?\nI like Index as a better name, which can then be directly implemented by the Trie implementations.   We should not ever need an polymorphic Trie, only polymorphic Indexes", "author": "gregw", "createdAt": "2020-11-09T14:05:47Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Trie.java", "diffHunk": "@@ -26,7 +26,7 @@\n  *\n  * @param <V> the Trie entry type\n  */\n-public interface Trie<V>\n+public interface Trie<V> extends Index<V>", "originalCommit": "04f1b682e33f9747503a97545a6cf443a8c77d19", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ0MTU5OQ==", "url": "https://github.com/eclipse/jetty.project/pull/5566#discussion_r521441599", "bodyText": "The Trie interface can and should go away. You've foreseen my intent about polymorphic Indexes.", "author": "lorban", "createdAt": "2020-11-11T15:33:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTgzODA5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTk3NDc3Nw==", "url": "https://github.com/eclipse/jetty.project/pull/5566#discussion_r519974777", "bodyText": "I think I've found a \"simple\" algorithm to work out the required capacity from a set of keys:\n    public static int requiredCapacity(Set<String> keys)\n    {\n        List<String> list = new ArrayList<>(keys);\n        Collections.sort(list);\n\n        return requiredCapacity(list, 0, list.size(), 0);\n    }\n\n    private static int requiredCapacity(List<String> keys, int offset, int length, int index)\n    {\n        if (length == 0)\n            return 0;\n\n        int required = 0;\n\n        Character c = null;\n        for (int i = 0; i < length; i++)\n        {\n            String k = keys.get(offset + i);\n\n            if (c == null)\n            {\n                if (k.length() >= index + 1)\n                {\n                    required++;\n                    c = k.charAt(index);;\n                }\n                else\n                {\n                    offset++;\n                    length--;\n                    i--;\n                }\n                continue;\n            }\n\n            if (k.length() >= index + 1)\n            {\n                char n = k.charAt(index);\n                if (c != n)\n                {\n                    required += requiredCapacity(keys, offset, i, index + 1) + 1;\n                    offset = i;\n                    length -= i;\n                    c = n;\n                    i = 1;\n                }\n                continue;\n            }\n\n            c = null;\n            offset = i;\n            length -= i;\n            i = 0;\n        }\n\n        required += requiredCapacity(keys, offset, length, index + 1);\n        return required;\n    }\nWhich passes the following tests:\n    @Test\n    public void testArrayTrieRequestCapacity()\n    {\n        assertThat(ArrayTrie.requiredCapacity(Set.of(\"ABC\")), is(3));\n        assertThat(ArrayTrie.requiredCapacity(Set.of(\"ABC\", \"XYZ\")), is(6));\n        assertThat(ArrayTrie.requiredCapacity(Set.of(\"A00\", \"A11\")), is(5));\n        assertThat(ArrayTrie.requiredCapacity(Set.of(\"A00\", \"A01\", \"A10\", \"A11\")), is(7));\n        assertThat(ArrayTrie.requiredCapacity(Set.of(\"ABC\", \"ABCDEF\")), is(6));\n        assertThat(ArrayTrie.requiredCapacity(Set.of(\"A\", \"AB\")), is(2));\n        assertThat(ArrayTrie.requiredCapacity(Set.of(\"AB\", \"A\")), is(2));\n        assertThat(ArrayTrie.requiredCapacity(Set.of(\"ABC\", \"ABCDEF\")), is(6));\n        assertThat(ArrayTrie.requiredCapacity(Set.of(\"ABCDEF\", \"ABC\")), is(6));\n        assertThat(ArrayTrie.requiredCapacity(Set.of(\"ABC\", \"ABCDEF\", \"ABX\")), is(7));\n        assertThat(ArrayTrie.requiredCapacity(Set.of(\"ABCDEF\", \"ABC\", \"ABX\")), is(7));\n    }", "author": "gregw", "createdAt": "2020-11-09T17:06:09Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Index.java", "diffHunk": "@@ -0,0 +1,148 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.util;\n+\n+import java.nio.ByteBuffer;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+public interface Index<V> extends OpaqueIndex\n+{\n+    @Override\n+    default boolean contains(String key)\n+    {\n+        return get(key) != null;\n+    }\n+\n+    @Override\n+    default boolean contains(String key, int offset, int length)\n+    {\n+        return get(key, offset, length) != null;\n+    }\n+\n+    /**\n+     * Get an exact match from a String key\n+     *\n+     * @param s The key\n+     * @return the value for the string key\n+     */\n+    V get(String s);\n+\n+    /**\n+     * Get an exact match from a String key\n+     *\n+     * @param s The key\n+     * @param offset The offset within the string of the key\n+     * @param len the length of the key\n+     * @return the value for the string / offset / length\n+     */\n+    V get(String s, int offset, int len);\n+\n+    /**\n+     * Get the best match from key in a String.\n+     *\n+     * @param s The string\n+     * @param offset The offset within the string of the key\n+     * @param len the length of the key\n+     * @return The value or null if not found\n+     */\n+    V getBest(String s, int offset, int len);\n+\n+    /**\n+     * Get the best match from key in a byte buffer.\n+     * The key is assumed to by ISO_8859_1 characters.\n+     *\n+     * @param b The buffer\n+     * @param offset The offset within the buffer of the key\n+     * @param len the length of the key\n+     * @return The value or null if not found\n+     */\n+    V getBest(ByteBuffer b, int offset, int len);\n+\n+    class Builder<V>\n+    {\n+        private Map<String, V> contents = new LinkedHashMap<>();\n+        private boolean caseSensitive;\n+\n+        public Builder<V> caseSensitive(boolean caseSensitive)\n+        {\n+            this.caseSensitive = caseSensitive;\n+            return this;\n+        }\n+\n+        public <T> Builder<V> withAllDerivate(T[] values, Function<T, Map<String, V>> function)\n+        {\n+            for (T value : values)\n+            {\n+                Map<String, V> pairs = function.apply(value);\n+                contents.putAll(pairs);\n+            }\n+            return this;\n+        }\n+\n+        public Builder<V> withAll(V[] values, Function<V, String> function)\n+        {\n+            for (V value : values)\n+            {\n+                String key = function.apply(value);\n+                contents.put(key, value);\n+            }\n+            return this;\n+        }\n+\n+        public Builder<V> with(String key, V value)\n+        {\n+            contents.put(key, value);\n+            return this;\n+        }\n+\n+        public Index<V> build()\n+        {\n+            int capacity = 16;\n+            Trie<V> result = createTrie(capacity);\n+            for (Map.Entry<String, V> entry : contents.entrySet())\n+            {\n+                while (!result.put(entry.getKey(), entry.getValue()))", "originalCommit": "172eb0894aabadf6483605fc93e8cb747539866d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ0MzM4OQ==", "url": "https://github.com/eclipse/jetty.project/pull/5566#discussion_r521443389", "bodyText": "Thanks! I'll have a look at it as it'll be needed to build immutable Indexes.", "author": "lorban", "createdAt": "2020-11-11T15:36:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTk3NDc3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ5OTE1OQ==", "url": "https://github.com/eclipse/jetty.project/pull/5566#discussion_r521499159", "bodyText": "Rather than a whole new class, can't we just have a mutable() method on the standard builder?", "author": "gregw", "createdAt": "2020-11-11T16:55:50Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/MutableOpaqueIndex.java", "diffHunk": "@@ -0,0 +1,57 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.util;\n+\n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+\n+public interface MutableOpaqueIndex extends OpaqueIndex", "originalCommit": "e77a26868266dc8cddcf66c8ebd16696f2b8048c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU2ODEzMQ==", "url": "https://github.com/eclipse/jetty.project/pull/5566#discussion_r529568131", "bodyText": "Yes, this is the way to go.", "author": "lorban", "createdAt": "2020-11-24T14:03:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ5OTE1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTUwMDU5MA==", "url": "https://github.com/eclipse/jetty.project/pull/5566#discussion_r521500590", "bodyText": "So the name Index is really clear what it is about.  But the name OpaqueIndex doesn't mean anything.\nI'd prefer either StringSet or to just use an Index<Void> as it will probably internally use the same impl anyway,", "author": "gregw", "createdAt": "2020-11-11T16:58:08Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/OpaqueIndex.java", "diffHunk": "@@ -0,0 +1,86 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.util;\n+\n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+\n+public interface OpaqueIndex", "originalCommit": "e77a26868266dc8cddcf66c8ebd16696f2b8048c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTQwMjQyMA==", "url": "https://github.com/eclipse/jetty.project/pull/5566#discussion_r529402420", "bodyText": "I agree. OpaqueIndex was a step too far, I've removed that interface and replaced its usages with Index<Boolean>.", "author": "lorban", "createdAt": "2020-11-24T10:14:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTUwMDU5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTUwMjM2Nw==", "url": "https://github.com/eclipse/jetty.project/pull/5566#discussion_r521502367", "bodyText": "Again, rather than a whole new class, I'd much rather have an immutable() or mutable() (depending on default) method on the Index.Builder.  Just like the JVM collections, they all have the mutable APIs.", "author": "gregw", "createdAt": "2020-11-11T17:00:29Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/MutableIndex.java", "diffHunk": "@@ -0,0 +1,102 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.util;\n+\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+public interface MutableIndex<V> extends Index<V>", "originalCommit": "e77a26868266dc8cddcf66c8ebd16696f2b8048c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTQwNjkyOA==", "url": "https://github.com/eclipse/jetty.project/pull/5566#discussion_r529406928", "bodyText": "Well, I'm very strongly in favor of separating the mutable vs the immutable API of an index as that makes the intent crystal clear when reading the code.\nBut having a single entry point to build both is the right thing to do IMO, so I've made MutableIndex.Builder not instanciatable and introduced a Index.Builder.mutable() method to create a mutable index.", "author": "lorban", "createdAt": "2020-11-24T10:18:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTUwMjM2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU0MDcyNw==", "url": "https://github.com/eclipse/jetty.project/pull/5566#discussion_r529540727", "bodyText": "Can you at least move this to be a subinterface of Index, so it matches the pattern we have in HttpFields and HttpUri", "author": "gregw", "createdAt": "2020-11-24T13:23:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTUwMjM2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU0NjYwNQ==", "url": "https://github.com/eclipse/jetty.project/pull/5566#discussion_r529546605", "bodyText": "You mean a nested interface I suppose, because it already is a subinterface of Index?", "author": "lorban", "createdAt": "2020-11-24T13:32:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTUwMjM2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU1MjkxNA==", "url": "https://github.com/eclipse/jetty.project/pull/5566#discussion_r529552914", "bodyText": "yep", "author": "gregw", "createdAt": "2020-11-24T13:41:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTUwMjM2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU2ODM0MA==", "url": "https://github.com/eclipse/jetty.project/pull/5566#discussion_r529568340", "bodyText": "Done.", "author": "lorban", "createdAt": "2020-11-24T14:03:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTUwMjM2Nw=="}], "type": "inlineReview"}, {"oid": "09f9887bc4aae5ced1a81b39b8d3a54db7b40c1c", "url": "https://github.com/eclipse/jetty.project/commit/09f9887bc4aae5ced1a81b39b8d3a54db7b40c1c", "message": "let the tries figure out their capacity when given a map in the ctor\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-11-23T11:31:28Z", "type": "forcePushed"}, {"oid": "882282c38fe6996e67e18ae7e40cf5695d72f22f", "url": "https://github.com/eclipse/jetty.project/commit/882282c38fe6996e67e18ae7e40cf5695d72f22f", "message": "tries refactoring\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-11-23T13:56:54Z", "type": "forcePushed"}, {"oid": "198225c283601b3728c1c878f149a4afa0e65d36", "url": "https://github.com/eclipse/jetty.project/commit/198225c283601b3728c1c878f149a4afa0e65d36", "message": "tries refactoring\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-11-23T15:01:39Z", "type": "forcePushed"}, {"oid": "0e4725b973f9631221a7fa59373498d4dbdb6633", "url": "https://github.com/eclipse/jetty.project/commit/0e4725b973f9631221a7fa59373498d4dbdb6633", "message": "Milestone 1: replace Trie interface and impls usage with new *Index interfaces and Builders\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-11-24T09:38:50Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU0MzI0OA==", "url": "https://github.com/eclipse/jetty.project/pull/5566#discussion_r529543248", "bodyText": "We are going to need good javadoc to explain what units capacity is in!\nperhaps also have a fixedCapacity(double) that multiplies the capacity of what is required for anything added to the builder.", "author": "gregw", "createdAt": "2020-11-24T13:26:59Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/MutableIndex.java", "diffHunk": "@@ -0,0 +1,79 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.util;\n+\n+import java.util.Map;\n+\n+public interface MutableIndex<V> extends Index<V>\n+{\n+    boolean isFull();\n+\n+    /**\n+     * Put an entry into the index.\n+     *\n+     * @param s The key for the entry\n+     * @param v The value of the entry\n+     * @return True if the index had capacity to add the field.\n+     */\n+    boolean put(String s, V v);\n+\n+    /**\n+     * Put a value as both a key and a value.\n+     *\n+     * @param v The value and key\n+     * @return True if the Trie had capacity to add the field.\n+     */\n+    boolean put(V v);\n+\n+    void clear();\n+\n+    V remove(String s);\n+\n+    class Builder<V> extends Index.Builder<V>\n+    {\n+        private int fixedCapacity;\n+\n+        Builder(Map<String, V> contents, boolean caseSensitive)\n+        {\n+            super(contents, caseSensitive);\n+        }\n+\n+        public MutableIndex.Builder<V> fixedCapacity(int capacity)", "originalCommit": "b5a271c2e81396f3efbf752de90ce2e0110ee94d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU0NDUwNg==", "url": "https://github.com/eclipse/jetty.project/pull/5566#discussion_r529544506", "bodyText": "Also for a mutable Index builder, this would be better named maxCapacity... which might be implemented as a fixedCapacity at max, or might not.", "author": "gregw", "createdAt": "2020-11-24T13:29:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU0MzI0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU3MzIzOQ==", "url": "https://github.com/eclipse/jetty.project/pull/5566#discussion_r529573239", "bodyText": "I like the maxCapacity name better, so I'll rename it.I kinda like the idea of using maxCapacity as a growth factor, except that the HttpParser's _fieldCache has a capacity that is user-configurable, and I don't think the intent is to use a growing index.", "author": "lorban", "createdAt": "2020-11-24T14:10:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU0MzI0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU0ODU1MA==", "url": "https://github.com/eclipse/jetty.project/pull/5566#discussion_r529548550", "bodyText": "This is not the correct algorithm as common roots of keys share nodes.  See the one I posted earlier", "author": "gregw", "createdAt": "2020-11-24T13:35:09Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/ArrayTrie.java", "diffHunk": "@@ -126,14 +122,40 @@ public ArrayTrie()\n      * store \"bar\" and \"bat\".\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public ArrayTrie(int capacity)\n+    ArrayTrie(int capacity)\n     {\n         super(true);\n+        capacity++;\n         _value = (V[])new Object[capacity];\n-        _rowIndex = new char[capacity * 32];\n+        _rowIndex = new char[capacity * ROW_SIZE];\n         _key = new String[capacity];\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n+    ArrayTrie(Map<String, V> initialValues)\n+    {\n+        super(true);\n+        int capacity = requiredCapacity(initialValues.keySet()) + 1;\n+        _value = (V[])new Object[capacity];\n+        _rowIndex = new char[capacity * ROW_SIZE];\n+        _key = new String[capacity];\n+        for (Map.Entry<String, V> entry : initialValues.entrySet())\n+        {\n+            if (!put(entry.getKey(), entry.getValue()))\n+                throw new AssertionError(\"Invalid capacity calculated (\" + capacity + \") at '\" + entry + \"' for \" + initialValues);\n+        }\n+    }\n+\n+    static int requiredCapacity(Set<String> keys)\n+    {\n+        int total = 0;\n+        for (String key : keys)\n+        {\n+            total += key.length() + 1;", "originalCommit": "b5a271c2e81396f3efbf752de90ce2e0110ee94d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU2MTEyMQ==", "url": "https://github.com/eclipse/jetty.project/pull/5566#discussion_r529561121", "bodyText": "I know, but the one you posted earlier is partially broken, so I reverted to this simple impl to get the API right and the tests passing.", "author": "lorban", "createdAt": "2020-11-24T13:53:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU0ODU1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU2NDQyNg==", "url": "https://github.com/eclipse/jetty.project/pull/5566#discussion_r529564426", "bodyText": "oh do tell what is broken! that sounds like fun!!!!\nBut at least comment for now that this is an over approximation.", "author": "gregw", "createdAt": "2020-11-24T13:58:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU0ODU1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU3MDI0Ng==", "url": "https://github.com/eclipse/jetty.project/pull/5566#discussion_r529570246", "bodyText": "IIRC it did not calculate the correct size for HTTP2Cipher.__blackCiphers, it underestimated it.", "author": "lorban", "createdAt": "2020-11-24T14:06:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU0ODU1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTc0MTA5Ng==", "url": "https://github.com/eclipse/jetty.project/pull/5566#discussion_r529741096", "bodyText": "Ah  I think I have it this time... and it is simpler:\n    public static int requiredCapacity(Set<String> keys)\n    {\n        List<String> list = new ArrayList<>(keys);\n        Collections.sort(list);\n        return requiredCapacity(list, 0, list.size(), 0);\n    }\n\n    private static int requiredCapacity(List<String> keys, int offset, int length, int index)\n    {\n        if (length == 0)\n            return 0;\n\n        int required = 0;\n\n        Character c = null;\n        for (int i = 0; i < length; i++)\n        {\n            String k = keys.get(offset + i);\n            if (k.length() <= index)\n                continue;\n            char n = k.charAt(index);\n            if (c == null)\n            {\n                required++;\n                c = n;\n                offset += i;\n                length -= i;\n            }\n            else if (c != n)\n            {\n                required +=  requiredCapacity(keys, offset, i, index + 1) + 1;\n                offset += i;\n                length -= i;\n                c = n;\n                i = 1;\n            }\n        }\n\n        if (c != null)\n            required += requiredCapacity(keys, offset, length, index + 1);\n        return required;\n    }\n\n    @Test\n    public void testRequiredCapacity()\n    {\n        assertThat(requiredCapacity(Set.of(\"A\")), is(1));\n        assertThat(requiredCapacity(Set.of(\"AB\")), is(2));\n        assertThat(requiredCapacity(Set.of(\"ABC\")), is(3));\n        assertThat(requiredCapacity(Set.of(\"ABC\", \"XYZ\")), is(6));\n        assertThat(requiredCapacity(Set.of(\"A00\", \"A11\")), is(5));\n        assertThat(requiredCapacity(Set.of(\"A00\", \"A01\", \"A10\", \"A11\")), is(7));\n        assertThat(requiredCapacity(Set.of(\"A\", \"AB\")), is(2));\n        assertThat(requiredCapacity(Set.of(\"A\", \"ABC\")), is(3));\n        assertThat(requiredCapacity(Set.of(\"A\", \"ABCD\")), is(4));\n        assertThat(requiredCapacity(Set.of(\"AB\", \"ABC\")), is(3));\n        assertThat(requiredCapacity(Set.of(\"ABC\", \"ABCD\")), is(4));\n        assertThat(requiredCapacity(Set.of(\"ABC\", \"ABCDEF\")), is(6));\n        assertThat(requiredCapacity(Set.of(\"AB\", \"A\")), is(2));\n        assertThat(requiredCapacity(Set.of(\"ABC\", \"ABCDEF\")), is(6));\n        assertThat(requiredCapacity(Set.of(\"ABCDEF\", \"ABC\")), is(6));\n        assertThat(requiredCapacity(Set.of(\"ABC\", \"ABCDEF\", \"ABX\")), is(7));\n        assertThat(requiredCapacity(Set.of(\"ABCDEF\", \"ABC\", \"ABX\")), is(7));\n        assertThat(requiredCapacity(Set.of(\"ADEF\", \"AQPR4\", \"AQZ\")), is(9));\n        assertThat(requiredCapacity(Set.of(\"111\", \"ADEF\", \"AQPR4\", \"AQZ\", \"999\")), is(15));\n    }", "author": "gregw", "createdAt": "2020-11-24T17:11:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU0ODU1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE3MzU4Mw==", "url": "https://github.com/eclipse/jetty.project/pull/5566#discussion_r530173583", "bodyText": "This one still fails:\n  assertThat(requiredCapacity(Set.of(\"utf-8\", \"utf8\", \"utf-16\", \"utf16\", \"iso-8859-1\", \"iso_8859_1\")), is(27));", "author": "lorban", "createdAt": "2020-11-25T08:05:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU0ODU1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDIzNDY1Mw==", "url": "https://github.com/eclipse/jetty.project/pull/5566#discussion_r530234653", "bodyText": "So much fun!!!!:\n    \n    public static int requiredCapacity(Set<String> keys)\n    {\n        List<String> list = new ArrayList<>(keys);\n        Collections.sort(list);\n        return requiredCapacity(list, 0, list.size(), 0);\n    }\n\n    private static int requiredCapacity(List<String> keys, int offset, int length, int index)\n    {\n        if (length == 0)\n            return 0;\n\n        int required = 0;\n\n        Character c = null;\n        for (int i = 0; i < length; i++)\n        {\n            String k = keys.get(offset + i);\n            if (k.length() <= index)\n                continue;\n            char n = k.charAt(index);\n            if (c == null)\n                required++;\n            else if (c != n)\n                required +=  requiredCapacity(keys, offset, i, index + 1) + 1;\n            else\n                continue;\n            c = n;\n            offset += i;\n            length -= i;\n            i = 0;\n        }\n\n        if (c != null)\n        {\n            required += requiredCapacity(keys, offset, length, index + 1);\n        }\n        return required;\n    }\n\n    @Test\n    public void testRequiredCapacity()\n    {\n        assertThat(requiredCapacity(Set.of(\"ABC\")), is(3));\n        assertThat(requiredCapacity(Set.of(\"ABC\", \"XYZ\")), is(6));\n        assertThat(requiredCapacity(Set.of(\"A00\", \"A11\")), is(5));\n        assertThat(requiredCapacity(Set.of(\"A00\", \"A01\", \"A10\", \"A11\")), is(7));\n        assertThat(requiredCapacity(Set.of(\"A\", \"AB\")), is(2));\n        assertThat(requiredCapacity(Set.of(\"A\", \"ABC\")), is(3));\n        assertThat(requiredCapacity(Set.of(\"A\", \"ABCD\")), is(4));\n        assertThat(requiredCapacity(Set.of(\"AB\", \"ABC\")), is(3));\n        assertThat(requiredCapacity(Set.of(\"ABC\", \"ABCD\")), is(4));\n        assertThat(requiredCapacity(Set.of(\"ABC\", \"ABCDEF\")), is(6));\n        assertThat(requiredCapacity(Set.of(\"AB\", \"A\")), is(2));\n        assertThat(requiredCapacity(Set.of(\"ABC\", \"ABCDEF\")), is(6));\n        assertThat(requiredCapacity(Set.of(\"ABCDEF\", \"ABC\")), is(6));\n        assertThat(requiredCapacity(Set.of(\"ABC\", \"ABCDEF\", \"ABX\")), is(7));\n        assertThat(requiredCapacity(Set.of(\"ABCDEF\", \"ABC\", \"ABX\")), is(7));\n        assertThat(requiredCapacity(Set.of(\"ADEF\", \"AQPR4\", \"AQZ\")), is(9));\n        assertThat(requiredCapacity(Set.of(\"111\", \"ADEF\", \"AQPR4\", \"AQZ\", \"999\")), is(15));\n        assertThat(requiredCapacity(Set.of(\"utf-16\", \"utf-8\")), is(7));\n        assertThat(requiredCapacity(Set.of(\"utf-16\", \"utf-8\", \"utf16\", \"utf8\")), is(10));\n        assertThat(requiredCapacity(Set.of(\"utf-8\", \"utf8\", \"utf-16\", \"utf16\", \"iso-8859-1\", \"iso_8859_1\")), is(27));\n    }", "author": "gregw", "createdAt": "2020-11-25T09:42:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU0ODU1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDI2MTE4Mw==", "url": "https://github.com/eclipse/jetty.project/pull/5566#discussion_r530261183", "bodyText": "final version:\n    /**\n     * Calculate required Trie capacity in nodes of a tree decomposition of the keys.\n     * For example given the keys:\n     * <ul>\n     *     <li>utf_16</li>\n     *     <li>utf_8</li>\n     *     <li>utf16</li>\n     *     <li>utf8</li>\n     * </ul>\n     * The tree has 10 nodes as follows:\n     * <pre>\n     *                     1 - 6\n     *                   /\n     *                 _ - 8\n     *               /\n     *     u - t - f - 1 - 6\n     *               \\\n     *                 8\n     * </pre>\n     * @param keys The keys to be put in a Trie\n     * @return The capacity in nodes of a tree decomposition\n     */\n    public static int requiredCapacity(Set<String> keys)\n    {\n        List<String> list = new ArrayList<>(keys);\n        Collections.sort(list);\n        return requiredCapacity(list, 0, list.size(), 0);\n    }\n\n    /**\n     * Calculate required Trie capacity in nodes of a sub-tree decomposition of the keys.\n     * @param keys The keys to calculate the capacity for\n     * @param offset The offset of the first key to be considered\n     * @param length The number of keys to be considered\n     * @param index The character to be considered\n     * @return The capacity in tree nodes of the substree\n     */\n    private static int requiredCapacity(List<String> keys, int offset, int length, int index)\n    {\n        int required = 0;\n\n        // Examine all the keys in the subtree\n        Character nodeChar = null;\n        for (int i = 0; i < length; i++)\n        {\n            String k = keys.get(offset + i);\n\n            // If the key is shorter than our current index then ignore it\n            if (k.length() <= index)\n                continue;\n\n            // Get the character at the index of the current key\n            char c = k.charAt(index);\n\n            // If the character is the same as the current node, then we are\n            // still in the current node and need to continue searching for the\n            // next node or the end of the keys\n            if (nodeChar != null && c == nodeChar)\n                continue;\n\n            // The character is a new node, so increase required by 1\n            required++;\n\n            // if we had a previous node, then add the required nodes for the subtree under it.\n            if (nodeChar != null)\n                required +=  requiredCapacity(keys, offset, i, index + 1);\n\n            // set the char for the new node\n            nodeChar = c;\n\n            // reset the offset, length and index to continue iteration from the start of the new node\n            offset += i;\n            length -= i;\n            i = 0;\n        }\n\n        // If we finish the iteration with a nodeChar, then we must add the required nodes for the subtree under it.\n        if (nodeChar != null)\n            required += requiredCapacity(keys, offset, length, index + 1);\n\n        return required;\n    }\n\n    @Test\n    public void testRequiredCapacity()\n    {\n        assertThat(requiredCapacity(Set.of(\"\")), is(0));\n        assertThat(requiredCapacity(Set.of(\"ABC\", \"\")), is(3));\n        assertThat(requiredCapacity(Set.of(\"ABC\")), is(3));\n        assertThat(requiredCapacity(Set.of(\"ABC\", \"XYZ\")), is(6));\n        assertThat(requiredCapacity(Set.of(\"A00\", \"A11\")), is(5));\n        assertThat(requiredCapacity(Set.of(\"A00\", \"A01\", \"A10\", \"A11\")), is(7));\n        assertThat(requiredCapacity(Set.of(\"A\", \"AB\")), is(2));\n        assertThat(requiredCapacity(Set.of(\"A\", \"ABC\")), is(3));\n        assertThat(requiredCapacity(Set.of(\"A\", \"ABCD\")), is(4));\n        assertThat(requiredCapacity(Set.of(\"AB\", \"ABC\")), is(3));\n        assertThat(requiredCapacity(Set.of(\"ABC\", \"ABCD\")), is(4));\n        assertThat(requiredCapacity(Set.of(\"ABC\", \"ABCDEF\")), is(6));\n        assertThat(requiredCapacity(Set.of(\"AB\", \"A\")), is(2));\n        assertThat(requiredCapacity(Set.of(\"ABC\", \"ABCDEF\")), is(6));\n        assertThat(requiredCapacity(Set.of(\"ABCDEF\", \"ABC\")), is(6));\n        assertThat(requiredCapacity(Set.of(\"ABC\", \"ABCDEF\", \"ABX\")), is(7));\n        assertThat(requiredCapacity(Set.of(\"ABCDEF\", \"ABC\", \"ABX\")), is(7));\n        assertThat(requiredCapacity(Set.of(\"ADEF\", \"AQPR4\", \"AQZ\")), is(9));\n        assertThat(requiredCapacity(Set.of(\"111\", \"ADEF\", \"AQPR4\", \"AQZ\", \"999\")), is(15));\n        assertThat(requiredCapacity(Set.of(\"utf-16\", \"utf-8\")), is(7));\n        assertThat(requiredCapacity(Set.of(\"utf-16\", \"utf-8\", \"utf16\", \"utf8\")), is(10));\n        assertThat(requiredCapacity(Set.of(\"utf-8\", \"utf8\", \"utf-16\", \"utf16\", \"iso-8859-1\", \"iso_8859_1\")), is(27));\n    }", "author": "gregw", "createdAt": "2020-11-25T10:21:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU0ODU1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDMxNDE5Mg==", "url": "https://github.com/eclipse/jetty.project/pull/5566#discussion_r530314192", "bodyText": "Works perfectly fine! Integrated.", "author": "lorban", "createdAt": "2020-11-25T11:47:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU0ODU1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU1MDg2OQ==", "url": "https://github.com/eclipse/jetty.project/pull/5566#discussion_r529550869", "bodyText": "This will create an unbounded shared cache!\nShould be something like:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final MutableIndex<HttpField> NO_CACHE = new Index.Builder<HttpField>()\n          \n          \n            \n                    .caseSensitive(false)\n          \n          \n            \n                    .mutable()\n          \n          \n            \n                    .build();\n          \n          \n            \n                private static final MutableIndex<HttpField> NO_CACHE = new Index.Builder<HttpField>()\n          \n          \n            \n                    .caseSensitive(false)\n          \n          \n            \n                    .mutable()\n          \n          \n            \n                    .maxCapacity(0)\n          \n          \n            \n                    .build();\n          \n      \n    \n    \n  \n\nHopefully the builder will be clever when is sees a maxCapacity of 0 and return an EmptyIndex impl", "author": "gregw", "createdAt": "2020-11-24T13:38:39Z", "path": "jetty-http/src/main/java/org/eclipse/jetty/http/HttpParser.java", "diffHunk": "@@ -106,8 +107,73 @@\n      * determine the header name even if the name:value combination is not cached\n      * </ul>\n      */\n-    public static final Trie<HttpField> CACHE = new ArrayTrie<>(2048);\n-    private static final Trie<HttpField> NO_CACHE = Trie.empty(true);\n+    public static final Index<HttpField> CACHE = new Index.Builder<HttpField>()\n+        .caseSensitive(false)\n+        .with(new HttpField(HttpHeader.CONNECTION, HttpHeaderValue.CLOSE))\n+        .with(new HttpField(HttpHeader.CONNECTION, HttpHeaderValue.KEEP_ALIVE))\n+        .with(new HttpField(HttpHeader.CONNECTION, HttpHeaderValue.UPGRADE))\n+        .with(new HttpField(HttpHeader.ACCEPT_ENCODING, \"gzip\"))\n+        .with(new HttpField(HttpHeader.ACCEPT_ENCODING, \"gzip, deflate\"))\n+        .with(new HttpField(HttpHeader.ACCEPT_ENCODING, \"gzip, deflate, br\"))\n+        .with(new HttpField(HttpHeader.ACCEPT_ENCODING, \"gzip,deflate,sdch\"))\n+        .with(new HttpField(HttpHeader.ACCEPT_LANGUAGE, \"en-US,enq=0.5\"))\n+        .with(new HttpField(HttpHeader.ACCEPT_LANGUAGE, \"en-GB,en-USq=0.8,enq=0.6\"))\n+        .with(new HttpField(HttpHeader.ACCEPT_LANGUAGE, \"en-AU,enq=0.9,it-ITq=0.8,itq=0.7,en-GBq=0.6,en-USq=0.5\"))\n+        .with(new HttpField(HttpHeader.ACCEPT_CHARSET, \"ISO-8859-1,utf-8q=0.7,*q=0.3\"))\n+        .with(new HttpField(HttpHeader.ACCEPT, \"*/*\"))\n+        .with(new HttpField(HttpHeader.ACCEPT, \"image/png,image/*q=0.8,*/*q=0.5\"))\n+        .with(new HttpField(HttpHeader.ACCEPT, \"text/html,application/xhtml+xml,application/xmlq=0.9,*/*q=0.8\"))\n+        .with(new HttpField(HttpHeader.ACCEPT, \"text/html,application/xhtml+xml,application/xmlq=0.9,image/webp,image/apng,*/*q=0.8\"))\n+        .with(new HttpField(HttpHeader.ACCEPT_RANGES, HttpHeaderValue.BYTES))\n+        .with(new HttpField(HttpHeader.PRAGMA, \"no-cache\"))\n+        .with(new HttpField(HttpHeader.CACHE_CONTROL, \"private, no-cache, no-cache=Set-Cookie, proxy-revalidate\"))\n+        .with(new HttpField(HttpHeader.CACHE_CONTROL, \"no-cache\"))\n+        .with(new HttpField(HttpHeader.CACHE_CONTROL, \"max-age=0\"))\n+        .with(new HttpField(HttpHeader.CONTENT_LENGTH, \"0\"))\n+        .with(new HttpField(HttpHeader.CONTENT_ENCODING, \"gzip\"))\n+        .with(new HttpField(HttpHeader.CONTENT_ENCODING, \"deflate\"))\n+        .with(new HttpField(HttpHeader.TRANSFER_ENCODING, \"chunked\"))\n+        .with(new HttpField(HttpHeader.EXPIRES, \"Fri, 01 Jan 1990 00:00:00 GMT\"))\n+        .withAll(() ->\n+        {\n+            Map<String, HttpField> map = new LinkedHashMap<>();\n+            // Add common Content types as fields\n+            for (String type : new String[]{\n+                \"text/plain\", \"text/html\", \"text/xml\", \"text/json\", \"application/json\", \"application/x-www-form-urlencoded\"\n+            })\n+            {\n+                HttpField field = new PreEncodedHttpField(HttpHeader.CONTENT_TYPE, type);\n+                map.put(field.toString(), field);\n+\n+                for (String charset : new String[]{\"utf-8\", \"iso-8859-1\"})\n+                {\n+                    PreEncodedHttpField field1 = new PreEncodedHttpField(HttpHeader.CONTENT_TYPE, type + \";charset=\" + charset);\n+                    map.put(field1.toString(), field1);\n+                    PreEncodedHttpField field2 = new PreEncodedHttpField(HttpHeader.CONTENT_TYPE, type + \"; charset=\" + charset);\n+                    map.put(field2.toString(), field2);\n+                    PreEncodedHttpField field3 = new PreEncodedHttpField(HttpHeader.CONTENT_TYPE, type + \";charset=\" + charset.toUpperCase(Locale.ENGLISH));\n+                    map.put(field3.toString(), field3);\n+                    PreEncodedHttpField field4 = new PreEncodedHttpField(HttpHeader.CONTENT_TYPE, type + \"; charset=\" + charset.toUpperCase(Locale.ENGLISH));\n+                    map.put(field4.toString(), field4);\n+                }\n+            }\n+            return map;\n+        })\n+        .withAll(() ->\n+        {\n+            Map<String, HttpField> map = new LinkedHashMap<>();\n+            for (HttpHeader h : HttpHeader.values())\n+            {\n+                HttpField httpField = new HttpField(h, (String)null);\n+                map.put(httpField.toString(), httpField);\n+            }\n+            return map;\n+        })\n+        .build();\n+    private static final MutableIndex<HttpField> NO_CACHE = new Index.Builder<HttpField>()\n+        .caseSensitive(false)\n+        .mutable()\n+        .build();", "originalCommit": "b5a271c2e81396f3efbf752de90ce2e0110ee94d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE4NDU1Mw==", "url": "https://github.com/eclipse/jetty.project/pull/5566#discussion_r530184553", "bodyText": "Good idea, let me add that in.", "author": "lorban", "createdAt": "2020-11-25T08:25:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU1MDg2OQ=="}], "type": "inlineReview"}, {"oid": "992342238cf05a743e445059ed20a8511d8ec1d0", "url": "https://github.com/eclipse/jetty.project/commit/992342238cf05a743e445059ed20a8511d8ec1d0", "message": "get rid of Trie interface\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-11-25T08:55:02Z", "type": "forcePushed"}, {"oid": "7f23b1980cac8df1d7abd2e8899a189404e0c480", "url": "https://github.com/eclipse/jetty.project/commit/7f23b1980cac8df1d7abd2e8899a189404e0c480", "message": "remove duplicates of Index.Mutable\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-11-25T11:46:42Z", "type": "forcePushed"}, {"oid": "343d0486d7d0f33b2b38442edeb953fc50c1bad7", "url": "https://github.com/eclipse/jetty.project/commit/343d0486d7d0f33b2b38442edeb953fc50c1bad7", "message": "remove duplicates of Index.Mutable\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-11-25T11:47:12Z", "type": "forcePushed"}, {"oid": "be277184979923410785682ec7d16e09b9995fd7", "url": "https://github.com/eclipse/jetty.project/commit/be277184979923410785682ec7d16e09b9995fd7", "message": "remove duplicates of Index.Mutable\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-11-25T12:09:34Z", "type": "forcePushed"}, {"oid": "442f910843024a3a71496b723790ff28cbf4934d", "url": "https://github.com/eclipse/jetty.project/commit/442f910843024a3a71496b723790ff28cbf4934d", "message": "javadoc\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-11-25T12:45:29Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ4NTM0OQ==", "url": "https://github.com/eclipse/jetty.project/pull/5566#discussion_r530485349", "bodyText": "This could just be a map, as I think it really should be case sensitive (old mistake)... or even just a string switch in the one place it is used.   But happy to leave for another PR. your call.", "author": "gregw", "createdAt": "2020-11-25T16:05:52Z", "path": "jetty-http/src/main/java/org/eclipse/jetty/http/HttpGenerator.java", "diffHunk": "@@ -92,13 +91,11 @@\n     private final int _send;\n     private static final int SEND_SERVER = 0x01;\n     private static final int SEND_XPOWEREDBY = 0x02;\n-    private static final Trie<Boolean> ASSUMED_CONTENT_METHODS = new ArrayTrie<>(8);\n-\n-    static\n-    {\n-        ASSUMED_CONTENT_METHODS.put(HttpMethod.POST.asString(), Boolean.TRUE);\n-        ASSUMED_CONTENT_METHODS.put(HttpMethod.PUT.asString(), Boolean.TRUE);\n-    }\n+    private static final Index<Boolean> ASSUMED_CONTENT_METHODS = new Index.Builder<Boolean>()", "originalCommit": "442f910843024a3a71496b723790ff28cbf4934d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUzODc1Nw==", "url": "https://github.com/eclipse/jetty.project/pull/5566#discussion_r530538757", "bodyText": "I think this should go into another PR as we don't want to delay 10.0.0 for too long.", "author": "lorban", "createdAt": "2020-11-25T17:28:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ4NTM0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ5MjI2OA==", "url": "https://github.com/eclipse/jetty.project/pull/5566#discussion_r530492268", "bodyText": "We need to create this lazily only when a with method is called....\neither that or we need a cheaper way for HttpParser to create a cache index on the fly without creating a lot of garbage.\nCurrently that code is:\n                            ? new Index.Builder<HttpField>()\n                            .caseSensitive(false)\n                            .mutable()\n                            .maxCapacity(getHeaderCacheSize())\n                            .build()\nSo even with a lazy contents it is creating two Builders with an int field in one and a boolean plus int in the other...\nPerhaps it would be better to support a short-cut like:\n                            ? new Index.MutableBuilder<HttpField>()\n                            .caseSensitive(false)\n                            .maxCapacity(getHeaderCacheSize())\n                            .build()", "author": "gregw", "createdAt": "2020-11-25T16:15:57Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Index.java", "diffHunk": "@@ -0,0 +1,340 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.util;\n+\n+import java.nio.ByteBuffer;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+/**\n+ * An immutable String lookup data structure.\n+ * @param <V> the entry type\n+ */\n+public interface Index<V>\n+{\n+    /**\n+     * Get an exact match from a String key\n+     *\n+     * @param s The key\n+     * @return the value for the string key\n+     */\n+    V get(String s);\n+\n+    /**\n+     * Get an exact match from a segment of a ByteBuufer as key\n+     *\n+     * @param b The buffer\n+     * @return The value or null if not found\n+     */\n+    V get(ByteBuffer b);\n+\n+    /**\n+     * Get an exact match from a String key\n+     *\n+     * @param s The key\n+     * @param offset The offset within the string of the key\n+     * @param len the length of the key\n+     * @return the value for the string / offset / length\n+     */\n+    V get(String s, int offset, int len);\n+\n+    /**\n+     * Get an exact match from a segment of a ByteBuufer as key\n+     *\n+     * @param b The buffer\n+     * @param offset The offset within the buffer of the key\n+     * @param len the length of the key\n+     * @return The value or null if not found\n+     */\n+    V get(ByteBuffer b, int offset, int len);\n+\n+    /**\n+     * Get the best match from key in a String.\n+     *\n+     * @param s The string\n+     * @param offset The offset within the string of the key\n+     * @param len the length of the key\n+     * @return The value or null if not found\n+     */\n+    V getBest(String s, int offset, int len);\n+\n+    /**\n+     * Get the best match from key in a byte buffer.\n+     * The key is assumed to by ISO_8859_1 characters.\n+     *\n+     * @param b The buffer\n+     * @param offset The offset within the buffer of the key\n+     * @param len the length of the key\n+     * @return The value or null if not found\n+     */\n+    V getBest(ByteBuffer b, int offset, int len);\n+\n+    /**\n+     * Get the best match from key in a String.\n+     *\n+     * @param s The string\n+     * @return The value or null if not found\n+     */\n+    V getBest(String s);\n+\n+    /**\n+     * Get the best match from key in a byte array.\n+     * The key is assumed to by ISO_8859_1 characters.\n+     *\n+     * @param b The buffer\n+     * @param offset The offset within the array of the key\n+     * @param len the length of the key\n+     * @return The value or null if not found\n+     */\n+    V getBest(byte[] b, int offset, int len);\n+\n+    /**\n+     * Check if the index contains any entry.\n+     *\n+     * @return true if the index does not contain any entry.\n+     */\n+    boolean isEmpty();\n+\n+    /**\n+     * Get the number of entries in the index.\n+     *\n+     * @return the index' entries count.\n+     */\n+    int size();\n+\n+    /**\n+     * Get a {@link Set} of the keys contained in this index.\n+     *\n+     * @return a {@link Set} of the keys contained in this index.\n+     */\n+    Set<String> keySet();\n+\n+    /**\n+     * A mutable String lookup data structure.\n+     * Implementations are not thread-safe.\n+     * @param <V> the entry type\n+     */\n+    interface Mutable<V> extends Index<V>\n+    {\n+        /**\n+         * Put an entry into the index.\n+         *\n+         * @param s The key for the entry\n+         * @param v The value of the entry\n+         * @return True if the index had capacity to add the field.\n+         */\n+        boolean put(String s, V v);\n+\n+        /**\n+         * Put a value as both a key and a value.\n+         *\n+         * @param v The value and key\n+         * @return True if the Trie had capacity to add the field.\n+         */\n+        boolean put(V v);\n+\n+        /**\n+         * Remove an entry from the index.\n+         *\n+         * @param s The key for the entry\n+         * @return The removed value of the entry\n+         */\n+        V remove(String s);\n+\n+        /**\n+         * Remove all entries from the index.\n+         */\n+        void clear();\n+\n+        /**\n+         * Builder of {@link Index.Mutable} instances. Such builder cannot be\n+         * directly created, it is instead returned by calling {@link Index.Builder#mutable()}.\n+         * @param <V> the entry type\n+         */\n+        class Builder<V> extends Index.Builder<V>\n+        {\n+            private int maxCapacity = -1;\n+\n+            Builder(Map<String, V> contents, boolean caseSensitive)\n+            {\n+                super(contents, caseSensitive);\n+            }\n+\n+            /**\n+             * Configure a maximum capacity for the mutable index.\n+             * A negative value means there is no capacity limit and\n+             * the index can grow without limits.\n+             * The default value is -1.\n+             * @param capacity the maximum capacity of the index.\n+             * @return this\n+             */\n+            public Builder<V> maxCapacity(int capacity)\n+            {\n+                this.maxCapacity = capacity;\n+                return this;\n+            }\n+\n+            /**\n+             * Build a {@link Mutable} instance.\n+             * @return a {@link Mutable} instance.\n+             */\n+            public Mutable<V> build()\n+            {\n+                Mutable<V> result;\n+                if (maxCapacity > 0)\n+                    result = new ArrayTernaryTrie<>(!caseSensitive, maxCapacity);\n+                else if (maxCapacity < 0)\n+                    result = new ArrayTernaryTrie.Growing<>(!caseSensitive, 512, 512);\n+                else\n+                    return EmptyTrie.instance(caseSensitive);\n+\n+                for (Map.Entry<String, V> entry : contents.entrySet())\n+                {\n+                    if (!result.put(entry.getKey(), entry.getValue()))\n+                        throw new AssertionError(\"Trie capacity exceeded at \" + entry.getKey());\n+                }\n+                return result;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Builder of {@link Index} instances.\n+     * @param <V> the entry type\n+     */\n+    class Builder<V>\n+    {\n+        Map<String, V> contents;\n+        boolean caseSensitive;\n+\n+        /**\n+         * Create a new index builder instance.\n+         */\n+        public Builder()\n+        {\n+            this(new LinkedHashMap<>(), false);", "originalCommit": "442f910843024a3a71496b723790ff28cbf4934d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU0MDE5Mg==", "url": "https://github.com/eclipse/jetty.project/pull/5566#discussion_r530540192", "bodyText": "I could make the Index.MutableBuilder constructor public, but if I make the HashMaps lazy I don't think cutting a single object that holds an int will save anything measurable.", "author": "lorban", "createdAt": "2020-11-25T17:30:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ5MjI2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU1NTgxNw==", "url": "https://github.com/eclipse/jetty.project/pull/5566#discussion_r530555817", "bodyText": "I think it is still worth making the constructor public... even a small cost is significant in the HttpParser", "author": "gregw", "createdAt": "2020-11-25T17:58:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ5MjI2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ5MzUyOA==", "url": "https://github.com/eclipse/jetty.project/pull/5566#discussion_r530493528", "bodyText": "See earlier comment about the expense of this. We need to make this as cheap as possible:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        ? new Index.Builder<HttpField>()\n          \n          \n            \n                                        .caseSensitive(false)\n          \n          \n            \n                                        .mutable()\n          \n          \n            \n                                        .maxCapacity(getHeaderCacheSize())\n          \n          \n            \n                                        .build()\n          \n          \n            \n                                        ? new Index.MutableBuilder<HttpField>()\n          \n          \n            \n                                        .caseSensitive(false)\n          \n          \n            \n                                        .maxCapacity(getHeaderCacheSize())\n          \n          \n            \n                                        .build()", "author": "gregw", "createdAt": "2020-11-25T16:17:51Z", "path": "jetty-http/src/main/java/org/eclipse/jetty/http/HttpParser.java", "diffHunk": "@@ -1052,14 +1065,22 @@ else if (_endOfContent == EndOfContent.CHUNKED_CONTENT)\n                     if (_fieldCache == null)\n                     {\n                         _fieldCache = (getHeaderCacheSize() > 0 && (_version != null && _version == HttpVersion.HTTP_1_1))\n-                            ? new ArrayTernaryTrie<>(getHeaderCacheSize())\n+                            ? new Index.Builder<HttpField>()\n+                            .caseSensitive(false)\n+                            .mutable()\n+                            .maxCapacity(getHeaderCacheSize())\n+                            .build()", "originalCommit": "442f910843024a3a71496b723790ff28cbf4934d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU0MDI4NQ==", "url": "https://github.com/eclipse/jetty.project/pull/5566#discussion_r530540285", "bodyText": "See above.", "author": "lorban", "createdAt": "2020-11-25T17:31:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ5MzUyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ5NjQ2MQ==", "url": "https://github.com/eclipse/jetty.project/pull/5566#discussion_r530496461", "bodyText": "Hmmmm not having isFull changes this a bit... plus I;m not sure it is right.  Maybe something like:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                if (_field == null)\n          \n          \n            \n                                {\n          \n          \n            \n                                    HttpField field = new HttpField(_header, caseInsensitiveHeader(_headerString, _header.asString()), _valueString);\n          \n          \n            \n                                    if (_fieldCache.put(field))\n          \n          \n            \n                                        _field = field;\n          \n          \n            \n                                }\n          \n          \n            \n                                else\n          \n          \n            \n                                if (_field == null)\n          \n          \n            \n                                    _field = new HttpField(_header, caseInsensitiveHeader(_headerString, _header.asString()), _valueString);\n          \n          \n            \n                                if (!_fieldCache.put(field))\n          \n          \n            \n                                {\n          \n          \n            \n                                    _fieldCache.clear();\n          \n          \n            \n                                    _fieldCache.put(field);\n          \n          \n            \n                                }", "author": "gregw", "createdAt": "2020-11-25T16:22:05Z", "path": "jetty-http/src/main/java/org/eclipse/jetty/http/HttpParser.java", "diffHunk": "@@ -1052,14 +1065,22 @@ else if (_endOfContent == EndOfContent.CHUNKED_CONTENT)\n                     if (_fieldCache == null)\n                     {\n                         _fieldCache = (getHeaderCacheSize() > 0 && (_version != null && _version == HttpVersion.HTTP_1_1))\n-                            ? new ArrayTernaryTrie<>(getHeaderCacheSize())\n+                            ? new Index.Builder<HttpField>()\n+                            .caseSensitive(false)\n+                            .mutable()\n+                            .maxCapacity(getHeaderCacheSize())\n+                            .build()\n                             : NO_CACHE;\n                     }\n \n-                    if (!_fieldCache.isFull())\n+                    if (_field == null)\n+                    {\n+                        HttpField field = new HttpField(_header, caseInsensitiveHeader(_headerString, _header.asString()), _valueString);\n+                        if (_fieldCache.put(field))\n+                            _field = field;\n+                    }\n+                    else", "originalCommit": "442f910843024a3a71496b723790ff28cbf4934d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU0NTc0Mg==", "url": "https://github.com/eclipse/jetty.project/pull/5566#discussion_r530545742", "bodyText": "Ideally, we should rely on some eviction algorithm in the index instead of clearing it. But that's quite a can of worm that should be left closed if possible.\nLet's use that if (!put) clear & put logic, it should be roughly equivalent to what the old code is doing.", "author": "lorban", "createdAt": "2020-11-25T17:40:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ5NjQ2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU1NTE5MQ==", "url": "https://github.com/eclipse/jetty.project/pull/5566#discussion_r530555191", "bodyText": "I think before it just filled up the cache and left it as is.... so maybe we just put and ignore the return for now.... we can refine in future PRs", "author": "gregw", "createdAt": "2020-11-25T17:57:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ5NjQ2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ5Nzk3Nw==", "url": "https://github.com/eclipse/jetty.project/pull/5566#discussion_r530497977", "bodyText": "Can you use <>\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private final Index.Mutable<MappedResource<E>> _exactMap = new Index.Builder<MappedResource<E>>()\n          \n          \n            \n                private final Index.Mutable<MappedResource<E>> _exactMap = new Index.Builder<>()", "author": "gregw", "createdAt": "2020-11-25T16:24:21Z", "path": "jetty-http/src/main/java/org/eclipse/jetty/http/pathmap/PathMappings.java", "diffHunk": "@@ -49,9 +48,18 @@\n     private static final Logger LOG = LoggerFactory.getLogger(PathMappings.class);\n     private final Set<MappedResource<E>> _mappings = new TreeSet<>(Comparator.comparing(MappedResource::getPathSpec));\n \n-    private Trie<MappedResource<E>> _exactMap = new ArrayTernaryTrie<>(false);\n-    private Trie<MappedResource<E>> _prefixMap = new ArrayTernaryTrie<>(false);\n-    private Trie<MappedResource<E>> _suffixMap = new ArrayTernaryTrie<>(false);\n+    private final Index.Mutable<MappedResource<E>> _exactMap = new Index.Builder<MappedResource<E>>()", "originalCommit": "442f910843024a3a71496b723790ff28cbf4934d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU0MTA2Mg==", "url": "https://github.com/eclipse/jetty.project/pull/5566#discussion_r530541062", "bodyText": "Unfortunately not, javac cannot infer the Index.Builder type.", "author": "lorban", "createdAt": "2020-11-25T17:32:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ5Nzk3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ5OTMyMA==", "url": "https://github.com/eclipse/jetty.project/pull/5566#discussion_r530499320", "bodyText": "soo much better!", "author": "gregw", "createdAt": "2020-11-25T16:26:10Z", "path": "jetty-http/src/main/java/org/eclipse/jetty/http/pathmap/PathMappings.java", "diffHunk": "@@ -230,24 +235,18 @@ public boolean put(PathSpec pathSpec, E resource)\n         {\n             case EXACT:\n                 String exact = pathSpec.getPrefix();\n-                while (exact != null && !_exactMap.put(exact, entry))\n-                {\n-                    _exactMap = new ArrayTernaryTrie<>((ArrayTernaryTrie<MappedResource<E>>)_exactMap, 1.5);\n-                }\n+                if (exact != null)\n+                    _exactMap.put(exact, entry);", "originalCommit": "442f910843024a3a71496b723790ff28cbf4934d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ5OTk1Nw==", "url": "https://github.com/eclipse/jetty.project/pull/5566#discussion_r530499957", "bodyText": "oops these have been accidentally commented out!", "author": "gregw", "createdAt": "2020-11-25T16:27:06Z", "path": "jetty-http2/http2-common/src/main/java/org/eclipse/jetty/http2/HTTP2Cipher.java", "diffHunk": "@@ -20,323 +20,312 @@\n \n import java.util.Comparator;\n \n-import org.eclipse.jetty.util.ArrayTrie;\n-import org.eclipse.jetty.util.Trie;\n+import org.eclipse.jetty.util.Index;\n \n public class HTTP2Cipher\n {\n     public static final Comparator<String> COMPARATOR = new CipherComparator();\n \n-    private static final Trie<Boolean> __blackProtocols = new ArrayTrie<>(6 * 5);\n-    private static final Trie<Boolean> __blackCiphers = new ArrayTrie<>(275 * 40);\n+    private static final Index<Boolean> __blackProtocols = new Index.Builder<Boolean>()\n+        .caseSensitive(false)\n+        .with(\"TLSv1.2\", Boolean.TRUE)\n+        .with(\"TLSv1.1\", Boolean.TRUE)\n+        .with(\"TLSv1\", Boolean.TRUE)\n+        .with(\"SSL\", Boolean.TRUE)\n+        .with(\"SSLv2\", Boolean.TRUE)\n+        .with(\"SSLv3\", Boolean.TRUE)\n+        .build();\n \n-    static String[] _xxx;\n-\n-    static\n-    {\n-        String[] protocols = {\"TLSv1.2\", \"TLSv1.1\", \"TLSv1\", \"SSL\", \"SSLv2\", \"SSLv3\"};\n-        for (String p : protocols)\n-        {\n-            __blackProtocols.put(p, Boolean.TRUE);\n-        }\n-\n-        String[] ciphers =\n-        {\n-            \"TLS_NULL_WITH_NULL_NULL\",\n-            // \"TLS_RSA_WITH_NULL_MD5\",\n-            \"TLS_RSA_WITH_NULL_SHA\",\n-            \"TLS_RSA_EXPORT_WITH_RC4_40_MD5\"/*,\n-            \"TLS_RSA_WITH_RC4_128_MD5\",\n-            \"TLS_RSA_WITH_RC4_128_SHA\",\n-            \"TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5\",\n-            \"TLS_RSA_WITH_IDEA_CBC_SHA\",\n-            \"TLS_RSA_EXPORT_WITH_DES40_CBC_SHA\",\n-            \"TLS_RSA_WITH_DES_CBC_SHA\",\n-            \"TLS_RSA_WITH_3DES_EDE_CBC_SHA\",\n-            \"TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA\",\n-            \"TLS_DH_DSS_WITH_DES_CBC_SHA\",\n-            \"TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA\",\n-            \"TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA\",\n-            \"TLS_DH_RSA_WITH_DES_CBC_SHA\",\n-            \"TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA\",\n-            \"TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA\",\n-            \"TLS_DHE_DSS_WITH_DES_CBC_SHA\",\n-            \"TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA\",\n-            \"TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA\",\n-            \"TLS_DHE_RSA_WITH_DES_CBC_SHA\",\n-            \"TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA\",\n-            \"TLS_DH_anon_EXPORT_WITH_RC4_40_MD5\",\n-            \"TLS_DH_anon_WITH_RC4_128_MD5\",\n-            \"TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA\",\n-            \"TLS_DH_anon_WITH_DES_CBC_SHA\",\n-            \"TLS_DH_anon_WITH_3DES_EDE_CBC_SHA\",\n-            \"TLS_KRB5_WITH_DES_CBC_SHA\",\n-            \"TLS_KRB5_WITH_3DES_EDE_CBC_SHA\",\n-            \"TLS_KRB5_WITH_RC4_128_SHA\",\n-            \"TLS_KRB5_WITH_IDEA_CBC_SHA\",\n-            \"TLS_KRB5_WITH_DES_CBC_MD5\",\n-            \"TLS_KRB5_WITH_3DES_EDE_CBC_MD5\",\n-            \"TLS_KRB5_WITH_RC4_128_MD5\",\n-            \"TLS_KRB5_WITH_IDEA_CBC_MD5\",\n-            \"TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA\",\n-            \"TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA\",\n-            \"TLS_KRB5_EXPORT_WITH_RC4_40_SHA\",\n-            \"TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5\",\n-            \"TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5\",\n-            \"TLS_KRB5_EXPORT_WITH_RC4_40_MD5\",\n-            \"TLS_PSK_WITH_NULL_SHA\",\n-            \"TLS_DHE_PSK_WITH_NULL_SHA\",\n-            \"TLS_RSA_PSK_WITH_NULL_SHA\",\n-            \"TLS_RSA_WITH_AES_128_CBC_SHA\",\n-            \"TLS_DH_DSS_WITH_AES_128_CBC_SHA\",\n-            \"TLS_DH_RSA_WITH_AES_128_CBC_SHA\",\n-            \"TLS_DHE_DSS_WITH_AES_128_CBC_SHA\",\n-            \"TLS_DHE_RSA_WITH_AES_128_CBC_SHA\",\n-            \"TLS_DH_anon_WITH_AES_128_CBC_SHA\",\n-            \"TLS_RSA_WITH_AES_256_CBC_SHA\",\n-            \"TLS_DH_DSS_WITH_AES_256_CBC_SHA\",\n-            \"TLS_DH_RSA_WITH_AES_256_CBC_SHA\",\n-            \"TLS_DHE_DSS_WITH_AES_256_CBC_SHA\",\n-            \"TLS_DHE_RSA_WITH_AES_256_CBC_SHA\",\n-            \"TLS_DH_anon_WITH_AES_256_CBC_SHA\",\n-            \"TLS_RSA_WITH_NULL_SHA256\",\n-            \"TLS_RSA_WITH_AES_128_CBC_SHA256\",\n-            \"TLS_RSA_WITH_AES_256_CBC_SHA256\",\n-            \"TLS_DH_DSS_WITH_AES_128_CBC_SHA256\",\n-            \"TLS_DH_RSA_WITH_AES_128_CBC_SHA256\",\n-            \"TLS_DHE_DSS_WITH_AES_128_CBC_SHA256\",\n-            \"TLS_RSA_WITH_CAMELLIA_128_CBC_SHA\",\n-            \"TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA\",\n-            \"TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA\",\n-            \"TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA\",\n-            \"TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA\",\n-            \"TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA\",\n-            \"TLS_DHE_RSA_WITH_AES_128_CBC_SHA256\",\n-            \"TLS_DH_DSS_WITH_AES_256_CBC_SHA256\",\n-            \"TLS_DH_RSA_WITH_AES_256_CBC_SHA256\",\n-            \"TLS_DHE_DSS_WITH_AES_256_CBC_SHA256\",\n-            \"TLS_DHE_RSA_WITH_AES_256_CBC_SHA256\",\n-            \"TLS_DH_anon_WITH_AES_128_CBC_SHA256\",\n-            \"TLS_DH_anon_WITH_AES_256_CBC_SHA256\",\n-            \"TLS_RSA_WITH_CAMELLIA_256_CBC_SHA\",\n-            \"TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA\",\n-            \"TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA\",\n-            \"TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA\",\n-            \"TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA\",\n-            \"TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA\",\n-            \"TLS_PSK_WITH_RC4_128_SHA\",\n-            \"TLS_PSK_WITH_3DES_EDE_CBC_SHA\",\n-            \"TLS_PSK_WITH_AES_128_CBC_SHA\",\n-            \"TLS_PSK_WITH_AES_256_CBC_SHA\",\n-            \"TLS_DHE_PSK_WITH_RC4_128_SHA\",\n-            \"TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA\",\n-            \"TLS_DHE_PSK_WITH_AES_128_CBC_SHA\",\n-            \"TLS_DHE_PSK_WITH_AES_256_CBC_SHA\",\n-            \"TLS_RSA_PSK_WITH_RC4_128_SHA\",\n-            \"TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA\",\n-            \"TLS_RSA_PSK_WITH_AES_128_CBC_SHA\",\n-            \"TLS_RSA_PSK_WITH_AES_256_CBC_SHA\",\n-            \"TLS_RSA_WITH_SEED_CBC_SHA\",\n-            \"TLS_DH_DSS_WITH_SEED_CBC_SHA\",\n-            \"TLS_DH_RSA_WITH_SEED_CBC_SHA\",\n-            \"TLS_DHE_DSS_WITH_SEED_CBC_SHA\",\n-            \"TLS_DHE_RSA_WITH_SEED_CBC_SHA\",\n-            \"TLS_DH_anon_WITH_SEED_CBC_SHA\",\n-            \"TLS_RSA_WITH_AES_128_GCM_SHA256\",\n-            \"TLS_RSA_WITH_AES_256_GCM_SHA384\",\n-            \"TLS_DH_RSA_WITH_AES_128_GCM_SHA256\",\n-            \"TLS_DH_RSA_WITH_AES_256_GCM_SHA384\",\n-            \"TLS_DH_DSS_WITH_AES_128_GCM_SHA256\",\n-            \"TLS_DH_DSS_WITH_AES_256_GCM_SHA384\",\n-            \"TLS_DH_anon_WITH_AES_128_GCM_SHA256\",\n-            \"TLS_DH_anon_WITH_AES_256_GCM_SHA384\",\n-            \"TLS_PSK_WITH_AES_128_GCM_SHA256\",\n-            \"TLS_PSK_WITH_AES_256_GCM_SHA384\",\n-            \"TLS_RSA_PSK_WITH_AES_128_GCM_SHA256\",\n-            \"TLS_RSA_PSK_WITH_AES_256_GCM_SHA384\",\n-            \"TLS_PSK_WITH_AES_128_CBC_SHA256\",\n-            \"TLS_PSK_WITH_AES_256_CBC_SHA384\",\n-            \"TLS_PSK_WITH_NULL_SHA256\",\n-            \"TLS_PSK_WITH_NULL_SHA384\",\n-            \"TLS_DHE_PSK_WITH_AES_128_CBC_SHA256\",\n-            \"TLS_DHE_PSK_WITH_AES_256_CBC_SHA384\",\n-            \"TLS_DHE_PSK_WITH_NULL_SHA256\",\n-            \"TLS_DHE_PSK_WITH_NULL_SHA384\",\n-            \"TLS_RSA_PSK_WITH_AES_128_CBC_SHA256\",\n-            \"TLS_RSA_PSK_WITH_AES_256_CBC_SHA384\",\n-            \"TLS_RSA_PSK_WITH_NULL_SHA256\",\n-            \"TLS_RSA_PSK_WITH_NULL_SHA384\",\n-            \"TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256\",\n-            \"TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256\",\n-            \"TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256\",\n-            \"TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256\",\n-            \"TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256\",\n-            \"TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256\",\n-            \"TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256\",\n-            \"TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256\",\n-            \"TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256\",\n-            \"TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256\",\n-            \"TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256\",\n-            \"TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256\",\n-            \"TLS_EMPTY_RENEGOTIATION_INFO_SCSV\",\n-            \"TLS_ECDH_ECDSA_WITH_NULL_SHA\",\n-            \"TLS_ECDH_ECDSA_WITH_RC4_128_SHA\",\n-            \"TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA\",\n-            \"TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA\",\n-            \"TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA\",\n-            \"TLS_ECDHE_ECDSA_WITH_NULL_SHA\",\n-            \"TLS_ECDHE_ECDSA_WITH_RC4_128_SHA\",\n-            \"TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA\",\n-            \"TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA\",\n-            \"TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA\",\n-            \"TLS_ECDH_RSA_WITH_NULL_SHA\",\n-            \"TLS_ECDH_RSA_WITH_RC4_128_SHA\",\n-            \"TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA\",\n-            \"TLS_ECDH_RSA_WITH_AES_128_CBC_SHA\",\n-            \"TLS_ECDH_RSA_WITH_AES_256_CBC_SHA\",\n-            \"TLS_ECDHE_RSA_WITH_NULL_SHA\",\n-            \"TLS_ECDHE_RSA_WITH_RC4_128_SHA\",\n-            \"TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA\",\n-            \"TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA\",\n-            \"TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA\",\n-            \"TLS_ECDH_anon_WITH_NULL_SHA\",\n-            \"TLS_ECDH_anon_WITH_RC4_128_SHA\",\n-            \"TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA\",\n-            \"TLS_ECDH_anon_WITH_AES_128_CBC_SHA\",\n-            \"TLS_ECDH_anon_WITH_AES_256_CBC_SHA\",\n-            \"TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA\",\n-            \"TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA\",\n-            \"TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA\",\n-            \"TLS_SRP_SHA_WITH_AES_128_CBC_SHA\",\n-            \"TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA\",\n-            \"TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA\",\n-            \"TLS_SRP_SHA_WITH_AES_256_CBC_SHA\",\n-            \"TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA\",\n-            \"TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA\",\n-            \"TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256\",\n-            \"TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384\",\n-            \"TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256\",\n-            \"TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384\",\n-            \"TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256\",\n-            \"TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384\",\n-            \"TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256\",\n-            \"TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384\",\n-            \"TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256\",\n-            \"TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384\",\n-            \"TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256\",\n-            \"TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384\",\n-            \"TLS_ECDHE_PSK_WITH_RC4_128_SHA\",\n-            \"TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA\",\n-            \"TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA\",\n-            \"TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA\",\n-            \"TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256\",\n-            \"TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384\",\n-            \"TLS_ECDHE_PSK_WITH_NULL_SHA\",\n-            \"TLS_ECDHE_PSK_WITH_NULL_SHA256\",\n-            \"TLS_ECDHE_PSK_WITH_NULL_SHA384\",\n-            \"TLS_RSA_WITH_ARIA_128_CBC_SHA256\",\n-            \"TLS_RSA_WITH_ARIA_256_CBC_SHA384\",\n-            \"TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256\",\n-            \"TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384\",\n-            \"TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256\",\n-            \"TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384\",\n-            \"TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256\",\n-            \"TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384\",\n-            \"TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256\",\n-            \"TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384\",\n-            \"TLS_DH_anon_WITH_ARIA_128_CBC_SHA256\",\n-            \"TLS_DH_anon_WITH_ARIA_256_CBC_SHA384\",\n-            \"TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256\",\n-            \"TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384\",\n-            \"TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256\",\n-            \"TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384\",\n-            \"TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256\",\n-            \"TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384\",\n-            \"TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256\",\n-            \"TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384\",\n-            \"TLS_RSA_WITH_ARIA_128_GCM_SHA256\",\n-            \"TLS_RSA_WITH_ARIA_256_GCM_SHA384\",\n-            \"TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256\",\n-            \"TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384\",\n-            \"TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256\",\n-            \"TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384\",\n-            \"TLS_DH_anon_WITH_ARIA_128_GCM_SHA256\",\n-            \"TLS_DH_anon_WITH_ARIA_256_GCM_SHA384\",\n-            \"TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256\",\n-            \"TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384\",\n-            \"TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256\",\n-            \"TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384\",\n-            \"TLS_PSK_WITH_ARIA_128_CBC_SHA256\",\n-            \"TLS_PSK_WITH_ARIA_256_CBC_SHA384\",\n-            \"TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256\",\n-            \"TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384\",\n-            \"TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256\",\n-            \"TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384\",\n-            \"TLS_PSK_WITH_ARIA_128_GCM_SHA256\",\n-            \"TLS_PSK_WITH_ARIA_256_GCM_SHA384\",\n-            \"TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256\",\n-            \"TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384\",\n-            \"TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256\",\n-            \"TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384\",\n-            \"TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256\",\n-            \"TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384\",\n-            \"TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256\",\n-            \"TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384\",\n-            \"TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256\",\n-            \"TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384\",\n-            \"TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256\",\n-            \"TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384\",\n-            \"TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256\",\n-            \"TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384\",\n-            \"TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256\",\n-            \"TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384\",\n-            \"TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256\",\n-            \"TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384\",\n-            \"TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256\",\n-            \"TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384\",\n-            \"TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256\",\n-            \"TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384\",\n-            \"TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256\",\n-            \"TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384\",\n-            \"TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256\",\n-            \"TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384\",\n-            \"TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256\",\n-            \"TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384\",\n-            \"TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256\",\n-            \"TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384\",\n-            \"TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256\",\n-            \"TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384\",\n-            \"TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256\",\n-            \"TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384\",\n-            \"TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256\",\n-            \"TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384\",\n-            \"TLS_RSA_WITH_AES_128_CCM\",\n-            \"TLS_RSA_WITH_AES_256_CCM\",\n-            \"TLS_RSA_WITH_AES_128_CCM_8\",\n-            \"TLS_RSA_WITH_AES_256_CCM_8\",\n-            \"TLS_PSK_WITH_AES_128_CCM\",\n-            \"TLS_PSK_WITH_AES_256_CCM\",\n-            \"TLS_PSK_WITH_AES_128_CCM_8\",\n-            \"TLS_PSK_WITH_AES_256_CCM_8\"\n-            */\n-        };\n-        _xxx = ciphers;\n-        for (String c : ciphers)\n-        {\n-            __blackCiphers.put(c, Boolean.TRUE);\n-        }\n-    }\n+    private static final Index<Boolean> __blackCiphers = new Index.Builder<Boolean>()\n+        .caseSensitive(false)\n+        .with(\"TLS_NULL_WITH_NULL_NULL\", Boolean.TRUE)\n+//        .with(\"TLS_RSA_WITH_NULL_MD5\", Boolean.TRUE)\n+        .with(\"TLS_RSA_WITH_NULL_SHA\", Boolean.TRUE)\n+        .with(\"TLS_RSA_EXPORT_WITH_RC4_40_MD5\", Boolean.TRUE)\n+        /*", "originalCommit": "442f910843024a3a71496b723790ff28cbf4934d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUwMDE4OQ==", "url": "https://github.com/eclipse/jetty.project/pull/5566#discussion_r530500189", "bodyText": "... I think by me!!!!", "author": "gregw", "createdAt": "2020-11-25T16:27:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ5OTk1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU0MzAxMw==", "url": "https://github.com/eclipse/jetty.project/pull/5566#discussion_r530543013", "bodyText": "Well, I don't know what you did, but you did it in 0a70cba", "author": "lorban", "createdAt": "2020-11-25T17:35:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ5OTk1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU1MzI1Nw==", "url": "https://github.com/eclipse/jetty.project/pull/5566#discussion_r530553257", "bodyText": "I think I did a merge from 9 to 10 in the branch I was experimenting!  My bad!", "author": "gregw", "createdAt": "2020-11-25T17:53:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ5OTk1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUwNDM3Ng==", "url": "https://github.com/eclipse/jetty.project/pull/5566#discussion_r530504376", "bodyText": "Maybe AbstractIndex and the name Trie only applies to real implementations?", "author": "gregw", "createdAt": "2020-11-25T16:33:53Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/AbstractTrie.java", "diffHunk": "@@ -29,7 +33,7 @@\n  *\n  * @param <V> the type of object that the Trie holds\n  */\n-public abstract class AbstractTrie<V> implements Trie<V>\n+abstract class AbstractTrie<V> implements Index.Mutable<V>", "originalCommit": "442f910843024a3a71496b723790ff28cbf4934d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU0Mzg0OA==", "url": "https://github.com/eclipse/jetty.project/pull/5566#discussion_r530543848", "bodyText": "It doesn't really matter as the class is package-protected, so I'd leave it as it.", "author": "lorban", "createdAt": "2020-11-25T17:37:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUwNDM3Ng=="}], "type": "inlineReview"}, {"oid": "5c561023bb1b049eff19e6354627440e06ad8354", "url": "https://github.com/eclipse/jetty.project/commit/5c561023bb1b049eff19e6354627440e06ad8354", "message": "throw an exception when trying to build a mutable index with maxSize == 0 and some contents\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-11-26T08:10:43Z", "type": "forcePushed"}, {"oid": "ea3e3c5a7da0ac4c0773eceef1f89f66a12d33b7", "url": "https://github.com/eclipse/jetty.project/commit/ea3e3c5a7da0ac4c0773eceef1f89f66a12d33b7", "message": "replace Trie interface and impls usage with new *Index interfaces and Builders\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-11-26T08:12:47Z", "type": "forcePushed"}, {"oid": "9a586516745bfce84db440c6852e8bb403daf8d8", "url": "https://github.com/eclipse/jetty.project/commit/9a586516745bfce84db440c6852e8bb403daf8d8", "message": "replace Trie interface and impls usage with new *Index interfaces and Builders\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-11-26T08:27:28Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDg2NDg4NQ==", "url": "https://github.com/eclipse/jetty.project/pull/5566#discussion_r530864885", "bodyText": "Is there a max capacity to ArrayTernaryTrie?  If so we might need to pick which implementation", "author": "gregw", "createdAt": "2020-11-26T08:53:10Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Index.java", "diffHunk": "@@ -0,0 +1,353 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.util;\n+\n+import java.nio.ByteBuffer;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+/**\n+ * An immutable String lookup data structure.\n+ * @param <V> the entry type\n+ */\n+public interface Index<V>\n+{\n+    /**\n+     * Get an exact match from a String key\n+     *\n+     * @param s The key\n+     * @return the value for the string key\n+     */\n+    V get(String s);\n+\n+    /**\n+     * Get an exact match from a segment of a ByteBuufer as key\n+     *\n+     * @param b The buffer\n+     * @return The value or null if not found\n+     */\n+    V get(ByteBuffer b);\n+\n+    /**\n+     * Get an exact match from a String key\n+     *\n+     * @param s The key\n+     * @param offset The offset within the string of the key\n+     * @param len the length of the key\n+     * @return the value for the string / offset / length\n+     */\n+    V get(String s, int offset, int len);\n+\n+    /**\n+     * Get an exact match from a segment of a ByteBuufer as key\n+     *\n+     * @param b The buffer\n+     * @param offset The offset within the buffer of the key\n+     * @param len the length of the key\n+     * @return The value or null if not found\n+     */\n+    V get(ByteBuffer b, int offset, int len);\n+\n+    /**\n+     * Get the best match from key in a String.\n+     *\n+     * @param s The string\n+     * @param offset The offset within the string of the key\n+     * @param len the length of the key\n+     * @return The value or null if not found\n+     */\n+    V getBest(String s, int offset, int len);\n+\n+    /**\n+     * Get the best match from key in a byte buffer.\n+     * The key is assumed to by ISO_8859_1 characters.\n+     *\n+     * @param b The buffer\n+     * @param offset The offset within the buffer of the key\n+     * @param len the length of the key\n+     * @return The value or null if not found\n+     */\n+    V getBest(ByteBuffer b, int offset, int len);\n+\n+    /**\n+     * Get the best match from key in a String.\n+     *\n+     * @param s The string\n+     * @return The value or null if not found\n+     */\n+    V getBest(String s);\n+\n+    /**\n+     * Get the best match from key in a byte array.\n+     * The key is assumed to by ISO_8859_1 characters.\n+     *\n+     * @param b The buffer\n+     * @param offset The offset within the array of the key\n+     * @param len the length of the key\n+     * @return The value or null if not found\n+     */\n+    V getBest(byte[] b, int offset, int len);\n+\n+    /**\n+     * Check if the index contains any entry.\n+     *\n+     * @return true if the index does not contain any entry.\n+     */\n+    boolean isEmpty();\n+\n+    /**\n+     * Get the number of entries in the index.\n+     *\n+     * @return the index' entries count.\n+     */\n+    int size();\n+\n+    /**\n+     * Get a {@link Set} of the keys contained in this index.\n+     *\n+     * @return a {@link Set} of the keys contained in this index.\n+     */\n+    Set<String> keySet();\n+\n+    /**\n+     * A mutable String lookup data structure.\n+     * Implementations are not thread-safe.\n+     * @param <V> the entry type\n+     */\n+    interface Mutable<V> extends Index<V>\n+    {\n+        /**\n+         * Put an entry into the index.\n+         *\n+         * @param s The key for the entry\n+         * @param v The value of the entry\n+         * @return True if the index had capacity to add the field.\n+         */\n+        boolean put(String s, V v);\n+\n+        /**\n+         * Put a value as both a key and a value.\n+         *\n+         * @param v The value and key\n+         * @return True if the Trie had capacity to add the field.\n+         */\n+        boolean put(V v);\n+\n+        /**\n+         * Remove an entry from the index.\n+         *\n+         * @param s The key for the entry\n+         * @return The removed value of the entry\n+         */\n+        V remove(String s);\n+\n+        /**\n+         * Remove all entries from the index.\n+         */\n+        void clear();\n+\n+        /**\n+         * Builder of {@link Index.Mutable} instances. Such builder cannot be\n+         * directly created, it is instead returned by calling {@link Index.Builder#mutable()}.\n+         * @param <V> the entry type\n+         */\n+        class Builder<V> extends Index.Builder<V>\n+        {\n+            private int maxCapacity = -1;\n+\n+            Builder(boolean caseSensitive, Map<String, V> contents)\n+            {\n+                super(caseSensitive, contents);\n+            }\n+\n+            /**\n+             * Configure a maximum capacity for the mutable index.\n+             * A negative value means there is no capacity limit and\n+             * the index can grow without limits.\n+             * The default value is -1.\n+             * @param capacity the maximum capacity of the index.\n+             * @return this\n+             */\n+            public Builder<V> maxCapacity(int capacity)\n+            {\n+                this.maxCapacity = capacity;\n+                return this;\n+            }\n+\n+            /**\n+             * Build a {@link Mutable} instance.\n+             * @return a {@link Mutable} instance.\n+             */\n+            public Mutable<V> build()\n+            {\n+                if (contents != null && maxCapacity == 0)\n+                    throw new IllegalStateException(\"Cannot create a mutable index with maxCapacity=0 and some contents\");\n+\n+                Mutable<V> result;\n+                if (maxCapacity > 0)\n+                    result = new ArrayTernaryTrie<>(!caseSensitive, maxCapacity);", "originalCommit": "9a586516745bfce84db440c6852e8bb403daf8d8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDg3Nzc3MQ==", "url": "https://github.com/eclipse/jetty.project/pull/5566#discussion_r530877771", "bodyText": "I think ArrayTernaryTrie also has character indexes... so it too will have a max size.   Thus we need to check for the max size and use a TreeTrie", "author": "gregw", "createdAt": "2020-11-26T09:14:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDg2NDg4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDg3ODIxNg==", "url": "https://github.com/eclipse/jetty.project/pull/5566#discussion_r530878216", "bodyText": "oops you deleted TreeTrie... I think there is still a case to use it.", "author": "gregw", "createdAt": "2020-11-26T09:14:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDg2NDg4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDkzMTk2MQ==", "url": "https://github.com/eclipse/jetty.project/pull/5566#discussion_r530931961", "bodyText": "There is, and I've added a simple check that throws an exception when we go over it. Simplistic, doesn't solve any problem, but at least the problem reported in #5291 would make the code throw a exception with a human-readable error.\nAs discussed, properly solving that would require a new case-sensitive trie implementation that supports larger sizes, so that's for another PR.", "author": "lorban", "createdAt": "2020-11-26T10:36:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDg2NDg4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDg2NzI0Ng==", "url": "https://github.com/eclipse/jetty.project/pull/5566#discussion_r530867246", "bodyText": "Is there a reason to use ArrayTrie in any cases?", "author": "gregw", "createdAt": "2020-11-26T08:57:05Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Index.java", "diffHunk": "@@ -0,0 +1,353 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.util;\n+\n+import java.nio.ByteBuffer;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+/**\n+ * An immutable String lookup data structure.\n+ * @param <V> the entry type\n+ */\n+public interface Index<V>\n+{\n+    /**\n+     * Get an exact match from a String key\n+     *\n+     * @param s The key\n+     * @return the value for the string key\n+     */\n+    V get(String s);\n+\n+    /**\n+     * Get an exact match from a segment of a ByteBuufer as key\n+     *\n+     * @param b The buffer\n+     * @return The value or null if not found\n+     */\n+    V get(ByteBuffer b);\n+\n+    /**\n+     * Get an exact match from a String key\n+     *\n+     * @param s The key\n+     * @param offset The offset within the string of the key\n+     * @param len the length of the key\n+     * @return the value for the string / offset / length\n+     */\n+    V get(String s, int offset, int len);\n+\n+    /**\n+     * Get an exact match from a segment of a ByteBuufer as key\n+     *\n+     * @param b The buffer\n+     * @param offset The offset within the buffer of the key\n+     * @param len the length of the key\n+     * @return The value or null if not found\n+     */\n+    V get(ByteBuffer b, int offset, int len);\n+\n+    /**\n+     * Get the best match from key in a String.\n+     *\n+     * @param s The string\n+     * @param offset The offset within the string of the key\n+     * @param len the length of the key\n+     * @return The value or null if not found\n+     */\n+    V getBest(String s, int offset, int len);\n+\n+    /**\n+     * Get the best match from key in a byte buffer.\n+     * The key is assumed to by ISO_8859_1 characters.\n+     *\n+     * @param b The buffer\n+     * @param offset The offset within the buffer of the key\n+     * @param len the length of the key\n+     * @return The value or null if not found\n+     */\n+    V getBest(ByteBuffer b, int offset, int len);\n+\n+    /**\n+     * Get the best match from key in a String.\n+     *\n+     * @param s The string\n+     * @return The value or null if not found\n+     */\n+    V getBest(String s);\n+\n+    /**\n+     * Get the best match from key in a byte array.\n+     * The key is assumed to by ISO_8859_1 characters.\n+     *\n+     * @param b The buffer\n+     * @param offset The offset within the array of the key\n+     * @param len the length of the key\n+     * @return The value or null if not found\n+     */\n+    V getBest(byte[] b, int offset, int len);\n+\n+    /**\n+     * Check if the index contains any entry.\n+     *\n+     * @return true if the index does not contain any entry.\n+     */\n+    boolean isEmpty();\n+\n+    /**\n+     * Get the number of entries in the index.\n+     *\n+     * @return the index' entries count.\n+     */\n+    int size();\n+\n+    /**\n+     * Get a {@link Set} of the keys contained in this index.\n+     *\n+     * @return a {@link Set} of the keys contained in this index.\n+     */\n+    Set<String> keySet();\n+\n+    /**\n+     * A mutable String lookup data structure.\n+     * Implementations are not thread-safe.\n+     * @param <V> the entry type\n+     */\n+    interface Mutable<V> extends Index<V>\n+    {\n+        /**\n+         * Put an entry into the index.\n+         *\n+         * @param s The key for the entry\n+         * @param v The value of the entry\n+         * @return True if the index had capacity to add the field.\n+         */\n+        boolean put(String s, V v);\n+\n+        /**\n+         * Put a value as both a key and a value.\n+         *\n+         * @param v The value and key\n+         * @return True if the Trie had capacity to add the field.\n+         */\n+        boolean put(V v);\n+\n+        /**\n+         * Remove an entry from the index.\n+         *\n+         * @param s The key for the entry\n+         * @return The removed value of the entry\n+         */\n+        V remove(String s);\n+\n+        /**\n+         * Remove all entries from the index.\n+         */\n+        void clear();\n+\n+        /**\n+         * Builder of {@link Index.Mutable} instances. Such builder cannot be\n+         * directly created, it is instead returned by calling {@link Index.Builder#mutable()}.\n+         * @param <V> the entry type\n+         */\n+        class Builder<V> extends Index.Builder<V>\n+        {\n+            private int maxCapacity = -1;\n+\n+            Builder(boolean caseSensitive, Map<String, V> contents)\n+            {\n+                super(caseSensitive, contents);\n+            }\n+\n+            /**\n+             * Configure a maximum capacity for the mutable index.\n+             * A negative value means there is no capacity limit and\n+             * the index can grow without limits.\n+             * The default value is -1.\n+             * @param capacity the maximum capacity of the index.\n+             * @return this\n+             */\n+            public Builder<V> maxCapacity(int capacity)\n+            {\n+                this.maxCapacity = capacity;\n+                return this;\n+            }\n+\n+            /**\n+             * Build a {@link Mutable} instance.\n+             * @return a {@link Mutable} instance.\n+             */\n+            public Mutable<V> build()\n+            {\n+                if (contents != null && maxCapacity == 0)\n+                    throw new IllegalStateException(\"Cannot create a mutable index with maxCapacity=0 and some contents\");\n+\n+                Mutable<V> result;\n+                if (maxCapacity > 0)\n+                    result = new ArrayTernaryTrie<>(!caseSensitive, maxCapacity);\n+                else if (maxCapacity < 0)\n+                    result = new ArrayTernaryTrie.Growing<>(!caseSensitive, 512, 512);\n+                else\n+                    result = EmptyTrie.instance(caseSensitive);", "originalCommit": "9a586516745bfce84db440c6852e8bb403daf8d8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDg3NjY0Ng==", "url": "https://github.com/eclipse/jetty.project/pull/5566#discussion_r530876646", "bodyText": "I think if the try is immutable with known content, then we can use ArrayTrie rather than ArrayTernaryTrie.... althought there is also the case of knowing the alphabet used.... ie if non US ASCII characters are used.... so perhaps we need to scan for them....   Hmmm after this PR I think", "author": "gregw", "createdAt": "2020-11-26T09:12:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDg2NzI0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDkyOTc0Ng==", "url": "https://github.com/eclipse/jetty.project/pull/5566#discussion_r530929746", "bodyText": "As discussed, we need to improve the algorithm that chooses the underlying implementation. But that's for another PR.", "author": "lorban", "createdAt": "2020-11-26T10:32:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDg2NzI0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDg2NzYyMQ==", "url": "https://github.com/eclipse/jetty.project/pull/5566#discussion_r530867621", "bodyText": "Need to pass in all the context paths and not have this mutable", "author": "gregw", "createdAt": "2020-11-26T08:57:37Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/handler/ContextHandlerCollection.java", "diffHunk": "@@ -378,12 +360,15 @@ public String toString()\n     private static class Mapping extends Handlers\n     {\n         private final Map<ContextHandler, Handler> _contextBranches = new HashMap<>();\n-        private final Trie<Map.Entry<String, Branch[]>> _pathBranches;\n+        private final Index.Mutable<Map.Entry<String, Branch[]>> _pathBranches;\n \n-        private Mapping(Handler[] handlers, int capacity)\n+        private Mapping(Handler[] handlers)\n         {\n             super(handlers);\n-            _pathBranches = new ArrayTernaryTrie<>(false, capacity);\n+            _pathBranches = new Index.Builder<Map.Entry<String, Branch[]>>()\n+                .caseSensitive(true)\n+                .mutable()\n+                .build();", "originalCommit": "9a586516745bfce84db440c6852e8bb403daf8d8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDkyODk4OA==", "url": "https://github.com/eclipse/jetty.project/pull/5566#discussion_r530928988", "bodyText": "Done, ContextHandlerCollection.Mapping is now immutable.", "author": "lorban", "createdAt": "2020-11-26T10:31:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDg2NzYyMQ=="}], "type": "inlineReview"}, {"oid": "aa8bd5d8201615b9faacd7675ef97e8adf32167d", "url": "https://github.com/eclipse/jetty.project/commit/aa8bd5d8201615b9faacd7675ef97e8adf32167d", "message": "replace Trie interface and impls usage with new *Index interfaces and Builders\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-11-26T13:14:16Z", "type": "commit"}, {"oid": "aa8bd5d8201615b9faacd7675ef97e8adf32167d", "url": "https://github.com/eclipse/jetty.project/commit/aa8bd5d8201615b9faacd7675ef97e8adf32167d", "message": "replace Trie interface and impls usage with new *Index interfaces and Builders\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-11-26T13:14:16Z", "type": "forcePushed"}]}