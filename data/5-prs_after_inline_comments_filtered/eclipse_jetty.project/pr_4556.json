{"pr_number": 4556, "pr_title": "HttpInput refactoring", "pr_createdAt": "2020-02-07T10:56:41Z", "pr_url": "https://github.com/eclipse/jetty.project/pull/4556", "timeline": [{"oid": "982ddc0c482171e3e386080191f2a3067865a42b", "url": "https://github.com/eclipse/jetty.project/commit/982ddc0c482171e3e386080191f2a3067865a42b", "message": "FCGI queue and pull model, merge all common code between H1, H2 and FCGI (Milestone 3)\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-11-03T16:30:25Z", "type": "commit"}, {"oid": "d0f04a8eae8bbb550b6f89a888392dde0d5d54b5", "url": "https://github.com/eclipse/jetty.project/commit/d0f04a8eae8bbb550b6f89a888392dde0d5d54b5", "message": "addContent now returns void (Milestone 4)\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-11-03T16:30:25Z", "type": "commit"}, {"oid": "a4258ec9c09ca36e59b9cff26cd2f267838b407a", "url": "https://github.com/eclipse/jetty.project/commit/a4258ec9c09ca36e59b9cff26cd2f267838b407a", "message": "Merge all HttpInput* impls into a single class, push all differences to HttpChannel* impls (Milestone 5)\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-11-03T16:30:25Z", "type": "commit"}, {"oid": "814dc69803f6c218b85c4f98306068e81be83eaa", "url": "https://github.com/eclipse/jetty.project/commit/814dc69803f6c218b85c4f98306068e81be83eaa", "message": "Get rid of addContent() by making produceContent() return Content instead.\nMake EOF and errors be special content.\nTransition to a much simplified FSM by using the needContent() / produceContent() model.\nImplement blocking on top of async, this way there is only one FSM.\n(Milestone 6)\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-11-03T16:30:25Z", "type": "forcePushed"}, {"oid": "21103d0d8d1774d83e9e6da1bbeb822b7be43a0e", "url": "https://github.com/eclipse/jetty.project/commit/21103d0d8d1774d83e9e6da1bbeb822b7be43a0e", "message": "Milestone 1: HTTP and FCGI pass all tests\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-02-11T10:45:32Z", "type": "forcePushed"}, {"oid": "0cd6733e95bb456cb4736b193ef3f8fc9f0ba219", "url": "https://github.com/eclipse/jetty.project/commit/0cd6733e95bb456cb4736b193ef3f8fc9f0ba219", "message": "Milestone 1: HTTP and FCGI pass all tests\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-02-11T10:46:36Z", "type": "forcePushed"}, {"oid": "dcad5ba1083ce23bddb5f0bde4a35549913b99f1", "url": "https://github.com/eclipse/jetty.project/commit/dcad5ba1083ce23bddb5f0bde4a35549913b99f1", "message": "ContentProducer must check raw content queue in hasRawContent()\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-02-12T10:31:16Z", "type": "forcePushed"}, {"oid": "d85ad4a424f68bfd91368e1307c2f6a0fe46839f", "url": "https://github.com/eclipse/jetty.project/commit/d85ad4a424f68bfd91368e1307c2f6a0fe46839f", "message": "re-implement HTTP 408 rate control\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-02-12T11:40:24Z", "type": "forcePushed"}, {"oid": "188e0141c8d36f5f14831f55866e77cafc1ce93b", "url": "https://github.com/eclipse/jetty.project/commit/188e0141c8d36f5f14831f55866e77cafc1ce93b", "message": "implement HTTP onIdleTimeout\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-02-12T13:54:49Z", "type": "forcePushed"}, {"oid": "8c15c69abb68bf269e22ed37b10ffda8b040cf08", "url": "https://github.com/eclipse/jetty.project/commit/8c15c69abb68bf269e22ed37b10ffda8b040cf08", "message": "fix demand() calls\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-02-17T16:22:19Z", "type": "forcePushed"}, {"oid": "02c5b1f5c80c387c2e03fe609b1da4213d0b741d", "url": "https://github.com/eclipse/jetty.project/commit/02c5b1f5c80c387c2e03fe609b1da4213d0b741d", "message": "change HTTP2 to a pulling model similar to HTTP1\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-02-18T16:17:19Z", "type": "forcePushed"}, {"oid": "e2f5b0daa6c8858a3a83046547e92a64fe237ac0", "url": "https://github.com/eclipse/jetty.project/commit/e2f5b0daa6c8858a3a83046547e92a64fe237ac0", "message": "tentative fix #3\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-02-19T16:19:27Z", "type": "forcePushed"}, {"oid": "1e441eaae8841d3ad0b900ed7d84baf52b10c415", "url": "https://github.com/eclipse/jetty.project/commit/1e441eaae8841d3ad0b900ed7d84baf52b10c415", "message": "re-align HTTP 1 and 2 consumeAll()\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-02-24T10:25:53Z", "type": "forcePushed"}, {"oid": "11041e06b2b4c39a7b3ad44f6795df8c22a4353b", "url": "https://github.com/eclipse/jetty.project/commit/11041e06b2b4c39a7b3ad44f6795df8c22a4353b", "message": "replace lambdas with enclosing method calls\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-02-24T15:29:18Z", "type": "forcePushed"}, {"oid": "57bb838cc1b5fc09c49ee2969973d42a5dd9ea0c", "url": "https://github.com/eclipse/jetty.project/commit/57bb838cc1b5fc09c49ee2969973d42a5dd9ea0c", "message": "replace lambdas with enclosing method calls\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-02-24T16:45:23Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg3MjQ4Mg==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r383872482", "bodyText": "Rather than have both AbstractLockedHttpInput and AbstractHttpInput, I think AbstractHttpInput should just be lockable but initialised with a NOOP AutoLock that will be removed by the JIT", "author": "gregw", "createdAt": "2020-02-25T13:19:33Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/AbstractLockedHttpInput.java", "diffHunk": "@@ -0,0 +1,236 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.io.IOException;\n+import javax.servlet.ReadListener;\n+\n+import org.eclipse.jetty.util.thread.AutoLock;\n+\n+public abstract class AbstractLockedHttpInput extends AbstractHttpInput", "originalCommit": "c609285694a824207e6f5a0a330bf9942621f524", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMyODcwNw==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r384328707", "bodyText": "That sounds like a reasonable idea. This code is still in motion, so I haven't given this particular subject too much thought so far. But I'd prefer to wait until all the functionality we want to be fully working before working on that.", "author": "lorban", "createdAt": "2020-02-26T08:12:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg3MjQ4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMzMDQ3Ng==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r384330476", "bodyText": "ack!    Although I think the NOOP lock idea will not work because AbstractHttpInput still needs a real lock in some situations....\nSo consider this comment to be that ultimately all implementations should have the same locking behaviour and if not then we really need to be clear why not.", "author": "gregw", "createdAt": "2020-02-26T08:16:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg3MjQ4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTEwOTY3MQ==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r385109671", "bodyText": "Agreed. Now that all three implementations are working, we need to investigate their differences to make educated decisions on what to do about them.", "author": "lorban", "createdAt": "2020-02-27T12:58:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg3MjQ4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg3NzU5MA==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r383877590", "bodyText": "It is not immediately obvious why this is always return true here?  So at the very least it needs a comment to explain.\nBut if it is always return true because you have meta knowledge about when/why addContent is called, I'm still struggling to think of why super.addContent might return false and you would want to override.   Specifically if the state is not WAITING, then returning true here might cause a second thread to be dispatched to the channel", "author": "gregw", "createdAt": "2020-02-25T13:29:40Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpInputOverHTTP.java", "diffHunk": "@@ -18,18 +18,37 @@\n \n package org.eclipse.jetty.server;\n \n-import java.io.IOException;\n-\n-public class HttpInputOverHTTP extends HttpInput\n+// tests used: RequestTest, PartialRFC2616Test, AsyncRequestReadTest, AsyncIOServletTest, GzipHandlerTest\n+public class HttpInputOverHTTP extends AbstractHttpInput\n {\n     public HttpInputOverHTTP(HttpChannelState state)\n     {\n         super(state);\n     }\n \n     @Override\n-    protected void produceContent() throws IOException\n+    public boolean addContent(Content content)\n+    {\n+        super.addContent(content);\n+        return true;", "originalCommit": "c609285694a824207e6f5a0a330bf9942621f524", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMzMDA3Ng==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r384330076", "bodyText": "This one always returns true because returning anything else in HTTP 1 could make the parser call addContent again right away which would end up adding two Content objects.\nRegarding HTTP 2, the behavior strictly matches what the code was doing before the refactoring, so I didn't give it much thought as that was working as-is.\nThis is definitely one of those areas that will need more investigation/discussion.", "author": "lorban", "createdAt": "2020-02-26T08:15:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg3NzU5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMzNzA2Mw==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r384337063", "bodyText": "I'm VERY uncomfortable with using this to prevent multiple calls to addContent because the boolean return is a real meaningful value that is derived for an important state change in the HttpChannel\nConsider we are asynchronous.... nobody has called isReady() yet but somebody calls available(), which ultimately causes addContent to be called, which changes the state of the HttpChannelState and returns a meaningful true/false as to weather a new thread needs to be scheduled or not.... that information is now lost.\nLet's think of the counter case?   When would a thread be in the parser when addContent would return false?   Well probably always if we go with the model that only the thread calling read is the one that runs the HttpInput machinery.... in which case perhaps it is no longer addContents job to make scheduling decisions???   Eitherway, this is a fundamental change that really needs to be thought out.", "author": "gregw", "createdAt": "2020-02-26T08:31:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg3NzU5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTExMTI2Mg==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r385111262", "bodyText": "So far, my gut feeling has been that the addContent() model is wrong and that HttpInput should pull data when it needs it instead of being pushed data whenever.\nHTTP 1, 2 and FCGI are subtly different in this matter. We need to thoroughly investigate to better understand the reasons behind those differences.", "author": "lorban", "createdAt": "2020-02-27T13:02:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg3NzU5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTYxNDM1MQ==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r385614351", "bodyText": "OK let's break this down:\n\nH1 Blocking.  Read will be called by a single thread dispatched to a handler - or at least an application thread that is bound by a single dispatched thread.   addContent is always called by that thread in the scope of read.  If it blocks, then the onFillableCallback just wakes it up and it tries to fill and parse again.\nH1 Async. Read can be called by any thread at any time, but we can say it is an app error if two threads call read at the same time.  addContent can be called either by a call to read  OR if isReady() has returned false, by the callback to onFillable calling HttpChannel.handle which calls produceRawContent - BUT not both as an application is not allowed to call read if isReady returned false.  The boolean return is again not a scheduling decision. Scheduling is done by the state change in HttpChannelState being checked in unhandle.\nH2 Blocking. addContent might be called by a reading thread, only if demand(1) is implemented synchronously when there is available content.  If there is no content, the reading thread blocks and the callback to onContent eventually calls addContent which does the signal to wakeup the blocked thread.\nH2 Async.  If there is content, then it acts like blocking. If there is no content, it is the callback to onContent that calls addContent and the boolean return is used to decide if a call to HttpChannel.handle is needed.\n\nSo for the four cases, we have four different scheduling mechanisms and behaviours!  Surely we can reduce this to two:\n\nfor blocking, any callbacks will do the unblock as soon as possible and let the reader do as much work as possible\nfor async, any callbacks should always enter HttpChannel.handle and let the producing logic there control what happens.", "author": "gregw", "createdAt": "2020-02-28T10:19:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg3NzU5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTYxNjk0Mg==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r385616942", "bodyText": "Specifically if we get rid of the current H2 async behaviour then the boolean return to addContent is probably no longer necessary!   My lingering concern here is that rawContent may be added that in then entirely consumed by an interceptor, in which case blocking threads need to wakeup, run that consumption and then block again!", "author": "gregw", "createdAt": "2020-02-28T10:25:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg3NzU5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg4NTQ3Ng==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r383885476", "bodyText": "I think at the very least this needs to be signalAll.\nWhile having two threads read from the same input is going to be highly problematic, the use of AbstractLockedHttpInput does mean that two threads can call read() and be mutually excluded.  If more than two bytes of content then arrive, one of the reads will be woken, but the other one never will.... then the other thread will block forever!", "author": "gregw", "createdAt": "2020-02-25T13:43:43Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/AbstractHttpInput.java", "diffHunk": "@@ -0,0 +1,769 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.Condition;\n+import javax.servlet.ReadListener;\n+\n+import org.eclipse.jetty.http.BadMessageException;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.eclipse.jetty.io.EofException;\n+import org.eclipse.jetty.util.component.Destroyable;\n+import org.eclipse.jetty.util.log.Log;\n+import org.eclipse.jetty.util.log.Logger;\n+import org.eclipse.jetty.util.thread.AutoLock;\n+\n+public abstract class AbstractHttpInput extends HttpInput\n+{\n+    private static final Logger LOG = Log.getLogger(AbstractHttpInput.class);\n+\n+    private final byte[] _oneByteBuffer = new byte[1];\n+\n+    protected final HttpChannelState _channelState;\n+    protected final ContentProducer _contentProducer;\n+    protected final AutoLock _contentLock = new AutoLock();\n+    protected final Condition _contentLockCondition = _contentLock.newCondition();\n+\n+    private Eof _eof = Eof.NOT_YET;\n+    private Throwable _error;\n+    private ReadListener _readListener;\n+    private long _firstByteTimeStamp = Long.MIN_VALUE;\n+\n+    public AbstractHttpInput(HttpChannelState state)\n+    {\n+        _channelState = state;\n+        _contentProducer = new ContentProducer(this::produceRawContent);\n+    }\n+\n+    /* HttpInput */\n+\n+    @Override\n+    public void recycle()\n+    {\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"recycle\");\n+        _contentProducer.recycle();\n+        _eof = Eof.NOT_YET;\n+        _error = null;\n+        _readListener = null;\n+        _firstByteTimeStamp = Long.MIN_VALUE;\n+    }\n+\n+    @Override\n+    public Interceptor getInterceptor()\n+    {\n+        return _contentProducer.getInterceptor();\n+    }\n+\n+    @Override\n+    public void setInterceptor(Interceptor interceptor)\n+    {\n+        _contentProducer.setInterceptor(interceptor);\n+    }\n+\n+    @Override\n+    public void addInterceptor(Interceptor interceptor)\n+    {\n+        _contentProducer.addInterceptor(interceptor);\n+    }\n+\n+    @Override\n+    public void asyncReadProduce()\n+    {\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"asyncReadProduce {}\", _contentProducer);\n+        _contentProducer.produceRawContent();\n+    }\n+\n+    @Override\n+    public boolean addContent(Content content)\n+    {\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"addContent {} {}\", content, _contentProducer);\n+        if (_firstByteTimeStamp == Long.MIN_VALUE)\n+        {\n+            _firstByteTimeStamp = System.nanoTime();\n+            if (_firstByteTimeStamp == Long.MIN_VALUE)\n+                _firstByteTimeStamp++;\n+        }\n+        _contentProducer.addContent(content);\n+        if (isAsync())\n+            return _channelState.onContentAdded();\n+        unblock();\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean hasContent()\n+    {\n+        return _contentProducer.hasRawContent();\n+    }\n+\n+    @Override\n+    public void unblock()\n+    {\n+        try (AutoLock lock = _contentLock.lock())\n+        {\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"signalling blocked thread to wake up\");\n+            _contentLockCondition.signal();", "originalCommit": "c609285694a824207e6f5a0a330bf9942621f524", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMzMjYwMA==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r384332600", "bodyText": "The ServletInputStream contract is unclear w.r.t this. My assumption is that this InputStream can be used from any thread one wants, but only one thread can use it at a time.\nPlease note that the pre-refactoring implementation uses notify() in this particular case instead of notifyAll() so at the very least I'd say that no regression was introduced here. This doesn't mean the existing behavior is right and we can't revisit it, but it's again an area of discussion.", "author": "lorban", "createdAt": "2020-02-26T08:22:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg4NTQ3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMzODk3Mw==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r384338973", "bodyText": "I agree totally that the contract is not clean and that having two threads calling read() is pretty silly thing to do.   But then users always do pretty silly things and in response we can throw ReadPending, give a rubbish response, throw some other nasty exception..... but blocking forever is a really bad way to react to bad code.\nPoint taken about prior notify(), but now we realise that we could block a bad app forever, I think going to signalAll with a // TODO to review is a good way to avoid losing that realisation.", "author": "gregw", "createdAt": "2020-02-26T08:36:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg4NTQ3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTExMzA0MQ==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r385113041", "bodyText": "Something quick and simple we could do is to call tryLock instead of lock and throw some sort of YouCannotUseThisApiConcurrentlyException when the lock cannot be taken.\nBut again, I'd add this to the list of investigations to be done.", "author": "lorban", "createdAt": "2020-02-27T13:05:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg4NTQ3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg5MDA5Mw==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r383890093", "bodyText": "I fail to see the reason for different behaviour between HTTP/1 and HTTP/2 with respect to locking?\nWhy is it OK for 2 applications threads in HTTP/1 to enter read() and content on the internal data structures of raw buffers and producers without any memory barriers etc.  yet we mutually exclude when the same application is run on HTTP/2.\nIt feels like we've not really sorted out what the thread safety of this class should be.  Either we are responsible for thread safety of input or we are not - it should not depend on protocol used... even if only as a side effect of the implementation.", "author": "gregw", "createdAt": "2020-02-25T13:51:43Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/AbstractLockedHttpInput.java", "diffHunk": "@@ -0,0 +1,236 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.io.IOException;\n+import javax.servlet.ReadListener;\n+\n+import org.eclipse.jetty.util.thread.AutoLock;\n+\n+public abstract class AbstractLockedHttpInput extends AbstractHttpInput\n+{\n+    public AbstractLockedHttpInput(HttpChannelState state)\n+    {\n+        super(state);\n+    }\n+\n+    /* HttpInput */\n+\n+    @Override\n+    public void recycle()\n+    {\n+        try (AutoLock lock = _contentLock.lock())\n+        {\n+            super.recycle();\n+        }\n+    }\n+\n+    @Override\n+    public Interceptor getInterceptor()\n+    {\n+        try (AutoLock lock = _contentLock.lock())\n+        {\n+            return super.getInterceptor();\n+        }\n+    }\n+\n+    @Override\n+    public void setInterceptor(Interceptor interceptor)\n+    {\n+        try (AutoLock lock = _contentLock.lock())\n+        {\n+            super.setInterceptor(interceptor);\n+        }\n+    }\n+\n+    @Override\n+    public void addInterceptor(Interceptor interceptor)\n+    {\n+        try (AutoLock lock = _contentLock.lock())\n+        {\n+            super.addInterceptor(interceptor);\n+        }\n+    }\n+\n+    @Override\n+    public void asyncReadProduce()\n+    {\n+        try (AutoLock lock = _contentLock.lock())\n+        {\n+            super.asyncReadProduce();\n+        }\n+    }\n+\n+    @Override\n+    public boolean addContent(Content content)\n+    {\n+        try (AutoLock lock = _contentLock.lock())\n+        {\n+            return super.addContent(content);\n+        }\n+    }\n+\n+    @Override\n+    public boolean hasContent()\n+    {\n+        try (AutoLock lock = _contentLock.lock())\n+        {\n+            return super.hasContent();\n+        }\n+    }\n+\n+    @Override\n+    public long getContentLength()\n+    {\n+        try (AutoLock lock = _contentLock.lock())\n+        {\n+            return super.getContentLength();\n+        }\n+    }\n+\n+    @Override\n+    public boolean earlyEOF()\n+    {\n+        try (AutoLock lock = _contentLock.lock())\n+        {\n+            return super.earlyEOF();\n+        }\n+    }\n+\n+    @Override\n+    public boolean eof()\n+    {\n+        try (AutoLock lock = _contentLock.lock())\n+        {\n+            return super.eof();\n+        }\n+    }\n+\n+    @Override\n+    public boolean consumeAll()\n+    {\n+        try (AutoLock lock = _contentLock.lock())\n+        {\n+            return super.consumeAll();\n+        }\n+    }\n+\n+    @Override\n+    public boolean isError()\n+    {\n+        try (AutoLock lock = _contentLock.lock())\n+        {\n+            return super.isError();\n+        }\n+    }\n+\n+    @Override\n+    public boolean isAsync()\n+    {\n+        try (AutoLock lock = _contentLock.lock())\n+        {\n+            return super.isAsync();\n+        }\n+    }\n+\n+    @Override\n+    public boolean onIdleTimeout(Throwable x)\n+    {\n+        try (AutoLock lock = _contentLock.lock())\n+        {\n+            return super.onIdleTimeout(x);\n+        }\n+    }\n+\n+    @Override\n+    public boolean failed(Throwable x)\n+    {\n+        try (AutoLock lock = _contentLock.lock())\n+        {\n+            return super.failed(x);\n+        }\n+    }\n+\n+    /* ServletInputStream */\n+\n+    @Override\n+    public boolean isFinished()\n+    {\n+        try (AutoLock lock = _contentLock.lock())\n+        {\n+            return super.isFinished();\n+        }\n+    }\n+\n+    @Override\n+    public boolean isReady()\n+    {\n+        try (AutoLock lock = _contentLock.lock())\n+        {\n+            return super.isReady();\n+        }\n+    }\n+\n+    @Override\n+    public void setReadListener(ReadListener readListener)\n+    {\n+        try (AutoLock lock = _contentLock.lock())\n+        {\n+            super.setReadListener(readListener);\n+        }\n+    }\n+\n+    @Override\n+    public int read() throws IOException\n+    {\n+        try (AutoLock lock = _contentLock.lock())", "originalCommit": "c609285694a824207e6f5a0a330bf9942621f524", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMzNTk5OQ==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r384335999", "bodyText": "This code assumes that there will only ever be a single thread entering read() or any other API-exposed method.\nThe reason why HTTP 1 does without locking is that if the above assumption is true, the whole logic can work without locking (at least in my limited analysis), while in the HTTP 2 case, even if the above assumption is true, we still need locking to avoid internal data races.\nFiguring out the exact thread safety requirements of this class is going to be a serious headache. At the moment, my opinion would be to lock all methods in all cases (both HTTP 1 and 2) to have a more common behavior as well as to be on the safe side and work on the thread safety problem in a subsequent refactoring exercise, as just cleaning up the HTTP 1 and 2 logic as well as getting rid of the internal queuing already proves to be quite challenging.", "author": "lorban", "createdAt": "2020-02-26T08:29:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg5MDA5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDM0MDgyNQ==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r384340825", "bodyText": "I agree that h1 and h2 locking should be the same.\nBut I don't think we should give up on working out a correct locking model which may need less locking than a default of lock every method.\nI think we can safely say that two application threads entering read() at the same time is not supported.  So all we need do is to define how our own callbacks interact with app threads calling HttpInput.  That should be doable... because if we don't understand then we will get it wrong one way or another!", "author": "gregw", "createdAt": "2020-02-26T08:40:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg5MDA5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDM0NDEwMQ==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r384344101", "bodyText": "More musings.....\nCurrently the code is written with the assumption that addContent can be called spontaneously at any time (for the h2 case), hence that call makes scheduling decisions and significant state changes within HttpChannelState and it trusts that the caller will respect the boolean return.\nPerhaps in the refactor, calling addContent can no longer happen spontaneously?  Perhaps it can only be called once HttpInput has decided to progress due to other scheduling decisions?  If so then perhaps it should not be making any scheduling decision nor returning a boolean?  Instead perhaps it just throws an ISE if it is not called as expected?", "author": "gregw", "createdAt": "2020-02-26T08:46:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg5MDA5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUyMzgwMw==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r384523803", "bodyText": "Even more musings.....\nDuring the hangout, I made the suggestion that we should try to always have the thread calling read be the one to do the parsing/producing etc.   However this is not really possible for async, even in HTTP/1, because we have to parse the filled buffer before we know if we have content or not, and only then do we go on to call the onDataAvailable callback.   So that in itself in unachievable.... but we can still strive to make h1 and h2 work in the same way.", "author": "gregw", "createdAt": "2020-02-26T14:25:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg5MDA5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTExNDgxMg==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r385114812", "bodyText": "Sync vs async behavior is another pain point this refactoring made apparent. And yet again, my prescription doesn't vary: investigate to completely understand why the model was made this way and eventually modify it.\nLots of fun ahead! :-)", "author": "lorban", "createdAt": "2020-02-27T13:09:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg5MDA5Mw=="}], "type": "inlineReview"}, {"oid": "d4e34d8528dcb0bb684ac87346518d22a625be1f", "url": "https://github.com/eclipse/jetty.project/commit/d4e34d8528dcb0bb684ac87346518d22a625be1f", "message": "FCGI queue and pull model\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-02-27T10:42:37Z", "type": "forcePushed"}, {"oid": "a3c751bb6addcbb11fb15698a0e55c6c66761931", "url": "https://github.com/eclipse/jetty.project/commit/a3c751bb6addcbb11fb15698a0e55c6c66761931", "message": "FCGI queue and pull model, merge all common code between H1, H2 and FCGI (Milestone 4)\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-03-02T16:43:45Z", "type": "forcePushed"}, {"oid": "60727abf3c080925ac2c46c567e5d3648b4d3445", "url": "https://github.com/eclipse/jetty.project/commit/60727abf3c080925ac2c46c567e5d3648b4d3445", "message": "align H2 and H1 addContent mechanisms\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-03-09T13:26:30Z", "type": "forcePushed"}, {"oid": "d86fc553f7d1fe6a5a4fae701cb8e6d942fa1e86", "url": "https://github.com/eclipse/jetty.project/commit/d86fc553f7d1fe6a5a4fae701cb8e6d942fa1e86", "message": "fix race conditions since HttpInputOverHTTP2 doesn't lock anymore\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-03-09T15:30:21Z", "type": "forcePushed"}, {"oid": "fa6df95f923d008fb5ded7138b193ae510eda2be", "url": "https://github.com/eclipse/jetty.project/commit/fa6df95f923d008fb5ded7138b193ae510eda2be", "message": "fix race conditions since HttpInputOverHTTP2 doesn't lock anymore\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-03-09T16:37:22Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTYwMTA5NQ==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r391601095", "bodyText": "add a comment for this assert, that one and only one thread should call unblock and only if we are blocked.", "author": "gregw", "createdAt": "2020-03-12T12:55:55Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpInput.java", "diffHunk": "@@ -190,633 +89,348 @@ public Interceptor getInterceptor()\n      */\n     public void setInterceptor(Interceptor interceptor)\n     {\n-        _interceptor = interceptor;\n+        _contentProducer.setInterceptor(interceptor);\n     }\n \n     /**\n-     * Set the {@link Interceptor}, using a {@link ChainedInterceptor} if\n+     * Set the {@link Interceptor}, chaining it to the existing one if\n      * an {@link Interceptor} is already set.\n      *\n      * @param interceptor the next {@link Interceptor} in a chain\n      */\n     public void addInterceptor(Interceptor interceptor)\n     {\n-        if (_interceptor == null)\n-            _interceptor = interceptor;\n+        Interceptor currentInterceptor = _contentProducer.getInterceptor();\n+        if (currentInterceptor == null)\n+            _contentProducer.setInterceptor(interceptor);\n         else\n-            _interceptor = new ChainedInterceptor(_interceptor, interceptor);\n-    }\n-\n-    @Override\n-    public int available()\n-    {\n-        int available = 0;\n-        boolean woken = false;\n-        synchronized (_inputQ)\n-        {\n-            if (_content == null)\n-                _content = _inputQ.poll();\n-            if (_content == null)\n-            {\n-                try\n-                {\n-                    produceContent();\n-                }\n-                catch (IOException e)\n-                {\n-                    woken = failed(e);\n-                }\n-                if (_content == null)\n-                    _content = _inputQ.poll();\n-            }\n-\n-            if (_content != null)\n-                available = _content.remaining();\n-        }\n-\n-        if (woken)\n-            wake();\n-        return available;\n-    }\n-\n-    protected void wake()\n-    {\n-        HttpChannel channel = _channelState.getHttpChannel();\n-        Executor executor = channel.getConnector().getServer().getThreadPool();\n-        executor.execute(channel);\n-    }\n-\n-    @Override\n-    public int read() throws IOException\n-    {\n-        int read = read(_oneByteBuffer, 0, 1);\n-        if (read == 0)\n-            throw new IllegalStateException(\"unready read=0\");\n-        return read < 0 ? -1 : _oneByteBuffer[0] & 0xFF;\n-    }\n-\n-    @Override\n-    public int read(byte[] b, int off, int len) throws IOException\n-    {\n-        boolean wake = false;\n-        int l;\n-        synchronized (_inputQ)\n-        {\n-            // Calculate minimum request rate for DOS protection\n-            long minRequestDataRate = _channelState.getHttpChannel().getHttpConfiguration().getMinRequestDataRate();\n-            if (minRequestDataRate > 0 && _firstByteTimeStamp != -1)\n-            {\n-                long period = System.nanoTime() - _firstByteTimeStamp;\n-                if (period > 0)\n-                {\n-                    long minimumData = minRequestDataRate * TimeUnit.NANOSECONDS.toMillis(period) / TimeUnit.SECONDS.toMillis(1);\n-                    if (_contentArrived < minimumData)\n-                    {\n-                        BadMessageException bad = new BadMessageException(HttpStatus.REQUEST_TIMEOUT_408,\n-                            String.format(\"Request content data rate < %d B/s\", minRequestDataRate));\n-                        if (_channelState.isResponseCommitted())\n-                            _channelState.getHttpChannel().abort(bad);\n-                        throw bad;\n-                    }\n-                }\n-            }\n-\n-            // Consume content looking for bytes to read\n-            while (true)\n-            {\n-                Content item = nextContent();\n-                if (item != null)\n-                {\n-                    l = get(item, b, off, len);\n-                    if (LOG.isDebugEnabled())\n-                        LOG.debug(\"{} read {} from {}\", this, l, item);\n-\n-                    // Consume any following poison pills\n-                    if (item.isEmpty())\n-                        nextInterceptedContent();\n-                    break;\n-                }\n-\n-                // No content, so should we block?\n-                if (!_state.blockForContent(this))\n-                {\n-                    // Not blocking, so what should we return?\n-                    l = _state.noContent();\n-\n-                    if (l < 0)\n-                        // If EOF do we need to wake for allDataRead callback?\n-                        wake = _channelState.onReadEof();\n-                    break;\n-                }\n-            }\n-        }\n-\n-        if (wake)\n-            wake();\n-        return l;\n+            _contentProducer.setInterceptor(new ChainedInterceptor(currentInterceptor, interceptor));\n     }\n \n     /**\n-     * Called when derived implementations should attempt to produce more Content and add it via {@link #addContent(Content)}. For protocols that are constantly\n-     * producing (eg HTTP2) this can be left as a noop;\n-     *\n-     * @throws IOException if unable to produce content\n+     * Called by channel when asynchronous IO needs to produce more content\n      */\n-    protected void produceContent() throws IOException\n+    public void asyncReadProduce()\n     {\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"asyncReadProduce {}\", _contentProducer);\n+        produceRawContent();\n     }\n \n     /**\n-     * Called by channel when asynchronous IO needs to produce more content\n+     * Adds some content to this input stream.\n      *\n-     * @throws IOException if unable to produce content\n+     * @param content the content to add\n      */\n-    public void asyncReadProduce() throws IOException\n+    public void addContent(Content content)\n     {\n-        synchronized (_inputQ)\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"addContent {} {}\", content, _contentProducer);\n+        if (_firstByteTimeStamp == Long.MIN_VALUE)\n         {\n-            produceContent();\n+            _firstByteTimeStamp = System.nanoTime();\n+            if (_firstByteTimeStamp == Long.MIN_VALUE)\n+                _firstByteTimeStamp++;\n         }\n+        _contentProducer.addContent(content);\n+        if (isAsync())\n+            _channelState.onContentAdded();\n     }\n \n-    /**\n-     * Get the next content from the inputQ, calling {@link #produceContent()} if need be. EOF is processed and state changed.\n-     *\n-     * @return the content or null if none available.\n-     * @throws IOException if retrieving the content fails\n-     */\n-    protected Content nextContent() throws IOException\n+    public boolean hasContent()\n     {\n-        Content content = nextNonSentinelContent();\n-        if (content == null && !isFinished())\n-        {\n-            produceContent();\n-            content = nextNonSentinelContent();\n-        }\n-        return content;\n+        return _contentProducer.hasRawContent();\n     }\n \n-    /**\n-     * Poll the inputQ for Content. Consumed buffers and {@link SentinelContent}s are removed and EOF state updated if need be.\n-     *\n-     * @return Content or null\n-     */\n-    protected Content nextNonSentinelContent()\n+    public void unblock()\n     {\n-        while (true)\n-        {\n-            // Get the next content (or EOF)\n-            Content content = nextInterceptedContent();\n-\n-            // If it is EOF, consume it here\n-            if (content instanceof SentinelContent)\n-            {\n-                // Consume the EOF content, either if it was original content\n-                // or if it was produced by interception\n-                consume(content);\n-                continue;\n-            }\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"signalling blocked thread to wake up\");\n+        if (!isError() && !_eof.isEof() && _semaphore.availablePermits() > 0)", "originalCommit": "743877ce7be889862c63f51350d61e5281f42a66", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTY1NzI4OQ==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r391657289", "bodyText": "That AssertionError was actually missing a message. How about making that this message instead of a comment?", "author": "lorban", "createdAt": "2020-03-12T14:25:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTYwMTA5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTY3MjgyMg==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r391672822", "bodyText": "sure", "author": "gregw", "createdAt": "2020-03-12T14:47:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTYwMTA5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTYwMTk2NA==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r391601964", "bodyText": "Is this actually necessary or is it a safety net?", "author": "gregw", "createdAt": "2020-03-12T12:57:32Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpInput.java", "diffHunk": "@@ -190,633 +89,348 @@ public Interceptor getInterceptor()\n      */\n     public void setInterceptor(Interceptor interceptor)\n     {\n-        _interceptor = interceptor;\n+        _contentProducer.setInterceptor(interceptor);\n     }\n \n     /**\n-     * Set the {@link Interceptor}, using a {@link ChainedInterceptor} if\n+     * Set the {@link Interceptor}, chaining it to the existing one if\n      * an {@link Interceptor} is already set.\n      *\n      * @param interceptor the next {@link Interceptor} in a chain\n      */\n     public void addInterceptor(Interceptor interceptor)\n     {\n-        if (_interceptor == null)\n-            _interceptor = interceptor;\n+        Interceptor currentInterceptor = _contentProducer.getInterceptor();\n+        if (currentInterceptor == null)\n+            _contentProducer.setInterceptor(interceptor);\n         else\n-            _interceptor = new ChainedInterceptor(_interceptor, interceptor);\n-    }\n-\n-    @Override\n-    public int available()\n-    {\n-        int available = 0;\n-        boolean woken = false;\n-        synchronized (_inputQ)\n-        {\n-            if (_content == null)\n-                _content = _inputQ.poll();\n-            if (_content == null)\n-            {\n-                try\n-                {\n-                    produceContent();\n-                }\n-                catch (IOException e)\n-                {\n-                    woken = failed(e);\n-                }\n-                if (_content == null)\n-                    _content = _inputQ.poll();\n-            }\n-\n-            if (_content != null)\n-                available = _content.remaining();\n-        }\n-\n-        if (woken)\n-            wake();\n-        return available;\n-    }\n-\n-    protected void wake()\n-    {\n-        HttpChannel channel = _channelState.getHttpChannel();\n-        Executor executor = channel.getConnector().getServer().getThreadPool();\n-        executor.execute(channel);\n-    }\n-\n-    @Override\n-    public int read() throws IOException\n-    {\n-        int read = read(_oneByteBuffer, 0, 1);\n-        if (read == 0)\n-            throw new IllegalStateException(\"unready read=0\");\n-        return read < 0 ? -1 : _oneByteBuffer[0] & 0xFF;\n-    }\n-\n-    @Override\n-    public int read(byte[] b, int off, int len) throws IOException\n-    {\n-        boolean wake = false;\n-        int l;\n-        synchronized (_inputQ)\n-        {\n-            // Calculate minimum request rate for DOS protection\n-            long minRequestDataRate = _channelState.getHttpChannel().getHttpConfiguration().getMinRequestDataRate();\n-            if (minRequestDataRate > 0 && _firstByteTimeStamp != -1)\n-            {\n-                long period = System.nanoTime() - _firstByteTimeStamp;\n-                if (period > 0)\n-                {\n-                    long minimumData = minRequestDataRate * TimeUnit.NANOSECONDS.toMillis(period) / TimeUnit.SECONDS.toMillis(1);\n-                    if (_contentArrived < minimumData)\n-                    {\n-                        BadMessageException bad = new BadMessageException(HttpStatus.REQUEST_TIMEOUT_408,\n-                            String.format(\"Request content data rate < %d B/s\", minRequestDataRate));\n-                        if (_channelState.isResponseCommitted())\n-                            _channelState.getHttpChannel().abort(bad);\n-                        throw bad;\n-                    }\n-                }\n-            }\n-\n-            // Consume content looking for bytes to read\n-            while (true)\n-            {\n-                Content item = nextContent();\n-                if (item != null)\n-                {\n-                    l = get(item, b, off, len);\n-                    if (LOG.isDebugEnabled())\n-                        LOG.debug(\"{} read {} from {}\", this, l, item);\n-\n-                    // Consume any following poison pills\n-                    if (item.isEmpty())\n-                        nextInterceptedContent();\n-                    break;\n-                }\n-\n-                // No content, so should we block?\n-                if (!_state.blockForContent(this))\n-                {\n-                    // Not blocking, so what should we return?\n-                    l = _state.noContent();\n-\n-                    if (l < 0)\n-                        // If EOF do we need to wake for allDataRead callback?\n-                        wake = _channelState.onReadEof();\n-                    break;\n-                }\n-            }\n-        }\n-\n-        if (wake)\n-            wake();\n-        return l;\n+            _contentProducer.setInterceptor(new ChainedInterceptor(currentInterceptor, interceptor));\n     }\n \n     /**\n-     * Called when derived implementations should attempt to produce more Content and add it via {@link #addContent(Content)}. For protocols that are constantly\n-     * producing (eg HTTP2) this can be left as a noop;\n-     *\n-     * @throws IOException if unable to produce content\n+     * Called by channel when asynchronous IO needs to produce more content\n      */\n-    protected void produceContent() throws IOException\n+    public void asyncReadProduce()\n     {\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"asyncReadProduce {}\", _contentProducer);\n+        produceRawContent();\n     }\n \n     /**\n-     * Called by channel when asynchronous IO needs to produce more content\n+     * Adds some content to this input stream.\n      *\n-     * @throws IOException if unable to produce content\n+     * @param content the content to add\n      */\n-    public void asyncReadProduce() throws IOException\n+    public void addContent(Content content)\n     {\n-        synchronized (_inputQ)\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"addContent {} {}\", content, _contentProducer);\n+        if (_firstByteTimeStamp == Long.MIN_VALUE)\n         {\n-            produceContent();\n+            _firstByteTimeStamp = System.nanoTime();\n+            if (_firstByteTimeStamp == Long.MIN_VALUE)\n+                _firstByteTimeStamp++;\n         }\n+        _contentProducer.addContent(content);\n+        if (isAsync())\n+            _channelState.onContentAdded();\n     }\n \n-    /**\n-     * Get the next content from the inputQ, calling {@link #produceContent()} if need be. EOF is processed and state changed.\n-     *\n-     * @return the content or null if none available.\n-     * @throws IOException if retrieving the content fails\n-     */\n-    protected Content nextContent() throws IOException\n+    public boolean hasContent()\n     {\n-        Content content = nextNonSentinelContent();\n-        if (content == null && !isFinished())\n-        {\n-            produceContent();\n-            content = nextNonSentinelContent();\n-        }\n-        return content;\n+        return _contentProducer.hasRawContent();\n     }\n \n-    /**\n-     * Poll the inputQ for Content. Consumed buffers and {@link SentinelContent}s are removed and EOF state updated if need be.\n-     *\n-     * @return Content or null\n-     */\n-    protected Content nextNonSentinelContent()\n+    public void unblock()\n     {\n-        while (true)\n-        {\n-            // Get the next content (or EOF)\n-            Content content = nextInterceptedContent();\n-\n-            // If it is EOF, consume it here\n-            if (content instanceof SentinelContent)\n-            {\n-                // Consume the EOF content, either if it was original content\n-                // or if it was produced by interception\n-                consume(content);\n-                continue;\n-            }\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"signalling blocked thread to wake up\");\n+        if (!isError() && !_eof.isEof() && _semaphore.availablePermits() > 0)\n+            throw new AssertionError();\n+        _semaphore.release();\n+    }\n \n-            return content;\n-        }\n+    public long getContentLength()\n+    {\n+        return _contentProducer.getRawContentArrived();\n     }\n \n     /**\n-     * Get the next readable from the inputQ, calling {@link #produceContent()} if need be. EOF is NOT processed and state is not changed.\n+     * This method should be called to signal that an EOF has been detected before all the expected content arrived.\n+     * <p>\n+     * Typically this will result in an EOFException being thrown from a subsequent read rather than a -1 return.\n      *\n-     * @return the content or EOF or null if none available.\n-     * @throws IOException if retrieving the content fails\n+     * @return true if content channel woken for read\n      */\n-    protected Content produceNextContext() throws IOException\n+    public boolean earlyEOF()\n     {\n-        Content content = nextInterceptedContent();\n-        if (content == null && !isFinished())\n-        {\n-            produceContent();\n-            content = nextInterceptedContent();\n-        }\n-        return content;\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"received early EOF\");\n+        _eof = Eof.EARLY_EOF;\n+        if (isAsync())\n+            return _channelState.onContentAdded();\n+        unblock();\n+        return false;\n     }\n \n     /**\n-     * Poll the inputQ for Content or EOF. Consumed buffers and non EOF {@link SentinelContent}s are removed. EOF state is not updated.\n-     * Interception is done within this method.\n+     * This method should be called to signal that all the expected content arrived.\n      *\n-     * @return Content with remaining, a {@link SentinelContent},  or null\n+     * @return true if content channel woken for read\n      */\n-    protected Content nextInterceptedContent()\n+    public boolean eof()\n     {\n-        // If we have a chunk produced by interception\n-        if (_intercepted != null)\n-        {\n-            // Use it if it has any remaining content\n-            if (_intercepted.hasContent())\n-                return _intercepted;\n-\n-            // succeed the chunk\n-            _intercepted.succeeded();\n-            _intercepted = null;\n-        }\n-\n-        // If we don't have a Content under consideration, get\n-        // the next one off the input Q.\n-        if (_content == null)\n-            _content = _inputQ.poll();\n-\n-        // While we have content to consider.\n-        while (_content != null)\n-        {\n-            // Are we intercepting?\n-            if (_interceptor != null)\n-            {\n-                // Intercept the current content (may be called several\n-                // times for the same content\n-                _intercepted = _interceptor.readFrom(_content);\n-\n-                // If interception produced new content\n-                if (_intercepted != null && _intercepted != _content)\n-                {\n-                    // if it is not empty use it\n-                    if (_intercepted.hasContent())\n-                        return _intercepted;\n-                    _intercepted.succeeded();\n-                }\n-\n-                // intercepted content consumed\n-                _intercepted = null;\n-\n-                // fall through so that the unintercepted _content is\n-                // considered for any remaining content, for EOF and to\n-                // succeed it if it is entirely consumed.\n-            }\n-\n-            // If the content has content or is an EOF marker, use it\n-            if (_content.hasContent() || _content instanceof SentinelContent)\n-                return _content;\n-\n-            // The content is consumed, so get the next one.  Note that EOF\n-            // content is never consumed here, but in #pollContent\n-            _content.succeeded();\n-            _content = _inputQ.poll();\n-        }\n-\n-        return null;\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"received EOF\");\n+        _eof = Eof.EOF;\n+        if (isAsync())\n+            return _channelState.onContentAdded();\n+        unblock();\n+        return false;\n     }\n \n-    private void consume(Content content)\n+    public boolean consumeAll()\n     {\n-        if (!isError() && content instanceof EofContent)\n-        {\n-            if (content == EARLY_EOF_CONTENT)\n-                _state = EARLY_EOF;\n-            else if (_listener == null)\n-                _state = EOF;\n-            else\n-                _state = AEOF;\n-        }\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"consume all\");\n+        _contentProducer.consumeTransformedContent(this::failRawContent, new IOException(\"Unconsumed content\"));\n+        if (_eof.isEof())\n+            _eof = Eof.CONSUMED_EOF;\n+\n+        if (isFinished())\n+            return !isError();\n \n-        // Consume the content, either if it was original content\n-        // or if it was produced by interception\n-        content.succeeded();\n-        if (_content == content)\n-            _content = null;\n-        else if (_intercepted == content)\n-            _intercepted = null;\n+        _eof = Eof.EARLY_EOF;\n+        return false;\n     }\n \n-    /**\n-     * Copies the given content into the given byte buffer.\n-     *\n-     * @param content the content to copy from\n-     * @param buffer the buffer to copy into\n-     * @param offset the buffer offset to start copying from\n-     * @param length the space available in the buffer\n-     * @return the number of bytes actually copied\n-     */\n-    protected int get(Content content, byte[] buffer, int offset, int length)\n+    public boolean isError()\n     {\n-        int l = content.get(buffer, offset, length);\n-        _contentConsumed += l;\n-        return l;\n+        return _error != null;\n     }\n \n-    /**\n-     * Consumes the given content. Calls the content succeeded if all content consumed.\n-     *\n-     * @param content the content to consume\n-     * @param length the number of bytes to consume\n-     */\n-    protected void skip(Content content, int length)\n+    public boolean isAsync()\n     {\n-        int l = content.skip(length);\n-\n-        _contentConsumed += l;\n-        if (l > 0 && content.isEmpty())\n-            nextNonSentinelContent(); // hungry succeed\n+        return _readListener != null;\n     }\n \n-    /**\n-     * Blocks until some content or some end-of-file event arrives.\n-     *\n-     * @throws IOException if the wait is interrupted\n-     */\n-    protected void blockForContent() throws IOException\n+    public boolean onIdleTimeout(Throwable x)\n     {\n-        try\n-        {\n-            _waitingForContent = true;\n-            _channelState.getHttpChannel().onBlockWaitForContent();\n-\n-            boolean loop = false;\n-            long timeout = 0;\n-            while (true)\n-            {\n-                // This method is called from a loop, so we just\n-                // need to check the timeout before and after waiting.\n-                if (loop)\n-                    break;\n-\n-                if (LOG.isDebugEnabled())\n-                    LOG.debug(\"{} blocking for content timeout={}\", this, timeout);\n-                if (timeout > 0)\n-                    _inputQ.wait(timeout);\n-                else\n-                    _inputQ.wait();\n-\n-                loop = true;\n-            }\n-        }\n-        catch (Throwable x)\n+        boolean neverDispatched = _channelState.isIdle();\n+        boolean waitingForContent = _contentProducer.available(this::produceRawContent) == 0 && !_eof.isEof();\n+        if ((waitingForContent || neverDispatched) && !isError())\n         {\n-            _channelState.getHttpChannel().onBlockWaitForContentFailure(x);\n+            x.addSuppressed(new Throwable(\"HttpInput idle timeout\"));\n+            _error = x;\n+            if (isAsync())\n+                return _channelState.onContentAdded();\n+            unblock();\n         }\n+        return false;\n     }\n \n-    /**\n-     * Adds some content to this input stream.\n-     *\n-     * @param content the content to add\n-     * @return true if content channel woken for read\n-     */\n-    public boolean addContent(Content content)\n+    public boolean failed(Throwable x)\n     {\n-        synchronized (_inputQ)\n-        {\n-            _waitingForContent = false;\n-            if (_firstByteTimeStamp == -1)\n-                _firstByteTimeStamp = System.nanoTime();\n-\n-            if (isFinished())\n-            {\n-                Throwable failure = isError() ? _state.getError() : new EOFException(\"Content after EOF\");\n-                content.failed(failure);\n-                return false;\n-            }\n-            else\n-            {\n-                _contentArrived += content.remaining();\n-\n-                if (_content == null && _inputQ.isEmpty())\n-                    _content = content;\n-                else\n-                    _inputQ.offer(content);\n-\n-                if (LOG.isDebugEnabled())\n-                    LOG.debug(\"{} addContent {}\", this, content);\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"failed \" + x);\n+        if (_error != null && _error != x)\n+            _error.addSuppressed(x);\n+        else\n+            _error = x;\n \n-                if (nextInterceptedContent() != null)\n-                    return wakeup();\n-                else\n-                    return false;\n-            }\n-        }\n+        if (isAsync())\n+            return _channelState.onContentAdded();\n+        unblock();\n+        return false;\n     }\n \n-    public boolean hasContent()\n-    {\n-        synchronized (_inputQ)\n-        {\n-            return _content != null || _inputQ.size() > 0;\n-        }\n-    }\n+    /* ServletInputStream */\n \n-    public void unblock()\n+    @Override\n+    public boolean isFinished()\n     {\n-        synchronized (_inputQ)\n-        {\n-            _inputQ.notify();\n-        }\n+        boolean finished = !_contentProducer.hasRawContent() && _eof.isConsumed();\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"isFinished? {}\", finished);\n+        return finished;\n     }\n \n-    public long getContentConsumed()\n+    @Override\n+    public boolean isReady()\n     {\n-        synchronized (_inputQ)\n+        // calling _contentProducer.available() might change the _eof state, so the following test order matters\n+        if (_contentProducer.available(this::produceRawContent) > 0 || _eof.isEof())\n         {\n-            return _contentConsumed;\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"isReady? true\");\n+            return true;\n         }\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"isReady? false\");\n+        _channelState.onReadUnready();\n+        return false;\n     }\n \n-    /**\n-     * This method should be called to signal that an EOF has been detected before all the expected content arrived.\n-     * <p>\n-     * Typically this will result in an EOFException being thrown from a subsequent read rather than a -1 return.\n-     *\n-     * @return true if content channel woken for read\n-     */\n-    public boolean earlyEOF()\n-    {\n-        return addContent(EARLY_EOF_CONTENT);\n-    }\n-\n-    /**\n-     * This method should be called to signal that all the expected content arrived.\n-     *\n-     * @return true if content channel woken for read\n-     */\n-    public boolean eof()\n+    @Override\n+    public void setReadListener(ReadListener readListener)\n     {\n-        return addContent(EOF_CONTENT);\n-    }\n+        if (_readListener != null)\n+            throw new IllegalStateException(\"ReadListener already set\");\n+        _readListener = Objects.requireNonNull(readListener);\n \n-    public boolean consumeAll()\n-    {\n-        synchronized (_inputQ)\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"setReadListener error=\" + _error + \" eof=\" + _eof + \" \" + _contentProducer);\n+        boolean woken;\n+        if (isError())\n         {\n-            try\n+            woken = _channelState.onReadReady();\n+        }\n+        else\n+        {\n+            if (_contentProducer.available(this::produceRawContent) > 0)\n             {\n-                while (true)\n-                {\n-                    Content item = nextContent();\n-                    if (item == null)\n-                        break; // Let's not bother blocking\n-\n-                    skip(item, item.remaining());\n-                }\n-                if (isFinished())\n-                    return !isError();\n-\n-                _state = EARLY_EOF;\n-                return false;\n+                woken = _channelState.onReadReady();\n+            }\n+            else if (_eof.isEof())\n+            {\n+                woken = _channelState.onReadEof();\n             }\n-            catch (Throwable e)\n+            else\n             {\n-                LOG.debug(e);\n-                _state = new ErrorState(e);\n-                return false;\n+                _channelState.onReadUnready();\n+                woken = false;\n             }\n         }\n-    }\n \n-    public boolean isError()\n-    {\n-        synchronized (_inputQ)\n-        {\n-            return _state instanceof ErrorState;\n-        }\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"setReadListener woken=\" + woken);\n+        if (woken)\n+            scheduleReadListenerNotification();\n     }\n \n-    public boolean isAsync()\n+    private void scheduleReadListenerNotification()\n     {\n-        synchronized (_inputQ)\n-        {\n-            return _state == ASYNC;\n-        }\n+        HttpChannel channel = _channelState.getHttpChannel();\n+        channel.execute(channel);\n     }\n \n     @Override\n-    public boolean isFinished()\n+    public int read() throws IOException\n     {\n-        synchronized (_inputQ)\n-        {\n-            return _state instanceof EOFState;\n-        }\n+        int read = read(_oneByteBuffer, 0, 1);\n+        if (read == 0)\n+            throw new IOException(\"unready read=0\");\n+        return read < 0 ? -1 : _oneByteBuffer[0] & 0xFF;\n     }\n \n     @Override\n-    public boolean isReady()\n+    public int read(byte[] b, int off, int len) throws IOException\n     {\n-        try\n+        // Calculate minimum request rate for DOS protection\n+        long minRequestDataRate = _channelState.getHttpChannel().getHttpConfiguration().getMinRequestDataRate();\n+        if (minRequestDataRate > 0 && _firstByteTimeStamp != Long.MIN_VALUE)\n         {\n-            synchronized (_inputQ)\n+            long period = System.nanoTime() - _firstByteTimeStamp;\n+            if (period > 0)\n             {\n-                if (_listener == null)\n-                    return true;\n-                if (_state instanceof EOFState)\n-                    return true;\n-                if (_waitingForContent)\n-                    return false;\n-                if (produceNextContext() != null)\n-                    return true;\n-                _channelState.onReadUnready();\n-                _waitingForContent = true;\n+                long minimumData = minRequestDataRate * TimeUnit.NANOSECONDS.toMillis(period) / TimeUnit.SECONDS.toMillis(1);\n+                if (_contentProducer.getRawContentArrived() < minimumData)\n+                {\n+                    BadMessageException bad = new BadMessageException(HttpStatus.REQUEST_TIMEOUT_408,\n+                        String.format(\"Request content data rate < %d B/s\", minRequestDataRate));\n+                    if (_channelState.isResponseCommitted())\n+                        _channelState.getHttpChannel().abort(bad);\n+                    throw bad;\n+                }\n             }\n-            return false;\n         }\n-        catch (IOException e)\n-        {\n-            LOG.ignore(e);\n-            return true;\n-        }\n-    }\n \n-    @Override\n-    public void setReadListener(ReadListener readListener)\n-    {\n-        boolean woken = false;\n-        try\n+        while (true)\n         {\n-            synchronized (_inputQ)\n+            _semaphore.drainPermits();", "originalCommit": "743877ce7be889862c63f51350d61e5281f42a66", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTY0Njc1Nw==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r391646757", "bodyText": "It's actually necessary as there are cases when unblock() is called while the thread actually isn't blocked, at least when in HTTP2 the demand() call is served immediately on the same thread.", "author": "lorban", "createdAt": "2020-03-12T14:10:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTYwMTk2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTY3MzMxNg==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r391673316", "bodyText": "I'll get you to talk me through this case.... and then you need to describe in a comment here as well!", "author": "gregw", "createdAt": "2020-03-12T14:48:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTYwMTk2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTYwNDA0MA==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r391604040", "bodyText": "Does this still need the rawContentProducer passed in?", "author": "gregw", "createdAt": "2020-03-12T13:01:21Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpInput.java", "diffHunk": "@@ -825,314 +439,372 @@ private boolean wakeup()\n     @Override\n     public void run()\n     {\n-        final ReadListener listener;\n-        Throwable error;\n-        boolean aeof = false;\n-\n-        synchronized (_inputQ)\n-        {\n-            listener = _listener;\n-\n-            if (_state == EOF)\n-                return;\n-\n-            if (_state == AEOF)\n-            {\n-                _state = EOF;\n-                aeof = true;\n-            }\n-\n-            error = _state.getError();\n-\n-            if (!aeof && error == null)\n-            {\n-                Content content = nextInterceptedContent();\n-                if (content == null)\n-                    return;\n-\n-                // Consume a directly received EOF without first calling onDataAvailable\n-                // So -1 will never be read and only onAddDataRread or onError will be called\n-                if (content instanceof EofContent)\n-                {\n-                    consume(content);\n-                    if (_state == EARLY_EOF)\n-                        error = _state.getError();\n-                    else if (_state == AEOF)\n-                    {\n-                        aeof = true;\n-                        _state = EOF;\n-                    }\n-                }\n-            }\n-        }\n-\n-        try\n+        if (!_contentProducer.hasRawContent())\n         {\n-            if (error != null)\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"running has no raw content; error: {}, EOF = {}\", _error, _eof);\n+            if (_error != null || _eof.isEarly())\n             {\n                 // TODO is this necessary to add here?\n                 _channelState.getHttpChannel().getResponse().getHttpFields().add(HttpConnection.CONNECTION_CLOSE);\n-                listener.onError(error);\n-            }\n-            else if (aeof)\n-            {\n-                listener.onAllDataRead();\n+                if (_error != null)\n+                    _readListener.onError(_error);\n+                else\n+                    _readListener.onError(new EofException(\"Early EOF\"));\n             }\n-            else\n+            else if (_eof.isEof())\n             {\n-                listener.onDataAvailable();\n-                // If -1 was read, then HttpChannelState#onEOF will have been called and a subsequent\n-                // unhandle will call run again so onAllDataRead() can be called.\n+                try\n+                {\n+                    _readListener.onAllDataRead();\n+                }\n+                catch (Throwable x)\n+                {\n+                    if (LOG.isDebugEnabled())\n+                        LOG.debug(\"running failed onAllDataRead\", x);\n+                    _readListener.onError(x);\n+                }\n             }\n+            // else: !hasContent() && !error && !EOF -> no-op\n         }\n-        catch (Throwable e)\n+        else\n         {\n-            LOG.warn(e.toString());\n-            LOG.debug(e);\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"running has raw content\");\n             try\n             {\n-                if (aeof || error == null)\n-                {\n-                    _channelState.getHttpChannel().getResponse().getHttpFields().add(HttpConnection.CONNECTION_CLOSE);\n-                    listener.onError(e);\n-                }\n+                _readListener.onDataAvailable();\n             }\n-            catch (Throwable e2)\n+            catch (Throwable x)\n             {\n-                LOG.warn(e2.toString());\n-                LOG.debug(e2);\n-                throw new RuntimeIOException(e2);\n+                if (LOG.isDebugEnabled())\n+                    LOG.debug(\"running failed onDataAvailable\", x);\n+                _readListener.onError(x);\n             }\n         }\n     }\n \n-    @Override\n-    public String toString()\n+    private void produceRawContent()\n     {\n-        State state;\n-        long consumed;\n-        int q;\n-        Content content;\n-        synchronized (_inputQ)\n-        {\n-            state = _state;\n-            consumed = _contentConsumed;\n-            q = _inputQ.size();\n-            content = _inputQ.peekFirst();\n-        }\n-        return String.format(\"%s@%x[c=%d,q=%d,[0]=%s,s=%s]\",\n-            getClass().getSimpleName(),\n-            hashCode(),\n-            consumed,\n-            q,\n-            content,\n-            state);\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"produceRawContent {}\", _contentProducer);\n+        _channelState.getHttpChannel().produceContent();\n     }\n \n-    /**\n-     * A Sentinel Content, which has zero length content but\n-     * indicates some other event in the input stream (eg EOF)\n-     */\n-    public static class SentinelContent extends Content\n+    private void failRawContent(Throwable failure)\n+    {\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"failRawContent {} - \" + failure, _contentProducer);\n+        _channelState.getHttpChannel().failContent(failure);\n+    }\n+\n+    private enum Eof\n     {\n-        private final String _name;\n+        NOT_YET(false, false, false),\n+        EOF(true, false, false),\n+        CONSUMED_EOF(true, true, false),\n+        EARLY_EOF(true, false, true),\n+        ;\n \n-        public SentinelContent(String name)\n+        private final boolean _eof;\n+        private final boolean _consumed;\n+        private final boolean _early;\n+\n+        Eof(boolean eof, boolean consumed, boolean early)\n         {\n-            super(BufferUtil.EMPTY_BUFFER);\n-            _name = name;\n+            _eof = eof;\n+            _consumed = consumed;\n+            _early = early;\n         }\n \n-        @Override\n-        public String toString()\n+        boolean isEof()\n         {\n-            return _name;\n+            return _eof;\n         }\n-    }\n \n-    public static class EofContent extends SentinelContent\n-    {\n-        EofContent(String name)\n+        boolean isConsumed()\n+        {\n+            return _consumed;\n+        }\n+\n+        boolean isEarly()\n         {\n-            super(name);\n+            return _early;\n         }\n     }\n \n-    public static class Content implements Callback\n+    private static class ContentProducer\n     {\n-        protected final ByteBuffer _content;\n+        // Note: _rawContent can never be null for as long as _transformedContent is not null.\n+        private Content _rawContent;\n+        private Content _transformedContent;\n+        private long _rawContentArrived;\n+        private Interceptor _interceptor;\n+        private Throwable _consumeFailure;\n \n-        public Content(ByteBuffer content)\n+        void recycle()\n         {\n-            _content = content;\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"recycle {}\", this);\n+            if (_transformedContent == _rawContent)\n+                _transformedContent = null;\n+            if (_transformedContent != null && !_transformedContent.isEmpty())\n+                _transformedContent.failed(null);\n+            _transformedContent = null;\n+            if (_rawContent != null && !_rawContent.isEmpty())\n+                _rawContent.failed(null);\n+            _rawContent = null;\n+            _rawContentArrived = 0L;\n+            if (_interceptor instanceof Destroyable)\n+                ((Destroyable)_interceptor).destroy();\n+            _interceptor = null;\n+            _consumeFailure = null;\n         }\n \n-        public ByteBuffer getByteBuffer()\n+        long getRawContentArrived()\n         {\n-            return _content;\n+            return _rawContentArrived;\n         }\n \n-        @Override\n-        public InvocationType getInvocationType()\n+        boolean hasRawContent()\n         {\n-            return InvocationType.NON_BLOCKING;\n+            return _rawContent != null;\n         }\n \n-        public int get(byte[] buffer, int offset, int length)\n+        Interceptor getInterceptor()\n         {\n-            length = Math.min(_content.remaining(), length);\n-            _content.get(buffer, offset, length);\n-            return length;\n+            return _interceptor;\n         }\n \n-        public int skip(int length)\n+        void setInterceptor(Interceptor interceptor)\n         {\n-            length = Math.min(_content.remaining(), length);\n-            _content.position(_content.position() + length);\n-            return length;\n+            this._interceptor = interceptor;\n         }\n \n-        public boolean hasContent()\n+        void addContent(Content content)\n         {\n-            return _content.hasRemaining();\n-        }\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"{} addContent {}\", this, content);\n+            if (content == null)\n+                throw new AssertionError(\"Cannot add null content\");\n+            if (_consumeFailure != null)\n+            {\n+                content.failed(_consumeFailure);\n+                return;\n+            }\n+            if (_rawContent != null)\n+                throw new AssertionError(\"Cannot add new content while current one hasn't been processed\");\n \n-        public int remaining()\n-        {\n-            return _content.remaining();\n+            _rawContent = content;\n+            _rawContentArrived += content.remaining();\n         }\n \n-        public boolean isEmpty()\n+        void consumeTransformedContent(Consumer<Throwable> failRawContent, Throwable failure)\n         {\n-            return !_content.hasRemaining();\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"{} consumeTransformedContent\", this);\n+            // start by depleting the current _transformedContent\n+            if (_transformedContent != null)\n+            {\n+                _transformedContent.skip(_transformedContent.remaining());\n+                if (_transformedContent != _rawContent)\n+                    _transformedContent.succeeded();\n+                _transformedContent = null;\n+            }\n+\n+            // don't bother transforming content, directly deplete the raw one\n+            if (_rawContent != null)\n+            {\n+                _rawContent.skip(_rawContent.remaining());\n+                _rawContent.succeeded();\n+                _rawContent = null;\n+            }\n+\n+            // fail whatever other content the producer may have\n+            _consumeFailure = failure;\n+            failRawContent.accept(failure);\n         }\n \n-        @Override\n-        public String toString()\n+        int available(Runnable rawContentProducer)", "originalCommit": "743877ce7be889862c63f51350d61e5281f42a66", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTY0NzU1NQ==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r391647555", "bodyText": "It's that or making ContentProducer non-static. I personally prefer keeping it static but I'm not married to that idea.", "author": "lorban", "createdAt": "2020-03-12T14:11:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTYwNDA0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTYwNDM2OQ==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r391604369", "bodyText": "Does this still need the rawContentProducer passed in?", "author": "gregw", "createdAt": "2020-03-12T13:02:00Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpInput.java", "diffHunk": "@@ -825,314 +439,372 @@ private boolean wakeup()\n     @Override\n     public void run()\n     {\n-        final ReadListener listener;\n-        Throwable error;\n-        boolean aeof = false;\n-\n-        synchronized (_inputQ)\n-        {\n-            listener = _listener;\n-\n-            if (_state == EOF)\n-                return;\n-\n-            if (_state == AEOF)\n-            {\n-                _state = EOF;\n-                aeof = true;\n-            }\n-\n-            error = _state.getError();\n-\n-            if (!aeof && error == null)\n-            {\n-                Content content = nextInterceptedContent();\n-                if (content == null)\n-                    return;\n-\n-                // Consume a directly received EOF without first calling onDataAvailable\n-                // So -1 will never be read and only onAddDataRread or onError will be called\n-                if (content instanceof EofContent)\n-                {\n-                    consume(content);\n-                    if (_state == EARLY_EOF)\n-                        error = _state.getError();\n-                    else if (_state == AEOF)\n-                    {\n-                        aeof = true;\n-                        _state = EOF;\n-                    }\n-                }\n-            }\n-        }\n-\n-        try\n+        if (!_contentProducer.hasRawContent())\n         {\n-            if (error != null)\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"running has no raw content; error: {}, EOF = {}\", _error, _eof);\n+            if (_error != null || _eof.isEarly())\n             {\n                 // TODO is this necessary to add here?\n                 _channelState.getHttpChannel().getResponse().getHttpFields().add(HttpConnection.CONNECTION_CLOSE);\n-                listener.onError(error);\n-            }\n-            else if (aeof)\n-            {\n-                listener.onAllDataRead();\n+                if (_error != null)\n+                    _readListener.onError(_error);\n+                else\n+                    _readListener.onError(new EofException(\"Early EOF\"));\n             }\n-            else\n+            else if (_eof.isEof())\n             {\n-                listener.onDataAvailable();\n-                // If -1 was read, then HttpChannelState#onEOF will have been called and a subsequent\n-                // unhandle will call run again so onAllDataRead() can be called.\n+                try\n+                {\n+                    _readListener.onAllDataRead();\n+                }\n+                catch (Throwable x)\n+                {\n+                    if (LOG.isDebugEnabled())\n+                        LOG.debug(\"running failed onAllDataRead\", x);\n+                    _readListener.onError(x);\n+                }\n             }\n+            // else: !hasContent() && !error && !EOF -> no-op\n         }\n-        catch (Throwable e)\n+        else\n         {\n-            LOG.warn(e.toString());\n-            LOG.debug(e);\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"running has raw content\");\n             try\n             {\n-                if (aeof || error == null)\n-                {\n-                    _channelState.getHttpChannel().getResponse().getHttpFields().add(HttpConnection.CONNECTION_CLOSE);\n-                    listener.onError(e);\n-                }\n+                _readListener.onDataAvailable();\n             }\n-            catch (Throwable e2)\n+            catch (Throwable x)\n             {\n-                LOG.warn(e2.toString());\n-                LOG.debug(e2);\n-                throw new RuntimeIOException(e2);\n+                if (LOG.isDebugEnabled())\n+                    LOG.debug(\"running failed onDataAvailable\", x);\n+                _readListener.onError(x);\n             }\n         }\n     }\n \n-    @Override\n-    public String toString()\n+    private void produceRawContent()\n     {\n-        State state;\n-        long consumed;\n-        int q;\n-        Content content;\n-        synchronized (_inputQ)\n-        {\n-            state = _state;\n-            consumed = _contentConsumed;\n-            q = _inputQ.size();\n-            content = _inputQ.peekFirst();\n-        }\n-        return String.format(\"%s@%x[c=%d,q=%d,[0]=%s,s=%s]\",\n-            getClass().getSimpleName(),\n-            hashCode(),\n-            consumed,\n-            q,\n-            content,\n-            state);\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"produceRawContent {}\", _contentProducer);\n+        _channelState.getHttpChannel().produceContent();\n     }\n \n-    /**\n-     * A Sentinel Content, which has zero length content but\n-     * indicates some other event in the input stream (eg EOF)\n-     */\n-    public static class SentinelContent extends Content\n+    private void failRawContent(Throwable failure)\n+    {\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"failRawContent {} - \" + failure, _contentProducer);\n+        _channelState.getHttpChannel().failContent(failure);\n+    }\n+\n+    private enum Eof\n     {\n-        private final String _name;\n+        NOT_YET(false, false, false),\n+        EOF(true, false, false),\n+        CONSUMED_EOF(true, true, false),\n+        EARLY_EOF(true, false, true),\n+        ;\n \n-        public SentinelContent(String name)\n+        private final boolean _eof;\n+        private final boolean _consumed;\n+        private final boolean _early;\n+\n+        Eof(boolean eof, boolean consumed, boolean early)\n         {\n-            super(BufferUtil.EMPTY_BUFFER);\n-            _name = name;\n+            _eof = eof;\n+            _consumed = consumed;\n+            _early = early;\n         }\n \n-        @Override\n-        public String toString()\n+        boolean isEof()\n         {\n-            return _name;\n+            return _eof;\n         }\n-    }\n \n-    public static class EofContent extends SentinelContent\n-    {\n-        EofContent(String name)\n+        boolean isConsumed()\n+        {\n+            return _consumed;\n+        }\n+\n+        boolean isEarly()\n         {\n-            super(name);\n+            return _early;\n         }\n     }\n \n-    public static class Content implements Callback\n+    private static class ContentProducer\n     {\n-        protected final ByteBuffer _content;\n+        // Note: _rawContent can never be null for as long as _transformedContent is not null.\n+        private Content _rawContent;\n+        private Content _transformedContent;\n+        private long _rawContentArrived;\n+        private Interceptor _interceptor;\n+        private Throwable _consumeFailure;\n \n-        public Content(ByteBuffer content)\n+        void recycle()\n         {\n-            _content = content;\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"recycle {}\", this);\n+            if (_transformedContent == _rawContent)\n+                _transformedContent = null;\n+            if (_transformedContent != null && !_transformedContent.isEmpty())\n+                _transformedContent.failed(null);\n+            _transformedContent = null;\n+            if (_rawContent != null && !_rawContent.isEmpty())\n+                _rawContent.failed(null);\n+            _rawContent = null;\n+            _rawContentArrived = 0L;\n+            if (_interceptor instanceof Destroyable)\n+                ((Destroyable)_interceptor).destroy();\n+            _interceptor = null;\n+            _consumeFailure = null;\n         }\n \n-        public ByteBuffer getByteBuffer()\n+        long getRawContentArrived()\n         {\n-            return _content;\n+            return _rawContentArrived;\n         }\n \n-        @Override\n-        public InvocationType getInvocationType()\n+        boolean hasRawContent()\n         {\n-            return InvocationType.NON_BLOCKING;\n+            return _rawContent != null;\n         }\n \n-        public int get(byte[] buffer, int offset, int length)\n+        Interceptor getInterceptor()\n         {\n-            length = Math.min(_content.remaining(), length);\n-            _content.get(buffer, offset, length);\n-            return length;\n+            return _interceptor;\n         }\n \n-        public int skip(int length)\n+        void setInterceptor(Interceptor interceptor)\n         {\n-            length = Math.min(_content.remaining(), length);\n-            _content.position(_content.position() + length);\n-            return length;\n+            this._interceptor = interceptor;\n         }\n \n-        public boolean hasContent()\n+        void addContent(Content content)\n         {\n-            return _content.hasRemaining();\n-        }\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"{} addContent {}\", this, content);\n+            if (content == null)\n+                throw new AssertionError(\"Cannot add null content\");\n+            if (_consumeFailure != null)\n+            {\n+                content.failed(_consumeFailure);\n+                return;\n+            }\n+            if (_rawContent != null)\n+                throw new AssertionError(\"Cannot add new content while current one hasn't been processed\");\n \n-        public int remaining()\n-        {\n-            return _content.remaining();\n+            _rawContent = content;\n+            _rawContentArrived += content.remaining();\n         }\n \n-        public boolean isEmpty()\n+        void consumeTransformedContent(Consumer<Throwable> failRawContent, Throwable failure)\n         {\n-            return !_content.hasRemaining();\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"{} consumeTransformedContent\", this);\n+            // start by depleting the current _transformedContent\n+            if (_transformedContent != null)\n+            {\n+                _transformedContent.skip(_transformedContent.remaining());\n+                if (_transformedContent != _rawContent)\n+                    _transformedContent.succeeded();\n+                _transformedContent = null;\n+            }\n+\n+            // don't bother transforming content, directly deplete the raw one\n+            if (_rawContent != null)\n+            {\n+                _rawContent.skip(_rawContent.remaining());\n+                _rawContent.succeeded();\n+                _rawContent = null;\n+            }\n+\n+            // fail whatever other content the producer may have\n+            _consumeFailure = failure;\n+            failRawContent.accept(failure);\n         }\n \n-        @Override\n-        public String toString()\n+        int available(Runnable rawContentProducer)\n         {\n-            return String.format(\"Content@%x{%s}\", hashCode(), BufferUtil.toDetailString(_content));\n+            Content content = nextNonEmptyContent(rawContentProducer);\n+            return content == null ? 0 : content.remaining();\n         }\n-    }\n \n-    protected abstract static class State\n-    {\n-        public boolean blockForContent(HttpInput in) throws IOException\n+        int read(Runnable rawContentProducer, byte[] b, int off, int len)\n         {\n-            return false;\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"{} read\", this);\n+            Content content = nextNonEmptyContent(rawContentProducer);\n+            return content == null ? 0 : content.get(b, off, len);\n         }\n \n-        public int noContent() throws IOException\n+        private Content nextNonEmptyContent(Runnable rawContentProducer)", "originalCommit": "743877ce7be889862c63f51350d61e5281f42a66", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTY0Nzc0MA==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r391647740", "bodyText": "Same as above.", "author": "lorban", "createdAt": "2020-03-12T14:11:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTYwNDM2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTYxMTQxNw==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r391611417", "bodyText": "This assignment needs to be done before the scheduleReadListenerNotification to avoid a race.", "author": "gregw", "createdAt": "2020-03-12T13:14:44Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpInput.java", "diffHunk": "@@ -190,633 +89,348 @@ public Interceptor getInterceptor()\n      */\n     public void setInterceptor(Interceptor interceptor)\n     {\n-        _interceptor = interceptor;\n+        _contentProducer.setInterceptor(interceptor);\n     }\n \n     /**\n-     * Set the {@link Interceptor}, using a {@link ChainedInterceptor} if\n+     * Set the {@link Interceptor}, chaining it to the existing one if\n      * an {@link Interceptor} is already set.\n      *\n      * @param interceptor the next {@link Interceptor} in a chain\n      */\n     public void addInterceptor(Interceptor interceptor)\n     {\n-        if (_interceptor == null)\n-            _interceptor = interceptor;\n+        Interceptor currentInterceptor = _contentProducer.getInterceptor();\n+        if (currentInterceptor == null)\n+            _contentProducer.setInterceptor(interceptor);\n         else\n-            _interceptor = new ChainedInterceptor(_interceptor, interceptor);\n-    }\n-\n-    @Override\n-    public int available()\n-    {\n-        int available = 0;\n-        boolean woken = false;\n-        synchronized (_inputQ)\n-        {\n-            if (_content == null)\n-                _content = _inputQ.poll();\n-            if (_content == null)\n-            {\n-                try\n-                {\n-                    produceContent();\n-                }\n-                catch (IOException e)\n-                {\n-                    woken = failed(e);\n-                }\n-                if (_content == null)\n-                    _content = _inputQ.poll();\n-            }\n-\n-            if (_content != null)\n-                available = _content.remaining();\n-        }\n-\n-        if (woken)\n-            wake();\n-        return available;\n-    }\n-\n-    protected void wake()\n-    {\n-        HttpChannel channel = _channelState.getHttpChannel();\n-        Executor executor = channel.getConnector().getServer().getThreadPool();\n-        executor.execute(channel);\n-    }\n-\n-    @Override\n-    public int read() throws IOException\n-    {\n-        int read = read(_oneByteBuffer, 0, 1);\n-        if (read == 0)\n-            throw new IllegalStateException(\"unready read=0\");\n-        return read < 0 ? -1 : _oneByteBuffer[0] & 0xFF;\n-    }\n-\n-    @Override\n-    public int read(byte[] b, int off, int len) throws IOException\n-    {\n-        boolean wake = false;\n-        int l;\n-        synchronized (_inputQ)\n-        {\n-            // Calculate minimum request rate for DOS protection\n-            long minRequestDataRate = _channelState.getHttpChannel().getHttpConfiguration().getMinRequestDataRate();\n-            if (minRequestDataRate > 0 && _firstByteTimeStamp != -1)\n-            {\n-                long period = System.nanoTime() - _firstByteTimeStamp;\n-                if (period > 0)\n-                {\n-                    long minimumData = minRequestDataRate * TimeUnit.NANOSECONDS.toMillis(period) / TimeUnit.SECONDS.toMillis(1);\n-                    if (_contentArrived < minimumData)\n-                    {\n-                        BadMessageException bad = new BadMessageException(HttpStatus.REQUEST_TIMEOUT_408,\n-                            String.format(\"Request content data rate < %d B/s\", minRequestDataRate));\n-                        if (_channelState.isResponseCommitted())\n-                            _channelState.getHttpChannel().abort(bad);\n-                        throw bad;\n-                    }\n-                }\n-            }\n-\n-            // Consume content looking for bytes to read\n-            while (true)\n-            {\n-                Content item = nextContent();\n-                if (item != null)\n-                {\n-                    l = get(item, b, off, len);\n-                    if (LOG.isDebugEnabled())\n-                        LOG.debug(\"{} read {} from {}\", this, l, item);\n-\n-                    // Consume any following poison pills\n-                    if (item.isEmpty())\n-                        nextInterceptedContent();\n-                    break;\n-                }\n-\n-                // No content, so should we block?\n-                if (!_state.blockForContent(this))\n-                {\n-                    // Not blocking, so what should we return?\n-                    l = _state.noContent();\n-\n-                    if (l < 0)\n-                        // If EOF do we need to wake for allDataRead callback?\n-                        wake = _channelState.onReadEof();\n-                    break;\n-                }\n-            }\n-        }\n-\n-        if (wake)\n-            wake();\n-        return l;\n+            _contentProducer.setInterceptor(new ChainedInterceptor(currentInterceptor, interceptor));\n     }\n \n     /**\n-     * Called when derived implementations should attempt to produce more Content and add it via {@link #addContent(Content)}. For protocols that are constantly\n-     * producing (eg HTTP2) this can be left as a noop;\n-     *\n-     * @throws IOException if unable to produce content\n+     * Called by channel when asynchronous IO needs to produce more content\n      */\n-    protected void produceContent() throws IOException\n+    public void asyncReadProduce()\n     {\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"asyncReadProduce {}\", _contentProducer);\n+        produceRawContent();\n     }\n \n     /**\n-     * Called by channel when asynchronous IO needs to produce more content\n+     * Adds some content to this input stream.\n      *\n-     * @throws IOException if unable to produce content\n+     * @param content the content to add\n      */\n-    public void asyncReadProduce() throws IOException\n+    public void addContent(Content content)\n     {\n-        synchronized (_inputQ)\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"addContent {} {}\", content, _contentProducer);\n+        if (_firstByteTimeStamp == Long.MIN_VALUE)\n         {\n-            produceContent();\n+            _firstByteTimeStamp = System.nanoTime();\n+            if (_firstByteTimeStamp == Long.MIN_VALUE)\n+                _firstByteTimeStamp++;\n         }\n+        _contentProducer.addContent(content);\n+        if (isAsync())\n+            _channelState.onContentAdded();\n     }\n \n-    /**\n-     * Get the next content from the inputQ, calling {@link #produceContent()} if need be. EOF is processed and state changed.\n-     *\n-     * @return the content or null if none available.\n-     * @throws IOException if retrieving the content fails\n-     */\n-    protected Content nextContent() throws IOException\n+    public boolean hasContent()\n     {\n-        Content content = nextNonSentinelContent();\n-        if (content == null && !isFinished())\n-        {\n-            produceContent();\n-            content = nextNonSentinelContent();\n-        }\n-        return content;\n+        return _contentProducer.hasRawContent();\n     }\n \n-    /**\n-     * Poll the inputQ for Content. Consumed buffers and {@link SentinelContent}s are removed and EOF state updated if need be.\n-     *\n-     * @return Content or null\n-     */\n-    protected Content nextNonSentinelContent()\n+    public void unblock()\n     {\n-        while (true)\n-        {\n-            // Get the next content (or EOF)\n-            Content content = nextInterceptedContent();\n-\n-            // If it is EOF, consume it here\n-            if (content instanceof SentinelContent)\n-            {\n-                // Consume the EOF content, either if it was original content\n-                // or if it was produced by interception\n-                consume(content);\n-                continue;\n-            }\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"signalling blocked thread to wake up\");\n+        if (!isError() && !_eof.isEof() && _semaphore.availablePermits() > 0)\n+            throw new AssertionError();\n+        _semaphore.release();\n+    }\n \n-            return content;\n-        }\n+    public long getContentLength()\n+    {\n+        return _contentProducer.getRawContentArrived();\n     }\n \n     /**\n-     * Get the next readable from the inputQ, calling {@link #produceContent()} if need be. EOF is NOT processed and state is not changed.\n+     * This method should be called to signal that an EOF has been detected before all the expected content arrived.\n+     * <p>\n+     * Typically this will result in an EOFException being thrown from a subsequent read rather than a -1 return.\n      *\n-     * @return the content or EOF or null if none available.\n-     * @throws IOException if retrieving the content fails\n+     * @return true if content channel woken for read\n      */\n-    protected Content produceNextContext() throws IOException\n+    public boolean earlyEOF()\n     {\n-        Content content = nextInterceptedContent();\n-        if (content == null && !isFinished())\n-        {\n-            produceContent();\n-            content = nextInterceptedContent();\n-        }\n-        return content;\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"received early EOF\");\n+        _eof = Eof.EARLY_EOF;\n+        if (isAsync())\n+            return _channelState.onContentAdded();\n+        unblock();\n+        return false;\n     }\n \n     /**\n-     * Poll the inputQ for Content or EOF. Consumed buffers and non EOF {@link SentinelContent}s are removed. EOF state is not updated.\n-     * Interception is done within this method.\n+     * This method should be called to signal that all the expected content arrived.\n      *\n-     * @return Content with remaining, a {@link SentinelContent},  or null\n+     * @return true if content channel woken for read\n      */\n-    protected Content nextInterceptedContent()\n+    public boolean eof()\n     {\n-        // If we have a chunk produced by interception\n-        if (_intercepted != null)\n-        {\n-            // Use it if it has any remaining content\n-            if (_intercepted.hasContent())\n-                return _intercepted;\n-\n-            // succeed the chunk\n-            _intercepted.succeeded();\n-            _intercepted = null;\n-        }\n-\n-        // If we don't have a Content under consideration, get\n-        // the next one off the input Q.\n-        if (_content == null)\n-            _content = _inputQ.poll();\n-\n-        // While we have content to consider.\n-        while (_content != null)\n-        {\n-            // Are we intercepting?\n-            if (_interceptor != null)\n-            {\n-                // Intercept the current content (may be called several\n-                // times for the same content\n-                _intercepted = _interceptor.readFrom(_content);\n-\n-                // If interception produced new content\n-                if (_intercepted != null && _intercepted != _content)\n-                {\n-                    // if it is not empty use it\n-                    if (_intercepted.hasContent())\n-                        return _intercepted;\n-                    _intercepted.succeeded();\n-                }\n-\n-                // intercepted content consumed\n-                _intercepted = null;\n-\n-                // fall through so that the unintercepted _content is\n-                // considered for any remaining content, for EOF and to\n-                // succeed it if it is entirely consumed.\n-            }\n-\n-            // If the content has content or is an EOF marker, use it\n-            if (_content.hasContent() || _content instanceof SentinelContent)\n-                return _content;\n-\n-            // The content is consumed, so get the next one.  Note that EOF\n-            // content is never consumed here, but in #pollContent\n-            _content.succeeded();\n-            _content = _inputQ.poll();\n-        }\n-\n-        return null;\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"received EOF\");\n+        _eof = Eof.EOF;\n+        if (isAsync())\n+            return _channelState.onContentAdded();\n+        unblock();\n+        return false;\n     }\n \n-    private void consume(Content content)\n+    public boolean consumeAll()\n     {\n-        if (!isError() && content instanceof EofContent)\n-        {\n-            if (content == EARLY_EOF_CONTENT)\n-                _state = EARLY_EOF;\n-            else if (_listener == null)\n-                _state = EOF;\n-            else\n-                _state = AEOF;\n-        }\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"consume all\");\n+        _contentProducer.consumeTransformedContent(this::failRawContent, new IOException(\"Unconsumed content\"));\n+        if (_eof.isEof())\n+            _eof = Eof.CONSUMED_EOF;\n+\n+        if (isFinished())\n+            return !isError();\n \n-        // Consume the content, either if it was original content\n-        // or if it was produced by interception\n-        content.succeeded();\n-        if (_content == content)\n-            _content = null;\n-        else if (_intercepted == content)\n-            _intercepted = null;\n+        _eof = Eof.EARLY_EOF;\n+        return false;\n     }\n \n-    /**\n-     * Copies the given content into the given byte buffer.\n-     *\n-     * @param content the content to copy from\n-     * @param buffer the buffer to copy into\n-     * @param offset the buffer offset to start copying from\n-     * @param length the space available in the buffer\n-     * @return the number of bytes actually copied\n-     */\n-    protected int get(Content content, byte[] buffer, int offset, int length)\n+    public boolean isError()\n     {\n-        int l = content.get(buffer, offset, length);\n-        _contentConsumed += l;\n-        return l;\n+        return _error != null;\n     }\n \n-    /**\n-     * Consumes the given content. Calls the content succeeded if all content consumed.\n-     *\n-     * @param content the content to consume\n-     * @param length the number of bytes to consume\n-     */\n-    protected void skip(Content content, int length)\n+    public boolean isAsync()\n     {\n-        int l = content.skip(length);\n-\n-        _contentConsumed += l;\n-        if (l > 0 && content.isEmpty())\n-            nextNonSentinelContent(); // hungry succeed\n+        return _readListener != null;\n     }\n \n-    /**\n-     * Blocks until some content or some end-of-file event arrives.\n-     *\n-     * @throws IOException if the wait is interrupted\n-     */\n-    protected void blockForContent() throws IOException\n+    public boolean onIdleTimeout(Throwable x)\n     {\n-        try\n-        {\n-            _waitingForContent = true;\n-            _channelState.getHttpChannel().onBlockWaitForContent();\n-\n-            boolean loop = false;\n-            long timeout = 0;\n-            while (true)\n-            {\n-                // This method is called from a loop, so we just\n-                // need to check the timeout before and after waiting.\n-                if (loop)\n-                    break;\n-\n-                if (LOG.isDebugEnabled())\n-                    LOG.debug(\"{} blocking for content timeout={}\", this, timeout);\n-                if (timeout > 0)\n-                    _inputQ.wait(timeout);\n-                else\n-                    _inputQ.wait();\n-\n-                loop = true;\n-            }\n-        }\n-        catch (Throwable x)\n+        boolean neverDispatched = _channelState.isIdle();\n+        boolean waitingForContent = _contentProducer.available(this::produceRawContent) == 0 && !_eof.isEof();\n+        if ((waitingForContent || neverDispatched) && !isError())\n         {\n-            _channelState.getHttpChannel().onBlockWaitForContentFailure(x);\n+            x.addSuppressed(new Throwable(\"HttpInput idle timeout\"));\n+            _error = x;\n+            if (isAsync())\n+                return _channelState.onContentAdded();\n+            unblock();\n         }\n+        return false;\n     }\n \n-    /**\n-     * Adds some content to this input stream.\n-     *\n-     * @param content the content to add\n-     * @return true if content channel woken for read\n-     */\n-    public boolean addContent(Content content)\n+    public boolean failed(Throwable x)\n     {\n-        synchronized (_inputQ)\n-        {\n-            _waitingForContent = false;\n-            if (_firstByteTimeStamp == -1)\n-                _firstByteTimeStamp = System.nanoTime();\n-\n-            if (isFinished())\n-            {\n-                Throwable failure = isError() ? _state.getError() : new EOFException(\"Content after EOF\");\n-                content.failed(failure);\n-                return false;\n-            }\n-            else\n-            {\n-                _contentArrived += content.remaining();\n-\n-                if (_content == null && _inputQ.isEmpty())\n-                    _content = content;\n-                else\n-                    _inputQ.offer(content);\n-\n-                if (LOG.isDebugEnabled())\n-                    LOG.debug(\"{} addContent {}\", this, content);\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"failed \" + x);\n+        if (_error != null && _error != x)\n+            _error.addSuppressed(x);\n+        else\n+            _error = x;\n \n-                if (nextInterceptedContent() != null)\n-                    return wakeup();\n-                else\n-                    return false;\n-            }\n-        }\n+        if (isAsync())\n+            return _channelState.onContentAdded();\n+        unblock();\n+        return false;\n     }\n \n-    public boolean hasContent()\n-    {\n-        synchronized (_inputQ)\n-        {\n-            return _content != null || _inputQ.size() > 0;\n-        }\n-    }\n+    /* ServletInputStream */\n \n-    public void unblock()\n+    @Override\n+    public boolean isFinished()\n     {\n-        synchronized (_inputQ)\n-        {\n-            _inputQ.notify();\n-        }\n+        boolean finished = !_contentProducer.hasRawContent() && _eof.isConsumed();\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"isFinished? {}\", finished);\n+        return finished;\n     }\n \n-    public long getContentConsumed()\n+    @Override\n+    public boolean isReady()\n     {\n-        synchronized (_inputQ)\n+        // calling _contentProducer.available() might change the _eof state, so the following test order matters\n+        if (_contentProducer.available(this::produceRawContent) > 0 || _eof.isEof())\n         {\n-            return _contentConsumed;\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"isReady? true\");\n+            return true;\n         }\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"isReady? false\");\n+        _channelState.onReadUnready();\n+        return false;\n     }\n \n-    /**\n-     * This method should be called to signal that an EOF has been detected before all the expected content arrived.\n-     * <p>\n-     * Typically this will result in an EOFException being thrown from a subsequent read rather than a -1 return.\n-     *\n-     * @return true if content channel woken for read\n-     */\n-    public boolean earlyEOF()\n-    {\n-        return addContent(EARLY_EOF_CONTENT);\n-    }\n-\n-    /**\n-     * This method should be called to signal that all the expected content arrived.\n-     *\n-     * @return true if content channel woken for read\n-     */\n-    public boolean eof()\n+    @Override\n+    public void setReadListener(ReadListener readListener)\n     {\n-        return addContent(EOF_CONTENT);\n-    }\n+        if (_readListener != null)\n+            throw new IllegalStateException(\"ReadListener already set\");\n+        _readListener = Objects.requireNonNull(readListener);\n \n-    public boolean consumeAll()\n-    {\n-        synchronized (_inputQ)\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"setReadListener error=\" + _error + \" eof=\" + _eof + \" \" + _contentProducer);\n+        boolean woken;\n+        if (isError())\n         {\n-            try\n+            woken = _channelState.onReadReady();\n+        }\n+        else\n+        {\n+            if (_contentProducer.available(this::produceRawContent) > 0)\n             {\n-                while (true)\n-                {\n-                    Content item = nextContent();\n-                    if (item == null)\n-                        break; // Let's not bother blocking\n-\n-                    skip(item, item.remaining());\n-                }\n-                if (isFinished())\n-                    return !isError();\n-\n-                _state = EARLY_EOF;\n-                return false;\n+                woken = _channelState.onReadReady();\n+            }\n+            else if (_eof.isEof())\n+            {\n+                woken = _channelState.onReadEof();\n             }\n-            catch (Throwable e)\n+            else\n             {\n-                LOG.debug(e);\n-                _state = new ErrorState(e);\n-                return false;\n+                _channelState.onReadUnready();\n+                woken = false;\n             }\n         }\n-    }\n \n-    public boolean isError()\n-    {\n-        synchronized (_inputQ)\n-        {\n-            return _state instanceof ErrorState;\n-        }\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"setReadListener woken=\" + woken);\n+        if (woken)\n+            scheduleReadListenerNotification();\n     }\n \n-    public boolean isAsync()\n+    private void scheduleReadListenerNotification()\n     {\n-        synchronized (_inputQ)\n-        {\n-            return _state == ASYNC;\n-        }\n+        HttpChannel channel = _channelState.getHttpChannel();\n+        channel.execute(channel);\n     }\n \n     @Override\n-    public boolean isFinished()\n+    public int read() throws IOException\n     {\n-        synchronized (_inputQ)\n-        {\n-            return _state instanceof EOFState;\n-        }\n+        int read = read(_oneByteBuffer, 0, 1);\n+        if (read == 0)\n+            throw new IOException(\"unready read=0\");\n+        return read < 0 ? -1 : _oneByteBuffer[0] & 0xFF;\n     }\n \n     @Override\n-    public boolean isReady()\n+    public int read(byte[] b, int off, int len) throws IOException\n     {\n-        try\n+        // Calculate minimum request rate for DOS protection\n+        long minRequestDataRate = _channelState.getHttpChannel().getHttpConfiguration().getMinRequestDataRate();\n+        if (minRequestDataRate > 0 && _firstByteTimeStamp != Long.MIN_VALUE)\n         {\n-            synchronized (_inputQ)\n+            long period = System.nanoTime() - _firstByteTimeStamp;\n+            if (period > 0)\n             {\n-                if (_listener == null)\n-                    return true;\n-                if (_state instanceof EOFState)\n-                    return true;\n-                if (_waitingForContent)\n-                    return false;\n-                if (produceNextContext() != null)\n-                    return true;\n-                _channelState.onReadUnready();\n-                _waitingForContent = true;\n+                long minimumData = minRequestDataRate * TimeUnit.NANOSECONDS.toMillis(period) / TimeUnit.SECONDS.toMillis(1);\n+                if (_contentProducer.getRawContentArrived() < minimumData)\n+                {\n+                    BadMessageException bad = new BadMessageException(HttpStatus.REQUEST_TIMEOUT_408,\n+                        String.format(\"Request content data rate < %d B/s\", minRequestDataRate));\n+                    if (_channelState.isResponseCommitted())\n+                        _channelState.getHttpChannel().abort(bad);\n+                    throw bad;\n+                }\n             }\n-            return false;\n         }\n-        catch (IOException e)\n-        {\n-            LOG.ignore(e);\n-            return true;\n-        }\n-    }\n \n-    @Override\n-    public void setReadListener(ReadListener readListener)\n-    {\n-        boolean woken = false;\n-        try\n+        while (true)\n         {\n-            synchronized (_inputQ)\n+            _semaphore.drainPermits();\n+            int read = _contentProducer.read(this::produceRawContent, b, off, len);\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"read produced {} byte(s)\", read);\n+            if (read > 0)\n+                return read;\n+\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"read error = \" + _error);\n+            if (_error != null)\n+                throw new IOException(_error);\n+\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"read EOF = {}\", _eof);\n+            if (_eof.isEarly())\n+                throw new EofException(\"Early EOF\");\n+\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"read async = {}\", isAsync());\n+            if (!isAsync())\n             {\n-                if (_listener != null)\n-                    throw new IllegalStateException(\"ReadListener already set\");\n-\n-                _listener = Objects.requireNonNull(readListener);\n-\n-                if (isError())\n+                if (_eof.isEof())\n+                {\n+                    _eof = Eof.CONSUMED_EOF;\n+                    if (LOG.isDebugEnabled())\n+                        LOG.debug(\"read on EOF, switching to CONSUMED_EOF and returning\");\n+                    return -1;\n+                }\n+                if (LOG.isDebugEnabled())\n+                    LOG.debug(\"read blocked\");\n+                blockForContent();\n+                if (LOG.isDebugEnabled())\n+                    LOG.debug(\"read unblocked\");\n+            }\n+            else\n+            {\n+                if (_eof.isEof())\n                 {\n-                    woken = _channelState.onReadReady();\n+                    boolean wasInAsyncWait = _channelState.onReadEof();\n+                    if (wasInAsyncWait)\n+                        scheduleReadListenerNotification();\n+                    if (LOG.isDebugEnabled())\n+                        LOG.debug(\"async read on EOF (was in async wait? {}), switching to CONSUMED_EOF and returning\", wasInAsyncWait);\n+                    _eof = Eof.CONSUMED_EOF;", "originalCommit": "743877ce7be889862c63f51350d61e5281f42a66", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTY0OTIyNw==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r391649227", "bodyText": "I think it's safe the way it is, at least for now. But I do agree that the assignment should be done before the scheduleReadListenerNotification() call.", "author": "lorban", "createdAt": "2020-03-12T14:13:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTYxMTQxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTYxNDI3Ng==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r391614276", "bodyText": "As per eclipse-ee4j/servlet-api#301 throwing an ISE here is good.\nWe just have to make sure that we never call OnDataAvailable because of raw content that get's entirely consumed by interceptors", "author": "gregw", "createdAt": "2020-03-12T13:19:41Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpInput.java", "diffHunk": "@@ -190,633 +89,348 @@ public Interceptor getInterceptor()\n      */\n     public void setInterceptor(Interceptor interceptor)\n     {\n-        _interceptor = interceptor;\n+        _contentProducer.setInterceptor(interceptor);\n     }\n \n     /**\n-     * Set the {@link Interceptor}, using a {@link ChainedInterceptor} if\n+     * Set the {@link Interceptor}, chaining it to the existing one if\n      * an {@link Interceptor} is already set.\n      *\n      * @param interceptor the next {@link Interceptor} in a chain\n      */\n     public void addInterceptor(Interceptor interceptor)\n     {\n-        if (_interceptor == null)\n-            _interceptor = interceptor;\n+        Interceptor currentInterceptor = _contentProducer.getInterceptor();\n+        if (currentInterceptor == null)\n+            _contentProducer.setInterceptor(interceptor);\n         else\n-            _interceptor = new ChainedInterceptor(_interceptor, interceptor);\n-    }\n-\n-    @Override\n-    public int available()\n-    {\n-        int available = 0;\n-        boolean woken = false;\n-        synchronized (_inputQ)\n-        {\n-            if (_content == null)\n-                _content = _inputQ.poll();\n-            if (_content == null)\n-            {\n-                try\n-                {\n-                    produceContent();\n-                }\n-                catch (IOException e)\n-                {\n-                    woken = failed(e);\n-                }\n-                if (_content == null)\n-                    _content = _inputQ.poll();\n-            }\n-\n-            if (_content != null)\n-                available = _content.remaining();\n-        }\n-\n-        if (woken)\n-            wake();\n-        return available;\n-    }\n-\n-    protected void wake()\n-    {\n-        HttpChannel channel = _channelState.getHttpChannel();\n-        Executor executor = channel.getConnector().getServer().getThreadPool();\n-        executor.execute(channel);\n-    }\n-\n-    @Override\n-    public int read() throws IOException\n-    {\n-        int read = read(_oneByteBuffer, 0, 1);\n-        if (read == 0)\n-            throw new IllegalStateException(\"unready read=0\");\n-        return read < 0 ? -1 : _oneByteBuffer[0] & 0xFF;\n-    }\n-\n-    @Override\n-    public int read(byte[] b, int off, int len) throws IOException\n-    {\n-        boolean wake = false;\n-        int l;\n-        synchronized (_inputQ)\n-        {\n-            // Calculate minimum request rate for DOS protection\n-            long minRequestDataRate = _channelState.getHttpChannel().getHttpConfiguration().getMinRequestDataRate();\n-            if (minRequestDataRate > 0 && _firstByteTimeStamp != -1)\n-            {\n-                long period = System.nanoTime() - _firstByteTimeStamp;\n-                if (period > 0)\n-                {\n-                    long minimumData = minRequestDataRate * TimeUnit.NANOSECONDS.toMillis(period) / TimeUnit.SECONDS.toMillis(1);\n-                    if (_contentArrived < minimumData)\n-                    {\n-                        BadMessageException bad = new BadMessageException(HttpStatus.REQUEST_TIMEOUT_408,\n-                            String.format(\"Request content data rate < %d B/s\", minRequestDataRate));\n-                        if (_channelState.isResponseCommitted())\n-                            _channelState.getHttpChannel().abort(bad);\n-                        throw bad;\n-                    }\n-                }\n-            }\n-\n-            // Consume content looking for bytes to read\n-            while (true)\n-            {\n-                Content item = nextContent();\n-                if (item != null)\n-                {\n-                    l = get(item, b, off, len);\n-                    if (LOG.isDebugEnabled())\n-                        LOG.debug(\"{} read {} from {}\", this, l, item);\n-\n-                    // Consume any following poison pills\n-                    if (item.isEmpty())\n-                        nextInterceptedContent();\n-                    break;\n-                }\n-\n-                // No content, so should we block?\n-                if (!_state.blockForContent(this))\n-                {\n-                    // Not blocking, so what should we return?\n-                    l = _state.noContent();\n-\n-                    if (l < 0)\n-                        // If EOF do we need to wake for allDataRead callback?\n-                        wake = _channelState.onReadEof();\n-                    break;\n-                }\n-            }\n-        }\n-\n-        if (wake)\n-            wake();\n-        return l;\n+            _contentProducer.setInterceptor(new ChainedInterceptor(currentInterceptor, interceptor));\n     }\n \n     /**\n-     * Called when derived implementations should attempt to produce more Content and add it via {@link #addContent(Content)}. For protocols that are constantly\n-     * producing (eg HTTP2) this can be left as a noop;\n-     *\n-     * @throws IOException if unable to produce content\n+     * Called by channel when asynchronous IO needs to produce more content\n      */\n-    protected void produceContent() throws IOException\n+    public void asyncReadProduce()\n     {\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"asyncReadProduce {}\", _contentProducer);\n+        produceRawContent();\n     }\n \n     /**\n-     * Called by channel when asynchronous IO needs to produce more content\n+     * Adds some content to this input stream.\n      *\n-     * @throws IOException if unable to produce content\n+     * @param content the content to add\n      */\n-    public void asyncReadProduce() throws IOException\n+    public void addContent(Content content)\n     {\n-        synchronized (_inputQ)\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"addContent {} {}\", content, _contentProducer);\n+        if (_firstByteTimeStamp == Long.MIN_VALUE)\n         {\n-            produceContent();\n+            _firstByteTimeStamp = System.nanoTime();\n+            if (_firstByteTimeStamp == Long.MIN_VALUE)\n+                _firstByteTimeStamp++;\n         }\n+        _contentProducer.addContent(content);\n+        if (isAsync())\n+            _channelState.onContentAdded();\n     }\n \n-    /**\n-     * Get the next content from the inputQ, calling {@link #produceContent()} if need be. EOF is processed and state changed.\n-     *\n-     * @return the content or null if none available.\n-     * @throws IOException if retrieving the content fails\n-     */\n-    protected Content nextContent() throws IOException\n+    public boolean hasContent()\n     {\n-        Content content = nextNonSentinelContent();\n-        if (content == null && !isFinished())\n-        {\n-            produceContent();\n-            content = nextNonSentinelContent();\n-        }\n-        return content;\n+        return _contentProducer.hasRawContent();\n     }\n \n-    /**\n-     * Poll the inputQ for Content. Consumed buffers and {@link SentinelContent}s are removed and EOF state updated if need be.\n-     *\n-     * @return Content or null\n-     */\n-    protected Content nextNonSentinelContent()\n+    public void unblock()\n     {\n-        while (true)\n-        {\n-            // Get the next content (or EOF)\n-            Content content = nextInterceptedContent();\n-\n-            // If it is EOF, consume it here\n-            if (content instanceof SentinelContent)\n-            {\n-                // Consume the EOF content, either if it was original content\n-                // or if it was produced by interception\n-                consume(content);\n-                continue;\n-            }\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"signalling blocked thread to wake up\");\n+        if (!isError() && !_eof.isEof() && _semaphore.availablePermits() > 0)\n+            throw new AssertionError();\n+        _semaphore.release();\n+    }\n \n-            return content;\n-        }\n+    public long getContentLength()\n+    {\n+        return _contentProducer.getRawContentArrived();\n     }\n \n     /**\n-     * Get the next readable from the inputQ, calling {@link #produceContent()} if need be. EOF is NOT processed and state is not changed.\n+     * This method should be called to signal that an EOF has been detected before all the expected content arrived.\n+     * <p>\n+     * Typically this will result in an EOFException being thrown from a subsequent read rather than a -1 return.\n      *\n-     * @return the content or EOF or null if none available.\n-     * @throws IOException if retrieving the content fails\n+     * @return true if content channel woken for read\n      */\n-    protected Content produceNextContext() throws IOException\n+    public boolean earlyEOF()\n     {\n-        Content content = nextInterceptedContent();\n-        if (content == null && !isFinished())\n-        {\n-            produceContent();\n-            content = nextInterceptedContent();\n-        }\n-        return content;\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"received early EOF\");\n+        _eof = Eof.EARLY_EOF;\n+        if (isAsync())\n+            return _channelState.onContentAdded();\n+        unblock();\n+        return false;\n     }\n \n     /**\n-     * Poll the inputQ for Content or EOF. Consumed buffers and non EOF {@link SentinelContent}s are removed. EOF state is not updated.\n-     * Interception is done within this method.\n+     * This method should be called to signal that all the expected content arrived.\n      *\n-     * @return Content with remaining, a {@link SentinelContent},  or null\n+     * @return true if content channel woken for read\n      */\n-    protected Content nextInterceptedContent()\n+    public boolean eof()\n     {\n-        // If we have a chunk produced by interception\n-        if (_intercepted != null)\n-        {\n-            // Use it if it has any remaining content\n-            if (_intercepted.hasContent())\n-                return _intercepted;\n-\n-            // succeed the chunk\n-            _intercepted.succeeded();\n-            _intercepted = null;\n-        }\n-\n-        // If we don't have a Content under consideration, get\n-        // the next one off the input Q.\n-        if (_content == null)\n-            _content = _inputQ.poll();\n-\n-        // While we have content to consider.\n-        while (_content != null)\n-        {\n-            // Are we intercepting?\n-            if (_interceptor != null)\n-            {\n-                // Intercept the current content (may be called several\n-                // times for the same content\n-                _intercepted = _interceptor.readFrom(_content);\n-\n-                // If interception produced new content\n-                if (_intercepted != null && _intercepted != _content)\n-                {\n-                    // if it is not empty use it\n-                    if (_intercepted.hasContent())\n-                        return _intercepted;\n-                    _intercepted.succeeded();\n-                }\n-\n-                // intercepted content consumed\n-                _intercepted = null;\n-\n-                // fall through so that the unintercepted _content is\n-                // considered for any remaining content, for EOF and to\n-                // succeed it if it is entirely consumed.\n-            }\n-\n-            // If the content has content or is an EOF marker, use it\n-            if (_content.hasContent() || _content instanceof SentinelContent)\n-                return _content;\n-\n-            // The content is consumed, so get the next one.  Note that EOF\n-            // content is never consumed here, but in #pollContent\n-            _content.succeeded();\n-            _content = _inputQ.poll();\n-        }\n-\n-        return null;\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"received EOF\");\n+        _eof = Eof.EOF;\n+        if (isAsync())\n+            return _channelState.onContentAdded();\n+        unblock();\n+        return false;\n     }\n \n-    private void consume(Content content)\n+    public boolean consumeAll()\n     {\n-        if (!isError() && content instanceof EofContent)\n-        {\n-            if (content == EARLY_EOF_CONTENT)\n-                _state = EARLY_EOF;\n-            else if (_listener == null)\n-                _state = EOF;\n-            else\n-                _state = AEOF;\n-        }\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"consume all\");\n+        _contentProducer.consumeTransformedContent(this::failRawContent, new IOException(\"Unconsumed content\"));\n+        if (_eof.isEof())\n+            _eof = Eof.CONSUMED_EOF;\n+\n+        if (isFinished())\n+            return !isError();\n \n-        // Consume the content, either if it was original content\n-        // or if it was produced by interception\n-        content.succeeded();\n-        if (_content == content)\n-            _content = null;\n-        else if (_intercepted == content)\n-            _intercepted = null;\n+        _eof = Eof.EARLY_EOF;\n+        return false;\n     }\n \n-    /**\n-     * Copies the given content into the given byte buffer.\n-     *\n-     * @param content the content to copy from\n-     * @param buffer the buffer to copy into\n-     * @param offset the buffer offset to start copying from\n-     * @param length the space available in the buffer\n-     * @return the number of bytes actually copied\n-     */\n-    protected int get(Content content, byte[] buffer, int offset, int length)\n+    public boolean isError()\n     {\n-        int l = content.get(buffer, offset, length);\n-        _contentConsumed += l;\n-        return l;\n+        return _error != null;\n     }\n \n-    /**\n-     * Consumes the given content. Calls the content succeeded if all content consumed.\n-     *\n-     * @param content the content to consume\n-     * @param length the number of bytes to consume\n-     */\n-    protected void skip(Content content, int length)\n+    public boolean isAsync()\n     {\n-        int l = content.skip(length);\n-\n-        _contentConsumed += l;\n-        if (l > 0 && content.isEmpty())\n-            nextNonSentinelContent(); // hungry succeed\n+        return _readListener != null;\n     }\n \n-    /**\n-     * Blocks until some content or some end-of-file event arrives.\n-     *\n-     * @throws IOException if the wait is interrupted\n-     */\n-    protected void blockForContent() throws IOException\n+    public boolean onIdleTimeout(Throwable x)\n     {\n-        try\n-        {\n-            _waitingForContent = true;\n-            _channelState.getHttpChannel().onBlockWaitForContent();\n-\n-            boolean loop = false;\n-            long timeout = 0;\n-            while (true)\n-            {\n-                // This method is called from a loop, so we just\n-                // need to check the timeout before and after waiting.\n-                if (loop)\n-                    break;\n-\n-                if (LOG.isDebugEnabled())\n-                    LOG.debug(\"{} blocking for content timeout={}\", this, timeout);\n-                if (timeout > 0)\n-                    _inputQ.wait(timeout);\n-                else\n-                    _inputQ.wait();\n-\n-                loop = true;\n-            }\n-        }\n-        catch (Throwable x)\n+        boolean neverDispatched = _channelState.isIdle();\n+        boolean waitingForContent = _contentProducer.available(this::produceRawContent) == 0 && !_eof.isEof();\n+        if ((waitingForContent || neverDispatched) && !isError())\n         {\n-            _channelState.getHttpChannel().onBlockWaitForContentFailure(x);\n+            x.addSuppressed(new Throwable(\"HttpInput idle timeout\"));\n+            _error = x;\n+            if (isAsync())\n+                return _channelState.onContentAdded();\n+            unblock();\n         }\n+        return false;\n     }\n \n-    /**\n-     * Adds some content to this input stream.\n-     *\n-     * @param content the content to add\n-     * @return true if content channel woken for read\n-     */\n-    public boolean addContent(Content content)\n+    public boolean failed(Throwable x)\n     {\n-        synchronized (_inputQ)\n-        {\n-            _waitingForContent = false;\n-            if (_firstByteTimeStamp == -1)\n-                _firstByteTimeStamp = System.nanoTime();\n-\n-            if (isFinished())\n-            {\n-                Throwable failure = isError() ? _state.getError() : new EOFException(\"Content after EOF\");\n-                content.failed(failure);\n-                return false;\n-            }\n-            else\n-            {\n-                _contentArrived += content.remaining();\n-\n-                if (_content == null && _inputQ.isEmpty())\n-                    _content = content;\n-                else\n-                    _inputQ.offer(content);\n-\n-                if (LOG.isDebugEnabled())\n-                    LOG.debug(\"{} addContent {}\", this, content);\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"failed \" + x);\n+        if (_error != null && _error != x)\n+            _error.addSuppressed(x);\n+        else\n+            _error = x;\n \n-                if (nextInterceptedContent() != null)\n-                    return wakeup();\n-                else\n-                    return false;\n-            }\n-        }\n+        if (isAsync())\n+            return _channelState.onContentAdded();\n+        unblock();\n+        return false;\n     }\n \n-    public boolean hasContent()\n-    {\n-        synchronized (_inputQ)\n-        {\n-            return _content != null || _inputQ.size() > 0;\n-        }\n-    }\n+    /* ServletInputStream */\n \n-    public void unblock()\n+    @Override\n+    public boolean isFinished()\n     {\n-        synchronized (_inputQ)\n-        {\n-            _inputQ.notify();\n-        }\n+        boolean finished = !_contentProducer.hasRawContent() && _eof.isConsumed();\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"isFinished? {}\", finished);\n+        return finished;\n     }\n \n-    public long getContentConsumed()\n+    @Override\n+    public boolean isReady()\n     {\n-        synchronized (_inputQ)\n+        // calling _contentProducer.available() might change the _eof state, so the following test order matters\n+        if (_contentProducer.available(this::produceRawContent) > 0 || _eof.isEof())\n         {\n-            return _contentConsumed;\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"isReady? true\");\n+            return true;\n         }\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"isReady? false\");\n+        _channelState.onReadUnready();\n+        return false;\n     }\n \n-    /**\n-     * This method should be called to signal that an EOF has been detected before all the expected content arrived.\n-     * <p>\n-     * Typically this will result in an EOFException being thrown from a subsequent read rather than a -1 return.\n-     *\n-     * @return true if content channel woken for read\n-     */\n-    public boolean earlyEOF()\n-    {\n-        return addContent(EARLY_EOF_CONTENT);\n-    }\n-\n-    /**\n-     * This method should be called to signal that all the expected content arrived.\n-     *\n-     * @return true if content channel woken for read\n-     */\n-    public boolean eof()\n+    @Override\n+    public void setReadListener(ReadListener readListener)\n     {\n-        return addContent(EOF_CONTENT);\n-    }\n+        if (_readListener != null)\n+            throw new IllegalStateException(\"ReadListener already set\");\n+        _readListener = Objects.requireNonNull(readListener);\n \n-    public boolean consumeAll()\n-    {\n-        synchronized (_inputQ)\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"setReadListener error=\" + _error + \" eof=\" + _eof + \" \" + _contentProducer);\n+        boolean woken;\n+        if (isError())\n         {\n-            try\n+            woken = _channelState.onReadReady();\n+        }\n+        else\n+        {\n+            if (_contentProducer.available(this::produceRawContent) > 0)\n             {\n-                while (true)\n-                {\n-                    Content item = nextContent();\n-                    if (item == null)\n-                        break; // Let's not bother blocking\n-\n-                    skip(item, item.remaining());\n-                }\n-                if (isFinished())\n-                    return !isError();\n-\n-                _state = EARLY_EOF;\n-                return false;\n+                woken = _channelState.onReadReady();\n+            }\n+            else if (_eof.isEof())\n+            {\n+                woken = _channelState.onReadEof();\n             }\n-            catch (Throwable e)\n+            else\n             {\n-                LOG.debug(e);\n-                _state = new ErrorState(e);\n-                return false;\n+                _channelState.onReadUnready();\n+                woken = false;\n             }\n         }\n-    }\n \n-    public boolean isError()\n-    {\n-        synchronized (_inputQ)\n-        {\n-            return _state instanceof ErrorState;\n-        }\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"setReadListener woken=\" + woken);\n+        if (woken)\n+            scheduleReadListenerNotification();\n     }\n \n-    public boolean isAsync()\n+    private void scheduleReadListenerNotification()\n     {\n-        synchronized (_inputQ)\n-        {\n-            return _state == ASYNC;\n-        }\n+        HttpChannel channel = _channelState.getHttpChannel();\n+        channel.execute(channel);\n     }\n \n     @Override\n-    public boolean isFinished()\n+    public int read() throws IOException\n     {\n-        synchronized (_inputQ)\n-        {\n-            return _state instanceof EOFState;\n-        }\n+        int read = read(_oneByteBuffer, 0, 1);\n+        if (read == 0)\n+            throw new IOException(\"unready read=0\");\n+        return read < 0 ? -1 : _oneByteBuffer[0] & 0xFF;\n     }\n \n     @Override\n-    public boolean isReady()\n+    public int read(byte[] b, int off, int len) throws IOException\n     {\n-        try\n+        // Calculate minimum request rate for DOS protection\n+        long minRequestDataRate = _channelState.getHttpChannel().getHttpConfiguration().getMinRequestDataRate();\n+        if (minRequestDataRate > 0 && _firstByteTimeStamp != Long.MIN_VALUE)\n         {\n-            synchronized (_inputQ)\n+            long period = System.nanoTime() - _firstByteTimeStamp;\n+            if (period > 0)\n             {\n-                if (_listener == null)\n-                    return true;\n-                if (_state instanceof EOFState)\n-                    return true;\n-                if (_waitingForContent)\n-                    return false;\n-                if (produceNextContext() != null)\n-                    return true;\n-                _channelState.onReadUnready();\n-                _waitingForContent = true;\n+                long minimumData = minRequestDataRate * TimeUnit.NANOSECONDS.toMillis(period) / TimeUnit.SECONDS.toMillis(1);\n+                if (_contentProducer.getRawContentArrived() < minimumData)\n+                {\n+                    BadMessageException bad = new BadMessageException(HttpStatus.REQUEST_TIMEOUT_408,\n+                        String.format(\"Request content data rate < %d B/s\", minRequestDataRate));\n+                    if (_channelState.isResponseCommitted())\n+                        _channelState.getHttpChannel().abort(bad);\n+                    throw bad;\n+                }\n             }\n-            return false;\n         }\n-        catch (IOException e)\n-        {\n-            LOG.ignore(e);\n-            return true;\n-        }\n-    }\n \n-    @Override\n-    public void setReadListener(ReadListener readListener)\n-    {\n-        boolean woken = false;\n-        try\n+        while (true)\n         {\n-            synchronized (_inputQ)\n+            _semaphore.drainPermits();\n+            int read = _contentProducer.read(this::produceRawContent, b, off, len);\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"read produced {} byte(s)\", read);\n+            if (read > 0)\n+                return read;\n+\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"read error = \" + _error);\n+            if (_error != null)\n+                throw new IOException(_error);\n+\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"read EOF = {}\", _eof);\n+            if (_eof.isEarly())\n+                throw new EofException(\"Early EOF\");\n+\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"read async = {}\", isAsync());\n+            if (!isAsync())\n             {\n-                if (_listener != null)\n-                    throw new IllegalStateException(\"ReadListener already set\");\n-\n-                _listener = Objects.requireNonNull(readListener);\n-\n-                if (isError())\n+                if (_eof.isEof())\n+                {\n+                    _eof = Eof.CONSUMED_EOF;\n+                    if (LOG.isDebugEnabled())\n+                        LOG.debug(\"read on EOF, switching to CONSUMED_EOF and returning\");\n+                    return -1;\n+                }\n+                if (LOG.isDebugEnabled())\n+                    LOG.debug(\"read blocked\");\n+                blockForContent();\n+                if (LOG.isDebugEnabled())\n+                    LOG.debug(\"read unblocked\");\n+            }\n+            else\n+            {\n+                if (_eof.isEof())\n                 {\n-                    woken = _channelState.onReadReady();\n+                    boolean wasInAsyncWait = _channelState.onReadEof();\n+                    if (wasInAsyncWait)\n+                        scheduleReadListenerNotification();\n+                    if (LOG.isDebugEnabled())\n+                        LOG.debug(\"async read on EOF (was in async wait? {}), switching to CONSUMED_EOF and returning\", wasInAsyncWait);\n+                    _eof = Eof.CONSUMED_EOF;\n+                    return -1;\n                 }\n                 else\n                 {\n-                    Content content = produceNextContext();\n-                    if (content != null)\n-                    {\n-                        _state = ASYNC;\n-                        woken = _channelState.onReadReady();\n-                    }\n-                    else if (_state == EOF)\n-                    {\n-                        _state = AEOF;\n-                        woken = _channelState.onReadEof();\n-                    }\n-                    else\n-                    {\n-                        _state = ASYNC;\n-                        _channelState.onReadUnready();\n-                        _waitingForContent = true;\n-                    }\n+                    //TODO returning 0 breaks the InputStream contract. Shouldn't IOException be thrown instead?", "originalCommit": "743877ce7be889862c63f51350d61e5281f42a66", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTY1MDA4OA==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r391650088", "bodyText": "I saw that, but I'd prefer to keep this the way it is, and fix all the missing ISE in a different PR.", "author": "lorban", "createdAt": "2020-03-12T14:15:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTYxNDI3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTY3Mzk3NQ==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r391673975", "bodyText": "ack!", "author": "gregw", "createdAt": "2020-03-12T14:49:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTYxNDI3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTYxODE0Mw==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r391618143", "bodyText": "I'm not a big fan of the passed array!   I'd much rather you return a HttpInput.LastContent wrapper of the HttpInput.Content", "author": "gregw", "createdAt": "2020-03-12T13:26:03Z", "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpChannelOverHTTP2.java", "diffHunk": "@@ -57,6 +58,64 @@\n     private boolean _expect100Continue;\n     private boolean _delayedUntilContent;\n     private boolean _useOutputDirectByteBuffers;\n+    private final RequestContent _requestContent = new RequestContent();\n+\n+    private class RequestContent\n+    {\n+        private HttpInput.Content _content;\n+        private boolean _endStream;\n+        private boolean _producing;\n+        private final AutoLock _lock = new AutoLock();\n+\n+        void setContent(boolean endStream, HttpInput.Content content)\n+        {\n+            try (AutoLock ignored = _lock.lock())\n+            {\n+                if (_content != null)\n+                    throw new AssertionError(\"content cannot be queued; stream=\" + getStream());\n+                _endStream = endStream;\n+                _content = content;\n+                _producing = false;\n+            }\n+        }\n+\n+        private HttpInput.Content takeContent(boolean[] endStreamResult)\n+        {\n+            try (AutoLock ignored = _lock.lock())\n+            {\n+                if (_content == null)\n+                    return null;\n+                HttpInput.Content contentCopy = _content;\n+                endStreamResult[0] = _endStream;\n+                _content = null;\n+                _endStream = false;\n+                return contentCopy;\n+            }\n+        }\n+\n+        HttpInput.Content takeContentOrDemand(boolean[] endStreamResult)", "originalCommit": "743877ce7be889862c63f51350d61e5281f42a66", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTY1MTU5NA==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r391651594", "bodyText": "This method actually used to return Map.Entry<Boolean, HttpInput.Content> but @sbordet preferred to mimic the j.u.c.a.AtomicMarkableReference.get(boolean[]) contract.", "author": "lorban", "createdAt": "2020-03-12T14:17:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTYxODE0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTY3NTkyMg==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r391675922", "bodyText": "hhhhmmmm maybe....  OK leave as is for now....   but a LastContent wrapper could be better and would be less allocations.  This allocates an array for every call, the Map.Entry allocated for every return.  The LastContent wrapper would only allocated for the last return!", "author": "gregw", "createdAt": "2020-03-12T14:52:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTYxODE0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTYyNDU3MA==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r391624570", "bodyText": "I think the problem here is that we may wake up if we receive raw content that is fully consumed by an interceptor.\nI think that either:\n\naddContent should attempt to do a transform and return a boolean to indicate if there is some; OR\nin the isAsyncCase you try calling nextNonEmptyContent to check if there is a non zero return.", "author": "gregw", "createdAt": "2020-03-12T13:36:41Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpInput.java", "diffHunk": "@@ -190,633 +89,348 @@ public Interceptor getInterceptor()\n      */\n     public void setInterceptor(Interceptor interceptor)\n     {\n-        _interceptor = interceptor;\n+        _contentProducer.setInterceptor(interceptor);\n     }\n \n     /**\n-     * Set the {@link Interceptor}, using a {@link ChainedInterceptor} if\n+     * Set the {@link Interceptor}, chaining it to the existing one if\n      * an {@link Interceptor} is already set.\n      *\n      * @param interceptor the next {@link Interceptor} in a chain\n      */\n     public void addInterceptor(Interceptor interceptor)\n     {\n-        if (_interceptor == null)\n-            _interceptor = interceptor;\n+        Interceptor currentInterceptor = _contentProducer.getInterceptor();\n+        if (currentInterceptor == null)\n+            _contentProducer.setInterceptor(interceptor);\n         else\n-            _interceptor = new ChainedInterceptor(_interceptor, interceptor);\n-    }\n-\n-    @Override\n-    public int available()\n-    {\n-        int available = 0;\n-        boolean woken = false;\n-        synchronized (_inputQ)\n-        {\n-            if (_content == null)\n-                _content = _inputQ.poll();\n-            if (_content == null)\n-            {\n-                try\n-                {\n-                    produceContent();\n-                }\n-                catch (IOException e)\n-                {\n-                    woken = failed(e);\n-                }\n-                if (_content == null)\n-                    _content = _inputQ.poll();\n-            }\n-\n-            if (_content != null)\n-                available = _content.remaining();\n-        }\n-\n-        if (woken)\n-            wake();\n-        return available;\n-    }\n-\n-    protected void wake()\n-    {\n-        HttpChannel channel = _channelState.getHttpChannel();\n-        Executor executor = channel.getConnector().getServer().getThreadPool();\n-        executor.execute(channel);\n-    }\n-\n-    @Override\n-    public int read() throws IOException\n-    {\n-        int read = read(_oneByteBuffer, 0, 1);\n-        if (read == 0)\n-            throw new IllegalStateException(\"unready read=0\");\n-        return read < 0 ? -1 : _oneByteBuffer[0] & 0xFF;\n-    }\n-\n-    @Override\n-    public int read(byte[] b, int off, int len) throws IOException\n-    {\n-        boolean wake = false;\n-        int l;\n-        synchronized (_inputQ)\n-        {\n-            // Calculate minimum request rate for DOS protection\n-            long minRequestDataRate = _channelState.getHttpChannel().getHttpConfiguration().getMinRequestDataRate();\n-            if (minRequestDataRate > 0 && _firstByteTimeStamp != -1)\n-            {\n-                long period = System.nanoTime() - _firstByteTimeStamp;\n-                if (period > 0)\n-                {\n-                    long minimumData = minRequestDataRate * TimeUnit.NANOSECONDS.toMillis(period) / TimeUnit.SECONDS.toMillis(1);\n-                    if (_contentArrived < minimumData)\n-                    {\n-                        BadMessageException bad = new BadMessageException(HttpStatus.REQUEST_TIMEOUT_408,\n-                            String.format(\"Request content data rate < %d B/s\", minRequestDataRate));\n-                        if (_channelState.isResponseCommitted())\n-                            _channelState.getHttpChannel().abort(bad);\n-                        throw bad;\n-                    }\n-                }\n-            }\n-\n-            // Consume content looking for bytes to read\n-            while (true)\n-            {\n-                Content item = nextContent();\n-                if (item != null)\n-                {\n-                    l = get(item, b, off, len);\n-                    if (LOG.isDebugEnabled())\n-                        LOG.debug(\"{} read {} from {}\", this, l, item);\n-\n-                    // Consume any following poison pills\n-                    if (item.isEmpty())\n-                        nextInterceptedContent();\n-                    break;\n-                }\n-\n-                // No content, so should we block?\n-                if (!_state.blockForContent(this))\n-                {\n-                    // Not blocking, so what should we return?\n-                    l = _state.noContent();\n-\n-                    if (l < 0)\n-                        // If EOF do we need to wake for allDataRead callback?\n-                        wake = _channelState.onReadEof();\n-                    break;\n-                }\n-            }\n-        }\n-\n-        if (wake)\n-            wake();\n-        return l;\n+            _contentProducer.setInterceptor(new ChainedInterceptor(currentInterceptor, interceptor));\n     }\n \n     /**\n-     * Called when derived implementations should attempt to produce more Content and add it via {@link #addContent(Content)}. For protocols that are constantly\n-     * producing (eg HTTP2) this can be left as a noop;\n-     *\n-     * @throws IOException if unable to produce content\n+     * Called by channel when asynchronous IO needs to produce more content\n      */\n-    protected void produceContent() throws IOException\n+    public void asyncReadProduce()\n     {\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"asyncReadProduce {}\", _contentProducer);\n+        produceRawContent();\n     }\n \n     /**\n-     * Called by channel when asynchronous IO needs to produce more content\n+     * Adds some content to this input stream.\n      *\n-     * @throws IOException if unable to produce content\n+     * @param content the content to add\n      */\n-    public void asyncReadProduce() throws IOException\n+    public void addContent(Content content)\n     {\n-        synchronized (_inputQ)\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"addContent {} {}\", content, _contentProducer);\n+        if (_firstByteTimeStamp == Long.MIN_VALUE)\n         {\n-            produceContent();\n+            _firstByteTimeStamp = System.nanoTime();\n+            if (_firstByteTimeStamp == Long.MIN_VALUE)\n+                _firstByteTimeStamp++;\n         }\n+        _contentProducer.addContent(content);\n+        if (isAsync())\n+            _channelState.onContentAdded();", "originalCommit": "743877ce7be889862c63f51350d61e5281f42a66", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTY1MzU3Mw==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r391653573", "bodyText": "Or this?\nif (isAsync() && _contentProducer.available(this::produceContent) > 0)\n    _channelState.onContentAdded();\n\nNote that this will make the thread that adds the content execute the transformation code, polluting its L1 code cache. This is probably cheaper than a context switch, though.", "author": "lorban", "createdAt": "2020-03-12T14:20:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTYyNDU3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTY3NzUyNw==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r391677527", "bodyText": "That's a nice way of doing it!\nDon't worry about the L1 cache, because the thread that does the transformation is doing so from with a HttpChannel.handle, which will see the changed state on unhandle and loop around to call the onDataAvailable callback, which will then call read and find all that nice tranformed data in its L1 cache!", "author": "gregw", "createdAt": "2020-03-12T14:54:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTYyNDU3MA=="}], "type": "inlineReview"}, {"oid": "92e760711fe4c6a5f682adc69797b1f4182306ed", "url": "https://github.com/eclipse/jetty.project/commit/92e760711fe4c6a5f682adc69797b1f4182306ed", "message": "apply slf4j changes\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-03-20T08:48:11Z", "type": "forcePushed"}, {"oid": "89badf0eea2cfe12b609fe45287e2ef15d549bbf", "url": "https://github.com/eclipse/jetty.project/commit/89badf0eea2cfe12b609fe45287e2ef15d549bbf", "message": "apply slf4j changes\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-03-20T09:29:17Z", "type": "forcePushed"}, {"oid": "1c326618a8f2f970375832bdf3a05d4e7b1faa63", "url": "https://github.com/eclipse/jetty.project/commit/1c326618a8f2f970375832bdf3a05d4e7b1faa63", "message": "fix deadlock by calling callbacks out of lock scope\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-03-24T11:29:16Z", "type": "forcePushed"}, {"oid": "3e7cdf055bd73934eba01d68a674a27fe3c0c1ae", "url": "https://github.com/eclipse/jetty.project/commit/3e7cdf055bd73934eba01d68a674a27fe3c0c1ae", "message": "fix deadlock by calling callbacks out of lock scope\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-03-24T13:29:43Z", "type": "forcePushed"}, {"oid": "bc5845d3c7e7fdd39bb07c607f0d50932e2238f9", "url": "https://github.com/eclipse/jetty.project/commit/bc5845d3c7e7fdd39bb07c607f0d50932e2238f9", "message": "apply slf4j changes\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-03-24T11:29:16Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTMwNTA3Mw==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r399305073", "bodyText": "Considering that HttpInput.Content is our interface, why don't we just put an isLast() method on it?", "author": "gregw", "createdAt": "2020-03-27T14:29:14Z", "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpChannelOverHTTP2.java", "diffHunk": "@@ -285,6 +285,23 @@ public void recycle()\n         getHttpTransport().recycle();\n     }\n \n+    public void onAsyncWaitForContent()\n+    {\n+        // Check if demand was fulfilled while we were transitioning to the REGISTERED state,\n+        // push the content to the HttpInput if that was the case.\n+        boolean[] endStreamResult = new boolean[1];\n+        HttpInput.Content content = _requestContent.takeContent(endStreamResult);", "originalCommit": "b2533d6772c223f0991aa3c4fa7bfeeacaf073d8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODg4OTMwNQ==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r408889305", "bodyText": "This implementation conflates too many things and needs to be simplified. See my latest version.", "author": "lorban", "createdAt": "2020-04-15T14:32:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTMwNTA3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTMwODAxNQ==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r399308015", "bodyText": "Can you explain how content can be added in POSSIBLE state?\nI thought the idea was that we switched to POSSIBLE from REGISTERED state when the callback happened, but then we call handle and it is only withing handle that we then switch from POSSIBLE to PRODUCING state and then onContentAdded might be called.", "author": "gregw", "createdAt": "2020-03-27T14:33:14Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpChannelState.java", "diffHunk": "@@ -1294,6 +1294,7 @@ public boolean onContentAdded()\n                 case READY:\n                     break;\n \n+                case POSSIBLE:", "originalCommit": "b2533d6772c223f0991aa3c4fa7bfeeacaf073d8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODgzMTE0OA==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r408831148", "bodyText": "That shouldn't be possible.", "author": "lorban", "createdAt": "2020-04-15T13:14:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTMwODAxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTMwOTI1Mw==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r399309253", "bodyText": "Again can you explain this?   If we are in POSSIBLE state then a thread is on its way to call handle an switch us to PRODUCING.   So we've already been called back! How can we get called back again?", "author": "gregw", "createdAt": "2020-03-27T14:34:59Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpChannelState.java", "diffHunk": "@@ -1378,6 +1379,7 @@ public boolean onReadPossible()\n                 case IDLE:\n                 case READY:\n                 case REGISTER:\n+                case POSSIBLE:", "originalCommit": "b2533d6772c223f0991aa3c4fa7bfeeacaf073d8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODg4ODIzOQ==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r408888239", "bodyText": "This should not happen, let me fix this.", "author": "lorban", "createdAt": "2020-04-15T14:31:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTMwOTI1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUzODYyNQ==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r407538625", "bodyText": "I'm not particularly fond of this - I'm sure it can be done otherwise.\nThe demand mechanism is well established now (even present in the JDK) so I would not change its semantic.", "author": "sbordet", "createdAt": "2020-04-13T15:28:17Z", "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpChannelOverHTTP2.java", "diffHunk": "@@ -62,58 +62,54 @@\n \n     private class RequestContent\n     {\n-        private HttpInput.Content _content;\n-        private boolean _endStream;\n         private boolean _producing;\n+        private boolean _woken;\n         private final AutoLock _lock = new AutoLock();\n \n-        void setContent(boolean endStream, HttpInput.Content content)\n+        public boolean woken()\n         {\n             try (AutoLock ignored = _lock.lock())\n             {\n-                if (_content != null)\n-                    throw new AssertionError(\"content cannot be queued; stream=\" + getStream());\n-                _endStream = endStream;\n-                _content = content;\n-                _producing = false;\n+                return _woken;\n             }\n         }\n \n-        HttpInput.Content takeContent(boolean[] endStreamResult)\n+        void setContent(boolean endStream, HttpInput.Content content)\n         {\n             try (AutoLock ignored = _lock.lock())\n             {\n-                if (_content == null)\n-                    return null;\n-                HttpInput.Content contentCopy = _content;\n-                endStreamResult[0] = _endStream;\n-                _content = null;\n-                _endStream = false;\n-                return contentCopy;\n+                _producing = false;\n+            }\n+\n+            boolean woken = onContent(content);\n+            if (endStream)\n+            {\n+                onContentComplete();\n+                woken |= onRequestComplete();\n+            }\n+\n+            try (AutoLock ignored = _lock.lock())\n+            {\n+                _woken = woken;\n             }\n         }\n \n-        HttpInput.Content takeContentOrDemand(boolean[] endStreamResult)\n+        void poll()\n         {\n-            HttpInput.Content content = takeContent(endStreamResult);\n-            if (content != null)\n-                return content;\n+            getStream().demand(0);", "originalCommit": "1e094a193e10f54fc241a680d89525b42842f2a7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU0OTIxNA==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r407549214", "bodyText": "The reason why I introduced this mechanism is to make HTTP 1 and 2 more similar and avoid triggering data demands until we reach a safe spot in the state machine, much like HTTP 1 makes the distinction between parseAndFill and setting fillInterested.\nThis drastically helps controlling the paths that could lead to race conditions as the latter can only happen wherever we decide they can happen instead of virtually everywhere, making debugging a lot more manageable.\nI tried really hard without touching this mechanism and the fact that you can't read data without triggering an async call that adds content makes the code, IMHO, virtually unmaintainable.", "author": "lorban", "createdAt": "2020-04-13T15:48:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUzODYyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU1MjcwMA==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r407552700", "bodyText": "We need to discuss this more, as we have certainly figured out more complex cases, and I don't feel this one is impossible to solve without breaking the demand semantic - which would potentially introduce a much larger problem.", "author": "sbordet", "createdAt": "2020-04-13T15:54:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUzODYyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU1NDU2Mg==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r407554562", "bodyText": "Yes, I agree.", "author": "lorban", "createdAt": "2020-04-13T15:58:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUzODYyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzkxMzg3Ng==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r407913876", "bodyText": "How about just adding an available() method to the interface.  All that is necessary is something that can be used to query to decide if we should continue iterating on content or exit and let HttpChannel.unhandle do the demand(1) to setup to receive more content.   So long as we don't have content arriving between those two events, then things become simpler.", "author": "gregw", "createdAt": "2020-04-14T07:12:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUzODYyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk4NTM3NQ==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r407985375", "bodyText": "I like the idea of adding an available() method a lot: it's a cleaner interface, trivial to implement and provides the necessary semantic.", "author": "lorban", "createdAt": "2020-04-14T09:12:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUzODYyNQ=="}], "type": "inlineReview"}, {"oid": "626538029e55fba20086149854cea33c55c16335", "url": "https://github.com/eclipse/jetty.project/commit/626538029e55fba20086149854cea33c55c16335", "message": "better align HTTP 1 and 2 by introducing Stream.demand(0)\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-04-13T15:54:51Z", "type": "forcePushed"}, {"oid": "0885323b85e66b3ac1897be0d9b431e62fbd4003", "url": "https://github.com/eclipse/jetty.project/commit/0885323b85e66b3ac1897be0d9b431e62fbd4003", "message": "refactor to minimize code changes vs Milestone 3\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-04-14T10:20:48Z", "type": "forcePushed"}, {"oid": "dd0f4aed1eae618872ac8eb914b0602591f7d0b0", "url": "https://github.com/eclipse/jetty.project/commit/dd0f4aed1eae618872ac8eb914b0602591f7d0b0", "message": "refactor to minimize code changes vs Milestone 3\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-04-14T13:44:31Z", "type": "forcePushed"}, {"oid": "d284fe9165e365002e9442b9d4f88e60fbda0ecc", "url": "https://github.com/eclipse/jetty.project/commit/d284fe9165e365002e9442b9d4f88e60fbda0ecc", "message": "refactor to minimize code changes vs Milestone 3\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-04-15T09:39:16Z", "type": "forcePushed"}, {"oid": "5cde27ce38474bea46b20bcad754145a05908457", "url": "https://github.com/eclipse/jetty.project/commit/5cde27ce38474bea46b20bcad754145a05908457", "message": "better align HTTP 1 and 2 by introducing Stream.available()\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-04-15T13:05:33Z", "type": "forcePushed"}, {"oid": "c962ad964697a44d60c6acf8cb55683a9b1da973", "url": "https://github.com/eclipse/jetty.project/commit/c962ad964697a44d60c6acf8cb55683a9b1da973", "message": "better align HTTP 1 and 2 by introducing Stream.available()\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-07-07T08:00:44Z", "type": "forcePushed"}, {"oid": "040ec64bfd0f091101f917a8a276b9f621c5a0ce", "url": "https://github.com/eclipse/jetty.project/commit/040ec64bfd0f091101f917a8a276b9f621c5a0ce", "message": "implement http 1 needContent()\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-08-11T07:57:16Z", "type": "forcePushed"}, {"oid": "14edc7abe51603dfcb4e604210db24d4cfe741ca", "url": "https://github.com/eclipse/jetty.project/commit/14edc7abe51603dfcb4e604210db24d4cfe741ca", "message": "implement needContent()\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-08-11T09:18:33Z", "type": "forcePushed"}, {"oid": "3ebc68060188d5b0a8bb1ec85909d980f0d05ab7", "url": "https://github.com/eclipse/jetty.project/commit/3ebc68060188d5b0a8bb1ec85909d980f0d05ab7", "message": "implement needContent()\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-08-11T09:27:40Z", "type": "forcePushed"}, {"oid": "49ac047a512ce0f4df95a30f3e393ff154011a2f", "url": "https://github.com/eclipse/jetty.project/commit/49ac047a512ce0f4df95a30f3e393ff154011a2f", "message": "implement needContent()\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-08-11T09:28:31Z", "type": "forcePushed"}, {"oid": "12a38ac90e0c5a50cd7ba58657285e51badd07f9", "url": "https://github.com/eclipse/jetty.project/commit/12a38ac90e0c5a50cd7ba58657285e51badd07f9", "message": "move content production to ContentProducer\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-08-11T12:06:14Z", "type": "forcePushed"}, {"oid": "9ad742a9f2f00f6ff5561549cadc48178af9a59a", "url": "https://github.com/eclipse/jetty.project/commit/9ad742a9f2f00f6ff5561549cadc48178af9a59a", "message": "fix http 1 failContent\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-08-17T09:15:54Z", "type": "forcePushed"}, {"oid": "e3f5a69b116e77730436a5e183416740781e1045", "url": "https://github.com/eclipse/jetty.project/commit/e3f5a69b116e77730436a5e183416740781e1045", "message": "implement http 2\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-08-17T12:52:54Z", "type": "forcePushed"}, {"oid": "8131020bba1e1eaccf386f3ac3e34ea59cd700fc", "url": "https://github.com/eclipse/jetty.project/commit/8131020bba1e1eaccf386f3ac3e34ea59cd700fc", "message": "get rid of HttpInput.addContent()\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-08-18T10:02:44Z", "type": "forcePushed"}, {"oid": "1eea901c285a4ba02843267f50c8dde9825460e7", "url": "https://github.com/eclipse/jetty.project/commit/1eea901c285a4ba02843267f50c8dde9825460e7", "message": "get rid of HttpInput.addContent()\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-08-18T11:07:38Z", "type": "forcePushed"}, {"oid": "c2cabb8df98ff33e6379b2b99f5f3ba9dff9ade4", "url": "https://github.com/eclipse/jetty.project/commit/c2cabb8df98ff33e6379b2b99f5f3ba9dff9ade4", "message": "javadoc and renaming\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-08-19T08:18:40Z", "type": "forcePushed"}, {"oid": "614b4b092c836653d38d432e30f903c453843fea", "url": "https://github.com/eclipse/jetty.project/commit/614b4b092c836653d38d432e30f903c453843fea", "message": "make use of special content for EOF and errors\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-08-24T13:26:49Z", "type": "forcePushed"}, {"oid": "ed47bc8dde6f5fd1df02bd6e78f714b295fab4d0", "url": "https://github.com/eclipse/jetty.project/commit/ed47bc8dde6f5fd1df02bd6e78f714b295fab4d0", "message": "new ContentProducer hierarchy\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-08-24T14:44:51Z", "type": "forcePushed"}, {"oid": "c352c3cd093b0f0a581c1d415395b6d0c5fceee6", "url": "https://github.com/eclipse/jetty.project/commit/c352c3cd093b0f0a581c1d415395b6d0c5fceee6", "message": "new ContentProducer hierarchy\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-08-24T14:53:29Z", "type": "forcePushed"}, {"oid": "38fa4d94b97c37daaf535c1755d83558cbab0dd4", "url": "https://github.com/eclipse/jetty.project/commit/38fa4d94b97c37daaf535c1755d83558cbab0dd4", "message": "new ContentProducer hierarchy\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-08-24T15:40:20Z", "type": "forcePushed"}, {"oid": "cb80a4b0158c76d4a59f81f10cfe1fc556667cf9", "url": "https://github.com/eclipse/jetty.project/commit/cb80a4b0158c76d4a59f81f10cfe1fc556667cf9", "message": "make use of special content for EOF and errors (H2)\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-08-25T15:01:27Z", "type": "forcePushed"}, {"oid": "9bb173dae87bc0f091c0ca71fed8e70d0ed12f56", "url": "https://github.com/eclipse/jetty.project/commit/9bb173dae87bc0f091c0ca71fed8e70d0ed12f56", "message": "new ContentProducer hierarchy\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-08-26T11:45:21Z", "type": "forcePushed"}, {"oid": "8d8e34e30f2c472d54d2af1441a489cd8a48ede9", "url": "https://github.com/eclipse/jetty.project/commit/8d8e34e30f2c472d54d2af1441a489cd8a48ede9", "message": "re-introduce minimum request rate and raw bytes counting\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-09-10T15:52:40Z", "type": "forcePushed"}, {"oid": "4ebba92a3436c6279421b022664610f3f4d3f18f", "url": "https://github.com/eclipse/jetty.project/commit/4ebba92a3436c6279421b022664610f3f4d3f18f", "message": "fix FCGI\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-09-14T06:42:42Z", "type": "forcePushed"}, {"oid": "e6db8272c7bda8a11a1d686039117124ccdf8d47", "url": "https://github.com/eclipse/jetty.project/commit/e6db8272c7bda8a11a1d686039117124ccdf8d47", "message": "enqueue special content together with normal content\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-09-16T13:07:50Z", "type": "forcePushed"}, {"oid": "21169bb9c2cf6930e3f50145cd8cee994f294483", "url": "https://github.com/eclipse/jetty.project/commit/21169bb9c2cf6930e3f50145cd8cee994f294483", "message": "consumeAll must not modify the Channel state\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-09-17T09:44:44Z", "type": "forcePushed"}, {"oid": "519760ddb6ab01944a3f0da1337be7825563e533", "url": "https://github.com/eclipse/jetty.project/commit/519760ddb6ab01944a3f0da1337be7825563e533", "message": "fix rebase\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-09-21T09:01:47Z", "type": "forcePushed"}, {"oid": "56aa53d5d301e518da8b829862a85b3078a92e3e", "url": "https://github.com/eclipse/jetty.project/commit/56aa53d5d301e518da8b829862a85b3078a92e3e", "message": "update state diagram\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-09-21T15:46:12Z", "type": "forcePushed"}, {"oid": "2f343b98613f99e14fc9c4c2c96f2bf13c804243", "url": "https://github.com/eclipse/jetty.project/commit/2f343b98613f99e14fc9c4c2c96f2bf13c804243", "message": "read() should not trigger content demand\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-09-22T16:55:09Z", "type": "forcePushed"}, {"oid": "76f1997cb557fbc61f6a49239f52038c45af79d6", "url": "https://github.com/eclipse/jetty.project/commit/76f1997cb557fbc61f6a49239f52038c45af79d6", "message": "fix test\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-09-29T11:48:40Z", "type": "forcePushed"}, {"oid": "f04217513884ab0c82df112a5dc6ff37c42f645b", "url": "https://github.com/eclipse/jetty.project/commit/f04217513884ab0c82df112a5dc6ff37c42f645b", "message": "add channel state diagrams\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-09-30T14:51:39Z", "type": "forcePushed"}, {"oid": "d2b3c42a9bbecef9322169f82f0cb2df65248b99", "url": "https://github.com/eclipse/jetty.project/commit/d2b3c42a9bbecef9322169f82f0cb2df65248b99", "message": "cleanups\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-10-01T09:55:35Z", "type": "forcePushed"}, {"oid": "80b56f3e8b1538d83c70a78fd9d4e47032e555d9", "url": "https://github.com/eclipse/jetty.project/commit/80b56f3e8b1538d83c70a78fd9d4e47032e555d9", "message": "is a different wakeup required at EOF?\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-10-05T11:29:38Z", "type": "forcePushed"}, {"oid": "2ad82e8e2c0e8a82c2be89552a4ffd457ea9b791", "url": "https://github.com/eclipse/jetty.project/commit/2ad82e8e2c0e8a82c2be89552a4ffd457ea9b791", "message": "make some HttpChannel methods abstract\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-10-06T13:59:10Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzIwMzY2Nw==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r503203667", "bodyText": "I don't think we need both implementations now.  Let's just go for the atomic one, so we can probably get rid of the interface.", "author": "gregw", "createdAt": "2020-10-12T10:38:57Z", "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpChannelOverHTTP2.java", "diffHunk": "@@ -261,31 +268,408 @@ public InvocationType getInvocationType()\n             {\n                 return callback.getInvocationType();\n             }\n-        });\n+        };\n+        _contentDemander.onContent(content);\n+        boolean handle = onContent(content);\n \n         boolean endStream = frame.isEndStream();\n         if (endStream)\n         {\n             boolean handleContent = onContentComplete();\n+            // this will generate EOF -> must happen before wakeup\n             boolean handleRequest = onRequestComplete();\n             handle |= handleContent | handleRequest;\n         }\n \n+        boolean woken = getRequest().getHttpInput().wakeup();\n         if (LOG.isDebugEnabled())\n         {\n-            LOG.debug(\"HTTP2 Request #{}/{}: {} bytes of {} content, handle: {}\",\n+            Stream stream = getStream();\n+            LOG.debug(\"HTTP2 Request #{}/{}: {} bytes of {} content, woken: {}, handle: {}\",\n                     stream.getId(),\n                     Integer.toHexString(stream.getSession().hashCode()),\n                     length,\n                     endStream ? \"last\" : \"some\",\n+                    woken,\n                     handle);\n         }\n+        handle |= woken;\n \n         boolean wasDelayed = _delayedUntilContent;\n         _delayedUntilContent = false;\n         return handle || wasDelayed ? this : null;\n     }\n \n+    private interface ContentDemander", "originalCommit": "24bbc717dd41dee613298b0b71d35ed35a556e61", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI0NzI4OA==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r503247288", "bodyText": "Done.", "author": "lorban", "createdAt": "2020-10-12T12:01:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzIwMzY2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzIwMzk0NA==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r503203944", "bodyText": "Can we remove the Tracer from all code now", "author": "gregw", "createdAt": "2020-10-12T10:39:32Z", "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpChannelOverHTTP2.java", "diffHunk": "@@ -261,31 +268,408 @@ public InvocationType getInvocationType()\n             {\n                 return callback.getInvocationType();\n             }\n-        });\n+        };\n+        _contentDemander.onContent(content);\n+        boolean handle = onContent(content);\n \n         boolean endStream = frame.isEndStream();\n         if (endStream)\n         {\n             boolean handleContent = onContentComplete();\n+            // this will generate EOF -> must happen before wakeup\n             boolean handleRequest = onRequestComplete();\n             handle |= handleContent | handleRequest;\n         }\n \n+        boolean woken = getRequest().getHttpInput().wakeup();\n         if (LOG.isDebugEnabled())\n         {\n-            LOG.debug(\"HTTP2 Request #{}/{}: {} bytes of {} content, handle: {}\",\n+            Stream stream = getStream();\n+            LOG.debug(\"HTTP2 Request #{}/{}: {} bytes of {} content, woken: {}, handle: {}\",\n                     stream.getId(),\n                     Integer.toHexString(stream.getSession().hashCode()),\n                     length,\n                     endStream ? \"last\" : \"some\",\n+                    woken,\n                     handle);\n         }\n+        handle |= woken;\n \n         boolean wasDelayed = _delayedUntilContent;\n         _delayedUntilContent = false;\n         return handle || wasDelayed ? this : null;\n     }\n \n+    private interface ContentDemander\n+    {\n+        void eof();\n+\n+        void recycle();\n+\n+        HttpInput.Content take();\n+\n+        boolean demand();\n+\n+        void onContent(HttpInput.Content content);\n+\n+        boolean onTimeout(Throwable failure);\n+\n+        void failContent(Throwable failure);\n+    }\n+\n+    private class ContentDemanderQueue implements ContentDemander\n+    {\n+        private boolean _demanding;\n+        private final Queue<HttpInput.Content> _contentQueue = new LinkedList<>();\n+\n+        @Override\n+        public synchronized void recycle()\n+        {\n+            _contentQueue.forEach(c ->\n+            {\n+                if (!c.isSpecial())\n+                    throw new AssertionError(\"unconsumed content: \" + _contentQueue);\n+            });\n+            _demanding = false;\n+            _contentQueue.clear();\n+        }\n+\n+        @Override\n+        public synchronized HttpInput.Content take()\n+        {\n+            HttpInput.Content c = _contentQueue.peek();\n+            if (c != null && !c.isSpecial())\n+            {\n+                _contentQueue.poll();\n+                if (c.isEof())\n+                    _contentQueue.add(EOF);\n+            }\n+            return c;\n+        }\n+\n+        @Override\n+        public synchronized boolean demand()\n+        {\n+            if (!_contentQueue.isEmpty())\n+                return true;\n+            if (!_demanding)\n+            {\n+                _demanding = true;\n+                IStream stream = getStream();\n+                if (stream == null)\n+                    _demanding = false;\n+                else\n+                    stream.demand(1);\n+            }\n+            return !_contentQueue.isEmpty();\n+        }\n+\n+        @Override\n+        public synchronized void onContent(HttpInput.Content content)\n+        {\n+            _demanding = false; // TODO maybe distinguish between upstream content and downstream errors\n+            if (content.isEof() && content.isSpecial() && content.isEmpty() && _contentQueue.size() == 1 && _contentQueue.peek().isEof())\n+            {\n+                content.succeeded();\n+                return;\n+            }\n+\n+            // error content fails and replaces any other content\n+            Throwable x = content.getError();\n+            if (x != null)\n+            {\n+                _contentQueue.forEach(c -> c.failed(x));\n+                _contentQueue.clear();\n+            }\n+\n+            _contentQueue.offer(content);\n+            if (_contentQueue.size() > 1)\n+                throw new AssertionError(\"Queue should never be more than 1: \" + _contentQueue);\n+        }\n+\n+        @Override\n+        public synchronized boolean onTimeout(Throwable failure)\n+        {\n+            if (_demanding && _contentQueue.isEmpty())\n+            {\n+                _demanding = false;\n+                _contentQueue.add(new HttpInput.ErrorContent(failure));\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public synchronized void eof()\n+        {\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"received EOF\");\n+\n+            if (_contentQueue.size() != 1 || !_contentQueue.peek().isEof())\n+                _contentQueue.add(EOF);\n+        }\n+\n+        @Override\n+        public synchronized void failContent(Throwable failure)\n+        {\n+            for (Iterator<HttpInput.Content> i = _contentQueue.iterator(); i.hasNext();)\n+            {\n+                HttpInput.Content c = i.next();\n+                if (!c.isSpecial())\n+                {\n+                    i.remove();\n+                    c.failed(failure);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static final HttpInput.Content EOF = new HttpInput.EofContent();\n+    private static final HttpInput.Content DEMANDING = new HttpInput.SpecialContent() {};\n+\n+    private class ContentDemanderAtomic implements ContentDemander\n+    {\n+        private final AtomicReference<HttpInput.Content> _content = new AtomicReference<>();\n+\n+        @Override\n+        public void recycle()\n+        {\n+            HttpInput.Content c = _content.getAndSet(null);\n+            if (c != null && !c.isSpecial())\n+                throw new AssertionError(\"unconsumed content: \" + c);\n+        }\n+\n+        @Override\n+        public HttpInput.Content take()\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c == null || c.isSpecial() || _content.compareAndSet(c, c.isEof() ? EOF : null))\n+                    return c;\n+            }\n+        }\n+\n+        @Override\n+        public boolean demand()\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c == DEMANDING)\n+                    return false;\n+                if (c != null)\n+                    return true;\n+                if (_content.compareAndSet(null, DEMANDING))\n+                {\n+                    IStream stream = getStream();\n+                    if (stream == null)\n+                    {\n+                        _content.set(null);\n+                        return false;\n+                    }\n+                    stream.demand(1);\n+                    c = _content.get();\n+                    return c != DEMANDING && c != null;\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void onContent(HttpInput.Content content)\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c == DEMANDING)\n+                {\n+                    if (_content.compareAndSet(DEMANDING, content))\n+                        return;\n+                }\n+                else if (c == null)\n+                {\n+                    if (!content.isSpecial())\n+                        throw new AssertionError(\"Non special content without demand\");\n+                    if (_content.compareAndSet(null, content))\n+                        return;\n+                }\n+                else if (c.isEof() && content.isEof() && content.isEmpty())\n+                {\n+                    content.succeeded();\n+                    return;\n+                }\n+                else if (content.getError() != null)\n+                {\n+                    if (c.getError() != null)\n+                    {\n+                        if (c.getError() != content.getError())\n+                            c.getError().addSuppressed(content.getError());\n+                        return;\n+                    }\n+                    if (_content.compareAndSet(c, content))\n+                    {\n+                        c.failed(content.getError());\n+                        return;\n+                    }\n+                }\n+                else if (c.getError() != null && content.remaining() == 0)\n+                {\n+                    content.succeeded();\n+                    return;\n+                }\n+                else\n+                {\n+                    throw new IllegalStateException(\"Cannot overwrite exiting content \" + c + \" with \" + content);\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public boolean onTimeout(Throwable failure)\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c != DEMANDING)\n+                    return false;\n+                if (_content.compareAndSet(DEMANDING, new HttpInput.ErrorContent(failure)))\n+                    return true;\n+            }\n+        }\n+\n+        @Override\n+        public void eof()\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c == DEMANDING)\n+                {\n+                    if (_content.compareAndSet(DEMANDING, EOF))\n+                        return;\n+                }\n+                else if (c == null)\n+                {\n+                    if (_content.compareAndSet(null, EOF))\n+                        return;\n+                }\n+                else if (c.isEof())\n+                {\n+                    return;\n+                }\n+                else if (c.remaining() == 0)\n+                {\n+                    if (_content.compareAndSet(c, EOF))\n+                        return;\n+                }\n+                else\n+                {\n+                    HttpInput.Content content = new HttpInput.Content(c.getByteBuffer())\n+                    {\n+                        @Override\n+                        public boolean isEof()\n+                        {\n+                            return true;\n+                        }\n+\n+                        @Override\n+                        public void succeeded()\n+                        {\n+                            c.succeeded();\n+                        }\n+\n+                        @Override\n+                        public void failed(Throwable x)\n+                        {\n+                            c.failed(x);\n+                        }\n+\n+                        @Override\n+                        public InvocationType getInvocationType()\n+                        {\n+                            return c.getInvocationType();\n+                        }\n+                    };\n+                    if (_content.compareAndSet(c, content))\n+                        return;\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void failContent(Throwable failure)\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c == null || c.isSpecial())\n+                    return;\n+                if (_content.compareAndSet(c, null))\n+                {\n+                    c.failed(failure);\n+                    return;\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public boolean needContent()\n+    {\n+        Tracer.in();", "originalCommit": "24bbc717dd41dee613298b0b71d35ed35a556e61", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI0NzM1Mg==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r503247352", "bodyText": "Done.", "author": "lorban", "createdAt": "2020-10-12T12:01:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzIwMzk0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzIwNDY3OA==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r503204678", "bodyText": "We need a puml interaction diagram and/or state diagram for this state machine!", "author": "gregw", "createdAt": "2020-10-12T10:40:56Z", "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpChannelOverHTTP2.java", "diffHunk": "@@ -261,31 +268,408 @@ public InvocationType getInvocationType()\n             {\n                 return callback.getInvocationType();\n             }\n-        });\n+        };\n+        _contentDemander.onContent(content);\n+        boolean handle = onContent(content);\n \n         boolean endStream = frame.isEndStream();\n         if (endStream)\n         {\n             boolean handleContent = onContentComplete();\n+            // this will generate EOF -> must happen before wakeup\n             boolean handleRequest = onRequestComplete();\n             handle |= handleContent | handleRequest;\n         }\n \n+        boolean woken = getRequest().getHttpInput().wakeup();\n         if (LOG.isDebugEnabled())\n         {\n-            LOG.debug(\"HTTP2 Request #{}/{}: {} bytes of {} content, handle: {}\",\n+            Stream stream = getStream();\n+            LOG.debug(\"HTTP2 Request #{}/{}: {} bytes of {} content, woken: {}, handle: {}\",\n                     stream.getId(),\n                     Integer.toHexString(stream.getSession().hashCode()),\n                     length,\n                     endStream ? \"last\" : \"some\",\n+                    woken,\n                     handle);\n         }\n+        handle |= woken;\n \n         boolean wasDelayed = _delayedUntilContent;\n         _delayedUntilContent = false;\n         return handle || wasDelayed ? this : null;\n     }\n \n+    private interface ContentDemander\n+    {\n+        void eof();\n+\n+        void recycle();\n+\n+        HttpInput.Content take();\n+\n+        boolean demand();\n+\n+        void onContent(HttpInput.Content content);\n+\n+        boolean onTimeout(Throwable failure);\n+\n+        void failContent(Throwable failure);\n+    }\n+\n+    private class ContentDemanderQueue implements ContentDemander\n+    {\n+        private boolean _demanding;\n+        private final Queue<HttpInput.Content> _contentQueue = new LinkedList<>();\n+\n+        @Override\n+        public synchronized void recycle()\n+        {\n+            _contentQueue.forEach(c ->\n+            {\n+                if (!c.isSpecial())\n+                    throw new AssertionError(\"unconsumed content: \" + _contentQueue);\n+            });\n+            _demanding = false;\n+            _contentQueue.clear();\n+        }\n+\n+        @Override\n+        public synchronized HttpInput.Content take()\n+        {\n+            HttpInput.Content c = _contentQueue.peek();\n+            if (c != null && !c.isSpecial())\n+            {\n+                _contentQueue.poll();\n+                if (c.isEof())\n+                    _contentQueue.add(EOF);\n+            }\n+            return c;\n+        }\n+\n+        @Override\n+        public synchronized boolean demand()\n+        {\n+            if (!_contentQueue.isEmpty())\n+                return true;\n+            if (!_demanding)\n+            {\n+                _demanding = true;\n+                IStream stream = getStream();\n+                if (stream == null)\n+                    _demanding = false;\n+                else\n+                    stream.demand(1);\n+            }\n+            return !_contentQueue.isEmpty();\n+        }\n+\n+        @Override\n+        public synchronized void onContent(HttpInput.Content content)\n+        {\n+            _demanding = false; // TODO maybe distinguish between upstream content and downstream errors\n+            if (content.isEof() && content.isSpecial() && content.isEmpty() && _contentQueue.size() == 1 && _contentQueue.peek().isEof())\n+            {\n+                content.succeeded();\n+                return;\n+            }\n+\n+            // error content fails and replaces any other content\n+            Throwable x = content.getError();\n+            if (x != null)\n+            {\n+                _contentQueue.forEach(c -> c.failed(x));\n+                _contentQueue.clear();\n+            }\n+\n+            _contentQueue.offer(content);\n+            if (_contentQueue.size() > 1)\n+                throw new AssertionError(\"Queue should never be more than 1: \" + _contentQueue);\n+        }\n+\n+        @Override\n+        public synchronized boolean onTimeout(Throwable failure)\n+        {\n+            if (_demanding && _contentQueue.isEmpty())\n+            {\n+                _demanding = false;\n+                _contentQueue.add(new HttpInput.ErrorContent(failure));\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public synchronized void eof()\n+        {\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"received EOF\");\n+\n+            if (_contentQueue.size() != 1 || !_contentQueue.peek().isEof())\n+                _contentQueue.add(EOF);\n+        }\n+\n+        @Override\n+        public synchronized void failContent(Throwable failure)\n+        {\n+            for (Iterator<HttpInput.Content> i = _contentQueue.iterator(); i.hasNext();)\n+            {\n+                HttpInput.Content c = i.next();\n+                if (!c.isSpecial())\n+                {\n+                    i.remove();\n+                    c.failed(failure);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static final HttpInput.Content EOF = new HttpInput.EofContent();\n+    private static final HttpInput.Content DEMANDING = new HttpInput.SpecialContent() {};\n+\n+    private class ContentDemanderAtomic implements ContentDemander\n+    {\n+        private final AtomicReference<HttpInput.Content> _content = new AtomicReference<>();", "originalCommit": "24bbc717dd41dee613298b0b71d35ed35a556e61", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI2MjkzNg==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r503262936", "bodyText": "I added a state diagram. I don't think an interaction diagram is going to help much as the code is relatively short and self contained.", "author": "lorban", "createdAt": "2020-10-12T12:32:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzIwNDY3OA=="}], "type": "inlineReview"}, {"oid": "82919412dbd87260462ec3127cd57d9ffbe1c73f", "url": "https://github.com/eclipse/jetty.project/commit/82919412dbd87260462ec3127cd57d9ffbe1c73f", "message": "remove tracer\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-10-12T12:06:42Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzM5ODk3Mw==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r503398973", "bodyText": "ALERT ALERT ALERT!!!!!!\nOMG a queue!!!!!!!!!!!\n:)", "author": "gregw", "createdAt": "2020-10-12T16:14:14Z", "path": "jetty-fcgi/fcgi-server/src/main/java/org/eclipse/jetty/fcgi/server/HttpChannelOverFCGI.java", "diffHunk": "@@ -43,6 +46,8 @@\n {\n     private static final Logger LOG = LoggerFactory.getLogger(HttpChannelOverFCGI.class);\n \n+    private final Queue<HttpInput.Content> _contentQueue = new LinkedList<>();", "originalCommit": "e86ce0103c9041952160e0cacbf48acde3f0ea60", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzc1NDcxNw==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r503754717", "bodyText": "In FCGI, yes. This makes the implementation sooo much simpler that I don't think it's worth the effort of getting rid of it.", "author": "lorban", "createdAt": "2020-10-13T08:15:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzM5ODk3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQwMDA5NQ==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r503400095", "bodyText": "Why?", "author": "gregw", "createdAt": "2020-10-12T16:16:16Z", "path": "jetty-http2/http2-common/src/main/java/org/eclipse/jetty/http2/HTTP2StreamEndPoint.java", "diffHunk": "@@ -611,6 +610,7 @@ private IOException ioFailure()\n         private void succeed()\n         {\n             callback.succeeded();\n+            stream.demand(1);", "originalCommit": "e86ce0103c9041952160e0cacbf48acde3f0ea60", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzc2MjQ4Ng==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r503762486", "bodyText": "This change, plus the ones in HTTP2ServerConnectionFactory and Stream were related to a bug in the H2's handling of backward compatibility calls (onDataDemanded vs onData) but the details are long gone from my mind. I modified those methods after a lengthy discussion with @sbordet so maybe he could remember the details?\nAnyways, if my memory is right, those could go into a separate PR.", "author": "lorban", "createdAt": "2020-10-13T08:26:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQwMDA5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzgxOTgyMg==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r503819822", "bodyText": "What tests fail if it is removed?\nI think having multiple things doing demand is at worst a big race and at best a source of unwanted events that make back pressure not work.\nIf we are demanding on every successful onData entry, then how sure are we that we are really getting back pressure from the application via HttpInput?  Isn't this demand here going to negate the demand we do in HttpChannelOverHttp2?", "author": "gregw", "createdAt": "2020-10-13T09:52:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQwMDA5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA1MDA4OA==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504050088", "bodyText": "I've investigated this and asked @sbordet for his help, and here's my this demand() call is required:\nBefore these changes, Content used to be queued and demand used to be chained automatically, i.e.: each time a demand was served, another one was automatically registered without HttpChannelOverHTTP2 or any other class having to explicitly call demand(1).\nSince we're not queuing anymore, HttpChannelOverHTTP2 needs explicit control over when demand is called, so HTTP2ServerConnectionFactory now overrides onDataDemanded() instead of onData() and we have to manually call demand(1) for serving HttpInput requests (as is done in HttpChannelOverHTTP2.needContent() and produceContent()) but also for other uses that do not make use of HttpChannelOverHTTP2 like this tunnelling EndPoint that is used by WebSockets.", "author": "lorban", "createdAt": "2020-10-13T15:31:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQwMDA5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQwMjg4Nw==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r503402887", "bodyText": "Need a comment somewhere saying why atomics/volatiles/locks are not needed in this class", "author": "gregw", "createdAt": "2020-10-12T16:21:18Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpChannelOverHttp.java", "diffHunk": "@@ -75,6 +78,55 @@ public void abort(Throwable failure)\n         _httpConnection.getGenerator().setPersistent(false);\n     }\n \n+    @Override\n+    public boolean needContent()\n+    {\n+        if (_specialContent != null || _content != null)", "originalCommit": "e86ce0103c9041952160e0cacbf48acde3f0ea60", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzc1NDkwOA==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r503754908", "bodyText": "Done.", "author": "lorban", "createdAt": "2020-10-13T08:15:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQwMjg4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQwMzI3MA==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r503403270", "bodyText": "remove XXXs", "author": "gregw", "createdAt": "2020-10-12T16:21:59Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpChannelOverHttp.java", "diffHunk": "@@ -75,6 +78,55 @@ public void abort(Throwable failure)\n         _httpConnection.getGenerator().setPersistent(false);\n     }\n \n+    @Override\n+    public boolean needContent()\n+    {\n+        if (_specialContent != null || _content != null)\n+        {\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"needContent has content immediately available: c={} sc={}\", _content, _specialContent);\n+            return true;\n+        }\n+        _httpConnection.parseAndFillForContent();\n+        if (_specialContent != null || _content != null)\n+        {\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"needContent has content after parseAndFillForContent: c={} sc={}\", _content, _specialContent);\n+            return true;\n+        }\n+\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"needContent has no content\");\n+        _httpConnection.asyncReadFillInterested();\n+        return false;\n+    }\n+\n+    @Override\n+    public HttpInput.Content produceContent()\n+    {\n+        // XXX if (_content == null && _specialContent == null)", "originalCommit": "e86ce0103c9041952160e0cacbf48acde3f0ea60", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzc1NDk1Nw==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r503754957", "bodyText": "Done.", "author": "lorban", "createdAt": "2020-10-13T08:15:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQwMzI3MA=="}], "type": "inlineReview"}, {"oid": "46d881adf81e66f15e036ff668c0e596236da0bc", "url": "https://github.com/eclipse/jetty.project/commit/46d881adf81e66f15e036ff668c0e596236da0bc", "message": "changes after review #1\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-10-13T08:28:00Z", "type": "forcePushed"}, {"oid": "273213e8df4f438bf853787ec932e22424e7fe8b", "url": "https://github.com/eclipse/jetty.project/commit/273213e8df4f438bf853787ec932e22424e7fe8b", "message": "move demand out of Entry.succeed and comment explaining why it must be explicitly called\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-10-13T15:22:08Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDk3OTYxMA==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504979610", "bodyText": "javadoc please", "author": "gregw", "createdAt": "2020-10-14T21:22:07Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/BlockingContentProducer.java", "diffHunk": "@@ -0,0 +1,133 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.util.concurrent.Semaphore;\n+\n+class BlockingContentProducer implements ContentProducer", "originalCommit": "273213e8df4f438bf853787ec932e22424e7fe8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTIyNzcyOA==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r509227728", "bodyText": "Done.", "author": "lorban", "createdAt": "2020-10-21T12:15:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDk3OTYxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDk3OTk2OQ==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504979969", "bodyText": "I really REALLY don't like having drainPermits.  This should not be necessary", "author": "gregw", "createdAt": "2020-10-14T21:22:50Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/BlockingContentProducer.java", "diffHunk": "@@ -0,0 +1,133 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.util.concurrent.Semaphore;\n+\n+class BlockingContentProducer implements ContentProducer\n+{\n+    private final Semaphore _semaphore = new Semaphore(0);\n+    private final AsyncContentProducer _asyncContentProducer;\n+    private final HttpChannel _httpChannel;\n+\n+    public BlockingContentProducer(HttpChannel httpChannel, AsyncContentProducer delegate)\n+    {\n+        _asyncContentProducer = delegate;\n+        _httpChannel = httpChannel;\n+    }\n+\n+    @Override\n+    public void recycle()\n+    {\n+        _asyncContentProducer.recycle();\n+    }\n+\n+    @Override\n+    public int available()\n+    {\n+        return _asyncContentProducer.available();\n+    }\n+\n+    @Override\n+    public boolean hasContent()\n+    {\n+        return _asyncContentProducer.hasContent();\n+    }\n+\n+    @Override\n+    public boolean isError()\n+    {\n+        return _asyncContentProducer.isError();\n+    }\n+\n+    @Override\n+    public void checkMinDataRate()\n+    {\n+        _asyncContentProducer.checkMinDataRate();\n+    }\n+\n+    @Override\n+    public long getRawContentArrived()\n+    {\n+        return _asyncContentProducer.getRawContentArrived();\n+    }\n+\n+    @Override\n+    public boolean consumeAll(Throwable x)\n+    {\n+        return _asyncContentProducer.consumeAll(x);\n+    }\n+\n+    @Override\n+    public HttpInput.Content nextContent()\n+    {\n+        while (true)\n+        {\n+            HttpInput.Content content = _asyncContentProducer.nextContent();\n+            if (content != null)\n+                return content;\n+\n+            _semaphore.drainPermits();", "originalCommit": "273213e8df4f438bf853787ec932e22424e7fe8b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDk5MjE5MQ==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504992191", "bodyText": "I think this is wrong because it means a spurious wakeup can occur even if needContent has not been called.\nA call to produceContent can do demand, so onData may be called at any time afterwards... so it is wrong for it to wakeup HttpInput if needContent has not been called.\nThis class needs to know if needContent has been called and only do a wakeup if it has.", "author": "gregw", "createdAt": "2020-10-14T21:47:52Z", "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpChannelOverHTTP2.java", "diffHunk": "@@ -261,31 +264,265 @@ public InvocationType getInvocationType()\n             {\n                 return callback.getInvocationType();\n             }\n-        });\n+        };\n+        _contentDemander.onContent(content);\n+        boolean handle = onContent(content);\n \n         boolean endStream = frame.isEndStream();\n         if (endStream)\n         {\n             boolean handleContent = onContentComplete();\n+            // this will generate EOF -> must happen before wakeup\n             boolean handleRequest = onRequestComplete();\n             handle |= handleContent | handleRequest;\n         }\n \n+        boolean woken = getRequest().getHttpInput().wakeup();", "originalCommit": "273213e8df4f438bf853787ec932e22424e7fe8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTM0MTM0MA==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505341340", "bodyText": "The more I think about this, the more I'm convinced we need a dedicated onContentAvailable callback that is only called if needContent has been called.", "author": "gregw", "createdAt": "2020-10-15T08:34:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDk5MjE5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTM2MDQ3NQ==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505360475", "bodyText": "We could almost pass a Callback in needContent to make the contract clear!", "author": "gregw", "createdAt": "2020-10-15T08:49:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDk5MjE5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDc4MjY5NQ==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504782695", "bodyText": "Use AutoLock where you use synchronized.", "author": "sbordet", "createdAt": "2020-10-14T15:43:31Z", "path": "jetty-fcgi/fcgi-server/src/main/java/org/eclipse/jetty/fcgi/server/HttpChannelOverFCGI.java", "diffHunk": "@@ -57,6 +62,92 @@ public HttpChannelOverFCGI(Connector connector, HttpConfiguration configuration,\n         this.dispatcher = new Dispatcher(connector.getServer().getThreadPool(), this);\n     }\n \n+    void enqueueContent(HttpInput.Content content)\n+    {\n+        Throwable failure;\n+        synchronized (_contentQueue)", "originalCommit": "273213e8df4f438bf853787ec932e22424e7fe8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjE0Nzg2MA==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r506147860", "bodyText": "Done.", "author": "lorban", "createdAt": "2020-10-16T08:04:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDc4MjY5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDc4NTc5Ng==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504785796", "bodyText": "Missing javadocs.", "author": "sbordet", "createdAt": "2020-10-14T15:47:57Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpChannel.java", "diffHunk": "@@ -119,11 +119,23 @@ public boolean isSendError()\n         return _state.isSendError();\n     }\n \n-    protected HttpInput newHttpInput(HttpChannelState state)\n+    private HttpInput newHttpInput(HttpChannelState state)\n     {\n         return new HttpInput(state);\n     }\n \n+    /**\n+     * @return true if content is immediately available.\n+     */\n+    public abstract boolean needContent();\n+\n+    /**\n+     * @return a {@link HttpInput.Content} object if one is immediately available without blocking, null otherwise.\n+     */\n+    public abstract HttpInput.Content produceContent();\n+\n+    public abstract void failContent(Throwable failure);", "originalCommit": "273213e8df4f438bf853787ec932e22424e7fe8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU5NTA3Ng==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505595076", "bodyText": "Sorted.", "author": "lorban", "createdAt": "2020-10-15T14:36:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDc4NTc5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDc4NjY1NA==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504786654", "bodyText": "Needs an explanation of what exactly the contract is, because produceContent() returns null if there is no content, so why would you need needContent() - I'm guessing to implement available(), but needs to be made clear.", "author": "sbordet", "createdAt": "2020-10-14T15:49:11Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpChannel.java", "diffHunk": "@@ -119,11 +119,23 @@ public boolean isSendError()\n         return _state.isSendError();\n     }\n \n-    protected HttpInput newHttpInput(HttpChannelState state)\n+    private HttpInput newHttpInput(HttpChannelState state)\n     {\n         return new HttpInput(state);\n     }\n \n+    /**\n+     * @return true if content is immediately available.\n+     */\n+    public abstract boolean needContent();", "originalCommit": "273213e8df4f438bf853787ec932e22424e7fe8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTM3NjUyMQ==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505376521", "bodyText": "EXACTLY!!!!!!!!!!!! needContent and produceContent are key parts of the new contract between HttpInput and HttpChannel so that we don't need to extend HttpInput on a a per transport/protocol basis.\nThis is the contract that needs a lot more rigour in both documentation and implementation.\nAs I have said elsewhere, it is not sufficient for the response to a needContent to just be a wakeup call that can be called for a thousand other reasons.   It needs  to be a precise success of failure callback.   I really think it should be:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public abstract boolean needContent();\n          \n          \n            \n                public abstract boolean needContent(Callback callback);\n          \n      \n    \n    \n  \n\nIf some error occurs when there is not a callback, then it needs to be delivered differently because there is no async or blocking operation for it to be delivered to.", "author": "gregw", "createdAt": "2020-10-15T09:04:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDc4NjY1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU5NjY3OQ==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505596679", "bodyText": "I agree that the contract currently is too loosely defined, but I think a good dose of javadoc should solve this.\nRegarding the new needContent(Callback) signature, I find the idea interesting. I'm going to try it out to see if it would improve clarity.", "author": "lorban", "createdAt": "2020-10-15T14:38:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDc4NjY1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTIyODU0Mw==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r509228543", "bodyText": "Hopefully the javadoc is now clear enough about what the contract is.", "author": "lorban", "createdAt": "2020-10-21T12:17:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDc4NjY1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjEwNDYwOA==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r512104608", "bodyText": "maybe a note about that if a failure happens, then onContentProduceable will be called and an ErrorContent will return the error on the next call to produceContent", "author": "gregw", "createdAt": "2020-10-26T16:40:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDc4NjY1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjU2ODc3OQ==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r512568779", "bodyText": "Added javadoc explaining the failure behavior.", "author": "lorban", "createdAt": "2020-10-27T10:20:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDc4NjY1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDc4NzUxNA==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504787514", "bodyText": "Perhaps expand the javadocs saying that the content is raw (i.e. not decoded). Can \"special\" content be returned here?", "author": "sbordet", "createdAt": "2020-10-14T15:50:18Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpChannel.java", "diffHunk": "@@ -119,11 +119,23 @@ public boolean isSendError()\n         return _state.isSendError();\n     }\n \n-    protected HttpInput newHttpInput(HttpChannelState state)\n+    private HttpInput newHttpInput(HttpChannelState state)\n     {\n         return new HttpInput(state);\n     }\n \n+    /**\n+     * @return true if content is immediately available.\n+     */\n+    public abstract boolean needContent();\n+\n+    /**\n+     * @return a {@link HttpInput.Content} object if one is immediately available without blocking, null otherwise.\n+     */\n+    public abstract HttpInput.Content produceContent();", "originalCommit": "273213e8df4f438bf853787ec932e22424e7fe8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU5NDExNA==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505594114", "bodyText": "Yes, I'm going to javadoc that the returned content is not decoded and that special content can be returned.", "author": "lorban", "createdAt": "2020-10-15T14:35:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDc4NzUxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDc5Mzk3OA==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504793978", "bodyText": "This is not right, I think.\nAs soon as the parser parses some content, it should notify HttpChannel.onContent().\nThis class should override onContent(), call super, and then queue the content.", "author": "sbordet", "createdAt": "2020-10-14T15:58:59Z", "path": "jetty-fcgi/fcgi-server/src/main/java/org/eclipse/jetty/fcgi/server/HttpChannelOverFCGI.java", "diffHunk": "@@ -57,6 +62,92 @@ public HttpChannelOverFCGI(Connector connector, HttpConfiguration configuration,\n         this.dispatcher = new Dispatcher(connector.getServer().getThreadPool(), this);\n     }\n \n+    void enqueueContent(HttpInput.Content content)\n+    {\n+        Throwable failure;\n+        synchronized (_contentQueue)\n+        {\n+            failure = _specialContent == null ? null : _specialContent.getError();\n+            if (failure == null)\n+                _contentQueue.offer(content);\n+        }\n+        if (failure != null)\n+            content.failed(failure);\n+    }\n+\n+    @Override\n+    public boolean needContent()\n+    {\n+        synchronized (_contentQueue)\n+        {\n+            if (_specialContent != null)\n+                return true;\n+            return !_contentQueue.isEmpty();\n+        }\n+    }\n+\n+    @Override\n+    public HttpInput.Content produceContent()\n+    {\n+        HttpInput.Content content;\n+        synchronized (_contentQueue)\n+        {\n+            content = _contentQueue.poll();\n+        }\n+        if (content != null)\n+        {\n+            onContent(content);", "originalCommit": "273213e8df4f438bf853787ec932e22424e7fe8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjE0ODU3MA==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r506148570", "bodyText": "You're right, I'll change that.", "author": "lorban", "createdAt": "2020-10-16T08:05:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDc5Mzk3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDc5NTE4Mg==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504795182", "bodyText": "HttpInput.Content is a Callback. Just clearing the queue does not feel right - should you not fail all the elements?\nAlso the method is called failContent() as if it would fail a specific content, but it fails all of them?", "author": "sbordet", "createdAt": "2020-10-14T16:00:37Z", "path": "jetty-fcgi/fcgi-server/src/main/java/org/eclipse/jetty/fcgi/server/HttpChannelOverFCGI.java", "diffHunk": "@@ -57,6 +62,92 @@ public HttpChannelOverFCGI(Connector connector, HttpConfiguration configuration,\n         this.dispatcher = new Dispatcher(connector.getServer().getThreadPool(), this);\n     }\n \n+    void enqueueContent(HttpInput.Content content)\n+    {\n+        Throwable failure;\n+        synchronized (_contentQueue)\n+        {\n+            failure = _specialContent == null ? null : _specialContent.getError();\n+            if (failure == null)\n+                _contentQueue.offer(content);\n+        }\n+        if (failure != null)\n+            content.failed(failure);\n+    }\n+\n+    @Override\n+    public boolean needContent()\n+    {\n+        synchronized (_contentQueue)\n+        {\n+            if (_specialContent != null)\n+                return true;\n+            return !_contentQueue.isEmpty();\n+        }\n+    }\n+\n+    @Override\n+    public HttpInput.Content produceContent()\n+    {\n+        HttpInput.Content content;\n+        synchronized (_contentQueue)\n+        {\n+            content = _contentQueue.poll();\n+        }\n+        if (content != null)\n+        {\n+            onContent(content);\n+        }\n+        else\n+        {\n+            synchronized (_contentQueue)\n+            {\n+                content = _specialContent;\n+            }\n+        }\n+        return content;\n+    }\n+\n+    @Override\n+    public void failContent(Throwable failure)\n+    {\n+        synchronized (_contentQueue)\n+        {\n+            _contentQueue.clear();\n+        }", "originalCommit": "273213e8df4f438bf853787ec932e22424e7fe8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTEwNTk5Mw==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r509105993", "bodyText": "You're right, not calling Content.failed() is an oversight that has to be fixed.\nfailContent() is indeed meant to fail all Content objects, so I'm going to rename it to failAllContent() to make that more clear. That, plus javadoc should help better understand the contract of that method.", "author": "lorban", "createdAt": "2020-10-21T08:54:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDc5NTE4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDc5NjgxOA==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504796818", "bodyText": "Coalesce the 2 sync blocks.", "author": "sbordet", "createdAt": "2020-10-14T16:03:04Z", "path": "jetty-fcgi/fcgi-server/src/main/java/org/eclipse/jetty/fcgi/server/HttpChannelOverFCGI.java", "diffHunk": "@@ -127,12 +218,48 @@ protected void dispatch()\n \n     public boolean onIdleTimeout(Throwable timeout)\n     {\n-        boolean handle = getRequest().getHttpInput().onIdleTimeout(timeout);\n+        boolean handle = doOnIdleTimeout(timeout);\n         if (handle)\n             execute(this);\n         return !handle;\n     }\n \n+    private boolean doOnIdleTimeout(Throwable x)\n+    {\n+        boolean neverDispatched = getState().isIdle();\n+        boolean waitingForContent;\n+        synchronized (_contentQueue)\n+        {\n+            waitingForContent = _contentQueue.isEmpty() || _contentQueue.peek().remaining() == 0;\n+        }\n+        HttpInput.Content specialContent;\n+        synchronized (_contentQueue)\n+        {\n+            specialContent = _specialContent;\n+        }", "originalCommit": "273213e8df4f438bf853787ec932e22424e7fe8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTEwNzk1OQ==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r509107959", "bodyText": "Good catch, will do.", "author": "lorban", "createdAt": "2020-10-21T08:57:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDc5NjgxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDc5NzI4Ng==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504797286", "bodyText": "What if the queue is not empty? Items in it should be failed, no?", "author": "sbordet", "createdAt": "2020-10-14T16:03:52Z", "path": "jetty-fcgi/fcgi-server/src/main/java/org/eclipse/jetty/fcgi/server/HttpChannelOverFCGI.java", "diffHunk": "@@ -127,12 +218,48 @@ protected void dispatch()\n \n     public boolean onIdleTimeout(Throwable timeout)\n     {\n-        boolean handle = getRequest().getHttpInput().onIdleTimeout(timeout);\n+        boolean handle = doOnIdleTimeout(timeout);\n         if (handle)\n             execute(this);\n         return !handle;\n     }\n \n+    private boolean doOnIdleTimeout(Throwable x)\n+    {\n+        boolean neverDispatched = getState().isIdle();\n+        boolean waitingForContent;\n+        synchronized (_contentQueue)\n+        {\n+            waitingForContent = _contentQueue.isEmpty() || _contentQueue.peek().remaining() == 0;\n+        }\n+        HttpInput.Content specialContent;\n+        synchronized (_contentQueue)\n+        {\n+            specialContent = _specialContent;\n+        }\n+        if ((waitingForContent || neverDispatched) && specialContent == null)\n+        {\n+            x.addSuppressed(new Throwable(\"HttpInput idle timeout\"));\n+            synchronized (_contentQueue)\n+            {\n+                _specialContent = new HttpInput.ErrorContent(x);\n+            }\n+            return getRequest().getHttpInput().wakeup();\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public void recycle()\n+    {\n+        synchronized (_contentQueue)\n+        {\n+            _contentQueue.clear();", "originalCommit": "273213e8df4f438bf853787ec932e22424e7fe8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTExMzE5Mg==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r509113192", "bodyText": "Actually, the queue should always be empty. H2 already checks during recycle that no content was left unconsumed and throws an AssertionError otherwise.\nI'm going to replicate this logic here and in HTTP 1.", "author": "lorban", "createdAt": "2020-10-21T09:04:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDc5NzI4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDc5Nzg0Mg==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504797842", "bodyText": "I would call onContent() as before, see previous comment.", "author": "sbordet", "createdAt": "2020-10-14T16:04:40Z", "path": "jetty-fcgi/fcgi-server/src/main/java/org/eclipse/jetty/fcgi/server/ServerFCGIConnection.java", "diffHunk": "@@ -197,7 +197,7 @@ public boolean onContent(int request, FCGI.StreamType stream, ByteBuffer buffer)\n             {\n                 ByteBuffer copy = ByteBuffer.allocate(buffer.remaining());\n                 copy.put(buffer).flip();\n-                channel.onContent(new HttpInput.Content(copy));\n+                channel.enqueueContent(new HttpInput.Content(copy));", "originalCommit": "273213e8df4f438bf853787ec932e22424e7fe8b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDc5ODI1Mg==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504798252", "bodyText": "Nope, calling a callback with a lock held.", "author": "sbordet", "createdAt": "2020-10-14T16:05:13Z", "path": "jetty-http2/http2-common/src/main/java/org/eclipse/jetty/http2/HTTP2Stream.java", "diffHunk": "@@ -235,6 +235,22 @@ public boolean isRemotelyClosed()\n         return state == CloseState.REMOTELY_CLOSED || state == CloseState.CLOSING || state == CloseState.CLOSED;\n     }\n \n+    @Override\n+    public void failAllData(Throwable x)\n+    {\n+        try (AutoLock l = lock.lock())\n+        {\n+            dataDemand = 0;\n+            while (true)\n+            {\n+                DataEntry dataEntry = dataQueue.poll();\n+                if (dataEntry == null)\n+                    break;\n+                dataEntry.callback.failed(x);", "originalCommit": "273213e8df4f438bf853787ec932e22424e7fe8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTExNTI2MQ==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r509115261", "bodyText": "Good catch, let me fix that.", "author": "lorban", "createdAt": "2020-10-21T09:07:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDc5ODI1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgwMDMzMA==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504800330", "bodyText": "Let's not put into comment previous versions of the implementation.\nThe reason to demand after succeeding an entry is because WebSocket does not have a backpressure API so you must always demand the next frame.", "author": "sbordet", "createdAt": "2020-10-14T16:08:07Z", "path": "jetty-http2/http2-common/src/main/java/org/eclipse/jetty/http2/HTTP2StreamEndPoint.java", "diffHunk": "@@ -216,6 +216,12 @@ public int fill(ByteBuffer sink) throws IOException\n         else\n         {\n             entry.succeed();\n+            // A demand must be made here because HTTP2ServerConnectionFactory overrides onDataDemanded() instead of onData()\n+            // to call HttpChannelOverHTTP2.onData() as HttpChannelOverHTTP2 must manually control when Stream.demand() is\n+            // called. When HttpInput used to queue content, it was okay to chain Stream.demand() requests as yet-undemanded\n+            // content was queued. But now that content isn't queued anymore, HttpChannelOverHTTP2 explicitly calls\n+            // Stream.demand() and this fake endpoint must do too to feed content to non-HttpInput users like WebSocket.\n+            stream.demand(1);", "originalCommit": "273213e8df4f438bf853787ec932e22424e7fe8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTExNjg0NA==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r509116844", "bodyText": "Comment updated.", "author": "lorban", "createdAt": "2020-10-21T09:10:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgwMDMzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgyMjUzMw==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504822533", "bodyText": "Is this necessary?\nBefore, a failure had to be notified to HttpInput because it had the queue of content, to fail them all.\nNow that the queue is gone, we should not come back to the stream, because it's the stream that originates the failure, or some other component that has the stream available.\nFor example:\nHttpTransportOverHTTP2.onCompleted() -> has the stream available, so failAllData() may be called here already.\n  HttpChannelOverHTTP2.consumeInput()\n    HttpInput.consumeAll()\n      ContentProducer.consumeAll()\n        HttpChannel.failContent()\n          Stream.failAllData()\n\nSeems like a back and forth that is not justified?\nCan't we just fail the stream immediately rather than forwarding through the channel, input, producer, and back?\nThere are other similar places where the stream is available, but we laser through to HttpInput.", "author": "sbordet", "createdAt": "2020-10-14T16:42:16Z", "path": "jetty-http2/http2-common/src/main/java/org/eclipse/jetty/http2/IStream.java", "diffHunk": "@@ -119,6 +119,13 @@\n      */\n     boolean isRemotelyClosed();\n \n+    /**\n+     * Fail all data queued in the stream and reset\n+     * demand to 0.\n+     * @param x the exception to fail the data with.\n+     */\n+    void failAllData(Throwable x);", "originalCommit": "273213e8df4f438bf853787ec932e22424e7fe8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTEyNTc1Ng==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r509125756", "bodyText": "We could directly call the channel to tell it to fail the content instead of going through HttpInput to do that, but we would still have to call HttpInput for two reasons:\n\nHttpInput's ContentProducer may contain a content object that also needs to be failed.\nHttpInput needs to know if EOF was reached after all content was failed to eventually abort the channel if there is some unconsumed input still in transit.\n\nI'm on the fence between concentrating all that logic in HttpInput.consumeAll() that calls back into the channel or letting each channel take care of failing its content then asking HttpInput to fails its content too passing it a flag to say if EOF was detected by the channel or not. Both have readability drawbacks IMHO.", "author": "lorban", "createdAt": "2020-10-21T09:22:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgyMjUzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgyMzIxMQ==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504823211", "bodyText": "Can't we have a default implementation for all these methods?", "author": "sbordet", "createdAt": "2020-10-14T16:43:24Z", "path": "jetty-security/src/test/java/org/eclipse/jetty/security/authentication/SpnegoAuthenticatorTest.java", "diffHunk": "@@ -62,6 +63,35 @@ public Server getServer()\n                 return null;\n             }\n \n+            @Override\n+            public boolean failed(Throwable x)\n+            {\n+                return false;\n+            }\n+\n+            @Override\n+            protected boolean eof()\n+            {\n+                return false;\n+            }\n+\n+            @Override\n+            public boolean needContent()\n+            {\n+                return false;\n+            }\n+\n+            @Override\n+            public HttpInput.Content produceContent()\n+            {\n+                return null;\n+            }\n+\n+            @Override\n+            public void failContent(Throwable failure)\n+            {\n+            }\n+", "originalCommit": "273213e8df4f438bf853787ec932e22424e7fe8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTEyNzcyOA==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r509127728", "bodyText": "We could, but since every non-test channel must implement them all, I'm not certain it's wise. Maybe we could move them to a new interface and have HttpChannel only have to implement a single getter for the impl of that new itnerface?", "author": "lorban", "createdAt": "2020-10-21T09:25:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgyMzIxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgyMzQ4Mg==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504823482", "bodyText": "Needs javadoc.", "author": "sbordet", "createdAt": "2020-10-14T16:43:53Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/AsyncContentProducer.java", "diffHunk": "@@ -0,0 +1,259 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jetty.http.BadMessageException;\n+import org.eclipse.jetty.http.HttpStatus;\n+\n+class AsyncContentProducer implements ContentProducer", "originalCommit": "273213e8df4f438bf853787ec932e22424e7fe8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTEyODE5OA==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r509128198", "bodyText": "Done.", "author": "lorban", "createdAt": "2020-10-21T09:26:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgyMzQ4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgyNjA3NQ==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504826075", "bodyText": "Remove unnecessary braces and inline.", "author": "sbordet", "createdAt": "2020-10-14T16:47:55Z", "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpChannelOverHTTP2.java", "diffHunk": "@@ -261,31 +264,265 @@ public InvocationType getInvocationType()\n             {\n                 return callback.getInvocationType();\n             }\n-        });\n+        };\n+        _contentDemander.onContent(content);\n+        boolean handle = onContent(content);\n \n         boolean endStream = frame.isEndStream();\n         if (endStream)\n         {\n             boolean handleContent = onContentComplete();\n+            // this will generate EOF -> must happen before wakeup\n             boolean handleRequest = onRequestComplete();\n             handle |= handleContent | handleRequest;\n         }\n \n+        boolean woken = getRequest().getHttpInput().wakeup();\n         if (LOG.isDebugEnabled())\n         {\n-            LOG.debug(\"HTTP2 Request #{}/{}: {} bytes of {} content, handle: {}\",\n+            Stream stream = getStream();\n+            LOG.debug(\"HTTP2 Request #{}/{}: {} bytes of {} content, woken: {}, handle: {}\",\n                     stream.getId(),\n                     Integer.toHexString(stream.getSession().hashCode()),\n                     length,\n                     endStream ? \"last\" : \"some\",\n+                    woken,\n                     handle);\n         }\n+        handle |= woken;\n \n         boolean wasDelayed = _delayedUntilContent;\n         _delayedUntilContent = false;\n         return handle || wasDelayed ? this : null;\n     }\n \n+    private static final HttpInput.Content EOF = new HttpInput.EofContent();\n+    private static final HttpInput.Content DEMANDING = new HttpInput.SpecialContent() {};\n+\n+    private class ContentDemander\n+    {\n+        private final AtomicReference<HttpInput.Content> _content = new AtomicReference<>();\n+\n+        public void recycle()\n+        {\n+            HttpInput.Content c = _content.getAndSet(null);\n+            if (c != null && !c.isSpecial())\n+                throw new AssertionError(\"unconsumed content: \" + c);\n+        }\n+\n+        public HttpInput.Content take()\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c == null || c.isSpecial() || _content.compareAndSet(c, c.isEof() ? EOF : null))\n+                    return c;\n+            }\n+        }\n+\n+        public boolean demand()\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c == DEMANDING)\n+                    return false;\n+                if (c != null)\n+                    return true;\n+                if (_content.compareAndSet(null, DEMANDING))\n+                {\n+                    IStream stream = getStream();\n+                    if (stream == null)\n+                    {\n+                        _content.set(null);\n+                        return false;\n+                    }\n+                    stream.demand(1);\n+                    c = _content.get();\n+                    return c != DEMANDING && c != null;\n+                }\n+            }\n+        }\n+\n+        public void onContent(HttpInput.Content content)\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c == DEMANDING)\n+                {\n+                    if (_content.compareAndSet(DEMANDING, content))\n+                        return;\n+                }\n+                else if (c == null)\n+                {\n+                    if (!content.isSpecial())\n+                        throw new AssertionError(\"Non special content without demand\");\n+                    if (_content.compareAndSet(null, content))\n+                        return;\n+                }\n+                else if (c.isEof() && content.isEof() && content.isEmpty())\n+                {\n+                    content.succeeded();\n+                    return;\n+                }\n+                else if (content.getError() != null)\n+                {\n+                    if (c.getError() != null)\n+                    {\n+                        if (c.getError() != content.getError())\n+                            c.getError().addSuppressed(content.getError());\n+                        return;\n+                    }\n+                    if (_content.compareAndSet(c, content))\n+                    {\n+                        c.failed(content.getError());\n+                        return;\n+                    }\n+                }\n+                else if (c.getError() != null && content.remaining() == 0)\n+                {\n+                    content.succeeded();\n+                    return;\n+                }\n+                else\n+                {\n+                    throw new IllegalStateException(\"Cannot overwrite exiting content \" + c + \" with \" + content);\n+                }\n+            }\n+        }\n+\n+        public boolean onTimeout(Throwable failure)\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c != DEMANDING)\n+                    return false;\n+                if (_content.compareAndSet(DEMANDING, new HttpInput.ErrorContent(failure)))\n+                    return true;\n+            }\n+        }\n+\n+        public void eof()\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c == DEMANDING)\n+                {\n+                    if (_content.compareAndSet(DEMANDING, EOF))\n+                        return;\n+                }\n+                else if (c == null)\n+                {\n+                    if (_content.compareAndSet(null, EOF))\n+                        return;\n+                }\n+                else if (c.isEof())\n+                {\n+                    return;\n+                }\n+                else if (c.remaining() == 0)\n+                {\n+                    if (_content.compareAndSet(c, EOF))\n+                        return;\n+                }\n+                else\n+                {\n+                    HttpInput.Content content = new HttpInput.Content(c.getByteBuffer())\n+                    {\n+                        @Override\n+                        public boolean isEof()\n+                        {\n+                            return true;\n+                        }\n+\n+                        @Override\n+                        public void succeeded()\n+                        {\n+                            c.succeeded();\n+                        }\n+\n+                        @Override\n+                        public void failed(Throwable x)\n+                        {\n+                            c.failed(x);\n+                        }\n+\n+                        @Override\n+                        public InvocationType getInvocationType()\n+                        {\n+                            return c.getInvocationType();\n+                        }\n+                    };\n+                    if (_content.compareAndSet(c, content))\n+                        return;\n+                }\n+            }\n+        }\n+\n+        public void failContent(Throwable failure)\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c == null || c.isSpecial())\n+                    return;\n+                if (_content.compareAndSet(c, null))\n+                {\n+                    c.failed(failure);\n+                    return;\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public boolean needContent()\n+    {\n+        boolean hasContent = _contentDemander.demand();\n+        return hasContent;\n+    }\n+\n+    @Override\n+    public HttpInput.Content produceContent()\n+    {\n+        if (_contentDemander.demand())\n+        {\n+            HttpInput.Content result = _contentDemander.take();\n+            {\n+                return result;\n+            }", "originalCommit": "273213e8df4f438bf853787ec932e22424e7fe8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTIyNzQ5Mg==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r509227492", "bodyText": "Done.", "author": "lorban", "createdAt": "2020-10-21T12:15:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgyNjA3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgyOTQzNw==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504829437", "bodyText": "Before the logic for demanding was not taking into account _delayedUntilContent.\nWhy now it is necessary?", "author": "sbordet", "createdAt": "2020-10-14T16:53:35Z", "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpChannelOverHTTP2.java", "diffHunk": "@@ -131,9 +134,18 @@ public Runnable onRequest(HeadersFrame frame)\n             _delayedUntilContent = getHttpConfiguration().isDelayDispatchUntilContent() &&\n                     !endStream && !_expect100Continue && !connect;\n \n-            // Delay the demand of DATA frames for CONNECT with :protocol.\n-            if (!connect || request.getProtocol() == null)\n-                getStream().demand(1);\n+            // Delay the demand of DATA frames for CONNECT with :protocol\n+            // or for normal requests expecting 100 continue.\n+            if (connect)\n+            {\n+                if (request.getProtocol() == null)\n+                    _contentDemander.demand();\n+            }\n+            else\n+            {\n+                if (_delayedUntilContent)\n+                    _contentDemander.demand();", "originalCommit": "273213e8df4f438bf853787ec932e22424e7fe8b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgzMDQ4Mw==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504830483", "bodyText": "Why this logic has been removed?", "author": "sbordet", "createdAt": "2020-10-14T16:55:15Z", "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpChannelOverHTTP2.java", "diffHunk": "@@ -224,26 +237,16 @@ protected void commit(MetaData.Response info)\n     @Override\n     public Runnable onData(DataFrame frame, Callback callback)\n     {\n-        return onRequestContent(frame, callback);\n-    }\n-\n-    public Runnable onRequestContent(DataFrame frame, final Callback callback)\n-    {\n-        Stream stream = getStream();\n-        if (stream.isReset())\n-        {\n-            // Consume previously queued content to\n-            // enlarge the session flow control window.\n-            consumeInput();\n-            // Consume immediately this content.\n-            callback.succeeded();\n-            return null;\n-        }\n-", "originalCommit": "273213e8df4f438bf853787ec932e22424e7fe8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQwMzA3NA==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r509403074", "bodyText": "Interesting... it actually was part of @gregw 's patch that transformed the ContentDemander to make it atomic. I'll investigate...", "author": "lorban", "createdAt": "2020-10-21T15:50:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgzMDQ4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk2MDg1Nw==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r511960857", "bodyText": "I could not see a reason why, so I've restored it. Maybe @gregw could comment on this?", "author": "lorban", "createdAt": "2020-10-26T13:32:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgzMDQ4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk3MDI4NA==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r511970284", "bodyText": "The call to stream.isReset() is a race, as the stream could be reset the nano second after it is called or at any time during the consumption of the frame that has been passed.\n@sbordet is there any reason to fail fast on reset ?\nIf not, then not handling reset here is the best way to test if we correctly handle a reset if the race is lost.\nBesides, this check is only closing the race window a tiny bit... how often will a stream be reset in the time between a data frame is received and handed to this method?\nI think the logic should be removed", "author": "gregw", "createdAt": "2020-10-26T13:45:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgzMDQ4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDg0NDM3NA==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504844374", "bodyText": "Should be named poll() since take() has typically blocking semantic.", "author": "sbordet", "createdAt": "2020-10-14T17:18:27Z", "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpChannelOverHTTP2.java", "diffHunk": "@@ -261,31 +264,265 @@ public InvocationType getInvocationType()\n             {\n                 return callback.getInvocationType();\n             }\n-        });\n+        };\n+        _contentDemander.onContent(content);\n+        boolean handle = onContent(content);\n \n         boolean endStream = frame.isEndStream();\n         if (endStream)\n         {\n             boolean handleContent = onContentComplete();\n+            // this will generate EOF -> must happen before wakeup\n             boolean handleRequest = onRequestComplete();\n             handle |= handleContent | handleRequest;\n         }\n \n+        boolean woken = getRequest().getHttpInput().wakeup();\n         if (LOG.isDebugEnabled())\n         {\n-            LOG.debug(\"HTTP2 Request #{}/{}: {} bytes of {} content, handle: {}\",\n+            Stream stream = getStream();\n+            LOG.debug(\"HTTP2 Request #{}/{}: {} bytes of {} content, woken: {}, handle: {}\",\n                     stream.getId(),\n                     Integer.toHexString(stream.getSession().hashCode()),\n                     length,\n                     endStream ? \"last\" : \"some\",\n+                    woken,\n                     handle);\n         }\n+        handle |= woken;\n \n         boolean wasDelayed = _delayedUntilContent;\n         _delayedUntilContent = false;\n         return handle || wasDelayed ? this : null;\n     }\n \n+    private static final HttpInput.Content EOF = new HttpInput.EofContent();\n+    private static final HttpInput.Content DEMANDING = new HttpInput.SpecialContent() {};\n+\n+    private class ContentDemander\n+    {\n+        private final AtomicReference<HttpInput.Content> _content = new AtomicReference<>();\n+\n+        public void recycle()\n+        {\n+            HttpInput.Content c = _content.getAndSet(null);\n+            if (c != null && !c.isSpecial())\n+                throw new AssertionError(\"unconsumed content: \" + c);\n+        }\n+\n+        public HttpInput.Content take()", "originalCommit": "273213e8df4f438bf853787ec932e22424e7fe8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTE5Mzk4MA==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r509193980", "bodyText": "Done.", "author": "lorban", "createdAt": "2020-10-21T11:17:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDg0NDM3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDg0NjIxOA==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504846218", "bodyText": "This check can be out of the if block, so you don't have to set _content back to null.", "author": "sbordet", "createdAt": "2020-10-14T17:21:42Z", "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpChannelOverHTTP2.java", "diffHunk": "@@ -261,31 +264,265 @@ public InvocationType getInvocationType()\n             {\n                 return callback.getInvocationType();\n             }\n-        });\n+        };\n+        _contentDemander.onContent(content);\n+        boolean handle = onContent(content);\n \n         boolean endStream = frame.isEndStream();\n         if (endStream)\n         {\n             boolean handleContent = onContentComplete();\n+            // this will generate EOF -> must happen before wakeup\n             boolean handleRequest = onRequestComplete();\n             handle |= handleContent | handleRequest;\n         }\n \n+        boolean woken = getRequest().getHttpInput().wakeup();\n         if (LOG.isDebugEnabled())\n         {\n-            LOG.debug(\"HTTP2 Request #{}/{}: {} bytes of {} content, handle: {}\",\n+            Stream stream = getStream();\n+            LOG.debug(\"HTTP2 Request #{}/{}: {} bytes of {} content, woken: {}, handle: {}\",\n                     stream.getId(),\n                     Integer.toHexString(stream.getSession().hashCode()),\n                     length,\n                     endStream ? \"last\" : \"some\",\n+                    woken,\n                     handle);\n         }\n+        handle |= woken;\n \n         boolean wasDelayed = _delayedUntilContent;\n         _delayedUntilContent = false;\n         return handle || wasDelayed ? this : null;\n     }\n \n+    private static final HttpInput.Content EOF = new HttpInput.EofContent();\n+    private static final HttpInput.Content DEMANDING = new HttpInput.SpecialContent() {};\n+\n+    private class ContentDemander\n+    {\n+        private final AtomicReference<HttpInput.Content> _content = new AtomicReference<>();\n+\n+        public void recycle()\n+        {\n+            HttpInput.Content c = _content.getAndSet(null);\n+            if (c != null && !c.isSpecial())\n+                throw new AssertionError(\"unconsumed content: \" + c);\n+        }\n+\n+        public HttpInput.Content take()\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c == null || c.isSpecial() || _content.compareAndSet(c, c.isEof() ? EOF : null))\n+                    return c;\n+            }\n+        }\n+\n+        public boolean demand()\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c == DEMANDING)\n+                    return false;\n+                if (c != null)\n+                    return true;\n+                if (_content.compareAndSet(null, DEMANDING))\n+                {\n+                    IStream stream = getStream();\n+                    if (stream == null)\n+                    {\n+                        _content.set(null);\n+                        return false;\n+                    }", "originalCommit": "273213e8df4f438bf853787ec932e22424e7fe8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQwNDQ4Mw==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r509404483", "bodyText": "I'm sorry, I don't get this. What check are you referring to?", "author": "lorban", "createdAt": "2020-10-21T15:52:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDg0NjIxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDg0NzE0OQ==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504847149", "bodyText": "The above 2 lines are the same as the first lines, can't you just loop around after stream.demand(1)?", "author": "sbordet", "createdAt": "2020-10-14T17:23:23Z", "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpChannelOverHTTP2.java", "diffHunk": "@@ -261,31 +264,265 @@ public InvocationType getInvocationType()\n             {\n                 return callback.getInvocationType();\n             }\n-        });\n+        };\n+        _contentDemander.onContent(content);\n+        boolean handle = onContent(content);\n \n         boolean endStream = frame.isEndStream();\n         if (endStream)\n         {\n             boolean handleContent = onContentComplete();\n+            // this will generate EOF -> must happen before wakeup\n             boolean handleRequest = onRequestComplete();\n             handle |= handleContent | handleRequest;\n         }\n \n+        boolean woken = getRequest().getHttpInput().wakeup();\n         if (LOG.isDebugEnabled())\n         {\n-            LOG.debug(\"HTTP2 Request #{}/{}: {} bytes of {} content, handle: {}\",\n+            Stream stream = getStream();\n+            LOG.debug(\"HTTP2 Request #{}/{}: {} bytes of {} content, woken: {}, handle: {}\",\n                     stream.getId(),\n                     Integer.toHexString(stream.getSession().hashCode()),\n                     length,\n                     endStream ? \"last\" : \"some\",\n+                    woken,\n                     handle);\n         }\n+        handle |= woken;\n \n         boolean wasDelayed = _delayedUntilContent;\n         _delayedUntilContent = false;\n         return handle || wasDelayed ? this : null;\n     }\n \n+    private static final HttpInput.Content EOF = new HttpInput.EofContent();\n+    private static final HttpInput.Content DEMANDING = new HttpInput.SpecialContent() {};\n+\n+    private class ContentDemander\n+    {\n+        private final AtomicReference<HttpInput.Content> _content = new AtomicReference<>();\n+\n+        public void recycle()\n+        {\n+            HttpInput.Content c = _content.getAndSet(null);\n+            if (c != null && !c.isSpecial())\n+                throw new AssertionError(\"unconsumed content: \" + c);\n+        }\n+\n+        public HttpInput.Content take()\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c == null || c.isSpecial() || _content.compareAndSet(c, c.isEof() ? EOF : null))\n+                    return c;\n+            }\n+        }\n+\n+        public boolean demand()\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c == DEMANDING)\n+                    return false;\n+                if (c != null)\n+                    return true;\n+                if (_content.compareAndSet(null, DEMANDING))\n+                {\n+                    IStream stream = getStream();\n+                    if (stream == null)\n+                    {\n+                        _content.set(null);\n+                        return false;\n+                    }\n+                    stream.demand(1);\n+                    c = _content.get();\n+                    return c != DEMANDING && c != null;", "originalCommit": "273213e8df4f438bf853787ec932e22424e7fe8b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDg0ODk4NQ==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504848985", "bodyText": "This covers multiple EOF? Can an EOF content be non-empty? Because if it can, it will end up in the illegal case below.", "author": "sbordet", "createdAt": "2020-10-14T17:26:07Z", "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpChannelOverHTTP2.java", "diffHunk": "@@ -261,31 +264,265 @@ public InvocationType getInvocationType()\n             {\n                 return callback.getInvocationType();\n             }\n-        });\n+        };\n+        _contentDemander.onContent(content);\n+        boolean handle = onContent(content);\n \n         boolean endStream = frame.isEndStream();\n         if (endStream)\n         {\n             boolean handleContent = onContentComplete();\n+            // this will generate EOF -> must happen before wakeup\n             boolean handleRequest = onRequestComplete();\n             handle |= handleContent | handleRequest;\n         }\n \n+        boolean woken = getRequest().getHttpInput().wakeup();\n         if (LOG.isDebugEnabled())\n         {\n-            LOG.debug(\"HTTP2 Request #{}/{}: {} bytes of {} content, handle: {}\",\n+            Stream stream = getStream();\n+            LOG.debug(\"HTTP2 Request #{}/{}: {} bytes of {} content, woken: {}, handle: {}\",\n                     stream.getId(),\n                     Integer.toHexString(stream.getSession().hashCode()),\n                     length,\n                     endStream ? \"last\" : \"some\",\n+                    woken,\n                     handle);\n         }\n+        handle |= woken;\n \n         boolean wasDelayed = _delayedUntilContent;\n         _delayedUntilContent = false;\n         return handle || wasDelayed ? this : null;\n     }\n \n+    private static final HttpInput.Content EOF = new HttpInput.EofContent();\n+    private static final HttpInput.Content DEMANDING = new HttpInput.SpecialContent() {};\n+\n+    private class ContentDemander\n+    {\n+        private final AtomicReference<HttpInput.Content> _content = new AtomicReference<>();\n+\n+        public void recycle()\n+        {\n+            HttpInput.Content c = _content.getAndSet(null);\n+            if (c != null && !c.isSpecial())\n+                throw new AssertionError(\"unconsumed content: \" + c);\n+        }\n+\n+        public HttpInput.Content take()\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c == null || c.isSpecial() || _content.compareAndSet(c, c.isEof() ? EOF : null))\n+                    return c;\n+            }\n+        }\n+\n+        public boolean demand()\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c == DEMANDING)\n+                    return false;\n+                if (c != null)\n+                    return true;\n+                if (_content.compareAndSet(null, DEMANDING))\n+                {\n+                    IStream stream = getStream();\n+                    if (stream == null)\n+                    {\n+                        _content.set(null);\n+                        return false;\n+                    }\n+                    stream.demand(1);\n+                    c = _content.get();\n+                    return c != DEMANDING && c != null;\n+                }\n+            }\n+        }\n+\n+        public void onContent(HttpInput.Content content)\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c == DEMANDING)\n+                {\n+                    if (_content.compareAndSet(DEMANDING, content))\n+                        return;\n+                }\n+                else if (c == null)\n+                {\n+                    if (!content.isSpecial())\n+                        throw new AssertionError(\"Non special content without demand\");\n+                    if (_content.compareAndSet(null, content))\n+                        return;\n+                }\n+                else if (c.isEof() && content.isEof() && content.isEmpty())", "originalCommit": "273213e8df4f438bf853787ec932e22424e7fe8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQwNTY2Mw==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r509405663", "bodyText": "A non-empty EOF should never be passed to this onContent method, otherwise it's a bug. The eof method should be called instead.", "author": "lorban", "createdAt": "2020-10-21T15:53:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDg0ODk4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDg1MjQwNg==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504852406", "bodyText": "Cannot throw! The content won't be completed and the flow control window will close. Must fail the content.", "author": "sbordet", "createdAt": "2020-10-14T17:31:52Z", "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpChannelOverHTTP2.java", "diffHunk": "@@ -261,31 +264,265 @@ public InvocationType getInvocationType()\n             {\n                 return callback.getInvocationType();\n             }\n-        });\n+        };\n+        _contentDemander.onContent(content);\n+        boolean handle = onContent(content);\n \n         boolean endStream = frame.isEndStream();\n         if (endStream)\n         {\n             boolean handleContent = onContentComplete();\n+            // this will generate EOF -> must happen before wakeup\n             boolean handleRequest = onRequestComplete();\n             handle |= handleContent | handleRequest;\n         }\n \n+        boolean woken = getRequest().getHttpInput().wakeup();\n         if (LOG.isDebugEnabled())\n         {\n-            LOG.debug(\"HTTP2 Request #{}/{}: {} bytes of {} content, handle: {}\",\n+            Stream stream = getStream();\n+            LOG.debug(\"HTTP2 Request #{}/{}: {} bytes of {} content, woken: {}, handle: {}\",\n                     stream.getId(),\n                     Integer.toHexString(stream.getSession().hashCode()),\n                     length,\n                     endStream ? \"last\" : \"some\",\n+                    woken,\n                     handle);\n         }\n+        handle |= woken;\n \n         boolean wasDelayed = _delayedUntilContent;\n         _delayedUntilContent = false;\n         return handle || wasDelayed ? this : null;\n     }\n \n+    private static final HttpInput.Content EOF = new HttpInput.EofContent();\n+    private static final HttpInput.Content DEMANDING = new HttpInput.SpecialContent() {};\n+\n+    private class ContentDemander\n+    {\n+        private final AtomicReference<HttpInput.Content> _content = new AtomicReference<>();\n+\n+        public void recycle()\n+        {\n+            HttpInput.Content c = _content.getAndSet(null);\n+            if (c != null && !c.isSpecial())\n+                throw new AssertionError(\"unconsumed content: \" + c);\n+        }\n+\n+        public HttpInput.Content take()\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c == null || c.isSpecial() || _content.compareAndSet(c, c.isEof() ? EOF : null))\n+                    return c;\n+            }\n+        }\n+\n+        public boolean demand()\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c == DEMANDING)\n+                    return false;\n+                if (c != null)\n+                    return true;\n+                if (_content.compareAndSet(null, DEMANDING))\n+                {\n+                    IStream stream = getStream();\n+                    if (stream == null)\n+                    {\n+                        _content.set(null);\n+                        return false;\n+                    }\n+                    stream.demand(1);\n+                    c = _content.get();\n+                    return c != DEMANDING && c != null;\n+                }\n+            }\n+        }\n+\n+        public void onContent(HttpInput.Content content)\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c == DEMANDING)\n+                {\n+                    if (_content.compareAndSet(DEMANDING, content))\n+                        return;\n+                }\n+                else if (c == null)\n+                {\n+                    if (!content.isSpecial())\n+                        throw new AssertionError(\"Non special content without demand\");", "originalCommit": "273213e8df4f438bf853787ec932e22424e7fe8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTIyMDgwMA==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r509220800", "bodyText": "Well, if we reach this branch, that means the state machine is broken and we have a bug. I could fail the content before throwing but there's no guarantee that this will help.", "author": "lorban", "createdAt": "2020-10-21T12:04:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDg1MjQwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjYxMDAwMA==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r516610000", "bodyText": "I insist that we cannot throw, even if it's a bug.\nThrowing will cause the server to hang and require a restart, while failing the callback will fail the current request and allow for future requests.", "author": "sbordet", "createdAt": "2020-11-03T11:50:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDg1MjQwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDg1MjYzNA==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504852634", "bodyText": "Cannot throw! Must fail the content and exit the loop.", "author": "sbordet", "createdAt": "2020-10-14T17:32:18Z", "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpChannelOverHTTP2.java", "diffHunk": "@@ -261,31 +264,265 @@ public InvocationType getInvocationType()\n             {\n                 return callback.getInvocationType();\n             }\n-        });\n+        };\n+        _contentDemander.onContent(content);\n+        boolean handle = onContent(content);\n \n         boolean endStream = frame.isEndStream();\n         if (endStream)\n         {\n             boolean handleContent = onContentComplete();\n+            // this will generate EOF -> must happen before wakeup\n             boolean handleRequest = onRequestComplete();\n             handle |= handleContent | handleRequest;\n         }\n \n+        boolean woken = getRequest().getHttpInput().wakeup();\n         if (LOG.isDebugEnabled())\n         {\n-            LOG.debug(\"HTTP2 Request #{}/{}: {} bytes of {} content, handle: {}\",\n+            Stream stream = getStream();\n+            LOG.debug(\"HTTP2 Request #{}/{}: {} bytes of {} content, woken: {}, handle: {}\",\n                     stream.getId(),\n                     Integer.toHexString(stream.getSession().hashCode()),\n                     length,\n                     endStream ? \"last\" : \"some\",\n+                    woken,\n                     handle);\n         }\n+        handle |= woken;\n \n         boolean wasDelayed = _delayedUntilContent;\n         _delayedUntilContent = false;\n         return handle || wasDelayed ? this : null;\n     }\n \n+    private static final HttpInput.Content EOF = new HttpInput.EofContent();\n+    private static final HttpInput.Content DEMANDING = new HttpInput.SpecialContent() {};\n+\n+    private class ContentDemander\n+    {\n+        private final AtomicReference<HttpInput.Content> _content = new AtomicReference<>();\n+\n+        public void recycle()\n+        {\n+            HttpInput.Content c = _content.getAndSet(null);\n+            if (c != null && !c.isSpecial())\n+                throw new AssertionError(\"unconsumed content: \" + c);\n+        }\n+\n+        public HttpInput.Content take()\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c == null || c.isSpecial() || _content.compareAndSet(c, c.isEof() ? EOF : null))\n+                    return c;\n+            }\n+        }\n+\n+        public boolean demand()\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c == DEMANDING)\n+                    return false;\n+                if (c != null)\n+                    return true;\n+                if (_content.compareAndSet(null, DEMANDING))\n+                {\n+                    IStream stream = getStream();\n+                    if (stream == null)\n+                    {\n+                        _content.set(null);\n+                        return false;\n+                    }\n+                    stream.demand(1);\n+                    c = _content.get();\n+                    return c != DEMANDING && c != null;\n+                }\n+            }\n+        }\n+\n+        public void onContent(HttpInput.Content content)\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c == DEMANDING)\n+                {\n+                    if (_content.compareAndSet(DEMANDING, content))\n+                        return;\n+                }\n+                else if (c == null)\n+                {\n+                    if (!content.isSpecial())\n+                        throw new AssertionError(\"Non special content without demand\");\n+                    if (_content.compareAndSet(null, content))\n+                        return;\n+                }\n+                else if (c.isEof() && content.isEof() && content.isEmpty())\n+                {\n+                    content.succeeded();\n+                    return;\n+                }\n+                else if (content.getError() != null)\n+                {\n+                    if (c.getError() != null)\n+                    {\n+                        if (c.getError() != content.getError())\n+                            c.getError().addSuppressed(content.getError());\n+                        return;\n+                    }\n+                    if (_content.compareAndSet(c, content))\n+                    {\n+                        c.failed(content.getError());\n+                        return;\n+                    }\n+                }\n+                else if (c.getError() != null && content.remaining() == 0)\n+                {\n+                    content.succeeded();\n+                    return;\n+                }\n+                else\n+                {\n+                    throw new IllegalStateException(\"Cannot overwrite exiting content \" + c + \" with \" + content);", "originalCommit": "273213e8df4f438bf853787ec932e22424e7fe8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTIyMTQ4OA==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r509221488", "bodyText": "Same as above: reaching this branch means there's a bug and there is no guarantee that we can recover from it.", "author": "lorban", "createdAt": "2020-10-21T12:05:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDg1MjYzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA5NDEzNg==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r512094136", "bodyText": "maybe be consistent with throwing either ISE or AE?", "author": "gregw", "createdAt": "2020-10-26T16:25:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDg1MjYzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjU2NjU5OA==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r512566598", "bodyText": "changed to throw AE.", "author": "lorban", "createdAt": "2020-10-27T10:16:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDg1MjYzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDkyNDU4Mg==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504924582", "bodyText": "So EOF content can be non-empty, which invalidates the logic above?", "author": "sbordet", "createdAt": "2020-10-14T19:36:13Z", "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpChannelOverHTTP2.java", "diffHunk": "@@ -261,31 +264,265 @@ public InvocationType getInvocationType()\n             {\n                 return callback.getInvocationType();\n             }\n-        });\n+        };\n+        _contentDemander.onContent(content);\n+        boolean handle = onContent(content);\n \n         boolean endStream = frame.isEndStream();\n         if (endStream)\n         {\n             boolean handleContent = onContentComplete();\n+            // this will generate EOF -> must happen before wakeup\n             boolean handleRequest = onRequestComplete();\n             handle |= handleContent | handleRequest;\n         }\n \n+        boolean woken = getRequest().getHttpInput().wakeup();\n         if (LOG.isDebugEnabled())\n         {\n-            LOG.debug(\"HTTP2 Request #{}/{}: {} bytes of {} content, handle: {}\",\n+            Stream stream = getStream();\n+            LOG.debug(\"HTTP2 Request #{}/{}: {} bytes of {} content, woken: {}, handle: {}\",\n                     stream.getId(),\n                     Integer.toHexString(stream.getSession().hashCode()),\n                     length,\n                     endStream ? \"last\" : \"some\",\n+                    woken,\n                     handle);\n         }\n+        handle |= woken;\n \n         boolean wasDelayed = _delayedUntilContent;\n         _delayedUntilContent = false;\n         return handle || wasDelayed ? this : null;\n     }\n \n+    private static final HttpInput.Content EOF = new HttpInput.EofContent();\n+    private static final HttpInput.Content DEMANDING = new HttpInput.SpecialContent() {};\n+\n+    private class ContentDemander\n+    {\n+        private final AtomicReference<HttpInput.Content> _content = new AtomicReference<>();\n+\n+        public void recycle()\n+        {\n+            HttpInput.Content c = _content.getAndSet(null);\n+            if (c != null && !c.isSpecial())\n+                throw new AssertionError(\"unconsumed content: \" + c);\n+        }\n+\n+        public HttpInput.Content take()\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c == null || c.isSpecial() || _content.compareAndSet(c, c.isEof() ? EOF : null))\n+                    return c;\n+            }\n+        }\n+\n+        public boolean demand()\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c == DEMANDING)\n+                    return false;\n+                if (c != null)\n+                    return true;\n+                if (_content.compareAndSet(null, DEMANDING))\n+                {\n+                    IStream stream = getStream();\n+                    if (stream == null)\n+                    {\n+                        _content.set(null);\n+                        return false;\n+                    }\n+                    stream.demand(1);\n+                    c = _content.get();\n+                    return c != DEMANDING && c != null;\n+                }\n+            }\n+        }\n+\n+        public void onContent(HttpInput.Content content)\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c == DEMANDING)\n+                {\n+                    if (_content.compareAndSet(DEMANDING, content))\n+                        return;\n+                }\n+                else if (c == null)\n+                {\n+                    if (!content.isSpecial())\n+                        throw new AssertionError(\"Non special content without demand\");\n+                    if (_content.compareAndSet(null, content))\n+                        return;\n+                }\n+                else if (c.isEof() && content.isEof() && content.isEmpty())\n+                {\n+                    content.succeeded();\n+                    return;\n+                }\n+                else if (content.getError() != null)\n+                {\n+                    if (c.getError() != null)\n+                    {\n+                        if (c.getError() != content.getError())\n+                            c.getError().addSuppressed(content.getError());\n+                        return;\n+                    }\n+                    if (_content.compareAndSet(c, content))\n+                    {\n+                        c.failed(content.getError());\n+                        return;\n+                    }\n+                }\n+                else if (c.getError() != null && content.remaining() == 0)\n+                {\n+                    content.succeeded();\n+                    return;\n+                }\n+                else\n+                {\n+                    throw new IllegalStateException(\"Cannot overwrite exiting content \" + c + \" with \" + content);\n+                }\n+            }\n+        }\n+\n+        public boolean onTimeout(Throwable failure)\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c != DEMANDING)\n+                    return false;\n+                if (_content.compareAndSet(DEMANDING, new HttpInput.ErrorContent(failure)))\n+                    return true;\n+            }\n+        }\n+\n+        public void eof()\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c == DEMANDING)\n+                {\n+                    if (_content.compareAndSet(DEMANDING, EOF))\n+                        return;\n+                }\n+                else if (c == null)\n+                {\n+                    if (_content.compareAndSet(null, EOF))\n+                        return;\n+                }\n+                else if (c.isEof())\n+                {\n+                    return;\n+                }\n+                else if (c.remaining() == 0)\n+                {\n+                    if (_content.compareAndSet(c, EOF))\n+                        return;\n+                }\n+                else\n+                {\n+                    HttpInput.Content content = new HttpInput.Content(c.getByteBuffer())", "originalCommit": "273213e8df4f438bf853787ec932e22424e7fe8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQwNTA5MA==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505405090", "bodyText": "Could this wrapping be a problem in AsyncContentProducer, where content instances are compared using ==.\nAlso, code that does isSpecial() typically implies isEOF(), but now we have a case where isSpecial() does not trigger even if the content is EOF. I am worried that elsewhere this is not taken into account correctly.", "author": "sbordet", "createdAt": "2020-10-15T09:42:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDkyNDU4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTIyNjc5MA==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r509226790", "bodyText": "I think you're getting confused because the HttpInput.Content contract isn't documented, so I'll add the necessary javadoc that should cover this question.\nBut to answer it: special content is special in the sense that it isn't backed by a byte buffer and it just indicates that we reached a special state, either an error or EOF. That, and the HttpChannel.produceContent() that specifies that once you reached special content, you'll always get it served.\n@gregw added that non-special content could hint that it is the last content by both being backed by a byte buffer and have the EOF flag set. But it's just a hint that currently only is implemented in H2 and that isn't relied upon anywhere. Everywhere out of the H2 channel, the code only expects EOF that is a special content.", "author": "lorban", "createdAt": "2020-10-21T12:14:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDkyNDU4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA5ODQ4MQ==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r512098481", "bodyText": "Currently EOF can arrive in H2 in two ways: with a data frame that has content; with an empty data frame.\nWith the former, a Frame with content and EOF will be created and then added, then eof() is called, which will be a noop in the c.isEof() branch above.\nWith the later, the demand should never be done until the frame with content is consumed, so the EOF will only arrive when their is no data.   I think onData will not be called, and then eof() will be called and do the simple c == null branch above.\nSo strictly speaking, this wrapping here of a non EOF content with one that is EOF should never EVER be used.  Perhaps we can just do a ISE or AE here... but then the eof hint on content becomes more than a hint", "author": "gregw", "createdAt": "2020-10-26T16:31:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDkyNDU4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjcxNTIxMw==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r512715213", "bodyText": "This branch is taken when onTrailer() is called, which happens when a request has trailers. I've added a comment to reflect this.", "author": "lorban", "createdAt": "2020-10-27T13:59:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDkyNDU4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDkyNTI0OQ==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504925249", "bodyText": "Inline this.", "author": "sbordet", "createdAt": "2020-10-14T19:37:29Z", "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpChannelOverHTTP2.java", "diffHunk": "@@ -261,31 +264,265 @@ public InvocationType getInvocationType()\n             {\n                 return callback.getInvocationType();\n             }\n-        });\n+        };\n+        _contentDemander.onContent(content);\n+        boolean handle = onContent(content);\n \n         boolean endStream = frame.isEndStream();\n         if (endStream)\n         {\n             boolean handleContent = onContentComplete();\n+            // this will generate EOF -> must happen before wakeup\n             boolean handleRequest = onRequestComplete();\n             handle |= handleContent | handleRequest;\n         }\n \n+        boolean woken = getRequest().getHttpInput().wakeup();\n         if (LOG.isDebugEnabled())\n         {\n-            LOG.debug(\"HTTP2 Request #{}/{}: {} bytes of {} content, handle: {}\",\n+            Stream stream = getStream();\n+            LOG.debug(\"HTTP2 Request #{}/{}: {} bytes of {} content, woken: {}, handle: {}\",\n                     stream.getId(),\n                     Integer.toHexString(stream.getSession().hashCode()),\n                     length,\n                     endStream ? \"last\" : \"some\",\n+                    woken,\n                     handle);\n         }\n+        handle |= woken;\n \n         boolean wasDelayed = _delayedUntilContent;\n         _delayedUntilContent = false;\n         return handle || wasDelayed ? this : null;\n     }\n \n+    private static final HttpInput.Content EOF = new HttpInput.EofContent();\n+    private static final HttpInput.Content DEMANDING = new HttpInput.SpecialContent() {};\n+\n+    private class ContentDemander\n+    {\n+        private final AtomicReference<HttpInput.Content> _content = new AtomicReference<>();\n+\n+        public void recycle()\n+        {\n+            HttpInput.Content c = _content.getAndSet(null);\n+            if (c != null && !c.isSpecial())\n+                throw new AssertionError(\"unconsumed content: \" + c);\n+        }\n+\n+        public HttpInput.Content take()\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c == null || c.isSpecial() || _content.compareAndSet(c, c.isEof() ? EOF : null))\n+                    return c;\n+            }\n+        }\n+\n+        public boolean demand()\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c == DEMANDING)\n+                    return false;\n+                if (c != null)\n+                    return true;\n+                if (_content.compareAndSet(null, DEMANDING))\n+                {\n+                    IStream stream = getStream();\n+                    if (stream == null)\n+                    {\n+                        _content.set(null);\n+                        return false;\n+                    }\n+                    stream.demand(1);\n+                    c = _content.get();\n+                    return c != DEMANDING && c != null;\n+                }\n+            }\n+        }\n+\n+        public void onContent(HttpInput.Content content)\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c == DEMANDING)\n+                {\n+                    if (_content.compareAndSet(DEMANDING, content))\n+                        return;\n+                }\n+                else if (c == null)\n+                {\n+                    if (!content.isSpecial())\n+                        throw new AssertionError(\"Non special content without demand\");\n+                    if (_content.compareAndSet(null, content))\n+                        return;\n+                }\n+                else if (c.isEof() && content.isEof() && content.isEmpty())\n+                {\n+                    content.succeeded();\n+                    return;\n+                }\n+                else if (content.getError() != null)\n+                {\n+                    if (c.getError() != null)\n+                    {\n+                        if (c.getError() != content.getError())\n+                            c.getError().addSuppressed(content.getError());\n+                        return;\n+                    }\n+                    if (_content.compareAndSet(c, content))\n+                    {\n+                        c.failed(content.getError());\n+                        return;\n+                    }\n+                }\n+                else if (c.getError() != null && content.remaining() == 0)\n+                {\n+                    content.succeeded();\n+                    return;\n+                }\n+                else\n+                {\n+                    throw new IllegalStateException(\"Cannot overwrite exiting content \" + c + \" with \" + content);\n+                }\n+            }\n+        }\n+\n+        public boolean onTimeout(Throwable failure)\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c != DEMANDING)\n+                    return false;\n+                if (_content.compareAndSet(DEMANDING, new HttpInput.ErrorContent(failure)))\n+                    return true;\n+            }\n+        }\n+\n+        public void eof()\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c == DEMANDING)\n+                {\n+                    if (_content.compareAndSet(DEMANDING, EOF))\n+                        return;\n+                }\n+                else if (c == null)\n+                {\n+                    if (_content.compareAndSet(null, EOF))\n+                        return;\n+                }\n+                else if (c.isEof())\n+                {\n+                    return;\n+                }\n+                else if (c.remaining() == 0)\n+                {\n+                    if (_content.compareAndSet(c, EOF))\n+                        return;\n+                }\n+                else\n+                {\n+                    HttpInput.Content content = new HttpInput.Content(c.getByteBuffer())\n+                    {\n+                        @Override\n+                        public boolean isEof()\n+                        {\n+                            return true;\n+                        }\n+\n+                        @Override\n+                        public void succeeded()\n+                        {\n+                            c.succeeded();\n+                        }\n+\n+                        @Override\n+                        public void failed(Throwable x)\n+                        {\n+                            c.failed(x);\n+                        }\n+\n+                        @Override\n+                        public InvocationType getInvocationType()\n+                        {\n+                            return c.getInvocationType();\n+                        }\n+                    };\n+                    if (_content.compareAndSet(c, content))\n+                        return;\n+                }\n+            }\n+        }\n+\n+        public void failContent(Throwable failure)\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c == null || c.isSpecial())\n+                    return;\n+                if (_content.compareAndSet(c, null))\n+                {\n+                    c.failed(failure);\n+                    return;\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public boolean needContent()\n+    {\n+        boolean hasContent = _contentDemander.demand();\n+        return hasContent;", "originalCommit": "273213e8df4f438bf853787ec932e22424e7fe8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTIyNzQwMA==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r509227400", "bodyText": "Done.", "author": "lorban", "createdAt": "2020-10-21T12:15:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDkyNTI0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDkyNzAzNw==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504927037", "bodyText": "Remove empty line.", "author": "sbordet", "createdAt": "2020-10-14T19:40:43Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/AsyncContentProducer.java", "diffHunk": "@@ -0,0 +1,259 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jetty.http.BadMessageException;\n+import org.eclipse.jetty.http.HttpStatus;\n+\n+class AsyncContentProducer implements ContentProducer\n+{\n+    private final HttpChannel _httpChannel;\n+    private HttpInput.Interceptor _interceptor;\n+    private HttpInput.Content _rawContent;\n+    private HttpInput.Content _transformedContent;\n+    private boolean _error;\n+", "originalCommit": "273213e8df4f438bf853787ec932e22424e7fe8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTEyODI4Nw==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r509128287", "bodyText": "Done.", "author": "lorban", "createdAt": "2020-10-21T09:26:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDkyNzAzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDkyNzI3Nw==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504927277", "bodyText": "Remove public.", "author": "sbordet", "createdAt": "2020-10-14T19:41:07Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/AsyncContentProducer.java", "diffHunk": "@@ -0,0 +1,259 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jetty.http.BadMessageException;\n+import org.eclipse.jetty.http.HttpStatus;\n+\n+class AsyncContentProducer implements ContentProducer\n+{\n+    private final HttpChannel _httpChannel;\n+    private HttpInput.Interceptor _interceptor;\n+    private HttpInput.Content _rawContent;\n+    private HttpInput.Content _transformedContent;\n+    private boolean _error;\n+\n+    private long _firstByteTimeStamp = Long.MIN_VALUE;\n+    private long _rawContentArrived;\n+\n+    public AsyncContentProducer(HttpChannel httpChannel)", "originalCommit": "273213e8df4f438bf853787ec932e22424e7fe8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTEyODUxMg==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r509128512", "bodyText": "Done.", "author": "lorban", "createdAt": "2020-10-21T09:27:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDkyNzI3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDkyODM1Mw==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504928353", "bodyText": "What does it mean that \"the produceContent() mechanism does not guarantee that all available content will be returned\"?\nSeems like a bug if produceContent() does not return the content?", "author": "sbordet", "createdAt": "2020-10-14T19:43:06Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/AsyncContentProducer.java", "diffHunk": "@@ -0,0 +1,259 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jetty.http.BadMessageException;\n+import org.eclipse.jetty.http.HttpStatus;\n+\n+class AsyncContentProducer implements ContentProducer\n+{\n+    private final HttpChannel _httpChannel;\n+    private HttpInput.Interceptor _interceptor;\n+    private HttpInput.Content _rawContent;\n+    private HttpInput.Content _transformedContent;\n+    private boolean _error;\n+\n+    private long _firstByteTimeStamp = Long.MIN_VALUE;\n+    private long _rawContentArrived;\n+\n+    public AsyncContentProducer(HttpChannel httpChannel)\n+    {\n+        _httpChannel = httpChannel;\n+    }\n+\n+    @Override\n+    public void recycle()\n+    {\n+        _interceptor = null;\n+        _rawContent = null;\n+        _transformedContent = null;\n+        _error = false;\n+        _firstByteTimeStamp = Long.MIN_VALUE;\n+        _rawContentArrived = 0L;\n+    }\n+\n+    @Override\n+    public HttpInput.Interceptor getInterceptor()\n+    {\n+        return _interceptor;\n+    }\n+\n+    @Override\n+    public void setInterceptor(HttpInput.Interceptor interceptor)\n+    {\n+        this._interceptor = interceptor;\n+    }\n+\n+    @Override\n+    public int available()\n+    {\n+        HttpInput.Content content = nextTransformedContent();\n+        return content == null ? 0 : content.remaining();\n+    }\n+\n+    @Override\n+    public boolean hasContent()\n+    {\n+        return _rawContent != null;\n+    }\n+\n+    @Override\n+    public boolean isError()\n+    {\n+        return _error;\n+    }\n+\n+    @Override\n+    public void checkMinDataRate()\n+    {\n+        long minRequestDataRate = _httpChannel.getHttpConfiguration().getMinRequestDataRate();\n+        if (minRequestDataRate > 0 && _firstByteTimeStamp != Long.MIN_VALUE)\n+        {\n+            long period = System.nanoTime() - _firstByteTimeStamp;\n+            if (period > 0)\n+            {\n+                long minimumData = minRequestDataRate * TimeUnit.NANOSECONDS.toMillis(period) / TimeUnit.SECONDS.toMillis(1);\n+                if (getRawContentArrived() < minimumData)\n+                {\n+                    BadMessageException bad = new BadMessageException(HttpStatus.REQUEST_TIMEOUT_408,\n+                        String.format(\"Request content data rate < %d B/s\", minRequestDataRate));\n+                    if (_httpChannel.getState().isResponseCommitted())\n+                        _httpChannel.abort(bad);\n+                    failCurrentContent(bad);\n+                    throw bad;\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public long getRawContentArrived()\n+    {\n+        return _rawContentArrived;\n+    }\n+\n+    @Override\n+    public boolean consumeAll(Throwable x)\n+    {\n+        failCurrentContent(x);\n+        // A specific HttpChannel mechanism must be used as the normal produceContent()\n+        // mechanism does not guarantee that all available content will be returned;\n+        // tests in StreamResetTest cover this.", "originalCommit": "273213e8df4f438bf853787ec932e22424e7fe8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTEzOTUzNQ==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r509139535", "bodyText": "This comment is pretty poor (it's definitely a rough brain dump that needs to be cleared). What it means is that with the following loop:\nwhile (_httpChannel.needContent())\n{\n    HttpInput.Content content = _httpChannel.produceContent();\n    ...\n}\nyou have no guarantee that even if the channel does have some content immediately available that it won't deliver it asynchronously by calling HttpInput.wakeup() when its ready to be read. So far, this is only true for H2 because calling Stream.demand(1) does not guarantee that onData() will be called before the demand call returns, even if the stream does contain some content.", "author": "lorban", "createdAt": "2020-10-21T09:43:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDkyODM1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDkyOTAyNg==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504929026", "bodyText": "Remove public.", "author": "sbordet", "createdAt": "2020-10-14T19:44:09Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/BlockingContentProducer.java", "diffHunk": "@@ -0,0 +1,133 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.util.concurrent.Semaphore;\n+\n+class BlockingContentProducer implements ContentProducer\n+{\n+    private final Semaphore _semaphore = new Semaphore(0);\n+    private final AsyncContentProducer _asyncContentProducer;\n+    private final HttpChannel _httpChannel;\n+\n+    public BlockingContentProducer(HttpChannel httpChannel, AsyncContentProducer delegate)", "originalCommit": "273213e8df4f438bf853787ec932e22424e7fe8b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDkzMTYyNg==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504931626", "bodyText": "What's this comment?", "author": "sbordet", "createdAt": "2020-10-14T19:49:06Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/BlockingContentProducer.java", "diffHunk": "@@ -0,0 +1,133 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.util.concurrent.Semaphore;\n+\n+class BlockingContentProducer implements ContentProducer\n+{\n+    private final Semaphore _semaphore = new Semaphore(0);\n+    private final AsyncContentProducer _asyncContentProducer;\n+    private final HttpChannel _httpChannel;\n+\n+    public BlockingContentProducer(HttpChannel httpChannel, AsyncContentProducer delegate)\n+    {\n+        _asyncContentProducer = delegate;\n+        _httpChannel = httpChannel;\n+    }\n+\n+    @Override\n+    public void recycle()\n+    {\n+        _asyncContentProducer.recycle();\n+    }\n+\n+    @Override\n+    public int available()\n+    {\n+        return _asyncContentProducer.available();\n+    }\n+\n+    @Override\n+    public boolean hasContent()\n+    {\n+        return _asyncContentProducer.hasContent();\n+    }\n+\n+    @Override\n+    public boolean isError()\n+    {\n+        return _asyncContentProducer.isError();\n+    }\n+\n+    @Override\n+    public void checkMinDataRate()\n+    {\n+        _asyncContentProducer.checkMinDataRate();\n+    }\n+\n+    @Override\n+    public long getRawContentArrived()\n+    {\n+        return _asyncContentProducer.getRawContentArrived();\n+    }\n+\n+    @Override\n+    public boolean consumeAll(Throwable x)\n+    {\n+        return _asyncContentProducer.consumeAll(x);\n+    }\n+\n+    @Override\n+    public HttpInput.Content nextContent()\n+    {\n+        while (true)\n+        {\n+            HttpInput.Content content = _asyncContentProducer.nextContent();\n+            if (content != null)\n+                return content;\n+\n+            _semaphore.drainPermits();\n+            _httpChannel.getState().onReadUnready();\n+            if (_httpChannel.needContent())\n+                continue;\n+\n+            try\n+            {\n+                _semaphore.acquire();\n+            }\n+            catch (InterruptedException e)\n+            {\n+                return new HttpInput.ErrorContent(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void reclaim(HttpInput.Content content)\n+    {\n+        _asyncContentProducer.reclaim(content);\n+    }\n+\n+    @Override\n+    public boolean isReady()\n+    {\n+        return available() > 0;\n+    }\n+\n+    @Override\n+    public HttpInput.Interceptor getInterceptor()\n+    {\n+        return _asyncContentProducer.getInterceptor();\n+    }\n+\n+    @Override\n+    public void setInterceptor(HttpInput.Interceptor interceptor)\n+    {\n+        _asyncContentProducer.setInterceptor(interceptor);\n+    }\n+\n+    @Override\n+    public boolean wakeup()\n+    {\n+        // Calling _asyncContentProducer.wakeup() breaks AsyncIOServletTest.testAsyncWriteThrowsError H2C.", "originalCommit": "273213e8df4f438bf853787ec932e22424e7fe8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTM3NDkzMQ==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505374931", "bodyText": "Also, feels weird that we are not forwarding to _asyncContextProducer -- if really not needed, it deserves a comment.", "author": "sbordet", "createdAt": "2020-10-15T09:02:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDkzMTYyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDkzMTg5Mg==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504931892", "bodyText": "Empty line.", "author": "sbordet", "createdAt": "2020-10-14T19:49:31Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/ContentProducer.java", "diffHunk": "@@ -0,0 +1,87 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+public interface ContentProducer\n+{\n+", "originalCommit": "273213e8df4f438bf853787ec932e22424e7fe8b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDkzMTk1MQ==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504931951", "bodyText": "javadocs, for the class and for all the methods.\nWhat's currently there does not explain what the method does, e.g. getRawContentArrived() does what?", "author": "sbordet", "createdAt": "2020-10-14T19:49:39Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/ContentProducer.java", "diffHunk": "@@ -0,0 +1,87 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+public interface ContentProducer", "originalCommit": "273213e8df4f438bf853787ec932e22424e7fe8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU5MzAyMg==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505593022", "bodyText": "I'm going to improve the javadoc of this class.", "author": "lorban", "createdAt": "2020-10-15T14:33:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDkzMTk1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDk0NjMxMQ==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504946311", "bodyText": "Why do you need to call produceRawContent() again? This is consumeAll() so we just fail what we have, right?", "author": "sbordet", "createdAt": "2020-10-14T20:16:09Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/AsyncContentProducer.java", "diffHunk": "@@ -0,0 +1,259 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jetty.http.BadMessageException;\n+import org.eclipse.jetty.http.HttpStatus;\n+\n+class AsyncContentProducer implements ContentProducer\n+{\n+    private final HttpChannel _httpChannel;\n+    private HttpInput.Interceptor _interceptor;\n+    private HttpInput.Content _rawContent;\n+    private HttpInput.Content _transformedContent;\n+    private boolean _error;\n+\n+    private long _firstByteTimeStamp = Long.MIN_VALUE;\n+    private long _rawContentArrived;\n+\n+    public AsyncContentProducer(HttpChannel httpChannel)\n+    {\n+        _httpChannel = httpChannel;\n+    }\n+\n+    @Override\n+    public void recycle()\n+    {\n+        _interceptor = null;\n+        _rawContent = null;\n+        _transformedContent = null;\n+        _error = false;\n+        _firstByteTimeStamp = Long.MIN_VALUE;\n+        _rawContentArrived = 0L;\n+    }\n+\n+    @Override\n+    public HttpInput.Interceptor getInterceptor()\n+    {\n+        return _interceptor;\n+    }\n+\n+    @Override\n+    public void setInterceptor(HttpInput.Interceptor interceptor)\n+    {\n+        this._interceptor = interceptor;\n+    }\n+\n+    @Override\n+    public int available()\n+    {\n+        HttpInput.Content content = nextTransformedContent();\n+        return content == null ? 0 : content.remaining();\n+    }\n+\n+    @Override\n+    public boolean hasContent()\n+    {\n+        return _rawContent != null;\n+    }\n+\n+    @Override\n+    public boolean isError()\n+    {\n+        return _error;\n+    }\n+\n+    @Override\n+    public void checkMinDataRate()\n+    {\n+        long minRequestDataRate = _httpChannel.getHttpConfiguration().getMinRequestDataRate();\n+        if (minRequestDataRate > 0 && _firstByteTimeStamp != Long.MIN_VALUE)\n+        {\n+            long period = System.nanoTime() - _firstByteTimeStamp;\n+            if (period > 0)\n+            {\n+                long minimumData = minRequestDataRate * TimeUnit.NANOSECONDS.toMillis(period) / TimeUnit.SECONDS.toMillis(1);\n+                if (getRawContentArrived() < minimumData)\n+                {\n+                    BadMessageException bad = new BadMessageException(HttpStatus.REQUEST_TIMEOUT_408,\n+                        String.format(\"Request content data rate < %d B/s\", minRequestDataRate));\n+                    if (_httpChannel.getState().isResponseCommitted())\n+                        _httpChannel.abort(bad);\n+                    failCurrentContent(bad);\n+                    throw bad;\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public long getRawContentArrived()\n+    {\n+        return _rawContentArrived;\n+    }\n+\n+    @Override\n+    public boolean consumeAll(Throwable x)\n+    {\n+        failCurrentContent(x);\n+        // A specific HttpChannel mechanism must be used as the normal produceContent()\n+        // mechanism does not guarantee that all available content will be returned;\n+        // tests in StreamResetTest cover this.\n+        _httpChannel.failContent(x);\n+        HttpInput.Content c = produceRawContent();", "originalCommit": "273213e8df4f438bf853787ec932e22424e7fe8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU5MjU2Nw==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505592567", "bodyText": "consumeAll() needs to return true if EOF was reached, so calling httpChannel.nextContent() then checking if the returned content is EOF does the trick since once you reach EOF, you can continuously call httpChannel.nextContent() and always be served a EofContent.", "author": "lorban", "createdAt": "2020-10-15T14:33:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDk0NjMxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY1Njk3Ng==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505656976", "bodyText": "We don't want to continuously read content from the network when we have decided to consume the content that we have.\nMy understanding is that produceRawContent() will cause fill&parse or stream.demand() which we don't want.", "author": "sbordet", "createdAt": "2020-10-15T15:56:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDk0NjMxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTE0NTU5OA==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r509145598", "bodyText": "Indeed. This can be solved by making failContent(x) return a boolean to indicate if EOF was reached. Let me do this.", "author": "lorban", "createdAt": "2020-10-21T09:53:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDk0NjMxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjU2MzE2OA==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r512563168", "bodyText": "Done.", "author": "lorban", "createdAt": "2020-10-27T10:11:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDk0NjMxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDk0ODQwMA==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504948400", "bodyText": "Why this call may block? Isn't it wrong that there is a blocking method if it can be implemented by AsyncContentProducer?", "author": "sbordet", "createdAt": "2020-10-14T20:20:04Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/ContentProducer.java", "diffHunk": "@@ -0,0 +1,87 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+public interface ContentProducer\n+{\n+\n+    void recycle();\n+\n+    /**\n+     * This call is always non-blocking.\n+     * Doesn't change state.\n+     * @return true if EOF was reached.\n+     */\n+    boolean consumeAll(Throwable x);\n+\n+    void checkMinDataRate();\n+\n+    /**\n+     * This call is always non-blocking.\n+     * Doesn't change state.\n+     */\n+    long getRawContentArrived();\n+\n+    /**\n+     * This call is always non-blocking.\n+     * Doesn't change state.\n+     */\n+    int available();\n+\n+    /**\n+     * This call is always non-blocking.\n+     * Doesn't change state.\n+     * Doesn't query the HttpChannel.\n+     */\n+    boolean hasContent();\n+\n+    /**\n+     * This call is always non-blocking.\n+     * Doesn't change state.\n+     * Doesn't query the HttpChannel.\n+     */\n+    boolean isError();\n+\n+    /**\n+     * This call may block.", "originalCommit": "273213e8df4f438bf853787ec932e22424e7fe8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU5MDQ1MA==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505590450", "bodyText": "Because of poor javadoc. What I meant is that some implementations may decide to make nextContent() a blocking call, some others may not. This is exactly what BlockingContentProducer and AsyncContentProducer do but I'd like the javadoc to avoid speaking about specific implementations.", "author": "lorban", "createdAt": "2020-10-15T14:30:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDk0ODQwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDk1NDk2Nw==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r504954967", "bodyText": "It's not true that _specialContent is only accessed by one thread. It is set by the scheduler thread during idle timeouts.", "author": "sbordet", "createdAt": "2020-10-14T20:32:33Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpChannelOverHttp.java", "diffHunk": "@@ -61,6 +62,15 @@\n     private boolean _expect102Processing = false;\n     private List<String> _complianceViolations;\n     private HttpFields.Mutable _trailers;\n+    // Both _content and _specialContent don't need to be volatile nor protected by a lock\n+    // as they're always accessed by the same thread, i.e.: we get notified by onFillable\n+    // that the socket contains new bytes and either schedule an onDataAvailable\n+    // call that is going to read the socket or release the blocking semaphore to wake up\n+    // the blocked reader and make it read the socket. The same logic is true for async\n+    // events like timeout: we get notified and either schedule onError or release the\n+    // blocking semaphore.\n+    private HttpInput.Content _content;\n+    private HttpInput.Content _specialContent;", "originalCommit": "273213e8df4f438bf853787ec932e22424e7fe8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU4ODk1OQ==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505588959", "bodyText": "My original analysis was that the scheduler thread only ever writes to _specialContent, then either notifies the blocked thread with the semaphore (which gives us a happens-before) or reschedules a thread that reads it. A job submission to a standard ExecutorService creates a happens-before relationship that would make this safe but I may need to check if the form of scheduling we use in EWYK does too. I suspect it does, but I'll review this in more details.", "author": "lorban", "createdAt": "2020-10-15T14:28:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDk1NDk2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM4MzQzMQ==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r508383431", "bodyText": "Looks safe to me, but I could mark _specialContent as volatile nevertheless. This would make the code a bit less brittle in wrt potential future changes.", "author": "lorban", "createdAt": "2020-10-20T10:20:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDk1NDk2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjEwNjI1Ng==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r512106256", "bodyText": "why do we need both _content and _specialContent.  We only have a single content in H2 and I think similar logic could be applied here.", "author": "gregw", "createdAt": "2020-10-26T16:42:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDk1NDk2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzEwMjQ2Nw==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r513102467", "bodyText": "I got rid of _specialContent.", "author": "lorban", "createdAt": "2020-10-28T00:04:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDk1NDk2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTMzMTAwNg==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505331006", "bodyText": "Why is not this call needed for the async case?\nFeels that blocking may be implemented in terms of async with just the semaphore, but only in this case we need an additional state change?", "author": "sbordet", "createdAt": "2020-10-15T08:24:25Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/BlockingContentProducer.java", "diffHunk": "@@ -0,0 +1,133 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.util.concurrent.Semaphore;\n+\n+class BlockingContentProducer implements ContentProducer\n+{\n+    private final Semaphore _semaphore = new Semaphore(0);\n+    private final AsyncContentProducer _asyncContentProducer;\n+    private final HttpChannel _httpChannel;\n+\n+    public BlockingContentProducer(HttpChannel httpChannel, AsyncContentProducer delegate)\n+    {\n+        _asyncContentProducer = delegate;\n+        _httpChannel = httpChannel;\n+    }\n+\n+    @Override\n+    public void recycle()\n+    {\n+        _asyncContentProducer.recycle();\n+    }\n+\n+    @Override\n+    public int available()\n+    {\n+        return _asyncContentProducer.available();\n+    }\n+\n+    @Override\n+    public boolean hasContent()\n+    {\n+        return _asyncContentProducer.hasContent();\n+    }\n+\n+    @Override\n+    public boolean isError()\n+    {\n+        return _asyncContentProducer.isError();\n+    }\n+\n+    @Override\n+    public void checkMinDataRate()\n+    {\n+        _asyncContentProducer.checkMinDataRate();\n+    }\n+\n+    @Override\n+    public long getRawContentArrived()\n+    {\n+        return _asyncContentProducer.getRawContentArrived();\n+    }\n+\n+    @Override\n+    public boolean consumeAll(Throwable x)\n+    {\n+        return _asyncContentProducer.consumeAll(x);\n+    }\n+\n+    @Override\n+    public HttpInput.Content nextContent()\n+    {\n+        while (true)\n+        {\n+            HttpInput.Content content = _asyncContentProducer.nextContent();\n+            if (content != null)\n+                return content;\n+\n+            _semaphore.drainPermits();\n+            _httpChannel.getState().onReadUnready();", "originalCommit": "273213e8df4f438bf853787ec932e22424e7fe8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTM5NDY1Mw==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505394653", "bodyText": "I find it strange that the blocking impl is half wrapping the async impl and half calling HttpChannelState directly.\nThe blocking impl should be 100% based on the async impl and any state changes that result should be done by the async impl", "author": "gregw", "createdAt": "2020-10-15T09:29:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTMzMTAwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU4NDE2Mg==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505584162", "bodyText": "I don't think drainPermits() is needed, and I also think that\n_httpChannel.getState().onReadUnready();\nif (_httpChannel.needContent())\n  continue;\ncan be replaced with\nif (_asyncContentProducer.isReady())\n  continue;\nI'll try both changes.", "author": "lorban", "createdAt": "2020-10-15T14:22:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTMzMTAwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjU2NDc2OQ==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r512564769", "bodyText": "Done.", "author": "lorban", "createdAt": "2020-10-27T10:14:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTMzMTAwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTM4MDA3Ng==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505380076", "bodyText": "It needs to be PRECISELY that only when needContent returns false will there be some callback that will release the semaphore. So we need to only ever acquire the semaphore in that case. We then don't need drain permits.       I'm still thinking needContent(Callback) is the way to go.", "author": "gregw", "createdAt": "2020-10-15T09:08:59Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/BlockingContentProducer.java", "diffHunk": "@@ -0,0 +1,133 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.util.concurrent.Semaphore;\n+\n+class BlockingContentProducer implements ContentProducer\n+{\n+    private final Semaphore _semaphore = new Semaphore(0);\n+    private final AsyncContentProducer _asyncContentProducer;\n+    private final HttpChannel _httpChannel;\n+\n+    public BlockingContentProducer(HttpChannel httpChannel, AsyncContentProducer delegate)\n+    {\n+        _asyncContentProducer = delegate;\n+        _httpChannel = httpChannel;\n+    }\n+\n+    @Override\n+    public void recycle()\n+    {\n+        _asyncContentProducer.recycle();\n+    }\n+\n+    @Override\n+    public int available()\n+    {\n+        return _asyncContentProducer.available();\n+    }\n+\n+    @Override\n+    public boolean hasContent()\n+    {\n+        return _asyncContentProducer.hasContent();\n+    }\n+\n+    @Override\n+    public boolean isError()\n+    {\n+        return _asyncContentProducer.isError();\n+    }\n+\n+    @Override\n+    public void checkMinDataRate()\n+    {\n+        _asyncContentProducer.checkMinDataRate();\n+    }\n+\n+    @Override\n+    public long getRawContentArrived()\n+    {\n+        return _asyncContentProducer.getRawContentArrived();\n+    }\n+\n+    @Override\n+    public boolean consumeAll(Throwable x)\n+    {\n+        return _asyncContentProducer.consumeAll(x);\n+    }\n+\n+    @Override\n+    public HttpInput.Content nextContent()\n+    {\n+        while (true)\n+        {\n+            HttpInput.Content content = _asyncContentProducer.nextContent();\n+            if (content != null)\n+                return content;\n+\n+            _semaphore.drainPermits();\n+            _httpChannel.getState().onReadUnready();\n+            if (_httpChannel.needContent())", "originalCommit": "273213e8df4f438bf853787ec932e22424e7fe8b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTM3NjM4NQ==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505376385", "bodyText": "Typo: should be \"onReadEof\".", "author": "sbordet", "createdAt": "2020-10-15T09:03:59Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpChannelState.java", "diffHunk": "@@ -1223,78 +1211,53 @@ public void setAttribute(String name, Object attribute)\n     }\n \n     /**\n-     * Called to signal async read isReady() has returned false.\n-     * This indicates that there is no content available to be consumed\n-     * and that once the channel enters the ASYNC_WAIT state it will\n-     * register for read interest by calling {@link HttpChannel#onAsyncWaitForContent()}\n-     * either from this method or from a subsequent call to {@link #unhandle()}.\n+     * Called to signal that the channel is ready for a callback.\n+     *\n+     * @return true if woken\n      */\n-    public void onReadUnready()\n+    public boolean onReadReady()\n     {\n-        boolean interested = false;\n+        boolean woken = false;\n         try (AutoLock l = lock())\n         {\n             if (LOG.isDebugEnabled())\n-                LOG.debug(\"onReadUnready {}\", toStringLocked());\n+                LOG.debug(\"onReadReady {}\", toStringLocked());\n \n             switch (_inputState)\n             {\n-                case IDLE:\n                 case READY:\n+                    _inputState = InputState.READY;\n+                    break;\n+                case IDLE:\n+                case UNREADY:\n+                    _inputState = InputState.READY;\n                     if (_state == State.WAITING)\n                     {\n-                        interested = true;\n-                        _inputState = InputState.REGISTERED;\n-                    }\n-                    else\n-                    {\n-                        _inputState = InputState.REGISTER;\n+                        woken = true;\n+                        _state = State.WOKEN;\n                     }\n                     break;\n \n-                case REGISTER:\n-                case REGISTERED:\n-                case POSSIBLE:\n-                case PRODUCING:\n-                    break;\n-\n                 default:\n                     throw new IllegalStateException(toStringLocked());\n             }\n         }\n-\n-        if (interested)\n-            _channel.onAsyncWaitForContent();\n+        return woken;\n     }\n \n-    /**\n-     * Called to signal that content is now available to read.\n-     * If the channel is in ASYNC_WAIT state and unready (ie isReady() has\n-     * returned false), then the state is changed to ASYNC_WOKEN and true\n-     * is returned.\n-     *\n-     * @return True IFF the channel was unready and in ASYNC_WAIT state\n-     */\n-    public boolean onContentAdded()\n+    public boolean onReadEof()\n     {\n         boolean woken = false;\n         try (AutoLock l = lock())\n         {\n             if (LOG.isDebugEnabled())\n-                LOG.debug(\"onContentAdded {}\", toStringLocked());\n+                LOG.debug(\"onReadReady {}\", toStringLocked());", "originalCommit": "273213e8df4f438bf853787ec932e22424e7fe8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU0OTM2Mw==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505549363", "bodyText": "done.", "author": "lorban", "createdAt": "2020-10-15T13:38:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTM3NjM4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTM3NjcwNg==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505376706", "bodyText": "Typo: should be \"onReadIdle\".", "author": "sbordet", "createdAt": "2020-10-15T09:04:29Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpChannelState.java", "diffHunk": "@@ -1329,77 +1283,62 @@ public boolean onReadReady()\n             switch (_inputState)\n             {\n                 case IDLE:\n+                case UNREADY:\n+                case READY:\n                     _inputState = InputState.READY;\n-                    if (_state == State.WAITING)\n-                    {\n-                        woken = true;\n-                        _state = State.WOKEN;\n-                    }\n                     break;\n \n                 default:\n                     throw new IllegalStateException(toStringLocked());\n             }\n         }\n-        return woken;\n     }\n \n-    /**\n-     * Called to indicate that more content may be available,\n-     * but that a handling thread may need to produce (fill/parse)\n-     * it.  Typically called by the async read success callback.\n-     *\n-     * @return {@code true} if more content may be available\n-     */\n-    public boolean onReadPossible()\n+    public void onReadIdle()\n     {\n-        boolean woken = false;\n         try (AutoLock l = lock())\n         {\n             if (LOG.isDebugEnabled())\n-                LOG.debug(\"onReadPossible {}\", toStringLocked());\n+                LOG.debug(\"onReadReady {}\", toStringLocked());", "originalCommit": "273213e8df4f438bf853787ec932e22424e7fe8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU0OTU4NA==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505549584", "bodyText": "done.", "author": "lorban", "createdAt": "2020-10-15T13:39:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTM3NjcwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTM3Njk5NA==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505376994", "bodyText": "Typo: should be \"onReadUnready\".", "author": "sbordet", "createdAt": "2020-10-15T09:04:51Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpChannelState.java", "diffHunk": "@@ -1329,77 +1283,62 @@ public boolean onReadReady()\n             switch (_inputState)\n             {\n                 case IDLE:\n+                case UNREADY:\n+                case READY:\n                     _inputState = InputState.READY;\n-                    if (_state == State.WAITING)\n-                    {\n-                        woken = true;\n-                        _state = State.WOKEN;\n-                    }\n                     break;\n \n                 default:\n                     throw new IllegalStateException(toStringLocked());\n             }\n         }\n-        return woken;\n     }\n \n-    /**\n-     * Called to indicate that more content may be available,\n-     * but that a handling thread may need to produce (fill/parse)\n-     * it.  Typically called by the async read success callback.\n-     *\n-     * @return {@code true} if more content may be available\n-     */\n-    public boolean onReadPossible()\n+    public void onReadIdle()\n     {\n-        boolean woken = false;\n         try (AutoLock l = lock())\n         {\n             if (LOG.isDebugEnabled())\n-                LOG.debug(\"onReadPossible {}\", toStringLocked());\n+                LOG.debug(\"onReadReady {}\", toStringLocked());\n \n             switch (_inputState)\n             {\n-                case REGISTERED:\n-                    _inputState = InputState.POSSIBLE;\n-                    if (_state == State.WAITING)\n-                    {\n-                        woken = true;\n-                        _state = State.WOKEN;\n-                    }\n+                case UNREADY:\n+                case READY:\n+                case IDLE:\n+                    _inputState = InputState.IDLE;\n                     break;\n \n                 default:\n                     throw new IllegalStateException(toStringLocked());\n             }\n         }\n-        return woken;\n     }\n \n     /**\n-     * Called to signal that a read has read -1.\n-     * Will wake if the read was called while in ASYNC_WAIT state\n-     *\n-     * @return {@code true} if woken\n+     * Called to indicate that more content may be available,\n+     * but that a handling thread may need to produce (fill/parse)\n+     * it.  Typically called by the async read success callback.\n      */\n-    public boolean onReadEof()\n+    public void onReadUnready()\n     {\n-        boolean woken = false;\n         try (AutoLock l = lock())\n         {\n             if (LOG.isDebugEnabled())\n-                LOG.debug(\"onEof {}\", toStringLocked());\n+                LOG.debug(\"onReadPossible {}\", toStringLocked());", "originalCommit": "273213e8df4f438bf853787ec932e22424e7fe8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU0OTQ0NQ==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505549445", "bodyText": "done.", "author": "lorban", "createdAt": "2020-10-15T13:38:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTM3Njk5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTM3Nzg1Nw==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505377857", "bodyText": "The comment is wrong, since parse() is called before fill().", "author": "sbordet", "createdAt": "2020-10-15T09:06:01Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpConnection.java", "diffHunk": "@@ -316,21 +314,20 @@ else if (filled < 0)\n     }\n \n     /**\n-     * Fill and parse data looking for content\n-     *\n-     * @return true if an {@link RequestHandler} method was called and it returned true;\n+     * Parse and fill data, looking for content\n      */\n-    protected boolean fillAndParseForContent()\n+    void parseAndFillForContent()\n     {\n-        boolean handled = false;\n+        // parseRequestBuffer() must always be called after fillRequestBuffer() otherwise this method doesn't trigger EOF/earlyEOF\n+        // which breaks AsyncRequestReadTest.testPartialReadThenShutdown()", "originalCommit": "273213e8df4f438bf853787ec932e22424e7fe8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU4MTQ0OQ==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505581449", "bodyText": "It's actually ambiguous. What I meant was that if you call fillRequestBuffer(), you must also call parseRequestBuffer(). I'll rephrase it.", "author": "lorban", "createdAt": "2020-10-15T14:19:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTM3Nzg1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTM3OTYxOQ==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505379619", "bodyText": "Remove comment.", "author": "sbordet", "createdAt": "2020-10-15T09:08:16Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpConnection.java", "diffHunk": "@@ -666,46 +652,32 @@ public void failed(Throwable x)\n         }\n     }\n \n-    private class BlockingReadCallback implements Callback\n+    private class AsyncReadCallback implements Callback\n     {\n         @Override\n         public void succeeded()\n         {\n-            _input.unblock();\n+            if (_channel.getRequest().getHttpInput().wakeup())\n+                _channel.execute(_channel);\n         }\n \n         @Override\n         public void failed(Throwable x)\n         {\n-            _input.failed(x);\n+            if (_channel.failed(x))\n+                _channel.execute(_channel);\n         }\n \n         @Override\n         public InvocationType getInvocationType()\n         {\n             // This callback does not block, rather it wakes up the\n             // thread that is blocked waiting on the read.\n+            // Must be NON_BLOCKING otherwise ThreadStarvationTest.testReadStarvation fails.", "originalCommit": "273213e8df4f438bf853787ec932e22424e7fe8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODMyMzA4Mg==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r508323082", "bodyText": "Done.", "author": "lorban", "createdAt": "2020-10-20T08:50:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTM3OTYxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTM4MTIwNg==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505381206", "bodyText": "We don't want to execute() the channel here. This is async so we must be able to just use the caller thread to do all the work without another queue+dispatch to another thread.", "author": "sbordet", "createdAt": "2020-10-15T09:10:23Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpConnection.java", "diffHunk": "@@ -666,46 +652,32 @@ public void failed(Throwable x)\n         }\n     }\n \n-    private class BlockingReadCallback implements Callback\n+    private class AsyncReadCallback implements Callback\n     {\n         @Override\n         public void succeeded()\n         {\n-            _input.unblock();\n+            if (_channel.getRequest().getHttpInput().wakeup())\n+                _channel.execute(_channel);", "originalCommit": "273213e8df4f438bf853787ec932e22424e7fe8b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTM4MTU5NA==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505381594", "bodyText": "Again, I don't think we want to execute here.", "author": "sbordet", "createdAt": "2020-10-15T09:10:53Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpConnection.java", "diffHunk": "@@ -666,46 +652,32 @@ public void failed(Throwable x)\n         }\n     }\n \n-    private class BlockingReadCallback implements Callback\n+    private class AsyncReadCallback implements Callback\n     {\n         @Override\n         public void succeeded()\n         {\n-            _input.unblock();\n+            if (_channel.getRequest().getHttpInput().wakeup())\n+                _channel.execute(_channel);\n         }\n \n         @Override\n         public void failed(Throwable x)\n         {\n-            _input.failed(x);\n+            if (_channel.failed(x))\n+                _channel.execute(_channel);", "originalCommit": "273213e8df4f438bf853787ec932e22424e7fe8b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTM4OTM3OQ==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505389379", "bodyText": "This method should be removed because nobody uses it.\nIf we really want to keep it for information purposes, we really need a better name that says whether these are bytes arrived (but possibly not yet consumed by the application), or bytes consumed by the application via read(), and clarify whether these are before or after transformation (e.g. ungzipping).", "author": "sbordet", "createdAt": "2020-10-15T09:21:21Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/Request.java", "diffHunk": "@@ -749,7 +749,7 @@ public long getContentLengthLong()\n \n     public long getContentRead()\n     {\n-        return _input.getContentConsumed();\n+        return _input.getContentReceived();\n     }\n ", "originalCommit": "273213e8df4f438bf853787ec932e22424e7fe8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM2Nzg4OA==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r508367888", "bodyText": "The getContentReceived method was added by @lachlan-roberts in his CustomRequestLog rework. It calls ContentProducer.getRawContentArrived() which IMHO is a reasonable name.\nI can rename those methods, or I can get rid of the getContentRead method, even if it's a bit out of scope.", "author": "lorban", "createdAt": "2020-10-20T09:56:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTM4OTM3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTM4OTk1OA==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505389958", "bodyText": "Obsolete comment?", "author": "sbordet", "createdAt": "2020-10-15T09:22:14Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpInput.java", "diffHunk": "@@ -192,648 +83,183 @@ public Interceptor getInterceptor()\n      */\n     public void setInterceptor(Interceptor interceptor)\n     {\n-        _interceptor = interceptor;\n+        _contentProducer.setInterceptor(interceptor);\n     }\n \n     /**\n-     * Set the {@link Interceptor}, using a {@link ChainedInterceptor} if\n+     * Set the {@link Interceptor}, chaining it to the existing one if\n      * an {@link Interceptor} is already set.\n      *\n      * @param interceptor the next {@link Interceptor} in a chain\n      */\n     public void addInterceptor(Interceptor interceptor)\n     {\n-        if (_interceptor == null)\n-            _interceptor = interceptor;\n+        Interceptor currentInterceptor = _contentProducer.getInterceptor();\n+        if (currentInterceptor == null)\n+            _contentProducer.setInterceptor(interceptor);\n         else\n-            _interceptor = new ChainedInterceptor(_interceptor, interceptor);\n+            _contentProducer.setInterceptor(new ChainedInterceptor(currentInterceptor, interceptor));\n     }\n \n-    @Override\n-    public int available()\n-    {\n-        int available = 0;\n-        boolean woken = false;\n-        try (AutoLock l = _lock.lock())\n-        {\n-            if (_content == null)\n-                _content = _inputQ.poll();\n-            if (_content == null)\n-            {\n-                try\n-                {\n-                    produceContent();\n-                }\n-                catch (IOException e)\n-                {\n-                    woken = failed(e);\n-                }\n-                if (_content == null)\n-                    _content = _inputQ.poll();\n-            }\n-\n-            if (_content != null)\n-                available = _content.remaining();\n-        }\n-\n-        if (woken)\n-            wake();\n-        return available;\n-    }\n-\n-    protected void wake()\n-    {\n-        HttpChannel channel = _channelState.getHttpChannel();\n-        Executor executor = channel.getConnector().getServer().getThreadPool();\n-        executor.execute(channel);\n-    }\n-\n-    @Override\n-    public int read() throws IOException\n+    public long getContentReceived()\n     {\n-        int read = read(_oneByteBuffer, 0, 1);\n-        if (read == 0)\n-            throw new IllegalStateException(\"unready read=0\");\n-        return read < 0 ? -1 : _oneByteBuffer[0] & 0xFF;\n+        return _contentProducer.getRawContentArrived();\n     }\n \n-    @Override\n-    public int read(byte[] b, int off, int len) throws IOException\n+    public boolean consumeAll()\n     {\n-        boolean wake = false;\n-        int read;\n-        try (AutoLock l = _lock.lock())\n-        {\n-            // Calculate minimum request rate for DOS protection\n-            long minRequestDataRate = _channelState.getHttpChannel().getHttpConfiguration().getMinRequestDataRate();\n-            if (minRequestDataRate > 0 && _firstByteTimeStamp != -1)\n-            {\n-                long period = System.nanoTime() - _firstByteTimeStamp;\n-                if (period > 0)\n-                {\n-                    long minimumData = minRequestDataRate * TimeUnit.NANOSECONDS.toMillis(period) / TimeUnit.SECONDS.toMillis(1);\n-                    if (_contentArrived < minimumData)\n-                    {\n-                        BadMessageException bad = new BadMessageException(HttpStatus.REQUEST_TIMEOUT_408,\n-                            String.format(\"Request content data rate < %d B/s\", minRequestDataRate));\n-                        if (_channelState.isResponseCommitted())\n-                            _channelState.getHttpChannel().abort(bad);\n-                        throw bad;\n-                    }\n-                }\n-            }\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"consume all\");\n+        boolean atEof = _contentProducer.consumeAll(new IOException(\"Unconsumed content\"));\n+        if (atEof)\n+            _consumedEof = true;\n \n-            // Consume content looking for bytes to read\n-            while (true)\n-            {\n-                Content item = nextContent();\n-                if (item != null)\n-                {\n-                    read = get(item, b, off, len);\n-                    if (LOG.isDebugEnabled())\n-                        LOG.debug(\"{} read {} from {}\", this, read, item);\n-\n-                    // Consume any following poison pills\n-                    if (item.isEmpty())\n-                        nextInterceptedContent();\n-                    break;\n-                }\n-\n-                // No content, so should we block?\n-                if (!_state.blockForContent(this))\n-                {\n-                    // Not blocking, so what should we return?\n-                    read = _state.noContent();\n-\n-                    if (read < 0)\n-                        // If EOF do we need to wake for allDataRead callback?\n-                        wake = _channelState.onReadEof();\n-                    break;\n-                }\n-            }\n-        }\n-\n-        if (wake)\n-            wake();\n-        return read;\n-    }\n+        if (isFinished())\n+            return !isError();\n \n-    /**\n-     * Called when derived implementations should attempt to produce more Content and add it via {@link #addContent(Content)}. For protocols that are constantly\n-     * producing (eg HTTP2) this can be left as a noop;\n-     *\n-     * @throws IOException if unable to produce content\n-     */\n-    protected void produceContent() throws IOException\n-    {\n+        // Modifying the state here to anything other than IDLE makes\n+        // ServerTimeoutsTest.testAsyncReadWithDelayedFirstContentWithDelayedDispatchIdleTimeoutFires H2C fail.", "originalCommit": "273213e8df4f438bf853787ec932e22424e7fe8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE0Nzg3Mg==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r510147872", "bodyText": "Indeed. Removed it.", "author": "lorban", "createdAt": "2020-10-22T13:10:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTM4OTk1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTM5MjY0NQ==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505392645", "bodyText": "I would call reclaim() only after a check to see if content is consumed. Like this seems a weird call and forces to read the reclaim() implementation to make sure it does nothing if there still is content to consume.", "author": "sbordet", "createdAt": "2020-10-15T09:26:06Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpInput.java", "diffHunk": "@@ -192,648 +83,183 @@ public Interceptor getInterceptor()\n      */\n     public void setInterceptor(Interceptor interceptor)\n     {\n-        _interceptor = interceptor;\n+        _contentProducer.setInterceptor(interceptor);\n     }\n \n     /**\n-     * Set the {@link Interceptor}, using a {@link ChainedInterceptor} if\n+     * Set the {@link Interceptor}, chaining it to the existing one if\n      * an {@link Interceptor} is already set.\n      *\n      * @param interceptor the next {@link Interceptor} in a chain\n      */\n     public void addInterceptor(Interceptor interceptor)\n     {\n-        if (_interceptor == null)\n-            _interceptor = interceptor;\n+        Interceptor currentInterceptor = _contentProducer.getInterceptor();\n+        if (currentInterceptor == null)\n+            _contentProducer.setInterceptor(interceptor);\n         else\n-            _interceptor = new ChainedInterceptor(_interceptor, interceptor);\n+            _contentProducer.setInterceptor(new ChainedInterceptor(currentInterceptor, interceptor));\n     }\n \n-    @Override\n-    public int available()\n-    {\n-        int available = 0;\n-        boolean woken = false;\n-        try (AutoLock l = _lock.lock())\n-        {\n-            if (_content == null)\n-                _content = _inputQ.poll();\n-            if (_content == null)\n-            {\n-                try\n-                {\n-                    produceContent();\n-                }\n-                catch (IOException e)\n-                {\n-                    woken = failed(e);\n-                }\n-                if (_content == null)\n-                    _content = _inputQ.poll();\n-            }\n-\n-            if (_content != null)\n-                available = _content.remaining();\n-        }\n-\n-        if (woken)\n-            wake();\n-        return available;\n-    }\n-\n-    protected void wake()\n-    {\n-        HttpChannel channel = _channelState.getHttpChannel();\n-        Executor executor = channel.getConnector().getServer().getThreadPool();\n-        executor.execute(channel);\n-    }\n-\n-    @Override\n-    public int read() throws IOException\n+    public long getContentReceived()\n     {\n-        int read = read(_oneByteBuffer, 0, 1);\n-        if (read == 0)\n-            throw new IllegalStateException(\"unready read=0\");\n-        return read < 0 ? -1 : _oneByteBuffer[0] & 0xFF;\n+        return _contentProducer.getRawContentArrived();\n     }\n \n-    @Override\n-    public int read(byte[] b, int off, int len) throws IOException\n+    public boolean consumeAll()\n     {\n-        boolean wake = false;\n-        int read;\n-        try (AutoLock l = _lock.lock())\n-        {\n-            // Calculate minimum request rate for DOS protection\n-            long minRequestDataRate = _channelState.getHttpChannel().getHttpConfiguration().getMinRequestDataRate();\n-            if (minRequestDataRate > 0 && _firstByteTimeStamp != -1)\n-            {\n-                long period = System.nanoTime() - _firstByteTimeStamp;\n-                if (period > 0)\n-                {\n-                    long minimumData = minRequestDataRate * TimeUnit.NANOSECONDS.toMillis(period) / TimeUnit.SECONDS.toMillis(1);\n-                    if (_contentArrived < minimumData)\n-                    {\n-                        BadMessageException bad = new BadMessageException(HttpStatus.REQUEST_TIMEOUT_408,\n-                            String.format(\"Request content data rate < %d B/s\", minRequestDataRate));\n-                        if (_channelState.isResponseCommitted())\n-                            _channelState.getHttpChannel().abort(bad);\n-                        throw bad;\n-                    }\n-                }\n-            }\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"consume all\");\n+        boolean atEof = _contentProducer.consumeAll(new IOException(\"Unconsumed content\"));\n+        if (atEof)\n+            _consumedEof = true;\n \n-            // Consume content looking for bytes to read\n-            while (true)\n-            {\n-                Content item = nextContent();\n-                if (item != null)\n-                {\n-                    read = get(item, b, off, len);\n-                    if (LOG.isDebugEnabled())\n-                        LOG.debug(\"{} read {} from {}\", this, read, item);\n-\n-                    // Consume any following poison pills\n-                    if (item.isEmpty())\n-                        nextInterceptedContent();\n-                    break;\n-                }\n-\n-                // No content, so should we block?\n-                if (!_state.blockForContent(this))\n-                {\n-                    // Not blocking, so what should we return?\n-                    read = _state.noContent();\n-\n-                    if (read < 0)\n-                        // If EOF do we need to wake for allDataRead callback?\n-                        wake = _channelState.onReadEof();\n-                    break;\n-                }\n-            }\n-        }\n-\n-        if (wake)\n-            wake();\n-        return read;\n-    }\n+        if (isFinished())\n+            return !isError();\n \n-    /**\n-     * Called when derived implementations should attempt to produce more Content and add it via {@link #addContent(Content)}. For protocols that are constantly\n-     * producing (eg HTTP2) this can be left as a noop;\n-     *\n-     * @throws IOException if unable to produce content\n-     */\n-    protected void produceContent() throws IOException\n-    {\n+        // Modifying the state here to anything other than IDLE makes\n+        // ServerTimeoutsTest.testAsyncReadWithDelayedFirstContentWithDelayedDispatchIdleTimeoutFires H2C fail.\n+        return false;\n     }\n \n-    /**\n-     * Called by channel when asynchronous IO needs to produce more content\n-     *\n-     * @throws IOException if unable to produce content\n-     */\n-    public void asyncReadProduce() throws IOException\n+    public boolean isError()\n     {\n-        try (AutoLock l = _lock.lock())\n-        {\n-            produceContent();\n-        }\n+        return _contentProducer.isError();\n     }\n \n-    /**\n-     * Get the next content from the inputQ, calling {@link #produceContent()} if need be. EOF is processed and state changed.\n-     *\n-     * @return the content or null if none available.\n-     * @throws IOException if retrieving the content fails\n-     */\n-    protected Content nextContent() throws IOException\n+    public boolean isAsync()\n     {\n-        Content content = nextNonSentinelContent();\n-        if (content == null && !isFinished())\n-        {\n-            produceContent();\n-            content = nextNonSentinelContent();\n-        }\n-        return content;\n+        return _readListener != null;\n     }\n \n-    /**\n-     * Poll the inputQ for Content. Consumed buffers and {@link SentinelContent}s are removed and EOF state updated if need be.\n-     *\n-     * @return Content or null\n-     */\n-    protected Content nextNonSentinelContent()\n-    {\n-        while (true)\n-        {\n-            // Get the next content (or EOF)\n-            Content content = nextInterceptedContent();\n-\n-            // If it is EOF, consume it here\n-            if (content instanceof SentinelContent)\n-            {\n-                // Consume the EOF content, either if it was original content\n-                // or if it was produced by interception\n-                consume(content);\n-                continue;\n-            }\n+    /* ServletInputStream */\n \n-            return content;\n-        }\n-    }\n-\n-    /**\n-     * Get the next readable from the inputQ, calling {@link #produceContent()} if need be. EOF is NOT processed and state is not changed.\n-     *\n-     * @return the content or EOF or null if none available.\n-     * @throws IOException if retrieving the content fails\n-     */\n-    protected Content produceNextContext() throws IOException\n+    @Override\n+    public boolean isFinished()\n     {\n-        Content content = nextInterceptedContent();\n-        if (content == null && !isFinished())\n-        {\n-            produceContent();\n-            content = nextInterceptedContent();\n-        }\n-        return content;\n+        boolean finished = _consumedEof;\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"isFinished? {}\", finished);\n+        return finished;\n     }\n \n-    /**\n-     * Poll the inputQ for Content or EOF. Consumed buffers and non EOF {@link SentinelContent}s are removed. EOF state is not updated.\n-     * Interception is done within this method.\n-     *\n-     * @return Content with remaining, a {@link SentinelContent},  or null\n-     */\n-    protected Content nextInterceptedContent()\n+    @Override\n+    public boolean isReady()\n     {\n-        // If we have a chunk produced by interception\n-        if (_intercepted != null)\n+        boolean ready = _contentProducer.isReady();\n+        if (!ready)\n         {\n-            // Use it if it has any remaining content\n-            if (_intercepted.hasContent())\n-                return _intercepted;\n-\n-            // succeed the chunk\n-            _intercepted.succeeded();\n-            _intercepted = null;\n-        }\n-\n-        // If we don't have a Content under consideration, get\n-        // the next one off the input Q.\n-        if (_content == null)\n-            _content = _inputQ.poll();\n-\n-        // While we have content to consider.\n-        while (_content != null)\n-        {\n-            // Are we intercepting?\n-            if (_interceptor != null)\n-            {\n-                // Intercept the current content (may be called several\n-                // times for the same content\n-                _intercepted = _interceptor.readFrom(_content);\n-\n-                // If interception produced new content\n-                if (_intercepted != null && _intercepted != _content)\n-                {\n-                    // if it is not empty use it\n-                    if (_intercepted.hasContent())\n-                        return _intercepted;\n-                    _intercepted.succeeded();\n-                }\n-\n-                // intercepted content consumed\n-                _intercepted = null;\n-\n-                // fall through so that the unintercepted _content is\n-                // considered for any remaining content, for EOF and to\n-                // succeed it if it is entirely consumed.\n-            }\n-\n-            // If the content has content or is an EOF marker, use it\n-            if (_content.hasContent() || _content instanceof SentinelContent)\n-                return _content;\n-\n-            // The content is consumed, so get the next one.  Note that EOF\n-            // content is never consumed here, but in #pollContent\n-            _content.succeeded();\n-            _content = _inputQ.poll();\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"isReady? false\");\n+            return false;\n         }\n \n-        return null;\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"isReady? true\");\n+        return true;\n     }\n \n-    private void consume(Content content)\n+    @Override\n+    public void setReadListener(ReadListener readListener)\n     {\n-        if (!isError() && content instanceof EofContent)\n-        {\n-            if (content == EARLY_EOF_CONTENT)\n-                _state = EARLY_EOF;\n-            else if (_listener == null)\n-                _state = EOF;\n-            else\n-                _state = AEOF;\n-        }\n+        if (_readListener != null)\n+            throw new IllegalStateException(\"ReadListener already set\");\n+        _readListener = Objects.requireNonNull(readListener);\n+        //illegal if async not started\n+        if (!_channelState.isAsyncStarted())\n+            throw new IllegalStateException(\"Async not started\");\n \n-        // Consume the content, either if it was original content\n-        // or if it was produced by interception\n-        content.succeeded();\n-        if (_content == content)\n-            _content = null;\n-        else if (_intercepted == content)\n-            _intercepted = null;\n+        _contentProducer = _asyncContentProducer;\n+        // trigger content production\n+        if (isReady() && _channelState.onReadEof()) // onReadEof b/c we want to transition from WAITING to WOKEN\n+            scheduleReadListenerNotification(); // this is needed by AsyncServletIOTest.testStolenAsyncRead\n     }\n \n-    /**\n-     * Copies the given content into the given byte buffer.\n-     *\n-     * @param content the content to copy from\n-     * @param buffer the buffer to copy into\n-     * @param offset the buffer offset to start copying from\n-     * @param length the space available in the buffer\n-     * @return the number of bytes actually copied\n-     */\n-    protected int get(Content content, byte[] buffer, int offset, int length)\n+    public boolean wakeup()\n     {\n-        int l = content.get(buffer, offset, length);\n-        _contentConsumed += l;\n-        return l;\n+        boolean wakeup = _contentProducer.wakeup();\n+        return wakeup;\n     }\n \n-    /**\n-     * Consumes the given content. Calls the content succeeded if all content consumed.\n-     *\n-     * @param content the content to consume\n-     * @param length the number of bytes to consume\n-     */\n-    protected void skip(Content content, int length)\n-    {\n-        int l = content.skip(length);\n-\n-        _contentConsumed += l;\n-        if (l > 0 && content.isEmpty())\n-            nextNonSentinelContent(); // hungry succeed\n-    }\n-\n-    /**\n-     * Blocks until some content or some end-of-file event arrives.\n-     *\n-     * @throws IOException if the wait is interrupted\n-     */\n-    protected void blockForContent() throws IOException\n+    @Override\n+    public int read() throws IOException\n     {\n-        assert _lock.isHeldByCurrentThread();\n-        try\n-        {\n-            _waitingForContent = true;\n-            _channelState.getHttpChannel().onBlockWaitForContent();\n-\n-            boolean loop = false;\n-            long timeout = 0;\n-            while (true)\n-            {\n-                // This method is called from a loop, so we just\n-                // need to check the timeout before and after waiting.\n-                if (loop)\n-                    break;\n-\n-                if (LOG.isDebugEnabled())\n-                    LOG.debug(\"{} blocking for content timeout={}\", this, timeout);\n-                if (timeout > 0)\n-                    _lock.await(timeout, TimeUnit.MILLISECONDS);\n-                else\n-                    _lock.await();\n-\n-                loop = true;\n-            }\n-        }\n-        catch (Throwable x)\n-        {\n-            _channelState.getHttpChannel().onBlockWaitForContentFailure(x);\n-        }\n+        int read = read(_oneByteBuffer, 0, 1);\n+        if (read == 0)\n+            throw new IOException(\"unready read=0\");\n+        return read < 0 ? -1 : _oneByteBuffer[0] & 0xFF;\n     }\n \n-    /**\n-     * Adds some content to this input stream.\n-     *\n-     * @param content the content to add\n-     * @return true if content channel woken for read\n-     */\n-    public boolean addContent(Content content)\n+    @Override\n+    public int read(byte[] b, int off, int len) throws IOException\n     {\n-        try (AutoLock l = _lock.lock())\n-        {\n-            _waitingForContent = false;\n-            if (_firstByteTimeStamp == -1)\n-                _firstByteTimeStamp = System.nanoTime();\n+        // Calculate minimum request rate for DoS protection\n+        _contentProducer.checkMinDataRate();\n \n-            if (isFinished())\n-            {\n-                Throwable failure = isError() ? _state.getError() : new EOFException(\"Content after EOF\");\n-                content.failed(failure);\n-                return false;\n-            }\n-            else\n-            {\n-                _contentArrived += content.remaining();\n-\n-                if (_content == null && _inputQ.isEmpty())\n-                    _content = content;\n-                else\n-                    _inputQ.offer(content);\n-\n-                if (LOG.isDebugEnabled())\n-                    LOG.debug(\"{} addContent {}\", this, content);\n-\n-                if (nextInterceptedContent() != null)\n-                    return wakeup();\n-                else\n-                    return false;\n-            }\n-        }\n-    }\n-\n-    public boolean hasContent()\n-    {\n-        try (AutoLock l = _lock.lock())\n+        Content content = _contentProducer.nextContent();\n+        if (content == null)\n+            throw new IllegalStateException(\"read on unready input\");\n+        if (!content.isSpecial())\n         {\n-            return _content != null || _inputQ.size() > 0;\n+            int read = content.get(b, off, len);\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"read produced {} byte(s)\", read);\n+            // Content may be null after the call to read, so it may need to be freed up.\n+            _contentProducer.reclaim(content);", "originalCommit": "273213e8df4f438bf853787ec932e22424e7fe8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQwNzEwNw==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505407107", "bodyText": "Does this code block work for EOF-wrapped content?\nConsider that below there is a content.isEof() check, so here we seem to assume that if a content is not special, then it cannot be EOF.", "author": "sbordet", "createdAt": "2020-10-15T09:44:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTM5MjY0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM4NDY3NQ==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r509384675", "bodyText": "I'll move the check out of reclaim. Regarding EOF: as said earlier, a non-special EOF content can be handled like any other non-EOF content as there's always going to be an extra special EOF content afterwards.", "author": "lorban", "createdAt": "2020-10-21T15:26:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTM5MjY0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQwODY5Mw==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505408693", "bodyText": "See above comment, does this work for EOF-wrapped content?", "author": "sbordet", "createdAt": "2020-10-15T09:47:02Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpInput.java", "diffHunk": "@@ -192,648 +83,183 @@ public Interceptor getInterceptor()\n      */\n     public void setInterceptor(Interceptor interceptor)\n     {\n-        _interceptor = interceptor;\n+        _contentProducer.setInterceptor(interceptor);\n     }\n \n     /**\n-     * Set the {@link Interceptor}, using a {@link ChainedInterceptor} if\n+     * Set the {@link Interceptor}, chaining it to the existing one if\n      * an {@link Interceptor} is already set.\n      *\n      * @param interceptor the next {@link Interceptor} in a chain\n      */\n     public void addInterceptor(Interceptor interceptor)\n     {\n-        if (_interceptor == null)\n-            _interceptor = interceptor;\n+        Interceptor currentInterceptor = _contentProducer.getInterceptor();\n+        if (currentInterceptor == null)\n+            _contentProducer.setInterceptor(interceptor);\n         else\n-            _interceptor = new ChainedInterceptor(_interceptor, interceptor);\n+            _contentProducer.setInterceptor(new ChainedInterceptor(currentInterceptor, interceptor));\n     }\n \n-    @Override\n-    public int available()\n-    {\n-        int available = 0;\n-        boolean woken = false;\n-        try (AutoLock l = _lock.lock())\n-        {\n-            if (_content == null)\n-                _content = _inputQ.poll();\n-            if (_content == null)\n-            {\n-                try\n-                {\n-                    produceContent();\n-                }\n-                catch (IOException e)\n-                {\n-                    woken = failed(e);\n-                }\n-                if (_content == null)\n-                    _content = _inputQ.poll();\n-            }\n-\n-            if (_content != null)\n-                available = _content.remaining();\n-        }\n-\n-        if (woken)\n-            wake();\n-        return available;\n-    }\n-\n-    protected void wake()\n-    {\n-        HttpChannel channel = _channelState.getHttpChannel();\n-        Executor executor = channel.getConnector().getServer().getThreadPool();\n-        executor.execute(channel);\n-    }\n-\n-    @Override\n-    public int read() throws IOException\n+    public long getContentReceived()\n     {\n-        int read = read(_oneByteBuffer, 0, 1);\n-        if (read == 0)\n-            throw new IllegalStateException(\"unready read=0\");\n-        return read < 0 ? -1 : _oneByteBuffer[0] & 0xFF;\n+        return _contentProducer.getRawContentArrived();\n     }\n \n-    @Override\n-    public int read(byte[] b, int off, int len) throws IOException\n+    public boolean consumeAll()\n     {\n-        boolean wake = false;\n-        int read;\n-        try (AutoLock l = _lock.lock())\n-        {\n-            // Calculate minimum request rate for DOS protection\n-            long minRequestDataRate = _channelState.getHttpChannel().getHttpConfiguration().getMinRequestDataRate();\n-            if (minRequestDataRate > 0 && _firstByteTimeStamp != -1)\n-            {\n-                long period = System.nanoTime() - _firstByteTimeStamp;\n-                if (period > 0)\n-                {\n-                    long minimumData = minRequestDataRate * TimeUnit.NANOSECONDS.toMillis(period) / TimeUnit.SECONDS.toMillis(1);\n-                    if (_contentArrived < minimumData)\n-                    {\n-                        BadMessageException bad = new BadMessageException(HttpStatus.REQUEST_TIMEOUT_408,\n-                            String.format(\"Request content data rate < %d B/s\", minRequestDataRate));\n-                        if (_channelState.isResponseCommitted())\n-                            _channelState.getHttpChannel().abort(bad);\n-                        throw bad;\n-                    }\n-                }\n-            }\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"consume all\");\n+        boolean atEof = _contentProducer.consumeAll(new IOException(\"Unconsumed content\"));\n+        if (atEof)\n+            _consumedEof = true;\n \n-            // Consume content looking for bytes to read\n-            while (true)\n-            {\n-                Content item = nextContent();\n-                if (item != null)\n-                {\n-                    read = get(item, b, off, len);\n-                    if (LOG.isDebugEnabled())\n-                        LOG.debug(\"{} read {} from {}\", this, read, item);\n-\n-                    // Consume any following poison pills\n-                    if (item.isEmpty())\n-                        nextInterceptedContent();\n-                    break;\n-                }\n-\n-                // No content, so should we block?\n-                if (!_state.blockForContent(this))\n-                {\n-                    // Not blocking, so what should we return?\n-                    read = _state.noContent();\n-\n-                    if (read < 0)\n-                        // If EOF do we need to wake for allDataRead callback?\n-                        wake = _channelState.onReadEof();\n-                    break;\n-                }\n-            }\n-        }\n-\n-        if (wake)\n-            wake();\n-        return read;\n-    }\n+        if (isFinished())\n+            return !isError();\n \n-    /**\n-     * Called when derived implementations should attempt to produce more Content and add it via {@link #addContent(Content)}. For protocols that are constantly\n-     * producing (eg HTTP2) this can be left as a noop;\n-     *\n-     * @throws IOException if unable to produce content\n-     */\n-    protected void produceContent() throws IOException\n-    {\n+        // Modifying the state here to anything other than IDLE makes\n+        // ServerTimeoutsTest.testAsyncReadWithDelayedFirstContentWithDelayedDispatchIdleTimeoutFires H2C fail.\n+        return false;\n     }\n \n-    /**\n-     * Called by channel when asynchronous IO needs to produce more content\n-     *\n-     * @throws IOException if unable to produce content\n-     */\n-    public void asyncReadProduce() throws IOException\n+    public boolean isError()\n     {\n-        try (AutoLock l = _lock.lock())\n-        {\n-            produceContent();\n-        }\n+        return _contentProducer.isError();\n     }\n \n-    /**\n-     * Get the next content from the inputQ, calling {@link #produceContent()} if need be. EOF is processed and state changed.\n-     *\n-     * @return the content or null if none available.\n-     * @throws IOException if retrieving the content fails\n-     */\n-    protected Content nextContent() throws IOException\n+    public boolean isAsync()\n     {\n-        Content content = nextNonSentinelContent();\n-        if (content == null && !isFinished())\n-        {\n-            produceContent();\n-            content = nextNonSentinelContent();\n-        }\n-        return content;\n+        return _readListener != null;\n     }\n \n-    /**\n-     * Poll the inputQ for Content. Consumed buffers and {@link SentinelContent}s are removed and EOF state updated if need be.\n-     *\n-     * @return Content or null\n-     */\n-    protected Content nextNonSentinelContent()\n-    {\n-        while (true)\n-        {\n-            // Get the next content (or EOF)\n-            Content content = nextInterceptedContent();\n-\n-            // If it is EOF, consume it here\n-            if (content instanceof SentinelContent)\n-            {\n-                // Consume the EOF content, either if it was original content\n-                // or if it was produced by interception\n-                consume(content);\n-                continue;\n-            }\n+    /* ServletInputStream */\n \n-            return content;\n-        }\n-    }\n-\n-    /**\n-     * Get the next readable from the inputQ, calling {@link #produceContent()} if need be. EOF is NOT processed and state is not changed.\n-     *\n-     * @return the content or EOF or null if none available.\n-     * @throws IOException if retrieving the content fails\n-     */\n-    protected Content produceNextContext() throws IOException\n+    @Override\n+    public boolean isFinished()\n     {\n-        Content content = nextInterceptedContent();\n-        if (content == null && !isFinished())\n-        {\n-            produceContent();\n-            content = nextInterceptedContent();\n-        }\n-        return content;\n+        boolean finished = _consumedEof;\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"isFinished? {}\", finished);\n+        return finished;\n     }\n \n-    /**\n-     * Poll the inputQ for Content or EOF. Consumed buffers and non EOF {@link SentinelContent}s are removed. EOF state is not updated.\n-     * Interception is done within this method.\n-     *\n-     * @return Content with remaining, a {@link SentinelContent},  or null\n-     */\n-    protected Content nextInterceptedContent()\n+    @Override\n+    public boolean isReady()\n     {\n-        // If we have a chunk produced by interception\n-        if (_intercepted != null)\n+        boolean ready = _contentProducer.isReady();\n+        if (!ready)\n         {\n-            // Use it if it has any remaining content\n-            if (_intercepted.hasContent())\n-                return _intercepted;\n-\n-            // succeed the chunk\n-            _intercepted.succeeded();\n-            _intercepted = null;\n-        }\n-\n-        // If we don't have a Content under consideration, get\n-        // the next one off the input Q.\n-        if (_content == null)\n-            _content = _inputQ.poll();\n-\n-        // While we have content to consider.\n-        while (_content != null)\n-        {\n-            // Are we intercepting?\n-            if (_interceptor != null)\n-            {\n-                // Intercept the current content (may be called several\n-                // times for the same content\n-                _intercepted = _interceptor.readFrom(_content);\n-\n-                // If interception produced new content\n-                if (_intercepted != null && _intercepted != _content)\n-                {\n-                    // if it is not empty use it\n-                    if (_intercepted.hasContent())\n-                        return _intercepted;\n-                    _intercepted.succeeded();\n-                }\n-\n-                // intercepted content consumed\n-                _intercepted = null;\n-\n-                // fall through so that the unintercepted _content is\n-                // considered for any remaining content, for EOF and to\n-                // succeed it if it is entirely consumed.\n-            }\n-\n-            // If the content has content or is an EOF marker, use it\n-            if (_content.hasContent() || _content instanceof SentinelContent)\n-                return _content;\n-\n-            // The content is consumed, so get the next one.  Note that EOF\n-            // content is never consumed here, but in #pollContent\n-            _content.succeeded();\n-            _content = _inputQ.poll();\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"isReady? false\");\n+            return false;\n         }\n \n-        return null;\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"isReady? true\");\n+        return true;\n     }\n \n-    private void consume(Content content)\n+    @Override\n+    public void setReadListener(ReadListener readListener)\n     {\n-        if (!isError() && content instanceof EofContent)\n-        {\n-            if (content == EARLY_EOF_CONTENT)\n-                _state = EARLY_EOF;\n-            else if (_listener == null)\n-                _state = EOF;\n-            else\n-                _state = AEOF;\n-        }\n+        if (_readListener != null)\n+            throw new IllegalStateException(\"ReadListener already set\");\n+        _readListener = Objects.requireNonNull(readListener);\n+        //illegal if async not started\n+        if (!_channelState.isAsyncStarted())\n+            throw new IllegalStateException(\"Async not started\");\n \n-        // Consume the content, either if it was original content\n-        // or if it was produced by interception\n-        content.succeeded();\n-        if (_content == content)\n-            _content = null;\n-        else if (_intercepted == content)\n-            _intercepted = null;\n+        _contentProducer = _asyncContentProducer;\n+        // trigger content production\n+        if (isReady() && _channelState.onReadEof()) // onReadEof b/c we want to transition from WAITING to WOKEN\n+            scheduleReadListenerNotification(); // this is needed by AsyncServletIOTest.testStolenAsyncRead\n     }\n \n-    /**\n-     * Copies the given content into the given byte buffer.\n-     *\n-     * @param content the content to copy from\n-     * @param buffer the buffer to copy into\n-     * @param offset the buffer offset to start copying from\n-     * @param length the space available in the buffer\n-     * @return the number of bytes actually copied\n-     */\n-    protected int get(Content content, byte[] buffer, int offset, int length)\n+    public boolean wakeup()\n     {\n-        int l = content.get(buffer, offset, length);\n-        _contentConsumed += l;\n-        return l;\n+        boolean wakeup = _contentProducer.wakeup();\n+        return wakeup;\n     }\n \n-    /**\n-     * Consumes the given content. Calls the content succeeded if all content consumed.\n-     *\n-     * @param content the content to consume\n-     * @param length the number of bytes to consume\n-     */\n-    protected void skip(Content content, int length)\n-    {\n-        int l = content.skip(length);\n-\n-        _contentConsumed += l;\n-        if (l > 0 && content.isEmpty())\n-            nextNonSentinelContent(); // hungry succeed\n-    }\n-\n-    /**\n-     * Blocks until some content or some end-of-file event arrives.\n-     *\n-     * @throws IOException if the wait is interrupted\n-     */\n-    protected void blockForContent() throws IOException\n+    @Override\n+    public int read() throws IOException\n     {\n-        assert _lock.isHeldByCurrentThread();\n-        try\n-        {\n-            _waitingForContent = true;\n-            _channelState.getHttpChannel().onBlockWaitForContent();\n-\n-            boolean loop = false;\n-            long timeout = 0;\n-            while (true)\n-            {\n-                // This method is called from a loop, so we just\n-                // need to check the timeout before and after waiting.\n-                if (loop)\n-                    break;\n-\n-                if (LOG.isDebugEnabled())\n-                    LOG.debug(\"{} blocking for content timeout={}\", this, timeout);\n-                if (timeout > 0)\n-                    _lock.await(timeout, TimeUnit.MILLISECONDS);\n-                else\n-                    _lock.await();\n-\n-                loop = true;\n-            }\n-        }\n-        catch (Throwable x)\n-        {\n-            _channelState.getHttpChannel().onBlockWaitForContentFailure(x);\n-        }\n+        int read = read(_oneByteBuffer, 0, 1);\n+        if (read == 0)\n+            throw new IOException(\"unready read=0\");\n+        return read < 0 ? -1 : _oneByteBuffer[0] & 0xFF;\n     }\n \n-    /**\n-     * Adds some content to this input stream.\n-     *\n-     * @param content the content to add\n-     * @return true if content channel woken for read\n-     */\n-    public boolean addContent(Content content)\n+    @Override\n+    public int read(byte[] b, int off, int len) throws IOException\n     {\n-        try (AutoLock l = _lock.lock())\n-        {\n-            _waitingForContent = false;\n-            if (_firstByteTimeStamp == -1)\n-                _firstByteTimeStamp = System.nanoTime();\n+        // Calculate minimum request rate for DoS protection\n+        _contentProducer.checkMinDataRate();\n \n-            if (isFinished())\n-            {\n-                Throwable failure = isError() ? _state.getError() : new EOFException(\"Content after EOF\");\n-                content.failed(failure);\n-                return false;\n-            }\n-            else\n-            {\n-                _contentArrived += content.remaining();\n-\n-                if (_content == null && _inputQ.isEmpty())\n-                    _content = content;\n-                else\n-                    _inputQ.offer(content);\n-\n-                if (LOG.isDebugEnabled())\n-                    LOG.debug(\"{} addContent {}\", this, content);\n-\n-                if (nextInterceptedContent() != null)\n-                    return wakeup();\n-                else\n-                    return false;\n-            }\n-        }\n-    }\n-\n-    public boolean hasContent()\n-    {\n-        try (AutoLock l = _lock.lock())\n+        Content content = _contentProducer.nextContent();\n+        if (content == null)\n+            throw new IllegalStateException(\"read on unready input\");\n+        if (!content.isSpecial())\n         {\n-            return _content != null || _inputQ.size() > 0;\n+            int read = content.get(b, off, len);\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"read produced {} byte(s)\", read);\n+            // Content may be null after the call to read, so it may need to be freed up.\n+            _contentProducer.reclaim(content);\n+            return read;\n         }\n-    }\n \n-    public void unblock()\n-    {\n-        try (AutoLock.WithCondition l = _lock.lock())\n+        Throwable error = content.getError();\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"read error = \" + error);\n+        if (error != null)\n         {\n-            l.signal();\n+            if (error instanceof IOException)\n+                throw (IOException)error;\n+            throw new IOException(error);\n         }\n-    }\n \n-    public long getContentConsumed()\n-    {\n-        try (AutoLock l = _lock.lock())\n+        if (content.isEof())", "originalCommit": "273213e8df4f438bf853787ec932e22424e7fe8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM4NTUwMA==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r509385500", "bodyText": "Yes, see my previous answer.", "author": "lorban", "createdAt": "2020-10-21T15:27:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQwODY5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQxMDIwMA==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505410200", "bodyText": "This will dispatch a new thread -- why do we need to wakeup from inside read() and dispatch a new thread?", "author": "sbordet", "createdAt": "2020-10-15T09:48:57Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpInput.java", "diffHunk": "@@ -192,648 +83,183 @@ public Interceptor getInterceptor()\n      */\n     public void setInterceptor(Interceptor interceptor)\n     {\n-        _interceptor = interceptor;\n+        _contentProducer.setInterceptor(interceptor);\n     }\n \n     /**\n-     * Set the {@link Interceptor}, using a {@link ChainedInterceptor} if\n+     * Set the {@link Interceptor}, chaining it to the existing one if\n      * an {@link Interceptor} is already set.\n      *\n      * @param interceptor the next {@link Interceptor} in a chain\n      */\n     public void addInterceptor(Interceptor interceptor)\n     {\n-        if (_interceptor == null)\n-            _interceptor = interceptor;\n+        Interceptor currentInterceptor = _contentProducer.getInterceptor();\n+        if (currentInterceptor == null)\n+            _contentProducer.setInterceptor(interceptor);\n         else\n-            _interceptor = new ChainedInterceptor(_interceptor, interceptor);\n+            _contentProducer.setInterceptor(new ChainedInterceptor(currentInterceptor, interceptor));\n     }\n \n-    @Override\n-    public int available()\n-    {\n-        int available = 0;\n-        boolean woken = false;\n-        try (AutoLock l = _lock.lock())\n-        {\n-            if (_content == null)\n-                _content = _inputQ.poll();\n-            if (_content == null)\n-            {\n-                try\n-                {\n-                    produceContent();\n-                }\n-                catch (IOException e)\n-                {\n-                    woken = failed(e);\n-                }\n-                if (_content == null)\n-                    _content = _inputQ.poll();\n-            }\n-\n-            if (_content != null)\n-                available = _content.remaining();\n-        }\n-\n-        if (woken)\n-            wake();\n-        return available;\n-    }\n-\n-    protected void wake()\n-    {\n-        HttpChannel channel = _channelState.getHttpChannel();\n-        Executor executor = channel.getConnector().getServer().getThreadPool();\n-        executor.execute(channel);\n-    }\n-\n-    @Override\n-    public int read() throws IOException\n+    public long getContentReceived()\n     {\n-        int read = read(_oneByteBuffer, 0, 1);\n-        if (read == 0)\n-            throw new IllegalStateException(\"unready read=0\");\n-        return read < 0 ? -1 : _oneByteBuffer[0] & 0xFF;\n+        return _contentProducer.getRawContentArrived();\n     }\n \n-    @Override\n-    public int read(byte[] b, int off, int len) throws IOException\n+    public boolean consumeAll()\n     {\n-        boolean wake = false;\n-        int read;\n-        try (AutoLock l = _lock.lock())\n-        {\n-            // Calculate minimum request rate for DOS protection\n-            long minRequestDataRate = _channelState.getHttpChannel().getHttpConfiguration().getMinRequestDataRate();\n-            if (minRequestDataRate > 0 && _firstByteTimeStamp != -1)\n-            {\n-                long period = System.nanoTime() - _firstByteTimeStamp;\n-                if (period > 0)\n-                {\n-                    long minimumData = minRequestDataRate * TimeUnit.NANOSECONDS.toMillis(period) / TimeUnit.SECONDS.toMillis(1);\n-                    if (_contentArrived < minimumData)\n-                    {\n-                        BadMessageException bad = new BadMessageException(HttpStatus.REQUEST_TIMEOUT_408,\n-                            String.format(\"Request content data rate < %d B/s\", minRequestDataRate));\n-                        if (_channelState.isResponseCommitted())\n-                            _channelState.getHttpChannel().abort(bad);\n-                        throw bad;\n-                    }\n-                }\n-            }\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"consume all\");\n+        boolean atEof = _contentProducer.consumeAll(new IOException(\"Unconsumed content\"));\n+        if (atEof)\n+            _consumedEof = true;\n \n-            // Consume content looking for bytes to read\n-            while (true)\n-            {\n-                Content item = nextContent();\n-                if (item != null)\n-                {\n-                    read = get(item, b, off, len);\n-                    if (LOG.isDebugEnabled())\n-                        LOG.debug(\"{} read {} from {}\", this, read, item);\n-\n-                    // Consume any following poison pills\n-                    if (item.isEmpty())\n-                        nextInterceptedContent();\n-                    break;\n-                }\n-\n-                // No content, so should we block?\n-                if (!_state.blockForContent(this))\n-                {\n-                    // Not blocking, so what should we return?\n-                    read = _state.noContent();\n-\n-                    if (read < 0)\n-                        // If EOF do we need to wake for allDataRead callback?\n-                        wake = _channelState.onReadEof();\n-                    break;\n-                }\n-            }\n-        }\n-\n-        if (wake)\n-            wake();\n-        return read;\n-    }\n+        if (isFinished())\n+            return !isError();\n \n-    /**\n-     * Called when derived implementations should attempt to produce more Content and add it via {@link #addContent(Content)}. For protocols that are constantly\n-     * producing (eg HTTP2) this can be left as a noop;\n-     *\n-     * @throws IOException if unable to produce content\n-     */\n-    protected void produceContent() throws IOException\n-    {\n+        // Modifying the state here to anything other than IDLE makes\n+        // ServerTimeoutsTest.testAsyncReadWithDelayedFirstContentWithDelayedDispatchIdleTimeoutFires H2C fail.\n+        return false;\n     }\n \n-    /**\n-     * Called by channel when asynchronous IO needs to produce more content\n-     *\n-     * @throws IOException if unable to produce content\n-     */\n-    public void asyncReadProduce() throws IOException\n+    public boolean isError()\n     {\n-        try (AutoLock l = _lock.lock())\n-        {\n-            produceContent();\n-        }\n+        return _contentProducer.isError();\n     }\n \n-    /**\n-     * Get the next content from the inputQ, calling {@link #produceContent()} if need be. EOF is processed and state changed.\n-     *\n-     * @return the content or null if none available.\n-     * @throws IOException if retrieving the content fails\n-     */\n-    protected Content nextContent() throws IOException\n+    public boolean isAsync()\n     {\n-        Content content = nextNonSentinelContent();\n-        if (content == null && !isFinished())\n-        {\n-            produceContent();\n-            content = nextNonSentinelContent();\n-        }\n-        return content;\n+        return _readListener != null;\n     }\n \n-    /**\n-     * Poll the inputQ for Content. Consumed buffers and {@link SentinelContent}s are removed and EOF state updated if need be.\n-     *\n-     * @return Content or null\n-     */\n-    protected Content nextNonSentinelContent()\n-    {\n-        while (true)\n-        {\n-            // Get the next content (or EOF)\n-            Content content = nextInterceptedContent();\n-\n-            // If it is EOF, consume it here\n-            if (content instanceof SentinelContent)\n-            {\n-                // Consume the EOF content, either if it was original content\n-                // or if it was produced by interception\n-                consume(content);\n-                continue;\n-            }\n+    /* ServletInputStream */\n \n-            return content;\n-        }\n-    }\n-\n-    /**\n-     * Get the next readable from the inputQ, calling {@link #produceContent()} if need be. EOF is NOT processed and state is not changed.\n-     *\n-     * @return the content or EOF or null if none available.\n-     * @throws IOException if retrieving the content fails\n-     */\n-    protected Content produceNextContext() throws IOException\n+    @Override\n+    public boolean isFinished()\n     {\n-        Content content = nextInterceptedContent();\n-        if (content == null && !isFinished())\n-        {\n-            produceContent();\n-            content = nextInterceptedContent();\n-        }\n-        return content;\n+        boolean finished = _consumedEof;\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"isFinished? {}\", finished);\n+        return finished;\n     }\n \n-    /**\n-     * Poll the inputQ for Content or EOF. Consumed buffers and non EOF {@link SentinelContent}s are removed. EOF state is not updated.\n-     * Interception is done within this method.\n-     *\n-     * @return Content with remaining, a {@link SentinelContent},  or null\n-     */\n-    protected Content nextInterceptedContent()\n+    @Override\n+    public boolean isReady()\n     {\n-        // If we have a chunk produced by interception\n-        if (_intercepted != null)\n+        boolean ready = _contentProducer.isReady();\n+        if (!ready)\n         {\n-            // Use it if it has any remaining content\n-            if (_intercepted.hasContent())\n-                return _intercepted;\n-\n-            // succeed the chunk\n-            _intercepted.succeeded();\n-            _intercepted = null;\n-        }\n-\n-        // If we don't have a Content under consideration, get\n-        // the next one off the input Q.\n-        if (_content == null)\n-            _content = _inputQ.poll();\n-\n-        // While we have content to consider.\n-        while (_content != null)\n-        {\n-            // Are we intercepting?\n-            if (_interceptor != null)\n-            {\n-                // Intercept the current content (may be called several\n-                // times for the same content\n-                _intercepted = _interceptor.readFrom(_content);\n-\n-                // If interception produced new content\n-                if (_intercepted != null && _intercepted != _content)\n-                {\n-                    // if it is not empty use it\n-                    if (_intercepted.hasContent())\n-                        return _intercepted;\n-                    _intercepted.succeeded();\n-                }\n-\n-                // intercepted content consumed\n-                _intercepted = null;\n-\n-                // fall through so that the unintercepted _content is\n-                // considered for any remaining content, for EOF and to\n-                // succeed it if it is entirely consumed.\n-            }\n-\n-            // If the content has content or is an EOF marker, use it\n-            if (_content.hasContent() || _content instanceof SentinelContent)\n-                return _content;\n-\n-            // The content is consumed, so get the next one.  Note that EOF\n-            // content is never consumed here, but in #pollContent\n-            _content.succeeded();\n-            _content = _inputQ.poll();\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"isReady? false\");\n+            return false;\n         }\n \n-        return null;\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"isReady? true\");\n+        return true;\n     }\n \n-    private void consume(Content content)\n+    @Override\n+    public void setReadListener(ReadListener readListener)\n     {\n-        if (!isError() && content instanceof EofContent)\n-        {\n-            if (content == EARLY_EOF_CONTENT)\n-                _state = EARLY_EOF;\n-            else if (_listener == null)\n-                _state = EOF;\n-            else\n-                _state = AEOF;\n-        }\n+        if (_readListener != null)\n+            throw new IllegalStateException(\"ReadListener already set\");\n+        _readListener = Objects.requireNonNull(readListener);\n+        //illegal if async not started\n+        if (!_channelState.isAsyncStarted())\n+            throw new IllegalStateException(\"Async not started\");\n \n-        // Consume the content, either if it was original content\n-        // or if it was produced by interception\n-        content.succeeded();\n-        if (_content == content)\n-            _content = null;\n-        else if (_intercepted == content)\n-            _intercepted = null;\n+        _contentProducer = _asyncContentProducer;\n+        // trigger content production\n+        if (isReady() && _channelState.onReadEof()) // onReadEof b/c we want to transition from WAITING to WOKEN\n+            scheduleReadListenerNotification(); // this is needed by AsyncServletIOTest.testStolenAsyncRead\n     }\n \n-    /**\n-     * Copies the given content into the given byte buffer.\n-     *\n-     * @param content the content to copy from\n-     * @param buffer the buffer to copy into\n-     * @param offset the buffer offset to start copying from\n-     * @param length the space available in the buffer\n-     * @return the number of bytes actually copied\n-     */\n-    protected int get(Content content, byte[] buffer, int offset, int length)\n+    public boolean wakeup()\n     {\n-        int l = content.get(buffer, offset, length);\n-        _contentConsumed += l;\n-        return l;\n+        boolean wakeup = _contentProducer.wakeup();\n+        return wakeup;\n     }\n \n-    /**\n-     * Consumes the given content. Calls the content succeeded if all content consumed.\n-     *\n-     * @param content the content to consume\n-     * @param length the number of bytes to consume\n-     */\n-    protected void skip(Content content, int length)\n-    {\n-        int l = content.skip(length);\n-\n-        _contentConsumed += l;\n-        if (l > 0 && content.isEmpty())\n-            nextNonSentinelContent(); // hungry succeed\n-    }\n-\n-    /**\n-     * Blocks until some content or some end-of-file event arrives.\n-     *\n-     * @throws IOException if the wait is interrupted\n-     */\n-    protected void blockForContent() throws IOException\n+    @Override\n+    public int read() throws IOException\n     {\n-        assert _lock.isHeldByCurrentThread();\n-        try\n-        {\n-            _waitingForContent = true;\n-            _channelState.getHttpChannel().onBlockWaitForContent();\n-\n-            boolean loop = false;\n-            long timeout = 0;\n-            while (true)\n-            {\n-                // This method is called from a loop, so we just\n-                // need to check the timeout before and after waiting.\n-                if (loop)\n-                    break;\n-\n-                if (LOG.isDebugEnabled())\n-                    LOG.debug(\"{} blocking for content timeout={}\", this, timeout);\n-                if (timeout > 0)\n-                    _lock.await(timeout, TimeUnit.MILLISECONDS);\n-                else\n-                    _lock.await();\n-\n-                loop = true;\n-            }\n-        }\n-        catch (Throwable x)\n-        {\n-            _channelState.getHttpChannel().onBlockWaitForContentFailure(x);\n-        }\n+        int read = read(_oneByteBuffer, 0, 1);\n+        if (read == 0)\n+            throw new IOException(\"unready read=0\");\n+        return read < 0 ? -1 : _oneByteBuffer[0] & 0xFF;\n     }\n \n-    /**\n-     * Adds some content to this input stream.\n-     *\n-     * @param content the content to add\n-     * @return true if content channel woken for read\n-     */\n-    public boolean addContent(Content content)\n+    @Override\n+    public int read(byte[] b, int off, int len) throws IOException\n     {\n-        try (AutoLock l = _lock.lock())\n-        {\n-            _waitingForContent = false;\n-            if (_firstByteTimeStamp == -1)\n-                _firstByteTimeStamp = System.nanoTime();\n+        // Calculate minimum request rate for DoS protection\n+        _contentProducer.checkMinDataRate();\n \n-            if (isFinished())\n-            {\n-                Throwable failure = isError() ? _state.getError() : new EOFException(\"Content after EOF\");\n-                content.failed(failure);\n-                return false;\n-            }\n-            else\n-            {\n-                _contentArrived += content.remaining();\n-\n-                if (_content == null && _inputQ.isEmpty())\n-                    _content = content;\n-                else\n-                    _inputQ.offer(content);\n-\n-                if (LOG.isDebugEnabled())\n-                    LOG.debug(\"{} addContent {}\", this, content);\n-\n-                if (nextInterceptedContent() != null)\n-                    return wakeup();\n-                else\n-                    return false;\n-            }\n-        }\n-    }\n-\n-    public boolean hasContent()\n-    {\n-        try (AutoLock l = _lock.lock())\n+        Content content = _contentProducer.nextContent();\n+        if (content == null)\n+            throw new IllegalStateException(\"read on unready input\");\n+        if (!content.isSpecial())\n         {\n-            return _content != null || _inputQ.size() > 0;\n+            int read = content.get(b, off, len);\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"read produced {} byte(s)\", read);\n+            // Content may be null after the call to read, so it may need to be freed up.\n+            _contentProducer.reclaim(content);\n+            return read;\n         }\n-    }\n \n-    public void unblock()\n-    {\n-        try (AutoLock.WithCondition l = _lock.lock())\n+        Throwable error = content.getError();\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"read error = \" + error);\n+        if (error != null)\n         {\n-            l.signal();\n+            if (error instanceof IOException)\n+                throw (IOException)error;\n+            throw new IOException(error);\n         }\n-    }\n \n-    public long getContentConsumed()\n-    {\n-        try (AutoLock l = _lock.lock())\n+        if (content.isEof())\n         {\n-            return _contentConsumed;\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"read on EOF, switching to CONSUMED_EOF and returning\");\n+            _consumedEof = true;\n+            if (wakeup())\n+                scheduleReadListenerNotification();", "originalCommit": "273213e8df4f438bf853787ec932e22424e7fe8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM4ODA2Mg==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r509388062", "bodyText": "When we reach EOF we need to wake for allDataRead callback. This is identical to how it was previously done. I'll add a comment to make that clearer.", "author": "lorban", "createdAt": "2020-10-21T15:30:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQxMDIwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQxMDgxNA==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505410814", "bodyText": "Perhaps \"peekContent()` is more descriptive of what the method does.", "author": "sbordet", "createdAt": "2020-10-15T09:49:55Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpInput.java", "diffHunk": "@@ -192,648 +83,183 @@ public Interceptor getInterceptor()\n      */\n     public void setInterceptor(Interceptor interceptor)\n     {\n-        _interceptor = interceptor;\n+        _contentProducer.setInterceptor(interceptor);\n     }\n \n     /**\n-     * Set the {@link Interceptor}, using a {@link ChainedInterceptor} if\n+     * Set the {@link Interceptor}, chaining it to the existing one if\n      * an {@link Interceptor} is already set.\n      *\n      * @param interceptor the next {@link Interceptor} in a chain\n      */\n     public void addInterceptor(Interceptor interceptor)\n     {\n-        if (_interceptor == null)\n-            _interceptor = interceptor;\n+        Interceptor currentInterceptor = _contentProducer.getInterceptor();\n+        if (currentInterceptor == null)\n+            _contentProducer.setInterceptor(interceptor);\n         else\n-            _interceptor = new ChainedInterceptor(_interceptor, interceptor);\n+            _contentProducer.setInterceptor(new ChainedInterceptor(currentInterceptor, interceptor));\n     }\n \n-    @Override\n-    public int available()\n-    {\n-        int available = 0;\n-        boolean woken = false;\n-        try (AutoLock l = _lock.lock())\n-        {\n-            if (_content == null)\n-                _content = _inputQ.poll();\n-            if (_content == null)\n-            {\n-                try\n-                {\n-                    produceContent();\n-                }\n-                catch (IOException e)\n-                {\n-                    woken = failed(e);\n-                }\n-                if (_content == null)\n-                    _content = _inputQ.poll();\n-            }\n-\n-            if (_content != null)\n-                available = _content.remaining();\n-        }\n-\n-        if (woken)\n-            wake();\n-        return available;\n-    }\n-\n-    protected void wake()\n-    {\n-        HttpChannel channel = _channelState.getHttpChannel();\n-        Executor executor = channel.getConnector().getServer().getThreadPool();\n-        executor.execute(channel);\n-    }\n-\n-    @Override\n-    public int read() throws IOException\n+    public long getContentReceived()\n     {\n-        int read = read(_oneByteBuffer, 0, 1);\n-        if (read == 0)\n-            throw new IllegalStateException(\"unready read=0\");\n-        return read < 0 ? -1 : _oneByteBuffer[0] & 0xFF;\n+        return _contentProducer.getRawContentArrived();\n     }\n \n-    @Override\n-    public int read(byte[] b, int off, int len) throws IOException\n+    public boolean consumeAll()\n     {\n-        boolean wake = false;\n-        int read;\n-        try (AutoLock l = _lock.lock())\n-        {\n-            // Calculate minimum request rate for DOS protection\n-            long minRequestDataRate = _channelState.getHttpChannel().getHttpConfiguration().getMinRequestDataRate();\n-            if (minRequestDataRate > 0 && _firstByteTimeStamp != -1)\n-            {\n-                long period = System.nanoTime() - _firstByteTimeStamp;\n-                if (period > 0)\n-                {\n-                    long minimumData = minRequestDataRate * TimeUnit.NANOSECONDS.toMillis(period) / TimeUnit.SECONDS.toMillis(1);\n-                    if (_contentArrived < minimumData)\n-                    {\n-                        BadMessageException bad = new BadMessageException(HttpStatus.REQUEST_TIMEOUT_408,\n-                            String.format(\"Request content data rate < %d B/s\", minRequestDataRate));\n-                        if (_channelState.isResponseCommitted())\n-                            _channelState.getHttpChannel().abort(bad);\n-                        throw bad;\n-                    }\n-                }\n-            }\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"consume all\");\n+        boolean atEof = _contentProducer.consumeAll(new IOException(\"Unconsumed content\"));\n+        if (atEof)\n+            _consumedEof = true;\n \n-            // Consume content looking for bytes to read\n-            while (true)\n-            {\n-                Content item = nextContent();\n-                if (item != null)\n-                {\n-                    read = get(item, b, off, len);\n-                    if (LOG.isDebugEnabled())\n-                        LOG.debug(\"{} read {} from {}\", this, read, item);\n-\n-                    // Consume any following poison pills\n-                    if (item.isEmpty())\n-                        nextInterceptedContent();\n-                    break;\n-                }\n-\n-                // No content, so should we block?\n-                if (!_state.blockForContent(this))\n-                {\n-                    // Not blocking, so what should we return?\n-                    read = _state.noContent();\n-\n-                    if (read < 0)\n-                        // If EOF do we need to wake for allDataRead callback?\n-                        wake = _channelState.onReadEof();\n-                    break;\n-                }\n-            }\n-        }\n-\n-        if (wake)\n-            wake();\n-        return read;\n-    }\n+        if (isFinished())\n+            return !isError();\n \n-    /**\n-     * Called when derived implementations should attempt to produce more Content and add it via {@link #addContent(Content)}. For protocols that are constantly\n-     * producing (eg HTTP2) this can be left as a noop;\n-     *\n-     * @throws IOException if unable to produce content\n-     */\n-    protected void produceContent() throws IOException\n-    {\n+        // Modifying the state here to anything other than IDLE makes\n+        // ServerTimeoutsTest.testAsyncReadWithDelayedFirstContentWithDelayedDispatchIdleTimeoutFires H2C fail.\n+        return false;\n     }\n \n-    /**\n-     * Called by channel when asynchronous IO needs to produce more content\n-     *\n-     * @throws IOException if unable to produce content\n-     */\n-    public void asyncReadProduce() throws IOException\n+    public boolean isError()\n     {\n-        try (AutoLock l = _lock.lock())\n-        {\n-            produceContent();\n-        }\n+        return _contentProducer.isError();\n     }\n \n-    /**\n-     * Get the next content from the inputQ, calling {@link #produceContent()} if need be. EOF is processed and state changed.\n-     *\n-     * @return the content or null if none available.\n-     * @throws IOException if retrieving the content fails\n-     */\n-    protected Content nextContent() throws IOException\n+    public boolean isAsync()\n     {\n-        Content content = nextNonSentinelContent();\n-        if (content == null && !isFinished())\n-        {\n-            produceContent();\n-            content = nextNonSentinelContent();\n-        }\n-        return content;\n+        return _readListener != null;\n     }\n \n-    /**\n-     * Poll the inputQ for Content. Consumed buffers and {@link SentinelContent}s are removed and EOF state updated if need be.\n-     *\n-     * @return Content or null\n-     */\n-    protected Content nextNonSentinelContent()\n-    {\n-        while (true)\n-        {\n-            // Get the next content (or EOF)\n-            Content content = nextInterceptedContent();\n-\n-            // If it is EOF, consume it here\n-            if (content instanceof SentinelContent)\n-            {\n-                // Consume the EOF content, either if it was original content\n-                // or if it was produced by interception\n-                consume(content);\n-                continue;\n-            }\n+    /* ServletInputStream */\n \n-            return content;\n-        }\n-    }\n-\n-    /**\n-     * Get the next readable from the inputQ, calling {@link #produceContent()} if need be. EOF is NOT processed and state is not changed.\n-     *\n-     * @return the content or EOF or null if none available.\n-     * @throws IOException if retrieving the content fails\n-     */\n-    protected Content produceNextContext() throws IOException\n+    @Override\n+    public boolean isFinished()\n     {\n-        Content content = nextInterceptedContent();\n-        if (content == null && !isFinished())\n-        {\n-            produceContent();\n-            content = nextInterceptedContent();\n-        }\n-        return content;\n+        boolean finished = _consumedEof;\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"isFinished? {}\", finished);\n+        return finished;\n     }\n \n-    /**\n-     * Poll the inputQ for Content or EOF. Consumed buffers and non EOF {@link SentinelContent}s are removed. EOF state is not updated.\n-     * Interception is done within this method.\n-     *\n-     * @return Content with remaining, a {@link SentinelContent},  or null\n-     */\n-    protected Content nextInterceptedContent()\n+    @Override\n+    public boolean isReady()\n     {\n-        // If we have a chunk produced by interception\n-        if (_intercepted != null)\n+        boolean ready = _contentProducer.isReady();\n+        if (!ready)\n         {\n-            // Use it if it has any remaining content\n-            if (_intercepted.hasContent())\n-                return _intercepted;\n-\n-            // succeed the chunk\n-            _intercepted.succeeded();\n-            _intercepted = null;\n-        }\n-\n-        // If we don't have a Content under consideration, get\n-        // the next one off the input Q.\n-        if (_content == null)\n-            _content = _inputQ.poll();\n-\n-        // While we have content to consider.\n-        while (_content != null)\n-        {\n-            // Are we intercepting?\n-            if (_interceptor != null)\n-            {\n-                // Intercept the current content (may be called several\n-                // times for the same content\n-                _intercepted = _interceptor.readFrom(_content);\n-\n-                // If interception produced new content\n-                if (_intercepted != null && _intercepted != _content)\n-                {\n-                    // if it is not empty use it\n-                    if (_intercepted.hasContent())\n-                        return _intercepted;\n-                    _intercepted.succeeded();\n-                }\n-\n-                // intercepted content consumed\n-                _intercepted = null;\n-\n-                // fall through so that the unintercepted _content is\n-                // considered for any remaining content, for EOF and to\n-                // succeed it if it is entirely consumed.\n-            }\n-\n-            // If the content has content or is an EOF marker, use it\n-            if (_content.hasContent() || _content instanceof SentinelContent)\n-                return _content;\n-\n-            // The content is consumed, so get the next one.  Note that EOF\n-            // content is never consumed here, but in #pollContent\n-            _content.succeeded();\n-            _content = _inputQ.poll();\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"isReady? false\");\n+            return false;\n         }\n \n-        return null;\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"isReady? true\");\n+        return true;\n     }\n \n-    private void consume(Content content)\n+    @Override\n+    public void setReadListener(ReadListener readListener)\n     {\n-        if (!isError() && content instanceof EofContent)\n-        {\n-            if (content == EARLY_EOF_CONTENT)\n-                _state = EARLY_EOF;\n-            else if (_listener == null)\n-                _state = EOF;\n-            else\n-                _state = AEOF;\n-        }\n+        if (_readListener != null)\n+            throw new IllegalStateException(\"ReadListener already set\");\n+        _readListener = Objects.requireNonNull(readListener);\n+        //illegal if async not started\n+        if (!_channelState.isAsyncStarted())\n+            throw new IllegalStateException(\"Async not started\");\n \n-        // Consume the content, either if it was original content\n-        // or if it was produced by interception\n-        content.succeeded();\n-        if (_content == content)\n-            _content = null;\n-        else if (_intercepted == content)\n-            _intercepted = null;\n+        _contentProducer = _asyncContentProducer;\n+        // trigger content production\n+        if (isReady() && _channelState.onReadEof()) // onReadEof b/c we want to transition from WAITING to WOKEN\n+            scheduleReadListenerNotification(); // this is needed by AsyncServletIOTest.testStolenAsyncRead\n     }\n \n-    /**\n-     * Copies the given content into the given byte buffer.\n-     *\n-     * @param content the content to copy from\n-     * @param buffer the buffer to copy into\n-     * @param offset the buffer offset to start copying from\n-     * @param length the space available in the buffer\n-     * @return the number of bytes actually copied\n-     */\n-    protected int get(Content content, byte[] buffer, int offset, int length)\n+    public boolean wakeup()\n     {\n-        int l = content.get(buffer, offset, length);\n-        _contentConsumed += l;\n-        return l;\n+        boolean wakeup = _contentProducer.wakeup();\n+        return wakeup;\n     }\n \n-    /**\n-     * Consumes the given content. Calls the content succeeded if all content consumed.\n-     *\n-     * @param content the content to consume\n-     * @param length the number of bytes to consume\n-     */\n-    protected void skip(Content content, int length)\n-    {\n-        int l = content.skip(length);\n-\n-        _contentConsumed += l;\n-        if (l > 0 && content.isEmpty())\n-            nextNonSentinelContent(); // hungry succeed\n-    }\n-\n-    /**\n-     * Blocks until some content or some end-of-file event arrives.\n-     *\n-     * @throws IOException if the wait is interrupted\n-     */\n-    protected void blockForContent() throws IOException\n+    @Override\n+    public int read() throws IOException\n     {\n-        assert _lock.isHeldByCurrentThread();\n-        try\n-        {\n-            _waitingForContent = true;\n-            _channelState.getHttpChannel().onBlockWaitForContent();\n-\n-            boolean loop = false;\n-            long timeout = 0;\n-            while (true)\n-            {\n-                // This method is called from a loop, so we just\n-                // need to check the timeout before and after waiting.\n-                if (loop)\n-                    break;\n-\n-                if (LOG.isDebugEnabled())\n-                    LOG.debug(\"{} blocking for content timeout={}\", this, timeout);\n-                if (timeout > 0)\n-                    _lock.await(timeout, TimeUnit.MILLISECONDS);\n-                else\n-                    _lock.await();\n-\n-                loop = true;\n-            }\n-        }\n-        catch (Throwable x)\n-        {\n-            _channelState.getHttpChannel().onBlockWaitForContentFailure(x);\n-        }\n+        int read = read(_oneByteBuffer, 0, 1);\n+        if (read == 0)\n+            throw new IOException(\"unready read=0\");\n+        return read < 0 ? -1 : _oneByteBuffer[0] & 0xFF;\n     }\n \n-    /**\n-     * Adds some content to this input stream.\n-     *\n-     * @param content the content to add\n-     * @return true if content channel woken for read\n-     */\n-    public boolean addContent(Content content)\n+    @Override\n+    public int read(byte[] b, int off, int len) throws IOException\n     {\n-        try (AutoLock l = _lock.lock())\n-        {\n-            _waitingForContent = false;\n-            if (_firstByteTimeStamp == -1)\n-                _firstByteTimeStamp = System.nanoTime();\n+        // Calculate minimum request rate for DoS protection\n+        _contentProducer.checkMinDataRate();\n \n-            if (isFinished())\n-            {\n-                Throwable failure = isError() ? _state.getError() : new EOFException(\"Content after EOF\");\n-                content.failed(failure);\n-                return false;\n-            }\n-            else\n-            {\n-                _contentArrived += content.remaining();\n-\n-                if (_content == null && _inputQ.isEmpty())\n-                    _content = content;\n-                else\n-                    _inputQ.offer(content);\n-\n-                if (LOG.isDebugEnabled())\n-                    LOG.debug(\"{} addContent {}\", this, content);\n-\n-                if (nextInterceptedContent() != null)\n-                    return wakeup();\n-                else\n-                    return false;\n-            }\n-        }\n-    }\n-\n-    public boolean hasContent()\n-    {\n-        try (AutoLock l = _lock.lock())\n+        Content content = _contentProducer.nextContent();\n+        if (content == null)\n+            throw new IllegalStateException(\"read on unready input\");\n+        if (!content.isSpecial())\n         {\n-            return _content != null || _inputQ.size() > 0;\n+            int read = content.get(b, off, len);\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"read produced {} byte(s)\", read);\n+            // Content may be null after the call to read, so it may need to be freed up.\n+            _contentProducer.reclaim(content);\n+            return read;\n         }\n-    }\n \n-    public void unblock()\n-    {\n-        try (AutoLock.WithCondition l = _lock.lock())\n+        Throwable error = content.getError();\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"read error = \" + error);\n+        if (error != null)\n         {\n-            l.signal();\n+            if (error instanceof IOException)\n+                throw (IOException)error;\n+            throw new IOException(error);\n         }\n-    }\n \n-    public long getContentConsumed()\n-    {\n-        try (AutoLock l = _lock.lock())\n+        if (content.isEof())\n         {\n-            return _contentConsumed;\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"read on EOF, switching to CONSUMED_EOF and returning\");\n+            _consumedEof = true;\n+            if (wakeup())\n+                scheduleReadListenerNotification();\n+            return -1;\n         }\n-    }\n \n-    public long getContentReceived()\n-    {\n-        synchronized (_inputQ)\n-        {\n-            return _contentArrived;\n-        }\n+        throw new AssertionError(\"no data, no error and not EOF\");\n     }\n \n-    /**\n-     * This method should be called to signal that an EOF has been detected before all the expected content arrived.\n-     * <p>\n-     * Typically this will result in an EOFException being thrown from a subsequent read rather than a -1 return.\n-     *\n-     * @return true if content channel woken for read\n-     */\n-    public boolean earlyEOF()\n+    private void scheduleReadListenerNotification()\n     {\n-        return addContent(EARLY_EOF_CONTENT);\n+        HttpChannel channel = _channelState.getHttpChannel();\n+        channel.execute(channel);\n     }\n \n     /**\n-     * This method should be called to signal that all the expected content arrived.\n-     *\n-     * @return true if content channel woken for read\n+     * Check if this HttpInput instance has content stored internally, without fetching/parsing\n+     * anything from the underlying channel.\n+     * @return true if the input contains content, false otherwise.\n      */\n-    public boolean eof()\n-    {\n-        return addContent(EOF_CONTENT);\n-    }\n-\n-    public boolean consumeAll()\n-    {\n-        try (AutoLock l = _lock.lock())\n-        {\n-            try\n-            {\n-                while (true)\n-                {\n-                    Content item = nextContent();\n-                    if (item == null)\n-                        break; // Let's not bother blocking\n-\n-                    skip(item, item.remaining());\n-                }\n-                if (isFinished())\n-                    return !isError();\n-\n-                _state = EARLY_EOF;\n-                return false;\n-            }\n-            catch (Throwable e)\n-            {\n-                if (LOG.isDebugEnabled())\n-                    LOG.debug(\"Unable to consume all input\", e);\n-                _state = new ErrorState(e);\n-                return false;\n-            }\n-        }\n-    }\n-\n-    public boolean isError()\n-    {\n-        try (AutoLock l = _lock.lock())\n-        {\n-            return _state instanceof ErrorState;\n-        }\n-    }\n-\n-    public boolean isAsync()\n-    {\n-        try (AutoLock l = _lock.lock())\n-        {\n-            return _state == ASYNC;\n-        }\n-    }\n-\n-    @Override\n-    public boolean isFinished()\n-    {\n-        try (AutoLock l = _lock.lock())\n-        {\n-            return _state instanceof EOFState;\n-        }\n-    }\n-\n-    @Override\n-    public boolean isReady()\n+    public boolean hasContent()", "originalCommit": "273213e8df4f438bf853787ec932e22424e7fe8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM5MjE4Mg==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r509392182", "bodyText": "In my mind peek recalls the queue semantic which this method doesn't resemble.", "author": "lorban", "createdAt": "2020-10-21T15:36:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQxMDgxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQxMjI1MA==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505412250", "bodyText": "Don't mention test failures -- just why available() cannot be called.\nEven though available() should be an idempotent method without side effects -- why can't be used here?", "author": "sbordet", "createdAt": "2020-10-15T09:52:05Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpInput.java", "diffHunk": "@@ -192,648 +83,183 @@ public Interceptor getInterceptor()\n      */\n     public void setInterceptor(Interceptor interceptor)\n     {\n-        _interceptor = interceptor;\n+        _contentProducer.setInterceptor(interceptor);\n     }\n \n     /**\n-     * Set the {@link Interceptor}, using a {@link ChainedInterceptor} if\n+     * Set the {@link Interceptor}, chaining it to the existing one if\n      * an {@link Interceptor} is already set.\n      *\n      * @param interceptor the next {@link Interceptor} in a chain\n      */\n     public void addInterceptor(Interceptor interceptor)\n     {\n-        if (_interceptor == null)\n-            _interceptor = interceptor;\n+        Interceptor currentInterceptor = _contentProducer.getInterceptor();\n+        if (currentInterceptor == null)\n+            _contentProducer.setInterceptor(interceptor);\n         else\n-            _interceptor = new ChainedInterceptor(_interceptor, interceptor);\n+            _contentProducer.setInterceptor(new ChainedInterceptor(currentInterceptor, interceptor));\n     }\n \n-    @Override\n-    public int available()\n-    {\n-        int available = 0;\n-        boolean woken = false;\n-        try (AutoLock l = _lock.lock())\n-        {\n-            if (_content == null)\n-                _content = _inputQ.poll();\n-            if (_content == null)\n-            {\n-                try\n-                {\n-                    produceContent();\n-                }\n-                catch (IOException e)\n-                {\n-                    woken = failed(e);\n-                }\n-                if (_content == null)\n-                    _content = _inputQ.poll();\n-            }\n-\n-            if (_content != null)\n-                available = _content.remaining();\n-        }\n-\n-        if (woken)\n-            wake();\n-        return available;\n-    }\n-\n-    protected void wake()\n-    {\n-        HttpChannel channel = _channelState.getHttpChannel();\n-        Executor executor = channel.getConnector().getServer().getThreadPool();\n-        executor.execute(channel);\n-    }\n-\n-    @Override\n-    public int read() throws IOException\n+    public long getContentReceived()\n     {\n-        int read = read(_oneByteBuffer, 0, 1);\n-        if (read == 0)\n-            throw new IllegalStateException(\"unready read=0\");\n-        return read < 0 ? -1 : _oneByteBuffer[0] & 0xFF;\n+        return _contentProducer.getRawContentArrived();\n     }\n \n-    @Override\n-    public int read(byte[] b, int off, int len) throws IOException\n+    public boolean consumeAll()\n     {\n-        boolean wake = false;\n-        int read;\n-        try (AutoLock l = _lock.lock())\n-        {\n-            // Calculate minimum request rate for DOS protection\n-            long minRequestDataRate = _channelState.getHttpChannel().getHttpConfiguration().getMinRequestDataRate();\n-            if (minRequestDataRate > 0 && _firstByteTimeStamp != -1)\n-            {\n-                long period = System.nanoTime() - _firstByteTimeStamp;\n-                if (period > 0)\n-                {\n-                    long minimumData = minRequestDataRate * TimeUnit.NANOSECONDS.toMillis(period) / TimeUnit.SECONDS.toMillis(1);\n-                    if (_contentArrived < minimumData)\n-                    {\n-                        BadMessageException bad = new BadMessageException(HttpStatus.REQUEST_TIMEOUT_408,\n-                            String.format(\"Request content data rate < %d B/s\", minRequestDataRate));\n-                        if (_channelState.isResponseCommitted())\n-                            _channelState.getHttpChannel().abort(bad);\n-                        throw bad;\n-                    }\n-                }\n-            }\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"consume all\");\n+        boolean atEof = _contentProducer.consumeAll(new IOException(\"Unconsumed content\"));\n+        if (atEof)\n+            _consumedEof = true;\n \n-            // Consume content looking for bytes to read\n-            while (true)\n-            {\n-                Content item = nextContent();\n-                if (item != null)\n-                {\n-                    read = get(item, b, off, len);\n-                    if (LOG.isDebugEnabled())\n-                        LOG.debug(\"{} read {} from {}\", this, read, item);\n-\n-                    // Consume any following poison pills\n-                    if (item.isEmpty())\n-                        nextInterceptedContent();\n-                    break;\n-                }\n-\n-                // No content, so should we block?\n-                if (!_state.blockForContent(this))\n-                {\n-                    // Not blocking, so what should we return?\n-                    read = _state.noContent();\n-\n-                    if (read < 0)\n-                        // If EOF do we need to wake for allDataRead callback?\n-                        wake = _channelState.onReadEof();\n-                    break;\n-                }\n-            }\n-        }\n-\n-        if (wake)\n-            wake();\n-        return read;\n-    }\n+        if (isFinished())\n+            return !isError();\n \n-    /**\n-     * Called when derived implementations should attempt to produce more Content and add it via {@link #addContent(Content)}. For protocols that are constantly\n-     * producing (eg HTTP2) this can be left as a noop;\n-     *\n-     * @throws IOException if unable to produce content\n-     */\n-    protected void produceContent() throws IOException\n-    {\n+        // Modifying the state here to anything other than IDLE makes\n+        // ServerTimeoutsTest.testAsyncReadWithDelayedFirstContentWithDelayedDispatchIdleTimeoutFires H2C fail.\n+        return false;\n     }\n \n-    /**\n-     * Called by channel when asynchronous IO needs to produce more content\n-     *\n-     * @throws IOException if unable to produce content\n-     */\n-    public void asyncReadProduce() throws IOException\n+    public boolean isError()\n     {\n-        try (AutoLock l = _lock.lock())\n-        {\n-            produceContent();\n-        }\n+        return _contentProducer.isError();\n     }\n \n-    /**\n-     * Get the next content from the inputQ, calling {@link #produceContent()} if need be. EOF is processed and state changed.\n-     *\n-     * @return the content or null if none available.\n-     * @throws IOException if retrieving the content fails\n-     */\n-    protected Content nextContent() throws IOException\n+    public boolean isAsync()\n     {\n-        Content content = nextNonSentinelContent();\n-        if (content == null && !isFinished())\n-        {\n-            produceContent();\n-            content = nextNonSentinelContent();\n-        }\n-        return content;\n+        return _readListener != null;\n     }\n \n-    /**\n-     * Poll the inputQ for Content. Consumed buffers and {@link SentinelContent}s are removed and EOF state updated if need be.\n-     *\n-     * @return Content or null\n-     */\n-    protected Content nextNonSentinelContent()\n-    {\n-        while (true)\n-        {\n-            // Get the next content (or EOF)\n-            Content content = nextInterceptedContent();\n-\n-            // If it is EOF, consume it here\n-            if (content instanceof SentinelContent)\n-            {\n-                // Consume the EOF content, either if it was original content\n-                // or if it was produced by interception\n-                consume(content);\n-                continue;\n-            }\n+    /* ServletInputStream */\n \n-            return content;\n-        }\n-    }\n-\n-    /**\n-     * Get the next readable from the inputQ, calling {@link #produceContent()} if need be. EOF is NOT processed and state is not changed.\n-     *\n-     * @return the content or EOF or null if none available.\n-     * @throws IOException if retrieving the content fails\n-     */\n-    protected Content produceNextContext() throws IOException\n+    @Override\n+    public boolean isFinished()\n     {\n-        Content content = nextInterceptedContent();\n-        if (content == null && !isFinished())\n-        {\n-            produceContent();\n-            content = nextInterceptedContent();\n-        }\n-        return content;\n+        boolean finished = _consumedEof;\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"isFinished? {}\", finished);\n+        return finished;\n     }\n \n-    /**\n-     * Poll the inputQ for Content or EOF. Consumed buffers and non EOF {@link SentinelContent}s are removed. EOF state is not updated.\n-     * Interception is done within this method.\n-     *\n-     * @return Content with remaining, a {@link SentinelContent},  or null\n-     */\n-    protected Content nextInterceptedContent()\n+    @Override\n+    public boolean isReady()\n     {\n-        // If we have a chunk produced by interception\n-        if (_intercepted != null)\n+        boolean ready = _contentProducer.isReady();\n+        if (!ready)\n         {\n-            // Use it if it has any remaining content\n-            if (_intercepted.hasContent())\n-                return _intercepted;\n-\n-            // succeed the chunk\n-            _intercepted.succeeded();\n-            _intercepted = null;\n-        }\n-\n-        // If we don't have a Content under consideration, get\n-        // the next one off the input Q.\n-        if (_content == null)\n-            _content = _inputQ.poll();\n-\n-        // While we have content to consider.\n-        while (_content != null)\n-        {\n-            // Are we intercepting?\n-            if (_interceptor != null)\n-            {\n-                // Intercept the current content (may be called several\n-                // times for the same content\n-                _intercepted = _interceptor.readFrom(_content);\n-\n-                // If interception produced new content\n-                if (_intercepted != null && _intercepted != _content)\n-                {\n-                    // if it is not empty use it\n-                    if (_intercepted.hasContent())\n-                        return _intercepted;\n-                    _intercepted.succeeded();\n-                }\n-\n-                // intercepted content consumed\n-                _intercepted = null;\n-\n-                // fall through so that the unintercepted _content is\n-                // considered for any remaining content, for EOF and to\n-                // succeed it if it is entirely consumed.\n-            }\n-\n-            // If the content has content or is an EOF marker, use it\n-            if (_content.hasContent() || _content instanceof SentinelContent)\n-                return _content;\n-\n-            // The content is consumed, so get the next one.  Note that EOF\n-            // content is never consumed here, but in #pollContent\n-            _content.succeeded();\n-            _content = _inputQ.poll();\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"isReady? false\");\n+            return false;\n         }\n \n-        return null;\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"isReady? true\");\n+        return true;\n     }\n \n-    private void consume(Content content)\n+    @Override\n+    public void setReadListener(ReadListener readListener)\n     {\n-        if (!isError() && content instanceof EofContent)\n-        {\n-            if (content == EARLY_EOF_CONTENT)\n-                _state = EARLY_EOF;\n-            else if (_listener == null)\n-                _state = EOF;\n-            else\n-                _state = AEOF;\n-        }\n+        if (_readListener != null)\n+            throw new IllegalStateException(\"ReadListener already set\");\n+        _readListener = Objects.requireNonNull(readListener);\n+        //illegal if async not started\n+        if (!_channelState.isAsyncStarted())\n+            throw new IllegalStateException(\"Async not started\");\n \n-        // Consume the content, either if it was original content\n-        // or if it was produced by interception\n-        content.succeeded();\n-        if (_content == content)\n-            _content = null;\n-        else if (_intercepted == content)\n-            _intercepted = null;\n+        _contentProducer = _asyncContentProducer;\n+        // trigger content production\n+        if (isReady() && _channelState.onReadEof()) // onReadEof b/c we want to transition from WAITING to WOKEN\n+            scheduleReadListenerNotification(); // this is needed by AsyncServletIOTest.testStolenAsyncRead\n     }\n \n-    /**\n-     * Copies the given content into the given byte buffer.\n-     *\n-     * @param content the content to copy from\n-     * @param buffer the buffer to copy into\n-     * @param offset the buffer offset to start copying from\n-     * @param length the space available in the buffer\n-     * @return the number of bytes actually copied\n-     */\n-    protected int get(Content content, byte[] buffer, int offset, int length)\n+    public boolean wakeup()\n     {\n-        int l = content.get(buffer, offset, length);\n-        _contentConsumed += l;\n-        return l;\n+        boolean wakeup = _contentProducer.wakeup();\n+        return wakeup;\n     }\n \n-    /**\n-     * Consumes the given content. Calls the content succeeded if all content consumed.\n-     *\n-     * @param content the content to consume\n-     * @param length the number of bytes to consume\n-     */\n-    protected void skip(Content content, int length)\n-    {\n-        int l = content.skip(length);\n-\n-        _contentConsumed += l;\n-        if (l > 0 && content.isEmpty())\n-            nextNonSentinelContent(); // hungry succeed\n-    }\n-\n-    /**\n-     * Blocks until some content or some end-of-file event arrives.\n-     *\n-     * @throws IOException if the wait is interrupted\n-     */\n-    protected void blockForContent() throws IOException\n+    @Override\n+    public int read() throws IOException\n     {\n-        assert _lock.isHeldByCurrentThread();\n-        try\n-        {\n-            _waitingForContent = true;\n-            _channelState.getHttpChannel().onBlockWaitForContent();\n-\n-            boolean loop = false;\n-            long timeout = 0;\n-            while (true)\n-            {\n-                // This method is called from a loop, so we just\n-                // need to check the timeout before and after waiting.\n-                if (loop)\n-                    break;\n-\n-                if (LOG.isDebugEnabled())\n-                    LOG.debug(\"{} blocking for content timeout={}\", this, timeout);\n-                if (timeout > 0)\n-                    _lock.await(timeout, TimeUnit.MILLISECONDS);\n-                else\n-                    _lock.await();\n-\n-                loop = true;\n-            }\n-        }\n-        catch (Throwable x)\n-        {\n-            _channelState.getHttpChannel().onBlockWaitForContentFailure(x);\n-        }\n+        int read = read(_oneByteBuffer, 0, 1);\n+        if (read == 0)\n+            throw new IOException(\"unready read=0\");\n+        return read < 0 ? -1 : _oneByteBuffer[0] & 0xFF;\n     }\n \n-    /**\n-     * Adds some content to this input stream.\n-     *\n-     * @param content the content to add\n-     * @return true if content channel woken for read\n-     */\n-    public boolean addContent(Content content)\n+    @Override\n+    public int read(byte[] b, int off, int len) throws IOException\n     {\n-        try (AutoLock l = _lock.lock())\n-        {\n-            _waitingForContent = false;\n-            if (_firstByteTimeStamp == -1)\n-                _firstByteTimeStamp = System.nanoTime();\n+        // Calculate minimum request rate for DoS protection\n+        _contentProducer.checkMinDataRate();\n \n-            if (isFinished())\n-            {\n-                Throwable failure = isError() ? _state.getError() : new EOFException(\"Content after EOF\");\n-                content.failed(failure);\n-                return false;\n-            }\n-            else\n-            {\n-                _contentArrived += content.remaining();\n-\n-                if (_content == null && _inputQ.isEmpty())\n-                    _content = content;\n-                else\n-                    _inputQ.offer(content);\n-\n-                if (LOG.isDebugEnabled())\n-                    LOG.debug(\"{} addContent {}\", this, content);\n-\n-                if (nextInterceptedContent() != null)\n-                    return wakeup();\n-                else\n-                    return false;\n-            }\n-        }\n-    }\n-\n-    public boolean hasContent()\n-    {\n-        try (AutoLock l = _lock.lock())\n+        Content content = _contentProducer.nextContent();\n+        if (content == null)\n+            throw new IllegalStateException(\"read on unready input\");\n+        if (!content.isSpecial())\n         {\n-            return _content != null || _inputQ.size() > 0;\n+            int read = content.get(b, off, len);\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"read produced {} byte(s)\", read);\n+            // Content may be null after the call to read, so it may need to be freed up.\n+            _contentProducer.reclaim(content);\n+            return read;\n         }\n-    }\n \n-    public void unblock()\n-    {\n-        try (AutoLock.WithCondition l = _lock.lock())\n+        Throwable error = content.getError();\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"read error = \" + error);\n+        if (error != null)\n         {\n-            l.signal();\n+            if (error instanceof IOException)\n+                throw (IOException)error;\n+            throw new IOException(error);\n         }\n-    }\n \n-    public long getContentConsumed()\n-    {\n-        try (AutoLock l = _lock.lock())\n+        if (content.isEof())\n         {\n-            return _contentConsumed;\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"read on EOF, switching to CONSUMED_EOF and returning\");\n+            _consumedEof = true;\n+            if (wakeup())\n+                scheduleReadListenerNotification();\n+            return -1;\n         }\n-    }\n \n-    public long getContentReceived()\n-    {\n-        synchronized (_inputQ)\n-        {\n-            return _contentArrived;\n-        }\n+        throw new AssertionError(\"no data, no error and not EOF\");\n     }\n \n-    /**\n-     * This method should be called to signal that an EOF has been detected before all the expected content arrived.\n-     * <p>\n-     * Typically this will result in an EOFException being thrown from a subsequent read rather than a -1 return.\n-     *\n-     * @return true if content channel woken for read\n-     */\n-    public boolean earlyEOF()\n+    private void scheduleReadListenerNotification()\n     {\n-        return addContent(EARLY_EOF_CONTENT);\n+        HttpChannel channel = _channelState.getHttpChannel();\n+        channel.execute(channel);\n     }\n \n     /**\n-     * This method should be called to signal that all the expected content arrived.\n-     *\n-     * @return true if content channel woken for read\n+     * Check if this HttpInput instance has content stored internally, without fetching/parsing\n+     * anything from the underlying channel.\n+     * @return true if the input contains content, false otherwise.\n      */\n-    public boolean eof()\n-    {\n-        return addContent(EOF_CONTENT);\n-    }\n-\n-    public boolean consumeAll()\n-    {\n-        try (AutoLock l = _lock.lock())\n-        {\n-            try\n-            {\n-                while (true)\n-                {\n-                    Content item = nextContent();\n-                    if (item == null)\n-                        break; // Let's not bother blocking\n-\n-                    skip(item, item.remaining());\n-                }\n-                if (isFinished())\n-                    return !isError();\n-\n-                _state = EARLY_EOF;\n-                return false;\n-            }\n-            catch (Throwable e)\n-            {\n-                if (LOG.isDebugEnabled())\n-                    LOG.debug(\"Unable to consume all input\", e);\n-                _state = new ErrorState(e);\n-                return false;\n-            }\n-        }\n-    }\n-\n-    public boolean isError()\n-    {\n-        try (AutoLock l = _lock.lock())\n-        {\n-            return _state instanceof ErrorState;\n-        }\n-    }\n-\n-    public boolean isAsync()\n-    {\n-        try (AutoLock l = _lock.lock())\n-        {\n-            return _state == ASYNC;\n-        }\n-    }\n-\n-    @Override\n-    public boolean isFinished()\n-    {\n-        try (AutoLock l = _lock.lock())\n-        {\n-            return _state instanceof EOFState;\n-        }\n-    }\n-\n-    @Override\n-    public boolean isReady()\n+    public boolean hasContent()\n     {\n-        try\n-        {\n-            try (AutoLock l = _lock.lock())\n-            {\n-                if (_listener == null)\n-                    return true;\n-                if (_state instanceof EOFState)\n-                    return true;\n-                if (_waitingForContent)\n-                    return false;\n-                if (produceNextContext() != null)\n-                    return true;\n-                _channelState.onReadUnready();\n-                _waitingForContent = true;\n-            }\n-            return false;\n-        }\n-        catch (IOException e)\n-        {\n-            LOG.trace(\"IGNORED\", e);\n-            return true;\n-        }\n+        // Cannot call _contentProducer.available() (which calls HttpChannel.produceContent())\n+        // as this breaks WebSocketOverHTTP2Test.testSlowWebSocketUpgradeWithHTTP2DataFramesQueued.\n+        return _contentProducer.hasContent();", "originalCommit": "273213e8df4f438bf853787ec932e22424e7fe8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM5NDM3Nw==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r509394377", "bodyText": "That's another brain-dump comment. Let me clarify it.", "author": "lorban", "createdAt": "2020-10-21T15:39:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQxMjI1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQxNTIwMg==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505415202", "bodyText": "Remove comment.", "author": "sbordet", "createdAt": "2020-10-15T09:56:09Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpInput.java", "diffHunk": "@@ -842,144 +268,122 @@ private boolean wakeup()\n     @Override\n     public void run()\n     {\n-        final ReadListener listener;\n-        Throwable error;\n-        boolean aeof = false;\n+        Content content = _contentProducer.nextContent();\n+        // The nextContent() call could return null if the transformer ate all\n+        // the raw bytes without producing any transformed content.\n+        if (content == null)\n+            return; // testAsyncEcho HTTP2 requires this", "originalCommit": "273213e8df4f438bf853787ec932e22424e7fe8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM5NjA5MQ==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r509396091", "bodyText": "Done.", "author": "lorban", "createdAt": "2020-10-21T15:41:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQxNTIwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQxNTcyNA==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505415724", "bodyText": "Another case of \"eof\" implies \"special\"?", "author": "sbordet", "createdAt": "2020-10-15T09:56:53Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpInput.java", "diffHunk": "@@ -842,144 +268,122 @@ private boolean wakeup()\n     @Override\n     public void run()\n     {\n-        final ReadListener listener;\n-        Throwable error;\n-        boolean aeof = false;\n+        Content content = _contentProducer.nextContent();\n+        // The nextContent() call could return null if the transformer ate all\n+        // the raw bytes without producing any transformed content.\n+        if (content == null)\n+            return; // testAsyncEcho HTTP2 requires this\n \n-        try (AutoLock l = _lock.lock())\n+        // required for AsyncRequestReadTest.testAsyncReadsWithDelays()\n+        if (_readListener == null)\n         {\n-            listener = _listener;\n-\n-            if (_state == EOF)\n-                return;\n-\n-            if (_state == AEOF)\n-            {\n-                _state = EOF;\n-                aeof = true;\n-            }\n-\n-            error = _state.getError();\n-\n-            if (!aeof && error == null)\n-            {\n-                Content content = nextInterceptedContent();\n-                if (content == null)\n-                    return;\n-\n-                // Consume a directly received EOF without first calling onDataAvailable\n-                // So -1 will never be read and only onAddDataRread or onError will be called\n-                if (content instanceof EofContent)\n-                {\n-                    consume(content);\n-                    if (_state == EARLY_EOF)\n-                        error = _state.getError();\n-                    else if (_state == AEOF)\n-                    {\n-                        aeof = true;\n-                        _state = EOF;\n-                    }\n-                }\n-            }\n+            wakeup();\n+            return;\n         }\n \n-        try\n+        if (content.isSpecial())\n         {\n+            Throwable error = content.getError();\n             if (error != null)\n             {\n                 // TODO is this necessary to add here?\n                 _channelState.getHttpChannel().getResponse().getHttpFields().add(HttpConnection.CONNECTION_CLOSE);\n-                listener.onError(error);\n-            }\n-            else if (aeof)\n-            {\n-                listener.onAllDataRead();\n+                _readListener.onError(error);\n             }\n-            else\n+            else if (content.isEof())", "originalCommit": "273213e8df4f438bf853787ec932e22424e7fe8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM5NjMxMg==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r509396312", "bodyText": "Yes.", "author": "lorban", "createdAt": "2020-10-21T15:41:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQxNTcyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQxOTYxNw==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505419617", "bodyText": "Please make it public due to JPMS, JUnit, etc.", "author": "sbordet", "createdAt": "2020-10-15T10:02:35Z", "path": "jetty-server/src/test/java/org/eclipse/jetty/server/AsyncContentProducerTest.java", "diffHunk": "@@ -0,0 +1,339 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.BrokenBarrierException;\n+import java.util.concurrent.CyclicBarrier;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.zip.GZIPOutputStream;\n+\n+import org.eclipse.jetty.io.ArrayByteBufferPool;\n+import org.eclipse.jetty.io.EofException;\n+import org.eclipse.jetty.server.handler.gzip.GzipHttpInputInterceptor;\n+import org.eclipse.jetty.util.compression.CompressionPool;\n+import org.eclipse.jetty.util.compression.InflaterPool;\n+import org.hamcrest.core.Is;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.notNullValue;\n+import static org.hamcrest.Matchers.nullValue;\n+\n+public class AsyncContentProducerTest\n+{\n+    private ScheduledExecutorService scheduledExecutorService;\n+    private InflaterPool inflaterPool;\n+\n+    @BeforeEach\n+    void setUp()", "originalCommit": "273213e8df4f438bf853787ec932e22424e7fe8b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQxOTY4Ng==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505419686", "bodyText": "Make it public.", "author": "sbordet", "createdAt": "2020-10-15T10:02:45Z", "path": "jetty-server/src/test/java/org/eclipse/jetty/server/AsyncContentProducerTest.java", "diffHunk": "@@ -0,0 +1,339 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.BrokenBarrierException;\n+import java.util.concurrent.CyclicBarrier;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.zip.GZIPOutputStream;\n+\n+import org.eclipse.jetty.io.ArrayByteBufferPool;\n+import org.eclipse.jetty.io.EofException;\n+import org.eclipse.jetty.server.handler.gzip.GzipHttpInputInterceptor;\n+import org.eclipse.jetty.util.compression.CompressionPool;\n+import org.eclipse.jetty.util.compression.InflaterPool;\n+import org.hamcrest.core.Is;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.notNullValue;\n+import static org.hamcrest.Matchers.nullValue;\n+\n+public class AsyncContentProducerTest\n+{\n+    private ScheduledExecutorService scheduledExecutorService;\n+    private InflaterPool inflaterPool;\n+\n+    @BeforeEach\n+    void setUp()\n+    {\n+        scheduledExecutorService = Executors.newSingleThreadScheduledExecutor();\n+        inflaterPool = new InflaterPool(CompressionPool.INFINITE_CAPACITY, true);\n+    }\n+\n+    @AfterEach\n+    void tearDown()", "originalCommit": "273213e8df4f438bf853787ec932e22424e7fe8b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQyMTMwMg==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505421302", "bodyText": "Another case of \"eof\" implies \"special\"?", "author": "sbordet", "createdAt": "2020-10-15T10:05:25Z", "path": "jetty-server/src/test/java/org/eclipse/jetty/server/AsyncContentProducerTest.java", "diffHunk": "@@ -0,0 +1,339 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.BrokenBarrierException;\n+import java.util.concurrent.CyclicBarrier;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.zip.GZIPOutputStream;\n+\n+import org.eclipse.jetty.io.ArrayByteBufferPool;\n+import org.eclipse.jetty.io.EofException;\n+import org.eclipse.jetty.server.handler.gzip.GzipHttpInputInterceptor;\n+import org.eclipse.jetty.util.compression.CompressionPool;\n+import org.eclipse.jetty.util.compression.InflaterPool;\n+import org.hamcrest.core.Is;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.notNullValue;\n+import static org.hamcrest.Matchers.nullValue;\n+\n+public class AsyncContentProducerTest\n+{\n+    private ScheduledExecutorService scheduledExecutorService;\n+    private InflaterPool inflaterPool;\n+\n+    @BeforeEach\n+    void setUp()\n+    {\n+        scheduledExecutorService = Executors.newSingleThreadScheduledExecutor();\n+        inflaterPool = new InflaterPool(CompressionPool.INFINITE_CAPACITY, true);\n+    }\n+\n+    @AfterEach\n+    void tearDown()\n+    {\n+        scheduledExecutorService.shutdownNow();\n+    }\n+\n+    @Test\n+    public void testAsyncContentProducerNoInterceptor() throws Exception\n+    {\n+        ByteBuffer[] buffers = new ByteBuffer[3];\n+        buffers[0] = ByteBuffer.wrap(\"1 hello 1\".getBytes(StandardCharsets.ISO_8859_1));\n+        buffers[1] = ByteBuffer.wrap(\"2 howdy 2\".getBytes(StandardCharsets.ISO_8859_1));\n+        buffers[2] = ByteBuffer.wrap(\"3 hey ya 3\".getBytes(StandardCharsets.ISO_8859_1));\n+        final int totalContentBytesCount = countRemaining(buffers);\n+        final String originalContentString = asString(buffers);\n+\n+        CyclicBarrier barrier = new CyclicBarrier(2);\n+\n+        ContentProducer contentProducer = new AsyncContentProducer(new ArrayDelayedHttpChannel(buffers, new HttpInput.EofContent(), scheduledExecutorService, barrier));\n+\n+        Throwable error = readAndAssertContent(totalContentBytesCount, originalContentString, contentProducer, (buffers.length + 1) * 2, 0, 4, barrier);\n+        assertThat(error, nullValue());\n+    }\n+\n+    @Test\n+    public void testAsyncContentProducerNoInterceptorWithError() throws Exception\n+    {\n+        ByteBuffer[] buffers = new ByteBuffer[3];\n+        buffers[0] = ByteBuffer.wrap(\"1 hello 1\".getBytes(StandardCharsets.ISO_8859_1));\n+        buffers[1] = ByteBuffer.wrap(\"2 howdy 2\".getBytes(StandardCharsets.ISO_8859_1));\n+        buffers[2] = ByteBuffer.wrap(\"3 hey ya 3\".getBytes(StandardCharsets.ISO_8859_1));\n+        final int totalContentBytesCount = countRemaining(buffers);\n+        final String originalContentString = asString(buffers);\n+        final Throwable expectedError = new EofException(\"Early EOF\");\n+\n+        CyclicBarrier barrier = new CyclicBarrier(2);\n+\n+        ContentProducer contentProducer = new AsyncContentProducer(new ArrayDelayedHttpChannel(buffers, new HttpInput.ErrorContent(expectedError), scheduledExecutorService, barrier));\n+\n+        Throwable error = readAndAssertContent(totalContentBytesCount, originalContentString, contentProducer, (buffers.length + 1) * 2, 0, 4, barrier);\n+        assertThat(error, Is.is(expectedError));\n+    }\n+\n+    @Test\n+    public void testAsyncContentProducerGzipInterceptor() throws Exception\n+    {\n+        ByteBuffer[] uncompressedBuffers = new ByteBuffer[3];\n+        uncompressedBuffers[0] = ByteBuffer.wrap(\"1 hello 1\".getBytes(StandardCharsets.ISO_8859_1));\n+        uncompressedBuffers[1] = ByteBuffer.wrap(\"2 howdy 2\".getBytes(StandardCharsets.ISO_8859_1));\n+        uncompressedBuffers[2] = ByteBuffer.wrap(\"3 hey ya 3\".getBytes(StandardCharsets.ISO_8859_1));\n+        final int totalContentBytesCount = countRemaining(uncompressedBuffers);\n+        final String originalContentString = asString(uncompressedBuffers);\n+\n+        ByteBuffer[] buffers = new ByteBuffer[3];\n+        buffers[0] = gzipByteBuffer(uncompressedBuffers[0]);\n+        buffers[1] = gzipByteBuffer(uncompressedBuffers[1]);\n+        buffers[2] = gzipByteBuffer(uncompressedBuffers[2]);\n+\n+        CyclicBarrier barrier = new CyclicBarrier(2);\n+\n+        ContentProducer contentProducer = new AsyncContentProducer(new ArrayDelayedHttpChannel(buffers, new HttpInput.EofContent(), scheduledExecutorService, barrier));\n+        contentProducer.setInterceptor(new GzipHttpInputInterceptor(inflaterPool, new ArrayByteBufferPool(1, 1, 2), 32));\n+\n+        Throwable error = readAndAssertContent(totalContentBytesCount, originalContentString, contentProducer, (buffers.length + 1) * 2, 0, 4, barrier);\n+        assertThat(error, nullValue());\n+    }\n+\n+    @Test\n+    public void testAsyncContentProducerGzipInterceptorWithTinyBuffers() throws Exception\n+    {\n+        ByteBuffer[] uncompressedBuffers = new ByteBuffer[3];\n+        uncompressedBuffers[0] = ByteBuffer.wrap(\"1 hello 1\".getBytes(StandardCharsets.ISO_8859_1));\n+        uncompressedBuffers[1] = ByteBuffer.wrap(\"2 howdy 2\".getBytes(StandardCharsets.ISO_8859_1));\n+        uncompressedBuffers[2] = ByteBuffer.wrap(\"3 hey ya 3\".getBytes(StandardCharsets.ISO_8859_1));\n+        final int totalContentBytesCount = countRemaining(uncompressedBuffers);\n+        final String originalContentString = asString(uncompressedBuffers);\n+\n+        ByteBuffer[] buffers = new ByteBuffer[3];\n+        buffers[0] = gzipByteBuffer(uncompressedBuffers[0]);\n+        buffers[1] = gzipByteBuffer(uncompressedBuffers[1]);\n+        buffers[2] = gzipByteBuffer(uncompressedBuffers[2]);\n+\n+        CyclicBarrier barrier = new CyclicBarrier(2);\n+\n+        ContentProducer contentProducer = new AsyncContentProducer(new ArrayDelayedHttpChannel(buffers, new HttpInput.EofContent(), scheduledExecutorService, barrier));\n+        contentProducer.setInterceptor(new GzipHttpInputInterceptor(inflaterPool, new ArrayByteBufferPool(1, 1, 2), 1));\n+\n+        Throwable error = readAndAssertContent(totalContentBytesCount, originalContentString, contentProducer, totalContentBytesCount + buffers.length + 2, 25, 4, barrier);\n+        assertThat(error, nullValue());\n+    }\n+\n+    @Test\n+    public void testBlockingContentProducerGzipInterceptorWithError() throws Exception\n+    {\n+        ByteBuffer[] uncompressedBuffers = new ByteBuffer[3];\n+        uncompressedBuffers[0] = ByteBuffer.wrap(\"1 hello 1\".getBytes(StandardCharsets.ISO_8859_1));\n+        uncompressedBuffers[1] = ByteBuffer.wrap(\"2 howdy 2\".getBytes(StandardCharsets.ISO_8859_1));\n+        uncompressedBuffers[2] = ByteBuffer.wrap(\"3 hey ya 3\".getBytes(StandardCharsets.ISO_8859_1));\n+        final int totalContentBytesCount = countRemaining(uncompressedBuffers);\n+        final String originalContentString = asString(uncompressedBuffers);\n+        final Throwable expectedError = new Throwable(\"HttpInput idle timeout\");\n+\n+        ByteBuffer[] buffers = new ByteBuffer[3];\n+        buffers[0] = gzipByteBuffer(uncompressedBuffers[0]);\n+        buffers[1] = gzipByteBuffer(uncompressedBuffers[1]);\n+        buffers[2] = gzipByteBuffer(uncompressedBuffers[2]);\n+\n+        CyclicBarrier barrier = new CyclicBarrier(2);\n+\n+        ContentProducer contentProducer = new AsyncContentProducer(new ArrayDelayedHttpChannel(buffers, new HttpInput.ErrorContent(expectedError), scheduledExecutorService, barrier));\n+        contentProducer.setInterceptor(new GzipHttpInputInterceptor(inflaterPool, new ArrayByteBufferPool(1, 1, 2), 32));\n+\n+        Throwable error = readAndAssertContent(totalContentBytesCount, originalContentString, contentProducer, (buffers.length + 1) * 2, 0, 4, barrier);\n+        assertThat(error, Is.is(expectedError));\n+    }\n+\n+    private Throwable readAndAssertContent(int totalContentBytesCount, String originalContentString, ContentProducer contentProducer, int totalContentCount, int readyCount, int notReadyCount, CyclicBarrier barrier) throws InterruptedException, BrokenBarrierException, TimeoutException\n+    {\n+        int readBytes = 0;\n+        String consumedString = \"\";\n+        int nextContentCount = 0;\n+        int isReadyFalseCount = 0;\n+        int isReadyTrueCount = 0;\n+        Throwable error = null;\n+\n+        while (true)\n+        {\n+            if (contentProducer.isReady())\n+                isReadyTrueCount++;\n+            else\n+                isReadyFalseCount++;\n+\n+            HttpInput.Content content = contentProducer.nextContent();\n+            nextContentCount++;\n+            if (content == null)\n+            {\n+                barrier.await(5, TimeUnit.SECONDS);\n+                content = contentProducer.nextContent();\n+                nextContentCount++;\n+            }\n+            assertThat(content, notNullValue());\n+\n+            if (content.isSpecial())\n+            {\n+                if (content.isEof())", "originalCommit": "273213e8df4f438bf853787ec932e22424e7fe8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM5NzEzNA==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r509397134", "bodyText": "Yes.", "author": "lorban", "createdAt": "2020-10-21T15:42:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQyMTMwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQyMjQ2NQ==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505422465", "bodyText": "Make it public.", "author": "sbordet", "createdAt": "2020-10-15T10:07:29Z", "path": "jetty-server/src/test/java/org/eclipse/jetty/server/BlockingContentProducerTest.java", "diffHunk": "@@ -0,0 +1,320 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.zip.GZIPOutputStream;\n+\n+import org.eclipse.jetty.io.ArrayByteBufferPool;\n+import org.eclipse.jetty.io.EofException;\n+import org.eclipse.jetty.server.handler.gzip.GzipHttpInputInterceptor;\n+import org.eclipse.jetty.util.compression.CompressionPool;\n+import org.eclipse.jetty.util.compression.InflaterPool;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.nullValue;\n+import static org.hamcrest.core.Is.is;\n+\n+public class BlockingContentProducerTest\n+{\n+    private ScheduledExecutorService scheduledExecutorService;\n+    private InflaterPool inflaterPool;\n+\n+    @BeforeEach\n+    void setUp()", "originalCommit": "273213e8df4f438bf853787ec932e22424e7fe8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU1MDI4MQ==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505550281", "bodyText": "done.", "author": "lorban", "createdAt": "2020-10-15T13:40:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQyMjQ2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQyMjU4MA==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505422580", "bodyText": "Make it public.", "author": "sbordet", "createdAt": "2020-10-15T10:07:41Z", "path": "jetty-server/src/test/java/org/eclipse/jetty/server/BlockingContentProducerTest.java", "diffHunk": "@@ -0,0 +1,320 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.zip.GZIPOutputStream;\n+\n+import org.eclipse.jetty.io.ArrayByteBufferPool;\n+import org.eclipse.jetty.io.EofException;\n+import org.eclipse.jetty.server.handler.gzip.GzipHttpInputInterceptor;\n+import org.eclipse.jetty.util.compression.CompressionPool;\n+import org.eclipse.jetty.util.compression.InflaterPool;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.nullValue;\n+import static org.hamcrest.core.Is.is;\n+\n+public class BlockingContentProducerTest\n+{\n+    private ScheduledExecutorService scheduledExecutorService;\n+    private InflaterPool inflaterPool;\n+\n+    @BeforeEach\n+    void setUp()\n+    {\n+        scheduledExecutorService = Executors.newSingleThreadScheduledExecutor();\n+        inflaterPool = new InflaterPool(CompressionPool.INFINITE_CAPACITY, true);\n+    }\n+\n+    @AfterEach\n+    void tearDown()", "originalCommit": "273213e8df4f438bf853787ec932e22424e7fe8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU1MDM2OQ==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505550369", "bodyText": "done.", "author": "lorban", "createdAt": "2020-10-15T13:40:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQyMjU4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQyMjgzNA==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505422834", "bodyText": "\"eof\" implies \"special\"?", "author": "sbordet", "createdAt": "2020-10-15T10:08:09Z", "path": "jetty-server/src/test/java/org/eclipse/jetty/server/BlockingContentProducerTest.java", "diffHunk": "@@ -0,0 +1,320 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.zip.GZIPOutputStream;\n+\n+import org.eclipse.jetty.io.ArrayByteBufferPool;\n+import org.eclipse.jetty.io.EofException;\n+import org.eclipse.jetty.server.handler.gzip.GzipHttpInputInterceptor;\n+import org.eclipse.jetty.util.compression.CompressionPool;\n+import org.eclipse.jetty.util.compression.InflaterPool;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.nullValue;\n+import static org.hamcrest.core.Is.is;\n+\n+public class BlockingContentProducerTest\n+{\n+    private ScheduledExecutorService scheduledExecutorService;\n+    private InflaterPool inflaterPool;\n+\n+    @BeforeEach\n+    void setUp()\n+    {\n+        scheduledExecutorService = Executors.newSingleThreadScheduledExecutor();\n+        inflaterPool = new InflaterPool(CompressionPool.INFINITE_CAPACITY, true);\n+    }\n+\n+    @AfterEach\n+    void tearDown()\n+    {\n+        scheduledExecutorService.shutdownNow();\n+    }\n+\n+    @Test\n+    public void testBlockingContentProducerNoInterceptor()\n+    {\n+        ByteBuffer[] buffers = new ByteBuffer[3];\n+        buffers[0] = ByteBuffer.wrap(\"1 hello 1\".getBytes(StandardCharsets.ISO_8859_1));\n+        buffers[1] = ByteBuffer.wrap(\"2 howdy 2\".getBytes(StandardCharsets.ISO_8859_1));\n+        buffers[2] = ByteBuffer.wrap(\"3 hey ya 3\".getBytes(StandardCharsets.ISO_8859_1));\n+        final int totalContentBytesCount = countRemaining(buffers);\n+        final String originalContentString = asString(buffers);\n+\n+        AtomicReference<ContentProducer> ref = new AtomicReference<>();\n+        ArrayDelayedHttpChannel httpChannel = new ArrayDelayedHttpChannel(buffers, new HttpInput.EofContent(), scheduledExecutorService, () -> ref.get().wakeup());\n+        ContentProducer contentProducer = new BlockingContentProducer(httpChannel, new AsyncContentProducer(httpChannel));\n+        ref.set(contentProducer);\n+\n+        Throwable error = readAndAssertContent(totalContentBytesCount, originalContentString, buffers.length + 1, contentProducer);\n+        assertThat(error, nullValue());\n+    }\n+\n+    @Test\n+    public void testBlockingContentProducerNoInterceptorWithError()\n+    {\n+        ByteBuffer[] buffers = new ByteBuffer[3];\n+        buffers[0] = ByteBuffer.wrap(\"1 hello 1\".getBytes(StandardCharsets.ISO_8859_1));\n+        buffers[1] = ByteBuffer.wrap(\"2 howdy 2\".getBytes(StandardCharsets.ISO_8859_1));\n+        buffers[2] = ByteBuffer.wrap(\"3 hey ya 3\".getBytes(StandardCharsets.ISO_8859_1));\n+        final int totalContentBytesCount = countRemaining(buffers);\n+        final String originalContentString = asString(buffers);\n+        final Throwable expectedError = new EofException(\"Early EOF\");\n+\n+        AtomicReference<ContentProducer> ref = new AtomicReference<>();\n+        ArrayDelayedHttpChannel httpChannel = new ArrayDelayedHttpChannel(buffers, new HttpInput.ErrorContent(expectedError), scheduledExecutorService, () -> ref.get().wakeup());\n+        ContentProducer contentProducer = new BlockingContentProducer(httpChannel, new AsyncContentProducer(httpChannel));\n+        ref.set(contentProducer);\n+\n+        Throwable error = readAndAssertContent(totalContentBytesCount, originalContentString, buffers.length + 1, contentProducer);\n+        assertThat(error, is(expectedError));\n+    }\n+\n+    @Test\n+    public void testBlockingContentProducerGzipInterceptor()\n+    {\n+        ByteBuffer[] uncompressedBuffers = new ByteBuffer[3];\n+        uncompressedBuffers[0] = ByteBuffer.wrap(\"1 hello 1\".getBytes(StandardCharsets.ISO_8859_1));\n+        uncompressedBuffers[1] = ByteBuffer.wrap(\"2 howdy 2\".getBytes(StandardCharsets.ISO_8859_1));\n+        uncompressedBuffers[2] = ByteBuffer.wrap(\"3 hey ya 3\".getBytes(StandardCharsets.ISO_8859_1));\n+        final int totalContentBytesCount = countRemaining(uncompressedBuffers);\n+        final String originalContentString = asString(uncompressedBuffers);\n+\n+        ByteBuffer[] buffers = new ByteBuffer[3];\n+        buffers[0] = gzipByteBuffer(uncompressedBuffers[0]);\n+        buffers[1] = gzipByteBuffer(uncompressedBuffers[1]);\n+        buffers[2] = gzipByteBuffer(uncompressedBuffers[2]);\n+\n+        AtomicReference<ContentProducer> ref = new AtomicReference<>();\n+        ArrayDelayedHttpChannel httpChannel = new ArrayDelayedHttpChannel(buffers, new HttpInput.EofContent(), scheduledExecutorService, () -> ref.get().wakeup());\n+        ContentProducer contentProducer = new BlockingContentProducer(httpChannel, new AsyncContentProducer(httpChannel));\n+        ref.set(contentProducer);\n+        contentProducer.setInterceptor(new GzipHttpInputInterceptor(inflaterPool, new ArrayByteBufferPool(1, 1, 2), 32));\n+\n+        Throwable error = readAndAssertContent(totalContentBytesCount, originalContentString, buffers.length + 1, contentProducer);\n+        assertThat(error, nullValue());\n+    }\n+\n+    @Test\n+    public void testBlockingContentProducerGzipInterceptorWithTinyBuffers()\n+    {\n+        ByteBuffer[] uncompressedBuffers = new ByteBuffer[3];\n+        uncompressedBuffers[0] = ByteBuffer.wrap(\"1 hello 1\".getBytes(StandardCharsets.ISO_8859_1));\n+        uncompressedBuffers[1] = ByteBuffer.wrap(\"2 howdy 2\".getBytes(StandardCharsets.ISO_8859_1));\n+        uncompressedBuffers[2] = ByteBuffer.wrap(\"3 hey ya 3\".getBytes(StandardCharsets.ISO_8859_1));\n+        final int totalContentBytesCount = countRemaining(uncompressedBuffers);\n+        final String originalContentString = asString(uncompressedBuffers);\n+\n+        ByteBuffer[] buffers = new ByteBuffer[3];\n+        buffers[0] = gzipByteBuffer(uncompressedBuffers[0]);\n+        buffers[1] = gzipByteBuffer(uncompressedBuffers[1]);\n+        buffers[2] = gzipByteBuffer(uncompressedBuffers[2]);\n+\n+        AtomicReference<ContentProducer> ref = new AtomicReference<>();\n+        ArrayDelayedHttpChannel httpChannel = new ArrayDelayedHttpChannel(buffers, new HttpInput.EofContent(), scheduledExecutorService, () -> ref.get().wakeup());\n+        ContentProducer contentProducer = new BlockingContentProducer(httpChannel, new AsyncContentProducer(httpChannel));\n+        ref.set(contentProducer);\n+        contentProducer.setInterceptor(new GzipHttpInputInterceptor(inflaterPool, new ArrayByteBufferPool(1, 1, 2), 1));\n+\n+        Throwable error = readAndAssertContent(totalContentBytesCount, originalContentString, totalContentBytesCount + 1, contentProducer);\n+        assertThat(error, nullValue());\n+    }\n+\n+    @Test\n+    public void testBlockingContentProducerGzipInterceptorWithError()\n+    {\n+        ByteBuffer[] uncompressedBuffers = new ByteBuffer[3];\n+        uncompressedBuffers[0] = ByteBuffer.wrap(\"1 hello 1\".getBytes(StandardCharsets.ISO_8859_1));\n+        uncompressedBuffers[1] = ByteBuffer.wrap(\"2 howdy 2\".getBytes(StandardCharsets.ISO_8859_1));\n+        uncompressedBuffers[2] = ByteBuffer.wrap(\"3 hey ya 3\".getBytes(StandardCharsets.ISO_8859_1));\n+        final int totalContentBytesCount = countRemaining(uncompressedBuffers);\n+        final String originalContentString = asString(uncompressedBuffers);\n+        final Throwable expectedError = new Throwable(\"HttpInput idle timeout\");\n+\n+        ByteBuffer[] buffers = new ByteBuffer[3];\n+        buffers[0] = gzipByteBuffer(uncompressedBuffers[0]);\n+        buffers[1] = gzipByteBuffer(uncompressedBuffers[1]);\n+        buffers[2] = gzipByteBuffer(uncompressedBuffers[2]);\n+\n+        AtomicReference<ContentProducer> ref = new AtomicReference<>();\n+        ArrayDelayedHttpChannel httpChannel = new ArrayDelayedHttpChannel(buffers, new HttpInput.ErrorContent(expectedError), scheduledExecutorService, () -> ref.get().wakeup());\n+        ContentProducer contentProducer = new BlockingContentProducer(httpChannel, new AsyncContentProducer(httpChannel));\n+        ref.set(contentProducer);\n+        contentProducer.setInterceptor(new GzipHttpInputInterceptor(inflaterPool, new ArrayByteBufferPool(1, 1, 2), 32));\n+\n+        Throwable error = readAndAssertContent(totalContentBytesCount, originalContentString, buffers.length + 1, contentProducer);\n+        assertThat(error, is(expectedError));\n+    }\n+\n+    private Throwable readAndAssertContent(int totalContentBytesCount, String originalContentString, int totalContentCount, ContentProducer contentProducer)\n+    {\n+        int readBytes = 0;\n+        int nextContentCount = 0;\n+        String consumedString = \"\";\n+        Throwable error = null;\n+        while (true)\n+        {\n+            HttpInput.Content content = contentProducer.nextContent();\n+            nextContentCount++;\n+\n+            if (content.isSpecial())\n+            {\n+                if (content.isEof())", "originalCommit": "273213e8df4f438bf853787ec932e22424e7fe8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU1MDgwMA==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505550800", "bodyText": "Yes, any content that does not wrap a ByteBuffer is special.", "author": "lorban", "createdAt": "2020-10-15T13:40:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQyMjgzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQyNTUyMA==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505425520", "bodyText": "Use a for loop for this?", "author": "sbordet", "createdAt": "2020-10-15T10:12:55Z", "path": "tests/test-http-client-transport/src/test/java/org/eclipse/jetty/http/client/AsyncIOServletTest.java", "diffHunk": "@@ -1345,6 +1358,324 @@ public void onComplete(Result result)\n         assertTrue(clientLatch.await(10, TimeUnit.SECONDS));\n     }\n \n+    @ParameterizedTest\n+    @ArgumentsSource(TransportProvider.class)\n+    public void testAsyncEcho(Transport transport) throws Exception\n+    {\n+        init(transport);\n+        scenario.start(new HttpServlet()\n+        {\n+            @Override\n+            protected void service(HttpServletRequest request, HttpServletResponse response) throws IOException\n+            {\n+                System.err.println(\"Service \" + request);\n+\n+                AsyncContext asyncContext = request.startAsync();\n+                ServletInputStream input = request.getInputStream();\n+                input.setReadListener(new ReadListener()\n+                {\n+                    @Override\n+                    public void onDataAvailable() throws IOException\n+                    {\n+                        while (input.isReady())\n+                        {\n+                            int b = input.read();\n+                            if (b >= 0)\n+                            {\n+                                // System.err.printf(\"0x%2x %s %n\", b, Character.isISOControl(b)?\"?\":(\"\"+(char)b));\n+                                response.getOutputStream().write(b);\n+                            }\n+                            else\n+                                return;\n+                        }\n+                    }\n+\n+                    @Override\n+                    public void onAllDataRead() throws IOException\n+                    {\n+                        asyncContext.complete();\n+                    }\n+\n+                    @Override\n+                    public void onError(Throwable x)\n+                    {\n+                    }\n+                });\n+            }\n+        });\n+\n+        AsyncRequestContent contentProvider = new AsyncRequestContent();\n+        CountDownLatch clientLatch = new CountDownLatch(1);\n+\n+        AtomicReference<Result> resultRef = new AtomicReference<>();\n+        scenario.client.newRequest(scenario.newURI())\n+            .method(HttpMethod.POST)\n+            .path(scenario.servletPath)\n+            .body(contentProvider)\n+            .send(new BufferingResponseListener(16 * 1024 * 1024)\n+            {\n+                @Override\n+                public void onComplete(Result result)\n+                {\n+                    resultRef.set(result);\n+                    clientLatch.countDown();\n+                }\n+            });\n+\n+        for (int i = 0; i < 1_000_000; i++)\n+        {\n+            contentProvider.offer(BufferUtil.toBuffer(\"S\" + i));\n+        }\n+        contentProvider.close();\n+\n+        assertTrue(clientLatch.await(30, TimeUnit.SECONDS));\n+        assertThat(resultRef.get().isSucceeded(), Matchers.is(true));\n+        assertThat(resultRef.get().getResponse().getStatus(), Matchers.equalTo(HttpStatus.OK_200));\n+    }\n+\n+    @ParameterizedTest\n+    @ArgumentsSource(TransportProvider.class)\n+    public void testAsyncInterceptedTwice(Transport transport) throws Exception\n+    {\n+        init(transport);\n+        scenario.start(new HttpServlet()\n+        {\n+            @Override\n+            protected void service(HttpServletRequest request, HttpServletResponse response) throws IOException\n+            {\n+                System.err.println(\"Service \" + request);\n+\n+                final HttpInput httpInput = ((Request)request).getHttpInput();\n+                httpInput.addInterceptor(new GzipHttpInputInterceptor(new InflaterPool(CompressionPool.INFINITE_CAPACITY, true), ((Request)request).getHttpChannel().getByteBufferPool(), 1024));\n+                httpInput.addInterceptor(content ->\n+                {\n+                    ByteBuffer byteBuffer = content.getByteBuffer();\n+                    byte[] bytes = new byte[2];\n+                    bytes[1] = byteBuffer.get();\n+                    bytes[0] = byteBuffer.get();\n+                    return new Content(wrap(bytes));\n+                });\n+\n+                AsyncContext asyncContext = request.startAsync();\n+                ServletInputStream input = request.getInputStream();\n+                ByteArrayOutputStream out = new ByteArrayOutputStream();\n+\n+                input.setReadListener(new ReadListener()\n+                {\n+                    @Override\n+                    public void onDataAvailable() throws IOException\n+                    {\n+                        while (input.isReady())\n+                        {\n+                            int b = input.read();\n+                            if (b > 0)\n+                            {\n+                                // System.err.printf(\"0x%2x %s %n\", b, Character.isISOControl(b)?\"?\":(\"\"+(char)b));\n+                                out.write(b);\n+                            }\n+                            else if (b < 0)\n+                                return;\n+                        }\n+                    }\n+\n+                    @Override\n+                    public void onAllDataRead() throws IOException\n+                    {\n+                        response.getOutputStream().write(out.toByteArray());\n+                        asyncContext.complete();\n+                    }\n+\n+                    @Override\n+                    public void onError(Throwable x)\n+                    {\n+                    }\n+                });\n+            }\n+        });\n+\n+        AsyncRequestContent contentProvider = new AsyncRequestContent();\n+        CountDownLatch clientLatch = new CountDownLatch(1);\n+\n+        String expected =\n+                \"0S\" +\n+                \"1S\" +\n+                \"2S\" +\n+                \"3S\" +\n+                \"4S\" +\n+                \"5S\" +\n+                \"6S\";\n+\n+        scenario.client.newRequest(scenario.newURI())\n+            .method(HttpMethod.POST)\n+            .path(scenario.servletPath)\n+            .body(contentProvider)\n+            .send(new BufferingResponseListener()\n+            {\n+                @Override\n+                public void onComplete(Result result)\n+                {\n+                    if (result.isSucceeded())\n+                    {\n+                        Response response = result.getResponse();\n+                        assertThat(response.getStatus(), Matchers.equalTo(HttpStatus.OK_200));\n+                        assertThat(getContentAsString(), Matchers.equalTo(expected));\n+                        clientLatch.countDown();\n+                    }\n+                }\n+            });\n+\n+        contentProvider.offer(gzipToBuffer(\"S0\"));\n+        contentProvider.flush();\n+        contentProvider.offer(gzipToBuffer(\"S1\"));\n+        contentProvider.flush();\n+        contentProvider.offer(gzipToBuffer(\"S2\"));\n+        contentProvider.flush();\n+        contentProvider.offer(gzipToBuffer(\"S3\"));\n+        contentProvider.flush();\n+        contentProvider.offer(gzipToBuffer(\"S4\"));\n+        contentProvider.flush();\n+        contentProvider.offer(gzipToBuffer(\"S5\"));\n+        contentProvider.flush();\n+        contentProvider.offer(gzipToBuffer(\"S6\"));\n+        contentProvider.close();", "originalCommit": "273213e8df4f438bf853787ec932e22424e7fe8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjE0MDU4Mg==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r506140582", "bodyText": "Sure.", "author": "lorban", "createdAt": "2020-10-16T07:54:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQyNTUyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQyNjEzNQ==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505426135", "bodyText": "Why was this removed?", "author": "sbordet", "createdAt": "2020-10-15T10:14:04Z", "path": "tests/test-http-client-transport/src/test/java/org/eclipse/jetty/http/client/TransportScenario.java", "diffHunk": "@@ -328,8 +326,6 @@ public void startServer(Handler handler) throws Exception\n         serverThreads.setName(\"server\");\n         serverThreads.setDetailedDump(true);\n         server = new Server(serverThreads);\n-        MBeanContainer mbeanContainer = new MBeanContainer(ManagementFactory.getPlatformMBeanServer());\n-        server.addBean(mbeanContainer);", "originalCommit": "273213e8df4f438bf853787ec932e22424e7fe8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU1NTQ3NQ==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r505555475", "bodyText": "Because the tests using the TransportScenario were leaking resources when ran continuously. Since none of those seem to require the MBeanContainer, I decided to ditch it.\nI have to re-investigate what made those resources leak and add a proper fix.", "author": "lorban", "createdAt": "2020-10-15T13:46:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQyNjEzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjEzODQ1Mw==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r506138453", "bodyText": "There's no apparent leak anymore in the tests I tried. I'll add this back.", "author": "lorban", "createdAt": "2020-10-16T07:51:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQyNjEzNQ=="}], "type": "inlineReview"}, {"oid": "e213bac2c8015b200c69e6ed0a6fc42a937e0250", "url": "https://github.com/eclipse/jetty.project/commit/e213bac2c8015b200c69e6ed0a6fc42a937e0250", "message": "fix compilation after rebase\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-10-16T08:59:10Z", "type": "forcePushed"}, {"oid": "95a93cb0173e9a42780c07f2d45a5b0f0c00b48b", "url": "https://github.com/eclipse/jetty.project/commit/95a93cb0173e9a42780c07f2d45a5b0f0c00b48b", "message": "fix compilation after rebase\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-10-19T08:42:31Z", "type": "forcePushed"}, {"oid": "5fe974883042120c758255d82d5a33044c7fe979", "url": "https://github.com/eclipse/jetty.project/commit/5fe974883042120c758255d82d5a33044c7fe979", "message": "only wakeup when needContent demanded\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-10-19T13:39:24Z", "type": "forcePushed"}, {"oid": "0065312d38203e75e3c06386cc8bfb2f3eb56b6f", "url": "https://github.com/eclipse/jetty.project/commit/0065312d38203e75e3c06386cc8bfb2f3eb56b6f", "message": "only wakeup when needContent demanded\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-10-19T14:11:08Z", "type": "forcePushed"}, {"oid": "ae16653550c4db993b10659606b1553a11796cb2", "url": "https://github.com/eclipse/jetty.project/commit/ae16653550c4db993b10659606b1553a11796cb2", "message": "only wakeup when needContent demanded\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-10-19T15:01:50Z", "type": "forcePushed"}, {"oid": "e616a89edfb6c02bf7c737af35060c03035f8143", "url": "https://github.com/eclipse/jetty.project/commit/e616a89edfb6c02bf7c737af35060c03035f8143", "message": "cleanup comment\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-10-20T11:32:00Z", "type": "forcePushed"}, {"oid": "2ddddd9deb240f7edb120d5aae29efe6cd8dd2d2", "url": "https://github.com/eclipse/jetty.project/commit/2ddddd9deb240f7edb120d5aae29efe6cd8dd2d2", "message": "cleanup\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-10-21T12:22:07Z", "type": "forcePushed"}, {"oid": "98d831b85c23aa760744582a85e061bc99032af8", "url": "https://github.com/eclipse/jetty.project/commit/98d831b85c23aa760744582a85e061bc99032af8", "message": "content javadoc\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-10-26T13:39:55Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA5MTgyMg==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r512091822", "bodyText": "Create 2 static final DemandingContents and pick between them rather than creating new ones all the time", "author": "gregw", "createdAt": "2020-10-26T16:22:37Z", "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpChannelOverHTTP2.java", "diffHunk": "@@ -261,31 +275,277 @@ public InvocationType getInvocationType()\n             {\n                 return callback.getInvocationType();\n             }\n-        });\n+        };\n+        boolean wakeup = _contentDemander.onContent(content);\n+        boolean handle = onContent(content);\n \n         boolean endStream = frame.isEndStream();\n         if (endStream)\n         {\n             boolean handleContent = onContentComplete();\n+            // this will generate EOF -> must happen before onContentProducible\n             boolean handleRequest = onRequestComplete();\n             handle |= handleContent | handleRequest;\n         }\n \n+        boolean woken = wakeup && getRequest().getHttpInput().onContentProducible();\n         if (LOG.isDebugEnabled())\n         {\n-            LOG.debug(\"HTTP2 Request #{}/{}: {} bytes of {} content, handle: {}\",\n+            LOG.debug(\"HTTP2 Request #{}/{}: {} bytes of {} content, woken: {}, handle: {}\",\n                     stream.getId(),\n                     Integer.toHexString(stream.getSession().hashCode()),\n                     length,\n                     endStream ? \"last\" : \"some\",\n+                    woken,\n                     handle);\n         }\n+        handle |= woken;\n \n         boolean wasDelayed = _delayedUntilContent;\n         _delayedUntilContent = false;\n         return handle || wasDelayed ? this : null;\n     }\n \n+    private static final HttpInput.Content EOF = new HttpInput.EofContent();\n+\n+    private static final class DemandingContent extends HttpInput.SpecialContent\n+    {\n+        private final boolean wakeup;\n+\n+        public DemandingContent(boolean wakeup)\n+        {\n+            this.wakeup = wakeup;\n+        }\n+    }\n+\n+    private class ContentDemander\n+    {\n+        private final AtomicReference<HttpInput.Content> _content = new AtomicReference<>();\n+\n+        public void recycle()\n+        {\n+            HttpInput.Content c = _content.getAndSet(null);\n+            if (c != null && !c.isSpecial())\n+                throw new AssertionError(\"unconsumed content: \" + c);\n+        }\n+\n+        public HttpInput.Content poll()\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c == null || c.isSpecial() || _content.compareAndSet(c, c.isEof() ? EOF : null))\n+                    return c;\n+            }\n+        }\n+\n+        public boolean demand(boolean wakeup)\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c instanceof DemandingContent)\n+                {\n+                    if (wakeup && !((DemandingContent)c).wakeup)\n+                    {\n+                        if (!_content.compareAndSet(c, new DemandingContent(true)))\n+                            continue;\n+                    }\n+                    return false;\n+                }\n+                if (c != null)\n+                    return true;\n+                if (_content.compareAndSet(null, new DemandingContent(wakeup)))", "originalCommit": "98d831b85c23aa760744582a85e061bc99032af8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjEzMDg2Nw==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r512130867", "bodyText": "Done.", "author": "lorban", "createdAt": "2020-10-26T17:12:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA5MTgyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA5MjU4MA==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r512092580", "bodyText": "rename wakeup  to needed", "author": "gregw", "createdAt": "2020-10-26T16:23:43Z", "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpChannelOverHTTP2.java", "diffHunk": "@@ -261,31 +275,277 @@ public InvocationType getInvocationType()\n             {\n                 return callback.getInvocationType();\n             }\n-        });\n+        };\n+        boolean wakeup = _contentDemander.onContent(content);\n+        boolean handle = onContent(content);\n \n         boolean endStream = frame.isEndStream();\n         if (endStream)\n         {\n             boolean handleContent = onContentComplete();\n+            // this will generate EOF -> must happen before onContentProducible\n             boolean handleRequest = onRequestComplete();\n             handle |= handleContent | handleRequest;\n         }\n \n+        boolean woken = wakeup && getRequest().getHttpInput().onContentProducible();\n         if (LOG.isDebugEnabled())\n         {\n-            LOG.debug(\"HTTP2 Request #{}/{}: {} bytes of {} content, handle: {}\",\n+            LOG.debug(\"HTTP2 Request #{}/{}: {} bytes of {} content, woken: {}, handle: {}\",\n                     stream.getId(),\n                     Integer.toHexString(stream.getSession().hashCode()),\n                     length,\n                     endStream ? \"last\" : \"some\",\n+                    woken,\n                     handle);\n         }\n+        handle |= woken;\n \n         boolean wasDelayed = _delayedUntilContent;\n         _delayedUntilContent = false;\n         return handle || wasDelayed ? this : null;\n     }\n \n+    private static final HttpInput.Content EOF = new HttpInput.EofContent();\n+\n+    private static final class DemandingContent extends HttpInput.SpecialContent\n+    {\n+        private final boolean wakeup;\n+\n+        public DemandingContent(boolean wakeup)\n+        {\n+            this.wakeup = wakeup;\n+        }\n+    }\n+\n+    private class ContentDemander\n+    {\n+        private final AtomicReference<HttpInput.Content> _content = new AtomicReference<>();\n+\n+        public void recycle()\n+        {\n+            HttpInput.Content c = _content.getAndSet(null);\n+            if (c != null && !c.isSpecial())\n+                throw new AssertionError(\"unconsumed content: \" + c);\n+        }\n+\n+        public HttpInput.Content poll()\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (c == null || c.isSpecial() || _content.compareAndSet(c, c.isEof() ? EOF : null))\n+                    return c;\n+            }\n+        }\n+\n+        public boolean demand(boolean wakeup)", "originalCommit": "98d831b85c23aa760744582a85e061bc99032af8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjEzMDk2Mw==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r512130963", "bodyText": "Done.", "author": "lorban", "createdAt": "2020-10-26T17:12:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA5MjU4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA5Mjc5Mg==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r512092792", "bodyText": "rename wakeup to needed", "author": "gregw", "createdAt": "2020-10-26T16:24:01Z", "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpChannelOverHTTP2.java", "diffHunk": "@@ -261,31 +275,277 @@ public InvocationType getInvocationType()\n             {\n                 return callback.getInvocationType();\n             }\n-        });\n+        };\n+        boolean wakeup = _contentDemander.onContent(content);\n+        boolean handle = onContent(content);\n \n         boolean endStream = frame.isEndStream();\n         if (endStream)\n         {\n             boolean handleContent = onContentComplete();\n+            // this will generate EOF -> must happen before onContentProducible\n             boolean handleRequest = onRequestComplete();\n             handle |= handleContent | handleRequest;\n         }\n \n+        boolean woken = wakeup && getRequest().getHttpInput().onContentProducible();\n         if (LOG.isDebugEnabled())\n         {\n-            LOG.debug(\"HTTP2 Request #{}/{}: {} bytes of {} content, handle: {}\",\n+            LOG.debug(\"HTTP2 Request #{}/{}: {} bytes of {} content, woken: {}, handle: {}\",\n                     stream.getId(),\n                     Integer.toHexString(stream.getSession().hashCode()),\n                     length,\n                     endStream ? \"last\" : \"some\",\n+                    woken,\n                     handle);\n         }\n+        handle |= woken;\n \n         boolean wasDelayed = _delayedUntilContent;\n         _delayedUntilContent = false;\n         return handle || wasDelayed ? this : null;\n     }\n \n+    private static final HttpInput.Content EOF = new HttpInput.EofContent();\n+\n+    private static final class DemandingContent extends HttpInput.SpecialContent\n+    {\n+        private final boolean wakeup;", "originalCommit": "98d831b85c23aa760744582a85e061bc99032af8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjEzMTAyNw==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r512131027", "bodyText": "Done.", "author": "lorban", "createdAt": "2020-10-26T17:13:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA5Mjc5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjEwMDkwNw==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r512100907", "bodyText": "So this is not really wakeup at this point.   It's more like contentWasNeeded or just `needed'", "author": "gregw", "createdAt": "2020-10-26T16:34:55Z", "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpChannelOverHTTP2.java", "diffHunk": "@@ -261,31 +275,277 @@ public InvocationType getInvocationType()\n             {\n                 return callback.getInvocationType();\n             }\n-        });\n+        };\n+        boolean wakeup = _contentDemander.onContent(content);", "originalCommit": "98d831b85c23aa760744582a85e061bc99032af8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjEzMTE0Mw==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r512131143", "bodyText": "Done.", "author": "lorban", "createdAt": "2020-10-26T17:13:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjEwMDkwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjEwMzIxMQ==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r512103211", "bodyText": "A comment here to say that IFF isReady() returns false has needContent been called, thus we no that eventually a call to onContentProducible will come.", "author": "gregw", "createdAt": "2020-10-26T16:38:18Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/BlockingContentProducer.java", "diffHunk": "@@ -0,0 +1,142 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.util.concurrent.Semaphore;\n+\n+/**\n+ * Blocking implementation of {@link ContentProducer}. Calling {@link #nextContent()} will block when\n+ * there is no available content but will never return null.\n+ */\n+class BlockingContentProducer implements ContentProducer\n+{\n+    private final Semaphore _semaphore = new Semaphore(0);\n+    private final AsyncContentProducer _asyncContentProducer;\n+\n+    public BlockingContentProducer(AsyncContentProducer delegate)\n+    {\n+        _asyncContentProducer = delegate;\n+    }\n+\n+    @Override\n+    public void recycle()\n+    {\n+        _asyncContentProducer.recycle();\n+        _semaphore.drainPermits();\n+    }\n+\n+    @Override\n+    public int available()\n+    {\n+        return _asyncContentProducer.available();\n+    }\n+\n+    @Override\n+    public boolean hasContent()\n+    {\n+        return _asyncContentProducer.hasContent();\n+    }\n+\n+    @Override\n+    public boolean isError()\n+    {\n+        return _asyncContentProducer.isError();\n+    }\n+\n+    @Override\n+    public void checkMinDataRate()\n+    {\n+        _asyncContentProducer.checkMinDataRate();\n+    }\n+\n+    @Override\n+    public long getRawContentArrived()\n+    {\n+        return _asyncContentProducer.getRawContentArrived();\n+    }\n+\n+    @Override\n+    public boolean consumeAll(Throwable x)\n+    {\n+        return _asyncContentProducer.consumeAll(x);\n+    }\n+\n+    @Override\n+    public HttpInput.Content nextContent()\n+    {\n+        while (true)\n+        {\n+            HttpInput.Content content = _asyncContentProducer.nextContent();\n+            if (content != null)\n+                return content;\n+\n+            if (_asyncContentProducer.isReady())\n+                continue;\n+", "originalCommit": "98d831b85c23aa760744582a85e061bc99032af8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjEzMTE5Nw==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r512131197", "bodyText": "Done.", "author": "lorban", "createdAt": "2020-10-26T17:13:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjEwMzIxMQ=="}], "type": "inlineReview"}, {"oid": "99f227a68292ad51f103d313f5c8e686f0108532", "url": "https://github.com/eclipse/jetty.project/commit/99f227a68292ad51f103d313f5c8e686f0108532", "message": "remove reset check\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-10-27T13:22:14Z", "type": "forcePushed"}, {"oid": "abd0fe15d030317f52710b43d8b7e00329c9ee32", "url": "https://github.com/eclipse/jetty.project/commit/abd0fe15d030317f52710b43d8b7e00329c9ee32", "message": "remove reset check\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-10-27T13:47:10Z", "type": "forcePushed"}, {"oid": "0b90ca72ac35889289d7b10508642bfbfd372763", "url": "https://github.com/eclipse/jetty.project/commit/0b90ca72ac35889289d7b10508642bfbfd372763", "message": "add comment explaining why a branch is needed\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-10-27T15:33:10Z", "type": "forcePushed"}, {"oid": "cba85b58aee7b8969746dc37619749d4b4874f36", "url": "https://github.com/eclipse/jetty.project/commit/cba85b58aee7b8969746dc37619749d4b4874f36", "message": "Get rid of addContent() by making produceContent() return Content instead.\nMake EOF and errors be special content.\nTransition to a much simplified FSM by using the needContent() / produceContent() model.\nImplement blocking on top of async, this way there is only one FSM.\n(Milestone 7)\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-10-29T08:21:14Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjUwOTg1MQ==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r516509851", "bodyText": "Doesn't special content, or at least EOF, need to be passed to the interceptors?\nRemember that we can EOF on non special content now, so interceptors might sometimes see EOF.... so they should always see it.\nIt may be that an interceptor is buffering content and can produce lots of content (over and over) from an empty EOF raw content.", "author": "gregw", "createdAt": "2020-11-03T09:00:29Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/AsyncContentProducer.java", "diffHunk": "@@ -0,0 +1,352 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jetty.http.BadMessageException;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Non-blocking {@link ContentProducer} implementation. Calling {@link #nextContent()} will never block\n+ * but will return null when there is no available content but will never return block.\n+ */\n+class AsyncContentProducer implements ContentProducer\n+{\n+    private static final Logger LOG = LoggerFactory.getLogger(AsyncContentProducer.class);\n+\n+    private final HttpChannel _httpChannel;\n+    private HttpInput.Interceptor _interceptor;\n+    private HttpInput.Content _rawContent;\n+    private HttpInput.Content _transformedContent;\n+    private boolean _error;\n+    private long _firstByteTimeStamp = Long.MIN_VALUE;\n+    private long _rawContentArrived;\n+\n+    AsyncContentProducer(HttpChannel httpChannel)\n+    {\n+        _httpChannel = httpChannel;\n+    }\n+\n+    @Override\n+    public void recycle()\n+    {\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"recycling {}\", this);\n+        _interceptor = null;\n+        _rawContent = null;\n+        _transformedContent = null;\n+        _error = false;\n+        _firstByteTimeStamp = Long.MIN_VALUE;\n+        _rawContentArrived = 0L;\n+    }\n+\n+    @Override\n+    public HttpInput.Interceptor getInterceptor()\n+    {\n+        return _interceptor;\n+    }\n+\n+    @Override\n+    public void setInterceptor(HttpInput.Interceptor interceptor)\n+    {\n+        this._interceptor = interceptor;\n+    }\n+\n+    @Override\n+    public int available()\n+    {\n+        HttpInput.Content content = nextTransformedContent();\n+        int available = content == null ? 0 : content.remaining();\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"available = {}\", available);\n+        return available;\n+    }\n+\n+    @Override\n+    public boolean hasContent()\n+    {\n+        boolean hasContent = _rawContent != null;\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"hasContent = {}\", hasContent);\n+        return hasContent;\n+    }\n+\n+    @Override\n+    public boolean isError()\n+    {\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"isError = {}\", _error);\n+        return _error;\n+    }\n+\n+    @Override\n+    public void checkMinDataRate()\n+    {\n+        long minRequestDataRate = _httpChannel.getHttpConfiguration().getMinRequestDataRate();\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"checkMinDataRate [m={},t={}]\", minRequestDataRate, _firstByteTimeStamp);\n+        if (minRequestDataRate > 0 && _firstByteTimeStamp != Long.MIN_VALUE)\n+        {\n+            long period = System.nanoTime() - _firstByteTimeStamp;\n+            if (period > 0)\n+            {\n+                long minimumData = minRequestDataRate * TimeUnit.NANOSECONDS.toMillis(period) / TimeUnit.SECONDS.toMillis(1);\n+                if (getRawContentArrived() < minimumData)\n+                {\n+                    if (LOG.isDebugEnabled())\n+                        LOG.debug(\"checkMinDataRate check failed\");\n+                    BadMessageException bad = new BadMessageException(HttpStatus.REQUEST_TIMEOUT_408,\n+                        String.format(\"Request content data rate < %d B/s\", minRequestDataRate));\n+                    if (_httpChannel.getState().isResponseCommitted())\n+                    {\n+                        if (LOG.isDebugEnabled())\n+                            LOG.debug(\"checkMinDataRate aborting channel\");\n+                        _httpChannel.abort(bad);\n+                    }\n+                    failCurrentContent(bad);\n+                    throw bad;\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public long getRawContentArrived()\n+    {\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"getRawContentArrived = {}\", _rawContentArrived);\n+        return _rawContentArrived;\n+    }\n+\n+    @Override\n+    public boolean consumeAll(Throwable x)\n+    {\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"consumeAll [e={}]\", (Object)x);\n+        failCurrentContent(x);\n+        // A specific HttpChannel mechanism must be used as the following code\n+        // does not guarantee that the channel will synchronously deliver all\n+        // content it already contains:\n+        //   while (true)\n+        //   {\n+        //       HttpInput.Content content = _httpChannel.produceContent();\n+        //       ...\n+        //   }\n+        // as the HttpChannel's produceContent() contract makes no such promise;\n+        // for instance the H2 implementation calls Stream.demand() that may\n+        // deliver the content asynchronously. Tests in StreamResetTest cover this.\n+        boolean atEof = _httpChannel.failAllContent(x);\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"failed all content of http channel; at EOF? {}\", atEof);\n+        return atEof;\n+    }\n+\n+    private void failCurrentContent(Throwable x)\n+    {\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"failing currently held content [r={},t={}]\", _rawContent, _transformedContent, x);\n+        if (_transformedContent != null && !_transformedContent.isSpecial())\n+        {\n+            if (_transformedContent != _rawContent)\n+            {\n+                _transformedContent.skip(_transformedContent.remaining());\n+                _transformedContent.failed(x);\n+            }\n+            _transformedContent = null;\n+        }\n+\n+        if (_rawContent != null && !_rawContent.isSpecial())\n+        {\n+            _rawContent.skip(_rawContent.remaining());\n+            _rawContent.failed(x);\n+            _rawContent = null;\n+        }\n+    }\n+\n+    @Override\n+    public boolean onContentProducible()\n+    {\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"onContentProducible\");\n+        return _httpChannel.getState().onReadReady();\n+    }\n+\n+    @Override\n+    public HttpInput.Content nextContent()\n+    {\n+        HttpInput.Content content = nextTransformedContent();\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"nextContent = {}\", content);\n+        if (content != null)\n+            _httpChannel.getState().onReadIdle();\n+        return content;\n+    }\n+\n+    @Override\n+    public void reclaim(HttpInput.Content content)\n+    {\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"reclaim {} [t={}]\", content, _transformedContent);\n+        if (_transformedContent == content)\n+        {\n+            content.succeeded();\n+            if (_transformedContent == _rawContent)\n+                _rawContent = null;\n+            _transformedContent = null;\n+        }\n+    }\n+\n+    @Override\n+    public boolean isReady()\n+    {\n+        HttpInput.Content content = nextTransformedContent();\n+        if (content == null)\n+        {\n+            _httpChannel.getState().onReadUnready();\n+            if (_httpChannel.needContent())\n+            {\n+                content = nextTransformedContent();\n+                if (LOG.isDebugEnabled())\n+                    LOG.debug(\"isReady got transformed content after needContent retry {}\", content);\n+                if (content != null)\n+                    _httpChannel.getState().onContentAdded();\n+            }\n+            else\n+            {\n+                if (LOG.isDebugEnabled())\n+                    LOG.debug(\"isReady has no transformed content after needContent\");\n+            }\n+        }\n+        else\n+        {\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"isReady got transformed content {}\", content);\n+            _httpChannel.getState().onContentAdded();\n+        }\n+        boolean ready = content != null;\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"isReady = {}\", ready);\n+        return ready;\n+    }\n+\n+    private HttpInput.Content nextTransformedContent()\n+    {\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"nextTransformedContent [r={},t={}]\", _rawContent, _transformedContent);\n+        if (_rawContent == null)\n+        {\n+            _rawContent = produceRawContent();\n+            if (_rawContent == null)\n+                return null;\n+        }\n+\n+        if (_transformedContent != null && _transformedContent.isEmpty())\n+        {\n+            if (_transformedContent != _rawContent)\n+                _transformedContent.succeeded();\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"nulling depleted transformed content\");\n+            _transformedContent = null;\n+        }\n+\n+        while (_transformedContent == null)\n+        {\n+            if (_rawContent.isSpecial())\n+            {\n+                _error = _rawContent.getError() != null;\n+                if (LOG.isDebugEnabled())\n+                    LOG.debug(\"raw content is special (with error = {}), returning it\", _error);\n+                return _rawContent;", "originalCommit": "cba85b58aee7b8969746dc37619749d4b4874f36", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjc2NjUzMw==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r516766533", "bodyText": "Our one interceptor does not need this, but I think it is needed in general.  So let's not make it a show stopper, but can you add a TODO and open a new issue.", "author": "gregw", "createdAt": "2020-11-03T15:46:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjUwOTg1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjc3OTQzMA==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r516779430", "bodyText": "I added a todo about this, let's move that out of this PR.", "author": "lorban", "createdAt": "2020-11-03T16:03:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjUwOTg1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjU5Njg0Nw==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r516596847", "bodyText": "I think it's entirely possible that an application does not want to read the content, so we should not throw here.", "author": "sbordet", "createdAt": "2020-11-03T11:25:46Z", "path": "jetty-fcgi/fcgi-server/src/main/java/org/eclipse/jetty/fcgi/server/HttpChannelOverFCGI.java", "diffHunk": "@@ -127,12 +231,46 @@ protected void dispatch()\n \n     public boolean onIdleTimeout(Throwable timeout)\n     {\n-        boolean handle = getRequest().getHttpInput().onIdleTimeout(timeout);\n+        boolean handle = doOnIdleTimeout(timeout);\n         if (handle)\n             execute(this);\n         return !handle;\n     }\n \n+    private boolean doOnIdleTimeout(Throwable x)\n+    {\n+        boolean neverDispatched = getState().isIdle();\n+        boolean waitingForContent;\n+        HttpInput.Content specialContent;\n+        try (AutoLock l = _lock.lock())\n+        {\n+            waitingForContent = _contentQueue.isEmpty() || _contentQueue.peek().remaining() == 0;\n+            specialContent = _specialContent;\n+        }\n+        if ((waitingForContent || neverDispatched) && specialContent == null)\n+        {\n+            x.addSuppressed(new Throwable(\"HttpInput idle timeout\"));\n+            try (AutoLock l = _lock.lock())\n+            {\n+                _specialContent = new HttpInput.ErrorContent(x);\n+            }\n+            return getRequest().getHttpInput().onContentProducible();\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public void recycle()\n+    {\n+        try (AutoLock l = _lock.lock())\n+        {\n+            if (!_contentQueue.isEmpty())\n+                throw new AssertionError(\"unconsumed content: \" + _contentQueue);", "originalCommit": "cba85b58aee7b8969746dc37619749d4b4874f36", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjc5MzE2NQ==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r516793165", "bodyText": "As discussed, this is safe in recycle.", "author": "lorban", "createdAt": "2020-11-03T16:23:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjU5Njg0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjU5OTcyOA==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r516599728", "bodyText": "Isn't it possible that there is unconsumed content?", "author": "sbordet", "createdAt": "2020-11-03T11:31:12Z", "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpChannelOverHTTP2.java", "diffHunk": "@@ -286,6 +297,345 @@ public InvocationType getInvocationType()\n         return handle || wasDelayed ? this : null;\n     }\n \n+    /**\n+     * Demanding content is a marker content that is used to remember that a demand was\n+     * registered into the stream. The {@code needed} flag indicates if the demand originated\n+     * from a call to {@link #produceContent()} when false or {@link #needContent()}\n+     * when true, as {@link HttpInput#onContentProducible()} must only be called\n+     * only when {@link #needContent()} was called.\n+     * Instances of this class must never escape the scope of this channel impl,\n+     * so {@link #produceContent()} must never return one.\n+     */\n+    private static final class DemandingContent extends HttpInput.SpecialContent\n+    {\n+        private final boolean needed;\n+\n+        private DemandingContent(boolean needed)\n+        {\n+            this.needed = needed;\n+        }\n+    }\n+\n+    private static final HttpInput.Content EOF = new HttpInput.EofContent();\n+    private static final HttpInput.Content DEMANDING_NEEDED = new DemandingContent(true);\n+    private static final HttpInput.Content DEMANDING_NOT_NEEDED = new DemandingContent(false);\n+\n+    private class ContentDemander\n+    {\n+        private final AtomicReference<HttpInput.Content> _content = new AtomicReference<>();\n+\n+        public void recycle()\n+        {\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"recycle {}\", this);\n+            HttpInput.Content c = _content.getAndSet(null);\n+            if (c != null && !c.isSpecial())\n+                throw new AssertionError(\"unconsumed content: \" + c);", "originalCommit": "cba85b58aee7b8969746dc37619749d4b4874f36", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjc5MjgxOQ==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r516792819", "bodyText": "As discussed, this is safe in recycle.", "author": "lorban", "createdAt": "2020-11-03T16:22:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjU5OTcyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjYxMDI5Ng==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r516610296", "bodyText": "Cannot throw.", "author": "sbordet", "createdAt": "2020-11-03T11:51:10Z", "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpChannelOverHTTP2.java", "diffHunk": "@@ -286,6 +297,345 @@ public InvocationType getInvocationType()\n         return handle || wasDelayed ? this : null;\n     }\n \n+    /**\n+     * Demanding content is a marker content that is used to remember that a demand was\n+     * registered into the stream. The {@code needed} flag indicates if the demand originated\n+     * from a call to {@link #produceContent()} when false or {@link #needContent()}\n+     * when true, as {@link HttpInput#onContentProducible()} must only be called\n+     * only when {@link #needContent()} was called.\n+     * Instances of this class must never escape the scope of this channel impl,\n+     * so {@link #produceContent()} must never return one.\n+     */\n+    private static final class DemandingContent extends HttpInput.SpecialContent\n+    {\n+        private final boolean needed;\n+\n+        private DemandingContent(boolean needed)\n+        {\n+            this.needed = needed;\n+        }\n+    }\n+\n+    private static final HttpInput.Content EOF = new HttpInput.EofContent();\n+    private static final HttpInput.Content DEMANDING_NEEDED = new DemandingContent(true);\n+    private static final HttpInput.Content DEMANDING_NOT_NEEDED = new DemandingContent(false);\n+\n+    private class ContentDemander\n+    {\n+        private final AtomicReference<HttpInput.Content> _content = new AtomicReference<>();\n+\n+        public void recycle()\n+        {\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"recycle {}\", this);\n+            HttpInput.Content c = _content.getAndSet(null);\n+            if (c != null && !c.isSpecial())\n+                throw new AssertionError(\"unconsumed content: \" + c);\n+        }\n+\n+        public HttpInput.Content poll()\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (LOG.isDebugEnabled())\n+                    LOG.debug(\"poll, content = {}\", c);\n+                if (c == null || c.isSpecial() || _content.compareAndSet(c, c.isEof() ? EOF : null))\n+                {\n+                    if (LOG.isDebugEnabled())\n+                        LOG.debug(\"returning current content\");\n+                    return c;\n+                }\n+            }\n+        }\n+\n+        public boolean demand(boolean needed)\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (LOG.isDebugEnabled())\n+                    LOG.debug(\"demand({}), content = {}\", needed, c);\n+                if (c instanceof DemandingContent)\n+                {\n+                    if (needed && !((DemandingContent)c).needed)\n+                    {\n+                        if (!_content.compareAndSet(c, DEMANDING_NEEDED))\n+                        {\n+                            if (LOG.isDebugEnabled())\n+                                LOG.debug(\"already demanding but switched needed flag to true\");\n+                            continue;\n+                        }\n+                    }\n+                    if (LOG.isDebugEnabled())\n+                        LOG.debug(\"already demanding, returning false\");\n+                    return false;\n+                }\n+                if (c != null)\n+                {\n+                    if (LOG.isDebugEnabled())\n+                        LOG.debug(\"content available, returning true\");\n+                    return true;\n+                }\n+                if (_content.compareAndSet(null, needed ? DEMANDING_NEEDED : DEMANDING_NOT_NEEDED))\n+                {\n+                    IStream stream = getStream();\n+                    if (stream == null)\n+                    {\n+                        _content.set(null);\n+                        if (LOG.isDebugEnabled())\n+                            LOG.debug(\"no content available, switched to demanding but stream is now null\");\n+                        return false;\n+                    }\n+                    if (LOG.isDebugEnabled())\n+                        LOG.debug(\"no content available, demanding stream {}\", stream);\n+                    stream.demand(1);\n+                    c = _content.get();\n+                    boolean hasContent = !(c instanceof DemandingContent) && c != null;\n+                    if (LOG.isDebugEnabled())\n+                        LOG.debug(\"has content now? {}\", hasContent);\n+                    return hasContent;\n+                }\n+            }\n+        }\n+\n+        public boolean onContent(HttpInput.Content content)\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (LOG.isDebugEnabled())\n+                    LOG.debug(\"content delivered by stream: {}, current content: {}\", content, c);\n+                if (c instanceof DemandingContent)\n+                {\n+                    if (_content.compareAndSet(c, content))\n+                    {\n+                        boolean needed = ((DemandingContent)c).needed;\n+                        if (LOG.isDebugEnabled())\n+                            LOG.debug(\"replacing demand content with {} succeeded; returning {}\", content, needed);\n+                        return needed;\n+                    }\n+                }\n+                else if (c == null)\n+                {\n+                    if (!content.isSpecial())\n+                        throw new AssertionError(\"Non special content without demand\");\n+                    if (_content.compareAndSet(null, content))\n+                    {\n+                        if (LOG.isDebugEnabled())\n+                            LOG.debug(\"replacing null content with {} succeeded\", content);\n+                        return false;\n+                    }\n+                }\n+                else if (c.isEof() && content.isEof() && content.isEmpty())\n+                {\n+                    content.succeeded();\n+                    return true;\n+                }\n+                else if (content.getError() != null)\n+                {\n+                    if (c.getError() != null)\n+                    {\n+                        if (c.getError() != content.getError())\n+                            c.getError().addSuppressed(content.getError());\n+                        return true;\n+                    }\n+                    if (_content.compareAndSet(c, content))\n+                    {\n+                        c.failed(content.getError());\n+                        if (LOG.isDebugEnabled())\n+                            LOG.debug(\"replacing current content with {} succeeded\", content);\n+                        return true;\n+                    }\n+                }\n+                else if (c.getError() != null && content.remaining() == 0)\n+                {\n+                    content.succeeded();\n+                    return true;\n+                }\n+                else\n+                {\n+                    throw new AssertionError(\"Cannot overwrite exiting content \" + c + \" with \" + content);", "originalCommit": "cba85b58aee7b8969746dc37619749d4b4874f36", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjc5NTU1NQ==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r516795555", "bodyText": "Ok, changed.", "author": "lorban", "createdAt": "2020-11-03T16:26:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjYxMDI5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjYxMjMwNw==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r516612307", "bodyText": "I don't think this is right, because we replace a valid content with EOF, but we don't complete the existing content, right?\nWe must call succeeded() or failed(Throwable) on c, but if we remove it from here, who will have a reference to it to complete it?", "author": "sbordet", "createdAt": "2020-11-03T11:55:06Z", "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpChannelOverHTTP2.java", "diffHunk": "@@ -286,6 +297,345 @@ public InvocationType getInvocationType()\n         return handle || wasDelayed ? this : null;\n     }\n \n+    /**\n+     * Demanding content is a marker content that is used to remember that a demand was\n+     * registered into the stream. The {@code needed} flag indicates if the demand originated\n+     * from a call to {@link #produceContent()} when false or {@link #needContent()}\n+     * when true, as {@link HttpInput#onContentProducible()} must only be called\n+     * only when {@link #needContent()} was called.\n+     * Instances of this class must never escape the scope of this channel impl,\n+     * so {@link #produceContent()} must never return one.\n+     */\n+    private static final class DemandingContent extends HttpInput.SpecialContent\n+    {\n+        private final boolean needed;\n+\n+        private DemandingContent(boolean needed)\n+        {\n+            this.needed = needed;\n+        }\n+    }\n+\n+    private static final HttpInput.Content EOF = new HttpInput.EofContent();\n+    private static final HttpInput.Content DEMANDING_NEEDED = new DemandingContent(true);\n+    private static final HttpInput.Content DEMANDING_NOT_NEEDED = new DemandingContent(false);\n+\n+    private class ContentDemander\n+    {\n+        private final AtomicReference<HttpInput.Content> _content = new AtomicReference<>();\n+\n+        public void recycle()\n+        {\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"recycle {}\", this);\n+            HttpInput.Content c = _content.getAndSet(null);\n+            if (c != null && !c.isSpecial())\n+                throw new AssertionError(\"unconsumed content: \" + c);\n+        }\n+\n+        public HttpInput.Content poll()\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (LOG.isDebugEnabled())\n+                    LOG.debug(\"poll, content = {}\", c);\n+                if (c == null || c.isSpecial() || _content.compareAndSet(c, c.isEof() ? EOF : null))\n+                {\n+                    if (LOG.isDebugEnabled())\n+                        LOG.debug(\"returning current content\");\n+                    return c;\n+                }\n+            }\n+        }\n+\n+        public boolean demand(boolean needed)\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (LOG.isDebugEnabled())\n+                    LOG.debug(\"demand({}), content = {}\", needed, c);\n+                if (c instanceof DemandingContent)\n+                {\n+                    if (needed && !((DemandingContent)c).needed)\n+                    {\n+                        if (!_content.compareAndSet(c, DEMANDING_NEEDED))\n+                        {\n+                            if (LOG.isDebugEnabled())\n+                                LOG.debug(\"already demanding but switched needed flag to true\");\n+                            continue;\n+                        }\n+                    }\n+                    if (LOG.isDebugEnabled())\n+                        LOG.debug(\"already demanding, returning false\");\n+                    return false;\n+                }\n+                if (c != null)\n+                {\n+                    if (LOG.isDebugEnabled())\n+                        LOG.debug(\"content available, returning true\");\n+                    return true;\n+                }\n+                if (_content.compareAndSet(null, needed ? DEMANDING_NEEDED : DEMANDING_NOT_NEEDED))\n+                {\n+                    IStream stream = getStream();\n+                    if (stream == null)\n+                    {\n+                        _content.set(null);\n+                        if (LOG.isDebugEnabled())\n+                            LOG.debug(\"no content available, switched to demanding but stream is now null\");\n+                        return false;\n+                    }\n+                    if (LOG.isDebugEnabled())\n+                        LOG.debug(\"no content available, demanding stream {}\", stream);\n+                    stream.demand(1);\n+                    c = _content.get();\n+                    boolean hasContent = !(c instanceof DemandingContent) && c != null;\n+                    if (LOG.isDebugEnabled())\n+                        LOG.debug(\"has content now? {}\", hasContent);\n+                    return hasContent;\n+                }\n+            }\n+        }\n+\n+        public boolean onContent(HttpInput.Content content)\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (LOG.isDebugEnabled())\n+                    LOG.debug(\"content delivered by stream: {}, current content: {}\", content, c);\n+                if (c instanceof DemandingContent)\n+                {\n+                    if (_content.compareAndSet(c, content))\n+                    {\n+                        boolean needed = ((DemandingContent)c).needed;\n+                        if (LOG.isDebugEnabled())\n+                            LOG.debug(\"replacing demand content with {} succeeded; returning {}\", content, needed);\n+                        return needed;\n+                    }\n+                }\n+                else if (c == null)\n+                {\n+                    if (!content.isSpecial())\n+                        throw new AssertionError(\"Non special content without demand\");\n+                    if (_content.compareAndSet(null, content))\n+                    {\n+                        if (LOG.isDebugEnabled())\n+                            LOG.debug(\"replacing null content with {} succeeded\", content);\n+                        return false;\n+                    }\n+                }\n+                else if (c.isEof() && content.isEof() && content.isEmpty())\n+                {\n+                    content.succeeded();\n+                    return true;\n+                }\n+                else if (content.getError() != null)\n+                {\n+                    if (c.getError() != null)\n+                    {\n+                        if (c.getError() != content.getError())\n+                            c.getError().addSuppressed(content.getError());\n+                        return true;\n+                    }\n+                    if (_content.compareAndSet(c, content))\n+                    {\n+                        c.failed(content.getError());\n+                        if (LOG.isDebugEnabled())\n+                            LOG.debug(\"replacing current content with {} succeeded\", content);\n+                        return true;\n+                    }\n+                }\n+                else if (c.getError() != null && content.remaining() == 0)\n+                {\n+                    content.succeeded();\n+                    return true;\n+                }\n+                else\n+                {\n+                    throw new AssertionError(\"Cannot overwrite exiting content \" + c + \" with \" + content);\n+                }\n+            }\n+        }\n+\n+        public boolean onTimeout(Throwable failure)\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (LOG.isDebugEnabled())\n+                    LOG.debug(\"onTimeout with current content: {} and failure = {}\", c, failure);\n+                if (!(c instanceof DemandingContent))\n+                    return false;\n+                if (_content.compareAndSet(c, new HttpInput.ErrorContent(failure)))\n+                {\n+                    if (LOG.isDebugEnabled())\n+                        LOG.debug(\"replacing current content with error succeeded\");\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        public void eof()\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (LOG.isDebugEnabled())\n+                    LOG.debug(\"eof with current content: {}\", c);\n+                if (c instanceof DemandingContent)\n+                {\n+                    if (_content.compareAndSet(c, EOF))\n+                    {\n+                        if (LOG.isDebugEnabled())\n+                            LOG.debug(\"replacing current content with special EOF succeeded\");\n+                        return;\n+                    }\n+                }\n+                else if (c == null)\n+                {\n+                    if (_content.compareAndSet(null, EOF))\n+                    {\n+                        if (LOG.isDebugEnabled())\n+                            LOG.debug(\"replacing null content with special EOF succeeded\");\n+                        return;\n+                    }\n+                }\n+                else if (c.isEof())\n+                {\n+                    if (LOG.isDebugEnabled())\n+                        LOG.debug(\"current content already is EOF\");\n+                    return;\n+                }\n+                else if (c.remaining() == 0)\n+                {\n+                    if (_content.compareAndSet(c, EOF))\n+                    {\n+                        if (LOG.isDebugEnabled())\n+                            LOG.debug(\"replacing current content with special EOF succeeded\");\n+                        return;\n+                    }", "originalCommit": "cba85b58aee7b8969746dc37619749d4b4874f36", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjc1MTg4Mw==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r516751883", "bodyText": "After discussion I now get the meaning of this code.", "author": "sbordet", "createdAt": "2020-11-03T15:27:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjYxMjMwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjYyNDc0Mg==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r516624742", "bodyText": "Improve the comment to:\n\"EOF may arrive with HEADERS frame (e.g. a trailer) that is not flow controlled, so we need to wrap the existing content.\"", "author": "sbordet", "createdAt": "2020-11-03T12:18:38Z", "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpChannelOverHTTP2.java", "diffHunk": "@@ -286,6 +297,345 @@ public InvocationType getInvocationType()\n         return handle || wasDelayed ? this : null;\n     }\n \n+    /**\n+     * Demanding content is a marker content that is used to remember that a demand was\n+     * registered into the stream. The {@code needed} flag indicates if the demand originated\n+     * from a call to {@link #produceContent()} when false or {@link #needContent()}\n+     * when true, as {@link HttpInput#onContentProducible()} must only be called\n+     * only when {@link #needContent()} was called.\n+     * Instances of this class must never escape the scope of this channel impl,\n+     * so {@link #produceContent()} must never return one.\n+     */\n+    private static final class DemandingContent extends HttpInput.SpecialContent\n+    {\n+        private final boolean needed;\n+\n+        private DemandingContent(boolean needed)\n+        {\n+            this.needed = needed;\n+        }\n+    }\n+\n+    private static final HttpInput.Content EOF = new HttpInput.EofContent();\n+    private static final HttpInput.Content DEMANDING_NEEDED = new DemandingContent(true);\n+    private static final HttpInput.Content DEMANDING_NOT_NEEDED = new DemandingContent(false);\n+\n+    private class ContentDemander\n+    {\n+        private final AtomicReference<HttpInput.Content> _content = new AtomicReference<>();\n+\n+        public void recycle()\n+        {\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"recycle {}\", this);\n+            HttpInput.Content c = _content.getAndSet(null);\n+            if (c != null && !c.isSpecial())\n+                throw new AssertionError(\"unconsumed content: \" + c);\n+        }\n+\n+        public HttpInput.Content poll()\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (LOG.isDebugEnabled())\n+                    LOG.debug(\"poll, content = {}\", c);\n+                if (c == null || c.isSpecial() || _content.compareAndSet(c, c.isEof() ? EOF : null))\n+                {\n+                    if (LOG.isDebugEnabled())\n+                        LOG.debug(\"returning current content\");\n+                    return c;\n+                }\n+            }\n+        }\n+\n+        public boolean demand(boolean needed)\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (LOG.isDebugEnabled())\n+                    LOG.debug(\"demand({}), content = {}\", needed, c);\n+                if (c instanceof DemandingContent)\n+                {\n+                    if (needed && !((DemandingContent)c).needed)\n+                    {\n+                        if (!_content.compareAndSet(c, DEMANDING_NEEDED))\n+                        {\n+                            if (LOG.isDebugEnabled())\n+                                LOG.debug(\"already demanding but switched needed flag to true\");\n+                            continue;\n+                        }\n+                    }\n+                    if (LOG.isDebugEnabled())\n+                        LOG.debug(\"already demanding, returning false\");\n+                    return false;\n+                }\n+                if (c != null)\n+                {\n+                    if (LOG.isDebugEnabled())\n+                        LOG.debug(\"content available, returning true\");\n+                    return true;\n+                }\n+                if (_content.compareAndSet(null, needed ? DEMANDING_NEEDED : DEMANDING_NOT_NEEDED))\n+                {\n+                    IStream stream = getStream();\n+                    if (stream == null)\n+                    {\n+                        _content.set(null);\n+                        if (LOG.isDebugEnabled())\n+                            LOG.debug(\"no content available, switched to demanding but stream is now null\");\n+                        return false;\n+                    }\n+                    if (LOG.isDebugEnabled())\n+                        LOG.debug(\"no content available, demanding stream {}\", stream);\n+                    stream.demand(1);\n+                    c = _content.get();\n+                    boolean hasContent = !(c instanceof DemandingContent) && c != null;\n+                    if (LOG.isDebugEnabled())\n+                        LOG.debug(\"has content now? {}\", hasContent);\n+                    return hasContent;\n+                }\n+            }\n+        }\n+\n+        public boolean onContent(HttpInput.Content content)\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (LOG.isDebugEnabled())\n+                    LOG.debug(\"content delivered by stream: {}, current content: {}\", content, c);\n+                if (c instanceof DemandingContent)\n+                {\n+                    if (_content.compareAndSet(c, content))\n+                    {\n+                        boolean needed = ((DemandingContent)c).needed;\n+                        if (LOG.isDebugEnabled())\n+                            LOG.debug(\"replacing demand content with {} succeeded; returning {}\", content, needed);\n+                        return needed;\n+                    }\n+                }\n+                else if (c == null)\n+                {\n+                    if (!content.isSpecial())\n+                        throw new AssertionError(\"Non special content without demand\");\n+                    if (_content.compareAndSet(null, content))\n+                    {\n+                        if (LOG.isDebugEnabled())\n+                            LOG.debug(\"replacing null content with {} succeeded\", content);\n+                        return false;\n+                    }\n+                }\n+                else if (c.isEof() && content.isEof() && content.isEmpty())\n+                {\n+                    content.succeeded();\n+                    return true;\n+                }\n+                else if (content.getError() != null)\n+                {\n+                    if (c.getError() != null)\n+                    {\n+                        if (c.getError() != content.getError())\n+                            c.getError().addSuppressed(content.getError());\n+                        return true;\n+                    }\n+                    if (_content.compareAndSet(c, content))\n+                    {\n+                        c.failed(content.getError());\n+                        if (LOG.isDebugEnabled())\n+                            LOG.debug(\"replacing current content with {} succeeded\", content);\n+                        return true;\n+                    }\n+                }\n+                else if (c.getError() != null && content.remaining() == 0)\n+                {\n+                    content.succeeded();\n+                    return true;\n+                }\n+                else\n+                {\n+                    throw new AssertionError(\"Cannot overwrite exiting content \" + c + \" with \" + content);\n+                }\n+            }\n+        }\n+\n+        public boolean onTimeout(Throwable failure)\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (LOG.isDebugEnabled())\n+                    LOG.debug(\"onTimeout with current content: {} and failure = {}\", c, failure);\n+                if (!(c instanceof DemandingContent))\n+                    return false;\n+                if (_content.compareAndSet(c, new HttpInput.ErrorContent(failure)))\n+                {\n+                    if (LOG.isDebugEnabled())\n+                        LOG.debug(\"replacing current content with error succeeded\");\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        public void eof()\n+        {\n+            while (true)\n+            {\n+                HttpInput.Content c = _content.get();\n+                if (LOG.isDebugEnabled())\n+                    LOG.debug(\"eof with current content: {}\", c);\n+                if (c instanceof DemandingContent)\n+                {\n+                    if (_content.compareAndSet(c, EOF))\n+                    {\n+                        if (LOG.isDebugEnabled())\n+                            LOG.debug(\"replacing current content with special EOF succeeded\");\n+                        return;\n+                    }\n+                }\n+                else if (c == null)\n+                {\n+                    if (_content.compareAndSet(null, EOF))\n+                    {\n+                        if (LOG.isDebugEnabled())\n+                            LOG.debug(\"replacing null content with special EOF succeeded\");\n+                        return;\n+                    }\n+                }\n+                else if (c.isEof())\n+                {\n+                    if (LOG.isDebugEnabled())\n+                        LOG.debug(\"current content already is EOF\");\n+                    return;\n+                }\n+                else if (c.remaining() == 0)\n+                {\n+                    if (_content.compareAndSet(c, EOF))\n+                    {\n+                        if (LOG.isDebugEnabled())\n+                            LOG.debug(\"replacing current content with special EOF succeeded\");\n+                        return;\n+                    }\n+                }\n+                else\n+                {\n+                    // onTrailer() needs this branch,\n+                    // covered by HttpTrailersTest.testRequestTrailersWithContent.", "originalCommit": "cba85b58aee7b8969746dc37619749d4b4874f36", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjc4MDQyNg==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r516780426", "bodyText": "Done.", "author": "lorban", "createdAt": "2020-11-03T16:05:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjYyNDc0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjY4NjY1Ng==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r516686656", "bodyText": "Fix end of sentence.", "author": "sbordet", "createdAt": "2020-11-03T14:01:24Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/AsyncContentProducer.java", "diffHunk": "@@ -0,0 +1,352 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jetty.http.BadMessageException;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Non-blocking {@link ContentProducer} implementation. Calling {@link #nextContent()} will never block\n+ * but will return null when there is no available content but will never return block.", "originalCommit": "cba85b58aee7b8969746dc37619749d4b4874f36", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjc4MTUwOA==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r516781508", "bodyText": "Done.", "author": "lorban", "createdAt": "2020-11-03T16:06:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjY4NjY1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjY4ODAxNA==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r516688014", "bodyText": "Javadocs.", "author": "sbordet", "createdAt": "2020-11-03T14:03:22Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpChannel.java", "diffHunk": "@@ -729,11 +733,15 @@ public boolean onRequestComplete()\n     {\n         if (LOG.isDebugEnabled())\n             LOG.debug(\"onRequestComplete {}\", this);\n-        boolean result = _request.getHttpInput().eof();\n+        boolean result = eof();\n         _combinedListener.onRequestEnd(_request);\n         return result;\n     }\n \n+    public abstract boolean failed(Throwable x);\n+\n+    protected abstract boolean eof();", "originalCommit": "cba85b58aee7b8969746dc37619749d4b4874f36", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjc4Nzk5Mg==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r516787992", "bodyText": "Done.", "author": "lorban", "createdAt": "2020-11-03T16:15:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjY4ODAxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjY5NDk2Mw==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r516694963", "bodyText": "Both HTTP/2 and HTTP/1.1 wrap an existing content, so it's worth having a proper wrapper class with the ability to specify eof, rather than anonymous classes -- they will also print better when DEBUG is enabled.", "author": "sbordet", "createdAt": "2020-11-03T14:12:47Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpChannelOverHttp.java", "diffHunk": "@@ -147,12 +241,94 @@ public void earlyEOF()\n         _httpConnection.getGenerator().setPersistent(false);\n         // If we have no request yet, just close\n         if (_metadata == null)\n+        {\n             _httpConnection.close();\n-        else if (onEarlyEOF() || _delayedForContent)\n+        }\n+        else\n         {\n-            _delayedForContent = false;\n-            handle();\n+            markEarlyEOF();\n+            if (_delayedForContent)\n+            {\n+                _delayedForContent = false;\n+                handle();\n+            }\n+        }\n+    }\n+\n+    private void markEarlyEOF()\n+    {\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"received early EOF, content = {}\", _content);\n+        EofException failure = new EofException(\"Early EOF\");\n+        if (_content != null)\n+            _content.failed(failure);\n+        _content = new HttpInput.ErrorContent(failure);\n+    }\n+\n+    @Override\n+    protected boolean eof()\n+    {\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"received EOF, content = {}\", _content);\n+        if (_content == null)\n+        {\n+            _content = EOF;\n+        }\n+        else\n+        {\n+            HttpInput.Content c = _content;\n+            _content = new HttpInput.Content(c.getByteBuffer())", "originalCommit": "cba85b58aee7b8969746dc37619749d4b4874f36", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjc5MjM5OQ==", "url": "https://github.com/eclipse/jetty.project/pull/4556#discussion_r516792399", "bodyText": "Done.", "author": "lorban", "createdAt": "2020-11-03T16:22:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjY5NDk2Mw=="}], "type": "inlineReview"}, {"oid": "07c26e66b1ea4a73933b54052a1b4501dbae11b8", "url": "https://github.com/eclipse/jetty.project/commit/07c26e66b1ea4a73933b54052a1b4501dbae11b8", "message": "Get rid of addContent() by making produceContent() return Content instead.\nMake EOF and errors be special content.\nTransition to a much simplified FSM by using the needContent() / produceContent() model.\nImplement blocking on top of async, this way there is only one FSM.\n(Milestone 7)\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-11-03T14:20:15Z", "type": "forcePushed"}, {"oid": "5a24c8dd174689b194e656b282242debc8e5e3bb", "url": "https://github.com/eclipse/jetty.project/commit/5a24c8dd174689b194e656b282242debc8e5e3bb", "message": "HTTP and FCGI pass all tests (Milestone 1)\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-11-03T16:30:24Z", "type": "commit"}, {"oid": "946f334810cf58cdca34513d69c059e1119188e3", "url": "https://github.com/eclipse/jetty.project/commit/946f334810cf58cdca34513d69c059e1119188e3", "message": "http2 impl (Milestone 2)\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-11-03T16:30:25Z", "type": "commit"}]}