{"pr_number": 5144, "pr_title": "Jetty 9.4.x 5104 incorrect via header", "pr_createdAt": "2020-08-12T22:10:05Z", "pr_url": "https://github.com/eclipse/jetty.project/pull/5144", "timeline": [{"oid": "b2ab05c44a3454f653a53da786dfc289c7e980bc", "url": "https://github.com/eclipse/jetty.project/commit/b2ab05c44a3454f653a53da786dfc289c7e980bc", "message": "Issue #5104 - Fix protocol version in Via header to work with H2 and other protocols\n\nSigned-off-by: Travis Spencer <travis@curity.io>", "committedDate": "2020-08-12T14:55:34Z", "type": "commit"}, {"oid": "79d340fdb6202a5dbcd9e980a48718de44672a39", "url": "https://github.com/eclipse/jetty.project/commit/79d340fdb6202a5dbcd9e980a48718de44672a39", "message": "Fixes #5104 - AbstractProxyServlet include incorrect protocol version in Via header when accessed over H2.\n\n* Introduced HttpFields.computeField() to put/append header values.\n* Reworked AbstractProxyServlet.addViaHeader().\n\nSigned-off-by: Simone Bordet <simone.bordet@gmail.com>", "committedDate": "2020-08-12T22:08:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc1NDg5MQ==", "url": "https://github.com/eclipse/jetty.project/pull/5144#discussion_r469754891", "bodyText": "I'm not keen on this implementation as for the common cases it will create a bit more garbage than necessary. However I don't really want to hold up this PR any more, so perhaps I'll do a different PR to improve this implementation.... and look at using it in other places.", "author": "gregw", "createdAt": "2020-08-13T07:35:50Z", "path": "jetty-http/src/main/java/org/eclipse/jetty/http/HttpFields.java", "diffHunk": "@@ -88,6 +89,115 @@ public HttpFields(HttpFields fields)\n         _size = fields._size;\n     }\n \n+    /**\n+     * <p>Computes a single field for the given HTTP header name and for existing fields with the same name.</p>\n+     *\n+     * <p>The compute function receives the field name and a list of fields with the same name\n+     * so that their values can be used to compute the value of the field that is returned\n+     * by the compute function.\n+     * If the compute function returns {@code null}, the fields with the given name are removed.</p>\n+     * <p>This method comes handy when you want to add an HTTP header if it does not exist,\n+     * or add a value if the HTTP header already exists, similarly to\n+     * {@link Map#compute(Object, BiFunction)}.</p>\n+     *\n+     * <p>This method can be used to {@link #put(HttpField) put} a new field (or blindly replace its value):</p>\n+     * <pre>\n+     * httpFields.computeField(\"X-New-Header\",\n+     *     (name, fields) -> new HttpField(name, \"NewValue\"));\n+     * </pre>\n+     *\n+     * <p>This method can be used to coalesce many fields into one:</p>\n+     * <pre>\n+     * // Input:\n+     * GET / HTTP/1.1\n+     * Host: localhost\n+     * Cookie: foo=1\n+     * Cookie: bar=2,baz=3\n+     * User-Agent: Jetty\n+     *\n+     * // Computation:\n+     * httpFields.computeField(\"Cookie\", (name, fields) ->\n+     * {\n+     *     // No cookies, nothing to do.\n+     *     if (fields == null)\n+     *         return null;\n+     *\n+     *     // Coalesces all cookies.\n+     *     String coalesced = fields.stream()\n+     *         .flatMap(field -> Stream.of(field.getValues()))\n+     *         .collect(Collectors.joining(\", \"));\n+     *\n+     *     // Returns a single Cookie header with all cookies.\n+     *     return new HttpField(name, coalesced);\n+     * }\n+     *\n+     * // Output:\n+     * GET / HTTP/1.1\n+     * Host: localhost\n+     * Cookie: foo=1, bar=2, baz=3\n+     * User-Agent: Jetty\n+     * </pre>\n+     *\n+     * <p>This method can be used to replace a field:</p>\n+     * <pre>\n+     * httpFields.computeField(\"X-Length\", (name, fields) ->\n+     * {\n+     *     if (fields == null)\n+     *         return null;\n+     *\n+     *     // Get any value among the X-Length headers.\n+     *     String length = fields.stream()\n+     *         .map(HttpField::getValue)\n+     *         .findAny()\n+     *         .orElse(\"0\");\n+     *\n+     *     // Replace X-Length headers with X-Capacity header.\n+     *     return new HttpField(\"X-Capacity\", length);\n+     * });\n+     * </pre>\n+     *\n+     * <p>This method can be used to remove a field:</p>\n+     * <pre>\n+     * httpFields.computeField(\"Connection\", (name, fields) -> null);\n+     * </pre>\n+     *\n+     * @param name the HTTP header name\n+     * @param computeFn the compute function\n+     */\n+    public void computeField(String name, BiFunction<String, List<HttpField>, HttpField> computeFn)\n+    {\n+        boolean found = false;\n+        ListIterator<HttpField> iterator = listIterator();\n+        while (iterator.hasNext())\n+        {\n+            HttpField field = iterator.next();\n+            if (field.getName().equalsIgnoreCase(name))\n+            {\n+                if (found)\n+                {\n+                    // Remove other headers with the same name, since\n+                    // we have computed one from all of them already.\n+                    iterator.remove();\n+                }\n+                else\n+                {\n+                    found = true;\n+                    HttpField newField = computeFn.apply(name, Collections.unmodifiableList(getFields(name)));", "originalCommit": "79d340fdb6202a5dbcd9e980a48718de44672a39", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc2MTgzMQ==", "url": "https://github.com/eclipse/jetty.project/pull/5144#discussion_r469761831", "bodyText": "working on a better impl... meanwhile use add here not put, as you have already iterated and discovered that it is not found.", "author": "gregw", "createdAt": "2020-08-13T07:49:16Z", "path": "jetty-http/src/main/java/org/eclipse/jetty/http/HttpFields.java", "diffHunk": "@@ -88,6 +89,115 @@ public HttpFields(HttpFields fields)\n         _size = fields._size;\n     }\n \n+    /**\n+     * <p>Computes a single field for the given HTTP header name and for existing fields with the same name.</p>\n+     *\n+     * <p>The compute function receives the field name and a list of fields with the same name\n+     * so that their values can be used to compute the value of the field that is returned\n+     * by the compute function.\n+     * If the compute function returns {@code null}, the fields with the given name are removed.</p>\n+     * <p>This method comes handy when you want to add an HTTP header if it does not exist,\n+     * or add a value if the HTTP header already exists, similarly to\n+     * {@link Map#compute(Object, BiFunction)}.</p>\n+     *\n+     * <p>This method can be used to {@link #put(HttpField) put} a new field (or blindly replace its value):</p>\n+     * <pre>\n+     * httpFields.computeField(\"X-New-Header\",\n+     *     (name, fields) -> new HttpField(name, \"NewValue\"));\n+     * </pre>\n+     *\n+     * <p>This method can be used to coalesce many fields into one:</p>\n+     * <pre>\n+     * // Input:\n+     * GET / HTTP/1.1\n+     * Host: localhost\n+     * Cookie: foo=1\n+     * Cookie: bar=2,baz=3\n+     * User-Agent: Jetty\n+     *\n+     * // Computation:\n+     * httpFields.computeField(\"Cookie\", (name, fields) ->\n+     * {\n+     *     // No cookies, nothing to do.\n+     *     if (fields == null)\n+     *         return null;\n+     *\n+     *     // Coalesces all cookies.\n+     *     String coalesced = fields.stream()\n+     *         .flatMap(field -> Stream.of(field.getValues()))\n+     *         .collect(Collectors.joining(\", \"));\n+     *\n+     *     // Returns a single Cookie header with all cookies.\n+     *     return new HttpField(name, coalesced);\n+     * }\n+     *\n+     * // Output:\n+     * GET / HTTP/1.1\n+     * Host: localhost\n+     * Cookie: foo=1, bar=2, baz=3\n+     * User-Agent: Jetty\n+     * </pre>\n+     *\n+     * <p>This method can be used to replace a field:</p>\n+     * <pre>\n+     * httpFields.computeField(\"X-Length\", (name, fields) ->\n+     * {\n+     *     if (fields == null)\n+     *         return null;\n+     *\n+     *     // Get any value among the X-Length headers.\n+     *     String length = fields.stream()\n+     *         .map(HttpField::getValue)\n+     *         .findAny()\n+     *         .orElse(\"0\");\n+     *\n+     *     // Replace X-Length headers with X-Capacity header.\n+     *     return new HttpField(\"X-Capacity\", length);\n+     * });\n+     * </pre>\n+     *\n+     * <p>This method can be used to remove a field:</p>\n+     * <pre>\n+     * httpFields.computeField(\"Connection\", (name, fields) -> null);\n+     * </pre>\n+     *\n+     * @param name the HTTP header name\n+     * @param computeFn the compute function\n+     */\n+    public void computeField(String name, BiFunction<String, List<HttpField>, HttpField> computeFn)\n+    {\n+        boolean found = false;\n+        ListIterator<HttpField> iterator = listIterator();\n+        while (iterator.hasNext())\n+        {\n+            HttpField field = iterator.next();\n+            if (field.getName().equalsIgnoreCase(name))\n+            {\n+                if (found)\n+                {\n+                    // Remove other headers with the same name, since\n+                    // we have computed one from all of them already.\n+                    iterator.remove();\n+                }\n+                else\n+                {\n+                    found = true;\n+                    HttpField newField = computeFn.apply(name, Collections.unmodifiableList(getFields(name)));\n+                    if (newField == null)\n+                        iterator.remove();\n+                    else\n+                        iterator.set(newField);\n+                }\n+            }\n+        }\n+        if (!found)\n+        {\n+            HttpField newField = computeFn.apply(name, null);\n+            if (newField != null)\n+                put(newField);", "originalCommit": "79d340fdb6202a5dbcd9e980a48718de44672a39", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc2MjAzOA==", "url": "https://github.com/eclipse/jetty.project/pull/5144#discussion_r469762038", "bodyText": "Need a version that takes a HttpHeader enum and you should use that for Via", "author": "gregw", "createdAt": "2020-08-13T07:49:39Z", "path": "jetty-http/src/main/java/org/eclipse/jetty/http/HttpFields.java", "diffHunk": "@@ -88,6 +89,115 @@ public HttpFields(HttpFields fields)\n         _size = fields._size;\n     }\n \n+    /**\n+     * <p>Computes a single field for the given HTTP header name and for existing fields with the same name.</p>\n+     *\n+     * <p>The compute function receives the field name and a list of fields with the same name\n+     * so that their values can be used to compute the value of the field that is returned\n+     * by the compute function.\n+     * If the compute function returns {@code null}, the fields with the given name are removed.</p>\n+     * <p>This method comes handy when you want to add an HTTP header if it does not exist,\n+     * or add a value if the HTTP header already exists, similarly to\n+     * {@link Map#compute(Object, BiFunction)}.</p>\n+     *\n+     * <p>This method can be used to {@link #put(HttpField) put} a new field (or blindly replace its value):</p>\n+     * <pre>\n+     * httpFields.computeField(\"X-New-Header\",\n+     *     (name, fields) -> new HttpField(name, \"NewValue\"));\n+     * </pre>\n+     *\n+     * <p>This method can be used to coalesce many fields into one:</p>\n+     * <pre>\n+     * // Input:\n+     * GET / HTTP/1.1\n+     * Host: localhost\n+     * Cookie: foo=1\n+     * Cookie: bar=2,baz=3\n+     * User-Agent: Jetty\n+     *\n+     * // Computation:\n+     * httpFields.computeField(\"Cookie\", (name, fields) ->\n+     * {\n+     *     // No cookies, nothing to do.\n+     *     if (fields == null)\n+     *         return null;\n+     *\n+     *     // Coalesces all cookies.\n+     *     String coalesced = fields.stream()\n+     *         .flatMap(field -> Stream.of(field.getValues()))\n+     *         .collect(Collectors.joining(\", \"));\n+     *\n+     *     // Returns a single Cookie header with all cookies.\n+     *     return new HttpField(name, coalesced);\n+     * }\n+     *\n+     * // Output:\n+     * GET / HTTP/1.1\n+     * Host: localhost\n+     * Cookie: foo=1, bar=2, baz=3\n+     * User-Agent: Jetty\n+     * </pre>\n+     *\n+     * <p>This method can be used to replace a field:</p>\n+     * <pre>\n+     * httpFields.computeField(\"X-Length\", (name, fields) ->\n+     * {\n+     *     if (fields == null)\n+     *         return null;\n+     *\n+     *     // Get any value among the X-Length headers.\n+     *     String length = fields.stream()\n+     *         .map(HttpField::getValue)\n+     *         .findAny()\n+     *         .orElse(\"0\");\n+     *\n+     *     // Replace X-Length headers with X-Capacity header.\n+     *     return new HttpField(\"X-Capacity\", length);\n+     * });\n+     * </pre>\n+     *\n+     * <p>This method can be used to remove a field:</p>\n+     * <pre>\n+     * httpFields.computeField(\"Connection\", (name, fields) -> null);\n+     * </pre>\n+     *\n+     * @param name the HTTP header name\n+     * @param computeFn the compute function\n+     */\n+    public void computeField(String name, BiFunction<String, List<HttpField>, HttpField> computeFn)", "originalCommit": "79d340fdb6202a5dbcd9e980a48718de44672a39", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f1a13521df66ce4206b8797707d176c4b3cd972b", "url": "https://github.com/eclipse/jetty.project/commit/f1a13521df66ce4206b8797707d176c4b3cd972b", "message": "improved implementation\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-08-13T08:06:31Z", "type": "commit"}, {"oid": "faea7c9ac189162b2630e59f052c3f761fb8902b", "url": "https://github.com/eclipse/jetty.project/commit/faea7c9ac189162b2630e59f052c3f761fb8902b", "message": "Fixes #5104 - AbstractProxyServlet include incorrect protocol version in Via header when accessed over H2.\n\nFixed javadocs.\n\nSigned-off-by: Simone Bordet <simone.bordet@gmail.com>", "committedDate": "2020-08-13T09:05:38Z", "type": "commit"}, {"oid": "f31604cff2206be10b329adc1561b379fa1fb99e", "url": "https://github.com/eclipse/jetty.project/commit/f31604cff2206be10b329adc1561b379fa1fb99e", "message": "added test. Fixed bugs\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-08-13T09:17:19Z", "type": "commit"}, {"oid": "a933b1645cce93728bf195462930edbd0b5a91a8", "url": "https://github.com/eclipse/jetty.project/commit/a933b1645cce93728bf195462930edbd0b5a91a8", "message": "simplified loops\nunmodifiable found list\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-08-13T09:27:37Z", "type": "commit"}, {"oid": "c3598e814b2103b5b36686a4cfd04232dd684606", "url": "https://github.com/eclipse/jetty.project/commit/c3598e814b2103b5b36686a4cfd04232dd684606", "message": "Merged branch 'jetty-9.4.x-5104-incorrect_via_header-2' into 'jetty-9.4.x-5104-incorrect_via_header'.", "committedDate": "2020-08-13T09:33:50Z", "type": "commit"}, {"oid": "7b3dccc1bff6431538f6d4ff069a20d60293edd9", "url": "https://github.com/eclipse/jetty.project/commit/7b3dccc1bff6431538f6d4ff069a20d60293edd9", "message": "Issue #5104 - AbstractProxyServlet include incorrect protocol version in Via header when accessed over H2.\n\nAdded HttpFields.computeField() for HttpHeader too and updated usages.\n\nSigned-off-by: Simone Bordet <simone.bordet@gmail.com>", "committedDate": "2020-08-13T09:50:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTg4NTU2OQ==", "url": "https://github.com/eclipse/jetty.project/pull/5144#discussion_r469885569", "bodyText": "I trust that this fluent style will resolve to something efficient enough for the common case of a single Via field?   If not then it might not be a bad idea to have special handling for viaFields.size()==1", "author": "gregw", "createdAt": "2020-08-13T11:33:10Z", "path": "jetty-proxy/src/main/java/org/eclipse/jetty/proxy/AbstractProxyServlet.java", "diffHunk": "@@ -513,9 +524,50 @@ protected void addProxyHeaders(HttpServletRequest clientRequest, Request proxyRe\n         addXForwardedHeaders(clientRequest, proxyRequest);\n     }\n \n+    /**\n+     * Adds the HTTP {@code Via} header to the proxied request.\n+     *\n+     * @param proxyRequest the request being proxied\n+     * @see #addViaHeader(HttpServletRequest, Request)\n+     */\n     protected void addViaHeader(Request proxyRequest)\n     {\n-        proxyRequest.header(HttpHeader.VIA, \"http/1.1 \" + getViaHost());\n+        HttpServletRequest clientRequest = (HttpServletRequest)proxyRequest.getAttributes().get(CLIENT_REQUEST_ATTRIBUTE);\n+        addViaHeader(clientRequest, proxyRequest);\n+    }\n+\n+    /**\n+     * <p>Adds the HTTP {@code Via} header to the proxied request, taking into account data present in the client request.</p>\n+     * <p>This method considers the protocol of the client request when forming the proxied request. If it\n+     * is HTTP, then the protocol name will not be included in the {@code Via} header that is sent by the proxy, and only\n+     * the protocol version will be sent. If it is not, the entire protocol (name and version) will be included. \n+     * If the client request includes a {@code Via} header, the result will be appended to that to form a chain.</p>\n+     *\n+     * @param clientRequest the client request\n+     * @param proxyRequest the request being proxied\n+     * @see <a href=\"https://tools.ietf.org/html/rfc7230#section-5.7.1\">RFC 7230 section 5.7.1</a>\n+     */\n+    protected void addViaHeader(HttpServletRequest clientRequest, Request proxyRequest)\n+    {\n+        String protocol = clientRequest.getProtocol();\n+        String[] parts = protocol.split(\"/\", 2);\n+        // Retain only the version if the protocol is HTTP.\n+        String protocolPart = parts.length == 2 && \"HTTP\".equalsIgnoreCase(parts[0]) ? parts[1] : protocol;\n+        String viaHeaderValue = protocolPart + \" \" + getViaHost();\n+        proxyRequest.getHeaders().computeField(HttpHeader.VIA, (header, viaFields) ->\n+        {\n+            if (viaFields == null || viaFields.isEmpty())\n+                return new HttpField(header, viaHeaderValue);\n+            String separator = \", \";\n+            String newValue = viaFields.stream()", "originalCommit": "7b3dccc1bff6431538f6d4ff069a20d60293edd9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkwOTkwMg==", "url": "https://github.com/eclipse/jetty.project/pull/5144#discussion_r469909902", "bodyText": "@gregw lost in the rest of the proxying it's a case where I'd prefer less code than more special case handling.\nThe typical case is that we are the only proxy, so viaFields.size()==0, which is already optimized.", "author": "sbordet", "createdAt": "2020-08-13T12:21:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTg4NTU2OQ=="}], "type": "inlineReview"}]}