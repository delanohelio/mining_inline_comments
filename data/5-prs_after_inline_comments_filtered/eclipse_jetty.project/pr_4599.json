{"pr_number": 4599, "pr_title": "Issue #4550 XmlConfiguration argument matching", "pr_createdAt": "2020-02-22T09:29:39Z", "pr_url": "https://github.com/eclipse/jetty.project/pull/4599", "timeline": [{"oid": "2073003a108cf0621d41790fd011c5bf51e065b0", "url": "https://github.com/eclipse/jetty.project/commit/2073003a108cf0621d41790fd011c5bf51e065b0", "message": "Issue #4550 XmlConfiguration argument matching\n\nImprove argument matching by:\n + rejecting obviously non matches (with allowance for unboxing)\n + sorting methods so that derived arguments are tried before more generic (eg String before Object)\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-02-22T09:28:28Z", "type": "commit"}, {"oid": "f35522c6b42d0b757e899b2b8262a3c55c8e6f1d", "url": "https://github.com/eclipse/jetty.project/commit/f35522c6b42d0b757e899b2b8262a3c55c8e6f1d", "message": "Issue #4550 XmlConfiguration argument matching\n\nImprove argument matching by:\n + can unbox from any Number to any Number\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-02-22T12:42:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE4ODgzMg==", "url": "https://github.com/eclipse/jetty.project/pull/4599#discussion_r383188832", "bodyText": "short maps to Long! The list should be sorted by smaller to bigger types (i.e. from boolean to double) so it's easier to see that they are all there.\nMerge this static block with the one below.", "author": "sbordet", "createdAt": "2020-02-24T10:36:41Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/TypeUtil.java", "diffHunk": "@@ -60,6 +60,22 @@\n \n     private static final HashMap<String, Class<?>> name2Class = new HashMap<>();\n \n+    private static final Map<Class<?>, Class<?>> __unbox;\n+\n+    static\n+    {\n+        Map<Class<?>, Class<?>> unbox = new HashMap<>();\n+        unbox.put(int.class, Integer.class);\n+        unbox.put(long.class, Long.class);\n+        unbox.put(byte.class, Byte.class);\n+        unbox.put(char.class, Character.class);\n+        unbox.put(float.class, Float.class);\n+        unbox.put(double.class, Double.class);\n+        unbox.put(short.class, Long.class);\n+        unbox.put(boolean.class, Boolean.class);\n+        __unbox = Collections.unmodifiableMap(unbox);\n+    }\n+", "originalCommit": "f35522c6b42d0b757e899b2b8262a3c55c8e6f1d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE5MzI5OQ==", "url": "https://github.com/eclipse/jetty.project/pull/4599#discussion_r383193299", "bodyText": "Not sure I get this?\nFirst expression should be just ac == c.\nFor c==Byte.class and ac==Long.class this returns true, but it is what we really want?\nWe cannot unbox a long into a byte, right?\nAlso there are other types implementing Number such as Atomic* and Big[Integer|Decimal].\nCalling isUnboxable(int.class, null) returns true, but we cannot unbox null to an int.\nCalling isUnboxed(int.class, new BigDecimal(\"0\")) returns true.\nThis feels it has a very specific logic that is only used in XmlConfiguration so perhaps should be there rather than in this class?", "author": "sbordet", "createdAt": "2020-02-24T10:45:43Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/TypeUtil.java", "diffHunk": "@@ -727,4 +743,16 @@ public static URI getModuleLocation(Class<?> clazz)\n         }\n         return null;\n     }\n+\n+    public static boolean isUnboxable(Class<?> type, Object arg)\n+    {\n+        if (!type.isPrimitive())\n+            return false;\n+        if (arg == null)\n+            return true;\n+\n+        Class<?> c = __unbox.get(type);\n+        Class<?> ac = arg.getClass();\n+        return ac == __unbox.get(type) || (Number.class.isAssignableFrom(c) && Number.class.isAssignableFrom(ac));", "originalCommit": "f35522c6b42d0b757e899b2b8262a3c55c8e6f1d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIyNDU5NA==", "url": "https://github.com/eclipse/jetty.project/pull/4599#discussion_r383224594", "bodyText": "I'm not sure I understand this.\nWe want to return args if unboxing is possible? That is already done by reflection.\nRemoving this block of code does not fail any test, so I am not sure why it was added?", "author": "sbordet", "createdAt": "2020-02-24T11:57:31Z", "path": "jetty-xml/src/main/java/org/eclipse/jetty/xml/XmlConfiguration.java", "diffHunk": "@@ -1734,47 +1756,64 @@ Args asEmptyVarArgs(Class<?> varArgType)\n                     return new Object[0];\n \n                 // If no arg names are specified, keep the arg order\n+                Object[] args;\n                 if (_names.stream().noneMatch(Objects::nonNull))\n-                    return _arguments.toArray(new Object[0]);\n-\n-                // If we don't have any parameters with names, then no match\n-                Annotation[][] parameterAnnotations = executable.getParameterAnnotations();\n-                if (parameterAnnotations == null || parameterAnnotations.length == 0)\n-                    return null;\n-\n-                // Find the position of all named parameters from the executable\n-                Map<String, Integer> position = new HashMap<>();\n-                int p = 0;\n-                for (Annotation[] paramAnnotation : parameterAnnotations)\n                 {\n-                    Integer pos = p++;\n-                    Arrays.stream(paramAnnotation)\n-                        .filter(Name.class::isInstance)\n-                        .map(Name.class::cast)\n-                        .findFirst().ifPresent(n -> position.put(n.value(), pos));\n+                    args = _arguments.toArray(new Object[0]);\n                 }\n-\n-                List<Object> arguments = new ArrayList<>(_arguments);\n-                List<String> names = new ArrayList<>(_names);\n-                // Map the actual arguments to the names\n-                for (p = 0; p < count; p++)\n+                else\n                 {\n-                    String name = names.get(p);\n-                    if (name != null)\n+                    // If we don't have any parameters with names, then no match\n+                    Annotation[][] parameterAnnotations = executable.getParameterAnnotations();\n+                    if (parameterAnnotations == null || parameterAnnotations.length == 0)\n+                        return null;\n+\n+                    // Find the position of all named parameters from the executable\n+                    Map<String, Integer> position = new HashMap<>();\n+                    int p = 0;\n+                    for (Annotation[] paramAnnotation : parameterAnnotations)\n                     {\n-                        Integer pos = position.get(name);\n-                        if (pos == null)\n-                            return null;\n-                        if (pos != p)\n+                        Integer pos = p++;\n+                        Arrays.stream(paramAnnotation)\n+                            .filter(Name.class::isInstance)\n+                            .map(Name.class::cast)\n+                            .findFirst().ifPresent(n -> position.put(n.value(), pos));\n+                    }\n+\n+                    List<Object> arguments = new ArrayList<>(_arguments);\n+                    List<String> names = new ArrayList<>(_names);\n+                    // Map the actual arguments to the names\n+                    for (p = 0; p < count; p++)\n+                    {\n+                        String name = names.get(p);\n+                        if (name != null)\n                         {\n-                            // adjust position of parameter\n-                            arguments.add(pos, arguments.remove(p));\n-                            names.add(pos, names.remove(p));\n-                            p = Math.min(p, pos);\n+                            Integer pos = position.get(name);\n+                            if (pos == null)\n+                                return null;\n+                            if (pos != p)\n+                            {\n+                                // adjust position of parameter\n+                                arguments.add(pos, arguments.remove(p));\n+                                names.add(pos, names.remove(p));\n+                                p = Math.min(p, pos);\n+                            }\n                         }\n                     }\n+                    args = arguments.toArray(new Object[0]);\n                 }\n-                return arguments.toArray(new Object[0]);\n+\n+                // Check assignable\n+                Parameter[] params = executable.getParameters();\n+                for (int i = 0; i < args.length; i++)\n+                {\n+                    if (args[i] != null &&\n+                        !params[i].getType().isAssignableFrom(args[i].getClass()) &&\n+                        !TypeUtil.isUnboxable(params[i].getType(), args[i]))\n+                        return null;\n+                }", "originalCommit": "f35522c6b42d0b757e899b2b8262a3c55c8e6f1d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d6843a97416f7282556b23184b45808239f2cc3e", "url": "https://github.com/eclipse/jetty.project/commit/d6843a97416f7282556b23184b45808239f2cc3e", "message": "Issue #4550\n\nDo not check the assignability of the arguments.  Instead rely on the order of the methods.\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-02-24T18:49:47Z", "type": "commit"}, {"oid": "3728314890d19a41e18a89955f1e03e35bf88ea6", "url": "https://github.com/eclipse/jetty.project/commit/3728314890d19a41e18a89955f1e03e35bf88ea6", "message": "Issue #4550\n\nunbox test no longer required\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-02-24T18:50:25Z", "type": "commit"}, {"oid": "626fe7156fee8eefe4cb19680c502a8ab43d2d06", "url": "https://github.com/eclipse/jetty.project/commit/626fe7156fee8eefe4cb19680c502a8ab43d2d06", "message": "Issue #4550\n\nSimplified test\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-02-24T22:08:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzczMzIzMw==", "url": "https://github.com/eclipse/jetty.project/pull/4599#discussion_r383733233", "bodyText": "How about this:\n    public static final Comparator<Executable> EXECUTABLE_COMPARATOR = (e1, e2) ->\n    {\n        int count = e1.getParameterCount();\n        int compare = Integer.compare(count, e2.getParameterCount());\n        if (compare == 0 && count > 0)\n        {\n            Parameter[] p1 = e1.getParameters();\n            Parameter[] p2 = e2.getParameters();\n            boolean va1 = p1[count - 1].isVarArgs();\n            boolean va2 = p2[count - 1].isVarArgs();\n            compare = Boolean.compare(va1, va2);\n            if (compare == 0)\n            {\n                // Rank by assignability of the arguments\n                for (int i = 0; i < count; i++)\n                {\n                    Class<?> t1 = p1[i].getType();\n                    Class<?> t2 = p2[i].getType();\n                    if (t1 != t2)\n                    {\n                        int weight = 2 ^ (count - 1 - i);\n                        boolean ref1 = !t1.isPrimitive();\n                        boolean ref2 = !t2.isPrimitive();\n                        int refs = Boolean.compare(ref1, ref2);\n                        if (refs == 0)\n                        {\n                            if (t1.isAssignableFrom(t2))\n                                compare += weight;\n                            else if (t2.isAssignableFrom(t1))\n                                compare -= weight;\n                        }\n                        else\n                        {\n                            compare += refs * weight;\n                        }\n                    }\n                }\n            }\n            compare = Math.min(1, Math.max(compare, -1));\n        }\n        return compare;\n    };", "author": "sbordet", "createdAt": "2020-02-25T08:50:15Z", "path": "jetty-xml/src/main/java/org/eclipse/jetty/xml/XmlConfiguration.java", "diffHunk": "@@ -99,20 +100,42 @@\n         };\n     private static final Iterable<ConfigurationProcessorFactory> __factoryLoader = ServiceLoader.load(ConfigurationProcessorFactory.class);\n     private static final XmlParser __parser = initParser();\n-    public static final Comparator<Executable> EXECUTABLE_COMPARATOR = (o1, o2) ->\n+    public static final Comparator<Executable> EXECUTABLE_COMPARATOR = (e1, e2) ->\n     {\n-        int p1 = o1.getParameterCount();\n-        int p2 = o2.getParameterCount();\n-        int compare = Integer.compare(p1, p2);\n-        if (compare == 0 && p1 > 0)\n+        int count = e1.getParameterCount();\n+        int compare = Integer.compare(count, e2.getParameterCount());\n+        if (compare == 0 && count > 0)\n         {\n-            boolean a1 = o1.getParameterTypes()[p1 - 1].isArray();\n-            boolean a2 = o2.getParameterTypes()[p2 - 1].isArray();\n-            if (a1 && !a2)\n+            Parameter[] p1 = e1.getParameters();\n+            Parameter[] p2 = e2.getParameters();\n+            boolean va1 = p1[count - 1].isVarArgs();\n+            boolean va2 = p2[count - 1].isVarArgs();\n+            if (va1 && !va2)\n                 compare = 1;\n-            else if (!a1 && a2)\n+            else if (!va1 && va2)\n                 compare = -1;\n+            else\n+            {\n+                // Rank by assignability of the arguments\n+                for (int i = 0; i < count; i++)\n+                {\n+                    Class<?> t1 = p1[i].getType();\n+                    Class<?> t2 = p2[i].getType();\n+                    if (t1 != t2)\n+                    {\n+                        if (t1.isAssignableFrom(t2))\n+                            compare = 1;\n+                        else if (t2.isAssignableFrom(t1))\n+                            compare = -1;\n+                        else\n+                            compare = t1.getName().compareTo(t2.getName());\n+                        break;\n+                    }\n+                }\n+            }\n+            compare = Math.min(1, Math.max(compare, -1));\n         }\n+\n         return compare;\n     };", "originalCommit": "3728314890d19a41e18a89955f1e03e35bf88ea6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "39dd24528688930539f09c09d71dcd1b478a4518", "url": "https://github.com/eclipse/jetty.project/commit/39dd24528688930539f09c09d71dcd1b478a4518", "message": "Issue #4550\n\nCleanup comparator\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-02-25T09:14:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkyMjUyMA==", "url": "https://github.com/eclipse/jetty.project/pull/4599#discussion_r383922520", "bodyText": "It's subtle that t1 and t2 are inverted here.\nI would prefer Boolean.compare(!t1.isPrimitive(), !t2.isPrimitive()).", "author": "sbordet", "createdAt": "2020-02-25T14:45:10Z", "path": "jetty-xml/src/main/java/org/eclipse/jetty/xml/XmlConfiguration.java", "diffHunk": "@@ -99,20 +100,47 @@\n         };\n     private static final Iterable<ConfigurationProcessorFactory> __factoryLoader = ServiceLoader.load(ConfigurationProcessorFactory.class);\n     private static final XmlParser __parser = initParser();\n-    public static final Comparator<Executable> EXECUTABLE_COMPARATOR = (o1, o2) ->\n+    public static final Comparator<Executable> EXECUTABLE_COMPARATOR = (e1, e2) ->\n     {\n-        int p1 = o1.getParameterCount();\n-        int p2 = o2.getParameterCount();\n-        int compare = Integer.compare(p1, p2);\n-        if (compare == 0 && p1 > 0)\n+        // Favour methods with less parameters\n+        int count = e1.getParameterCount();\n+        int compare = Integer.compare(count, e2.getParameterCount());\n+        if (compare == 0 && count > 0)\n         {\n-            boolean a1 = o1.getParameterTypes()[p1 - 1].isArray();\n-            boolean a2 = o2.getParameterTypes()[p2 - 1].isArray();\n-            if (a1 && !a2)\n-                compare = 1;\n-            else if (!a1 && a2)\n-                compare = -1;\n+            Parameter[] p1 = e1.getParameters();\n+            Parameter[] p2 = e2.getParameters();\n+\n+            // Favour methods without varargs\n+            compare = Boolean.compare(p1[count - 1].isVarArgs(), p2[count - 1].isVarArgs());\n+            if (compare == 0)\n+            {\n+                // Rank by differences in the parameters\n+                for (int i = 0; i < count; i++)\n+                {\n+                    Class<?> t1 = p1[i].getType();\n+                    Class<?> t2 = p2[i].getType();\n+                    if (t1 != t2)\n+                    {\n+                        // Favour derived type over base type\n+                        compare = Boolean.compare(t1.isAssignableFrom(t2), t2.isAssignableFrom(t1));\n+                        if (compare == 0)\n+                        {\n+                            // favour primitive type over reference\n+                            compare = Boolean.compare(t2.isPrimitive(), t1.isPrimitive());", "originalCommit": "39dd24528688930539f09c09d71dcd1b478a4518", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzk0NTAyOQ==", "url": "https://github.com/eclipse/jetty.project/pull/4599#discussion_r383945029", "bodyText": "that's how I wrote it initially.... switching....", "author": "gregw", "createdAt": "2020-02-25T15:18:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkyMjUyMA=="}], "type": "inlineReview"}, {"oid": "a95e40e01e5b42e7deeb66106478e1e1b23ce437", "url": "https://github.com/eclipse/jetty.project/commit/a95e40e01e5b42e7deeb66106478e1e1b23ce437", "message": "Issue #4550\n\nCleanup comparator\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-02-25T15:17:33Z", "type": "commit"}]}