{"pr_number": 4777, "pr_title": "Immutable HttpFields and MetaData", "pr_createdAt": "2020-04-15T09:26:33Z", "pr_url": "https://github.com/eclipse/jetty.project/pull/4777", "timeline": [{"oid": "e37a34c9b831d41f82fdf31c221299b2635e18c4", "url": "https://github.com/eclipse/jetty.project/commit/e37a34c9b831d41f82fdf31c221299b2635e18c4", "message": "Immutable version of HttpFields\n\nPreserve API and usage of HttpFields class while providing a read only interface and immutable implementation.\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-04-15T08:58:23Z", "type": "commit"}, {"oid": "75df043c3f976a1cef73aafc609c5b5169a40487", "url": "https://github.com/eclipse/jetty.project/commit/75df043c3f976a1cef73aafc609c5b5169a40487", "message": "Immutable version of HttpFields\n\nUse an ArrayList in HttpFields. While slightly slower than the array, it will mostly be used as a builder pattern for an Immutable\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-04-15T09:20:52Z", "type": "commit"}, {"oid": "753e02cf6be03572eb242b826998431993056a79", "url": "https://github.com/eclipse/jetty.project/commit/753e02cf6be03572eb242b826998431993056a79", "message": "Immutable version of HttpFields\n\nFixed exception type.\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-04-15T11:40:22Z", "type": "commit"}, {"oid": "53bf5a5ca6847702db162c04dcd52b93fbffcecb", "url": "https://github.com/eclipse/jetty.project/commit/53bf5a5ca6847702db162c04dcd52b93fbffcecb", "message": "Immutable version of HttpFields\n\nasImmutable method\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-04-15T21:25:05Z", "type": "commit"}, {"oid": "d9837d93b8ab5103a259250a7052d12a56af44d6", "url": "https://github.com/eclipse/jetty.project/commit/d9837d93b8ab5103a259250a7052d12a56af44d6", "message": "Immutable MetaData\n\nMade HttpURIU immutable with a builder pattern.\nMetaData immutable and working within http module.\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-04-16T09:25:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQyNjYxNA==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r409426614", "bodyText": "Equivalent to:\nreturn Stream.of(_fields).iterator();", "author": "lorban", "createdAt": "2020-04-16T09:48:26Z", "path": "jetty-http/src/main/java/org/eclipse/jetty/http/HttpFields.java", "diffHunk": "@@ -724,337 +466,163 @@ public HttpField remove(HttpHeader name)\n     public HttpField remove(String name)\n     {\n         HttpField removed = null;\n-        for (int i = _size; i-- > 0; )\n+        for (ListIterator<HttpField> i = listIterator(); i.hasNext();)\n         {\n-            HttpField f = _fields[i];\n+            HttpField f = i.next();\n             if (f.getName().equalsIgnoreCase(name))\n             {\n                 removed = f;\n-                System.arraycopy(_fields, i + 1, _fields, i, --_size - i);\n+                i.remove();\n             }\n         }\n         return removed;\n     }\n \n-    /**\n-     * Get a header as an long value. Returns the value of an integer field or -1 if not found. The\n-     * case of the field name is ignored.\n-     *\n-     * @param name the case-insensitive field name\n-     * @return the value of the field as a long\n-     * @throws NumberFormatException If bad long found\n-     */\n-    public long getLongField(String name) throws NumberFormatException\n-    {\n-        HttpField field = getField(name);\n-        return field == null ? -1L : field.getLongValue();\n-    }\n-\n-    /**\n-     * Get a header as a date value. Returns the value of a date field, or -1 if not found. The case\n-     * of the field name is ignored.\n-     *\n-     * @param name the case-insensitive field name\n-     * @return the value of the field as a number of milliseconds since unix epoch\n-     */\n-    public long getDateField(String name)\n-    {\n-        HttpField field = getField(name);\n-        if (field == null)\n-            return -1;\n-\n-        String val = valueParameters(field.getValue(), null);\n-        if (val == null)\n-            return -1;\n-\n-        final long date = DateParser.parseDate(val);\n-        if (date == -1)\n-            throw new IllegalArgumentException(\"Cannot convert date: \" + val);\n-        return date;\n-    }\n-\n-    /**\n-     * Sets the value of an long field.\n-     *\n-     * @param name the field name\n-     * @param value the field long value\n-     */\n-    public void putLongField(HttpHeader name, long value)\n-    {\n-        String v = Long.toString(value);\n-        put(name, v);\n-    }\n-\n-    /**\n-     * Sets the value of an long field.\n-     *\n-     * @param name the field name\n-     * @param value the field long value\n-     */\n-    public void putLongField(String name, long value)\n-    {\n-        String v = Long.toString(value);\n-        put(name, v);\n-    }\n-\n-    /**\n-     * Sets the value of a date field.\n-     *\n-     * @param name the field name\n-     * @param date the field date value\n-     */\n-    public void putDateField(HttpHeader name, long date)\n-    {\n-        String d = DateGenerator.formatDate(date);\n-        put(name, d);\n-    }\n-\n-    /**\n-     * Sets the value of a date field.\n-     *\n-     * @param name the field name\n-     * @param date the field date value\n-     */\n-    public void putDateField(String name, long date)\n+    public int size()\n     {\n-        String d = DateGenerator.formatDate(date);\n-        put(name, d);\n+        return _fields.size();\n     }\n \n-    /**\n-     * Sets the value of a date field.\n-     *\n-     * @param name the field name\n-     * @param date the field date value\n-     */\n-    public void addDateField(String name, long date)\n+    @Override\n+    public Stream<HttpField> stream()\n     {\n-        String d = DateGenerator.formatDate(date);\n-        add(name, d);\n+        return _fields.stream();\n     }\n \n     @Override\n-    public int hashCode()\n+    public String toString()\n     {\n-        int hash = 0;\n-        for (HttpField field : _fields)\n-        {\n-            hash += field.hashCode();\n-        }\n-        return hash;\n+        return asString();\n     }\n \n-    @Override\n-    public boolean equals(Object o)\n+    protected String addCSV(QuotedCSV existing, String... values)\n     {\n-        if (this == o)\n-            return true;\n-        if (!(o instanceof HttpFields))\n-            return false;\n-\n-        HttpFields that = (HttpFields)o;\n-\n-        // Order is not important, so we cannot rely on List.equals().\n-        if (size() != that.size())\n-            return false;\n-\n-        loop:\n-        for (HttpField fi : this)\n+        // remove any existing values from the new values\n+        boolean add = true;\n+        if (existing != null && !existing.isEmpty())\n         {\n-            for (HttpField fa : that)\n+            add = false;\n+\n+            for (int i = values.length; i-- > 0; )\n             {\n-                if (fi.equals(fa))\n-                    continue loop;\n+                String unquoted = QuotedCSV.unquote(values[i]);\n+                if (existing.getValues().contains(unquoted))\n+                    values[i] = null;\n+                else\n+                    add = true;\n             }\n-            return false;\n         }\n-        return true;\n-    }\n \n-    @Override\n-    public String toString()\n-    {\n-        try\n+        if (add)\n         {\n-            StringBuilder buffer = new StringBuilder();\n-            for (HttpField field : this)\n+            StringBuilder value = new StringBuilder();\n+            for (String v : values)\n             {\n-                if (field != null)\n-                {\n-                    String tmp = field.getName();\n-                    if (tmp != null)\n-                        buffer.append(tmp);\n-                    buffer.append(\": \");\n-                    tmp = field.getValue();\n-                    if (tmp != null)\n-                        buffer.append(tmp);\n-                    buffer.append(\"\\r\\n\");\n-                }\n+                if (v == null)\n+                    continue;\n+                if (value.length() > 0)\n+                    value.append(\", \");\n+                value.append(v);\n             }\n-            buffer.append(\"\\r\\n\");\n-            return buffer.toString();\n-        }\n-        catch (Exception e)\n-        {\n-            LOG.warn(\"Unable to get fields as String\", e);\n-            return e.toString();\n-        }\n-    }\n-\n-    public void clear()\n-    {\n-        _size = 0;\n-    }\n-\n-    public void addAll(HttpFields fields)\n-    {\n-        for (int i = 0; i < fields._size; i++)\n-        {\n-            add(fields._fields[i]);\n+            if (value.length() > 0)\n+                return value.toString();\n         }\n-    }\n \n-    /**\n-     * Get field value without parameters. Some field values can have parameters. This method separates the\n-     * value from the parameters and optionally populates a map with the parameters. For example:\n-     *\n-     * <PRE>\n-     *\n-     * FieldName : Value ; param1=val1 ; param2=val2\n-     *\n-     * </PRE>\n-     *\n-     * @param value The Field value, possibly with parameters.\n-     * @return The value.\n-     */\n-    public static String stripParameters(String value)\n-    {\n-        if (value == null)\n-            return null;\n-\n-        int i = value.indexOf(';');\n-        if (i < 0)\n-            return value;\n-        return value.substring(0, i).trim();\n+        return null;\n     }\n \n     /**\n-     * Get field value parameters. Some field values can have parameters. This method separates the\n-     * value from the parameters and optionally populates a map with the parameters. For example:\n-     *\n-     * <PRE>\n+     * HTTP Fields. A collection of HTTP header and or Trailer fields.\n      *\n-     * FieldName : Value ; param1=val1 ; param2=val2\n-     *\n-     * </PRE>\n+     * <p>This class is not synchronized as it is expected that modifications will only be performed by a\n+     * single thread.\n      *\n-     * @param value The Field value, possibly with parameters.\n-     * @param parameters A map to populate with the parameters, or null\n-     * @return The value.\n+     * <p>The cookie handling provided by this class is guided by the Servlet specification and RFC6265.\n      */\n-    public static String valueParameters(String value, Map<String, String> parameters)\n+    private static class Immutable implements HttpFieldList\n     {\n-        if (value == null)\n-            return null;\n+        private final HttpField[] _fields;\n \n-        int i = value.indexOf(';');\n-        if (i < 0)\n-            return value;\n-        if (parameters == null)\n-            return value.substring(0, i).trim();\n-\n-        StringTokenizer tok1 = new QuotedStringTokenizer(value.substring(i), \";\", false, true);\n-        while (tok1.hasMoreTokens())\n+        /**\n+         * Initialize HttpFields from copy.\n+         *\n+         * @param fields the fields to copy data from\n+         */\n+        Immutable(HttpField[] fields)\n         {\n-            String token = tok1.nextToken();\n-            StringTokenizer tok2 = new QuotedStringTokenizer(token, \"= \");\n-            if (tok2.hasMoreTokens())\n-            {\n-                String paramName = tok2.nextToken();\n-                String paramVal = null;\n-                if (tok2.hasMoreTokens())\n-                    paramVal = tok2.nextToken();\n-                parameters.put(paramName, paramVal);\n-            }\n+            _fields = fields;\n         }\n \n-        return value.substring(0, i).trim();\n-    }\n-\n-    private class ListItr implements ListIterator<HttpField>\n-    {\n-        int _cursor;       // index of next element to return\n-        int _current = -1;\n-\n         @Override\n-        public boolean hasNext()\n+        public HttpFieldList asImmutable()\n         {\n-            return _cursor != _size;\n+            return this;\n         }\n \n         @Override\n-        public HttpField next()\n+        public boolean equals(Object o)\n         {\n-            if (_cursor == _size)\n-                throw new NoSuchElementException();\n-            _current = _cursor++;\n-            return _fields[_current];\n-        }\n+            if (this == o)\n+                return true;\n+            if (!(o instanceof Immutable))\n+                return false;\n \n-        @Override\n-        public void remove()\n-        {\n-            if (_current < 0)\n-                throw new IllegalStateException();\n-            _size--;\n-            System.arraycopy(_fields, _current + 1, _fields, _current, _size - _current);\n-            _fields[_size] = null;\n-            _cursor = _current;\n-            _current = -1;\n+            return isEqualTo((HttpFieldList)o);\n         }\n \n         @Override\n-        public boolean hasPrevious()\n+        public HttpField getField(int index)\n         {\n-            return _cursor > 0;\n+            if (index >= _fields.length)\n+                throw new NoSuchElementException();\n+            return _fields[index];\n         }\n \n         @Override\n-        public HttpField previous()\n+        public int hashCode()\n         {\n-            if (_cursor == 0)\n-                throw new NoSuchElementException();\n-            _current = --_cursor;\n-            return _fields[_current];\n+            return asHashCode();\n         }\n \n         @Override\n-        public int nextIndex()\n+        public Iterator<HttpField> iterator()\n         {\n-            return _cursor + 1;\n+            return new Iterator<>()", "originalCommit": "d9837d93b8ab5103a259250a7052d12a56af44d6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQzMTI2Mg==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r409431262", "bodyText": "Why aren't the above two private?", "author": "lorban", "createdAt": "2020-04-16T09:55:51Z", "path": "jetty-http/src/main/java/org/eclipse/jetty/http/HttpURI.java", "diffHunk": "@@ -50,527 +49,126 @@\n  */\n public class HttpURI\n {\n-    private enum State\n+    private final String _scheme;\n+    private final String _user;\n+    private final String _host;\n+    private final int _port;\n+    private final String _path;\n+    private final String _param;\n+    private final String _query;\n+    private final String _fragment;\n+    private String _uri;\n+    private String _decodedPath;", "originalCommit": "d9837d93b8ab5103a259250a7052d12a56af44d6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQzMzM4OQ==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r409433389", "bodyText": "This class' immutability is... surprising. I'm not fond of the internal interface TBH.", "author": "lorban", "createdAt": "2020-04-16T09:59:01Z", "path": "jetty-http/src/main/java/org/eclipse/jetty/http/HttpFields.java", "diffHunk": "@@ -45,12 +36,9 @@\n  *\n  * <p>The cookie handling provided by this class is guided by the Servlet specification and RFC6265.\n  */\n-public class HttpFields implements Iterable<HttpField>\n+public class HttpFields implements Iterable<HttpField>, HttpFieldList", "originalCommit": "d9837d93b8ab5103a259250a7052d12a56af44d6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTUzNjQzNg==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r409536436", "bodyText": "We are limited in how much we can change HttpFields because it is part of some public interfaces.   This change make HttpFields a builder for the HttpFields.Immutable inner class.    It's not what I'd do if green fields.     Note that for HttpURI I have made it truly immutable and added HttpURI.Builder, which I think is a better way to go... I did that differently because that is more of an internal class.\nI'm not sure what you mean by \"internal interface\"?  There is an external HttpEventList interface that is implemented by both HttpFields and HttpFields.Immutable", "author": "gregw", "createdAt": "2020-04-16T13:01:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQzMzM4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQzNDI5Nw==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r409434297", "bodyText": "Why isn't that field immutable?", "author": "lorban", "createdAt": "2020-04-16T10:00:24Z", "path": "jetty-http/src/main/java/org/eclipse/jetty/http/MetaData.java", "diffHunk": "@@ -18,35 +18,44 @@\n \n package org.eclipse.jetty.http;\n \n-import java.util.Collections;\n import java.util.Iterator;\n import java.util.function.Supplier;\n \n public class MetaData implements Iterable<HttpField>\n {\n-    private HttpVersion _httpVersion;\n-    private final HttpFields _fields;\n-    private long _contentLength;\n-    private Supplier<HttpFields> _trailers;\n-\n-    public MetaData(HttpVersion version, HttpFields fields)\n+    private static final Supplier<HttpFieldList> SELF_SUPPLIED_TRAILORS = () -> null;\n+    private static final HttpFieldList SUPPLIED_TRAILERS = new HttpFields().asImmutable();\n+    private final HttpVersion _httpVersion;\n+    private final HttpFieldList _fields;\n+    private final long _contentLengthKnown;\n+    private final long _contentLengthField;\n+    private final Supplier<HttpFieldList> _trailerSupplier;\n+    private HttpFieldList _trailers;", "originalCommit": "d9837d93b8ab5103a259250a7052d12a56af44d6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTUzNzczMg==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r409537732", "bodyText": "Because it is not part of the immutable meta-data.  rather it is a field of the self referencing trailerSupplier that is used if a specific supplier is not provided.\nI will review this once I have trailers working and will then document a lot better if I keep it... I may move to an inner class if I can convince myself it wont be less efficient.", "author": "gregw", "createdAt": "2020-04-16T13:03:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQzNDI5Nw=="}], "type": "inlineReview"}, {"oid": "f2f08e50b1f2e43133bc372c0d8297893ebcad45", "url": "https://github.com/eclipse/jetty.project/commit/f2f08e50b1f2e43133bc372c0d8297893ebcad45", "message": "Immutable MetaData\n\nFixes from review\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-04-16T12:55:13Z", "type": "commit"}, {"oid": "8d5b036fe54ae96194ae268895e8f7830672c426", "url": "https://github.com/eclipse/jetty.project/commit/8d5b036fe54ae96194ae268895e8f7830672c426", "message": "Immutable MetaData\n\nPassing tests upto and including jetty-server\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-04-17T11:45:35Z", "type": "commit"}, {"oid": "8de4fb6ed9465a91b3c206f48223b8ce6e9a8834", "url": "https://github.com/eclipse/jetty.project/commit/8de4fb6ed9465a91b3c206f48223b8ce6e9a8834", "message": "Immutable MetaData\n\nCleanup of HttpURI.Builder API as suggested in PR.\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-04-17T13:28:28Z", "type": "commit"}, {"oid": "c1010f3e628dff69f69945915f2b2b244829a73d", "url": "https://github.com/eclipse/jetty.project/commit/c1010f3e628dff69f69945915f2b2b244829a73d", "message": "Immutable MetaData\n\nAdded builder for MetaData.Request\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-04-17T14:10:58Z", "type": "commit"}, {"oid": "1bb6ba471fbd7f3ed7c5984a47498ccf5ded8614", "url": "https://github.com/eclipse/jetty.project/commit/1bb6ba471fbd7f3ed7c5984a47498ccf5ded8614", "message": "Merge remote-tracking branch 'origin/jetty-10.0.x' into jetty-10.0.x-ImmutableMetaData", "committedDate": "2020-04-18T06:56:28Z", "type": "commit"}, {"oid": "c0b98a3b3b4c3c9d8378f3fcb60f69376d6f07cc", "url": "https://github.com/eclipse/jetty.project/commit/c0b98a3b3b4c3c9d8378f3fcb60f69376d6f07cc", "message": "Immutable MetaData\n\nmore api fixes\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-04-18T07:13:51Z", "type": "commit"}, {"oid": "4c334e8611ce8dd894b8fa1bdc795a8cffc95d02", "url": "https://github.com/eclipse/jetty.project/commit/4c334e8611ce8dd894b8fa1bdc795a8cffc95d02", "message": "Immutable MetaData\n\nWIP making HttpFiels itself immutable.  Currently working up to jetty-servlet.\n\nNeed to consider if content-length really is meta data and how much and when can we trust it.\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-04-18T16:55:47Z", "type": "commit"}, {"oid": "23bcdd205555f292f73b4cd74c05bf9169234df6", "url": "https://github.com/eclipse/jetty.project/commit/23bcdd205555f292f73b4cd74c05bf9169234df6", "message": "Immutable MetaData\n\nWIP\n\nNeed to consider if content-length really is meta data and how much and when can we trust it. Also need to consider difference between h2 and h1 authority in metadata.\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-04-19T15:18:49Z", "type": "commit"}, {"oid": "a953f425bc05b09e543313fba8d22f58c06b354a", "url": "https://github.com/eclipse/jetty.project/commit/a953f425bc05b09e543313fba8d22f58c06b354a", "message": "Immutable MetaData WIP\n\njetty-client and jetty-servlet passing tests.\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-04-19T17:06:39Z", "type": "commit"}, {"oid": "fb81db19733e7a8d8f872a9e60396dc3108b32d7", "url": "https://github.com/eclipse/jetty.project/commit/fb81db19733e7a8d8f872a9e60396dc3108b32d7", "message": "Immutable MetaData WIP\n\nBetter align the style of immutability between `HttpFields` and `HttpURI`.\nThey both now have static build() and from() methods, plus Builder and Immutable implementations.\nPotentially `Builder` could be renamed as `Mutable`\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-04-20T10:18:02Z", "type": "commit"}, {"oid": "372455a6cae366b26502ec4a17b48aa0d85cb2da", "url": "https://github.com/eclipse/jetty.project/commit/372455a6cae366b26502ec4a17b48aa0d85cb2da", "message": "Immutable MetaData WIP\n\nhttp2-server tests passed\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-04-20T10:56:46Z", "type": "commit"}, {"oid": "58e458c0139ed41660aa2b98cd6b063d93230413", "url": "https://github.com/eclipse/jetty.project/commit/58e458c0139ed41660aa2b98cd6b063d93230413", "message": "Immutable MetaData WIP\n\nhttp2-client tests passed\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-04-20T11:22:02Z", "type": "commit"}, {"oid": "0215268bc36e278ed7f2316a45efe0054f3e0466", "url": "https://github.com/eclipse/jetty.project/commit/0215268bc36e278ed7f2316a45efe0054f3e0466", "message": "Immutable MetaData WIP\n\ncleann build?\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-04-20T12:56:10Z", "type": "commit"}, {"oid": "90aae8b33a327f50728f5d3a6af3845c4840003d", "url": "https://github.com/eclipse/jetty.project/commit/90aae8b33a327f50728f5d3a6af3845c4840003d", "message": "Merge branch 'jetty-10.0.x' into jetty-10.0.x-ImmutableMetaData", "committedDate": "2020-04-20T12:57:14Z", "type": "commit"}, {"oid": "c23ea622b5c803d7f85027c84ad1e1e654bc6465", "url": "https://github.com/eclipse/jetty.project/commit/c23ea622b5c803d7f85027c84ad1e1e654bc6465", "message": "Immutable MetaData WIP\n\nfix\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-04-20T13:34:00Z", "type": "commit"}, {"oid": "cf6df85cf92d312203f0f78c23ae54fac18e2d19", "url": "https://github.com/eclipse/jetty.project/commit/cf6df85cf92d312203f0f78c23ae54fac18e2d19", "message": "Immutable MetaData WIP\n\nmore test fixes\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-04-20T16:33:16Z", "type": "commit"}, {"oid": "e8617da0f1ce5f06dacd446299568d6d231a750c", "url": "https://github.com/eclipse/jetty.project/commit/e8617da0f1ce5f06dacd446299568d6d231a750c", "message": "Immutable MetaData WIP\n\nCleanups, mostly using EMPTY when appropriate.\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-04-20T17:28:57Z", "type": "commit"}, {"oid": "a2d05a17214cccc1aa88fb9b685ee1f068bc9267", "url": "https://github.com/eclipse/jetty.project/commit/a2d05a17214cccc1aa88fb9b685ee1f068bc9267", "message": "Immutable MetaData WIP\n\nCleanups, use immutable\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-04-20T17:33:33Z", "type": "commit"}, {"oid": "f6387a0ec329564d0d07997337600e92d4ca9247", "url": "https://github.com/eclipse/jetty.project/commit/f6387a0ec329564d0d07997337600e92d4ca9247", "message": "Immutable MetaData WIP\n\nNo trailers for connect\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-04-21T10:43:13Z", "type": "commit"}, {"oid": "d1b62c71753f13ab8f6fad0860d478d8f7781d7b", "url": "https://github.com/eclipse/jetty.project/commit/d1b62c71753f13ab8f6fad0860d478d8f7781d7b", "message": "Immutable MetaData WIP\n\nFix CONNECT path handling\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-04-21T11:26:20Z", "type": "commit"}, {"oid": "79c453b171168f50e787ec079373e84655b8003d", "url": "https://github.com/eclipse/jetty.project/commit/79c453b171168f50e787ec079373e84655b8003d", "message": "Immutable MetaData WIP\n\nfixed rewrite query handling\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-04-21T13:29:18Z", "type": "commit"}, {"oid": "8943b9b80618ea0e5a6ed7d05b7eecb2a6b188af", "url": "https://github.com/eclipse/jetty.project/commit/8943b9b80618ea0e5a6ed7d05b7eecb2a6b188af", "message": "Immutable MetaData WIP\n\nrename Builders to Muttables\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-04-21T15:14:51Z", "type": "commit"}, {"oid": "89aa96902e9d1ee67165552fc5a8da1fb3ac32c9", "url": "https://github.com/eclipse/jetty.project/commit/89aa96902e9d1ee67165552fc5a8da1fb3ac32c9", "message": "Immutable MetaData WIP\n\nmisc cleanups\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-04-21T15:51:26Z", "type": "commit"}, {"oid": "0ac9421e7e7dbdcca4d8dea3cff5929ae6780401", "url": "https://github.com/eclipse/jetty.project/commit/0ac9421e7e7dbdcca4d8dea3cff5929ae6780401", "message": "Merge remote-tracking branch 'origin/jetty-10.0.x' into jetty-10.0.x-ImmutableMetaData", "committedDate": "2020-04-22T07:53:43Z", "type": "commit"}, {"oid": "915f324b581df316a8ed997c7e2a4bf62b13d43a", "url": "https://github.com/eclipse/jetty.project/commit/915f324b581df316a8ed997c7e2a4bf62b13d43a", "message": "Immutable MetaData WIP\n\nRevert to using arrays due to garbage generated by streams and iterators (12% of a simple benchmark!).\nEven if this garbage is an artifact of the JIT being disabled by observation, it can hide other allocations, so best to just use simple arrays!\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-04-22T14:30:56Z", "type": "commit"}, {"oid": "3de51af3fcc2e58bec8af6671856bded1726f495", "url": "https://github.com/eclipse/jetty.project/commit/3de51af3fcc2e58bec8af6671856bded1726f495", "message": "Immutable MetaData WIP\n\nMore optimizations and better test coverage.\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-04-22T17:37:46Z", "type": "commit"}, {"oid": "dd154dd9a92b7841b8adea5e6b9197d4ed5bb7c3", "url": "https://github.com/eclipse/jetty.project/commit/dd154dd9a92b7841b8adea5e6b9197d4ed5bb7c3", "message": "Immutable Metadata\n\nvarious cleanups\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-04-22T20:53:05Z", "type": "commit"}, {"oid": "3c5e8b644ac87802e1340aa1cc2cc2eaffb001a4", "url": "https://github.com/eclipse/jetty.project/commit/3c5e8b644ac87802e1340aa1cc2cc2eaffb001a4", "message": "Merge branch 'jetty-10.0.x' into jetty-10.0.x-ImmutableMetaData", "committedDate": "2020-04-22T21:02:15Z", "type": "commit"}, {"oid": "3749a5ca5526d8526fc4e4320f158e8a34e097b4", "url": "https://github.com/eclipse/jetty.project/commit/3749a5ca5526d8526fc4e4320f158e8a34e097b4", "message": "Immutable MetaData WIP\n\nMore optimizations\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-04-22T21:39:28Z", "type": "commit"}, {"oid": "5971476d306e012ebd6201c6ef708c470a5a75e9", "url": "https://github.com/eclipse/jetty.project/commit/5971476d306e012ebd6201c6ef708c470a5a75e9", "message": "Merge remote-tracking branch 'origin/jetty-10.0.x' into jetty-10.0.x-ImmutableMetaData\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-04-23T07:24:41Z", "type": "commit"}, {"oid": "fa86645a99b52390456f0c04bea50f94b890daf5", "url": "https://github.com/eclipse/jetty.project/commit/fa86645a99b52390456f0c04bea50f94b890daf5", "message": "Immutable MetaData WIP\n\nreview changes\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-04-23T08:18:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY5MTI1NA==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413691254", "bodyText": "Please rename this field to WS_VERSION_FIELD (singular).", "author": "sbordet", "createdAt": "2020-04-23T10:13:57Z", "path": "jetty-websocket/websocket-core/src/main/java/org/eclipse/jetty/websocket/core/client/HttpUpgraderOverHTTP.java", "diffHunk": "@@ -30,13 +30,19 @@\n import org.eclipse.jetty.http.HttpHeader;\n import org.eclipse.jetty.http.HttpMethod;\n import org.eclipse.jetty.http.HttpVersion;\n+import org.eclipse.jetty.http.PreEncodedHttpField;\n import org.eclipse.jetty.io.EndPoint;\n import org.eclipse.jetty.util.Callback;\n import org.eclipse.jetty.websocket.core.WebSocketConstants;\n import org.eclipse.jetty.websocket.core.internal.WebSocketCore;\n \n public class HttpUpgraderOverHTTP implements HttpUpgrader\n {\n+    private static final PreEncodedHttpField WS_VERSIONS_FIELD = new PreEncodedHttpField(HttpHeader.SEC_WEBSOCKET_VERSION, WebSocketConstants.SPEC_VERSION_STRING);", "originalCommit": "fa86645a99b52390456f0c04bea50f94b890daf5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY5MTkxOQ==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413691919", "bodyText": "This field is the same field that exist in HttpUpgraderOverHTTP.\nCan you please name them the same, i.e. WS_VERSION_FIELD?", "author": "sbordet", "createdAt": "2020-04-23T10:15:01Z", "path": "jetty-websocket/websocket-core/src/main/java/org/eclipse/jetty/websocket/core/client/HttpUpgraderOverHTTP2.java", "diffHunk": "@@ -23,12 +23,14 @@\n import org.eclipse.jetty.client.HttpUpgrader;\n import org.eclipse.jetty.http.HttpHeader;\n import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.PreEncodedHttpField;\n import org.eclipse.jetty.io.EndPoint;\n import org.eclipse.jetty.util.Callback;\n import org.eclipse.jetty.websocket.core.WebSocketConstants;\n \n public class HttpUpgraderOverHTTP2 implements HttpUpgrader\n {\n+    public static final PreEncodedHttpField SPEC_VERSION_FIELD = new PreEncodedHttpField(HttpHeader.SEC_WEBSOCKET_VERSION, WebSocketConstants.SPEC_VERSION_STRING);", "originalCommit": "fa86645a99b52390456f0c04bea50f94b890daf5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY5NzgxMg==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413697812", "bodyText": "Should not this be just HttpFields as return type?", "author": "sbordet", "createdAt": "2020-04-23T10:24:34Z", "path": "jetty-client/src/main/java/org/eclipse/jetty/client/HttpRequest.java", "diffHunk": "@@ -353,7 +381,7 @@ public Request attribute(String name, Object value)\n     }\n \n     @Override\n-    public HttpFields getHeaders()\n+    public HttpFields.Mutable getHeaders()", "originalCommit": "fa86645a99b52390456f0c04bea50f94b890daf5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDM2Mzg5Ng==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r414363896", "bodyText": "Actually now that I have added the put(HttpField), add(HttpField) etc. methods it could be an immutable return.\nSo currently this supports both old style (get the fields as a builder and modify) and the new style (use add,put, set).\nWe can keep it like this, go back to just old style (removing new methods) or change to immutable to just support new style.  Your thoughts?", "author": "gregw", "createdAt": "2020-04-24T07:40:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY5NzgxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDM3Nzk5Mg==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r414377992", "bodyText": "See #4808. Let's finish this and then discuss - currently I'm leaning for Request headers(Consumer<HttpFields.Mutable>)", "author": "sbordet", "createdAt": "2020-04-24T08:04:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY5NzgxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQwMTcwMA==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r414401700", "bodyText": "I did try the consumer approach and it worked well enough, but was a little bit more verbose.   Will defer this to #4808", "author": "gregw", "createdAt": "2020-04-24T08:42:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY5NzgxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY5ODc2Mw==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413698763", "bodyText": "Should not this be just HttpFields as return type?", "author": "sbordet", "createdAt": "2020-04-23T10:26:03Z", "path": "jetty-client/src/main/java/org/eclipse/jetty/client/HttpResponse.java", "diffHunk": "@@ -103,15 +108,15 @@ public HttpFields getHeaders()\n         return result;\n     }\n \n-    public HttpFields getTrailers()\n+    public HttpFields.Mutable getTrailers()", "originalCommit": "fa86645a99b52390456f0c04bea50f94b890daf5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY5OTg5NQ==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413699895", "bodyText": "I think for now these are fine, although remove() is never used.\nI will file another issue about reviewing the way headers can be set on a request because there is need to explicitly separate the \"add\" semantic from the \"put\" semantic.", "author": "sbordet", "createdAt": "2020-04-23T10:27:53Z", "path": "jetty-client/src/main/java/org/eclipse/jetty/client/api/Request.java", "diffHunk": "@@ -152,6 +153,32 @@\n      */\n     HttpFields getHeaders();\n \n+    /** Set the headers, clearing any existing headers\n+     * @param fields The fields to set\n+     * @return this request object\n+     */\n+    Request set(HttpFields fields);\n+\n+    /**\n+     * @param header the header to remove\n+     * @return this request object\n+     */\n+    Request remove(HttpHeader header);\n+\n+    /**\n+     * @param field the field to add\n+     * @return this request object\n+     * @see #header(HttpHeader, String)\n+     */\n+    Request add(HttpField field);\n+\n+    /**\n+     * @param field the field to put\n+     * @return this request object\n+     * @see #header(HttpHeader, String)\n+     */\n+    Request put(HttpField field);\n+", "originalCommit": "fa86645a99b52390456f0c04bea50f94b890daf5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDM2NDI0Mw==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r414364243", "bodyText": "See comment above... maybe these are not necessary anymore?", "author": "gregw", "createdAt": "2020-04-24T07:41:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY5OTg5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcwMDkyOA==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413700928", "bodyText": "Remove .Mutable.", "author": "sbordet", "createdAt": "2020-04-23T10:29:34Z", "path": "jetty-client/src/main/java/org/eclipse/jetty/client/util/MultiPartRequestContent.java", "diffHunk": "@@ -145,7 +145,7 @@ public void fail(Throwable failure)\n      * @param content the part content\n      * @param fields the headers associated with this part\n      */\n-    public void addFieldPart(String name, Request.Content content, HttpFields fields)\n+    public void addFieldPart(String name, Request.Content content, HttpFields.Mutable fields)", "originalCommit": "fa86645a99b52390456f0c04bea50f94b890daf5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcwMDk5OQ==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413700999", "bodyText": "Remove .Mutable.", "author": "sbordet", "createdAt": "2020-04-23T10:29:40Z", "path": "jetty-client/src/main/java/org/eclipse/jetty/client/util/MultiPartRequestContent.java", "diffHunk": "@@ -164,7 +164,7 @@ public void addFieldPart(String name, Request.Content content, HttpFields fields\n      * @param content the part content\n      * @param fields the headers associated with this part\n      */\n-    public void addFilePart(String name, String fileName, Request.Content content, HttpFields fields)\n+    public void addFilePart(String name, String fileName, Request.Content content, HttpFields.Mutable fields)", "originalCommit": "fa86645a99b52390456f0c04bea50f94b890daf5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcwMzA1Ng==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413703056", "bodyText": "This line was the point of the test: verify that even if the server did not send Connection: close, the client closes the connection.\nIt must be restored.", "author": "sbordet", "createdAt": "2020-04-23T10:32:50Z", "path": "jetty-client/src/test/java/org/eclipse/jetty/client/ClientConnectionCloseTest.java", "diffHunk": "@@ -249,8 +249,7 @@ public void handle(String target, Request baseRequest, HttpServletRequest reques\n                 DuplexConnectionPool connectionPool = (DuplexConnectionPool)destination.getConnectionPool();\n                 HttpConnectionOverHTTP connection = (HttpConnectionOverHTTP)connectionPool.getActiveConnections().iterator().next();\n                 assertFalse(connection.getEndPoint().isOutputShutdown());\n-            })\n-            .onResponseHeaders(r -> r.getHeaders().remove(HttpHeader.CONNECTION));", "originalCommit": "fa86645a99b52390456f0c04bea50f94b890daf5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDM2NzEwNA==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r414367104", "bodyText": "So do you want to the signature of Response.HeaderListener to be:\nboolean onHeader(Response response, HttpField.Mutable field);\nCurrently I have not exposed the mutable for the response headers.\nIs it expected that listeners in the client mutate the headers received or is this just for this test?", "author": "gregw", "createdAt": "2020-04-24T07:46:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcwMzA1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDM3OTk3Mg==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r414379972", "bodyText": "Ah good point. It is just a trick for the test. HttpClient detects when there is a Connection: close and initiates the close locally. I want to remove the Connection: close so that I want to verify that the TCP close by the server triggers the client to TCP close too. However, I can see applications wanting to filter out certain headers (e.g. cookies) so perhaps a Mutable is not that bad in this listener.", "author": "sbordet", "createdAt": "2020-04-24T08:07:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcwMzA1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQwNTYwOA==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r414405608", "bodyText": "For now I have just down cast in the unit test to access the mutable headers, so the test works.  I'll defer to #4808 for any other changes to the response listener APIs", "author": "gregw", "createdAt": "2020-04-24T08:48:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcwMzA1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcwNDIyMw==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413704223", "bodyText": "Since you have replaced containsKey() with contains(), can you also remove all the .asString() in this class, now that contains() takes a HttpHeader?", "author": "sbordet", "createdAt": "2020-04-23T10:34:45Z", "path": "jetty-client/src/test/java/org/eclipse/jetty/client/HttpClientRedirectTest.java", "diffHunk": "@@ -70,7 +70,7 @@ public void test303(Scenario scenario) throws Exception\n             .send();\n         assertNotNull(response);\n         assertEquals(200, response.getStatus());\n-        assertFalse(response.getHeaders().containsKey(HttpHeader.LOCATION.asString()));\n+        assertFalse(response.getHeaders().contains(HttpHeader.LOCATION.asString()));", "originalCommit": "fa86645a99b52390456f0c04bea50f94b890daf5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcwNjAxOA==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413706018", "bodyText": "Remove these fields, this is documentation code, we don't need to optimize.", "author": "sbordet", "createdAt": "2020-04-23T10:37:42Z", "path": "jetty-documentation/src/main/java/embedded/client/http/HTTPClientDocs.java", "diffHunk": "@@ -78,6 +79,11 @@\n @SuppressWarnings(\"unused\")\n public class HTTPClientDocs\n {\n+\n+    public static final PreEncodedHttpField H2C_UPGRADE_FIELD = new PreEncodedHttpField(HttpHeader.UPGRADE, \"h2c\");\n+    public static final PreEncodedHttpField H2_SETTINGS_FIELD = new PreEncodedHttpField(HttpHeader.HTTP2_SETTINGS, \"\");\n+    public static final PreEncodedHttpField H2_UPGRADE_CONNECTION_FIELD = new PreEncodedHttpField(HttpHeader.CONNECTION, \"Upgrade, HTTP2-Settings\");", "originalCommit": "fa86645a99b52390456f0c04bea50f94b890daf5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcwNjcxNg==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413706716", "bodyText": "Restore this section of the documentation as it was before, no point in optimizing it.", "author": "sbordet", "createdAt": "2020-04-23T10:38:43Z", "path": "jetty-documentation/src/main/java/embedded/client/http/HTTPClientDocs.java", "diffHunk": "@@ -798,9 +804,9 @@ public void dynamicClearText() throws Exception\n         // Make a clear-text upgrade request from HTTP/1.1 to HTTP/2.\n         // The request will start as HTTP/1.1, but the response will be HTTP/2.\n         ContentResponse upgradedResponse = client.newRequest(\"host\", 8080)\n-            .header(HttpHeader.UPGRADE, \"h2c\")\n-            .header(HttpHeader.HTTP2_SETTINGS, \"\")\n-            .header(HttpHeader.CONNECTION, \"Upgrade, HTTP2-Settings\")\n+            .add(H2C_UPGRADE_FIELD)\n+            .add(H2_SETTINGS_FIELD)\n+            .add(H2_UPGRADE_CONNECTION_FIELD)", "originalCommit": "fa86645a99b52390456f0c04bea50f94b890daf5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcwNzEzOQ==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413707139", "bodyText": "Remove .Mutable.", "author": "sbordet", "createdAt": "2020-04-23T10:39:28Z", "path": "jetty-documentation/src/main/java/embedded/client/http2/HTTP2ClientDocs.java", "diffHunk": "@@ -172,11 +172,11 @@ public void newStreamWithData() throws Exception\n         Session session = sessionCF.get();\n \n         // Configure the request headers.\n-        HttpFields requestHeaders = new HttpFields();\n-        requestHeaders.put(HttpHeader.CONTENT_TYPE, \"application/json\");\n+        HttpFields.Mutable requestHeaders = HttpFields.build()", "originalCommit": "fa86645a99b52390456f0c04bea50f94b890daf5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcwNzMyNA==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413707324", "bodyText": "Remove .Mutable.", "author": "sbordet", "createdAt": "2020-04-23T10:39:42Z", "path": "jetty-documentation/src/main/java/embedded/client/http2/HTTP2ClientDocs.java", "diffHunk": "@@ -213,9 +213,9 @@ public void responseListener() throws Exception\n         CompletableFuture<Session> sessionCF = http2Client.connect(serverAddress, new Session.Listener.Adapter());\n         Session session = sessionCF.get();\n \n-        HttpFields requestHeaders = new HttpFields();\n-        requestHeaders.put(HttpHeader.USER_AGENT, \"Jetty HTTP2Client {version}\");\n-        MetaData.Request request = new MetaData.Request(\"GET\", new HttpURI(\"http://localhost:8080/path\"), HttpVersion.HTTP_2, requestHeaders);\n+        HttpFields.Mutable requestHeaders = HttpFields.build()", "originalCommit": "fa86645a99b52390456f0c04bea50f94b890daf5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcwNzQ3Ng==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413707476", "bodyText": "Remove .Mutable.", "author": "sbordet", "createdAt": "2020-04-23T10:39:54Z", "path": "jetty-documentation/src/main/java/embedded/client/http2/HTTP2ClientDocs.java", "diffHunk": "@@ -358,9 +358,9 @@ public void pushReset() throws Exception\n         CompletableFuture<Session> sessionCF = http2Client.connect(serverAddress, new Session.Listener.Adapter());\n         Session session = sessionCF.get();\n \n-        HttpFields requestHeaders = new HttpFields();\n-        requestHeaders.put(HttpHeader.USER_AGENT, \"Jetty HTTP2Client {version}\");\n-        MetaData.Request request = new MetaData.Request(\"GET\", new HttpURI(\"http://localhost:8080/path\"), HttpVersion.HTTP_2, requestHeaders);\n+        HttpFields.Mutable requestHeaders = HttpFields.build()", "originalCommit": "fa86645a99b52390456f0c04bea50f94b890daf5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcwNzk0OQ==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413707949", "bodyText": "Restore the local variable newPath for documentation clarity.", "author": "sbordet", "createdAt": "2020-04-23T10:40:44Z", "path": "jetty-documentation/src/main/java/embedded/server/http/HTTPServerDocs.java", "diffHunk": "@@ -464,9 +464,7 @@ public void handle(String target, Request jettyRequest, HttpServletRequest reque\n                 {\n                     // Rewrite old paths to new paths.\n                     HttpURI uri = jettyRequest.getHttpURI();\n-                    HttpURI newURI = new HttpURI(uri);\n-                    String newPath = \"/new_path/\" + path.substring(\"/old_path/\".length());\n-                    newURI.setPath(newPath);\n+                    HttpURI newURI = HttpURI.build(uri).path(\"/new_path/\" + path.substring(\"/old_path/\".length()));", "originalCommit": "fa86645a99b52390456f0c04bea50f94b890daf5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcxNDExNQ==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413714115", "bodyText": "I feel better to use remove() field by field, rather than getField() + remove(EnumSet).\nReason being that if there is one more/less header to treat in this way, I will never remember to add/remove it from the EnumSet.", "author": "sbordet", "createdAt": "2020-04-23T10:50:59Z", "path": "jetty-fcgi/fcgi-client/src/main/java/org/eclipse/jetty/fcgi/client/http/HttpSenderOverFCGI.java", "diffHunk": "@@ -74,13 +71,14 @@ protected void sendHeaders(HttpExchange exchange, ByteBuffer contentBuffer, bool\n         fcgiHeaders.put(FCGI.Headers.QUERY_STRING, query == null ? \"\" : query);\n \n         // FastCGI headers based on HTTP headers\n-        HttpField httpField = headers.remove(HttpHeader.AUTHORIZATION);\n+        HttpField httpField = headers.getField(HttpHeader.AUTHORIZATION);\n         if (httpField != null)\n             fcgiHeaders.put(FCGI.Headers.AUTH_TYPE, httpField.getValue());\n-        httpField = headers.remove(HttpHeader.CONTENT_LENGTH);\n+        httpField = headers.getField(HttpHeader.CONTENT_LENGTH);\n         fcgiHeaders.put(FCGI.Headers.CONTENT_LENGTH, httpField == null ? \"\" : httpField.getValue());\n-        httpField = headers.remove(HttpHeader.CONTENT_TYPE);\n+        httpField = headers.getField(HttpHeader.CONTENT_TYPE);\n         fcgiHeaders.put(FCGI.Headers.CONTENT_TYPE, httpField == null ? \"\" : httpField.getValue());\n+        headers.remove(EnumSet.of(HttpHeader.AUTHORIZATION, HttpHeader.CONTENT_LENGTH, HttpHeader.CONTENT_TYPE));", "originalCommit": "fa86645a99b52390456f0c04bea50f94b890daf5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDM3MTAwMA==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r414371000", "bodyText": "Actually it can be even simplified more.  No need for headers to be mutable anyway!", "author": "gregw", "createdAt": "2020-04-24T07:52:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcxNDExNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcxNDgyOQ==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413714829", "bodyText": "Remove asString().", "author": "sbordet", "createdAt": "2020-04-23T10:52:08Z", "path": "jetty-fcgi/fcgi-server/src/main/java/org/eclipse/jetty/fcgi/server/proxy/FastCGIProxyServlet.java", "diffHunk": "@@ -180,7 +180,7 @@ protected void sendProxyRequest(HttpServletRequest request, HttpServletResponse\n             proxyRequest.attribute(REQUEST_QUERY_ATTRIBUTE, originalQuery);\n \n         // If the Host header is missing, add it.\n-        if (!proxyRequest.getHeaders().containsKey(HttpHeader.HOST.asString()))\n+        if (!proxyRequest.getHeaders().contains(HttpHeader.HOST.asString()))", "originalCommit": "fa86645a99b52390456f0c04bea50f94b890daf5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcxOTYxNQ==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413719615", "bodyText": "Remove .Mutable.", "author": "sbordet", "createdAt": "2020-04-23T10:59:52Z", "path": "jetty-http/src/main/java/org/eclipse/jetty/http/HttpParser.java", "diffHunk": "@@ -72,7 +72,7 @@\n  * is used to lookup common combinations of headers and values\n  * (eg. \"Connection: close\"), or just header names (eg. \"Connection:\" ).\n  * For headers who's value is not known statically (eg. Host, COOKIE) then a\n- * per parser dynamic Trie of {@link HttpFields} from previous parsed messages\n+ * per parser dynamic Trie of {@link HttpFields.Mutable} from previous parsed messages", "originalCommit": "fa86645a99b52390456f0c04bea50f94b890daf5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcyMDAzOQ==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413720039", "bodyText": "Don't refer to HttpFields.", "author": "sbordet", "createdAt": "2020-04-23T11:00:35Z", "path": "jetty-http/src/main/java/org/eclipse/jetty/http/HttpURI.java", "diffHunk": "@@ -18,798 +18,1064 @@\n \n package org.eclipse.jetty.http;\n \n-import java.io.UnsupportedEncodingException;\n import java.net.URI;\n import java.net.URISyntaxException;\n-import java.nio.charset.Charset;\n-import java.nio.charset.StandardCharsets;\n \n-import org.eclipse.jetty.util.MultiMap;\n+import org.eclipse.jetty.util.HostPort;\n+import org.eclipse.jetty.util.StringUtil;\n import org.eclipse.jetty.util.TypeUtil;\n import org.eclipse.jetty.util.URIUtil;\n import org.eclipse.jetty.util.UrlEncoded;\n \n /**\n  * Http URI.\n- * Parse an HTTP URI from a string or byte array.  Given a URI\n- * <code>http://user@host:port/path/info;param?query#fragment</code>\n- * this class will split it into the following undecoded optional elements:<ul>\n+ *\n+ * Both {@link HttpFields.Mutable} and {@link HttpFields.Immutable} implementations are available", "originalCommit": "fa86645a99b52390456f0c04bea50f94b890daf5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcyMDE4OQ==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413720189", "bodyText": "Restore fragments.", "author": "sbordet", "createdAt": "2020-04-23T11:00:51Z", "path": "jetty-http/src/main/java/org/eclipse/jetty/http/HttpURI.java", "diffHunk": "@@ -18,798 +18,1064 @@\n \n package org.eclipse.jetty.http;\n \n-import java.io.UnsupportedEncodingException;\n import java.net.URI;\n import java.net.URISyntaxException;\n-import java.nio.charset.Charset;\n-import java.nio.charset.StandardCharsets;\n \n-import org.eclipse.jetty.util.MultiMap;\n+import org.eclipse.jetty.util.HostPort;\n+import org.eclipse.jetty.util.StringUtil;\n import org.eclipse.jetty.util.TypeUtil;\n import org.eclipse.jetty.util.URIUtil;\n import org.eclipse.jetty.util.UrlEncoded;\n \n /**\n  * Http URI.\n- * Parse an HTTP URI from a string or byte array.  Given a URI\n- * <code>http://user@host:port/path/info;param?query#fragment</code>\n- * this class will split it into the following undecoded optional elements:<ul>\n+ *\n+ * Both {@link HttpFields.Mutable} and {@link HttpFields.Immutable} implementations are available\n+ * via the static methods such as {@link #build()} and {@link #from(String)}.\n+ *\n+ * A URI such as\n+ * <code>http://user@host:port/path;ignored/info;param?query#ignored</code>\n+ * is split into the following undecoded elements:<ul>\n  * <li>{@link #getScheme()} - http:</li>\n  * <li>{@link #getAuthority()} - //name@host:port</li>\n  * <li>{@link #getHost()} - host</li>\n  * <li>{@link #getPort()} - port</li>\n  * <li>{@link #getPath()} - /path/info</li>\n  * <li>{@link #getParam()} - param</li>\n  * <li>{@link #getQuery()} - query</li>\n- * <li>{@link #getFragment()} - fragment</li>\n  * </ul>\n- *\n  * <p>Any parameters will be returned from {@link #getPath()}, but are excluded from the\n  * return value of {@link #getDecodedPath()}.   If there are multiple parameters, the\n- * {@link #getParam()} method returns only the last one.\n+ * {@link #getParam()} method returns only the last one. Fragments are ignored.", "originalCommit": "fa86645a99b52390456f0c04bea50f94b890daf5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcyMTUxOA==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413721518", "bodyText": "Please use the same order of the fields declarations, otherwise it's too difficult to say if we forgot to assign a field.", "author": "sbordet", "createdAt": "2020-04-23T11:03:00Z", "path": "jetty-http/src/main/java/org/eclipse/jetty/http/HttpURI.java", "diffHunk": "@@ -18,798 +18,1064 @@\n \n package org.eclipse.jetty.http;\n \n-import java.io.UnsupportedEncodingException;\n import java.net.URI;\n import java.net.URISyntaxException;\n-import java.nio.charset.Charset;\n-import java.nio.charset.StandardCharsets;\n \n-import org.eclipse.jetty.util.MultiMap;\n+import org.eclipse.jetty.util.HostPort;\n+import org.eclipse.jetty.util.StringUtil;\n import org.eclipse.jetty.util.TypeUtil;\n import org.eclipse.jetty.util.URIUtil;\n import org.eclipse.jetty.util.UrlEncoded;\n \n /**\n  * Http URI.\n- * Parse an HTTP URI from a string or byte array.  Given a URI\n- * <code>http://user@host:port/path/info;param?query#fragment</code>\n- * this class will split it into the following undecoded optional elements:<ul>\n+ *\n+ * Both {@link HttpFields.Mutable} and {@link HttpFields.Immutable} implementations are available\n+ * via the static methods such as {@link #build()} and {@link #from(String)}.\n+ *\n+ * A URI such as\n+ * <code>http://user@host:port/path;ignored/info;param?query#ignored</code>\n+ * is split into the following undecoded elements:<ul>\n  * <li>{@link #getScheme()} - http:</li>\n  * <li>{@link #getAuthority()} - //name@host:port</li>\n  * <li>{@link #getHost()} - host</li>\n  * <li>{@link #getPort()} - port</li>\n  * <li>{@link #getPath()} - /path/info</li>\n  * <li>{@link #getParam()} - param</li>\n  * <li>{@link #getQuery()} - query</li>\n- * <li>{@link #getFragment()} - fragment</li>\n  * </ul>\n- *\n  * <p>Any parameters will be returned from {@link #getPath()}, but are excluded from the\n  * return value of {@link #getDecodedPath()}.   If there are multiple parameters, the\n- * {@link #getParam()} method returns only the last one.\n+ * {@link #getParam()} method returns only the last one. Fragments are ignored.\n  */\n-public class HttpURI\n+public interface HttpURI\n {\n-    private enum State\n+    static Mutable build()\n     {\n-        START,\n-        HOST_OR_PATH,\n-        SCHEME_OR_PATH,\n-        HOST,\n-        IPV6,\n-        PORT,\n-        PATH,\n-        PARAM,\n-        QUERY,\n-        FRAGMENT,\n-        ASTERISK\n+        return new Mutable();\n     }\n \n-    ;\n-\n-    private String _scheme;\n-    private String _user;\n-    private String _host;\n-    private int _port;\n-    private String _path;\n-    private String _param;\n-    private String _query;\n-    private String _fragment;\n-\n-    String _uri;\n-    String _decodedPath;\n-\n-    /**\n-     * Construct a normalized URI.\n-     * Port is not set if it is the default port.\n-     *\n-     * @param scheme the URI scheme\n-     * @param host the URI hose\n-     * @param port the URI port\n-     * @param path the URI path\n-     * @param param the URI param\n-     * @param query the URI query\n-     * @param fragment the URI fragment\n-     * @return the normalized URI\n-     */\n-    public static HttpURI createHttpURI(String scheme, String host, int port, String path, String param, String query, String fragment)\n+    static Mutable build(HttpURI uri)\n     {\n-        if (port == 80 && HttpScheme.HTTP.is(scheme))\n-            port = 0;\n-        if (port == 443 && HttpScheme.HTTPS.is(scheme))\n-            port = 0;\n-        return new HttpURI(scheme, host, port, path, param, query, fragment);\n+        return new Mutable(uri);\n     }\n \n-    public HttpURI()\n+    static Mutable build(HttpURI uri, String pathQuery)\n     {\n+        return new Mutable(uri, pathQuery);\n     }\n \n-    public HttpURI(String scheme, String host, int port, String path, String param, String query, String fragment)\n+    static Mutable build(HttpURI uri, String path, String param, String query)\n     {\n-        _scheme = scheme;\n-        _host = host;\n-        _port = port;\n-        _path = path;\n-        _param = param;\n-        _query = query;\n-        _fragment = fragment;\n+        return new Mutable(uri, path, param, query);\n     }\n \n-    public HttpURI(HttpURI uri)\n+    static Mutable build(URI uri)\n     {\n-        this(uri._scheme, uri._host, uri._port, uri._path, uri._param, uri._query, uri._fragment);\n-        _uri = uri._uri;\n+        return new Mutable(uri);\n     }\n \n-    public HttpURI(String uri)\n+    static Mutable build(String uri)\n     {\n-        _port = -1;\n-        parse(State.START, uri);\n+        return new Mutable(uri);\n     }\n \n-    public HttpURI(URI uri)\n+    static Immutable from(URI uri)\n     {\n-        _uri = null;\n-\n-        _scheme = uri.getScheme();\n-        _host = uri.getHost();\n-        if (_host == null && uri.getRawSchemeSpecificPart().startsWith(\"//\"))\n-            _host = \"\";\n-        _port = uri.getPort();\n-        _user = uri.getUserInfo();\n-        _path = uri.getRawPath();\n-\n-        _decodedPath = uri.getPath();\n-        if (_decodedPath != null)\n-        {\n-            int p = _decodedPath.lastIndexOf(';');\n-            if (p >= 0)\n-                _param = _decodedPath.substring(p + 1);\n-        }\n-        _query = uri.getRawQuery();\n-        _fragment = uri.getFragment();\n-\n-        _decodedPath = null;\n+        return new HttpURI.Mutable(uri).asImmutable();\n     }\n \n-    public HttpURI(String scheme, String host, int port, String pathQuery)\n+    static Immutable from(String uri)\n     {\n-        _uri = null;\n-\n-        _scheme = scheme;\n-        _host = host;\n-        _port = port;\n-\n-        if (pathQuery != null)\n-            parse(State.PATH, pathQuery);\n+        return new HttpURI.Mutable(uri).asImmutable();\n     }\n \n-    public void parse(String uri)\n+    static Immutable from(String method, String uri)\n     {\n-        clear();\n-        _uri = uri;\n-        parse(State.START, uri);\n+        if (HttpMethod.CONNECT.is(method))\n+            return new Immutable(uri);\n+        if (uri.startsWith(\"/\"))\n+            return HttpURI.build().pathQuery(uri).asImmutable();\n+        return HttpURI.from(uri);\n     }\n \n-    public void parse(String uri, int offset, int length)\n+    static Immutable from(String scheme, String host, int port, String pathQuery)\n     {\n-        clear();\n-        int end = offset + length;\n-        _uri = uri.substring(offset, end);\n-        parse(State.START, uri);\n+        return new Mutable(scheme, host, port, pathQuery).asImmutable();\n     }\n \n-    private void parse(State state, final String uri)\n-    {\n-        boolean encoded = false;\n-        int end = uri.length();\n-        int mark = 0;\n-        int pathMark = 0;\n-        char last = '/';\n-        for (int i = 0; i < end; i++)\n-        {\n-            char c = uri.charAt(i);\n+    Immutable asImmutable();\n \n-            switch (state)\n-            {\n-                case START:\n-                {\n-                    switch (c)\n-                    {\n-                        case '/':\n-                            mark = i;\n-                            state = State.HOST_OR_PATH;\n-                            break;\n-                        case ';':\n-                            mark = i + 1;\n-                            state = State.PARAM;\n-                            break;\n-                        case '?':\n-                            // assume empty path (if seen at start)\n-                            _path = \"\";\n-                            mark = i + 1;\n-                            state = State.QUERY;\n-                            break;\n-                        case '#':\n-                            mark = i + 1;\n-                            state = State.FRAGMENT;\n-                            break;\n-                        case '*':\n-                            _path = \"*\";\n-                            state = State.ASTERISK;\n-                            break;\n-\n-                        case '.':\n-                            pathMark = i;\n-                            state = State.PATH;\n-                            encoded = true;\n-                            break;\n-\n-                        default:\n-                            mark = i;\n-                            if (_scheme == null)\n-                                state = State.SCHEME_OR_PATH;\n-                            else\n-                            {\n-                                pathMark = i;\n-                                state = State.PATH;\n-                            }\n-                            break;\n-                    }\n+    String getAuthority();\n \n-                    continue;\n-                }\n+    String getDecodedPath();\n \n-                case SCHEME_OR_PATH:\n-                {\n-                    switch (c)\n-                    {\n-                        case ':':\n-                            // must have been a scheme\n-                            _scheme = uri.substring(mark, i);\n-                            // Start again with scheme set\n-                            state = State.START;\n-                            break;\n-\n-                        case '/':\n-                            // must have been in a path and still are\n-                            state = State.PATH;\n-                            break;\n+    String getHost();\n \n-                        case ';':\n-                            // must have been in a path \n-                            mark = i + 1;\n-                            state = State.PARAM;\n-                            break;\n+    String getParam();\n \n-                        case '?':\n-                            // must have been in a path \n-                            _path = uri.substring(mark, i);\n-                            mark = i + 1;\n-                            state = State.QUERY;\n-                            break;\n+    String getPath();\n \n-                        case '%':\n-                            // must have be in an encoded path \n-                            encoded = true;\n-                            state = State.PATH;\n-                            break;\n+    String getPathQuery();\n \n-                        case '#':\n-                            // must have been in a path \n-                            _path = uri.substring(mark, i);\n-                            state = State.FRAGMENT;\n-                            break;\n+    int getPort();\n \n-                        default:\n-                            break;\n-                    }\n-                    continue;\n-                }\n+    String getQuery();\n \n-                case HOST_OR_PATH:\n-                {\n-                    switch (c)\n-                    {\n-                        case '/':\n-                            _host = \"\";\n-                            mark = i + 1;\n-                            state = State.HOST;\n-                            break;\n-\n-                        case '@':\n-                        case ';':\n-                        case '?':\n-                        case '#':\n-                            // was a path, look again\n-                            i--;\n-                            pathMark = mark;\n-                            state = State.PATH;\n-                            break;\n+    String getScheme();\n \n-                        case '.':\n-                            // it is a path\n-                            encoded = true;\n-                            pathMark = mark;\n-                            state = State.PATH;\n-                            break;\n+    String getUser();\n \n-                        default:\n-                            // it is a path\n-                            pathMark = mark;\n-                            state = State.PATH;\n-                    }\n-                    continue;\n-                }\n+    boolean hasAuthority();\n \n-                case HOST:\n-                {\n-                    switch (c)\n-                    {\n-                        case '/':\n-                            _host = uri.substring(mark, i);\n-                            pathMark = mark = i;\n-                            state = State.PATH;\n-                            break;\n-                        case ':':\n-                            if (i > mark)\n-                                _host = uri.substring(mark, i);\n-                            mark = i + 1;\n-                            state = State.PORT;\n-                            break;\n-                        case '@':\n-                            if (_user != null)\n-                                throw new IllegalArgumentException(\"Bad authority\");\n-                            _user = uri.substring(mark, i);\n-                            mark = i + 1;\n-                            break;\n+    boolean isAbsolute();\n \n-                        case '[':\n-                            state = State.IPV6;\n-                            break;\n+    default URI toURI()\n+    {\n+        try\n+        {\n+            String query = getQuery();\n+            return new URI(getScheme(), null, getHost(), getPort(), getPath(), query == null ? null : UrlEncoded.decodeString(query), null);\n+        }\n+        catch (URISyntaxException x)\n+        {\n+            throw new RuntimeException(x);\n+        }\n+    }\n \n-                        default:\n-                            break;\n-                    }\n-                    break;\n-                }\n+    class Immutable implements HttpURI\n+    {\n+        private final String _scheme;\n+        private final String _user;\n+        private final String _host;\n+        private final int _port;\n+        private final String _path;\n+        private final String _param;\n+        private final String _query;\n+        private String _uri;\n+        private String _decodedPath;\n+\n+        private Immutable(Mutable builder)\n+        {\n+            _uri = builder._uri;\n+            _scheme = builder._scheme;\n+            _user = builder._user;\n+            _host = builder._host;\n+            _port = builder._port;\n+            _path = builder._path;\n+            _decodedPath = builder._decodedPath;\n+            _param = builder._param;\n+            _query = builder._query;\n+        }\n \n-                case IPV6:\n-                {\n-                    switch (c)\n-                    {\n-                        case '/':\n-                            throw new IllegalArgumentException(\"No closing ']' for ipv6 in \" + uri);\n-                        case ']':\n-                            c = uri.charAt(++i);\n-                            _host = uri.substring(mark, i);\n-                            if (c == ':')\n-                            {\n-                                mark = i + 1;\n-                                state = State.PORT;\n-                            }\n-                            else\n-                            {\n-                                pathMark = mark = i;\n-                                state = State.PATH;\n-                            }\n-                            break;\n+        private Immutable(String uri)\n+        {\n+            _uri = uri;\n+            _scheme = null;\n+            _user = null;\n+            _host = null;\n+            _port = -1;\n+            _path = uri;\n+            _decodedPath = null;\n+            _param = null;\n+            _query = null;\n+        }", "originalCommit": "fa86645a99b52390456f0c04bea50f94b890daf5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcyMzEyOA==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413723128", "bodyText": "Don't this is a good idea to use toString() for equality, since we may modify toString() to include the hashCode and now we are screwed.\nIntroduce an asString() method or toURI() with a clear semantic and use those.", "author": "sbordet", "createdAt": "2020-04-23T11:05:52Z", "path": "jetty-http/src/main/java/org/eclipse/jetty/http/HttpURI.java", "diffHunk": "@@ -18,798 +18,1064 @@\n \n package org.eclipse.jetty.http;\n \n-import java.io.UnsupportedEncodingException;\n import java.net.URI;\n import java.net.URISyntaxException;\n-import java.nio.charset.Charset;\n-import java.nio.charset.StandardCharsets;\n \n-import org.eclipse.jetty.util.MultiMap;\n+import org.eclipse.jetty.util.HostPort;\n+import org.eclipse.jetty.util.StringUtil;\n import org.eclipse.jetty.util.TypeUtil;\n import org.eclipse.jetty.util.URIUtil;\n import org.eclipse.jetty.util.UrlEncoded;\n \n /**\n  * Http URI.\n- * Parse an HTTP URI from a string or byte array.  Given a URI\n- * <code>http://user@host:port/path/info;param?query#fragment</code>\n- * this class will split it into the following undecoded optional elements:<ul>\n+ *\n+ * Both {@link HttpFields.Mutable} and {@link HttpFields.Immutable} implementations are available\n+ * via the static methods such as {@link #build()} and {@link #from(String)}.\n+ *\n+ * A URI such as\n+ * <code>http://user@host:port/path;ignored/info;param?query#ignored</code>\n+ * is split into the following undecoded elements:<ul>\n  * <li>{@link #getScheme()} - http:</li>\n  * <li>{@link #getAuthority()} - //name@host:port</li>\n  * <li>{@link #getHost()} - host</li>\n  * <li>{@link #getPort()} - port</li>\n  * <li>{@link #getPath()} - /path/info</li>\n  * <li>{@link #getParam()} - param</li>\n  * <li>{@link #getQuery()} - query</li>\n- * <li>{@link #getFragment()} - fragment</li>\n  * </ul>\n- *\n  * <p>Any parameters will be returned from {@link #getPath()}, but are excluded from the\n  * return value of {@link #getDecodedPath()}.   If there are multiple parameters, the\n- * {@link #getParam()} method returns only the last one.\n+ * {@link #getParam()} method returns only the last one. Fragments are ignored.\n  */\n-public class HttpURI\n+public interface HttpURI\n {\n-    private enum State\n+    static Mutable build()\n     {\n-        START,\n-        HOST_OR_PATH,\n-        SCHEME_OR_PATH,\n-        HOST,\n-        IPV6,\n-        PORT,\n-        PATH,\n-        PARAM,\n-        QUERY,\n-        FRAGMENT,\n-        ASTERISK\n+        return new Mutable();\n     }\n \n-    ;\n-\n-    private String _scheme;\n-    private String _user;\n-    private String _host;\n-    private int _port;\n-    private String _path;\n-    private String _param;\n-    private String _query;\n-    private String _fragment;\n-\n-    String _uri;\n-    String _decodedPath;\n-\n-    /**\n-     * Construct a normalized URI.\n-     * Port is not set if it is the default port.\n-     *\n-     * @param scheme the URI scheme\n-     * @param host the URI hose\n-     * @param port the URI port\n-     * @param path the URI path\n-     * @param param the URI param\n-     * @param query the URI query\n-     * @param fragment the URI fragment\n-     * @return the normalized URI\n-     */\n-    public static HttpURI createHttpURI(String scheme, String host, int port, String path, String param, String query, String fragment)\n+    static Mutable build(HttpURI uri)\n     {\n-        if (port == 80 && HttpScheme.HTTP.is(scheme))\n-            port = 0;\n-        if (port == 443 && HttpScheme.HTTPS.is(scheme))\n-            port = 0;\n-        return new HttpURI(scheme, host, port, path, param, query, fragment);\n+        return new Mutable(uri);\n     }\n \n-    public HttpURI()\n+    static Mutable build(HttpURI uri, String pathQuery)\n     {\n+        return new Mutable(uri, pathQuery);\n     }\n \n-    public HttpURI(String scheme, String host, int port, String path, String param, String query, String fragment)\n+    static Mutable build(HttpURI uri, String path, String param, String query)\n     {\n-        _scheme = scheme;\n-        _host = host;\n-        _port = port;\n-        _path = path;\n-        _param = param;\n-        _query = query;\n-        _fragment = fragment;\n+        return new Mutable(uri, path, param, query);\n     }\n \n-    public HttpURI(HttpURI uri)\n+    static Mutable build(URI uri)\n     {\n-        this(uri._scheme, uri._host, uri._port, uri._path, uri._param, uri._query, uri._fragment);\n-        _uri = uri._uri;\n+        return new Mutable(uri);\n     }\n \n-    public HttpURI(String uri)\n+    static Mutable build(String uri)\n     {\n-        _port = -1;\n-        parse(State.START, uri);\n+        return new Mutable(uri);\n     }\n \n-    public HttpURI(URI uri)\n+    static Immutable from(URI uri)\n     {\n-        _uri = null;\n-\n-        _scheme = uri.getScheme();\n-        _host = uri.getHost();\n-        if (_host == null && uri.getRawSchemeSpecificPart().startsWith(\"//\"))\n-            _host = \"\";\n-        _port = uri.getPort();\n-        _user = uri.getUserInfo();\n-        _path = uri.getRawPath();\n-\n-        _decodedPath = uri.getPath();\n-        if (_decodedPath != null)\n-        {\n-            int p = _decodedPath.lastIndexOf(';');\n-            if (p >= 0)\n-                _param = _decodedPath.substring(p + 1);\n-        }\n-        _query = uri.getRawQuery();\n-        _fragment = uri.getFragment();\n-\n-        _decodedPath = null;\n+        return new HttpURI.Mutable(uri).asImmutable();\n     }\n \n-    public HttpURI(String scheme, String host, int port, String pathQuery)\n+    static Immutable from(String uri)\n     {\n-        _uri = null;\n-\n-        _scheme = scheme;\n-        _host = host;\n-        _port = port;\n-\n-        if (pathQuery != null)\n-            parse(State.PATH, pathQuery);\n+        return new HttpURI.Mutable(uri).asImmutable();\n     }\n \n-    public void parse(String uri)\n+    static Immutable from(String method, String uri)\n     {\n-        clear();\n-        _uri = uri;\n-        parse(State.START, uri);\n+        if (HttpMethod.CONNECT.is(method))\n+            return new Immutable(uri);\n+        if (uri.startsWith(\"/\"))\n+            return HttpURI.build().pathQuery(uri).asImmutable();\n+        return HttpURI.from(uri);\n     }\n \n-    public void parse(String uri, int offset, int length)\n+    static Immutable from(String scheme, String host, int port, String pathQuery)\n     {\n-        clear();\n-        int end = offset + length;\n-        _uri = uri.substring(offset, end);\n-        parse(State.START, uri);\n+        return new Mutable(scheme, host, port, pathQuery).asImmutable();\n     }\n \n-    private void parse(State state, final String uri)\n-    {\n-        boolean encoded = false;\n-        int end = uri.length();\n-        int mark = 0;\n-        int pathMark = 0;\n-        char last = '/';\n-        for (int i = 0; i < end; i++)\n-        {\n-            char c = uri.charAt(i);\n+    Immutable asImmutable();\n \n-            switch (state)\n-            {\n-                case START:\n-                {\n-                    switch (c)\n-                    {\n-                        case '/':\n-                            mark = i;\n-                            state = State.HOST_OR_PATH;\n-                            break;\n-                        case ';':\n-                            mark = i + 1;\n-                            state = State.PARAM;\n-                            break;\n-                        case '?':\n-                            // assume empty path (if seen at start)\n-                            _path = \"\";\n-                            mark = i + 1;\n-                            state = State.QUERY;\n-                            break;\n-                        case '#':\n-                            mark = i + 1;\n-                            state = State.FRAGMENT;\n-                            break;\n-                        case '*':\n-                            _path = \"*\";\n-                            state = State.ASTERISK;\n-                            break;\n-\n-                        case '.':\n-                            pathMark = i;\n-                            state = State.PATH;\n-                            encoded = true;\n-                            break;\n-\n-                        default:\n-                            mark = i;\n-                            if (_scheme == null)\n-                                state = State.SCHEME_OR_PATH;\n-                            else\n-                            {\n-                                pathMark = i;\n-                                state = State.PATH;\n-                            }\n-                            break;\n-                    }\n+    String getAuthority();\n \n-                    continue;\n-                }\n+    String getDecodedPath();\n \n-                case SCHEME_OR_PATH:\n-                {\n-                    switch (c)\n-                    {\n-                        case ':':\n-                            // must have been a scheme\n-                            _scheme = uri.substring(mark, i);\n-                            // Start again with scheme set\n-                            state = State.START;\n-                            break;\n-\n-                        case '/':\n-                            // must have been in a path and still are\n-                            state = State.PATH;\n-                            break;\n+    String getHost();\n \n-                        case ';':\n-                            // must have been in a path \n-                            mark = i + 1;\n-                            state = State.PARAM;\n-                            break;\n+    String getParam();\n \n-                        case '?':\n-                            // must have been in a path \n-                            _path = uri.substring(mark, i);\n-                            mark = i + 1;\n-                            state = State.QUERY;\n-                            break;\n+    String getPath();\n \n-                        case '%':\n-                            // must have be in an encoded path \n-                            encoded = true;\n-                            state = State.PATH;\n-                            break;\n+    String getPathQuery();\n \n-                        case '#':\n-                            // must have been in a path \n-                            _path = uri.substring(mark, i);\n-                            state = State.FRAGMENT;\n-                            break;\n+    int getPort();\n \n-                        default:\n-                            break;\n-                    }\n-                    continue;\n-                }\n+    String getQuery();\n \n-                case HOST_OR_PATH:\n-                {\n-                    switch (c)\n-                    {\n-                        case '/':\n-                            _host = \"\";\n-                            mark = i + 1;\n-                            state = State.HOST;\n-                            break;\n-\n-                        case '@':\n-                        case ';':\n-                        case '?':\n-                        case '#':\n-                            // was a path, look again\n-                            i--;\n-                            pathMark = mark;\n-                            state = State.PATH;\n-                            break;\n+    String getScheme();\n \n-                        case '.':\n-                            // it is a path\n-                            encoded = true;\n-                            pathMark = mark;\n-                            state = State.PATH;\n-                            break;\n+    String getUser();\n \n-                        default:\n-                            // it is a path\n-                            pathMark = mark;\n-                            state = State.PATH;\n-                    }\n-                    continue;\n-                }\n+    boolean hasAuthority();\n \n-                case HOST:\n-                {\n-                    switch (c)\n-                    {\n-                        case '/':\n-                            _host = uri.substring(mark, i);\n-                            pathMark = mark = i;\n-                            state = State.PATH;\n-                            break;\n-                        case ':':\n-                            if (i > mark)\n-                                _host = uri.substring(mark, i);\n-                            mark = i + 1;\n-                            state = State.PORT;\n-                            break;\n-                        case '@':\n-                            if (_user != null)\n-                                throw new IllegalArgumentException(\"Bad authority\");\n-                            _user = uri.substring(mark, i);\n-                            mark = i + 1;\n-                            break;\n+    boolean isAbsolute();\n \n-                        case '[':\n-                            state = State.IPV6;\n-                            break;\n+    default URI toURI()\n+    {\n+        try\n+        {\n+            String query = getQuery();\n+            return new URI(getScheme(), null, getHost(), getPort(), getPath(), query == null ? null : UrlEncoded.decodeString(query), null);\n+        }\n+        catch (URISyntaxException x)\n+        {\n+            throw new RuntimeException(x);\n+        }\n+    }\n \n-                        default:\n-                            break;\n-                    }\n-                    break;\n-                }\n+    class Immutable implements HttpURI\n+    {\n+        private final String _scheme;\n+        private final String _user;\n+        private final String _host;\n+        private final int _port;\n+        private final String _path;\n+        private final String _param;\n+        private final String _query;\n+        private String _uri;\n+        private String _decodedPath;\n+\n+        private Immutable(Mutable builder)\n+        {\n+            _uri = builder._uri;\n+            _scheme = builder._scheme;\n+            _user = builder._user;\n+            _host = builder._host;\n+            _port = builder._port;\n+            _path = builder._path;\n+            _decodedPath = builder._decodedPath;\n+            _param = builder._param;\n+            _query = builder._query;\n+        }\n \n-                case IPV6:\n-                {\n-                    switch (c)\n-                    {\n-                        case '/':\n-                            throw new IllegalArgumentException(\"No closing ']' for ipv6 in \" + uri);\n-                        case ']':\n-                            c = uri.charAt(++i);\n-                            _host = uri.substring(mark, i);\n-                            if (c == ':')\n-                            {\n-                                mark = i + 1;\n-                                state = State.PORT;\n-                            }\n-                            else\n-                            {\n-                                pathMark = mark = i;\n-                                state = State.PATH;\n-                            }\n-                            break;\n+        private Immutable(String uri)\n+        {\n+            _uri = uri;\n+            _scheme = null;\n+            _user = null;\n+            _host = null;\n+            _port = -1;\n+            _path = uri;\n+            _decodedPath = null;\n+            _param = null;\n+            _query = null;\n+        }\n \n-                        default:\n-                            break;\n-                    }\n+        @Override\n+        public Immutable asImmutable()\n+        {\n+            return this;\n+        }\n \n-                    break;\n-                }\n+        @Override\n+        public boolean equals(Object o)\n+        {\n+            if (o == this)\n+                return true;\n+            if (!(o instanceof HttpURI))\n+                return false;\n+            return toString().equals(o.toString());", "originalCommit": "fa86645a99b52390456f0c04bea50f94b890daf5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcyNDE4OA==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413724188", "bodyText": "The implementation of hashCode() is missing! It must be there if equals() is overridden.", "author": "sbordet", "createdAt": "2020-04-23T11:07:38Z", "path": "jetty-http/src/main/java/org/eclipse/jetty/http/HttpURI.java", "diffHunk": "@@ -18,798 +18,1064 @@\n \n package org.eclipse.jetty.http;\n \n-import java.io.UnsupportedEncodingException;\n import java.net.URI;\n import java.net.URISyntaxException;\n-import java.nio.charset.Charset;\n-import java.nio.charset.StandardCharsets;\n \n-import org.eclipse.jetty.util.MultiMap;\n+import org.eclipse.jetty.util.HostPort;\n+import org.eclipse.jetty.util.StringUtil;\n import org.eclipse.jetty.util.TypeUtil;\n import org.eclipse.jetty.util.URIUtil;\n import org.eclipse.jetty.util.UrlEncoded;\n \n /**\n  * Http URI.\n- * Parse an HTTP URI from a string or byte array.  Given a URI\n- * <code>http://user@host:port/path/info;param?query#fragment</code>\n- * this class will split it into the following undecoded optional elements:<ul>\n+ *\n+ * Both {@link HttpFields.Mutable} and {@link HttpFields.Immutable} implementations are available\n+ * via the static methods such as {@link #build()} and {@link #from(String)}.\n+ *\n+ * A URI such as\n+ * <code>http://user@host:port/path;ignored/info;param?query#ignored</code>\n+ * is split into the following undecoded elements:<ul>\n  * <li>{@link #getScheme()} - http:</li>\n  * <li>{@link #getAuthority()} - //name@host:port</li>\n  * <li>{@link #getHost()} - host</li>\n  * <li>{@link #getPort()} - port</li>\n  * <li>{@link #getPath()} - /path/info</li>\n  * <li>{@link #getParam()} - param</li>\n  * <li>{@link #getQuery()} - query</li>\n- * <li>{@link #getFragment()} - fragment</li>\n  * </ul>\n- *\n  * <p>Any parameters will be returned from {@link #getPath()}, but are excluded from the\n  * return value of {@link #getDecodedPath()}.   If there are multiple parameters, the\n- * {@link #getParam()} method returns only the last one.\n+ * {@link #getParam()} method returns only the last one. Fragments are ignored.\n  */\n-public class HttpURI\n+public interface HttpURI\n {\n-    private enum State\n+    static Mutable build()\n     {\n-        START,\n-        HOST_OR_PATH,\n-        SCHEME_OR_PATH,\n-        HOST,\n-        IPV6,\n-        PORT,\n-        PATH,\n-        PARAM,\n-        QUERY,\n-        FRAGMENT,\n-        ASTERISK\n+        return new Mutable();\n     }\n \n-    ;\n-\n-    private String _scheme;\n-    private String _user;\n-    private String _host;\n-    private int _port;\n-    private String _path;\n-    private String _param;\n-    private String _query;\n-    private String _fragment;\n-\n-    String _uri;\n-    String _decodedPath;\n-\n-    /**\n-     * Construct a normalized URI.\n-     * Port is not set if it is the default port.\n-     *\n-     * @param scheme the URI scheme\n-     * @param host the URI hose\n-     * @param port the URI port\n-     * @param path the URI path\n-     * @param param the URI param\n-     * @param query the URI query\n-     * @param fragment the URI fragment\n-     * @return the normalized URI\n-     */\n-    public static HttpURI createHttpURI(String scheme, String host, int port, String path, String param, String query, String fragment)\n+    static Mutable build(HttpURI uri)\n     {\n-        if (port == 80 && HttpScheme.HTTP.is(scheme))\n-            port = 0;\n-        if (port == 443 && HttpScheme.HTTPS.is(scheme))\n-            port = 0;\n-        return new HttpURI(scheme, host, port, path, param, query, fragment);\n+        return new Mutable(uri);\n     }\n \n-    public HttpURI()\n+    static Mutable build(HttpURI uri, String pathQuery)\n     {\n+        return new Mutable(uri, pathQuery);\n     }\n \n-    public HttpURI(String scheme, String host, int port, String path, String param, String query, String fragment)\n+    static Mutable build(HttpURI uri, String path, String param, String query)\n     {\n-        _scheme = scheme;\n-        _host = host;\n-        _port = port;\n-        _path = path;\n-        _param = param;\n-        _query = query;\n-        _fragment = fragment;\n+        return new Mutable(uri, path, param, query);\n     }\n \n-    public HttpURI(HttpURI uri)\n+    static Mutable build(URI uri)\n     {\n-        this(uri._scheme, uri._host, uri._port, uri._path, uri._param, uri._query, uri._fragment);\n-        _uri = uri._uri;\n+        return new Mutable(uri);\n     }\n \n-    public HttpURI(String uri)\n+    static Mutable build(String uri)\n     {\n-        _port = -1;\n-        parse(State.START, uri);\n+        return new Mutable(uri);\n     }\n \n-    public HttpURI(URI uri)\n+    static Immutable from(URI uri)\n     {\n-        _uri = null;\n-\n-        _scheme = uri.getScheme();\n-        _host = uri.getHost();\n-        if (_host == null && uri.getRawSchemeSpecificPart().startsWith(\"//\"))\n-            _host = \"\";\n-        _port = uri.getPort();\n-        _user = uri.getUserInfo();\n-        _path = uri.getRawPath();\n-\n-        _decodedPath = uri.getPath();\n-        if (_decodedPath != null)\n-        {\n-            int p = _decodedPath.lastIndexOf(';');\n-            if (p >= 0)\n-                _param = _decodedPath.substring(p + 1);\n-        }\n-        _query = uri.getRawQuery();\n-        _fragment = uri.getFragment();\n-\n-        _decodedPath = null;\n+        return new HttpURI.Mutable(uri).asImmutable();\n     }\n \n-    public HttpURI(String scheme, String host, int port, String pathQuery)\n+    static Immutable from(String uri)\n     {\n-        _uri = null;\n-\n-        _scheme = scheme;\n-        _host = host;\n-        _port = port;\n-\n-        if (pathQuery != null)\n-            parse(State.PATH, pathQuery);\n+        return new HttpURI.Mutable(uri).asImmutable();\n     }\n \n-    public void parse(String uri)\n+    static Immutable from(String method, String uri)\n     {\n-        clear();\n-        _uri = uri;\n-        parse(State.START, uri);\n+        if (HttpMethod.CONNECT.is(method))\n+            return new Immutable(uri);\n+        if (uri.startsWith(\"/\"))\n+            return HttpURI.build().pathQuery(uri).asImmutable();\n+        return HttpURI.from(uri);\n     }\n \n-    public void parse(String uri, int offset, int length)\n+    static Immutable from(String scheme, String host, int port, String pathQuery)\n     {\n-        clear();\n-        int end = offset + length;\n-        _uri = uri.substring(offset, end);\n-        parse(State.START, uri);\n+        return new Mutable(scheme, host, port, pathQuery).asImmutable();\n     }\n \n-    private void parse(State state, final String uri)\n-    {\n-        boolean encoded = false;\n-        int end = uri.length();\n-        int mark = 0;\n-        int pathMark = 0;\n-        char last = '/';\n-        for (int i = 0; i < end; i++)\n-        {\n-            char c = uri.charAt(i);\n+    Immutable asImmutable();\n \n-            switch (state)\n-            {\n-                case START:\n-                {\n-                    switch (c)\n-                    {\n-                        case '/':\n-                            mark = i;\n-                            state = State.HOST_OR_PATH;\n-                            break;\n-                        case ';':\n-                            mark = i + 1;\n-                            state = State.PARAM;\n-                            break;\n-                        case '?':\n-                            // assume empty path (if seen at start)\n-                            _path = \"\";\n-                            mark = i + 1;\n-                            state = State.QUERY;\n-                            break;\n-                        case '#':\n-                            mark = i + 1;\n-                            state = State.FRAGMENT;\n-                            break;\n-                        case '*':\n-                            _path = \"*\";\n-                            state = State.ASTERISK;\n-                            break;\n-\n-                        case '.':\n-                            pathMark = i;\n-                            state = State.PATH;\n-                            encoded = true;\n-                            break;\n-\n-                        default:\n-                            mark = i;\n-                            if (_scheme == null)\n-                                state = State.SCHEME_OR_PATH;\n-                            else\n-                            {\n-                                pathMark = i;\n-                                state = State.PATH;\n-                            }\n-                            break;\n-                    }\n+    String getAuthority();\n \n-                    continue;\n-                }\n+    String getDecodedPath();\n \n-                case SCHEME_OR_PATH:\n-                {\n-                    switch (c)\n-                    {\n-                        case ':':\n-                            // must have been a scheme\n-                            _scheme = uri.substring(mark, i);\n-                            // Start again with scheme set\n-                            state = State.START;\n-                            break;\n-\n-                        case '/':\n-                            // must have been in a path and still are\n-                            state = State.PATH;\n-                            break;\n+    String getHost();\n \n-                        case ';':\n-                            // must have been in a path \n-                            mark = i + 1;\n-                            state = State.PARAM;\n-                            break;\n+    String getParam();\n \n-                        case '?':\n-                            // must have been in a path \n-                            _path = uri.substring(mark, i);\n-                            mark = i + 1;\n-                            state = State.QUERY;\n-                            break;\n+    String getPath();\n \n-                        case '%':\n-                            // must have be in an encoded path \n-                            encoded = true;\n-                            state = State.PATH;\n-                            break;\n+    String getPathQuery();\n \n-                        case '#':\n-                            // must have been in a path \n-                            _path = uri.substring(mark, i);\n-                            state = State.FRAGMENT;\n-                            break;\n+    int getPort();\n \n-                        default:\n-                            break;\n-                    }\n-                    continue;\n-                }\n+    String getQuery();\n \n-                case HOST_OR_PATH:\n-                {\n-                    switch (c)\n-                    {\n-                        case '/':\n-                            _host = \"\";\n-                            mark = i + 1;\n-                            state = State.HOST;\n-                            break;\n-\n-                        case '@':\n-                        case ';':\n-                        case '?':\n-                        case '#':\n-                            // was a path, look again\n-                            i--;\n-                            pathMark = mark;\n-                            state = State.PATH;\n-                            break;\n+    String getScheme();\n \n-                        case '.':\n-                            // it is a path\n-                            encoded = true;\n-                            pathMark = mark;\n-                            state = State.PATH;\n-                            break;\n+    String getUser();\n \n-                        default:\n-                            // it is a path\n-                            pathMark = mark;\n-                            state = State.PATH;\n-                    }\n-                    continue;\n-                }\n+    boolean hasAuthority();\n \n-                case HOST:\n-                {\n-                    switch (c)\n-                    {\n-                        case '/':\n-                            _host = uri.substring(mark, i);\n-                            pathMark = mark = i;\n-                            state = State.PATH;\n-                            break;\n-                        case ':':\n-                            if (i > mark)\n-                                _host = uri.substring(mark, i);\n-                            mark = i + 1;\n-                            state = State.PORT;\n-                            break;\n-                        case '@':\n-                            if (_user != null)\n-                                throw new IllegalArgumentException(\"Bad authority\");\n-                            _user = uri.substring(mark, i);\n-                            mark = i + 1;\n-                            break;\n+    boolean isAbsolute();\n \n-                        case '[':\n-                            state = State.IPV6;\n-                            break;\n+    default URI toURI()\n+    {\n+        try\n+        {\n+            String query = getQuery();\n+            return new URI(getScheme(), null, getHost(), getPort(), getPath(), query == null ? null : UrlEncoded.decodeString(query), null);\n+        }\n+        catch (URISyntaxException x)\n+        {\n+            throw new RuntimeException(x);\n+        }\n+    }\n \n-                        default:\n-                            break;\n-                    }\n-                    break;\n-                }\n+    class Immutable implements HttpURI\n+    {\n+        private final String _scheme;\n+        private final String _user;\n+        private final String _host;\n+        private final int _port;\n+        private final String _path;\n+        private final String _param;\n+        private final String _query;\n+        private String _uri;\n+        private String _decodedPath;\n+\n+        private Immutable(Mutable builder)\n+        {\n+            _uri = builder._uri;\n+            _scheme = builder._scheme;\n+            _user = builder._user;\n+            _host = builder._host;\n+            _port = builder._port;\n+            _path = builder._path;\n+            _decodedPath = builder._decodedPath;\n+            _param = builder._param;\n+            _query = builder._query;\n+        }\n \n-                case IPV6:\n-                {\n-                    switch (c)\n-                    {\n-                        case '/':\n-                            throw new IllegalArgumentException(\"No closing ']' for ipv6 in \" + uri);\n-                        case ']':\n-                            c = uri.charAt(++i);\n-                            _host = uri.substring(mark, i);\n-                            if (c == ':')\n-                            {\n-                                mark = i + 1;\n-                                state = State.PORT;\n-                            }\n-                            else\n-                            {\n-                                pathMark = mark = i;\n-                                state = State.PATH;\n-                            }\n-                            break;\n+        private Immutable(String uri)\n+        {\n+            _uri = uri;\n+            _scheme = null;\n+            _user = null;\n+            _host = null;\n+            _port = -1;\n+            _path = uri;\n+            _decodedPath = null;\n+            _param = null;\n+            _query = null;\n+        }\n \n-                        default:\n-                            break;\n-                    }\n+        @Override\n+        public Immutable asImmutable()\n+        {\n+            return this;\n+        }\n \n-                    break;\n-                }\n+        @Override\n+        public boolean equals(Object o)\n+        {\n+            if (o == this)\n+                return true;\n+            if (!(o instanceof HttpURI))\n+                return false;\n+            return toString().equals(o.toString());\n+        }", "originalCommit": "fa86645a99b52390456f0c04bea50f94b890daf5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcyNjU2Mw==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413726563", "bodyText": "Use same order as the field declarations.", "author": "sbordet", "createdAt": "2020-04-23T11:11:36Z", "path": "jetty-http/src/main/java/org/eclipse/jetty/http/HttpURI.java", "diffHunk": "@@ -18,798 +18,1064 @@\n \n package org.eclipse.jetty.http;\n \n-import java.io.UnsupportedEncodingException;\n import java.net.URI;\n import java.net.URISyntaxException;\n-import java.nio.charset.Charset;\n-import java.nio.charset.StandardCharsets;\n \n-import org.eclipse.jetty.util.MultiMap;\n+import org.eclipse.jetty.util.HostPort;\n+import org.eclipse.jetty.util.StringUtil;\n import org.eclipse.jetty.util.TypeUtil;\n import org.eclipse.jetty.util.URIUtil;\n import org.eclipse.jetty.util.UrlEncoded;\n \n /**\n  * Http URI.\n- * Parse an HTTP URI from a string or byte array.  Given a URI\n- * <code>http://user@host:port/path/info;param?query#fragment</code>\n- * this class will split it into the following undecoded optional elements:<ul>\n+ *\n+ * Both {@link HttpFields.Mutable} and {@link HttpFields.Immutable} implementations are available\n+ * via the static methods such as {@link #build()} and {@link #from(String)}.\n+ *\n+ * A URI such as\n+ * <code>http://user@host:port/path;ignored/info;param?query#ignored</code>\n+ * is split into the following undecoded elements:<ul>\n  * <li>{@link #getScheme()} - http:</li>\n  * <li>{@link #getAuthority()} - //name@host:port</li>\n  * <li>{@link #getHost()} - host</li>\n  * <li>{@link #getPort()} - port</li>\n  * <li>{@link #getPath()} - /path/info</li>\n  * <li>{@link #getParam()} - param</li>\n  * <li>{@link #getQuery()} - query</li>\n- * <li>{@link #getFragment()} - fragment</li>\n  * </ul>\n- *\n  * <p>Any parameters will be returned from {@link #getPath()}, but are excluded from the\n  * return value of {@link #getDecodedPath()}.   If there are multiple parameters, the\n- * {@link #getParam()} method returns only the last one.\n+ * {@link #getParam()} method returns only the last one. Fragments are ignored.\n  */\n-public class HttpURI\n+public interface HttpURI\n {\n-    private enum State\n+    static Mutable build()\n     {\n-        START,\n-        HOST_OR_PATH,\n-        SCHEME_OR_PATH,\n-        HOST,\n-        IPV6,\n-        PORT,\n-        PATH,\n-        PARAM,\n-        QUERY,\n-        FRAGMENT,\n-        ASTERISK\n+        return new Mutable();\n     }\n \n-    ;\n-\n-    private String _scheme;\n-    private String _user;\n-    private String _host;\n-    private int _port;\n-    private String _path;\n-    private String _param;\n-    private String _query;\n-    private String _fragment;\n-\n-    String _uri;\n-    String _decodedPath;\n-\n-    /**\n-     * Construct a normalized URI.\n-     * Port is not set if it is the default port.\n-     *\n-     * @param scheme the URI scheme\n-     * @param host the URI hose\n-     * @param port the URI port\n-     * @param path the URI path\n-     * @param param the URI param\n-     * @param query the URI query\n-     * @param fragment the URI fragment\n-     * @return the normalized URI\n-     */\n-    public static HttpURI createHttpURI(String scheme, String host, int port, String path, String param, String query, String fragment)\n+    static Mutable build(HttpURI uri)\n     {\n-        if (port == 80 && HttpScheme.HTTP.is(scheme))\n-            port = 0;\n-        if (port == 443 && HttpScheme.HTTPS.is(scheme))\n-            port = 0;\n-        return new HttpURI(scheme, host, port, path, param, query, fragment);\n+        return new Mutable(uri);\n     }\n \n-    public HttpURI()\n+    static Mutable build(HttpURI uri, String pathQuery)\n     {\n+        return new Mutable(uri, pathQuery);\n     }\n \n-    public HttpURI(String scheme, String host, int port, String path, String param, String query, String fragment)\n+    static Mutable build(HttpURI uri, String path, String param, String query)\n     {\n-        _scheme = scheme;\n-        _host = host;\n-        _port = port;\n-        _path = path;\n-        _param = param;\n-        _query = query;\n-        _fragment = fragment;\n+        return new Mutable(uri, path, param, query);\n     }\n \n-    public HttpURI(HttpURI uri)\n+    static Mutable build(URI uri)\n     {\n-        this(uri._scheme, uri._host, uri._port, uri._path, uri._param, uri._query, uri._fragment);\n-        _uri = uri._uri;\n+        return new Mutable(uri);\n     }\n \n-    public HttpURI(String uri)\n+    static Mutable build(String uri)\n     {\n-        _port = -1;\n-        parse(State.START, uri);\n+        return new Mutable(uri);\n     }\n \n-    public HttpURI(URI uri)\n+    static Immutable from(URI uri)\n     {\n-        _uri = null;\n-\n-        _scheme = uri.getScheme();\n-        _host = uri.getHost();\n-        if (_host == null && uri.getRawSchemeSpecificPart().startsWith(\"//\"))\n-            _host = \"\";\n-        _port = uri.getPort();\n-        _user = uri.getUserInfo();\n-        _path = uri.getRawPath();\n-\n-        _decodedPath = uri.getPath();\n-        if (_decodedPath != null)\n-        {\n-            int p = _decodedPath.lastIndexOf(';');\n-            if (p >= 0)\n-                _param = _decodedPath.substring(p + 1);\n-        }\n-        _query = uri.getRawQuery();\n-        _fragment = uri.getFragment();\n-\n-        _decodedPath = null;\n+        return new HttpURI.Mutable(uri).asImmutable();\n     }\n \n-    public HttpURI(String scheme, String host, int port, String pathQuery)\n+    static Immutable from(String uri)\n     {\n-        _uri = null;\n-\n-        _scheme = scheme;\n-        _host = host;\n-        _port = port;\n-\n-        if (pathQuery != null)\n-            parse(State.PATH, pathQuery);\n+        return new HttpURI.Mutable(uri).asImmutable();\n     }\n \n-    public void parse(String uri)\n+    static Immutable from(String method, String uri)\n     {\n-        clear();\n-        _uri = uri;\n-        parse(State.START, uri);\n+        if (HttpMethod.CONNECT.is(method))\n+            return new Immutable(uri);\n+        if (uri.startsWith(\"/\"))\n+            return HttpURI.build().pathQuery(uri).asImmutable();\n+        return HttpURI.from(uri);\n     }\n \n-    public void parse(String uri, int offset, int length)\n+    static Immutable from(String scheme, String host, int port, String pathQuery)\n     {\n-        clear();\n-        int end = offset + length;\n-        _uri = uri.substring(offset, end);\n-        parse(State.START, uri);\n+        return new Mutable(scheme, host, port, pathQuery).asImmutable();\n     }\n \n-    private void parse(State state, final String uri)\n-    {\n-        boolean encoded = false;\n-        int end = uri.length();\n-        int mark = 0;\n-        int pathMark = 0;\n-        char last = '/';\n-        for (int i = 0; i < end; i++)\n-        {\n-            char c = uri.charAt(i);\n+    Immutable asImmutable();\n \n-            switch (state)\n-            {\n-                case START:\n-                {\n-                    switch (c)\n-                    {\n-                        case '/':\n-                            mark = i;\n-                            state = State.HOST_OR_PATH;\n-                            break;\n-                        case ';':\n-                            mark = i + 1;\n-                            state = State.PARAM;\n-                            break;\n-                        case '?':\n-                            // assume empty path (if seen at start)\n-                            _path = \"\";\n-                            mark = i + 1;\n-                            state = State.QUERY;\n-                            break;\n-                        case '#':\n-                            mark = i + 1;\n-                            state = State.FRAGMENT;\n-                            break;\n-                        case '*':\n-                            _path = \"*\";\n-                            state = State.ASTERISK;\n-                            break;\n-\n-                        case '.':\n-                            pathMark = i;\n-                            state = State.PATH;\n-                            encoded = true;\n-                            break;\n-\n-                        default:\n-                            mark = i;\n-                            if (_scheme == null)\n-                                state = State.SCHEME_OR_PATH;\n-                            else\n-                            {\n-                                pathMark = i;\n-                                state = State.PATH;\n-                            }\n-                            break;\n-                    }\n+    String getAuthority();\n \n-                    continue;\n-                }\n+    String getDecodedPath();\n \n-                case SCHEME_OR_PATH:\n-                {\n-                    switch (c)\n-                    {\n-                        case ':':\n-                            // must have been a scheme\n-                            _scheme = uri.substring(mark, i);\n-                            // Start again with scheme set\n-                            state = State.START;\n-                            break;\n-\n-                        case '/':\n-                            // must have been in a path and still are\n-                            state = State.PATH;\n-                            break;\n+    String getHost();\n \n-                        case ';':\n-                            // must have been in a path \n-                            mark = i + 1;\n-                            state = State.PARAM;\n-                            break;\n+    String getParam();\n \n-                        case '?':\n-                            // must have been in a path \n-                            _path = uri.substring(mark, i);\n-                            mark = i + 1;\n-                            state = State.QUERY;\n-                            break;\n+    String getPath();\n \n-                        case '%':\n-                            // must have be in an encoded path \n-                            encoded = true;\n-                            state = State.PATH;\n-                            break;\n+    String getPathQuery();\n \n-                        case '#':\n-                            // must have been in a path \n-                            _path = uri.substring(mark, i);\n-                            state = State.FRAGMENT;\n-                            break;\n+    int getPort();\n \n-                        default:\n-                            break;\n-                    }\n-                    continue;\n-                }\n+    String getQuery();\n \n-                case HOST_OR_PATH:\n-                {\n-                    switch (c)\n-                    {\n-                        case '/':\n-                            _host = \"\";\n-                            mark = i + 1;\n-                            state = State.HOST;\n-                            break;\n-\n-                        case '@':\n-                        case ';':\n-                        case '?':\n-                        case '#':\n-                            // was a path, look again\n-                            i--;\n-                            pathMark = mark;\n-                            state = State.PATH;\n-                            break;\n+    String getScheme();\n \n-                        case '.':\n-                            // it is a path\n-                            encoded = true;\n-                            pathMark = mark;\n-                            state = State.PATH;\n-                            break;\n+    String getUser();\n \n-                        default:\n-                            // it is a path\n-                            pathMark = mark;\n-                            state = State.PATH;\n-                    }\n-                    continue;\n-                }\n+    boolean hasAuthority();\n \n-                case HOST:\n-                {\n-                    switch (c)\n-                    {\n-                        case '/':\n-                            _host = uri.substring(mark, i);\n-                            pathMark = mark = i;\n-                            state = State.PATH;\n-                            break;\n-                        case ':':\n-                            if (i > mark)\n-                                _host = uri.substring(mark, i);\n-                            mark = i + 1;\n-                            state = State.PORT;\n-                            break;\n-                        case '@':\n-                            if (_user != null)\n-                                throw new IllegalArgumentException(\"Bad authority\");\n-                            _user = uri.substring(mark, i);\n-                            mark = i + 1;\n-                            break;\n+    boolean isAbsolute();\n \n-                        case '[':\n-                            state = State.IPV6;\n-                            break;\n+    default URI toURI()\n+    {\n+        try\n+        {\n+            String query = getQuery();\n+            return new URI(getScheme(), null, getHost(), getPort(), getPath(), query == null ? null : UrlEncoded.decodeString(query), null);\n+        }\n+        catch (URISyntaxException x)\n+        {\n+            throw new RuntimeException(x);\n+        }\n+    }\n \n-                        default:\n-                            break;\n-                    }\n-                    break;\n-                }\n+    class Immutable implements HttpURI\n+    {\n+        private final String _scheme;\n+        private final String _user;\n+        private final String _host;\n+        private final int _port;\n+        private final String _path;\n+        private final String _param;\n+        private final String _query;\n+        private String _uri;\n+        private String _decodedPath;\n+\n+        private Immutable(Mutable builder)\n+        {\n+            _uri = builder._uri;\n+            _scheme = builder._scheme;\n+            _user = builder._user;\n+            _host = builder._host;\n+            _port = builder._port;\n+            _path = builder._path;\n+            _decodedPath = builder._decodedPath;\n+            _param = builder._param;\n+            _query = builder._query;\n+        }\n \n-                case IPV6:\n-                {\n-                    switch (c)\n-                    {\n-                        case '/':\n-                            throw new IllegalArgumentException(\"No closing ']' for ipv6 in \" + uri);\n-                        case ']':\n-                            c = uri.charAt(++i);\n-                            _host = uri.substring(mark, i);\n-                            if (c == ':')\n-                            {\n-                                mark = i + 1;\n-                                state = State.PORT;\n-                            }\n-                            else\n-                            {\n-                                pathMark = mark = i;\n-                                state = State.PATH;\n-                            }\n-                            break;\n+        private Immutable(String uri)\n+        {\n+            _uri = uri;\n+            _scheme = null;\n+            _user = null;\n+            _host = null;\n+            _port = -1;\n+            _path = uri;\n+            _decodedPath = null;\n+            _param = null;\n+            _query = null;\n+        }\n \n-                        default:\n-                            break;\n-                    }\n+        @Override\n+        public Immutable asImmutable()\n+        {\n+            return this;\n+        }\n \n-                    break;\n-                }\n+        @Override\n+        public boolean equals(Object o)\n+        {\n+            if (o == this)\n+                return true;\n+            if (!(o instanceof HttpURI))\n+                return false;\n+            return toString().equals(o.toString());\n+        }\n \n-                case PORT:\n-                {\n-                    if (c == '@')\n-                    {\n-                        if (_user != null)\n-                            throw new IllegalArgumentException(\"Bad authority\");\n-                        // It wasn't a port, but a password!\n-                        _user = _host + \":\" + uri.substring(mark, i);\n-                        mark = i + 1;\n-                        state = State.HOST;\n-                    }\n-                    else if (c == '/')\n-                    {\n-                        _port = TypeUtil.parseInt(uri, mark, i - mark, 10);\n-                        pathMark = mark = i;\n-                        state = State.PATH;\n-                    }\n-                    break;\n-                }\n+        @Override\n+        public String getAuthority()\n+        {\n+            if (_port > 0)\n+                return _host + \":\" + _port;\n+            return _host;\n+        }\n \n-                case PATH:\n-                {\n-                    switch (c)\n-                    {\n-                        case ';':\n-                            mark = i + 1;\n-                            state = State.PARAM;\n-                            break;\n-                        case '?':\n-                            _path = uri.substring(pathMark, i);\n-                            mark = i + 1;\n-                            state = State.QUERY;\n-                            break;\n-                        case '#':\n-                            _path = uri.substring(pathMark, i);\n-                            mark = i + 1;\n-                            state = State.FRAGMENT;\n-                            break;\n-                        case '%':\n-                            encoded = true;\n-                            break;\n-                        case '.':\n-                            if ('/' == last)\n-                                encoded = true;\n-                            break;\n-                        default:\n-                            break;\n-                    }\n-                    break;\n-                }\n+        @Override\n+        public String getDecodedPath()\n+        {\n+            if (_decodedPath == null && _path != null)\n+                _decodedPath = URIUtil.canonicalPath(URIUtil.decodePath(_path));\n+            return _decodedPath;\n+        }\n \n-                case PARAM:\n-                {\n-                    switch (c)\n-                    {\n-                        case '?':\n-                            _path = uri.substring(pathMark, i);\n-                            _param = uri.substring(mark, i);\n-                            mark = i + 1;\n-                            state = State.QUERY;\n-                            break;\n-                        case '#':\n-                            _path = uri.substring(pathMark, i);\n-                            _param = uri.substring(mark, i);\n-                            mark = i + 1;\n-                            state = State.FRAGMENT;\n-                            break;\n-                        case '/':\n-                            encoded = true;\n-                            // ignore internal params\n-                            state = State.PATH;\n-                            break;\n-                        case ';':\n-                            // multiple parameters\n-                            mark = i + 1;\n-                            break;\n-                        default:\n-                            break;\n-                    }\n-                    break;\n-                }\n+        @Override\n+        public String getHost()\n+        {\n+            // Return null for empty host to retain compatibility with java.net.URI\n+            if (_host != null && _host.isEmpty())\n+                return null;\n+            return _host;\n+        }\n \n-                case QUERY:\n-                {\n-                    if (c == '#')\n-                    {\n-                        _query = uri.substring(mark, i);\n-                        mark = i + 1;\n-                        state = State.FRAGMENT;\n-                    }\n-                    break;\n-                }\n+        @Override\n+        public String getParam()\n+        {\n+            return _param;\n+        }\n \n-                case ASTERISK:\n-                {\n-                    throw new IllegalArgumentException(\"Bad character '*'\");\n-                }\n+        @Override\n+        public String getPath()\n+        {\n+            return _path;\n+        }\n \n-                case FRAGMENT:\n-                {\n-                    _fragment = uri.substring(mark, end);\n-                    i = end;\n-                    break;\n-                }\n+        @Override\n+        public String getPathQuery()\n+        {\n+            if (_query == null)\n+                return _path;\n+            return _path + \"?\" + _query;\n+        }\n \n-                default:\n-                    throw new IllegalStateException(state.toString());\n-            }\n-            last = c;\n+        @Override\n+        public int getPort()\n+        {\n+            return _port;\n         }\n \n-        switch (state)\n+        @Override\n+        public String getQuery()\n         {\n-            case START:\n-                break;\n-            case SCHEME_OR_PATH:\n-                _path = uri.substring(mark, end);\n-                break;\n+            return _query;\n+        }\n \n-            case HOST_OR_PATH:\n-                _path = uri.substring(mark, end);\n-                break;\n+        @Override\n+        public String getScheme()\n+        {\n+            return _scheme;\n+        }\n+\n+        @Override\n+        public String getUser()\n+        {\n+            return _user;\n+        }\n \n-            case HOST:\n-                if (end > mark)\n-                    _host = uri.substring(mark, end);\n-                break;\n+        @Override\n+        public boolean hasAuthority()\n+        {\n+            return _host != null;\n+        }\n \n-            case IPV6:\n-                throw new IllegalArgumentException(\"No closing ']' for ipv6 in \" + uri);\n+        @Override\n+        public boolean isAbsolute()\n+        {\n+            return !StringUtil.isEmpty(_scheme);\n+        }\n \n-            case PORT:\n-                _port = TypeUtil.parseInt(uri, mark, end - mark, 10);\n-                break;\n+        @Override\n+        public String toString()\n+        {\n+            if (_uri == null)\n+            {\n+                StringBuilder out = new StringBuilder();\n \n-            case ASTERISK:\n-                break;\n+                if (_scheme != null)\n+                    out.append(_scheme).append(':');\n \n-            case FRAGMENT:\n-                _fragment = uri.substring(mark, end);\n-                break;\n+                if (_host != null)\n+                {\n+                    out.append(\"//\");\n+                    if (_user != null)\n+                        out.append(_user).append('@');\n+                    out.append(_host);\n+                }\n \n-            case PARAM:\n-                _path = uri.substring(pathMark, end);\n-                _param = uri.substring(mark, end);\n-                break;\n+                if (_port > 0)\n+                    out.append(':').append(_port);\n \n-            case PATH:\n-                _path = uri.substring(pathMark, end);\n-                break;\n+                if (_path != null)\n+                    out.append(_path);\n \n-            case QUERY:\n-                _query = uri.substring(mark, end);\n-                break;\n+                if (_query != null)\n+                    out.append('?').append(_query);\n \n-            default:\n-                throw new IllegalStateException(state.toString());\n+                if (out.length() > 0)\n+                    _uri = out.toString();\n+                else\n+                    _uri = \"\";\n+            }\n+            return _uri;\n         }\n \n-        if (!encoded)\n+        @Override\n+        public URI toURI()\n         {\n-            if (_param == null)\n-                _decodedPath = _path;\n-            else\n-                _decodedPath = _path.substring(0, _path.length() - _param.length() - 1);\n+            try\n+            {\n+                return new URI(_scheme, null, _host, _port, _path, _query == null ? null : UrlEncoded.decodeString(_query), null);\n+            }\n+            catch (URISyntaxException x)\n+            {\n+                throw new RuntimeException(x);\n+            }\n         }\n     }\n \n-    /**\n-     * Parse according to https://tools.ietf.org/html/rfc7230#section-5.3\n-     *\n-     * @param method the request method\n-     * @param uri the request uri\n-     */\n-    public void parseRequestTarget(String method, String uri)\n+    class Mutable implements HttpURI\n     {\n-        clear();\n-        _uri = uri;\n+        private enum State\n+        {\n+            START,\n+            HOST_OR_PATH,\n+            SCHEME_OR_PATH,\n+            HOST,\n+            IPV6,\n+            PORT,\n+            PATH,\n+            PARAM,\n+            QUERY,\n+            FRAGMENT,\n+            ASTERISK\n+        }\n \n-        if (HttpMethod.CONNECT.is(method))\n-            _path = uri;\n-        else\n-            parse(uri.startsWith(\"/\") ? State.PATH : State.START, uri);\n-    }\n+        private String _uri;\n+        private String _decodedPath;\n+        private String _scheme;\n+        private String _user;\n+        private String _host;\n+        private int _port;\n+        private String _path;\n+        private String _param;\n+        private String _query;\n+\n+        private Mutable()\n+        {\n+        }\n \n-    public String getScheme()\n-    {\n-        return _scheme;\n-    }\n+        private Mutable(HttpURI uri)\n+        {\n+            uri(uri);\n+        }\n \n-    public String getHost()\n-    {\n-        // Return null for empty host to retain compatibility with java.net.URI\n-        if (_host != null && _host.isEmpty())\n-            return null;\n-        return _host;\n-    }\n+        private Mutable(HttpURI baseURI, String pathQuery)\n+        {\n+            _uri = null;\n+            _scheme = baseURI.getScheme();\n+            _user = baseURI.getUser();\n+            _host = baseURI.getHost();\n+            _port = baseURI.getPort();\n+            if (pathQuery != null)\n+                parse(State.PATH, pathQuery);\n+        }\n \n-    public int getPort()\n-    {\n-        return _port;\n-    }\n+        private Mutable(HttpURI baseURI, String path, String param, String query)\n+        {\n+            _uri = null;\n+            _scheme = baseURI.getScheme();\n+            _user = baseURI.getUser();\n+            _host = baseURI.getHost();\n+            _port = baseURI.getPort();\n+            _path = path;\n+            _param = param;\n+            _query = query;\n+        }\n \n-    /**\n-     * The parsed Path.\n-     *\n-     * @return the path as parsed on valid URI.  null for invalid URI.\n-     */\n-    public String getPath()\n-    {\n-        return _path;\n-    }\n+        private Mutable(String uri)\n+        {\n+            _port = -1;\n+            parse(State.START, uri);\n+        }\n \n-    public String getDecodedPath()\n-    {\n-        if (_decodedPath == null && _path != null)\n-            _decodedPath = URIUtil.canonicalPath(URIUtil.decodePath(_path));\n-        return _decodedPath;\n-    }\n+        private Mutable(URI uri)\n+        {\n+            _uri = null;\n+\n+            _scheme = uri.getScheme();\n+            _host = uri.getHost();\n+            if (_host == null && uri.getRawSchemeSpecificPart().startsWith(\"//\"))\n+                _host = \"\";\n+            _port = uri.getPort();\n+            _user = uri.getUserInfo();\n+            _path = uri.getRawPath();\n+\n+            String pathParam = uri.getPath();\n+            if (pathParam != null)\n+            {\n+                int p = pathParam.lastIndexOf(';');\n+                if (p >= 0)\n+                    _param = pathParam.substring(p + 1);\n+                else\n+                    _decodedPath = pathParam;\n+            }\n+            _query = uri.getRawQuery();\n+        }\n \n-    public String getParam()\n-    {\n-        return _param;\n-    }\n+        private Mutable(String scheme, String host, int port, String pathQuery)\n+        {\n+            _uri = null;\n \n-    public void setParam(String param)\n-    {\n-        _param = param;\n-        if (_path != null && !_path.contains(_param))\n+            _scheme = scheme;\n+            _host = host;\n+            _port = port;\n+\n+            if (pathQuery != null)\n+                parse(State.PATH, pathQuery);\n+        }\n+\n+        @Override\n+        public Immutable asImmutable()\n         {\n-            _path += \";\" + _param;\n+            return new Immutable(this);\n         }\n-    }\n \n-    public String getQuery()\n-    {\n-        return _query;\n-    }\n+        /**\n+         * @param host the host\n+         * @param port the port\n+         * @return this mutable\n+         */\n+        public Mutable authority(String host, int port)\n+        {\n+            _user = null;\n+            _host = host;\n+            _port = port;\n+            _uri = null;\n+            return this;\n+        }\n \n-    public boolean hasQuery()\n-    {\n-        return _query != null && !_query.isEmpty();\n-    }\n+        /**\n+         * @param hostport the host and port combined\n+         * @return this mutable\n+         */\n+        public Mutable authority(String hostport)\n+        {\n+            HostPort hp = new HostPort(hostport);\n+            _user = null;\n+            _host = hp.getHost();\n+            _port = hp.getPort();\n+            _uri = null;\n+            return this;\n+        }\n \n-    public String getFragment()\n-    {\n-        return _fragment;\n-    }\n+        public Mutable clear()\n+        {\n+            _uri = null;\n+            _scheme = null;\n+            _host = null;\n+            _port = -1;\n+            _path = null;\n+            _param = null;\n+            _query = null;\n+            _decodedPath = null;\n+            _user = null;\n+            return this;\n+        }", "originalCommit": "fa86645a99b52390456f0c04bea50f94b890daf5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcyODM3Mw==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413728373", "bodyText": "Typo: TRAILERS.", "author": "sbordet", "createdAt": "2020-04-23T11:14:48Z", "path": "jetty-http/src/main/java/org/eclipse/jetty/http/MetaData.java", "diffHunk": "@@ -24,29 +24,38 @@\n \n public class MetaData implements Iterable<HttpField>\n {\n-    private HttpVersion _httpVersion;\n+    private static final Supplier<HttpFields> SELF_SUPPLIED_TRAILORS = () -> null;", "originalCommit": "fa86645a99b52390456f0c04bea50f94b890daf5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcyODc0Nw==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413728747", "bodyText": "Please review whether we really need this.", "author": "sbordet", "createdAt": "2020-04-23T11:15:30Z", "path": "jetty-http/src/main/java/org/eclipse/jetty/http/MetaData.java", "diffHunk": "@@ -83,42 +84,39 @@ public HttpFields getFields()\n         return _fields;\n     }\n \n+    public boolean mayHaveTrailers()\n+    {\n+        return _trailers != null;\n+    }", "originalCommit": "fa86645a99b52390456f0c04bea50f94b890daf5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzczMDc3Mw==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413730773", "bodyText": "Yes, CONNECT has a scheme and a path when it's a WebSocket tunnel over HTTP/2 (RFC8441).", "author": "sbordet", "createdAt": "2020-04-23T11:19:01Z", "path": "jetty-http/src/main/java/org/eclipse/jetty/http/MetaData.java", "diffHunk": "@@ -257,7 +221,10 @@ public ConnectRequest(HttpScheme scheme, HostPortHttpField authority, String pat\n \n         public ConnectRequest(String scheme, HostPortHttpField authority, String path, HttpFields fields, String protocol)\n         {\n-            super(HttpMethod.CONNECT.asString(), scheme, authority, path, HttpVersion.HTTP_2, fields, Long.MIN_VALUE);\n+            // TODO should connect requests have paths?", "originalCommit": "fa86645a99b52390456f0c04bea50f94b890daf5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzczNDk5NA==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413734994", "bodyText": "Revert when you have reverted the fragment.", "author": "sbordet", "createdAt": "2020-04-23T11:26:14Z", "path": "jetty-http/src/test/java/org/eclipse/jetty/http/HttpURIParseTest.java", "diffHunk": "@@ -179,7 +179,10 @@ public void testParseString(String input, String scheme, String host, Integer po\n             assertThat(\"[\" + input + \"] .path\", httpUri.getPath(), is(path));\n             assertThat(\"[\" + input + \"] .param\", httpUri.getParam(), is(param));\n             assertThat(\"[\" + input + \"] .query\", httpUri.getQuery(), is(query));\n-            assertThat(\"[\" + input + \"] .fragment\", httpUri.getFragment(), is(fragment));\n+\n+            // We don't retain the fragment\n+            if (input.indexOf('#') >= 0)\n+                input = input.substring(0, input.indexOf('#'));", "originalCommit": "fa86645a99b52390456f0c04bea50f94b890daf5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzczNzQ0Ng==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413737446", "bodyText": "Remove .Mutable.", "author": "sbordet", "createdAt": "2020-04-23T11:30:27Z", "path": "jetty-http2/http2-client/src/test/java/org/eclipse/jetty/http2/client/HTTP2Test.java", "diffHunk": "@@ -811,8 +806,8 @@ public void testClientInvalidHeader() throws Exception\n \n         // A bad header in the request should fail on the client.\n         Session session = newClient(new Session.Listener.Adapter());\n-        HttpFields requestFields = new HttpFields();\n-        requestFields.put(\":custom\", \"special\");\n+        HttpFields.Mutable requestFields = HttpFields.build()", "originalCommit": "fa86645a99b52390456f0c04bea50f94b890daf5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc0MTU3OQ==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413741579", "bodyText": "Why was this logic removed? Seems important to me.", "author": "sbordet", "createdAt": "2020-04-23T11:37:36Z", "path": "jetty-http2/http2-hpack/src/main/java/org/eclipse/jetty/http2/hpack/MetaDataBuilder.java", "diffHunk": "@@ -162,14 +163,6 @@ else if (value != null)\n                     break;\n \n                 case HOST:\n-                    // :authority fields must come first.  If we have one, ignore the host header as far as authority goes.\n-                    if (_authority == null)\n-                    {\n-                        if (field instanceof HostPortHttpField)\n-                            _authority = (HostPortHttpField)field;\n-                        else if (value != null)\n-                            _authority = new AuthorityHttpField(value);\n-                    }", "originalCommit": "fa86645a99b52390456f0c04bea50f94b890daf5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDM3NzY0NQ==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r414377645", "bodyText": "I don't believe it is necessary anymore because the Request.setMetaData method is able to take the authority from either the URI or the host field.\nThere is no need to look for a host header in a HTTP2 request when the authority field is mandatory.\nWe had this kind of dual approach were we were trying to make the h2 metadata look a bit like h1 meta data, but not entirely.... so the request still has to be aware of the differences.  So either we make metadata identical regardless of protocol - OR we just let it record the info that was in the message and let the client/server deal with it.   I've opted for the later.", "author": "gregw", "createdAt": "2020-04-24T08:03:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc0MTU3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTAwNjA2OQ==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r415006069", "bodyText": "I have checked the proxy tests for h2->http/1.1 and the host header is correctly added by the HttpClient.", "author": "gregw", "createdAt": "2020-04-25T07:39:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc0MTU3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc0NjI3OA==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413746278", "bodyText": "This is the CONNECT tunnel request, it does not have trailers.", "author": "sbordet", "createdAt": "2020-04-23T11:45:57Z", "path": "jetty-http2/http2-http-client-transport/src/main/java/org/eclipse/jetty/http2/client/http/HttpSenderOverHTTP2.java", "diffHunk": "@@ -64,6 +64,8 @@ protected void sendHeaders(HttpExchange exchange, ByteBuffer contentBuffer, bool\n         MetaData.Request metaData;\n         if (isTunnel)\n         {\n+            // TODO what to do with trailers ??", "originalCommit": "fa86645a99b52390456f0c04bea50f94b890daf5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc0NjUyMg==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413746522", "bodyText": "CONNECT requests may have scheme and path for WebSocket over HTTP/2.", "author": "sbordet", "createdAt": "2020-04-23T11:46:18Z", "path": "jetty-http2/http2-http-client-transport/src/main/java/org/eclipse/jetty/http2/client/http/HttpSenderOverHTTP2.java", "diffHunk": "@@ -64,6 +64,8 @@ protected void sendHeaders(HttpExchange exchange, ByteBuffer contentBuffer, bool\n         MetaData.Request metaData;\n         if (isTunnel)\n         {\n+            // TODO what to do with trailers ??\n+            // TODO should connect requests have paths???", "originalCommit": "fa86645a99b52390456f0c04bea50f94b890daf5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc5NTQyOQ==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413795429", "bodyText": "This code was removed, but seems important that it is there.", "author": "sbordet", "createdAt": "2020-04-23T13:00:51Z", "path": "jetty-http2/http2-server/src/main/java/org/eclipse/jetty/http2/server/HttpChannelOverHTTP2.java", "diffHunk": "@@ -110,21 +110,9 @@ public Runnable onRequest(HeadersFrame frame)\n             MetaData.Request request = (MetaData.Request)frame.getMetaData();\n             HttpFields fields = request.getFields();\n \n-            // HTTP/2 sends the Host header as the :authority\n-            // pseudo-header, so we need to synthesize a Host header.\n-            if (!fields.contains(HttpHeader.HOST))\n-            {\n-                String authority = request.getURI().getAuthority();\n-                if (authority != null)\n-                {\n-                    // Lower-case to be consistent with other HTTP/2 headers.\n-                    fields.put(\"host\", authority);\n-                }\n-            }\n-", "originalCommit": "fa86645a99b52390456f0c04bea50f94b890daf5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDM3ODEyNg==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r414378126", "bodyText": "I don't think so.  H2 requests do not need a host header and the Request.setMetaData is able to extract authority from either URI or field as appropriate.", "author": "gregw", "createdAt": "2020-04-24T08:04:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc5NTQyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTAwNjA1Mw==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r415006053", "bodyText": "I have checked the proxy tests for h2->http/1.1 and the host header is correctly added by the HttpClient.", "author": "gregw", "createdAt": "2020-04-25T07:39:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc5NTQyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc5OTIxNA==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413799214", "bodyText": "Add space before _query.", "author": "sbordet", "createdAt": "2020-04-23T13:06:15Z", "path": "jetty-rewrite/src/main/java/org/eclipse/jetty/rewrite/handler/RewritePatternRule.java", "diffHunk": "@@ -90,20 +91,9 @@ public String apply(String target, HttpServletRequest request, HttpServletRespon\n     @Override\n     public void applyURI(Request request, String oldURI, String newURI) throws IOException\n     {\n-        if (_query == null)\n-        {\n-            request.setURIPathQuery(newURI);\n-        }\n-        else\n-        {\n-            String queryString = request.getQueryString();\n-            if (queryString != null)\n-                queryString = queryString + \"&\" + _query;\n-            else\n-                queryString = _query;\n-            request.setURIPathQuery(newURI);\n-            request.setQueryString(queryString);\n-        }\n+        HttpURI baseURI = request.getHttpURI();\n+        String query = URIUtil.addQueries(baseURI.getQuery(),_query);", "originalCommit": "fa86645a99b52390456f0c04bea50f94b890daf5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk5MDcwMA==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413990700", "bodyText": "doh! checkstyle has stopped working for me! Again!", "author": "gregw", "createdAt": "2020-04-23T17:34:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc5OTIxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzgwMTY0NQ==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413801645", "bodyText": "Is asImmutable() needed here?", "author": "sbordet", "createdAt": "2020-04-23T13:09:47Z", "path": "jetty-rewrite/src/test/java/org/eclipse/jetty/rewrite/handler/ForwardedSchemeHeaderRuleTest.java", "diffHunk": "@@ -73,13 +72,13 @@ public void testHeaderValue() throws Exception\n         _rule.matchAndApply(\"/\", _request, _response);\n         assertEquals(\"https\", _request.getScheme());\n \n-        _request.setScheme(\"other\");\n+        _request.setHttpURI(HttpURI.build(_request.getRequestURI()).scheme(\"other\").asImmutable());", "originalCommit": "fa86645a99b52390456f0c04bea50f94b890daf5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzgwMTc4OQ==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413801789", "bodyText": "Is asImmutable() needed here?", "author": "sbordet", "createdAt": "2020-04-23T13:10:00Z", "path": "jetty-rewrite/src/test/java/org/eclipse/jetty/rewrite/handler/ForwardedSchemeHeaderRuleTest.java", "diffHunk": "@@ -73,13 +72,13 @@ public void testHeaderValue() throws Exception\n         _rule.matchAndApply(\"/\", _request, _response);\n         assertEquals(\"https\", _request.getScheme());\n \n-        _request.setScheme(\"other\");\n+        _request.setHttpURI(HttpURI.build(_request.getRequestURI()).scheme(\"other\").asImmutable());\n         // header value doesn't match rule's value\n         setRequestHeader(\"Front-End-Https\", \"off\");\n         _rule.matchAndApply(\"/\", _request, _response);\n         assertEquals(\"other\", _request.getScheme());\n \n-        _request.setScheme(null);\n+        _request.setHttpURI(HttpURI.build(_request.getRequestURI()).scheme((String)null).asImmutable());", "originalCommit": "fa86645a99b52390456f0c04bea50f94b890daf5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzgwNDU5Nw==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413804597", "bodyText": "Remove all asImmutable() from this test class?", "author": "sbordet", "createdAt": "2020-04-23T13:28:55Z", "path": "jetty-rewrite/src/test/java/org/eclipse/jetty/rewrite/handler/RewriteHandlerTest.java", "diffHunk": "@@ -83,7 +84,7 @@ public void test() throws Exception\n         _handler.setOriginalPathAttribute(\"/before\");\n         _handler.setRewriteRequestURI(true);\n         _handler.setRewritePathInfo(true);\n-        _request.setURIPathQuery(\"/xxx/bar\");\n+        _request.setHttpURI(HttpURI.build(_request.getHttpURI(), \"/xxx/bar\").asImmutable());", "originalCommit": "fa86645a99b52390456f0c04bea50f94b890daf5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzgxOTE3OQ==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413819179", "bodyText": "Remove all asImmutable() from this test class?", "author": "sbordet", "createdAt": "2020-04-23T14:00:22Z", "path": "jetty-rewrite/src/test/java/org/eclipse/jetty/rewrite/handler/RewritePatternRuleTest.java", "diffHunk": "@@ -87,8 +88,7 @@ public void testRequestWithQueryString() throws IOException\n     {\n         String replacement = \"/replace\";\n         String queryString = \"request=parameter\";\n-        _request.setURIPathQuery(\"/old/context\");\n-        _request.setQueryString(queryString);\n+        _request.setHttpURI(HttpURI.build(_request.getHttpURI(), \"/old/context\", null, queryString).asImmutable());", "originalCommit": "fa86645a99b52390456f0c04bea50f94b890daf5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzgxOTMzNA==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413819334", "bodyText": "Remove all asImmutable() from this test class?", "author": "sbordet", "createdAt": "2020-04-23T14:00:33Z", "path": "jetty-rewrite/src/test/java/org/eclipse/jetty/rewrite/handler/RewriteRegexRuleTest.java", "diffHunk": "@@ -62,12 +63,12 @@ public void testRequestUriEnabled(Scenario scenario) throws Exception\n         RewriteRegexRule rule = new RewriteRegexRule();\n \n         reset();\n-        _request.setURIPathQuery(null);\n+        _request.setHttpURI(HttpURI.build(_request.getHttpURI()).asImmutable());", "originalCommit": "fa86645a99b52390456f0c04bea50f94b890daf5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzgxOTU3MA==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413819570", "bodyText": "Remove all asImmutable() from this test class?", "author": "sbordet", "createdAt": "2020-04-23T14:00:46Z", "path": "jetty-rewrite/src/test/java/org/eclipse/jetty/rewrite/handler/ValidUrlRuleTest.java", "diffHunk": "@@ -43,7 +44,7 @@ public void init() throws Exception\n     public void testValidUrl() throws Exception\n     {\n         _rule.setCode(\"404\");\n-        _request.setURIPathQuery(\"/valid/uri.html\");\n+        _request.setHttpURI(HttpURI.build(_request.getHttpURI(), \"/valid/uri.html\").asImmutable());", "originalCommit": "fa86645a99b52390456f0c04bea50f94b890daf5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzgxOTk0NQ==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413819945", "bodyText": "Remove all asImmutable() from this test class?", "author": "sbordet", "createdAt": "2020-04-23T14:01:14Z", "path": "jetty-rewrite/src/test/java/org/eclipse/jetty/rewrite/handler/VirtualHostRuleContainerTest.java", "diffHunk": "@@ -49,7 +50,7 @@ public void init() throws Exception\n         _fooContainerRule.setRules(new Rule[]{_fooRule});\n \n         start(false);\n-        _request.setURIPathQuery(\"/cheese/bar\");\n+        _request.setHttpURI(HttpURI.build(_request.getHttpURI(), \"/cheese/bar\").asImmutable());", "originalCommit": "fa86645a99b52390456f0c04bea50f94b890daf5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzgyMDgwMg==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413820802", "bodyText": "Remove all asImmutable() from this test class?", "author": "sbordet", "createdAt": "2020-04-23T14:02:13Z", "path": "jetty-security/src/test/java/org/eclipse/jetty/security/DataConstraintsTest.java", "diffHunk": "@@ -71,7 +72,7 @@ public void startServer()\n             @Override\n             public void customize(Connector connector, HttpConfiguration channelConfig, Request request)\n             {\n-                request.setScheme(HttpScheme.HTTPS.asString());\n+                request.setHttpURI(HttpURI.build(request.getHttpURI()).scheme(HttpScheme.HTTPS).asImmutable());", "originalCommit": "fa86645a99b52390456f0c04bea50f94b890daf5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzgyMTIxNw==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413821217", "bodyText": "Remove all asImmutable() from this test class?", "author": "sbordet", "createdAt": "2020-04-23T14:02:42Z", "path": "jetty-security/src/test/java/org/eclipse/jetty/security/authentication/SpnegoAuthenticatorTest.java", "diffHunk": "@@ -113,11 +112,11 @@ public void flush() throws IOException {}\n         };\n         Request req = channel.getRequest();\n         Response res = channel.getResponse();\n-        HttpFields httpFields = new HttpFields();\n+\n         // Create a bogus Authorization header. We don't care about the actual credentials.\n-        httpFields.add(HttpHeader.AUTHORIZATION, \"Basic asdf\");\n-        MetaData.Request metadata = new MetaData.Request(httpFields);\n-        metadata.setURI(new HttpURI(\"http://localhost\"));\n+\n+        MetaData.Request metadata = new MetaData.Request(null, HttpURI.build(\"http://localhost\").asImmutable(), null,", "originalCommit": "fa86645a99b52390456f0c04bea50f94b890daf5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzgyNTgzNQ==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413825835", "bodyText": "Remove asImmutable()?", "author": "sbordet", "createdAt": "2020-04-23T14:07:32Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/HttpChannel.java", "diffHunk": "@@ -720,7 +715,7 @@ public void onTrailers(HttpFields trailers)\n     {\n         if (LOG.isDebugEnabled())\n             LOG.debug(\"onTrailers {} {}\", this, trailers);\n-        _trailers = trailers;\n+        _request.getMetaData().setTrailers(trailers.asImmutable());", "originalCommit": "fa86645a99b52390456f0c04bea50f94b890daf5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzg0NDY5Nw==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413844697", "bodyText": "Should be _queryEncoding.name(), not toString().", "author": "sbordet", "createdAt": "2020-04-23T14:29:00Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/Request.java", "diffHunk": "@@ -1163,15 +1119,19 @@ public HttpVersion getHttpVersion()\n     }\n \n     public String getQueryEncoding()\n+    {\n+        return _queryEncoding == null ? null : _queryEncoding.toString();", "originalCommit": "fa86645a99b52390456f0c04bea50f94b890daf5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzg0Nzk0NA==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413847944", "bodyText": "Space after colon.", "author": "sbordet", "createdAt": "2020-04-23T14:32:47Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/ResourceService.java", "diffHunk": "@@ -488,10 +488,8 @@ protected boolean passConditionalHeaders(HttpServletRequest request, HttpServlet\n             if (request instanceof Request)\n             {\n                 // Find multiple fields by iteration as an optimization \n-                HttpFields fields = ((Request)request).getHttpFields();\n-                for (int i = fields.size(); i-- > 0; )\n+                for (HttpField field :  ((Request)request).getHttpFields())", "originalCommit": "fa86645a99b52390456f0c04bea50f94b890daf5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzg1NjA2NQ==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413856065", "bodyText": "The if branch is equal to the initial part of the else branch, so perhaps you can remove the duplication?", "author": "sbordet", "createdAt": "2020-04-23T14:42:01Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/handler/ContextHandler.java", "diffHunk": "@@ -2142,16 +2140,25 @@ public RequestDispatcher getRequestDispatcher(String uriInContext)\n \n             try\n             {\n-                HttpURI uri = new HttpURI(null, null, 0, uriInContext);\n-\n-                String pathInfo = URIUtil.canonicalPath(uri.getDecodedPath());\n-                if (pathInfo == null)\n-                    return null;\n-\n                 String contextPath = getContextPath();\n-                if (contextPath != null && contextPath.length() > 0)\n-                    uri.setPath(URIUtil.addPaths(contextPath, uri.getPath()));\n-\n+                HttpURI uri;\n+                String pathInfo;\n+                if (StringUtil.isEmpty(contextPath))\n+                {\n+                    uri = HttpURI.from(uriInContext);\n+                    pathInfo = URIUtil.canonicalPath(uri.getDecodedPath());\n+                    if (StringUtil.isEmpty(pathInfo))\n+                        return null;\n+                }\n+                else\n+                {\n+                    HttpURI.Mutable builder = HttpURI.build(uriInContext);\n+                    if (StringUtil.isEmpty(URIUtil.canonicalPath(builder.getDecodedPath())))\n+                        return null;\n+                    builder.path(URIUtil.addPaths(contextPath,builder.getPath()));\n+                    uri = builder.asImmutable();\n+                    pathInfo = uri.getDecodedPath().substring(contextPath.length());\n+                }", "originalCommit": "fa86645a99b52390456f0c04bea50f94b890daf5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzg1ODAxNQ==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413858015", "bodyText": "Remove .Mutable.", "author": "sbordet", "createdAt": "2020-04-23T14:44:12Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/handler/ErrorHandler.java", "diffHunk": "@@ -56,7 +56,7 @@\n  * An ErrorHandler is registered with {@link ContextHandler#setErrorHandler(ErrorHandler)} or\n  * {@link Server#setErrorHandler(ErrorHandler)}.\n  * It is called by the HttpResponse.sendError method to write an error page via {@link #handle(String, Request, HttpServletRequest, HttpServletResponse)}\n- * or via {@link #badMessageError(int, String, HttpFields)} for bad requests for which a dispatch cannot be done.\n+ * or via {@link #badMessageError(int, String, HttpFields.Mutable)} for bad requests for which a dispatch cannot be done.", "originalCommit": "fa86645a99b52390456f0c04bea50f94b890daf5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk5NTYyMw==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413995623", "bodyText": "That one actually is a needed Mutable.", "author": "gregw", "createdAt": "2020-04-23T17:41:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzg1ODAxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzg1ODExNQ==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413858115", "bodyText": "Remove .Mutable.", "author": "sbordet", "createdAt": "2020-04-23T14:44:20Z", "path": "jetty-server/src/main/java/org/eclipse/jetty/server/handler/ErrorHandler.java", "diffHunk": "@@ -521,10 +521,12 @@ protected void writeErrorPageStacks(HttpServletRequest request, Writer writer)\n      * @param fields The header fields that will be sent with the response.\n      * @return The content as a ByteBuffer, or null for no body.\n      */\n-    public ByteBuffer badMessageError(int status, String reason, HttpFields fields)\n+    public ByteBuffer badMessageError(int status, String reason, HttpFields.Mutable fields)", "originalCommit": "fa86645a99b52390456f0c04bea50f94b890daf5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk5NTgxNQ==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413995815", "bodyText": "that one is needed", "author": "gregw", "createdAt": "2020-04-23T17:41:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzg1ODExNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzg2NDUwOA==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413864508", "bodyText": "Remove .asImmutable().", "author": "sbordet", "createdAt": "2020-04-23T14:51:20Z", "path": "jetty-server/src/test/java/org/eclipse/jetty/server/ResponseTest.java", "diffHunk": "@@ -861,7 +861,7 @@ public void testEncodeRedirect()\n     {\n         Response response = getResponse();\n         Request request = response.getHttpChannel().getRequest();\n-        request.setAuthority(\"myhost\", 8888);\n+        request.setHttpURI(HttpURI.build(request.getHttpURI()).host(\"myhost\").port(8888).asImmutable());", "originalCommit": "fa86645a99b52390456f0c04bea50f94b890daf5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzg2NDYzMg==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413864632", "bodyText": "Remove .asImmutable().", "author": "sbordet", "createdAt": "2020-04-23T14:51:30Z", "path": "jetty-server/src/test/java/org/eclipse/jetty/server/ResponseTest.java", "diffHunk": "@@ -949,10 +950,12 @@ public void testSendRedirect()\n                     Response response = getResponse();\n                     Request request = response.getHttpChannel().getRequest();\n \n-                    request.setScheme(\"http\");\n+                    HttpURI.Mutable builder = HttpURI.build(request.getHttpURI(),\n+                        \"/path/info;param;jsessionid=12345?query=0&more=1#target\");\n+                    builder.scheme(\"http\");\n                     if (host != null)\n-                        request.setAuthority(host, port);\n-                    request.setURIPathQuery(\"/path/info;param;jsessionid=12345?query=0&more=1#target\");\n+                        builder.host(host).port(port);\n+                    request.setHttpURI(builder.asImmutable());", "originalCommit": "fa86645a99b52390456f0c04bea50f94b890daf5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzg3MTc5OQ==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413871799", "bodyText": "Likely no need for .Mutable everywhere in this class.", "author": "sbordet", "createdAt": "2020-04-23T14:59:43Z", "path": "jetty-websocket/websocket-core/src/test/java/org/eclipse/jetty/websocket/core/extensions/PerMessageDeflaterBufferSizeTest.java", "diffHunk": "@@ -106,7 +106,7 @@ public void testClientDeflateBufferSize() throws Exception\n         ClientUpgradeRequest upgradeRequest = ClientUpgradeRequest.from(client, serverUri, clientHandler);\n         upgradeRequest.addExtensions(\"permessage-deflate; @deflate_buffer_size=\" + deflateBufferSize);\n \n-        CompletableFuture<HttpFields> futureRequestHeaders = new CompletableFuture<>();\n+        CompletableFuture<HttpFields.Mutable> futureRequestHeaders = new CompletableFuture<>();", "originalCommit": "fa86645a99b52390456f0c04bea50f94b890daf5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzg3NDAzOQ==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413874039", "bodyText": "This is the same as the variable fields declared above, so remove the duplication?", "author": "sbordet", "createdAt": "2020-04-23T15:02:07Z", "path": "jetty-websocket/websocket-jetty-client/src/main/java/org/eclipse/jetty/websocket/client/impl/JettyClientUpgradeRequest.java", "diffHunk": "@@ -49,14 +49,14 @@ public JettyClientUpgradeRequest(WebSocketCoreClient coreClient, UpgradeRequest\n         if (request != null)\n         {\n             // Copy request details into actual request\n-            HttpFields fields = getHeaders();\n+            HttpFields.Mutable fields = getHeaders();\n             request.getHeaders().forEach(fields::put);\n \n             // Copy manually created Cookies into place\n             List<HttpCookie> cookies = request.getCookies();\n             if (cookies != null)\n             {\n-                HttpFields headers = getHeaders();\n+                HttpFields.Mutable headers = getHeaders();", "originalCommit": "fa86645a99b52390456f0c04bea50f94b890daf5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzg3ODY2OA==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413878668", "bodyText": "Use HttpFields.EMPTY.", "author": "sbordet", "createdAt": "2020-04-23T15:07:41Z", "path": "tests/test-http-client-transport/src/test/java/org/eclipse/jetty/http/client/ProxyWithDynamicTransportTest.java", "diffHunk": "@@ -442,7 +442,7 @@ protected void close(Throwable failure)\n         http2Client.connect(new InetSocketAddress(\"localhost\", proxyConnector.getLocalPort()), new Session.Listener.Adapter(), sessionPromise);\n         Session session = sessionPromise.get(5, TimeUnit.SECONDS);\n         String serverAddress = \"localhost:\" + serverConnector.getLocalPort();\n-        MetaData.ConnectRequest connect = new MetaData.ConnectRequest(HttpScheme.HTTP, new AuthorityHttpField(serverAddress), null, new HttpFields(), null);\n+        MetaData.ConnectRequest connect = new MetaData.ConnectRequest(HttpScheme.HTTP, new AuthorityHttpField(serverAddress), null, HttpFields.build(), null);", "originalCommit": "fa86645a99b52390456f0c04bea50f94b890daf5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzg3ODgwMQ==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r413878801", "bodyText": "Use HttpFields.EMPTY.", "author": "sbordet", "createdAt": "2020-04-23T15:07:48Z", "path": "tests/test-http-client-transport/src/test/java/org/eclipse/jetty/http/client/ProxyWithDynamicTransportTest.java", "diffHunk": "@@ -527,7 +527,7 @@ protected void close(Throwable failure)\n         http2Client.connect(new InetSocketAddress(\"localhost\", proxyConnector.getLocalPort()), new Session.Listener.Adapter(), sessionPromise);\n         Session session = sessionPromise.get(5, TimeUnit.SECONDS);\n         String serverAddress = \"localhost:\" + serverConnector.getLocalPort();\n-        MetaData.ConnectRequest connect = new MetaData.ConnectRequest(HttpScheme.HTTP, new AuthorityHttpField(serverAddress), null, new HttpFields(), null);\n+        MetaData.ConnectRequest connect = new MetaData.ConnectRequest(HttpScheme.HTTP, new AuthorityHttpField(serverAddress), null, HttpFields.build(), null);", "originalCommit": "fa86645a99b52390456f0c04bea50f94b890daf5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c71cb54a13f9ca2a72a3ba8e4bb7c64ba359b635", "url": "https://github.com/eclipse/jetty.project/commit/c71cb54a13f9ca2a72a3ba8e4bb7c64ba359b635", "message": "Immutable MetaData WIP\n\nchanges after review:\n + less usage of Mutable\n + more usage of EMPTY\n + restored fragment handling\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-04-23T17:10:02Z", "type": "commit"}, {"oid": "1fe41691011c6434ee6c1a894f676fcc83a42739", "url": "https://github.com/eclipse/jetty.project/commit/1fe41691011c6434ee6c1a894f676fcc83a42739", "message": "Immutable MetaData WIP\n\nchanges after review:\n + less usage of Mutable\n + less usage of asImmutable\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-04-23T17:43:23Z", "type": "commit"}, {"oid": "9e9274fece8b9f952e5b5c91c548c7c962ebd7b8", "url": "https://github.com/eclipse/jetty.project/commit/9e9274fece8b9f952e5b5c91c548c7c962ebd7b8", "message": "Immutable MetaData WIP\n\nchanges after review:\n + less usage of Mutable\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-04-24T07:52:24Z", "type": "commit"}, {"oid": "1abe2c79f8b3ab0257b105b095ee67f90b2fb3c3", "url": "https://github.com/eclipse/jetty.project/commit/1abe2c79f8b3ab0257b105b095ee67f90b2fb3c3", "message": "Immutable MetaData\n\nchanges after review:\n + better handling of URI in ContextHandler\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-04-24T08:11:25Z", "type": "commit"}, {"oid": "ad82672e233254cb6e49b7bfe8cc431b2a7a8f5f", "url": "https://github.com/eclipse/jetty.project/commit/ad82672e233254cb6e49b7bfe8cc431b2a7a8f5f", "message": "Immutable MetaData\n\nchanges after review:\n + downcast in test to access mutable response headers.\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-04-24T08:46:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQwMTEwOQ==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r414401109", "bodyText": "Please use put() since it's not a multiple occurrences header.", "author": "sbordet", "createdAt": "2020-04-24T08:41:14Z", "path": "jetty-documentation/src/main/java/embedded/client/http2/HTTP2ClientDocs.java", "diffHunk": "@@ -266,9 +266,9 @@ public void reset() throws Exception\n         CompletableFuture<Session> sessionCF = http2Client.connect(serverAddress, new Session.Listener.Adapter());\n         Session session = sessionCF.get();\n \n-        HttpFields requestHeaders = new HttpFields();\n-        requestHeaders.put(HttpHeader.USER_AGENT, \"Jetty HTTP2Client {version}\");\n-        MetaData.Request request = new MetaData.Request(\"GET\", new HttpURI(\"http://localhost:8080/path\"), HttpVersion.HTTP_2, requestHeaders);\n+        HttpFields requestHeaders = HttpFields.build()\n+            .add(HttpHeader.USER_AGENT, \"Jetty HTTP2Client {version}\");", "originalCommit": "1abe2c79f8b3ab0257b105b095ee67f90b2fb3c3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQwMTE5Ng==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r414401196", "bodyText": "Please use put() since it's not a multiple occurrences header.", "author": "sbordet", "createdAt": "2020-04-24T08:41:21Z", "path": "jetty-documentation/src/main/java/embedded/client/http2/HTTP2ClientDocs.java", "diffHunk": "@@ -296,9 +296,9 @@ public void push() throws Exception\n         CompletableFuture<Session> sessionCF = http2Client.connect(serverAddress, new Session.Listener.Adapter());\n         Session session = sessionCF.get();\n \n-        HttpFields requestHeaders = new HttpFields();\n-        requestHeaders.put(HttpHeader.USER_AGENT, \"Jetty HTTP2Client {version}\");\n-        MetaData.Request request = new MetaData.Request(\"GET\", new HttpURI(\"http://localhost:8080/path\"), HttpVersion.HTTP_2, requestHeaders);\n+        HttpFields requestHeaders = HttpFields.build()\n+            .add(HttpHeader.USER_AGENT, \"Jetty HTTP2Client {version}\");", "originalCommit": "1abe2c79f8b3ab0257b105b095ee67f90b2fb3c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcwNzEyOQ==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r414707129", "bodyText": "really?  We can see that it doesn't exist already and add is a lot faster that put... I guess not that much faster on an empty fields. ok", "author": "gregw", "createdAt": "2020-04-24T16:30:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQwMTE5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQxODY4MQ==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r414418681", "bodyText": "Please rename to singular WS_VERSION_FIELD.", "author": "sbordet", "createdAt": "2020-04-24T09:08:12Z", "path": "jetty-websocket/websocket-core/src/main/java/org/eclipse/jetty/websocket/core/client/HttpUpgraderOverHTTP2.java", "diffHunk": "@@ -23,12 +23,14 @@\n import org.eclipse.jetty.client.HttpUpgrader;\n import org.eclipse.jetty.http.HttpHeader;\n import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.PreEncodedHttpField;\n import org.eclipse.jetty.io.EndPoint;\n import org.eclipse.jetty.util.Callback;\n import org.eclipse.jetty.websocket.core.WebSocketConstants;\n \n public class HttpUpgraderOverHTTP2 implements HttpUpgrader\n {\n+    public static final PreEncodedHttpField WS_VERSIONS_FIELD = new PreEncodedHttpField(HttpHeader.SEC_WEBSOCKET_VERSION, WebSocketConstants.SPEC_VERSION_STRING);", "originalCommit": "ad82672e233254cb6e49b7bfe8cc431b2a7a8f5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQxOTIzMw==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r414419233", "bodyText": "Checkstyle will complain, as for always requires braces.", "author": "sbordet", "createdAt": "2020-04-24T09:09:00Z", "path": "jetty-websocket/websocket-jetty-client/src/main/java/org/eclipse/jetty/websocket/client/impl/JettyClientUpgradeRequest.java", "diffHunk": "@@ -49,19 +49,16 @@ public JettyClientUpgradeRequest(WebSocketCoreClient coreClient, UpgradeRequest\n         if (request != null)\n         {\n             // Copy request details into actual request\n-            HttpFields fields = getHeaders();\n+            HttpFields.Mutable fields = getHeaders();\n             request.getHeaders().forEach(fields::put);\n \n             // Copy manually created Cookies into place\n             List<HttpCookie> cookies = request.getCookies();\n             if (cookies != null)\n             {\n-                HttpFields headers = getHeaders();\n                 // TODO: remove existing Cookie header (if set)?\n                 for (HttpCookie cookie : cookies)\n-                {\n-                    headers.add(HttpHeader.COOKIE, cookie.toString());\n-                }\n+                    fields.add(HttpHeader.COOKIE, cookie.toString());", "originalCommit": "ad82672e233254cb6e49b7bfe8cc431b2a7a8f5f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcwNTMyMA==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r414705320", "bodyText": "Checkstyle is dead in intellij for me.  I've tried re-importing, but it just refuses to work?!?!?!?!", "author": "gregw", "createdAt": "2020-04-24T16:28:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQxOTIzMw=="}], "type": "inlineReview"}, {"oid": "ec9224d2191468dde347ac2d5e625d01ea4919e4", "url": "https://github.com/eclipse/jetty.project/commit/ec9224d2191468dde347ac2d5e625d01ea4919e4", "message": "Immutable MetaData\n\nchanges after review:\n + use put instead of add for one time headers\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-04-24T16:32:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTcwMDkyMQ==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r415700921", "bodyText": "Make it private.", "author": "sbordet", "createdAt": "2020-04-27T10:36:13Z", "path": "jetty-websocket/websocket-core/src/main/java/org/eclipse/jetty/websocket/core/client/HttpUpgraderOverHTTP2.java", "diffHunk": "@@ -23,12 +23,14 @@\n import org.eclipse.jetty.client.HttpUpgrader;\n import org.eclipse.jetty.http.HttpHeader;\n import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.PreEncodedHttpField;\n import org.eclipse.jetty.io.EndPoint;\n import org.eclipse.jetty.util.Callback;\n import org.eclipse.jetty.websocket.core.WebSocketConstants;\n \n public class HttpUpgraderOverHTTP2 implements HttpUpgrader\n {\n+    public static final PreEncodedHttpField WS_VERSION_FIELD = new PreEncodedHttpField(HttpHeader.SEC_WEBSOCKET_VERSION, WebSocketConstants.SPEC_VERSION_STRING);", "originalCommit": "ec9224d2191468dde347ac2d5e625d01ea4919e4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTcxNDI5MA==", "url": "https://github.com/eclipse/jetty.project/pull/4777#discussion_r415714290", "bodyText": "done", "author": "gregw", "createdAt": "2020-04-27T10:57:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTcwMDkyMQ=="}], "type": "inlineReview"}, {"oid": "5817a1ab489dfc5d4f5eb1de93e2a4f7d98416a3", "url": "https://github.com/eclipse/jetty.project/commit/5817a1ab489dfc5d4f5eb1de93e2a4f7d98416a3", "message": "private\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-04-27T10:56:34Z", "type": "commit"}, {"oid": "ac3cb3cf21cf3d50f13368ca3e2688401acc1d81", "url": "https://github.com/eclipse/jetty.project/commit/ac3cb3cf21cf3d50f13368ca3e2688401acc1d81", "message": "Merge remote-tracking branch 'origin/jetty-10.0.x' into jetty-10.0.x-ImmutableMetaData", "committedDate": "2020-04-27T13:14:10Z", "type": "commit"}, {"oid": "79bb9f75eae4101f31cdfbd137dc587a1c5a0813", "url": "https://github.com/eclipse/jetty.project/commit/79bb9f75eae4101f31cdfbd137dc587a1c5a0813", "message": "Merge branch 'jetty-10.0.x' into jetty-10.0.x-ImmutableMetaData", "committedDate": "2020-04-28T08:58:02Z", "type": "commit"}]}