{"pr_number": 4975, "pr_title": "Improve client http connection pools", "pr_createdAt": "2020-06-17T12:45:12Z", "pr_url": "https://github.com/eclipse/jetty.project/pull/4975", "timeline": [{"oid": "e896232cf4770468485cf4c4a0ac416f8ad6dac6", "url": "https://github.com/eclipse/jetty.project/commit/e896232cf4770468485cf4c4a0ac416f8ad6dac6", "message": "replace DuplexConnectionPool with PoolDuplexConnectionPool\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-06-17T12:46:17Z", "type": "forcePushed"}, {"oid": "a937ab1c3906a7ccb68620fafb20e5e64c41c19c", "url": "https://github.com/eclipse/jetty.project/commit/a937ab1c3906a7ccb68620fafb20e5e64c41c19c", "message": "fix license headers and checkstyle\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-06-18T08:35:25Z", "type": "forcePushed"}, {"oid": "9cbe6dc2a336adce3df509eee64b123269a9bdf3", "url": "https://github.com/eclipse/jetty.project/commit/9cbe6dc2a336adce3df509eee64b123269a9bdf3", "message": "fix license headers and checkstyle\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-06-18T09:55:47Z", "type": "forcePushed"}, {"oid": "30f1da92c5b7f98e38db159cbd18bc9211d59914", "url": "https://github.com/eclipse/jetty.project/commit/30f1da92c5b7f98e38db159cbd18bc9211d59914", "message": "fix tests\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-06-19T15:37:30Z", "type": "forcePushed"}, {"oid": "e0a8bb64a4668145a9fa79aa80c9be144843d994", "url": "https://github.com/eclipse/jetty.project/commit/e0a8bb64a4668145a9fa79aa80c9be144843d994", "message": "Initial new pool implementation and benchmark\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-06-22T10:09:58Z", "type": "forcePushed"}, {"oid": "e5b51b53a88d3abcd534bbb431bd2a44af06d083", "url": "https://github.com/eclipse/jetty.project/commit/e5b51b53a88d3abcd534bbb431bd2a44af06d083", "message": "initialize RR pool to the max connection count\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-06-22T12:42:17Z", "type": "forcePushed"}, {"oid": "bf482f49246e474651fc48aa60476b47a7884366", "url": "https://github.com/eclipse/jetty.project/commit/bf482f49246e474651fc48aa60476b47a7884366", "message": "strictly refuse working with connections that were not created by the pool\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-06-23T07:10:57Z", "type": "forcePushed"}, {"oid": "14fd0075a992c272f8a5a980479bf3144843d137", "url": "https://github.com/eclipse/jetty.project/commit/14fd0075a992c272f8a5a980479bf3144843d137", "message": "cleanup AbstractConnectionPool API\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-06-25T16:30:10Z", "type": "forcePushed"}, {"oid": "95ba89f6cd57b3b3c26ae1f5550f2324046e9465", "url": "https://github.com/eclipse/jetty.project/commit/95ba89f6cd57b3b3c26ae1f5550f2324046e9465", "message": "cleanup AbstractConnectionPool API\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-06-25T16:31:08Z", "type": "forcePushed"}, {"oid": "074d326dc1332517aef099ea13a182217077853e", "url": "https://github.com/eclipse/jetty.project/commit/074d326dc1332517aef099ea13a182217077853e", "message": "checkstyle fixes\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-06-29T11:51:55Z", "type": "forcePushed"}, {"oid": "85bbc26ee46ce0eb728b0b5b75370b17328440c2", "url": "https://github.com/eclipse/jetty.project/commit/85bbc26ee46ce0eb728b0b5b75370b17328440c2", "message": "improve code\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-06-29T13:41:41Z", "type": "forcePushed"}, {"oid": "c046f11c5914d8c11cb44a3de8d09d466adc55e0", "url": "https://github.com/eclipse/jetty.project/commit/c046f11c5914d8c11cb44a3de8d09d466adc55e0", "message": "move maxMultiplex and maxUsageCount to Pool\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-06-30T13:25:07Z", "type": "forcePushed"}, {"oid": "9e0d0cbc8ce29e7f45f03e34f61d4de07f6f00ef", "url": "https://github.com/eclipse/jetty.project/commit/9e0d0cbc8ce29e7f45f03e34f61d4de07f6f00ef", "message": "add test\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-06-30T14:23:53Z", "type": "forcePushed"}, {"oid": "9799e06573a2e396289411410ea79e376613b41c", "url": "https://github.com/eclipse/jetty.project/commit/9799e06573a2e396289411410ea79e376613b41c", "message": "add test\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-07-01T13:22:44Z", "type": "forcePushed"}, {"oid": "9cc8efd2f01631c664397d5e4eacdc1d70b03188", "url": "https://github.com/eclipse/jetty.project/commit/9cc8efd2f01631c664397d5e4eacdc1d70b03188", "message": "remove maxMultiplex and and maxUsageCount constructor parameters\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-07-06T15:51:15Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg4NjIxMA==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r450886210", "bodyText": "Previous constructors should be re-instated for backwards compatibility.\nNew constructors must not be deprecated already", "author": "sbordet", "createdAt": "2020-07-07T13:59:39Z", "path": "jetty-client/src/main/java/org/eclipse/jetty/client/AbstractConnectionPool.java", "diffHunk": "@@ -18,57 +18,88 @@\n \n package org.eclipse.jetty.client;\n \n+import java.io.IOException;\n import java.util.Collection;\n-import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n \n import org.eclipse.jetty.client.api.Connection;\n import org.eclipse.jetty.client.api.Destination;\n-import org.eclipse.jetty.util.AtomicBiInteger;\n+import org.eclipse.jetty.util.Attachable;\n import org.eclipse.jetty.util.Callback;\n+import org.eclipse.jetty.util.Pool;\n import org.eclipse.jetty.util.Promise;\n import org.eclipse.jetty.util.annotation.ManagedAttribute;\n import org.eclipse.jetty.util.annotation.ManagedObject;\n import org.eclipse.jetty.util.component.Dumpable;\n import org.eclipse.jetty.util.log.Log;\n import org.eclipse.jetty.util.log.Logger;\n+import org.eclipse.jetty.util.thread.Sweeper;\n \n @ManagedObject\n-public abstract class AbstractConnectionPool implements ConnectionPool, Dumpable\n+public abstract class AbstractConnectionPool implements ConnectionPool, Dumpable, Sweeper.Sweepable\n {\n     private static final Logger LOG = Log.getLogger(AbstractConnectionPool.class);\n \n-    /**\n-     * The connectionCount encodes both the total connections plus the pending connection counts, so both can be atomically changed.\n-     * The bottom 32 bits represent the total connections and the top 32 bits represent the pending connections.\n-     */\n-    private final AtomicBiInteger connections = new AtomicBiInteger();\n-    private final AtomicBoolean closed = new AtomicBoolean();\n     private final HttpDestination destination;\n     private final int maxConnections;\n     private final Callback requester;\n+    private final AtomicInteger pendingConnectionCount = new AtomicInteger();\n+    private final Pool<Connection> pool;\n \n     /**\n-     * @param destination the correspondent destination\n-     * @param maxConnections the max number of connections\n-     * @param requester the callback to notify about new connection creation/failure\n-     * @deprecated use {@link #AbstractConnectionPool(HttpDestination, int, Callback)} instead\n+     * @deprecated use {@link #AbstractConnectionPool(HttpDestination, int, int, boolean, Callback)} instead\n      */\n     @Deprecated\n-    protected AbstractConnectionPool(Destination destination, int maxConnections, Callback requester)\n+    protected AbstractConnectionPool(Destination destination, int initialConnections, int maxConnections, boolean cache, Callback requester)", "originalCommit": "9cc8efd2f01631c664397d5e4eacdc1d70b03188", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM1MjE2Mw==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r451352163", "bodyText": "You're right, that is an overlook. Let me fix this.", "author": "lorban", "createdAt": "2020-07-08T07:54:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg4NjIxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg5MDU4Ng==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r450890586", "bodyText": "ThreadPoolExecutor.prestartAllCoreThreads() is not called from the constructor.\nI wonder if we should use the same logic, and offer a similar method to explicitly pre-open the initial connections.\nThis would have the benefit of not requiring initialConnections as a constructor parameters, avoid races between the pool opening the initial connections and application code actually using the pool (which could open more connections than required) and allow to return a CompletableFuture that signals when they have been opened.", "author": "sbordet", "createdAt": "2020-07-07T14:05:33Z", "path": "jetty-client/src/main/java/org/eclipse/jetty/client/AbstractConnectionPool.java", "diffHunk": "@@ -18,57 +18,88 @@\n \n package org.eclipse.jetty.client;\n \n+import java.io.IOException;\n import java.util.Collection;\n-import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n \n import org.eclipse.jetty.client.api.Connection;\n import org.eclipse.jetty.client.api.Destination;\n-import org.eclipse.jetty.util.AtomicBiInteger;\n+import org.eclipse.jetty.util.Attachable;\n import org.eclipse.jetty.util.Callback;\n+import org.eclipse.jetty.util.Pool;\n import org.eclipse.jetty.util.Promise;\n import org.eclipse.jetty.util.annotation.ManagedAttribute;\n import org.eclipse.jetty.util.annotation.ManagedObject;\n import org.eclipse.jetty.util.component.Dumpable;\n import org.eclipse.jetty.util.log.Log;\n import org.eclipse.jetty.util.log.Logger;\n+import org.eclipse.jetty.util.thread.Sweeper;\n \n @ManagedObject\n-public abstract class AbstractConnectionPool implements ConnectionPool, Dumpable\n+public abstract class AbstractConnectionPool implements ConnectionPool, Dumpable, Sweeper.Sweepable\n {\n     private static final Logger LOG = Log.getLogger(AbstractConnectionPool.class);\n \n-    /**\n-     * The connectionCount encodes both the total connections plus the pending connection counts, so both can be atomically changed.\n-     * The bottom 32 bits represent the total connections and the top 32 bits represent the pending connections.\n-     */\n-    private final AtomicBiInteger connections = new AtomicBiInteger();\n-    private final AtomicBoolean closed = new AtomicBoolean();\n     private final HttpDestination destination;\n     private final int maxConnections;\n     private final Callback requester;\n+    private final AtomicInteger pendingConnectionCount = new AtomicInteger();\n+    private final Pool<Connection> pool;\n \n     /**\n-     * @param destination the correspondent destination\n-     * @param maxConnections the max number of connections\n-     * @param requester the callback to notify about new connection creation/failure\n-     * @deprecated use {@link #AbstractConnectionPool(HttpDestination, int, Callback)} instead\n+     * @deprecated use {@link #AbstractConnectionPool(HttpDestination, int, int, boolean, Callback)} instead\n      */\n     @Deprecated\n-    protected AbstractConnectionPool(Destination destination, int maxConnections, Callback requester)\n+    protected AbstractConnectionPool(Destination destination, int initialConnections, int maxConnections, boolean cache, Callback requester)\n     {\n-        this((HttpDestination)destination, maxConnections, requester);\n+        this((HttpDestination)destination, initialConnections, maxConnections, cache, requester);\n     }\n \n-    protected AbstractConnectionPool(HttpDestination destination, int maxConnections, Callback requester)\n+    protected AbstractConnectionPool(HttpDestination destination, int initialConnections, int maxConnections, boolean cache, Callback requester)\n     {\n+        if (maxConnections < initialConnections)\n+            throw new IllegalArgumentException(\"maxConnections must be >= than initialConnections\");\n         this.destination = destination;\n         this.maxConnections = maxConnections;\n         this.requester = requester;\n+        this.pool = new Pool<>(cache ? 1 : 0);\n+        for (int i = 0; i < initialConnections; i++)\n+        {\n+            tryCreate(maxConnections);\n+        }", "originalCommit": "9cc8efd2f01631c664397d5e4eacdc1d70b03188", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM3Mzg3OQ==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r451373879", "bodyText": "Makes sense. I'll remove the constructor parameter and replace it with a method that guarantees the connections are fully setup.", "author": "lorban", "createdAt": "2020-07-08T08:30:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg5MDU4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg5MTE4OA==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r450891188", "bodyText": "pool should be added as a bean so it will be dumped.", "author": "sbordet", "createdAt": "2020-07-07T14:06:26Z", "path": "jetty-client/src/main/java/org/eclipse/jetty/client/AbstractConnectionPool.java", "diffHunk": "@@ -18,57 +18,88 @@\n \n package org.eclipse.jetty.client;\n \n+import java.io.IOException;\n import java.util.Collection;\n-import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n \n import org.eclipse.jetty.client.api.Connection;\n import org.eclipse.jetty.client.api.Destination;\n-import org.eclipse.jetty.util.AtomicBiInteger;\n+import org.eclipse.jetty.util.Attachable;\n import org.eclipse.jetty.util.Callback;\n+import org.eclipse.jetty.util.Pool;\n import org.eclipse.jetty.util.Promise;\n import org.eclipse.jetty.util.annotation.ManagedAttribute;\n import org.eclipse.jetty.util.annotation.ManagedObject;\n import org.eclipse.jetty.util.component.Dumpable;\n import org.eclipse.jetty.util.log.Log;\n import org.eclipse.jetty.util.log.Logger;\n+import org.eclipse.jetty.util.thread.Sweeper;\n \n @ManagedObject\n-public abstract class AbstractConnectionPool implements ConnectionPool, Dumpable\n+public abstract class AbstractConnectionPool implements ConnectionPool, Dumpable, Sweeper.Sweepable\n {\n     private static final Logger LOG = Log.getLogger(AbstractConnectionPool.class);\n \n-    /**\n-     * The connectionCount encodes both the total connections plus the pending connection counts, so both can be atomically changed.\n-     * The bottom 32 bits represent the total connections and the top 32 bits represent the pending connections.\n-     */\n-    private final AtomicBiInteger connections = new AtomicBiInteger();\n-    private final AtomicBoolean closed = new AtomicBoolean();\n     private final HttpDestination destination;\n     private final int maxConnections;\n     private final Callback requester;\n+    private final AtomicInteger pendingConnectionCount = new AtomicInteger();\n+    private final Pool<Connection> pool;\n \n     /**\n-     * @param destination the correspondent destination\n-     * @param maxConnections the max number of connections\n-     * @param requester the callback to notify about new connection creation/failure\n-     * @deprecated use {@link #AbstractConnectionPool(HttpDestination, int, Callback)} instead\n+     * @deprecated use {@link #AbstractConnectionPool(HttpDestination, int, int, boolean, Callback)} instead\n      */\n     @Deprecated\n-    protected AbstractConnectionPool(Destination destination, int maxConnections, Callback requester)\n+    protected AbstractConnectionPool(Destination destination, int initialConnections, int maxConnections, boolean cache, Callback requester)\n     {\n-        this((HttpDestination)destination, maxConnections, requester);\n+        this((HttpDestination)destination, initialConnections, maxConnections, cache, requester);\n     }\n \n-    protected AbstractConnectionPool(HttpDestination destination, int maxConnections, Callback requester)\n+    protected AbstractConnectionPool(HttpDestination destination, int initialConnections, int maxConnections, boolean cache, Callback requester)\n     {\n+        if (maxConnections < initialConnections)\n+            throw new IllegalArgumentException(\"maxConnections must be >= than initialConnections\");\n         this.destination = destination;\n         this.maxConnections = maxConnections;\n         this.requester = requester;\n+        this.pool = new Pool<>(cache ? 1 : 0);", "originalCommit": "9cc8efd2f01631c664397d5e4eacdc1d70b03188", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTU2NjU2OA==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r451566568", "bodyText": "Ok.", "author": "lorban", "createdAt": "2020-07-08T13:59:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg5MTE4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg5MTY4NA==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r450891684", "bodyText": "Either make these new getters @ManagedAttribute, or the correspondent getters in Pool.\nI probably like them best here, so users will have only one place to go in JMC.", "author": "sbordet", "createdAt": "2020-07-07T14:07:06Z", "path": "jetty-client/src/main/java/org/eclipse/jetty/client/AbstractConnectionPool.java", "diffHunk": "@@ -18,57 +18,88 @@\n \n package org.eclipse.jetty.client;\n \n+import java.io.IOException;\n import java.util.Collection;\n-import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n \n import org.eclipse.jetty.client.api.Connection;\n import org.eclipse.jetty.client.api.Destination;\n-import org.eclipse.jetty.util.AtomicBiInteger;\n+import org.eclipse.jetty.util.Attachable;\n import org.eclipse.jetty.util.Callback;\n+import org.eclipse.jetty.util.Pool;\n import org.eclipse.jetty.util.Promise;\n import org.eclipse.jetty.util.annotation.ManagedAttribute;\n import org.eclipse.jetty.util.annotation.ManagedObject;\n import org.eclipse.jetty.util.component.Dumpable;\n import org.eclipse.jetty.util.log.Log;\n import org.eclipse.jetty.util.log.Logger;\n+import org.eclipse.jetty.util.thread.Sweeper;\n \n @ManagedObject\n-public abstract class AbstractConnectionPool implements ConnectionPool, Dumpable\n+public abstract class AbstractConnectionPool implements ConnectionPool, Dumpable, Sweeper.Sweepable\n {\n     private static final Logger LOG = Log.getLogger(AbstractConnectionPool.class);\n \n-    /**\n-     * The connectionCount encodes both the total connections plus the pending connection counts, so both can be atomically changed.\n-     * The bottom 32 bits represent the total connections and the top 32 bits represent the pending connections.\n-     */\n-    private final AtomicBiInteger connections = new AtomicBiInteger();\n-    private final AtomicBoolean closed = new AtomicBoolean();\n     private final HttpDestination destination;\n     private final int maxConnections;\n     private final Callback requester;\n+    private final AtomicInteger pendingConnectionCount = new AtomicInteger();\n+    private final Pool<Connection> pool;\n \n     /**\n-     * @param destination the correspondent destination\n-     * @param maxConnections the max number of connections\n-     * @param requester the callback to notify about new connection creation/failure\n-     * @deprecated use {@link #AbstractConnectionPool(HttpDestination, int, Callback)} instead\n+     * @deprecated use {@link #AbstractConnectionPool(HttpDestination, int, int, boolean, Callback)} instead\n      */\n     @Deprecated\n-    protected AbstractConnectionPool(Destination destination, int maxConnections, Callback requester)\n+    protected AbstractConnectionPool(Destination destination, int initialConnections, int maxConnections, boolean cache, Callback requester)\n     {\n-        this((HttpDestination)destination, maxConnections, requester);\n+        this((HttpDestination)destination, initialConnections, maxConnections, cache, requester);\n     }\n \n-    protected AbstractConnectionPool(HttpDestination destination, int maxConnections, Callback requester)\n+    protected AbstractConnectionPool(HttpDestination destination, int initialConnections, int maxConnections, boolean cache, Callback requester)\n     {\n+        if (maxConnections < initialConnections)\n+            throw new IllegalArgumentException(\"maxConnections must be >= than initialConnections\");\n         this.destination = destination;\n         this.maxConnections = maxConnections;\n         this.requester = requester;\n+        this.pool = new Pool<>(cache ? 1 : 0);\n+        for (int i = 0; i < initialConnections; i++)\n+        {\n+            tryCreate(maxConnections);\n+        }\n+    }\n+\n+    protected int getMaxMultiplex()", "originalCommit": "9cc8efd2f01631c664397d5e4eacdc1d70b03188", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTU3MzE2NQ==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r451573165", "bodyText": "Ok.", "author": "lorban", "createdAt": "2020-07-08T14:07:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg5MTY4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg5MjYzOA==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r450892638", "bodyText": "Restore protected, there may be implementations from users.", "author": "sbordet", "createdAt": "2020-07-07T14:08:23Z", "path": "jetty-client/src/main/java/org/eclipse/jetty/client/AbstractConnectionPool.java", "diffHunk": "@@ -129,13 +160,12 @@ public Connection acquire()\n      * @return an idle connection or {@code null} if no idle connections are available\n      * @see #tryCreate(int)\n      */\n-    protected Connection acquire(boolean create)\n+    Connection acquire(boolean create)", "originalCommit": "9cc8efd2f01631c664397d5e4eacdc1d70b03188", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM3NDA1Mg==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r451374052", "bodyText": "Ok.", "author": "lorban", "createdAt": "2020-07-08T08:31:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg5MjYzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg5MjgxNw==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r450892817", "bodyText": "Restore protected, there may be implementations from users.", "author": "sbordet", "createdAt": "2020-07-07T14:08:37Z", "path": "jetty-client/src/main/java/org/eclipse/jetty/client/AbstractConnectionPool.java", "diffHunk": "@@ -151,13 +181,12 @@ protected Connection acquire(boolean create)\n      * @param maxPending the max desired number of connections scheduled for opening,\n      * or a negative number to always trigger the opening of a new connection\n      */\n-    protected void tryCreate(int maxPending)\n+    void tryCreate(int maxPending)", "originalCommit": "9cc8efd2f01631c664397d5e4eacdc1d70b03188", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg5MzkwNw==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r450893907", "bodyText": "The previous logic was different: when create==false, there was a call to activate(). There is a reason for the change?", "author": "sbordet", "createdAt": "2020-07-07T14:10:02Z", "path": "jetty-client/src/main/java/org/eclipse/jetty/client/AbstractConnectionPool.java", "diffHunk": "@@ -129,13 +160,12 @@ public Connection acquire()\n      * @return an idle connection or {@code null} if no idle connections are available\n      * @see #tryCreate(int)\n      */\n-    protected Connection acquire(boolean create)\n+    Connection acquire(boolean create)\n     {\n         Connection connection = activate();\n-        if (connection == null)\n+        if (connection == null && create)\n         {\n-            if (create)\n-                tryCreate(destination.getQueuedRequestCount());\n+            tryCreate(destination.getQueuedRequestCount());", "originalCommit": "9cc8efd2f01631c664397d5e4eacdc1d70b03188", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDkwNzM4OQ==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r450907389", "bodyText": "I think this broke the max number of connections limit.\npool.size() and pending connections are not atomically changed, so it's possible that when a connection takes a long time to be created, we continue to call tryCreate() and exceed maxConnections.", "author": "sbordet", "createdAt": "2020-07-07T14:27:42Z", "path": "jetty-client/src/main/java/org/eclipse/jetty/client/AbstractConnectionPool.java", "diffHunk": "@@ -151,13 +181,12 @@ protected Connection acquire(boolean create)\n      * @param maxPending the max desired number of connections scheduled for opening,\n      * or a negative number to always trigger the opening of a new connection\n      */\n-    protected void tryCreate(int maxPending)\n+    void tryCreate(int maxPending)\n     {\n         while (true)\n         {\n-            long encoded = connections.get();\n-            int pending = AtomicBiInteger.getHi(encoded);\n-            int total = AtomicBiInteger.getLo(encoded);\n+            int pending = pendingConnectionCount.get();\n+            int total = pool.size() + pending;", "originalCommit": "9cc8efd2f01631c664397d5e4eacdc1d70b03188", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTU0MDQ1Mg==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r451540452", "bodyText": "AtomicBiInteger is my current favourite class... at least until we add AtomicQuadShort, which will then be my favourite class until we add AtomicOctaByte!      So don't think you can get rid of it that easily.\nThe point of encoding both the size and pending into the same Atomic is so that one cannot be changed while we are looping/considering/changing the other.    In this case, we might decide to increment pending but concurrently the size is already incremented to the max size.  Previously we would see that in 171 and loop, now we don't see it.\nI so have to find a need for AtomicOctaByte.... maybe that would simplify HttpInput?", "author": "gregw", "createdAt": "2020-07-08T13:23:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDkwNzM4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg4NDIxMw==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r454884213", "bodyText": "This still needs to be resolved.", "author": "gregw", "createdAt": "2020-07-15T08:33:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDkwNzM4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDkxMDI4Ng==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r450910286", "bodyText": "Leaks the underlying algorithm, we should avoid it.\nAlso protected Connection active(Connection connection) has been deleted but should be restored.\nCan this be moved to RoundRobinConnectionPool?", "author": "sbordet", "createdAt": "2020-07-07T14:31:20Z", "path": "jetty-client/src/main/java/org/eclipse/jetty/client/AbstractConnectionPool.java", "diffHunk": "@@ -180,61 +209,135 @@ public void succeeded(Connection connection)\n                     {\n                         if (LOG.isDebugEnabled())\n                             LOG.debug(\"Connection {}/{} creation succeeded {}\", total + 1, maxConnections, connection);\n-                        connections.add(-1, 0);\n-                        onCreated(connection);\n-                        proceed();\n+                        pendingConnectionCount.decrementAndGet();\n+                        adopt(connection);\n+                        requester.succeeded();\n                     }\n \n                     @Override\n                     public void failed(Throwable x)\n                     {\n                         if (LOG.isDebugEnabled())\n                             LOG.debug(\"Connection \" + (total + 1) + \"/\" + maxConnections + \" creation failed\", x);\n-                        connections.add(-1, -1);\n+                        pendingConnectionCount.decrementAndGet();\n                         requester.failed(x);\n                     }\n                 });\n \n-                return;\n+                break;\n             }\n         }\n     }\n \n-    protected abstract void onCreated(Connection connection);\n-\n-    protected void proceed()\n+    //TODO Review tests calling this method.\n+    void adopt(Connection connection)\n     {\n-        requester.succeeded();\n+        if (!(connection instanceof Attachable))\n+            throw new IllegalArgumentException(\"Invalid connection object: \" + connection);\n+        Attachable attachable = (Attachable)connection;\n+        Pool<Connection>.Entry pooledConnection = pool.newEntry(connection);\n+        attachable.attach(pooledConnection);\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"onCreating {}\", pooledConnection);\n+        onCreated(connection);\n+        pool.add(pooledConnection);\n+        idle(connection, false);\n     }\n \n-    protected abstract Connection activate();\n+    protected Connection activate()\n+    {\n+        return activate(-1);\n+    }\n \n-    protected Connection active(Connection connection)\n+    protected Connection activate(int offset)", "originalCommit": "9cc8efd2f01631c664397d5e4eacdc1d70b03188", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQyOTEyNQ==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r461429125", "bodyText": "I still have concerns about this - I would like to move the \"index\" to round-robin only, as others don't need it.", "author": "sbordet", "createdAt": "2020-07-28T09:02:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDkxMDI4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDkxMzEzMQ==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r450913131", "bodyText": "You should not need this if pool is added as a bean.", "author": "sbordet", "createdAt": "2020-07-07T14:35:03Z", "path": "jetty-client/src/main/java/org/eclipse/jetty/client/AbstractConnectionPool.java", "diffHunk": "@@ -243,28 +346,60 @@ protected void released(Connection connection)\n \n     protected void removed(Connection connection)\n     {\n-        int pooled = connections.addAndGetLo(-1);\n-        if (LOG.isDebugEnabled())\n-            LOG.debug(\"Connection removed {} - pooled: {}\", connection, pooled);\n+    }\n+\n+    public Collection<Connection> getIdleConnections()\n+    {\n+        return pool.values().stream().filter(e -> e.getState() == 0).map(Pool.Entry::getPooled).collect(Collectors.toList());\n+    }\n+\n+    public Collection<Connection> getActiveConnections()\n+    {\n+        return pool.values().stream().filter(e -> e.getState() > 0).map(Pool.Entry::getPooled).collect(Collectors.toList());\n     }\n \n     @Override\n     public void close()\n     {\n-        if (closed.compareAndSet(false, true))\n-        {\n-            connections.set(0, 0);\n-        }\n+        pool.close();\n     }\n \n-    protected void close(Collection<Connection> connections)\n+    @Override\n+    public void dump(Appendable out, String indent) throws IOException\n+    {\n+        Dumpable.dumpObjects(out, indent, this, pool);\n+    }", "originalCommit": "9cc8efd2f01631c664397d5e4eacdc1d70b03188", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDkxNTU2Mg==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r450915562", "bodyText": "http2.IStream also has attachment concept. Can we make this new interface match the methods in IStream?", "author": "sbordet", "createdAt": "2020-07-07T14:38:29Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Attachable.java", "diffHunk": "@@ -0,0 +1,37 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.util;\n+\n+/**\n+ * Abstract mechanism to support attachment of misc. objects.\n+ */\n+public interface Attachable\n+{\n+    /**\n+     * Attach the given object.\n+     * @param obj the attachment.\n+     */\n+    void attach(Object obj);\n+\n+    /**\n+     * Get the attached object.\n+     * @return the attachment.\n+     */\n+    Object attachment();\n+}", "originalCommit": "9cc8efd2f01631c664397d5e4eacdc1d70b03188", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTcwODMyMw==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r451708323", "bodyText": "Yes, Done.", "author": "lorban", "createdAt": "2020-07-08T17:25:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDkxNTU2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDkxNjQzMg==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r450916432", "bodyText": "Unnecessary empty line.", "author": "sbordet", "createdAt": "2020-07-07T14:39:40Z", "path": "jetty-client/src/main/java/org/eclipse/jetty/client/HttpConnection.java", "diffHunk": "@@ -272,9 +274,22 @@ public boolean onIdleTimeout(long idleTimeout)\n         }\n     }\n \n+    @Override\n+    public void attach(Object obj)\n+    {\n+        this.attachment = obj;\n+    }\n+\n+    @Override\n+    public Object attachment()\n+    {\n+        return attachment;\n+    }\n+\n     @Override\n     public String toString()\n     {\n         return String.format(\"%s@%h\", getClass().getSimpleName(), this);\n     }\n+", "originalCommit": "9cc8efd2f01631c664397d5e4eacdc1d70b03188", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTU3NDMzNQ==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r451574335", "bodyText": "Removed.", "author": "lorban", "createdAt": "2020-07-08T14:09:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDkxNjQzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDkxODMwMg==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r450918302", "bodyText": "This class cannot be deleted - it's used for the specific problem indicated in the javadocs.", "author": "sbordet", "createdAt": "2020-07-07T14:42:13Z", "path": "jetty-client/src/main/java/org/eclipse/jetty/client/ValidatingConnectionPool.java", "diffHunk": "@@ -1,211 +0,0 @@\n-//\n-//  ========================================================================\n-//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n-//  ------------------------------------------------------------------------\n-//  All rights reserved. This program and the accompanying materials\n-//  are made available under the terms of the Eclipse Public License v1.0\n-//  and Apache License v2.0 which accompanies this distribution.\n-//\n-//      The Eclipse Public License is available at\n-//      http://www.eclipse.org/legal/epl-v10.html\n-//\n-//      The Apache License v2.0 is available at\n-//      http://www.opensource.org/licenses/apache2.0.php\n-//\n-//  You may elect to redistribute this code under either of these licenses.\n-//  ========================================================================\n-//\n-\n-package org.eclipse.jetty.client;\n-\n-import java.io.IOException;\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.stream.Stream;\n-\n-import org.eclipse.jetty.client.api.Connection;\n-import org.eclipse.jetty.client.api.Destination;\n-import org.eclipse.jetty.util.Callback;\n-import org.eclipse.jetty.util.annotation.ManagedAttribute;\n-import org.eclipse.jetty.util.component.DumpableCollection;\n-import org.eclipse.jetty.util.log.Log;\n-import org.eclipse.jetty.util.log.Logger;\n-import org.eclipse.jetty.util.thread.Scheduler;\n-\n-/**\n- * <p>A connection pool that validates connections before\n- * making them available for use.</p>\n- * <p>Connections that have just been opened are not validated.\n- * Connections that are {@link #release(Connection) released} will\n- * be validated.</p>\n- * <p>Validation by reading from the EndPoint is not reliable,\n- * since the TCP FIN may arrive just after the validation read.</p>\n- * <p>This class validates connections by putting them in a\n- * \"quarantine\" for a configurable timeout, where they cannot\n- * be used to send requests. When the timeout expires, the\n- * quarantined connection is made idle and therefore available\n- * to send requests.</p>\n- * <p>The existing HttpClient mechanism to detect server closes\n- * will trigger and close quarantined connections, before they\n- * are made idle (and reusable) again.</p>\n- * <p>There still is a small chance that the timeout expires,\n- * the connection is made idle and available again, it is used\n- * to send a request exactly when the server decides to close.\n- * This case is however unavoidable and may be mitigated by\n- * tuning the idle timeout of the servers to be larger than\n- * that of the client.</p>\n- */\n-public class ValidatingConnectionPool extends DuplexConnectionPool", "originalCommit": "9cc8efd2f01631c664397d5e4eacdc1d70b03188", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDkxOTkxNQ==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r450919915", "bodyText": "This class does not seem to do much, and all its functionalities can be moved to AbstractConnectionPool.", "author": "sbordet", "createdAt": "2020-07-07T14:44:14Z", "path": "jetty-client/src/test/java/org/eclipse/jetty/client/ConnectionPoolHelper.java", "diffHunk": "@@ -0,0 +1,42 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.client;\n+\n+import org.eclipse.jetty.client.api.Connection;\n+import org.eclipse.jetty.client.api.Destination;\n+\n+public class ConnectionPoolHelper", "originalCommit": "9cc8efd2f01631c664397d5e4eacdc1d70b03188", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTU3NTE4OQ==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r451575189", "bodyText": "Not without exposing the internals of AbstractConnectionPool.", "author": "lorban", "createdAt": "2020-07-08T14:10:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDkxOTkxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDkyNjAyMg==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r450926022", "bodyText": "Unfortunately, I think Queue<Connection> DuplexConnectionPool.getIdleConnections() should be restored.\nFortunately, the return type can be covariant, so it should not be a big deal (but need deprecation).", "author": "sbordet", "createdAt": "2020-07-07T14:52:09Z", "path": "jetty-client/src/test/java/org/eclipse/jetty/client/HttpClientTest.java", "diffHunk": "@@ -133,7 +133,8 @@ public void testStoppingClosesConnections(Scenario scenario) throws Exception\n         HttpConnectionOverHTTP connection = null;\n         while (connection == null && TimeUnit.NANOSECONDS.toSeconds(System.nanoTime() - start) < 5)\n         {\n-            connection = (HttpConnectionOverHTTP)connectionPool.getIdleConnections().peek();\n+            Iterator<Connection> it = connectionPool.getIdleConnections().iterator();", "originalCommit": "9cc8efd2f01631c664397d5e4eacdc1d70b03188", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDkyNjc2Nw==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r450926767", "bodyText": "Must be restored.", "author": "sbordet", "createdAt": "2020-07-07T14:53:05Z", "path": "jetty-client/src/test/java/org/eclipse/jetty/client/ValidatingConnectionPoolTest.java", "diffHunk": "@@ -1,181 +0,0 @@\n-//\n-//  ========================================================================\n-//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n-//  ------------------------------------------------------------------------\n-//  All rights reserved. This program and the accompanying materials\n-//  are made available under the terms of the Eclipse Public License v1.0\n-//  and Apache License v2.0 which accompanies this distribution.\n-//\n-//      The Eclipse Public License is available at\n-//      http://www.eclipse.org/legal/epl-v10.html\n-//\n-//      The Apache License v2.0 is available at\n-//      http://www.opensource.org/licenses/apache2.0.php\n-//\n-//  You may elect to redistribute this code under either of these licenses.\n-//  ========================================================================\n-//\n-\n-package org.eclipse.jetty.client;\n-\n-import java.io.IOException;\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.TimeUnit;\n-import javax.servlet.ServletException;\n-import javax.servlet.http.HttpServletRequest;\n-import javax.servlet.http.HttpServletResponse;\n-\n-import org.eclipse.jetty.client.api.ContentResponse;\n-import org.eclipse.jetty.client.api.Request;\n-import org.eclipse.jetty.client.util.FutureResponseListener;\n-import org.eclipse.jetty.http.HttpHeader;\n-import org.eclipse.jetty.http.HttpHeaderValue;\n-import org.eclipse.jetty.http.HttpStatus;\n-import org.eclipse.jetty.server.Handler;\n-import org.eclipse.jetty.server.handler.AbstractHandler;\n-import org.junit.jupiter.params.ParameterizedTest;\n-import org.junit.jupiter.params.provider.ArgumentsSource;\n-\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-\n-public class ValidatingConnectionPoolTest extends AbstractHttpClientServerTest", "originalCommit": "9cc8efd2f01631c664397d5e4eacdc1d70b03188", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDkyODk0OQ==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r450928949", "bodyText": "Can this be made an inner class of the benchmark?", "author": "sbordet", "createdAt": "2020-07-07T14:55:55Z", "path": "jetty-jmh/src/main/java/org/eclipse/jetty/client/jmh/MockConnection.java", "diffHunk": "@@ -0,0 +1,57 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.client.jmh;\n+\n+import org.eclipse.jetty.client.api.Connection;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.api.Response;\n+import org.eclipse.jetty.util.Attachable;\n+\n+class MockConnection implements Connection, Attachable", "originalCommit": "9cc8efd2f01631c664397d5e4eacdc1d70b03188", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTY3Mjc3Mw==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r451672773", "bodyText": "Yes, it can. Let me change that.", "author": "lorban", "createdAt": "2020-07-08T16:27:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDkyODk0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk0MTQxOA==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r450941418", "bodyText": "cacheSize can be 0. Perhaps just remove the throw and assume <= 0 means disabled.", "author": "sbordet", "createdAt": "2020-07-07T15:12:24Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -0,0 +1,395 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.util;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.eclipse.jetty.util.log.Log;\n+import org.eclipse.jetty.util.log.Logger;\n+\n+/**\n+ * A fast container of poolable objects, with optional support for\n+ * multiplexing and thread-local caching.\n+ * @param <T>\n+ */\n+public class Pool<T> implements AutoCloseable\n+{\n+    private static final Logger LOGGER = Log.getLogger(Pool.class);\n+\n+    private final List<Entry> sharedList = new CopyOnWriteArrayList<>();\n+    private final Collection<List<Entry>> allCaches = new CopyOnWriteArrayList<>();\n+    private final ThreadLocal<List<Entry>> cache;\n+    private final Lock closeLock = new ReentrantLock();\n+    private final int cacheSize;\n+    private volatile boolean closed;\n+    private volatile int maxMultiplex = 1;\n+    private volatile int maxUsageCount = -1;\n+\n+    /**\n+     * Construct a Pool with the specified thread-local cache size.\n+     *\n+     * @param cacheSize the thread-local cache size. A value of 0 means the cache is disabled.\n+     */\n+    public Pool(int cacheSize)\n+    {\n+        if (cacheSize < 0)\n+            throw new IllegalArgumentException(\"Cache size must be >= 1\");", "originalCommit": "9cc8efd2f01631c664397d5e4eacdc1d70b03188", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk0MzEyMw==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r450943123", "bodyText": "I'd return false here. Cases where the client is shutting down when a connection is being added are not uncommon.", "author": "sbordet", "createdAt": "2020-07-07T15:14:40Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -0,0 +1,395 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.util;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.eclipse.jetty.util.log.Log;\n+import org.eclipse.jetty.util.log.Logger;\n+\n+/**\n+ * A fast container of poolable objects, with optional support for\n+ * multiplexing and thread-local caching.\n+ * @param <T>\n+ */\n+public class Pool<T> implements AutoCloseable\n+{\n+    private static final Logger LOGGER = Log.getLogger(Pool.class);\n+\n+    private final List<Entry> sharedList = new CopyOnWriteArrayList<>();\n+    private final Collection<List<Entry>> allCaches = new CopyOnWriteArrayList<>();\n+    private final ThreadLocal<List<Entry>> cache;\n+    private final Lock closeLock = new ReentrantLock();\n+    private final int cacheSize;\n+    private volatile boolean closed;\n+    private volatile int maxMultiplex = 1;\n+    private volatile int maxUsageCount = -1;\n+\n+    /**\n+     * Construct a Pool with the specified thread-local cache size.\n+     *\n+     * @param cacheSize the thread-local cache size. A value of 0 means the cache is disabled.\n+     */\n+    public Pool(int cacheSize)\n+    {\n+        if (cacheSize < 0)\n+            throw new IllegalArgumentException(\"Cache size must be >= 1\");\n+        this.cacheSize = cacheSize;\n+        if (cacheSize > 0)\n+        {\n+            this.cache = ThreadLocal.withInitial(() ->\n+            {\n+                List<Entry> list = new ArrayList<>(cacheSize);\n+                allCaches.add(list);\n+                return list;\n+            });\n+        }\n+        else\n+        {\n+            this.cache = null;\n+        }\n+    }\n+\n+    public int getMaxMultiplex()\n+    {\n+        return maxMultiplex;\n+    }\n+\n+    public final void setMaxMultiplex(int maxMultiplex)\n+    {\n+        if (maxMultiplex < 1)\n+            throw new IllegalArgumentException(\"Max multiplex must be >= 1\");\n+        this.maxMultiplex = maxMultiplex;\n+    }\n+\n+    public int getMaxUsageCount()\n+    {\n+        return maxUsageCount;\n+    }\n+\n+    public final void setMaxUsageCount(int maxUsageCount)\n+    {\n+        if (maxUsageCount == 0)\n+            throw new IllegalArgumentException(\"Max usage count must be != 0\");\n+        this.maxUsageCount = maxUsageCount;\n+    }\n+\n+    public Entry newEntry(T pooled)\n+    {\n+        return new Entry(pooled);\n+    }\n+\n+    /**\n+     * Add a new object to the pool for others to acquire.\n+     *\n+     * @param entry an object to add to the pool\n+     */\n+    public void add(Entry entry)\n+    {\n+        closeLock.lock();\n+        try\n+        {\n+            if (closed)\n+                throw new IllegalStateException(\"Pool has been closed\");", "originalCommit": "9cc8efd2f01631c664397d5e4eacdc1d70b03188", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk1MjMzMA==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r450952330", "bodyText": "Not sure what this lock protects. Apparently not field closed as it's volatile and often read outside the lock?", "author": "sbordet", "createdAt": "2020-07-07T15:27:44Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -0,0 +1,395 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.util;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.eclipse.jetty.util.log.Log;\n+import org.eclipse.jetty.util.log.Logger;\n+\n+/**\n+ * A fast container of poolable objects, with optional support for\n+ * multiplexing and thread-local caching.\n+ * @param <T>\n+ */\n+public class Pool<T> implements AutoCloseable\n+{\n+    private static final Logger LOGGER = Log.getLogger(Pool.class);\n+\n+    private final List<Entry> sharedList = new CopyOnWriteArrayList<>();\n+    private final Collection<List<Entry>> allCaches = new CopyOnWriteArrayList<>();\n+    private final ThreadLocal<List<Entry>> cache;\n+    private final Lock closeLock = new ReentrantLock();", "originalCommit": "9cc8efd2f01631c664397d5e4eacdc1d70b03188", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTU0ODUwOQ==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r451548509", "bodyText": "The lock is only about preventing concurrent add() and close() calls, i.e.: don't allow adding new objects to the pool once close() has been called. I've reworked the closed state to check it from all methods and added some extra test.", "author": "lorban", "createdAt": "2020-07-08T13:35:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk1MjMzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk1MzM3NQ==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r450953375", "bodyText": "maxUsageCount is volatile and should be copied in a local variable since it's used few lines below too.", "author": "sbordet", "createdAt": "2020-07-07T15:29:10Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -0,0 +1,395 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.util;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.eclipse.jetty.util.log.Log;\n+import org.eclipse.jetty.util.log.Logger;\n+\n+/**\n+ * A fast container of poolable objects, with optional support for\n+ * multiplexing and thread-local caching.\n+ * @param <T>\n+ */\n+public class Pool<T> implements AutoCloseable\n+{\n+    private static final Logger LOGGER = Log.getLogger(Pool.class);\n+\n+    private final List<Entry> sharedList = new CopyOnWriteArrayList<>();\n+    private final Collection<List<Entry>> allCaches = new CopyOnWriteArrayList<>();\n+    private final ThreadLocal<List<Entry>> cache;\n+    private final Lock closeLock = new ReentrantLock();\n+    private final int cacheSize;\n+    private volatile boolean closed;\n+    private volatile int maxMultiplex = 1;\n+    private volatile int maxUsageCount = -1;\n+\n+    /**\n+     * Construct a Pool with the specified thread-local cache size.\n+     *\n+     * @param cacheSize the thread-local cache size. A value of 0 means the cache is disabled.\n+     */\n+    public Pool(int cacheSize)\n+    {\n+        if (cacheSize < 0)\n+            throw new IllegalArgumentException(\"Cache size must be >= 1\");\n+        this.cacheSize = cacheSize;\n+        if (cacheSize > 0)\n+        {\n+            this.cache = ThreadLocal.withInitial(() ->\n+            {\n+                List<Entry> list = new ArrayList<>(cacheSize);\n+                allCaches.add(list);\n+                return list;\n+            });\n+        }\n+        else\n+        {\n+            this.cache = null;\n+        }\n+    }\n+\n+    public int getMaxMultiplex()\n+    {\n+        return maxMultiplex;\n+    }\n+\n+    public final void setMaxMultiplex(int maxMultiplex)\n+    {\n+        if (maxMultiplex < 1)\n+            throw new IllegalArgumentException(\"Max multiplex must be >= 1\");\n+        this.maxMultiplex = maxMultiplex;\n+    }\n+\n+    public int getMaxUsageCount()\n+    {\n+        return maxUsageCount;\n+    }\n+\n+    public final void setMaxUsageCount(int maxUsageCount)\n+    {\n+        if (maxUsageCount == 0)\n+            throw new IllegalArgumentException(\"Max usage count must be != 0\");\n+        this.maxUsageCount = maxUsageCount;\n+    }\n+\n+    public Entry newEntry(T pooled)\n+    {\n+        return new Entry(pooled);\n+    }\n+\n+    /**\n+     * Add a new object to the pool for others to acquire.\n+     *\n+     * @param entry an object to add to the pool\n+     */\n+    public void add(Entry entry)\n+    {\n+        closeLock.lock();\n+        try\n+        {\n+            if (closed)\n+                throw new IllegalStateException(\"Pool has been closed\");\n+            sharedList.add(entry);\n+        }\n+        finally\n+        {\n+            closeLock.unlock();\n+        }\n+    }\n+\n+    /**\n+     * Acquire the entry from the pool at the specified index.\n+     *\n+     * @param idx the index of the entry to acquire.\n+     * @return the specified entry or null if there is none at the specified index or if it is not available.\n+     */\n+    public Entry acquireAt(int idx)\n+    {\n+        try\n+        {\n+            Entry entry = sharedList.get(idx);\n+            if (entry.tryAcquire())\n+                return entry;\n+        }\n+        catch (IndexOutOfBoundsException e)\n+        {\n+            // no entry at that index\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Acquire an entry from the pool.\n+     *\n+     * @return an entry from the pool or null if none is available.\n+     */\n+    public Entry acquire()\n+    {\n+        // first check the thread-local cache\n+        if (cache != null)\n+        {\n+            List<Entry> cachedList = cache.get();\n+            while (!cachedList.isEmpty())\n+            {\n+                Entry cachedEntry = cachedList.remove(cachedList.size() - 1);\n+                if (cachedEntry.tryAcquire())\n+                    return cachedEntry;\n+            }\n+        }\n+\n+        // then iterate the shared list\n+        for (Entry entry : sharedList)\n+        {\n+            if (entry.tryAcquire())\n+                return entry;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * This method will return an acquired object to the pool.  Objects\n+     * that are acquired from the pool but never released will result\n+     * in a memory leak.\n+     *\n+     * @param entry the value to return to the pool\n+     * @return false if the pooled entry should be disposed of\n+     * @throws NullPointerException if value is null\n+     */\n+    public boolean release(Entry entry)\n+    {\n+        // first mark it as unused\n+        boolean reusable = entry.tryRelease();\n+\n+        // then cache the released entry\n+        if (cache != null && reusable)\n+        {\n+            List<Entry> cachedList = cache.get();\n+            if (cachedList.size() < cacheSize)\n+                cachedList.add(entry);\n+        }\n+        return reusable;\n+    }\n+\n+    public boolean isClosed()\n+    {\n+        return closed;\n+    }\n+\n+    @Override\n+    public void close()\n+    {\n+        closeLock.lock();\n+        try\n+        {\n+            closed = true;\n+\n+            // clear the shared list and close its entries\n+            for (Entry entry : sharedList)\n+            {\n+                if (remove(entry) && entry instanceof Closeable)\n+                {\n+                    try\n+                    {\n+                        ((Closeable)entry).close();\n+                    }\n+                    catch (IOException e)\n+                    {\n+                        LOGGER.warn(\"Error closing entry {}\", entry, e);\n+                    }\n+                }\n+            }\n+\n+            // clear the thread-local caches\n+            allCaches.forEach(List::clear);\n+            allCaches.clear();\n+        }\n+        finally\n+        {\n+            closeLock.unlock();\n+        }\n+    }\n+\n+    /**\n+     * Remove a value from the pool.\n+     *\n+     * @param entry the value to remove\n+     * @return true if the entry was removed, false otherwise\n+     */\n+    public boolean remove(Entry entry)\n+    {\n+        if (!entry.tryRemove() && !closed)\n+        {\n+            if (LOGGER.isDebugEnabled())\n+                LOGGER.debug(\"Attempt to remove an object from the pool that is still in use: {}\", entry);\n+            return false;\n+        }\n+\n+        boolean removed = sharedList.remove(entry);\n+        if (!removed && !closed)\n+        {\n+            if (LOGGER.isDebugEnabled())\n+                LOGGER.debug(\"Attempt to remove an object from the pool that does not exist: {}\", entry);\n+        }\n+\n+        return removed;\n+    }\n+\n+    public int size()\n+    {\n+        return sharedList.size();\n+    }\n+\n+    public Collection<Entry> values()\n+    {\n+        return Collections.unmodifiableCollection(sharedList);\n+    }\n+\n+    @Override\n+    public String toString()\n+    {\n+        return getClass().getSimpleName() + \" size=\" + sharedList.size() + \" entries=\" + sharedList;\n+    }\n+\n+    public class Entry\n+    {\n+        private final AtomicBiInteger state = new AtomicBiInteger(); // hi: 0=open,1=closed lo: multiplexing counter\n+        private final AtomicInteger usageCount = new AtomicInteger();\n+        private final T pooled;\n+\n+        public Entry(T pooled)\n+        {\n+            this.pooled = pooled;\n+        }\n+\n+        public T getPooled()\n+        {\n+            return pooled;\n+        }\n+\n+        public boolean tryAcquire()\n+        {\n+            if (maxUsageCount >= 0)", "originalCommit": "9cc8efd2f01631c664397d5e4eacdc1d70b03188", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTUzMzA1Mw==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r451533053", "bodyText": "I don't believe it would matter, but one less volatile read is always a good thing so I'll do it anyways.", "author": "lorban", "createdAt": "2020-07-08T13:12:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk1MzM3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk1NDYwMA==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r450954600", "bodyText": "Perhaps just use an AtomicLong?", "author": "sbordet", "createdAt": "2020-07-07T15:30:54Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -0,0 +1,395 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.util;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.eclipse.jetty.util.log.Log;\n+import org.eclipse.jetty.util.log.Logger;\n+\n+/**\n+ * A fast container of poolable objects, with optional support for\n+ * multiplexing and thread-local caching.\n+ * @param <T>\n+ */\n+public class Pool<T> implements AutoCloseable\n+{\n+    private static final Logger LOGGER = Log.getLogger(Pool.class);\n+\n+    private final List<Entry> sharedList = new CopyOnWriteArrayList<>();\n+    private final Collection<List<Entry>> allCaches = new CopyOnWriteArrayList<>();\n+    private final ThreadLocal<List<Entry>> cache;\n+    private final Lock closeLock = new ReentrantLock();\n+    private final int cacheSize;\n+    private volatile boolean closed;\n+    private volatile int maxMultiplex = 1;\n+    private volatile int maxUsageCount = -1;\n+\n+    /**\n+     * Construct a Pool with the specified thread-local cache size.\n+     *\n+     * @param cacheSize the thread-local cache size. A value of 0 means the cache is disabled.\n+     */\n+    public Pool(int cacheSize)\n+    {\n+        if (cacheSize < 0)\n+            throw new IllegalArgumentException(\"Cache size must be >= 1\");\n+        this.cacheSize = cacheSize;\n+        if (cacheSize > 0)\n+        {\n+            this.cache = ThreadLocal.withInitial(() ->\n+            {\n+                List<Entry> list = new ArrayList<>(cacheSize);\n+                allCaches.add(list);\n+                return list;\n+            });\n+        }\n+        else\n+        {\n+            this.cache = null;\n+        }\n+    }\n+\n+    public int getMaxMultiplex()\n+    {\n+        return maxMultiplex;\n+    }\n+\n+    public final void setMaxMultiplex(int maxMultiplex)\n+    {\n+        if (maxMultiplex < 1)\n+            throw new IllegalArgumentException(\"Max multiplex must be >= 1\");\n+        this.maxMultiplex = maxMultiplex;\n+    }\n+\n+    public int getMaxUsageCount()\n+    {\n+        return maxUsageCount;\n+    }\n+\n+    public final void setMaxUsageCount(int maxUsageCount)\n+    {\n+        if (maxUsageCount == 0)\n+            throw new IllegalArgumentException(\"Max usage count must be != 0\");\n+        this.maxUsageCount = maxUsageCount;\n+    }\n+\n+    public Entry newEntry(T pooled)\n+    {\n+        return new Entry(pooled);\n+    }\n+\n+    /**\n+     * Add a new object to the pool for others to acquire.\n+     *\n+     * @param entry an object to add to the pool\n+     */\n+    public void add(Entry entry)\n+    {\n+        closeLock.lock();\n+        try\n+        {\n+            if (closed)\n+                throw new IllegalStateException(\"Pool has been closed\");\n+            sharedList.add(entry);\n+        }\n+        finally\n+        {\n+            closeLock.unlock();\n+        }\n+    }\n+\n+    /**\n+     * Acquire the entry from the pool at the specified index.\n+     *\n+     * @param idx the index of the entry to acquire.\n+     * @return the specified entry or null if there is none at the specified index or if it is not available.\n+     */\n+    public Entry acquireAt(int idx)\n+    {\n+        try\n+        {\n+            Entry entry = sharedList.get(idx);\n+            if (entry.tryAcquire())\n+                return entry;\n+        }\n+        catch (IndexOutOfBoundsException e)\n+        {\n+            // no entry at that index\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Acquire an entry from the pool.\n+     *\n+     * @return an entry from the pool or null if none is available.\n+     */\n+    public Entry acquire()\n+    {\n+        // first check the thread-local cache\n+        if (cache != null)\n+        {\n+            List<Entry> cachedList = cache.get();\n+            while (!cachedList.isEmpty())\n+            {\n+                Entry cachedEntry = cachedList.remove(cachedList.size() - 1);\n+                if (cachedEntry.tryAcquire())\n+                    return cachedEntry;\n+            }\n+        }\n+\n+        // then iterate the shared list\n+        for (Entry entry : sharedList)\n+        {\n+            if (entry.tryAcquire())\n+                return entry;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * This method will return an acquired object to the pool.  Objects\n+     * that are acquired from the pool but never released will result\n+     * in a memory leak.\n+     *\n+     * @param entry the value to return to the pool\n+     * @return false if the pooled entry should be disposed of\n+     * @throws NullPointerException if value is null\n+     */\n+    public boolean release(Entry entry)\n+    {\n+        // first mark it as unused\n+        boolean reusable = entry.tryRelease();\n+\n+        // then cache the released entry\n+        if (cache != null && reusable)\n+        {\n+            List<Entry> cachedList = cache.get();\n+            if (cachedList.size() < cacheSize)\n+                cachedList.add(entry);\n+        }\n+        return reusable;\n+    }\n+\n+    public boolean isClosed()\n+    {\n+        return closed;\n+    }\n+\n+    @Override\n+    public void close()\n+    {\n+        closeLock.lock();\n+        try\n+        {\n+            closed = true;\n+\n+            // clear the shared list and close its entries\n+            for (Entry entry : sharedList)\n+            {\n+                if (remove(entry) && entry instanceof Closeable)\n+                {\n+                    try\n+                    {\n+                        ((Closeable)entry).close();\n+                    }\n+                    catch (IOException e)\n+                    {\n+                        LOGGER.warn(\"Error closing entry {}\", entry, e);\n+                    }\n+                }\n+            }\n+\n+            // clear the thread-local caches\n+            allCaches.forEach(List::clear);\n+            allCaches.clear();\n+        }\n+        finally\n+        {\n+            closeLock.unlock();\n+        }\n+    }\n+\n+    /**\n+     * Remove a value from the pool.\n+     *\n+     * @param entry the value to remove\n+     * @return true if the entry was removed, false otherwise\n+     */\n+    public boolean remove(Entry entry)\n+    {\n+        if (!entry.tryRemove() && !closed)\n+        {\n+            if (LOGGER.isDebugEnabled())\n+                LOGGER.debug(\"Attempt to remove an object from the pool that is still in use: {}\", entry);\n+            return false;\n+        }\n+\n+        boolean removed = sharedList.remove(entry);\n+        if (!removed && !closed)\n+        {\n+            if (LOGGER.isDebugEnabled())\n+                LOGGER.debug(\"Attempt to remove an object from the pool that does not exist: {}\", entry);\n+        }\n+\n+        return removed;\n+    }\n+\n+    public int size()\n+    {\n+        return sharedList.size();\n+    }\n+\n+    public Collection<Entry> values()\n+    {\n+        return Collections.unmodifiableCollection(sharedList);\n+    }\n+\n+    @Override\n+    public String toString()\n+    {\n+        return getClass().getSimpleName() + \" size=\" + sharedList.size() + \" entries=\" + sharedList;\n+    }\n+\n+    public class Entry\n+    {\n+        private final AtomicBiInteger state = new AtomicBiInteger(); // hi: 0=open,1=closed lo: multiplexing counter\n+        private final AtomicInteger usageCount = new AtomicInteger();\n+        private final T pooled;\n+\n+        public Entry(T pooled)\n+        {\n+            this.pooled = pooled;\n+        }\n+\n+        public T getPooled()\n+        {\n+            return pooled;\n+        }\n+\n+        public boolean tryAcquire()\n+        {\n+            if (maxUsageCount >= 0)\n+            {\n+                int currentUsageCount = usageCount.getAndIncrement();\n+                if (currentUsageCount < 0)\n+                    currentUsageCount = Integer.MAX_VALUE;", "originalCommit": "9cc8efd2f01631c664397d5e4eacdc1d70b03188", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM4MTc3Nw==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r451381777", "bodyText": "That would the problem to an unlikely-reachable future rather than handling it. I'm not fond of that idea.", "author": "lorban", "createdAt": "2020-07-08T08:43:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk1NDYwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk2MTg3OA==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r450961878", "bodyText": "I don't think usage count algorithm is correct.\n1000 threads calling pool.acquire() will all hit the first Entry and increment the usageCount of this entry far beyond its multiplex value. The first thread that releases will see that the entry is over used although it's not.", "author": "sbordet", "createdAt": "2020-07-07T15:41:45Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -0,0 +1,395 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.util;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.eclipse.jetty.util.log.Log;\n+import org.eclipse.jetty.util.log.Logger;\n+\n+/**\n+ * A fast container of poolable objects, with optional support for\n+ * multiplexing and thread-local caching.\n+ * @param <T>\n+ */\n+public class Pool<T> implements AutoCloseable\n+{\n+    private static final Logger LOGGER = Log.getLogger(Pool.class);\n+\n+    private final List<Entry> sharedList = new CopyOnWriteArrayList<>();\n+    private final Collection<List<Entry>> allCaches = new CopyOnWriteArrayList<>();\n+    private final ThreadLocal<List<Entry>> cache;\n+    private final Lock closeLock = new ReentrantLock();\n+    private final int cacheSize;\n+    private volatile boolean closed;\n+    private volatile int maxMultiplex = 1;\n+    private volatile int maxUsageCount = -1;\n+\n+    /**\n+     * Construct a Pool with the specified thread-local cache size.\n+     *\n+     * @param cacheSize the thread-local cache size. A value of 0 means the cache is disabled.\n+     */\n+    public Pool(int cacheSize)\n+    {\n+        if (cacheSize < 0)\n+            throw new IllegalArgumentException(\"Cache size must be >= 1\");\n+        this.cacheSize = cacheSize;\n+        if (cacheSize > 0)\n+        {\n+            this.cache = ThreadLocal.withInitial(() ->\n+            {\n+                List<Entry> list = new ArrayList<>(cacheSize);\n+                allCaches.add(list);\n+                return list;\n+            });\n+        }\n+        else\n+        {\n+            this.cache = null;\n+        }\n+    }\n+\n+    public int getMaxMultiplex()\n+    {\n+        return maxMultiplex;\n+    }\n+\n+    public final void setMaxMultiplex(int maxMultiplex)\n+    {\n+        if (maxMultiplex < 1)\n+            throw new IllegalArgumentException(\"Max multiplex must be >= 1\");\n+        this.maxMultiplex = maxMultiplex;\n+    }\n+\n+    public int getMaxUsageCount()\n+    {\n+        return maxUsageCount;\n+    }\n+\n+    public final void setMaxUsageCount(int maxUsageCount)\n+    {\n+        if (maxUsageCount == 0)\n+            throw new IllegalArgumentException(\"Max usage count must be != 0\");\n+        this.maxUsageCount = maxUsageCount;\n+    }\n+\n+    public Entry newEntry(T pooled)\n+    {\n+        return new Entry(pooled);\n+    }\n+\n+    /**\n+     * Add a new object to the pool for others to acquire.\n+     *\n+     * @param entry an object to add to the pool\n+     */\n+    public void add(Entry entry)\n+    {\n+        closeLock.lock();\n+        try\n+        {\n+            if (closed)\n+                throw new IllegalStateException(\"Pool has been closed\");\n+            sharedList.add(entry);\n+        }\n+        finally\n+        {\n+            closeLock.unlock();\n+        }\n+    }\n+\n+    /**\n+     * Acquire the entry from the pool at the specified index.\n+     *\n+     * @param idx the index of the entry to acquire.\n+     * @return the specified entry or null if there is none at the specified index or if it is not available.\n+     */\n+    public Entry acquireAt(int idx)\n+    {\n+        try\n+        {\n+            Entry entry = sharedList.get(idx);\n+            if (entry.tryAcquire())\n+                return entry;\n+        }\n+        catch (IndexOutOfBoundsException e)\n+        {\n+            // no entry at that index\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Acquire an entry from the pool.\n+     *\n+     * @return an entry from the pool or null if none is available.\n+     */\n+    public Entry acquire()\n+    {\n+        // first check the thread-local cache\n+        if (cache != null)\n+        {\n+            List<Entry> cachedList = cache.get();\n+            while (!cachedList.isEmpty())\n+            {\n+                Entry cachedEntry = cachedList.remove(cachedList.size() - 1);\n+                if (cachedEntry.tryAcquire())\n+                    return cachedEntry;\n+            }\n+        }\n+\n+        // then iterate the shared list\n+        for (Entry entry : sharedList)\n+        {\n+            if (entry.tryAcquire())\n+                return entry;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * This method will return an acquired object to the pool.  Objects\n+     * that are acquired from the pool but never released will result\n+     * in a memory leak.\n+     *\n+     * @param entry the value to return to the pool\n+     * @return false if the pooled entry should be disposed of\n+     * @throws NullPointerException if value is null\n+     */\n+    public boolean release(Entry entry)\n+    {\n+        // first mark it as unused\n+        boolean reusable = entry.tryRelease();\n+\n+        // then cache the released entry\n+        if (cache != null && reusable)\n+        {\n+            List<Entry> cachedList = cache.get();\n+            if (cachedList.size() < cacheSize)\n+                cachedList.add(entry);\n+        }\n+        return reusable;\n+    }\n+\n+    public boolean isClosed()\n+    {\n+        return closed;\n+    }\n+\n+    @Override\n+    public void close()\n+    {\n+        closeLock.lock();\n+        try\n+        {\n+            closed = true;\n+\n+            // clear the shared list and close its entries\n+            for (Entry entry : sharedList)\n+            {\n+                if (remove(entry) && entry instanceof Closeable)\n+                {\n+                    try\n+                    {\n+                        ((Closeable)entry).close();\n+                    }\n+                    catch (IOException e)\n+                    {\n+                        LOGGER.warn(\"Error closing entry {}\", entry, e);\n+                    }\n+                }\n+            }\n+\n+            // clear the thread-local caches\n+            allCaches.forEach(List::clear);\n+            allCaches.clear();\n+        }\n+        finally\n+        {\n+            closeLock.unlock();\n+        }\n+    }\n+\n+    /**\n+     * Remove a value from the pool.\n+     *\n+     * @param entry the value to remove\n+     * @return true if the entry was removed, false otherwise\n+     */\n+    public boolean remove(Entry entry)\n+    {\n+        if (!entry.tryRemove() && !closed)\n+        {\n+            if (LOGGER.isDebugEnabled())\n+                LOGGER.debug(\"Attempt to remove an object from the pool that is still in use: {}\", entry);\n+            return false;\n+        }\n+\n+        boolean removed = sharedList.remove(entry);\n+        if (!removed && !closed)\n+        {\n+            if (LOGGER.isDebugEnabled())\n+                LOGGER.debug(\"Attempt to remove an object from the pool that does not exist: {}\", entry);\n+        }\n+\n+        return removed;\n+    }\n+\n+    public int size()\n+    {\n+        return sharedList.size();\n+    }\n+\n+    public Collection<Entry> values()\n+    {\n+        return Collections.unmodifiableCollection(sharedList);\n+    }\n+\n+    @Override\n+    public String toString()\n+    {\n+        return getClass().getSimpleName() + \" size=\" + sharedList.size() + \" entries=\" + sharedList;\n+    }\n+\n+    public class Entry\n+    {\n+        private final AtomicBiInteger state = new AtomicBiInteger(); // hi: 0=open,1=closed lo: multiplexing counter\n+        private final AtomicInteger usageCount = new AtomicInteger();\n+        private final T pooled;\n+\n+        public Entry(T pooled)\n+        {\n+            this.pooled = pooled;\n+        }\n+\n+        public T getPooled()\n+        {\n+            return pooled;\n+        }\n+\n+        public boolean tryAcquire()\n+        {\n+            if (maxUsageCount >= 0)\n+            {\n+                int currentUsageCount = usageCount.getAndIncrement();\n+                if (currentUsageCount < 0)\n+                    currentUsageCount = Integer.MAX_VALUE;\n+                if (currentUsageCount >= maxUsageCount)\n+                    return false;\n+            }", "originalCommit": "9cc8efd2f01631c664397d5e4eacdc1d70b03188", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTUzMDMwMw==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r451530303", "bodyText": "As discussed, I don't think that the algorithm is broken but it's tedious to reason about. So I've refactored it to store the three states in the AtomicBiInteger which should make it more maintainable.", "author": "lorban", "createdAt": "2020-07-08T13:08:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk2MTg3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk2MjQ3NQ==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r450962475", "bodyText": "Remove this class.", "author": "sbordet", "createdAt": "2020-07-07T15:42:42Z", "path": "tests/test-http-client-transport/src/test/java/org/eclipse/jetty/client/ConnectionPoolHelper.java", "diffHunk": "@@ -0,0 +1,32 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.client;\n+\n+import org.eclipse.jetty.client.api.Connection;\n+import org.eclipse.jetty.client.api.Destination;\n+\n+public class ConnectionPoolHelper", "originalCommit": "9cc8efd2f01631c664397d5e4eacdc1d70b03188", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk4Njg4MQ==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r450986881", "bodyText": "A thread past this statement has decremented the pending but not increased yet the pool size, so it's in a race with another thread entering tryCreate().", "author": "sbordet", "createdAt": "2020-07-07T16:19:23Z", "path": "jetty-client/src/main/java/org/eclipse/jetty/client/AbstractConnectionPool.java", "diffHunk": "@@ -180,61 +209,135 @@ public void succeeded(Connection connection)\n                     {\n                         if (LOG.isDebugEnabled())\n                             LOG.debug(\"Connection {}/{} creation succeeded {}\", total + 1, maxConnections, connection);\n-                        connections.add(-1, 0);\n-                        onCreated(connection);\n-                        proceed();\n+                        pendingConnectionCount.decrementAndGet();", "originalCommit": "9cc8efd2f01631c664397d5e4eacdc1d70b03188", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM3ODk4NA==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r451378984", "bodyText": "You're right, decrementing pendingConnectionCount before making the pool adopt the connection risks overshooting maxConnections. The only alternative is to first make the pool adopt the connection before decrementing pendingConnectionCount. There's a risk of not reaching maxConnections immediately if such race would occur, but later calls to tryCreate would eventually solve that so I think that's no big issue.", "author": "lorban", "createdAt": "2020-07-08T08:39:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk4Njg4MQ=="}], "type": "inlineReview"}, {"oid": "314b2f293ae16b76ca8883be60b844858460caac", "url": "https://github.com/eclipse/jetty.project/commit/314b2f293ae16b76ca8883be60b844858460caac", "message": "restore previous behavior of non-pooled connections\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-07-09T08:43:00Z", "type": "forcePushed"}, {"oid": "9d5918e7cfc3f319344abd25ed64dfa7971d87f1", "url": "https://github.com/eclipse/jetty.project/commit/9d5918e7cfc3f319344abd25ed64dfa7971d87f1", "message": "restore ValidatingConnectionPool\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-07-10T08:10:39Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg4MzQ4NQ==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r454883485", "bodyText": "If the pool is being added to the destination as a been, then perhaps we should first look for an existing pool on the destination before creation a new one?", "author": "gregw", "createdAt": "2020-07-15T08:31:41Z", "path": "jetty-client/src/main/java/org/eclipse/jetty/client/AbstractConnectionPool.java", "diffHunk": "@@ -18,57 +18,121 @@\n \n package org.eclipse.jetty.client;\n \n+import java.io.IOException;\n+import java.util.ArrayList;\n import java.util.Collection;\n-import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n \n import org.eclipse.jetty.client.api.Connection;\n import org.eclipse.jetty.client.api.Destination;\n-import org.eclipse.jetty.util.AtomicBiInteger;\n+import org.eclipse.jetty.util.Attachable;\n import org.eclipse.jetty.util.Callback;\n+import org.eclipse.jetty.util.Pool;\n import org.eclipse.jetty.util.Promise;\n import org.eclipse.jetty.util.annotation.ManagedAttribute;\n import org.eclipse.jetty.util.annotation.ManagedObject;\n import org.eclipse.jetty.util.component.Dumpable;\n import org.eclipse.jetty.util.log.Log;\n import org.eclipse.jetty.util.log.Logger;\n+import org.eclipse.jetty.util.thread.Sweeper;\n+\n+import static java.util.stream.Collectors.toList;\n \n @ManagedObject\n-public abstract class AbstractConnectionPool implements ConnectionPool, Dumpable\n+public abstract class AbstractConnectionPool implements ConnectionPool, Dumpable, Sweeper.Sweepable\n {\n     private static final Logger LOG = Log.getLogger(AbstractConnectionPool.class);\n \n-    /**\n-     * The connectionCount encodes both the total connections plus the pending connection counts, so both can be atomically changed.\n-     * The bottom 32 bits represent the total connections and the top 32 bits represent the pending connections.\n-     */\n-    private final AtomicBiInteger connections = new AtomicBiInteger();\n-    private final AtomicBoolean closed = new AtomicBoolean();\n     private final HttpDestination destination;\n     private final int maxConnections;\n     private final Callback requester;\n+    private final AtomicInteger pendingConnectionCount = new AtomicInteger();\n+    private final Pool<Connection> pool;\n \n     /**\n-     * @param destination the correspondent destination\n-     * @param maxConnections the max number of connections\n-     * @param requester the callback to notify about new connection creation/failure\n-     * @deprecated use {@link #AbstractConnectionPool(HttpDestination, int, Callback)} instead\n+     * @deprecated use {@link #AbstractConnectionPool(HttpDestination, int, boolean, Callback)} instead\n      */\n     @Deprecated\n     protected AbstractConnectionPool(Destination destination, int maxConnections, Callback requester)\n     {\n-        this((HttpDestination)destination, maxConnections, requester);\n+        this((HttpDestination)destination, maxConnections, true, requester);\n     }\n \n-    protected AbstractConnectionPool(HttpDestination destination, int maxConnections, Callback requester)\n+    protected AbstractConnectionPool(HttpDestination destination, int maxConnections, boolean cache, Callback requester)\n     {\n         this.destination = destination;\n         this.maxConnections = maxConnections;\n         this.requester = requester;\n+        this.pool = new Pool<>(cache ? 1 : 0);\n+        destination.addBean(this.pool);", "originalCommit": "9d5918e7cfc3f319344abd25ed64dfa7971d87f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkyMzkzOQ==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r454923939", "bodyText": "Sure, done.", "author": "lorban", "createdAt": "2020-07-15T09:39:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg4MzQ4NQ=="}], "type": "inlineReview"}, {"oid": "5ea68a906eab038218390a78780eb016fea3dced", "url": "https://github.com/eclipse/jetty.project/commit/5ea68a906eab038218390a78780eb016fea3dced", "message": "change the pool to a reservation model\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-07-16T09:23:50Z", "type": "forcePushed"}, {"oid": "93674651ce57a2dff57c89abb937b6fe4bb9467b", "url": "https://github.com/eclipse/jetty.project/commit/93674651ce57a2dff57c89abb937b6fe4bb9467b", "message": "change the pool to a reservation model\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-07-16T10:38:11Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTc5OTkwNg==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r455799906", "bodyText": "I think we need to check max size within this lock, otherwise we will be in a test and set race.", "author": "gregw", "createdAt": "2020-07-16T13:49:21Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -0,0 +1,429 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.util;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.eclipse.jetty.util.component.Dumpable;\n+import org.eclipse.jetty.util.log.Log;\n+import org.eclipse.jetty.util.log.Logger;\n+\n+/**\n+ * A fast container of poolable objects, with optional support for\n+ * multiplexing and thread-local caching.\n+ * @param <T>\n+ */\n+public class Pool<T> implements AutoCloseable, Dumpable\n+{\n+    private static final Logger LOGGER = Log.getLogger(Pool.class);\n+\n+    private final List<Entry> sharedList = new CopyOnWriteArrayList<>();\n+    private final ThreadLocal<List<Entry>> cache;\n+    private final Lock closeLock = new ReentrantLock();\n+    private final int cacheSize;\n+    private volatile boolean closed;\n+    private volatile int maxMultiplex = 1;\n+    private volatile int maxUsageCount = -1;\n+\n+    /**\n+     * Construct a Pool with the specified thread-local cache size.\n+     *\n+     * @param cacheSize the thread-local cache size. A value less than 1 means the cache is disabled.\n+     */\n+    public Pool(int cacheSize)\n+    {\n+        this.cacheSize = cacheSize;\n+        if (cacheSize > 0)\n+            this.cache = ThreadLocal.withInitial(() -> (List<Entry>)new ArrayList<Entry>(cacheSize));\n+        else\n+            this.cache = null;\n+    }\n+\n+    public int getMaxMultiplex()\n+    {\n+        return maxMultiplex;\n+    }\n+\n+    public final void setMaxMultiplex(int maxMultiplex)\n+    {\n+        if (maxMultiplex < 1)\n+            throw new IllegalArgumentException(\"Max multiplex must be >= 1\");\n+        this.maxMultiplex = maxMultiplex;\n+    }\n+\n+    public int getMaxUsageCount()\n+    {\n+        return maxUsageCount;\n+    }\n+\n+    public final void setMaxUsageCount(int maxUsageCount)\n+    {\n+        if (maxUsageCount == 0)\n+            throw new IllegalArgumentException(\"Max usage count must be != 0\");\n+        this.maxUsageCount = maxUsageCount;\n+    }\n+\n+    /**\n+     * Create a new disabled slot into the pool. The returned entry\n+     * won't be acquirable as long as {@link Entry#enable(Object)}\n+     * has not been called.\n+     *\n+     * @return a disabled entry that is contained in the pool,\n+     * or null if the pool is closed.\n+     */\n+    public Entry addReservation()\n+    {\n+        closeLock.lock();\n+        try\n+        {\n+            if (!closed)", "originalCommit": "93674651ce57a2dff57c89abb937b6fe4bb9467b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg4NjE3MQ==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r455886171", "bodyText": "This makes sense when combined with the comment below.", "author": "lorban", "createdAt": "2020-07-16T15:45:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTc5OTkwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTgwMTc1Nw==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r455801757", "bodyText": "I would make the pool enforce max size, either preconfigured or passed in to addReservation(maxConnections).  If it returns null here then you are over capacity so you can return the completed future.", "author": "gregw", "createdAt": "2020-07-16T13:51:46Z", "path": "jetty-client/src/main/java/org/eclipse/jetty/client/AbstractConnectionPool.java", "diffHunk": "@@ -150,90 +218,167 @@ protected Connection acquire(boolean create)\n      * @param maxPending the max desired number of connections scheduled for opening,\n      * or a negative number to always trigger the opening of a new connection\n      */\n-    protected void tryCreate(int maxPending)\n+    Future<Void> tryCreate(int maxPending)\n     {\n-        while (true)\n+        CompletableFuture<Void> future = new CompletableFuture<>();\n+        int pending = getPendingConnectionCount();\n+        int total = pool.size();\n+\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"tryCreate {}/{} connections {}/{} pending\", total, maxConnections, pending, maxPending);\n+\n+        if (total >= maxConnections)\n         {\n-            long encoded = connections.get();\n-            int pending = AtomicBiInteger.getHi(encoded);\n-            int total = AtomicBiInteger.getLo(encoded);\n+            future.complete(null);\n+            return future;\n+        }\n \n-            if (LOG.isDebugEnabled())\n-                LOG.debug(\"tryCreate {}/{} connections {}/{} pending\", total, maxConnections, pending, maxPending);\n+        if (maxPending >= 0 && pending >= maxPending)\n+        {\n+            future.complete(null);\n+            return future;\n+        }\n \n-            if (total >= maxConnections)\n-                return;\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"newConnection {}/{} connections {}/{} pending\", total + 1, maxConnections, pending + 1, maxPending);\n \n-            if (maxPending >= 0 && pending >= maxPending)\n-                return;\n+        Pool<Connection>.Entry entry = pool.addReservation();", "originalCommit": "93674651ce57a2dff57c89abb937b6fe4bb9467b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg4NjYxOQ==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r455886619", "bodyText": "This both sounds very reasonable and natural for the pool to take care of its max size. Let me do it.", "author": "lorban", "createdAt": "2020-07-16T15:45:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTgwMTc1Nw=="}], "type": "inlineReview"}, {"oid": "70b69a559a48819638e7a86c65f1554664ebfc13", "url": "https://github.com/eclipse/jetty.project/commit/70b69a559a48819638e7a86c65f1554664ebfc13", "message": "internalize max size to the pool\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-07-16T16:07:29Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc4NjEwMg==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r458786102", "bodyText": "I think that it is strange to try to enforce the pending externally to the pool (which calls pending reservations).\nWhy not do pool.addReservation(maxPending) ?", "author": "gregw", "createdAt": "2020-07-22T13:21:11Z", "path": "jetty-client/src/main/java/org/eclipse/jetty/client/AbstractConnectionPool.java", "diffHunk": "@@ -150,90 +216,167 @@ protected Connection acquire(boolean create)\n      * @param maxPending the max desired number of connections scheduled for opening,\n      * or a negative number to always trigger the opening of a new connection\n      */\n-    protected void tryCreate(int maxPending)\n+    Future<Void> tryCreate(int maxPending)\n     {\n-        while (true)\n-        {\n-            long encoded = connections.get();\n-            int pending = AtomicBiInteger.getHi(encoded);\n-            int total = AtomicBiInteger.getLo(encoded);\n+        CompletableFuture<Void> future = new CompletableFuture<>();\n+        int pending = getPendingConnectionCount();\n+        int total = pool.size();\n+        int maxConnections = pool.getMaxEntries();\n \n-            if (LOG.isDebugEnabled())\n-                LOG.debug(\"tryCreate {}/{} connections {}/{} pending\", total, maxConnections, pending, maxPending);\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"tryCreate {}/{} connections {}/{} pending\", total, maxConnections, pending, maxPending);\n \n-            if (total >= maxConnections)\n-                return;\n+        if (maxPending >= 0 && pending >= maxPending)\n+        {\n+            future.complete(null);\n+            return future;\n+        }\n \n-            if (maxPending >= 0 && pending >= maxPending)\n-                return;\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"newConnection {}/{} connections {}/{} pending\", total + 1, maxConnections, pending + 1, maxPending);\n \n-            if (connections.compareAndSet(encoded, pending + 1, total + 1))\n+        Pool<Connection>.Entry entry = pool.addReservation();", "originalCommit": "70b69a559a48819638e7a86c65f1554664ebfc13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc2MDQwMw==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r460760403", "bodyText": "Yes, this makes sense. Done.", "author": "lorban", "createdAt": "2020-07-27T09:23:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc4NjEwMg=="}], "type": "inlineReview"}, {"oid": "8f7478ff4bdeb130d9b5e1e35beff558e6e1d6df", "url": "https://github.com/eclipse/jetty.project/commit/8f7478ff4bdeb130d9b5e1e35beff558e6e1d6df", "message": "enforce pending within the pool\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-07-27T09:22:52Z", "type": "forcePushed"}, {"oid": "6fe83515f536d9d0e94d7fdeea6516b9012f6aa0", "url": "https://github.com/eclipse/jetty.project/commit/6fe83515f536d9d0e94d7fdeea6516b9012f6aa0", "message": "enforce pending within the pool\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-07-27T09:31:04Z", "type": "forcePushed"}, {"oid": "9d99ff0b5f8592dd43a85bb0ce3abd0d2df8619c", "url": "https://github.com/eclipse/jetty.project/commit/9d99ff0b5f8592dd43a85bb0ce3abd0d2df8619c", "message": "enforce pending within the pool\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-07-27T09:32:37Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc2OTA5Nw==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r460769097", "bodyText": "Name either as\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public Entry addReservation(int maxPending)\n          \n          \n            \n                public Entry addReservation(int maxReservations)\n          \n      \n    \n    \n  \n\nor\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public Entry addReservation(int maxPending)\n          \n          \n            \n                public Entry addPending(int maxPending)", "author": "gregw", "createdAt": "2020-07-27T09:38:58Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -0,0 +1,441 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.util;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.eclipse.jetty.util.component.Dumpable;\n+import org.eclipse.jetty.util.log.Log;\n+import org.eclipse.jetty.util.log.Logger;\n+\n+/**\n+ * A fast container of poolable objects, with optional support for\n+ * multiplexing and thread-local caching.\n+ * @param <T>\n+ */\n+public class Pool<T> implements AutoCloseable, Dumpable\n+{\n+    private static final Logger LOGGER = Log.getLogger(Pool.class);\n+\n+    private final List<Entry> sharedList = new CopyOnWriteArrayList<>();\n+    private final ThreadLocal<List<Entry>> cache;\n+    private final Lock closeLock = new ReentrantLock();\n+    private final int maxEntries;\n+    private final int cacheSize;\n+    private volatile boolean closed;\n+    private volatile int maxMultiplex = 1;\n+    private volatile int maxUsageCount = -1;\n+\n+    /**\n+     * Construct a Pool with the specified thread-local cache size.\n+     *\n+     * @param maxEntries the maximum amount of entries that the pool will accept.\n+     * @param cacheSize the thread-local cache size. A value less than 1 means the cache is disabled.\n+     */\n+    public Pool(int maxEntries, int cacheSize)\n+    {\n+        this.maxEntries = maxEntries;\n+        this.cacheSize = cacheSize;\n+        if (cacheSize > 0)\n+            this.cache = ThreadLocal.withInitial(() -> (List<Entry>)new ArrayList<Entry>(cacheSize));\n+        else\n+            this.cache = null;\n+    }\n+\n+    public int getMaxEntries()\n+    {\n+        return maxEntries;\n+    }\n+\n+    public int getMaxMultiplex()\n+    {\n+        return maxMultiplex;\n+    }\n+\n+    public final void setMaxMultiplex(int maxMultiplex)\n+    {\n+        if (maxMultiplex < 1)\n+            throw new IllegalArgumentException(\"Max multiplex must be >= 1\");\n+        this.maxMultiplex = maxMultiplex;\n+    }\n+\n+    public int getMaxUsageCount()\n+    {\n+        return maxUsageCount;\n+    }\n+\n+    public final void setMaxUsageCount(int maxUsageCount)\n+    {\n+        if (maxUsageCount == 0)\n+            throw new IllegalArgumentException(\"Max usage count must be != 0\");\n+        this.maxUsageCount = maxUsageCount;\n+    }\n+\n+    /**\n+     * Create a new disabled slot into the pool. The returned entry\n+     * won't be acquirable as long as {@link Entry#enable(Object)}\n+     * has not been called.\n+     *\n+     * @param maxPending the max desired number of connections scheduled for opening,\n+     * or a negative number to always trigger the opening of a new connection\n+     * @return a disabled entry that is contained in the pool,\n+     * or null if the pool is closed.\n+     */\n+    public Entry addReservation(int maxPending)", "originalCommit": "9d99ff0b5f8592dd43a85bb0ce3abd0d2df8619c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc2OTUxMA==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r460769510", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    closeLock.lock();\n          \n          \n            \n                    reservationLock.lock();", "author": "gregw", "createdAt": "2020-07-27T09:39:42Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -0,0 +1,441 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.util;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.eclipse.jetty.util.component.Dumpable;\n+import org.eclipse.jetty.util.log.Log;\n+import org.eclipse.jetty.util.log.Logger;\n+\n+/**\n+ * A fast container of poolable objects, with optional support for\n+ * multiplexing and thread-local caching.\n+ * @param <T>\n+ */\n+public class Pool<T> implements AutoCloseable, Dumpable\n+{\n+    private static final Logger LOGGER = Log.getLogger(Pool.class);\n+\n+    private final List<Entry> sharedList = new CopyOnWriteArrayList<>();\n+    private final ThreadLocal<List<Entry>> cache;\n+    private final Lock closeLock = new ReentrantLock();\n+    private final int maxEntries;\n+    private final int cacheSize;\n+    private volatile boolean closed;\n+    private volatile int maxMultiplex = 1;\n+    private volatile int maxUsageCount = -1;\n+\n+    /**\n+     * Construct a Pool with the specified thread-local cache size.\n+     *\n+     * @param maxEntries the maximum amount of entries that the pool will accept.\n+     * @param cacheSize the thread-local cache size. A value less than 1 means the cache is disabled.\n+     */\n+    public Pool(int maxEntries, int cacheSize)\n+    {\n+        this.maxEntries = maxEntries;\n+        this.cacheSize = cacheSize;\n+        if (cacheSize > 0)\n+            this.cache = ThreadLocal.withInitial(() -> (List<Entry>)new ArrayList<Entry>(cacheSize));\n+        else\n+            this.cache = null;\n+    }\n+\n+    public int getMaxEntries()\n+    {\n+        return maxEntries;\n+    }\n+\n+    public int getMaxMultiplex()\n+    {\n+        return maxMultiplex;\n+    }\n+\n+    public final void setMaxMultiplex(int maxMultiplex)\n+    {\n+        if (maxMultiplex < 1)\n+            throw new IllegalArgumentException(\"Max multiplex must be >= 1\");\n+        this.maxMultiplex = maxMultiplex;\n+    }\n+\n+    public int getMaxUsageCount()\n+    {\n+        return maxUsageCount;\n+    }\n+\n+    public final void setMaxUsageCount(int maxUsageCount)\n+    {\n+        if (maxUsageCount == 0)\n+            throw new IllegalArgumentException(\"Max usage count must be != 0\");\n+        this.maxUsageCount = maxUsageCount;\n+    }\n+\n+    /**\n+     * Create a new disabled slot into the pool. The returned entry\n+     * won't be acquirable as long as {@link Entry#enable(Object)}\n+     * has not been called.\n+     *\n+     * @param maxPending the max desired number of connections scheduled for opening,\n+     * or a negative number to always trigger the opening of a new connection\n+     * @return a disabled entry that is contained in the pool,\n+     * or null if the pool is closed.\n+     */\n+    public Entry addReservation(int maxPending)\n+    {\n+        closeLock.lock();", "originalCommit": "9d99ff0b5f8592dd43a85bb0ce3abd0d2df8619c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDgwMDI5Nw==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r460800297", "bodyText": "ok.", "author": "lorban", "createdAt": "2020-07-27T10:37:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc2OTUxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc3MjgyNg==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r460772826", "bodyText": "When would it ever be suitable to have a cache for a connection pool?  Surely that could result in connections living in thread local caches of other threads, so that the current thread can't access them and can't create a new connection due to limits?\nDoesn't the cache only make sense for resources like buffers that are not limited by number?", "author": "gregw", "createdAt": "2020-07-27T09:45:38Z", "path": "jetty-client/src/main/java/org/eclipse/jetty/client/AbstractConnectionPool.java", "diffHunk": "@@ -18,69 +18,135 @@\n \n package org.eclipse.jetty.client;\n \n+import java.io.IOException;\n+import java.util.ArrayList;\n import java.util.Collection;\n-import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Future;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n \n import org.eclipse.jetty.client.api.Connection;\n import org.eclipse.jetty.client.api.Destination;\n-import org.eclipse.jetty.util.AtomicBiInteger;\n+import org.eclipse.jetty.util.Attachable;\n import org.eclipse.jetty.util.Callback;\n+import org.eclipse.jetty.util.Pool;\n import org.eclipse.jetty.util.Promise;\n import org.eclipse.jetty.util.annotation.ManagedAttribute;\n import org.eclipse.jetty.util.annotation.ManagedObject;\n import org.eclipse.jetty.util.component.Dumpable;\n import org.eclipse.jetty.util.log.Log;\n import org.eclipse.jetty.util.log.Logger;\n+import org.eclipse.jetty.util.thread.Sweeper;\n+\n+import static java.util.stream.Collectors.toList;\n \n @ManagedObject\n-public abstract class AbstractConnectionPool implements ConnectionPool, Dumpable\n+public abstract class AbstractConnectionPool implements ConnectionPool, Dumpable, Sweeper.Sweepable\n {\n     private static final Logger LOG = Log.getLogger(AbstractConnectionPool.class);\n \n-    /**\n-     * The connectionCount encodes both the total connections plus the pending connection counts, so both can be atomically changed.\n-     * The bottom 32 bits represent the total connections and the top 32 bits represent the pending connections.\n-     */\n-    private final AtomicBiInteger connections = new AtomicBiInteger();\n-    private final AtomicBoolean closed = new AtomicBoolean();\n     private final HttpDestination destination;\n-    private final int maxConnections;\n     private final Callback requester;\n+    private final Pool<Connection> pool;\n \n     /**\n-     * @param destination the correspondent destination\n-     * @param maxConnections the max number of connections\n-     * @param requester the callback to notify about new connection creation/failure\n-     * @deprecated use {@link #AbstractConnectionPool(HttpDestination, int, Callback)} instead\n+     * @deprecated use {@link #AbstractConnectionPool(HttpDestination, int, boolean, Callback)} instead\n      */\n     @Deprecated\n     protected AbstractConnectionPool(Destination destination, int maxConnections, Callback requester)\n     {\n-        this((HttpDestination)destination, maxConnections, requester);\n+        this((HttpDestination)destination, maxConnections, true, requester);\n     }\n \n-    protected AbstractConnectionPool(HttpDestination destination, int maxConnections, Callback requester)\n+    protected AbstractConnectionPool(HttpDestination destination, int maxConnections, boolean cache, Callback requester)\n     {\n         this.destination = destination;\n-        this.maxConnections = maxConnections;\n         this.requester = requester;\n+        @SuppressWarnings(\"unchecked\")\n+        Pool<Connection> pool = destination.getBean(Pool.class);\n+        if (pool == null)\n+        {\n+            pool = new Pool<>(maxConnections, cache ? 1 : 0);", "originalCommit": "9d99ff0b5f8592dd43a85bb0ce3abd0d2df8619c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc3NTQ4Ng==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r460775486", "bodyText": "Ah answering my own question.... the cache is only for what entries should be tried first.. another thread can still access them because they are still in the main list of entries.   The cache is just there to avoid hammering on the first index of the entry list!     So I think a bit more javadoc on Pool is needed to explain how it works.", "author": "gregw", "createdAt": "2020-07-27T09:50:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc3MjgyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDgwMTAyMw==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r460801023", "bodyText": "Ok, I'll add some javadoc to explain the caching mechanism.", "author": "lorban", "createdAt": "2020-07-27T10:38:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc3MjgyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc3ODQyMQ==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r460778421", "bodyText": "Is a cache ever likely to be more than 1?  It feels a little bit overkill to have a list here rather than just a singled cached value.", "author": "gregw", "createdAt": "2020-07-27T09:55:19Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -0,0 +1,441 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.util;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.eclipse.jetty.util.component.Dumpable;\n+import org.eclipse.jetty.util.log.Log;\n+import org.eclipse.jetty.util.log.Logger;\n+\n+/**\n+ * A fast container of poolable objects, with optional support for\n+ * multiplexing and thread-local caching.\n+ * @param <T>\n+ */\n+public class Pool<T> implements AutoCloseable, Dumpable\n+{\n+    private static final Logger LOGGER = Log.getLogger(Pool.class);\n+\n+    private final List<Entry> sharedList = new CopyOnWriteArrayList<>();\n+    private final ThreadLocal<List<Entry>> cache;", "originalCommit": "9d99ff0b5f8592dd43a85bb0ce3abd0d2df8619c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc5NjQwOQ==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r460796409", "bodyText": "A cache larger than 1 makes no sense for this http connection pool use case, but it would for other use-cases like byte buffers for instance.", "author": "lorban", "createdAt": "2020-07-27T10:29:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc3ODQyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc4MDI4OQ==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r460780289", "bodyText": "This comment is just a thought bubble about a possible optimisation.\nCould the threadlocal cache also store the iterator used here, so that if there is no cached entry (or it is taken by somebody else), then rather than always start from the beginning of the list, you can start from the last iterator used... and only if no iterator or you reach the end do you get a new iterator.    This could spread load over the array and produce a little less garbage.\nAnyway, not something for this PR, just an idea.", "author": "gregw", "createdAt": "2020-07-27T09:58:41Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -0,0 +1,441 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.util;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.eclipse.jetty.util.component.Dumpable;\n+import org.eclipse.jetty.util.log.Log;\n+import org.eclipse.jetty.util.log.Logger;\n+\n+/**\n+ * A fast container of poolable objects, with optional support for\n+ * multiplexing and thread-local caching.\n+ * @param <T>\n+ */\n+public class Pool<T> implements AutoCloseable, Dumpable\n+{\n+    private static final Logger LOGGER = Log.getLogger(Pool.class);\n+\n+    private final List<Entry> sharedList = new CopyOnWriteArrayList<>();\n+    private final ThreadLocal<List<Entry>> cache;\n+    private final Lock closeLock = new ReentrantLock();\n+    private final int maxEntries;\n+    private final int cacheSize;\n+    private volatile boolean closed;\n+    private volatile int maxMultiplex = 1;\n+    private volatile int maxUsageCount = -1;\n+\n+    /**\n+     * Construct a Pool with the specified thread-local cache size.\n+     *\n+     * @param maxEntries the maximum amount of entries that the pool will accept.\n+     * @param cacheSize the thread-local cache size. A value less than 1 means the cache is disabled.\n+     */\n+    public Pool(int maxEntries, int cacheSize)\n+    {\n+        this.maxEntries = maxEntries;\n+        this.cacheSize = cacheSize;\n+        if (cacheSize > 0)\n+            this.cache = ThreadLocal.withInitial(() -> (List<Entry>)new ArrayList<Entry>(cacheSize));\n+        else\n+            this.cache = null;\n+    }\n+\n+    public int getMaxEntries()\n+    {\n+        return maxEntries;\n+    }\n+\n+    public int getMaxMultiplex()\n+    {\n+        return maxMultiplex;\n+    }\n+\n+    public final void setMaxMultiplex(int maxMultiplex)\n+    {\n+        if (maxMultiplex < 1)\n+            throw new IllegalArgumentException(\"Max multiplex must be >= 1\");\n+        this.maxMultiplex = maxMultiplex;\n+    }\n+\n+    public int getMaxUsageCount()\n+    {\n+        return maxUsageCount;\n+    }\n+\n+    public final void setMaxUsageCount(int maxUsageCount)\n+    {\n+        if (maxUsageCount == 0)\n+            throw new IllegalArgumentException(\"Max usage count must be != 0\");\n+        this.maxUsageCount = maxUsageCount;\n+    }\n+\n+    /**\n+     * Create a new disabled slot into the pool. The returned entry\n+     * won't be acquirable as long as {@link Entry#enable(Object)}\n+     * has not been called.\n+     *\n+     * @param maxPending the max desired number of connections scheduled for opening,\n+     * or a negative number to always trigger the opening of a new connection\n+     * @return a disabled entry that is contained in the pool,\n+     * or null if the pool is closed.\n+     */\n+    public Entry addReservation(int maxPending)\n+    {\n+        closeLock.lock();\n+        try\n+        {\n+            long pending = sharedList.stream().filter(entry -> entry.getPooled() == null).count();\n+            if (maxPending >= 0 && pending >= maxPending)\n+            {\n+                return null;\n+            }\n+\n+            if (!closed && sharedList.size() < maxEntries)\n+            {\n+                Entry entry = new Entry();\n+                sharedList.add(entry);\n+                return entry;\n+            }\n+            return null;\n+        }\n+        finally\n+        {\n+            closeLock.unlock();\n+        }\n+    }\n+\n+    /**\n+     * Acquire the entry from the pool at the specified index.\n+     *\n+     * @param idx the index of the entry to acquire.\n+     * @return the specified entry or null if there is none at the specified index or if it is not available.\n+     */\n+    public Entry acquireAt(int idx)\n+    {\n+        if (closed)\n+            return null;\n+\n+        try\n+        {\n+            Entry entry = sharedList.get(idx);\n+            if (entry.tryAcquire())\n+                return entry;\n+        }\n+        catch (IndexOutOfBoundsException e)\n+        {\n+            // no entry at that index\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Acquire an entry from the pool.\n+     *\n+     * @return an entry from the pool or null if none is available.\n+     */\n+    public Entry acquire()\n+    {\n+        if (closed)\n+            return null;\n+\n+        // first check the thread-local cache\n+        if (cache != null)\n+        {\n+            List<Entry> cachedList = cache.get();\n+            while (!cachedList.isEmpty())\n+            {\n+                Entry cachedEntry = cachedList.remove(cachedList.size() - 1);\n+                if (cachedEntry.tryAcquire())\n+                    return cachedEntry;\n+            }\n+        }\n+\n+        // then iterate the shared list\n+        for (Entry entry : sharedList)", "originalCommit": "9d99ff0b5f8592dd43a85bb0ce3abd0d2df8619c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc5ODgxNQ==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r460798815", "bodyText": "Well, this behavior was chosen on purpose: always try to reuse the same connections to let the lesser used connections cool down and eventually timeout and shrink the pool. The sibling acquireAt(int) method is there in case you want to implement exactly what you describe externally, which is what the RoundRobinConnectionPool does.", "author": "lorban", "createdAt": "2020-07-27T10:33:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc4MDI4OQ=="}], "type": "inlineReview"}, {"oid": "4da75934ebc000efb0a13d60524a9e679e26573d", "url": "https://github.com/eclipse/jetty.project/commit/4da75934ebc000efb0a13d60524a9e679e26573d", "message": "improve javadoc and do some renaming\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-07-27T11:42:04Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQwMTgyMA==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r461401820", "bodyText": "This should return a CompletableFuture.", "author": "sbordet", "createdAt": "2020-07-28T08:17:03Z", "path": "jetty-client/src/main/java/org/eclipse/jetty/client/ConnectionPool.java", "diffHunk": "@@ -27,6 +27,15 @@\n  */\n public interface ConnectionPool extends Closeable\n {\n+    /**\n+     * Optionally pre-create up to <code>connectionCount</code>\n+     * connections so they are immediately ready for use.\n+     * @param connectionCount the number of connections to pre-start.\n+     */\n+    default void preCreateConnections(int connectionCount)", "originalCommit": "4da75934ebc000efb0a13d60524a9e679e26573d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE0NzAyMg==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r462147022", "bodyText": "I agree about returning Future/CompletableFuture. About the exact return type, let's focus the discussion on the implementation.", "author": "lorban", "createdAt": "2020-07-29T08:58:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQwMTgyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQwMzQ3Ng==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r461403476", "bodyText": "Let's not block here, but return a CompletableFuture from this method.", "author": "sbordet", "createdAt": "2020-07-28T08:20:03Z", "path": "jetty-client/src/main/java/org/eclipse/jetty/client/AbstractConnectionPool.java", "diffHunk": "@@ -18,69 +18,135 @@\n \n package org.eclipse.jetty.client;\n \n+import java.io.IOException;\n+import java.util.ArrayList;\n import java.util.Collection;\n-import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Future;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n \n import org.eclipse.jetty.client.api.Connection;\n import org.eclipse.jetty.client.api.Destination;\n-import org.eclipse.jetty.util.AtomicBiInteger;\n+import org.eclipse.jetty.util.Attachable;\n import org.eclipse.jetty.util.Callback;\n+import org.eclipse.jetty.util.Pool;\n import org.eclipse.jetty.util.Promise;\n import org.eclipse.jetty.util.annotation.ManagedAttribute;\n import org.eclipse.jetty.util.annotation.ManagedObject;\n import org.eclipse.jetty.util.component.Dumpable;\n import org.eclipse.jetty.util.log.Log;\n import org.eclipse.jetty.util.log.Logger;\n+import org.eclipse.jetty.util.thread.Sweeper;\n+\n+import static java.util.stream.Collectors.toList;\n \n @ManagedObject\n-public abstract class AbstractConnectionPool implements ConnectionPool, Dumpable\n+public abstract class AbstractConnectionPool implements ConnectionPool, Dumpable, Sweeper.Sweepable\n {\n     private static final Logger LOG = Log.getLogger(AbstractConnectionPool.class);\n \n-    /**\n-     * The connectionCount encodes both the total connections plus the pending connection counts, so both can be atomically changed.\n-     * The bottom 32 bits represent the total connections and the top 32 bits represent the pending connections.\n-     */\n-    private final AtomicBiInteger connections = new AtomicBiInteger();\n-    private final AtomicBoolean closed = new AtomicBoolean();\n     private final HttpDestination destination;\n-    private final int maxConnections;\n     private final Callback requester;\n+    private final Pool<Connection> pool;\n \n     /**\n-     * @param destination the correspondent destination\n-     * @param maxConnections the max number of connections\n-     * @param requester the callback to notify about new connection creation/failure\n-     * @deprecated use {@link #AbstractConnectionPool(HttpDestination, int, Callback)} instead\n+     * @deprecated use {@link #AbstractConnectionPool(HttpDestination, int, boolean, Callback)} instead\n      */\n     @Deprecated\n     protected AbstractConnectionPool(Destination destination, int maxConnections, Callback requester)\n     {\n-        this((HttpDestination)destination, maxConnections, requester);\n+        this((HttpDestination)destination, maxConnections, true, requester);\n     }\n \n-    protected AbstractConnectionPool(HttpDestination destination, int maxConnections, Callback requester)\n+    protected AbstractConnectionPool(HttpDestination destination, int maxConnections, boolean cache, Callback requester)\n     {\n         this.destination = destination;\n-        this.maxConnections = maxConnections;\n         this.requester = requester;\n+        @SuppressWarnings(\"unchecked\")\n+        Pool<Connection> pool = destination.getBean(Pool.class);\n+        if (pool == null)\n+        {\n+            pool = new Pool<>(maxConnections, cache ? 1 : 0);\n+            destination.addBean(pool);\n+        }\n+        this.pool = pool;\n+    }\n+\n+    @Override\n+    public void preCreateConnections(int connectionCount)\n+    {\n+        List<Future<Connection>> futures = new ArrayList<>();\n+        for (int i = 0; i < connectionCount; i++)\n+        {\n+            futures.add(tryCreate(pool.getMaxEntries()));\n+        }\n+        List<Throwable> exceptions = new ArrayList<>();\n+        for (Future<Connection> future : futures)\n+        {\n+            try\n+            {\n+                future.get();", "originalCommit": "4da75934ebc000efb0a13d60524a9e679e26573d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE1ODIyNg==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r462158226", "bodyText": "Agreed.", "author": "lorban", "createdAt": "2020-07-29T09:16:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQwMzQ3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQyNTM1Nw==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r461425357", "bodyText": "I don't like pc.getState() exposed - we change the implementation and we're breaking.\nCan we have Entry.isClosed() and Entry.isInUse() or similar?", "author": "sbordet", "createdAt": "2020-07-28T08:55:56Z", "path": "jetty-client/src/main/java/org/eclipse/jetty/client/AbstractConnectionPool.java", "diffHunk": "@@ -18,69 +18,135 @@\n \n package org.eclipse.jetty.client;\n \n+import java.io.IOException;\n+import java.util.ArrayList;\n import java.util.Collection;\n-import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Future;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n \n import org.eclipse.jetty.client.api.Connection;\n import org.eclipse.jetty.client.api.Destination;\n-import org.eclipse.jetty.util.AtomicBiInteger;\n+import org.eclipse.jetty.util.Attachable;\n import org.eclipse.jetty.util.Callback;\n+import org.eclipse.jetty.util.Pool;\n import org.eclipse.jetty.util.Promise;\n import org.eclipse.jetty.util.annotation.ManagedAttribute;\n import org.eclipse.jetty.util.annotation.ManagedObject;\n import org.eclipse.jetty.util.component.Dumpable;\n import org.eclipse.jetty.util.log.Log;\n import org.eclipse.jetty.util.log.Logger;\n+import org.eclipse.jetty.util.thread.Sweeper;\n+\n+import static java.util.stream.Collectors.toList;\n \n @ManagedObject\n-public abstract class AbstractConnectionPool implements ConnectionPool, Dumpable\n+public abstract class AbstractConnectionPool implements ConnectionPool, Dumpable, Sweeper.Sweepable\n {\n     private static final Logger LOG = Log.getLogger(AbstractConnectionPool.class);\n \n-    /**\n-     * The connectionCount encodes both the total connections plus the pending connection counts, so both can be atomically changed.\n-     * The bottom 32 bits represent the total connections and the top 32 bits represent the pending connections.\n-     */\n-    private final AtomicBiInteger connections = new AtomicBiInteger();\n-    private final AtomicBoolean closed = new AtomicBoolean();\n     private final HttpDestination destination;\n-    private final int maxConnections;\n     private final Callback requester;\n+    private final Pool<Connection> pool;\n \n     /**\n-     * @param destination the correspondent destination\n-     * @param maxConnections the max number of connections\n-     * @param requester the callback to notify about new connection creation/failure\n-     * @deprecated use {@link #AbstractConnectionPool(HttpDestination, int, Callback)} instead\n+     * @deprecated use {@link #AbstractConnectionPool(HttpDestination, int, boolean, Callback)} instead\n      */\n     @Deprecated\n     protected AbstractConnectionPool(Destination destination, int maxConnections, Callback requester)\n     {\n-        this((HttpDestination)destination, maxConnections, requester);\n+        this((HttpDestination)destination, maxConnections, true, requester);\n     }\n \n-    protected AbstractConnectionPool(HttpDestination destination, int maxConnections, Callback requester)\n+    protected AbstractConnectionPool(HttpDestination destination, int maxConnections, boolean cache, Callback requester)\n     {\n         this.destination = destination;\n-        this.maxConnections = maxConnections;\n         this.requester = requester;\n+        @SuppressWarnings(\"unchecked\")\n+        Pool<Connection> pool = destination.getBean(Pool.class);\n+        if (pool == null)\n+        {\n+            pool = new Pool<>(maxConnections, cache ? 1 : 0);\n+            destination.addBean(pool);\n+        }\n+        this.pool = pool;\n+    }\n+\n+    @Override\n+    public void preCreateConnections(int connectionCount)\n+    {\n+        List<Future<Connection>> futures = new ArrayList<>();\n+        for (int i = 0; i < connectionCount; i++)\n+        {\n+            futures.add(tryCreate(pool.getMaxEntries()));\n+        }\n+        List<Throwable> exceptions = new ArrayList<>();\n+        for (Future<Connection> future : futures)\n+        {\n+            try\n+            {\n+                future.get();\n+            }\n+            catch (Throwable t)\n+            {\n+                exceptions.add(t);\n+            }\n+        }\n+        if (!exceptions.isEmpty())\n+        {\n+            RuntimeException runtimeException = new RuntimeException(\"Error pre-creating connections\");\n+            exceptions.forEach(runtimeException::addSuppressed);\n+            throw runtimeException;\n+        }\n+    }\n+\n+    protected int getMaxMultiplex()\n+    {\n+        return pool.getMaxMultiplex();\n+    }\n+\n+    protected void setMaxMultiplex(int maxMultiplex)\n+    {\n+        pool.setMaxMultiplex(maxMultiplex);\n     }\n \n-    protected HttpDestination getHttpDestination()\n+    protected int getMaxUsageCount()\n     {\n-        return destination;\n+        return pool.getMaxUsageCount();\n+    }\n+\n+    protected void setMaxUsageCount(int maxUsageCount)\n+    {\n+        pool.setMaxUsageCount(maxUsageCount);\n+    }\n+\n+    @ManagedAttribute(value = \"The number of active connections\", readonly = true)\n+    public int getActiveConnectionCount()\n+    {\n+        return (int)pool.values().stream().filter(pc -> pc.getState() > 0).count();", "originalCommit": "4da75934ebc000efb0a13d60524a9e679e26573d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE0NTQ4Nw==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r462145487", "bodyText": "getState() is IMHO abstract enough that it can its contract can accomodate with a different implementation. But I do agree that having three explicit boolean isClosed()  boolean isIdle() and boolean isInUse() methods is much clearer.\nLet's do this change.", "author": "lorban", "createdAt": "2020-07-29T08:56:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQyNTM1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQyNzQ3Mw==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r461427473", "bodyText": "NOOOO! CompletableFuture, not Future \ud83e\udd23\nAlso, missing @return in javadocs.", "author": "sbordet", "createdAt": "2020-07-28T08:59:21Z", "path": "jetty-client/src/main/java/org/eclipse/jetty/client/AbstractConnectionPool.java", "diffHunk": "@@ -150,90 +216,159 @@ protected Connection acquire(boolean create)\n      * @param maxPending the max desired number of connections scheduled for opening,\n      * or a negative number to always trigger the opening of a new connection\n      */\n-    protected void tryCreate(int maxPending)\n+    Future<Connection> tryCreate(int maxPending)", "originalCommit": "4da75934ebc000efb0a13d60524a9e679e26573d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE0NjE5Ng==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r462146196", "bodyText": "I don't really mind returning a CompletableFuture instead of a plain Future but I wonder what kind of benefit this would have?", "author": "lorban", "createdAt": "2020-07-29T08:57:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQyNzQ3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE4MDIyMA==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r462180220", "bodyText": "Well, composition is one such benefit, so I changed the return type to CompletableFuture.", "author": "lorban", "createdAt": "2020-07-29T09:54:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQyNzQ3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQzMjYwNg==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r461432606", "bodyText": "Why is this deprecated?", "author": "sbordet", "createdAt": "2020-07-28T09:07:31Z", "path": "jetty-client/src/main/java/org/eclipse/jetty/client/AbstractConnectionPool.java", "diffHunk": "@@ -242,28 +377,193 @@ protected void released(Connection connection)\n \n     protected void removed(Connection connection)\n     {\n-        int pooled = connections.addAndGetLo(-1);\n-        if (LOG.isDebugEnabled())\n-            LOG.debug(\"Connection removed {} - pooled: {}\", connection, pooled);\n     }\n \n-    @Override\n-    public void close()\n+    /**\n+     * @deprecated Relying on this method indicates a reliance on the implementation details.\n+     * @return an unmodifiable queue working as a view of the idle connections.\n+     */\n+    @Deprecated\n+    public Queue<Connection> getIdleConnections()\n     {\n-        if (closed.compareAndSet(false, true))\n+        return new QueueView(e -> e.getState() == 0);\n+    }\n+\n+    /**\n+     * @deprecated Relying on this method indicates a reliance on the implementation details.\n+     * @return an unmodifiable collection working as a view of the active connections.\n+     */\n+    @Deprecated\n+    public Collection<Connection> getActiveConnections()", "originalCommit": "4da75934ebc000efb0a13d60524a9e679e26573d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE3OTY2OA==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r462179668", "bodyText": "I deprecated that method because I couldn't think of a compelling reason why anyone would need to get all active connections, besides testing.", "author": "lorban", "createdAt": "2020-07-29T09:53:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQzMjYwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQzMzM5Mg==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r461433392", "bodyText": "A lot of work to implement Queue from scratch... Could we not filter eagerly, rather than lazily?", "author": "sbordet", "createdAt": "2020-07-28T09:08:20Z", "path": "jetty-client/src/main/java/org/eclipse/jetty/client/AbstractConnectionPool.java", "diffHunk": "@@ -242,28 +377,193 @@ protected void released(Connection connection)\n \n     protected void removed(Connection connection)\n     {\n-        int pooled = connections.addAndGetLo(-1);\n-        if (LOG.isDebugEnabled())\n-            LOG.debug(\"Connection removed {} - pooled: {}\", connection, pooled);\n     }\n \n-    @Override\n-    public void close()\n+    /**\n+     * @deprecated Relying on this method indicates a reliance on the implementation details.\n+     * @return an unmodifiable queue working as a view of the idle connections.\n+     */\n+    @Deprecated\n+    public Queue<Connection> getIdleConnections()\n     {\n-        if (closed.compareAndSet(false, true))\n+        return new QueueView(e -> e.getState() == 0);\n+    }\n+\n+    /**\n+     * @deprecated Relying on this method indicates a reliance on the implementation details.\n+     * @return an unmodifiable collection working as a view of the active connections.\n+     */\n+    @Deprecated\n+    public Collection<Connection> getActiveConnections()\n+    {\n+        return new QueueView(e -> e.getState() > 0);\n+    }\n+\n+    private class QueueView implements Queue<Connection>", "originalCommit": "4da75934ebc000efb0a13d60524a9e679e26573d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE3NzI3Mg==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r462177272", "bodyText": "No, because the internal structure of the pool is not and cannot be a queue.", "author": "lorban", "createdAt": "2020-07-29T09:49:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQzMzM5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUyNjk2OA==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r462526968", "bodyText": "I meant this:\ngetActiveConnections() {\n        return pool.values().stream()\n            .filter(Pool.Entry::isInUse)\n            .collect(Collectors.toList());\n}\nWhy do we need QueueView at all?", "author": "sbordet", "createdAt": "2020-07-29T19:12:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQzMzM5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ0NDIwMQ==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r461444201", "bodyText": "I think calling super will call again released(connection) that has already been called in release(Connection), that quarantines the connection. Here the quarantine is finished, so we only want to call idle(), no?", "author": "sbordet", "createdAt": "2020-07-28T09:24:41Z", "path": "jetty-client/src/main/java/org/eclipse/jetty/client/ValidatingConnectionPool.java", "diffHunk": "@@ -170,21 +138,11 @@ public void run()\n             if (done.compareAndSet(false, true))\n             {\n                 boolean closed = isClosed();\n-                lock();\n-                try\n-                {\n-                    if (LOG.isDebugEnabled())\n-                        LOG.debug(\"Validated {}\", connection);\n-                    quarantine.remove(connection);\n-                    if (!closed)\n-                        deactivate(connection);\n-                }\n-                finally\n-                {\n-                    unlock();\n-                }\n-\n-                idle(connection, closed);\n+                if (LOG.isDebugEnabled())\n+                    LOG.debug(\"Validated {}\", connection);\n+                quarantine.remove(connection);\n+                if (!closed)\n+                    ValidatingConnectionPool.super.release(connection);", "originalCommit": "4da75934ebc000efb0a13d60524a9e679e26573d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIyNzc2Ng==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r462227766", "bodyText": "You're right, let me fix this.", "author": "lorban", "createdAt": "2020-07-29T11:26:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ0NDIwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ0OTE0Nw==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r461449147", "bodyText": "I don't think it's right to not check the return value.\nThere is a race between the scheduler ending the quarantine and some other thread calling this method (e.g. server closing or idle timeout).\nWe don't want to have both threads call concurrent super methods.\nMaybe it was wrong before too?", "author": "sbordet", "createdAt": "2020-07-28T09:32:49Z", "path": "jetty-client/src/main/java/org/eclipse/jetty/client/ValidatingConnectionPool.java", "diffHunk": "@@ -105,50 +95,28 @@ public boolean release(Connection connection)\n     @Override\n     public boolean remove(Connection connection)\n     {\n-        Holder holder;\n-        lock();\n-        try\n-        {\n-            holder = quarantine.remove(connection);\n-        }\n-        finally\n-        {\n-            unlock();\n-        }\n+        Holder holder = quarantine.remove(connection);\n \n-        if (holder == null)\n-            return super.remove(connection);\n+        if (holder != null)\n+            holder.cancel();", "originalCommit": "4da75934ebc000efb0a13d60524a9e679e26573d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIzNDA1Mw==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r462234053", "bodyText": "I've refactored this code to be more like it previously was; and it seems the problem of calling super.remove twice was already present. But this doesn't have any ill-effect: it can be safely be called concurrently.", "author": "lorban", "createdAt": "2020-07-29T11:39:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ0OTE0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ1MDczMQ==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r461450731", "bodyText": "Space after comma.", "author": "sbordet", "createdAt": "2020-07-28T09:35:24Z", "path": "jetty-jmh/src/main/java/org/eclipse/jetty/client/jmh/ConnectionPoolsBenchmark.java", "diffHunk": "@@ -0,0 +1,180 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.client.jmh;\n+\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+import org.eclipse.jetty.client.ConnectionPool;\n+import org.eclipse.jetty.client.DuplexConnectionPool;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.HttpConversation;\n+import org.eclipse.jetty.client.HttpDestination;\n+import org.eclipse.jetty.client.HttpExchange;\n+import org.eclipse.jetty.client.HttpRequest;\n+import org.eclipse.jetty.client.MultiplexConnectionPool;\n+import org.eclipse.jetty.client.Origin;\n+import org.eclipse.jetty.client.RoundRobinConnectionPool;\n+import org.eclipse.jetty.client.SendFailure;\n+import org.eclipse.jetty.client.api.Connection;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.api.Response;\n+import org.eclipse.jetty.util.Attachable;\n+import org.eclipse.jetty.util.Callback;\n+import org.eclipse.jetty.util.Promise;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.infra.Blackhole;\n+import org.openjdk.jmh.runner.Runner;\n+import org.openjdk.jmh.runner.RunnerException;\n+import org.openjdk.jmh.runner.options.Options;\n+import org.openjdk.jmh.runner.options.OptionsBuilder;\n+\n+@State(Scope.Benchmark)\n+public class ConnectionPoolsBenchmark\n+{\n+    private ConnectionPool pool;\n+\n+    @Param({\"round-robin\", \"cached/multiplex\", \"uncached/multiplex\", \"cached/duplex\", \"uncached/duplex\"})\n+    public static String POOL_TYPE;\n+\n+    @Setup\n+    public void setUp() throws Exception\n+    {\n+        HttpClient httpClient = new HttpClient()\n+        {\n+            @Override\n+            protected void newConnection(HttpDestination destination, Promise<Connection> promise)\n+            {\n+                promise.succeeded(new MockConnection());\n+            }\n+        };\n+        HttpDestination httpDestination = new HttpDestination(httpClient, new Origin(\"http\", \"localhost\", 8080))\n+        {\n+            @Override\n+            protected SendFailure send(Connection connection, HttpExchange exchange)\n+            {\n+                return null;\n+            }\n+        };\n+\n+        HttpConversation httpConversation = new HttpConversation();\n+        HttpRequest httpRequest = new HttpRequest(httpClient, httpConversation, new URI(\"http://localhost:8080\")) {};\n+        HttpExchange httpExchange = new HttpExchange(httpDestination, httpRequest, new ArrayList<>());\n+        httpDestination.getHttpExchanges().add(httpExchange);\n+\n+        int initialConnections = 12;\n+        int maxConnections = 100;\n+        switch (POOL_TYPE)\n+        {\n+            case \"uncached/duplex\":\n+                pool = new DuplexConnectionPool(httpDestination, maxConnections, false, Callback.NOOP);\n+                pool.preCreateConnections(initialConnections);\n+                break;\n+            case \"cached/duplex\":\n+                pool = new DuplexConnectionPool(httpDestination, maxConnections, true, Callback.NOOP);\n+                pool.preCreateConnections(initialConnections);\n+                break;\n+            case \"uncached/multiplex\":\n+                pool = new MultiplexConnectionPool(httpDestination, maxConnections,false, Callback.NOOP, 12);\n+                pool.preCreateConnections(initialConnections);\n+                break;\n+            case \"cached/multiplex\":\n+                pool = new MultiplexConnectionPool(httpDestination, maxConnections,true, Callback.NOOP, 12);\n+                pool.preCreateConnections(initialConnections);\n+                break;\n+            case \"round-robin\":\n+                pool = new RoundRobinConnectionPool(httpDestination, maxConnections, Callback.NOOP);\n+                pool.preCreateConnections(maxConnections);\n+                break;\n+            default:\n+                throw new AssertionError(\"Unknown pool type: \" + POOL_TYPE);\n+        }\n+    }\n+\n+    @TearDown\n+    public void tearDown()\n+    {\n+        pool.close();\n+        pool = null;\n+    }\n+\n+    @Benchmark\n+    public void testPool()\n+    {\n+        Connection connection = pool.acquire();\n+        if (connection == null && !POOL_TYPE.equals(\"round-robin\"))\n+            throw new AssertionError(\"from thread \" + Thread.currentThread().getName());\n+        Blackhole.consumeCPU(ThreadLocalRandom.current().nextInt(10,20));", "originalCommit": "4da75934ebc000efb0a13d60524a9e679e26573d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE3NTMxNw==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r462175317", "bodyText": "Ooops, let me fix this.", "author": "lorban", "createdAt": "2020-07-29T09:45:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ1MDczMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ1MTQ4OA==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r461451488", "bodyText": "Don't abbreviate \"misc.\".", "author": "sbordet", "createdAt": "2020-07-28T09:36:32Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Attachable.java", "diffHunk": "@@ -0,0 +1,38 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.util;\n+\n+/**\n+ * Abstract mechanism to support attachment of misc. objects.", "originalCommit": "4da75934ebc000efb0a13d60524a9e679e26573d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE3NTY5NA==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r462175694", "bodyText": "Ok.", "author": "lorban", "createdAt": "2020-07-29T09:46:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ1MTQ4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ1MzEwNg==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r461453106", "bodyText": "Remove this last </p>. Either wrap properly paragraphs, or use a open-only <p> to add a blank line.", "author": "sbordet", "createdAt": "2020-07-28T09:39:18Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -0,0 +1,459 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.util;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.eclipse.jetty.util.component.Dumpable;\n+import org.eclipse.jetty.util.log.Log;\n+import org.eclipse.jetty.util.log.Logger;\n+\n+/**\n+ * A fast container of poolable objects, with optional support for\n+ * multiplexing, max usage count and thread-local caching.\n+ * <p>\n+ * The thread-local caching mechanism is about remembering up to N previously\n+ * used entries into a thread-local single-threaded collection.\n+ * When that collection is not empty, its entries are removed one by one\n+ * during acquisition until an entry that can be acquired is found.\n+ * This can greatly speed up acquisition when both the acquisition and the\n+ * release of the entries is done on the same thread as this avoids iterating\n+ * the global, thread-safe collection of entries.\n+ * </p>", "originalCommit": "4da75934ebc000efb0a13d60524a9e679e26573d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjEzMzU3MQ==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r462133571", "bodyText": "Ok.", "author": "lorban", "createdAt": "2020-07-29T08:35:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ1MzEwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ1NDIzNg==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r461454236", "bodyText": "Unnecessary cast?", "author": "sbordet", "createdAt": "2020-07-28T09:41:13Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -0,0 +1,459 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.util;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.eclipse.jetty.util.component.Dumpable;\n+import org.eclipse.jetty.util.log.Log;\n+import org.eclipse.jetty.util.log.Logger;\n+\n+/**\n+ * A fast container of poolable objects, with optional support for\n+ * multiplexing, max usage count and thread-local caching.\n+ * <p>\n+ * The thread-local caching mechanism is about remembering up to N previously\n+ * used entries into a thread-local single-threaded collection.\n+ * When that collection is not empty, its entries are removed one by one\n+ * during acquisition until an entry that can be acquired is found.\n+ * This can greatly speed up acquisition when both the acquisition and the\n+ * release of the entries is done on the same thread as this avoids iterating\n+ * the global, thread-safe collection of entries.\n+ * </p>\n+ * @param <T>\n+ */\n+public class Pool<T> implements AutoCloseable, Dumpable\n+{\n+    private static final Logger LOGGER = Log.getLogger(Pool.class);\n+\n+    private final List<Entry> sharedList = new CopyOnWriteArrayList<>();\n+    /*\n+     * The cache is used to avoid hammering on the first index of the entry list.\n+     * Caches can become poisoned (i.e.: containing entries that are in use) when\n+     * the release isn't done by the acquiring thread or when the entry pool is\n+     * undersized compared to the load applied on it.\n+     * When an entry can't be found in the cache, the global list is iterated\n+     * normally so the cache has no visible effect besides performance.\n+     */\n+    private final ThreadLocal<List<Entry>> cache;\n+    private final Lock reservationLock = new ReentrantLock();\n+    private final int maxEntries;\n+    private final int cacheSize;\n+    private volatile boolean closed;\n+    private volatile int maxMultiplex = 1;\n+    private volatile int maxUsageCount = -1;\n+\n+    /**\n+     * Construct a Pool with the specified thread-local cache size.\n+     *\n+     * @param maxEntries the maximum amount of entries that the pool will accept.\n+     * @param cacheSize the thread-local cache size. A value less than 1 means the cache is disabled.\n+     */\n+    public Pool(int maxEntries, int cacheSize)\n+    {\n+        this.maxEntries = maxEntries;\n+        this.cacheSize = cacheSize;\n+        if (cacheSize > 0)\n+            this.cache = ThreadLocal.withInitial(() -> (List<Entry>)new ArrayList<Entry>(cacheSize));", "originalCommit": "4da75934ebc000efb0a13d60524a9e679e26573d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjEzNDI5NA==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r462134294", "bodyText": "Indeed, but Intellij wasn't smart enough to report it. I'll check my settings and remove that cast.", "author": "lorban", "createdAt": "2020-07-29T08:36:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ1NDIzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ1NTUzNw==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r461455537", "bodyText": "Rename to reserve() since there is no correspondent removeReservation()?", "author": "sbordet", "createdAt": "2020-07-28T09:43:21Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -0,0 +1,459 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.util;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.eclipse.jetty.util.component.Dumpable;\n+import org.eclipse.jetty.util.log.Log;\n+import org.eclipse.jetty.util.log.Logger;\n+\n+/**\n+ * A fast container of poolable objects, with optional support for\n+ * multiplexing, max usage count and thread-local caching.\n+ * <p>\n+ * The thread-local caching mechanism is about remembering up to N previously\n+ * used entries into a thread-local single-threaded collection.\n+ * When that collection is not empty, its entries are removed one by one\n+ * during acquisition until an entry that can be acquired is found.\n+ * This can greatly speed up acquisition when both the acquisition and the\n+ * release of the entries is done on the same thread as this avoids iterating\n+ * the global, thread-safe collection of entries.\n+ * </p>\n+ * @param <T>\n+ */\n+public class Pool<T> implements AutoCloseable, Dumpable\n+{\n+    private static final Logger LOGGER = Log.getLogger(Pool.class);\n+\n+    private final List<Entry> sharedList = new CopyOnWriteArrayList<>();\n+    /*\n+     * The cache is used to avoid hammering on the first index of the entry list.\n+     * Caches can become poisoned (i.e.: containing entries that are in use) when\n+     * the release isn't done by the acquiring thread or when the entry pool is\n+     * undersized compared to the load applied on it.\n+     * When an entry can't be found in the cache, the global list is iterated\n+     * normally so the cache has no visible effect besides performance.\n+     */\n+    private final ThreadLocal<List<Entry>> cache;\n+    private final Lock reservationLock = new ReentrantLock();\n+    private final int maxEntries;\n+    private final int cacheSize;\n+    private volatile boolean closed;\n+    private volatile int maxMultiplex = 1;\n+    private volatile int maxUsageCount = -1;\n+\n+    /**\n+     * Construct a Pool with the specified thread-local cache size.\n+     *\n+     * @param maxEntries the maximum amount of entries that the pool will accept.\n+     * @param cacheSize the thread-local cache size. A value less than 1 means the cache is disabled.\n+     */\n+    public Pool(int maxEntries, int cacheSize)\n+    {\n+        this.maxEntries = maxEntries;\n+        this.cacheSize = cacheSize;\n+        if (cacheSize > 0)\n+            this.cache = ThreadLocal.withInitial(() -> (List<Entry>)new ArrayList<Entry>(cacheSize));\n+        else\n+            this.cache = null;\n+    }\n+\n+    public int getMaxEntries()\n+    {\n+        return maxEntries;\n+    }\n+\n+    public int getMaxMultiplex()\n+    {\n+        return maxMultiplex;\n+    }\n+\n+    public final void setMaxMultiplex(int maxMultiplex)\n+    {\n+        if (maxMultiplex < 1)\n+            throw new IllegalArgumentException(\"Max multiplex must be >= 1\");\n+        this.maxMultiplex = maxMultiplex;\n+    }\n+\n+    public int getMaxUsageCount()\n+    {\n+        return maxUsageCount;\n+    }\n+\n+    public final void setMaxUsageCount(int maxUsageCount)\n+    {\n+        if (maxUsageCount == 0)\n+            throw new IllegalArgumentException(\"Max usage count must be != 0\");\n+        this.maxUsageCount = maxUsageCount;\n+    }\n+\n+    /**\n+     * Create a new disabled slot into the pool. The returned entry\n+     * won't be acquirable as long as {@link Entry#enable(Object)}\n+     * has not been called.\n+     *\n+     * @param maxReservations the max desired number of reserved entries,\n+     * or a negative number to always trigger the reservation of a new entry.\n+     * @return a disabled entry that is contained in the pool,\n+     * or null if the pool is closed or if the pool already contains\n+     * {@link #getMaxEntries()} entries.\n+     */\n+    public Entry addReservation(int maxReservations)", "originalCommit": "4da75934ebc000efb0a13d60524a9e679e26573d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE2MDExMw==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r462160113", "bodyText": "Sounds reasonable. I'll do it.", "author": "lorban", "createdAt": "2020-07-29T09:20:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ1NTUzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ4OTY1Mw==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r461489653", "bodyText": "Isn't this method very costly now? with the stream filtering and the lock? Can't we use the entry state to \"reserve\"?", "author": "sbordet", "createdAt": "2020-07-28T10:47:58Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -0,0 +1,459 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.util;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.eclipse.jetty.util.component.Dumpable;\n+import org.eclipse.jetty.util.log.Log;\n+import org.eclipse.jetty.util.log.Logger;\n+\n+/**\n+ * A fast container of poolable objects, with optional support for\n+ * multiplexing, max usage count and thread-local caching.\n+ * <p>\n+ * The thread-local caching mechanism is about remembering up to N previously\n+ * used entries into a thread-local single-threaded collection.\n+ * When that collection is not empty, its entries are removed one by one\n+ * during acquisition until an entry that can be acquired is found.\n+ * This can greatly speed up acquisition when both the acquisition and the\n+ * release of the entries is done on the same thread as this avoids iterating\n+ * the global, thread-safe collection of entries.\n+ * </p>\n+ * @param <T>\n+ */\n+public class Pool<T> implements AutoCloseable, Dumpable\n+{\n+    private static final Logger LOGGER = Log.getLogger(Pool.class);\n+\n+    private final List<Entry> sharedList = new CopyOnWriteArrayList<>();\n+    /*\n+     * The cache is used to avoid hammering on the first index of the entry list.\n+     * Caches can become poisoned (i.e.: containing entries that are in use) when\n+     * the release isn't done by the acquiring thread or when the entry pool is\n+     * undersized compared to the load applied on it.\n+     * When an entry can't be found in the cache, the global list is iterated\n+     * normally so the cache has no visible effect besides performance.\n+     */\n+    private final ThreadLocal<List<Entry>> cache;\n+    private final Lock reservationLock = new ReentrantLock();\n+    private final int maxEntries;\n+    private final int cacheSize;\n+    private volatile boolean closed;\n+    private volatile int maxMultiplex = 1;\n+    private volatile int maxUsageCount = -1;\n+\n+    /**\n+     * Construct a Pool with the specified thread-local cache size.\n+     *\n+     * @param maxEntries the maximum amount of entries that the pool will accept.\n+     * @param cacheSize the thread-local cache size. A value less than 1 means the cache is disabled.\n+     */\n+    public Pool(int maxEntries, int cacheSize)\n+    {\n+        this.maxEntries = maxEntries;\n+        this.cacheSize = cacheSize;\n+        if (cacheSize > 0)\n+            this.cache = ThreadLocal.withInitial(() -> (List<Entry>)new ArrayList<Entry>(cacheSize));\n+        else\n+            this.cache = null;\n+    }\n+\n+    public int getMaxEntries()\n+    {\n+        return maxEntries;\n+    }\n+\n+    public int getMaxMultiplex()\n+    {\n+        return maxMultiplex;\n+    }\n+\n+    public final void setMaxMultiplex(int maxMultiplex)\n+    {\n+        if (maxMultiplex < 1)\n+            throw new IllegalArgumentException(\"Max multiplex must be >= 1\");\n+        this.maxMultiplex = maxMultiplex;\n+    }\n+\n+    public int getMaxUsageCount()\n+    {\n+        return maxUsageCount;\n+    }\n+\n+    public final void setMaxUsageCount(int maxUsageCount)\n+    {\n+        if (maxUsageCount == 0)\n+            throw new IllegalArgumentException(\"Max usage count must be != 0\");\n+        this.maxUsageCount = maxUsageCount;\n+    }\n+\n+    /**\n+     * Create a new disabled slot into the pool. The returned entry\n+     * won't be acquirable as long as {@link Entry#enable(Object)}\n+     * has not been called.\n+     *\n+     * @param maxReservations the max desired number of reserved entries,\n+     * or a negative number to always trigger the reservation of a new entry.\n+     * @return a disabled entry that is contained in the pool,\n+     * or null if the pool is closed or if the pool already contains\n+     * {@link #getMaxEntries()} entries.\n+     */\n+    public Entry addReservation(int maxReservations)\n+    {\n+        reservationLock.lock();\n+        try\n+        {\n+            long pending = sharedList.stream().filter(entry -> entry.getPooled() == null).count();\n+            if (maxReservations >= 0 && pending >= maxReservations)\n+            {\n+                return null;\n+            }\n+\n+            if (!closed && sharedList.size() < maxEntries)\n+            {\n+                Entry entry = new Entry();\n+                sharedList.add(entry);\n+                return entry;\n+            }\n+            return null;\n+        }\n+        finally\n+        {\n+            reservationLock.unlock();\n+        }\n+    }", "originalCommit": "4da75934ebc000efb0a13d60524a9e679e26573d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE3MzQwMA==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r462173400", "bodyText": "For a certain definition of costly, yes: this method takes a lock and iterates the shared list. But over the Grand Scheme of Things, adding entries to the pool should be a rather uncommon event, I don't think adding new pooled entries every millisecond is a sane behavior after warmup is done. So overall, I don't think it really matters.", "author": "lorban", "createdAt": "2020-07-29T09:42:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ4OTY1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUzMDI1Ng==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r462530256", "bodyText": "As discussed, I think the lock can be made smaller (just rename it from reservationLock to lock as it's also used to protect closed).\nOnly 138-142 needs to be guarded by the lock.", "author": "sbordet", "createdAt": "2020-07-29T19:18:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ4OTY1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTUzMTQ3OA==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r461531478", "bodyText": "Why the lock here? I mean that it seems to protect close but not everywhere, and works on the same variables that are used in other methods but not protected by this lock.", "author": "sbordet", "createdAt": "2020-07-28T12:12:41Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -0,0 +1,459 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.util;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.eclipse.jetty.util.component.Dumpable;\n+import org.eclipse.jetty.util.log.Log;\n+import org.eclipse.jetty.util.log.Logger;\n+\n+/**\n+ * A fast container of poolable objects, with optional support for\n+ * multiplexing, max usage count and thread-local caching.\n+ * <p>\n+ * The thread-local caching mechanism is about remembering up to N previously\n+ * used entries into a thread-local single-threaded collection.\n+ * When that collection is not empty, its entries are removed one by one\n+ * during acquisition until an entry that can be acquired is found.\n+ * This can greatly speed up acquisition when both the acquisition and the\n+ * release of the entries is done on the same thread as this avoids iterating\n+ * the global, thread-safe collection of entries.\n+ * </p>\n+ * @param <T>\n+ */\n+public class Pool<T> implements AutoCloseable, Dumpable\n+{\n+    private static final Logger LOGGER = Log.getLogger(Pool.class);\n+\n+    private final List<Entry> sharedList = new CopyOnWriteArrayList<>();\n+    /*\n+     * The cache is used to avoid hammering on the first index of the entry list.\n+     * Caches can become poisoned (i.e.: containing entries that are in use) when\n+     * the release isn't done by the acquiring thread or when the entry pool is\n+     * undersized compared to the load applied on it.\n+     * When an entry can't be found in the cache, the global list is iterated\n+     * normally so the cache has no visible effect besides performance.\n+     */\n+    private final ThreadLocal<List<Entry>> cache;\n+    private final Lock reservationLock = new ReentrantLock();\n+    private final int maxEntries;\n+    private final int cacheSize;\n+    private volatile boolean closed;\n+    private volatile int maxMultiplex = 1;\n+    private volatile int maxUsageCount = -1;\n+\n+    /**\n+     * Construct a Pool with the specified thread-local cache size.\n+     *\n+     * @param maxEntries the maximum amount of entries that the pool will accept.\n+     * @param cacheSize the thread-local cache size. A value less than 1 means the cache is disabled.\n+     */\n+    public Pool(int maxEntries, int cacheSize)\n+    {\n+        this.maxEntries = maxEntries;\n+        this.cacheSize = cacheSize;\n+        if (cacheSize > 0)\n+            this.cache = ThreadLocal.withInitial(() -> (List<Entry>)new ArrayList<Entry>(cacheSize));\n+        else\n+            this.cache = null;\n+    }\n+\n+    public int getMaxEntries()\n+    {\n+        return maxEntries;\n+    }\n+\n+    public int getMaxMultiplex()\n+    {\n+        return maxMultiplex;\n+    }\n+\n+    public final void setMaxMultiplex(int maxMultiplex)\n+    {\n+        if (maxMultiplex < 1)\n+            throw new IllegalArgumentException(\"Max multiplex must be >= 1\");\n+        this.maxMultiplex = maxMultiplex;\n+    }\n+\n+    public int getMaxUsageCount()\n+    {\n+        return maxUsageCount;\n+    }\n+\n+    public final void setMaxUsageCount(int maxUsageCount)\n+    {\n+        if (maxUsageCount == 0)\n+            throw new IllegalArgumentException(\"Max usage count must be != 0\");\n+        this.maxUsageCount = maxUsageCount;\n+    }\n+\n+    /**\n+     * Create a new disabled slot into the pool. The returned entry\n+     * won't be acquirable as long as {@link Entry#enable(Object)}\n+     * has not been called.\n+     *\n+     * @param maxReservations the max desired number of reserved entries,\n+     * or a negative number to always trigger the reservation of a new entry.\n+     * @return a disabled entry that is contained in the pool,\n+     * or null if the pool is closed or if the pool already contains\n+     * {@link #getMaxEntries()} entries.\n+     */\n+    public Entry addReservation(int maxReservations)\n+    {\n+        reservationLock.lock();\n+        try\n+        {\n+            long pending = sharedList.stream().filter(entry -> entry.getPooled() == null).count();\n+            if (maxReservations >= 0 && pending >= maxReservations)\n+            {\n+                return null;\n+            }\n+\n+            if (!closed && sharedList.size() < maxEntries)\n+            {\n+                Entry entry = new Entry();\n+                sharedList.add(entry);\n+                return entry;\n+            }\n+            return null;\n+        }\n+        finally\n+        {\n+            reservationLock.unlock();\n+        }\n+    }\n+\n+    /**\n+     * Acquire the entry from the pool at the specified index. This method bypasses the thread-local mechanism.\n+     *\n+     * @param idx the index of the entry to acquire.\n+     * @return the specified entry or null if there is none at the specified index or if it is not available.\n+     */\n+    public Entry acquireAt(int idx)\n+    {\n+        if (closed)\n+            return null;\n+\n+        try\n+        {\n+            Entry entry = sharedList.get(idx);\n+            if (entry.tryAcquire())\n+                return entry;\n+        }\n+        catch (IndexOutOfBoundsException e)\n+        {\n+            // no entry at that index\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Acquire an entry from the pool.\n+     *\n+     * @return an entry from the pool or null if none is available.\n+     */\n+    public Entry acquire()\n+    {\n+        if (closed)\n+            return null;\n+\n+        // first check the thread-local cache\n+        if (cache != null)\n+        {\n+            List<Entry> cachedList = cache.get();\n+            while (!cachedList.isEmpty())\n+            {\n+                Entry cachedEntry = cachedList.remove(cachedList.size() - 1);\n+                if (cachedEntry.tryAcquire())\n+                    return cachedEntry;\n+            }\n+        }\n+\n+        // then iterate the shared list\n+        for (Entry entry : sharedList)\n+        {\n+            if (entry.tryAcquire())\n+                return entry;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * This method will return an acquired object to the pool. Objects\n+     * that are acquired from the pool but never released will result\n+     * in a memory leak.\n+     *\n+     * @param entry the value to return to the pool\n+     * @return false if the pooled entry should be disposed of\n+     * @throws NullPointerException if value is null\n+     */\n+    public boolean release(Entry entry)\n+    {\n+        if (closed)\n+            return false;\n+\n+        // first mark it as unused\n+        boolean reusable = entry.tryRelease();\n+\n+        // then cache the released entry\n+        if (cache != null && reusable)\n+        {\n+            List<Entry> cachedList = cache.get();\n+            if (cachedList.size() < cacheSize)\n+                cachedList.add(entry);\n+        }\n+        return reusable;\n+    }\n+\n+    public boolean isClosed()\n+    {\n+        return closed;\n+    }\n+\n+    @Override\n+    public void close()\n+    {\n+        reservationLock.lock();", "originalCommit": "4da75934ebc000efb0a13d60524a9e679e26573d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE2ODY4NQ==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r462168685", "bodyText": "The only thing that must not happen concurrently is the addition of entries to the shared list, and additions while it is being cleaned up as this could cause:\n\novershooting maxEntries\novershooting maxReservations\ncreating entries in a closed pool\n\nwhile concurrently acquiring / releasing / removing entries can be safely handled. So this is what this lock is about.", "author": "lorban", "createdAt": "2020-07-29T09:34:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTUzMTQ3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUzMDk0OA==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r462530948", "bodyText": "As discussed, the lock can be reduced to flip closed, copy the entries, and clear sharedList.\nThe iteration can be outside.", "author": "sbordet", "createdAt": "2020-07-29T19:19:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTUzMTQ3OA=="}], "type": "inlineReview"}, {"oid": "2c56ee1485df817c22c9a4d14174ecd06264f2fb", "url": "https://github.com/eclipse/jetty.project/commit/2c56ee1485df817c22c9a4d14174ecd06264f2fb", "message": "batch of review changes\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-07-29T11:26:53Z", "type": "forcePushed"}, {"oid": "a1060e5ab0949ebd82a6f981408add3014070211", "url": "https://github.com/eclipse/jetty.project/commit/a1060e5ab0949ebd82a6f981408add3014070211", "message": "batch of review changes\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-07-29T11:34:12Z", "type": "forcePushed"}, {"oid": "4ece469a177dafde91bc6758268297d4c7b9eed3", "url": "https://github.com/eclipse/jetty.project/commit/4ece469a177dafde91bc6758268297d4c7b9eed3", "message": "batch of review changes\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-07-29T13:30:06Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQzNTc0OA==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r462435748", "bodyText": "I think methods similar to this will be useful to have in Pool as well, and here just delegate to Pool.", "author": "sbordet", "createdAt": "2020-07-29T16:38:04Z", "path": "jetty-client/src/main/java/org/eclipse/jetty/client/AbstractConnectionPool.java", "diffHunk": "@@ -18,69 +18,115 @@\n \n package org.eclipse.jetty.client;\n \n+import java.io.IOException;\n import java.util.Collection;\n-import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.Iterator;\n+import java.util.Queue;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n \n import org.eclipse.jetty.client.api.Connection;\n import org.eclipse.jetty.client.api.Destination;\n-import org.eclipse.jetty.util.AtomicBiInteger;\n+import org.eclipse.jetty.util.Attachable;\n import org.eclipse.jetty.util.Callback;\n+import org.eclipse.jetty.util.Pool;\n import org.eclipse.jetty.util.Promise;\n import org.eclipse.jetty.util.annotation.ManagedAttribute;\n import org.eclipse.jetty.util.annotation.ManagedObject;\n import org.eclipse.jetty.util.component.Dumpable;\n import org.eclipse.jetty.util.log.Log;\n import org.eclipse.jetty.util.log.Logger;\n+import org.eclipse.jetty.util.thread.Sweeper;\n+\n+import static java.util.stream.Collectors.toList;\n \n @ManagedObject\n-public abstract class AbstractConnectionPool implements ConnectionPool, Dumpable\n+public abstract class AbstractConnectionPool implements ConnectionPool, Dumpable, Sweeper.Sweepable\n {\n     private static final Logger LOG = Log.getLogger(AbstractConnectionPool.class);\n \n-    /**\n-     * The connectionCount encodes both the total connections plus the pending connection counts, so both can be atomically changed.\n-     * The bottom 32 bits represent the total connections and the top 32 bits represent the pending connections.\n-     */\n-    private final AtomicBiInteger connections = new AtomicBiInteger();\n-    private final AtomicBoolean closed = new AtomicBoolean();\n     private final HttpDestination destination;\n-    private final int maxConnections;\n     private final Callback requester;\n+    private final Pool<Connection> pool;\n \n     /**\n-     * @param destination the correspondent destination\n-     * @param maxConnections the max number of connections\n-     * @param requester the callback to notify about new connection creation/failure\n-     * @deprecated use {@link #AbstractConnectionPool(HttpDestination, int, Callback)} instead\n+     * @deprecated use {@link #AbstractConnectionPool(HttpDestination, int, boolean, Callback)} instead\n      */\n     @Deprecated\n     protected AbstractConnectionPool(Destination destination, int maxConnections, Callback requester)\n     {\n-        this((HttpDestination)destination, maxConnections, requester);\n+        this((HttpDestination)destination, maxConnections, true, requester);\n     }\n \n-    protected AbstractConnectionPool(HttpDestination destination, int maxConnections, Callback requester)\n+    protected AbstractConnectionPool(HttpDestination destination, int maxConnections, boolean cache, Callback requester)\n     {\n         this.destination = destination;\n-        this.maxConnections = maxConnections;\n         this.requester = requester;\n+        @SuppressWarnings(\"unchecked\")\n+        Pool<Connection> pool = destination.getBean(Pool.class);\n+        if (pool == null)\n+        {\n+            pool = new Pool<>(maxConnections, cache ? 1 : 0);\n+            destination.addBean(pool);\n+        }\n+        this.pool = pool;\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> preCreateConnections(int connectionCount)\n+    {\n+        CompletableFuture<?>[] futures = new CompletableFuture[connectionCount];\n+        for (int i = 0; i < connectionCount; i++)\n+        {\n+            futures[i] = tryCreate(pool.getMaxEntries());\n+        }\n+        return CompletableFuture.allOf(futures);\n+    }\n+\n+    protected int getMaxMultiplex()\n+    {\n+        return pool.getMaxMultiplex();\n+    }\n+\n+    protected void setMaxMultiplex(int maxMultiplex)\n+    {\n+        pool.setMaxMultiplex(maxMultiplex);\n+    }\n+\n+    protected int getMaxUsageCount()\n+    {\n+        return pool.getMaxUsageCount();\n+    }\n+\n+    protected void setMaxUsageCount(int maxUsageCount)\n+    {\n+        pool.setMaxUsageCount(maxUsageCount);\n+    }\n+\n+    @ManagedAttribute(value = \"The number of active connections\", readonly = true)\n+    public int getActiveConnectionCount()\n+    {\n+        return (int)pool.values().stream().filter(Pool.Entry::isInUse).count();", "originalCommit": "e843914f9c39b9b3745077053ee7bd198411b2c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzA0MjU3Ng==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r463042576", "bodyText": "Ok.", "author": "lorban", "createdAt": "2020-07-30T14:35:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQzNTc0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQzNTgzNQ==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r462435835", "bodyText": "Ditto", "author": "sbordet", "createdAt": "2020-07-29T16:38:14Z", "path": "jetty-client/src/main/java/org/eclipse/jetty/client/AbstractConnectionPool.java", "diffHunk": "@@ -18,69 +18,115 @@\n \n package org.eclipse.jetty.client;\n \n+import java.io.IOException;\n import java.util.Collection;\n-import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.Iterator;\n+import java.util.Queue;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n \n import org.eclipse.jetty.client.api.Connection;\n import org.eclipse.jetty.client.api.Destination;\n-import org.eclipse.jetty.util.AtomicBiInteger;\n+import org.eclipse.jetty.util.Attachable;\n import org.eclipse.jetty.util.Callback;\n+import org.eclipse.jetty.util.Pool;\n import org.eclipse.jetty.util.Promise;\n import org.eclipse.jetty.util.annotation.ManagedAttribute;\n import org.eclipse.jetty.util.annotation.ManagedObject;\n import org.eclipse.jetty.util.component.Dumpable;\n import org.eclipse.jetty.util.log.Log;\n import org.eclipse.jetty.util.log.Logger;\n+import org.eclipse.jetty.util.thread.Sweeper;\n+\n+import static java.util.stream.Collectors.toList;\n \n @ManagedObject\n-public abstract class AbstractConnectionPool implements ConnectionPool, Dumpable\n+public abstract class AbstractConnectionPool implements ConnectionPool, Dumpable, Sweeper.Sweepable\n {\n     private static final Logger LOG = Log.getLogger(AbstractConnectionPool.class);\n \n-    /**\n-     * The connectionCount encodes both the total connections plus the pending connection counts, so both can be atomically changed.\n-     * The bottom 32 bits represent the total connections and the top 32 bits represent the pending connections.\n-     */\n-    private final AtomicBiInteger connections = new AtomicBiInteger();\n-    private final AtomicBoolean closed = new AtomicBoolean();\n     private final HttpDestination destination;\n-    private final int maxConnections;\n     private final Callback requester;\n+    private final Pool<Connection> pool;\n \n     /**\n-     * @param destination the correspondent destination\n-     * @param maxConnections the max number of connections\n-     * @param requester the callback to notify about new connection creation/failure\n-     * @deprecated use {@link #AbstractConnectionPool(HttpDestination, int, Callback)} instead\n+     * @deprecated use {@link #AbstractConnectionPool(HttpDestination, int, boolean, Callback)} instead\n      */\n     @Deprecated\n     protected AbstractConnectionPool(Destination destination, int maxConnections, Callback requester)\n     {\n-        this((HttpDestination)destination, maxConnections, requester);\n+        this((HttpDestination)destination, maxConnections, true, requester);\n     }\n \n-    protected AbstractConnectionPool(HttpDestination destination, int maxConnections, Callback requester)\n+    protected AbstractConnectionPool(HttpDestination destination, int maxConnections, boolean cache, Callback requester)\n     {\n         this.destination = destination;\n-        this.maxConnections = maxConnections;\n         this.requester = requester;\n+        @SuppressWarnings(\"unchecked\")\n+        Pool<Connection> pool = destination.getBean(Pool.class);\n+        if (pool == null)\n+        {\n+            pool = new Pool<>(maxConnections, cache ? 1 : 0);\n+            destination.addBean(pool);\n+        }\n+        this.pool = pool;\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> preCreateConnections(int connectionCount)\n+    {\n+        CompletableFuture<?>[] futures = new CompletableFuture[connectionCount];\n+        for (int i = 0; i < connectionCount; i++)\n+        {\n+            futures[i] = tryCreate(pool.getMaxEntries());\n+        }\n+        return CompletableFuture.allOf(futures);\n+    }\n+\n+    protected int getMaxMultiplex()\n+    {\n+        return pool.getMaxMultiplex();\n+    }\n+\n+    protected void setMaxMultiplex(int maxMultiplex)\n+    {\n+        pool.setMaxMultiplex(maxMultiplex);\n+    }\n+\n+    protected int getMaxUsageCount()\n+    {\n+        return pool.getMaxUsageCount();\n+    }\n+\n+    protected void setMaxUsageCount(int maxUsageCount)\n+    {\n+        pool.setMaxUsageCount(maxUsageCount);\n+    }\n+\n+    @ManagedAttribute(value = \"The number of active connections\", readonly = true)\n+    public int getActiveConnectionCount()\n+    {\n+        return (int)pool.values().stream().filter(Pool.Entry::isInUse).count();\n     }\n \n-    protected HttpDestination getHttpDestination()\n+    @ManagedAttribute(value = \"The number of idle connections\", readonly = true)\n+    public int getIdleConnectionCount()\n     {\n-        return destination;\n+        return (int)pool.values().stream().filter(Pool.Entry::isIdle).count();", "originalCommit": "e843914f9c39b9b3745077053ee7bd198411b2c3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQzNjAyMQ==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r462436021", "bodyText": "Ditto", "author": "sbordet", "createdAt": "2020-07-29T16:38:32Z", "path": "jetty-client/src/main/java/org/eclipse/jetty/client/AbstractConnectionPool.java", "diffHunk": "@@ -97,19 +143,19 @@ public int getPendingCount()\n     @ManagedAttribute(value = \"The number of pending connections\", readonly = true)\n     public int getPendingConnectionCount()\n     {\n-        return connections.getHi();\n+        return (int)pool.values().stream().filter(entry -> entry.getPooled() == null).count();", "originalCommit": "e843914f9c39b9b3745077053ee7bd198411b2c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzA0MjY4NQ==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r463042685", "bodyText": "Ok.", "author": "lorban", "createdAt": "2020-07-30T14:35:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQzNjAyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQzNzQxOQ==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r462437419", "bodyText": "Unfortunately it's a breaking change, as implementations need to be able to call this method.\nCan you restore the original signature, but also have one with the return type be CompletableFuture and the original call the new one (also called from preCreateConnection()).", "author": "sbordet", "createdAt": "2020-07-29T16:40:52Z", "path": "jetty-client/src/main/java/org/eclipse/jetty/client/AbstractConnectionPool.java", "diffHunk": "@@ -150,90 +196,171 @@ protected Connection acquire(boolean create)\n      * @param maxPending the max desired number of connections scheduled for opening,\n      * or a negative number to always trigger the opening of a new connection\n      */\n-    protected void tryCreate(int maxPending)\n+    CompletableFuture<Connection> tryCreate(int maxPending)", "originalCommit": "e843914f9c39b9b3745077053ee7bd198411b2c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzA2NDE1Mg==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r463064152", "bodyText": "Done.", "author": "lorban", "createdAt": "2020-07-30T15:04:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQzNzQxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ0ODU1NQ==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r462448555", "bodyText": "I would move the completion of the future before proceed(), because proceed() may take a long time to complete, as it sends the request and then loops to send as many requests as possible.", "author": "sbordet", "createdAt": "2020-07-29T16:59:17Z", "path": "jetty-client/src/main/java/org/eclipse/jetty/client/AbstractConnectionPool.java", "diffHunk": "@@ -150,90 +196,171 @@ protected Connection acquire(boolean create)\n      * @param maxPending the max desired number of connections scheduled for opening,\n      * or a negative number to always trigger the opening of a new connection\n      */\n-    protected void tryCreate(int maxPending)\n+    CompletableFuture<Connection> tryCreate(int maxPending)\n     {\n-        while (true)\n-        {\n-            long encoded = connections.get();\n-            int pending = AtomicBiInteger.getHi(encoded);\n-            int total = AtomicBiInteger.getLo(encoded);\n+        CompletableFuture<Connection> future = new CompletableFuture<>();\n \n-            if (LOG.isDebugEnabled())\n-                LOG.debug(\"tryCreate {}/{} connections {}/{} pending\", total, maxConnections, pending, maxPending);\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"tryCreate {}/{} connections {}/{} pending\", pool.size(), pool.getMaxEntries(), getPendingConnectionCount(), maxPending);\n \n-            if (total >= maxConnections)\n-                return;\n+        Pool<Connection>.Entry entry = pool.reserve(maxPending);\n+        if (entry == null)\n+        {\n+            future.complete(null);\n+            return future;\n+        }\n \n-            if (maxPending >= 0 && pending >= maxPending)\n-                return;\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"newConnection {}/{} connections {}/{} pending\", pool.size(), pool.getMaxEntries(), getPendingConnectionCount(), maxPending);\n \n-            if (connections.compareAndSet(encoded, pending + 1, total + 1))\n+        destination.newConnection(new Promise<Connection>()\n+        {\n+            @Override\n+            public void succeeded(Connection connection)\n             {\n                 if (LOG.isDebugEnabled())\n-                    LOG.debug(\"newConnection {}/{} connections {}/{} pending\", total + 1, maxConnections, pending + 1, maxPending);\n-\n-                destination.newConnection(new Promise<Connection>()\n-                {\n-                    @Override\n-                    public void succeeded(Connection connection)\n-                    {\n-                        if (LOG.isDebugEnabled())\n-                            LOG.debug(\"Connection {}/{} creation succeeded {}\", total + 1, maxConnections, connection);\n-                        connections.add(-1, 0);\n-                        onCreated(connection);\n-                        proceed();\n-                    }\n-\n-                    @Override\n-                    public void failed(Throwable x)\n-                    {\n-                        if (LOG.isDebugEnabled())\n-                            LOG.debug(\"Connection \" + (total + 1) + \"/\" + maxConnections + \" creation failed\", x);\n-                        connections.add(-1, -1);\n-                        requester.failed(x);\n-                    }\n-                });\n-\n-                return;\n+                    LOG.debug(\"Connection {}/{} creation succeeded {}\", pool.size(), pool.getMaxEntries(), connection);\n+                adopt(entry, connection);\n+                proceed();\n+                future.complete(connection);", "originalCommit": "e843914f9c39b9b3745077053ee7bd198411b2c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzA2MzE5NA==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r463063194", "bodyText": "Done.", "author": "lorban", "createdAt": "2020-07-30T15:02:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ0ODU1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ0OTA4MQ==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r462449081", "bodyText": "Same as above, move future completion before requester.failed().", "author": "sbordet", "createdAt": "2020-07-29T17:00:03Z", "path": "jetty-client/src/main/java/org/eclipse/jetty/client/AbstractConnectionPool.java", "diffHunk": "@@ -150,90 +196,171 @@ protected Connection acquire(boolean create)\n      * @param maxPending the max desired number of connections scheduled for opening,\n      * or a negative number to always trigger the opening of a new connection\n      */\n-    protected void tryCreate(int maxPending)\n+    CompletableFuture<Connection> tryCreate(int maxPending)\n     {\n-        while (true)\n-        {\n-            long encoded = connections.get();\n-            int pending = AtomicBiInteger.getHi(encoded);\n-            int total = AtomicBiInteger.getLo(encoded);\n+        CompletableFuture<Connection> future = new CompletableFuture<>();\n \n-            if (LOG.isDebugEnabled())\n-                LOG.debug(\"tryCreate {}/{} connections {}/{} pending\", total, maxConnections, pending, maxPending);\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"tryCreate {}/{} connections {}/{} pending\", pool.size(), pool.getMaxEntries(), getPendingConnectionCount(), maxPending);\n \n-            if (total >= maxConnections)\n-                return;\n+        Pool<Connection>.Entry entry = pool.reserve(maxPending);\n+        if (entry == null)\n+        {\n+            future.complete(null);\n+            return future;\n+        }\n \n-            if (maxPending >= 0 && pending >= maxPending)\n-                return;\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"newConnection {}/{} connections {}/{} pending\", pool.size(), pool.getMaxEntries(), getPendingConnectionCount(), maxPending);\n \n-            if (connections.compareAndSet(encoded, pending + 1, total + 1))\n+        destination.newConnection(new Promise<Connection>()\n+        {\n+            @Override\n+            public void succeeded(Connection connection)\n             {\n                 if (LOG.isDebugEnabled())\n-                    LOG.debug(\"newConnection {}/{} connections {}/{} pending\", total + 1, maxConnections, pending + 1, maxPending);\n-\n-                destination.newConnection(new Promise<Connection>()\n-                {\n-                    @Override\n-                    public void succeeded(Connection connection)\n-                    {\n-                        if (LOG.isDebugEnabled())\n-                            LOG.debug(\"Connection {}/{} creation succeeded {}\", total + 1, maxConnections, connection);\n-                        connections.add(-1, 0);\n-                        onCreated(connection);\n-                        proceed();\n-                    }\n-\n-                    @Override\n-                    public void failed(Throwable x)\n-                    {\n-                        if (LOG.isDebugEnabled())\n-                            LOG.debug(\"Connection \" + (total + 1) + \"/\" + maxConnections + \" creation failed\", x);\n-                        connections.add(-1, -1);\n-                        requester.failed(x);\n-                    }\n-                });\n-\n-                return;\n+                    LOG.debug(\"Connection {}/{} creation succeeded {}\", pool.size(), pool.getMaxEntries(), connection);\n+                adopt(entry, connection);\n+                proceed();\n+                future.complete(connection);\n             }\n-        }\n-    }\n \n-    protected abstract void onCreated(Connection connection);\n+            @Override\n+            public void failed(Throwable x)\n+            {\n+                if (LOG.isDebugEnabled())\n+                    LOG.debug(\"Connection \" + pool.size() + \"/\" + pool.getMaxEntries() + \" creation failed\", x);\n+                pool.remove(entry);\n+                requester.failed(x);\n+                future.completeExceptionally(x);", "originalCommit": "e843914f9c39b9b3745077053ee7bd198411b2c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzA2MzEwNg==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r463063106", "bodyText": "Done.", "author": "lorban", "createdAt": "2020-07-30T15:02:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ0OTA4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ1MTIyMg==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r462451222", "bodyText": "I wonder whether we should return CF<Connection> vs CF<Void>. Handing out the connection is subject to races because this class will use the connection, and the code that receives the CF may too.\nFor example, the send of the request may fail, the connection be closed, and the code that receives the CF now has a Connection that is closed.\nOn the other hand, this is a low-level class and if other implementations mess with it it's their fault.\nOpinions?", "author": "sbordet", "createdAt": "2020-07-29T17:03:39Z", "path": "jetty-client/src/main/java/org/eclipse/jetty/client/AbstractConnectionPool.java", "diffHunk": "@@ -150,90 +196,171 @@ protected Connection acquire(boolean create)\n      * @param maxPending the max desired number of connections scheduled for opening,\n      * or a negative number to always trigger the opening of a new connection\n      */\n-    protected void tryCreate(int maxPending)\n+    CompletableFuture<Connection> tryCreate(int maxPending)\n     {\n-        while (true)\n-        {\n-            long encoded = connections.get();\n-            int pending = AtomicBiInteger.getHi(encoded);\n-            int total = AtomicBiInteger.getLo(encoded);\n+        CompletableFuture<Connection> future = new CompletableFuture<>();", "originalCommit": "e843914f9c39b9b3745077053ee7bd198411b2c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzA2Mjk2Mg==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r463062962", "bodyText": "As discussed, CF<Void> should be used. Let me change this.", "author": "lorban", "createdAt": "2020-07-30T15:02:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ1MTIyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUzMDAzNg==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r462530036", "bodyText": "As discussed, I think the lock can be made smaller (just rename it from reservationLock to lock as it's also used to protect closed).\nOnly 138-142 needs to be guarded by the lock.", "author": "sbordet", "createdAt": "2020-07-29T19:17:47Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -0,0 +1,460 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.util;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.eclipse.jetty.util.component.Dumpable;\n+import org.eclipse.jetty.util.log.Log;\n+import org.eclipse.jetty.util.log.Logger;\n+\n+/**\n+ * A fast container of poolable objects, with optional support for\n+ * multiplexing, max usage count and thread-local caching.\n+ * <p>\n+ * The thread-local caching mechanism is about remembering up to N previously\n+ * used entries into a thread-local single-threaded collection.\n+ * When that collection is not empty, its entries are removed one by one\n+ * during acquisition until an entry that can be acquired is found.\n+ * This can greatly speed up acquisition when both the acquisition and the\n+ * release of the entries is done on the same thread as this avoids iterating\n+ * the global, thread-safe collection of entries.\n+ * @param <T>\n+ */\n+public class Pool<T> implements AutoCloseable, Dumpable\n+{\n+    private static final Logger LOGGER = Log.getLogger(Pool.class);\n+\n+    private final List<Entry> sharedList = new CopyOnWriteArrayList<>();\n+    /*\n+     * The cache is used to avoid hammering on the first index of the entry list.\n+     * Caches can become poisoned (i.e.: containing entries that are in use) when\n+     * the release isn't done by the acquiring thread or when the entry pool is\n+     * undersized compared to the load applied on it.\n+     * When an entry can't be found in the cache, the global list is iterated\n+     * normally so the cache has no visible effect besides performance.\n+     */\n+    private final ThreadLocal<List<Entry>> cache;\n+    private final Lock reservationLock = new ReentrantLock();\n+    private final int maxEntries;\n+    private final int cacheSize;\n+    private volatile boolean closed;\n+    private volatile int maxMultiplex = 1;\n+    private volatile int maxUsageCount = -1;\n+\n+    /**\n+     * Construct a Pool with the specified thread-local cache size.\n+     *\n+     * @param maxEntries the maximum amount of entries that the pool will accept.\n+     * @param cacheSize the thread-local cache size. A value less than 1 means the cache is disabled.\n+     */\n+    public Pool(int maxEntries, int cacheSize)\n+    {\n+        this.maxEntries = maxEntries;\n+        this.cacheSize = cacheSize;\n+        if (cacheSize > 0)\n+            this.cache = ThreadLocal.withInitial(() -> new ArrayList<Entry>(cacheSize));\n+        else\n+            this.cache = null;\n+    }\n+\n+    public int getMaxEntries()\n+    {\n+        return maxEntries;\n+    }\n+\n+    public int getMaxMultiplex()\n+    {\n+        return maxMultiplex;\n+    }\n+\n+    public final void setMaxMultiplex(int maxMultiplex)\n+    {\n+        if (maxMultiplex < 1)\n+            throw new IllegalArgumentException(\"Max multiplex must be >= 1\");\n+        this.maxMultiplex = maxMultiplex;\n+    }\n+\n+    public int getMaxUsageCount()\n+    {\n+        return maxUsageCount;\n+    }\n+\n+    public final void setMaxUsageCount(int maxUsageCount)\n+    {\n+        if (maxUsageCount == 0)\n+            throw new IllegalArgumentException(\"Max usage count must be != 0\");\n+        this.maxUsageCount = maxUsageCount;\n+    }\n+\n+    /**\n+     * Create a new disabled slot into the pool. The returned entry\n+     * won't be acquirable as long as {@link Entry#enable(Object)}\n+     * has not been called.\n+     *\n+     * @param maxReservations the max desired number of reserved entries,\n+     * or a negative number to always trigger the reservation of a new entry.\n+     * @return a disabled entry that is contained in the pool,\n+     * or null if the pool is closed or if the pool already contains\n+     * {@link #getMaxEntries()} entries.\n+     */\n+    public Entry reserve(int maxReservations)\n+    {\n+        reservationLock.lock();\n+        try\n+        {\n+            if (maxReservations >= 0)\n+            {\n+                long pending = sharedList.stream().filter(entry -> entry.getPooled() == null).count();\n+                if (pending >= maxReservations)\n+                    return null;\n+            }\n+\n+            if (!closed && sharedList.size() < maxEntries)\n+            {\n+                Entry entry = new Entry();\n+                sharedList.add(entry);\n+                return entry;\n+            }\n+            return null;\n+        }\n+        finally\n+        {\n+            reservationLock.unlock();\n+        }", "originalCommit": "e843914f9c39b9b3745077053ee7bd198411b2c3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUzNDcwMA==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r462534700", "bodyText": "I'd rather throw IllegalStateException here - if we get this wrong we are going to screw anyway somewhere else.", "author": "sbordet", "createdAt": "2020-07-29T19:26:23Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -0,0 +1,460 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.util;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.eclipse.jetty.util.component.Dumpable;\n+import org.eclipse.jetty.util.log.Log;\n+import org.eclipse.jetty.util.log.Logger;\n+\n+/**\n+ * A fast container of poolable objects, with optional support for\n+ * multiplexing, max usage count and thread-local caching.\n+ * <p>\n+ * The thread-local caching mechanism is about remembering up to N previously\n+ * used entries into a thread-local single-threaded collection.\n+ * When that collection is not empty, its entries are removed one by one\n+ * during acquisition until an entry that can be acquired is found.\n+ * This can greatly speed up acquisition when both the acquisition and the\n+ * release of the entries is done on the same thread as this avoids iterating\n+ * the global, thread-safe collection of entries.\n+ * @param <T>\n+ */\n+public class Pool<T> implements AutoCloseable, Dumpable\n+{\n+    private static final Logger LOGGER = Log.getLogger(Pool.class);\n+\n+    private final List<Entry> sharedList = new CopyOnWriteArrayList<>();\n+    /*\n+     * The cache is used to avoid hammering on the first index of the entry list.\n+     * Caches can become poisoned (i.e.: containing entries that are in use) when\n+     * the release isn't done by the acquiring thread or when the entry pool is\n+     * undersized compared to the load applied on it.\n+     * When an entry can't be found in the cache, the global list is iterated\n+     * normally so the cache has no visible effect besides performance.\n+     */\n+    private final ThreadLocal<List<Entry>> cache;\n+    private final Lock reservationLock = new ReentrantLock();\n+    private final int maxEntries;\n+    private final int cacheSize;\n+    private volatile boolean closed;\n+    private volatile int maxMultiplex = 1;\n+    private volatile int maxUsageCount = -1;\n+\n+    /**\n+     * Construct a Pool with the specified thread-local cache size.\n+     *\n+     * @param maxEntries the maximum amount of entries that the pool will accept.\n+     * @param cacheSize the thread-local cache size. A value less than 1 means the cache is disabled.\n+     */\n+    public Pool(int maxEntries, int cacheSize)\n+    {\n+        this.maxEntries = maxEntries;\n+        this.cacheSize = cacheSize;\n+        if (cacheSize > 0)\n+            this.cache = ThreadLocal.withInitial(() -> new ArrayList<Entry>(cacheSize));\n+        else\n+            this.cache = null;\n+    }\n+\n+    public int getMaxEntries()\n+    {\n+        return maxEntries;\n+    }\n+\n+    public int getMaxMultiplex()\n+    {\n+        return maxMultiplex;\n+    }\n+\n+    public final void setMaxMultiplex(int maxMultiplex)\n+    {\n+        if (maxMultiplex < 1)\n+            throw new IllegalArgumentException(\"Max multiplex must be >= 1\");\n+        this.maxMultiplex = maxMultiplex;\n+    }\n+\n+    public int getMaxUsageCount()\n+    {\n+        return maxUsageCount;\n+    }\n+\n+    public final void setMaxUsageCount(int maxUsageCount)\n+    {\n+        if (maxUsageCount == 0)\n+            throw new IllegalArgumentException(\"Max usage count must be != 0\");\n+        this.maxUsageCount = maxUsageCount;\n+    }\n+\n+    /**\n+     * Create a new disabled slot into the pool. The returned entry\n+     * won't be acquirable as long as {@link Entry#enable(Object)}\n+     * has not been called.\n+     *\n+     * @param maxReservations the max desired number of reserved entries,\n+     * or a negative number to always trigger the reservation of a new entry.\n+     * @return a disabled entry that is contained in the pool,\n+     * or null if the pool is closed or if the pool already contains\n+     * {@link #getMaxEntries()} entries.\n+     */\n+    public Entry reserve(int maxReservations)\n+    {\n+        reservationLock.lock();\n+        try\n+        {\n+            if (maxReservations >= 0)\n+            {\n+                long pending = sharedList.stream().filter(entry -> entry.getPooled() == null).count();\n+                if (pending >= maxReservations)\n+                    return null;\n+            }\n+\n+            if (!closed && sharedList.size() < maxEntries)\n+            {\n+                Entry entry = new Entry();\n+                sharedList.add(entry);\n+                return entry;\n+            }\n+            return null;\n+        }\n+        finally\n+        {\n+            reservationLock.unlock();\n+        }\n+    }\n+\n+    /**\n+     * Acquire the entry from the pool at the specified index. This method bypasses the thread-local mechanism.\n+     *\n+     * @param idx the index of the entry to acquire.\n+     * @return the specified entry or null if there is none at the specified index or if it is not available.\n+     */\n+    public Entry acquireAt(int idx)\n+    {\n+        if (closed)\n+            return null;\n+\n+        try\n+        {\n+            Entry entry = sharedList.get(idx);\n+            if (entry.tryAcquire())\n+                return entry;\n+        }\n+        catch (IndexOutOfBoundsException e)\n+        {\n+            // no entry at that index\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Acquire an entry from the pool.\n+     *\n+     * @return an entry from the pool or null if none is available.\n+     */\n+    public Entry acquire()\n+    {\n+        if (closed)\n+            return null;\n+\n+        // first check the thread-local cache\n+        if (cache != null)\n+        {\n+            List<Entry> cachedList = cache.get();\n+            while (!cachedList.isEmpty())\n+            {\n+                Entry cachedEntry = cachedList.remove(cachedList.size() - 1);\n+                if (cachedEntry.tryAcquire())\n+                    return cachedEntry;\n+            }\n+        }\n+\n+        // then iterate the shared list\n+        for (Entry entry : sharedList)\n+        {\n+            if (entry.tryAcquire())\n+                return entry;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * This method will return an acquired object to the pool. Objects\n+     * that are acquired from the pool but never released will result\n+     * in a memory leak.\n+     *\n+     * @param entry the value to return to the pool\n+     * @return false if the pooled entry should be disposed of\n+     * @throws NullPointerException if value is null\n+     */\n+    public boolean release(Entry entry)\n+    {\n+        if (closed)\n+            return false;\n+\n+        // first mark it as unused\n+        boolean reusable = entry.tryRelease();\n+\n+        // then cache the released entry\n+        if (cache != null && reusable)\n+        {\n+            List<Entry> cachedList = cache.get();\n+            if (cachedList.size() < cacheSize)\n+                cachedList.add(entry);\n+        }\n+        return reusable;\n+    }\n+\n+    public boolean isClosed()\n+    {\n+        return closed;\n+    }\n+\n+    @Override\n+    public void close()\n+    {\n+        reservationLock.lock();\n+        try\n+        {\n+            closed = true;\n+\n+            // clear the shared list and close its entries\n+            for (Entry entry : sharedList)\n+            {\n+                if (entry.tryRemove() && entry.pooled instanceof Closeable)\n+                {\n+                    try\n+                    {\n+                        ((Closeable)entry.pooled).close();\n+                    }\n+                    catch (IOException e)\n+                    {\n+                        LOGGER.warn(\"Error closing entry {}\", entry, e);\n+                    }\n+                }\n+            }\n+            sharedList.clear();\n+        }\n+        finally\n+        {\n+            reservationLock.unlock();\n+        }\n+    }\n+\n+    /**\n+     * Remove a value from the pool.\n+     *\n+     * @param entry the value to remove\n+     * @return true if the entry was removed, false otherwise\n+     */\n+    public boolean remove(Entry entry)\n+    {\n+        if (closed)\n+            return false;\n+\n+        if (!entry.tryRemove())\n+        {\n+            if (LOGGER.isDebugEnabled())\n+                LOGGER.debug(\"Attempt to remove an object from the pool that is still in use: {}\", entry);\n+            return false;\n+        }\n+\n+        boolean removed = sharedList.remove(entry);\n+        if (!removed)\n+        {\n+            if (LOGGER.isDebugEnabled())\n+                LOGGER.debug(\"Attempt to remove an object from the pool that does not exist: {}\", entry);\n+        }\n+\n+        return removed;\n+    }\n+\n+    public int size()\n+    {\n+        return sharedList.size();\n+    }\n+\n+    public Collection<Entry> values()\n+    {\n+        return Collections.unmodifiableCollection(sharedList);\n+    }\n+\n+    @Override\n+    public void dump(Appendable out, String indent) throws IOException\n+    {\n+        Dumpable.dumpObjects(out, indent, this);\n+    }\n+\n+    @Override\n+    public String toString()\n+    {\n+        return getClass().getSimpleName() + \" size=\" + sharedList.size() + \" closed=\" + closed + \" entries=\" + sharedList;\n+    }\n+\n+    public class Entry\n+    {\n+        // hi: positive=open/maxUsage counter,negative=closed lo: multiplexing counter\n+        private final AtomicBiInteger state;\n+        private volatile T pooled;\n+\n+        public Entry()\n+        {\n+            this.state = new AtomicBiInteger(-1, 0);\n+        }\n+\n+        public T getPooled()\n+        {\n+            return pooled;\n+        }\n+\n+        public void enable(T pooled)\n+        {\n+            if (!isClosed())\n+                throw new IllegalStateException(\"Open entries cannot be enabled : \" + this);\n+            Objects.requireNonNull(pooled);\n+            this.pooled = pooled;\n+            state.set(0, 0);\n+        }\n+\n+        /**\n+         * @return true if the pooled object was acquired.\n+         */\n+        public boolean tryAcquire()\n+        {\n+            while (true)\n+            {\n+                long encoded = state.get();\n+                int usageCount = AtomicBiInteger.getHi(encoded);\n+                boolean closed = usageCount < 0;\n+                int multiplexingCount = AtomicBiInteger.getLo(encoded);\n+                int currentMaxUsageCount = maxUsageCount;\n+                if (closed || multiplexingCount >= maxMultiplex || (currentMaxUsageCount > 0 && usageCount >= currentMaxUsageCount))\n+                    return false;\n+\n+                if (state.compareAndSet(encoded, usageCount + 1, multiplexingCount + 1))\n+                    return true;\n+            }\n+        }\n+\n+        /**\n+         * @return false if the pooled object should be disposed of.\n+         */\n+        public boolean tryRelease()\n+        {\n+            int newMultiplexingCount;\n+            int usageCount;\n+            while (true)\n+            {\n+                long encoded = state.get();\n+                usageCount = AtomicBiInteger.getHi(encoded);\n+                boolean closed = usageCount < 0;\n+                if (closed)\n+                    return false;\n+\n+                newMultiplexingCount = AtomicBiInteger.getLo(encoded) - 1;\n+                if (newMultiplexingCount < 0)\n+                {\n+                    if (LOGGER.isDebugEnabled())\n+                        LOGGER.debug(\"try release failed on negative multiplexing count : {}\", newMultiplexingCount);", "originalCommit": "e843914f9c39b9b3745077053ee7bd198411b2c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzA2MDUxNg==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r463060516", "bodyText": "ok.", "author": "lorban", "createdAt": "2020-07-30T14:59:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUzNDcwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUzODQ3MA==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r462538470", "bodyText": "I think the javadocs should say what this method does, something like \"return true if the entry was released\" or similar.", "author": "sbordet", "createdAt": "2020-07-29T19:33:11Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -0,0 +1,460 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.util;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.eclipse.jetty.util.component.Dumpable;\n+import org.eclipse.jetty.util.log.Log;\n+import org.eclipse.jetty.util.log.Logger;\n+\n+/**\n+ * A fast container of poolable objects, with optional support for\n+ * multiplexing, max usage count and thread-local caching.\n+ * <p>\n+ * The thread-local caching mechanism is about remembering up to N previously\n+ * used entries into a thread-local single-threaded collection.\n+ * When that collection is not empty, its entries are removed one by one\n+ * during acquisition until an entry that can be acquired is found.\n+ * This can greatly speed up acquisition when both the acquisition and the\n+ * release of the entries is done on the same thread as this avoids iterating\n+ * the global, thread-safe collection of entries.\n+ * @param <T>\n+ */\n+public class Pool<T> implements AutoCloseable, Dumpable\n+{\n+    private static final Logger LOGGER = Log.getLogger(Pool.class);\n+\n+    private final List<Entry> sharedList = new CopyOnWriteArrayList<>();\n+    /*\n+     * The cache is used to avoid hammering on the first index of the entry list.\n+     * Caches can become poisoned (i.e.: containing entries that are in use) when\n+     * the release isn't done by the acquiring thread or when the entry pool is\n+     * undersized compared to the load applied on it.\n+     * When an entry can't be found in the cache, the global list is iterated\n+     * normally so the cache has no visible effect besides performance.\n+     */\n+    private final ThreadLocal<List<Entry>> cache;\n+    private final Lock reservationLock = new ReentrantLock();\n+    private final int maxEntries;\n+    private final int cacheSize;\n+    private volatile boolean closed;\n+    private volatile int maxMultiplex = 1;\n+    private volatile int maxUsageCount = -1;\n+\n+    /**\n+     * Construct a Pool with the specified thread-local cache size.\n+     *\n+     * @param maxEntries the maximum amount of entries that the pool will accept.\n+     * @param cacheSize the thread-local cache size. A value less than 1 means the cache is disabled.\n+     */\n+    public Pool(int maxEntries, int cacheSize)\n+    {\n+        this.maxEntries = maxEntries;\n+        this.cacheSize = cacheSize;\n+        if (cacheSize > 0)\n+            this.cache = ThreadLocal.withInitial(() -> new ArrayList<Entry>(cacheSize));\n+        else\n+            this.cache = null;\n+    }\n+\n+    public int getMaxEntries()\n+    {\n+        return maxEntries;\n+    }\n+\n+    public int getMaxMultiplex()\n+    {\n+        return maxMultiplex;\n+    }\n+\n+    public final void setMaxMultiplex(int maxMultiplex)\n+    {\n+        if (maxMultiplex < 1)\n+            throw new IllegalArgumentException(\"Max multiplex must be >= 1\");\n+        this.maxMultiplex = maxMultiplex;\n+    }\n+\n+    public int getMaxUsageCount()\n+    {\n+        return maxUsageCount;\n+    }\n+\n+    public final void setMaxUsageCount(int maxUsageCount)\n+    {\n+        if (maxUsageCount == 0)\n+            throw new IllegalArgumentException(\"Max usage count must be != 0\");\n+        this.maxUsageCount = maxUsageCount;\n+    }\n+\n+    /**\n+     * Create a new disabled slot into the pool. The returned entry\n+     * won't be acquirable as long as {@link Entry#enable(Object)}\n+     * has not been called.\n+     *\n+     * @param maxReservations the max desired number of reserved entries,\n+     * or a negative number to always trigger the reservation of a new entry.\n+     * @return a disabled entry that is contained in the pool,\n+     * or null if the pool is closed or if the pool already contains\n+     * {@link #getMaxEntries()} entries.\n+     */\n+    public Entry reserve(int maxReservations)\n+    {\n+        reservationLock.lock();\n+        try\n+        {\n+            if (maxReservations >= 0)\n+            {\n+                long pending = sharedList.stream().filter(entry -> entry.getPooled() == null).count();\n+                if (pending >= maxReservations)\n+                    return null;\n+            }\n+\n+            if (!closed && sharedList.size() < maxEntries)\n+            {\n+                Entry entry = new Entry();\n+                sharedList.add(entry);\n+                return entry;\n+            }\n+            return null;\n+        }\n+        finally\n+        {\n+            reservationLock.unlock();\n+        }\n+    }\n+\n+    /**\n+     * Acquire the entry from the pool at the specified index. This method bypasses the thread-local mechanism.\n+     *\n+     * @param idx the index of the entry to acquire.\n+     * @return the specified entry or null if there is none at the specified index or if it is not available.\n+     */\n+    public Entry acquireAt(int idx)\n+    {\n+        if (closed)\n+            return null;\n+\n+        try\n+        {\n+            Entry entry = sharedList.get(idx);\n+            if (entry.tryAcquire())\n+                return entry;\n+        }\n+        catch (IndexOutOfBoundsException e)\n+        {\n+            // no entry at that index\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Acquire an entry from the pool.\n+     *\n+     * @return an entry from the pool or null if none is available.\n+     */\n+    public Entry acquire()\n+    {\n+        if (closed)\n+            return null;\n+\n+        // first check the thread-local cache\n+        if (cache != null)\n+        {\n+            List<Entry> cachedList = cache.get();\n+            while (!cachedList.isEmpty())\n+            {\n+                Entry cachedEntry = cachedList.remove(cachedList.size() - 1);\n+                if (cachedEntry.tryAcquire())\n+                    return cachedEntry;\n+            }\n+        }\n+\n+        // then iterate the shared list\n+        for (Entry entry : sharedList)\n+        {\n+            if (entry.tryAcquire())\n+                return entry;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * This method will return an acquired object to the pool. Objects\n+     * that are acquired from the pool but never released will result\n+     * in a memory leak.\n+     *\n+     * @param entry the value to return to the pool\n+     * @return false if the pooled entry should be disposed of\n+     * @throws NullPointerException if value is null\n+     */\n+    public boolean release(Entry entry)\n+    {\n+        if (closed)\n+            return false;\n+\n+        // first mark it as unused\n+        boolean reusable = entry.tryRelease();\n+\n+        // then cache the released entry\n+        if (cache != null && reusable)\n+        {\n+            List<Entry> cachedList = cache.get();\n+            if (cachedList.size() < cacheSize)\n+                cachedList.add(entry);\n+        }\n+        return reusable;\n+    }\n+\n+    public boolean isClosed()\n+    {\n+        return closed;\n+    }\n+\n+    @Override\n+    public void close()\n+    {\n+        reservationLock.lock();\n+        try\n+        {\n+            closed = true;\n+\n+            // clear the shared list and close its entries\n+            for (Entry entry : sharedList)\n+            {\n+                if (entry.tryRemove() && entry.pooled instanceof Closeable)\n+                {\n+                    try\n+                    {\n+                        ((Closeable)entry.pooled).close();\n+                    }\n+                    catch (IOException e)\n+                    {\n+                        LOGGER.warn(\"Error closing entry {}\", entry, e);\n+                    }\n+                }\n+            }\n+            sharedList.clear();\n+        }\n+        finally\n+        {\n+            reservationLock.unlock();\n+        }\n+    }\n+\n+    /**\n+     * Remove a value from the pool.\n+     *\n+     * @param entry the value to remove\n+     * @return true if the entry was removed, false otherwise\n+     */\n+    public boolean remove(Entry entry)\n+    {\n+        if (closed)\n+            return false;\n+\n+        if (!entry.tryRemove())\n+        {\n+            if (LOGGER.isDebugEnabled())\n+                LOGGER.debug(\"Attempt to remove an object from the pool that is still in use: {}\", entry);\n+            return false;\n+        }\n+\n+        boolean removed = sharedList.remove(entry);\n+        if (!removed)\n+        {\n+            if (LOGGER.isDebugEnabled())\n+                LOGGER.debug(\"Attempt to remove an object from the pool that does not exist: {}\", entry);\n+        }\n+\n+        return removed;\n+    }\n+\n+    public int size()\n+    {\n+        return sharedList.size();\n+    }\n+\n+    public Collection<Entry> values()\n+    {\n+        return Collections.unmodifiableCollection(sharedList);\n+    }\n+\n+    @Override\n+    public void dump(Appendable out, String indent) throws IOException\n+    {\n+        Dumpable.dumpObjects(out, indent, this);\n+    }\n+\n+    @Override\n+    public String toString()\n+    {\n+        return getClass().getSimpleName() + \" size=\" + sharedList.size() + \" closed=\" + closed + \" entries=\" + sharedList;\n+    }\n+\n+    public class Entry\n+    {\n+        // hi: positive=open/maxUsage counter,negative=closed lo: multiplexing counter\n+        private final AtomicBiInteger state;\n+        private volatile T pooled;\n+\n+        public Entry()\n+        {\n+            this.state = new AtomicBiInteger(-1, 0);\n+        }\n+\n+        public T getPooled()\n+        {\n+            return pooled;\n+        }\n+\n+        public void enable(T pooled)\n+        {\n+            if (!isClosed())\n+                throw new IllegalStateException(\"Open entries cannot be enabled : \" + this);\n+            Objects.requireNonNull(pooled);\n+            this.pooled = pooled;\n+            state.set(0, 0);\n+        }\n+\n+        /**\n+         * @return true if the pooled object was acquired.\n+         */\n+        public boolean tryAcquire()\n+        {\n+            while (true)\n+            {\n+                long encoded = state.get();\n+                int usageCount = AtomicBiInteger.getHi(encoded);\n+                boolean closed = usageCount < 0;\n+                int multiplexingCount = AtomicBiInteger.getLo(encoded);\n+                int currentMaxUsageCount = maxUsageCount;\n+                if (closed || multiplexingCount >= maxMultiplex || (currentMaxUsageCount > 0 && usageCount >= currentMaxUsageCount))\n+                    return false;\n+\n+                if (state.compareAndSet(encoded, usageCount + 1, multiplexingCount + 1))\n+                    return true;\n+            }\n+        }\n+\n+        /**\n+         * @return false if the pooled object should be disposed of.", "originalCommit": "e843914f9c39b9b3745077053ee7bd198411b2c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzA1OTg2OA==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r463059868", "bodyText": "Ok.", "author": "lorban", "createdAt": "2020-07-30T14:58:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUzODQ3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU0MjEyNg==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r462542126", "bodyText": "I would rewrite this in a way similar to tryRelease().\nWe want to set hi=-1 and return true only if also the multiplexCount==0.\nI would read the multiplexCount, update closed = casHi(usageCount, -1) and then return closed && multiplexCount==0.\nAm I missing something?", "author": "sbordet", "createdAt": "2020-07-29T19:39:46Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -0,0 +1,460 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.util;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.eclipse.jetty.util.component.Dumpable;\n+import org.eclipse.jetty.util.log.Log;\n+import org.eclipse.jetty.util.log.Logger;\n+\n+/**\n+ * A fast container of poolable objects, with optional support for\n+ * multiplexing, max usage count and thread-local caching.\n+ * <p>\n+ * The thread-local caching mechanism is about remembering up to N previously\n+ * used entries into a thread-local single-threaded collection.\n+ * When that collection is not empty, its entries are removed one by one\n+ * during acquisition until an entry that can be acquired is found.\n+ * This can greatly speed up acquisition when both the acquisition and the\n+ * release of the entries is done on the same thread as this avoids iterating\n+ * the global, thread-safe collection of entries.\n+ * @param <T>\n+ */\n+public class Pool<T> implements AutoCloseable, Dumpable\n+{\n+    private static final Logger LOGGER = Log.getLogger(Pool.class);\n+\n+    private final List<Entry> sharedList = new CopyOnWriteArrayList<>();\n+    /*\n+     * The cache is used to avoid hammering on the first index of the entry list.\n+     * Caches can become poisoned (i.e.: containing entries that are in use) when\n+     * the release isn't done by the acquiring thread or when the entry pool is\n+     * undersized compared to the load applied on it.\n+     * When an entry can't be found in the cache, the global list is iterated\n+     * normally so the cache has no visible effect besides performance.\n+     */\n+    private final ThreadLocal<List<Entry>> cache;\n+    private final Lock reservationLock = new ReentrantLock();\n+    private final int maxEntries;\n+    private final int cacheSize;\n+    private volatile boolean closed;\n+    private volatile int maxMultiplex = 1;\n+    private volatile int maxUsageCount = -1;\n+\n+    /**\n+     * Construct a Pool with the specified thread-local cache size.\n+     *\n+     * @param maxEntries the maximum amount of entries that the pool will accept.\n+     * @param cacheSize the thread-local cache size. A value less than 1 means the cache is disabled.\n+     */\n+    public Pool(int maxEntries, int cacheSize)\n+    {\n+        this.maxEntries = maxEntries;\n+        this.cacheSize = cacheSize;\n+        if (cacheSize > 0)\n+            this.cache = ThreadLocal.withInitial(() -> new ArrayList<Entry>(cacheSize));\n+        else\n+            this.cache = null;\n+    }\n+\n+    public int getMaxEntries()\n+    {\n+        return maxEntries;\n+    }\n+\n+    public int getMaxMultiplex()\n+    {\n+        return maxMultiplex;\n+    }\n+\n+    public final void setMaxMultiplex(int maxMultiplex)\n+    {\n+        if (maxMultiplex < 1)\n+            throw new IllegalArgumentException(\"Max multiplex must be >= 1\");\n+        this.maxMultiplex = maxMultiplex;\n+    }\n+\n+    public int getMaxUsageCount()\n+    {\n+        return maxUsageCount;\n+    }\n+\n+    public final void setMaxUsageCount(int maxUsageCount)\n+    {\n+        if (maxUsageCount == 0)\n+            throw new IllegalArgumentException(\"Max usage count must be != 0\");\n+        this.maxUsageCount = maxUsageCount;\n+    }\n+\n+    /**\n+     * Create a new disabled slot into the pool. The returned entry\n+     * won't be acquirable as long as {@link Entry#enable(Object)}\n+     * has not been called.\n+     *\n+     * @param maxReservations the max desired number of reserved entries,\n+     * or a negative number to always trigger the reservation of a new entry.\n+     * @return a disabled entry that is contained in the pool,\n+     * or null if the pool is closed or if the pool already contains\n+     * {@link #getMaxEntries()} entries.\n+     */\n+    public Entry reserve(int maxReservations)\n+    {\n+        reservationLock.lock();\n+        try\n+        {\n+            if (maxReservations >= 0)\n+            {\n+                long pending = sharedList.stream().filter(entry -> entry.getPooled() == null).count();\n+                if (pending >= maxReservations)\n+                    return null;\n+            }\n+\n+            if (!closed && sharedList.size() < maxEntries)\n+            {\n+                Entry entry = new Entry();\n+                sharedList.add(entry);\n+                return entry;\n+            }\n+            return null;\n+        }\n+        finally\n+        {\n+            reservationLock.unlock();\n+        }\n+    }\n+\n+    /**\n+     * Acquire the entry from the pool at the specified index. This method bypasses the thread-local mechanism.\n+     *\n+     * @param idx the index of the entry to acquire.\n+     * @return the specified entry or null if there is none at the specified index or if it is not available.\n+     */\n+    public Entry acquireAt(int idx)\n+    {\n+        if (closed)\n+            return null;\n+\n+        try\n+        {\n+            Entry entry = sharedList.get(idx);\n+            if (entry.tryAcquire())\n+                return entry;\n+        }\n+        catch (IndexOutOfBoundsException e)\n+        {\n+            // no entry at that index\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Acquire an entry from the pool.\n+     *\n+     * @return an entry from the pool or null if none is available.\n+     */\n+    public Entry acquire()\n+    {\n+        if (closed)\n+            return null;\n+\n+        // first check the thread-local cache\n+        if (cache != null)\n+        {\n+            List<Entry> cachedList = cache.get();\n+            while (!cachedList.isEmpty())\n+            {\n+                Entry cachedEntry = cachedList.remove(cachedList.size() - 1);\n+                if (cachedEntry.tryAcquire())\n+                    return cachedEntry;\n+            }\n+        }\n+\n+        // then iterate the shared list\n+        for (Entry entry : sharedList)\n+        {\n+            if (entry.tryAcquire())\n+                return entry;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * This method will return an acquired object to the pool. Objects\n+     * that are acquired from the pool but never released will result\n+     * in a memory leak.\n+     *\n+     * @param entry the value to return to the pool\n+     * @return false if the pooled entry should be disposed of\n+     * @throws NullPointerException if value is null\n+     */\n+    public boolean release(Entry entry)\n+    {\n+        if (closed)\n+            return false;\n+\n+        // first mark it as unused\n+        boolean reusable = entry.tryRelease();\n+\n+        // then cache the released entry\n+        if (cache != null && reusable)\n+        {\n+            List<Entry> cachedList = cache.get();\n+            if (cachedList.size() < cacheSize)\n+                cachedList.add(entry);\n+        }\n+        return reusable;\n+    }\n+\n+    public boolean isClosed()\n+    {\n+        return closed;\n+    }\n+\n+    @Override\n+    public void close()\n+    {\n+        reservationLock.lock();\n+        try\n+        {\n+            closed = true;\n+\n+            // clear the shared list and close its entries\n+            for (Entry entry : sharedList)\n+            {\n+                if (entry.tryRemove() && entry.pooled instanceof Closeable)\n+                {\n+                    try\n+                    {\n+                        ((Closeable)entry.pooled).close();\n+                    }\n+                    catch (IOException e)\n+                    {\n+                        LOGGER.warn(\"Error closing entry {}\", entry, e);\n+                    }\n+                }\n+            }\n+            sharedList.clear();\n+        }\n+        finally\n+        {\n+            reservationLock.unlock();\n+        }\n+    }\n+\n+    /**\n+     * Remove a value from the pool.\n+     *\n+     * @param entry the value to remove\n+     * @return true if the entry was removed, false otherwise\n+     */\n+    public boolean remove(Entry entry)\n+    {\n+        if (closed)\n+            return false;\n+\n+        if (!entry.tryRemove())\n+        {\n+            if (LOGGER.isDebugEnabled())\n+                LOGGER.debug(\"Attempt to remove an object from the pool that is still in use: {}\", entry);\n+            return false;\n+        }\n+\n+        boolean removed = sharedList.remove(entry);\n+        if (!removed)\n+        {\n+            if (LOGGER.isDebugEnabled())\n+                LOGGER.debug(\"Attempt to remove an object from the pool that does not exist: {}\", entry);\n+        }\n+\n+        return removed;\n+    }\n+\n+    public int size()\n+    {\n+        return sharedList.size();\n+    }\n+\n+    public Collection<Entry> values()\n+    {\n+        return Collections.unmodifiableCollection(sharedList);\n+    }\n+\n+    @Override\n+    public void dump(Appendable out, String indent) throws IOException\n+    {\n+        Dumpable.dumpObjects(out, indent, this);\n+    }\n+\n+    @Override\n+    public String toString()\n+    {\n+        return getClass().getSimpleName() + \" size=\" + sharedList.size() + \" closed=\" + closed + \" entries=\" + sharedList;\n+    }\n+\n+    public class Entry\n+    {\n+        // hi: positive=open/maxUsage counter,negative=closed lo: multiplexing counter\n+        private final AtomicBiInteger state;\n+        private volatile T pooled;\n+\n+        public Entry()\n+        {\n+            this.state = new AtomicBiInteger(-1, 0);\n+        }\n+\n+        public T getPooled()\n+        {\n+            return pooled;\n+        }\n+\n+        public void enable(T pooled)\n+        {\n+            if (!isClosed())\n+                throw new IllegalStateException(\"Open entries cannot be enabled : \" + this);\n+            Objects.requireNonNull(pooled);\n+            this.pooled = pooled;\n+            state.set(0, 0);\n+        }\n+\n+        /**\n+         * @return true if the pooled object was acquired.\n+         */\n+        public boolean tryAcquire()\n+        {\n+            while (true)\n+            {\n+                long encoded = state.get();\n+                int usageCount = AtomicBiInteger.getHi(encoded);\n+                boolean closed = usageCount < 0;\n+                int multiplexingCount = AtomicBiInteger.getLo(encoded);\n+                int currentMaxUsageCount = maxUsageCount;\n+                if (closed || multiplexingCount >= maxMultiplex || (currentMaxUsageCount > 0 && usageCount >= currentMaxUsageCount))\n+                    return false;\n+\n+                if (state.compareAndSet(encoded, usageCount + 1, multiplexingCount + 1))\n+                    return true;\n+            }\n+        }\n+\n+        /**\n+         * @return false if the pooled object should be disposed of.\n+         */\n+        public boolean tryRelease()\n+        {\n+            int newMultiplexingCount;\n+            int usageCount;\n+            while (true)\n+            {\n+                long encoded = state.get();\n+                usageCount = AtomicBiInteger.getHi(encoded);\n+                boolean closed = usageCount < 0;\n+                if (closed)\n+                    return false;\n+\n+                newMultiplexingCount = AtomicBiInteger.getLo(encoded) - 1;\n+                if (newMultiplexingCount < 0)\n+                {\n+                    if (LOGGER.isDebugEnabled())\n+                        LOGGER.debug(\"try release failed on negative multiplexing count : {}\", newMultiplexingCount);\n+                    return false;\n+                }\n+\n+                if (state.compareAndSet(encoded, usageCount, newMultiplexingCount))\n+                    break;\n+            }\n+\n+            int currentMaxUsageCount = maxUsageCount;\n+            boolean overUsed = currentMaxUsageCount > 0 && usageCount >= currentMaxUsageCount;\n+            return !(overUsed && newMultiplexingCount == 0);\n+        }\n+\n+        /**\n+         * @return true if the pooled object was marked as removed.\n+         */\n+        public boolean tryRemove()\n+        {\n+            boolean removed;\n+            int lastUsageCount = state.getHi();\n+            while (true)\n+            {\n+                long encoded = state.get();\n+                int usageCount = AtomicBiInteger.getHi(encoded);\n+                int currentMaxUsageCount = maxUsageCount;\n+                if (currentMaxUsageCount > 0 && usageCount >= currentMaxUsageCount)\n+                {\n+                    removed = state.compareAndSetHi(usageCount, -1);\n+                }\n+                else\n+                {\n+                    removed = state.compareAndSet(usageCount, -1, 1, 0);\n+                    if (!removed)\n+                        removed = state.compareAndSet(usageCount, -1, 0, 0);\n+                }\n+                if (removed || lastUsageCount == usageCount)\n+                    break;\n+                lastUsageCount = state.getHi();\n+            }\n+            return removed;", "originalCommit": "e843914f9c39b9b3745077053ee7bd198411b2c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzA1NDIyNw==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r463054227", "bodyText": "Summary of our review: the state should be CAS'ed to hi: -1, lo: Math.max(multiplexCount - 1).", "author": "lorban", "createdAt": "2020-07-30T14:50:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU0MjEyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU0NDc2MQ==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r462544761", "bodyText": "This would return -1, do we want that?", "author": "sbordet", "createdAt": "2020-07-29T19:44:52Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -0,0 +1,460 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.util;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.eclipse.jetty.util.component.Dumpable;\n+import org.eclipse.jetty.util.log.Log;\n+import org.eclipse.jetty.util.log.Logger;\n+\n+/**\n+ * A fast container of poolable objects, with optional support for\n+ * multiplexing, max usage count and thread-local caching.\n+ * <p>\n+ * The thread-local caching mechanism is about remembering up to N previously\n+ * used entries into a thread-local single-threaded collection.\n+ * When that collection is not empty, its entries are removed one by one\n+ * during acquisition until an entry that can be acquired is found.\n+ * This can greatly speed up acquisition when both the acquisition and the\n+ * release of the entries is done on the same thread as this avoids iterating\n+ * the global, thread-safe collection of entries.\n+ * @param <T>\n+ */\n+public class Pool<T> implements AutoCloseable, Dumpable\n+{\n+    private static final Logger LOGGER = Log.getLogger(Pool.class);\n+\n+    private final List<Entry> sharedList = new CopyOnWriteArrayList<>();\n+    /*\n+     * The cache is used to avoid hammering on the first index of the entry list.\n+     * Caches can become poisoned (i.e.: containing entries that are in use) when\n+     * the release isn't done by the acquiring thread or when the entry pool is\n+     * undersized compared to the load applied on it.\n+     * When an entry can't be found in the cache, the global list is iterated\n+     * normally so the cache has no visible effect besides performance.\n+     */\n+    private final ThreadLocal<List<Entry>> cache;\n+    private final Lock reservationLock = new ReentrantLock();\n+    private final int maxEntries;\n+    private final int cacheSize;\n+    private volatile boolean closed;\n+    private volatile int maxMultiplex = 1;\n+    private volatile int maxUsageCount = -1;\n+\n+    /**\n+     * Construct a Pool with the specified thread-local cache size.\n+     *\n+     * @param maxEntries the maximum amount of entries that the pool will accept.\n+     * @param cacheSize the thread-local cache size. A value less than 1 means the cache is disabled.\n+     */\n+    public Pool(int maxEntries, int cacheSize)\n+    {\n+        this.maxEntries = maxEntries;\n+        this.cacheSize = cacheSize;\n+        if (cacheSize > 0)\n+            this.cache = ThreadLocal.withInitial(() -> new ArrayList<Entry>(cacheSize));\n+        else\n+            this.cache = null;\n+    }\n+\n+    public int getMaxEntries()\n+    {\n+        return maxEntries;\n+    }\n+\n+    public int getMaxMultiplex()\n+    {\n+        return maxMultiplex;\n+    }\n+\n+    public final void setMaxMultiplex(int maxMultiplex)\n+    {\n+        if (maxMultiplex < 1)\n+            throw new IllegalArgumentException(\"Max multiplex must be >= 1\");\n+        this.maxMultiplex = maxMultiplex;\n+    }\n+\n+    public int getMaxUsageCount()\n+    {\n+        return maxUsageCount;\n+    }\n+\n+    public final void setMaxUsageCount(int maxUsageCount)\n+    {\n+        if (maxUsageCount == 0)\n+            throw new IllegalArgumentException(\"Max usage count must be != 0\");\n+        this.maxUsageCount = maxUsageCount;\n+    }\n+\n+    /**\n+     * Create a new disabled slot into the pool. The returned entry\n+     * won't be acquirable as long as {@link Entry#enable(Object)}\n+     * has not been called.\n+     *\n+     * @param maxReservations the max desired number of reserved entries,\n+     * or a negative number to always trigger the reservation of a new entry.\n+     * @return a disabled entry that is contained in the pool,\n+     * or null if the pool is closed or if the pool already contains\n+     * {@link #getMaxEntries()} entries.\n+     */\n+    public Entry reserve(int maxReservations)\n+    {\n+        reservationLock.lock();\n+        try\n+        {\n+            if (maxReservations >= 0)\n+            {\n+                long pending = sharedList.stream().filter(entry -> entry.getPooled() == null).count();\n+                if (pending >= maxReservations)\n+                    return null;\n+            }\n+\n+            if (!closed && sharedList.size() < maxEntries)\n+            {\n+                Entry entry = new Entry();\n+                sharedList.add(entry);\n+                return entry;\n+            }\n+            return null;\n+        }\n+        finally\n+        {\n+            reservationLock.unlock();\n+        }\n+    }\n+\n+    /**\n+     * Acquire the entry from the pool at the specified index. This method bypasses the thread-local mechanism.\n+     *\n+     * @param idx the index of the entry to acquire.\n+     * @return the specified entry or null if there is none at the specified index or if it is not available.\n+     */\n+    public Entry acquireAt(int idx)\n+    {\n+        if (closed)\n+            return null;\n+\n+        try\n+        {\n+            Entry entry = sharedList.get(idx);\n+            if (entry.tryAcquire())\n+                return entry;\n+        }\n+        catch (IndexOutOfBoundsException e)\n+        {\n+            // no entry at that index\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Acquire an entry from the pool.\n+     *\n+     * @return an entry from the pool or null if none is available.\n+     */\n+    public Entry acquire()\n+    {\n+        if (closed)\n+            return null;\n+\n+        // first check the thread-local cache\n+        if (cache != null)\n+        {\n+            List<Entry> cachedList = cache.get();\n+            while (!cachedList.isEmpty())\n+            {\n+                Entry cachedEntry = cachedList.remove(cachedList.size() - 1);\n+                if (cachedEntry.tryAcquire())\n+                    return cachedEntry;\n+            }\n+        }\n+\n+        // then iterate the shared list\n+        for (Entry entry : sharedList)\n+        {\n+            if (entry.tryAcquire())\n+                return entry;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * This method will return an acquired object to the pool. Objects\n+     * that are acquired from the pool but never released will result\n+     * in a memory leak.\n+     *\n+     * @param entry the value to return to the pool\n+     * @return false if the pooled entry should be disposed of\n+     * @throws NullPointerException if value is null\n+     */\n+    public boolean release(Entry entry)\n+    {\n+        if (closed)\n+            return false;\n+\n+        // first mark it as unused\n+        boolean reusable = entry.tryRelease();\n+\n+        // then cache the released entry\n+        if (cache != null && reusable)\n+        {\n+            List<Entry> cachedList = cache.get();\n+            if (cachedList.size() < cacheSize)\n+                cachedList.add(entry);\n+        }\n+        return reusable;\n+    }\n+\n+    public boolean isClosed()\n+    {\n+        return closed;\n+    }\n+\n+    @Override\n+    public void close()\n+    {\n+        reservationLock.lock();\n+        try\n+        {\n+            closed = true;\n+\n+            // clear the shared list and close its entries\n+            for (Entry entry : sharedList)\n+            {\n+                if (entry.tryRemove() && entry.pooled instanceof Closeable)\n+                {\n+                    try\n+                    {\n+                        ((Closeable)entry.pooled).close();\n+                    }\n+                    catch (IOException e)\n+                    {\n+                        LOGGER.warn(\"Error closing entry {}\", entry, e);\n+                    }\n+                }\n+            }\n+            sharedList.clear();\n+        }\n+        finally\n+        {\n+            reservationLock.unlock();\n+        }\n+    }\n+\n+    /**\n+     * Remove a value from the pool.\n+     *\n+     * @param entry the value to remove\n+     * @return true if the entry was removed, false otherwise\n+     */\n+    public boolean remove(Entry entry)\n+    {\n+        if (closed)\n+            return false;\n+\n+        if (!entry.tryRemove())\n+        {\n+            if (LOGGER.isDebugEnabled())\n+                LOGGER.debug(\"Attempt to remove an object from the pool that is still in use: {}\", entry);\n+            return false;\n+        }\n+\n+        boolean removed = sharedList.remove(entry);\n+        if (!removed)\n+        {\n+            if (LOGGER.isDebugEnabled())\n+                LOGGER.debug(\"Attempt to remove an object from the pool that does not exist: {}\", entry);\n+        }\n+\n+        return removed;\n+    }\n+\n+    public int size()\n+    {\n+        return sharedList.size();\n+    }\n+\n+    public Collection<Entry> values()\n+    {\n+        return Collections.unmodifiableCollection(sharedList);\n+    }\n+\n+    @Override\n+    public void dump(Appendable out, String indent) throws IOException\n+    {\n+        Dumpable.dumpObjects(out, indent, this);\n+    }\n+\n+    @Override\n+    public String toString()\n+    {\n+        return getClass().getSimpleName() + \" size=\" + sharedList.size() + \" closed=\" + closed + \" entries=\" + sharedList;\n+    }\n+\n+    public class Entry\n+    {\n+        // hi: positive=open/maxUsage counter,negative=closed lo: multiplexing counter\n+        private final AtomicBiInteger state;\n+        private volatile T pooled;\n+\n+        public Entry()\n+        {\n+            this.state = new AtomicBiInteger(-1, 0);\n+        }\n+\n+        public T getPooled()\n+        {\n+            return pooled;\n+        }\n+\n+        public void enable(T pooled)\n+        {\n+            if (!isClosed())\n+                throw new IllegalStateException(\"Open entries cannot be enabled : \" + this);\n+            Objects.requireNonNull(pooled);\n+            this.pooled = pooled;\n+            state.set(0, 0);\n+        }\n+\n+        /**\n+         * @return true if the pooled object was acquired.\n+         */\n+        public boolean tryAcquire()\n+        {\n+            while (true)\n+            {\n+                long encoded = state.get();\n+                int usageCount = AtomicBiInteger.getHi(encoded);\n+                boolean closed = usageCount < 0;\n+                int multiplexingCount = AtomicBiInteger.getLo(encoded);\n+                int currentMaxUsageCount = maxUsageCount;\n+                if (closed || multiplexingCount >= maxMultiplex || (currentMaxUsageCount > 0 && usageCount >= currentMaxUsageCount))\n+                    return false;\n+\n+                if (state.compareAndSet(encoded, usageCount + 1, multiplexingCount + 1))\n+                    return true;\n+            }\n+        }\n+\n+        /**\n+         * @return false if the pooled object should be disposed of.\n+         */\n+        public boolean tryRelease()\n+        {\n+            int newMultiplexingCount;\n+            int usageCount;\n+            while (true)\n+            {\n+                long encoded = state.get();\n+                usageCount = AtomicBiInteger.getHi(encoded);\n+                boolean closed = usageCount < 0;\n+                if (closed)\n+                    return false;\n+\n+                newMultiplexingCount = AtomicBiInteger.getLo(encoded) - 1;\n+                if (newMultiplexingCount < 0)\n+                {\n+                    if (LOGGER.isDebugEnabled())\n+                        LOGGER.debug(\"try release failed on negative multiplexing count : {}\", newMultiplexingCount);\n+                    return false;\n+                }\n+\n+                if (state.compareAndSet(encoded, usageCount, newMultiplexingCount))\n+                    break;\n+            }\n+\n+            int currentMaxUsageCount = maxUsageCount;\n+            boolean overUsed = currentMaxUsageCount > 0 && usageCount >= currentMaxUsageCount;\n+            return !(overUsed && newMultiplexingCount == 0);\n+        }\n+\n+        /**\n+         * @return true if the pooled object was marked as removed.\n+         */\n+        public boolean tryRemove()\n+        {\n+            boolean removed;\n+            int lastUsageCount = state.getHi();\n+            while (true)\n+            {\n+                long encoded = state.get();\n+                int usageCount = AtomicBiInteger.getHi(encoded);\n+                int currentMaxUsageCount = maxUsageCount;\n+                if (currentMaxUsageCount > 0 && usageCount >= currentMaxUsageCount)\n+                {\n+                    removed = state.compareAndSetHi(usageCount, -1);\n+                }\n+                else\n+                {\n+                    removed = state.compareAndSet(usageCount, -1, 1, 0);\n+                    if (!removed)\n+                        removed = state.compareAndSet(usageCount, -1, 0, 0);\n+                }\n+                if (removed || lastUsageCount == usageCount)\n+                    break;\n+                lastUsageCount = state.getHi();\n+            }\n+            return removed;\n+        }\n+\n+        public boolean isClosed()\n+        {\n+            return state.getHi() < 0;\n+        }\n+\n+        public boolean isIdle()\n+        {\n+            long encoded = state.get();\n+            if (AtomicBiInteger.getHi(encoded) < 0)\n+                return false;\n+            return AtomicBiInteger.getLo(encoded) == 0;\n+        }\n+\n+        public boolean isInUse()\n+        {\n+            long encoded = state.get();\n+            if (AtomicBiInteger.getHi(encoded) < 0)\n+                return false;\n+            return AtomicBiInteger.getLo(encoded) > 0;\n+        }\n+\n+        public int getUsageCount()\n+        {\n+            return state.getHi();", "originalCommit": "e843914f9c39b9b3745077053ee7bd198411b2c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzA1MzAxNw==", "url": "https://github.com/eclipse/jetty.project/pull/4975#discussion_r463053017", "bodyText": "No, we don't. This should never return a value < 0. Let me fix this.", "author": "lorban", "createdAt": "2020-07-30T14:48:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU0NDc2MQ=="}], "type": "inlineReview"}, {"oid": "7a2d5ab2302ca9a6a277fac7cce33570543a6a33", "url": "https://github.com/eclipse/jetty.project/commit/7a2d5ab2302ca9a6a277fac7cce33570543a6a33", "message": "Re-implement HTTP connection pooling with a non-queuing algorithm\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-07-30T15:20:51Z", "type": "forcePushed"}, {"oid": "cb3722bd495bde3a92b17b2d81e1269b170da4f5", "url": "https://github.com/eclipse/jetty.project/commit/cb3722bd495bde3a92b17b2d81e1269b170da4f5", "message": "Re-implement HTTP connection pooling with a non-queuing algorithm\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-07-31T07:49:15Z", "type": "forcePushed"}, {"oid": "02cc00d432cd7b595442e7d2acb0d45e9bd62128", "url": "https://github.com/eclipse/jetty.project/commit/02cc00d432cd7b595442e7d2acb0d45e9bd62128", "message": "Re-implement HTTP connection pooling with a non-queuing algorithm\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-07-31T07:58:38Z", "type": "forcePushed"}, {"oid": "f663697445ad5cf1e2df29816747a010cf987821", "url": "https://github.com/eclipse/jetty.project/commit/f663697445ad5cf1e2df29816747a010cf987821", "message": "Re-implement HTTP connection pooling with a non-queuing algorithm\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-07-31T08:00:54Z", "type": "forcePushed"}, {"oid": "e9dad975e66d84fd128d2b8b6c91d901aa7a021d", "url": "https://github.com/eclipse/jetty.project/commit/e9dad975e66d84fd128d2b8b6c91d901aa7a021d", "message": "Re-implement HTTP connection pooling with a non-queuing algorithm\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-07-31T08:36:43Z", "type": "commit"}, {"oid": "e9dad975e66d84fd128d2b8b6c91d901aa7a021d", "url": "https://github.com/eclipse/jetty.project/commit/e9dad975e66d84fd128d2b8b6c91d901aa7a021d", "message": "Re-implement HTTP connection pooling with a non-queuing algorithm\n\nSigned-off-by: Ludovic Orban <lorban@bitronix.be>", "committedDate": "2020-07-31T08:36:43Z", "type": "forcePushed"}]}