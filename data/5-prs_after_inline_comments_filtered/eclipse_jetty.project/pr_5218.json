{"pr_number": 5218, "pr_title": "Alternative Pool Strategies", "pr_createdAt": "2020-09-01T10:16:27Z", "pr_url": "https://github.com/eclipse/jetty.project/pull/5218", "timeline": [{"oid": "b63c59d511e274908808ac3b338c40149f074864", "url": "https://github.com/eclipse/jetty.project/commit/b63c59d511e274908808ac3b338c40149f074864", "message": "Speculative idea to make a pluggable Pool strategy\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-09-01T10:14:49Z", "type": "commit"}, {"oid": "410fe53ea19e7b0a66e010da66672936326cfc55", "url": "https://github.com/eclipse/jetty.project/commit/410fe53ea19e7b0a66e010da66672936326cfc55", "message": "Speculative idea to make a pluggable Pool strategy\n\n + javadoc\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-09-01T13:43:34Z", "type": "commit"}, {"oid": "27d31dedb26cd625b3919b31efd7043c78abf226", "url": "https://github.com/eclipse/jetty.project/commit/27d31dedb26cd625b3919b31efd7043c78abf226", "message": "Speculative idea to make a pluggable Pool strategy\n\n + Added a ThreadLocalStrategy for a single cached item\n + Tell strategies about newly reserved entries\n + Fixed multiplexing test that was dependent on the impl of the cache\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-09-01T14:13:17Z", "type": "commit"}, {"oid": "91df8dad0945b6951ff30629df4e86e739a02d85", "url": "https://github.com/eclipse/jetty.project/commit/91df8dad0945b6951ff30629df4e86e739a02d85", "message": "Speculative idea to make a pluggable Pool strategy\n\n + added tests\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-09-01T15:38:54Z", "type": "commit"}, {"oid": "db086a513502d36bde7d1d886eaea7dca3e53721", "url": "https://github.com/eclipse/jetty.project/commit/db086a513502d36bde7d1d886eaea7dca3e53721", "message": "Feedback from review\n\n + Don't have a fallback iteration, instead make a SearchStrategy and DualStrategy", "committedDate": "2020-09-02T11:53:56Z", "type": "commit"}, {"oid": "6ab7bd726b0e2412a5c1497348473dbac98d64a3", "url": "https://github.com/eclipse/jetty.project/commit/6ab7bd726b0e2412a5c1497348473dbac98d64a3", "message": "Feedback from review\n\n + split strategies into Cache and Strategies", "committedDate": "2020-09-02T12:34:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA0NDU0NA==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r482044544", "bodyText": "Why a release() inside reserve()?", "author": "sbordet", "createdAt": "2020-09-02T12:53:16Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -165,7 +201,8 @@ public Entry reserve(int allotment)\n             pending.incrementAndGet();\n \n             Entry entry = new Entry();\n-            sharedList.add(entry);\n+            entries.add(entry);\n+            strategy.released(entries, entry, true);", "originalCommit": "6ab7bd726b0e2412a5c1497348473dbac98d64a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA0NzMzMw==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r482047333", "bodyText": "Just release() and implementations have to call entry.tryRelease() so that we're symmetric with acquire() above?", "author": "sbordet", "createdAt": "2020-09-02T12:57:31Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -559,4 +574,222 @@ public String toString()\n                 pooled);\n         }\n     }\n+\n+    /** A pluggable strategy to optimize pool acquisition\n+     * @param <T> The type of the items in the pool\n+     */\n+    public interface Cache<T>\n+    {\n+        /** Acquire an entry\n+         * @param entries The list of entries known to the pool. This may be concurrently modified.\n+         * @return An acquired entry or null if none can be acquired by this strategy\n+         */\n+        Pool<T>.Entry acquire(List<Pool<T>.Entry> entries);\n+\n+        /**\n+         * Notification an entry has been release.  The notification comes after the entry\n+         * has been put back in the pool and it may already have been reacquired before or during this call.\n+         * @param entries The list of entries known to the pool. This may be concurrently modified.\n+         * @param entry The entry to be release\n+         * @param reusable true if the entry is reusable and will be put back in the pool.\n+         */\n+        default void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)", "originalCommit": "6ab7bd726b0e2412a5c1497348473dbac98d64a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA1NTkxNA==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r482055914", "bodyText": "I second @sbordet; and wouldn't the following signature be better?\nvoid release(Pool<T>.Entry entry);\nwithout a list of entries (I can't see why it would be needed) and no default impl?", "author": "lorban", "createdAt": "2020-09-02T13:10:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA0NzMzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA0NzcyMg==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r482047722", "bodyText": "Is not this class missing a remove() method?", "author": "sbordet", "createdAt": "2020-09-02T12:58:08Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -559,4 +574,222 @@ public String toString()\n                 pooled);\n         }\n     }\n+\n+    /** A pluggable strategy to optimize pool acquisition\n+     * @param <T> The type of the items in the pool\n+     */\n+    public interface Cache<T>\n+    {\n+        /** Acquire an entry\n+         * @param entries The list of entries known to the pool. This may be concurrently modified.\n+         * @return An acquired entry or null if none can be acquired by this strategy\n+         */\n+        Pool<T>.Entry acquire(List<Pool<T>.Entry> entries);\n+\n+        /**\n+         * Notification an entry has been release.  The notification comes after the entry\n+         * has been put back in the pool and it may already have been reacquired before or during this call.\n+         * @param entries The list of entries known to the pool. This may be concurrently modified.\n+         * @param entry The entry to be release\n+         * @param reusable true if the entry is reusable and will be put back in the pool.\n+         */\n+        default void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n+        {\n+        }\n+    }", "originalCommit": "6ab7bd726b0e2412a5c1497348473dbac98d64a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA1MjMwNg==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r482052306", "bodyText": "LinearSearchStrategy?", "author": "lorban", "createdAt": "2020-09-02T13:05:07Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -559,4 +574,222 @@ public String toString()\n                 pooled);\n         }\n     }\n+\n+    /** A pluggable strategy to optimize pool acquisition\n+     * @param <T> The type of the items in the pool\n+     */\n+    public interface Cache<T>\n+    {\n+        /** Acquire an entry\n+         * @param entries The list of entries known to the pool. This may be concurrently modified.\n+         * @return An acquired entry or null if none can be acquired by this strategy\n+         */\n+        Pool<T>.Entry acquire(List<Pool<T>.Entry> entries);\n+\n+        /**\n+         * Notification an entry has been release.  The notification comes after the entry\n+         * has been put back in the pool and it may already have been reacquired before or during this call.\n+         * @param entries The list of entries known to the pool. This may be concurrently modified.\n+         * @param entry The entry to be release\n+         * @param reusable true if the entry is reusable and will be put back in the pool.\n+         */\n+        default void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n+        {\n+        }\n+    }\n+\n+    public interface Strategy<T> extends Cache<T>\n+    {\n+    }\n+\n+    public static class CacheStrategy<T> implements Strategy<T>\n+    {\n+        final Cache<T> cache;\n+        final Strategy<T> strategy;\n+\n+        public CacheStrategy(Cache<T> cache, Strategy<T> planB)\n+        {\n+            Objects.requireNonNull(cache);\n+            Objects.requireNonNull(planB);\n+            this.cache = cache;\n+            this.strategy = planB;\n+        }\n+\n+        @Override\n+        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n+        {\n+            Pool<T>.Entry entry = cache.acquire(entries);\n+            return entry == null ? strategy.acquire(entries) : entry;\n+        }\n+\n+        @Override\n+        public void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n+        {\n+            cache.released(entries, entry, reusable);\n+            strategy.released(entries, entry, reusable);\n+        }\n+    }\n+\n+    public static class SearchStrategy<T> implements Strategy<T>", "originalCommit": "6ab7bd726b0e2412a5c1497348473dbac98d64a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA1Mjc1MA==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r482052750", "bodyText": "private final?", "author": "lorban", "createdAt": "2020-09-02T13:05:49Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -559,4 +574,222 @@ public String toString()\n                 pooled);\n         }\n     }\n+\n+    /** A pluggable strategy to optimize pool acquisition\n+     * @param <T> The type of the items in the pool\n+     */\n+    public interface Cache<T>\n+    {\n+        /** Acquire an entry\n+         * @param entries The list of entries known to the pool. This may be concurrently modified.\n+         * @return An acquired entry or null if none can be acquired by this strategy\n+         */\n+        Pool<T>.Entry acquire(List<Pool<T>.Entry> entries);\n+\n+        /**\n+         * Notification an entry has been release.  The notification comes after the entry\n+         * has been put back in the pool and it may already have been reacquired before or during this call.\n+         * @param entries The list of entries known to the pool. This may be concurrently modified.\n+         * @param entry The entry to be release\n+         * @param reusable true if the entry is reusable and will be put back in the pool.\n+         */\n+        default void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n+        {\n+        }\n+    }\n+\n+    public interface Strategy<T> extends Cache<T>\n+    {\n+    }\n+\n+    public static class CacheStrategy<T> implements Strategy<T>\n+    {\n+        final Cache<T> cache;\n+        final Strategy<T> strategy;\n+\n+        public CacheStrategy(Cache<T> cache, Strategy<T> planB)\n+        {\n+            Objects.requireNonNull(cache);\n+            Objects.requireNonNull(planB);\n+            this.cache = cache;\n+            this.strategy = planB;\n+        }\n+\n+        @Override\n+        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n+        {\n+            Pool<T>.Entry entry = cache.acquire(entries);\n+            return entry == null ? strategy.acquire(entries) : entry;\n+        }\n+\n+        @Override\n+        public void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n+        {\n+            cache.released(entries, entry, reusable);\n+            strategy.released(entries, entry, reusable);\n+        }\n+    }\n+\n+    public static class SearchStrategy<T> implements Strategy<T>\n+    {\n+        @Override\n+        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n+        {\n+            for (Pool<T>.Entry e : entries)\n+            {\n+                if (e.tryAcquire())\n+                    return e;\n+            }\n+            return null;\n+        }\n+    }\n+\n+    public static class ThreadLocalCache<T> implements Cache<T>\n+    {\n+        private final ThreadLocal<Pool<T>.Entry> last;\n+\n+        ThreadLocalCache()\n+        {\n+            last = new ThreadLocal<>();\n+        }\n+\n+        @Override\n+        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n+        {\n+            Pool<T>.Entry entry = last.get();\n+            if (entry != null && entry.tryAcquire())\n+                return entry;\n+            return null;\n+        }\n+\n+        @Override\n+        public void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n+        {\n+            if (reusable)\n+                last.set(entry);\n+        }\n+    }\n+\n+    public static class ThreadLocalListCache<T> implements Cache<T>\n+    {\n+        private final ThreadLocal<List<Pool<T>.Entry>> cache;\n+        private final int cacheSize;\n+\n+        ThreadLocalListCache(int size)\n+        {\n+            this.cacheSize = size;\n+            this.cache = ThreadLocal.withInitial(() -> new ArrayList<>(cacheSize));\n+        }\n+\n+        @Override\n+        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n+        {\n+            List<Pool<T>.Entry> cachedList = cache.get();\n+            while (!cachedList.isEmpty())\n+            {\n+                Pool<T>.Entry cachedEntry = cachedList.remove(cachedList.size() - 1);\n+                if (cachedEntry.tryAcquire())\n+                    return cachedEntry;\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n+        {\n+            if (reusable)\n+            {\n+                List<Pool<T>.Entry> cachedList = cache.get();\n+                if (cachedList.size() < cacheSize)\n+                    cachedList.add(entry);\n+            }\n+        }\n+    }\n+\n+    private abstract static class IndexedCached<T> implements Cache<T>\n+    {\n+        @Override\n+        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n+        {\n+            int size = entries.size();\n+            if (size == 0)\n+                return null;\n+            int i = nextIndex(size);\n+            try\n+            {\n+                Pool<T>.Entry entry = entries.get(i);\n+                if (entry != null && entry.tryAcquire())\n+                    return entry;\n+            }\n+            catch (Exception e)\n+            {\n+                // Could be out of bounds\n+                LOGGER.ignore(e);\n+            }\n+            return null;\n+        }\n+\n+        protected abstract int nextIndex(int size);\n+    }\n+\n+    public static class RandomCache<T> extends IndexedCached<T>\n+    {\n+        @Override\n+        protected int nextIndex(int size)\n+        {\n+            return ThreadLocalRandom.current().nextInt(size);\n+        }\n+    }\n+\n+    public static class RoundRobinCache<T> extends IndexedCached<T>\n+    {\n+        AtomicInteger index = new AtomicInteger();", "originalCommit": "6ab7bd726b0e2412a5c1497348473dbac98d64a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA1MzAwOQ==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r482053009", "bodyText": "do we want to keep this strategy?", "author": "lorban", "createdAt": "2020-09-02T13:06:13Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -559,4 +574,222 @@ public String toString()\n                 pooled);\n         }\n     }\n+\n+    /** A pluggable strategy to optimize pool acquisition\n+     * @param <T> The type of the items in the pool\n+     */\n+    public interface Cache<T>\n+    {\n+        /** Acquire an entry\n+         * @param entries The list of entries known to the pool. This may be concurrently modified.\n+         * @return An acquired entry or null if none can be acquired by this strategy\n+         */\n+        Pool<T>.Entry acquire(List<Pool<T>.Entry> entries);\n+\n+        /**\n+         * Notification an entry has been release.  The notification comes after the entry\n+         * has been put back in the pool and it may already have been reacquired before or during this call.\n+         * @param entries The list of entries known to the pool. This may be concurrently modified.\n+         * @param entry The entry to be release\n+         * @param reusable true if the entry is reusable and will be put back in the pool.\n+         */\n+        default void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n+        {\n+        }\n+    }\n+\n+    public interface Strategy<T> extends Cache<T>\n+    {\n+    }\n+\n+    public static class CacheStrategy<T> implements Strategy<T>\n+    {\n+        final Cache<T> cache;\n+        final Strategy<T> strategy;\n+\n+        public CacheStrategy(Cache<T> cache, Strategy<T> planB)\n+        {\n+            Objects.requireNonNull(cache);\n+            Objects.requireNonNull(planB);\n+            this.cache = cache;\n+            this.strategy = planB;\n+        }\n+\n+        @Override\n+        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n+        {\n+            Pool<T>.Entry entry = cache.acquire(entries);\n+            return entry == null ? strategy.acquire(entries) : entry;\n+        }\n+\n+        @Override\n+        public void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n+        {\n+            cache.released(entries, entry, reusable);\n+            strategy.released(entries, entry, reusable);\n+        }\n+    }\n+\n+    public static class SearchStrategy<T> implements Strategy<T>\n+    {\n+        @Override\n+        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n+        {\n+            for (Pool<T>.Entry e : entries)\n+            {\n+                if (e.tryAcquire())\n+                    return e;\n+            }\n+            return null;\n+        }\n+    }\n+\n+    public static class ThreadLocalCache<T> implements Cache<T>\n+    {\n+        private final ThreadLocal<Pool<T>.Entry> last;\n+\n+        ThreadLocalCache()\n+        {\n+            last = new ThreadLocal<>();\n+        }\n+\n+        @Override\n+        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n+        {\n+            Pool<T>.Entry entry = last.get();\n+            if (entry != null && entry.tryAcquire())\n+                return entry;\n+            return null;\n+        }\n+\n+        @Override\n+        public void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n+        {\n+            if (reusable)\n+                last.set(entry);\n+        }\n+    }\n+\n+    public static class ThreadLocalListCache<T> implements Cache<T>\n+    {\n+        private final ThreadLocal<List<Pool<T>.Entry>> cache;\n+        private final int cacheSize;\n+\n+        ThreadLocalListCache(int size)\n+        {\n+            this.cacheSize = size;\n+            this.cache = ThreadLocal.withInitial(() -> new ArrayList<>(cacheSize));\n+        }\n+\n+        @Override\n+        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n+        {\n+            List<Pool<T>.Entry> cachedList = cache.get();\n+            while (!cachedList.isEmpty())\n+            {\n+                Pool<T>.Entry cachedEntry = cachedList.remove(cachedList.size() - 1);\n+                if (cachedEntry.tryAcquire())\n+                    return cachedEntry;\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n+        {\n+            if (reusable)\n+            {\n+                List<Pool<T>.Entry> cachedList = cache.get();\n+                if (cachedList.size() < cacheSize)\n+                    cachedList.add(entry);\n+            }\n+        }\n+    }\n+\n+    private abstract static class IndexedCached<T> implements Cache<T>\n+    {\n+        @Override\n+        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n+        {\n+            int size = entries.size();\n+            if (size == 0)\n+                return null;\n+            int i = nextIndex(size);\n+            try\n+            {\n+                Pool<T>.Entry entry = entries.get(i);\n+                if (entry != null && entry.tryAcquire())\n+                    return entry;\n+            }\n+            catch (Exception e)\n+            {\n+                // Could be out of bounds\n+                LOGGER.ignore(e);\n+            }\n+            return null;\n+        }\n+\n+        protected abstract int nextIndex(int size);\n+    }\n+\n+    public static class RandomCache<T> extends IndexedCached<T>\n+    {\n+        @Override\n+        protected int nextIndex(int size)\n+        {\n+            return ThreadLocalRandom.current().nextInt(size);\n+        }\n+    }\n+\n+    public static class RoundRobinCache<T> extends IndexedCached<T>\n+    {\n+        AtomicInteger index = new AtomicInteger();\n+\n+        @Override\n+        protected int nextIndex(int size)\n+        {\n+            return index.getAndUpdate(c -> Math.max(0, c + 1)) % size;\n+        }\n+    }\n+\n+    public static class RoundRobinStrategy<T> extends RoundRobinCache<T> implements Strategy<T>\n+    {\n+        @Override\n+        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n+        {\n+            int tries = entries.size();\n+            while (tries-- > 0)\n+            {\n+                Pool<T>.Entry entry = super.acquire(entries);\n+                if (entry != null)\n+                    return entry;\n+            }\n+            return null;\n+        }\n+    }\n+\n+    public static class LeastRecentlyUsedStrategy<T> implements Strategy<T>", "originalCommit": "6ab7bd726b0e2412a5c1497348473dbac98d64a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjMxMDA5NQ==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r482310095", "bodyText": "I'll keep for now to test API during dev... but don't think we should include it in final merge... actually I might move it to a test to check that an external strategy can be applied without access to protected methods", "author": "gregw", "createdAt": "2020-09-02T18:58:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA1MzAwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA1NjMzMg==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r482056332", "bodyText": "Are both Strategy and Cache needed?", "author": "lorban", "createdAt": "2020-09-02T13:11:12Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -559,4 +574,222 @@ public String toString()\n                 pooled);\n         }\n     }\n+\n+    /** A pluggable strategy to optimize pool acquisition\n+     * @param <T> The type of the items in the pool\n+     */\n+    public interface Cache<T>\n+    {\n+        /** Acquire an entry\n+         * @param entries The list of entries known to the pool. This may be concurrently modified.\n+         * @return An acquired entry or null if none can be acquired by this strategy\n+         */\n+        Pool<T>.Entry acquire(List<Pool<T>.Entry> entries);\n+\n+        /**\n+         * Notification an entry has been release.  The notification comes after the entry\n+         * has been put back in the pool and it may already have been reacquired before or during this call.\n+         * @param entries The list of entries known to the pool. This may be concurrently modified.\n+         * @param entry The entry to be release\n+         * @param reusable true if the entry is reusable and will be put back in the pool.\n+         */\n+        default void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n+        {\n+        }\n+    }\n+\n+    public interface Strategy<T> extends Cache<T>", "originalCommit": "6ab7bd726b0e2412a5c1497348473dbac98d64a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjMwODQzNg==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r482308436", "bodyText": "Strategy and Cache are needed if we want to make a distinction between impls that just try to find an entry and then give up (threadlocal, random) and those that do a search  ( linear, round-robin).\nHowever, I too am not convinced the distinction is necessary.", "author": "gregw", "createdAt": "2020-09-02T18:56:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA1NjMzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA1NzEyOA==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r482057128", "bodyText": "If we go with this design, the RR connection pool should be rewritten to use the RR strategy and this method should be removed.", "author": "lorban", "createdAt": "2020-09-02T13:12:22Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -176,14 +213,15 @@ public Entry reserve(int allotment)\n      * @param idx the index of the entry to acquire.\n      * @return the specified entry or null if there is none at the specified index or if it is not available.\n      */\n+    @Deprecated", "originalCommit": "6ab7bd726b0e2412a5c1497348473dbac98d64a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA1Nzg1OA==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r482057858", "bodyText": "this.cache = Objects.requireNonNull(cache);", "author": "lorban", "createdAt": "2020-09-02T13:13:32Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -559,4 +574,222 @@ public String toString()\n                 pooled);\n         }\n     }\n+\n+    /** A pluggable strategy to optimize pool acquisition\n+     * @param <T> The type of the items in the pool\n+     */\n+    public interface Cache<T>\n+    {\n+        /** Acquire an entry\n+         * @param entries The list of entries known to the pool. This may be concurrently modified.\n+         * @return An acquired entry or null if none can be acquired by this strategy\n+         */\n+        Pool<T>.Entry acquire(List<Pool<T>.Entry> entries);\n+\n+        /**\n+         * Notification an entry has been release.  The notification comes after the entry\n+         * has been put back in the pool and it may already have been reacquired before or during this call.\n+         * @param entries The list of entries known to the pool. This may be concurrently modified.\n+         * @param entry The entry to be release\n+         * @param reusable true if the entry is reusable and will be put back in the pool.\n+         */\n+        default void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n+        {\n+        }\n+    }\n+\n+    public interface Strategy<T> extends Cache<T>\n+    {\n+    }\n+\n+    public static class CacheStrategy<T> implements Strategy<T>\n+    {\n+        final Cache<T> cache;\n+        final Strategy<T> strategy;\n+\n+        public CacheStrategy(Cache<T> cache, Strategy<T> planB)\n+        {\n+            Objects.requireNonNull(cache);\n+            Objects.requireNonNull(planB);\n+            this.cache = cache;", "originalCommit": "6ab7bd726b0e2412a5c1497348473dbac98d64a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA1ODAyNw==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r482058027", "bodyText": "this.strategy = Objects.requireNonNull(planB);", "author": "lorban", "createdAt": "2020-09-02T13:13:49Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -559,4 +574,222 @@ public String toString()\n                 pooled);\n         }\n     }\n+\n+    /** A pluggable strategy to optimize pool acquisition\n+     * @param <T> The type of the items in the pool\n+     */\n+    public interface Cache<T>\n+    {\n+        /** Acquire an entry\n+         * @param entries The list of entries known to the pool. This may be concurrently modified.\n+         * @return An acquired entry or null if none can be acquired by this strategy\n+         */\n+        Pool<T>.Entry acquire(List<Pool<T>.Entry> entries);\n+\n+        /**\n+         * Notification an entry has been release.  The notification comes after the entry\n+         * has been put back in the pool and it may already have been reacquired before or during this call.\n+         * @param entries The list of entries known to the pool. This may be concurrently modified.\n+         * @param entry The entry to be release\n+         * @param reusable true if the entry is reusable and will be put back in the pool.\n+         */\n+        default void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n+        {\n+        }\n+    }\n+\n+    public interface Strategy<T> extends Cache<T>\n+    {\n+    }\n+\n+    public static class CacheStrategy<T> implements Strategy<T>\n+    {\n+        final Cache<T> cache;\n+        final Strategy<T> strategy;\n+\n+        public CacheStrategy(Cache<T> cache, Strategy<T> planB)\n+        {\n+            Objects.requireNonNull(cache);\n+            Objects.requireNonNull(planB);\n+            this.cache = cache;\n+            this.strategy = planB;", "originalCommit": "6ab7bd726b0e2412a5c1497348473dbac98d64a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA1ODY1OQ==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r482058659", "bodyText": "This comment isn't accurate anymore as the iteration is also part of the strategy.", "author": "lorban", "createdAt": "2020-09-02T13:14:43Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -197,32 +235,14 @@ public Entry acquireAt(int idx)\n     /**\n      * Acquire an entry from the pool.\n      * Only enabled entries will be returned from this method and their enable method must not be called.\n+     * The implementation first tries the pool strategy and then a brute force iteration over entries.", "originalCommit": "6ab7bd726b0e2412a5c1497348473dbac98d64a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e250a4966d93eeb9117b93c6a9030ca7537a8443", "url": "https://github.com/eclipse/jetty.project/commit/e250a4966d93eeb9117b93c6a9030ca7537a8443", "message": "Feedback from review\n\n + Added reserve and release", "committedDate": "2020-09-02T13:57:26Z", "type": "commit"}, {"oid": "505321687c6ad3e7bcc6e64e6d1d0b183167b419", "url": "https://github.com/eclipse/jetty.project/commit/505321687c6ad3e7bcc6e64e6d1d0b183167b419", "message": "Improved Pool Strategies:\n\n+ reverted to post notifications for removed, reserved and released.\n+ Added a few more strategies that need to be benchmarked, that use the list iterator.\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-09-07T17:30:07Z", "type": "commit"}, {"oid": "d9abdeb3cd71f0405b9b95f8d288baccb2edbf8c", "url": "https://github.com/eclipse/jetty.project/commit/d9abdeb3cd71f0405b9b95f8d288baccb2edbf8c", "message": "Testing all the different strategies\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-09-08T10:39:07Z", "type": "commit"}, {"oid": "0aa6bc92110ade8c4c96b26e8c074620447857ee", "url": "https://github.com/eclipse/jetty.project/commit/0aa6bc92110ade8c4c96b26e8c074620447857ee", "message": "More simplifications and made LRU work (ish)\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-09-08T10:51:13Z", "type": "commit"}, {"oid": "15ab22647b3e1bc8e791d9a4e6bd16a9d1ed61e8", "url": "https://github.com/eclipse/jetty.project/commit/15ab22647b3e1bc8e791d9a4e6bd16a9d1ed61e8", "message": "javadoc", "committedDate": "2020-09-08T12:38:01Z", "type": "commit"}, {"oid": "c18a77e8135047393ba289ca3179693b5af4ffad", "url": "https://github.com/eclipse/jetty.project/commit/c18a77e8135047393ba289ca3179693b5af4ffad", "message": "More javadoc\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-09-08T12:54:40Z", "type": "commit"}, {"oid": "8906678227cc6ab9bc6feadbd0e0bb3533f9781c", "url": "https://github.com/eclipse/jetty.project/commit/8906678227cc6ab9bc6feadbd0e0bb3533f9781c", "message": "JMH Test\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-09-09T10:01:25Z", "type": "commit"}, {"oid": "feda65d15aa906a1c0689ea45b26e15a17906beb", "url": "https://github.com/eclipse/jetty.project/commit/feda65d15aa906a1c0689ea45b26e15a17906beb", "message": "one strategy\n\nSigned-off-by: gregw <gregw@webtide.com>", "committedDate": "2020-09-10T06:10:02Z", "type": "commit"}, {"oid": "0b0030d9897ce8d95e3167e35b72855cd57db0fd", "url": "https://github.com/eclipse/jetty.project/commit/0b0030d9897ce8d95e3167e35b72855cd57db0fd", "message": "test\n\nSigned-off-by: gregw <gregw@webtide.com>", "committedDate": "2020-09-10T07:18:36Z", "type": "commit"}, {"oid": "bf520b4d8b559c5ed8551573d780dced775bcc06", "url": "https://github.com/eclipse/jetty.project/commit/bf520b4d8b559c5ed8551573d780dced775bcc06", "message": "Split implementations:\n\n + pluggable strategies\n + hard coded\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-09-10T07:35:11Z", "type": "commit"}, {"oid": "e91578457bbc36b8db01006b3a821d5185ecac1c", "url": "https://github.com/eclipse/jetty.project/commit/e91578457bbc36b8db01006b3a821d5185ecac1c", "message": "More benchmarks", "committedDate": "2020-09-10T09:40:03Z", "type": "commit"}, {"oid": "db00126abd11f5734e499bb8a7ab795bc769b879", "url": "https://github.com/eclipse/jetty.project/commit/db00126abd11f5734e499bb8a7ab795bc769b879", "message": "Built in strategy", "committedDate": "2020-09-10T12:41:48Z", "type": "commit"}, {"oid": "69fe8f669bcf89607c5da6f4a39964585e2dc0b9", "url": "https://github.com/eclipse/jetty.project/commit/69fe8f669bcf89607c5da6f4a39964585e2dc0b9", "message": "removed strategies version and simplified to single configurable solution.\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-09-10T13:40:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ3NTQxNA==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r486475414", "bodyText": "You should move this comment around since you also moved the ThreadLocal variable it speaks about.", "author": "lorban", "createdAt": "2020-09-10T16:25:47Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -65,29 +75,74 @@\n      * When an entry can't be found in the cache, the global list is iterated\n      * normally so the cache has no visible effect besides performance.\n      */", "originalCommit": "69fe8f669bcf89607c5da6f4a39964585e2dc0b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ3Nzk2NQ==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r486477965", "bodyText": "This method should go and any caller should be replaced with a Pool using the RR strategy.", "author": "lorban", "createdAt": "2020-09-10T16:29:46Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -176,14 +231,15 @@ public Entry reserve(int allotment)\n      * @param idx the index of the entry to acquire.\n      * @return the specified entry or null if there is none at the specified index or if it is not available.\n      */\n+    @Deprecated\n     public Entry acquireAt(int idx)", "originalCommit": "69fe8f669bcf89607c5da6f4a39964585e2dc0b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjUwNDE3NA==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r486504174", "bodyText": "Yep - waiting for @sbordet to help rework connection pool.", "author": "gregw", "createdAt": "2020-09-10T17:12:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ3Nzk2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ3ODY3OQ==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r486478679", "bodyText": "I'd add a message to the exception, something like\nthrow new IllegalArgumentException(\"Invalid strategy : \" + strategy);", "author": "lorban", "createdAt": "2020-09-10T16:30:54Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -204,25 +260,51 @@ public Entry acquire()\n         if (closed)\n             return null;\n \n-        // first check the thread-local cache\n+        int size = entries.size();\n+        if (size == 0)\n+            return null;\n+\n         if (cache != null)\n         {\n-            List<Entry> cachedList = cache.get();\n-            while (!cachedList.isEmpty())\n+            Pool<T>.Entry entry = cache.get();\n+            if (entry != null && entry.tryAcquire())\n+                return entry;\n+        }\n+\n+        int index = startIndex(size);\n+\n+        for (int tries = size; tries-- > 0;)\n+        {\n+            try\n+            {\n+                Pool<T>.Entry entry = entries.get(index);\n+                if (entry != null && entry.tryAcquire())\n+                    return entry;\n+            }\n+            catch (IndexOutOfBoundsException e)\n             {\n-                Entry cachedEntry = cachedList.remove(cachedList.size() - 1);\n-                if (cachedEntry.tryAcquire())\n-                    return cachedEntry;\n+                LOGGER.ignore(e);\n             }\n+            index = (index + 1) % size;\n         }\n+        return null;\n+    }\n \n-        // then iterate the shared list\n-        for (Entry entry : sharedList)\n+    private int startIndex(int size)\n+    {\n+        switch (strategy)\n         {\n-            if (entry.tryAcquire())\n-                return entry;\n+            case LINEAR:\n+                return 0;\n+            case RANDOM:\n+                return ThreadLocalRandom.current().nextInt(size);\n+            case ROUND_ROBIN:\n+                return next.getAndUpdate(c -> Math.max(0, c + 1)) % size;\n+            case THREAD_ID:\n+                return (int)(Thread.currentThread().getId() % size);\n+            default:\n+                throw new IllegalArgumentException();", "originalCommit": "69fe8f669bcf89607c5da6f4a39964585e2dc0b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ3OTY1Ng==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r486479656", "bodyText": "This doesn't seem to be used.", "author": "lorban", "createdAt": "2020-09-10T16:32:25Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -500,6 +575,13 @@ boolean tryRelease()\n             return !(overUsed && newMultiplexingCount == 0);\n         }\n \n+        public boolean isOverUsed()", "originalCommit": "69fe8f669bcf89607c5da6f4a39964585e2dc0b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjUwNTI2OQ==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r486505269", "bodyText": "I did have a use for it.... but can't remember now... was probably some esoteric strategy or perhaps a unit test.\nI still think it is a nice to have along with the isIdle type methods.", "author": "gregw", "createdAt": "2020-09-10T17:14:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ3OTY1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyNDYwMg==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r489224602", "bodyText": "+1 for keeping the method for JMX and such.", "author": "sbordet", "createdAt": "2020-09-16T07:33:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ3OTY1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ3OTgyOQ==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r486479829", "bodyText": "This doesn't have to be public.", "author": "lorban", "createdAt": "2020-09-10T16:32:40Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -452,7 +527,7 @@ public boolean remove()\n          * the multiplex count is maxMultiplex and the entry is not closed,\n          * false otherwise.\n          */\n-        boolean tryAcquire()\n+        public boolean tryAcquire()", "originalCommit": "69fe8f669bcf89607c5da6f4a39964585e2dc0b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjUwNTU2Mw==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r486505563", "bodyText": "Ah yes! It needed to be public for strategies... but not now!", "author": "gregw", "createdAt": "2020-09-10T17:15:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ3OTgyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ4MDAzOA==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r486480038", "bodyText": "This index doesn't seem to be used.", "author": "lorban", "createdAt": "2020-09-10T16:33:00Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -345,45 +417,48 @@ public void close()\n \n     public int size()\n     {\n-        return sharedList.size();\n+        return entries.size();\n     }\n \n     public Collection<Entry> values()\n     {\n-        return Collections.unmodifiableCollection(sharedList);\n+        return Collections.unmodifiableCollection(entries);\n     }\n \n     @Override\n     public void dump(Appendable out, String indent) throws IOException\n     {\n-        Dumpable.dumpObjects(out, indent, this);\n+        Dumpable.dumpObjects(out, indent, this,\n+            new DumpableCollection(\"entries\", entries));\n     }\n \n     @Override\n     public String toString()\n     {\n-        return String.format(\"%s@%x[size=%d closed=%s entries=%s]\",\n+        return String.format(\"%s@%x[size=%d closed=%s pending=%d]\",\n             getClass().getSimpleName(),\n             hashCode(),\n-            sharedList.size(),\n+            entries.size(),\n             closed,\n-            sharedList);\n+            pending.get());\n     }\n \n     public class Entry\n     {\n         // hi: positive=open/maxUsage counter; negative=closed; MIN_VALUE pending\n         // lo: multiplexing counter\n         private final AtomicBiInteger state;\n+        private final int index;", "originalCommit": "69fe8f669bcf89607c5da6f4a39964585e2dc0b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjUwNTk3MQ==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r486505971", "bodyText": "oops yes - that was a broken hack for another esoteric round robin", "author": "gregw", "createdAt": "2020-09-10T17:15:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ4MDAzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ4MTA1MA==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r486481050", "bodyText": "I would rename these variables to the actual name of their value: usageCount and multiplexingCount.", "author": "lorban", "createdAt": "2020-09-10T16:34:37Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -549,12 +631,17 @@ public int getUsageCount()\n         public String toString()\n         {\n             long encoded = state.get();\n-            return String.format(\"%s@%x{usage=%d/%d,multiplex=%d/%d,pooled=%s}\",\n+            int hi = AtomicBiInteger.getHi(encoded);\n+            int lo = AtomicBiInteger.getLo(encoded);", "originalCommit": "69fe8f669bcf89607c5da6f4a39964585e2dc0b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ4MzQ3MA==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r486483470", "bodyText": "Since all the other names of this enum describe the starting index, I'd rename this one to something like INDEX_ZERO.", "author": "lorban", "createdAt": "2020-09-10T16:38:37Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -65,29 +75,74 @@\n      * When an entry can't be found in the cache, the global list is iterated\n      * normally so the cache has no visible effect besides performance.\n      */\n-    private final ThreadLocal<List<Entry>> cache;\n+\n     private final Locker locker = new Locker();\n     private final int maxEntries;\n-    private final int cacheSize;\n     private final AtomicInteger pending = new AtomicInteger();\n+    private final Strategy strategy;\n+    private final ThreadLocal<Entry> cache;\n+    private final AtomicInteger next;\n     private volatile boolean closed;\n     private volatile int maxMultiplex = 1;\n     private volatile int maxUsageCount = -1;\n \n+    public enum Strategy\n+    {\n+        /**\n+         * The Linear strategy looks for an entry always starting from the first entry.\n+         * It will favour the early entries in the pool, but may contend on them more.\n+         */\n+        LINEAR,", "originalCommit": "69fe8f669bcf89607c5da6f4a39964585e2dc0b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjUxMTI1OQ==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r486511259", "bodyText": "How about FIRST?", "author": "gregw", "createdAt": "2020-09-10T17:24:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ4MzQ3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ4Mzk4OQ==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r486483989", "bodyText": "AtomicInteger nextIndex?", "author": "lorban", "createdAt": "2020-09-10T16:39:21Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -65,29 +75,74 @@\n      * When an entry can't be found in the cache, the global list is iterated\n      * normally so the cache has no visible effect besides performance.\n      */\n-    private final ThreadLocal<List<Entry>> cache;\n+\n     private final Locker locker = new Locker();\n     private final int maxEntries;\n-    private final int cacheSize;\n     private final AtomicInteger pending = new AtomicInteger();\n+    private final Strategy strategy;\n+    private final ThreadLocal<Entry> cache;\n+    private final AtomicInteger next;", "originalCommit": "69fe8f669bcf89607c5da6f4a39964585e2dc0b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ4NDQ4NQ==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r486484485", "bodyText": "new ThreadLocal<>()?", "author": "lorban", "createdAt": "2020-09-10T16:40:06Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -65,29 +75,74 @@\n      * When an entry can't be found in the cache, the global list is iterated\n      * normally so the cache has no visible effect besides performance.\n      */\n-    private final ThreadLocal<List<Entry>> cache;\n+\n     private final Locker locker = new Locker();\n     private final int maxEntries;\n-    private final int cacheSize;\n     private final AtomicInteger pending = new AtomicInteger();\n+    private final Strategy strategy;\n+    private final ThreadLocal<Entry> cache;\n+    private final AtomicInteger next;\n     private volatile boolean closed;\n     private volatile int maxMultiplex = 1;\n     private volatile int maxUsageCount = -1;\n \n+    public enum Strategy\n+    {\n+        /**\n+         * The Linear strategy looks for an entry always starting from the first entry.\n+         * It will favour the early entries in the pool, but may contend on them more.\n+         */\n+        LINEAR,\n+\n+        /**\n+         * The Random strategy looks for an entry by iterating from a random starting\n+         * index.  No entries are favoured and contention is reduced.\n+         */\n+        RANDOM,\n+\n+        /**\n+         * The Thread ID strategy uses the {@link Thread#getId()} of the current thread\n+         * to select a starting point for an entry search.  Whilst not as performant as\n+         * using the {@link ThreadLocal} cache, it may be suitable when the pool is substantially smaller\n+         * than the number of available threads.\n+         * No entries are favoured and contention is reduced.\n+         */\n+        THREAD_ID,\n+\n+        /**\n+         * The Round Robin strategy looks for an entry by iterating from a starting point\n+         * that is incremented on every search. This gives similar results to the\n+         * random strategy but with more predictable behaviour.\n+         * No entries are favoured and contention is reduced.\n+         */\n+        ROUND_ROBIN,\n+    }\n+\n     /**\n-     * Construct a Pool with the specified thread-local cache size.\n+     * Construct a Pool with a specified lookup strategy and no\n+     * {@link ThreadLocal} cache.\n      *\n+     * @param strategy The strategy to used for looking up entries.\n      * @param maxEntries the maximum amount of entries that the pool will accept.\n-     * @param cacheSize the thread-local cache size. A value less than 1 means the cache is disabled.\n      */\n-    public Pool(int maxEntries, int cacheSize)\n+    public Pool(Strategy strategy, int maxEntries)\n+    {\n+        this(strategy, maxEntries, false);\n+    }\n+\n+    /**\n+     * Construct a Pool with the specified thread-local cache size and\n+     * an optional {@link ThreadLocal} cache.\n+     * @param strategy The strategy to used for looking up entries.\n+     * @param maxEntries the maximum amount of entries that the pool will accept.\n+     * @param cache True if a {@link ThreadLocal} cache should be used to try the most recently released entry.\n+     */\n+    public Pool(Strategy strategy, int maxEntries, boolean cache)\n     {\n         this.maxEntries = maxEntries;\n-        this.cacheSize = cacheSize;\n-        if (cacheSize > 0)\n-            this.cache = ThreadLocal.withInitial(() -> new ArrayList<Entry>(cacheSize));\n-        else\n-            this.cache = null;\n+        this.strategy = strategy;\n+        this.cache = cache ? new ThreadLocal() : null;", "originalCommit": "69fe8f669bcf89607c5da6f4a39964585e2dc0b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjUwOTAwNQ==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r486509005", "bodyText": "Don't need the threadlocal if not caching", "author": "gregw", "createdAt": "2020-09-10T17:21:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ4NDQ4NQ=="}], "type": "inlineReview"}, {"oid": "68bf2b508004b214483b598314490b0c000c2f8a", "url": "https://github.com/eclipse/jetty.project/commit/68bf2b508004b214483b598314490b0c000c2f8a", "message": "updates from review\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-09-10T17:24:16Z", "type": "commit"}, {"oid": "225b096122977e3a0c8576559288aa1ba34839b1", "url": "https://github.com/eclipse/jetty.project/commit/225b096122977e3a0c8576559288aa1ba34839b1", "message": "better javadoc\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-09-10T17:26:14Z", "type": "commit"}, {"oid": "46d18190d1acff0fe13e727d7ce219cc4b19aaa8", "url": "https://github.com/eclipse/jetty.project/commit/46d18190d1acff0fe13e727d7ce219cc4b19aaa8", "message": "Merge branch 'jetty-9.4.x' into jetty-9.4.x-PoolStrategy", "committedDate": "2020-09-15T09:55:33Z", "type": "commit"}, {"oid": "1ef761ed10d5d818a7c3e63a0d5769a00e6630af", "url": "https://github.com/eclipse/jetty.project/commit/1ef761ed10d5d818a7c3e63a0d5769a00e6630af", "message": "Updated ConnectionPool classes to use Pool strategies", "committedDate": "2020-09-15T10:57:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyMjE3Nw==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r489222177", "bodyText": "Overriding listIterator(int) is not necessary anymore, since we never use it, and we don't leak the entries field.", "author": "sbordet", "createdAt": "2020-09-16T07:29:02Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -56,38 +51,98 @@\n {\n     private static final Logger LOGGER = Log.getLogger(Pool.class);\n \n-    private final List<Entry> sharedList = new CopyOnWriteArrayList<>();\n+    private final List<Entry> entries = new CopyOnWriteArrayList<Entry>()\n+    {\n+        @Override\n+        public ListIterator<Entry> listIterator(int index)\n+        {\n+            try\n+            {\n+                return super.listIterator(index);\n+            }\n+            catch (IndexOutOfBoundsException e)\n+            {\n+                return listIterator();\n+            }\n+        }\n+    };", "originalCommit": "1ef761ed10d5d818a7c3e63a0d5769a00e6630af", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyMzE0OA==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r489223148", "bodyText": "There is no \"normal\" strategy, I would rephrase: \"is iterated with the configured StrategyType\".", "author": "sbordet", "createdAt": "2020-09-16T07:30:37Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -56,38 +51,98 @@\n {\n     private static final Logger LOGGER = Log.getLogger(Pool.class);\n \n-    private final List<Entry> sharedList = new CopyOnWriteArrayList<>();\n+    private final List<Entry> entries = new CopyOnWriteArrayList<Entry>()\n+    {\n+        @Override\n+        public ListIterator<Entry> listIterator(int index)\n+        {\n+            try\n+            {\n+                return super.listIterator(index);\n+            }\n+            catch (IndexOutOfBoundsException e)\n+            {\n+                return listIterator();\n+            }\n+        }\n+    };\n+\n+    private final int maxEntries;\n+    private final AtomicInteger pending = new AtomicInteger();\n+    private final StrategyType strategyType;\n+\n     /*\n      * The cache is used to avoid hammering on the first index of the entry list.\n      * Caches can become poisoned (i.e.: containing entries that are in use) when\n      * the release isn't done by the acquiring thread or when the entry pool is\n      * undersized compared to the load applied on it.\n      * When an entry can't be found in the cache, the global list is iterated\n-     * normally so the cache has no visible effect besides performance.\n+     * with the normal strategy so the cache has no visible effect besides performance.", "originalCommit": "1ef761ed10d5d818a7c3e63a0d5769a00e6630af", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyMzMzMw==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r489223333", "bodyText": "Javadocs.", "author": "sbordet", "createdAt": "2020-09-16T07:30:59Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -56,38 +51,98 @@\n {\n     private static final Logger LOGGER = Log.getLogger(Pool.class);\n \n-    private final List<Entry> sharedList = new CopyOnWriteArrayList<>();\n+    private final List<Entry> entries = new CopyOnWriteArrayList<Entry>()\n+    {\n+        @Override\n+        public ListIterator<Entry> listIterator(int index)\n+        {\n+            try\n+            {\n+                return super.listIterator(index);\n+            }\n+            catch (IndexOutOfBoundsException e)\n+            {\n+                return listIterator();\n+            }\n+        }\n+    };\n+\n+    private final int maxEntries;\n+    private final AtomicInteger pending = new AtomicInteger();\n+    private final StrategyType strategyType;\n+\n     /*\n      * The cache is used to avoid hammering on the first index of the entry list.\n      * Caches can become poisoned (i.e.: containing entries that are in use) when\n      * the release isn't done by the acquiring thread or when the entry pool is\n      * undersized compared to the load applied on it.\n      * When an entry can't be found in the cache, the global list is iterated\n-     * normally so the cache has no visible effect besides performance.\n+     * with the normal strategy so the cache has no visible effect besides performance.\n      */\n-    private final ThreadLocal<List<Entry>> cache;\n     private final Locker locker = new Locker();\n-    private final int maxEntries;\n-    private final int cacheSize;\n-    private final AtomicInteger pending = new AtomicInteger();\n+    private final ThreadLocal<Entry> cache;\n+    private final AtomicInteger nextIndex;\n     private volatile boolean closed;\n     private volatile int maxMultiplex = 1;\n     private volatile int maxUsageCount = -1;\n \n+    public enum StrategyType", "originalCommit": "1ef761ed10d5d818a7c3e63a0d5769a00e6630af", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyMzkwNg==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r489223906", "bodyText": "Add @deprecated javadoc too.", "author": "sbordet", "createdAt": "2020-09-16T07:31:56Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -176,14 +231,15 @@ public Entry reserve(int allotment)\n      * @param idx the index of the entry to acquire.\n      * @return the specified entry or null if there is none at the specified index or if it is not available.\n      */\n+    @Deprecated", "originalCommit": "1ef761ed10d5d818a7c3e63a0d5769a00e6630af", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTMyMDE3Mw==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r489320173", "bodyText": "I guess we can't just remove it... will do in 10", "author": "gregw", "createdAt": "2020-09-16T10:05:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyMzkwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyNTM3Mw==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r489225373", "bodyText": "new Pool<>(...) is enough, remove type parameter.", "author": "sbordet", "createdAt": "2020-09-16T07:34:39Z", "path": "jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java", "diffHunk": "@@ -40,20 +50,27 @@\n \n public class PoolTest\n {\n-    public static Stream<Object[]> cacheSize()\n+\n+    interface Factory\n+    {\n+        Pool<String> getPool(int maxSize);\n+    }\n+\n+    public static Stream<Object[]> strategy()\n     {\n         List<Object[]> data = new ArrayList<>();\n-        data.add(new Object[]{0});\n-        data.add(new Object[]{1});\n-        data.add(new Object[]{2});\n+        data.add(new Object[]{(Factory)s -> new Pool<String>(FIRST, s)});\n+        data.add(new Object[]{(Factory)s -> new Pool<String>(RANDOM, s)});\n+        data.add(new Object[]{(Factory)s -> new Pool<String>(FIRST, s, true)});\n+        data.add(new Object[]{(Factory)s -> new Pool<String>(ROUND_ROBIN, s)});", "originalCommit": "1ef761ed10d5d818a7c3e63a0d5769a00e6630af", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyNjQxNQ==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r489226415", "bodyText": "This test contains an unused e2 variable that I would instead add to the asserts, for example, to confirm that it is in use even after removing e1, or that e2 == e1, etc.", "author": "sbordet", "createdAt": "2020-09-16T07:36:34Z", "path": "jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java", "diffHunk": "@@ -331,34 +347,44 @@ public void testMaxUsageCount(int cacheSize)\n     }\n \n     @ParameterizedTest\n-    @MethodSource(value = \"cacheSize\")\n-    public void testMaxMultiplex(int cacheSize)\n+    @MethodSource(value = \"strategy\")\n+    public void testMaxMultiplex(Factory factory)\n     {\n-        Pool<String> pool = new Pool<>(2, cacheSize);\n+        Pool<String> pool = factory.getPool(2);\n         pool.setMaxMultiplex(3);\n-        pool.reserve(-1).enable(\"aaa\", false);\n-        pool.reserve(-1).enable(\"bbb\", false);\n \n-        Pool<String>.Entry e1 = pool.acquire();\n-        Pool<String>.Entry e2 = pool.acquire();\n-        Pool<String>.Entry e3 = pool.acquire();\n-        Pool<String>.Entry e4 = pool.acquire();\n-        assertThat(e1.getPooled(), equalTo(\"aaa\"));\n-        assertThat(e1, sameInstance(e2));\n-        assertThat(e1, sameInstance(e3));\n-        assertThat(e4.getPooled(), equalTo(\"bbb\"));\n-        assertThat(pool.release(e1), is(true));\n-        Pool<String>.Entry e5 = pool.acquire();\n-        assertThat(e2, sameInstance(e5));\n-        Pool<String>.Entry e6 = pool.acquire();\n-        assertThat(e4, sameInstance(e6));\n+        Map<String, AtomicInteger> counts = new HashMap<>();\n+        AtomicInteger a = new AtomicInteger();\n+        AtomicInteger b = new AtomicInteger();\n+        counts.put(\"a\", a);\n+        counts.put(\"b\", b);\n+        pool.reserve(-1).enable(\"a\", false);\n+        pool.reserve(-1).enable(\"b\", false);\n+\n+        counts.get(pool.acquire().getPooled()).incrementAndGet();\n+        counts.get(pool.acquire().getPooled()).incrementAndGet();\n+        counts.get(pool.acquire().getPooled()).incrementAndGet();\n+        counts.get(pool.acquire().getPooled()).incrementAndGet();\n+\n+        assertThat(a.get(), greaterThan(0));\n+        assertThat(a.get(), lessThanOrEqualTo(3));\n+        assertThat(b.get(), greaterThan(0));\n+        assertThat(b.get(), lessThanOrEqualTo(3));\n+\n+        counts.get(pool.acquire().getPooled()).incrementAndGet();\n+        counts.get(pool.acquire().getPooled()).incrementAndGet();\n+\n+        assertThat(a.get(), is(3));\n+        assertThat(b.get(), is(3));\n+\n+        assertNull(pool.acquire());\n     }\n \n     @ParameterizedTest\n-    @MethodSource(value = \"cacheSize\")\n-    public void testRemoveMultiplexed(int cacheSize)\n+    @MethodSource(value = \"strategy\")\n+    public void testRemoveMultiplexed(Factory factory)\n     {\n-        Pool<String> pool = new Pool<>(1, cacheSize);\n+        Pool<String> pool = factory.getPool(1);\n         pool.setMaxMultiplex(2);\n         pool.reserve(-1).enable(\"aaa\", false);", "originalCommit": "1ef761ed10d5d818a7c3e63a0d5769a00e6630af", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyNzM1Ng==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r489227356", "bodyText": "This test contains an unused variable e2 that I would use in asserts, at least to verify that e2 == e1.", "author": "sbordet", "createdAt": "2020-09-16T07:38:19Z", "path": "jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java", "diffHunk": "@@ -506,10 +532,10 @@ public void testMultiplexMaxUsageReachedAcquireThenReleaseThenRemove(int cacheSi\n     }\n \n     @ParameterizedTest\n-    @MethodSource(value = \"cacheSize\")\n-    public void testUsageCountAfterReachingMaxMultiplexLimit(int cacheSize)\n+    @MethodSource(value = \"strategy\")\n+    public void testUsageCountAfterReachingMaxMultiplexLimit(Factory factory)\n     {\n-        Pool<String> pool = new Pool<>(1, cacheSize);\n+        Pool<String> pool = factory.getPool(1);\n         pool.setMaxMultiplex(2);\n         pool.setMaxUsageCount(10);\n         pool.reserve(-1).enable(\"aaa\", false);", "originalCommit": "1ef761ed10d5d818a7c3e63a0d5769a00e6630af", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f9773d5ae3ab72c189fae474bd138951b5b5e73a", "url": "https://github.com/eclipse/jetty.project/commit/f9773d5ae3ab72c189fae474bd138951b5b5e73a", "message": "Small javadocs fixes.\n\nSigned-off-by: Simone Bordet <simone.bordet@gmail.com>", "committedDate": "2020-09-16T07:40:14Z", "type": "commit"}, {"oid": "4504fee50b8ebd30becb0e402a7d831bded3e1ea", "url": "https://github.com/eclipse/jetty.project/commit/4504fee50b8ebd30becb0e402a7d831bded3e1ea", "message": "Merge branch 'jetty-9.4.x' into jetty-9.4.x-PoolStrategy", "committedDate": "2020-09-16T10:00:27Z", "type": "commit"}, {"oid": "6c90442d5b368d3d6274acfd81893d37d6755951", "url": "https://github.com/eclipse/jetty.project/commit/6c90442d5b368d3d6274acfd81893d37d6755951", "message": "Updates from review", "committedDate": "2020-09-16T10:13:12Z", "type": "commit"}, {"oid": "21f93c6df1faf2612fa510fa8df28de25877ac8e", "url": "https://github.com/eclipse/jetty.project/commit/21f93c6df1faf2612fa510fa8df28de25877ac8e", "message": "javadoc", "committedDate": "2020-09-16T16:24:44Z", "type": "commit"}]}