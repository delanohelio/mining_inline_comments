{"pr_number": 5801, "pr_title": "Implement max duration of HTTP ConnectionPools", "pr_createdAt": "2020-12-11T15:14:33Z", "pr_url": "https://github.com/eclipse/jetty.project/pull/5801", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTAyODQ2OA==", "url": "https://github.com/eclipse/jetty.project/pull/5801#discussion_r541028468", "bodyText": "How does this get set?  I don't see a way of configuring this (or a testcase demonstrating how to set it)", "author": "joakime", "createdAt": "2020-12-11T15:29:11Z", "path": "jetty-client/src/main/java/org/eclipse/jetty/client/AbstractConnectionPool.java", "diffHunk": "@@ -90,6 +109,17 @@ protected void doStop() throws Exception\n         return CompletableFuture.allOf(futures);\n     }\n \n+    @ManagedAttribute(value = \"The maximum duration in milliseconds a connection can be used for before it gets closed\")\n+    public long getMaxDuration()\n+    {\n+        return maxDuration;\n+    }\n+\n+    public void setMaxDuration(long maxDuration)\n+    {\n+        this.maxDuration = maxDuration;", "originalCommit": "44bc3ef63b0fe5661256587680d7f9841e56c20f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjQ0MzA5MA==", "url": "https://github.com/eclipse/jetty.project/pull/5801#discussion_r542443090", "bodyText": "I've now added a new parameter to ConnectionPoolTest that is running the test suite against a pool with a configured max duration.", "author": "lorban", "createdAt": "2020-12-14T14:50:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTAyODQ2OA=="}], "type": "inlineReview"}, {"oid": "302aad51bc994854bcc5a262f071b872b812ef88", "url": "https://github.com/eclipse/jetty.project/commit/302aad51bc994854bcc5a262f071b872b812ef88", "message": "add max duration property to the HTTP connection pool", "committedDate": "2020-12-14T14:36:57Z", "type": "forcePushed"}, {"oid": "24d97b8c1e044ae2cc5f418037956ed9defa8a73", "url": "https://github.com/eclipse/jetty.project/commit/24d97b8c1e044ae2cc5f418037956ed9defa8a73", "message": "add max duration property", "committedDate": "2020-12-14T14:49:05Z", "type": "forcePushed"}, {"oid": "5b8246fe345d06833a4df2c4241b81b0d7fd54b2", "url": "https://github.com/eclipse/jetty.project/commit/5b8246fe345d06833a4df2c4241b81b0d7fd54b2", "message": "add max duration property", "committedDate": "2020-12-17T15:30:19Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODAzNjM0NA==", "url": "https://github.com/eclipse/jetty.project/pull/5801#discussion_r548036344", "bodyText": "Should be protected, no?", "author": "sbordet", "createdAt": "2020-12-23T16:19:36Z", "path": "jetty-client/src/main/java/org/eclipse/jetty/client/AbstractConnectionPool.java", "diffHunk": "@@ -48,8 +50,25 @@\n \n     private final HttpDestination destination;\n     private final Callback requester;\n-    private final Pool<Connection> pool;\n+    private final Pool<ConnectionHolder> pool;\n     private boolean maximizeConnections;\n+    private volatile long maxDurationNanos = 0L;\n+\n+    public static class ConnectionHolder", "originalCommit": "5b8246fe345d06833a4df2c4241b81b0d7fd54b2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTE2MjQzMQ==", "url": "https://github.com/eclipse/jetty.project/pull/5801#discussion_r551162431", "bodyText": "Indeed, let me change this.", "author": "lorban", "createdAt": "2021-01-04T07:58:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODAzNjM0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA0MTMxMQ==", "url": "https://github.com/eclipse/jetty.project/pull/5801#discussion_r548041311", "bodyText": "Please add a debug statement before this line to log it's been closed due to expiration.", "author": "sbordet", "createdAt": "2020-12-23T16:30:11Z", "path": "jetty-client/src/main/java/org/eclipse/jetty/client/AbstractConnectionPool.java", "diffHunk": "@@ -281,16 +316,25 @@ protected void proceed()\n \n     protected Connection activate()\n     {\n-        Pool<Connection>.Entry entry = pool.acquire();\n-        if (entry != null)\n+        while (true)\n         {\n+            Pool<ConnectionHolder>.Entry entry = pool.acquire();\n+            if (entry == null)\n+                return null;\n+            Connection connection = entry.getPooled().connection;\n+\n+            long maxDurationNanos = this.maxDurationNanos;\n+            if (maxDurationNanos > 0L && entry.getPooled().isExpired(maxDurationNanos))\n+            {\n+                IO.close(connection);", "originalCommit": "5b8246fe345d06833a4df2c4241b81b0d7fd54b2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTE2MjQ4OQ==", "url": "https://github.com/eclipse/jetty.project/pull/5801#discussion_r551162489", "bodyText": "Ok.", "author": "lorban", "createdAt": "2021-01-04T07:59:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA0MTMxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA0MjYzMQ==", "url": "https://github.com/eclipse/jetty.project/pull/5801#discussion_r548042631", "bodyText": "The filter() lambda is wrong, it's entry.getPooled.connection that may implement Sweepable.\nPerhaps it's better to map to connection first, then filter, then forEach()", "author": "sbordet", "createdAt": "2020-12-23T16:33:20Z", "path": "jetty-client/src/main/java/org/eclipse/jetty/client/AbstractConnectionPool.java", "diffHunk": "@@ -426,12 +471,12 @@ public boolean sweep()\n     {\n         pool.values().stream().filter(entry -> entry.getPooled() instanceof Sweeper.Sweepable).forEach(entry ->", "originalCommit": "5b8246fe345d06833a4df2c4241b81b0d7fd54b2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTE2OTE0Nw==", "url": "https://github.com/eclipse/jetty.project/pull/5801#discussion_r551169147", "bodyText": "Good catch, let me do that.", "author": "lorban", "createdAt": "2021-01-04T08:17:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA0MjYzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA0MzgzNg==", "url": "https://github.com/eclipse/jetty.project/pull/5801#discussion_r548043836", "bodyText": "I don't see a test that verifies that the max duration mechanism works?", "author": "sbordet", "createdAt": "2020-12-23T16:35:52Z", "path": "jetty-client/src/test/java/org/eclipse/jetty/client/ConnectionPoolTest.java", "diffHunk": "@@ -71,6 +71,12 @@\n     {\n         return Stream.of(\n             new ConnectionPoolFactory(\"duplex\", destination -> new DuplexConnectionPool(destination, destination.getHttpClient().getMaxConnectionsPerDestination(), destination)),\n+            new ConnectionPoolFactory(\"duplex-maxDuration\", destination ->\n+            {\n+                DuplexConnectionPool pool = new DuplexConnectionPool(destination, destination.getHttpClient().getMaxConnectionsPerDestination(), destination);\n+                pool.setMaxDuration(10);\n+                return pool;\n+            }),", "originalCommit": "5b8246fe345d06833a4df2c4241b81b0d7fd54b2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTE4OTU5Nw==", "url": "https://github.com/eclipse/jetty.project/pull/5801#discussion_r551189597", "bodyText": "You're right, adding a specific test for this functionality would be good. Let me add one.", "author": "lorban", "createdAt": "2021-01-04T09:05:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA0MzgzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA0NDg1Mw==", "url": "https://github.com/eclipse/jetty.project/pull/5801#discussion_r548044853", "bodyText": "This change is confusing as says that it \"mark\" but actually \"tries to mark\", says \"closed\", but the method is called \"tryRemove\".\nI would revert this change and perhaps explain a little more in the javadocs what the method actually does.", "author": "sbordet", "createdAt": "2020-12-23T16:38:00Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -604,8 +604,8 @@ boolean tryRelease()\n         }\n \n         /**\n-         * Try to mark the entry as removed.\n-         * @return true if the entry has to be removed from the containing pool, false otherwise.\n+         * Mark the entry as closed.", "originalCommit": "5b8246fe345d06833a4df2c4241b81b0d7fd54b2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTE2ODc5MA==", "url": "https://github.com/eclipse/jetty.project/pull/5801#discussion_r551168790", "bodyText": "Damn, I replaced incomplete doc with with even worse doc! Let me rework this.", "author": "lorban", "createdAt": "2021-01-04T08:16:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA0NDg1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA0NTM4MQ==", "url": "https://github.com/eclipse/jetty.project/pull/5801#discussion_r548045381", "bodyText": "Changes to this class are unrelated with the PR, right?", "author": "sbordet", "createdAt": "2020-12-23T16:39:07Z", "path": "jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java", "diffHunk": "@@ -53,7 +52,24 @@\n \n     interface Factory\n     {\n-        Pool<String> getPool(int maxSize);\n+        Pool<CloseableHolder> getPool(int maxSize);", "originalCommit": "5b8246fe345d06833a4df2c4241b81b0d7fd54b2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTE2ODA2Mg==", "url": "https://github.com/eclipse/jetty.project/pull/5801#discussion_r551168062", "bodyText": "Correct. I wanted to add a few more checks to assert that connections are closed when they should be while working on this PR.", "author": "lorban", "createdAt": "2021-01-04T08:14:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA0NTM4MQ=="}], "type": "inlineReview"}, {"oid": "e6ca0d9530735a0902843952a954a5920d0495c7", "url": "https://github.com/eclipse/jetty.project/commit/e6ca0d9530735a0902843952a954a5920d0495c7", "message": "implement connection pool max duration", "committedDate": "2021-01-07T16:29:26Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzgzMjAxNQ==", "url": "https://github.com/eclipse/jetty.project/pull/5801#discussion_r553832015", "bodyText": "Can you please move this class at end of file?", "author": "sbordet", "createdAt": "2021-01-08T09:25:35Z", "path": "jetty-client/src/main/java/org/eclipse/jetty/client/AbstractConnectionPool.java", "diffHunk": "@@ -54,6 +57,23 @@\n     private final Callback requester;\n     private final Pool<Connection> pool;\n     private boolean maximizeConnections;\n+    private volatile long maxDurationNanos = 0L;\n+\n+    private static class EntryHolder", "originalCommit": "d16e97d0cf5e971e85f31f7b3596568f5b38d2cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDg5NTAzNQ==", "url": "https://github.com/eclipse/jetty.project/pull/5801#discussion_r554895035", "bodyText": "Ok.", "author": "lorban", "createdAt": "2021-01-11T08:51:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzgzMjAxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzgzMzA5Mg==", "url": "https://github.com/eclipse/jetty.project/pull/5801#discussion_r553833092", "bodyText": "Move the javadoc from the setter to the getter.\nAlso needs a paragraph explaining that the duration is passive and enforced on acquire(), so don't expect connections to be closed when maxDuration expires when they are idle -- there is the idleTimeout for that (link it).", "author": "sbordet", "createdAt": "2021-01-08T09:27:48Z", "path": "jetty-client/src/main/java/org/eclipse/jetty/client/AbstractConnectionPool.java", "diffHunk": "@@ -105,6 +125,22 @@ protected void doStop() throws Exception\n         return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]));\n     }\n \n+    @ManagedAttribute(value = \"The maximum duration in milliseconds a connection can be used for before it gets closed\")\n+    public long getMaxDuration()", "originalCommit": "d16e97d0cf5e971e85f31f7b3596568f5b38d2cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDkwMDcyMg==", "url": "https://github.com/eclipse/jetty.project/pull/5801#discussion_r554900722", "bodyText": "Ok, I've moved the javadoc and made it more substantial.", "author": "lorban", "createdAt": "2021-01-11T09:02:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzgzMzA5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzgzNDA3MQ==", "url": "https://github.com/eclipse/jetty.project/pull/5801#discussion_r553834071", "bodyText": "Can holder ever be null here?", "author": "sbordet", "createdAt": "2021-01-08T09:29:41Z", "path": "jetty-client/src/main/java/org/eclipse/jetty/client/AbstractConnectionPool.java", "diffHunk": "@@ -290,16 +326,35 @@ protected void proceed()\n \n     protected Connection activate()\n     {\n-        Pool<Connection>.Entry entry = pool.acquire();\n-        if (entry != null)\n+        while (true)\n         {\n-            if (LOG.isDebugEnabled())\n-                LOG.debug(\"Activated {} {}\", entry, pool);\n-            Connection connection = entry.getPooled();\n-            acquired(connection);\n-            return connection;\n+            Pool<Connection>.Entry entry = pool.acquire();\n+            if (entry != null)\n+            {\n+                Connection connection = entry.getPooled();\n+\n+                long maxDurationNanos = this.maxDurationNanos;\n+                if (maxDurationNanos > 0L)\n+                {\n+                    EntryHolder holder = (EntryHolder)((Attachable)connection).getAttachment();\n+                    if (holder != null && holder.isExpired(maxDurationNanos))", "originalCommit": "d16e97d0cf5e971e85f31f7b3596568f5b38d2cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDkwNTEzOQ==", "url": "https://github.com/eclipse/jetty.project/pull/5801#discussion_r554905139", "bodyText": "No, it can't. The only time the attachment can be null is before the entry is enabled or after it is removed so pool.acquire() can never return a connection with a null attachment. Let me remove this unneeded check.", "author": "lorban", "createdAt": "2021-01-11T09:11:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzgzNDA3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzgzNTMwMQ==", "url": "https://github.com/eclipse/jetty.project/pull/5801#discussion_r553835301", "bodyText": "The comment is now wrong :)", "author": "sbordet", "createdAt": "2021-01-08T09:32:20Z", "path": "jetty-client/src/test/java/org/eclipse/jetty/client/ConnectionPoolTest.java", "diffHunk": "@@ -432,6 +441,128 @@ protected void service(String target, org.eclipse.jetty.server.Request jettyRequ\n         assertThat(connectionPool.getConnectionCount(), Matchers.greaterThanOrEqualTo(count));\n     }\n \n+    @Test\n+    public void testMaxDurationConnectionsWithConstrainedPool() throws Exception\n+    {\n+        // ConnectionPools may NOT open a few more connections than expected.", "originalCommit": "d16e97d0cf5e971e85f31f7b3596568f5b38d2cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDkwNTc4Ng==", "url": "https://github.com/eclipse/jetty.project/pull/5801#discussion_r554905786", "bodyText": "It's not because in this test, the pool is constrained to only a single connection. But I'll mention that in the comment.", "author": "lorban", "createdAt": "2021-01-11T09:12:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzgzNTMwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzgzNjk3Ng==", "url": "https://github.com/eclipse/jetty.project/pull/5801#discussion_r553836976", "bodyText": "Why execute() if you're waiting for the response? I would simplify and just:\nContentResponse response = client.newRequest(...)\n  .timeout(5, SECONDS)\n  .send();\nassertEquals(200, response.getStatus());", "author": "sbordet", "createdAt": "2021-01-08T09:35:43Z", "path": "jetty-client/src/test/java/org/eclipse/jetty/client/ConnectionPoolTest.java", "diffHunk": "@@ -432,6 +441,128 @@ protected void service(String target, org.eclipse.jetty.server.Request jettyRequ\n         assertThat(connectionPool.getConnectionCount(), Matchers.greaterThanOrEqualTo(count));\n     }\n \n+    @Test\n+    public void testMaxDurationConnectionsWithConstrainedPool() throws Exception\n+    {\n+        // ConnectionPools may NOT open a few more connections than expected.\n+\n+        final int maxDuration = 30;\n+        AtomicInteger poolAcquireCounter = new AtomicInteger();\n+        AtomicInteger poolRemoveCounter = new AtomicInteger();\n+        ConnectionPoolFactory factory = new ConnectionPoolFactory(\"duplex-maxDuration\", destination ->\n+        {\n+            // Constrain the max pool size to 1.\n+            DuplexConnectionPool pool = new DuplexConnectionPool(destination, 1, destination)\n+            {\n+                @Override\n+                protected void acquired(Connection connection)\n+                {\n+                    poolAcquireCounter.incrementAndGet();\n+                }\n+\n+                @Override\n+                protected void removed(Connection connection)\n+                {\n+                    poolRemoveCounter.incrementAndGet();\n+                }\n+            };\n+            pool.setMaxDuration(maxDuration);\n+            return pool;\n+        });\n+\n+        startServer(new EmptyServerHandler());\n+\n+        QueuedThreadPool clientThreads = new QueuedThreadPool(3);\n+        clientThreads.setName(\"client\");\n+        HttpClientTransport transport = new HttpClientTransportOverHTTP(1);\n+        transport.setConnectionPoolFactory(factory.factory);\n+        client = new HttpClient(transport, null);\n+        client.setExecutor(clientThreads);\n+        client.start();\n+\n+        // Use the connection pool 5 times with a delay that is longer than the max duration in between each time.\n+        for (int i = 0; i < 5; i++)\n+        {\n+            CountDownLatch latch = new CountDownLatch(1);\n+            clientThreads.execute(() -> client.newRequest(\"localhost\", connector.getLocalPort())", "originalCommit": "d16e97d0cf5e971e85f31f7b3596568f5b38d2cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDkxMDYwNg==", "url": "https://github.com/eclipse/jetty.project/pull/5801#discussion_r554910606", "bodyText": "Indeed. Let me change that.", "author": "lorban", "createdAt": "2021-01-11T09:21:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzgzNjk3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzgzODAwMA==", "url": "https://github.com/eclipse/jetty.project/pull/5801#discussion_r553838000", "bodyText": "Don't execute(), see other comment.", "author": "sbordet", "createdAt": "2021-01-08T09:37:42Z", "path": "jetty-client/src/test/java/org/eclipse/jetty/client/ConnectionPoolTest.java", "diffHunk": "@@ -432,6 +441,128 @@ protected void service(String target, org.eclipse.jetty.server.Request jettyRequ\n         assertThat(connectionPool.getConnectionCount(), Matchers.greaterThanOrEqualTo(count));\n     }\n \n+    @Test\n+    public void testMaxDurationConnectionsWithConstrainedPool() throws Exception\n+    {\n+        // ConnectionPools may NOT open a few more connections than expected.\n+\n+        final int maxDuration = 30;\n+        AtomicInteger poolAcquireCounter = new AtomicInteger();\n+        AtomicInteger poolRemoveCounter = new AtomicInteger();\n+        ConnectionPoolFactory factory = new ConnectionPoolFactory(\"duplex-maxDuration\", destination ->\n+        {\n+            // Constrain the max pool size to 1.\n+            DuplexConnectionPool pool = new DuplexConnectionPool(destination, 1, destination)\n+            {\n+                @Override\n+                protected void acquired(Connection connection)\n+                {\n+                    poolAcquireCounter.incrementAndGet();\n+                }\n+\n+                @Override\n+                protected void removed(Connection connection)\n+                {\n+                    poolRemoveCounter.incrementAndGet();\n+                }\n+            };\n+            pool.setMaxDuration(maxDuration);\n+            return pool;\n+        });\n+\n+        startServer(new EmptyServerHandler());\n+\n+        QueuedThreadPool clientThreads = new QueuedThreadPool(3);\n+        clientThreads.setName(\"client\");\n+        HttpClientTransport transport = new HttpClientTransportOverHTTP(1);\n+        transport.setConnectionPoolFactory(factory.factory);\n+        client = new HttpClient(transport, null);\n+        client.setExecutor(clientThreads);\n+        client.start();\n+\n+        // Use the connection pool 5 times with a delay that is longer than the max duration in between each time.\n+        for (int i = 0; i < 5; i++)\n+        {\n+            CountDownLatch latch = new CountDownLatch(1);\n+            clientThreads.execute(() -> client.newRequest(\"localhost\", connector.getLocalPort())\n+                .send(result ->\n+                {\n+                    if (result.isSucceeded())\n+                        latch.countDown();\n+                }));\n+            assertTrue(latch.await(1, TimeUnit.SECONDS));\n+\n+            Thread.sleep(maxDuration * 2);\n+        }\n+\n+        // Check that the pool acquired 5 and removed 4 connections;\n+        // it must be exactly 4 removed b/c each cycle of the loop\n+        // can only open 1 connection as the pool is constrained to\n+        // maximum 1 connection.\n+        assertThat(poolAcquireCounter.get(), Matchers.is(5));\n+        assertThat(poolRemoveCounter.get(), Matchers.is(4));\n+    }\n+\n+    @Test\n+    public void testMaxDurationConnectionsWithUnconstrainedPool() throws Exception\n+    {\n+        // ConnectionPools may open a few more connections than expected.\n+\n+        final int maxDuration = 30;\n+        AtomicInteger poolAcquireCounter = new AtomicInteger();\n+        AtomicInteger poolRemoveCounter = new AtomicInteger();\n+        ConnectionPoolFactory factory = new ConnectionPoolFactory(\"duplex-maxDuration\", destination ->\n+        {\n+            DuplexConnectionPool pool = new DuplexConnectionPool(destination, destination.getHttpClient().getMaxConnectionsPerDestination(), destination)\n+            {\n+                @Override\n+                protected void acquired(Connection connection)\n+                {\n+                    poolAcquireCounter.incrementAndGet();\n+                }\n+\n+                @Override\n+                protected void removed(Connection connection)\n+                {\n+                    poolRemoveCounter.incrementAndGet();\n+                }\n+            };\n+            pool.setMaxDuration(maxDuration);\n+            return pool;\n+        });\n+\n+        startServer(new EmptyServerHandler());\n+\n+        QueuedThreadPool clientThreads = new QueuedThreadPool(3);\n+        clientThreads.setName(\"client\");\n+        HttpClientTransport transport = new HttpClientTransportOverHTTP(1);\n+        transport.setConnectionPoolFactory(factory.factory);\n+        client = new HttpClient(transport, null);\n+        client.setExecutor(clientThreads);\n+        client.start();\n+\n+        // Use the connection pool 5 times with a delay that is longer than the max duration in between each time.\n+        for (int i = 0; i < 5; i++)\n+        {\n+            CountDownLatch latch = new CountDownLatch(1);\n+            clientThreads.execute(() -> client.newRequest(\"localhost\", connector.getLocalPort())", "originalCommit": "d16e97d0cf5e971e85f31f7b3596568f5b38d2cf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzgzOTE2OQ==", "url": "https://github.com/eclipse/jetty.project/pull/5801#discussion_r553839169", "bodyText": "Remove comment, the comment below just before the asserts is enough.", "author": "sbordet", "createdAt": "2021-01-08T09:39:55Z", "path": "jetty-http2/http2-http-client-transport/src/test/java/org/eclipse/jetty/http2/client/http/MultiplexedConnectionPoolTest.java", "diffHunk": "@@ -0,0 +1,304 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.http2.client.http;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.eclipse.jetty.client.ConnectionPool;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.HttpClientTransport;\n+import org.eclipse.jetty.client.MultiplexConnectionPool;\n+import org.eclipse.jetty.client.api.Connection;\n+import org.eclipse.jetty.http2.client.HTTP2Client;\n+import org.eclipse.jetty.http2.server.HTTP2ServerConnectionFactory;\n+import org.eclipse.jetty.server.Handler;\n+import org.eclipse.jetty.server.HttpConfiguration;\n+import org.eclipse.jetty.server.Request;\n+import org.eclipse.jetty.server.Server;\n+import org.eclipse.jetty.server.ServerConnector;\n+import org.eclipse.jetty.util.Pool;\n+import org.eclipse.jetty.util.thread.QueuedThreadPool;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.allOf;\n+import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.lessThanOrEqualTo;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+// Sibling of ConnectionPoolTest, but using H2 to multiplex connections.\n+public class MultiplexedConnectionPoolTest\n+{\n+    private Server server;\n+    private ServerConnector connector;\n+    private HttpClient client;\n+\n+    private void startServer(Handler handler) throws Exception\n+    {\n+        server = new Server();\n+        connector = new ServerConnector(server, 1, 1, new HTTP2ServerConnectionFactory(new HttpConfiguration()));\n+        server.addConnector(connector);\n+        server.setHandler(handler);\n+        server.start();\n+    }\n+\n+    @AfterEach\n+    public void disposeServer() throws Exception\n+    {\n+        connector = null;\n+        if (server != null)\n+        {\n+            server.stop();\n+            server = null;\n+        }\n+    }\n+\n+    @AfterEach\n+    public void disposeClient() throws Exception\n+    {\n+        if (client != null)\n+        {\n+            client.stop();\n+            client = null;\n+        }\n+    }\n+\n+    @Test\n+    public void testMaxDurationConnectionsWithMultiplexedPool() throws Exception\n+    {\n+        // ConnectionPools may open a few more connections than expected.", "originalCommit": "d16e97d0cf5e971e85f31f7b3596568f5b38d2cf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzgzOTg0OQ==", "url": "https://github.com/eclipse/jetty.project/pull/5801#discussion_r553839849", "bodyText": "Don't limit the threads to just so few. We don't want this test to depend on the thread pool behavior.", "author": "sbordet", "createdAt": "2021-01-08T09:41:18Z", "path": "jetty-client/src/test/java/org/eclipse/jetty/client/ConnectionPoolTest.java", "diffHunk": "@@ -432,6 +441,128 @@ protected void service(String target, org.eclipse.jetty.server.Request jettyRequ\n         assertThat(connectionPool.getConnectionCount(), Matchers.greaterThanOrEqualTo(count));\n     }\n \n+    @Test\n+    public void testMaxDurationConnectionsWithConstrainedPool() throws Exception\n+    {\n+        // ConnectionPools may NOT open a few more connections than expected.\n+\n+        final int maxDuration = 30;\n+        AtomicInteger poolAcquireCounter = new AtomicInteger();\n+        AtomicInteger poolRemoveCounter = new AtomicInteger();\n+        ConnectionPoolFactory factory = new ConnectionPoolFactory(\"duplex-maxDuration\", destination ->\n+        {\n+            // Constrain the max pool size to 1.\n+            DuplexConnectionPool pool = new DuplexConnectionPool(destination, 1, destination)\n+            {\n+                @Override\n+                protected void acquired(Connection connection)\n+                {\n+                    poolAcquireCounter.incrementAndGet();\n+                }\n+\n+                @Override\n+                protected void removed(Connection connection)\n+                {\n+                    poolRemoveCounter.incrementAndGet();\n+                }\n+            };\n+            pool.setMaxDuration(maxDuration);\n+            return pool;\n+        });\n+\n+        startServer(new EmptyServerHandler());\n+\n+        QueuedThreadPool clientThreads = new QueuedThreadPool(3);", "originalCommit": "d16e97d0cf5e971e85f31f7b3596568f5b38d2cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDkxMDY4NA==", "url": "https://github.com/eclipse/jetty.project/pull/5801#discussion_r554910684", "bodyText": "Indeed. Let me change that.", "author": "lorban", "createdAt": "2021-01-11T09:21:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzgzOTg0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg0MDAzNg==", "url": "https://github.com/eclipse/jetty.project/pull/5801#discussion_r553840036", "bodyText": "Same as above.", "author": "sbordet", "createdAt": "2021-01-08T09:41:41Z", "path": "jetty-client/src/test/java/org/eclipse/jetty/client/ConnectionPoolTest.java", "diffHunk": "@@ -432,6 +441,128 @@ protected void service(String target, org.eclipse.jetty.server.Request jettyRequ\n         assertThat(connectionPool.getConnectionCount(), Matchers.greaterThanOrEqualTo(count));\n     }\n \n+    @Test\n+    public void testMaxDurationConnectionsWithConstrainedPool() throws Exception\n+    {\n+        // ConnectionPools may NOT open a few more connections than expected.\n+\n+        final int maxDuration = 30;\n+        AtomicInteger poolAcquireCounter = new AtomicInteger();\n+        AtomicInteger poolRemoveCounter = new AtomicInteger();\n+        ConnectionPoolFactory factory = new ConnectionPoolFactory(\"duplex-maxDuration\", destination ->\n+        {\n+            // Constrain the max pool size to 1.\n+            DuplexConnectionPool pool = new DuplexConnectionPool(destination, 1, destination)\n+            {\n+                @Override\n+                protected void acquired(Connection connection)\n+                {\n+                    poolAcquireCounter.incrementAndGet();\n+                }\n+\n+                @Override\n+                protected void removed(Connection connection)\n+                {\n+                    poolRemoveCounter.incrementAndGet();\n+                }\n+            };\n+            pool.setMaxDuration(maxDuration);\n+            return pool;\n+        });\n+\n+        startServer(new EmptyServerHandler());\n+\n+        QueuedThreadPool clientThreads = new QueuedThreadPool(3);\n+        clientThreads.setName(\"client\");\n+        HttpClientTransport transport = new HttpClientTransportOverHTTP(1);\n+        transport.setConnectionPoolFactory(factory.factory);\n+        client = new HttpClient(transport, null);\n+        client.setExecutor(clientThreads);\n+        client.start();\n+\n+        // Use the connection pool 5 times with a delay that is longer than the max duration in between each time.\n+        for (int i = 0; i < 5; i++)\n+        {\n+            CountDownLatch latch = new CountDownLatch(1);\n+            clientThreads.execute(() -> client.newRequest(\"localhost\", connector.getLocalPort())\n+                .send(result ->\n+                {\n+                    if (result.isSucceeded())\n+                        latch.countDown();\n+                }));\n+            assertTrue(latch.await(1, TimeUnit.SECONDS));\n+\n+            Thread.sleep(maxDuration * 2);\n+        }\n+\n+        // Check that the pool acquired 5 and removed 4 connections;\n+        // it must be exactly 4 removed b/c each cycle of the loop\n+        // can only open 1 connection as the pool is constrained to\n+        // maximum 1 connection.\n+        assertThat(poolAcquireCounter.get(), Matchers.is(5));\n+        assertThat(poolRemoveCounter.get(), Matchers.is(4));\n+    }\n+\n+    @Test\n+    public void testMaxDurationConnectionsWithUnconstrainedPool() throws Exception\n+    {\n+        // ConnectionPools may open a few more connections than expected.\n+\n+        final int maxDuration = 30;\n+        AtomicInteger poolAcquireCounter = new AtomicInteger();\n+        AtomicInteger poolRemoveCounter = new AtomicInteger();\n+        ConnectionPoolFactory factory = new ConnectionPoolFactory(\"duplex-maxDuration\", destination ->\n+        {\n+            DuplexConnectionPool pool = new DuplexConnectionPool(destination, destination.getHttpClient().getMaxConnectionsPerDestination(), destination)\n+            {\n+                @Override\n+                protected void acquired(Connection connection)\n+                {\n+                    poolAcquireCounter.incrementAndGet();\n+                }\n+\n+                @Override\n+                protected void removed(Connection connection)\n+                {\n+                    poolRemoveCounter.incrementAndGet();\n+                }\n+            };\n+            pool.setMaxDuration(maxDuration);\n+            return pool;\n+        });\n+\n+        startServer(new EmptyServerHandler());\n+\n+        QueuedThreadPool clientThreads = new QueuedThreadPool(3);", "originalCommit": "d16e97d0cf5e971e85f31f7b3596568f5b38d2cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDkxMDc0OQ==", "url": "https://github.com/eclipse/jetty.project/pull/5801#discussion_r554910749", "bodyText": "Indeed. Let me change that.", "author": "lorban", "createdAt": "2021-01-11T09:21:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg0MDAzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg0MTE3OA==", "url": "https://github.com/eclipse/jetty.project/pull/5801#discussion_r553841178", "bodyText": "Use the default maxThreads.", "author": "sbordet", "createdAt": "2021-01-08T09:43:51Z", "path": "jetty-http2/http2-http-client-transport/src/test/java/org/eclipse/jetty/http2/client/http/MultiplexedConnectionPoolTest.java", "diffHunk": "@@ -0,0 +1,304 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.http2.client.http;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.eclipse.jetty.client.ConnectionPool;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.HttpClientTransport;\n+import org.eclipse.jetty.client.MultiplexConnectionPool;\n+import org.eclipse.jetty.client.api.Connection;\n+import org.eclipse.jetty.http2.client.HTTP2Client;\n+import org.eclipse.jetty.http2.server.HTTP2ServerConnectionFactory;\n+import org.eclipse.jetty.server.Handler;\n+import org.eclipse.jetty.server.HttpConfiguration;\n+import org.eclipse.jetty.server.Request;\n+import org.eclipse.jetty.server.Server;\n+import org.eclipse.jetty.server.ServerConnector;\n+import org.eclipse.jetty.util.Pool;\n+import org.eclipse.jetty.util.thread.QueuedThreadPool;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.allOf;\n+import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.lessThanOrEqualTo;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+// Sibling of ConnectionPoolTest, but using H2 to multiplex connections.\n+public class MultiplexedConnectionPoolTest\n+{\n+    private Server server;\n+    private ServerConnector connector;\n+    private HttpClient client;\n+\n+    private void startServer(Handler handler) throws Exception\n+    {\n+        server = new Server();\n+        connector = new ServerConnector(server, 1, 1, new HTTP2ServerConnectionFactory(new HttpConfiguration()));\n+        server.addConnector(connector);\n+        server.setHandler(handler);\n+        server.start();\n+    }\n+\n+    @AfterEach\n+    public void disposeServer() throws Exception\n+    {\n+        connector = null;\n+        if (server != null)\n+        {\n+            server.stop();\n+            server = null;\n+        }\n+    }\n+\n+    @AfterEach\n+    public void disposeClient() throws Exception\n+    {\n+        if (client != null)\n+        {\n+            client.stop();\n+            client = null;\n+        }\n+    }\n+\n+    @Test\n+    public void testMaxDurationConnectionsWithMultiplexedPool() throws Exception\n+    {\n+        // ConnectionPools may open a few more connections than expected.\n+\n+        final int maxDuration = 30;\n+        AtomicInteger poolAcquireCounter = new AtomicInteger();\n+        AtomicInteger poolRemoveCounter = new AtomicInteger();\n+        AtomicReference<Pool<Connection>> poolRef = new AtomicReference<>();\n+        ConnectionPoolFactory factory = new ConnectionPoolFactory(\"duplex-maxDuration\", destination ->\n+        {\n+            int maxConnections = destination.getHttpClient().getMaxConnectionsPerDestination();\n+            Pool<Connection> pool = new Pool<>(Pool.StrategyType.FIRST, maxConnections, false);\n+            poolRef.set(pool);\n+            MultiplexConnectionPool connectionPool = new MultiplexConnectionPool(destination, pool, destination, 2)\n+            {\n+                @Override\n+                protected void acquired(Connection connection)\n+                {\n+                    poolAcquireCounter.incrementAndGet();\n+                }\n+\n+                @Override\n+                protected void removed(Connection connection)\n+                {\n+                    poolRemoveCounter.incrementAndGet();\n+                }\n+            };\n+            connectionPool.setMaxDuration(maxDuration);\n+            return connectionPool;\n+        });\n+\n+        startServer(new EmptyServerHandler());\n+\n+        QueuedThreadPool clientThreads = new QueuedThreadPool(3);", "originalCommit": "d16e97d0cf5e971e85f31f7b3596568f5b38d2cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDk2NjU4MA==", "url": "https://github.com/eclipse/jetty.project/pull/5801#discussion_r554966580", "bodyText": "Ok.", "author": "lorban", "createdAt": "2021-01-11T10:59:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg0MTE3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg0MjIwNQ==", "url": "https://github.com/eclipse/jetty.project/pull/5801#discussion_r553842205", "bodyText": "I'm surprised the test has the same numbers of the non-multiplexed one.\nIf you're testing correct behavior, should you not test connection rather than number of times acquired() has been called (as it could be called with the same connection object)?", "author": "sbordet", "createdAt": "2021-01-08T09:45:44Z", "path": "jetty-http2/http2-http-client-transport/src/test/java/org/eclipse/jetty/http2/client/http/MultiplexedConnectionPoolTest.java", "diffHunk": "@@ -0,0 +1,304 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.http2.client.http;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.eclipse.jetty.client.ConnectionPool;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.HttpClientTransport;\n+import org.eclipse.jetty.client.MultiplexConnectionPool;\n+import org.eclipse.jetty.client.api.Connection;\n+import org.eclipse.jetty.http2.client.HTTP2Client;\n+import org.eclipse.jetty.http2.server.HTTP2ServerConnectionFactory;\n+import org.eclipse.jetty.server.Handler;\n+import org.eclipse.jetty.server.HttpConfiguration;\n+import org.eclipse.jetty.server.Request;\n+import org.eclipse.jetty.server.Server;\n+import org.eclipse.jetty.server.ServerConnector;\n+import org.eclipse.jetty.util.Pool;\n+import org.eclipse.jetty.util.thread.QueuedThreadPool;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.allOf;\n+import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.lessThanOrEqualTo;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+// Sibling of ConnectionPoolTest, but using H2 to multiplex connections.\n+public class MultiplexedConnectionPoolTest\n+{\n+    private Server server;\n+    private ServerConnector connector;\n+    private HttpClient client;\n+\n+    private void startServer(Handler handler) throws Exception\n+    {\n+        server = new Server();\n+        connector = new ServerConnector(server, 1, 1, new HTTP2ServerConnectionFactory(new HttpConfiguration()));\n+        server.addConnector(connector);\n+        server.setHandler(handler);\n+        server.start();\n+    }\n+\n+    @AfterEach\n+    public void disposeServer() throws Exception\n+    {\n+        connector = null;\n+        if (server != null)\n+        {\n+            server.stop();\n+            server = null;\n+        }\n+    }\n+\n+    @AfterEach\n+    public void disposeClient() throws Exception\n+    {\n+        if (client != null)\n+        {\n+            client.stop();\n+            client = null;\n+        }\n+    }\n+\n+    @Test\n+    public void testMaxDurationConnectionsWithMultiplexedPool() throws Exception\n+    {\n+        // ConnectionPools may open a few more connections than expected.\n+\n+        final int maxDuration = 30;\n+        AtomicInteger poolAcquireCounter = new AtomicInteger();\n+        AtomicInteger poolRemoveCounter = new AtomicInteger();\n+        AtomicReference<Pool<Connection>> poolRef = new AtomicReference<>();\n+        ConnectionPoolFactory factory = new ConnectionPoolFactory(\"duplex-maxDuration\", destination ->\n+        {\n+            int maxConnections = destination.getHttpClient().getMaxConnectionsPerDestination();\n+            Pool<Connection> pool = new Pool<>(Pool.StrategyType.FIRST, maxConnections, false);\n+            poolRef.set(pool);\n+            MultiplexConnectionPool connectionPool = new MultiplexConnectionPool(destination, pool, destination, 2)\n+            {\n+                @Override\n+                protected void acquired(Connection connection)\n+                {\n+                    poolAcquireCounter.incrementAndGet();\n+                }\n+\n+                @Override\n+                protected void removed(Connection connection)\n+                {\n+                    poolRemoveCounter.incrementAndGet();\n+                }\n+            };\n+            connectionPool.setMaxDuration(maxDuration);\n+            return connectionPool;\n+        });\n+\n+        startServer(new EmptyServerHandler());\n+\n+        QueuedThreadPool clientThreads = new QueuedThreadPool(3);\n+        clientThreads.setName(\"client\");\n+        HttpClientTransport transport = new HttpClientTransportOverHTTP2(new HTTP2Client());\n+        transport.setConnectionPoolFactory(factory.factory);\n+        client = new HttpClient(transport, null);\n+        client.setExecutor(clientThreads);\n+        client.start();\n+\n+        // Use the connection pool 5 times with a delay that is longer than the max duration in between each time.\n+        for (int i = 0; i < 5; i++)\n+        {\n+            CountDownLatch latch = new CountDownLatch(1);\n+            clientThreads.execute(() -> client.newRequest(\"localhost\", connector.getLocalPort())\n+                .send(result ->\n+                {\n+                    if (result.isSucceeded())\n+                        latch.countDown();\n+                }));\n+            assertTrue(latch.await(1, TimeUnit.SECONDS));\n+\n+            // Check that the pool never grows above 1.\n+            assertThat(poolRef.get().size(), is(1));\n+\n+            Thread.sleep(maxDuration * 2);\n+        }\n+\n+        // Check that the pool acquired 5 and removed 4 connections;\n+        // it must be exactly 4 removed b/c while the pool is not\n+        // constrained, it can multiplex requests on a single connection\n+        // so that should prevent opening more connections than needed.\n+        assertThat(poolAcquireCounter.get(), is(5));\n+        assertThat(poolRemoveCounter.get(), is(4));", "originalCommit": "d16e97d0cf5e971e85f31f7b3596568f5b38d2cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDk2NzQwNw==", "url": "https://github.com/eclipse/jetty.project/pull/5801#discussion_r554967407", "bodyText": "This test should assert creations, not acquisitions. But besides that, it asserts that multiplexed connections are not reused since they expire between each use. This is why the figures are the same as for the non-multiplexed tests.", "author": "lorban", "createdAt": "2021-01-11T11:00:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg0MjIwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg0NjE4Mg==", "url": "https://github.com/eclipse/jetty.project/pull/5801#discussion_r553846182", "bodyText": "Don't execute() also because you risk creating 2 connections, not just one.", "author": "sbordet", "createdAt": "2021-01-08T09:53:15Z", "path": "jetty-http2/http2-http-client-transport/src/test/java/org/eclipse/jetty/http2/client/http/MultiplexedConnectionPoolTest.java", "diffHunk": "@@ -0,0 +1,304 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.http2.client.http;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.eclipse.jetty.client.ConnectionPool;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.HttpClientTransport;\n+import org.eclipse.jetty.client.MultiplexConnectionPool;\n+import org.eclipse.jetty.client.api.Connection;\n+import org.eclipse.jetty.http2.client.HTTP2Client;\n+import org.eclipse.jetty.http2.server.HTTP2ServerConnectionFactory;\n+import org.eclipse.jetty.server.Handler;\n+import org.eclipse.jetty.server.HttpConfiguration;\n+import org.eclipse.jetty.server.Request;\n+import org.eclipse.jetty.server.Server;\n+import org.eclipse.jetty.server.ServerConnector;\n+import org.eclipse.jetty.util.Pool;\n+import org.eclipse.jetty.util.thread.QueuedThreadPool;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.allOf;\n+import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.lessThanOrEqualTo;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+// Sibling of ConnectionPoolTest, but using H2 to multiplex connections.\n+public class MultiplexedConnectionPoolTest\n+{\n+    private Server server;\n+    private ServerConnector connector;\n+    private HttpClient client;\n+\n+    private void startServer(Handler handler) throws Exception\n+    {\n+        server = new Server();\n+        connector = new ServerConnector(server, 1, 1, new HTTP2ServerConnectionFactory(new HttpConfiguration()));\n+        server.addConnector(connector);\n+        server.setHandler(handler);\n+        server.start();\n+    }\n+\n+    @AfterEach\n+    public void disposeServer() throws Exception\n+    {\n+        connector = null;\n+        if (server != null)\n+        {\n+            server.stop();\n+            server = null;\n+        }\n+    }\n+\n+    @AfterEach\n+    public void disposeClient() throws Exception\n+    {\n+        if (client != null)\n+        {\n+            client.stop();\n+            client = null;\n+        }\n+    }\n+\n+    @Test\n+    public void testMaxDurationConnectionsWithMultiplexedPool() throws Exception\n+    {\n+        // ConnectionPools may open a few more connections than expected.\n+\n+        final int maxDuration = 30;\n+        AtomicInteger poolAcquireCounter = new AtomicInteger();\n+        AtomicInteger poolRemoveCounter = new AtomicInteger();\n+        AtomicReference<Pool<Connection>> poolRef = new AtomicReference<>();\n+        ConnectionPoolFactory factory = new ConnectionPoolFactory(\"duplex-maxDuration\", destination ->\n+        {\n+            int maxConnections = destination.getHttpClient().getMaxConnectionsPerDestination();\n+            Pool<Connection> pool = new Pool<>(Pool.StrategyType.FIRST, maxConnections, false);\n+            poolRef.set(pool);\n+            MultiplexConnectionPool connectionPool = new MultiplexConnectionPool(destination, pool, destination, 2)\n+            {\n+                @Override\n+                protected void acquired(Connection connection)\n+                {\n+                    poolAcquireCounter.incrementAndGet();\n+                }\n+\n+                @Override\n+                protected void removed(Connection connection)\n+                {\n+                    poolRemoveCounter.incrementAndGet();\n+                }\n+            };\n+            connectionPool.setMaxDuration(maxDuration);\n+            return connectionPool;\n+        });\n+\n+        startServer(new EmptyServerHandler());\n+\n+        QueuedThreadPool clientThreads = new QueuedThreadPool(3);\n+        clientThreads.setName(\"client\");\n+        HttpClientTransport transport = new HttpClientTransportOverHTTP2(new HTTP2Client());\n+        transport.setConnectionPoolFactory(factory.factory);\n+        client = new HttpClient(transport, null);\n+        client.setExecutor(clientThreads);\n+        client.start();\n+\n+        // Use the connection pool 5 times with a delay that is longer than the max duration in between each time.\n+        for (int i = 0; i < 5; i++)\n+        {\n+            CountDownLatch latch = new CountDownLatch(1);\n+            clientThreads.execute(() -> client.newRequest(\"localhost\", connector.getLocalPort())\n+                .send(result ->\n+                {\n+                    if (result.isSucceeded())\n+                        latch.countDown();\n+                }));\n+            assertTrue(latch.await(1, TimeUnit.SECONDS));\n+\n+            // Check that the pool never grows above 1.\n+            assertThat(poolRef.get().size(), is(1));\n+\n+            Thread.sleep(maxDuration * 2);\n+        }\n+\n+        // Check that the pool acquired 5 and removed 4 connections;\n+        // it must be exactly 4 removed b/c while the pool is not\n+        // constrained, it can multiplex requests on a single connection\n+        // so that should prevent opening more connections than needed.\n+        assertThat(poolAcquireCounter.get(), is(5));\n+        assertThat(poolRemoveCounter.get(), is(4));\n+    }\n+\n+    @Test\n+    public void testMaxDurationConnectionsWithMultiplexedPoolClosesExpiredConnectionWhileStillInUse() throws Exception\n+    {\n+        // ConnectionPools may open a few more connections than expected.\n+\n+        final int maxDuration = 30;\n+        AtomicInteger poolAcquireCounter = new AtomicInteger();\n+        AtomicInteger poolRemoveCounter = new AtomicInteger();\n+        AtomicReference<Pool<Connection>> poolRef = new AtomicReference<>();\n+        ConnectionPoolFactory factory = new ConnectionPoolFactory(\"duplex-maxDuration\", destination ->\n+        {\n+            int maxConnections = destination.getHttpClient().getMaxConnectionsPerDestination();\n+            Pool<Connection> pool = new Pool<>(Pool.StrategyType.FIRST, maxConnections, false);\n+            poolRef.set(pool);\n+            MultiplexConnectionPool connectionPool = new MultiplexConnectionPool(destination, pool, destination, 2)\n+            {\n+                @Override\n+                protected void acquired(Connection connection)\n+                {\n+                    poolAcquireCounter.incrementAndGet();\n+                }\n+\n+                @Override\n+                protected void removed(Connection connection)\n+                {\n+                    poolRemoveCounter.incrementAndGet();\n+                }\n+            };\n+            connectionPool.setMaxDuration(maxDuration);\n+            return connectionPool;\n+        });\n+\n+        Semaphore semaphore = new Semaphore(0);\n+        startServer(new EmptyServerHandler()\n+        {\n+            @Override\n+            protected void service(String target, Request jettyRequest, HttpServletRequest request, HttpServletResponse response) throws ServletException\n+            {\n+                if (!target.equals(\"/block\"))\n+                    return;\n+\n+                try\n+                {\n+                    semaphore.acquire();\n+                }\n+                catch (Exception e)\n+                {\n+                    throw new ServletException(e);\n+                }\n+            }\n+        });\n+\n+        QueuedThreadPool clientThreads = new QueuedThreadPool(10);\n+        clientThreads.setName(\"client\");\n+        HttpClientTransport transport = new HttpClientTransportOverHTTP2(new HTTP2Client());\n+        transport.setConnectionPoolFactory(factory.factory);\n+        client = new HttpClient(transport, null);\n+        client.setExecutor(clientThreads);\n+        client.start();\n+\n+        for (int i = 0; i < 5; i++)\n+        {\n+            CountDownLatch latch1 = new CountDownLatch(1);\n+            CountDownLatch latch2 = new CountDownLatch(2);\n+            // create 2 requests that are going to consume all the multiplexing slots\n+            clientThreads.execute(() -> client.newRequest(\"http://localhost:\" + connector.getLocalPort() + \"/block\")\n+                .send(result ->\n+                {\n+                    if (result.isSucceeded())\n+                    {\n+                        latch1.countDown();\n+                        latch2.countDown();\n+                    }\n+                }));\n+            clientThreads.execute(() -> client.newRequest(\"http://localhost:\" + connector.getLocalPort() + \"/block\")\n+                .send(result ->\n+                {\n+                    if (result.isSucceeded())\n+                    {\n+                        latch1.countDown();\n+                        latch2.countDown();\n+                    }\n+                }));", "originalCommit": "d16e97d0cf5e971e85f31f7b3596568f5b38d2cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDk2ODM2Mw==", "url": "https://github.com/eclipse/jetty.project/pull/5801#discussion_r554968363", "bodyText": "I've completely revisited this test as there were many discrepancies between what I wanted to test and what it actually tested. It should now be much stricter about the behavior it generates and what it asserts.", "author": "lorban", "createdAt": "2021-01-11T11:02:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg0NjE4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTY4MjEyNg==", "url": "https://github.com/eclipse/jetty.project/pull/5801#discussion_r555682126", "bodyText": "You want to override onCreated() not acquired().", "author": "sbordet", "createdAt": "2021-01-12T10:53:14Z", "path": "jetty-client/src/test/java/org/eclipse/jetty/client/ConnectionPoolTest.java", "diffHunk": "@@ -432,6 +441,115 @@ protected void service(String target, org.eclipse.jetty.server.Request jettyRequ\n         assertThat(connectionPool.getConnectionCount(), Matchers.greaterThanOrEqualTo(count));\n     }\n \n+    @Test\n+    public void testMaxDurationConnectionsWithConstrainedPool() throws Exception\n+    {\n+        // ConnectionPool may NOT open more connections than expected because\n+        // it is constrained to a single connection in this test.\n+\n+        final int maxDuration = 30;\n+        AtomicInteger poolAcquireCounter = new AtomicInteger();\n+        AtomicInteger poolRemoveCounter = new AtomicInteger();\n+        ConnectionPoolFactory factory = new ConnectionPoolFactory(\"duplex-maxDuration\", destination ->\n+        {\n+            // Constrain the max pool size to 1.\n+            DuplexConnectionPool pool = new DuplexConnectionPool(destination, 1, destination)\n+            {\n+                @Override\n+                protected void acquired(Connection connection)", "originalCommit": "b1d2a9ad95b5eb73f2bdc6c3e198192f40dc216d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTY5ODY5MQ==", "url": "https://github.com/eclipse/jetty.project/pull/5801#discussion_r555698691", "bodyText": "Indeed, let me change that.", "author": "lorban", "createdAt": "2021-01-12T11:22:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTY4MjEyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTY4MjI1OQ==", "url": "https://github.com/eclipse/jetty.project/pull/5801#discussion_r555682259", "bodyText": "Put it into a local variable, less \"magic\" numbers.", "author": "sbordet", "createdAt": "2021-01-12T10:53:30Z", "path": "jetty-client/src/test/java/org/eclipse/jetty/client/ConnectionPoolTest.java", "diffHunk": "@@ -432,6 +441,115 @@ protected void service(String target, org.eclipse.jetty.server.Request jettyRequ\n         assertThat(connectionPool.getConnectionCount(), Matchers.greaterThanOrEqualTo(count));\n     }\n \n+    @Test\n+    public void testMaxDurationConnectionsWithConstrainedPool() throws Exception\n+    {\n+        // ConnectionPool may NOT open more connections than expected because\n+        // it is constrained to a single connection in this test.\n+\n+        final int maxDuration = 30;\n+        AtomicInteger poolAcquireCounter = new AtomicInteger();\n+        AtomicInteger poolRemoveCounter = new AtomicInteger();\n+        ConnectionPoolFactory factory = new ConnectionPoolFactory(\"duplex-maxDuration\", destination ->\n+        {\n+            // Constrain the max pool size to 1.", "originalCommit": "b1d2a9ad95b5eb73f2bdc6c3e198192f40dc216d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTY5OTA0NQ==", "url": "https://github.com/eclipse/jetty.project/pull/5801#discussion_r555699045", "bodyText": "Ok.", "author": "lorban", "createdAt": "2021-01-12T11:22:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTY4MjI1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTY4MjcyMA==", "url": "https://github.com/eclipse/jetty.project/pull/5801#discussion_r555682720", "bodyText": "You want to override onCreated() not acquired().", "author": "sbordet", "createdAt": "2021-01-12T10:54:13Z", "path": "jetty-client/src/test/java/org/eclipse/jetty/client/ConnectionPoolTest.java", "diffHunk": "@@ -432,6 +441,115 @@ protected void service(String target, org.eclipse.jetty.server.Request jettyRequ\n         assertThat(connectionPool.getConnectionCount(), Matchers.greaterThanOrEqualTo(count));\n     }\n \n+    @Test\n+    public void testMaxDurationConnectionsWithConstrainedPool() throws Exception\n+    {\n+        // ConnectionPool may NOT open more connections than expected because\n+        // it is constrained to a single connection in this test.\n+\n+        final int maxDuration = 30;\n+        AtomicInteger poolAcquireCounter = new AtomicInteger();\n+        AtomicInteger poolRemoveCounter = new AtomicInteger();\n+        ConnectionPoolFactory factory = new ConnectionPoolFactory(\"duplex-maxDuration\", destination ->\n+        {\n+            // Constrain the max pool size to 1.\n+            DuplexConnectionPool pool = new DuplexConnectionPool(destination, 1, destination)\n+            {\n+                @Override\n+                protected void acquired(Connection connection)\n+                {\n+                    poolAcquireCounter.incrementAndGet();\n+                }\n+\n+                @Override\n+                protected void removed(Connection connection)\n+                {\n+                    poolRemoveCounter.incrementAndGet();\n+                }\n+            };\n+            pool.setMaxDuration(maxDuration);\n+            return pool;\n+        });\n+\n+        startServer(new EmptyServerHandler());\n+\n+        HttpClientTransport transport = new HttpClientTransportOverHTTP(1);\n+        transport.setConnectionPoolFactory(factory.factory);\n+        client = new HttpClient(transport, null);\n+        client.start();\n+\n+        // Use the connection pool 5 times with a delay that is longer than the max duration in between each time.\n+        for (int i = 0; i < 5; i++)\n+        {\n+            ContentResponse response = client.newRequest(\"localhost\", connector.getLocalPort())\n+                .timeout(5, TimeUnit.SECONDS)\n+                .send();\n+            assertThat(response.getStatus(), Matchers.is(200));\n+\n+            Thread.sleep(maxDuration * 2);\n+        }\n+\n+        // Check that the pool acquired 5 and removed 4 connections;\n+        // it must be exactly 4 removed b/c each cycle of the loop\n+        // can only open 1 connection as the pool is constrained to\n+        // maximum 1 connection.\n+        assertThat(poolAcquireCounter.get(), Matchers.is(5));\n+        assertThat(poolRemoveCounter.get(), Matchers.is(4));\n+    }\n+\n+    @Test\n+    public void testMaxDurationConnectionsWithUnconstrainedPool() throws Exception\n+    {\n+        // ConnectionPools may open a few more connections than expected.\n+\n+        final int maxDuration = 30;\n+        AtomicInteger poolAcquireCounter = new AtomicInteger();\n+        AtomicInteger poolRemoveCounter = new AtomicInteger();\n+        ConnectionPoolFactory factory = new ConnectionPoolFactory(\"duplex-maxDuration\", destination ->\n+        {\n+            DuplexConnectionPool pool = new DuplexConnectionPool(destination, destination.getHttpClient().getMaxConnectionsPerDestination(), destination)\n+            {\n+                @Override\n+                protected void acquired(Connection connection)", "originalCommit": "b1d2a9ad95b5eb73f2bdc6c3e198192f40dc216d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTY5ODkzNQ==", "url": "https://github.com/eclipse/jetty.project/pull/5801#discussion_r555698935", "bodyText": "Indeed, let me change that.", "author": "lorban", "createdAt": "2021-01-12T11:22:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTY4MjcyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTY4MzMzMg==", "url": "https://github.com/eclipse/jetty.project/pull/5801#discussion_r555683332", "bodyText": "Put maxMultiplex into a variable so it's clearer.", "author": "sbordet", "createdAt": "2021-01-12T10:55:08Z", "path": "jetty-http2/http2-http-client-transport/src/test/java/org/eclipse/jetty/http2/client/http/MultiplexedConnectionPoolTest.java", "diffHunk": "@@ -0,0 +1,306 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.http2.client.http;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.eclipse.jetty.client.ConnectionPool;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.HttpClientTransport;\n+import org.eclipse.jetty.client.MultiplexConnectionPool;\n+import org.eclipse.jetty.client.api.Connection;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.http2.client.HTTP2Client;\n+import org.eclipse.jetty.http2.server.HTTP2ServerConnectionFactory;\n+import org.eclipse.jetty.server.Handler;\n+import org.eclipse.jetty.server.HttpConfiguration;\n+import org.eclipse.jetty.server.Request;\n+import org.eclipse.jetty.server.Server;\n+import org.eclipse.jetty.server.ServerConnector;\n+import org.eclipse.jetty.util.Pool;\n+import org.eclipse.jetty.util.thread.QueuedThreadPool;\n+import org.hamcrest.Matchers;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+// Sibling of ConnectionPoolTest, but using H2 to multiplex connections.\n+public class MultiplexedConnectionPoolTest\n+{\n+    private Server server;\n+    private ServerConnector connector;\n+    private HttpClient client;\n+\n+    private void startServer(Handler handler) throws Exception\n+    {\n+        server = new Server();\n+        HTTP2ServerConnectionFactory http2ServerConnectionFactory = new HTTP2ServerConnectionFactory(new HttpConfiguration());\n+        http2ServerConnectionFactory.setMaxConcurrentStreams(2);\n+        connector = new ServerConnector(server, 1, 1, http2ServerConnectionFactory);\n+        server.addConnector(connector);\n+        server.setHandler(handler);\n+        server.start();\n+    }\n+\n+    @AfterEach\n+    public void disposeServer() throws Exception\n+    {\n+        connector = null;\n+        if (server != null)\n+        {\n+            server.stop();\n+            server = null;\n+        }\n+    }\n+\n+    @AfterEach\n+    public void disposeClient() throws Exception\n+    {\n+        if (client != null)\n+        {\n+            client.stop();\n+            client = null;\n+        }\n+    }\n+\n+    @Test\n+    public void testMaxDurationConnectionsWithMultiplexedPool() throws Exception\n+    {\n+        final int maxDuration = 30;\n+        AtomicInteger poolCreateCounter = new AtomicInteger();\n+        AtomicInteger poolRemoveCounter = new AtomicInteger();\n+        AtomicReference<Pool<Connection>> poolRef = new AtomicReference<>();\n+        ConnectionPoolFactory factory = new ConnectionPoolFactory(\"duplex-maxDuration\", destination ->\n+        {\n+            int maxConnections = destination.getHttpClient().getMaxConnectionsPerDestination();\n+            Pool<Connection> pool = new Pool<>(Pool.StrategyType.FIRST, maxConnections, false);\n+            poolRef.set(pool);\n+            MultiplexConnectionPool connectionPool = new MultiplexConnectionPool(destination, pool, destination, 2)", "originalCommit": "b1d2a9ad95b5eb73f2bdc6c3e198192f40dc216d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTY5OTM5NQ==", "url": "https://github.com/eclipse/jetty.project/pull/5801#discussion_r555699395", "bodyText": "Ok.", "author": "lorban", "createdAt": "2021-01-12T11:23:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTY4MzMzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTY4MzcyOA==", "url": "https://github.com/eclipse/jetty.project/pull/5801#discussion_r555683728", "bodyText": "Put maxMultiplex into a variable.", "author": "sbordet", "createdAt": "2021-01-12T10:55:48Z", "path": "jetty-http2/http2-http-client-transport/src/test/java/org/eclipse/jetty/http2/client/http/MultiplexedConnectionPoolTest.java", "diffHunk": "@@ -0,0 +1,306 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.http2.client.http;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.eclipse.jetty.client.ConnectionPool;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.HttpClientTransport;\n+import org.eclipse.jetty.client.MultiplexConnectionPool;\n+import org.eclipse.jetty.client.api.Connection;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.http2.client.HTTP2Client;\n+import org.eclipse.jetty.http2.server.HTTP2ServerConnectionFactory;\n+import org.eclipse.jetty.server.Handler;\n+import org.eclipse.jetty.server.HttpConfiguration;\n+import org.eclipse.jetty.server.Request;\n+import org.eclipse.jetty.server.Server;\n+import org.eclipse.jetty.server.ServerConnector;\n+import org.eclipse.jetty.util.Pool;\n+import org.eclipse.jetty.util.thread.QueuedThreadPool;\n+import org.hamcrest.Matchers;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+// Sibling of ConnectionPoolTest, but using H2 to multiplex connections.\n+public class MultiplexedConnectionPoolTest\n+{\n+    private Server server;\n+    private ServerConnector connector;\n+    private HttpClient client;\n+\n+    private void startServer(Handler handler) throws Exception\n+    {\n+        server = new Server();\n+        HTTP2ServerConnectionFactory http2ServerConnectionFactory = new HTTP2ServerConnectionFactory(new HttpConfiguration());\n+        http2ServerConnectionFactory.setMaxConcurrentStreams(2);\n+        connector = new ServerConnector(server, 1, 1, http2ServerConnectionFactory);\n+        server.addConnector(connector);\n+        server.setHandler(handler);\n+        server.start();\n+    }\n+\n+    @AfterEach\n+    public void disposeServer() throws Exception\n+    {\n+        connector = null;\n+        if (server != null)\n+        {\n+            server.stop();\n+            server = null;\n+        }\n+    }\n+\n+    @AfterEach\n+    public void disposeClient() throws Exception\n+    {\n+        if (client != null)\n+        {\n+            client.stop();\n+            client = null;\n+        }\n+    }\n+\n+    @Test\n+    public void testMaxDurationConnectionsWithMultiplexedPool() throws Exception\n+    {\n+        final int maxDuration = 30;\n+        AtomicInteger poolCreateCounter = new AtomicInteger();\n+        AtomicInteger poolRemoveCounter = new AtomicInteger();\n+        AtomicReference<Pool<Connection>> poolRef = new AtomicReference<>();\n+        ConnectionPoolFactory factory = new ConnectionPoolFactory(\"duplex-maxDuration\", destination ->\n+        {\n+            int maxConnections = destination.getHttpClient().getMaxConnectionsPerDestination();\n+            Pool<Connection> pool = new Pool<>(Pool.StrategyType.FIRST, maxConnections, false);\n+            poolRef.set(pool);\n+            MultiplexConnectionPool connectionPool = new MultiplexConnectionPool(destination, pool, destination, 2)\n+            {\n+                @Override\n+                protected void onCreated(Connection connection)\n+                {\n+                    poolCreateCounter.incrementAndGet();\n+                }\n+\n+                @Override\n+                protected void removed(Connection connection)\n+                {\n+                    poolRemoveCounter.incrementAndGet();\n+                }\n+            };\n+            connectionPool.setMaxDuration(maxDuration);\n+            return connectionPool;\n+        });\n+\n+        startServer(new EmptyServerHandler());\n+\n+        HttpClientTransport transport = new HttpClientTransportOverHTTP2(new HTTP2Client());\n+        transport.setConnectionPoolFactory(factory.factory);\n+        client = new HttpClient(transport, null);\n+        client.start();\n+\n+        // Use the connection pool 5 times with a delay that is longer than the max duration in between each time.\n+        for (int i = 0; i < 5; i++)\n+        {\n+            ContentResponse response = client.newRequest(\"localhost\", connector.getLocalPort())\n+                .timeout(5, TimeUnit.SECONDS)\n+                .send();\n+            assertThat(response.getStatus(), Matchers.is(200));\n+\n+            // Check that the pool never grows above 1.\n+            assertThat(poolRef.get().size(), is(1));\n+\n+            Thread.sleep(maxDuration * 2);\n+        }\n+\n+        // Check that the pool created 5 and removed 4 connections;\n+        // it must be exactly 4 removed b/c while the pool is not\n+        // constrained, it can multiplex requests on a single connection\n+        // so that should prevent opening more connections than needed.\n+        assertThat(poolCreateCounter.get(), is(5));\n+        assertThat(poolRemoveCounter.get(), is(4));\n+    }\n+\n+    @Test\n+    public void testMaxDurationConnectionsWithMultiplexedPoolClosesExpiredConnectionWhileStillInUse() throws Exception\n+    {\n+        final int maxDuration = 1000;\n+        final int maxIdle = 2000;\n+\n+        AtomicInteger poolCreateCounter = new AtomicInteger();\n+        AtomicInteger poolRemoveCounter = new AtomicInteger();\n+        AtomicReference<Pool<Connection>> poolRef = new AtomicReference<>();\n+        ConnectionPoolFactory factory = new ConnectionPoolFactory(\"duplex-maxDuration\", destination ->\n+        {\n+            int maxConnections = destination.getHttpClient().getMaxConnectionsPerDestination();\n+            Pool<Connection> pool = new Pool<>(Pool.StrategyType.FIRST, maxConnections, false);\n+            poolRef.set(pool);\n+            MultiplexConnectionPool connectionPool = new MultiplexConnectionPool(destination, pool, destination, 2)", "originalCommit": "b1d2a9ad95b5eb73f2bdc6c3e198192f40dc216d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTY5OTc1Ng==", "url": "https://github.com/eclipse/jetty.project/pull/5801#discussion_r555699756", "bodyText": "Ok.", "author": "lorban", "createdAt": "2021-01-12T11:23:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTY4MzcyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTY4NDIzNQ==", "url": "https://github.com/eclipse/jetty.project/pull/5801#discussion_r555684235", "bodyText": "No need to execute().\nPlease use:\nnewRequest(\"localhost\", port)\n  .path(\"/block\")", "author": "sbordet", "createdAt": "2021-01-12T10:56:35Z", "path": "jetty-http2/http2-http-client-transport/src/test/java/org/eclipse/jetty/http2/client/http/MultiplexedConnectionPoolTest.java", "diffHunk": "@@ -0,0 +1,306 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.http2.client.http;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.eclipse.jetty.client.ConnectionPool;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.HttpClientTransport;\n+import org.eclipse.jetty.client.MultiplexConnectionPool;\n+import org.eclipse.jetty.client.api.Connection;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.http2.client.HTTP2Client;\n+import org.eclipse.jetty.http2.server.HTTP2ServerConnectionFactory;\n+import org.eclipse.jetty.server.Handler;\n+import org.eclipse.jetty.server.HttpConfiguration;\n+import org.eclipse.jetty.server.Request;\n+import org.eclipse.jetty.server.Server;\n+import org.eclipse.jetty.server.ServerConnector;\n+import org.eclipse.jetty.util.Pool;\n+import org.eclipse.jetty.util.thread.QueuedThreadPool;\n+import org.hamcrest.Matchers;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+// Sibling of ConnectionPoolTest, but using H2 to multiplex connections.\n+public class MultiplexedConnectionPoolTest\n+{\n+    private Server server;\n+    private ServerConnector connector;\n+    private HttpClient client;\n+\n+    private void startServer(Handler handler) throws Exception\n+    {\n+        server = new Server();\n+        HTTP2ServerConnectionFactory http2ServerConnectionFactory = new HTTP2ServerConnectionFactory(new HttpConfiguration());\n+        http2ServerConnectionFactory.setMaxConcurrentStreams(2);\n+        connector = new ServerConnector(server, 1, 1, http2ServerConnectionFactory);\n+        server.addConnector(connector);\n+        server.setHandler(handler);\n+        server.start();\n+    }\n+\n+    @AfterEach\n+    public void disposeServer() throws Exception\n+    {\n+        connector = null;\n+        if (server != null)\n+        {\n+            server.stop();\n+            server = null;\n+        }\n+    }\n+\n+    @AfterEach\n+    public void disposeClient() throws Exception\n+    {\n+        if (client != null)\n+        {\n+            client.stop();\n+            client = null;\n+        }\n+    }\n+\n+    @Test\n+    public void testMaxDurationConnectionsWithMultiplexedPool() throws Exception\n+    {\n+        final int maxDuration = 30;\n+        AtomicInteger poolCreateCounter = new AtomicInteger();\n+        AtomicInteger poolRemoveCounter = new AtomicInteger();\n+        AtomicReference<Pool<Connection>> poolRef = new AtomicReference<>();\n+        ConnectionPoolFactory factory = new ConnectionPoolFactory(\"duplex-maxDuration\", destination ->\n+        {\n+            int maxConnections = destination.getHttpClient().getMaxConnectionsPerDestination();\n+            Pool<Connection> pool = new Pool<>(Pool.StrategyType.FIRST, maxConnections, false);\n+            poolRef.set(pool);\n+            MultiplexConnectionPool connectionPool = new MultiplexConnectionPool(destination, pool, destination, 2)\n+            {\n+                @Override\n+                protected void onCreated(Connection connection)\n+                {\n+                    poolCreateCounter.incrementAndGet();\n+                }\n+\n+                @Override\n+                protected void removed(Connection connection)\n+                {\n+                    poolRemoveCounter.incrementAndGet();\n+                }\n+            };\n+            connectionPool.setMaxDuration(maxDuration);\n+            return connectionPool;\n+        });\n+\n+        startServer(new EmptyServerHandler());\n+\n+        HttpClientTransport transport = new HttpClientTransportOverHTTP2(new HTTP2Client());\n+        transport.setConnectionPoolFactory(factory.factory);\n+        client = new HttpClient(transport, null);\n+        client.start();\n+\n+        // Use the connection pool 5 times with a delay that is longer than the max duration in between each time.\n+        for (int i = 0; i < 5; i++)\n+        {\n+            ContentResponse response = client.newRequest(\"localhost\", connector.getLocalPort())\n+                .timeout(5, TimeUnit.SECONDS)\n+                .send();\n+            assertThat(response.getStatus(), Matchers.is(200));\n+\n+            // Check that the pool never grows above 1.\n+            assertThat(poolRef.get().size(), is(1));\n+\n+            Thread.sleep(maxDuration * 2);\n+        }\n+\n+        // Check that the pool created 5 and removed 4 connections;\n+        // it must be exactly 4 removed b/c while the pool is not\n+        // constrained, it can multiplex requests on a single connection\n+        // so that should prevent opening more connections than needed.\n+        assertThat(poolCreateCounter.get(), is(5));\n+        assertThat(poolRemoveCounter.get(), is(4));\n+    }\n+\n+    @Test\n+    public void testMaxDurationConnectionsWithMultiplexedPoolClosesExpiredConnectionWhileStillInUse() throws Exception\n+    {\n+        final int maxDuration = 1000;\n+        final int maxIdle = 2000;\n+\n+        AtomicInteger poolCreateCounter = new AtomicInteger();\n+        AtomicInteger poolRemoveCounter = new AtomicInteger();\n+        AtomicReference<Pool<Connection>> poolRef = new AtomicReference<>();\n+        ConnectionPoolFactory factory = new ConnectionPoolFactory(\"duplex-maxDuration\", destination ->\n+        {\n+            int maxConnections = destination.getHttpClient().getMaxConnectionsPerDestination();\n+            Pool<Connection> pool = new Pool<>(Pool.StrategyType.FIRST, maxConnections, false);\n+            poolRef.set(pool);\n+            MultiplexConnectionPool connectionPool = new MultiplexConnectionPool(destination, pool, destination, 2)\n+            {\n+                @Override\n+                protected void onCreated(Connection connection)\n+                {\n+                    poolCreateCounter.incrementAndGet();\n+                }\n+\n+                @Override\n+                protected void removed(Connection connection)\n+                {\n+                    poolRemoveCounter.incrementAndGet();\n+                }\n+            };\n+            connectionPool.setMaxDuration(maxDuration);\n+            return connectionPool;\n+        });\n+\n+        Semaphore handlerSignalingSemaphore = new Semaphore(0);\n+        Semaphore handlerWaitingSemaphore = new Semaphore(0);\n+        startServer(new EmptyServerHandler()\n+        {\n+            @Override\n+            protected void service(String target, Request jettyRequest, HttpServletRequest request, HttpServletResponse response) throws ServletException\n+            {\n+                if (!target.equals(\"/block\"))\n+                    return;\n+\n+                handlerSignalingSemaphore.release();\n+\n+                try\n+                {\n+                    handlerWaitingSemaphore.acquire();\n+                }\n+                catch (Exception e)\n+                {\n+                    throw new ServletException(e);\n+                }\n+            }\n+        });\n+\n+        QueuedThreadPool clientThreads = new QueuedThreadPool();\n+        clientThreads.setName(\"client\");\n+        HttpClientTransport transport = new HttpClientTransportOverHTTP2(new HTTP2Client());\n+        transport.setConnectionPoolFactory(factory.factory);\n+        client = new HttpClient(transport, null);\n+        client.setExecutor(clientThreads);\n+        client.setIdleTimeout(maxIdle);\n+        client.start();\n+\n+        CountDownLatch latch1 = new CountDownLatch(1);\n+        CountDownLatch latch2 = new CountDownLatch(2);\n+        // create 2 requests that are going to consume all the multiplexing slots\n+        clientThreads.execute(() -> client.newRequest(\"http://localhost:\" + connector.getLocalPort() + \"/block\")", "originalCommit": "b1d2a9ad95b5eb73f2bdc6c3e198192f40dc216d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTY5OTkxOA==", "url": "https://github.com/eclipse/jetty.project/pull/5801#discussion_r555699918", "bodyText": "Ok.", "author": "lorban", "createdAt": "2021-01-12T11:24:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTY4NDIzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTY4NDM3Nw==", "url": "https://github.com/eclipse/jetty.project/pull/5801#discussion_r555684377", "bodyText": "No need to execute().\nPlease use:\nnewRequest(\"localhost\", port)\n  .path(\"/block\")", "author": "sbordet", "createdAt": "2021-01-12T10:56:46Z", "path": "jetty-http2/http2-http-client-transport/src/test/java/org/eclipse/jetty/http2/client/http/MultiplexedConnectionPoolTest.java", "diffHunk": "@@ -0,0 +1,306 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.http2.client.http;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.eclipse.jetty.client.ConnectionPool;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.HttpClientTransport;\n+import org.eclipse.jetty.client.MultiplexConnectionPool;\n+import org.eclipse.jetty.client.api.Connection;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.http2.client.HTTP2Client;\n+import org.eclipse.jetty.http2.server.HTTP2ServerConnectionFactory;\n+import org.eclipse.jetty.server.Handler;\n+import org.eclipse.jetty.server.HttpConfiguration;\n+import org.eclipse.jetty.server.Request;\n+import org.eclipse.jetty.server.Server;\n+import org.eclipse.jetty.server.ServerConnector;\n+import org.eclipse.jetty.util.Pool;\n+import org.eclipse.jetty.util.thread.QueuedThreadPool;\n+import org.hamcrest.Matchers;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+// Sibling of ConnectionPoolTest, but using H2 to multiplex connections.\n+public class MultiplexedConnectionPoolTest\n+{\n+    private Server server;\n+    private ServerConnector connector;\n+    private HttpClient client;\n+\n+    private void startServer(Handler handler) throws Exception\n+    {\n+        server = new Server();\n+        HTTP2ServerConnectionFactory http2ServerConnectionFactory = new HTTP2ServerConnectionFactory(new HttpConfiguration());\n+        http2ServerConnectionFactory.setMaxConcurrentStreams(2);\n+        connector = new ServerConnector(server, 1, 1, http2ServerConnectionFactory);\n+        server.addConnector(connector);\n+        server.setHandler(handler);\n+        server.start();\n+    }\n+\n+    @AfterEach\n+    public void disposeServer() throws Exception\n+    {\n+        connector = null;\n+        if (server != null)\n+        {\n+            server.stop();\n+            server = null;\n+        }\n+    }\n+\n+    @AfterEach\n+    public void disposeClient() throws Exception\n+    {\n+        if (client != null)\n+        {\n+            client.stop();\n+            client = null;\n+        }\n+    }\n+\n+    @Test\n+    public void testMaxDurationConnectionsWithMultiplexedPool() throws Exception\n+    {\n+        final int maxDuration = 30;\n+        AtomicInteger poolCreateCounter = new AtomicInteger();\n+        AtomicInteger poolRemoveCounter = new AtomicInteger();\n+        AtomicReference<Pool<Connection>> poolRef = new AtomicReference<>();\n+        ConnectionPoolFactory factory = new ConnectionPoolFactory(\"duplex-maxDuration\", destination ->\n+        {\n+            int maxConnections = destination.getHttpClient().getMaxConnectionsPerDestination();\n+            Pool<Connection> pool = new Pool<>(Pool.StrategyType.FIRST, maxConnections, false);\n+            poolRef.set(pool);\n+            MultiplexConnectionPool connectionPool = new MultiplexConnectionPool(destination, pool, destination, 2)\n+            {\n+                @Override\n+                protected void onCreated(Connection connection)\n+                {\n+                    poolCreateCounter.incrementAndGet();\n+                }\n+\n+                @Override\n+                protected void removed(Connection connection)\n+                {\n+                    poolRemoveCounter.incrementAndGet();\n+                }\n+            };\n+            connectionPool.setMaxDuration(maxDuration);\n+            return connectionPool;\n+        });\n+\n+        startServer(new EmptyServerHandler());\n+\n+        HttpClientTransport transport = new HttpClientTransportOverHTTP2(new HTTP2Client());\n+        transport.setConnectionPoolFactory(factory.factory);\n+        client = new HttpClient(transport, null);\n+        client.start();\n+\n+        // Use the connection pool 5 times with a delay that is longer than the max duration in between each time.\n+        for (int i = 0; i < 5; i++)\n+        {\n+            ContentResponse response = client.newRequest(\"localhost\", connector.getLocalPort())\n+                .timeout(5, TimeUnit.SECONDS)\n+                .send();\n+            assertThat(response.getStatus(), Matchers.is(200));\n+\n+            // Check that the pool never grows above 1.\n+            assertThat(poolRef.get().size(), is(1));\n+\n+            Thread.sleep(maxDuration * 2);\n+        }\n+\n+        // Check that the pool created 5 and removed 4 connections;\n+        // it must be exactly 4 removed b/c while the pool is not\n+        // constrained, it can multiplex requests on a single connection\n+        // so that should prevent opening more connections than needed.\n+        assertThat(poolCreateCounter.get(), is(5));\n+        assertThat(poolRemoveCounter.get(), is(4));\n+    }\n+\n+    @Test\n+    public void testMaxDurationConnectionsWithMultiplexedPoolClosesExpiredConnectionWhileStillInUse() throws Exception\n+    {\n+        final int maxDuration = 1000;\n+        final int maxIdle = 2000;\n+\n+        AtomicInteger poolCreateCounter = new AtomicInteger();\n+        AtomicInteger poolRemoveCounter = new AtomicInteger();\n+        AtomicReference<Pool<Connection>> poolRef = new AtomicReference<>();\n+        ConnectionPoolFactory factory = new ConnectionPoolFactory(\"duplex-maxDuration\", destination ->\n+        {\n+            int maxConnections = destination.getHttpClient().getMaxConnectionsPerDestination();\n+            Pool<Connection> pool = new Pool<>(Pool.StrategyType.FIRST, maxConnections, false);\n+            poolRef.set(pool);\n+            MultiplexConnectionPool connectionPool = new MultiplexConnectionPool(destination, pool, destination, 2)\n+            {\n+                @Override\n+                protected void onCreated(Connection connection)\n+                {\n+                    poolCreateCounter.incrementAndGet();\n+                }\n+\n+                @Override\n+                protected void removed(Connection connection)\n+                {\n+                    poolRemoveCounter.incrementAndGet();\n+                }\n+            };\n+            connectionPool.setMaxDuration(maxDuration);\n+            return connectionPool;\n+        });\n+\n+        Semaphore handlerSignalingSemaphore = new Semaphore(0);\n+        Semaphore handlerWaitingSemaphore = new Semaphore(0);\n+        startServer(new EmptyServerHandler()\n+        {\n+            @Override\n+            protected void service(String target, Request jettyRequest, HttpServletRequest request, HttpServletResponse response) throws ServletException\n+            {\n+                if (!target.equals(\"/block\"))\n+                    return;\n+\n+                handlerSignalingSemaphore.release();\n+\n+                try\n+                {\n+                    handlerWaitingSemaphore.acquire();\n+                }\n+                catch (Exception e)\n+                {\n+                    throw new ServletException(e);\n+                }\n+            }\n+        });\n+\n+        QueuedThreadPool clientThreads = new QueuedThreadPool();\n+        clientThreads.setName(\"client\");\n+        HttpClientTransport transport = new HttpClientTransportOverHTTP2(new HTTP2Client());\n+        transport.setConnectionPoolFactory(factory.factory);\n+        client = new HttpClient(transport, null);\n+        client.setExecutor(clientThreads);\n+        client.setIdleTimeout(maxIdle);\n+        client.start();\n+\n+        CountDownLatch latch1 = new CountDownLatch(1);\n+        CountDownLatch latch2 = new CountDownLatch(2);\n+        // create 2 requests that are going to consume all the multiplexing slots\n+        clientThreads.execute(() -> client.newRequest(\"http://localhost:\" + connector.getLocalPort() + \"/block\")\n+            .send(result ->\n+            {\n+                if (result.isSucceeded())\n+                {\n+                    latch1.countDown();\n+                    latch2.countDown();\n+                }\n+            }));\n+\n+        // wait for the 1st request to be serviced to make sure only 1 connection gets created\n+        handlerSignalingSemaphore.acquire();\n+\n+        clientThreads.execute(() -> client.newRequest(\"http://localhost:\" + connector.getLocalPort() + \"/block\")", "originalCommit": "b1d2a9ad95b5eb73f2bdc6c3e198192f40dc216d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTY5OTk3OQ==", "url": "https://github.com/eclipse/jetty.project/pull/5801#discussion_r555699979", "bodyText": "Ok.", "author": "lorban", "createdAt": "2021-01-12T11:24:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTY4NDM3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTY4OTMzNQ==", "url": "https://github.com/eclipse/jetty.project/pull/5801#discussion_r555689335", "bodyText": "Be explicit and add .path(\"/dontblock\").", "author": "sbordet", "createdAt": "2021-01-12T11:05:12Z", "path": "jetty-http2/http2-http-client-transport/src/test/java/org/eclipse/jetty/http2/client/http/MultiplexedConnectionPoolTest.java", "diffHunk": "@@ -0,0 +1,306 @@\n+//\n+//  ========================================================================\n+//  Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//  ------------------------------------------------------------------------\n+//  All rights reserved. This program and the accompanying materials\n+//  are made available under the terms of the Eclipse Public License v1.0\n+//  and Apache License v2.0 which accompanies this distribution.\n+//\n+//      The Eclipse Public License is available at\n+//      http://www.eclipse.org/legal/epl-v10.html\n+//\n+//      The Apache License v2.0 is available at\n+//      http://www.opensource.org/licenses/apache2.0.php\n+//\n+//  You may elect to redistribute this code under either of these licenses.\n+//  ========================================================================\n+//\n+\n+package org.eclipse.jetty.http2.client.http;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.eclipse.jetty.client.ConnectionPool;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.HttpClientTransport;\n+import org.eclipse.jetty.client.MultiplexConnectionPool;\n+import org.eclipse.jetty.client.api.Connection;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.http2.client.HTTP2Client;\n+import org.eclipse.jetty.http2.server.HTTP2ServerConnectionFactory;\n+import org.eclipse.jetty.server.Handler;\n+import org.eclipse.jetty.server.HttpConfiguration;\n+import org.eclipse.jetty.server.Request;\n+import org.eclipse.jetty.server.Server;\n+import org.eclipse.jetty.server.ServerConnector;\n+import org.eclipse.jetty.util.Pool;\n+import org.eclipse.jetty.util.thread.QueuedThreadPool;\n+import org.hamcrest.Matchers;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+// Sibling of ConnectionPoolTest, but using H2 to multiplex connections.\n+public class MultiplexedConnectionPoolTest\n+{\n+    private Server server;\n+    private ServerConnector connector;\n+    private HttpClient client;\n+\n+    private void startServer(Handler handler) throws Exception\n+    {\n+        server = new Server();\n+        HTTP2ServerConnectionFactory http2ServerConnectionFactory = new HTTP2ServerConnectionFactory(new HttpConfiguration());\n+        http2ServerConnectionFactory.setMaxConcurrentStreams(2);\n+        connector = new ServerConnector(server, 1, 1, http2ServerConnectionFactory);\n+        server.addConnector(connector);\n+        server.setHandler(handler);\n+        server.start();\n+    }\n+\n+    @AfterEach\n+    public void disposeServer() throws Exception\n+    {\n+        connector = null;\n+        if (server != null)\n+        {\n+            server.stop();\n+            server = null;\n+        }\n+    }\n+\n+    @AfterEach\n+    public void disposeClient() throws Exception\n+    {\n+        if (client != null)\n+        {\n+            client.stop();\n+            client = null;\n+        }\n+    }\n+\n+    @Test\n+    public void testMaxDurationConnectionsWithMultiplexedPool() throws Exception\n+    {\n+        final int maxDuration = 30;\n+        AtomicInteger poolCreateCounter = new AtomicInteger();\n+        AtomicInteger poolRemoveCounter = new AtomicInteger();\n+        AtomicReference<Pool<Connection>> poolRef = new AtomicReference<>();\n+        ConnectionPoolFactory factory = new ConnectionPoolFactory(\"duplex-maxDuration\", destination ->\n+        {\n+            int maxConnections = destination.getHttpClient().getMaxConnectionsPerDestination();\n+            Pool<Connection> pool = new Pool<>(Pool.StrategyType.FIRST, maxConnections, false);\n+            poolRef.set(pool);\n+            MultiplexConnectionPool connectionPool = new MultiplexConnectionPool(destination, pool, destination, 2)\n+            {\n+                @Override\n+                protected void onCreated(Connection connection)\n+                {\n+                    poolCreateCounter.incrementAndGet();\n+                }\n+\n+                @Override\n+                protected void removed(Connection connection)\n+                {\n+                    poolRemoveCounter.incrementAndGet();\n+                }\n+            };\n+            connectionPool.setMaxDuration(maxDuration);\n+            return connectionPool;\n+        });\n+\n+        startServer(new EmptyServerHandler());\n+\n+        HttpClientTransport transport = new HttpClientTransportOverHTTP2(new HTTP2Client());\n+        transport.setConnectionPoolFactory(factory.factory);\n+        client = new HttpClient(transport, null);\n+        client.start();\n+\n+        // Use the connection pool 5 times with a delay that is longer than the max duration in between each time.\n+        for (int i = 0; i < 5; i++)\n+        {\n+            ContentResponse response = client.newRequest(\"localhost\", connector.getLocalPort())\n+                .timeout(5, TimeUnit.SECONDS)\n+                .send();\n+            assertThat(response.getStatus(), Matchers.is(200));\n+\n+            // Check that the pool never grows above 1.\n+            assertThat(poolRef.get().size(), is(1));\n+\n+            Thread.sleep(maxDuration * 2);\n+        }\n+\n+        // Check that the pool created 5 and removed 4 connections;\n+        // it must be exactly 4 removed b/c while the pool is not\n+        // constrained, it can multiplex requests on a single connection\n+        // so that should prevent opening more connections than needed.\n+        assertThat(poolCreateCounter.get(), is(5));\n+        assertThat(poolRemoveCounter.get(), is(4));\n+    }\n+\n+    @Test\n+    public void testMaxDurationConnectionsWithMultiplexedPoolClosesExpiredConnectionWhileStillInUse() throws Exception\n+    {\n+        final int maxDuration = 1000;\n+        final int maxIdle = 2000;\n+\n+        AtomicInteger poolCreateCounter = new AtomicInteger();\n+        AtomicInteger poolRemoveCounter = new AtomicInteger();\n+        AtomicReference<Pool<Connection>> poolRef = new AtomicReference<>();\n+        ConnectionPoolFactory factory = new ConnectionPoolFactory(\"duplex-maxDuration\", destination ->\n+        {\n+            int maxConnections = destination.getHttpClient().getMaxConnectionsPerDestination();\n+            Pool<Connection> pool = new Pool<>(Pool.StrategyType.FIRST, maxConnections, false);\n+            poolRef.set(pool);\n+            MultiplexConnectionPool connectionPool = new MultiplexConnectionPool(destination, pool, destination, 2)\n+            {\n+                @Override\n+                protected void onCreated(Connection connection)\n+                {\n+                    poolCreateCounter.incrementAndGet();\n+                }\n+\n+                @Override\n+                protected void removed(Connection connection)\n+                {\n+                    poolRemoveCounter.incrementAndGet();\n+                }\n+            };\n+            connectionPool.setMaxDuration(maxDuration);\n+            return connectionPool;\n+        });\n+\n+        Semaphore handlerSignalingSemaphore = new Semaphore(0);\n+        Semaphore handlerWaitingSemaphore = new Semaphore(0);\n+        startServer(new EmptyServerHandler()\n+        {\n+            @Override\n+            protected void service(String target, Request jettyRequest, HttpServletRequest request, HttpServletResponse response) throws ServletException\n+            {\n+                if (!target.equals(\"/block\"))\n+                    return;\n+\n+                handlerSignalingSemaphore.release();\n+\n+                try\n+                {\n+                    handlerWaitingSemaphore.acquire();\n+                }\n+                catch (Exception e)\n+                {\n+                    throw new ServletException(e);\n+                }\n+            }\n+        });\n+\n+        QueuedThreadPool clientThreads = new QueuedThreadPool();\n+        clientThreads.setName(\"client\");\n+        HttpClientTransport transport = new HttpClientTransportOverHTTP2(new HTTP2Client());\n+        transport.setConnectionPoolFactory(factory.factory);\n+        client = new HttpClient(transport, null);\n+        client.setExecutor(clientThreads);\n+        client.setIdleTimeout(maxIdle);\n+        client.start();\n+\n+        CountDownLatch latch1 = new CountDownLatch(1);\n+        CountDownLatch latch2 = new CountDownLatch(2);\n+        // create 2 requests that are going to consume all the multiplexing slots\n+        clientThreads.execute(() -> client.newRequest(\"http://localhost:\" + connector.getLocalPort() + \"/block\")\n+            .send(result ->\n+            {\n+                if (result.isSucceeded())\n+                {\n+                    latch1.countDown();\n+                    latch2.countDown();\n+                }\n+            }));\n+\n+        // wait for the 1st request to be serviced to make sure only 1 connection gets created\n+        handlerSignalingSemaphore.acquire();\n+\n+        clientThreads.execute(() -> client.newRequest(\"http://localhost:\" + connector.getLocalPort() + \"/block\")\n+            .send(result ->\n+            {\n+                if (result.isSucceeded())\n+                {\n+                    latch1.countDown();\n+                    latch2.countDown();\n+                }\n+            }));\n+\n+        // wait for both requests to start being serviced\n+        handlerSignalingSemaphore.acquire();\n+\n+        assertThat(poolCreateCounter.get(), is(1));\n+\n+        // finalize 1 request, freeing up 1 multiplexing slot\n+        handlerWaitingSemaphore.release();\n+        // wait until 1st request finished\n+        assertTrue(latch1.await(5, TimeUnit.SECONDS));\n+\n+        assertThat(poolRef.get().getInUseCount(), is(1));\n+        assertThat(poolRef.get().getIdleCount(), is(0));\n+        assertThat(poolRef.get().getClosedCount(), is(0));\n+        assertThat(poolRef.get().size(), is(1));\n+\n+        // wait for the connection to expire\n+        Thread.sleep(maxDuration + 500);\n+\n+        // send a 3rd request that will close the expired multiplexed connection\n+        ContentResponse response = client.newRequest(\"localhost\", connector.getLocalPort())", "originalCommit": "b1d2a9ad95b5eb73f2bdc6c3e198192f40dc216d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTcwMDA2Mg==", "url": "https://github.com/eclipse/jetty.project/pull/5801#discussion_r555700062", "bodyText": "Ok.", "author": "lorban", "createdAt": "2021-01-12T11:24:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTY4OTMzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTY5Mzg5Nw==", "url": "https://github.com/eclipse/jetty.project/pull/5801#discussion_r555693897", "bodyText": "Wrap with <p>.", "author": "sbordet", "createdAt": "2021-01-12T11:13:25Z", "path": "jetty-client/src/main/java/org/eclipse/jetty/client/AbstractConnectionPool.java", "diffHunk": "@@ -105,6 +109,27 @@ protected void doStop() throws Exception\n         return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]));\n     }\n \n+    /**\n+     * Get the max usage duration in milliseconds of the pool's connections.", "originalCommit": "b1d2a9ad95b5eb73f2bdc6c3e198192f40dc216d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0dec883fdad0951b212545ce76deda748c0c4957", "url": "https://github.com/eclipse/jetty.project/commit/0dec883fdad0951b212545ce76deda748c0c4957", "message": "implement connection pool max duration", "committedDate": "2021-01-12T14:41:56Z", "type": "commit"}, {"oid": "0dec883fdad0951b212545ce76deda748c0c4957", "url": "https://github.com/eclipse/jetty.project/commit/0dec883fdad0951b212545ce76deda748c0c4957", "message": "implement connection pool max duration", "committedDate": "2021-01-12T14:41:56Z", "type": "forcePushed"}]}