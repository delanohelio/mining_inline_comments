{"pr_number": 4601, "pr_title": "Issue #4572 - Introduce jetty-slf4j-impl (part 1 of 3)", "pr_createdAt": "2020-02-24T19:24:00Z", "pr_url": "https://github.com/eclipse/jetty.project/pull/4601", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc0OTc5Mw==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r383749793", "bodyText": "I don't particularly like this because it is designed to force allocation, and we can avoid it.\nThis can just be emit(JettyLogger, Level, String, Object...) as all the rest can be computed by the implementation.", "author": "sbordet", "createdAt": "2020-02-25T09:20:54Z", "path": "jetty-slf4j-impl/src/main/java/org/eclipse/jetty/logging/JettyAppender.java", "diffHunk": "@@ -0,0 +1,24 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.logging;\n+\n+public interface JettyAppender\n+{\n+    void emit(JettyLoggingEvent event);", "originalCommit": "c972e60312fb68c7d0025b6a588cc0af833aa3f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzgwOTc3Mg==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r383809772", "bodyText": "This is in preparation for the slf4j 2.0.0 behaviors.\nWhich will use the org.slf4j.event.LoggingEvent to handle the differences between normal loggers and location aware loggers, along with the markers and context key value pairs.", "author": "joakime", "createdAt": "2020-02-25T11:03:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc0OTc5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzgxNzIxMw==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r383817213", "bodyText": "I see this as just an implementation detail.\nWhether we will be forced by an implementation to create an event it's orthogonal to the design of this interface.\nEvents are not part of the SLF4J API so we don't need them.", "author": "sbordet", "createdAt": "2020-02-25T11:19:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc0OTc5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg0OTk0Ng==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r383849946", "bodyText": "We can always have an Appender that makes events if they are needed by an integration", "author": "gregw", "createdAt": "2020-02-25T12:32:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc0OTc5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg4ODQyOQ==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r383888429", "bodyText": "The new interface would look like this ...\n    void emit(Level level, long timestamp, String threadName, String name, String condensedName, String message, Throwable throwable, Object[] argumentArray, \n              boolean hideStacks, Marker marker);\nAnd when slf4j 2.0.0 hits (currently in alpha, no public log4j 2 support yet) the API will look like this ...\n    void emit(Level level, long timestamp, String threadName, String name, String condensedName, String message, Throwable throwable, Object[] argumentArray, \n              boolean hideStacks, List<Marker> markers, List<KeyValuePair> keyValueContextPairs);", "author": "joakime", "createdAt": "2020-02-25T13:48:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc0OTc5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg4OTg3Ng==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r383889876", "bodyText": "We can always have an Appender that makes events if they are needed by an integration\n\nSlf4j will give us org.slf4j.event.LoggingEvent instances from the API itself in version 2.0.0+\nThe idea of an Appender to make events isn't really a thing, we receive them, not the other way around.", "author": "joakime", "createdAt": "2020-02-25T13:51:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc0OTc5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkwMTYxMQ==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r383901611", "bodyText": "This is now feeling a lot more like we are using slf4j implementation rather than their interface, making me much less interested in this idea.\nI just don't see why the implementation of LOG.debug(\"foo\"); should end up in being much more than a System.err.printf under the hood.   We don't want our default implementation to be a stream of slf4j event objects.\nI don't understand your point about us not generating events.  The proposed code for debug is:\n     @Override\n    public void debug(String msg)\n    {\n        if (isDebugEnabled())\n        {\n            getAppender().emit(asEvent(Level.DEBUG, msg));\n        }\n    }\nBut there is no reason that it cannot be:\n     @Override\n    public void debug(String msg)\n    {\n        if (isDebugEnabled())\n        {\n            getAppender().emit(Level.DEBUG, msg);\n        }\n    }\nand if events are needed, then emit can create them.... but in fact I can't even see why we need the abstraction of an appender? Shouldn't this code just be:\nBut there is no reason that it cannot be:\n     @Override\n    public void debug(String msg)\n    {\n        if (isDebugEnabled())\n        {\n            emit(Level.DEBUG, msg);\n        }\n    }\nIf we want to do something more complex, then the whole implementation of debug is replaced with another jar.    We don't want to reinvent log interception/filtering/appending etc. etc.  we just want a simple StdErr implementation that is statically initialised and can be replaced with a third party implementation if anything sophisticated is desired.", "author": "gregw", "createdAt": "2020-02-25T14:11:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc0OTc5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkwNzIwMQ==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r383907201", "bodyText": "Splitting up the Logger from what actually produces the log (Appender) makes things easier to maintain and test, and as a bonus it uses less memory (as each logger instance is no longer doing the entire job of emitting the log).\nI'll give it a go at making our Appender have multiple entry points.\nAnd with slf4j 2.0.0  ...\nWe have Markers and KeyValuePairs as well to make a decision on. (do we care to support them or not).\nMarkers are supported by logback only (currently).\nKeyValuePairs (the end result of MDC use) are supported by log4j1 impl, logback impl, and jdk/jul impls currently. (log4j2 impl in git shows signs of supporting them too).", "author": "joakime", "createdAt": "2020-02-25T14:20:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc0OTc5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkxMjk4Nw==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r383912987", "bodyText": "A split API for Appender would now look like ...\n    void emit(JettyLogger logger, Level level, long timestamp, String threadName, String message);\n\n    void emit(JettyLogger logger, Level level, long timestamp, String threadName,\n              Throwable throwable, String message);\n\n    void emit(JettyLogger logger, Level level, long timestamp, String threadName, String message,\n              Object[] argumentArray);\n\n    void emit(JettyLogger logger, Level level, long timestamp, String threadName, String name,\n              Throwable throwable, String message, Object[] argumentArray);\nWhere each parameter is ...\n\nJettyLogger logger is used for the logger name (full or condensed based on appender config), and the hideStacks configuration for that logger.\nLevel level is for the level of the event itself.\nlong timestamp the timestamp at logging event time (either from the raw Logger methods like .info() and .debug, but also from org.slf4j.event.LoggingEvent data given to us)\nString threadName the threadName at logging event time (either from the raw Logger methods like .info() and .debug, but also from org.slf4j.event.LoggingEvent data given to us)\nString message the log message (or log message format)\nThrowable throwable the throwable given. (presented as a whole stacktrace or not, based on logger's hideStacks configuration)\nObject[] argumentArray the array of arguments given to the log.", "author": "joakime", "createdAt": "2020-02-25T14:29:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc0OTc5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkxNTU4Ng==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r383915586", "bodyText": "There is no need for all those parameters. The 4 I gave in the initial comment are sufficient.", "author": "sbordet", "createdAt": "2020-02-25T14:34:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc0OTc5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkzNjk3OA==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r383936978", "bodyText": "This is now feeling a lot more like we are using slf4j implementation rather than their interface, making me much less interested in this idea.\n\nThe entirety of Jetty uses only org.slf4j.Logger and org.slf4j.LoggerFactory, we are using their interface.\nThis jetty-slf4j-impl is our implementation of those, and are completely optional.\nIn fact, only the StacklessLogging class is used directly by Jetty test cases, the rest is not used directly by Jetty.\nScenario 1\nThe use of slf4j also allows us to (for example) capture other loggers and route them to any slf4j implementation we want.\nJetty uses the org.slf4j.Logger API to create it's logging events.\nWe have the following jars on the classpath.\n\nslf4j-api.jar\njetty-slf4j-impl.jar (this is the slf4j impl in use)\njcl-over-slf4j.jar (bridge api for commons-logging)\njul-to-slf4j.jar (bridge api for java.util.logging, JSP and mail jars use this)\nlog4j-to-slf4j.jar (bridge api for log4j 1.x and log4j 2.x)\n\n(For slf4j 1.x there are also bridge API jars for apache juli, and osgi logging, haven't checked for slf4j 2.x)\nWe can receive events from any of the logging APIs now.\nOur org.eclipse.jetty.logging.JettyLogger can receive those events as ...\n\nCalls to equivalent .info() or .debug() style methods\nA call to public void log(org.slf4j.event.LoggingEvent event) (depends on bridge API - this is the SubstituteLogger internal slf4j API).\nA call to public void log(Marker marker, String callerFQCN, int level, String msg, Object[] arguments, Throwable t) (depends on bridge API and if source/location features - this is the LocationAwareLogger internal slf4j API)\n\nThe existence of the org.slf4j.event.LoggingEvent is to handle loggers that process events in a non-direct way:\n\nlost threadname information (like java.util.logging)\ntimestamp skews (like osgi logging)\n\nWith this PR, the jetty-slf4j-impl can handle all of those events, and can now be written to System.err via the StdErrAppender (not supported in Jetty 9.4.x or current 10.x HEAD) and we don't have to care about where it came from, just implement the interface org.slf4j.Logger (with LocationAwareLogger and SubstituteLogger extensions)\nScenario 2\nJetty uses the org.slf4j.Logger API to create it's logging events.\nThe user has chosen to use it's own slf4j impl (lets call it corp-slf4j-impl.jar)\nJetty participates with logging level / name / MDC / location without extra work or effort.\nAll of the classes in this PR are unused and are not present.", "author": "joakime", "createdAt": "2020-02-25T15:06:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc0OTc5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkzODIzMg==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r383938232", "bodyText": "There is no need for all those parameters. The 4 I gave in the initial comment are sufficient.\n\nNo, they are not.\nEspecially when using slf4j bridge APIs for capturing other loggers into our jetty-slf4j-impl", "author": "joakime", "createdAt": "2020-02-25T15:08:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc0OTc5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE1ODI5MQ==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r384158291", "bodyText": "The entire StdErrAppender API interface has been redone.\nNo more JettyLoggingEvent.", "author": "joakime", "createdAt": "2020-02-25T22:12:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc0OTc5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc1MTY1Mw==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r383751653", "bodyText": "See above, all these asEvent() are not necessary.", "author": "sbordet", "createdAt": "2020-02-25T09:24:10Z", "path": "jetty-slf4j-impl/src/main/java/org/eclipse/jetty/logging/JettyLogger.java", "diffHunk": "@@ -0,0 +1,663 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.logging;\n+\n+import java.util.Objects;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.Marker;\n+import org.slf4j.event.Level;\n+import org.slf4j.spi.LocationAwareLogger;\n+\n+public class JettyLogger implements LocationAwareLogger, Logger\n+{\n+    /**\n+     * The Level to set if you want this logger to be \"OFF\"\n+     */\n+    public static final int OFF = 999;\n+    /**\n+     * The Level to set if you want this logger to show all events from all levels.\n+     */\n+    public static final int ALL = -1;\n+\n+    private final String name;\n+    private final String condensedName;\n+    private int level;\n+    private JettyAppender appender;\n+    private boolean hideStacks = false;\n+\n+    public JettyLogger(String name)\n+    {\n+        this.name = name;\n+        this.condensedName = JettyLoggerFactory.condensePackageString(name);\n+    }\n+\n+    @Override\n+    public void debug(String msg)\n+    {\n+        if (isDebugEnabled())\n+        {\n+            getAppender().emit(asEvent(Level.DEBUG, msg));\n+        }\n+    }\n+\n+    @Override\n+    public void debug(String format, Object arg)\n+    {\n+        if (isDebugEnabled())\n+        {\n+            getAppender().emit(asEvent(Level.DEBUG, format, arg));\n+        }\n+    }\n+\n+    @Override\n+    public void debug(String format, Object arg1, Object arg2)\n+    {\n+        if (isDebugEnabled())\n+        {\n+            getAppender().emit(asEvent(Level.DEBUG, format, arg1, arg2));\n+        }\n+    }\n+\n+    @Override\n+    public void debug(String format, Object... arguments)\n+    {\n+        if (isDebugEnabled())\n+        {\n+            getAppender().emit(asEvent(Level.DEBUG, format, arguments));\n+        }\n+    }\n+\n+    @Override\n+    public void debug(String msg, Throwable throwable)\n+    {\n+        if (isDebugEnabled())\n+        {\n+            getAppender().emit(asEvent(Level.DEBUG, msg, throwable));\n+        }\n+    }\n+\n+    @Override\n+    public boolean isDebugEnabled(Marker marker)\n+    {\n+        return isDebugEnabled();\n+    }\n+\n+    @Override\n+    public void debug(Marker marker, String msg)\n+    {\n+        debug(msg);\n+    }\n+\n+    @Override\n+    public void debug(Marker marker, String format, Object arg)\n+    {\n+        debug(format, arg);\n+    }\n+\n+    @Override\n+    public void debug(Marker marker, String format, Object arg1, Object arg2)\n+    {\n+        debug(format, arg1, arg2);\n+    }\n+\n+    @Override\n+    public void debug(Marker marker, String format, Object... arguments)\n+    {\n+        debug(format, arguments);\n+    }\n+\n+    @Override\n+    public void debug(Marker marker, String msg, Throwable t)\n+    {\n+        debug(msg, t);\n+    }\n+\n+    @Override\n+    public void error(String msg)\n+    {\n+        if (isErrorEnabled())\n+        {\n+            getAppender().emit(asEvent(Level.ERROR, msg));\n+        }\n+    }\n+\n+    @Override\n+    public void error(String format, Object arg)\n+    {\n+        if (isErrorEnabled())\n+        {\n+            getAppender().emit(asEvent(Level.ERROR, format, arg));\n+        }\n+    }\n+\n+    @Override\n+    public void error(String format, Object arg1, Object arg2)\n+    {\n+        if (isErrorEnabled())\n+        {\n+            getAppender().emit(asEvent(Level.ERROR, format, arg1, arg2));\n+        }\n+    }\n+\n+    @Override\n+    public void error(String format, Object... arguments)\n+    {\n+        if (isErrorEnabled())\n+        {\n+            getAppender().emit(asEvent(Level.ERROR, format, arguments));\n+        }\n+    }\n+\n+    @Override\n+    public void error(String msg, Throwable throwable)\n+    {\n+        if (isErrorEnabled())\n+        {\n+            getAppender().emit(asEvent(Level.ERROR, msg, throwable));\n+        }\n+    }\n+\n+    @Override\n+    public boolean isErrorEnabled(Marker marker)\n+    {\n+        return isErrorEnabled();\n+    }\n+\n+    @Override\n+    public void error(Marker marker, String msg)\n+    {\n+        error(msg);\n+    }\n+\n+    @Override\n+    public void error(Marker marker, String format, Object arg)\n+    {\n+        error(format, arg);\n+    }\n+\n+    @Override\n+    public void error(Marker marker, String format, Object arg1, Object arg2)\n+    {\n+        error(format, arg1, arg2);\n+    }\n+\n+    @Override\n+    public void error(Marker marker, String format, Object... arguments)\n+    {\n+        error(format, arguments);\n+    }\n+\n+    @Override\n+    public void error(Marker marker, String msg, Throwable t)\n+    {\n+        error(msg, t);\n+    }\n+\n+    public JettyAppender getAppender()\n+    {\n+        return appender;\n+    }\n+\n+    @Override\n+    public void log(Marker marker, String fqcn, int levelInt, String message, Object[] argArray, Throwable throwable)\n+    {\n+        if (this.level <= levelInt)\n+        {\n+            getAppender().emit(asEvent(intToLevel(levelInt), message, throwable, argArray));\n+        }\n+    }\n+\n+    public void setAppender(JettyAppender appender)\n+    {\n+        this.appender = appender;\n+    }\n+\n+    public String getCondensedName()\n+    {\n+        return condensedName;\n+    }\n+\n+    public int getLevel()\n+    {\n+        return level;\n+    }\n+\n+    public void setLevel(Level level)\n+    {\n+        Objects.requireNonNull(level, \"Level\");\n+        setLevel(level.toInt());\n+    }\n+\n+    public void setLevel(int lvlInt)\n+    {\n+        this.level = lvlInt;\n+\n+        // apply setLevel to children too.\n+        JettyLoggerFactory jettyLoggerFactory = JettyLoggerFactory.getLoggerFactory();\n+        jettyLoggerFactory.walkChildLoggers(this.getName(), (logger) -> logger.setLevel(lvlInt));\n+    }\n+\n+    @Override\n+    public String getName()\n+    {\n+        return name;\n+    }\n+\n+    @Override\n+    public void info(String msg)\n+    {\n+        if (isInfoEnabled())\n+        {\n+            getAppender().emit(asEvent(Level.INFO, msg));\n+        }\n+    }\n+\n+    @Override\n+    public void info(String format, Object arg)\n+    {\n+        if (isInfoEnabled())\n+        {\n+            getAppender().emit(asEvent(Level.INFO, format, arg));\n+        }\n+    }\n+\n+    @Override\n+    public void info(String format, Object arg1, Object arg2)\n+    {\n+        if (isInfoEnabled())\n+        {\n+            getAppender().emit(asEvent(Level.INFO, format, arg1, arg2));\n+        }\n+    }\n+\n+    @Override\n+    public void info(String format, Object... arguments)\n+    {\n+        if (isInfoEnabled())\n+        {\n+            getAppender().emit(asEvent(Level.INFO, format, arguments));\n+        }\n+    }\n+\n+    @Override\n+    public void info(String msg, Throwable throwable)\n+    {\n+        if (isInfoEnabled())\n+        {\n+            getAppender().emit(asEvent(Level.INFO, msg, throwable));\n+        }\n+    }\n+\n+    @Override\n+    public boolean isInfoEnabled(Marker marker)\n+    {\n+        return isInfoEnabled();\n+    }\n+\n+    @Override\n+    public void info(Marker marker, String msg)\n+    {\n+        info(msg);\n+    }\n+\n+    @Override\n+    public void info(Marker marker, String format, Object arg)\n+    {\n+        info(format, arg);\n+    }\n+\n+    @Override\n+    public void info(Marker marker, String format, Object arg1, Object arg2)\n+    {\n+        info(format, arg1, arg2);\n+    }\n+\n+    @Override\n+    public void info(Marker marker, String format, Object... arguments)\n+    {\n+        info(format, arguments);\n+    }\n+\n+    @Override\n+    public void info(Marker marker, String msg, Throwable t)\n+    {\n+        info(msg, t);\n+    }\n+\n+    @Override\n+    public boolean isDebugEnabled()\n+    {\n+        return level <= Level.DEBUG.toInt();\n+    }\n+\n+    @Override\n+    public boolean isErrorEnabled()\n+    {\n+        return level <= Level.ERROR.toInt();\n+    }\n+\n+    public boolean isHideStacks()\n+    {\n+        return hideStacks;\n+    }\n+\n+    public void setHideStacks(boolean hideStacks)\n+    {\n+        this.hideStacks = hideStacks;\n+    }\n+\n+    @Override\n+    public boolean isInfoEnabled()\n+    {\n+        return level <= Level.INFO.toInt();\n+    }\n+\n+    @Override\n+    public boolean isTraceEnabled()\n+    {\n+        return level <= Level.TRACE.toInt();\n+    }\n+\n+    @Override\n+    public boolean isWarnEnabled()\n+    {\n+        return level <= Level.WARN.toInt();\n+    }\n+\n+    @Override\n+    public void trace(String msg)\n+    {\n+        if (isTraceEnabled())\n+        {\n+            getAppender().emit(asEvent(Level.TRACE, msg));\n+        }\n+    }\n+\n+    @Override\n+    public void trace(String format, Object arg)\n+    {\n+        if (isTraceEnabled())\n+        {\n+            getAppender().emit(asEvent(Level.TRACE, format, arg));\n+        }\n+    }\n+\n+    @Override\n+    public void trace(String format, Object arg1, Object arg2)\n+    {\n+        if (isTraceEnabled())\n+        {\n+            getAppender().emit(asEvent(Level.TRACE, format, arg1, arg2));\n+        }\n+    }\n+\n+    @Override\n+    public void trace(String format, Object... arguments)\n+    {\n+        if (isTraceEnabled())\n+        {\n+            getAppender().emit(asEvent(Level.TRACE, format, arguments));\n+        }\n+    }\n+\n+    @Override\n+    public void trace(String msg, Throwable throwable)\n+    {\n+        if (isTraceEnabled())\n+        {\n+            getAppender().emit(asEvent(Level.TRACE, msg, throwable));\n+        }\n+    }\n+\n+    @Override\n+    public boolean isTraceEnabled(Marker marker)\n+    {\n+        return isTraceEnabled();\n+    }\n+\n+    @Override\n+    public void trace(Marker marker, String msg)\n+    {\n+        trace(msg);\n+    }\n+\n+    @Override\n+    public void trace(Marker marker, String format, Object arg)\n+    {\n+        trace(format, arg);\n+    }\n+\n+    @Override\n+    public void trace(Marker marker, String format, Object arg1, Object arg2)\n+    {\n+        trace(format, arg1, arg2);\n+    }\n+\n+    @Override\n+    public void trace(Marker marker, String format, Object... argArray)\n+    {\n+        trace(format, argArray);\n+    }\n+\n+    @Override\n+    public void trace(Marker marker, String msg, Throwable t)\n+    {\n+        trace(msg, t);\n+    }\n+\n+    @Override\n+    public void warn(String msg)\n+    {\n+        if (isWarnEnabled())\n+        {\n+            getAppender().emit(asEvent(Level.WARN, msg));\n+        }\n+    }\n+\n+    @Override\n+    public void warn(String format, Object arg)\n+    {\n+        if (isWarnEnabled())\n+        {\n+            getAppender().emit(asEvent(Level.WARN, format, arg));\n+        }\n+    }\n+\n+    @Override\n+    public void warn(String format, Object... arguments)\n+    {\n+        if (isWarnEnabled())\n+        {\n+            getAppender().emit(asEvent(Level.WARN, format, arguments));\n+        }\n+    }\n+\n+    @Override\n+    public void warn(String format, Object arg1, Object arg2)\n+    {\n+        if (isWarnEnabled())\n+        {\n+            getAppender().emit(asEvent(Level.WARN, format, arg1, arg2));\n+        }\n+    }\n+\n+    @Override\n+    public void warn(String msg, Throwable throwable)\n+    {\n+        if (isWarnEnabled())\n+        {\n+            getAppender().emit(asEvent(Level.WARN, msg, throwable));\n+        }\n+    }\n+\n+    @Override\n+    public boolean isWarnEnabled(Marker marker)\n+    {\n+        return isWarnEnabled();\n+    }\n+\n+    @Override\n+    public void warn(Marker marker, String msg)\n+    {\n+        warn(msg);\n+    }\n+\n+    @Override\n+    public void warn(Marker marker, String format, Object arg)\n+    {\n+        warn(format, arg);\n+    }\n+\n+    @Override\n+    public void warn(Marker marker, String format, Object arg1, Object arg2)\n+    {\n+        warn(format, arg1, arg2);\n+    }\n+\n+    @Override\n+    public void warn(Marker marker, String format, Object... arguments)\n+    {\n+        warn(format, arguments);\n+    }\n+\n+    @Override\n+    public void warn(Marker marker, String msg, Throwable t)\n+    {\n+        warn(msg, t);\n+    }\n+\n+    public static Level intToLevel(int level)\n+    {\n+        if (level >= JettyLogger.OFF)\n+            return Level.ERROR;\n+        if (level >= Level.ERROR.toInt())\n+            return Level.ERROR;\n+        if (level >= Level.WARN.toInt())\n+            return Level.WARN;\n+        if (level >= Level.INFO.toInt())\n+            return Level.INFO;\n+        if (level >= Level.DEBUG.toInt())\n+            return Level.DEBUG;\n+        if (level >= Level.TRACE.toInt())\n+            return Level.TRACE;\n+        return Level.TRACE; // everything else\n+    }\n+\n+    public static String levelToString(int level)\n+    {\n+        if (level >= JettyLogger.OFF)\n+            return \"OFF\";\n+        if (level >= Level.ERROR.toInt())\n+            return \"ERROR\";\n+        if (level >= Level.WARN.toInt())\n+            return \"WARN\";\n+        if (level >= Level.INFO.toInt())\n+            return \"INFO\";\n+        if (level >= Level.DEBUG.toInt())\n+            return \"DEBUG\";\n+        if (level >= Level.TRACE.toInt())\n+            return \"TRACE\";\n+        return \"OFF\"; // everything else\n+    }\n+\n+    @SuppressWarnings(\"StringBufferReplaceableByString\")\n+    @Override\n+    public String toString()\n+    {\n+        final StringBuilder sb = new StringBuilder();\n+        sb.append(JettyLogger.class.getSimpleName());\n+        sb.append(':').append(name);\n+        sb.append(\":LEVEL=\").append(levelToString(level));\n+        return sb.toString();\n+    }\n+\n+    private JettyLoggingEvent asEvent(Level level, String msg)", "originalCommit": "c972e60312fb68c7d0025b6a588cc0af833aa3f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE1NjIxMQ==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r384156211", "bodyText": "JettyLoggingEvent has been removed.", "author": "joakime", "createdAt": "2020-02-25T22:07:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc1MTY1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc1MzI0NA==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r383753244", "bodyText": "We want to write the code in a way that this assert is not necessary - why paying the cost for every call?", "author": "sbordet", "createdAt": "2020-02-25T09:26:57Z", "path": "jetty-slf4j-impl/src/main/java/org/eclipse/jetty/logging/JettyLoggerFactory.java", "diffHunk": "@@ -0,0 +1,250 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.logging;\n+\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.function.Consumer;\n+\n+import org.slf4j.ILoggerFactory;\n+import org.slf4j.Logger;\n+\n+public class JettyLoggerFactory implements ILoggerFactory\n+{\n+    protected static JettyLoggerFactory getLoggerFactory()\n+    {\n+        if (instance == null)\n+        {\n+            instance = new JettyLoggerFactory();\n+        }\n+\n+        return instance;\n+    }\n+\n+    protected static void setInstance(JettyLoggerFactory loggerFactory)\n+    {\n+        if (loggerFactory != null && instance != null)\n+        {\n+            System.err.printf(\"Replacing main Instance %s@%x with %s@%x\",\n+                instance.getClass().getName(),\n+                instance.hashCode(),\n+                loggerFactory.getClass().getName(),\n+                loggerFactory.hashCode());\n+        }\n+        instance = loggerFactory;\n+    }\n+\n+    private static JettyLoggerFactory instance;\n+\n+    private static final String ROOT_LOGGER_NAME = \"\";\n+    private boolean initialized = false;\n+    private JettyLoggerConfiguration configuration;\n+    private JettyLogger rootLogger;\n+    private ConcurrentMap<String, JettyLogger> loggerMap;\n+\n+    private JettyLoggerFactory()\n+    {\n+    }\n+\n+    public JettyLoggerFactory initialize(JettyLoggerConfiguration config)\n+    {\n+        configuration = Objects.requireNonNull(config, \"JettyLoggerConfiguration\");\n+\n+        loggerMap = new ConcurrentHashMap<>();\n+\n+        rootLogger = new JettyLogger(ROOT_LOGGER_NAME);\n+        loggerMap.put(ROOT_LOGGER_NAME, rootLogger);\n+\n+        rootLogger.setLevel(configuration.getLevel(ROOT_LOGGER_NAME));\n+        rootLogger.setAppender(new StdErrAppender(configuration));\n+\n+        initialized = true;\n+        return this;\n+    }\n+\n+    private void assertInitialized()\n+    {\n+        if (!initialized)\n+        {\n+            throw new IllegalStateException(this.getClass().getSimpleName() + \" is not initialized yet\");\n+        }\n+    }\n+\n+    /**\n+     * Get a {@link JettyLogger} instance, creating if not yet existing.\n+     *\n+     * @param name the name of the logger\n+     * @return the JettyLogger instance\n+     */\n+    public JettyLogger getJettyLogger(String name)\n+    {\n+        assertInitialized();", "originalCommit": "c972e60312fb68c7d0025b6a588cc0af833aa3f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzgxMDIxMw==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r383810213", "bodyText": "This is only and impact during initialization of a Logger itself, which should occur only once per JVM per named logger.", "author": "joakime", "createdAt": "2020-02-25T11:04:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc1MzI0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzgxODIzMA==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r383818230", "bodyText": "Nope, that is called every time you get a logger.\nAssuming that it only happens once is assuming too much. For example, CometD uses per-instance loggers and there can be thousands/millions of instances created in the lifespan of the application.", "author": "sbordet", "createdAt": "2020-02-25T11:21:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc1MzI0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg5Mzc3MA==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r383893770", "bodyText": "That's just a horrible use of logging in CometD, this is why Markers and MDC and KeyValuePairs exist.", "author": "joakime", "createdAt": "2020-02-25T13:58:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc1MzI0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkxNjQ2MQ==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r383916461", "bodyText": "It's not \"horrible use\", it's actually a feature. What I'm saying is that I don't want to bind design decision to assumptions that are wrong, so let's base on the least number of assumptions.", "author": "sbordet", "createdAt": "2020-02-25T14:35:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc1MzI0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE1NjMwNw==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r384156307", "bodyText": "initialized assert removed", "author": "joakime", "createdAt": "2020-02-25T22:08:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc1MzI0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc1MzgwMg==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r383753802", "bodyText": "The static parts of this class need to be synchronized, or eagerly initialized.", "author": "sbordet", "createdAt": "2020-02-25T09:27:59Z", "path": "jetty-slf4j-impl/src/main/java/org/eclipse/jetty/logging/JettyLoggerFactory.java", "diffHunk": "@@ -0,0 +1,250 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.logging;\n+\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.function.Consumer;\n+\n+import org.slf4j.ILoggerFactory;\n+import org.slf4j.Logger;\n+\n+public class JettyLoggerFactory implements ILoggerFactory", "originalCommit": "c972e60312fb68c7d0025b6a588cc0af833aa3f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE1NzA4Nw==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r384157087", "bodyText": "For normal (non-testing) usage, this is only initialized by slf4j-api during it's org.slf4j.LoggerFactory.getInstance() call which results in our service provider being kicked off during a formal initialization phase.\nSee JettyLoggingServiceProvider.initialize()", "author": "joakime", "createdAt": "2020-02-25T22:09:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc1MzgwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQ4NzIzNA==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r384487234", "bodyText": "Removed singletons at JettyLoggerFactory level", "author": "joakime", "createdAt": "2020-02-26T13:22:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc1MzgwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc1NDI5NA==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r383754294", "bodyText": "Why do we need this at all? Just for testing?", "author": "sbordet", "createdAt": "2020-02-25T09:28:51Z", "path": "jetty-slf4j-impl/src/main/java/org/eclipse/jetty/logging/JettyLoggerFactory.java", "diffHunk": "@@ -0,0 +1,250 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.logging;\n+\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.function.Consumer;\n+\n+import org.slf4j.ILoggerFactory;\n+import org.slf4j.Logger;\n+\n+public class JettyLoggerFactory implements ILoggerFactory\n+{\n+    protected static JettyLoggerFactory getLoggerFactory()\n+    {\n+        if (instance == null)\n+        {\n+            instance = new JettyLoggerFactory();\n+        }\n+\n+        return instance;\n+    }\n+\n+    protected static void setInstance(JettyLoggerFactory loggerFactory)", "originalCommit": "c972e60312fb68c7d0025b6a588cc0af833aa3f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg5Mjc1OA==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r383892758", "bodyText": "It's to help with testing, yes.\nThat's also the reason it's protected and not public.", "author": "joakime", "createdAt": "2020-02-25T13:56:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc1NDI5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc1NTQ0Mw==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r383755443", "bodyText": "This is not atomic. Use loggerMap.compute().", "author": "sbordet", "createdAt": "2020-02-25T09:30:47Z", "path": "jetty-slf4j-impl/src/main/java/org/eclipse/jetty/logging/JettyLoggerFactory.java", "diffHunk": "@@ -0,0 +1,250 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.logging;\n+\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.function.Consumer;\n+\n+import org.slf4j.ILoggerFactory;\n+import org.slf4j.Logger;\n+\n+public class JettyLoggerFactory implements ILoggerFactory\n+{\n+    protected static JettyLoggerFactory getLoggerFactory()\n+    {\n+        if (instance == null)\n+        {\n+            instance = new JettyLoggerFactory();\n+        }\n+\n+        return instance;\n+    }\n+\n+    protected static void setInstance(JettyLoggerFactory loggerFactory)\n+    {\n+        if (loggerFactory != null && instance != null)\n+        {\n+            System.err.printf(\"Replacing main Instance %s@%x with %s@%x\",\n+                instance.getClass().getName(),\n+                instance.hashCode(),\n+                loggerFactory.getClass().getName(),\n+                loggerFactory.hashCode());\n+        }\n+        instance = loggerFactory;\n+    }\n+\n+    private static JettyLoggerFactory instance;\n+\n+    private static final String ROOT_LOGGER_NAME = \"\";\n+    private boolean initialized = false;\n+    private JettyLoggerConfiguration configuration;\n+    private JettyLogger rootLogger;\n+    private ConcurrentMap<String, JettyLogger> loggerMap;\n+\n+    private JettyLoggerFactory()\n+    {\n+    }\n+\n+    public JettyLoggerFactory initialize(JettyLoggerConfiguration config)\n+    {\n+        configuration = Objects.requireNonNull(config, \"JettyLoggerConfiguration\");\n+\n+        loggerMap = new ConcurrentHashMap<>();\n+\n+        rootLogger = new JettyLogger(ROOT_LOGGER_NAME);\n+        loggerMap.put(ROOT_LOGGER_NAME, rootLogger);\n+\n+        rootLogger.setLevel(configuration.getLevel(ROOT_LOGGER_NAME));\n+        rootLogger.setAppender(new StdErrAppender(configuration));\n+\n+        initialized = true;\n+        return this;\n+    }\n+\n+    private void assertInitialized()\n+    {\n+        if (!initialized)\n+        {\n+            throw new IllegalStateException(this.getClass().getSimpleName() + \" is not initialized yet\");\n+        }\n+    }\n+\n+    /**\n+     * Get a {@link JettyLogger} instance, creating if not yet existing.\n+     *\n+     * @param name the name of the logger\n+     * @return the JettyLogger instance\n+     */\n+    public JettyLogger getJettyLogger(String name)\n+    {\n+        assertInitialized();\n+\n+        if (name.equals(ROOT_LOGGER_NAME))\n+        {\n+            return getRootLogger();\n+        }\n+\n+        JettyLogger jettyLogger = loggerMap.get(name);\n+        if (jettyLogger == null)\n+        {\n+            jettyLogger = createLogger(name);\n+            loggerMap.putIfAbsent(name, jettyLogger);", "originalCommit": "c972e60312fb68c7d0025b6a588cc0af833aa3f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc1NzY3MQ==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r383757671", "bodyText": "This method and the one above are never used.", "author": "sbordet", "createdAt": "2020-02-25T09:34:55Z", "path": "jetty-slf4j-impl/src/main/java/org/eclipse/jetty/logging/JettyLoggerFactory.java", "diffHunk": "@@ -0,0 +1,250 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.logging;\n+\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.function.Consumer;\n+\n+import org.slf4j.ILoggerFactory;\n+import org.slf4j.Logger;\n+\n+public class JettyLoggerFactory implements ILoggerFactory\n+{\n+    protected static JettyLoggerFactory getLoggerFactory()\n+    {\n+        if (instance == null)\n+        {\n+            instance = new JettyLoggerFactory();\n+        }\n+\n+        return instance;\n+    }\n+\n+    protected static void setInstance(JettyLoggerFactory loggerFactory)\n+    {\n+        if (loggerFactory != null && instance != null)\n+        {\n+            System.err.printf(\"Replacing main Instance %s@%x with %s@%x\",\n+                instance.getClass().getName(),\n+                instance.hashCode(),\n+                loggerFactory.getClass().getName(),\n+                loggerFactory.hashCode());\n+        }\n+        instance = loggerFactory;\n+    }\n+\n+    private static JettyLoggerFactory instance;\n+\n+    private static final String ROOT_LOGGER_NAME = \"\";\n+    private boolean initialized = false;\n+    private JettyLoggerConfiguration configuration;\n+    private JettyLogger rootLogger;\n+    private ConcurrentMap<String, JettyLogger> loggerMap;\n+\n+    private JettyLoggerFactory()\n+    {\n+    }\n+\n+    public JettyLoggerFactory initialize(JettyLoggerConfiguration config)\n+    {\n+        configuration = Objects.requireNonNull(config, \"JettyLoggerConfiguration\");\n+\n+        loggerMap = new ConcurrentHashMap<>();\n+\n+        rootLogger = new JettyLogger(ROOT_LOGGER_NAME);\n+        loggerMap.put(ROOT_LOGGER_NAME, rootLogger);\n+\n+        rootLogger.setLevel(configuration.getLevel(ROOT_LOGGER_NAME));\n+        rootLogger.setAppender(new StdErrAppender(configuration));\n+\n+        initialized = true;\n+        return this;\n+    }\n+\n+    private void assertInitialized()\n+    {\n+        if (!initialized)\n+        {\n+            throw new IllegalStateException(this.getClass().getSimpleName() + \" is not initialized yet\");\n+        }\n+    }\n+\n+    /**\n+     * Get a {@link JettyLogger} instance, creating if not yet existing.\n+     *\n+     * @param name the name of the logger\n+     * @return the JettyLogger instance\n+     */\n+    public JettyLogger getJettyLogger(String name)\n+    {\n+        assertInitialized();\n+\n+        if (name.equals(ROOT_LOGGER_NAME))\n+        {\n+            return getRootLogger();\n+        }\n+\n+        JettyLogger jettyLogger = loggerMap.get(name);\n+        if (jettyLogger == null)\n+        {\n+            jettyLogger = createLogger(name);\n+            loggerMap.putIfAbsent(name, jettyLogger);\n+        }\n+        return jettyLogger;\n+    }\n+\n+    /**\n+     * Main interface for {@link ILoggerFactory}\n+     *\n+     * @param name the name of the logger\n+     * @return the Slf4j Logger\n+     */\n+    @Override\n+    public Logger getLogger(String name)\n+    {\n+        return getJettyLogger(name);\n+    }\n+\n+    protected void walkChildLoggers(String parentName, Consumer<JettyLogger> childConsumer)\n+    {\n+        String prefix = parentName;\n+        if (parentName.length() > 0 && !prefix.endsWith(\".\"))\n+        {\n+            prefix += \".\";\n+        }\n+\n+        for (JettyLogger logger : loggerMap.values())\n+        {\n+            if (logger.getName().equals(parentName))\n+            {\n+                // skip self\n+                continue;\n+            }\n+\n+            // is child, and is not itself\n+            if (logger.getName().startsWith(prefix))\n+            {\n+                childConsumer.accept(logger);\n+            }\n+        }\n+    }\n+\n+    public JettyLogger getConfiguredJettyLogger(Class<?> clazz)\n+    {\n+        return getConfiguredJettyLogger(clazz.getName());\n+    }\n+\n+    public JettyLogger getConfiguredJettyLogger(String name)", "originalCommit": "c972e60312fb68c7d0025b6a588cc0af833aa3f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc1NzkyMQ==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r383757921", "bodyText": "Not needed, see above.", "author": "sbordet", "createdAt": "2020-02-25T09:35:23Z", "path": "jetty-slf4j-impl/src/main/java/org/eclipse/jetty/logging/JettyLoggingEvent.java", "diffHunk": "@@ -0,0 +1,107 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.logging;\n+\n+import org.slf4j.Marker;\n+import org.slf4j.event.Level;\n+import org.slf4j.event.LoggingEvent;\n+\n+public class JettyLoggingEvent implements LoggingEvent", "originalCommit": "c972e60312fb68c7d0025b6a588cc0af833aa3f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzgxMDY0Nw==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r383810647", "bodyText": "Absolutely needed for our slf4j 2.0.0 (near) future", "author": "joakime", "createdAt": "2020-02-25T11:05:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc1NzkyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg1MzYwMA==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r383853600", "bodyText": "Can you explain why it is needed for slf4j 2.0?  I'ver had a quick look at the API and most of it is unchanged and doesn't require events.  Even the LoggingEventBuilder API should only require a builder implementation and there is no compulsion for normal logging to use that path.", "author": "gregw", "createdAt": "2020-02-25T12:40:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc1NzkyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc1ODk3Ng==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r383758976", "bodyText": "Can't we use BasicMDCAdapter? I don't think we need a Jetty specific one, but we may want to use the MDC, so we want to have a working implementation.", "author": "sbordet", "createdAt": "2020-02-25T09:37:19Z", "path": "jetty-slf4j-impl/src/main/java/org/eclipse/jetty/logging/JettyLoggingServiceProvider.java", "diffHunk": "@@ -0,0 +1,78 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.logging;\n+\n+import org.slf4j.ILoggerFactory;\n+import org.slf4j.IMarkerFactory;\n+import org.slf4j.helpers.BasicMarkerFactory;\n+import org.slf4j.helpers.NOPMDCAdapter;\n+import org.slf4j.spi.MDCAdapter;\n+import org.slf4j.spi.SLF4JServiceProvider;\n+\n+public class JettyLoggingServiceProvider implements SLF4JServiceProvider\n+{\n+    /**\n+     * Declare the version of the SLF4J API this implementation is compiled against.\n+     * The value of this field is modified with each major release.\n+     */\n+    // to avoid constant folding by the compiler, this field must *not* be final\n+    public static String REQUESTED_API_VERSION = \"1.8.99\"; // !final\n+\n+    private JettyLoggerFactory loggerFactory;\n+    private BasicMarkerFactory markerFactory;\n+    private MDCAdapter mdcAdapter;\n+\n+    @Override\n+    public void initialize()\n+    {\n+        JettyLoggerConfiguration config = new JettyLoggerConfiguration().loadRuntime(this.getClass().getClassLoader());\n+        loggerFactory = JettyLoggerFactory.getLoggerFactory().initialize(config);\n+        markerFactory = new BasicMarkerFactory();\n+        mdcAdapter = new NOPMDCAdapter(); // TODO: Provide Jetty Implementation?", "originalCommit": "c972e60312fb68c7d0025b6a588cc0af833aa3f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzgxMTQ0Mg==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r383811442", "bodyText": "Using a MDC would also mean we have a custom logger output (appender) to do something with that MDC content.\n(yay, we have the key value pairs, now what do we do with them in StdErrAppender?)\nAlso, in slf4j 2.0.0 this is replaced with a better KeyValuePairs handling in the org.slf4j.event.LoggingEvent", "author": "joakime", "createdAt": "2020-02-25T11:07:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc1ODk3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc2MjQzOA==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r383762438", "bodyText": "What if 2 thread concurrently trigger the first initialization of this service provider? Does SLF4J make any guarantee that this will not happen?\nIf it does not, then we may have a concurrent call to a static object that must be guarded.", "author": "sbordet", "createdAt": "2020-02-25T09:41:40Z", "path": "jetty-slf4j-impl/src/main/java/org/eclipse/jetty/logging/JettyLoggingServiceProvider.java", "diffHunk": "@@ -0,0 +1,78 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.logging;\n+\n+import org.slf4j.ILoggerFactory;\n+import org.slf4j.IMarkerFactory;\n+import org.slf4j.helpers.BasicMarkerFactory;\n+import org.slf4j.helpers.NOPMDCAdapter;\n+import org.slf4j.spi.MDCAdapter;\n+import org.slf4j.spi.SLF4JServiceProvider;\n+\n+public class JettyLoggingServiceProvider implements SLF4JServiceProvider\n+{\n+    /**\n+     * Declare the version of the SLF4J API this implementation is compiled against.\n+     * The value of this field is modified with each major release.\n+     */\n+    // to avoid constant folding by the compiler, this field must *not* be final\n+    public static String REQUESTED_API_VERSION = \"1.8.99\"; // !final\n+\n+    private JettyLoggerFactory loggerFactory;\n+    private BasicMarkerFactory markerFactory;\n+    private MDCAdapter mdcAdapter;\n+\n+    @Override\n+    public void initialize()\n+    {\n+        JettyLoggerConfiguration config = new JettyLoggerConfiguration().loadRuntime(this.getClass().getClassLoader());\n+        loggerFactory = JettyLoggerFactory.getLoggerFactory().initialize(config);", "originalCommit": "c972e60312fb68c7d0025b6a588cc0af833aa3f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzgxMTY0Mw==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r383811643", "bodyText": "Yes, slf4j makes sure this doesn't happen.", "author": "joakime", "createdAt": "2020-02-25T11:07:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc2MjQzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc2NTgwMg==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r383765802", "bodyText": "We do not remember if the stack were hidden before? We should restore to whatever value it was before, rather than forcing false, no? Make squelched a Map and we should be good.", "author": "sbordet", "createdAt": "2020-02-25T09:45:44Z", "path": "jetty-slf4j-impl/src/main/java/org/eclipse/jetty/logging/StacklessLogging.java", "diffHunk": "@@ -0,0 +1,126 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.logging;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.slf4j.ILoggerFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A try-with-resources compatible layer for {@link JettyLogger#setHideStacks(boolean) hiding stacktraces} within the scope of the <code>try</code> block when\n+ * logging with {@link JettyLogger} implementation.\n+ * <p>\n+ * Use of other logging implementation cause no effect when using this class\n+ * <p>\n+ * Example:\n+ *\n+ * <pre>\n+ * try (StacklessLogging scope = new StacklessLogging(EventDriver.class,Noisy.class))\n+ * {\n+ *     doActionThatCausesStackTraces();\n+ * }\n+ * </pre>\n+ */\n+public class StacklessLogging implements AutoCloseable\n+{\n+    private static final Logger LOG = LoggerFactory.getLogger(StacklessLogging.class);\n+    private static final JettyLoggerFactory loggerFactory;\n+\n+    static\n+    {\n+        JettyLoggerFactory jettyLoggerFactory = null;\n+        ILoggerFactory activeLoggerFactory = LoggerFactory.getILoggerFactory();\n+        if (activeLoggerFactory instanceof JettyLoggerFactory)\n+        {\n+            jettyLoggerFactory = (JettyLoggerFactory)activeLoggerFactory;\n+        }\n+        else\n+        {\n+            LOG.warn(\"Unable to squelch stacktraces ({} is not a {})\",\n+                activeLoggerFactory.getClass().getName(),\n+                JettyLoggerFactory.class.getName());\n+        }\n+        loggerFactory = jettyLoggerFactory;\n+    }\n+\n+    private final Set<JettyLogger> squelched = new HashSet<>();\n+\n+    public StacklessLogging(Class<?>... classesToSquelch)\n+    {\n+        for (Class<?> clazz : classesToSquelch)\n+        {\n+            JettyLogger jettyLogger = loggerFactory.getJettyLogger(clazz.getName());\n+            // only operate on loggers that are of type StdErrLog\n+            if (!jettyLogger.isDebugEnabled())\n+            {\n+                if (!jettyLogger.isHideStacks())\n+                {\n+                    jettyLogger.setHideStacks(true);\n+                    squelched.add(jettyLogger);\n+                }\n+            }\n+        }\n+    }\n+\n+    public StacklessLogging(Package... packagesToSquelch)\n+    {\n+        for (Package pkg : packagesToSquelch)\n+        {\n+            JettyLogger jettyLogger = loggerFactory.getJettyLogger(pkg.getName());\n+            // only operate on loggers that are of type StdErrLog\n+            if (!jettyLogger.isDebugEnabled())\n+            {\n+                if (!jettyLogger.isHideStacks())\n+                {\n+                    jettyLogger.setHideStacks(true);\n+                    squelched.add(jettyLogger);\n+                }\n+            }\n+        }\n+    }\n+\n+    public StacklessLogging(Logger... logs)\n+    {\n+        for (Logger log : logs)\n+        {\n+            // only operate on loggers that are of type StdErrLog\n+            if (log instanceof JettyLogger && !log.isDebugEnabled())\n+            {\n+                JettyLogger jettyLogger = ((JettyLogger)log);\n+                if (!jettyLogger.isHideStacks())\n+                {\n+                    jettyLogger.setHideStacks(true);\n+                    squelched.add(jettyLogger);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void close()\n+    {\n+        for (JettyLogger log : squelched)\n+        {\n+            log.setHideStacks(false);", "originalCommit": "c972e60312fb68c7d0025b6a588cc0af833aa3f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzgxMjIxNw==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r383812217", "bodyText": "Good point.\nBut to be fair, we only really use StacklessLogging in our unit tests.", "author": "joakime", "createdAt": "2020-02-25T11:08:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc2NTgwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE2MTkxOQ==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r384161919", "bodyText": "No work is needed here.\nThe squelched collection only has loggers that were originally logger.isHideStacks == false;\nEntries that were originally logger.isHideStacks == true are not present in the squelched list.", "author": "joakime", "createdAt": "2020-02-25T22:20:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc2NTgwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc2NjQwNA==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r383766404", "bodyText": "Use {@code ...} instead of <code>.", "author": "sbordet", "createdAt": "2020-02-25T09:46:41Z", "path": "jetty-slf4j-impl/src/main/java/org/eclipse/jetty/logging/StdErrAppender.java", "diffHunk": "@@ -0,0 +1,251 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.logging;\n+\n+import java.io.PrintStream;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Objects;\n+import java.util.TimeZone;\n+\n+import org.slf4j.event.Level;\n+import org.slf4j.helpers.FormattingTuple;\n+import org.slf4j.helpers.MessageFormatter;\n+\n+public class StdErrAppender implements JettyAppender\n+{\n+    private final DateTimeFormatter timestampFormatter;\n+    private final ZoneId timezone;\n+    /**\n+     * True to have output show condensed logger names, false to use the as defined long names.\n+     */\n+    private final boolean condensedNames;\n+    /**\n+     * True to have messages escaped for control characters, false to leave messages alone.\n+     */\n+    private final boolean escapedMessages;\n+    /**\n+     * True to have formatting be based on the strict definition of Slf4J's {@link MessageFormatter},\n+     * where there has to be a match to the number of <code>{}</code> in the format string", "originalCommit": "c972e60312fb68c7d0025b6a588cc0af833aa3f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzgxMjUxMw==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r383812513", "bodyText": "Using {@code ...} for content that contains { or } has caused problems in the javadoc tooling (in the past).", "author": "joakime", "createdAt": "2020-02-25T11:09:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc2NjQwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI5NTQ2Nw==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r384295467", "bodyText": "I'm really curious about the story behind this? :) ERROR is 5 characters so DEBUG will not be longer", "author": "olamy", "createdAt": "2020-02-26T06:27:35Z", "path": "jetty-slf4j-impl/src/main/java/org/eclipse/jetty/logging/StdErrAppender.java", "diffHunk": "@@ -0,0 +1,331 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.logging;\n+\n+import java.io.PrintStream;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Objects;\n+import java.util.TimeZone;\n+\n+import org.slf4j.event.Level;\n+import org.slf4j.helpers.FormattingTuple;\n+import org.slf4j.helpers.MessageFormatter;\n+import org.slf4j.helpers.NormalizedParameters;\n+\n+public class StdErrAppender implements JettyAppender\n+{\n+    /**\n+     * Configuration keys specific to the StdErrAppender\n+     */\n+    public static final String NAME_CONDENSE_KEY = \"org.eclipse.jetty.logging.appender.NAME_CONDENSE\";\n+    public static final String THREAD_PADDING_KEY = \"org.eclipse.jetty.logging.appender.THREAD_PADDING\";\n+    public static final String MESSAGE_ESCAPE_KEY = \"org.eclipse.jetty.logging.appender.MESSAGE_ESCAPE\";\n+    public static final String STRICT_SLF4J_FORMAT_KEY = \"org.eclipse.jetty.logging.appender.STRICT_SLF4J_SYNTAX\";\n+    public static final String ZONEID_KEY = \"org.eclipse.jetty.logging.appender.ZONE_ID\";\n+\n+    private static final Object[] EMPTY_ARGS = new Object[0];\n+    private final DateTimeFormatter timestampFormatter;\n+    private final ZoneId timezone;\n+\n+    /**\n+     * True to have output show condensed logger names, false to use the as defined long names.\n+     */\n+    private final boolean condensedNames;\n+\n+    /**\n+     * True to have messages escaped for control characters, false to leave messages alone.\n+     */\n+    private final boolean escapedMessages;\n+\n+    /**\n+     * True to have formatting be based on the strict definition of Slf4J's {@link MessageFormatter},\n+     * where there has to be a match to the number of <code>{}</code> in the format string\n+     * to the number of arguments provided on the various {@link org.slf4j.Logger} methods.\n+     * False will use the old-school Jetty message formatter, which will add missing <code>{}</code>\n+     * entries to the end of the format String if it detects more arguments then there are <code>{}</code>\n+     * elements in the provided format String.\n+     */\n+    private final boolean strictFormat;\n+\n+    /**\n+     * The fixed size of the thread name to use for output\n+     */\n+    private final int threadPadding;\n+\n+    /**\n+     * The stream to write logging events to.\n+     */\n+    private PrintStream stderr;\n+\n+    public StdErrAppender(JettyLoggerConfiguration config)\n+    {\n+        this(config, System.err);\n+    }\n+\n+    public StdErrAppender(JettyLoggerConfiguration config, PrintStream stream)\n+    {\n+        this(config, stream, null);\n+    }\n+\n+    public StdErrAppender(JettyLoggerConfiguration config, PrintStream stream, ZoneId zoneId)\n+    {\n+        Objects.requireNonNull(config, \"JettyLoggerConfiguration\");\n+        this.stderr = Objects.requireNonNull(stream, \"PrintStream\");\n+\n+        ZoneId tzone = zoneId;\n+        if (tzone == null)\n+        {\n+            tzone = config.getZoneId(ZONEID_KEY);\n+            if (tzone == null)\n+            {\n+                tzone = TimeZone.getDefault().toZoneId();\n+            }\n+        }\n+\n+        this.timezone = tzone;\n+        this.timestampFormatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss.SSS\");\n+        this.timestampFormatter.withZone(timezone);\n+\n+        this.condensedNames = config.getBoolean(NAME_CONDENSE_KEY, true);\n+        this.escapedMessages = config.getBoolean(MESSAGE_ESCAPE_KEY, true);\n+        this.strictFormat = config.getBoolean(STRICT_SLF4J_FORMAT_KEY, true);\n+        this.threadPadding = config.getInt(THREAD_PADDING_KEY, -1);\n+    }\n+\n+    @Override\n+    public void emit(JettyLogger logger, Level level, long timestamp, String threadName, String message)\n+    {\n+        emit(logger, level, timestamp, threadName, null, message, EMPTY_ARGS);\n+    }\n+\n+    @Override\n+    public void emit(JettyLogger logger, Level level, long timestamp, String threadName, Throwable throwable, String message)\n+    {\n+        emit(logger, level, timestamp, threadName, throwable, message, EMPTY_ARGS);\n+    }\n+\n+    @Override\n+    public void emit(JettyLogger logger, Level level, long timestamp, String threadName, String message, Object... argumentArray)\n+    {\n+        Throwable cause = NormalizedParameters.getThrowableCandidate(argumentArray);\n+        emit(logger, level, timestamp, threadName, cause, message, argumentArray);\n+    }\n+\n+    @Override\n+    public void emit(JettyLogger logger, Level level, long timestamp, String threadName, Throwable throwable, String message, Object... argumentArray)\n+    {\n+        StringBuilder builder = new StringBuilder(64);\n+        format(builder, logger, level, timestamp, threadName, throwable, message, argumentArray);\n+        stderr.println(builder);\n+    }\n+\n+    public ZoneId getTimeZone()\n+    {\n+        return timezone;\n+    }\n+\n+    public boolean isCondensedNames()\n+    {\n+        return condensedNames;\n+    }\n+\n+    public boolean isEscapedMessages()\n+    {\n+        return escapedMessages;\n+    }\n+\n+    public int getThreadPadding()\n+    {\n+        return threadPadding;\n+    }\n+\n+    public boolean isStrictFormat()\n+    {\n+        return strictFormat;\n+    }\n+\n+    public void setStream(PrintStream stream)\n+    {\n+        this.stderr = stream;\n+    }\n+\n+    private void format(StringBuilder builder, JettyLogger logger, Level level, long timestamp, String threadName, Throwable throwable, String message, Object... argumentArray)\n+    {\n+        Throwable cause = throwable;\n+\n+        // Timestamp\n+        ZonedDateTime tsInstant = Instant.ofEpochMilli(timestamp).atZone(timezone);\n+        timestampFormatter.formatTo(tsInstant, builder);\n+\n+        // Level\n+        builder.append(':').append(renderedLevel(level));\n+\n+        // Logger Name\n+        builder.append(':');\n+        if (condensedNames)\n+        {\n+            builder.append(logger.getCondensedName());\n+        }\n+        else\n+        {\n+            builder.append(logger.getName());\n+        }\n+\n+        // Thread Name\n+        builder.append(':');\n+        builder.append(threadName); // TODO: support TAG_PAD configuration\n+        builder.append(':');\n+\n+        // Message\n+        builder.append(' ');\n+\n+        if (strictFormat)\n+        {\n+            FormattingTuple ft = MessageFormatter.arrayFormat(message, argumentArray);\n+            appendEscaped(builder, ft.getMessage());\n+            if (cause == null)\n+            {\n+                cause = ft.getThrowable();\n+            }\n+        }\n+        else\n+        {\n+            // TODO: this should really be removed, as it violates the slf4j API contract for throwables and such\n+            StringBuilder msg = new StringBuilder();\n+            Object[] args = argumentArray == null ? EMPTY_ARGS : argumentArray;\n+            msg.append(Objects.requireNonNullElseGet(message, () -> \"{} \".repeat(args.length)));\n+            String braces = \"{}\";\n+            int start = 0;\n+            for (Object arg : args)\n+            {\n+                int bracesIndex = msg.indexOf(braces, start);\n+                if (bracesIndex < 0)\n+                {\n+                    appendEscaped(builder, msg.substring(start));\n+                    builder.append(\" \");\n+                    if (arg != null)\n+                        builder.append(arg);\n+                    start = msg.length();\n+                }\n+                else\n+                {\n+                    appendEscaped(builder, msg.substring(start, bracesIndex));\n+                    builder.append(arg);\n+                    start = bracesIndex + braces.length();\n+                }\n+            }\n+            appendEscaped(builder, msg.substring(start));\n+        }\n+\n+        // Throwable\n+        if (cause != null)\n+        {\n+            if (logger.isHideStacks())\n+            {\n+                builder.append(\": \").append(cause);\n+            }\n+            else\n+            {\n+                appendCause(builder, cause, \"\");\n+            }\n+        }\n+    }\n+\n+    private String renderedLevel(Level level)\n+    {\n+        switch (level)\n+        {\n+            case ERROR:  // New for Jetty 10+\n+                return \"ERROR\";\n+            case WARN:\n+                return \"WARN\";\n+            case INFO:\n+                return \"INFO\";\n+            case DEBUG:\n+                return \"DBUG\"; // keeping abbreviated name for historical reasons", "originalCommit": "66627df561490eff65438008ba555292864faf55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxNDUwMg==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r384314502", "bodyText": "ERROR is a new level that was not there before. See my comment above.", "author": "gregw", "createdAt": "2020-02-26T07:33:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI5NTQ2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDM0MjM2NQ==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r384342365", "bodyText": "my question is more why keep the \"DBUG\" :) we can use \"DEBUG\"", "author": "olamy", "createdAt": "2020-02-26T08:43:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI5NTQ2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDM0NTQ5Mw==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r384345493", "bodyText": "Sure we can use \"DEBUG\", but we then have to use \"WARN \" instead of \"WARN\" to keep the formatting nice.  I'm OK with that... or even if we pad with \"%5s\" when printing (although adding the space here is probably a lot faster/simpler).", "author": "gregw", "createdAt": "2020-02-26T08:49:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI5NTQ2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQ4Njk4Nw==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r384486987", "bodyText": "Fixed.", "author": "joakime", "createdAt": "2020-02-26T13:21:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI5NTQ2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMwOTY4Nw==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r384309687", "bodyText": "Do we need this static instance at all?  The instance we will use is the one created by the JettyLoggingServiceProvider so why confuse things and have another lazy static?", "author": "gregw", "createdAt": "2020-02-26T07:18:57Z", "path": "jetty-slf4j-impl/src/main/java/org/eclipse/jetty/logging/JettyLoggerFactory.java", "diffHunk": "@@ -0,0 +1,213 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.logging;\n+\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.function.Consumer;\n+\n+import org.slf4j.ILoggerFactory;\n+import org.slf4j.Logger;\n+\n+public class JettyLoggerFactory implements ILoggerFactory\n+{\n+    protected static JettyLoggerFactory getLoggerFactory()", "originalCommit": "66627df561490eff65438008ba555292864faf55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQ0MjAxMw==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r384442013", "bodyText": "That static is used by both our implementation (to handle cascading level and hidestacks runtime changes) and the JettyLoggingServiceProvider's own initialize() phase.", "author": "joakime", "createdAt": "2020-02-26T11:45:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMwOTY4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQ1NjI3MA==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r384456270", "bodyText": "I think this is needlessly complex and the use of initiailize methods means we cannot use fast finals.\nThe JettyLoggingServiceProvider should just make it's own instance and pass the configuration into the constructor. If slf4j is providing us with a life cycle mechanism, then I don't see why we need to duplicate with statics.  Can you try to get rid of this", "author": "gregw", "createdAt": "2020-02-26T12:18:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMwOTY4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQ4NjkxMg==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r384486912", "bodyText": "Removed singletons at JettyLoggerFactory", "author": "joakime", "createdAt": "2020-02-26T13:21:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMwOTY4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxMTAwMA==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r384311000", "bodyText": "Why are we not using DateCache?    I know it is not as flexible as a modern formatter, but it is fast for the simple data stamp that this log needs.  If users want anything fancier, they should replace our logging.", "author": "gregw", "createdAt": "2020-02-26T07:23:13Z", "path": "jetty-slf4j-impl/src/main/java/org/eclipse/jetty/logging/StdErrAppender.java", "diffHunk": "@@ -0,0 +1,331 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.logging;\n+\n+import java.io.PrintStream;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Objects;\n+import java.util.TimeZone;\n+\n+import org.slf4j.event.Level;\n+import org.slf4j.helpers.FormattingTuple;\n+import org.slf4j.helpers.MessageFormatter;\n+import org.slf4j.helpers.NormalizedParameters;\n+\n+public class StdErrAppender implements JettyAppender\n+{\n+    /**\n+     * Configuration keys specific to the StdErrAppender\n+     */\n+    public static final String NAME_CONDENSE_KEY = \"org.eclipse.jetty.logging.appender.NAME_CONDENSE\";\n+    public static final String THREAD_PADDING_KEY = \"org.eclipse.jetty.logging.appender.THREAD_PADDING\";\n+    public static final String MESSAGE_ESCAPE_KEY = \"org.eclipse.jetty.logging.appender.MESSAGE_ESCAPE\";\n+    public static final String STRICT_SLF4J_FORMAT_KEY = \"org.eclipse.jetty.logging.appender.STRICT_SLF4J_SYNTAX\";\n+    public static final String ZONEID_KEY = \"org.eclipse.jetty.logging.appender.ZONE_ID\";\n+\n+    private static final Object[] EMPTY_ARGS = new Object[0];\n+    private final DateTimeFormatter timestampFormatter;", "originalCommit": "66627df561490eff65438008ba555292864faf55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQ0MTMwMA==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r384441300", "bodyText": "Our DateCache exists in jetty-util (which we cannot depend on), and it uses the standard Java DateTimeFormatter in exactly the same way like this code does (when formatting with milliseconds like this Appender does).\nThe DateCache only works on caching results that are on the same second and do not contain a millisecond formatting string.", "author": "joakime", "createdAt": "2020-02-26T11:43:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxMTAwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQ0MzgxNg==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r384443816", "bodyText": "StdErrLog uses DateCache and separately handles the ms.  So why can't we depend on jetty-util?      I know it is a very old class.... but when it was introduced it was VERY beneficial.  If we are doing full logging, we can avoid thousands of time formats per second - well worth it!", "author": "gregw", "createdAt": "2020-02-26T11:49:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxMTAwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQ0Njk3OA==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r384446978", "bodyText": "Yes, and I tested StdErrLog's DateCache usage, and found it has a 100% cache-miss on uses with DateCache simply because it formats with milliseconds.\nWhich means, DateCache always used java's DateTimeFormatter to format.", "author": "joakime", "createdAt": "2020-02-26T11:56:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxMTAwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQ0ODkwOA==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r384448908", "bodyText": "Opened #4605 to review DateCache.\nThe results of that can determine what we do here.\nUse it more aggressively everywhere (including this jetty-slf4j-impl), or something else.", "author": "joakime", "createdAt": "2020-02-26T12:00:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxMTAwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQ1MDMzMA==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r384450330", "bodyText": "Then let's not remove it and have to review to have it replace.  Keep it and review to see if we remove it!", "author": "gregw", "createdAt": "2020-02-26T12:04:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxMTAwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQ1MzE3Mg==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r384453172", "bodyText": "I cannot add the dependency on jetty-util here as jetty-util uses logging it's a loop in both the dependencies on maven and the load order at jvm runtime.\nI would rather just rip out the DateTimeFormatter entirely and just use raw inline formatting against the Java 8+ date/time APIs.", "author": "joakime", "createdAt": "2020-02-26T12:11:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxMTAwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQ1NjgwNQ==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r384456805", "bodyText": "StdErrLog uses it, so this can use it.    Avoiding calling any formatter thousands of times per second is very valuble.", "author": "gregw", "createdAt": "2020-02-26T12:19:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxMTAwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQ1ODg4Mw==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r384458883", "bodyText": "I just ran StdErrLogTest and it had 1 MISS and every other log in the test was a date cache hit!", "author": "gregw", "createdAt": "2020-02-26T12:24:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxMTAwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQ1OTg4NQ==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r384459885", "bodyText": "Note the solution to the dependency issue is to make this implementation part of org.eclipse.jetty.util.log in jetty-util", "author": "gregw", "createdAt": "2020-02-26T12:26:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxMTAwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQ3MjYwMw==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r384472603", "bodyText": "I did this differently:\n\nBrought in DateCache into jetty-sfl4j-impl\nStripped out everything that jetty-slf4j-impl wouldn't use (down to 1 public method)\nRenamed it to Timestamp\nHave millisecond formatting done within Timestamp on top of the cached Tick.formattedString (if a cache hit or cache miss on the second cache, just like DateCache does)", "author": "joakime", "createdAt": "2020-02-26T12:53:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxMTAwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQ3MjYzMg==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r384472632", "bodyText": "Oh but we can't do that... because then we can't replace the jar.... hmmmmm", "author": "gregw", "createdAt": "2020-02-26T12:53:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxMTAwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQ3NTM3Ng==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r384475376", "bodyText": "This is the only method in DateCache that a logger would use.\n\n  \n    \n      jetty.project/jetty-util/src/main/java/org/eclipse/jetty/util/DateCache.java\n    \n    \n        Lines 203 to 222\n      in\n      7ce14a4\n    \n    \n    \n    \n\n        \n          \n               /** \n        \n\n        \n          \n                * Format a date according to our stored formatter. \n        \n\n        \n          \n                * The passed time is expected to be close to the current time, so it is \n        \n\n        \n          \n                * compared to the last value passed and if it is within the same second, \n        \n\n        \n          \n                * the format is reused.  Otherwise a new cached format is created. \n        \n\n        \n          \n                * \n        \n\n        \n          \n                * @param now the milliseconds since unix epoch \n        \n\n        \n          \n                * @return Formatted date \n        \n\n        \n          \n                */ \n        \n\n        \n          \n               public String formatNow(long now) \n        \n\n        \n          \n               { \n        \n\n        \n          \n                   long seconds = now / 1000; \n        \n\n        \n          \n            \n        \n\n        \n          \n                   Tick tick = _tick; \n        \n\n        \n          \n            \n        \n\n        \n          \n                   // Is this the cached time \n        \n\n        \n          \n                   if (tick != null && tick._seconds == seconds) \n        \n\n        \n          \n                       return tick._string; \n        \n\n        \n          \n                   return formatTick(now)._string; \n        \n\n        \n          \n               } \n        \n    \n  \n\n\nIncidentally, in the process, I discovered a bug in DateCache, filed in #4606", "author": "joakime", "createdAt": "2020-02-26T12:58:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxMTAwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxMjYxOQ==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r384312619", "bodyText": "what is this?  Looks like slf4j implementation to me.... and a mode of operation.   We don't want either.\nWe just want simple formatting as we currently do, if anything different is required then we replace the logging jar.\nModes of operation are just slow and confusing.\nSo we definitely have to remove the modes.\nAre the slf4j helper classes in the API jar?   What are the differences between their format and ours?", "author": "gregw", "createdAt": "2020-02-26T07:28:13Z", "path": "jetty-slf4j-impl/src/main/java/org/eclipse/jetty/logging/StdErrAppender.java", "diffHunk": "@@ -0,0 +1,331 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.logging;\n+\n+import java.io.PrintStream;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Objects;\n+import java.util.TimeZone;\n+\n+import org.slf4j.event.Level;\n+import org.slf4j.helpers.FormattingTuple;\n+import org.slf4j.helpers.MessageFormatter;\n+import org.slf4j.helpers.NormalizedParameters;\n+\n+public class StdErrAppender implements JettyAppender\n+{\n+    /**\n+     * Configuration keys specific to the StdErrAppender\n+     */\n+    public static final String NAME_CONDENSE_KEY = \"org.eclipse.jetty.logging.appender.NAME_CONDENSE\";\n+    public static final String THREAD_PADDING_KEY = \"org.eclipse.jetty.logging.appender.THREAD_PADDING\";\n+    public static final String MESSAGE_ESCAPE_KEY = \"org.eclipse.jetty.logging.appender.MESSAGE_ESCAPE\";\n+    public static final String STRICT_SLF4J_FORMAT_KEY = \"org.eclipse.jetty.logging.appender.STRICT_SLF4J_SYNTAX\";\n+    public static final String ZONEID_KEY = \"org.eclipse.jetty.logging.appender.ZONE_ID\";\n+\n+    private static final Object[] EMPTY_ARGS = new Object[0];\n+    private final DateTimeFormatter timestampFormatter;\n+    private final ZoneId timezone;\n+\n+    /**\n+     * True to have output show condensed logger names, false to use the as defined long names.\n+     */\n+    private final boolean condensedNames;\n+\n+    /**\n+     * True to have messages escaped for control characters, false to leave messages alone.\n+     */\n+    private final boolean escapedMessages;\n+\n+    /**\n+     * True to have formatting be based on the strict definition of Slf4J's {@link MessageFormatter},\n+     * where there has to be a match to the number of <code>{}</code> in the format string\n+     * to the number of arguments provided on the various {@link org.slf4j.Logger} methods.\n+     * False will use the old-school Jetty message formatter, which will add missing <code>{}</code>\n+     * entries to the end of the format String if it detects more arguments then there are <code>{}</code>\n+     * elements in the provided format String.\n+     */\n+    private final boolean strictFormat;\n+\n+    /**\n+     * The fixed size of the thread name to use for output\n+     */\n+    private final int threadPadding;\n+\n+    /**\n+     * The stream to write logging events to.\n+     */\n+    private PrintStream stderr;\n+\n+    public StdErrAppender(JettyLoggerConfiguration config)\n+    {\n+        this(config, System.err);\n+    }\n+\n+    public StdErrAppender(JettyLoggerConfiguration config, PrintStream stream)\n+    {\n+        this(config, stream, null);\n+    }\n+\n+    public StdErrAppender(JettyLoggerConfiguration config, PrintStream stream, ZoneId zoneId)\n+    {\n+        Objects.requireNonNull(config, \"JettyLoggerConfiguration\");\n+        this.stderr = Objects.requireNonNull(stream, \"PrintStream\");\n+\n+        ZoneId tzone = zoneId;\n+        if (tzone == null)\n+        {\n+            tzone = config.getZoneId(ZONEID_KEY);\n+            if (tzone == null)\n+            {\n+                tzone = TimeZone.getDefault().toZoneId();\n+            }\n+        }\n+\n+        this.timezone = tzone;\n+        this.timestampFormatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss.SSS\");\n+        this.timestampFormatter.withZone(timezone);\n+\n+        this.condensedNames = config.getBoolean(NAME_CONDENSE_KEY, true);\n+        this.escapedMessages = config.getBoolean(MESSAGE_ESCAPE_KEY, true);\n+        this.strictFormat = config.getBoolean(STRICT_SLF4J_FORMAT_KEY, true);\n+        this.threadPadding = config.getInt(THREAD_PADDING_KEY, -1);\n+    }\n+\n+    @Override\n+    public void emit(JettyLogger logger, Level level, long timestamp, String threadName, String message)\n+    {\n+        emit(logger, level, timestamp, threadName, null, message, EMPTY_ARGS);\n+    }\n+\n+    @Override\n+    public void emit(JettyLogger logger, Level level, long timestamp, String threadName, Throwable throwable, String message)\n+    {\n+        emit(logger, level, timestamp, threadName, throwable, message, EMPTY_ARGS);\n+    }\n+\n+    @Override\n+    public void emit(JettyLogger logger, Level level, long timestamp, String threadName, String message, Object... argumentArray)\n+    {\n+        Throwable cause = NormalizedParameters.getThrowableCandidate(argumentArray);\n+        emit(logger, level, timestamp, threadName, cause, message, argumentArray);\n+    }\n+\n+    @Override\n+    public void emit(JettyLogger logger, Level level, long timestamp, String threadName, Throwable throwable, String message, Object... argumentArray)\n+    {\n+        StringBuilder builder = new StringBuilder(64);\n+        format(builder, logger, level, timestamp, threadName, throwable, message, argumentArray);\n+        stderr.println(builder);\n+    }\n+\n+    public ZoneId getTimeZone()\n+    {\n+        return timezone;\n+    }\n+\n+    public boolean isCondensedNames()\n+    {\n+        return condensedNames;\n+    }\n+\n+    public boolean isEscapedMessages()\n+    {\n+        return escapedMessages;\n+    }\n+\n+    public int getThreadPadding()\n+    {\n+        return threadPadding;\n+    }\n+\n+    public boolean isStrictFormat()\n+    {\n+        return strictFormat;\n+    }\n+\n+    public void setStream(PrintStream stream)\n+    {\n+        this.stderr = stream;\n+    }\n+\n+    private void format(StringBuilder builder, JettyLogger logger, Level level, long timestamp, String threadName, Throwable throwable, String message, Object... argumentArray)\n+    {\n+        Throwable cause = throwable;\n+\n+        // Timestamp\n+        ZonedDateTime tsInstant = Instant.ofEpochMilli(timestamp).atZone(timezone);\n+        timestampFormatter.formatTo(tsInstant, builder);\n+\n+        // Level\n+        builder.append(':').append(renderedLevel(level));\n+\n+        // Logger Name\n+        builder.append(':');\n+        if (condensedNames)\n+        {\n+            builder.append(logger.getCondensedName());\n+        }\n+        else\n+        {\n+            builder.append(logger.getName());\n+        }\n+\n+        // Thread Name\n+        builder.append(':');\n+        builder.append(threadName); // TODO: support TAG_PAD configuration\n+        builder.append(':');\n+\n+        // Message\n+        builder.append(' ');\n+\n+        if (strictFormat)\n+        {\n+            FormattingTuple ft = MessageFormatter.arrayFormat(message, argumentArray);\n+            appendEscaped(builder, ft.getMessage());", "originalCommit": "66627df561490eff65438008ba555292864faf55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQzOTIxMw==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r384439213", "bodyText": "Our formatter is historical and frankly broken.\nI'll remove our formatter (the MessageFormatter is in the slf4j-api jar and handles formatting along with final Throwable logic)", "author": "joakime", "createdAt": "2020-02-26T11:39:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxMjYxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQ0Mjk0Ng==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r384442946", "bodyText": "OK - but can you explain the differences?", "author": "gregw", "createdAt": "2020-02-26T11:47:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxMjYxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQ0NjI1Mg==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r384446252", "bodyText": "MessageFormatter will ...\n\nperform the {} formatting\nhandle escaped \\\\{} entries in the input format string\nhonor the provided {} and not add extra ones that are missing\nhandle null argument array entries properly (by not showing null in the output)\nskip formatting if arguments array is empty\nif final argument is a throwable make note of it and return it\n\nOur formatter will ...\n\nperform the {} formatting\nnot honor escaped \\\\{} entries\nadd missing {} entries to process entire arguments array\nformat even if arguments array is empty or contains null characters\nformat Throwable via Throwable.toString() as any other argument in the array", "author": "joakime", "createdAt": "2020-02-26T11:55:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxMjYxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQ0OTYzOQ==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r384449639", "bodyText": "OK sounds near enough... and if we have the helpers on the classpath anyway!", "author": "gregw", "createdAt": "2020-02-26T12:02:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxMjYxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQ4Njc5Nw==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r384486797", "bodyText": "The lax formatting that Jetty StdErrLog had is now removed", "author": "joakime", "createdAt": "2020-02-26T13:21:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxMjYxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxNDM3Nw==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r384314377", "bodyText": "The intention is that all the level tags are the same length so that they read nicely down the screen (not sure how ignored escaped that), so they should either be:\n\"ERR \"\n\"WARN\"\n\"INFO\"\n\"DBUG\"\n\nor\n\"ERROR\"\n\"WARN \"\n\"INFO \"\n\"DEBUG\"", "author": "gregw", "createdAt": "2020-02-26T07:33:29Z", "path": "jetty-slf4j-impl/src/main/java/org/eclipse/jetty/logging/StdErrAppender.java", "diffHunk": "@@ -0,0 +1,331 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.logging;\n+\n+import java.io.PrintStream;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Objects;\n+import java.util.TimeZone;\n+\n+import org.slf4j.event.Level;\n+import org.slf4j.helpers.FormattingTuple;\n+import org.slf4j.helpers.MessageFormatter;\n+import org.slf4j.helpers.NormalizedParameters;\n+\n+public class StdErrAppender implements JettyAppender\n+{\n+    /**\n+     * Configuration keys specific to the StdErrAppender\n+     */\n+    public static final String NAME_CONDENSE_KEY = \"org.eclipse.jetty.logging.appender.NAME_CONDENSE\";\n+    public static final String THREAD_PADDING_KEY = \"org.eclipse.jetty.logging.appender.THREAD_PADDING\";\n+    public static final String MESSAGE_ESCAPE_KEY = \"org.eclipse.jetty.logging.appender.MESSAGE_ESCAPE\";\n+    public static final String STRICT_SLF4J_FORMAT_KEY = \"org.eclipse.jetty.logging.appender.STRICT_SLF4J_SYNTAX\";\n+    public static final String ZONEID_KEY = \"org.eclipse.jetty.logging.appender.ZONE_ID\";\n+\n+    private static final Object[] EMPTY_ARGS = new Object[0];\n+    private final DateTimeFormatter timestampFormatter;\n+    private final ZoneId timezone;\n+\n+    /**\n+     * True to have output show condensed logger names, false to use the as defined long names.\n+     */\n+    private final boolean condensedNames;\n+\n+    /**\n+     * True to have messages escaped for control characters, false to leave messages alone.\n+     */\n+    private final boolean escapedMessages;\n+\n+    /**\n+     * True to have formatting be based on the strict definition of Slf4J's {@link MessageFormatter},\n+     * where there has to be a match to the number of <code>{}</code> in the format string\n+     * to the number of arguments provided on the various {@link org.slf4j.Logger} methods.\n+     * False will use the old-school Jetty message formatter, which will add missing <code>{}</code>\n+     * entries to the end of the format String if it detects more arguments then there are <code>{}</code>\n+     * elements in the provided format String.\n+     */\n+    private final boolean strictFormat;\n+\n+    /**\n+     * The fixed size of the thread name to use for output\n+     */\n+    private final int threadPadding;\n+\n+    /**\n+     * The stream to write logging events to.\n+     */\n+    private PrintStream stderr;\n+\n+    public StdErrAppender(JettyLoggerConfiguration config)\n+    {\n+        this(config, System.err);\n+    }\n+\n+    public StdErrAppender(JettyLoggerConfiguration config, PrintStream stream)\n+    {\n+        this(config, stream, null);\n+    }\n+\n+    public StdErrAppender(JettyLoggerConfiguration config, PrintStream stream, ZoneId zoneId)\n+    {\n+        Objects.requireNonNull(config, \"JettyLoggerConfiguration\");\n+        this.stderr = Objects.requireNonNull(stream, \"PrintStream\");\n+\n+        ZoneId tzone = zoneId;\n+        if (tzone == null)\n+        {\n+            tzone = config.getZoneId(ZONEID_KEY);\n+            if (tzone == null)\n+            {\n+                tzone = TimeZone.getDefault().toZoneId();\n+            }\n+        }\n+\n+        this.timezone = tzone;\n+        this.timestampFormatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss.SSS\");\n+        this.timestampFormatter.withZone(timezone);\n+\n+        this.condensedNames = config.getBoolean(NAME_CONDENSE_KEY, true);\n+        this.escapedMessages = config.getBoolean(MESSAGE_ESCAPE_KEY, true);\n+        this.strictFormat = config.getBoolean(STRICT_SLF4J_FORMAT_KEY, true);\n+        this.threadPadding = config.getInt(THREAD_PADDING_KEY, -1);\n+    }\n+\n+    @Override\n+    public void emit(JettyLogger logger, Level level, long timestamp, String threadName, String message)\n+    {\n+        emit(logger, level, timestamp, threadName, null, message, EMPTY_ARGS);\n+    }\n+\n+    @Override\n+    public void emit(JettyLogger logger, Level level, long timestamp, String threadName, Throwable throwable, String message)\n+    {\n+        emit(logger, level, timestamp, threadName, throwable, message, EMPTY_ARGS);\n+    }\n+\n+    @Override\n+    public void emit(JettyLogger logger, Level level, long timestamp, String threadName, String message, Object... argumentArray)\n+    {\n+        Throwable cause = NormalizedParameters.getThrowableCandidate(argumentArray);\n+        emit(logger, level, timestamp, threadName, cause, message, argumentArray);\n+    }\n+\n+    @Override\n+    public void emit(JettyLogger logger, Level level, long timestamp, String threadName, Throwable throwable, String message, Object... argumentArray)\n+    {\n+        StringBuilder builder = new StringBuilder(64);\n+        format(builder, logger, level, timestamp, threadName, throwable, message, argumentArray);\n+        stderr.println(builder);\n+    }\n+\n+    public ZoneId getTimeZone()\n+    {\n+        return timezone;\n+    }\n+\n+    public boolean isCondensedNames()\n+    {\n+        return condensedNames;\n+    }\n+\n+    public boolean isEscapedMessages()\n+    {\n+        return escapedMessages;\n+    }\n+\n+    public int getThreadPadding()\n+    {\n+        return threadPadding;\n+    }\n+\n+    public boolean isStrictFormat()\n+    {\n+        return strictFormat;\n+    }\n+\n+    public void setStream(PrintStream stream)\n+    {\n+        this.stderr = stream;\n+    }\n+\n+    private void format(StringBuilder builder, JettyLogger logger, Level level, long timestamp, String threadName, Throwable throwable, String message, Object... argumentArray)\n+    {\n+        Throwable cause = throwable;\n+\n+        // Timestamp\n+        ZonedDateTime tsInstant = Instant.ofEpochMilli(timestamp).atZone(timezone);\n+        timestampFormatter.formatTo(tsInstant, builder);\n+\n+        // Level\n+        builder.append(':').append(renderedLevel(level));\n+\n+        // Logger Name\n+        builder.append(':');\n+        if (condensedNames)\n+        {\n+            builder.append(logger.getCondensedName());\n+        }\n+        else\n+        {\n+            builder.append(logger.getName());\n+        }\n+\n+        // Thread Name\n+        builder.append(':');\n+        builder.append(threadName); // TODO: support TAG_PAD configuration\n+        builder.append(':');\n+\n+        // Message\n+        builder.append(' ');\n+\n+        if (strictFormat)\n+        {\n+            FormattingTuple ft = MessageFormatter.arrayFormat(message, argumentArray);\n+            appendEscaped(builder, ft.getMessage());\n+            if (cause == null)\n+            {\n+                cause = ft.getThrowable();\n+            }\n+        }\n+        else\n+        {\n+            // TODO: this should really be removed, as it violates the slf4j API contract for throwables and such\n+            StringBuilder msg = new StringBuilder();\n+            Object[] args = argumentArray == null ? EMPTY_ARGS : argumentArray;\n+            msg.append(Objects.requireNonNullElseGet(message, () -> \"{} \".repeat(args.length)));\n+            String braces = \"{}\";\n+            int start = 0;\n+            for (Object arg : args)\n+            {\n+                int bracesIndex = msg.indexOf(braces, start);\n+                if (bracesIndex < 0)\n+                {\n+                    appendEscaped(builder, msg.substring(start));\n+                    builder.append(\" \");\n+                    if (arg != null)\n+                        builder.append(arg);\n+                    start = msg.length();\n+                }\n+                else\n+                {\n+                    appendEscaped(builder, msg.substring(start, bracesIndex));\n+                    builder.append(arg);\n+                    start = bracesIndex + braces.length();\n+                }\n+            }\n+            appendEscaped(builder, msg.substring(start));\n+        }\n+\n+        // Throwable\n+        if (cause != null)\n+        {\n+            if (logger.isHideStacks())\n+            {\n+                builder.append(\": \").append(cause);\n+            }\n+            else\n+            {\n+                appendCause(builder, cause, \"\");\n+            }\n+        }\n+    }\n+\n+    private String renderedLevel(Level level)\n+    {\n+        switch (level)\n+        {\n+            case ERROR:  // New for Jetty 10+\n+                return \"ERROR\";", "originalCommit": "66627df561490eff65438008ba555292864faf55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQ0MjQxNw==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r384442417", "bodyText": "I'll use the second form.", "author": "joakime", "createdAt": "2020-02-26T11:46:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxNDM3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY4MjAyMA==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r384682020", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private JettyLoggerConfiguration configuration;\n          \n          \n            \n                private JettyLogger rootLogger;\n          \n          \n            \n                private final JettyLoggerConfiguration configuration;\n          \n          \n            \n                private final JettyLogger rootLogger;", "author": "gregw", "createdAt": "2020-02-26T18:30:45Z", "path": "jetty-slf4j-impl/src/main/java/org/eclipse/jetty/logging/JettyLoggerFactory.java", "diffHunk": "@@ -0,0 +1,196 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.logging;\n+\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.function.Consumer;\n+\n+import org.slf4j.ILoggerFactory;\n+import org.slf4j.Logger;\n+\n+public class JettyLoggerFactory implements ILoggerFactory\n+{\n+    private static final String ROOT_LOGGER_NAME = \"\";\n+    private JettyLoggerConfiguration configuration;\n+    private JettyLogger rootLogger;", "originalCommit": "8a85bfb10f9aaea7a593a1cb2708b256f13aec88", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY4NzgyMg==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r384687822", "bodyText": "This is the side effect of eliminating the singleton.\nI need to be able to reset the active configuration that org.slf4j.LoggerFactory is tracking, as I cannot reset the active LoggerFactory to test scenarios.\nI either have a Singleton with final fields where I can reset the singleton itself, or I have the ability to reset the configuration.", "author": "joakime", "createdAt": "2020-02-26T18:41:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY4MjAyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY5NDg1NA==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r384694854", "bodyText": "Done", "author": "joakime", "createdAt": "2020-02-26T18:54:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY4MjAyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY4MjczOQ==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r384682739", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    initialize(config);\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                /**\n          \n          \n            \n                 * Reinitialize this Factory, forgetting about all prior config and loggers.\n          \n          \n            \n                 * <p>\n          \n          \n            \n                 * This is really only used in test cases.\n          \n          \n            \n                 * </p>\n          \n          \n            \n                 *\n          \n          \n            \n                 * @param config the configuration to reset to\n          \n          \n            \n                 */\n          \n          \n            \n                protected void initialize(JettyLoggerConfiguration config)\n          \n          \n            \n                {", "author": "gregw", "createdAt": "2020-02-26T18:32:01Z", "path": "jetty-slf4j-impl/src/main/java/org/eclipse/jetty/logging/JettyLoggerFactory.java", "diffHunk": "@@ -0,0 +1,196 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under\n+// the terms of the Eclipse Public License 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0\n+//\n+// This Source Code may also be made available under the following\n+// Secondary Licenses when the conditions for such availability set\n+// forth in the Eclipse Public License, v. 2.0 are satisfied:\n+// the Apache License v2.0 which is available at\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.logging;\n+\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.function.Consumer;\n+\n+import org.slf4j.ILoggerFactory;\n+import org.slf4j.Logger;\n+\n+public class JettyLoggerFactory implements ILoggerFactory\n+{\n+    private static final String ROOT_LOGGER_NAME = \"\";\n+    private JettyLoggerConfiguration configuration;\n+    private JettyLogger rootLogger;\n+    private ConcurrentMap<String, JettyLogger> loggerMap;\n+\n+    public JettyLoggerFactory(JettyLoggerConfiguration config)\n+    {\n+        initialize(config);\n+    }\n+\n+    /**\n+     * Reinitialize this Factory, forgetting about all prior config and loggers.\n+     * <p>\n+     * This is really only used in test cases.\n+     * </p>\n+     *\n+     * @param config the configuration to reset to\n+     */\n+    protected void initialize(JettyLoggerConfiguration config)\n+    {", "originalCommit": "8a85bfb10f9aaea7a593a1cb2708b256f13aec88", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY4ODE2Mw==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r384688163", "bodyText": "I need this for testing, all of your prior recommendations have eliminated all of my options, don't get rid of this one too.", "author": "joakime", "createdAt": "2020-02-26T18:42:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY4MjczOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY5NDgxMA==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r384694810", "bodyText": "Done.", "author": "joakime", "createdAt": "2020-02-26T18:54:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY4MjczOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc0OTkyNQ==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r384749925", "bodyText": "Nope. This is not needed.", "author": "sbordet", "createdAt": "2020-02-26T20:36:04Z", "path": "jetty-slf4j-impl/src/main/java/org/eclipse/jetty/logging/JettyLoggerFactory.java", "diffHunk": "@@ -69,7 +69,7 @@ public JettyLogger getJettyLogger(String name)\n      * @return the Slf4j Logger\n      */\n     @Override\n-    public Logger getLogger(String name)\n+    public synchronized Logger getLogger(String name)", "originalCommit": "1339bd1d851ecd5d07a5cc9223f42653a0361ac3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc2NzY2Mw==", "url": "https://github.com/eclipse/jetty.project/pull/4601#discussion_r384767663", "bodyText": "reverted.", "author": "joakime", "createdAt": "2020-02-26T21:11:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc0OTkyNQ=="}], "type": "inlineReview"}, {"oid": "8b7e64915f9e6d7be6ca69cc1143931e1b35fde2", "url": "https://github.com/eclipse/jetty.project/commit/8b7e64915f9e6d7be6ca69cc1143931e1b35fde2", "message": "Issue #4572 - Replace Jetty Logging with SLF4J\n\n* Introducing jetty-slf4j-impl\n* Make Jetty use org.slf4j\n* Removed most of org.eclipse.jetty.util.log classes\n* Left org.eclipse.jetty.util.log.Log and\n       org.eclipse.jetty.util.log.Logger but as\n  simple bridge classes that are deprecated\n* Migrated code using org.eclipse.jetty.util.log.StacklessLogging\n  to org.eclipse.jetty.logging.StacklessLogging found in\n  the jetty-slf4j-impl\n* Moved logging start modules from jetty-util to jetty-home\n* Simplified logging start modules\n* Updated code that was using StdErrLog directly\n* Updating module-info.java for org.slf4j\n* removing org.eclipse.jetty.util.log.class references\n* jetty-start supports manually declared default provider\n  + and we use it to default \"logging\" to the \"logging-jetty\" provider\n* Cleaning up jetty-maven-plugin and IT testing for Logging\n* Using old slf4j for it testing\n* Updating compiler config to show Xlint:exports warnings\n* Updating console-capture and logging-noop\n* Adding slf4j bridge (capture) jetty modules\n* Updates to jetty logging module locations\n* Changing reference to slf4j dependent mod\n* Process requested enabled modules in topological order\n* Limiting inclusions in shaded jetty-start\n  + Also adding note to jetty-util classes that are used by\n    jetty-start\n* Default logging level on baseline logging config is INFO (not DEBUG)\n* Changing from system to server classes in logging\n* Updating other modules to use new logging names\n\nSigned-off-by: Joakim Erdfelt <joakim.erdfelt@gmail.com>", "committedDate": "2020-03-16T16:21:54Z", "type": "commit"}, {"oid": "8b7e64915f9e6d7be6ca69cc1143931e1b35fde2", "url": "https://github.com/eclipse/jetty.project/commit/8b7e64915f9e6d7be6ca69cc1143931e1b35fde2", "message": "Issue #4572 - Replace Jetty Logging with SLF4J\n\n* Introducing jetty-slf4j-impl\n* Make Jetty use org.slf4j\n* Removed most of org.eclipse.jetty.util.log classes\n* Left org.eclipse.jetty.util.log.Log and\n       org.eclipse.jetty.util.log.Logger but as\n  simple bridge classes that are deprecated\n* Migrated code using org.eclipse.jetty.util.log.StacklessLogging\n  to org.eclipse.jetty.logging.StacklessLogging found in\n  the jetty-slf4j-impl\n* Moved logging start modules from jetty-util to jetty-home\n* Simplified logging start modules\n* Updated code that was using StdErrLog directly\n* Updating module-info.java for org.slf4j\n* removing org.eclipse.jetty.util.log.class references\n* jetty-start supports manually declared default provider\n  + and we use it to default \"logging\" to the \"logging-jetty\" provider\n* Cleaning up jetty-maven-plugin and IT testing for Logging\n* Using old slf4j for it testing\n* Updating compiler config to show Xlint:exports warnings\n* Updating console-capture and logging-noop\n* Adding slf4j bridge (capture) jetty modules\n* Updates to jetty logging module locations\n* Changing reference to slf4j dependent mod\n* Process requested enabled modules in topological order\n* Limiting inclusions in shaded jetty-start\n  + Also adding note to jetty-util classes that are used by\n    jetty-start\n* Default logging level on baseline logging config is INFO (not DEBUG)\n* Changing from system to server classes in logging\n* Updating other modules to use new logging names\n\nSigned-off-by: Joakim Erdfelt <joakim.erdfelt@gmail.com>", "committedDate": "2020-03-16T16:21:54Z", "type": "forcePushed"}]}