{"pr_number": 8758, "pr_title": "BAEL-3855", "pr_createdAt": "2020-02-19T22:29:54Z", "pr_url": "https://github.com/eugenp/tutorials/pull/8758", "timeline": [{"oid": "9c4f89d4142044ea62b9c7de98a4da6f6f6513fe", "url": "https://github.com/eugenp/tutorials/commit/9c4f89d4142044ea62b9c7de98a4da6f6f6513fe", "message": "Hexagonal architecture: a quick and practical example", "committedDate": "2019-12-05T10:32:58Z", "type": "commit"}, {"oid": "e2fd861f60bccf189f1aca68877e2ccb1edd6b27", "url": "https://github.com/eugenp/tutorials/commit/e2fd861f60bccf189f1aca68877e2ccb1edd6b27", "message": "Merge pull request #1 from eugenp/master\n\nSend PR", "committedDate": "2019-12-20T14:09:08Z", "type": "commit"}, {"oid": "a000150c46682fc16dd6ebb136d941f04459ccb9", "url": "https://github.com/eugenp/tutorials/commit/a000150c46682fc16dd6ebb136d941f04459ccb9", "message": "BAEL 3486", "committedDate": "2019-12-23T08:28:02Z", "type": "commit"}, {"oid": "4cf4a15ac8ce47f2fae2a1f18132ad97ce2c6991", "url": "https://github.com/eugenp/tutorials/commit/4cf4a15ac8ce47f2fae2a1f18132ad97ce2c6991", "message": "BAEL-3855\n\nLock Striping", "committedDate": "2020-02-19T22:14:25Z", "type": "commit"}, {"oid": "2227006e076e168ba8c8bf63de6733b79d77553b", "url": "https://github.com/eugenp/tutorials/commit/2227006e076e168ba8c8bf63de6733b79d77553b", "message": "BAEL-3855", "committedDate": "2020-02-19T22:26:24Z", "type": "commit"}, {"oid": "7094a3b15bc8c69b6773807f100071b0b7fed029", "url": "https://github.com/eugenp/tutorials/commit/7094a3b15bc8c69b6773807f100071b0b7fed029", "message": "BAEL-3855", "committedDate": "2020-02-19T22:27:45Z", "type": "commit"}, {"oid": "6388b70f30386a8af7b0bdcea03332b91a268fda", "url": "https://github.com/eugenp/tutorials/commit/6388b70f30386a8af7b0bdcea03332b91a268fda", "message": "BAEL-3855", "committedDate": "2020-02-19T22:28:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjEwODMxOQ==", "url": "https://github.com/eugenp/tutorials/pull/8758#discussion_r382108319", "bodyText": "fix indentation throughout the class", "author": "rpvilao", "createdAt": "2020-02-20T16:21:55Z", "path": "lock-striping/src/com/baeldung/concurrent/lock/BenchMark.java", "diffHunk": "@@ -0,0 +1,66 @@\n+package com.baeldung.concurrent.lock;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+@State(Scope.Thread)\n+@Warmup(iterations = 2, time = 1, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 3, time = 1, timeUnit = TimeUnit.MILLISECONDS)\n+public class BenchMark {\n+    ConcurrentAccessMap accessMyMap;", "originalCommit": "6388b70f30386a8af7b0bdcea03332b91a268fda", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjExMDM5Nw==", "url": "https://github.com/eugenp/tutorials/pull/8758#discussion_r382110397", "bodyText": "indentation", "author": "rpvilao", "createdAt": "2020-02-20T16:25:13Z", "path": "lock-striping/src/com/baeldung/concurrent/lock/ConcurrentAccessMap.java", "diffHunk": "@@ -0,0 +1,33 @@\n+package com.baeldung.concurrent.lock;\n+\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+\n+import com.google.common.base.Supplier;\n+\n+public abstract class ConcurrentAccessMap {", "originalCommit": "6388b70f30386a8af7b0bdcea03332b91a268fda", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjExMDQ5NA==", "url": "https://github.com/eugenp/tutorials/pull/8758#discussion_r382110494", "bodyText": "indentation", "author": "rpvilao", "createdAt": "2020-02-20T16:25:22Z", "path": "lock-striping/src/com/baeldung/concurrent/lock/ConcurrentAccessMap.java", "diffHunk": "@@ -0,0 +1,33 @@\n+package com.baeldung.concurrent.lock;\n+\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+\n+import com.google.common.base.Supplier;\n+\n+public abstract class ConcurrentAccessMap {\n+\tstatic final int SLOTS = 4;\n+\tstatic final int THREADS = 10000;\n+\tstatic final int BUCKETS = Runtime.getRuntime().availableProcessors() * SLOTS;\n+\tprivate CompletableFuture<?>[] requests;\n+\tMap<String, String> map;\n+\t\t\n+\tpublic ConcurrentAccessMap(Map<String, String> map) {\n+\t\tthis.map = map;\n+\t}\n+\t\n+\tpublic final void doWork(String type) {\n+\t\trequests = new CompletableFuture<?>[THREADS * SLOTS];\n+\n+\t\tfor (int i = 0; i < THREADS; i++) {\n+        \trequests[SLOTS * i + 0] = CompletableFuture.supplyAsync(putSupplier(i));", "originalCommit": "6388b70f30386a8af7b0bdcea03332b91a268fda", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "63b4db7f7a4253e486d4b13fffadd4f26f89c8f6", "url": "https://github.com/eugenp/tutorials/commit/63b4db7f7a4253e486d4b13fffadd4f26f89c8f6", "message": "BAEL-3855\n\nidentation, moved to new module, removed needless classes, better benchmark", "committedDate": "2020-02-21T13:17:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkwMDc2Nw==", "url": "https://github.com/eugenp/tutorials/pull/8758#discussion_r382900767", "bodyText": "fix indentation", "author": "rpvilao", "createdAt": "2020-02-22T09:47:33Z", "path": "lock-striping/src/com/baeldung/concurrent/lock/ConcurrentAccessMap.java", "diffHunk": "@@ -0,0 +1,33 @@\n+package com.baeldung.concurrent.lock;\n+\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+\n+import com.google.common.base.Supplier;\n+\n+public abstract class ConcurrentAccessMap {\n+    static final int SLOTS = 4;\n+    static final int THREADS = 10000;\n+    static final int BUCKETS = Runtime.getRuntime().availableProcessors() * SLOTS;\n+    private CompletableFuture<?>[] requests;\n+    protected Map<String, String> map;\n+    \n+    public ConcurrentAccessMap(Map<String, String> map) {\n+        this.map = map;\n+    }\n+\n+    public final void doWork(String type) {\n+        requests = new CompletableFuture<?>[THREADS * SLOTS];\n+\n+        for (int i = 0; i < THREADS; i++) {\n+            requests[SLOTS * i + 0] = CompletableFuture.supplyAsync(putSupplier(i));\n+            requests[SLOTS * i + 1] = CompletableFuture.supplyAsync(getSupplier(i));\n+            requests[SLOTS * i + 2] = CompletableFuture.supplyAsync(getSupplier(i));\n+            requests[SLOTS * i + 3] = CompletableFuture.supplyAsync(getSupplier(i)); \t\n+\t\t}", "originalCommit": "63b4db7f7a4253e486d4b13fffadd4f26f89c8f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkwNjYyNQ==", "url": "https://github.com/eugenp/tutorials/pull/8758#discussion_r382906625", "bodyText": "Updated now", "author": "mguarnaccia", "createdAt": "2020-02-22T11:36:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkwMDc2Nw=="}], "type": "inlineReview"}, {"oid": "d1e309cecf6093746fcf32c84119fc730f0b03ce", "url": "https://github.com/eugenp/tutorials/commit/d1e309cecf6093746fcf32c84119fc730f0b03ce", "message": "BAEL-3855\n\nTree update", "committedDate": "2020-02-22T11:34:10Z", "type": "commit"}, {"oid": "8a0d5d85363680bcda2a75f3d71f642225ccca78", "url": "https://github.com/eugenp/tutorials/commit/8a0d5d85363680bcda2a75f3d71f642225ccca78", "message": "BAEL-3855\n\ntree fix", "committedDate": "2020-02-24T09:10:02Z", "type": "commit"}, {"oid": "f1d6b292bd2d785b95fe2cd86b77ee77dacfa00c", "url": "https://github.com/eugenp/tutorials/commit/f1d6b292bd2d785b95fe2cd86b77ee77dacfa00c", "message": "BAEL-3855\n\nMoved to java-core-modules folder", "committedDate": "2020-02-25T09:31:59Z", "type": "commit"}, {"oid": "38d9ed40ca3b8abea4c365646572e4a7026fa633", "url": "https://github.com/eugenp/tutorials/commit/38d9ed40ca3b8abea4c365646572e4a7026fa633", "message": "BAEL-3855\n\nUpdated", "committedDate": "2020-03-09T15:43:35Z", "type": "commit"}, {"oid": "388ba64d3dc8a6e7a4fa11465a382ccf40658b05", "url": "https://github.com/eugenp/tutorials/commit/388ba64d3dc8a6e7a4fa11465a382ccf40658b05", "message": "Delete CoarseGrained.java", "committedDate": "2020-03-11T10:20:37Z", "type": "commit"}, {"oid": "ade062068900b5994bd09665a5aa766db8b6638e", "url": "https://github.com/eugenp/tutorials/commit/ade062068900b5994bd09665a5aa766db8b6638e", "message": "Delete LockStriped.java", "committedDate": "2020-03-11T10:21:01Z", "type": "commit"}, {"oid": "e2c4ff751b26bed7e293cae523c948ce1c81ec7d", "url": "https://github.com/eugenp/tutorials/commit/e2c4ff751b26bed7e293cae523c948ce1c81ec7d", "message": "BAEL-3855", "committedDate": "2020-03-11T12:19:25Z", "type": "commit"}, {"oid": "0566eccb2c0cbdf7a7e033e99aaa2d879118373b", "url": "https://github.com/eugenp/tutorials/commit/0566eccb2c0cbdf7a7e033e99aaa2d879118373b", "message": "BAEL-3855", "committedDate": "2020-03-11T13:31:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk5NjUxMg==", "url": "https://github.com/eugenp/tutorials/pull/8758#discussion_r390996512", "bodyText": "I think this would be simplified by having both instances of your test instantiated from the beginning:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                ConcurrentAccessExperiment accessMyMap;\n          \n          \n            \n                SingleLock single = new SingleLock();\n          \n          \n            \n                StripedLock striped = new StripedLock(BUCKETS);", "author": "jzheaux", "createdAt": "2020-03-11T14:09:26Z", "path": "core-java-modules/core-java-concurrency-collections-2/src/main/java/com/baeldung/concurrent/lock/ConcurrentAccessBenchmark.java", "diffHunk": "@@ -0,0 +1,49 @@\n+package com.baeldung.concurrent.lock;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+@State(Scope.Thread)\n+@Fork(value = 1)\n+@Warmup(iterations = 0)\n+public class ConcurrentAccessBenchmark {\n+    ConcurrentAccessExperiment accessMyMap;", "originalCommit": "0566eccb2c0cbdf7a7e033e99aaa2d879118373b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTEyOTUzNg==", "url": "https://github.com/eugenp/tutorials/pull/8758#discussion_r391129536", "bodyText": "Now both are inited on test call", "author": "mguarnaccia", "createdAt": "2020-03-11T17:11:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk5NjUxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk5NzM3Nw==", "url": "https://github.com/eugenp/tutorials/pull/8758#discussion_r390997377", "bodyText": "The JMH documentation states that benchmark methods should return a value in order to protect against dead code elimination. Maybe doWork could return the resulting Map.", "author": "jzheaux", "createdAt": "2020-03-11T14:10:40Z", "path": "core-java-modules/core-java-concurrency-collections-2/src/main/java/com/baeldung/concurrent/lock/ConcurrentAccessBenchmark.java", "diffHunk": "@@ -0,0 +1,49 @@\n+package com.baeldung.concurrent.lock;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+@State(Scope.Thread)\n+@Fork(value = 1)\n+@Warmup(iterations = 0)\n+public class ConcurrentAccessBenchmark {\n+    ConcurrentAccessExperiment accessMyMap;\n+    static final int SLOTS = 4;\n+    static final int THREADS = 10000;\n+    static final int BUCKETS = Runtime.getRuntime().availableProcessors() * SLOTS;\n+\n+    @Param({\"Single Lock\", \"Striped Lock\"})\n+    private String lockType;\n+\n+    @Param({\"HashMap\", \"ConcurrentHashMap\"})\n+    private String mapType;\n+\n+    @Setup\n+    public void setup() {\n+        switch (lockType) {\n+            case \"Single Lock\":\n+                accessMyMap = new SingleLock();\n+                break;\n+            case \"Striped Lock\":\n+                accessMyMap = new StripedLock(BUCKETS);\n+                break;\n+        }\n+    }\n+\n+    @Benchmark\n+    @BenchmarkMode(Mode.Throughput)\n+    @OutputTimeUnit(TimeUnit.MILLISECONDS)\n+    public void test() throws InterruptedException {", "originalCommit": "0566eccb2c0cbdf7a7e033e99aaa2d879118373b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTEzMjk4Mw==", "url": "https://github.com/eugenp/tutorials/pull/8758#discussion_r391132983", "bodyText": "Done!", "author": "mguarnaccia", "createdAt": "2020-03-11T17:17:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk5NzM3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTAwMDQ5Ng==", "url": "https://github.com/eugenp/tutorials/pull/8758#discussion_r391000496", "bodyText": "I believe that having more than one benchmark method would simplify both ConcurrentAccessBenchmark and ConcurrentAccessExperiment. For example:\n@Benchmark\npublic Map<String, String> singleLockHashMap() {\n    return this.single.doWork(new HashMap<>(), THREADS, SLOTS);\n}\n\n@Benchmark\npublic Map<String, String> stripedLockHashMap() {\n    return this.striped.doWork(new HashMap<>(), THREADS, SLOTS);\n}\n\n@Benchmark\npublic Map<String, String> singleLockConcurrentHashMap() {\n    return this.single.doWork(new ConcurrentHashMap<>(), THREADS, SLOTS);\n}\n\n@Benchmark\npublic Map<String, String> stripedLockConcurrentHashMap() {\n    return this.striped.doWork(new ConcurrentHashMap<>(), THREADS, SLOTS);\n}\nThen, you wouldn't need the setup method in this class nor in the experiment class. You could also then remove the lockType parameter and wouldn't need a direct reference to ConcurrentAccessExperiment.", "author": "jzheaux", "createdAt": "2020-03-11T14:14:49Z", "path": "core-java-modules/core-java-concurrency-collections-2/src/main/java/com/baeldung/concurrent/lock/ConcurrentAccessBenchmark.java", "diffHunk": "@@ -0,0 +1,49 @@\n+package com.baeldung.concurrent.lock;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+@State(Scope.Thread)\n+@Fork(value = 1)\n+@Warmup(iterations = 0)\n+public class ConcurrentAccessBenchmark {\n+    ConcurrentAccessExperiment accessMyMap;\n+    static final int SLOTS = 4;\n+    static final int THREADS = 10000;\n+    static final int BUCKETS = Runtime.getRuntime().availableProcessors() * SLOTS;\n+\n+    @Param({\"Single Lock\", \"Striped Lock\"})\n+    private String lockType;\n+\n+    @Param({\"HashMap\", \"ConcurrentHashMap\"})\n+    private String mapType;\n+\n+    @Setup\n+    public void setup() {\n+        switch (lockType) {\n+            case \"Single Lock\":\n+                accessMyMap = new SingleLock();\n+                break;\n+            case \"Striped Lock\":\n+                accessMyMap = new StripedLock(BUCKETS);\n+                break;\n+        }\n+    }\n+\n+    @Benchmark", "originalCommit": "0566eccb2c0cbdf7a7e033e99aaa2d879118373b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTEzMTAwNQ==", "url": "https://github.com/eugenp/tutorials/pull/8758#discussion_r391131005", "bodyText": "Done!", "author": "mguarnaccia", "createdAt": "2020-03-11T17:13:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTAwMDQ5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTAwMDcxMg==", "url": "https://github.com/eugenp/tutorials/pull/8758#discussion_r391000712", "bodyText": "Let's remove this since it's redundant", "author": "jzheaux", "createdAt": "2020-03-11T14:15:07Z", "path": "core-java-modules/core-java-concurrency-collections-2/src/main/java/com/baeldung/concurrent/lock/ConcurrentAccessExperiment.java", "diffHunk": "@@ -0,0 +1,40 @@\n+package com.baeldung.concurrent.lock;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import com.google.common.base.Supplier;\n+\n+public abstract class ConcurrentAccessExperiment {\n+\n+    public ConcurrentAccessExperiment() {", "originalCommit": "0566eccb2c0cbdf7a7e033e99aaa2d879118373b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTEzMTEwMw==", "url": "https://github.com/eugenp/tutorials/pull/8758#discussion_r391131103", "bodyText": "Done", "author": "mguarnaccia", "createdAt": "2020-03-11T17:14:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTAwMDcxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTAwMTU0MQ==", "url": "https://github.com/eugenp/tutorials/pull/8758#discussion_r391001541", "bodyText": "Why not simply use lock.lock()? That seems to be the default suggestion from the JavaDoc.", "author": "jzheaux", "createdAt": "2020-03-11T14:16:12Z", "path": "core-java-modules/core-java-concurrency-collections-2/src/main/java/com/baeldung/concurrent/lock/SingleLock.java", "diffHunk": "@@ -0,0 +1,44 @@\n+package com.baeldung.concurrent.lock;\n+\n+import java.util.Map;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import com.google.common.base.Supplier;\n+\n+public class SingleLock extends ConcurrentAccessExperiment {\n+    ReentrantLock lock;\n+\n+    public SingleLock() {\n+        lock = new ReentrantLock();\n+    }\n+\n+    protected synchronized Supplier<?> putSupplier(Map<String,String> map, int key) {\n+        return (()-> {\n+            boolean done = false;\n+            try {\n+                while(!done) {", "originalCommit": "0566eccb2c0cbdf7a7e033e99aaa2d879118373b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTIwMzM4NQ==", "url": "https://github.com/eugenp/tutorials/pull/8758#discussion_r391203385", "bodyText": "done, but I had to replicate the behavior in both *Lock classes", "author": "mguarnaccia", "createdAt": "2020-03-11T19:14:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTAwMTU0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTAwNDk5OQ==", "url": "https://github.com/eugenp/tutorials/pull/8758#discussion_r391004999", "bodyText": "I'm not sure I understand the point of these methods being synchronized if they are using programmatic locks. I've always understood that these are alternatives - you can use locks instead of synchronized as an optimization.", "author": "jzheaux", "createdAt": "2020-03-11T14:20:46Z", "path": "core-java-modules/core-java-concurrency-collections-2/src/main/java/com/baeldung/concurrent/lock/SingleLock.java", "diffHunk": "@@ -0,0 +1,44 @@\n+package com.baeldung.concurrent.lock;\n+\n+import java.util.Map;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import com.google.common.base.Supplier;\n+\n+public class SingleLock extends ConcurrentAccessExperiment {\n+    ReentrantLock lock;\n+\n+    public SingleLock() {\n+        lock = new ReentrantLock();\n+    }\n+\n+    protected synchronized Supplier<?> putSupplier(Map<String,String> map, int key) {", "originalCommit": "0566eccb2c0cbdf7a7e033e99aaa2d879118373b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTIwMzAzNw==", "url": "https://github.com/eugenp/tutorials/pull/8758#discussion_r391203037", "bodyText": "ok, it was added from a previous thread we had. removed now.", "author": "mguarnaccia", "createdAt": "2020-03-11T19:13:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTAwNDk5OQ=="}], "type": "inlineReview"}, {"oid": "1faabdd643e3dcfc32f4ecec2000614a158a8e36", "url": "https://github.com/eugenp/tutorials/commit/1faabdd643e3dcfc32f4ecec2000614a158a8e36", "message": "BAEL-3855", "committedDate": "2020-03-11T17:18:05Z", "type": "commit"}, {"oid": "e0058789fbdaf60da758b1b49ea45067bfa78746", "url": "https://github.com/eugenp/tutorials/commit/e0058789fbdaf60da758b1b49ea45067bfa78746", "message": "BAEL-3855", "committedDate": "2020-03-11T18:56:30Z", "type": "commit"}, {"oid": "7b403992993f8d27532141c372a0e0811d1875ac", "url": "https://github.com/eugenp/tutorials/commit/7b403992993f8d27532141c372a0e0811d1875ac", "message": "BAEL-3855", "committedDate": "2020-03-11T19:09:14Z", "type": "commit"}, {"oid": "2892b138ee99616983a67d7fbb2ec4c3c0358ef6", "url": "https://github.com/eugenp/tutorials/commit/2892b138ee99616983a67d7fbb2ec4c3c0358ef6", "message": "BAEL-3855\n\nidentation", "committedDate": "2020-03-11T19:13:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI3Mzk4Mw==", "url": "https://github.com/eugenp/tutorials/pull/8758#discussion_r392273983", "bodyText": "Wouldn't this be an infinite loop? Seems risky to just infinitely try again. I'd recommend doing:\nlock.lock();\ntry {\n    return map.put(\"key\" + key, \"value\" + key);\n} finally {\n    lock.unlock();\n}\nThis is what the JavaDoc recommends.\nAlso, if you return the result of map.put, then you don't need the extra return null; at the bottom.", "author": "jzheaux", "createdAt": "2020-03-13T14:48:07Z", "path": "core-java-modules/core-java-concurrency-collections-2/src/main/java/com/baeldung/concurrent/lock/SingleLock.java", "diffHunk": "@@ -0,0 +1,46 @@\n+package com.baeldung.concurrent.lock;\n+\n+import java.util.Map;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import com.google.common.base.Supplier;\n+\n+public class SingleLock extends ConcurrentAccessExperiment {\n+    ReentrantLock lock;\n+\n+    public SingleLock() {\n+        lock = new ReentrantLock();\n+    }\n+\n+    protected Supplier<?> putSupplier(Map<String,String> map, int key) {\n+        return (()-> {\n+            try {\n+                lock.lock();\n+                map.put(\"key\" + key, \"value\" + key);\n+            } catch (Exception e) {\n+                this.putSupplier(map, key);", "originalCommit": "2892b138ee99616983a67d7fbb2ec4c3c0358ef6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI4Mjc2Mg==", "url": "https://github.com/eugenp/tutorials/pull/8758#discussion_r392282762", "bodyText": "Well, what if the lock is not acquired? the thread won't execute and we lose a put/get", "author": "mguarnaccia", "createdAt": "2020-03-13T15:02:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI3Mzk4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU5NzMwMg==", "url": "https://github.com/eugenp/tutorials/pull/8758#discussion_r392597302", "bodyText": "lock will block until the lock is acquired. From the JavaDoc:\n\nIf the lock is held by another thread then the current thread becomes disabled for thread scheduling purposes and lies dormant until the lock has been acquired, at which time the lock hold count is set to one.", "author": "jzheaux", "createdAt": "2020-03-14T15:41:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI3Mzk4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU5NzU1NA==", "url": "https://github.com/eugenp/tutorials/pull/8758#discussion_r392597554", "bodyText": "The thread will block until the lock is acquired. From the JavaDoc:\n\nIf the lock is held by another thread then the current thread becomes disabled for thread scheduling purposes and lies dormant until the lock has been acquired, at which time the lock hold count is set to one.\n\nI guess the question I have is, what is so different about this use case that we'd deviate from the JavaDoc?", "author": "jzheaux", "createdAt": "2020-03-14T15:45:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI3Mzk4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjY2NTM5Nw==", "url": "https://github.com/eugenp/tutorials/pull/8758#discussion_r392665397", "bodyText": "Ok", "author": "mguarnaccia", "createdAt": "2020-03-15T11:39:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI3Mzk4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI3NTEzMA==", "url": "https://github.com/eugenp/tutorials/pull/8758#discussion_r392275130", "bodyText": "Please check the indentation here.", "author": "jzheaux", "createdAt": "2020-03-13T14:49:55Z", "path": "core-java-modules/core-java-concurrency-collections-2/src/main/java/com/baeldung/concurrent/lock/StripedLock.java", "diffHunk": "@@ -0,0 +1,51 @@\n+package com.baeldung.concurrent.lock;\n+\n+import java.util.Map;\n+import java.util.concurrent.locks.Lock;\n+\n+import com.google.common.base.Supplier;\n+import com.google.common.util.concurrent.Striped;\n+\n+public class StripedLock extends ConcurrentAccessExperiment {\n+    Striped<Lock> stripedLock;\n+\n+    public StripedLock(int buckets) {\n+        stripedLock = Striped.lock(buckets);\n+    }\n+\n+    protected Supplier<?> putSupplier(Map<String,String> map, int key) {\n+        return (()-> {\n+        \tint bucket = key % stripedLock.size();", "originalCommit": "2892b138ee99616983a67d7fbb2ec4c3c0358ef6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI5OTAxMA==", "url": "https://github.com/eugenp/tutorials/pull/8758#discussion_r392299010", "bodyText": "Done", "author": "mguarnaccia", "createdAt": "2020-03-13T15:27:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI3NTEzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI3NjM2NQ==", "url": "https://github.com/eugenp/tutorials/pull/8758#discussion_r392276365", "bodyText": "I don't understand why you are re-instantiated the object each time. Won't that play into your results?\nIt seems like what you want to do is just reuse one already instantiated at the field level. That way, your benchmark is only about the work being done on the map and not about that plus the cost of instantiating the worker object.", "author": "jzheaux", "createdAt": "2020-03-13T14:51:49Z", "path": "core-java-modules/core-java-concurrency-collections-2/src/main/java/com/baeldung/concurrent/lock/ConcurrentAccessBenchmark.java", "diffHunk": "@@ -0,0 +1,52 @@\n+package com.baeldung.concurrent.lock;\n+\n+import java.util.HashMap;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+@State(Scope.Thread)\n+@Fork(value = 2)\n+@Warmup(iterations = 0)\n+public class ConcurrentAccessBenchmark {\n+    ConcurrentAccessExperiment accessMyMap;\n+    static final int SLOTS = 4;\n+    static final int THREADS = 10000;\n+    static final int BUCKETS = Runtime.getRuntime().availableProcessors() * SLOTS;\n+\n+    @Benchmark\n+    @BenchmarkMode(Mode.Throughput)\n+    @OutputTimeUnit(TimeUnit.MILLISECONDS)\n+    public void singleLockHashMap() throws InterruptedException {\n+        (new SingleLock()).doWork(new HashMap<String,String>(), THREADS, SLOTS);", "originalCommit": "2892b138ee99616983a67d7fbb2ec4c3c0358ef6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI5NTY3Mg==", "url": "https://github.com/eugenp/tutorials/pull/8758#discussion_r392295672", "bodyText": "I'm sorry but I don't get the point. Instantiating the object is not such a big cost, also it appears in every test. If we want to instantiate the maps before, we should also remove the \"put\" phase inside the test.", "author": "mguarnaccia", "createdAt": "2020-03-13T15:22:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI3NjM2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU5NzQ0Mg==", "url": "https://github.com/eugenp/tutorials/pull/8758#discussion_r392597442", "bodyText": "To be clear, I'm only referring to new SingleLock() and by association new StripedLock().\nThe reason we should remove the instantiation is that it is unnecessary. What are you gaining from instantiating it here? AFAICT, each test doesn't need its own instance in order to give correct results.", "author": "jzheaux", "createdAt": "2020-03-14T15:43:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI3NjM2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjY2NDUwNw==", "url": "https://github.com/eugenp/tutorials/pull/8758#discussion_r392664507", "bodyText": "Ok", "author": "mguarnaccia", "createdAt": "2020-03-15T11:28:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI3NjM2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI3NjUzNQ==", "url": "https://github.com/eugenp/tutorials/pull/8758#discussion_r392276535", "bodyText": "These need to return values, in accordance with JMH's guidelines.", "author": "jzheaux", "createdAt": "2020-03-13T14:52:06Z", "path": "core-java-modules/core-java-concurrency-collections-2/src/main/java/com/baeldung/concurrent/lock/ConcurrentAccessBenchmark.java", "diffHunk": "@@ -0,0 +1,52 @@\n+package com.baeldung.concurrent.lock;\n+\n+import java.util.HashMap;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+@State(Scope.Thread)\n+@Fork(value = 2)\n+@Warmup(iterations = 0)\n+public class ConcurrentAccessBenchmark {\n+    ConcurrentAccessExperiment accessMyMap;\n+    static final int SLOTS = 4;\n+    static final int THREADS = 10000;\n+    static final int BUCKETS = Runtime.getRuntime().availableProcessors() * SLOTS;\n+\n+    @Benchmark\n+    @BenchmarkMode(Mode.Throughput)\n+    @OutputTimeUnit(TimeUnit.MILLISECONDS)\n+    public void singleLockHashMap() throws InterruptedException {", "originalCommit": "2892b138ee99616983a67d7fbb2ec4c3c0358ef6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI5NzgxOA==", "url": "https://github.com/eugenp/tutorials/pull/8758#discussion_r392297818", "bodyText": "Sorry, I only changed the doWork method. I'll fix it.", "author": "mguarnaccia", "createdAt": "2020-03-13T15:26:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI3NjUzNQ=="}], "type": "inlineReview"}, {"oid": "d04b0f30b6094ad647200e4ca32f8294400bd1ea", "url": "https://github.com/eugenp/tutorials/commit/d04b0f30b6094ad647200e4ca32f8294400bd1ea", "message": "BAEL-3855", "committedDate": "2020-03-13T15:33:34Z", "type": "commit"}, {"oid": "34bfe41cd9eeae716b258d14d9c0236b15878dec", "url": "https://github.com/eugenp/tutorials/commit/34bfe41cd9eeae716b258d14d9c0236b15878dec", "message": "BAEL-3855", "committedDate": "2020-03-15T11:50:43Z", "type": "commit"}, {"oid": "22b51db880fdd7ca547f566ace3ddd927f2adeaf", "url": "https://github.com/eugenp/tutorials/commit/22b51db880fdd7ca547f566ace3ddd927f2adeaf", "message": "BAEL-3855", "committedDate": "2020-03-15T12:04:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzc4MTQ0Nw==", "url": "https://github.com/eugenp/tutorials/pull/8758#discussion_r393781447", "bodyText": "We don't want to lock inside the try (see the JavaDoc). The reason is that if lock.lock() did in fact throw a RuntimeException, then the unlock could cause some unexpected results (since it's re-entrant, it could unlock one more level than intended, for example).", "author": "jzheaux", "createdAt": "2020-03-17T15:50:38Z", "path": "core-java-modules/core-java-concurrency-collections-2/src/main/java/com/baeldung/concurrent/lock/SingleLock.java", "diffHunk": "@@ -0,0 +1,36 @@\n+package com.baeldung.concurrent.lock;\n+\n+import java.util.Map;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import com.google.common.base.Supplier;\n+\n+public class SingleLock extends ConcurrentAccessExperiment {\n+    ReentrantLock lock;\n+\n+    public SingleLock() {\n+        lock = new ReentrantLock();\n+    }\n+\n+    protected Supplier<?> putSupplier(Map<String,String> map, int key) {\n+        return (()-> {\n+            try {\n+                lock.lock();", "originalCommit": "22b51db880fdd7ca547f566ace3ddd927f2adeaf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIwMzMzMg==", "url": "https://github.com/eugenp/tutorials/pull/8758#discussion_r394203332", "bodyText": "Ok!", "author": "mguarnaccia", "createdAt": "2020-03-18T09:20:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzc4MTQ0Nw=="}], "type": "inlineReview"}, {"oid": "9140283ca2f8c9d8d2e191825dadce46bb8f0089", "url": "https://github.com/eugenp/tutorials/commit/9140283ca2f8c9d8d2e191825dadce46bb8f0089", "message": "BAEL-3855", "committedDate": "2020-03-18T09:18:58Z", "type": "commit"}]}