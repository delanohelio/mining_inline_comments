{"pr_number": 1034, "pr_title": "ksql - generate globalId from kafka record", "pr_createdAt": "2020-11-26T11:36:19Z", "pr_url": "https://github.com/Apicurio/apicurio-registry/pull/1034", "timeline": [{"oid": "cf117c7ad67c9b9f931d80c9ef0bdb518d6a867e", "url": "https://github.com/Apicurio/apicurio-registry/commit/cf117c7ad67c9b9f931d80c9ef0bdb518d6a867e", "message": "ksql - generate globalId from kafka record", "committedDate": "2020-11-26T11:32:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDk3NDA1Mw==", "url": "https://github.com/Apicurio/apicurio-registry/pull/1034#discussion_r530974053", "bodyText": "Why don't just bind the globalId, like we're doing with the other parameters?", "author": "carlesarnal", "createdAt": "2020-11-26T11:48:23Z", "path": "utils/sql/src/main/java/io/apicurio/registry/storage/impl/sql/CommonSqlStatements.java", "diffHunk": "@@ -147,17 +147,20 @@ public String updateArtifactLatest() {\n     public String updateArtifactLatestGlobalId() {\n         return \"UPDATE artifacts SET latest = (SELECT v.globalId FROM versions v WHERE v.artifactId = ? AND v.version = ?) WHERE artifactId = ?\";\n     }\n-    \n+\n     /**\n      * @see io.apicurio.registry.storage.impl.sql.SqlStatements#insertVersion()\n      */\n     @Override\n-    public String insertVersion(boolean firstVersion) {\n+    public String insertVersion(boolean firstVersion, String globalId) {\n+        String query;\n         if (firstVersion) {\n-            return \"INSERT INTO versions (artifactId, version, state, name, description, createdBy, createdOn, labels, properties, contentId) VALUES (?, 1, ?, ?, ?, ?, ?, ?, ?, ?)\";\n+            query = \"INSERT INTO versions (globalId, artifactId, version, state, name, description, createdBy, createdOn, labels, properties, contentId) VALUES (%s, ?, 1, ?, ?, ?, ?, ?, ?, ?, ?)\";", "originalCommit": "cf117c7ad67c9b9f931d80c9ef0bdb518d6a867e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDk4MDQzNA==", "url": "https://github.com/Apicurio/apicurio-registry/pull/1034#discussion_r530980434", "bodyText": "I tried that before, and in the case of the sql sequence case triying to bind nextval('globalidsequence') does not work.\nThe library we are using tries to bind that as the value to insert, and in that case it is an expression for the db to generate the value.\nAnd I needed to combine both, allowing the db to generate the value or providing the value beforehand", "author": "famartinrh", "createdAt": "2020-11-26T11:59:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDk3NDA1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc4OTc3Mg==", "url": "https://github.com/Apicurio/apicurio-registry/pull/1034#discussion_r532789772", "bodyText": "I understand, but I think doing it this way is going to trigger security scanners to flag this as a SQL injection vulnerability (technically it is).  We could bind the value just like the other parameters if we make a separate DB call to get the next sequence value.  What do you think about that approach?", "author": "EricWittmann", "createdAt": "2020-11-30T17:56:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDk3NDA1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgwMTYyOQ==", "url": "https://github.com/Apicurio/apicurio-registry/pull/1034#discussion_r532801629", "bodyText": "if making a separate DB call is fine with transactionality, which I guess it is , I'm ok with your approach", "author": "famartinrh", "createdAt": "2020-11-30T18:15:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDk3NDA1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgxMzYzNw==", "url": "https://github.com/Apicurio/apicurio-registry/pull/1034#discussion_r532813637", "bodyText": "Yeah should be fine with the Tx.  Let's try doing that - it should clean some things up.", "author": "EricWittmann", "createdAt": "2020-11-30T18:35:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDk3NDA1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc5OTM2OA==", "url": "https://github.com/Apicurio/apicurio-registry/pull/1034#discussion_r532799368", "bodyText": "We may need to revisit this for multi-tenancy if we go that way.  Fine for now though.  I wonder if we could use 10 or 12 bits when shifting to give us more headroom for the offset.  The less we bitshift the offset the fewer partitions we can have, but right now we can have 65k partitions which seems high.  Bitshifting by 10 would give us 1024 partitions and more headroom before we overran the integer.  Overrunning the integer is a concern for the ccompat API, which uses an integer for the globalId instead of a long.\nThoughts @Apicurio/developers ?", "author": "EricWittmann", "createdAt": "2020-11-30T18:11:42Z", "path": "storage/ksql/src/main/java/io/apicurio/registry/storage/impl/ksql/sql/KafkaSQLSink.java", "diffHunk": "@@ -233,4 +264,16 @@ private boolean isGlobalRules(String artifactId) {\n         return artifactId.equals(KafkaSqlRegistryStorage.GLOBAL_RULES_ID);\n     }\n \n+    public long toGlobalId(long offset, int partition) {\n+        return getBaseOffset() + (offset << 16) + partition;\n+    }\n+\n+    // just to make sure we can always move the whole system\n+    // and not get duplicates; e.g. after move baseOffset = max(globalId) + 1\n+    public long getBaseOffset() {\n+        //TODO\n+        //        return Long.parseLong(properties.getProperty(\"storage.base.offset\", \"0\"));\n+        return 0;\n+    }\n+", "originalCommit": "cf117c7ad67c9b9f931d80c9ef0bdb518d6a867e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgwMDc5Mg==", "url": "https://github.com/Apicurio/apicurio-registry/pull/1034#discussion_r532800792", "bodyText": "To avoid a SQL injection vector, this could instead actually make a call to the DB to get the next value and return it.", "author": "EricWittmann", "createdAt": "2020-11-30T18:14:07Z", "path": "utils/sql/src/main/java/io/apicurio/registry/storage/impl/sql/SqlGlobalIdGenerator.java", "diffHunk": "@@ -0,0 +1,28 @@\n+/*\n+ * Copyright 2020 Red Hat\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.apicurio.registry.storage.impl.sql;\n+\n+/**\n+ * @author Fabian Martinez\n+ */\n+public class SqlGlobalIdGenerator implements GlobalIdGenerator {", "originalCommit": "cf117c7ad67c9b9f931d80c9ef0bdb518d6a867e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5f3862af0fdb02b4040079ca069b3258bef96eee", "url": "https://github.com/Apicurio/apicurio-registry/commit/5f3862af0fdb02b4040079ca069b3258bef96eee", "message": "obtain globalId in sql storage with separated call to the DB", "committedDate": "2020-12-01T11:54:33Z", "type": "commit"}]}