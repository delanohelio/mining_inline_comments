{"pr_number": 1632, "pr_title": "search for references from IClassFile without source", "pr_createdAt": "2020-12-15T20:16:22Z", "pr_url": "https://github.com/eclipse/eclipse.jdt.ls/pull/1632", "timeline": [{"oid": "319a9049c59047e9918f2c643a56dd60a448b5f7", "url": "https://github.com/eclipse/eclipse.jdt.ls/commit/319a9049c59047e9918f2c643a56dd60a448b5f7", "message": "search for enum reference without source\n\nSigned-off-by: Snjezana Peco <snjezana.peco@redhat.com>", "committedDate": "2020-12-15T21:33:23Z", "type": "forcePushed"}, {"oid": "90650bb673e8d9f255f377c53905642cfaf8efc7", "url": "https://github.com/eclipse/eclipse.jdt.ls/commit/90650bb673e8d9f255f377c53905642cfaf8efc7", "message": "search for enum reference without source\n\nSigned-off-by: Snjezana Peco <snjezana.peco@redhat.com>", "committedDate": "2020-12-15T21:41:18Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA2MDQ1Mg==", "url": "https://github.com/eclipse/eclipse.jdt.ls/pull/1632#discussion_r552060452", "bodyText": "I would place this logic in a separate private method that returns the boolean value that is assigned to 'found'. This just simplifies this method a bit.", "author": "rgrunber", "createdAt": "2021-01-05T16:54:58Z", "path": "org.eclipse.jdt.ls.core/src/org/eclipse/jdt/ls/core/internal/handlers/ReferencesHandler.java", "diffHunk": "@@ -149,6 +161,79 @@ public void acceptSearchMatch(SearchMatch match) throws CoreException {\n \t\t\t\t\t\tif (cf != null && cf.getSourceRange() != null) {\n \t\t\t\t\t\t\tlocation = JDTUtils.toLocation(cf, match.getOffset(), match.getLength());\n \t\t\t\t\t\t}\n+\t\t\t\t\t\tif (cf != null && location == null) {\n+\t\t\t\t\t\t\tContentProviderManager contentProvider = JavaLanguageServerPlugin.getContentProviderManager();\n+\t\t\t\t\t\t\tString contents = contentProvider.getSource(cf, new NullProgressMonitor());\n+\t\t\t\t\t\t\tif (contents != null) {\n+\t\t\t\t\t\t\t\tfinal ASTParser parser = ASTParser.newParser(IASTSharedValues.SHARED_AST_LEVEL);\n+\t\t\t\t\t\t\t\tparser.setResolveBindings(true);\n+\t\t\t\t\t\t\t\tparser.setKind(ASTParser.K_COMPILATION_UNIT);\n+\t\t\t\t\t\t\t\tparser.setStatementsRecovery(IASTSharedValues.SHARED_AST_STATEMENT_RECOVERY);\n+\t\t\t\t\t\t\t\tparser.setBindingsRecovery(IASTSharedValues.SHARED_BINDING_RECOVERY);\n+\t\t\t\t\t\t\t\tparser.setSource(contents.toCharArray());\n+\t\t\t\t\t\t\t\tCompilationUnit unit = (CompilationUnit) parser.createAST(null);\n+\t\t\t\t\t\t\t\tfinal ASTNode[] nodes = new ASTNode[1];\n+\t\t\t\t\t\t\t\tunit.accept(new ASTVisitor() {\n+\n+\t\t\t\t\t\t\t\t\t@Override\n+\t\t\t\t\t\t\t\t\tpublic boolean visit(SimpleName node) {\n+\t\t\t\t\t\t\t\t\t\tif (element.getElementName().equals(node.getIdentifier())) {\n+\t\t\t\t\t\t\t\t\t\t\tASTNode parent = node.getParent();\n+\t\t\t\t\t\t\t\t\t\t\tboolean found = false;\n+\t\t\t\t\t\t\t\t\t\t\tswitch (parent.getNodeType()) {\n+\t\t\t\t\t\t\t\t\t\t\t\tcase ASTNode.ANNOTATION_TYPE_DECLARATION:\n+\t\t\t\t\t\t\t\t\t\t\t\tcase ASTNode.ANNOTATION_TYPE_MEMBER_DECLARATION:\n+\t\t\t\t\t\t\t\t\t\t\t\t\tfound = element.getElementType() == IJavaElement.ANNOTATION;\n+\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t\t\t\t\t\t\tcase ASTNode.FIELD_DECLARATION:\n+\t\t\t\t\t\t\t\t\t\t\t\tcase ASTNode.ENUM_CONSTANT_DECLARATION:\n+\t\t\t\t\t\t\t\t\t\t\t\tcase ASTNode.ENUM_DECLARATION:\n+\t\t\t\t\t\t\t\t\t\t\t\tcase ASTNode.FIELD_ACCESS:\n+\t\t\t\t\t\t\t\t\t\t\t\t\tfound = element.getElementType() == IJavaElement.FIELD;\n+\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t\t\t\t\t\t\tcase ASTNode.METHOD_DECLARATION:\n+\t\t\t\t\t\t\t\t\t\t\t\tcase ASTNode.METHOD_INVOCATION:\n+\t\t\t\t\t\t\t\t\t\t\t\tcase ASTNode.EXPRESSION_METHOD_REFERENCE:\n+\t\t\t\t\t\t\t\t\t\t\t\t\tfound = element.getElementType() == IJavaElement.METHOD;\n+\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t\t\t\t\t\t\tcase ASTNode.TYPE_DECLARATION:\n+\t\t\t\t\t\t\t\t\t\t\t\tcase ASTNode.VARIABLE_DECLARATION_FRAGMENT:\n+\t\t\t\t\t\t\t\t\t\t\t\tcase ASTNode.VARIABLE_DECLARATION_STATEMENT:\n+\t\t\t\t\t\t\t\t\t\t\t\tcase ASTNode.VARIABLE_DECLARATION_EXPRESSION:\n+\t\t\t\t\t\t\t\t\t\t\t\t\tfound = element.getElementType() == IJavaElement.TYPE || element.getElementType() == IJavaElement.FIELD || element.getElementType() == IJavaElement.METHOD;\n+\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t\t\t\t\t\t\tdefault:\n+\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t\t\t\t\t\t}", "originalCommit": "90650bb673e8d9f255f377c53905642cfaf8efc7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njc5OTY3OQ==", "url": "https://github.com/eclipse/eclipse.jdt.ls/pull/1632#discussion_r556799679", "bodyText": "Fixed.", "author": "snjeza", "createdAt": "2021-01-13T20:11:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA2MDQ1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA2MzE4Mg==", "url": "https://github.com/eclipse/eclipse.jdt.ls/pull/1632#discussion_r552063182", "bodyText": "Might be worth confirming whether setResolveBindings/setBindingsRecovery can be false. If possible, it should improve computation time.", "author": "rgrunber", "createdAt": "2021-01-05T16:59:05Z", "path": "org.eclipse.jdt.ls.core/src/org/eclipse/jdt/ls/core/internal/handlers/ReferencesHandler.java", "diffHunk": "@@ -149,6 +161,79 @@ public void acceptSearchMatch(SearchMatch match) throws CoreException {\n \t\t\t\t\t\tif (cf != null && cf.getSourceRange() != null) {\n \t\t\t\t\t\t\tlocation = JDTUtils.toLocation(cf, match.getOffset(), match.getLength());\n \t\t\t\t\t\t}\n+\t\t\t\t\t\tif (cf != null && location == null) {\n+\t\t\t\t\t\t\tContentProviderManager contentProvider = JavaLanguageServerPlugin.getContentProviderManager();\n+\t\t\t\t\t\t\tString contents = contentProvider.getSource(cf, new NullProgressMonitor());\n+\t\t\t\t\t\t\tif (contents != null) {\n+\t\t\t\t\t\t\t\tfinal ASTParser parser = ASTParser.newParser(IASTSharedValues.SHARED_AST_LEVEL);\n+\t\t\t\t\t\t\t\tparser.setResolveBindings(true);", "originalCommit": "90650bb673e8d9f255f377c53905642cfaf8efc7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njc5OTkxMQ==", "url": "https://github.com/eclipse/eclipse.jdt.ls/pull/1632#discussion_r556799911", "bodyText": "Fixed.", "author": "snjeza", "createdAt": "2021-01-13T20:11:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA2MzE4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg4NDc5Mw==", "url": "https://github.com/eclipse/eclipse.jdt.ls/pull/1632#discussion_r556884793", "bodyText": "Can setResolveBindings(..) be set to false as well ? This is the method that requests the creation of bindings.", "author": "rgrunber", "createdAt": "2021-01-13T22:04:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA2MzE4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njk3NjU1Nw==", "url": "https://github.com/eclipse/eclipse.jdt.ls/pull/1632#discussion_r556976557", "bodyText": "Fixed", "author": "snjeza", "createdAt": "2021-01-14T01:00:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA2MzE4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA3MTYyNw==", "url": "https://github.com/eclipse/eclipse.jdt.ls/pull/1632#discussion_r552071627", "bodyText": "I guess searching the full project can be a bit expensive ? If so this is fine.", "author": "rgrunber", "createdAt": "2021-01-05T17:13:08Z", "path": "org.eclipse.jdt.ls.core/src/org/eclipse/jdt/ls/core/internal/JDTUtils.java", "diffHunk": "@@ -727,28 +727,17 @@ public static IJavaElement findElementAtSelection(ITypeRoot unit, int line, int\n \t\t\t\ttry {\r\n \t\t\t\t\toffset = document.getLineOffset(line) + column;\r\n \t\t\t\t\tif (offset > -1) {\r\n+\t\t\t\t\t\tif (offset > 0 && !isJavaIdentifierOrPeriod(contents.charAt(offset))) {\r\n+\t\t\t\t\t\t\toffset = offset - 1;\r\n+\t\t\t\t\t\t}\r\n \t\t\t\t\t\tString name = parse(contents, offset);\r\n \t\t\t\t\t\tif (name == null) {\r\n \t\t\t\t\t\t\treturn null;\r\n \t\t\t\t\t\t}\r\n-\t\t\t\t\t\tSearchPattern pattern = SearchPattern.createPattern(name, IJavaSearchConstants.TYPE,\r\n-\t\t\t\t\t\t\t\tIJavaSearchConstants.DECLARATIONS, SearchPattern.R_FULL_MATCH);\r\n-\r\n-\t\t\t\t\t\tIJavaSearchScope scope = createSearchScope(unit.getJavaProject(), preferenceManager);\r\n-\r\n-\t\t\t\t\t\tList<IJavaElement> elements = new ArrayList<>();\r\n-\t\t\t\t\t\tSearchRequestor requestor = new SearchRequestor() {\r\n-\t\t\t\t\t\t\t@Override\r\n-\t\t\t\t\t\t\tpublic void acceptSearchMatch(SearchMatch match) {\r\n-\t\t\t\t\t\t\t\tif (match.getElement() instanceof IJavaElement) {\r\n-\t\t\t\t\t\t\t\t\telements.add((IJavaElement) match.getElement());\r\n-\t\t\t\t\t\t\t\t}\r\n-\t\t\t\t\t\t\t}\r\n-\t\t\t\t\t\t};\r\n-\t\t\t\t\t\tSearchEngine searchEngine = new SearchEngine();\r\n-\t\t\t\t\t\tsearchEngine.search(pattern,\r\n-\t\t\t\t\t\t\t\tnew SearchParticipant[] { SearchEngine.getDefaultSearchParticipant() }, scope,\r\n-\t\t\t\t\t\t\t\trequestor, null);\r\n+\t\t\t\t\t\tList<IJavaElement> elements = search(unit, name, preferenceManager);\r\n+\t\t\t\t\t\tif (elements.isEmpty()) {\r\n+\t\t\t\t\t\t\telements = search(unit.getJavaProject(), name, preferenceManager);\r", "originalCommit": "90650bb673e8d9f255f377c53905642cfaf8efc7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjgwMDA5Mw==", "url": "https://github.com/eclipse/eclipse.jdt.ls/pull/1632#discussion_r556800093", "bodyText": "You are right.", "author": "snjeza", "createdAt": "2021-01-13T20:11:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA3MTYyNw=="}], "type": "inlineReview"}, {"oid": "3558bc63abe63e1f9c8ae1ff970545e1e0038c42", "url": "https://github.com/eclipse/eclipse.jdt.ls/commit/3558bc63abe63e1f9c8ae1ff970545e1e0038c42", "message": "search for enum reference without source\n\nSigned-off-by: Snjezana Peco <snjezana.peco@redhat.com>", "committedDate": "2021-01-13T20:10:24Z", "type": "forcePushed"}, {"oid": "9ce4d1390f69b4ace660770e8016b020e7c53722", "url": "https://github.com/eclipse/eclipse.jdt.ls/commit/9ce4d1390f69b4ace660770e8016b020e7c53722", "message": "search for enum reference without source\n\nSigned-off-by: Snjezana Peco <snjezana.peco@redhat.com>", "committedDate": "2021-01-13T23:59:53Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzk0Nzk4NA==", "url": "https://github.com/eclipse/eclipse.jdt.ls/pull/1632#discussion_r557947984", "bodyText": "We can make this as a utility method. Both NavigateToDefinitionHandler and NavigateToTypeDefinitionHandler have the same need to convert position to a location of the disassembled source.\nBut when you reuse it for the 'Go to Definition' feature, you don't need parse the method body while resolving the dom because 'Go to Definition' never jumps to the method implementation.\nfinal ASTParser parser = ASTParser.newParser(IASTSharedValues.SHARED_AST_LEVEL);\nparser.setResolveBindings(false);\nparser.setKind(ASTParser.K_COMPILATION_UNIT);\nparser.setStatementsRecovery(false);\nparser.setBindingsRecovery(false);\nparser.setSource(contents.toCharArray());\nparser.setIgnoreMethodBodies(true);   <== No need to parse method body since 'go to definition' only jumps to the method declaration.", "author": "testforstephen", "createdAt": "2021-01-15T07:32:35Z", "path": "org.eclipse.jdt.ls.core/src/org/eclipse/jdt/ls/core/internal/handlers/ReferencesHandler.java", "diffHunk": "@@ -149,6 +161,85 @@ public void acceptSearchMatch(SearchMatch match) throws CoreException {\n \t\t\t\t\t\tif (cf != null && cf.getSourceRange() != null) {\n \t\t\t\t\t\t\tlocation = JDTUtils.toLocation(cf, match.getOffset(), match.getLength());\n \t\t\t\t\t\t}\n+\t\t\t\t\t\tif (cf != null && location == null) {\n+\t\t\t\t\t\t\tContentProviderManager contentProvider = JavaLanguageServerPlugin.getContentProviderManager();\n+\t\t\t\t\t\t\tString contents = contentProvider.getSource(cf, new NullProgressMonitor());\n+\t\t\t\t\t\t\tif (contents != null) {\n+\t\t\t\t\t\t\t\tfinal ASTParser parser = ASTParser.newParser(IASTSharedValues.SHARED_AST_LEVEL);\n+\t\t\t\t\t\t\t\tparser.setResolveBindings(false);\n+\t\t\t\t\t\t\t\tparser.setKind(ASTParser.K_COMPILATION_UNIT);\n+\t\t\t\t\t\t\t\tparser.setStatementsRecovery(false);\n+\t\t\t\t\t\t\t\tparser.setBindingsRecovery(false);\n+\t\t\t\t\t\t\t\tparser.setSource(contents.toCharArray());\n+\t\t\t\t\t\t\t\tCompilationUnit unit = (CompilationUnit) parser.createAST(null);\n+\t\t\t\t\t\t\t\tfinal ASTNode[] nodes = new ASTNode[1];\n+\t\t\t\t\t\t\t\tunit.accept(new ASTVisitor() {\n+\n+\t\t\t\t\t\t\t\t\t@Override\n+\t\t\t\t\t\t\t\t\tpublic boolean visit(SimpleName node) {\n+\t\t\t\t\t\t\t\t\t\tif (element.getElementName().equals(node.getIdentifier())) {\n+\t\t\t\t\t\t\t\t\t\t\tif (find(element, nodes, node)) {\n+\t\t\t\t\t\t\t\t\t\t\t\treturn false;\n+\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\treturn super.visit(node);\n+\t\t\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t\t\tprivate boolean find(IJavaElement element, final ASTNode[] nodes, SimpleName node) {\n+\t\t\t\t\t\t\t\t\t\tASTNode parent = node.getParent();\n+\t\t\t\t\t\t\t\t\t\tboolean found = false;\n+\t\t\t\t\t\t\t\t\t\tswitch (parent.getNodeType()) {\n+\t\t\t\t\t\t\t\t\t\t\tcase ASTNode.ANNOTATION_TYPE_DECLARATION:\n+\t\t\t\t\t\t\t\t\t\t\tcase ASTNode.ANNOTATION_TYPE_MEMBER_DECLARATION:\n+\t\t\t\t\t\t\t\t\t\t\t\tfound = element.getElementType() == IJavaElement.ANNOTATION;\n+\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t\t\t\t\t\tcase ASTNode.FIELD_DECLARATION:\n+\t\t\t\t\t\t\t\t\t\t\tcase ASTNode.ENUM_CONSTANT_DECLARATION:\n+\t\t\t\t\t\t\t\t\t\t\tcase ASTNode.ENUM_DECLARATION:\n+\t\t\t\t\t\t\t\t\t\t\tcase ASTNode.FIELD_ACCESS:\n+\t\t\t\t\t\t\t\t\t\t\t\tfound = element.getElementType() == IJavaElement.FIELD;\n+\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t\t\t\t\t\tcase ASTNode.METHOD_DECLARATION:\n+\t\t\t\t\t\t\t\t\t\t\tcase ASTNode.METHOD_INVOCATION:\n+\t\t\t\t\t\t\t\t\t\t\tcase ASTNode.EXPRESSION_METHOD_REFERENCE:\n+\t\t\t\t\t\t\t\t\t\t\t\tfound = element.getElementType() == IJavaElement.METHOD;\n+\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t\t\t\t\t\tcase ASTNode.TYPE_DECLARATION:\n+\t\t\t\t\t\t\t\t\t\t\tcase ASTNode.VARIABLE_DECLARATION_FRAGMENT:\n+\t\t\t\t\t\t\t\t\t\t\tcase ASTNode.VARIABLE_DECLARATION_STATEMENT:\n+\t\t\t\t\t\t\t\t\t\t\tcase ASTNode.VARIABLE_DECLARATION_EXPRESSION:\n+\t\t\t\t\t\t\t\t\t\t\t\tfound = element.getElementType() == IJavaElement.TYPE || element.getElementType() == IJavaElement.FIELD || element.getElementType() == IJavaElement.METHOD;\n+\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t\t\t\t\t\tdefault:\n+\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\tif (found) {\n+\t\t\t\t\t\t\t\t\t\t\tnodes[0] = node;\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\treturn found;\n+\t\t\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t\t});\n+\t\t\t\t\t\t\t\tASTNode node = nodes[0];\n+\t\t\t\t\t\t\t\tif (node != null) {\n+\t\t\t\t\t\t\t\t\tString uriString = JDTUtils.toUri(cf);\n+\t\t\t\t\t\t\t\t\tint offset = node.getStartPosition();\n+\t\t\t\t\t\t\t\t\tint length = node.getLength();\n+\t\t\t\t\t\t\t\t\tRange range;\n+\t\t\t\t\t\t\t\t\tif (offset >= 0 && length > 0 && offset + length <= contents.length()) {\n+\t\t\t\t\t\t\t\t\t\tIDocument document = new Document(contents);\n+\t\t\t\t\t\t\t\t\t\tint[] start = JsonRpcHelpers.toLine(document, offset);\n+\t\t\t\t\t\t\t\t\t\tint[] end = JsonRpcHelpers.toLine(document, offset + length);\n+\t\t\t\t\t\t\t\t\t\trange = new Range(new Position(start[0], start[1]), new Position(end[0], end[1]));\n+\t\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\t\trange = new Range();\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\tlocation = new Location(uriString, range);\n+\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\tlocation = JDTUtils.toLocation(cf, 0, 0);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}", "originalCommit": "9ce4d1390f69b4ace660770e8016b020e7c53722", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTc4OTM2Ng==", "url": "https://github.com/eclipse/eclipse.jdt.ls/pull/1632#discussion_r559789366", "bodyText": "Fixed. See f60e209#diff-38af31aa96ae8ee1debae74bf388b43dea8891646b1032ecdb2f4a7ea3e06f8cR1464", "author": "snjeza", "createdAt": "2021-01-18T20:49:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzk0Nzk4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODAxOTA4Ng==", "url": "https://github.com/eclipse/eclipse.jdt.ls/pull/1632#discussion_r558019086", "bodyText": "The search engine is a long running job, it's better to pass the external progress monitor to make it cancellable.\nA typical scenario is hover operation. When you move mouse on the editor, it will trigger multiple hover requests, and the previous unfinished request will be cancelled by client. So you'd better to pass the external monitor to the search engine.", "author": "testforstephen", "createdAt": "2021-01-15T08:21:11Z", "path": "org.eclipse.jdt.ls.core/src/org/eclipse/jdt/ls/core/internal/JDTUtils.java", "diffHunk": "@@ -727,28 +727,17 @@ public static IJavaElement findElementAtSelection(ITypeRoot unit, int line, int\n \t\t\t\ttry {\r\n \t\t\t\t\toffset = document.getLineOffset(line) + column;\r\n \t\t\t\t\tif (offset > -1) {\r\n+\t\t\t\t\t\tif (offset > 0 && !isJavaIdentifierOrPeriod(contents.charAt(offset))) {\r\n+\t\t\t\t\t\t\toffset = offset - 1;\r\n+\t\t\t\t\t\t}\r\n \t\t\t\t\t\tString name = parse(contents, offset);\r\n \t\t\t\t\t\tif (name == null) {\r\n \t\t\t\t\t\t\treturn null;\r\n \t\t\t\t\t\t}\r\n-\t\t\t\t\t\tSearchPattern pattern = SearchPattern.createPattern(name, IJavaSearchConstants.TYPE,\r\n-\t\t\t\t\t\t\t\tIJavaSearchConstants.DECLARATIONS, SearchPattern.R_FULL_MATCH);\r\n-\r\n-\t\t\t\t\t\tIJavaSearchScope scope = createSearchScope(unit.getJavaProject(), preferenceManager);\r\n-\r\n-\t\t\t\t\t\tList<IJavaElement> elements = new ArrayList<>();\r\n-\t\t\t\t\t\tSearchRequestor requestor = new SearchRequestor() {\r\n-\t\t\t\t\t\t\t@Override\r\n-\t\t\t\t\t\t\tpublic void acceptSearchMatch(SearchMatch match) {\r\n-\t\t\t\t\t\t\t\tif (match.getElement() instanceof IJavaElement) {\r\n-\t\t\t\t\t\t\t\t\telements.add((IJavaElement) match.getElement());\r\n-\t\t\t\t\t\t\t\t}\r\n-\t\t\t\t\t\t\t}\r\n-\t\t\t\t\t\t};\r\n-\t\t\t\t\t\tSearchEngine searchEngine = new SearchEngine();\r\n-\t\t\t\t\t\tsearchEngine.search(pattern,\r\n-\t\t\t\t\t\t\t\tnew SearchParticipant[] { SearchEngine.getDefaultSearchParticipant() }, scope,\r\n-\t\t\t\t\t\t\t\trequestor, null);\r\n+\t\t\t\t\t\tList<IJavaElement> elements = search(unit, name, preferenceManager);\r\n+\t\t\t\t\t\tif (elements.isEmpty()) {\r\n+\t\t\t\t\t\t\telements = search(unit.getJavaProject(), name, preferenceManager);\r", "originalCommit": "9ce4d1390f69b4ace660770e8016b020e7c53722", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTc4OTQ1NA==", "url": "https://github.com/eclipse/eclipse.jdt.ls/pull/1632#discussion_r559789454", "bodyText": "Fixed.", "author": "snjeza", "createdAt": "2021-01-18T20:49:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODAxOTA4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODI1MzI5MA==", "url": "https://github.com/eclipse/eclipse.jdt.ls/pull/1632#discussion_r558253290", "bodyText": "Another idea is to add a preference like java.references.includeDecompiledSources to control whether to include the decompiled sources when finding references. The default value can be true. This is similar as java.references.includeAccessors.", "author": "testforstephen", "createdAt": "2021-01-15T11:42:39Z", "path": "org.eclipse.jdt.ls.core/src/org/eclipse/jdt/ls/core/internal/handlers/ReferencesHandler.java", "diffHunk": "@@ -149,6 +161,85 @@ public void acceptSearchMatch(SearchMatch match) throws CoreException {\n \t\t\t\t\t\tif (cf != null && cf.getSourceRange() != null) {\n \t\t\t\t\t\t\tlocation = JDTUtils.toLocation(cf, match.getOffset(), match.getLength());\n \t\t\t\t\t\t}\n+\t\t\t\t\t\tif (cf != null && location == null) {\n+\t\t\t\t\t\t\tContentProviderManager contentProvider = JavaLanguageServerPlugin.getContentProviderManager();\n+\t\t\t\t\t\t\tString contents = contentProvider.getSource(cf, new NullProgressMonitor());", "originalCommit": "9ce4d1390f69b4ace660770e8016b020e7c53722", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTc4OTcxMw==", "url": "https://github.com/eclipse/eclipse.jdt.ls/pull/1632#discussion_r559789713", "bodyText": "Fixed. See redhat-developer/vscode-java#1773", "author": "snjeza", "createdAt": "2021-01-18T20:50:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODI1MzI5MA=="}], "type": "inlineReview"}, {"oid": "f60e209a3590f751cd35dcb643d2f14a4acd4062", "url": "https://github.com/eclipse/eclipse.jdt.ls/commit/f60e209a3590f751cd35dcb643d2f14a4acd4062", "message": "search for references from IClassFile without source\n\nSigned-off-by: Snjezana Peco <snjezana.peco@redhat.com>", "committedDate": "2021-01-18T20:40:26Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTg3MzcwMw==", "url": "https://github.com/eclipse/eclipse.jdt.ls/pull/1632#discussion_r559873703", "bodyText": "i would prefer to remove this check because only one instruction if (offset > -1) has been performed since the last check.", "author": "testforstephen", "createdAt": "2021-01-19T02:18:21Z", "path": "org.eclipse.jdt.ls.core/src/org/eclipse/jdt/ls/core/internal/JDTUtils.java", "diffHunk": "@@ -715,9 +719,15 @@ public static IJavaElement findElementAtSelection(ITypeRoot unit, int line, int\n \t\t\treturn null;\r\n \t\t}\r\n \t\tint offset = JsonRpcHelpers.toOffset(unit.getBuffer(), line, column);\r\n+\t\tif (monitor != null && monitor.isCanceled()) {\r\n+\t\t\treturn null;\r\n+\t\t}\r\n \t\tif (offset > -1) {\r\n \t\t\treturn unit.codeSelect(offset, 0);\r\n \t\t}\r\n+\t\tif (monitor != null && monitor.isCanceled()) {\r\n+\t\t\treturn null;\r\n+\t\t}\r", "originalCommit": "f60e209a3590f751cd35dcb643d2f14a4acd4062", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTIyNDA3Ng==", "url": "https://github.com/eclipse/eclipse.jdt.ls/pull/1632#discussion_r561224076", "bodyText": "Fixed", "author": "snjeza", "createdAt": "2021-01-20T19:32:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTg3MzcwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTg3NDU3OQ==", "url": "https://github.com/eclipse/eclipse.jdt.ls/pull/1632#discussion_r559874579", "bodyText": "I would suggest that there is no need to add a cancellation check inside a loop that runs quickly.", "author": "testforstephen", "createdAt": "2021-01-19T02:21:42Z", "path": "org.eclipse.jdt.ls.core/src/org/eclipse/jdt/ls/core/internal/JDTUtils.java", "diffHunk": "@@ -759,18 +764,57 @@ public void acceptSearchMatch(SearchMatch match) {\n \t\treturn null;\r\n \t}\r\n \r\n-\tprivate static String parse(String contents, int offset) {\r\n+\tprivate static List<IJavaElement> search(IJavaElement element, String name, PreferenceManager preferenceManager, IProgressMonitor monitor) throws CoreException {\r\n+\t\tSearchPattern typePattern = SearchPattern.createPattern(name, IJavaSearchConstants.TYPE, IJavaSearchConstants.DECLARATIONS, SearchPattern.R_FULL_MATCH | SearchPattern.R_CASE_SENSITIVE);\r\n+\t\tSearchPattern fieldPattern = SearchPattern.createPattern(name, IJavaSearchConstants.FIELD, IJavaSearchConstants.DECLARATIONS, SearchPattern.R_FULL_MATCH | SearchPattern.R_CASE_SENSITIVE);\r\n+\t\tSearchPattern methodPattern = SearchPattern.createPattern(name, IJavaSearchConstants.METHOD, IJavaSearchConstants.DECLARATIONS, SearchPattern.R_FULL_MATCH | SearchPattern.R_CASE_SENSITIVE);\r\n+\t\tSearchPattern pattern = SearchPattern.createOrPattern(typePattern, fieldPattern);\r\n+\t\tpattern = SearchPattern.createOrPattern(pattern, methodPattern);\r\n+\t\tIJavaSearchScope scope = createSearchScope(element, preferenceManager);\r\n+\t\tif (monitor != null && monitor.isCanceled()) {\r\n+\t\t\treturn Collections.emptyList();\r\n+\t\t}\r\n+\t\tList<IJavaElement> elements = new ArrayList<>();\r\n+\t\tSearchRequestor requestor = new SearchRequestor() {\r\n+\t\t\t@Override\r\n+\t\t\tpublic void acceptSearchMatch(SearchMatch match) {\r\n+\t\t\t\tif (monitor != null && monitor.isCanceled()) {\r\n+\t\t\t\t\treturn;\r\n+\t\t\t\t}\r\n+\t\t\t\tif (match.getElement() instanceof IJavaElement) {\r\n+\t\t\t\t\telements.add((IJavaElement) match.getElement());\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t};\r\n+\t\tSearchEngine searchEngine = new SearchEngine();\r\n+\t\tsearchEngine.search(pattern, new SearchParticipant[] { SearchEngine.getDefaultSearchParticipant() }, scope, requestor, monitor);\r\n+\t\tif (monitor != null && monitor.isCanceled()) {\r\n+\t\t\treturn Collections.emptyList();\r\n+\t\t}\r\n+\t\treturn elements;\r\n+\t}\r\n+\r\n+\tprivate static String parse(String contents, int offset, IProgressMonitor monitor) {\r\n \t\tif (contents == null || offset < 0 || contents.length() < offset\r\n \t\t\t\t|| !isJavaIdentifierOrPeriod(contents.charAt(offset))) {\r\n \t\t\treturn null;\r\n \t\t}\r\n \t\tint start = offset;\r\n \t\twhile (start - 1 > -1 && isJavaIdentifierOrPeriod(contents.charAt(start - 1))) {\r\n \t\t\tstart--;\r\n+\t\t\tif (monitor != null && monitor.isCanceled()) {\r\n+\t\t\t\treturn null;\r\n+\t\t\t}\r", "originalCommit": "f60e209a3590f751cd35dcb643d2f14a4acd4062", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTg3NDc2Mw==", "url": "https://github.com/eclipse/eclipse.jdt.ls/pull/1632#discussion_r559874763", "bodyText": "Remove the cancellation check as the same reason as above.", "author": "testforstephen", "createdAt": "2021-01-19T02:22:24Z", "path": "org.eclipse.jdt.ls.core/src/org/eclipse/jdt/ls/core/internal/JDTUtils.java", "diffHunk": "@@ -759,18 +764,57 @@ public void acceptSearchMatch(SearchMatch match) {\n \t\treturn null;\r\n \t}\r\n \r\n-\tprivate static String parse(String contents, int offset) {\r\n+\tprivate static List<IJavaElement> search(IJavaElement element, String name, PreferenceManager preferenceManager, IProgressMonitor monitor) throws CoreException {\r\n+\t\tSearchPattern typePattern = SearchPattern.createPattern(name, IJavaSearchConstants.TYPE, IJavaSearchConstants.DECLARATIONS, SearchPattern.R_FULL_MATCH | SearchPattern.R_CASE_SENSITIVE);\r\n+\t\tSearchPattern fieldPattern = SearchPattern.createPattern(name, IJavaSearchConstants.FIELD, IJavaSearchConstants.DECLARATIONS, SearchPattern.R_FULL_MATCH | SearchPattern.R_CASE_SENSITIVE);\r\n+\t\tSearchPattern methodPattern = SearchPattern.createPattern(name, IJavaSearchConstants.METHOD, IJavaSearchConstants.DECLARATIONS, SearchPattern.R_FULL_MATCH | SearchPattern.R_CASE_SENSITIVE);\r\n+\t\tSearchPattern pattern = SearchPattern.createOrPattern(typePattern, fieldPattern);\r\n+\t\tpattern = SearchPattern.createOrPattern(pattern, methodPattern);\r\n+\t\tIJavaSearchScope scope = createSearchScope(element, preferenceManager);\r\n+\t\tif (monitor != null && monitor.isCanceled()) {\r\n+\t\t\treturn Collections.emptyList();\r\n+\t\t}\r\n+\t\tList<IJavaElement> elements = new ArrayList<>();\r\n+\t\tSearchRequestor requestor = new SearchRequestor() {\r\n+\t\t\t@Override\r\n+\t\t\tpublic void acceptSearchMatch(SearchMatch match) {\r\n+\t\t\t\tif (monitor != null && monitor.isCanceled()) {\r\n+\t\t\t\t\treturn;\r\n+\t\t\t\t}\r\n+\t\t\t\tif (match.getElement() instanceof IJavaElement) {\r\n+\t\t\t\t\telements.add((IJavaElement) match.getElement());\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t};\r\n+\t\tSearchEngine searchEngine = new SearchEngine();\r\n+\t\tsearchEngine.search(pattern, new SearchParticipant[] { SearchEngine.getDefaultSearchParticipant() }, scope, requestor, monitor);\r\n+\t\tif (monitor != null && monitor.isCanceled()) {\r\n+\t\t\treturn Collections.emptyList();\r\n+\t\t}\r\n+\t\treturn elements;\r\n+\t}\r\n+\r\n+\tprivate static String parse(String contents, int offset, IProgressMonitor monitor) {\r\n \t\tif (contents == null || offset < 0 || contents.length() < offset\r\n \t\t\t\t|| !isJavaIdentifierOrPeriod(contents.charAt(offset))) {\r\n \t\t\treturn null;\r\n \t\t}\r\n \t\tint start = offset;\r\n \t\twhile (start - 1 > -1 && isJavaIdentifierOrPeriod(contents.charAt(start - 1))) {\r\n \t\t\tstart--;\r\n+\t\t\tif (monitor != null && monitor.isCanceled()) {\r\n+\t\t\t\treturn null;\r\n+\t\t\t}\r\n \t\t}\r\n \t\tint end = offset;\r\n \t\twhile (end <= contents.length() && isJavaIdentifierOrPeriod(contents.charAt(end))) {\r\n \t\t\tend++;\r\n+\t\t\tif (monitor != null && monitor.isCanceled()) {\r\n+\t\t\t\treturn null;\r\n+\t\t\t}\r", "originalCommit": "f60e209a3590f751cd35dcb643d2f14a4acd4062", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTIyNDIwNQ==", "url": "https://github.com/eclipse/eclipse.jdt.ls/pull/1632#discussion_r561224205", "bodyText": "Fixed", "author": "snjeza", "createdAt": "2021-01-20T19:32:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTg3NDc2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTg4OTY5OQ==", "url": "https://github.com/eclipse/eclipse.jdt.ls/pull/1632#discussion_r559889699", "bodyText": "The search based approach is just using the element name to match the result, that is not accurate in some cases. Also it cannot find local variable.\nFor example, the sample code below is the decompiled source for Gson class, which contains two overload methods toGson. If i select the second method toGson and call findElementAtSelection, it will return me with the first toGson method, that's not accurate.\npublic final class Gson {\n   ...\n   public String toJson(Object src) {\n      return src == null ? this.toJson((JsonElement)JsonNull.INSTANCE) : this.toJson((Object)src, (Type)src.getClass());\n   }\n\n   public String toJson(Object src, Type typeOfSrc) {\n      StringWriter writer = new StringWriter();\n      this.toJson(src, typeOfSrc, (Appendable)writer);\n      return writer.toString();\n   }\n}\n\nI'm thinking whether to have a better approach to resolve the selected element.", "author": "testforstephen", "createdAt": "2021-01-19T03:19:45Z", "path": "org.eclipse.jdt.ls.core/src/org/eclipse/jdt/ls/core/internal/JDTUtils.java", "diffHunk": "@@ -727,28 +737,23 @@ public static IJavaElement findElementAtSelection(ITypeRoot unit, int line, int\n \t\t\t\ttry {\r\n \t\t\t\t\toffset = document.getLineOffset(line) + column;\r\n \t\t\t\t\tif (offset > -1) {\r\n-\t\t\t\t\t\tString name = parse(contents, offset);\r\n+\t\t\t\t\t\tif (offset > 0 && !isJavaIdentifierOrPeriod(contents.charAt(offset))) {\r\n+\t\t\t\t\t\t\toffset = offset - 1;\r\n+\t\t\t\t\t\t}\r\n+\t\t\t\t\t\tif (monitor != null && monitor.isCanceled()) {\r\n+\t\t\t\t\t\t\treturn null;\r\n+\t\t\t\t\t\t}\r\n+\t\t\t\t\t\tString name = parse(contents, offset, monitor);\r\n \t\t\t\t\t\tif (name == null) {\r\n \t\t\t\t\t\t\treturn null;\r\n \t\t\t\t\t\t}\r\n-\t\t\t\t\t\tSearchPattern pattern = SearchPattern.createPattern(name, IJavaSearchConstants.TYPE,\r\n-\t\t\t\t\t\t\t\tIJavaSearchConstants.DECLARATIONS, SearchPattern.R_FULL_MATCH);\r\n-\r\n-\t\t\t\t\t\tIJavaSearchScope scope = createSearchScope(unit.getJavaProject(), preferenceManager);\r\n-\r\n-\t\t\t\t\t\tList<IJavaElement> elements = new ArrayList<>();\r\n-\t\t\t\t\t\tSearchRequestor requestor = new SearchRequestor() {\r\n-\t\t\t\t\t\t\t@Override\r\n-\t\t\t\t\t\t\tpublic void acceptSearchMatch(SearchMatch match) {\r\n-\t\t\t\t\t\t\t\tif (match.getElement() instanceof IJavaElement) {\r\n-\t\t\t\t\t\t\t\t\telements.add((IJavaElement) match.getElement());\r\n-\t\t\t\t\t\t\t\t}\r\n-\t\t\t\t\t\t\t}\r\n-\t\t\t\t\t\t};\r\n-\t\t\t\t\t\tSearchEngine searchEngine = new SearchEngine();\r\n-\t\t\t\t\t\tsearchEngine.search(pattern,\r\n-\t\t\t\t\t\t\t\tnew SearchParticipant[] { SearchEngine.getDefaultSearchParticipant() }, scope,\r\n-\t\t\t\t\t\t\t\trequestor, null);\r\n+\t\t\t\t\t\tif (monitor != null && monitor.isCanceled()) {\r\n+\t\t\t\t\t\t\treturn null;\r\n+\t\t\t\t\t\t}\r\n+\t\t\t\t\t\tList<IJavaElement> elements = search(unit, name, preferenceManager, monitor);\r", "originalCommit": "f60e209a3590f751cd35dcb643d2f14a4acd4062", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTIyNDM1Mg==", "url": "https://github.com/eclipse/eclipse.jdt.ls/pull/1632#discussion_r561224352", "bodyText": "Fixed.", "author": "snjeza", "createdAt": "2021-01-20T19:33:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTg4OTY5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDI5MDE1NQ==", "url": "https://github.com/eclipse/eclipse.jdt.ls/pull/1632#discussion_r564290155", "bodyText": "i don't think my comment was addressed.\nIn the current findElementAtSelection, you use search engine with the patterns like type/field/method declarations to search for the selected name, which is very limited and only covers a small part of use cases.\nSee the sample below:\n\nif the cursor stops at a type name StringWriter of Line 291, findElementAtSelection returns the correct element java.io.StringWriter.\nif the cursor stops at a method name toJson of Line 290, findElementAtSelection returns the element toJson at Line 286, which is not the right element.\nif the cursor stops at a local variable writer of Line 291, nothing returns.\n\n\nIf you take a look at the codeSelect() implementation of CU and ClassFile, they're leveraging SelectionEngine for that. SelectionEngine uses resolveBinding to find the binding element at the selection range, which is more accurate. Maybe we can also try to reuse SelectionEngine for decompiled source.", "author": "testforstephen", "createdAt": "2021-01-26T07:11:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTg4OTY5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDkzNTUzNQ==", "url": "https://github.com/eclipse/eclipse.jdt.ls/pull/1632#discussion_r564935535", "bodyText": "Do you have an example artifact that produces this amount of information when decompiled ? The most I can get even when compiling gson from sources is the method signature information, but no local statements info.", "author": "rgrunber", "createdAt": "2021-01-27T00:36:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTg4OTY5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDk2Nzk3Mw==", "url": "https://github.com/eclipse/eclipse.jdt.ls/pull/1632#discussion_r564967973", "bodyText": "@rgrunber You can try https://marketplace.visualstudio.com/items?itemName=dgileadi.java-decompiler", "author": "snjeza", "createdAt": "2021-01-27T01:51:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTg4OTY5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDk4MDkzNQ==", "url": "https://github.com/eclipse/eclipse.jdt.ls/pull/1632#discussion_r564980935", "bodyText": "Yes, install the decompiler extension and open this sample project eclipse-sample.zip", "author": "testforstephen", "createdAt": "2021-01-27T02:29:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTg4OTY5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjQzMDE2Mw==", "url": "https://github.com/eclipse/eclipse.jdt.ls/pull/1632#discussion_r566430163", "bodyText": "i don't think my comment was addressed.\n\n@testforstephen could you, please, check it again?", "author": "snjeza", "createdAt": "2021-01-28T21:49:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTg4OTY5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjQ2NTU2Mg==", "url": "https://github.com/eclipse/eclipse.jdt.ls/pull/1632#discussion_r566465562", "bodyText": "I\"m assuming you're calling \"Go to Definition\" on the tokens and checking the result of JDTUtils.findElementAtSelection(..) called from NavigateToDefinitionHandler.computeDefinitionNavigation(..) ?\n\nFor the type name, StringWriter on 291, it seems to be returning java.io.StringWriter and even jumps to the class (If I have the JRE sources installed, I've seen it fail, or even go to the wrong class)\nFor toJson on 290, it returns the method with the correct parameters\nFor writer on 291, I see many writer members (field/methods) from various classes that match, which doesn't seem right.", "author": "rgrunber", "createdAt": "2021-01-28T22:59:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTg4OTY5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjQ3MTU2NQ==", "url": "https://github.com/eclipse/eclipse.jdt.ls/pull/1632#discussion_r566471565", "bodyText": "I\"m assuming you're calling \"Go to Definition\" on the tokens and checking the result of JDTUtils.findElementAtSelection(..) called from NavigateToDefinitionHandler.computeDefinitionNavigation(..) ?\nFor the type name, StringWriter on 291, it seems to be returning java.io.StringWriter and even jumps to the class (If I have the JRE sources installed, I've seen it fail, or even go to the wrong class)\n\n@rgrunber I will fix  \"Go To Definition\" within #1634 when you merge this PR.\n\nFor writer on 291, I see many writer members (field/methods) from various classes that match, which doesn't seem right.\n\n@rgrunber  Could you, please, check again?", "author": "snjeza", "createdAt": "2021-01-28T23:13:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTg4OTY5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTA4ODgxNQ==", "url": "https://github.com/eclipse/eclipse.jdt.ls/pull/1632#discussion_r569088815", "bodyText": "I think the issue with too many unrelated members with the same name being returned should be fixed now.\nOne other case I seem to have found :\nI place the cursor somewhere on toJson of gson.toJson(gson) and select Find All References. One result is the selection itself, but the other is the full range of :\npublic String toJson(Object src) {\n  return src == null ? this.toJson((JsonElement)JsonNull.INSTANCE) : this.toJson((Object)src, (Type)src.getClass());\n}\n\nThe match being found in the search engine (ReferencesHandler#search(..)) is the java element\njava.lang.String toJson(java.lang.Object) {key=Lcom/google/gson/Gson;.toJson(Ljava/lang/Object;)Ljava/lang/String;} [in Gson [in Gson.class [in com.google.gson [in lib/gson-2.8.6.jar [in eclipse_sample]]]]]", "author": "rgrunber", "createdAt": "2021-02-03T02:31:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTg4OTY5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTcyNzc5Ng==", "url": "https://github.com/eclipse/eclipse.jdt.ls/pull/1632#discussion_r569727796", "bodyText": "Eclipse JDT doesn't search any decompiled source. We can find the public declarations in a class file, but can't find a reference in a method body.\nThe patch finds the locations of an element in a decompiled source and an element at some location in a class file.\nWe should attach the whole decompiled source to its library if we want to find such references. I can try to add such a feature, but decompiling the whole library could take some time.\nCould, you, please, test it again?", "author": "snjeza", "createdAt": "2021-02-03T20:31:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTg4OTY5OQ=="}], "type": "inlineReview"}, {"oid": "2c977c286312394a407c5e442a42030158cb08cc", "url": "https://github.com/eclipse/eclipse.jdt.ls/commit/2c977c286312394a407c5e442a42030158cb08cc", "message": "search for references from IClassFile without source\n\nSigned-off-by: Snjezana Peco <snjezana.peco@redhat.com>", "committedDate": "2021-01-20T19:31:24Z", "type": "forcePushed"}, {"oid": "894cb03a4093913e0149e90d4342703e2701c96c", "url": "https://github.com/eclipse/eclipse.jdt.ls/commit/894cb03a4093913e0149e90d4342703e2701c96c", "message": "search for references from IClassFile without source\n\nSigned-off-by: Snjezana Peco <snjezana.peco@redhat.com>", "committedDate": "2021-01-28T19:24:26Z", "type": "forcePushed"}, {"oid": "ab42a9cf1bb73fbdd2f54752102cfa7858d0798a", "url": "https://github.com/eclipse/eclipse.jdt.ls/commit/ab42a9cf1bb73fbdd2f54752102cfa7858d0798a", "message": "search for references from IClassFile without source\n\nSigned-off-by: Snjezana Peco <snjezana.peco@redhat.com>", "committedDate": "2021-02-01T17:55:46Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTE4OTQ1MQ==", "url": "https://github.com/eclipse/eclipse.jdt.ls/pull/1632#discussion_r569189451", "bodyText": "Why not to use ITypeRoot.getWorkingCopy() method directly? What's the difference between this one and ITypeRoot.getWorkingCopy()?", "author": "testforstephen", "createdAt": "2021-02-03T07:39:27Z", "path": "org.eclipse.jdt.ls.core/src/org/eclipse/jdt/ls/core/internal/JDTUtils.java", "diffHunk": "@@ -1403,4 +1713,83 @@ public static IMethod resolveMethod(CompletionProposal proposal, IJavaProject ja\n \t\treturn null;\r\n \t}\r\n \r\n+\tpublic static Location searchDecompiledSources(IJavaElement element, IClassFile classFile, boolean ignoreMethodBody, IProgressMonitor monitor) throws JavaModelException {\r\n+\t\tContentProviderManager contentProvider = JavaLanguageServerPlugin.getContentProviderManager();\r\n+\t\tString contents = contentProvider.getSource(classFile, new NullProgressMonitor());\r\n+\t\tLocation location = null;\r\n+\t\tif (monitor != null && monitor.isCanceled()) {\r\n+\t\t\treturn location;\r\n+\t\t}\r\n+\t\tif (contents != null) {\r\n+\t\t\tICompilationUnit workingCopy = null;\r\n+\t\t\tworkingCopy = getWorkingCopy(classFile, contents, monitor);\r\n+\t\t\ttry {\r\n+\t\t\t\tfinal ASTParser parser = ASTParser.newParser(IASTSharedValues.SHARED_AST_LEVEL);\r\n+\t\t\t\tparser.setResolveBindings(true);\r\n+\t\t\t\tparser.setKind(ASTParser.K_COMPILATION_UNIT);\r\n+\t\t\t\tparser.setStatementsRecovery(false);\r\n+\t\t\t\tparser.setBindingsRecovery(false);\r\n+\t\t\t\tparser.setSource(workingCopy);\r\n+\t\t\t\tparser.setIgnoreMethodBodies(ignoreMethodBody);\r\n+\t\t\t\tCompilationUnit unit = (CompilationUnit) parser.createAST(monitor);\r\n+\t\t\t\tfinal ASTNode[] nodes = new ASTNode[1];\r\n+\t\t\t\tif (monitor != null && monitor.isCanceled()) {\r\n+\t\t\t\t\treturn location;\r\n+\t\t\t\t}\r\n+\t\t\t\tunit.accept(new ClassFileVisitor(element, nodes, monitor));\r\n+\t\t\t\tASTNode node = nodes[0];\r\n+\t\t\t\tif (monitor != null && monitor.isCanceled()) {\r\n+\t\t\t\t\treturn location;\r\n+\t\t\t\t}\r\n+\t\t\t\tif (node != null) {\r\n+\t\t\t\t\tString uriString = JDTUtils.toUri(classFile);\r\n+\t\t\t\t\tint offset = node.getStartPosition();\r\n+\t\t\t\t\tint length = node.getLength();\r\n+\t\t\t\t\tRange range;\r\n+\t\t\t\t\tif (offset >= 0 && length > 0 && offset + length <= contents.length()) {\r\n+\t\t\t\t\t\tIDocument document = new Document(contents);\r\n+\t\t\t\t\t\tint[] start = JsonRpcHelpers.toLine(document, offset);\r\n+\t\t\t\t\t\tint[] end = JsonRpcHelpers.toLine(document, offset + length);\r\n+\t\t\t\t\t\trange = new Range(new Position(start[0], start[1]), new Position(end[0], end[1]));\r\n+\t\t\t\t\t} else {\r\n+\t\t\t\t\t\trange = new Range();\r\n+\t\t\t\t\t}\r\n+\t\t\t\t\tlocation = new Location(uriString, range);\r\n+\t\t\t\t} else {\r\n+\t\t\t\t\tlocation = JDTUtils.toLocation(classFile, 0, 0);\r\n+\t\t\t\t}\r\n+\t\t\t} finally {\r\n+\t\t\t\tif (workingCopy != null) {\r\n+\t\t\t\t\tworkingCopy.discardWorkingCopy();\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t}\r\n+\t\treturn location;\r\n+\t}\r\n+\r\n+\tpublic static ICompilationUnit getWorkingCopy(IClassFile classFile, String contents, IProgressMonitor monitor) throws JavaModelException {\r", "originalCommit": "ab42a9cf1bb73fbdd2f54752102cfa7858d0798a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTcyOTAyMQ==", "url": "https://github.com/eclipse/eclipse.jdt.ls/pull/1632#discussion_r569729021", "bodyText": "We associate a decompiled source with a class file and configure a ICompilationUnit.", "author": "snjeza", "createdAt": "2021-02-03T20:33:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTE4OTQ1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTg5MzcxNA==", "url": "https://github.com/eclipse/eclipse.jdt.ls/pull/1632#discussion_r569893714", "bodyText": "But in your new findElementAtSelection() method, you're using ClassFile.getWorkingCopy() to attach a decompile source, it looks more concise to me.\nICompilationUnit workingCopy = classFile.getWorkingCopy(new WorkingCopyOwner() { }, monitor);\nworkingCopy.getBuffer().setContents(contents);\nworkingCopy.becomeWorkingCopy(monitor);\nworkingCopy.makeConsistent(monitor);", "author": "testforstephen", "createdAt": "2021-02-04T02:14:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTE4OTQ1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTQ2OTc2OQ==", "url": "https://github.com/eclipse/eclipse.jdt.ls/pull/1632#discussion_r571469769", "bodyText": "Fixed.", "author": "snjeza", "createdAt": "2021-02-06T18:39:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTE4OTQ1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTE5NTgyNg==", "url": "https://github.com/eclipse/eclipse.jdt.ls/pull/1632#discussion_r569195826", "bodyText": "i would add check to bypass those class file with source jar attached to avoid creating workingCopy for them.", "author": "testforstephen", "createdAt": "2021-02-03T07:51:56Z", "path": "org.eclipse.jdt.ls.core/src/org/eclipse/jdt/ls/core/internal/HoverInfoProvider.java", "diffHunk": "@@ -90,11 +91,22 @@ public HoverInfoProvider(ITypeRoot aUnit, PreferenceManager preferenceManager) {\n \n \tpublic List<Either<String, MarkedString>> computeHover(int line, int column, IProgressMonitor monitor) {\n \t\tList<Either<String, MarkedString>> res = new LinkedList<>();\n+\t\tICompilationUnit workingCopy = null;\n \t\ttry {\n \t\t\tif (monitor.isCanceled()) {\n \t\t\t\treturn cancelled(res);\n \t\t\t}\n-\t\t\tIJavaElement[] elements = JDTUtils.findElementsAtSelection(unit, line, column, this.preferenceManager, monitor);\n+\t\t\tITypeRoot typeRoot = unit;\n+\t\t\tif (unit instanceof IClassFile && preferenceManager.getPreferences().isIncludeDecompiledSources()) {", "originalCommit": "ab42a9cf1bb73fbdd2f54752102cfa7858d0798a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTczNDI3MQ==", "url": "https://github.com/eclipse/eclipse.jdt.ls/pull/1632#discussion_r569734271", "bodyText": "Fixed.", "author": "snjeza", "createdAt": "2021-02-03T20:42:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTE5NTgyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTIyMDk4OA==", "url": "https://github.com/eclipse/eclipse.jdt.ls/pull/1632#discussion_r569220988", "bodyText": "The codeSelect above already returns a JavaElement, it it possible to make other places to use this result directly? I didn't get the point to use search engine to search the element again.", "author": "testforstephen", "createdAt": "2021-02-03T08:34:55Z", "path": "org.eclipse.jdt.ls.core/src/org/eclipse/jdt/ls/core/internal/JDTUtils.java", "diffHunk": "@@ -715,46 +887,170 @@ public static IJavaElement findElementAtSelection(ITypeRoot unit, int line, int\n \t\t\treturn null;\r\n \t\t}\r\n \t\tint offset = JsonRpcHelpers.toOffset(unit.getBuffer(), line, column);\r\n+\t\tif (monitor != null && monitor.isCanceled()) {\r\n+\t\t\treturn null;\r\n+\t\t}\r\n \t\tif (offset > -1) {\r\n \t\t\treturn unit.codeSelect(offset, 0);\r\n \t\t}\r\n \t\tif (unit instanceof IClassFile) {\r\n \t\t\tIClassFile classFile = (IClassFile) unit;\r\n \t\t\tContentProviderManager contentProvider = JavaLanguageServerPlugin.getContentProviderManager();\r\n \t\t\tString contents = contentProvider.getSource(classFile, monitor);\r\n-\t\t\tif (contents != null) {\r\n+\t\t\tif (contents != null && !contents.isBlank()) {\r\n \t\t\t\tIDocument document = new Document(contents);\r\n+\t\t\t\tICompilationUnit workingCopy = null;\r\n \t\t\t\ttry {\r\n \t\t\t\t\toffset = document.getLineOffset(line) + column;\r\n \t\t\t\t\tif (offset > -1) {\r\n-\t\t\t\t\t\tString name = parse(contents, offset);\r\n-\t\t\t\t\t\tif (name == null) {\r\n+\t\t\t\t\t\tif (offset > 0 && !isJavaIdentifierOrPeriod(contents.charAt(offset))) {\r\n+\t\t\t\t\t\t\toffset = offset - 1;\r\n+\t\t\t\t\t\t}\r\n+\t\t\t\t\t\tif (monitor != null && monitor.isCanceled()) {\r\n+\t\t\t\t\t\t\treturn null;\r\n+\t\t\t\t\t\t}\r\n+\t\t\t\t\t\tIRegion region = parseRegion(contents, offset);\r\n+\t\t\t\t\t\tif (region == null) {\r\n \t\t\t\t\t\t\treturn null;\r\n \t\t\t\t\t\t}\r\n-\t\t\t\t\t\tSearchPattern pattern = SearchPattern.createPattern(name, IJavaSearchConstants.TYPE,\r\n-\t\t\t\t\t\t\t\tIJavaSearchConstants.DECLARATIONS, SearchPattern.R_FULL_MATCH);\r\n-\r\n-\t\t\t\t\t\tIJavaSearchScope scope = createSearchScope(unit.getJavaProject(), preferenceManager);\r\n-\r\n-\t\t\t\t\t\tList<IJavaElement> elements = new ArrayList<>();\r\n-\t\t\t\t\t\tSearchRequestor requestor = new SearchRequestor() {\r\n-\t\t\t\t\t\t\t@Override\r\n-\t\t\t\t\t\t\tpublic void acceptSearchMatch(SearchMatch match) {\r\n-\t\t\t\t\t\t\t\tif (match.getElement() instanceof IJavaElement) {\r\n-\t\t\t\t\t\t\t\t\telements.add((IJavaElement) match.getElement());\r\n-\t\t\t\t\t\t\t\t}\r\n+\t\t\t\t\t\tif (monitor != null && monitor.isCanceled()) {\r\n+\t\t\t\t\t\t\treturn null;\r\n+\t\t\t\t\t\t}\r\n+\t\t\t\t\t\tworkingCopy = unit.getWorkingCopy(new WorkingCopyOwner() {\r\n+\t\t\t\t\t\t}, monitor);\r\n+\t\t\t\t\t\tworkingCopy.getBuffer().setContents(contents);\r\n+\t\t\t\t\t\tworkingCopy.becomeWorkingCopy(monitor);\r\n+\t\t\t\t\t\tworkingCopy.makeConsistent(monitor);\r\n+\t\t\t\t\t\tIJavaElement[] sourceElements = workingCopy.codeSelect(region.getOffset(), region.getLength());\r\n+\t\t\t\t\t\tif (sourceElements == null || sourceElements.length == 0) {\r\n+\t\t\t\t\t\t\treturn null;\r\n+\t\t\t\t\t\t}\r\n+\t\t\t\t\t\tIJavaElement element;\r\n+\t\t\t\t\t\tif (sourceElements.length != 1) {\r\n+\t\t\t\t\t\t\t// they could be package fragments.\r\n+\t\t\t\t\t\t\t// We need to select the one that matches the package fragment of the current unit\r\n+\t\t\t\t\t\t\tIPackageFragment packageFragment = (IPackageFragment) unit.getParent();\r\n+\t\t\t\t\t\t\tIJavaElement found = Stream.of(sourceElements).filter(e -> e.equals(packageFragment)).findFirst().orElse(null);\r\n+\t\t\t\t\t\t\tif (found == null) {\r\n+\t\t\t\t\t\t\t\t// this would be a binary package fragment\r\n+\t\t\t\t\t\t\t\telement = sourceElements[0];\r\n+\t\t\t\t\t\t\t} else {\r\n+\t\t\t\t\t\t\t\telement = found;\r\n \t\t\t\t\t\t\t}\r\n-\t\t\t\t\t\t};\r\n-\t\t\t\t\t\tSearchEngine searchEngine = new SearchEngine();\r\n-\t\t\t\t\t\tsearchEngine.search(pattern,\r\n-\t\t\t\t\t\t\t\tnew SearchParticipant[] { SearchEngine.getDefaultSearchParticipant() }, scope,\r\n-\t\t\t\t\t\t\t\trequestor, null);\r\n+\t\t\t\t\t\t} else {\r\n+\t\t\t\t\t\t\telement = sourceElements[0];\r\n+\t\t\t\t\t\t}\r\n+\t\t\t\t\t\tString name = contents.substring(region.getOffset(), region.getOffset() + region.getLength());\r\n+\t\t\t\t\t\tList<IJavaElement> elements = search(unit, name, element, preferenceManager, monitor);\r\n+\t\t\t\t\t\tif (monitor != null && monitor.isCanceled()) {\r\n+\t\t\t\t\t\t\treturn null;\r\n+\t\t\t\t\t\t}\r\n+\t\t\t\t\t\tif (elements.isEmpty()) {\r\n+\t\t\t\t\t\t\telements = search(unit.getJavaProject(), name, element, preferenceManager, monitor);\r\n+\t\t\t\t\t\t}\r", "originalCommit": "ab42a9cf1bb73fbdd2f54752102cfa7858d0798a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTczMDg3OQ==", "url": "https://github.com/eclipse/eclipse.jdt.ls/pull/1632#discussion_r569730879", "bodyText": "The codeselect finds a java element in a ICompilationUnit we have created using JDTUtils.getWorkingCopy(). We can't return a java element from ICompilationUnit which is created temporarily and destroyed. We have to search a class file.", "author": "snjeza", "createdAt": "2021-02-03T20:37:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTIyMDk4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTg5NjExOQ==", "url": "https://github.com/eclipse/eclipse.jdt.ls/pull/1632#discussion_r569896119", "bodyText": "We can't return a java element from ICompilationUnit which is created temporarily and destroyed.\n\nIf this is the only concern, then you can have the outermost caller to create the workingcopy, and destroy the workingcopy until the LSP response returns.\nWe need to search three times to find the currently selected element, which seems a bit too complicated.", "author": "testforstephen", "createdAt": "2021-02-04T02:22:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTIyMDk4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTI0MTI4MA==", "url": "https://github.com/eclipse/eclipse.jdt.ls/pull/1632#discussion_r571241280", "bodyText": "I have updated the PR. Could, you, please, review it.", "author": "snjeza", "createdAt": "2021-02-05T20:47:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTIyMDk4OA=="}], "type": "inlineReview"}, {"oid": "85be40f94d6b27b737c52f42cb3047d7404409c7", "url": "https://github.com/eclipse/eclipse.jdt.ls/commit/85be40f94d6b27b737c52f42cb3047d7404409c7", "message": "search for references from IClassFile without source\n\nSigned-off-by: Snjezana Peco <snjezana.peco@redhat.com>", "committedDate": "2021-02-03T20:42:08Z", "type": "forcePushed"}, {"oid": "34aa411285f465eb08c2c5f95647323d19e3fa1f", "url": "https://github.com/eclipse/eclipse.jdt.ls/commit/34aa411285f465eb08c2c5f95647323d19e3fa1f", "message": "search for references from IClassFile without source\n\nSigned-off-by: Snjezana Peco <snjezana.peco@redhat.com>", "committedDate": "2021-02-05T20:27:40Z", "type": "forcePushed"}, {"oid": "a7ba70d9bddbf1f4bd50ba6d245eea0639da5c38", "url": "https://github.com/eclipse/eclipse.jdt.ls/commit/a7ba70d9bddbf1f4bd50ba6d245eea0639da5c38", "message": "search for references from IClassFile without source\n\nSigned-off-by: Snjezana Peco <snjezana.peco@redhat.com>", "committedDate": "2021-02-06T18:33:36Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTU3MjE1OA==", "url": "https://github.com/eclipse/eclipse.jdt.ls/pull/1632#discussion_r571572158", "bodyText": "monitor2 -> monitor", "author": "testforstephen", "createdAt": "2021-02-07T07:34:04Z", "path": "org.eclipse.jdt.ls.core/src/org/eclipse/jdt/ls/core/internal/JDTUtils.java", "diffHunk": "@@ -394,16 +402,207 @@ public static IClassFile resolveClassFile(URI uri){\n \t * @return either a class file or compilation unit\r\n \t */\r\n \tpublic static ITypeRoot resolveTypeRoot(String uriString) {\r\n+\t\treturn resolveTypeRoot(uriString, false, null);\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Convenience method that combines {@link #resolveClassFile(String)} and\r\n+\t * {@link #resolveCompilationUnit(String)}.\r\n+\t *\r\n+\t * @param uri\r\n+\t * @param returnCompilationUnit\r\n+\t * @param monitor2\r", "originalCommit": "a7ba70d9bddbf1f4bd50ba6d245eea0639da5c38", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTY2ODgyMg==", "url": "https://github.com/eclipse/eclipse.jdt.ls/pull/1632#discussion_r571668822", "bodyText": "Fixed.", "author": "snjeza", "createdAt": "2021-02-07T19:02:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTU3MjE1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTU3Mjg1NA==", "url": "https://github.com/eclipse/eclipse.jdt.ls/pull/1632#discussion_r571572854", "bodyText": "how about naming it as discardClassFileWorkingCopy?", "author": "testforstephen", "createdAt": "2021-02-07T07:40:06Z", "path": "org.eclipse.jdt.ls.core/src/org/eclipse/jdt/ls/core/internal/JDTUtils.java", "diffHunk": "@@ -394,16 +402,207 @@ public static IClassFile resolveClassFile(URI uri){\n \t * @return either a class file or compilation unit\r\n \t */\r\n \tpublic static ITypeRoot resolveTypeRoot(String uriString) {\r\n+\t\treturn resolveTypeRoot(uriString, false, null);\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Convenience method that combines {@link #resolveClassFile(String)} and\r\n+\t * {@link #resolveCompilationUnit(String)}.\r\n+\t *\r\n+\t * @param uri\r\n+\t * @param returnCompilationUnit\r\n+\t * @param monitor2\r\n+\t * @return either a class file or compilation unit\r\n+\t */\r\n+\tpublic static ITypeRoot resolveTypeRoot(String uriString, boolean returnCompilationUnit, IProgressMonitor monitor) {\r\n \t\tURI uri = toURI(uriString);\r\n \t\tif (uri == null) {\r\n \t\t\treturn null;\r\n \t\t}\r\n \t\tif (JDT_SCHEME.equals(uri.getScheme())) {\r\n-\t\t\treturn resolveClassFile(uri);\r\n+\t\t\tIClassFile classFile = resolveClassFile(uri);\r\n+\t\t\ttry {\r\n+\t\t\t\tif (returnCompilationUnit && classFile != null && classFile.getSourceRange() == null) {\r\n+\t\t\t\t\tContentProviderManager contentProvider = JavaLanguageServerPlugin.getContentProviderManager();\r\n+\t\t\t\t\tString contents = contentProvider.getSource(classFile, new NullProgressMonitor());\r\n+\t\t\t\t\tif (contents != null && !contents.isBlank()) {\r\n+\t\t\t\t\t\treturn getWorkingCopy(classFile, contents, monitor);\r\n+\t\t\t\t\t}\r\n+\t\t\t\t}\r\n+\t\t\t} catch (JavaModelException e) {\r\n+\t\t\t\tJavaLanguageServerPlugin.logException(e.getMessage(), e);\r\n+\t\t\t}\r\n+\t\t\treturn classFile;\r\n \t\t}\r\n \t\treturn resolveCompilationUnit(uri);\r\n \t}\r\n \r\n+\tpublic static void discardWorkingCopy(ITypeRoot unit) {\r", "originalCommit": "a7ba70d9bddbf1f4bd50ba6d245eea0639da5c38", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTY2ODg0MQ==", "url": "https://github.com/eclipse/eclipse.jdt.ls/pull/1632#discussion_r571668841", "bodyText": "Fixed.", "author": "snjeza", "createdAt": "2021-02-07T19:03:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTU3Mjg1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTU3MzQ0OQ==", "url": "https://github.com/eclipse/eclipse.jdt.ls/pull/1632#discussion_r571573449", "bodyText": "I just searched the code and this new helper method is unused. You can remove it.", "author": "testforstephen", "createdAt": "2021-02-07T07:45:54Z", "path": "org.eclipse.jdt.ls.core/src/org/eclipse/jdt/ls/core/internal/JDTUtils.java", "diffHunk": "@@ -937,6 +1100,20 @@ public static IJavaSearchScope createSearchScope(IJavaProject project, Preferenc\n \t\treturn SearchEngine.createJavaSearchScope(elements, scope);\r\n \t}\r\n \r\n+\tpublic static IJavaSearchScope createSearchScope(IJavaElement element, PreferenceManager preferenceManager) {\r", "originalCommit": "a7ba70d9bddbf1f4bd50ba6d245eea0639da5c38", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTY2ODg4OQ==", "url": "https://github.com/eclipse/eclipse.jdt.ls/pull/1632#discussion_r571668889", "bodyText": "I have removed it.", "author": "snjeza", "createdAt": "2021-02-07T19:03:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTU3MzQ0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTU3Mzk4MQ==", "url": "https://github.com/eclipse/eclipse.jdt.ls/pull/1632#discussion_r571573981", "bodyText": "merge them to one line.\nICompilationUnit workingCopy = getWorkingCopy(classFile, contents, monitor);", "author": "testforstephen", "createdAt": "2021-02-07T07:50:05Z", "path": "org.eclipse.jdt.ls.core/src/org/eclipse/jdt/ls/core/internal/JDTUtils.java", "diffHunk": "@@ -1403,4 +1580,123 @@ public static IMethod resolveMethod(CompletionProposal proposal, IJavaProject ja\n \t\treturn null;\r\n \t}\r\n \r\n+\tpublic static List<Location> searchDecompiledSources(IJavaElement element, IClassFile classFile, boolean ignoreMethodBody, boolean declaration, IProgressMonitor monitor) throws JavaModelException {\r\n+\t\tPreferenceManager preferencesManager = JavaLanguageServerPlugin.getPreferencesManager();\r\n+\t\tif (preferencesManager == null || !preferencesManager.isClientSupportsClassFileContent() || !preferencesManager.getPreferences().isIncludeDecompiledSources()) {\r\n+\t\t\treturn Collections.emptyList();\r\n+\t\t}\r\n+\t\tContentProviderManager contentProvider = JavaLanguageServerPlugin.getContentProviderManager();\r\n+\t\tString contents = contentProvider.getSource(classFile, new NullProgressMonitor());\r\n+\t\tif (monitor != null && monitor.isCanceled()) {\r\n+\t\t\treturn Collections.emptyList();\r\n+\t\t}\r\n+\t\tList<Location> locations = new ArrayList<>();\r\n+\t\tif (contents != null && !contents.isBlank()) {\r\n+\t\t\tICompilationUnit workingCopy = null;\r\n+\t\t\tworkingCopy = getWorkingCopy(classFile, contents, monitor);\r", "originalCommit": "a7ba70d9bddbf1f4bd50ba6d245eea0639da5c38", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTY2ODkzMw==", "url": "https://github.com/eclipse/eclipse.jdt.ls/pull/1632#discussion_r571668933", "bodyText": "Fixed.", "author": "snjeza", "createdAt": "2021-02-07T19:03:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTU3Mzk4MQ=="}], "type": "inlineReview"}, {"oid": "aec27b73314f7dc7c8b104a9eec64841450e2509", "url": "https://github.com/eclipse/eclipse.jdt.ls/commit/aec27b73314f7dc7c8b104a9eec64841450e2509", "message": "search for references from IClassFile without source\n\nSigned-off-by: Snjezana Peco <snjezana.peco@redhat.com>", "committedDate": "2021-02-07T18:59:44Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzEzNTIwMw==", "url": "https://github.com/eclipse/eclipse.jdt.ls/pull/1632#discussion_r573135203", "bodyText": "I don't think unit is ever a ClassFileWorkingCopy for me. Is there a specific case where this should happen ?", "author": "rgrunber", "createdAt": "2021-02-09T18:35:00Z", "path": "org.eclipse.jdt.ls.core/src/org/eclipse/jdt/ls/core/internal/JDTUtils.java", "diffHunk": "@@ -394,16 +402,216 @@ public static IClassFile resolveClassFile(URI uri){\n \t * @return either a class file or compilation unit\r\n \t */\r\n \tpublic static ITypeRoot resolveTypeRoot(String uriString) {\r\n+\t\treturn resolveTypeRoot(uriString, false, null);\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Convenience method that combines {@link #resolveClassFile(String)} and\r\n+\t * {@link #resolveCompilationUnit(String)}.\r\n+\t *\r\n+\t * @param uri\r\n+\t * @param returnCompilationUnit\r\n+\t * @param monitor\r\n+\t * @return either a class file or compilation unit\r\n+\t */\r\n+\tpublic static ITypeRoot resolveTypeRoot(String uriString, boolean returnCompilationUnit, IProgressMonitor monitor) {\r\n \t\tURI uri = toURI(uriString);\r\n \t\tif (uri == null) {\r\n \t\t\treturn null;\r\n \t\t}\r\n \t\tif (JDT_SCHEME.equals(uri.getScheme())) {\r\n-\t\t\treturn resolveClassFile(uri);\r\n+\t\t\tIClassFile classFile = resolveClassFile(uri);\r\n+\t\t\ttry {\r\n+\t\t\t\tif (returnCompilationUnit && classFile != null && classFile.getSourceRange() == null) {\r\n+\t\t\t\t\tContentProviderManager contentProvider = JavaLanguageServerPlugin.getContentProviderManager();\r\n+\t\t\t\t\tif (monitor == null) {\r\n+\t\t\t\t\t\tmonitor = new NullProgressMonitor();\r\n+\t\t\t\t\t}\r\n+\t\t\t\t\tString contents;\r\n+\t\t\t\t\ttry {\r\n+\t\t\t\t\t\tcontents = contentProvider.getSource(classFile, monitor);\r\n+\t\t\t\t\t} catch (Exception e) {\r\n+\t\t\t\t\t\tJavaLanguageServerPlugin.logException(e.getMessage(), e);\r\n+\t\t\t\t\t\treturn classFile;\r\n+\t\t\t\t\t}\r\n+\t\t\t\t\tif (contents != null && !contents.isBlank()) {\r\n+\t\t\t\t\t\treturn getWorkingCopy(classFile, contents, monitor);\r\n+\t\t\t\t\t}\r\n+\t\t\t\t}\r\n+\t\t\t} catch (JavaModelException e) {\r\n+\t\t\t\tJavaLanguageServerPlugin.logException(e.getMessage(), e);\r\n+\t\t\t}\r\n+\t\t\treturn classFile;\r\n \t\t}\r\n \t\treturn resolveCompilationUnit(uri);\r\n \t}\r\n \r\n+\tpublic static void discardClassFileWorkingCopy(ITypeRoot unit) {\r", "originalCommit": "aec27b73314f7dc7c8b104a9eec64841450e2509", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzIwNDc0Mg==", "url": "https://github.com/eclipse/eclipse.jdt.ls/pull/1632#discussion_r573204742", "bodyText": "you are right. Fixed.", "author": "snjeza", "createdAt": "2021-02-09T20:13:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzEzNTIwMw=="}], "type": "inlineReview"}, {"oid": "70bf4f54e89457eb7d4dceab67b842ffc0880618", "url": "https://github.com/eclipse/eclipse.jdt.ls/commit/70bf4f54e89457eb7d4dceab67b842ffc0880618", "message": "search for references from IClassFile without source\n\nSigned-off-by: Snjezana Peco <snjezana.peco@redhat.com>", "committedDate": "2021-02-09T20:12:24Z", "type": "forcePushed"}, {"oid": "14394cb01c650123ef4f313ec8f96f6f281cf25e", "url": "https://github.com/eclipse/eclipse.jdt.ls/commit/14394cb01c650123ef4f313ec8f96f6f281cf25e", "message": "search for references from IClassFile without source\n\nSigned-off-by: Snjezana Peco <snjezana.peco@redhat.com>", "committedDate": "2021-02-14T14:40:59Z", "type": "commit"}, {"oid": "14394cb01c650123ef4f313ec8f96f6f281cf25e", "url": "https://github.com/eclipse/eclipse.jdt.ls/commit/14394cb01c650123ef4f313ec8f96f6f281cf25e", "message": "search for references from IClassFile without source\n\nSigned-off-by: Snjezana Peco <snjezana.peco@redhat.com>", "committedDate": "2021-02-14T14:40:59Z", "type": "forcePushed"}]}