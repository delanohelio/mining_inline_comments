{"pr_number": 7255, "pr_title": "Re-work Function MetaDataManager to make all metadata writes only by the leader", "pr_createdAt": "2020-06-12T02:43:47Z", "pr_url": "https://github.com/apache/pulsar/pull/7255", "timeline": [{"oid": "bf11f0ca6532ee3a176bde27b944b8b4bc7a6ff3", "url": "https://github.com/apache/pulsar/commit/bf11f0ca6532ee3a176bde27b944b8b4bc7a6ff3", "message": "Function workers re-direct call update requests to the leader", "committedDate": "2020-06-11T01:32:13Z", "type": "commit"}, {"oid": "691d0548ee9552ddef23298a3ce5d00bda022037", "url": "https://github.com/apache/pulsar/commit/691d0548ee9552ddef23298a3ce5d00bda022037", "message": "Fixed test", "committedDate": "2020-06-11T01:45:22Z", "type": "commit"}, {"oid": "cfb203d011dcded6248c8d33e414d519fa955b1a", "url": "https://github.com/apache/pulsar/commit/cfb203d011dcded6248c8d33e414d519fa955b1a", "message": "tests pass", "committedDate": "2020-06-11T05:18:25Z", "type": "commit"}, {"oid": "f8145443b49957898144cd9ec1f2b76b0b1f6f09", "url": "https://github.com/apache/pulsar/commit/f8145443b49957898144cd9ec1f2b76b0b1f6f09", "message": "Working version", "committedDate": "2020-06-11T07:44:32Z", "type": "commit"}, {"oid": "b0a7f284351f58810e8c962221413bcf6578db02", "url": "https://github.com/apache/pulsar/commit/b0a7f284351f58810e8c962221413bcf6578db02", "message": "Fix test", "committedDate": "2020-06-11T15:42:44Z", "type": "commit"}, {"oid": "e612318f8ad1b0b7356d1fb885b4723eca7c6afd", "url": "https://github.com/apache/pulsar/commit/e612318f8ad1b0b7356d1fb885b4723eca7c6afd", "message": "Merge remote-tracking branch 'apache/master' into functions_leader_executor", "committedDate": "2020-06-11T15:43:08Z", "type": "commit"}, {"oid": "ea53753ec173eff15fd4223f634bc31e658fad74", "url": "https://github.com/apache/pulsar/commit/ea53753ec173eff15fd4223f634bc31e658fad74", "message": "Merge branch 'master' into functions_leader_executor", "committedDate": "2020-06-12T02:36:27Z", "type": "commit"}, {"oid": "c02274ab17fed9c3d85a98c1ff4a90201bfb3a88", "url": "https://github.com/apache/pulsar/commit/c02274ab17fed9c3d85a98c1ff4a90201bfb3a88", "message": "Short circuit update", "committedDate": "2020-06-12T18:57:03Z", "type": "commit"}, {"oid": "93c54e1b4083107010a90fc162a1a7039c2e64b8", "url": "https://github.com/apache/pulsar/commit/93c54e1b4083107010a90fc162a1a7039c2e64b8", "message": "Fix test", "committedDate": "2020-06-12T19:15:07Z", "type": "commit"}, {"oid": "fd8766e46f22329c831b9141a05d1a90b8e3146e", "url": "https://github.com/apache/pulsar/commit/fd8766e46f22329c831b9141a05d1a90b8e3146e", "message": "Fix test", "committedDate": "2020-06-12T19:35:03Z", "type": "commit"}, {"oid": "b5b17528eea66df0d94fad47616f901f53a42473", "url": "https://github.com/apache/pulsar/commit/b5b17528eea66df0d94fad47616f901f53a42473", "message": "Fix tests", "committedDate": "2020-06-12T23:03:34Z", "type": "commit"}, {"oid": "d3403c7ae8129f12a3f0e982e3372ad5d4ad5d7a", "url": "https://github.com/apache/pulsar/commit/d3403c7ae8129f12a3f0e982e3372ad5d4ad5d7a", "message": "Added one more catch", "committedDate": "2020-06-12T23:05:19Z", "type": "commit"}, {"oid": "cc3646ebaae59d683462b240478fae3319aeac7a", "url": "https://github.com/apache/pulsar/commit/cc3646ebaae59d683462b240478fae3319aeac7a", "message": "Added one more catch", "committedDate": "2020-06-12T23:05:42Z", "type": "commit"}, {"oid": "6b8d6d251bbeac1ad565aaebd0b4629794258c82", "url": "https://github.com/apache/pulsar/commit/6b8d6d251bbeac1ad565aaebd0b4629794258c82", "message": "Seperated internal and external errors", "committedDate": "2020-06-12T23:06:35Z", "type": "commit"}, {"oid": "aeb51ca4c44bb0cdf83904dcb8b2bbe9446a0da4", "url": "https://github.com/apache/pulsar/commit/aeb51ca4c44bb0cdf83904dcb8b2bbe9446a0da4", "message": "Fix test", "committedDate": "2020-06-13T00:04:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM0NjIwNw==", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r440346207", "bodyText": "I don't think it is a good idea to expose this in the admin API. This is an internal thing and users should not have to the option to call this directly", "author": "jerrypeng", "createdAt": "2020-06-15T17:51:55Z", "path": "pulsar-client-admin/src/main/java/org/apache/pulsar/client/admin/Functions.java", "diffHunk": "@@ -893,4 +893,42 @@ void putFunctionState(String tenant, String namespace, String function, Function\n      */\n     CompletableFuture<Void> putFunctionStateAsync(\n             String tenant, String namespace, String function, FunctionState state);\n+\n+    /**\n+     * Sends update function request to worker leader. This is an internal only api\n+     * <p/>\n+     *\n+     * @param tenant\n+     *            Tenant name\n+     * @param namespace\n+     *            Namespace name\n+     * @param function\n+     *            Function name\n+     * @param functionMetaData\n+     *            byte repr of FunctionMetaData\n+     **\n+     * @throws NotAuthorizedException\n+     *             You don't have admin permission to get the configuration of the cluster\n+     * @throws PulsarAdminException\n+     *             Unexpected error\n+     */\n+    void updateOnWorkerLeader(String tenant, String namespace, String function, byte[] functionMetaData,", "originalCommit": "aeb51ca4c44bb0cdf83904dcb8b2bbe9446a0da4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjM3MzE2NQ==", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r442373165", "bodyText": "removed", "author": "srkukarni", "createdAt": "2020-06-18T17:01:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM0NjIwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM0NjQ3MQ==", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r440346471", "bodyText": "Same comment about exposing these internal APIs to end users", "author": "jerrypeng", "createdAt": "2020-06-15T17:52:27Z", "path": "pulsar-client-admin/src/main/java/org/apache/pulsar/client/admin/internal/FunctionsImpl.java", "diffHunk": "@@ -984,4 +985,53 @@ public void putFunctionState(String tenant, String namespace, String function, F\n         }\n         return future;\n     }\n+\n+    @Override\n+    public void updateOnWorkerLeader(String tenant, String namespace,\n+                                     String function, byte[] functionMetaData,\n+                                     boolean delete) throws PulsarAdminException {\n+        try {\n+            updateOnWorkerLeaderAsync(tenant, namespace, function,\n+                    functionMetaData, delete).get(this.readTimeoutMs, TimeUnit.MILLISECONDS);\n+        } catch (ExecutionException e) {\n+            throw (PulsarAdminException) e.getCause();\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+            throw new PulsarAdminException(e);\n+        } catch (TimeoutException e) {\n+            throw new PulsarAdminException.TimeoutException(e);\n+        }\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> updateOnWorkerLeaderAsync(String tenant, String namespace,", "originalCommit": "aeb51ca4c44bb0cdf83904dcb8b2bbe9446a0da4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjM3MzIyMw==", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r442373223", "bodyText": "removed", "author": "srkukarni", "createdAt": "2020-06-18T17:01:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM0NjQ3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM2NjQ0NA==", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r440366444", "bodyText": "Shouldn't we also set a key so that we can use topic compaction?", "author": "jerrypeng", "createdAt": "2020-06-15T18:29:38Z", "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/FunctionMetaDataManager.java", "diffHunk": "@@ -168,68 +151,78 @@ public synchronized boolean containsFunction(String tenant, String namespace, St\n         return containsFunctionMetaData(tenant, namespace, functionName);\n     }\n \n-    /**\n-     * Sends an update request to the FMT (Function Metadata Topic)\n-     * @param functionMetaData The function metadata that needs to be updated\n-     * @return a completable future of when the update has been applied\n-     */\n-    public synchronized CompletableFuture<RequestResult> updateFunction(FunctionMetaData functionMetaData) {\n-\n-        FunctionMetaData existingFunctionMetadata = null;\n-        if (containsFunction(functionMetaData.getFunctionDetails().getTenant(),\n-                functionMetaData.getFunctionDetails().getNamespace(),\n-                functionMetaData.getFunctionDetails().getName())) {\n-            existingFunctionMetadata = getFunctionMetaData(functionMetaData.getFunctionDetails().getTenant(),\n-                    functionMetaData.getFunctionDetails().getNamespace(),\n-                    functionMetaData.getFunctionDetails().getName());\n+    public synchronized void updateFunctionOnLeader(FunctionMetaData functionMetaData, boolean delete)\n+            throws IllegalStateException, IllegalArgumentException {\n+        if (exclusiveLeaderProducer == null) {\n+            throw new IllegalStateException(\"Not the leader\");\n+        }\n+        boolean needsScheduling;\n+        if (delete) {\n+            needsScheduling = proccessDeregister(functionMetaData);\n+        } else {\n+            needsScheduling = processUpdate(functionMetaData);\n+        }\n+        Request.ServiceRequest serviceRequest = Request.ServiceRequest.newBuilder()\n+                .setServiceRequestType(delete ? Request.ServiceRequest.ServiceRequestType.DELETE : Request.ServiceRequest.ServiceRequestType.UPDATE)\n+                .setFunctionMetaData(functionMetaData)\n+                .setWorkerId(workerConfig.getWorkerId())\n+                .setRequestId(UUID.randomUUID().toString())\n+                .build();\n+        try {\n+            exclusiveLeaderProducer.send(serviceRequest.toByteArray());", "originalCommit": "aeb51ca4c44bb0cdf83904dcb8b2bbe9446a0da4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQxMzAxOA==", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r440413018", "bodyText": "That is a follow on change. I wanted this pr to just focus on the changed mechanism of handling updates", "author": "srkukarni", "createdAt": "2020-06-15T19:58:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM2NjQ0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM2ODUxMg==", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r440368512", "bodyText": "I don't think this is the right approach.  You might be interrupting a message being processed.  The goal is the reach to the end and process all the messages.  I would just doing something similar to what I have done here:\nhttps://github.com/apache/pulsar/pull/7237/files#diff-fb140c4ab9a86232f8d85b90cf0d3705R168", "author": "jerrypeng", "createdAt": "2020-06-15T18:33:22Z", "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/FunctionMetaDataTopicTailer.java", "diffHunk": "@@ -77,12 +89,25 @@ public void run() {\n                     if (!(th instanceof InterruptedException || th.getCause() instanceof InterruptedException)) {\n                         log.warn(\"Encountered error when metadata tailer is not running\", th);\n                     }\n-                    return;\n                 }\n             }\n         }\n     }\n \n+    public void stopWhenNoMoreMessages() {\n+        stopOnNoMessageAvailable = true;\n+        readerThread.interrupt();", "originalCommit": "aeb51ca4c44bb0cdf83904dcb8b2bbe9446a0da4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjM1MDcyMQ==", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r442350721", "bodyText": "changed", "author": "srkukarni", "createdAt": "2020-06-18T16:24:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM2ODUxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM3MDU1MQ==", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r440370551", "bodyText": "we shouldn't need to catch any exceptions.  The thread needs to complete without any errors", "author": "jerrypeng", "createdAt": "2020-06-15T18:37:08Z", "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/FunctionMetaDataTopicTailer.java", "diffHunk": "@@ -77,12 +89,25 @@ public void run() {\n                     if (!(th instanceof InterruptedException || th.getCause() instanceof InterruptedException)) {\n                         log.warn(\"Encountered error when metadata tailer is not running\", th);\n                     }\n-                    return;\n                 }\n             }\n         }\n     }\n \n+    public void stopWhenNoMoreMessages() {\n+        stopOnNoMessageAvailable = true;\n+        readerThread.interrupt();\n+        // We need to wait here till the thread exits to make sure that the reader is up to date\n+        while (true) {\n+            try {\n+                readerThread.join();\n+                return;\n+            } catch (InterruptedException e) {", "originalCommit": "aeb51ca4c44bb0cdf83904dcb8b2bbe9446a0da4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjM1MDc3Mg==", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r442350772", "bodyText": "removed", "author": "srkukarni", "createdAt": "2020-06-18T16:24:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM3MDU1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM4MDk4Ng==", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r440380986", "bodyText": "I don't think we should check \"! stopOnNoMessageAvailable\". If errors occur while stopOnNoMessageAvailable=true, we still need to correctly handle the exception and not ignore it because that means we didn't process all messages successfully", "author": "jerrypeng", "createdAt": "2020-06-15T18:56:35Z", "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/FunctionMetaDataTopicTailer.java", "diffHunk": "@@ -63,12 +65,22 @@ public void start() {\n \n     @Override\n     public void run() {\n-        while(running) {\n+        while (running) {\n+            if (stopOnNoMessageAvailable) {\n+                try {\n+                    if (!reader.hasMessageAvailable()) {\n+                        break;\n+                    }\n+                } catch (PulsarClientException e) {\n+                    log.error(\"Received exception while testing hasMessageAvailable\", e);\n+                    errorNotifier.triggerError(e);\n+                }\n+            }\n             try {\n                 Message<byte[]> msg = reader.readNext();\n                 processRequest(msg);\n             } catch (Throwable th) {\n-                if (running) {\n+                if (running && !stopOnNoMessageAvailable) {", "originalCommit": "aeb51ca4c44bb0cdf83904dcb8b2bbe9446a0da4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjM1MDgxNg==", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r442350816", "bodyText": "changed", "author": "srkukarni", "createdAt": "2020-06-18T16:24:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM4MDk4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM4NjQ1Ng==", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r440386456", "bodyText": "Why do you need to move this here?", "author": "jerrypeng", "createdAt": "2020-06-15T19:06:39Z", "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/WorkerService.java", "diffHunk": "@@ -171,6 +171,9 @@ public void start(URI dlogUri,\n             this.functionMetaDataManager = new FunctionMetaDataManager(\n                     this.workerConfig, this.schedulerManager, this.client, errorNotifier);\n \n+            // initialize function metadata manager\n+            this.functionMetaDataManager.initialize();", "originalCommit": "aeb51ca4c44bb0cdf83904dcb8b2bbe9446a0da4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjM3MzYzOA==", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r442373638", "bodyText": "Upon start, we always first want to get up-to-date before becoming leader and starting to serve requests", "author": "srkukarni", "createdAt": "2020-06-18T17:01:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM4NjQ1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUzMDgyMQ==", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r442530821", "bodyText": "This should happen after membership manager is created/started.  We want to do this prior to the worker \"joining\" the cluster", "author": "jerrypeng", "createdAt": "2020-06-18T22:13:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM4NjQ1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU3MTE5OA==", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r442571198", "bodyText": "Whats the harm before doing that? All that will happen is that this will read the topic and update its internal state", "author": "srkukarni", "createdAt": "2020-06-19T00:34:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM4NjQ1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM5NDYxMw==", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r440394613", "bodyText": "It is not a good idea to simply re-create the metadata tailer object.  This will cause the tailer to start reading from the beginning.  This will cause all the tailer to have to re-read the whole topic.  The problem here is not only that the the tailer has to re-read the whole topic which can take time but during that time the in-memory metadata map for the worker will be inconsistent.  If a user request is sent to the worker during this time, the behavior might be incorrect.  I would suggest keeping track of the message Id that represents to which message the current view of the metadata relates to.  When the worker is the leader and it updates its in memory metadata cache and  produces messages to metadata topic, we should update the message id.  When the worker loses leadership, the tailer should use the message id and start reading from there", "author": "jerrypeng", "createdAt": "2020-06-15T19:22:29Z", "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/FunctionMetaDataManager.java", "diffHunk": "@@ -168,68 +151,78 @@ public synchronized boolean containsFunction(String tenant, String namespace, St\n         return containsFunctionMetaData(tenant, namespace, functionName);\n     }\n \n-    /**\n-     * Sends an update request to the FMT (Function Metadata Topic)\n-     * @param functionMetaData The function metadata that needs to be updated\n-     * @return a completable future of when the update has been applied\n-     */\n-    public synchronized CompletableFuture<RequestResult> updateFunction(FunctionMetaData functionMetaData) {\n-\n-        FunctionMetaData existingFunctionMetadata = null;\n-        if (containsFunction(functionMetaData.getFunctionDetails().getTenant(),\n-                functionMetaData.getFunctionDetails().getNamespace(),\n-                functionMetaData.getFunctionDetails().getName())) {\n-            existingFunctionMetadata = getFunctionMetaData(functionMetaData.getFunctionDetails().getTenant(),\n-                    functionMetaData.getFunctionDetails().getNamespace(),\n-                    functionMetaData.getFunctionDetails().getName());\n+    public synchronized void updateFunctionOnLeader(FunctionMetaData functionMetaData, boolean delete)\n+            throws IllegalStateException, IllegalArgumentException {\n+        if (exclusiveLeaderProducer == null) {\n+            throw new IllegalStateException(\"Not the leader\");\n+        }\n+        boolean needsScheduling;\n+        if (delete) {\n+            needsScheduling = proccessDeregister(functionMetaData);\n+        } else {\n+            needsScheduling = processUpdate(functionMetaData);\n+        }\n+        Request.ServiceRequest serviceRequest = Request.ServiceRequest.newBuilder()\n+                .setServiceRequestType(delete ? Request.ServiceRequest.ServiceRequestType.DELETE : Request.ServiceRequest.ServiceRequestType.UPDATE)\n+                .setFunctionMetaData(functionMetaData)\n+                .setWorkerId(workerConfig.getWorkerId())\n+                .setRequestId(UUID.randomUUID().toString())\n+                .build();\n+        try {\n+            exclusiveLeaderProducer.send(serviceRequest.toByteArray());\n+        } catch (Exception e) {\n+            log.error(\"Could not write into Function Metadata topic\", e);\n+            errorNotifier.triggerError(e);\n+        }\n+        if (needsScheduling) {\n+            this.schedulerManager.schedule();\n         }\n-\n-        FunctionMetaData newFunctionMetaData = FunctionMetaDataUtils.generateUpdatedMetadata(existingFunctionMetadata, functionMetaData);\n-\n-        Request.ServiceRequest updateRequest = ServiceRequestUtils.getUpdateRequest(\n-                this.workerConfig.getWorkerId(), newFunctionMetaData);\n-\n-        return submit(updateRequest);\n     }\n \n-\n-    /**\n-     * Sends a deregister request to the FMT (Function Metadata Topic) for a function\n-     * @param tenant the tenant the function that needs to be deregistered belongs to\n-     * @param namespace the namespace the function that needs to be deregistered belongs to\n-     * @param functionName the name of the function\n-     * @return a completable future of when the deregister has been applied\n-     */\n-    public synchronized CompletableFuture<RequestResult> deregisterFunction(String tenant, String namespace, String functionName) {\n-        FunctionMetaData functionMetaData = this.functionMetaDataMap.get(tenant).get(namespace).get(functionName);\n-\n-        FunctionMetaData newFunctionMetaData = FunctionMetaDataUtils.generateUpdatedMetadata(functionMetaData, functionMetaData);\n-\n-        Request.ServiceRequest deregisterRequest = ServiceRequestUtils.getDeregisterRequest(\n-                this.workerConfig.getWorkerId(), newFunctionMetaData);\n-\n-        return submit(deregisterRequest);\n+    // Note that this method cannot be syncrhonized because the tailer might still be processing messages\n+    public void acquireLeadership() {\n+        log.info(\"FunctionMetaDataManager becoming leader by creating exclusive producer\");\n+        FunctionMetaDataTopicTailer tailer = internalAcquireLeadership();\n+        // Now that we have created the exclusive producer, wait for reader to get over\n+        if (tailer != null) {\n+            tailer.stopWhenNoMoreMessages();\n+            tailer.close();\n+        }\n+        this.schedulerManager.schedule();\n+        log.info(\"FunctionMetaDataManager done becoming leader by doing its first schedule\");\n     }\n \n-    /**\n-     * Sends a start/stop function request to the FMT (Function Metadata Topic) for a function\n-     * @param tenant the tenant the function that needs to be deregistered belongs to\n-     * @param namespace the namespace the function that needs to be deregistered belongs to\n-     * @param functionName the name of the function\n-     * @param instanceId the instanceId of the function, -1 if for all instances\n-     * @param start do we need to start or stop\n-     * @return a completable future of when the start/stop has been applied\n-     */\n-    public synchronized CompletableFuture<RequestResult> changeFunctionInstanceStatus(String tenant, String namespace, String functionName,\n-                                                                                      Integer instanceId, boolean start) {\n-        FunctionMetaData functionMetaData = this.functionMetaDataMap.get(tenant).get(namespace).get(functionName);\n-\n-        FunctionMetaData newFunctionMetaData = FunctionMetaDataUtils.changeFunctionInstanceStatus(functionMetaData, instanceId, start);\n-\n-        Request.ServiceRequest updateRequest = ServiceRequestUtils.getUpdateRequest(\n-                this.workerConfig.getWorkerId(), newFunctionMetaData);\n+    private synchronized FunctionMetaDataTopicTailer internalAcquireLeadership() {\n+        if (exclusiveLeaderProducer == null) {\n+            try {\n+                exclusiveLeaderProducer = pulsarClient.newProducer()\n+                        .topic(this.workerConfig.getFunctionMetadataTopic())\n+                        .producerName(workerConfig.getWorkerId() + \"-leader\")\n+                        // .type(EXCLUSIVE)\n+                        .create();\n+            } catch (PulsarClientException e) {\n+                log.error(\"Error creating exclusive producer\", e);\n+                errorNotifier.triggerError(e);\n+            }\n+        } else {\n+            log.error(\"Logic Error in FunctionMetaData Manager\");\n+            errorNotifier.triggerError(new IllegalStateException());\n+        }\n+        FunctionMetaDataTopicTailer tailer = this.functionMetaDataTopicTailer;\n+        this.functionMetaDataTopicTailer = null;\n+        return tailer;\n+    }\n \n-        return submit(updateRequest);\n+    public synchronized void giveupLeadership() {\n+        log.info(\"FunctionMetaDataManager giving up leadership by closing exclusive producer\");\n+        try {\n+            exclusiveLeaderProducer.close();\n+        } catch (PulsarClientException e) {\n+            log.error(\"Error closing exclusive producer\", e);\n+            errorNotifier.triggerError(e);\n+        }\n+        exclusiveLeaderProducer = null;\n+        initializeTailer();", "originalCommit": "aeb51ca4c44bb0cdf83904dcb8b2bbe9446a0da4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQxMTk4NA==", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r440411984", "bodyText": "will do", "author": "srkukarni", "createdAt": "2020-06-15T19:56:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM5NDYxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjM1MDg3Mg==", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r442350872", "bodyText": "changed", "author": "srkukarni", "createdAt": "2020-06-18T16:24:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM5NDYxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQwMzI3OQ==", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r440403279", "bodyText": "Currently when there are concurrent modifications, the worker will fail requests.  That doesn't seem to be done now.  All requests are accepted and 200s will be returned to the user but internally some requests will just be silently ignored.", "author": "jerrypeng", "createdAt": "2020-06-15T19:39:12Z", "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/FunctionMetaDataManager.java", "diffHunk": "@@ -168,68 +151,78 @@ public synchronized boolean containsFunction(String tenant, String namespace, St\n         return containsFunctionMetaData(tenant, namespace, functionName);\n     }\n \n-    /**\n-     * Sends an update request to the FMT (Function Metadata Topic)\n-     * @param functionMetaData The function metadata that needs to be updated\n-     * @return a completable future of when the update has been applied\n-     */\n-    public synchronized CompletableFuture<RequestResult> updateFunction(FunctionMetaData functionMetaData) {\n-\n-        FunctionMetaData existingFunctionMetadata = null;\n-        if (containsFunction(functionMetaData.getFunctionDetails().getTenant(),\n-                functionMetaData.getFunctionDetails().getNamespace(),\n-                functionMetaData.getFunctionDetails().getName())) {\n-            existingFunctionMetadata = getFunctionMetaData(functionMetaData.getFunctionDetails().getTenant(),\n-                    functionMetaData.getFunctionDetails().getNamespace(),\n-                    functionMetaData.getFunctionDetails().getName());\n+    public synchronized void updateFunctionOnLeader(FunctionMetaData functionMetaData, boolean delete)", "originalCommit": "aeb51ca4c44bb0cdf83904dcb8b2bbe9446a0da4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQxMTMzNA==", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r440411334", "bodyText": "That behaviour hasn't changed. Users will still see 'This request is outdated, please try again' messages upon concurrent updates. That behaviour is now executed by the leader which will return that error in the /leader request.", "author": "srkukarni", "createdAt": "2020-06-15T19:55:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQwMzI3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDAyNTE0MQ==", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r444025141", "bodyText": "How is that the case?  The method \"submit\" is deleted. We were using the \"submit()\" method to put a completable future in the \"pendingServiceRequests\" map and then completing the future when we were merging in the request to the local metadata cache. If there was a conflict the future is completed exceptionally with an error message.  It seems that whole workflow is removed.", "author": "jerrypeng", "createdAt": "2020-06-23T07:42:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQwMzI3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDAyODk0Ng==", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r444028946", "bodyText": "I see you are throwing an IllegalArgumentException for those", "author": "jerrypeng", "createdAt": "2020-06-23T07:49:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQwMzI3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ1OTQ1MQ==", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r444459451", "bodyText": "Yes. All of that workflow is gone because we no longer use submit workflow. Leader either directly updates cache or in worker mode the trailer does the update", "author": "srkukarni", "createdAt": "2020-06-23T19:33:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQwMzI3OQ=="}], "type": "inlineReview"}, {"oid": "527aea2affed67ca9bda71831c9fa615be9529c5", "url": "https://github.com/apache/pulsar/commit/527aea2affed67ca9bda71831c9fa615be9529c5", "message": "Address feedback", "committedDate": "2020-06-18T16:24:20Z", "type": "commit"}, {"oid": "dcc4cd2ceb555366c4ce54ffd32979be4c6c99a6", "url": "https://github.com/apache/pulsar/commit/dcc4cd2ceb555366c4ce54ffd32979be4c6c99a6", "message": "Do not expose updateOnLeader to functions", "committedDate": "2020-06-18T17:00:37Z", "type": "commit"}, {"oid": "f8f2d345af3630f651ab5ac0c39c229df8d6d5c5", "url": "https://github.com/apache/pulsar/commit/f8f2d345af3630f651ab5ac0c39c229df8d6d5c5", "message": "hide api", "committedDate": "2020-06-18T17:15:37Z", "type": "commit"}, {"oid": "476b692bdc9b7a2aece1e4ccad597dca30391b27", "url": "https://github.com/apache/pulsar/commit/476b692bdc9b7a2aece1e4ccad597dca30391b27", "message": "hide api", "committedDate": "2020-06-18T17:15:55Z", "type": "commit"}, {"oid": "ad7309946d060252bf19aabc589f152bb93d1423", "url": "https://github.com/apache/pulsar/commit/ad7309946d060252bf19aabc589f152bb93d1423", "message": "Merge branch 'master' into functions_leader_executor", "committedDate": "2020-06-20T22:25:04Z", "type": "commit"}, {"oid": "acd999f81b21f73e78ec951df9a81e93c541666e", "url": "https://github.com/apache/pulsar/commit/acd999f81b21f73e78ec951df9a81e93c541666e", "message": "removed duplicate comments", "committedDate": "2020-06-20T22:31:49Z", "type": "commit"}, {"oid": "a256bc987bca5a8cc61c2b95b0103b3c159d4399", "url": "https://github.com/apache/pulsar/commit/a256bc987bca5a8cc61c2b95b0103b3c159d4399", "message": "Do leadership changes in function metadata manager", "committedDate": "2020-06-20T22:49:27Z", "type": "commit"}, {"oid": "8fc89c35e9752682a70540510447764639ed5fbe", "url": "https://github.com/apache/pulsar/commit/8fc89c35e9752682a70540510447764639ed5fbe", "message": "make the function sync", "committedDate": "2020-06-21T00:00:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzczMTE2Mg==", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r443731162", "bodyText": "Should we separate out the metadata tailer from the meta manager like what we did for the assignment tailer and runtime manager?", "author": "jerrypeng", "createdAt": "2020-06-22T17:55:17Z", "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/FunctionMetaDataManager.java", "diffHunk": "@@ -90,25 +79,25 @@ public FunctionMetaDataManager(WorkerConfig workerConfig,\n      */\n     public void initialize() {\n         try {\n+            initializeTailer();\n             this.functionMetaDataTopicTailer = new FunctionMetaDataTopicTailer(this,\n                     pulsarClient.newReader(), this.workerConfig, this.errorNotifier);\n             // read all existing messages\n-            this.setInitializePhase(true);\n             while (this.functionMetaDataTopicTailer.getReader().hasMessageAvailable()) {\n                 this.functionMetaDataTopicTailer.processRequest(this.functionMetaDataTopicTailer.getReader().readNext());\n             }\n-            this.setInitializePhase(false);\n-            \n-\n         } catch (Exception e) {\n             log.error(\"Failed to initialize meta data store\", e);\n-            throw new RuntimeException(e);\n+            errorNotifier.triggerError(e);\n         }\n     }\n-    \n+\n+    private void initializeTailer() throws PulsarClientException {", "originalCommit": "8fc89c35e9752682a70540510447764639ed5fbe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzc4MDcxMw==", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r443780713", "bodyText": "As it stands now, currently PulsarMetaDataManager encapsulates all of this logic within itself. I can split this up in a following changes", "author": "srkukarni", "createdAt": "2020-06-22T19:33:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzczMTE2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDAxNjgwMw==", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r444016803", "bodyText": "Can you add some comments to this method as well of the FunctionMetadataManager to explain the workflow of processing a metadata request?", "author": "jerrypeng", "createdAt": "2020-06-23T07:27:43Z", "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/FunctionMetaDataManager.java", "diffHunk": "@@ -171,68 +160,83 @@ public synchronized boolean containsFunction(String tenant, String namespace, St\n         return containsFunctionMetaData(tenant, namespace, functionName);\n     }\n \n-    /**\n-     * Sends an update request to the FMT (Function Metadata Topic)\n-     * @param functionMetaData The function metadata that needs to be updated\n-     * @return a completable future of when the update has been applied\n-     */\n-    public synchronized CompletableFuture<RequestResult> updateFunction(FunctionMetaData functionMetaData) {\n-\n-        FunctionMetaData existingFunctionMetadata = null;\n-        if (containsFunction(functionMetaData.getFunctionDetails().getTenant(),\n-                functionMetaData.getFunctionDetails().getNamespace(),\n-                functionMetaData.getFunctionDetails().getName())) {\n-            existingFunctionMetadata = getFunctionMetaData(functionMetaData.getFunctionDetails().getTenant(),\n-                    functionMetaData.getFunctionDetails().getNamespace(),\n-                    functionMetaData.getFunctionDetails().getName());\n+    public synchronized void updateFunctionOnLeader(FunctionMetaData functionMetaData, boolean delete)", "originalCommit": "8fc89c35e9752682a70540510447764639ed5fbe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDMzMzA2MQ==", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r444333061", "bodyText": "Added more comments on this class", "author": "srkukarni", "createdAt": "2020-06-23T15:57:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDAxNjgwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDAyODQxOA==", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r444028418", "bodyText": "Why are we catching and ignoring the exceptions?  Are not the \"out of data request errors\" thrown as illegal argument exceptions? If we catch them and ignore it, how are to users going to receive the error?", "author": "jerrypeng", "createdAt": "2020-06-23T07:48:05Z", "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/FunctionMetaDataManager.java", "diffHunk": "@@ -241,20 +245,21 @@ public synchronized boolean containsFunction(String tenant, String namespace, St\n      * @param serviceRequest The request\n      */\n     public void processRequest(MessageId messageId, Request.ServiceRequest serviceRequest) {\n-\n-        // make sure that processing requests don't happen simultaneously\n-        synchronized (this) {\n+        try {\n             switch (serviceRequest.getServiceRequestType()) {\n                 case UPDATE:\n-                    this.processUpdate(serviceRequest);\n+                    this.processUpdate(serviceRequest.getFunctionMetaData());\n                     break;\n                 case DELETE:\n-                    this.proccessDeregister(serviceRequest);\n+                    this.proccessDeregister(serviceRequest.getFunctionMetaData());\n                     break;\n                 default:\n                     log.warn(\"Received request with unrecognized type: {}\", serviceRequest);\n             }\n+        } catch (IllegalArgumentException e) {\n+            // Its ok. Nothing much we can do about it", "originalCommit": "8fc89c35e9752682a70540510447764639ed5fbe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDMyNDQ1NA==", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r444324454", "bodyText": "processRequest is called by the metadata tailer. Thus it cannot really do much about IllegalArgumentException.\nUsers will get the IllegalArgumentException from the processUpdate and processDelete from the leader path.", "author": "srkukarni", "createdAt": "2020-06-23T15:44:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDAyODQxOA=="}], "type": "inlineReview"}, {"oid": "6f21176c62a23df0df7b327778b4ce81d3ea8dbe", "url": "https://github.com/apache/pulsar/commit/6f21176c62a23df0df7b327778b4ce81d3ea8dbe", "message": "Added more comments", "committedDate": "2020-06-23T15:56:51Z", "type": "commit"}, {"oid": "f381eeeca5da48123d2d034de374919a0734cbd4", "url": "https://github.com/apache/pulsar/commit/f381eeeca5da48123d2d034de374919a0734cbd4", "message": "Merge branch 'master' into functions_leader_executor", "committedDate": "2020-06-23T17:31:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQzMTQyNQ==", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r444431425", "bodyText": "Why are we removing this?", "author": "jerrypeng", "createdAt": "2020-06-23T18:41:49Z", "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/FunctionMetaDataManager.java", "diffHunk": "@@ -80,37 +84,40 @@ public FunctionMetaDataManager(WorkerConfig workerConfig,\n                 this.pulsarClient, this.workerConfig.getFunctionMetadataTopic());\n         this.schedulerManager = schedulerManager;\n         this.errorNotifier = errorNotifier;\n+        exclusiveLeaderProducer = null;\n     }\n \n     /**\n      * Public methods. Please use these methods if references FunctionMetaManager from an external class\n      */\n \n     /**\n-     * Initializes the FunctionMetaDataManager.  Does the following:\n-     * 1. Consume all existing function meta data upon start to establish existing state\n+     * Initializes the FunctionMetaDataManager. By default we start in the worker mode.\n+     * We consume all existing function meta data to establish existing state\n      */\n     public void initialize() {\n         try {\n+            initializeTailer();\n             this.functionMetaDataTopicTailer = new FunctionMetaDataTopicTailer(this,\n                     pulsarClient.newReader(), this.workerConfig, this.errorNotifier);\n             // read all existing messages\n-            this.setInitializePhase(true);\n             while (this.functionMetaDataTopicTailer.getReader().hasMessageAvailable()) {\n                 this.functionMetaDataTopicTailer.processRequest(this.functionMetaDataTopicTailer.getReader().readNext());\n             }\n-            this.setInitializePhase(false);\n             \n             this.isInitialized.complete(null);\n         } catch (Exception e) {\n             log.error(\"Failed to initialize meta data store\", e);\n-            throw new RuntimeException(e);\n+            errorNotifier.triggerError(e);\n         }\n     }\n-    \n+\n+    private void initializeTailer() throws PulsarClientException {\n+        this.functionMetaDataTopicTailer = new FunctionMetaDataTopicTailer(this,\n+                pulsarClient.newReader().startMessageId(lastMessageSeen), this.workerConfig, this.errorNotifier);\n+    }\n+\n     public void start() {\n-        // schedule functions if necessary\n-        this.schedulerManager.schedule();", "originalCommit": "f381eeeca5da48123d2d034de374919a0734cbd4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ0NDUwMg==", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r444444502", "bodyText": "nvm", "author": "jerrypeng", "createdAt": "2020-06-23T19:05:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQzMTQyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQzNTgzNg==", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r444435836", "bodyText": "Why are we getting rid of the \"isInitializePhase\" flag?  The flag is in place so we don't call schedule() for every message during the initialization phase and we wait to just call schedule at the end of the init phase", "author": "jerrypeng", "createdAt": "2020-06-23T18:49:24Z", "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/FunctionMetaDataManager.java", "diffHunk": "@@ -52,20 +61,15 @@\n     @VisibleForTesting\n     final Map<String, Map<String, Map<String, FunctionMetaData>>> functionMetaDataMap = new ConcurrentHashMap<>();\n \n-    // A map in which the key is the service request id and value is the service request\n-    private final Map<String, ServiceRequestInfo> pendingServiceRequests = new ConcurrentHashMap<>();\n-\n     private final ServiceRequestManager serviceRequestManager;\n     private final SchedulerManager schedulerManager;\n     private final WorkerConfig workerConfig;\n     private final PulsarClient pulsarClient;\n     private final ErrorNotifier errorNotifier;\n \n     private FunctionMetaDataTopicTailer functionMetaDataTopicTailer;\n-\n-    @Setter\n-    @Getter\n-    boolean isInitializePhase = false;", "originalCommit": "f381eeeca5da48123d2d034de374919a0734cbd4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ0MzYzNg==", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r444443636", "bodyText": "I see in \"processRequest()\" no scheduling is called and only in \"updateFunctionOnLeader\" is schedule() called", "author": "jerrypeng", "createdAt": "2020-06-23T19:03:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQzNTgzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQzODU4Nw==", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r444438587", "bodyText": "It seems more natural that the FunctionMetaDataTopicTailer keeps track of this since the FunctionMetadataManager isn't in charge of reading the topic", "author": "jerrypeng", "createdAt": "2020-06-23T18:54:33Z", "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/FunctionMetaDataManager.java", "diffHunk": "@@ -52,20 +61,15 @@\n     @VisibleForTesting\n     final Map<String, Map<String, Map<String, FunctionMetaData>>> functionMetaDataMap = new ConcurrentHashMap<>();\n \n-    // A map in which the key is the service request id and value is the service request\n-    private final Map<String, ServiceRequestInfo> pendingServiceRequests = new ConcurrentHashMap<>();\n-\n     private final ServiceRequestManager serviceRequestManager;\n     private final SchedulerManager schedulerManager;\n     private final WorkerConfig workerConfig;\n     private final PulsarClient pulsarClient;\n     private final ErrorNotifier errorNotifier;\n \n     private FunctionMetaDataTopicTailer functionMetaDataTopicTailer;\n-\n-    @Setter\n-    @Getter\n-    boolean isInitializePhase = false;\n+    private Producer exclusiveLeaderProducer;\n+    private MessageId lastMessageSeen = MessageId.earliest;", "originalCommit": "f381eeeca5da48123d2d034de374919a0734cbd4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ2MTQzOQ==", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r444461439", "bodyText": "Actually no. Manager should keep track of it since in leader mode there is no tailer", "author": "srkukarni", "createdAt": "2020-06-23T19:37:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQzODU4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ0MDUyMw==", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r444440523", "bodyText": "it is kind of weird that the functionMetaDataTopicTailer.processRequest() will call back to FunctionMetadataManager.  Seems like an awkward interaction between the classes.  Perhaps we can refactor in a subsequent PR.", "author": "jerrypeng", "createdAt": "2020-06-23T18:57:52Z", "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/FunctionMetaDataManager.java", "diffHunk": "@@ -80,37 +84,40 @@ public FunctionMetaDataManager(WorkerConfig workerConfig,\n                 this.pulsarClient, this.workerConfig.getFunctionMetadataTopic());\n         this.schedulerManager = schedulerManager;\n         this.errorNotifier = errorNotifier;\n+        exclusiveLeaderProducer = null;\n     }\n \n     /**\n      * Public methods. Please use these methods if references FunctionMetaManager from an external class\n      */\n \n     /**\n-     * Initializes the FunctionMetaDataManager.  Does the following:\n-     * 1. Consume all existing function meta data upon start to establish existing state\n+     * Initializes the FunctionMetaDataManager. By default we start in the worker mode.\n+     * We consume all existing function meta data to establish existing state\n      */\n     public void initialize() {\n         try {\n+            initializeTailer();\n             this.functionMetaDataTopicTailer = new FunctionMetaDataTopicTailer(this,\n                     pulsarClient.newReader(), this.workerConfig, this.errorNotifier);\n             // read all existing messages\n-            this.setInitializePhase(true);\n             while (this.functionMetaDataTopicTailer.getReader().hasMessageAvailable()) {\n                 this.functionMetaDataTopicTailer.processRequest(this.functionMetaDataTopicTailer.getReader().readNext());", "originalCommit": "f381eeeca5da48123d2d034de374919a0734cbd4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ2MTYwNw==", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r444461607", "bodyText": "Agreed", "author": "srkukarni", "createdAt": "2020-06-23T19:37:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ0MDUyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ2NTIwOA==", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r444465208", "bodyText": "Shouldn't we also start the the tailer here?", "author": "jerrypeng", "createdAt": "2020-06-23T19:44:49Z", "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/FunctionMetaDataManager.java", "diffHunk": "@@ -174,89 +181,124 @@ public synchronized boolean containsFunction(String tenant, String namespace, St\n     }\n \n     /**\n-     * Sends an update request to the FMT (Function Metadata Topic)\n-     * @param functionMetaData The function metadata that needs to be updated\n-     * @return a completable future of when the update has been applied\n+     * Called by the worker when we are in the leader mode.  In this state, we update our in-memory\n+     * data structures and then write to the metadata topic.\n+     * @param functionMetaData The function metadata in question\n+     * @param delete Is this a delete operation\n+     * @throws IllegalStateException if we are not the leader\n+     * @throws IllegalArgumentException if the request is out of date.\n      */\n-    public synchronized CompletableFuture<RequestResult> updateFunction(FunctionMetaData functionMetaData) {\n-\n-        FunctionMetaData existingFunctionMetadata = null;\n-        if (containsFunction(functionMetaData.getFunctionDetails().getTenant(),\n-                functionMetaData.getFunctionDetails().getNamespace(),\n-                functionMetaData.getFunctionDetails().getName())) {\n-            existingFunctionMetadata = getFunctionMetaData(functionMetaData.getFunctionDetails().getTenant(),\n-                    functionMetaData.getFunctionDetails().getNamespace(),\n-                    functionMetaData.getFunctionDetails().getName());\n+    public synchronized void updateFunctionOnLeader(FunctionMetaData functionMetaData, boolean delete)\n+            throws IllegalStateException, IllegalArgumentException {\n+        if (exclusiveLeaderProducer == null) {\n+            throw new IllegalStateException(\"Not the leader\");\n+        }\n+        boolean needsScheduling;\n+        if (delete) {\n+            needsScheduling = proccessDeregister(functionMetaData);\n+        } else {\n+            needsScheduling = processUpdate(functionMetaData);\n+        }\n+        Request.ServiceRequest serviceRequest = Request.ServiceRequest.newBuilder()\n+                .setServiceRequestType(delete ? Request.ServiceRequest.ServiceRequestType.DELETE : Request.ServiceRequest.ServiceRequestType.UPDATE)\n+                .setFunctionMetaData(functionMetaData)\n+                .setWorkerId(workerConfig.getWorkerId())\n+                .setRequestId(UUID.randomUUID().toString())\n+                .build();\n+        try {\n+            lastMessageSeen = exclusiveLeaderProducer.send(serviceRequest.toByteArray());\n+        } catch (Exception e) {\n+            log.error(\"Could not write into Function Metadata topic\", e);\n+            errorNotifier.triggerError(e);\n+        }\n+        if (needsScheduling) {\n+            this.schedulerManager.schedule();\n         }\n-\n-        FunctionMetaData newFunctionMetaData = FunctionMetaDataUtils.generateUpdatedMetadata(existingFunctionMetadata, functionMetaData);\n-\n-        Request.ServiceRequest updateRequest = ServiceRequestUtils.getUpdateRequest(\n-                this.workerConfig.getWorkerId(), newFunctionMetaData);\n-\n-        return submit(updateRequest);\n     }\n \n-\n     /**\n-     * Sends a deregister request to the FMT (Function Metadata Topic) for a function\n-     * @param tenant the tenant the function that needs to be deregistered belongs to\n-     * @param namespace the namespace the function that needs to be deregistered belongs to\n-     * @param functionName the name of the function\n-     * @return a completable future of when the deregister has been applied\n+     * Called by the leader service when this worker becomes the leader.\n+     * We first get exclusive producer on the metadata topic. Next we drain the tailer\n+     * to ensure that we have caught up to metadata topic. After which we close the tailer.\n+     * Note that this method cannot be syncrhonized because the tailer might still be processing messages\n      */\n-    public synchronized CompletableFuture<RequestResult> deregisterFunction(String tenant, String namespace, String functionName) {\n-        FunctionMetaData functionMetaData = this.functionMetaDataMap.get(tenant).get(namespace).get(functionName);\n-\n-        FunctionMetaData newFunctionMetaData = FunctionMetaDataUtils.generateUpdatedMetadata(functionMetaData, functionMetaData);\n-\n-        Request.ServiceRequest deregisterRequest = ServiceRequestUtils.getDeregisterRequest(\n-                this.workerConfig.getWorkerId(), newFunctionMetaData);\n+    public void acquireLeadership() {\n+        log.info(\"FunctionMetaDataManager becoming leader by creating exclusive producer\");\n+        FunctionMetaDataTopicTailer tailer = internalAcquireLeadership();\n+        // Now that we have created the exclusive producer, wait for reader to get over\n+        if (tailer != null) {\n+            try {\n+                tailer.stopWhenNoMoreMessages().get();\n+            } catch (Exception e) {\n+                log.error(\"Error while waiting for metadata tailer thread to finish\", e);\n+                errorNotifier.triggerError(e);\n+            }\n+            tailer.close();\n+        }\n+        this.schedulerManager.schedule();\n+        log.info(\"FunctionMetaDataManager done becoming leader by doing its first schedule\");\n+    }\n \n-        return submit(deregisterRequest);\n+    private synchronized FunctionMetaDataTopicTailer internalAcquireLeadership() {\n+        if (exclusiveLeaderProducer == null) {\n+            try {\n+                exclusiveLeaderProducer = pulsarClient.newProducer()\n+                        .topic(this.workerConfig.getFunctionMetadataTopic())\n+                        .producerName(workerConfig.getWorkerId() + \"-leader\")\n+                        // .type(EXCLUSIVE)\n+                        .create();\n+            } catch (PulsarClientException e) {\n+                log.error(\"Error creating exclusive producer\", e);\n+                errorNotifier.triggerError(e);\n+            }\n+        } else {\n+            log.error(\"Logic Error in FunctionMetaData Manager\");\n+            errorNotifier.triggerError(new IllegalStateException());\n+        }\n+        FunctionMetaDataTopicTailer tailer = this.functionMetaDataTopicTailer;\n+        this.functionMetaDataTopicTailer = null;\n+        return tailer;\n     }\n \n     /**\n-     * Sends a start/stop function request to the FMT (Function Metadata Topic) for a function\n-     * @param tenant the tenant the function that needs to be deregistered belongs to\n-     * @param namespace the namespace the function that needs to be deregistered belongs to\n-     * @param functionName the name of the function\n-     * @param instanceId the instanceId of the function, -1 if for all instances\n-     * @param start do we need to start or stop\n-     * @return a completable future of when the start/stop has been applied\n+     * called by the leader service when we lose leadership. We close the exclusive producer\n+     * and start the tailer.\n      */\n-    public synchronized CompletableFuture<RequestResult> changeFunctionInstanceStatus(String tenant, String namespace, String functionName,\n-                                                                                      Integer instanceId, boolean start) {\n-        FunctionMetaData functionMetaData = this.functionMetaDataMap.get(tenant).get(namespace).get(functionName);\n-\n-        FunctionMetaData newFunctionMetaData = FunctionMetaDataUtils.changeFunctionInstanceStatus(functionMetaData, instanceId, start);\n-\n-        Request.ServiceRequest updateRequest = ServiceRequestUtils.getUpdateRequest(\n-                this.workerConfig.getWorkerId(), newFunctionMetaData);\n-\n-        return submit(updateRequest);\n+    public synchronized void giveupLeadership() {\n+        log.info(\"FunctionMetaDataManager giving up leadership by closing exclusive producer\");\n+        try {\n+            exclusiveLeaderProducer.close();\n+            exclusiveLeaderProducer = null;\n+            initializeTailer();", "originalCommit": "f381eeeca5da48123d2d034de374919a0734cbd4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ5Mzg0OQ==", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r444493849", "bodyText": "That happens at start", "author": "srkukarni", "createdAt": "2020-06-23T20:41:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ2NTIwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU0OTk2MA==", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r444549960", "bodyText": "I don't quite follow.  In \"internalAcquireLeadership\" the tailer is closed.  When the worker loses leadership, where is the tailer getting started up again?", "author": "jerrypeng", "createdAt": "2020-06-23T22:48:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ2NTIwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ3MDU5MQ==", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r444470591", "bodyText": "To check if we have really reached the end of the topic, I think its safer if we check reader.hasMessageAvailable() == false and reader.readNext(5, TimeUnit.SECONDS) returns null.", "author": "jerrypeng", "createdAt": "2020-06-23T19:55:08Z", "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/FunctionMetaDataTopicTailer.java", "diffHunk": "@@ -54,19 +58,33 @@ public FunctionMetaDataTopicTailer(FunctionMetaDataManager functionMetaDataManag\n         readerThread = new Thread(this);\n         readerThread.setName(\"function-metadata-tailer-thread\");\n         this.errorNotifier = errorNotifier;\n+        stopOnNoMessageAvailable = false;\n     }\n \n     public void start() {\n         running = true;\n+        exitFuture = new CompletableFuture<>();\n         readerThread.start();\n     }\n \n     @Override\n     public void run() {\n-        while(running) {\n+        while (running) {", "originalCommit": "f381eeeca5da48123d2d034de374919a0734cbd4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ3OTk3Mw==", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r444479973", "bodyText": "Shouldn't we return a 500 error to the end user?  If we call just \"errorNotifier.triggerError(e)\", the worker die and the end user will likely not get a response or a timeout error", "author": "jerrypeng", "createdAt": "2020-06-23T20:13:36Z", "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/FunctionMetaDataManager.java", "diffHunk": "@@ -174,89 +181,124 @@ public synchronized boolean containsFunction(String tenant, String namespace, St\n     }\n \n     /**\n-     * Sends an update request to the FMT (Function Metadata Topic)\n-     * @param functionMetaData The function metadata that needs to be updated\n-     * @return a completable future of when the update has been applied\n+     * Called by the worker when we are in the leader mode.  In this state, we update our in-memory\n+     * data structures and then write to the metadata topic.\n+     * @param functionMetaData The function metadata in question\n+     * @param delete Is this a delete operation\n+     * @throws IllegalStateException if we are not the leader\n+     * @throws IllegalArgumentException if the request is out of date.\n      */\n-    public synchronized CompletableFuture<RequestResult> updateFunction(FunctionMetaData functionMetaData) {\n-\n-        FunctionMetaData existingFunctionMetadata = null;\n-        if (containsFunction(functionMetaData.getFunctionDetails().getTenant(),\n-                functionMetaData.getFunctionDetails().getNamespace(),\n-                functionMetaData.getFunctionDetails().getName())) {\n-            existingFunctionMetadata = getFunctionMetaData(functionMetaData.getFunctionDetails().getTenant(),\n-                    functionMetaData.getFunctionDetails().getNamespace(),\n-                    functionMetaData.getFunctionDetails().getName());\n+    public synchronized void updateFunctionOnLeader(FunctionMetaData functionMetaData, boolean delete)\n+            throws IllegalStateException, IllegalArgumentException {\n+        if (exclusiveLeaderProducer == null) {\n+            throw new IllegalStateException(\"Not the leader\");\n+        }\n+        boolean needsScheduling;\n+        if (delete) {\n+            needsScheduling = proccessDeregister(functionMetaData);\n+        } else {\n+            needsScheduling = processUpdate(functionMetaData);\n+        }\n+        Request.ServiceRequest serviceRequest = Request.ServiceRequest.newBuilder()\n+                .setServiceRequestType(delete ? Request.ServiceRequest.ServiceRequestType.DELETE : Request.ServiceRequest.ServiceRequestType.UPDATE)\n+                .setFunctionMetaData(functionMetaData)\n+                .setWorkerId(workerConfig.getWorkerId())\n+                .setRequestId(UUID.randomUUID().toString())\n+                .build();\n+        try {\n+            lastMessageSeen = exclusiveLeaderProducer.send(serviceRequest.toByteArray());\n+        } catch (Exception e) {", "originalCommit": "f381eeeca5da48123d2d034de374919a0734cbd4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ5NjUyMw==", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r444496523", "bodyText": "good point. Changed", "author": "srkukarni", "createdAt": "2020-06-23T20:46:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ3OTk3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU2MTkwMw==", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r444561903", "bodyText": "\"errorNotifier.triggerError(e);\" is still being called.  The worker might exit before exception gets bubbled up and a response send back", "author": "jerrypeng", "createdAt": "2020-06-23T23:25:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ3OTk3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI1NzIwOQ==", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r445257209", "bodyText": "@srkukarni ^^^", "author": "jerrypeng", "createdAt": "2020-06-25T01:23:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ3OTk3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI2NTM5Nw==", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r445265397", "bodyText": "So the question here is whats the right thing to do. If we are having issues to write into the producer, should the leader just reject the request saying Internal server error and hope that things will be better next time? Or is the right approach to trigger worker death?", "author": "srkukarni", "createdAt": "2020-06-25T01:56:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ3OTk3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTM0NjA3NQ==", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r445346075", "bodyText": "We should return the error to the worker making the call to the leader, otherwise the worker might have to wait for a timeout.  I think we should just return an error and the user can retry.  There is no guarantee that restarting the worker or electing another leader will help solve the issue since all the workers have the same configuration.  Restarting can also be heavy and I would prefer to minimize the amount of forced restarts as possible.", "author": "jerrypeng", "createdAt": "2020-06-25T06:59:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ3OTk3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ4MTQyNA==", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r444481424", "bodyText": "why do we need to synchronize this method?", "author": "jerrypeng", "createdAt": "2020-06-23T20:16:32Z", "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/FunctionMetaDataManager.java", "diffHunk": "@@ -174,89 +181,124 @@ public synchronized boolean containsFunction(String tenant, String namespace, St\n     }\n \n     /**\n-     * Sends an update request to the FMT (Function Metadata Topic)\n-     * @param functionMetaData The function metadata that needs to be updated\n-     * @return a completable future of when the update has been applied\n+     * Called by the worker when we are in the leader mode.  In this state, we update our in-memory\n+     * data structures and then write to the metadata topic.\n+     * @param functionMetaData The function metadata in question\n+     * @param delete Is this a delete operation\n+     * @throws IllegalStateException if we are not the leader\n+     * @throws IllegalArgumentException if the request is out of date.\n      */\n-    public synchronized CompletableFuture<RequestResult> updateFunction(FunctionMetaData functionMetaData) {\n-\n-        FunctionMetaData existingFunctionMetadata = null;\n-        if (containsFunction(functionMetaData.getFunctionDetails().getTenant(),\n-                functionMetaData.getFunctionDetails().getNamespace(),\n-                functionMetaData.getFunctionDetails().getName())) {\n-            existingFunctionMetadata = getFunctionMetaData(functionMetaData.getFunctionDetails().getTenant(),\n-                    functionMetaData.getFunctionDetails().getNamespace(),\n-                    functionMetaData.getFunctionDetails().getName());\n+    public synchronized void updateFunctionOnLeader(FunctionMetaData functionMetaData, boolean delete)\n+            throws IllegalStateException, IllegalArgumentException {\n+        if (exclusiveLeaderProducer == null) {\n+            throw new IllegalStateException(\"Not the leader\");\n+        }\n+        boolean needsScheduling;\n+        if (delete) {\n+            needsScheduling = proccessDeregister(functionMetaData);\n+        } else {\n+            needsScheduling = processUpdate(functionMetaData);\n+        }\n+        Request.ServiceRequest serviceRequest = Request.ServiceRequest.newBuilder()\n+                .setServiceRequestType(delete ? Request.ServiceRequest.ServiceRequestType.DELETE : Request.ServiceRequest.ServiceRequestType.UPDATE)\n+                .setFunctionMetaData(functionMetaData)\n+                .setWorkerId(workerConfig.getWorkerId())\n+                .setRequestId(UUID.randomUUID().toString())\n+                .build();\n+        try {\n+            lastMessageSeen = exclusiveLeaderProducer.send(serviceRequest.toByteArray());\n+        } catch (Exception e) {\n+            log.error(\"Could not write into Function Metadata topic\", e);\n+            errorNotifier.triggerError(e);\n+        }\n+        if (needsScheduling) {\n+            this.schedulerManager.schedule();\n         }\n-\n-        FunctionMetaData newFunctionMetaData = FunctionMetaDataUtils.generateUpdatedMetadata(existingFunctionMetadata, functionMetaData);\n-\n-        Request.ServiceRequest updateRequest = ServiceRequestUtils.getUpdateRequest(\n-                this.workerConfig.getWorkerId(), newFunctionMetaData);\n-\n-        return submit(updateRequest);\n     }\n \n-\n     /**\n-     * Sends a deregister request to the FMT (Function Metadata Topic) for a function\n-     * @param tenant the tenant the function that needs to be deregistered belongs to\n-     * @param namespace the namespace the function that needs to be deregistered belongs to\n-     * @param functionName the name of the function\n-     * @return a completable future of when the deregister has been applied\n+     * Called by the leader service when this worker becomes the leader.\n+     * We first get exclusive producer on the metadata topic. Next we drain the tailer\n+     * to ensure that we have caught up to metadata topic. After which we close the tailer.\n+     * Note that this method cannot be syncrhonized because the tailer might still be processing messages\n      */\n-    public synchronized CompletableFuture<RequestResult> deregisterFunction(String tenant, String namespace, String functionName) {\n-        FunctionMetaData functionMetaData = this.functionMetaDataMap.get(tenant).get(namespace).get(functionName);\n-\n-        FunctionMetaData newFunctionMetaData = FunctionMetaDataUtils.generateUpdatedMetadata(functionMetaData, functionMetaData);\n-\n-        Request.ServiceRequest deregisterRequest = ServiceRequestUtils.getDeregisterRequest(\n-                this.workerConfig.getWorkerId(), newFunctionMetaData);\n+    public void acquireLeadership() {\n+        log.info(\"FunctionMetaDataManager becoming leader by creating exclusive producer\");\n+        FunctionMetaDataTopicTailer tailer = internalAcquireLeadership();\n+        // Now that we have created the exclusive producer, wait for reader to get over\n+        if (tailer != null) {\n+            try {\n+                tailer.stopWhenNoMoreMessages().get();\n+            } catch (Exception e) {\n+                log.error(\"Error while waiting for metadata tailer thread to finish\", e);\n+                errorNotifier.triggerError(e);\n+            }\n+            tailer.close();\n+        }\n+        this.schedulerManager.schedule();\n+        log.info(\"FunctionMetaDataManager done becoming leader by doing its first schedule\");\n+    }\n \n-        return submit(deregisterRequest);\n+    private synchronized FunctionMetaDataTopicTailer internalAcquireLeadership() {", "originalCommit": "f381eeeca5da48123d2d034de374919a0734cbd4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ5NjM0MA==", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r444496340", "bodyText": "Because there could be other updates to functions going on.", "author": "srkukarni", "createdAt": "2020-06-23T20:45:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ4MTQyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU0MTg4MA==", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r444541880", "bodyText": "How could that happen? internalAcquireLeadership() is only called in acquireLeadership() which is only called in becomeActive() which is synchronized.", "author": "jerrypeng", "createdAt": "2020-06-23T22:24:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ4MTQyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI1NzMwNA==", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r445257304", "bodyText": "@srkukarni ^^^", "author": "jerrypeng", "createdAt": "2020-06-25T01:23:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ4MTQyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI2NzM4MQ==", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r445267381", "bodyText": "The becomeActive is synchronized on the LeaderService Object. This method is sync on the MetaDataManager object. Having sync here will prevent other parts like metadatatailer from interfering with internal structures.", "author": "srkukarni", "createdAt": "2020-06-25T02:03:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ4MTQyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ4MzY4Mw==", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r444483683", "bodyText": "It is kind of confusing to be calling \"processFunctionUpdate\" in de-register routine since we also have a update function routine. Maybe rename the method to something else?  \"processFunctionRequest\"?", "author": "jerrypeng", "createdAt": "2020-06-23T20:20:51Z", "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/rest/api/ComponentImpl.java", "diffHunk": "@@ -392,24 +392,13 @@ public void deregisterFunction(final String tenant,\n             throw new RestException(Status.NOT_FOUND, String.format(\"%s %s doesn't exist\", ComponentTypeUtils.toString(componentType), componentName));\n         }\n \n-        CompletableFuture<RequestResult> completableFuture = functionMetaDataManager.deregisterFunction(tenant,\n-                namespace, componentName);\n-\n-        RequestResult requestResult = null;\n-        try {\n-            requestResult = completableFuture.get();\n-            if (!requestResult.isSuccess()) {\n-                throw new RestException(Status.BAD_REQUEST, requestResult.getMessage());\n-            }\n-        } catch (ExecutionException e) {\n-            log.error(\"Execution Exception while deregistering {} @ /{}/{}/{}\",\n-                    ComponentTypeUtils.toString(componentType), tenant, namespace, componentName, e);\n-            throw new RestException(Status.INTERNAL_SERVER_ERROR, e.getCause().getMessage());\n-        } catch (InterruptedException e) {\n-            log.error(\"Interrupted Exception while deregistering {} @ /{}/{}/{}\",\n-                    ComponentTypeUtils.toString(componentType), tenant, namespace, componentName, e);\n-            throw new RestException(Status.REQUEST_TIMEOUT, e.getMessage());\n-        }\n+        FunctionMetaData newVersionedMetaData = FunctionMetaDataUtils.generateUpdatedMetadata(functionMetaData, functionMetaData);\n+        processFunctionUpdate(newVersionedMetaData.getFunctionDetails().getTenant(),", "originalCommit": "f381eeeca5da48123d2d034de374919a0734cbd4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ5NzE4NQ==", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r444497185", "bodyText": "changed to internalProcessFunctionRequest", "author": "srkukarni", "createdAt": "2020-06-23T20:47:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ4MzY4Mw=="}], "type": "inlineReview"}, {"oid": "43eaf86d1a503ee7aa7eead8772b878dc4652379", "url": "https://github.com/apache/pulsar/commit/43eaf86d1a503ee7aa7eead8772b878dc4652379", "message": "Throw error", "committedDate": "2020-06-23T20:46:07Z", "type": "commit"}, {"oid": "c28e1224402c8a51a2eca0e93602b0f753ff2b03", "url": "https://github.com/apache/pulsar/commit/c28e1224402c8a51a2eca0e93602b0f753ff2b03", "message": "Changed name", "committedDate": "2020-06-23T20:47:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU1MTM4NA==", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r444551384", "bodyText": "Can we rename \" FunctionMetaDataUtils.generateUpdatedMetadata\" to something like  \"FunctionMetaDataUtils.incrMetadataVersion\"", "author": "jerrypeng", "createdAt": "2020-06-23T22:52:47Z", "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/rest/api/ComponentImpl.java", "diffHunk": "@@ -392,24 +391,13 @@ public void deregisterFunction(final String tenant,\n             throw new RestException(Status.NOT_FOUND, String.format(\"%s %s doesn't exist\", ComponentTypeUtils.toString(componentType), componentName));\n         }\n \n-        CompletableFuture<RequestResult> completableFuture = functionMetaDataManager.deregisterFunction(tenant,\n-                namespace, componentName);\n-\n-        RequestResult requestResult = null;\n-        try {\n-            requestResult = completableFuture.get();\n-            if (!requestResult.isSuccess()) {\n-                throw new RestException(Status.BAD_REQUEST, requestResult.getMessage());\n-            }\n-        } catch (ExecutionException e) {\n-            log.error(\"Execution Exception while deregistering {} @ /{}/{}/{}\",\n-                    ComponentTypeUtils.toString(componentType), tenant, namespace, componentName, e);\n-            throw new RestException(Status.INTERNAL_SERVER_ERROR, e.getCause().getMessage());\n-        } catch (InterruptedException e) {\n-            log.error(\"Interrupted Exception while deregistering {} @ /{}/{}/{}\",\n-                    ComponentTypeUtils.toString(componentType), tenant, namespace, componentName, e);\n-            throw new RestException(Status.REQUEST_TIMEOUT, e.getMessage());\n-        }\n+        FunctionMetaData newVersionedMetaData = FunctionMetaDataUtils.generateUpdatedMetadata(functionMetaData, functionMetaData);", "originalCommit": "c28e1224402c8a51a2eca0e93602b0f753ff2b03", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU1MzE3Mg==", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r444553172", "bodyText": "Changed", "author": "srkukarni", "createdAt": "2020-06-23T22:58:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU1MTM4NA=="}], "type": "inlineReview"}, {"oid": "fb86d0a49fa92eff08726a399db825e4783fc3b9", "url": "https://github.com/apache/pulsar/commit/fb86d0a49fa92eff08726a399db825e4783fc3b9", "message": "address comments", "committedDate": "2020-06-23T22:58:06Z", "type": "commit"}, {"oid": "a61e6748bda039235b1d95b34367468d7a4135aa", "url": "https://github.com/apache/pulsar/commit/a61e6748bda039235b1d95b34367468d7a4135aa", "message": "Deleted unused classes", "committedDate": "2020-06-24T05:49:11Z", "type": "commit"}, {"oid": "d7196264acd6f6e6995726b9a0a4aa11abe26678", "url": "https://github.com/apache/pulsar/commit/d7196264acd6f6e6995726b9a0a4aa11abe26678", "message": "Rework metadata manager", "committedDate": "2020-06-24T18:33:23Z", "type": "commit"}, {"oid": "3b824e9e881c90902787290475416a6b9076f54b", "url": "https://github.com/apache/pulsar/commit/3b824e9e881c90902787290475416a6b9076f54b", "message": "Working", "committedDate": "2020-06-24T21:24:53Z", "type": "commit"}, {"oid": "c5328d14af689f3763344f5c7642ec1957cbc6ea", "url": "https://github.com/apache/pulsar/commit/c5328d14af689f3763344f5c7642ec1957cbc6ea", "message": "Fix test", "committedDate": "2020-06-24T22:07:06Z", "type": "commit"}, {"oid": "abed1f756f6abb92b718a1ce7aea733d14413272", "url": "https://github.com/apache/pulsar/commit/abed1f756f6abb92b718a1ce7aea733d14413272", "message": "A better way for test", "committedDate": "2020-06-24T22:50:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI1OTE2Ng==", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r445259166", "bodyText": "couldn't there be a race condition between here and \"start()\" where you are relying on whether exclusiveLeaderProducer is null or not.  \"acquireLeadership()\" is called by the \"becomeActive\" which is using the client listener thread while \"start()\" is executed by the worker \"main\" thread", "author": "jerrypeng", "createdAt": "2020-06-25T01:30:50Z", "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/FunctionMetaDataManager.java", "diffHunk": "@@ -174,89 +188,127 @@ public synchronized boolean containsFunction(String tenant, String namespace, St\n     }\n \n     /**\n-     * Sends an update request to the FMT (Function Metadata Topic)\n-     * @param functionMetaData The function metadata that needs to be updated\n-     * @return a completable future of when the update has been applied\n+     * Called by the worker when we are in the leader mode.  In this state, we update our in-memory\n+     * data structures and then write to the metadata topic.\n+     * @param functionMetaData The function metadata in question\n+     * @param delete Is this a delete operation\n+     * @throws IllegalStateException if we are not the leader\n+     * @throws IllegalArgumentException if the request is out of date.\n      */\n-    public synchronized CompletableFuture<RequestResult> updateFunction(FunctionMetaData functionMetaData) {\n-\n-        FunctionMetaData existingFunctionMetadata = null;\n-        if (containsFunction(functionMetaData.getFunctionDetails().getTenant(),\n-                functionMetaData.getFunctionDetails().getNamespace(),\n-                functionMetaData.getFunctionDetails().getName())) {\n-            existingFunctionMetadata = getFunctionMetaData(functionMetaData.getFunctionDetails().getTenant(),\n-                    functionMetaData.getFunctionDetails().getNamespace(),\n-                    functionMetaData.getFunctionDetails().getName());\n+    public synchronized void updateFunctionOnLeader(FunctionMetaData functionMetaData, boolean delete)\n+            throws IllegalStateException, IllegalArgumentException {\n+        if (exclusiveLeaderProducer == null) {\n+            throw new IllegalStateException(\"Not the leader\");\n+        }\n+        boolean needsScheduling;\n+        if (delete) {\n+            needsScheduling = proccessDeregister(functionMetaData);\n+        } else {\n+            needsScheduling = processUpdate(functionMetaData);\n+        }\n+        Request.ServiceRequest serviceRequest = Request.ServiceRequest.newBuilder()\n+                .setServiceRequestType(delete ? Request.ServiceRequest.ServiceRequestType.DELETE : Request.ServiceRequest.ServiceRequestType.UPDATE)\n+                .setFunctionMetaData(functionMetaData)\n+                .setWorkerId(workerConfig.getWorkerId())\n+                .setRequestId(UUID.randomUUID().toString())\n+                .build();\n+        try {\n+            lastMessageSeen = exclusiveLeaderProducer.send(serviceRequest.toByteArray());\n+        } catch (Exception e) {\n+            log.error(\"Could not write into Function Metadata topic\", e);\n+            errorNotifier.triggerError(e);\n+            throw new IllegalStateException(\"Internal Error updating function at the leader\", e);\n+        }\n+        if (needsScheduling) {\n+            this.schedulerManager.schedule();\n         }\n-\n-        FunctionMetaData newFunctionMetaData = FunctionMetaDataUtils.generateUpdatedMetadata(existingFunctionMetadata, functionMetaData);\n-\n-        Request.ServiceRequest updateRequest = ServiceRequestUtils.getUpdateRequest(\n-                this.workerConfig.getWorkerId(), newFunctionMetaData);\n-\n-        return submit(updateRequest);\n     }\n \n-\n     /**\n-     * Sends a deregister request to the FMT (Function Metadata Topic) for a function\n-     * @param tenant the tenant the function that needs to be deregistered belongs to\n-     * @param namespace the namespace the function that needs to be deregistered belongs to\n-     * @param functionName the name of the function\n-     * @return a completable future of when the deregister has been applied\n+     * Called by the leader service when this worker becomes the leader.\n+     * We first get exclusive producer on the metadata topic. Next we drain the tailer\n+     * to ensure that we have caught up to metadata topic. After which we close the tailer.\n+     * Note that this method cannot be syncrhonized because the tailer might still be processing messages\n      */\n-    public synchronized CompletableFuture<RequestResult> deregisterFunction(String tenant, String namespace, String functionName) {\n-        FunctionMetaData functionMetaData = this.functionMetaDataMap.get(tenant).get(namespace).get(functionName);\n-\n-        FunctionMetaData newFunctionMetaData = FunctionMetaDataUtils.generateUpdatedMetadata(functionMetaData, functionMetaData);\n-\n-        Request.ServiceRequest deregisterRequest = ServiceRequestUtils.getDeregisterRequest(\n-                this.workerConfig.getWorkerId(), newFunctionMetaData);\n+    public void acquireLeadership() {\n+        log.info(\"FunctionMetaDataManager becoming leader by creating exclusive producer\");\n+        FunctionMetaDataTopicTailer tailer = internalAcquireLeadership();\n+        // Now that we have created the exclusive producer, wait for reader to get over\n+        if (tailer != null) {\n+            try {\n+                tailer.stopWhenNoMoreMessages().get();\n+            } catch (Exception e) {\n+                log.error(\"Error while waiting for metadata tailer thread to finish\", e);\n+                errorNotifier.triggerError(e);\n+            }\n+            tailer.close();\n+        }\n+        log.info(\"FunctionMetaDataManager done becoming leader\");\n+    }\n \n-        return submit(deregisterRequest);\n+    private synchronized FunctionMetaDataTopicTailer internalAcquireLeadership() {\n+        if (exclusiveLeaderProducer == null) {\n+            try {\n+                exclusiveLeaderProducer = pulsarClient.newProducer()", "originalCommit": "abed1f756f6abb92b718a1ce7aea733d14413272", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI2MDY5NA==", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r445260694", "bodyText": "nvm", "author": "jerrypeng", "createdAt": "2020-06-25T01:37:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI1OTE2Ng=="}], "type": "inlineReview"}, {"oid": "7bb5bc0222903b30aeeb7c01afadf6a390925bab", "url": "https://github.com/apache/pulsar/commit/7bb5bc0222903b30aeeb7c01afadf6a390925bab", "message": "Address feedback", "committedDate": "2020-06-25T17:45:06Z", "type": "commit"}, {"oid": "97094788e52baabacea2110228adf54bf6e9ce2d", "url": "https://github.com/apache/pulsar/commit/97094788e52baabacea2110228adf54bf6e9ce2d", "message": "Merge branch 'master' into functions_leader_executor", "committedDate": "2020-06-25T21:53:46Z", "type": "commit"}]}