{"pr_number": 7818, "pr_title": "Support MaxUnackedMessagesOnConsumer on topic level", "pr_createdAt": "2020-08-14T07:34:54Z", "pr_url": "https://github.com/apache/pulsar/pull/7818", "timeline": [{"oid": "cad634520cd84efd9d7431b7e221906e812d6d72", "url": "https://github.com/apache/pulsar/commit/cad634520cd84efd9d7431b7e221906e812d6d72", "message": "support MaxUnackedMessagesOnConsumer", "committedDate": "2020-08-13T15:17:25Z", "type": "commit"}, {"oid": "9da33f6b44c47c65098a1c9078f0b22f145aedfd", "url": "https://github.com/apache/pulsar/commit/9da33f6b44c47c65098a1c9078f0b22f145aedfd", "message": "change unit test", "committedDate": "2020-08-14T08:40:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYyNDkzMQ==", "url": "https://github.com/apache/pulsar/pull/7818#discussion_r470624931", "bodyText": "minor: remove asyncResponse on setMaxUnackedMessagesOnConsumer", "author": "jianyun8023", "createdAt": "2020-08-14T13:31:25Z", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/v2/PersistentTopics.java", "diffHunk": "@@ -250,6 +250,69 @@ public void createNonPartitionedTopic(\n         internalCreateNonPartitionedTopic(authoritative);\n     }\n \n+    @GET\n+    @Path(\"/{tenant}/{namespace}/{topic}/maxUnackedMessagesOnConsumer\")\n+    @ApiOperation(value = \"Get max unacked messages per consumer config on a topic.\")\n+    @ApiResponses(value = {@ApiResponse(code = 403, message = \"Don't have admin permission\"),\n+            @ApiResponse(code = 404, message = \"Tenant or cluster or namespace or topic doesn't exist\"),\n+            @ApiResponse(code = 500, message = \"Internal server error\"),})\n+    public void getMaxUnackedMessagesOnConsumer(@Suspended final AsyncResponse asyncResponse,\n+                                                    @PathParam(\"tenant\") String tenant,\n+                                                    @PathParam(\"namespace\") String namespace,\n+                                                    @PathParam(\"topic\") @Encoded String encodedTopic) {\n+        validateTopicName(tenant, namespace, encodedTopic);\n+        TopicPolicies topicPolicies = getTopicPolicies(topicName).orElse(new TopicPolicies());\n+        if (topicPolicies.isMaxUnackedMessagesOnConsumerSet()) {\n+            asyncResponse.resume(topicPolicies.getMaxUnackedMessagesOnConsumer());\n+        } else {\n+            asyncResponse.resume(Response.noContent().build());\n+        }\n+    }\n+\n+    @POST\n+    @Path(\"/{tenant}/{namespace}/{topic}/maxUnackedMessagesOnConsumer\")\n+    @ApiOperation(value = \"Set max unacked messages per consumer config on a topic.\")\n+    @ApiResponses(value = {@ApiResponse(code = 403, message = \"Don't have admin permission\"),\n+            @ApiResponse(code = 404, message = \"Tenant or cluster or namespace or topic doesn't exist\"),})\n+    public void setMaxUnackedMessagesOnConsumer(@Suspended final AsyncResponse asyncResponse,\n+                                                    @PathParam(\"tenant\") String tenant,\n+                                                    @PathParam(\"namespace\") String namespace,\n+                                                    @PathParam(\"topic\") @Encoded String encodedTopic,\n+                                                    @ApiParam(value = \"Max unacked messages on consumer policies for the specified topic\")\n+                                                            Integer maxUnackedNum) {\n+        validateTopicName(tenant, namespace, encodedTopic);\n+        validateAdminAccessForTenant(tenant);\n+        validatePoliciesReadOnlyAccess();\n+        checkTopicLevelPolicyEnable();\n+        if (topicName.isGlobal()) {\n+            validateGlobalNamespaceOwnership(namespaceName);\n+        }\n+        internalSetMaxUnackedMessagesOnConsumer(maxUnackedNum).whenComplete((res, ex) -> {\n+            if (ex instanceof RestException) {\n+                log.error(\"Failed set MaxUnackedMessagesOnConsumer\", ex);\n+                asyncResponse.resume(ex);\n+            } else if (ex != null) {\n+                log.error(\"Failed set MaxUnackedMessagesOnConsumer\", ex);\n+                asyncResponse.resume(new RestException(ex));\n+            } else {\n+                asyncResponse.resume(Response.noContent().build());\n+            }\n+        });\n+    }\n+\n+    @DELETE\n+    @Path(\"/{tenant}/{namespace}/{topic}/maxUnackedMessagesOnConsumer\")\n+    @ApiOperation(value = \"Delete max unacked messages per consumer config on a topic.\")\n+    @ApiResponses(value = {@ApiResponse(code = 403, message = \"Don't have admin permission\"),\n+            @ApiResponse(code = 404, message = \"Tenant or cluster or namespace or topic doesn't exist\"),})\n+    public void deleteMaxUnackedMessagesOnConsumer(@Suspended final AsyncResponse asyncResponse,\n+                                                       @PathParam(\"tenant\") String tenant,\n+                                                       @PathParam(\"namespace\") String namespace,\n+                                                       @PathParam(\"topic\") @Encoded String encodedTopic) {\n+        validateTopicName(tenant, namespace, encodedTopic);\n+        setMaxUnackedMessagesOnConsumer(asyncResponse, tenant, namespace, encodedTopic, null);", "originalCommit": "9da33f6b44c47c65098a1c9078f0b22f145aedfd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY2MzU3MA==", "url": "https://github.com/apache/pulsar/pull/7818#discussion_r470663570", "bodyText": "emm...I am a little confused that all previous set methods have asyncResponse,such as setBacklogQuota\u3001setMessageTTL\u3001setRetention...\nIs it better to be consistent? @jianyun8023", "author": "315157973", "createdAt": "2020-08-14T14:38:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYyNDkzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDk3Mjc3Nw==", "url": "https://github.com/apache/pulsar/pull/7818#discussion_r470972777", "bodyText": "@jianyun8023 would you please explain a little more of your reason for asyncResponse?\nWe need asyncResponse to make the request async.", "author": "jiazhai", "createdAt": "2020-08-15T12:27:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYyNDkzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDk5MDYyNg==", "url": "https://github.com/apache/pulsar/pull/7818#discussion_r470990626", "bodyText": "Modify this method, remove the parameter asyncResponse, and modify the return  to CompletableFuture<Void>", "author": "jianyun8023", "createdAt": "2020-08-15T13:50:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYyNDkzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDk5NDgwOA==", "url": "https://github.com/apache/pulsar/pull/7818#discussion_r470994808", "bodyText": "Modify this method, remove the parameter asyncResponse, and modify the return to CompletableFuture<Void>\n\nIs it a mistake? This is not an internal method. Please take a look. @jianyun8023", "author": "315157973", "createdAt": "2020-08-15T14:17:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYyNDkzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDk5NDg2Mg==", "url": "https://github.com/apache/pulsar/pull/7818#discussion_r470994862", "bodyText": "internalSetMaxUnackedMessagesOnConsumer already returns CompletableFuture", "author": "315157973", "createdAt": "2020-08-15T14:18:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYyNDkzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDk5NTQ4OQ==", "url": "https://github.com/apache/pulsar/pull/7818#discussion_r470995489", "bodyText": "I'm sorry, I made a mistake.", "author": "jianyun8023", "createdAt": "2020-08-15T14:25:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYyNDkzMQ=="}], "type": "inlineReview"}]}