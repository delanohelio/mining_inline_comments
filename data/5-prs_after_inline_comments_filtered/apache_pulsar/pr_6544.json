{"pr_number": 6544, "pr_title": "Implementation of Transaction Buffer Client.", "pr_createdAt": "2020-03-17T00:10:39Z", "pr_url": "https://github.com/apache/pulsar/pull/6544", "timeline": [{"oid": "b318862d6140d57ab3c4e013896a47a414653995", "url": "https://github.com/apache/pulsar/commit/b318862d6140d57ab3c4e013896a47a414653995", "message": "Implementation of Transaction Buffer Client.", "committedDate": "2020-03-19T13:42:44Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjI1OTU3OQ==", "url": "https://github.com/apache/pulsar/pull/6544#discussion_r396259579", "bodyText": "It is time out, so timeTowaitMs  shouldn't  =  operationTimeoutInMills", "author": "congbobo184", "createdAt": "2020-03-23T07:46:59Z", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/transaction/buffer/impl/TransactionBufferHandlerImpl.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.transaction.buffer.impl;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.util.HashedWheelTimer;\n+import io.netty.util.Recycler;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.Timeout;\n+import io.netty.util.TimerTask;\n+import io.netty.util.concurrent.DefaultThreadFactory;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.pulsar.broker.namespace.NamespaceService;\n+import org.apache.pulsar.client.api.transaction.TransactionBufferClientException;\n+import org.apache.pulsar.client.impl.ClientCnx;\n+import org.apache.pulsar.client.impl.ConnectionPool;\n+import org.apache.pulsar.common.api.proto.PulsarApi;\n+import org.apache.pulsar.common.naming.TopicName;\n+import org.apache.pulsar.common.protocol.Commands;\n+import org.apache.pulsar.client.impl.transaction.TransactionBufferHandler;\n+import org.apache.pulsar.common.util.FutureUtil;\n+import org.apache.pulsar.transaction.impl.common.TxnID;\n+\n+import java.net.InetSocketAddress;\n+import java.net.URI;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+@Slf4j\n+public class TransactionBufferHandlerImpl implements TransactionBufferHandler, TimerTask {\n+\n+    private final ConcurrentSkipListMap<Long, OpRequestSend> pendingRequests;\n+    private final ConnectionPool connectionPool;\n+    private final NamespaceService namespaceService;\n+    private final AtomicLong requestIdGenerator = new AtomicLong();\n+    private long operationTimeoutInMills;\n+    private Timeout requestTimeout;\n+    private HashedWheelTimer timer;\n+    private final Semaphore semaphore;\n+    private final boolean blockIfReachMaxPendingOps;\n+\n+    public TransactionBufferHandlerImpl(ConnectionPool connectionPool, NamespaceService namespaceService) {\n+        this.connectionPool = connectionPool;\n+        this.pendingRequests = new ConcurrentSkipListMap<>();\n+        this.namespaceService = namespaceService;\n+        this.operationTimeoutInMills = 3000L;\n+        this.semaphore = new Semaphore(10000);\n+        this.blockIfReachMaxPendingOps = true;\n+        this.timer = new HashedWheelTimer(new DefaultThreadFactory(\"pulsar-transaction-buffer-client-timer\"));\n+        this.requestTimeout = timer.newTimeout(this, operationTimeoutInMills, TimeUnit.MILLISECONDS);\n+    }\n+\n+    @Override\n+    public CompletableFuture<TxnID> endTxnOnTopic(String topic, long txnIdMostBits, long txnIdLeastBits, PulsarApi.TxnAction action) {\n+        CompletableFuture<TxnID> cb = new CompletableFuture<>();\n+        if (!canSendRequest(cb)) {\n+            return cb;\n+        }\n+        long requestId = requestIdGenerator.getAndIncrement();\n+        ByteBuf cmd = Commands.newEndTxnOnPartition(requestId, txnIdLeastBits, txnIdMostBits, topic, action);\n+        OpRequestSend op = OpRequestSend.create(requestId, topic, cmd, cb);\n+        pendingRequests.put(requestId, op);\n+        cmd.retain();\n+        cnx(topic).whenComplete((clientCnx, throwable) -> {\n+            if (throwable == null) {\n+                try {\n+                    clientCnx.ctx().writeAndFlush(cmd, clientCnx.ctx().voidPromise());\n+                } catch (Exception e) {\n+                    cb.completeExceptionally(e);\n+                    pendingRequests.remove(requestId);\n+                    op.recycle();\n+                }\n+            } else {\n+                cb.completeExceptionally(throwable);\n+                pendingRequests.remove(requestId);\n+                op.recycle();\n+            }\n+        });\n+        return cb;\n+    }\n+\n+    @Override\n+    public CompletableFuture<TxnID> endTxnOnSubscription(String topic, String subscription, long txnIdMostBits, long txnIdLeastBits, PulsarApi.TxnAction action) {\n+        CompletableFuture<TxnID> cb = new CompletableFuture<>();\n+        if (!canSendRequest(cb)) {\n+            return cb;\n+        }\n+        long requestId = requestIdGenerator.getAndIncrement();\n+        ByteBuf cmd = Commands.newEndTxnOnSubscription(requestId, txnIdLeastBits, txnIdMostBits, topic, subscription, action);\n+        OpRequestSend op = OpRequestSend.create(requestId, topic, cmd, cb);\n+        pendingRequests.put(requestId, op);\n+        cmd.retain();\n+        cnx(topic).whenComplete((clientCnx, throwable) -> {\n+            if (throwable == null) {\n+                try {\n+                    clientCnx.ctx().writeAndFlush(cmd, clientCnx.ctx().voidPromise());\n+                } catch (Exception e) {\n+                    cb.completeExceptionally(e);\n+                    pendingRequests.remove(requestId);\n+                    op.recycle();\n+                }\n+            } else {\n+                cb.completeExceptionally(throwable);\n+                pendingRequests.remove(requestId);\n+                op.recycle();\n+            }\n+        });\n+        return cb;\n+    }\n+\n+    @Override\n+    public void handleEndTxnOnTopicResponse(long requestId, PulsarApi.CommandEndTxnOnPartitionResponse response) {\n+        OpRequestSend op = pendingRequests.remove(requestId);\n+        if (op == null) {\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Got end txn on topic response for timeout {} - {}\", response.getTxnidMostBits(),\n+                        response.getTxnidLeastBits());\n+            }\n+            return;\n+        }\n+\n+        if (!response.hasError()) {\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"[{}] Got end txn on topic response for for request {}\", op.topic, response.getRequestId());\n+            }\n+            op.cb.complete(new TxnID(response.getTxnidMostBits(), response.getTxnidLeastBits()));\n+        } else {\n+            log.error(\"[{}] Got end txn on topic response for request {} error {}\", op.topic, response.getRequestId(), response.getError());\n+            op.cb.completeExceptionally(getException(response.getError(), response.getMessage()));\n+        }\n+        op.recycle();\n+    }\n+\n+    @Override\n+    public void handleEndTxnOnSubscriptionResponse(long requestId, PulsarApi.CommandEndTxnOnSubscriptionResponse response) {\n+        OpRequestSend op = pendingRequests.remove(requestId);\n+        if (op == null) {\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Got end txn on subscription response for timeout {} - {}\", response.getTxnidMostBits(),\n+                        response.getTxnidLeastBits());\n+            }\n+            return;\n+        }\n+\n+        if (!response.hasError()) {\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"[{}] Got end txn on subscription response for for request {}\", op.topic, response.getRequestId());\n+            }\n+            op.cb.complete(new TxnID(response.getTxnidMostBits(), response.getTxnidLeastBits()));\n+        } else {\n+            log.error(\"[{}] Got end txn on subscription response for request {} error {}\", op.topic, response.getRequestId(), response.getError());\n+            op.cb.completeExceptionally(getException(response.getError(), response.getMessage()));\n+        }\n+        op.recycle();\n+    }\n+\n+    private CompletableFuture<ClientCnx> cnx(String topic) {\n+        return getServiceUrl(topic).thenCompose(serviceUrl -> {\n+            try {\n+                if (serviceUrl == null) {\n+                    return CompletableFuture.completedFuture(null);\n+                }\n+                URI uri = new URI(serviceUrl);\n+                return connectionPool.getConnection(InetSocketAddress.createUnresolved(uri.getHost(), uri.getPort())).thenCompose(clientCnx -> {\n+                    clientCnx.registerTransactionBufferHandler(TransactionBufferHandlerImpl.this);\n+                    return CompletableFuture.completedFuture(clientCnx);\n+                });\n+            } catch (Exception e) {\n+                return FutureUtil.failedFuture(e);\n+            }\n+        });\n+    }\n+\n+    private CompletableFuture<String> getServiceUrl(String topic) {\n+        TopicName topicName = TopicName.get(topic);\n+        return namespaceService.getBundleAsync(topicName)\n+                .thenCompose(namespaceService::getOwnerAsync)\n+                .thenCompose(ned -> {\n+                    String serviceUrl = null;\n+                    if (ned.isPresent()) {\n+                        serviceUrl = ned.get().getNativeUrl();\n+                    }\n+                   return CompletableFuture.completedFuture(serviceUrl);\n+                });\n+    }\n+\n+    private TransactionBufferClientException getException(PulsarApi.ServerError serverError, String msg) {\n+        return new TransactionBufferClientException(msg);\n+    }\n+\n+    private boolean canSendRequest(CompletableFuture<?> callback) {\n+        try {\n+            if (blockIfReachMaxPendingOps) {\n+                semaphore.acquire();\n+            } else {\n+                if (!semaphore.tryAcquire()) {\n+                    callback.completeExceptionally(new TransactionBufferClientException(\"Reach max pending ops.\"));\n+                    return false;\n+                }\n+            }\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+            callback.completeExceptionally(TransactionBufferClientException.unwrap(e));\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public void run(Timeout timeout) throws Exception {\n+        if (timeout.isCancelled()) {\n+            return;\n+        }\n+        long timeToWaitMs;\n+        OpRequestSend peeked = null;\n+        Map.Entry<Long, OpRequestSend> firstEntry = pendingRequests.firstEntry();\n+        peeked = firstEntry == null ? null : firstEntry.getValue();\n+        while (peeked != null && peeked.createdAt + operationTimeoutInMills - System.currentTimeMillis() <= 0) {\n+            if (!peeked.cb.isDone()) {\n+                peeked.cb.completeExceptionally(new TransactionBufferClientException.RequestTimeoutException());\n+                onResponse(peeked);\n+            } else {\n+                break;\n+            }\n+            firstEntry = pendingRequests.firstEntry();\n+            peeked = firstEntry == null ? null : firstEntry.getValue();\n+        }\n+        if (peeked == null) {\n+            timeToWaitMs = operationTimeoutInMills;\n+        } else {\n+            long diff = (peeked.createdAt + operationTimeoutInMills) - System.currentTimeMillis();\n+            if (diff <= 0) {\n+                timeToWaitMs = operationTimeoutInMills;", "originalCommit": "5d7e81611b92ce7c06e04875f7c3fc28f57c4d60", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMyODEwNw==", "url": "https://github.com/apache/pulsar/pull/6544#discussion_r396328107", "bodyText": "I think  clientCnx.ctx().writeAndFlush(cmd, clientCnx.ctx().voidPromise());  should .addListener", "author": "congbobo184", "createdAt": "2020-03-23T09:53:35Z", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/transaction/buffer/impl/TransactionBufferHandlerImpl.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.transaction.buffer.impl;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.util.HashedWheelTimer;\n+import io.netty.util.Recycler;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.Timeout;\n+import io.netty.util.TimerTask;\n+import io.netty.util.concurrent.DefaultThreadFactory;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.pulsar.broker.namespace.NamespaceService;\n+import org.apache.pulsar.client.api.transaction.TransactionBufferClientException;\n+import org.apache.pulsar.client.impl.ClientCnx;\n+import org.apache.pulsar.client.impl.ConnectionPool;\n+import org.apache.pulsar.common.api.proto.PulsarApi;\n+import org.apache.pulsar.common.naming.TopicName;\n+import org.apache.pulsar.common.protocol.Commands;\n+import org.apache.pulsar.client.impl.transaction.TransactionBufferHandler;\n+import org.apache.pulsar.common.util.FutureUtil;\n+import org.apache.pulsar.transaction.impl.common.TxnID;\n+\n+import java.net.InetSocketAddress;\n+import java.net.URI;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+@Slf4j\n+public class TransactionBufferHandlerImpl implements TransactionBufferHandler, TimerTask {\n+\n+    private final ConcurrentSkipListMap<Long, OpRequestSend> pendingRequests;\n+    private final ConnectionPool connectionPool;\n+    private final NamespaceService namespaceService;\n+    private final AtomicLong requestIdGenerator = new AtomicLong();\n+    private long operationTimeoutInMills;\n+    private Timeout requestTimeout;\n+    private HashedWheelTimer timer;\n+    private final Semaphore semaphore;\n+    private final boolean blockIfReachMaxPendingOps;\n+\n+    public TransactionBufferHandlerImpl(ConnectionPool connectionPool, NamespaceService namespaceService) {\n+        this.connectionPool = connectionPool;\n+        this.pendingRequests = new ConcurrentSkipListMap<>();\n+        this.namespaceService = namespaceService;\n+        this.operationTimeoutInMills = 3000L;\n+        this.semaphore = new Semaphore(10000);\n+        this.blockIfReachMaxPendingOps = true;\n+        this.timer = new HashedWheelTimer(new DefaultThreadFactory(\"pulsar-transaction-buffer-client-timer\"));\n+        this.requestTimeout = timer.newTimeout(this, operationTimeoutInMills, TimeUnit.MILLISECONDS);\n+    }\n+\n+    @Override\n+    public CompletableFuture<TxnID> endTxnOnTopic(String topic, long txnIdMostBits, long txnIdLeastBits, PulsarApi.TxnAction action) {\n+        CompletableFuture<TxnID> cb = new CompletableFuture<>();\n+        if (!canSendRequest(cb)) {\n+            return cb;\n+        }\n+        long requestId = requestIdGenerator.getAndIncrement();\n+        ByteBuf cmd = Commands.newEndTxnOnPartition(requestId, txnIdLeastBits, txnIdMostBits, topic, action);\n+        OpRequestSend op = OpRequestSend.create(requestId, topic, cmd, cb);\n+        pendingRequests.put(requestId, op);\n+        cmd.retain();\n+        cnx(topic).whenComplete((clientCnx, throwable) -> {\n+            if (throwable == null) {\n+                try {\n+                    clientCnx.ctx().writeAndFlush(cmd, clientCnx.ctx().voidPromise());", "originalCommit": "5d7e81611b92ce7c06e04875f7c3fc28f57c4d60", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "510c8c5c7e1c762f060c26b10b456b1b2d8e5548", "url": "https://github.com/apache/pulsar/commit/510c8c5c7e1c762f060c26b10b456b1b2d8e5548", "message": "Implementation of Transaction Buffer Client.", "committedDate": "2020-05-22T10:26:10Z", "type": "commit"}, {"oid": "b52b347b50ff7c37affc4a0658d822c52eff8885", "url": "https://github.com/apache/pulsar/commit/b52b347b50ff7c37affc4a0658d822c52eff8885", "message": "Fix check style.", "committedDate": "2020-05-22T10:26:10Z", "type": "commit"}, {"oid": "f9c99102a620610bcd73da647d35d1d68fe86fae", "url": "https://github.com/apache/pulsar/commit/f9c99102a620610bcd73da647d35d1d68fe86fae", "message": "add license header", "committedDate": "2020-05-22T10:26:10Z", "type": "commit"}, {"oid": "f9c99102a620610bcd73da647d35d1d68fe86fae", "url": "https://github.com/apache/pulsar/commit/f9c99102a620610bcd73da647d35d1d68fe86fae", "message": "add license header", "committedDate": "2020-05-22T10:26:10Z", "type": "forcePushed"}, {"oid": "ba2ff3deae4fc2d0f9d61b8b309df329ebbcc4aa", "url": "https://github.com/apache/pulsar/commit/ba2ff3deae4fc2d0f9d61b8b309df329ebbcc4aa", "message": "Merge remote-tracking branch 'apache/master' into txn_buffer_client", "committedDate": "2020-07-21T08:58:10Z", "type": "commit"}, {"oid": "86a22fdb120ecfd4fd12797d0bcfc896cb7c6599", "url": "https://github.com/apache/pulsar/commit/86a22fdb120ecfd4fd12797d0bcfc896cb7c6599", "message": "fix  tests", "committedDate": "2020-07-21T09:14:42Z", "type": "commit"}, {"oid": "a4740050be1f802310fbd6c6d046f8984ef8e098", "url": "https://github.com/apache/pulsar/commit/a4740050be1f802310fbd6c6d046f8984ef8e098", "message": "Merge remote-tracking branch 'apache/master' into txn_buffer_client", "committedDate": "2020-07-23T08:31:16Z", "type": "commit"}, {"oid": "3a9affec8d3c3d8d620c91cf15144cefd588032b", "url": "https://github.com/apache/pulsar/commit/3a9affec8d3c3d8d620c91cf15144cefd588032b", "message": "Merge remote-tracking branch 'apache/master' into txn_buffer_client", "committedDate": "2020-07-27T09:56:44Z", "type": "commit"}]}