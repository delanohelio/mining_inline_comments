{"pr_number": 6074, "pr_title": "PIP-55: Refresh Authentication Credentials", "pr_createdAt": "2020-01-17T05:06:34Z", "pr_url": "https://github.com/apache/pulsar/pull/6074", "timeline": [{"oid": "0c356d66672a9f20e3a525309807b92d41b24ea7", "url": "https://github.com/apache/pulsar/commit/0c356d66672a9f20e3a525309807b92d41b24ea7", "message": "PIP-55: Refresh Authentication Credentials", "committedDate": "2020-01-17T05:03:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc3MjM1MA==", "url": "https://github.com/apache/pulsar/pull/6074#discussion_r367772350", "bodyText": "I think this needs to be marked volatile?", "author": "jerrypeng", "createdAt": "2020-01-17T05:14:46Z", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/ServerCnx.java", "diffHunk": "@@ -127,6 +127,10 @@\n     AuthenticationDataSource authenticationData;\n     AuthenticationProvider authenticationProvider;\n     AuthenticationState authState;\n+    // In case of proxy, if the authentication credentials are forwardable,\n+    // it will hold the credentials of the original client\n+    AuthenticationState originalAuthState;\n+    private boolean pendingAuthChallengeResponse = false;", "originalCommit": "0c356d66672a9f20e3a525309807b92d41b24ea7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEwNTM0OA==", "url": "https://github.com/apache/pulsar/pull/6074#discussion_r368105348", "bodyText": "This variable will be always accessed only the connection IO thread so there won't be any race condition.", "author": "merlimat", "createdAt": "2020-01-17T19:42:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc3MjM1MA=="}], "type": "inlineReview"}, {"oid": "c19830825e187c3e2907cd6538e5951a98bf1b96", "url": "https://github.com/apache/pulsar/commit/c19830825e187c3e2907cd6538e5951a98bf1b96", "message": "Fixed import order", "committedDate": "2020-01-17T05:39:10Z", "type": "commit"}, {"oid": "1dd0fb7b0ff3989b74bd8cc6dddce87c8fdbcbcd", "url": "https://github.com/apache/pulsar/commit/1dd0fb7b0ff3989b74bd8cc6dddce87c8fdbcbcd", "message": "Do not check for original client credential if it's not coming through proxy", "committedDate": "2020-01-17T06:06:13Z", "type": "commit"}, {"oid": "d07a9266226639388672d87cca42ca2fbfe53cb8", "url": "https://github.com/apache/pulsar/commit/d07a9266226639388672d87cca42ca2fbfe53cb8", "message": "Fixed import order", "committedDate": "2020-01-17T19:29:04Z", "type": "commit"}, {"oid": "d07a9266226639388672d87cca42ca2fbfe53cb8", "url": "https://github.com/apache/pulsar/commit/d07a9266226639388672d87cca42ca2fbfe53cb8", "message": "Fixed import order", "committedDate": "2020-01-17T19:29:04Z", "type": "forcePushed"}, {"oid": "e5e1fbba000b4327e14c8365b2fffecd8d803f35", "url": "https://github.com/apache/pulsar/commit/e5e1fbba000b4327e14c8365b2fffecd8d803f35", "message": "Fixed mocked test assumption", "committedDate": "2020-01-17T20:09:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk3NjgzOA==", "url": "https://github.com/apache/pulsar/pull/6074#discussion_r369976838", "bodyText": "nit: Why not set to Long.MAX_VALUE and make the check simpler?", "author": "ivankelly", "createdAt": "2020-01-23T08:11:34Z", "path": "pulsar-broker-common/src/main/java/org/apache/pulsar/broker/authentication/AuthenticationProviderToken.java", "diffHunk": "@@ -166,4 +179,61 @@ private SignatureAlgorithm getPublicKeyAlgType(ServiceConfiguration conf) throws\n             return SignatureAlgorithm.RS256;\n         }\n     }\n+\n+    private static final class TokenAuthenticationState implements AuthenticationState {\n+        private final AuthenticationProviderToken provider;\n+        private AuthenticationDataSource authenticationDataSource;\n+        private Jwt<?, Claims> jwt;\n+        private final SocketAddress remoteAddress;\n+        private final SSLSession sslSession;\n+        private long expiration;\n+\n+        TokenAuthenticationState(\n+                AuthenticationProviderToken provider,\n+                AuthData authData,\n+                SocketAddress remoteAddress,\n+                SSLSession sslSession) throws AuthenticationException {\n+            this.provider = provider;\n+            this.remoteAddress = remoteAddress;\n+            this.sslSession = sslSession;\n+            this.authenticate(authData);\n+        }\n+\n+        @Override\n+        public String getAuthRole() throws AuthenticationException {\n+            return provider.getPrincipal(jwt);\n+        }\n+\n+        @Override\n+        public AuthData authenticate(AuthData authData) throws AuthenticationException {\n+            String token = new String(authData.getBytes(), UTF_8);\n+\n+            this.jwt = provider.authenticateToken(token);\n+            this.authenticationDataSource = new AuthenticationDataCommand(token, remoteAddress, sslSession);\n+            if (jwt.getBody().getExpiration() != null) {\n+                this.expiration = jwt.getBody().getExpiration().getTime();\n+            } else {\n+                this.expiration = 0;", "originalCommit": "e5e1fbba000b4327e14c8365b2fffecd8d803f35", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg0NTkzMQ==", "url": "https://github.com/apache/pulsar/pull/6074#discussion_r370845931", "bodyText": "Fixed", "author": "merlimat", "createdAt": "2020-01-24T21:16:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk3NjgzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk3ODgwMg==", "url": "https://github.com/apache/pulsar/pull/6074#discussion_r369978802", "bodyText": "nit: Why not Cache<ServerCnx, ServerCnx> and avoid possibly allocating the SocketAddress? We don't care about the keys in any case. Maybe add a comment that the you're using Cache to avoid having to clean stuff up.", "author": "ivankelly", "createdAt": "2020-01-23T08:17:20Z", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/PulsarChannelInitializer.java", "diffHunk": "@@ -38,6 +48,11 @@\n     private final NettySslContextBuilder sslCtxRefresher;\n     private final ServiceConfiguration brokerConf;\n \n+    private final Cache<SocketAddress, ServerCnx> connections = Caffeine.newBuilder()", "originalCommit": "e5e1fbba000b4327e14c8365b2fffecd8d803f35", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg0NTg4Mg==", "url": "https://github.com/apache/pulsar/pull/6074#discussion_r370845882", "bodyText": "The socket address is already kept in the ServerCnx itself, so it will not be a new allocation here.", "author": "merlimat", "createdAt": "2020-01-24T21:16:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk3ODgwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg0NjMzMQ==", "url": "https://github.com/apache/pulsar/pull/6074#discussion_r370846331", "bodyText": "Added comment", "author": "merlimat", "createdAt": "2020-01-24T21:17:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk3ODgwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk4MDAyMA==", "url": "https://github.com/apache/pulsar/pull/6074#discussion_r369980020", "bodyText": "Since you're using Cache to hold the connections, and the lifetime of the entry in connections is based on whether it's been GC'd, this will likely spam the logs. Maybe only log if after throwing, the cnx is still in connected state.", "author": "ivankelly", "createdAt": "2020-01-23T08:20:53Z", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/PulsarChannelInitializer.java", "diffHunk": "@@ -78,6 +97,19 @@ protected void initChannel(SocketChannel ch) throws Exception {\n         // ServerCnx ends up reading higher number of messages and broker can not throttle the messages by disabling\n         // auto-read.\n         ch.pipeline().addLast(\"flowController\", new FlowControlHandler());\n-        ch.pipeline().addLast(\"handler\", new ServerCnx(pulsar));\n+        ServerCnx cnx = new ServerCnx(pulsar);\n+        ch.pipeline().addLast(\"handler\", cnx);\n+\n+        connections.put(ch.remoteAddress(), cnx);\n+    }\n+\n+    private void refreshAuthenticationCredentials() {\n+        connections.asMap().values().forEach(cnx -> {\n+            try {\n+                cnx.refreshAuthenticationCredentials();\n+            } catch (Throwable t) {\n+                log.warn(\"[{}] Failed to refresh auth credentials\", cnx.getRemoteAddress());", "originalCommit": "e5e1fbba000b4327e14c8365b2fffecd8d803f35", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg0NzEzMw==", "url": "https://github.com/apache/pulsar/pull/6074#discussion_r370847133", "bodyText": "When we get the ref to cnx, it will be a strong ref to it, so we're not going to loose it during the iteration. Then, inside that method, i'm checking for\n   if (getState() != State.Connected || !isActive) {\n            // Connection is either still being established or already closed.\n            return;\n        }\nto avoid getting errors on a connections that's already gone", "author": "merlimat", "createdAt": "2020-01-24T21:20:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk4MDAyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk4MjQyNg==", "url": "https://github.com/apache/pulsar/pull/6074#discussion_r369982426", "bodyText": "This comment is now wrong. I think the flow should change a little here, to only call completeConnect if it's the initial auth. There seems to be enough difference in the flows to have them completely separate.", "author": "ivankelly", "createdAt": "2020-01-23T08:27:14Z", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/ServerCnx.java", "diffHunk": "@@ -476,19 +473,42 @@ private void completeConnect(int clientProtoVersion, String clientVersion) {\n     }\n \n     // According to auth result, send newConnected or newAuthChallenge command.\n-    private void doAuthentication(AuthData clientData,\n-                                  int clientProtocolVersion,\n-                                  String clientVersion) throws Exception {\n+    private State doAuthentication(AuthData clientData,\n+                                   int clientProtocolVersion,\n+                                   String clientVersion) throws Exception {\n+\n+        // The original auth state can only be set on subsequent auth attempts (and only\n+        // in presence of a proxy and if the proxy is forwarding the credentials).\n+        // In this case, the re-validation needs to be done against the original client\n+        // credentials.\n+        boolean useOriginalAuthState = (originalAuthState != null);\n+        AuthenticationState authState =  useOriginalAuthState ? originalAuthState : this.authState;\n+        String authRole = useOriginalAuthState ? originalPrincipal : this.authRole;\n         AuthData brokerData = authState.authenticate(clientData);\n+\n         // authentication has completed, will send newConnected command.", "originalCommit": "e5e1fbba000b4327e14c8365b2fffecd8d803f35", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg1MDUzMg==", "url": "https://github.com/apache/pulsar/pull/6074#discussion_r370850532", "bodyText": "Fixed the comment and tried to make the flow a bit clearer", "author": "merlimat", "createdAt": "2020-01-24T21:29:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk4MjQyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk4Mzc1OQ==", "url": "https://github.com/apache/pulsar/pull/6074#discussion_r369983759", "bodyText": "not for this patch, but it seems strange that this is a synchronous call, given that authentication could be calling out to a remote system.", "author": "ivankelly", "createdAt": "2020-01-23T08:30:22Z", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/ServerCnx.java", "diffHunk": "@@ -551,29 +624,46 @@ protected void handleConnect(CommandConnect connect) {\n             if (sslHandler != null) {\n                 sslSession = ((SslHandler) sslHandler).engine().getSession();\n             }\n-            originalPrincipal = getOriginalPrincipal(\n-                connect.hasOriginalAuthData() ? connect.getOriginalAuthData() : null,\n-                connect.hasOriginalAuthMethod() ? connect.getOriginalAuthMethod() : null,\n-                connect.hasOriginalPrincipal() ? connect.getOriginalPrincipal() : null,\n-                sslSession);\n \n             authState = authenticationProvider.newAuthState(clientData, remoteAddress, sslSession);\n             authenticationData = authState.getAuthDataSource();\n-            doAuthentication(clientData, clientProtocolVersion, clientVersion);\n+            state = doAuthentication(clientData, clientProtocolVersion, clientVersion);", "originalCommit": "e5e1fbba000b4327e14c8365b2fffecd8d803f35", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg0MzM0MA==", "url": "https://github.com/apache/pulsar/pull/6074#discussion_r370843340", "bodyText": "Yes, initially all auth methods were completely stateless and therefore didn't require any asynchronousness in the provider API. This is not true now in general and we'll have to make a bit of a refactor to achieve that.", "author": "merlimat", "createdAt": "2020-01-24T21:10:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk4Mzc1OQ=="}], "type": "inlineReview"}, {"oid": "d8e885404799d0fc637fef63c94fecae864075d4", "url": "https://github.com/apache/pulsar/commit/d8e885404799d0fc637fef63c94fecae864075d4", "message": "Addressed comments", "committedDate": "2020-01-24T21:29:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg1NjcyMA==", "url": "https://github.com/apache/pulsar/pull/6074#discussion_r370856720", "bodyText": "we should disable it by default.", "author": "rdhabalia", "createdAt": "2020-01-24T21:46:24Z", "path": "pulsar-broker-common/src/main/java/org/apache/pulsar/broker/ServiceConfiguration.java", "diffHunk": "@@ -660,6 +660,12 @@\n     )\n     private Set<String> authenticationProviders = Sets.newTreeSet();\n \n+    @FieldContext(\n+        category = CATEGORY_AUTHENTICATION,\n+        doc = \"Interval of time for checking for expired authentication credentials\"\n+    )\n+    private int authenticationRefreshCheckSeconds = 60;", "originalCommit": "d8e885404799d0fc637fef63c94fecae864075d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg3MDc4NA==", "url": "https://github.com/apache/pulsar/pull/6074#discussion_r370870784", "bodyText": "It will \"disabled by default\" in the sense that the current credentials are not expiring as of now.", "author": "merlimat", "createdAt": "2020-01-24T22:30:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg1NjcyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg2NDE1Mg==", "url": "https://github.com/apache/pulsar/pull/6074#discussion_r370864152", "bodyText": "if client doesn't support then let's not change the behavior and don't close the connection, because closing connection will interrupt the client side processing and it requires them to upgrade client lib immediately if client wants to fix auto disconnect. So, we don't want our client to complain for such changed behavior which requires them to upgrade client lib.", "author": "rdhabalia", "createdAt": "2020-01-24T22:07:57Z", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/ServerCnx.java", "diffHunk": "@@ -497,8 +523,60 @@ private void doAuthentication(AuthData clientData,\n             log.debug(\"[{}] Authentication in progress client by method {}.\",\n                 remoteAddress, authMethod);\n         }\n-        state = State.Connecting;\n-        return;\n+        return State.Connecting;\n+    }\n+\n+    public void refreshAuthenticationCredentials() {\n+        if (getState() != State.Connected || !isActive) {\n+            // Connection is either still being established or already closed.\n+            return;\n+        }\n+\n+        AuthenticationState authState = this.originalAuthState != null ? originalAuthState : this.authState;\n+        if (authState != null && !authState.isExpired()) {\n+            // Credentials are still valid. Nothing to do at this point\n+            return;\n+        }\n+\n+        if (originalPrincipal != null && originalAuthState == null) {\n+            log.info(\n+                    \"[{}] Cannot revalidate user credential when using proxy and not forwarding the credentials. Closing connection\",\n+                    remoteAddress);\n+            return;\n+        }\n+\n+        ctx.executor().execute(SafeRun.safeRun(() -> {\n+            log.info(\"[{}] Refreshing authentication credentials\", remoteAddress);\n+\n+            if (!supportsAuthenticationRefresh()) {\n+                log.warn(\"[{}] Closing connection because client doesn't support auth credentials refresh\", remoteAddress);\n+                ctx.close();", "originalCommit": "d8e885404799d0fc637fef63c94fecae864075d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg3NTI3Mw==", "url": "https://github.com/apache/pulsar/pull/6074#discussion_r370875273", "bodyText": "If we don't close the connection for older clients, it becomes a security loophole.\nAlso,  keep in mind that this is only apply if the credentials are expiring. In that case, a client will typically be reading the credentials each time are needed (eg: from a file or through a supplier function).\nIf that was not the case, it would have trouble even without this change. (eg: when a broker gets restarted it will not be able to reconnect anymore).\nAfter the connection gets closed, an older client will be anyway able to immediately reconnect and refresh the authentication.", "author": "merlimat", "createdAt": "2020-01-24T22:46:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg2NDE1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg1OTMyOA==", "url": "https://github.com/apache/pulsar/pull/6074#discussion_r374859328", "bodyText": "this change will not work for us because we have usecase where application creates large number of producers on one connection and if the client library is not upgraded then it closes the connection and disrupts all producers connection. this application is latency sensitive and we would like to avoid reconnection.", "author": "rdhabalia", "createdAt": "2020-02-04T18:55:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg2NDE1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTA4MTY0NQ==", "url": "https://github.com/apache/pulsar/pull/6074#discussion_r375081645", "bodyText": "if the client library is not upgraded then it closes the connection and disrupts all producers connection.\n\nThis is only if the credentials are expiring and if the authentication provider enforces that (which right now will only be the token auth provider).\nAvoiding to challenge older client defeats the purpose of this feature in that it opens a backdoor to completely avoid the check.\nIf older clients are a concern, I'd suggest to either:\n\nnot use this feature (or similarly working feature)\nuse non-expiring credentials for older clients\nuse credentials with long expire time to minimize the number of reconnections\nforce clients to upgrade version\n\nI honestly don't see any better solution for that. I'd categorically exclude the \"ignore old clients\" for the false sense of security and the massive sec issue it opens.", "author": "merlimat", "createdAt": "2020-02-05T06:42:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg2NDE1Mg=="}], "type": "inlineReview"}, {"oid": "e10b038f32b1f307bb9d22789d7552ca6a63215a", "url": "https://github.com/apache/pulsar/commit/e10b038f32b1f307bb9d22789d7552ca6a63215a", "message": "Avoid to print NPE on auth refresh check if auth is disabled", "committedDate": "2020-02-05T05:56:07Z", "type": "commit"}]}