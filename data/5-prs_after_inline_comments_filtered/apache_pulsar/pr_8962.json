{"pr_number": 8962, "pr_title": "[ShadeTest]Add integration shade test for pulsar-client and pulsar-cient-admin.", "pr_createdAt": "2020-12-15T12:21:51Z", "pr_url": "https://github.com/apache/pulsar/pull/8962", "timeline": [{"oid": "3b41ed3b610197a4fdf9bb44a9b919ef059e6789", "url": "https://github.com/apache/pulsar/commit/3b41ed3b610197a4fdf9bb44a9b919ef059e6789", "message": "Add integration shade test for pulsar-client and pulsar-cient-admin.", "committedDate": "2020-12-15T12:15:28Z", "type": "commit"}, {"oid": "c9d12e8aa9237c541d39ab3244be68ae9ede64f2", "url": "https://github.com/apache/pulsar/commit/c9d12e8aa9237c541d39ab3244be68ae9ede64f2", "message": "Remove useless log codes.", "committedDate": "2020-12-15T12:22:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzM3MTE1NQ==", "url": "https://github.com/apache/pulsar/pull/8962#discussion_r543371155", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    String topicName = \"persistent://my-property/my-ns/myrsa-topic1-\"+ System.currentTimeMillis();\n          \n          \n            \n                    String topicName = \"persistent://my-property/my-ns/myrsa-topic1-\" + System.currentTimeMillis();", "author": "jbampton", "createdAt": "2020-12-15T14:09:15Z", "path": "tests/pulsar-client-admin-shade-test/src/test/java/org/apache/pulsar/tests/integration/SimpleProducerConsumerTest.java", "diffHunk": "@@ -0,0 +1,577 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.tests.integration;\n+\n+import lombok.Cleanup;\n+import org.apache.pulsar.client.admin.PulsarAdmin;\n+import org.apache.pulsar.client.admin.PulsarAdminException;\n+import org.apache.pulsar.client.api.*;\n+import org.apache.pulsar.client.impl.MessageImpl;\n+import org.apache.pulsar.client.impl.TopicMessageImpl;\n+import org.apache.pulsar.client.impl.crypto.MessageCryptoBc;\n+import org.apache.pulsar.common.api.EncryptionContext;\n+import org.apache.pulsar.common.api.proto.PulsarApi;\n+import org.apache.pulsar.common.compression.CompressionCodec;\n+import org.apache.pulsar.common.compression.CompressionCodecProvider;\n+import org.apache.pulsar.common.policies.data.TenantInfo;\n+import org.apache.pulsar.common.protocol.Commands;\n+import org.apache.pulsar.shade.com.google.common.collect.Maps;\n+import org.apache.pulsar.shade.com.google.common.collect.Sets;\n+import org.apache.pulsar.shade.io.netty.buffer.ByteBuf;\n+import org.apache.pulsar.shade.io.netty.buffer.Unpooled;\n+import org.apache.pulsar.shaded.com.google.protobuf.v241.ByteString;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.security.Security;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.testng.Assert.*;\n+\n+public class SimpleProducerConsumerTest {\n+    private static final Logger log = LoggerFactory.getLogger(SimpleProducerConsumerTest.class);\n+\n+    private PulsarContainer pulsarContainer;\n+    private URI lookupUrl;\n+    private PulsarClient pulsarClient;\n+\n+    @BeforeClass\n+    public void setup() throws PulsarClientException, URISyntaxException, PulsarAdminException {\n+        Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());\n+\n+        pulsarContainer = new PulsarContainer();\n+        pulsarContainer.start();\n+        pulsarClient = PulsarClient.builder()\n+                .serviceUrl(pulsarContainer.getPlainTextPulsarBrokerUrl())\n+                .build();\n+        lookupUrl = new URI(pulsarContainer.getPlainTextPulsarBrokerUrl());\n+\n+        PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(pulsarContainer.getPulsarAdminUrl()).build();\n+        admin.tenants().createTenant(\"my-property\",\n+                new TenantInfo(Sets.newHashSet(\"appid1\", \"appid2\"), Sets.newHashSet(\"standalone\")));\n+        admin.namespaces().createNamespace(\"my-property/my-ns\");\n+        admin.namespaces().setNamespaceReplicationClusters(\"my-property/my-ns\", Sets.newHashSet(\"standalone\"));\n+        admin.close();\n+    }\n+\n+    @AfterClass\n+    public void cleanup() throws PulsarClientException {\n+        pulsarClient.close();\n+        pulsarContainer.stop();\n+        pulsarContainer.close();\n+    }\n+\n+    private PulsarClient newPulsarClient(String url, int intervalInSecs) throws PulsarClientException {\n+        return PulsarClient.builder().serviceUrl(url).statsInterval(intervalInSecs, TimeUnit.SECONDS).build();\n+    }\n+\n+    @Test\n+    public void testRSAEncryption() throws Exception {\n+\n+        String topicName = \"persistent://my-property/my-ns/myrsa-topic1-\"+ System.currentTimeMillis();", "originalCommit": "c9d12e8aa9237c541d39ab3244be68ae9ede64f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzM3NDYxNg==", "url": "https://github.com/apache/pulsar/pull/8962#discussion_r543374616", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Set<String> messages = new HashSet(); // Since messages are in random order\n          \n          \n            \n                    Set<String> messages = new HashSet();// Since messages are in random order", "author": "jbampton", "createdAt": "2020-12-15T14:12:18Z", "path": "tests/pulsar-client-admin-shade-test/src/test/java/org/apache/pulsar/tests/integration/SimpleProducerConsumerTest.java", "diffHunk": "@@ -0,0 +1,577 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.tests.integration;\n+\n+import lombok.Cleanup;\n+import org.apache.pulsar.client.admin.PulsarAdmin;\n+import org.apache.pulsar.client.admin.PulsarAdminException;\n+import org.apache.pulsar.client.api.*;\n+import org.apache.pulsar.client.impl.MessageImpl;\n+import org.apache.pulsar.client.impl.TopicMessageImpl;\n+import org.apache.pulsar.client.impl.crypto.MessageCryptoBc;\n+import org.apache.pulsar.common.api.EncryptionContext;\n+import org.apache.pulsar.common.api.proto.PulsarApi;\n+import org.apache.pulsar.common.compression.CompressionCodec;\n+import org.apache.pulsar.common.compression.CompressionCodecProvider;\n+import org.apache.pulsar.common.policies.data.TenantInfo;\n+import org.apache.pulsar.common.protocol.Commands;\n+import org.apache.pulsar.shade.com.google.common.collect.Maps;\n+import org.apache.pulsar.shade.com.google.common.collect.Sets;\n+import org.apache.pulsar.shade.io.netty.buffer.ByteBuf;\n+import org.apache.pulsar.shade.io.netty.buffer.Unpooled;\n+import org.apache.pulsar.shaded.com.google.protobuf.v241.ByteString;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.security.Security;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.testng.Assert.*;\n+\n+public class SimpleProducerConsumerTest {\n+    private static final Logger log = LoggerFactory.getLogger(SimpleProducerConsumerTest.class);\n+\n+    private PulsarContainer pulsarContainer;\n+    private URI lookupUrl;\n+    private PulsarClient pulsarClient;\n+\n+    @BeforeClass\n+    public void setup() throws PulsarClientException, URISyntaxException, PulsarAdminException {\n+        Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());\n+\n+        pulsarContainer = new PulsarContainer();\n+        pulsarContainer.start();\n+        pulsarClient = PulsarClient.builder()\n+                .serviceUrl(pulsarContainer.getPlainTextPulsarBrokerUrl())\n+                .build();\n+        lookupUrl = new URI(pulsarContainer.getPlainTextPulsarBrokerUrl());\n+\n+        PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(pulsarContainer.getPulsarAdminUrl()).build();\n+        admin.tenants().createTenant(\"my-property\",\n+                new TenantInfo(Sets.newHashSet(\"appid1\", \"appid2\"), Sets.newHashSet(\"standalone\")));\n+        admin.namespaces().createNamespace(\"my-property/my-ns\");\n+        admin.namespaces().setNamespaceReplicationClusters(\"my-property/my-ns\", Sets.newHashSet(\"standalone\"));\n+        admin.close();\n+    }\n+\n+    @AfterClass\n+    public void cleanup() throws PulsarClientException {\n+        pulsarClient.close();\n+        pulsarContainer.stop();\n+        pulsarContainer.close();\n+    }\n+\n+    private PulsarClient newPulsarClient(String url, int intervalInSecs) throws PulsarClientException {\n+        return PulsarClient.builder().serviceUrl(url).statsInterval(intervalInSecs, TimeUnit.SECONDS).build();\n+    }\n+\n+    @Test\n+    public void testRSAEncryption() throws Exception {\n+\n+        String topicName = \"persistent://my-property/my-ns/myrsa-topic1-\"+ System.currentTimeMillis();\n+\n+        class EncKeyReader implements CryptoKeyReader {\n+\n+            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();\n+\n+            @Override\n+            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {\n+                String CERT_FILE_PATH = \"./src/test/resources/certificate/public-key.\" + keyName;\n+                if (Files.isReadable(Paths.get(CERT_FILE_PATH))) {\n+                    try {\n+                        keyInfo.setKey(Files.readAllBytes(Paths.get(CERT_FILE_PATH)));\n+                        return keyInfo;\n+                    } catch (IOException e) {\n+                        Assert.fail(\"Failed to read certificate from \" + CERT_FILE_PATH);\n+                    }\n+                } else {\n+                    Assert.fail(\"Certificate file \" + CERT_FILE_PATH + \" is not present or not readable.\");\n+                }\n+                return null;\n+            }\n+\n+            @Override\n+            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> keyMeta) {\n+                String CERT_FILE_PATH = \"./src/test/resources/certificate/private-key.\" + keyName;\n+                if (Files.isReadable(Paths.get(CERT_FILE_PATH))) {\n+                    try {\n+                        keyInfo.setKey(Files.readAllBytes(Paths.get(CERT_FILE_PATH)));\n+                        return keyInfo;\n+                    } catch (IOException e) {\n+                        Assert.fail(\"Failed to read certificate from \" + CERT_FILE_PATH);\n+                    }\n+                } else {\n+                    Assert.fail(\"Certificate file \" + CERT_FILE_PATH + \" is not present or not readable.\");\n+                }\n+                return null;\n+            }\n+        }\n+\n+        final int totalMsg = 10;\n+\n+        Set<String> messageSet = Sets.newHashSet();\n+        Consumer<byte[]> consumer = pulsarClient.newConsumer().topic(\"persistent://my-property/my-ns/myrsa-topic1\")\n+                .subscriptionName(\"my-subscriber-name\").cryptoKeyReader(new EncKeyReader()).subscribe();\n+        Consumer<byte[]> normalConsumer = pulsarClient.newConsumer()\n+                .topic(topicName).subscriptionName(\"my-subscriber-name-normal\")\n+                .subscribe();\n+\n+        Producer<byte[]> producer = pulsarClient.newProducer().topic(\"persistent://my-property/my-ns/myrsa-topic1\")\n+                .addEncryptionKey(\"client-rsa.pem\").cryptoKeyReader(new EncKeyReader()).create();\n+        Producer<byte[]> producer2 = pulsarClient.newProducer().topic(\"persistent://my-property/my-ns/myrsa-topic1\")\n+                .addEncryptionKey(\"client-rsa.pem\").cryptoKeyReader(new EncKeyReader()).create();\n+\n+        for (int i = 0; i < totalMsg; i++) {\n+            String message = \"my-message-\" + i;\n+            producer.send(message.getBytes());\n+        }\n+        for (int i = totalMsg; i < totalMsg * 2; i++) {\n+            String message = \"my-message-\" + i;\n+            producer2.send(message.getBytes());\n+        }\n+\n+        MessageImpl<byte[]> msg = null;\n+\n+        msg = (MessageImpl<byte[]>) normalConsumer.receive(500, TimeUnit.MILLISECONDS);\n+        // should not able to read message using normal message.\n+        assertNull(msg);\n+\n+        for (int i = 0; i < totalMsg * 2; i++) {\n+            msg = (MessageImpl<byte[]>) consumer.receive(5, TimeUnit.SECONDS);\n+            // verify that encrypted message contains encryption-context\n+            msg.getEncryptionCtx()\n+                    .orElseThrow(() -> new IllegalStateException(\"encryption-ctx not present for encrypted message\"));\n+            String receivedMessage = new String(msg.getData());\n+            log.debug(\"Received message: [{}]\", receivedMessage);\n+            String expectedMessage = \"my-message-\" + i;\n+            testMessageOrderAndDuplicates(messageSet, receivedMessage, expectedMessage);\n+        }\n+        // Acknowledge the consumption of all messages at once\n+        consumer.acknowledgeCumulative(msg);\n+        consumer.close();\n+    }\n+\n+    protected <T> void testMessageOrderAndDuplicates(Set<T> messagesReceived, T receivedMessage,\n+                                                     T expectedMessage) {\n+        // Make sure that messages are received in order\n+        Assert.assertEquals(receivedMessage, expectedMessage,\n+                \"Received message \" + receivedMessage + \" did not match the expected message \" + expectedMessage);\n+\n+        // Make sure that there are no duplicates\n+        Assert.assertTrue(messagesReceived.add(receivedMessage), \"Received duplicate message \" + receivedMessage);\n+    }\n+\n+    @Test\n+    public void testRedeliveryOfFailedMessages() throws Exception {\n+\n+        @Cleanup\n+        PulsarClient pulsarClient = PulsarClient.builder()\n+                .serviceUrl(pulsarContainer.getPlainTextPulsarBrokerUrl())\n+                .build();\n+\n+        final String encryptionKeyName = \"client-rsa.pem\";\n+        final String encryptionKeyVersion = \"1.0\";\n+        Map<String, String> metadata = Maps.newHashMap();\n+        metadata.put(\"version\", encryptionKeyVersion);\n+        class EncKeyReader implements CryptoKeyReader {\n+            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();\n+\n+            @Override\n+            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {\n+                String CERT_FILE_PATH = \"./src/test/resources/certificate/public-key.\" + keyName;\n+                if (Files.isReadable(Paths.get(CERT_FILE_PATH))) {\n+                    try {\n+                        keyInfo.setKey(Files.readAllBytes(Paths.get(CERT_FILE_PATH)));\n+                        keyInfo.setMetadata(metadata);\n+                        return keyInfo;\n+                    } catch (IOException e) {\n+                        Assert.fail(\"Failed to read certificate from \" + CERT_FILE_PATH);\n+                    }\n+                } else {\n+                    Assert.fail(\"Certificate file \" + CERT_FILE_PATH + \" is not present or not readable.\");\n+                }\n+                return null;\n+            }\n+\n+            @Override\n+            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> keyMeta) {\n+                String CERT_FILE_PATH = \"./src/test/resources/certificate/private-key.\" + keyName;\n+                if (Files.isReadable(Paths.get(CERT_FILE_PATH))) {\n+                    try {\n+                        keyInfo.setKey(Files.readAllBytes(Paths.get(CERT_FILE_PATH)));\n+                        keyInfo.setMetadata(metadata);\n+                        return keyInfo;\n+                    } catch (IOException e) {\n+                        Assert.fail(\"Failed to read certificate from \" + CERT_FILE_PATH);\n+                    }\n+                } else {\n+                    Assert.fail(\"Certificate file \" + CERT_FILE_PATH + \" is not present or not readable.\");\n+                }\n+                return null;\n+            }\n+        }\n+\n+        class InvalidKeyReader implements CryptoKeyReader {\n+            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();\n+\n+            @Override\n+            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {\n+                return null;\n+            }\n+\n+            @Override\n+            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> metadata) {\n+                return null;\n+            }\n+        }\n+\n+        /*\n+         * Redelivery functionality guarantees that customer will get a chance to process the message again.\n+         * In case of shared subscription eventually every client will get a chance to process the message, till one of them acks it.\n+         *\n+         * For client with Encryption enabled where in cases like a new production rollout or a buggy client configuration, we might have a mismatch of consumers\n+         * - few which can decrypt, few which can't (due to errors or cryptoReader not configured).\n+         *\n+         * In that case eventually all messages should be acked as long as there is a single consumer who can decrypt the message.\n+         *\n+         * Consumer 1 - Can decrypt message\n+         * Consumer 2 - Has invalid Reader configured.\n+         * Consumer 3 - Has no reader configured.\n+         *\n+         */\n+\n+        String topicName = \"persistent://my-property/my-ns/myrsa-topic2\";\n+\n+        Producer<byte[]> producer = pulsarClient.newProducer().topic(topicName)\n+                .addEncryptionKey(encryptionKeyName).compressionType(CompressionType.LZ4)\n+                .cryptoKeyReader(new EncKeyReader()).create();\n+\n+        PulsarClient newPulsarClient = newPulsarClient(lookupUrl.toString(), 0);// Creates new client connection\n+        Consumer<byte[]> consumer1 = newPulsarClient.newConsumer().topicsPattern(topicName)\n+                .subscriptionName(\"my-subscriber-name\").cryptoKeyReader(new EncKeyReader())\n+                .subscriptionType(SubscriptionType.Shared).ackTimeout(1, TimeUnit.SECONDS).subscribe();\n+\n+        PulsarClient newPulsarClient1 = newPulsarClient(lookupUrl.toString(), 0);// Creates new client connection\n+        Consumer<byte[]> consumer2 = newPulsarClient1.newConsumer().topicsPattern(topicName)\n+                .subscriptionName(\"my-subscriber-name\").cryptoKeyReader(new InvalidKeyReader())\n+                .subscriptionType(SubscriptionType.Shared).ackTimeout(1, TimeUnit.SECONDS).subscribe();\n+\n+        PulsarClient newPulsarClient2 = newPulsarClient(lookupUrl.toString(), 0);// Creates new client connection\n+        Consumer<byte[]> consumer3 = newPulsarClient2.newConsumer().topicsPattern(topicName)\n+                .subscriptionName(\"my-subscriber-name\").subscriptionType(SubscriptionType.Shared).ackTimeout(1, TimeUnit.SECONDS).subscribe();\n+\n+        int numberOfMessages = 100;\n+        String message = \"my-message\";\n+        Set<String> messages = new HashSet(); // Since messages are in random order", "originalCommit": "c9d12e8aa9237c541d39ab3244be68ae9ede64f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzM3NjEzNw==", "url": "https://github.com/apache/pulsar/pull/8962#discussion_r543376137", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    for (int i = 0; i<numberOfMessages; i++) {\n          \n          \n            \n                    for (int i = 0; i < numberOfMessages; i++) {", "author": "jbampton", "createdAt": "2020-12-15T14:13:32Z", "path": "tests/pulsar-client-admin-shade-test/src/test/java/org/apache/pulsar/tests/integration/SimpleProducerConsumerTest.java", "diffHunk": "@@ -0,0 +1,577 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.tests.integration;\n+\n+import lombok.Cleanup;\n+import org.apache.pulsar.client.admin.PulsarAdmin;\n+import org.apache.pulsar.client.admin.PulsarAdminException;\n+import org.apache.pulsar.client.api.*;\n+import org.apache.pulsar.client.impl.MessageImpl;\n+import org.apache.pulsar.client.impl.TopicMessageImpl;\n+import org.apache.pulsar.client.impl.crypto.MessageCryptoBc;\n+import org.apache.pulsar.common.api.EncryptionContext;\n+import org.apache.pulsar.common.api.proto.PulsarApi;\n+import org.apache.pulsar.common.compression.CompressionCodec;\n+import org.apache.pulsar.common.compression.CompressionCodecProvider;\n+import org.apache.pulsar.common.policies.data.TenantInfo;\n+import org.apache.pulsar.common.protocol.Commands;\n+import org.apache.pulsar.shade.com.google.common.collect.Maps;\n+import org.apache.pulsar.shade.com.google.common.collect.Sets;\n+import org.apache.pulsar.shade.io.netty.buffer.ByteBuf;\n+import org.apache.pulsar.shade.io.netty.buffer.Unpooled;\n+import org.apache.pulsar.shaded.com.google.protobuf.v241.ByteString;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.security.Security;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.testng.Assert.*;\n+\n+public class SimpleProducerConsumerTest {\n+    private static final Logger log = LoggerFactory.getLogger(SimpleProducerConsumerTest.class);\n+\n+    private PulsarContainer pulsarContainer;\n+    private URI lookupUrl;\n+    private PulsarClient pulsarClient;\n+\n+    @BeforeClass\n+    public void setup() throws PulsarClientException, URISyntaxException, PulsarAdminException {\n+        Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());\n+\n+        pulsarContainer = new PulsarContainer();\n+        pulsarContainer.start();\n+        pulsarClient = PulsarClient.builder()\n+                .serviceUrl(pulsarContainer.getPlainTextPulsarBrokerUrl())\n+                .build();\n+        lookupUrl = new URI(pulsarContainer.getPlainTextPulsarBrokerUrl());\n+\n+        PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(pulsarContainer.getPulsarAdminUrl()).build();\n+        admin.tenants().createTenant(\"my-property\",\n+                new TenantInfo(Sets.newHashSet(\"appid1\", \"appid2\"), Sets.newHashSet(\"standalone\")));\n+        admin.namespaces().createNamespace(\"my-property/my-ns\");\n+        admin.namespaces().setNamespaceReplicationClusters(\"my-property/my-ns\", Sets.newHashSet(\"standalone\"));\n+        admin.close();\n+    }\n+\n+    @AfterClass\n+    public void cleanup() throws PulsarClientException {\n+        pulsarClient.close();\n+        pulsarContainer.stop();\n+        pulsarContainer.close();\n+    }\n+\n+    private PulsarClient newPulsarClient(String url, int intervalInSecs) throws PulsarClientException {\n+        return PulsarClient.builder().serviceUrl(url).statsInterval(intervalInSecs, TimeUnit.SECONDS).build();\n+    }\n+\n+    @Test\n+    public void testRSAEncryption() throws Exception {\n+\n+        String topicName = \"persistent://my-property/my-ns/myrsa-topic1-\"+ System.currentTimeMillis();\n+\n+        class EncKeyReader implements CryptoKeyReader {\n+\n+            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();\n+\n+            @Override\n+            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {\n+                String CERT_FILE_PATH = \"./src/test/resources/certificate/public-key.\" + keyName;\n+                if (Files.isReadable(Paths.get(CERT_FILE_PATH))) {\n+                    try {\n+                        keyInfo.setKey(Files.readAllBytes(Paths.get(CERT_FILE_PATH)));\n+                        return keyInfo;\n+                    } catch (IOException e) {\n+                        Assert.fail(\"Failed to read certificate from \" + CERT_FILE_PATH);\n+                    }\n+                } else {\n+                    Assert.fail(\"Certificate file \" + CERT_FILE_PATH + \" is not present or not readable.\");\n+                }\n+                return null;\n+            }\n+\n+            @Override\n+            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> keyMeta) {\n+                String CERT_FILE_PATH = \"./src/test/resources/certificate/private-key.\" + keyName;\n+                if (Files.isReadable(Paths.get(CERT_FILE_PATH))) {\n+                    try {\n+                        keyInfo.setKey(Files.readAllBytes(Paths.get(CERT_FILE_PATH)));\n+                        return keyInfo;\n+                    } catch (IOException e) {\n+                        Assert.fail(\"Failed to read certificate from \" + CERT_FILE_PATH);\n+                    }\n+                } else {\n+                    Assert.fail(\"Certificate file \" + CERT_FILE_PATH + \" is not present or not readable.\");\n+                }\n+                return null;\n+            }\n+        }\n+\n+        final int totalMsg = 10;\n+\n+        Set<String> messageSet = Sets.newHashSet();\n+        Consumer<byte[]> consumer = pulsarClient.newConsumer().topic(\"persistent://my-property/my-ns/myrsa-topic1\")\n+                .subscriptionName(\"my-subscriber-name\").cryptoKeyReader(new EncKeyReader()).subscribe();\n+        Consumer<byte[]> normalConsumer = pulsarClient.newConsumer()\n+                .topic(topicName).subscriptionName(\"my-subscriber-name-normal\")\n+                .subscribe();\n+\n+        Producer<byte[]> producer = pulsarClient.newProducer().topic(\"persistent://my-property/my-ns/myrsa-topic1\")\n+                .addEncryptionKey(\"client-rsa.pem\").cryptoKeyReader(new EncKeyReader()).create();\n+        Producer<byte[]> producer2 = pulsarClient.newProducer().topic(\"persistent://my-property/my-ns/myrsa-topic1\")\n+                .addEncryptionKey(\"client-rsa.pem\").cryptoKeyReader(new EncKeyReader()).create();\n+\n+        for (int i = 0; i < totalMsg; i++) {\n+            String message = \"my-message-\" + i;\n+            producer.send(message.getBytes());\n+        }\n+        for (int i = totalMsg; i < totalMsg * 2; i++) {\n+            String message = \"my-message-\" + i;\n+            producer2.send(message.getBytes());\n+        }\n+\n+        MessageImpl<byte[]> msg = null;\n+\n+        msg = (MessageImpl<byte[]>) normalConsumer.receive(500, TimeUnit.MILLISECONDS);\n+        // should not able to read message using normal message.\n+        assertNull(msg);\n+\n+        for (int i = 0; i < totalMsg * 2; i++) {\n+            msg = (MessageImpl<byte[]>) consumer.receive(5, TimeUnit.SECONDS);\n+            // verify that encrypted message contains encryption-context\n+            msg.getEncryptionCtx()\n+                    .orElseThrow(() -> new IllegalStateException(\"encryption-ctx not present for encrypted message\"));\n+            String receivedMessage = new String(msg.getData());\n+            log.debug(\"Received message: [{}]\", receivedMessage);\n+            String expectedMessage = \"my-message-\" + i;\n+            testMessageOrderAndDuplicates(messageSet, receivedMessage, expectedMessage);\n+        }\n+        // Acknowledge the consumption of all messages at once\n+        consumer.acknowledgeCumulative(msg);\n+        consumer.close();\n+    }\n+\n+    protected <T> void testMessageOrderAndDuplicates(Set<T> messagesReceived, T receivedMessage,\n+                                                     T expectedMessage) {\n+        // Make sure that messages are received in order\n+        Assert.assertEquals(receivedMessage, expectedMessage,\n+                \"Received message \" + receivedMessage + \" did not match the expected message \" + expectedMessage);\n+\n+        // Make sure that there are no duplicates\n+        Assert.assertTrue(messagesReceived.add(receivedMessage), \"Received duplicate message \" + receivedMessage);\n+    }\n+\n+    @Test\n+    public void testRedeliveryOfFailedMessages() throws Exception {\n+\n+        @Cleanup\n+        PulsarClient pulsarClient = PulsarClient.builder()\n+                .serviceUrl(pulsarContainer.getPlainTextPulsarBrokerUrl())\n+                .build();\n+\n+        final String encryptionKeyName = \"client-rsa.pem\";\n+        final String encryptionKeyVersion = \"1.0\";\n+        Map<String, String> metadata = Maps.newHashMap();\n+        metadata.put(\"version\", encryptionKeyVersion);\n+        class EncKeyReader implements CryptoKeyReader {\n+            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();\n+\n+            @Override\n+            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {\n+                String CERT_FILE_PATH = \"./src/test/resources/certificate/public-key.\" + keyName;\n+                if (Files.isReadable(Paths.get(CERT_FILE_PATH))) {\n+                    try {\n+                        keyInfo.setKey(Files.readAllBytes(Paths.get(CERT_FILE_PATH)));\n+                        keyInfo.setMetadata(metadata);\n+                        return keyInfo;\n+                    } catch (IOException e) {\n+                        Assert.fail(\"Failed to read certificate from \" + CERT_FILE_PATH);\n+                    }\n+                } else {\n+                    Assert.fail(\"Certificate file \" + CERT_FILE_PATH + \" is not present or not readable.\");\n+                }\n+                return null;\n+            }\n+\n+            @Override\n+            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> keyMeta) {\n+                String CERT_FILE_PATH = \"./src/test/resources/certificate/private-key.\" + keyName;\n+                if (Files.isReadable(Paths.get(CERT_FILE_PATH))) {\n+                    try {\n+                        keyInfo.setKey(Files.readAllBytes(Paths.get(CERT_FILE_PATH)));\n+                        keyInfo.setMetadata(metadata);\n+                        return keyInfo;\n+                    } catch (IOException e) {\n+                        Assert.fail(\"Failed to read certificate from \" + CERT_FILE_PATH);\n+                    }\n+                } else {\n+                    Assert.fail(\"Certificate file \" + CERT_FILE_PATH + \" is not present or not readable.\");\n+                }\n+                return null;\n+            }\n+        }\n+\n+        class InvalidKeyReader implements CryptoKeyReader {\n+            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();\n+\n+            @Override\n+            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {\n+                return null;\n+            }\n+\n+            @Override\n+            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> metadata) {\n+                return null;\n+            }\n+        }\n+\n+        /*\n+         * Redelivery functionality guarantees that customer will get a chance to process the message again.\n+         * In case of shared subscription eventually every client will get a chance to process the message, till one of them acks it.\n+         *\n+         * For client with Encryption enabled where in cases like a new production rollout or a buggy client configuration, we might have a mismatch of consumers\n+         * - few which can decrypt, few which can't (due to errors or cryptoReader not configured).\n+         *\n+         * In that case eventually all messages should be acked as long as there is a single consumer who can decrypt the message.\n+         *\n+         * Consumer 1 - Can decrypt message\n+         * Consumer 2 - Has invalid Reader configured.\n+         * Consumer 3 - Has no reader configured.\n+         *\n+         */\n+\n+        String topicName = \"persistent://my-property/my-ns/myrsa-topic2\";\n+\n+        Producer<byte[]> producer = pulsarClient.newProducer().topic(topicName)\n+                .addEncryptionKey(encryptionKeyName).compressionType(CompressionType.LZ4)\n+                .cryptoKeyReader(new EncKeyReader()).create();\n+\n+        PulsarClient newPulsarClient = newPulsarClient(lookupUrl.toString(), 0);// Creates new client connection\n+        Consumer<byte[]> consumer1 = newPulsarClient.newConsumer().topicsPattern(topicName)\n+                .subscriptionName(\"my-subscriber-name\").cryptoKeyReader(new EncKeyReader())\n+                .subscriptionType(SubscriptionType.Shared).ackTimeout(1, TimeUnit.SECONDS).subscribe();\n+\n+        PulsarClient newPulsarClient1 = newPulsarClient(lookupUrl.toString(), 0);// Creates new client connection\n+        Consumer<byte[]> consumer2 = newPulsarClient1.newConsumer().topicsPattern(topicName)\n+                .subscriptionName(\"my-subscriber-name\").cryptoKeyReader(new InvalidKeyReader())\n+                .subscriptionType(SubscriptionType.Shared).ackTimeout(1, TimeUnit.SECONDS).subscribe();\n+\n+        PulsarClient newPulsarClient2 = newPulsarClient(lookupUrl.toString(), 0);// Creates new client connection\n+        Consumer<byte[]> consumer3 = newPulsarClient2.newConsumer().topicsPattern(topicName)\n+                .subscriptionName(\"my-subscriber-name\").subscriptionType(SubscriptionType.Shared).ackTimeout(1, TimeUnit.SECONDS).subscribe();\n+\n+        int numberOfMessages = 100;\n+        String message = \"my-message\";\n+        Set<String> messages = new HashSet(); // Since messages are in random order\n+        for (int i = 0; i<numberOfMessages; i++) {", "originalCommit": "c9d12e8aa9237c541d39ab3244be68ae9ede64f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzM3NjcwOQ==", "url": "https://github.com/apache/pulsar/pull/8962#discussion_r543376709", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    for (int i = 0; i<numberOfMessages; i++) {\n          \n          \n            \n                    for (int i = 0; i < numberOfMessages; i++) {", "author": "jbampton", "createdAt": "2020-12-15T14:13:58Z", "path": "tests/pulsar-client-admin-shade-test/src/test/java/org/apache/pulsar/tests/integration/SimpleProducerConsumerTest.java", "diffHunk": "@@ -0,0 +1,577 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.tests.integration;\n+\n+import lombok.Cleanup;\n+import org.apache.pulsar.client.admin.PulsarAdmin;\n+import org.apache.pulsar.client.admin.PulsarAdminException;\n+import org.apache.pulsar.client.api.*;\n+import org.apache.pulsar.client.impl.MessageImpl;\n+import org.apache.pulsar.client.impl.TopicMessageImpl;\n+import org.apache.pulsar.client.impl.crypto.MessageCryptoBc;\n+import org.apache.pulsar.common.api.EncryptionContext;\n+import org.apache.pulsar.common.api.proto.PulsarApi;\n+import org.apache.pulsar.common.compression.CompressionCodec;\n+import org.apache.pulsar.common.compression.CompressionCodecProvider;\n+import org.apache.pulsar.common.policies.data.TenantInfo;\n+import org.apache.pulsar.common.protocol.Commands;\n+import org.apache.pulsar.shade.com.google.common.collect.Maps;\n+import org.apache.pulsar.shade.com.google.common.collect.Sets;\n+import org.apache.pulsar.shade.io.netty.buffer.ByteBuf;\n+import org.apache.pulsar.shade.io.netty.buffer.Unpooled;\n+import org.apache.pulsar.shaded.com.google.protobuf.v241.ByteString;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.security.Security;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.testng.Assert.*;\n+\n+public class SimpleProducerConsumerTest {\n+    private static final Logger log = LoggerFactory.getLogger(SimpleProducerConsumerTest.class);\n+\n+    private PulsarContainer pulsarContainer;\n+    private URI lookupUrl;\n+    private PulsarClient pulsarClient;\n+\n+    @BeforeClass\n+    public void setup() throws PulsarClientException, URISyntaxException, PulsarAdminException {\n+        Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());\n+\n+        pulsarContainer = new PulsarContainer();\n+        pulsarContainer.start();\n+        pulsarClient = PulsarClient.builder()\n+                .serviceUrl(pulsarContainer.getPlainTextPulsarBrokerUrl())\n+                .build();\n+        lookupUrl = new URI(pulsarContainer.getPlainTextPulsarBrokerUrl());\n+\n+        PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(pulsarContainer.getPulsarAdminUrl()).build();\n+        admin.tenants().createTenant(\"my-property\",\n+                new TenantInfo(Sets.newHashSet(\"appid1\", \"appid2\"), Sets.newHashSet(\"standalone\")));\n+        admin.namespaces().createNamespace(\"my-property/my-ns\");\n+        admin.namespaces().setNamespaceReplicationClusters(\"my-property/my-ns\", Sets.newHashSet(\"standalone\"));\n+        admin.close();\n+    }\n+\n+    @AfterClass\n+    public void cleanup() throws PulsarClientException {\n+        pulsarClient.close();\n+        pulsarContainer.stop();\n+        pulsarContainer.close();\n+    }\n+\n+    private PulsarClient newPulsarClient(String url, int intervalInSecs) throws PulsarClientException {\n+        return PulsarClient.builder().serviceUrl(url).statsInterval(intervalInSecs, TimeUnit.SECONDS).build();\n+    }\n+\n+    @Test\n+    public void testRSAEncryption() throws Exception {\n+\n+        String topicName = \"persistent://my-property/my-ns/myrsa-topic1-\"+ System.currentTimeMillis();\n+\n+        class EncKeyReader implements CryptoKeyReader {\n+\n+            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();\n+\n+            @Override\n+            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {\n+                String CERT_FILE_PATH = \"./src/test/resources/certificate/public-key.\" + keyName;\n+                if (Files.isReadable(Paths.get(CERT_FILE_PATH))) {\n+                    try {\n+                        keyInfo.setKey(Files.readAllBytes(Paths.get(CERT_FILE_PATH)));\n+                        return keyInfo;\n+                    } catch (IOException e) {\n+                        Assert.fail(\"Failed to read certificate from \" + CERT_FILE_PATH);\n+                    }\n+                } else {\n+                    Assert.fail(\"Certificate file \" + CERT_FILE_PATH + \" is not present or not readable.\");\n+                }\n+                return null;\n+            }\n+\n+            @Override\n+            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> keyMeta) {\n+                String CERT_FILE_PATH = \"./src/test/resources/certificate/private-key.\" + keyName;\n+                if (Files.isReadable(Paths.get(CERT_FILE_PATH))) {\n+                    try {\n+                        keyInfo.setKey(Files.readAllBytes(Paths.get(CERT_FILE_PATH)));\n+                        return keyInfo;\n+                    } catch (IOException e) {\n+                        Assert.fail(\"Failed to read certificate from \" + CERT_FILE_PATH);\n+                    }\n+                } else {\n+                    Assert.fail(\"Certificate file \" + CERT_FILE_PATH + \" is not present or not readable.\");\n+                }\n+                return null;\n+            }\n+        }\n+\n+        final int totalMsg = 10;\n+\n+        Set<String> messageSet = Sets.newHashSet();\n+        Consumer<byte[]> consumer = pulsarClient.newConsumer().topic(\"persistent://my-property/my-ns/myrsa-topic1\")\n+                .subscriptionName(\"my-subscriber-name\").cryptoKeyReader(new EncKeyReader()).subscribe();\n+        Consumer<byte[]> normalConsumer = pulsarClient.newConsumer()\n+                .topic(topicName).subscriptionName(\"my-subscriber-name-normal\")\n+                .subscribe();\n+\n+        Producer<byte[]> producer = pulsarClient.newProducer().topic(\"persistent://my-property/my-ns/myrsa-topic1\")\n+                .addEncryptionKey(\"client-rsa.pem\").cryptoKeyReader(new EncKeyReader()).create();\n+        Producer<byte[]> producer2 = pulsarClient.newProducer().topic(\"persistent://my-property/my-ns/myrsa-topic1\")\n+                .addEncryptionKey(\"client-rsa.pem\").cryptoKeyReader(new EncKeyReader()).create();\n+\n+        for (int i = 0; i < totalMsg; i++) {\n+            String message = \"my-message-\" + i;\n+            producer.send(message.getBytes());\n+        }\n+        for (int i = totalMsg; i < totalMsg * 2; i++) {\n+            String message = \"my-message-\" + i;\n+            producer2.send(message.getBytes());\n+        }\n+\n+        MessageImpl<byte[]> msg = null;\n+\n+        msg = (MessageImpl<byte[]>) normalConsumer.receive(500, TimeUnit.MILLISECONDS);\n+        // should not able to read message using normal message.\n+        assertNull(msg);\n+\n+        for (int i = 0; i < totalMsg * 2; i++) {\n+            msg = (MessageImpl<byte[]>) consumer.receive(5, TimeUnit.SECONDS);\n+            // verify that encrypted message contains encryption-context\n+            msg.getEncryptionCtx()\n+                    .orElseThrow(() -> new IllegalStateException(\"encryption-ctx not present for encrypted message\"));\n+            String receivedMessage = new String(msg.getData());\n+            log.debug(\"Received message: [{}]\", receivedMessage);\n+            String expectedMessage = \"my-message-\" + i;\n+            testMessageOrderAndDuplicates(messageSet, receivedMessage, expectedMessage);\n+        }\n+        // Acknowledge the consumption of all messages at once\n+        consumer.acknowledgeCumulative(msg);\n+        consumer.close();\n+    }\n+\n+    protected <T> void testMessageOrderAndDuplicates(Set<T> messagesReceived, T receivedMessage,\n+                                                     T expectedMessage) {\n+        // Make sure that messages are received in order\n+        Assert.assertEquals(receivedMessage, expectedMessage,\n+                \"Received message \" + receivedMessage + \" did not match the expected message \" + expectedMessage);\n+\n+        // Make sure that there are no duplicates\n+        Assert.assertTrue(messagesReceived.add(receivedMessage), \"Received duplicate message \" + receivedMessage);\n+    }\n+\n+    @Test\n+    public void testRedeliveryOfFailedMessages() throws Exception {\n+\n+        @Cleanup\n+        PulsarClient pulsarClient = PulsarClient.builder()\n+                .serviceUrl(pulsarContainer.getPlainTextPulsarBrokerUrl())\n+                .build();\n+\n+        final String encryptionKeyName = \"client-rsa.pem\";\n+        final String encryptionKeyVersion = \"1.0\";\n+        Map<String, String> metadata = Maps.newHashMap();\n+        metadata.put(\"version\", encryptionKeyVersion);\n+        class EncKeyReader implements CryptoKeyReader {\n+            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();\n+\n+            @Override\n+            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {\n+                String CERT_FILE_PATH = \"./src/test/resources/certificate/public-key.\" + keyName;\n+                if (Files.isReadable(Paths.get(CERT_FILE_PATH))) {\n+                    try {\n+                        keyInfo.setKey(Files.readAllBytes(Paths.get(CERT_FILE_PATH)));\n+                        keyInfo.setMetadata(metadata);\n+                        return keyInfo;\n+                    } catch (IOException e) {\n+                        Assert.fail(\"Failed to read certificate from \" + CERT_FILE_PATH);\n+                    }\n+                } else {\n+                    Assert.fail(\"Certificate file \" + CERT_FILE_PATH + \" is not present or not readable.\");\n+                }\n+                return null;\n+            }\n+\n+            @Override\n+            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> keyMeta) {\n+                String CERT_FILE_PATH = \"./src/test/resources/certificate/private-key.\" + keyName;\n+                if (Files.isReadable(Paths.get(CERT_FILE_PATH))) {\n+                    try {\n+                        keyInfo.setKey(Files.readAllBytes(Paths.get(CERT_FILE_PATH)));\n+                        keyInfo.setMetadata(metadata);\n+                        return keyInfo;\n+                    } catch (IOException e) {\n+                        Assert.fail(\"Failed to read certificate from \" + CERT_FILE_PATH);\n+                    }\n+                } else {\n+                    Assert.fail(\"Certificate file \" + CERT_FILE_PATH + \" is not present or not readable.\");\n+                }\n+                return null;\n+            }\n+        }\n+\n+        class InvalidKeyReader implements CryptoKeyReader {\n+            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();\n+\n+            @Override\n+            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {\n+                return null;\n+            }\n+\n+            @Override\n+            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> metadata) {\n+                return null;\n+            }\n+        }\n+\n+        /*\n+         * Redelivery functionality guarantees that customer will get a chance to process the message again.\n+         * In case of shared subscription eventually every client will get a chance to process the message, till one of them acks it.\n+         *\n+         * For client with Encryption enabled where in cases like a new production rollout or a buggy client configuration, we might have a mismatch of consumers\n+         * - few which can decrypt, few which can't (due to errors or cryptoReader not configured).\n+         *\n+         * In that case eventually all messages should be acked as long as there is a single consumer who can decrypt the message.\n+         *\n+         * Consumer 1 - Can decrypt message\n+         * Consumer 2 - Has invalid Reader configured.\n+         * Consumer 3 - Has no reader configured.\n+         *\n+         */\n+\n+        String topicName = \"persistent://my-property/my-ns/myrsa-topic2\";\n+\n+        Producer<byte[]> producer = pulsarClient.newProducer().topic(topicName)\n+                .addEncryptionKey(encryptionKeyName).compressionType(CompressionType.LZ4)\n+                .cryptoKeyReader(new EncKeyReader()).create();\n+\n+        PulsarClient newPulsarClient = newPulsarClient(lookupUrl.toString(), 0);// Creates new client connection\n+        Consumer<byte[]> consumer1 = newPulsarClient.newConsumer().topicsPattern(topicName)\n+                .subscriptionName(\"my-subscriber-name\").cryptoKeyReader(new EncKeyReader())\n+                .subscriptionType(SubscriptionType.Shared).ackTimeout(1, TimeUnit.SECONDS).subscribe();\n+\n+        PulsarClient newPulsarClient1 = newPulsarClient(lookupUrl.toString(), 0);// Creates new client connection\n+        Consumer<byte[]> consumer2 = newPulsarClient1.newConsumer().topicsPattern(topicName)\n+                .subscriptionName(\"my-subscriber-name\").cryptoKeyReader(new InvalidKeyReader())\n+                .subscriptionType(SubscriptionType.Shared).ackTimeout(1, TimeUnit.SECONDS).subscribe();\n+\n+        PulsarClient newPulsarClient2 = newPulsarClient(lookupUrl.toString(), 0);// Creates new client connection\n+        Consumer<byte[]> consumer3 = newPulsarClient2.newConsumer().topicsPattern(topicName)\n+                .subscriptionName(\"my-subscriber-name\").subscriptionType(SubscriptionType.Shared).ackTimeout(1, TimeUnit.SECONDS).subscribe();\n+\n+        int numberOfMessages = 100;\n+        String message = \"my-message\";\n+        Set<String> messages = new HashSet(); // Since messages are in random order\n+        for (int i = 0; i<numberOfMessages; i++) {\n+            producer.send((message + i).getBytes());\n+        }\n+\n+        // Consuming from consumer 2 and 3\n+        // no message should be returned since they can't decrypt the message\n+        Message m = consumer2.receive(3, TimeUnit.SECONDS);\n+        assertNull(m);\n+        m = consumer3.receive(3, TimeUnit.SECONDS);\n+        assertNull(m);\n+\n+        for (int i = 0; i<numberOfMessages; i++) {", "originalCommit": "c9d12e8aa9237c541d39ab3244be68ae9ede64f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzM3NzA2OA==", "url": "https://github.com/apache/pulsar/pull/8962#discussion_r543377068", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    for (int i = 0; i<numberOfMessages; i++) {\n          \n          \n            \n                    for (int i = 0; i < numberOfMessages; i++) {", "author": "jbampton", "createdAt": "2020-12-15T14:14:17Z", "path": "tests/pulsar-client-admin-shade-test/src/test/java/org/apache/pulsar/tests/integration/SimpleProducerConsumerTest.java", "diffHunk": "@@ -0,0 +1,577 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.tests.integration;\n+\n+import lombok.Cleanup;\n+import org.apache.pulsar.client.admin.PulsarAdmin;\n+import org.apache.pulsar.client.admin.PulsarAdminException;\n+import org.apache.pulsar.client.api.*;\n+import org.apache.pulsar.client.impl.MessageImpl;\n+import org.apache.pulsar.client.impl.TopicMessageImpl;\n+import org.apache.pulsar.client.impl.crypto.MessageCryptoBc;\n+import org.apache.pulsar.common.api.EncryptionContext;\n+import org.apache.pulsar.common.api.proto.PulsarApi;\n+import org.apache.pulsar.common.compression.CompressionCodec;\n+import org.apache.pulsar.common.compression.CompressionCodecProvider;\n+import org.apache.pulsar.common.policies.data.TenantInfo;\n+import org.apache.pulsar.common.protocol.Commands;\n+import org.apache.pulsar.shade.com.google.common.collect.Maps;\n+import org.apache.pulsar.shade.com.google.common.collect.Sets;\n+import org.apache.pulsar.shade.io.netty.buffer.ByteBuf;\n+import org.apache.pulsar.shade.io.netty.buffer.Unpooled;\n+import org.apache.pulsar.shaded.com.google.protobuf.v241.ByteString;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.security.Security;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.testng.Assert.*;\n+\n+public class SimpleProducerConsumerTest {\n+    private static final Logger log = LoggerFactory.getLogger(SimpleProducerConsumerTest.class);\n+\n+    private PulsarContainer pulsarContainer;\n+    private URI lookupUrl;\n+    private PulsarClient pulsarClient;\n+\n+    @BeforeClass\n+    public void setup() throws PulsarClientException, URISyntaxException, PulsarAdminException {\n+        Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());\n+\n+        pulsarContainer = new PulsarContainer();\n+        pulsarContainer.start();\n+        pulsarClient = PulsarClient.builder()\n+                .serviceUrl(pulsarContainer.getPlainTextPulsarBrokerUrl())\n+                .build();\n+        lookupUrl = new URI(pulsarContainer.getPlainTextPulsarBrokerUrl());\n+\n+        PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(pulsarContainer.getPulsarAdminUrl()).build();\n+        admin.tenants().createTenant(\"my-property\",\n+                new TenantInfo(Sets.newHashSet(\"appid1\", \"appid2\"), Sets.newHashSet(\"standalone\")));\n+        admin.namespaces().createNamespace(\"my-property/my-ns\");\n+        admin.namespaces().setNamespaceReplicationClusters(\"my-property/my-ns\", Sets.newHashSet(\"standalone\"));\n+        admin.close();\n+    }\n+\n+    @AfterClass\n+    public void cleanup() throws PulsarClientException {\n+        pulsarClient.close();\n+        pulsarContainer.stop();\n+        pulsarContainer.close();\n+    }\n+\n+    private PulsarClient newPulsarClient(String url, int intervalInSecs) throws PulsarClientException {\n+        return PulsarClient.builder().serviceUrl(url).statsInterval(intervalInSecs, TimeUnit.SECONDS).build();\n+    }\n+\n+    @Test\n+    public void testRSAEncryption() throws Exception {\n+\n+        String topicName = \"persistent://my-property/my-ns/myrsa-topic1-\"+ System.currentTimeMillis();\n+\n+        class EncKeyReader implements CryptoKeyReader {\n+\n+            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();\n+\n+            @Override\n+            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {\n+                String CERT_FILE_PATH = \"./src/test/resources/certificate/public-key.\" + keyName;\n+                if (Files.isReadable(Paths.get(CERT_FILE_PATH))) {\n+                    try {\n+                        keyInfo.setKey(Files.readAllBytes(Paths.get(CERT_FILE_PATH)));\n+                        return keyInfo;\n+                    } catch (IOException e) {\n+                        Assert.fail(\"Failed to read certificate from \" + CERT_FILE_PATH);\n+                    }\n+                } else {\n+                    Assert.fail(\"Certificate file \" + CERT_FILE_PATH + \" is not present or not readable.\");\n+                }\n+                return null;\n+            }\n+\n+            @Override\n+            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> keyMeta) {\n+                String CERT_FILE_PATH = \"./src/test/resources/certificate/private-key.\" + keyName;\n+                if (Files.isReadable(Paths.get(CERT_FILE_PATH))) {\n+                    try {\n+                        keyInfo.setKey(Files.readAllBytes(Paths.get(CERT_FILE_PATH)));\n+                        return keyInfo;\n+                    } catch (IOException e) {\n+                        Assert.fail(\"Failed to read certificate from \" + CERT_FILE_PATH);\n+                    }\n+                } else {\n+                    Assert.fail(\"Certificate file \" + CERT_FILE_PATH + \" is not present or not readable.\");\n+                }\n+                return null;\n+            }\n+        }\n+\n+        final int totalMsg = 10;\n+\n+        Set<String> messageSet = Sets.newHashSet();\n+        Consumer<byte[]> consumer = pulsarClient.newConsumer().topic(\"persistent://my-property/my-ns/myrsa-topic1\")\n+                .subscriptionName(\"my-subscriber-name\").cryptoKeyReader(new EncKeyReader()).subscribe();\n+        Consumer<byte[]> normalConsumer = pulsarClient.newConsumer()\n+                .topic(topicName).subscriptionName(\"my-subscriber-name-normal\")\n+                .subscribe();\n+\n+        Producer<byte[]> producer = pulsarClient.newProducer().topic(\"persistent://my-property/my-ns/myrsa-topic1\")\n+                .addEncryptionKey(\"client-rsa.pem\").cryptoKeyReader(new EncKeyReader()).create();\n+        Producer<byte[]> producer2 = pulsarClient.newProducer().topic(\"persistent://my-property/my-ns/myrsa-topic1\")\n+                .addEncryptionKey(\"client-rsa.pem\").cryptoKeyReader(new EncKeyReader()).create();\n+\n+        for (int i = 0; i < totalMsg; i++) {\n+            String message = \"my-message-\" + i;\n+            producer.send(message.getBytes());\n+        }\n+        for (int i = totalMsg; i < totalMsg * 2; i++) {\n+            String message = \"my-message-\" + i;\n+            producer2.send(message.getBytes());\n+        }\n+\n+        MessageImpl<byte[]> msg = null;\n+\n+        msg = (MessageImpl<byte[]>) normalConsumer.receive(500, TimeUnit.MILLISECONDS);\n+        // should not able to read message using normal message.\n+        assertNull(msg);\n+\n+        for (int i = 0; i < totalMsg * 2; i++) {\n+            msg = (MessageImpl<byte[]>) consumer.receive(5, TimeUnit.SECONDS);\n+            // verify that encrypted message contains encryption-context\n+            msg.getEncryptionCtx()\n+                    .orElseThrow(() -> new IllegalStateException(\"encryption-ctx not present for encrypted message\"));\n+            String receivedMessage = new String(msg.getData());\n+            log.debug(\"Received message: [{}]\", receivedMessage);\n+            String expectedMessage = \"my-message-\" + i;\n+            testMessageOrderAndDuplicates(messageSet, receivedMessage, expectedMessage);\n+        }\n+        // Acknowledge the consumption of all messages at once\n+        consumer.acknowledgeCumulative(msg);\n+        consumer.close();\n+    }\n+\n+    protected <T> void testMessageOrderAndDuplicates(Set<T> messagesReceived, T receivedMessage,\n+                                                     T expectedMessage) {\n+        // Make sure that messages are received in order\n+        Assert.assertEquals(receivedMessage, expectedMessage,\n+                \"Received message \" + receivedMessage + \" did not match the expected message \" + expectedMessage);\n+\n+        // Make sure that there are no duplicates\n+        Assert.assertTrue(messagesReceived.add(receivedMessage), \"Received duplicate message \" + receivedMessage);\n+    }\n+\n+    @Test\n+    public void testRedeliveryOfFailedMessages() throws Exception {\n+\n+        @Cleanup\n+        PulsarClient pulsarClient = PulsarClient.builder()\n+                .serviceUrl(pulsarContainer.getPlainTextPulsarBrokerUrl())\n+                .build();\n+\n+        final String encryptionKeyName = \"client-rsa.pem\";\n+        final String encryptionKeyVersion = \"1.0\";\n+        Map<String, String> metadata = Maps.newHashMap();\n+        metadata.put(\"version\", encryptionKeyVersion);\n+        class EncKeyReader implements CryptoKeyReader {\n+            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();\n+\n+            @Override\n+            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {\n+                String CERT_FILE_PATH = \"./src/test/resources/certificate/public-key.\" + keyName;\n+                if (Files.isReadable(Paths.get(CERT_FILE_PATH))) {\n+                    try {\n+                        keyInfo.setKey(Files.readAllBytes(Paths.get(CERT_FILE_PATH)));\n+                        keyInfo.setMetadata(metadata);\n+                        return keyInfo;\n+                    } catch (IOException e) {\n+                        Assert.fail(\"Failed to read certificate from \" + CERT_FILE_PATH);\n+                    }\n+                } else {\n+                    Assert.fail(\"Certificate file \" + CERT_FILE_PATH + \" is not present or not readable.\");\n+                }\n+                return null;\n+            }\n+\n+            @Override\n+            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> keyMeta) {\n+                String CERT_FILE_PATH = \"./src/test/resources/certificate/private-key.\" + keyName;\n+                if (Files.isReadable(Paths.get(CERT_FILE_PATH))) {\n+                    try {\n+                        keyInfo.setKey(Files.readAllBytes(Paths.get(CERT_FILE_PATH)));\n+                        keyInfo.setMetadata(metadata);\n+                        return keyInfo;\n+                    } catch (IOException e) {\n+                        Assert.fail(\"Failed to read certificate from \" + CERT_FILE_PATH);\n+                    }\n+                } else {\n+                    Assert.fail(\"Certificate file \" + CERT_FILE_PATH + \" is not present or not readable.\");\n+                }\n+                return null;\n+            }\n+        }\n+\n+        class InvalidKeyReader implements CryptoKeyReader {\n+            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();\n+\n+            @Override\n+            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {\n+                return null;\n+            }\n+\n+            @Override\n+            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> metadata) {\n+                return null;\n+            }\n+        }\n+\n+        /*\n+         * Redelivery functionality guarantees that customer will get a chance to process the message again.\n+         * In case of shared subscription eventually every client will get a chance to process the message, till one of them acks it.\n+         *\n+         * For client with Encryption enabled where in cases like a new production rollout or a buggy client configuration, we might have a mismatch of consumers\n+         * - few which can decrypt, few which can't (due to errors or cryptoReader not configured).\n+         *\n+         * In that case eventually all messages should be acked as long as there is a single consumer who can decrypt the message.\n+         *\n+         * Consumer 1 - Can decrypt message\n+         * Consumer 2 - Has invalid Reader configured.\n+         * Consumer 3 - Has no reader configured.\n+         *\n+         */\n+\n+        String topicName = \"persistent://my-property/my-ns/myrsa-topic2\";\n+\n+        Producer<byte[]> producer = pulsarClient.newProducer().topic(topicName)\n+                .addEncryptionKey(encryptionKeyName).compressionType(CompressionType.LZ4)\n+                .cryptoKeyReader(new EncKeyReader()).create();\n+\n+        PulsarClient newPulsarClient = newPulsarClient(lookupUrl.toString(), 0);// Creates new client connection\n+        Consumer<byte[]> consumer1 = newPulsarClient.newConsumer().topicsPattern(topicName)\n+                .subscriptionName(\"my-subscriber-name\").cryptoKeyReader(new EncKeyReader())\n+                .subscriptionType(SubscriptionType.Shared).ackTimeout(1, TimeUnit.SECONDS).subscribe();\n+\n+        PulsarClient newPulsarClient1 = newPulsarClient(lookupUrl.toString(), 0);// Creates new client connection\n+        Consumer<byte[]> consumer2 = newPulsarClient1.newConsumer().topicsPattern(topicName)\n+                .subscriptionName(\"my-subscriber-name\").cryptoKeyReader(new InvalidKeyReader())\n+                .subscriptionType(SubscriptionType.Shared).ackTimeout(1, TimeUnit.SECONDS).subscribe();\n+\n+        PulsarClient newPulsarClient2 = newPulsarClient(lookupUrl.toString(), 0);// Creates new client connection\n+        Consumer<byte[]> consumer3 = newPulsarClient2.newConsumer().topicsPattern(topicName)\n+                .subscriptionName(\"my-subscriber-name\").subscriptionType(SubscriptionType.Shared).ackTimeout(1, TimeUnit.SECONDS).subscribe();\n+\n+        int numberOfMessages = 100;\n+        String message = \"my-message\";\n+        Set<String> messages = new HashSet(); // Since messages are in random order\n+        for (int i = 0; i<numberOfMessages; i++) {\n+            producer.send((message + i).getBytes());\n+        }\n+\n+        // Consuming from consumer 2 and 3\n+        // no message should be returned since they can't decrypt the message\n+        Message m = consumer2.receive(3, TimeUnit.SECONDS);\n+        assertNull(m);\n+        m = consumer3.receive(3, TimeUnit.SECONDS);\n+        assertNull(m);\n+\n+        for (int i = 0; i<numberOfMessages; i++) {\n+            // All messages would be received by consumer 1\n+            m = consumer1.receive();\n+            messages.add(new String(m.getData()));\n+            consumer1.acknowledge(m);\n+        }\n+\n+        // Consuming from consumer 2 and 3 again just to be sure\n+        // no message should be returned since they can't decrypt the message\n+        m = consumer2.receive(3, TimeUnit.SECONDS);\n+        assertNull(m);\n+        m = consumer3.receive(3, TimeUnit.SECONDS);\n+        assertNull(m);\n+\n+        // checking if all messages were received\n+        for (int i = 0; i<numberOfMessages; i++) {", "originalCommit": "c9d12e8aa9237c541d39ab3244be68ae9ede64f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzM4MDg2Ng==", "url": "https://github.com/apache/pulsar/pull/8962#discussion_r543380866", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    String topicName = \"persistent://my-property/my-ns/myrsa-topic1-\"+ System.currentTimeMillis();\n          \n          \n            \n                    String topicName = \"persistent://my-property/my-ns/myrsa-topic1-\" + System.currentTimeMillis();", "author": "jbampton", "createdAt": "2020-12-15T14:17:11Z", "path": "tests/pulsar-client-shade-test/src/test/java/org/apache/pulsar/tests/integration/SimpleProducerConsumerTest.java", "diffHunk": "@@ -0,0 +1,576 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.tests.integration;\n+\n+import lombok.Cleanup;\n+import org.apache.pulsar.client.admin.PulsarAdmin;\n+import org.apache.pulsar.client.admin.PulsarAdminException;\n+import org.apache.pulsar.client.api.*;\n+import org.apache.pulsar.client.impl.MessageImpl;\n+import org.apache.pulsar.client.impl.TopicMessageImpl;\n+import org.apache.pulsar.client.impl.crypto.MessageCryptoBc;\n+import org.apache.pulsar.common.api.EncryptionContext;\n+import org.apache.pulsar.common.api.proto.PulsarApi;\n+import org.apache.pulsar.common.compression.CompressionCodec;\n+import org.apache.pulsar.common.compression.CompressionCodecProvider;\n+import org.apache.pulsar.common.policies.data.TenantInfo;\n+import org.apache.pulsar.common.protocol.Commands;\n+import org.apache.pulsar.shade.com.google.common.collect.Maps;\n+import org.apache.pulsar.shade.com.google.common.collect.Sets;\n+import org.apache.pulsar.shade.io.netty.buffer.ByteBuf;\n+import org.apache.pulsar.shade.io.netty.buffer.Unpooled;\n+import org.apache.pulsar.shaded.com.google.protobuf.v241.ByteString;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.security.Security;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.testng.Assert.*;\n+\n+public class SimpleProducerConsumerTest {\n+    private static final Logger log = LoggerFactory.getLogger(SimpleProducerConsumerTest.class);\n+\n+    private PulsarContainer pulsarContainer;\n+    private URI lookupUrl;\n+    private PulsarClient pulsarClient;\n+\n+    @BeforeClass\n+    public void setup() throws PulsarClientException, URISyntaxException, PulsarAdminException {\n+        Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());\n+        pulsarContainer = new PulsarContainer();\n+        pulsarContainer.start();\n+        pulsarClient = PulsarClient.builder()\n+                .serviceUrl(pulsarContainer.getPlainTextPulsarBrokerUrl())\n+                .build();\n+        lookupUrl = new URI(pulsarContainer.getPlainTextPulsarBrokerUrl());\n+\n+        PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(pulsarContainer.getPulsarAdminUrl()).build();\n+        admin.tenants().createTenant(\"my-property\",\n+                new TenantInfo(Sets.newHashSet(\"appid1\", \"appid2\"), Sets.newHashSet(\"standalone\")));\n+        admin.namespaces().createNamespace(\"my-property/my-ns\");\n+        admin.namespaces().setNamespaceReplicationClusters(\"my-property/my-ns\", Sets.newHashSet(\"standalone\"));\n+        admin.close();\n+    }\n+\n+    @AfterClass\n+    public void cleanup() throws PulsarClientException {\n+        pulsarClient.close();\n+        pulsarContainer.stop();\n+        pulsarContainer.close();\n+    }\n+\n+    private PulsarClient newPulsarClient(String url, int intervalInSecs) throws PulsarClientException {\n+        return PulsarClient.builder().serviceUrl(url).statsInterval(intervalInSecs, TimeUnit.SECONDS).build();\n+    }\n+\n+    @Test\n+    public void testRSAEncryption() throws Exception {\n+\n+        String topicName = \"persistent://my-property/my-ns/myrsa-topic1-\"+ System.currentTimeMillis();", "originalCommit": "c9d12e8aa9237c541d39ab3244be68ae9ede64f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzM4MjM5OQ==", "url": "https://github.com/apache/pulsar/pull/8962#discussion_r543382399", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Set<String> messages = new HashSet(); // Since messages are in random order\n          \n          \n            \n                    Set<String> messages = new HashSet();// Since messages are in random order", "author": "jbampton", "createdAt": "2020-12-15T14:18:19Z", "path": "tests/pulsar-client-shade-test/src/test/java/org/apache/pulsar/tests/integration/SimpleProducerConsumerTest.java", "diffHunk": "@@ -0,0 +1,576 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.tests.integration;\n+\n+import lombok.Cleanup;\n+import org.apache.pulsar.client.admin.PulsarAdmin;\n+import org.apache.pulsar.client.admin.PulsarAdminException;\n+import org.apache.pulsar.client.api.*;\n+import org.apache.pulsar.client.impl.MessageImpl;\n+import org.apache.pulsar.client.impl.TopicMessageImpl;\n+import org.apache.pulsar.client.impl.crypto.MessageCryptoBc;\n+import org.apache.pulsar.common.api.EncryptionContext;\n+import org.apache.pulsar.common.api.proto.PulsarApi;\n+import org.apache.pulsar.common.compression.CompressionCodec;\n+import org.apache.pulsar.common.compression.CompressionCodecProvider;\n+import org.apache.pulsar.common.policies.data.TenantInfo;\n+import org.apache.pulsar.common.protocol.Commands;\n+import org.apache.pulsar.shade.com.google.common.collect.Maps;\n+import org.apache.pulsar.shade.com.google.common.collect.Sets;\n+import org.apache.pulsar.shade.io.netty.buffer.ByteBuf;\n+import org.apache.pulsar.shade.io.netty.buffer.Unpooled;\n+import org.apache.pulsar.shaded.com.google.protobuf.v241.ByteString;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.security.Security;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.testng.Assert.*;\n+\n+public class SimpleProducerConsumerTest {\n+    private static final Logger log = LoggerFactory.getLogger(SimpleProducerConsumerTest.class);\n+\n+    private PulsarContainer pulsarContainer;\n+    private URI lookupUrl;\n+    private PulsarClient pulsarClient;\n+\n+    @BeforeClass\n+    public void setup() throws PulsarClientException, URISyntaxException, PulsarAdminException {\n+        Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());\n+        pulsarContainer = new PulsarContainer();\n+        pulsarContainer.start();\n+        pulsarClient = PulsarClient.builder()\n+                .serviceUrl(pulsarContainer.getPlainTextPulsarBrokerUrl())\n+                .build();\n+        lookupUrl = new URI(pulsarContainer.getPlainTextPulsarBrokerUrl());\n+\n+        PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(pulsarContainer.getPulsarAdminUrl()).build();\n+        admin.tenants().createTenant(\"my-property\",\n+                new TenantInfo(Sets.newHashSet(\"appid1\", \"appid2\"), Sets.newHashSet(\"standalone\")));\n+        admin.namespaces().createNamespace(\"my-property/my-ns\");\n+        admin.namespaces().setNamespaceReplicationClusters(\"my-property/my-ns\", Sets.newHashSet(\"standalone\"));\n+        admin.close();\n+    }\n+\n+    @AfterClass\n+    public void cleanup() throws PulsarClientException {\n+        pulsarClient.close();\n+        pulsarContainer.stop();\n+        pulsarContainer.close();\n+    }\n+\n+    private PulsarClient newPulsarClient(String url, int intervalInSecs) throws PulsarClientException {\n+        return PulsarClient.builder().serviceUrl(url).statsInterval(intervalInSecs, TimeUnit.SECONDS).build();\n+    }\n+\n+    @Test\n+    public void testRSAEncryption() throws Exception {\n+\n+        String topicName = \"persistent://my-property/my-ns/myrsa-topic1-\"+ System.currentTimeMillis();\n+\n+        class EncKeyReader implements CryptoKeyReader {\n+\n+            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();\n+\n+            @Override\n+            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {\n+                String CERT_FILE_PATH = \"./src/test/resources/certificate/public-key.\" + keyName;\n+                if (Files.isReadable(Paths.get(CERT_FILE_PATH))) {\n+                    try {\n+                        keyInfo.setKey(Files.readAllBytes(Paths.get(CERT_FILE_PATH)));\n+                        return keyInfo;\n+                    } catch (IOException e) {\n+                        Assert.fail(\"Failed to read certificate from \" + CERT_FILE_PATH);\n+                    }\n+                } else {\n+                    Assert.fail(\"Certificate file \" + CERT_FILE_PATH + \" is not present or not readable.\");\n+                }\n+                return null;\n+            }\n+\n+            @Override\n+            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> keyMeta) {\n+                String CERT_FILE_PATH = \"./src/test/resources/certificate/private-key.\" + keyName;\n+                if (Files.isReadable(Paths.get(CERT_FILE_PATH))) {\n+                    try {\n+                        keyInfo.setKey(Files.readAllBytes(Paths.get(CERT_FILE_PATH)));\n+                        return keyInfo;\n+                    } catch (IOException e) {\n+                        Assert.fail(\"Failed to read certificate from \" + CERT_FILE_PATH);\n+                    }\n+                } else {\n+                    Assert.fail(\"Certificate file \" + CERT_FILE_PATH + \" is not present or not readable.\");\n+                }\n+                return null;\n+            }\n+        }\n+\n+        final int totalMsg = 10;\n+\n+        Set<String> messageSet = Sets.newHashSet();\n+        Consumer<byte[]> consumer = pulsarClient.newConsumer().topic(\"persistent://my-property/my-ns/myrsa-topic1\")\n+                .subscriptionName(\"my-subscriber-name\").cryptoKeyReader(new EncKeyReader()).subscribe();\n+        Consumer<byte[]> normalConsumer = pulsarClient.newConsumer()\n+                .topic(topicName).subscriptionName(\"my-subscriber-name-normal\")\n+                .subscribe();\n+\n+        Producer<byte[]> producer = pulsarClient.newProducer().topic(\"persistent://my-property/my-ns/myrsa-topic1\")\n+                .addEncryptionKey(\"client-rsa.pem\").cryptoKeyReader(new EncKeyReader()).create();\n+        Producer<byte[]> producer2 = pulsarClient.newProducer().topic(\"persistent://my-property/my-ns/myrsa-topic1\")\n+                .addEncryptionKey(\"client-rsa.pem\").cryptoKeyReader(new EncKeyReader()).create();\n+\n+        for (int i = 0; i < totalMsg; i++) {\n+            String message = \"my-message-\" + i;\n+            producer.send(message.getBytes());\n+        }\n+        for (int i = totalMsg; i < totalMsg * 2; i++) {\n+            String message = \"my-message-\" + i;\n+            producer2.send(message.getBytes());\n+        }\n+\n+        MessageImpl<byte[]> msg = null;\n+\n+        msg = (MessageImpl<byte[]>) normalConsumer.receive(500, TimeUnit.MILLISECONDS);\n+        // should not able to read message using normal message.\n+        assertNull(msg);\n+\n+        for (int i = 0; i < totalMsg * 2; i++) {\n+            msg = (MessageImpl<byte[]>) consumer.receive(5, TimeUnit.SECONDS);\n+            // verify that encrypted message contains encryption-context\n+            msg.getEncryptionCtx()\n+                    .orElseThrow(() -> new IllegalStateException(\"encryption-ctx not present for encrypted message\"));\n+            String receivedMessage = new String(msg.getData());\n+            log.debug(\"Received message: [{}]\", receivedMessage);\n+            String expectedMessage = \"my-message-\" + i;\n+            testMessageOrderAndDuplicates(messageSet, receivedMessage, expectedMessage);\n+        }\n+        // Acknowledge the consumption of all messages at once\n+        consumer.acknowledgeCumulative(msg);\n+        consumer.close();\n+    }\n+\n+    protected <T> void testMessageOrderAndDuplicates(Set<T> messagesReceived, T receivedMessage,\n+                                                     T expectedMessage) {\n+        // Make sure that messages are received in order\n+        Assert.assertEquals(receivedMessage, expectedMessage,\n+                \"Received message \" + receivedMessage + \" did not match the expected message \" + expectedMessage);\n+\n+        // Make sure that there are no duplicates\n+        Assert.assertTrue(messagesReceived.add(receivedMessage), \"Received duplicate message \" + receivedMessage);\n+    }\n+\n+    @Test\n+    public void testRedeliveryOfFailedMessages() throws Exception {\n+\n+        @Cleanup\n+        PulsarClient pulsarClient = PulsarClient.builder()\n+                .serviceUrl(pulsarContainer.getPlainTextPulsarBrokerUrl())\n+                .build();\n+\n+        final String encryptionKeyName = \"client-rsa.pem\";\n+        final String encryptionKeyVersion = \"1.0\";\n+        Map<String, String> metadata = Maps.newHashMap();\n+        metadata.put(\"version\", encryptionKeyVersion);\n+        class EncKeyReader implements CryptoKeyReader {\n+            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();\n+\n+            @Override\n+            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {\n+                String CERT_FILE_PATH = \"./src/test/resources/certificate/public-key.\" + keyName;\n+                if (Files.isReadable(Paths.get(CERT_FILE_PATH))) {\n+                    try {\n+                        keyInfo.setKey(Files.readAllBytes(Paths.get(CERT_FILE_PATH)));\n+                        keyInfo.setMetadata(metadata);\n+                        return keyInfo;\n+                    } catch (IOException e) {\n+                        Assert.fail(\"Failed to read certificate from \" + CERT_FILE_PATH);\n+                    }\n+                } else {\n+                    Assert.fail(\"Certificate file \" + CERT_FILE_PATH + \" is not present or not readable.\");\n+                }\n+                return null;\n+            }\n+\n+            @Override\n+            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> keyMeta) {\n+                String CERT_FILE_PATH = \"./src/test/resources/certificate/private-key.\" + keyName;\n+                if (Files.isReadable(Paths.get(CERT_FILE_PATH))) {\n+                    try {\n+                        keyInfo.setKey(Files.readAllBytes(Paths.get(CERT_FILE_PATH)));\n+                        keyInfo.setMetadata(metadata);\n+                        return keyInfo;\n+                    } catch (IOException e) {\n+                        Assert.fail(\"Failed to read certificate from \" + CERT_FILE_PATH);\n+                    }\n+                } else {\n+                    Assert.fail(\"Certificate file \" + CERT_FILE_PATH + \" is not present or not readable.\");\n+                }\n+                return null;\n+            }\n+        }\n+\n+        class InvalidKeyReader implements CryptoKeyReader {\n+            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();\n+\n+            @Override\n+            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {\n+                return null;\n+            }\n+\n+            @Override\n+            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> metadata) {\n+                return null;\n+            }\n+        }\n+\n+        /*\n+         * Redelivery functionality guarantees that customer will get a chance to process the message again.\n+         * In case of shared subscription eventually every client will get a chance to process the message, till one of them acks it.\n+         *\n+         * For client with Encryption enabled where in cases like a new production rollout or a buggy client configuration, we might have a mismatch of consumers\n+         * - few which can decrypt, few which can't (due to errors or cryptoReader not configured).\n+         *\n+         * In that case eventually all messages should be acked as long as there is a single consumer who can decrypt the message.\n+         *\n+         * Consumer 1 - Can decrypt message\n+         * Consumer 2 - Has invalid Reader configured.\n+         * Consumer 3 - Has no reader configured.\n+         *\n+         */\n+\n+        String topicName = \"persistent://my-property/my-ns/myrsa-topic2\";\n+\n+        Producer<byte[]> producer = pulsarClient.newProducer().topic(topicName)\n+                .addEncryptionKey(encryptionKeyName).compressionType(CompressionType.LZ4)\n+                .cryptoKeyReader(new EncKeyReader()).create();\n+\n+        PulsarClient newPulsarClient = newPulsarClient(lookupUrl.toString(), 0);// Creates new client connection\n+        Consumer<byte[]> consumer1 = newPulsarClient.newConsumer().topicsPattern(topicName)\n+                .subscriptionName(\"my-subscriber-name\").cryptoKeyReader(new EncKeyReader())\n+                .subscriptionType(SubscriptionType.Shared).ackTimeout(1, TimeUnit.SECONDS).subscribe();\n+\n+        PulsarClient newPulsarClient1 = newPulsarClient(lookupUrl.toString(), 0);// Creates new client connection\n+        Consumer<byte[]> consumer2 = newPulsarClient1.newConsumer().topicsPattern(topicName)\n+                .subscriptionName(\"my-subscriber-name\").cryptoKeyReader(new InvalidKeyReader())\n+                .subscriptionType(SubscriptionType.Shared).ackTimeout(1, TimeUnit.SECONDS).subscribe();\n+\n+        PulsarClient newPulsarClient2 = newPulsarClient(lookupUrl.toString(), 0);// Creates new client connection\n+        Consumer<byte[]> consumer3 = newPulsarClient2.newConsumer().topicsPattern(topicName)\n+                .subscriptionName(\"my-subscriber-name\").subscriptionType(SubscriptionType.Shared).ackTimeout(1, TimeUnit.SECONDS).subscribe();\n+\n+        int numberOfMessages = 100;\n+        String message = \"my-message\";\n+        Set<String> messages = new HashSet(); // Since messages are in random order", "originalCommit": "c9d12e8aa9237c541d39ab3244be68ae9ede64f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzM4MjgxNw==", "url": "https://github.com/apache/pulsar/pull/8962#discussion_r543382817", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    for (int i = 0; i<numberOfMessages; i++) {\n          \n          \n            \n                    for (int i = 0; i < numberOfMessages; i++) {", "author": "jbampton", "createdAt": "2020-12-15T14:18:40Z", "path": "tests/pulsar-client-shade-test/src/test/java/org/apache/pulsar/tests/integration/SimpleProducerConsumerTest.java", "diffHunk": "@@ -0,0 +1,576 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.tests.integration;\n+\n+import lombok.Cleanup;\n+import org.apache.pulsar.client.admin.PulsarAdmin;\n+import org.apache.pulsar.client.admin.PulsarAdminException;\n+import org.apache.pulsar.client.api.*;\n+import org.apache.pulsar.client.impl.MessageImpl;\n+import org.apache.pulsar.client.impl.TopicMessageImpl;\n+import org.apache.pulsar.client.impl.crypto.MessageCryptoBc;\n+import org.apache.pulsar.common.api.EncryptionContext;\n+import org.apache.pulsar.common.api.proto.PulsarApi;\n+import org.apache.pulsar.common.compression.CompressionCodec;\n+import org.apache.pulsar.common.compression.CompressionCodecProvider;\n+import org.apache.pulsar.common.policies.data.TenantInfo;\n+import org.apache.pulsar.common.protocol.Commands;\n+import org.apache.pulsar.shade.com.google.common.collect.Maps;\n+import org.apache.pulsar.shade.com.google.common.collect.Sets;\n+import org.apache.pulsar.shade.io.netty.buffer.ByteBuf;\n+import org.apache.pulsar.shade.io.netty.buffer.Unpooled;\n+import org.apache.pulsar.shaded.com.google.protobuf.v241.ByteString;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.security.Security;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.testng.Assert.*;\n+\n+public class SimpleProducerConsumerTest {\n+    private static final Logger log = LoggerFactory.getLogger(SimpleProducerConsumerTest.class);\n+\n+    private PulsarContainer pulsarContainer;\n+    private URI lookupUrl;\n+    private PulsarClient pulsarClient;\n+\n+    @BeforeClass\n+    public void setup() throws PulsarClientException, URISyntaxException, PulsarAdminException {\n+        Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());\n+        pulsarContainer = new PulsarContainer();\n+        pulsarContainer.start();\n+        pulsarClient = PulsarClient.builder()\n+                .serviceUrl(pulsarContainer.getPlainTextPulsarBrokerUrl())\n+                .build();\n+        lookupUrl = new URI(pulsarContainer.getPlainTextPulsarBrokerUrl());\n+\n+        PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(pulsarContainer.getPulsarAdminUrl()).build();\n+        admin.tenants().createTenant(\"my-property\",\n+                new TenantInfo(Sets.newHashSet(\"appid1\", \"appid2\"), Sets.newHashSet(\"standalone\")));\n+        admin.namespaces().createNamespace(\"my-property/my-ns\");\n+        admin.namespaces().setNamespaceReplicationClusters(\"my-property/my-ns\", Sets.newHashSet(\"standalone\"));\n+        admin.close();\n+    }\n+\n+    @AfterClass\n+    public void cleanup() throws PulsarClientException {\n+        pulsarClient.close();\n+        pulsarContainer.stop();\n+        pulsarContainer.close();\n+    }\n+\n+    private PulsarClient newPulsarClient(String url, int intervalInSecs) throws PulsarClientException {\n+        return PulsarClient.builder().serviceUrl(url).statsInterval(intervalInSecs, TimeUnit.SECONDS).build();\n+    }\n+\n+    @Test\n+    public void testRSAEncryption() throws Exception {\n+\n+        String topicName = \"persistent://my-property/my-ns/myrsa-topic1-\"+ System.currentTimeMillis();\n+\n+        class EncKeyReader implements CryptoKeyReader {\n+\n+            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();\n+\n+            @Override\n+            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {\n+                String CERT_FILE_PATH = \"./src/test/resources/certificate/public-key.\" + keyName;\n+                if (Files.isReadable(Paths.get(CERT_FILE_PATH))) {\n+                    try {\n+                        keyInfo.setKey(Files.readAllBytes(Paths.get(CERT_FILE_PATH)));\n+                        return keyInfo;\n+                    } catch (IOException e) {\n+                        Assert.fail(\"Failed to read certificate from \" + CERT_FILE_PATH);\n+                    }\n+                } else {\n+                    Assert.fail(\"Certificate file \" + CERT_FILE_PATH + \" is not present or not readable.\");\n+                }\n+                return null;\n+            }\n+\n+            @Override\n+            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> keyMeta) {\n+                String CERT_FILE_PATH = \"./src/test/resources/certificate/private-key.\" + keyName;\n+                if (Files.isReadable(Paths.get(CERT_FILE_PATH))) {\n+                    try {\n+                        keyInfo.setKey(Files.readAllBytes(Paths.get(CERT_FILE_PATH)));\n+                        return keyInfo;\n+                    } catch (IOException e) {\n+                        Assert.fail(\"Failed to read certificate from \" + CERT_FILE_PATH);\n+                    }\n+                } else {\n+                    Assert.fail(\"Certificate file \" + CERT_FILE_PATH + \" is not present or not readable.\");\n+                }\n+                return null;\n+            }\n+        }\n+\n+        final int totalMsg = 10;\n+\n+        Set<String> messageSet = Sets.newHashSet();\n+        Consumer<byte[]> consumer = pulsarClient.newConsumer().topic(\"persistent://my-property/my-ns/myrsa-topic1\")\n+                .subscriptionName(\"my-subscriber-name\").cryptoKeyReader(new EncKeyReader()).subscribe();\n+        Consumer<byte[]> normalConsumer = pulsarClient.newConsumer()\n+                .topic(topicName).subscriptionName(\"my-subscriber-name-normal\")\n+                .subscribe();\n+\n+        Producer<byte[]> producer = pulsarClient.newProducer().topic(\"persistent://my-property/my-ns/myrsa-topic1\")\n+                .addEncryptionKey(\"client-rsa.pem\").cryptoKeyReader(new EncKeyReader()).create();\n+        Producer<byte[]> producer2 = pulsarClient.newProducer().topic(\"persistent://my-property/my-ns/myrsa-topic1\")\n+                .addEncryptionKey(\"client-rsa.pem\").cryptoKeyReader(new EncKeyReader()).create();\n+\n+        for (int i = 0; i < totalMsg; i++) {\n+            String message = \"my-message-\" + i;\n+            producer.send(message.getBytes());\n+        }\n+        for (int i = totalMsg; i < totalMsg * 2; i++) {\n+            String message = \"my-message-\" + i;\n+            producer2.send(message.getBytes());\n+        }\n+\n+        MessageImpl<byte[]> msg = null;\n+\n+        msg = (MessageImpl<byte[]>) normalConsumer.receive(500, TimeUnit.MILLISECONDS);\n+        // should not able to read message using normal message.\n+        assertNull(msg);\n+\n+        for (int i = 0; i < totalMsg * 2; i++) {\n+            msg = (MessageImpl<byte[]>) consumer.receive(5, TimeUnit.SECONDS);\n+            // verify that encrypted message contains encryption-context\n+            msg.getEncryptionCtx()\n+                    .orElseThrow(() -> new IllegalStateException(\"encryption-ctx not present for encrypted message\"));\n+            String receivedMessage = new String(msg.getData());\n+            log.debug(\"Received message: [{}]\", receivedMessage);\n+            String expectedMessage = \"my-message-\" + i;\n+            testMessageOrderAndDuplicates(messageSet, receivedMessage, expectedMessage);\n+        }\n+        // Acknowledge the consumption of all messages at once\n+        consumer.acknowledgeCumulative(msg);\n+        consumer.close();\n+    }\n+\n+    protected <T> void testMessageOrderAndDuplicates(Set<T> messagesReceived, T receivedMessage,\n+                                                     T expectedMessage) {\n+        // Make sure that messages are received in order\n+        Assert.assertEquals(receivedMessage, expectedMessage,\n+                \"Received message \" + receivedMessage + \" did not match the expected message \" + expectedMessage);\n+\n+        // Make sure that there are no duplicates\n+        Assert.assertTrue(messagesReceived.add(receivedMessage), \"Received duplicate message \" + receivedMessage);\n+    }\n+\n+    @Test\n+    public void testRedeliveryOfFailedMessages() throws Exception {\n+\n+        @Cleanup\n+        PulsarClient pulsarClient = PulsarClient.builder()\n+                .serviceUrl(pulsarContainer.getPlainTextPulsarBrokerUrl())\n+                .build();\n+\n+        final String encryptionKeyName = \"client-rsa.pem\";\n+        final String encryptionKeyVersion = \"1.0\";\n+        Map<String, String> metadata = Maps.newHashMap();\n+        metadata.put(\"version\", encryptionKeyVersion);\n+        class EncKeyReader implements CryptoKeyReader {\n+            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();\n+\n+            @Override\n+            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {\n+                String CERT_FILE_PATH = \"./src/test/resources/certificate/public-key.\" + keyName;\n+                if (Files.isReadable(Paths.get(CERT_FILE_PATH))) {\n+                    try {\n+                        keyInfo.setKey(Files.readAllBytes(Paths.get(CERT_FILE_PATH)));\n+                        keyInfo.setMetadata(metadata);\n+                        return keyInfo;\n+                    } catch (IOException e) {\n+                        Assert.fail(\"Failed to read certificate from \" + CERT_FILE_PATH);\n+                    }\n+                } else {\n+                    Assert.fail(\"Certificate file \" + CERT_FILE_PATH + \" is not present or not readable.\");\n+                }\n+                return null;\n+            }\n+\n+            @Override\n+            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> keyMeta) {\n+                String CERT_FILE_PATH = \"./src/test/resources/certificate/private-key.\" + keyName;\n+                if (Files.isReadable(Paths.get(CERT_FILE_PATH))) {\n+                    try {\n+                        keyInfo.setKey(Files.readAllBytes(Paths.get(CERT_FILE_PATH)));\n+                        keyInfo.setMetadata(metadata);\n+                        return keyInfo;\n+                    } catch (IOException e) {\n+                        Assert.fail(\"Failed to read certificate from \" + CERT_FILE_PATH);\n+                    }\n+                } else {\n+                    Assert.fail(\"Certificate file \" + CERT_FILE_PATH + \" is not present or not readable.\");\n+                }\n+                return null;\n+            }\n+        }\n+\n+        class InvalidKeyReader implements CryptoKeyReader {\n+            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();\n+\n+            @Override\n+            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {\n+                return null;\n+            }\n+\n+            @Override\n+            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> metadata) {\n+                return null;\n+            }\n+        }\n+\n+        /*\n+         * Redelivery functionality guarantees that customer will get a chance to process the message again.\n+         * In case of shared subscription eventually every client will get a chance to process the message, till one of them acks it.\n+         *\n+         * For client with Encryption enabled where in cases like a new production rollout or a buggy client configuration, we might have a mismatch of consumers\n+         * - few which can decrypt, few which can't (due to errors or cryptoReader not configured).\n+         *\n+         * In that case eventually all messages should be acked as long as there is a single consumer who can decrypt the message.\n+         *\n+         * Consumer 1 - Can decrypt message\n+         * Consumer 2 - Has invalid Reader configured.\n+         * Consumer 3 - Has no reader configured.\n+         *\n+         */\n+\n+        String topicName = \"persistent://my-property/my-ns/myrsa-topic2\";\n+\n+        Producer<byte[]> producer = pulsarClient.newProducer().topic(topicName)\n+                .addEncryptionKey(encryptionKeyName).compressionType(CompressionType.LZ4)\n+                .cryptoKeyReader(new EncKeyReader()).create();\n+\n+        PulsarClient newPulsarClient = newPulsarClient(lookupUrl.toString(), 0);// Creates new client connection\n+        Consumer<byte[]> consumer1 = newPulsarClient.newConsumer().topicsPattern(topicName)\n+                .subscriptionName(\"my-subscriber-name\").cryptoKeyReader(new EncKeyReader())\n+                .subscriptionType(SubscriptionType.Shared).ackTimeout(1, TimeUnit.SECONDS).subscribe();\n+\n+        PulsarClient newPulsarClient1 = newPulsarClient(lookupUrl.toString(), 0);// Creates new client connection\n+        Consumer<byte[]> consumer2 = newPulsarClient1.newConsumer().topicsPattern(topicName)\n+                .subscriptionName(\"my-subscriber-name\").cryptoKeyReader(new InvalidKeyReader())\n+                .subscriptionType(SubscriptionType.Shared).ackTimeout(1, TimeUnit.SECONDS).subscribe();\n+\n+        PulsarClient newPulsarClient2 = newPulsarClient(lookupUrl.toString(), 0);// Creates new client connection\n+        Consumer<byte[]> consumer3 = newPulsarClient2.newConsumer().topicsPattern(topicName)\n+                .subscriptionName(\"my-subscriber-name\").subscriptionType(SubscriptionType.Shared).ackTimeout(1, TimeUnit.SECONDS).subscribe();\n+\n+        int numberOfMessages = 100;\n+        String message = \"my-message\";\n+        Set<String> messages = new HashSet(); // Since messages are in random order\n+        for (int i = 0; i<numberOfMessages; i++) {", "originalCommit": "c9d12e8aa9237c541d39ab3244be68ae9ede64f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzM4MzE1NA==", "url": "https://github.com/apache/pulsar/pull/8962#discussion_r543383154", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    for (int i = 0; i<numberOfMessages; i++) {\n          \n          \n            \n                    for (int i = 0; i < numberOfMessages; i++) {", "author": "jbampton", "createdAt": "2020-12-15T14:18:55Z", "path": "tests/pulsar-client-shade-test/src/test/java/org/apache/pulsar/tests/integration/SimpleProducerConsumerTest.java", "diffHunk": "@@ -0,0 +1,576 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.tests.integration;\n+\n+import lombok.Cleanup;\n+import org.apache.pulsar.client.admin.PulsarAdmin;\n+import org.apache.pulsar.client.admin.PulsarAdminException;\n+import org.apache.pulsar.client.api.*;\n+import org.apache.pulsar.client.impl.MessageImpl;\n+import org.apache.pulsar.client.impl.TopicMessageImpl;\n+import org.apache.pulsar.client.impl.crypto.MessageCryptoBc;\n+import org.apache.pulsar.common.api.EncryptionContext;\n+import org.apache.pulsar.common.api.proto.PulsarApi;\n+import org.apache.pulsar.common.compression.CompressionCodec;\n+import org.apache.pulsar.common.compression.CompressionCodecProvider;\n+import org.apache.pulsar.common.policies.data.TenantInfo;\n+import org.apache.pulsar.common.protocol.Commands;\n+import org.apache.pulsar.shade.com.google.common.collect.Maps;\n+import org.apache.pulsar.shade.com.google.common.collect.Sets;\n+import org.apache.pulsar.shade.io.netty.buffer.ByteBuf;\n+import org.apache.pulsar.shade.io.netty.buffer.Unpooled;\n+import org.apache.pulsar.shaded.com.google.protobuf.v241.ByteString;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.security.Security;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.testng.Assert.*;\n+\n+public class SimpleProducerConsumerTest {\n+    private static final Logger log = LoggerFactory.getLogger(SimpleProducerConsumerTest.class);\n+\n+    private PulsarContainer pulsarContainer;\n+    private URI lookupUrl;\n+    private PulsarClient pulsarClient;\n+\n+    @BeforeClass\n+    public void setup() throws PulsarClientException, URISyntaxException, PulsarAdminException {\n+        Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());\n+        pulsarContainer = new PulsarContainer();\n+        pulsarContainer.start();\n+        pulsarClient = PulsarClient.builder()\n+                .serviceUrl(pulsarContainer.getPlainTextPulsarBrokerUrl())\n+                .build();\n+        lookupUrl = new URI(pulsarContainer.getPlainTextPulsarBrokerUrl());\n+\n+        PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(pulsarContainer.getPulsarAdminUrl()).build();\n+        admin.tenants().createTenant(\"my-property\",\n+                new TenantInfo(Sets.newHashSet(\"appid1\", \"appid2\"), Sets.newHashSet(\"standalone\")));\n+        admin.namespaces().createNamespace(\"my-property/my-ns\");\n+        admin.namespaces().setNamespaceReplicationClusters(\"my-property/my-ns\", Sets.newHashSet(\"standalone\"));\n+        admin.close();\n+    }\n+\n+    @AfterClass\n+    public void cleanup() throws PulsarClientException {\n+        pulsarClient.close();\n+        pulsarContainer.stop();\n+        pulsarContainer.close();\n+    }\n+\n+    private PulsarClient newPulsarClient(String url, int intervalInSecs) throws PulsarClientException {\n+        return PulsarClient.builder().serviceUrl(url).statsInterval(intervalInSecs, TimeUnit.SECONDS).build();\n+    }\n+\n+    @Test\n+    public void testRSAEncryption() throws Exception {\n+\n+        String topicName = \"persistent://my-property/my-ns/myrsa-topic1-\"+ System.currentTimeMillis();\n+\n+        class EncKeyReader implements CryptoKeyReader {\n+\n+            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();\n+\n+            @Override\n+            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {\n+                String CERT_FILE_PATH = \"./src/test/resources/certificate/public-key.\" + keyName;\n+                if (Files.isReadable(Paths.get(CERT_FILE_PATH))) {\n+                    try {\n+                        keyInfo.setKey(Files.readAllBytes(Paths.get(CERT_FILE_PATH)));\n+                        return keyInfo;\n+                    } catch (IOException e) {\n+                        Assert.fail(\"Failed to read certificate from \" + CERT_FILE_PATH);\n+                    }\n+                } else {\n+                    Assert.fail(\"Certificate file \" + CERT_FILE_PATH + \" is not present or not readable.\");\n+                }\n+                return null;\n+            }\n+\n+            @Override\n+            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> keyMeta) {\n+                String CERT_FILE_PATH = \"./src/test/resources/certificate/private-key.\" + keyName;\n+                if (Files.isReadable(Paths.get(CERT_FILE_PATH))) {\n+                    try {\n+                        keyInfo.setKey(Files.readAllBytes(Paths.get(CERT_FILE_PATH)));\n+                        return keyInfo;\n+                    } catch (IOException e) {\n+                        Assert.fail(\"Failed to read certificate from \" + CERT_FILE_PATH);\n+                    }\n+                } else {\n+                    Assert.fail(\"Certificate file \" + CERT_FILE_PATH + \" is not present or not readable.\");\n+                }\n+                return null;\n+            }\n+        }\n+\n+        final int totalMsg = 10;\n+\n+        Set<String> messageSet = Sets.newHashSet();\n+        Consumer<byte[]> consumer = pulsarClient.newConsumer().topic(\"persistent://my-property/my-ns/myrsa-topic1\")\n+                .subscriptionName(\"my-subscriber-name\").cryptoKeyReader(new EncKeyReader()).subscribe();\n+        Consumer<byte[]> normalConsumer = pulsarClient.newConsumer()\n+                .topic(topicName).subscriptionName(\"my-subscriber-name-normal\")\n+                .subscribe();\n+\n+        Producer<byte[]> producer = pulsarClient.newProducer().topic(\"persistent://my-property/my-ns/myrsa-topic1\")\n+                .addEncryptionKey(\"client-rsa.pem\").cryptoKeyReader(new EncKeyReader()).create();\n+        Producer<byte[]> producer2 = pulsarClient.newProducer().topic(\"persistent://my-property/my-ns/myrsa-topic1\")\n+                .addEncryptionKey(\"client-rsa.pem\").cryptoKeyReader(new EncKeyReader()).create();\n+\n+        for (int i = 0; i < totalMsg; i++) {\n+            String message = \"my-message-\" + i;\n+            producer.send(message.getBytes());\n+        }\n+        for (int i = totalMsg; i < totalMsg * 2; i++) {\n+            String message = \"my-message-\" + i;\n+            producer2.send(message.getBytes());\n+        }\n+\n+        MessageImpl<byte[]> msg = null;\n+\n+        msg = (MessageImpl<byte[]>) normalConsumer.receive(500, TimeUnit.MILLISECONDS);\n+        // should not able to read message using normal message.\n+        assertNull(msg);\n+\n+        for (int i = 0; i < totalMsg * 2; i++) {\n+            msg = (MessageImpl<byte[]>) consumer.receive(5, TimeUnit.SECONDS);\n+            // verify that encrypted message contains encryption-context\n+            msg.getEncryptionCtx()\n+                    .orElseThrow(() -> new IllegalStateException(\"encryption-ctx not present for encrypted message\"));\n+            String receivedMessage = new String(msg.getData());\n+            log.debug(\"Received message: [{}]\", receivedMessage);\n+            String expectedMessage = \"my-message-\" + i;\n+            testMessageOrderAndDuplicates(messageSet, receivedMessage, expectedMessage);\n+        }\n+        // Acknowledge the consumption of all messages at once\n+        consumer.acknowledgeCumulative(msg);\n+        consumer.close();\n+    }\n+\n+    protected <T> void testMessageOrderAndDuplicates(Set<T> messagesReceived, T receivedMessage,\n+                                                     T expectedMessage) {\n+        // Make sure that messages are received in order\n+        Assert.assertEquals(receivedMessage, expectedMessage,\n+                \"Received message \" + receivedMessage + \" did not match the expected message \" + expectedMessage);\n+\n+        // Make sure that there are no duplicates\n+        Assert.assertTrue(messagesReceived.add(receivedMessage), \"Received duplicate message \" + receivedMessage);\n+    }\n+\n+    @Test\n+    public void testRedeliveryOfFailedMessages() throws Exception {\n+\n+        @Cleanup\n+        PulsarClient pulsarClient = PulsarClient.builder()\n+                .serviceUrl(pulsarContainer.getPlainTextPulsarBrokerUrl())\n+                .build();\n+\n+        final String encryptionKeyName = \"client-rsa.pem\";\n+        final String encryptionKeyVersion = \"1.0\";\n+        Map<String, String> metadata = Maps.newHashMap();\n+        metadata.put(\"version\", encryptionKeyVersion);\n+        class EncKeyReader implements CryptoKeyReader {\n+            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();\n+\n+            @Override\n+            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {\n+                String CERT_FILE_PATH = \"./src/test/resources/certificate/public-key.\" + keyName;\n+                if (Files.isReadable(Paths.get(CERT_FILE_PATH))) {\n+                    try {\n+                        keyInfo.setKey(Files.readAllBytes(Paths.get(CERT_FILE_PATH)));\n+                        keyInfo.setMetadata(metadata);\n+                        return keyInfo;\n+                    } catch (IOException e) {\n+                        Assert.fail(\"Failed to read certificate from \" + CERT_FILE_PATH);\n+                    }\n+                } else {\n+                    Assert.fail(\"Certificate file \" + CERT_FILE_PATH + \" is not present or not readable.\");\n+                }\n+                return null;\n+            }\n+\n+            @Override\n+            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> keyMeta) {\n+                String CERT_FILE_PATH = \"./src/test/resources/certificate/private-key.\" + keyName;\n+                if (Files.isReadable(Paths.get(CERT_FILE_PATH))) {\n+                    try {\n+                        keyInfo.setKey(Files.readAllBytes(Paths.get(CERT_FILE_PATH)));\n+                        keyInfo.setMetadata(metadata);\n+                        return keyInfo;\n+                    } catch (IOException e) {\n+                        Assert.fail(\"Failed to read certificate from \" + CERT_FILE_PATH);\n+                    }\n+                } else {\n+                    Assert.fail(\"Certificate file \" + CERT_FILE_PATH + \" is not present or not readable.\");\n+                }\n+                return null;\n+            }\n+        }\n+\n+        class InvalidKeyReader implements CryptoKeyReader {\n+            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();\n+\n+            @Override\n+            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {\n+                return null;\n+            }\n+\n+            @Override\n+            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> metadata) {\n+                return null;\n+            }\n+        }\n+\n+        /*\n+         * Redelivery functionality guarantees that customer will get a chance to process the message again.\n+         * In case of shared subscription eventually every client will get a chance to process the message, till one of them acks it.\n+         *\n+         * For client with Encryption enabled where in cases like a new production rollout or a buggy client configuration, we might have a mismatch of consumers\n+         * - few which can decrypt, few which can't (due to errors or cryptoReader not configured).\n+         *\n+         * In that case eventually all messages should be acked as long as there is a single consumer who can decrypt the message.\n+         *\n+         * Consumer 1 - Can decrypt message\n+         * Consumer 2 - Has invalid Reader configured.\n+         * Consumer 3 - Has no reader configured.\n+         *\n+         */\n+\n+        String topicName = \"persistent://my-property/my-ns/myrsa-topic2\";\n+\n+        Producer<byte[]> producer = pulsarClient.newProducer().topic(topicName)\n+                .addEncryptionKey(encryptionKeyName).compressionType(CompressionType.LZ4)\n+                .cryptoKeyReader(new EncKeyReader()).create();\n+\n+        PulsarClient newPulsarClient = newPulsarClient(lookupUrl.toString(), 0);// Creates new client connection\n+        Consumer<byte[]> consumer1 = newPulsarClient.newConsumer().topicsPattern(topicName)\n+                .subscriptionName(\"my-subscriber-name\").cryptoKeyReader(new EncKeyReader())\n+                .subscriptionType(SubscriptionType.Shared).ackTimeout(1, TimeUnit.SECONDS).subscribe();\n+\n+        PulsarClient newPulsarClient1 = newPulsarClient(lookupUrl.toString(), 0);// Creates new client connection\n+        Consumer<byte[]> consumer2 = newPulsarClient1.newConsumer().topicsPattern(topicName)\n+                .subscriptionName(\"my-subscriber-name\").cryptoKeyReader(new InvalidKeyReader())\n+                .subscriptionType(SubscriptionType.Shared).ackTimeout(1, TimeUnit.SECONDS).subscribe();\n+\n+        PulsarClient newPulsarClient2 = newPulsarClient(lookupUrl.toString(), 0);// Creates new client connection\n+        Consumer<byte[]> consumer3 = newPulsarClient2.newConsumer().topicsPattern(topicName)\n+                .subscriptionName(\"my-subscriber-name\").subscriptionType(SubscriptionType.Shared).ackTimeout(1, TimeUnit.SECONDS).subscribe();\n+\n+        int numberOfMessages = 100;\n+        String message = \"my-message\";\n+        Set<String> messages = new HashSet(); // Since messages are in random order\n+        for (int i = 0; i<numberOfMessages; i++) {\n+            producer.send((message + i).getBytes());\n+        }\n+\n+        // Consuming from consumer 2 and 3\n+        // no message should be returned since they can't decrypt the message\n+        Message m = consumer2.receive(3, TimeUnit.SECONDS);\n+        assertNull(m);\n+        m = consumer3.receive(3, TimeUnit.SECONDS);\n+        assertNull(m);\n+\n+        for (int i = 0; i<numberOfMessages; i++) {", "originalCommit": "c9d12e8aa9237c541d39ab3244be68ae9ede64f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzM4MzQ1MQ==", "url": "https://github.com/apache/pulsar/pull/8962#discussion_r543383451", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    for (int i = 0; i<numberOfMessages; i++) {\n          \n          \n            \n                    for (int i = 0; i < numberOfMessages; i++) {", "author": "jbampton", "createdAt": "2020-12-15T14:19:12Z", "path": "tests/pulsar-client-shade-test/src/test/java/org/apache/pulsar/tests/integration/SimpleProducerConsumerTest.java", "diffHunk": "@@ -0,0 +1,576 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.tests.integration;\n+\n+import lombok.Cleanup;\n+import org.apache.pulsar.client.admin.PulsarAdmin;\n+import org.apache.pulsar.client.admin.PulsarAdminException;\n+import org.apache.pulsar.client.api.*;\n+import org.apache.pulsar.client.impl.MessageImpl;\n+import org.apache.pulsar.client.impl.TopicMessageImpl;\n+import org.apache.pulsar.client.impl.crypto.MessageCryptoBc;\n+import org.apache.pulsar.common.api.EncryptionContext;\n+import org.apache.pulsar.common.api.proto.PulsarApi;\n+import org.apache.pulsar.common.compression.CompressionCodec;\n+import org.apache.pulsar.common.compression.CompressionCodecProvider;\n+import org.apache.pulsar.common.policies.data.TenantInfo;\n+import org.apache.pulsar.common.protocol.Commands;\n+import org.apache.pulsar.shade.com.google.common.collect.Maps;\n+import org.apache.pulsar.shade.com.google.common.collect.Sets;\n+import org.apache.pulsar.shade.io.netty.buffer.ByteBuf;\n+import org.apache.pulsar.shade.io.netty.buffer.Unpooled;\n+import org.apache.pulsar.shaded.com.google.protobuf.v241.ByteString;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.security.Security;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.testng.Assert.*;\n+\n+public class SimpleProducerConsumerTest {\n+    private static final Logger log = LoggerFactory.getLogger(SimpleProducerConsumerTest.class);\n+\n+    private PulsarContainer pulsarContainer;\n+    private URI lookupUrl;\n+    private PulsarClient pulsarClient;\n+\n+    @BeforeClass\n+    public void setup() throws PulsarClientException, URISyntaxException, PulsarAdminException {\n+        Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());\n+        pulsarContainer = new PulsarContainer();\n+        pulsarContainer.start();\n+        pulsarClient = PulsarClient.builder()\n+                .serviceUrl(pulsarContainer.getPlainTextPulsarBrokerUrl())\n+                .build();\n+        lookupUrl = new URI(pulsarContainer.getPlainTextPulsarBrokerUrl());\n+\n+        PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(pulsarContainer.getPulsarAdminUrl()).build();\n+        admin.tenants().createTenant(\"my-property\",\n+                new TenantInfo(Sets.newHashSet(\"appid1\", \"appid2\"), Sets.newHashSet(\"standalone\")));\n+        admin.namespaces().createNamespace(\"my-property/my-ns\");\n+        admin.namespaces().setNamespaceReplicationClusters(\"my-property/my-ns\", Sets.newHashSet(\"standalone\"));\n+        admin.close();\n+    }\n+\n+    @AfterClass\n+    public void cleanup() throws PulsarClientException {\n+        pulsarClient.close();\n+        pulsarContainer.stop();\n+        pulsarContainer.close();\n+    }\n+\n+    private PulsarClient newPulsarClient(String url, int intervalInSecs) throws PulsarClientException {\n+        return PulsarClient.builder().serviceUrl(url).statsInterval(intervalInSecs, TimeUnit.SECONDS).build();\n+    }\n+\n+    @Test\n+    public void testRSAEncryption() throws Exception {\n+\n+        String topicName = \"persistent://my-property/my-ns/myrsa-topic1-\"+ System.currentTimeMillis();\n+\n+        class EncKeyReader implements CryptoKeyReader {\n+\n+            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();\n+\n+            @Override\n+            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {\n+                String CERT_FILE_PATH = \"./src/test/resources/certificate/public-key.\" + keyName;\n+                if (Files.isReadable(Paths.get(CERT_FILE_PATH))) {\n+                    try {\n+                        keyInfo.setKey(Files.readAllBytes(Paths.get(CERT_FILE_PATH)));\n+                        return keyInfo;\n+                    } catch (IOException e) {\n+                        Assert.fail(\"Failed to read certificate from \" + CERT_FILE_PATH);\n+                    }\n+                } else {\n+                    Assert.fail(\"Certificate file \" + CERT_FILE_PATH + \" is not present or not readable.\");\n+                }\n+                return null;\n+            }\n+\n+            @Override\n+            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> keyMeta) {\n+                String CERT_FILE_PATH = \"./src/test/resources/certificate/private-key.\" + keyName;\n+                if (Files.isReadable(Paths.get(CERT_FILE_PATH))) {\n+                    try {\n+                        keyInfo.setKey(Files.readAllBytes(Paths.get(CERT_FILE_PATH)));\n+                        return keyInfo;\n+                    } catch (IOException e) {\n+                        Assert.fail(\"Failed to read certificate from \" + CERT_FILE_PATH);\n+                    }\n+                } else {\n+                    Assert.fail(\"Certificate file \" + CERT_FILE_PATH + \" is not present or not readable.\");\n+                }\n+                return null;\n+            }\n+        }\n+\n+        final int totalMsg = 10;\n+\n+        Set<String> messageSet = Sets.newHashSet();\n+        Consumer<byte[]> consumer = pulsarClient.newConsumer().topic(\"persistent://my-property/my-ns/myrsa-topic1\")\n+                .subscriptionName(\"my-subscriber-name\").cryptoKeyReader(new EncKeyReader()).subscribe();\n+        Consumer<byte[]> normalConsumer = pulsarClient.newConsumer()\n+                .topic(topicName).subscriptionName(\"my-subscriber-name-normal\")\n+                .subscribe();\n+\n+        Producer<byte[]> producer = pulsarClient.newProducer().topic(\"persistent://my-property/my-ns/myrsa-topic1\")\n+                .addEncryptionKey(\"client-rsa.pem\").cryptoKeyReader(new EncKeyReader()).create();\n+        Producer<byte[]> producer2 = pulsarClient.newProducer().topic(\"persistent://my-property/my-ns/myrsa-topic1\")\n+                .addEncryptionKey(\"client-rsa.pem\").cryptoKeyReader(new EncKeyReader()).create();\n+\n+        for (int i = 0; i < totalMsg; i++) {\n+            String message = \"my-message-\" + i;\n+            producer.send(message.getBytes());\n+        }\n+        for (int i = totalMsg; i < totalMsg * 2; i++) {\n+            String message = \"my-message-\" + i;\n+            producer2.send(message.getBytes());\n+        }\n+\n+        MessageImpl<byte[]> msg = null;\n+\n+        msg = (MessageImpl<byte[]>) normalConsumer.receive(500, TimeUnit.MILLISECONDS);\n+        // should not able to read message using normal message.\n+        assertNull(msg);\n+\n+        for (int i = 0; i < totalMsg * 2; i++) {\n+            msg = (MessageImpl<byte[]>) consumer.receive(5, TimeUnit.SECONDS);\n+            // verify that encrypted message contains encryption-context\n+            msg.getEncryptionCtx()\n+                    .orElseThrow(() -> new IllegalStateException(\"encryption-ctx not present for encrypted message\"));\n+            String receivedMessage = new String(msg.getData());\n+            log.debug(\"Received message: [{}]\", receivedMessage);\n+            String expectedMessage = \"my-message-\" + i;\n+            testMessageOrderAndDuplicates(messageSet, receivedMessage, expectedMessage);\n+        }\n+        // Acknowledge the consumption of all messages at once\n+        consumer.acknowledgeCumulative(msg);\n+        consumer.close();\n+    }\n+\n+    protected <T> void testMessageOrderAndDuplicates(Set<T> messagesReceived, T receivedMessage,\n+                                                     T expectedMessage) {\n+        // Make sure that messages are received in order\n+        Assert.assertEquals(receivedMessage, expectedMessage,\n+                \"Received message \" + receivedMessage + \" did not match the expected message \" + expectedMessage);\n+\n+        // Make sure that there are no duplicates\n+        Assert.assertTrue(messagesReceived.add(receivedMessage), \"Received duplicate message \" + receivedMessage);\n+    }\n+\n+    @Test\n+    public void testRedeliveryOfFailedMessages() throws Exception {\n+\n+        @Cleanup\n+        PulsarClient pulsarClient = PulsarClient.builder()\n+                .serviceUrl(pulsarContainer.getPlainTextPulsarBrokerUrl())\n+                .build();\n+\n+        final String encryptionKeyName = \"client-rsa.pem\";\n+        final String encryptionKeyVersion = \"1.0\";\n+        Map<String, String> metadata = Maps.newHashMap();\n+        metadata.put(\"version\", encryptionKeyVersion);\n+        class EncKeyReader implements CryptoKeyReader {\n+            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();\n+\n+            @Override\n+            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {\n+                String CERT_FILE_PATH = \"./src/test/resources/certificate/public-key.\" + keyName;\n+                if (Files.isReadable(Paths.get(CERT_FILE_PATH))) {\n+                    try {\n+                        keyInfo.setKey(Files.readAllBytes(Paths.get(CERT_FILE_PATH)));\n+                        keyInfo.setMetadata(metadata);\n+                        return keyInfo;\n+                    } catch (IOException e) {\n+                        Assert.fail(\"Failed to read certificate from \" + CERT_FILE_PATH);\n+                    }\n+                } else {\n+                    Assert.fail(\"Certificate file \" + CERT_FILE_PATH + \" is not present or not readable.\");\n+                }\n+                return null;\n+            }\n+\n+            @Override\n+            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> keyMeta) {\n+                String CERT_FILE_PATH = \"./src/test/resources/certificate/private-key.\" + keyName;\n+                if (Files.isReadable(Paths.get(CERT_FILE_PATH))) {\n+                    try {\n+                        keyInfo.setKey(Files.readAllBytes(Paths.get(CERT_FILE_PATH)));\n+                        keyInfo.setMetadata(metadata);\n+                        return keyInfo;\n+                    } catch (IOException e) {\n+                        Assert.fail(\"Failed to read certificate from \" + CERT_FILE_PATH);\n+                    }\n+                } else {\n+                    Assert.fail(\"Certificate file \" + CERT_FILE_PATH + \" is not present or not readable.\");\n+                }\n+                return null;\n+            }\n+        }\n+\n+        class InvalidKeyReader implements CryptoKeyReader {\n+            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();\n+\n+            @Override\n+            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {\n+                return null;\n+            }\n+\n+            @Override\n+            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> metadata) {\n+                return null;\n+            }\n+        }\n+\n+        /*\n+         * Redelivery functionality guarantees that customer will get a chance to process the message again.\n+         * In case of shared subscription eventually every client will get a chance to process the message, till one of them acks it.\n+         *\n+         * For client with Encryption enabled where in cases like a new production rollout or a buggy client configuration, we might have a mismatch of consumers\n+         * - few which can decrypt, few which can't (due to errors or cryptoReader not configured).\n+         *\n+         * In that case eventually all messages should be acked as long as there is a single consumer who can decrypt the message.\n+         *\n+         * Consumer 1 - Can decrypt message\n+         * Consumer 2 - Has invalid Reader configured.\n+         * Consumer 3 - Has no reader configured.\n+         *\n+         */\n+\n+        String topicName = \"persistent://my-property/my-ns/myrsa-topic2\";\n+\n+        Producer<byte[]> producer = pulsarClient.newProducer().topic(topicName)\n+                .addEncryptionKey(encryptionKeyName).compressionType(CompressionType.LZ4)\n+                .cryptoKeyReader(new EncKeyReader()).create();\n+\n+        PulsarClient newPulsarClient = newPulsarClient(lookupUrl.toString(), 0);// Creates new client connection\n+        Consumer<byte[]> consumer1 = newPulsarClient.newConsumer().topicsPattern(topicName)\n+                .subscriptionName(\"my-subscriber-name\").cryptoKeyReader(new EncKeyReader())\n+                .subscriptionType(SubscriptionType.Shared).ackTimeout(1, TimeUnit.SECONDS).subscribe();\n+\n+        PulsarClient newPulsarClient1 = newPulsarClient(lookupUrl.toString(), 0);// Creates new client connection\n+        Consumer<byte[]> consumer2 = newPulsarClient1.newConsumer().topicsPattern(topicName)\n+                .subscriptionName(\"my-subscriber-name\").cryptoKeyReader(new InvalidKeyReader())\n+                .subscriptionType(SubscriptionType.Shared).ackTimeout(1, TimeUnit.SECONDS).subscribe();\n+\n+        PulsarClient newPulsarClient2 = newPulsarClient(lookupUrl.toString(), 0);// Creates new client connection\n+        Consumer<byte[]> consumer3 = newPulsarClient2.newConsumer().topicsPattern(topicName)\n+                .subscriptionName(\"my-subscriber-name\").subscriptionType(SubscriptionType.Shared).ackTimeout(1, TimeUnit.SECONDS).subscribe();\n+\n+        int numberOfMessages = 100;\n+        String message = \"my-message\";\n+        Set<String> messages = new HashSet(); // Since messages are in random order\n+        for (int i = 0; i<numberOfMessages; i++) {\n+            producer.send((message + i).getBytes());\n+        }\n+\n+        // Consuming from consumer 2 and 3\n+        // no message should be returned since they can't decrypt the message\n+        Message m = consumer2.receive(3, TimeUnit.SECONDS);\n+        assertNull(m);\n+        m = consumer3.receive(3, TimeUnit.SECONDS);\n+        assertNull(m);\n+\n+        for (int i = 0; i<numberOfMessages; i++) {\n+            // All messages would be received by consumer 1\n+            m = consumer1.receive();\n+            messages.add(new String(m.getData()));\n+            consumer1.acknowledge(m);\n+        }\n+\n+        // Consuming from consumer 2 and 3 again just to be sure\n+        // no message should be returned since they can't decrypt the message\n+        m = consumer2.receive(3, TimeUnit.SECONDS);\n+        assertNull(m);\n+        m = consumer3.receive(3, TimeUnit.SECONDS);\n+        assertNull(m);\n+\n+        // checking if all messages were received\n+        for (int i = 0; i<numberOfMessages; i++) {", "originalCommit": "c9d12e8aa9237c541d39ab3244be68ae9ede64f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5075b9839a89a9064ee0015042eba37d856dd35b", "url": "https://github.com/apache/pulsar/commit/5075b9839a89a9064ee0015042eba37d856dd35b", "message": "Fix pulsar-client-admin dependency problem.", "committedDate": "2020-12-18T07:07:58Z", "type": "commit"}, {"oid": "5836ee787bb2526f3597716e6e3b27f4c3f27ea3", "url": "https://github.com/apache/pulsar/commit/5836ee787bb2526f3597716e6e3b27f4c3f27ea3", "message": "Format codes.", "committedDate": "2020-12-18T07:16:04Z", "type": "commit"}]}