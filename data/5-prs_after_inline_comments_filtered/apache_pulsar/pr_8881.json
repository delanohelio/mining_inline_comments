{"pr_number": 8881, "pr_title": "[Transaction] Transaction pending ack persistent", "pr_createdAt": "2020-12-09T15:47:16Z", "pr_url": "https://github.com/apache/pulsar/pull/8881", "timeline": [{"oid": "1d86b4d5c0a12e3246bdbdb75ec62de867aa2c0e", "url": "https://github.com/apache/pulsar/commit/1d86b4d5c0a12e3246bdbdb75ec62de867aa2c0e", "message": "Transaction pending ack persistent", "committedDate": "2020-12-09T11:08:38Z", "type": "commit"}, {"oid": "e4a11de81ab064b5840eaf9daf74d892c4e7960c", "url": "https://github.com/apache/pulsar/commit/e4a11de81ab064b5840eaf9daf74d892c4e7960c", "message": "Fix some named", "committedDate": "2020-12-09T15:45:19Z", "type": "commit"}, {"oid": "8e26d8aed029ebdb2ec78e6092a4fdf82210c494", "url": "https://github.com/apache/pulsar/commit/8e26d8aed029ebdb2ec78e6092a4fdf82210c494", "message": "Merge remote-tracking branch 'apache/master' into congbobo184_transaction_pendingack_persistent\n\n# Conflicts:\n#\tpulsar-broker/src/main/java/org/apache/pulsar/broker/transaction/pendingack/PendingAckHandle.java\n#\tpulsar-broker/src/main/java/org/apache/pulsar/broker/transaction/pendingack/impl/PendingAckHandleImpl.java", "committedDate": "2020-12-10T08:19:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzk1ODYyMw==", "url": "https://github.com/apache/pulsar/pull/8881#discussion_r557958623", "bodyText": "can we add checkIdReady to PendingAckHandle ?\nusing instanceof is not a good practice, we should leverage polymorphism", "author": "eolivelli", "createdAt": "2021-01-15T07:41:39Z", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/persistent/PersistentSubscription.java", "diffHunk": "@@ -161,6 +162,12 @@ void setReplicated(boolean replicated) {\n \n     @Override\n     public synchronized void addConsumer(Consumer consumer) throws BrokerServiceException {\n+        if (pendingAckHandle instanceof PendingAckHandleImpl) {\n+            if (!((PendingAckHandleImpl) pendingAckHandle).checkIfReady()) {", "originalCommit": "8e26d8aed029ebdb2ec78e6092a4fdf82210c494", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzk2MDI0Mw==", "url": "https://github.com/apache/pulsar/pull/8881#discussion_r557960243", "bodyText": "how many times is this method supposed to be called ?", "author": "eolivelli", "createdAt": "2021-01-15T07:42:56Z", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/transaction/pendingack/PendingAckReplyCallBack.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.transaction.pendingack;\n+\n+import org.apache.pulsar.broker.transaction.proto.TransactionPendingAck.PendingAckMetadataEntry;\n+\n+/**\n+ * Call back for pending ack reply.\n+ */\n+public interface PendingAckReplyCallBack {\n+\n+    /**\n+     * Pending ack replay complete callback for pending ack store.\n+     */\n+    void replayComplete();\n+\n+    /**\n+     * Handle metadata entry.", "originalCommit": "8e26d8aed029ebdb2ec78e6092a4fdf82210c494", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxOTc1ODIwNg==", "url": "https://github.com/apache/pulsar/pull/8881#discussion_r619758206", "bodyText": "handle pending ack log. invoke as many times as there have entry have to be recover.", "author": "congbobo184", "createdAt": "2021-04-25T06:20:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzk2MDI0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzk2MDU2OQ==", "url": "https://github.com/apache/pulsar/pull/8881#discussion_r557960569", "bodyText": "is there any way to receive notification of a failure ?", "author": "eolivelli", "createdAt": "2021-01-15T07:43:11Z", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/transaction/pendingack/PendingAckReplyCallBack.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.transaction.pendingack;\n+\n+import org.apache.pulsar.broker.transaction.proto.TransactionPendingAck.PendingAckMetadataEntry;\n+\n+/**\n+ * Call back for pending ack reply.\n+ */\n+public interface PendingAckReplyCallBack {\n+\n+    /**\n+     * Pending ack replay complete callback for pending ack store.\n+     */\n+    void replayComplete();", "originalCommit": "8e26d8aed029ebdb2ec78e6092a4fdf82210c494", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxOTc1ODU5Ng==", "url": "https://github.com/apache/pulsar/pull/8881#discussion_r619758596", "bodyText": "it can't fail, unless metadata is corrupted", "author": "congbobo184", "createdAt": "2021-04-25T06:24:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzk2MDU2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzk2Njk0MA==", "url": "https://github.com/apache/pulsar/pull/8881#discussion_r557966940", "bodyText": "is this expected to happen inside the scheduledExecutorService ?", "author": "eolivelli", "createdAt": "2021-01-15T07:48:05Z", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/transaction/pendingack/impl/InMemoryPendingAckStore.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.transaction.pendingack.impl;\n+\n+import org.apache.bookkeeper.mledger.impl.PositionImpl;\n+import org.apache.commons.lang3.tuple.MutablePair;\n+import org.apache.pulsar.broker.transaction.pendingack.PendingAckStore;\n+import org.apache.pulsar.client.api.transaction.TxnID;\n+import org.apache.pulsar.common.api.proto.PulsarApi;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+/**\n+ * In memory implementation of {@link PendingAckStore}.\n+ */\n+public class InMemoryPendingAckStore implements PendingAckStore {\n+\n+    @Override\n+    public void replayAsync(PendingAckHandleImpl pendingAckHandle, ScheduledExecutorService scheduledExecutorService) {\n+        pendingAckHandle.changeToReadyState();", "originalCommit": "8e26d8aed029ebdb2ec78e6092a4fdf82210c494", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxOTc1ODcwNA==", "url": "https://github.com/apache/pulsar/pull/8881#discussion_r619758704", "bodyText": "InMemoryPendingAckStore.java don't need replay.", "author": "congbobo184", "createdAt": "2021-04-25T06:25:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzk2Njk0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzk3MDcxNQ==", "url": "https://github.com/apache/pulsar/pull/8881#discussion_r557970715", "bodyText": "this is not good,\nthe contract is to exit the current activity in case of InterrupedException or at least set Thread.interrupted flag", "author": "eolivelli", "createdAt": "2021-01-15T07:51:02Z", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/transaction/pendingack/impl/MLPendingAckStore.java", "diffHunk": "@@ -0,0 +1,336 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.transaction.pendingack.impl;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import io.netty.util.Timer;\n+import org.apache.bookkeeper.mledger.AsyncCallbacks;\n+import org.apache.bookkeeper.mledger.Entry;\n+import org.apache.bookkeeper.mledger.ManagedCursor;\n+import org.apache.bookkeeper.mledger.ManagedLedger;\n+import org.apache.bookkeeper.mledger.ManagedLedgerException;\n+import org.apache.bookkeeper.mledger.Position;\n+import org.apache.bookkeeper.mledger.impl.PositionImpl;\n+import org.apache.commons.lang3.tuple.MutablePair;\n+import org.apache.pulsar.broker.transaction.pendingack.PendingAckReplyCallBack;\n+import org.apache.pulsar.broker.transaction.pendingack.PendingAckStore;\n+import org.apache.pulsar.broker.transaction.proto.TransactionPendingAck.PendingAckMetadata;\n+import org.apache.pulsar.broker.transaction.proto.TransactionPendingAck.PendingAckMetadataEntry;\n+import org.apache.pulsar.broker.transaction.proto.TransactionPendingAck.PendingAckOp;\n+import org.apache.pulsar.client.api.transaction.TxnID;\n+import org.apache.pulsar.common.allocator.PulsarByteBufAllocator;\n+import org.apache.pulsar.common.api.proto.PulsarApi.CommandAck.AckType;\n+import org.apache.pulsar.common.naming.TopicName;\n+import org.apache.pulsar.common.util.SafeCollectionUtils;\n+import org.apache.pulsar.common.util.protobuf.ByteBufCodedInputStream;\n+import org.apache.pulsar.common.util.protobuf.ByteBufCodedOutputStream;\n+import org.jctools.queues.MessagePassingQueue;\n+import org.jctools.queues.SpscArrayQueue;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The implement of the pending ack store by manageLedger.\n+ */\n+public class MLPendingAckStore implements PendingAckStore {\n+\n+\n+    private final ManagedLedger managedLedger;\n+\n+    private final ManagedCursor cursor;\n+\n+    private static final String PENDING_ACK_STORE_SUFFIX = \"-transaction-pendingack\";\n+\n+    private static final String PENDING_ACK_STORE_CURSOR_NAME = \"pendingack\";\n+\n+    private final SpscArrayQueue<Entry> entryQueue;\n+\n+    //this is for replay\n+    private final PositionImpl lastConfirmedEntry;\n+\n+    private PositionImpl currentLoadPosition;\n+\n+    private final Timer timer;\n+\n+    private final MLPendingAckStoreTimerTask mlPendingAckStoreTimerTask;\n+\n+    private final int intervalTime;\n+\n+    public MLPendingAckStore(ManagedLedger managedLedger, ManagedCursor cursor,\n+                             Timer timer, ManagedCursor subManagedCursor, int maxIntervalTime, int minIntervalTime) {\n+        this.managedLedger = managedLedger;\n+        this.cursor = cursor;\n+        this.currentLoadPosition = (PositionImpl) this.cursor.getMarkDeletedPosition();\n+        this.entryQueue = new SpscArrayQueue<>(2000);\n+        this.lastConfirmedEntry = (PositionImpl) managedLedger.getLastConfirmedEntry();\n+        this.timer = timer;\n+        this.intervalTime = minIntervalTime;\n+        this.mlPendingAckStoreTimerTask = new MLPendingAckStoreTimerTask(cursor, managedLedger,\n+                minIntervalTime, maxIntervalTime, subManagedCursor, this.timer);\n+    }\n+\n+    @Override\n+    public void replayAsync(PendingAckHandleImpl pendingAckHandle, ScheduledExecutorService transactionReplayExecutor) {\n+        transactionReplayExecutor\n+                .execute(new PendingAckReplay(new MLPendingAckReplyCallBack(this, pendingAckHandle)));\n+    }\n+\n+    //TODO can control the number of entry to read\n+    private void readAsync(int numberOfEntriesToRead,\n+                           AsyncCallbacks.ReadEntriesCallback readEntriesCallback) {\n+        cursor.asyncReadEntries(numberOfEntriesToRead, readEntriesCallback, System.nanoTime());\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> closeAsync() {\n+        CompletableFuture<Void> completableFuture = new CompletableFuture<>();\n+        cursor.asyncClose(new AsyncCallbacks.CloseCallback() {\n+            @Override\n+            public void closeComplete(Object ctx) {\n+                try {\n+                    managedLedger.close();\n+                } catch (Exception e) {\n+                    completableFuture.completeExceptionally(e);\n+                }\n+                completableFuture.complete(null);\n+            }\n+\n+            @Override\n+            public void closeFailed(ManagedLedgerException exception, Object ctx) {\n+                completableFuture.completeExceptionally(exception);\n+            }\n+        }, null);\n+        return completableFuture;\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> appendIndividualAck(TxnID txnID, List<MutablePair<PositionImpl, Integer>> positions) {\n+        PendingAckMetadataEntry.Builder builder = PendingAckMetadataEntry.newBuilder();\n+        builder.setPendingAckOp(PendingAckOp.ACK);\n+        builder.setAckType(AckType.Individual);\n+        positions.forEach(positionIntegerMutablePair -> {\n+            PendingAckMetadata.Builder metadataBuilder = PendingAckMetadata.newBuilder();\n+            PositionImpl position = positionIntegerMutablePair.getLeft();\n+            int batchSize = positionIntegerMutablePair.getRight();\n+            if (positionIntegerMutablePair.getLeft().getAckSet() != null) {\n+                metadataBuilder.addAllAckSet(SafeCollectionUtils.longArrayToList(position.getAckSet()));\n+                metadataBuilder.setBatchSize(batchSize);\n+            }\n+            metadataBuilder.setLedgerId(position.getLedgerId());\n+            metadataBuilder.setEntryId(position.getEntryId());\n+            PendingAckMetadata pendingAckMetadata = metadataBuilder.build();\n+            metadataBuilder.recycle();\n+            builder.addPendingAckMetadata(pendingAckMetadata);\n+        });\n+        return appendCommon(builder, txnID);\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> appendCumulativeAck(TxnID txnID, PositionImpl position) {\n+        PendingAckMetadataEntry.Builder builder = PendingAckMetadataEntry.newBuilder();\n+        builder.setPendingAckOp(PendingAckOp.ACK);\n+        builder.setAckType(AckType.Cumulative);\n+        PendingAckMetadata.Builder metadataBuilder = PendingAckMetadata.newBuilder();\n+        if (position.getAckSet() != null) {\n+            metadataBuilder.addAllAckSet(SafeCollectionUtils.longArrayToList(position.getAckSet()));\n+        }\n+        metadataBuilder.setLedgerId(position.getLedgerId());\n+        metadataBuilder.setEntryId(position.getEntryId());\n+        PendingAckMetadata pendingAckMetadata = metadataBuilder.build();\n+        metadataBuilder.recycle();\n+        builder.addPendingAckMetadata(pendingAckMetadata);\n+        return appendCommon(builder, txnID);\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> appendCommitMark(TxnID txnID, AckType ackType) {\n+        PendingAckMetadataEntry.Builder builder = PendingAckMetadataEntry.newBuilder();\n+        builder.setPendingAckOp(PendingAckOp.COMMIT);\n+        builder.setAckType(ackType);\n+        return appendCommon(builder, txnID);\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> appendAbortMark(TxnID txnID, AckType ackType) {\n+        PendingAckMetadataEntry.Builder builder = PendingAckMetadataEntry.newBuilder();\n+        builder.setPendingAckOp(PendingAckOp.ABORT);\n+        builder.setAckType(ackType);\n+        return appendCommon(builder, txnID);\n+    }\n+\n+    private CompletableFuture<Void> appendCommon(PendingAckMetadataEntry.Builder builder, TxnID txnID) {\n+        CompletableFuture<Void> completableFuture = new CompletableFuture<>();\n+        builder.setTxnidLeastBits(txnID.getLeastSigBits());\n+        builder.setTxnidMostBits(txnID.getMostSigBits());\n+        PendingAckMetadataEntry pendingAckMetadataEntry = builder.build();\n+        int transactionMetadataEntrySize = pendingAckMetadataEntry.getSerializedSize();\n+        ByteBuf buf = PulsarByteBufAllocator.DEFAULT.buffer(transactionMetadataEntrySize, transactionMetadataEntrySize);\n+        ByteBufCodedOutputStream outStream = ByteBufCodedOutputStream.get(buf);\n+        try {\n+            pendingAckMetadataEntry.writeTo(outStream);\n+            managedLedger.asyncAddEntry(buf, new AsyncCallbacks.AddEntryCallback() {\n+                @Override\n+                public void addComplete(Position position, Object ctx) {\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"[{}][{}] MLPendingAckStore message append success at {}, operation : {}\",\n+                                managedLedger.getName(), ctx, position, builder.getPendingAckOp());\n+                    }\n+                    builder.recycle();\n+                    pendingAckMetadataEntry.recycle();\n+                    buf.release();\n+                    completableFuture.complete(null);\n+                }\n+\n+                @Override\n+                public void addFailed(ManagedLedgerException exception, Object ctx) {\n+                    log.error(\"[{}][{}] MLPendingAckStore message append fail exception : {}, operation : {}\",\n+                            managedLedger.getName(), ctx, exception, builder.getPendingAckOp());\n+                    builder.recycle();\n+                    pendingAckMetadataEntry.recycle();\n+                    buf.release();\n+                    completableFuture.completeExceptionally(exception);\n+                }\n+            } , null);\n+        } catch (Exception e) {\n+            log.error(\"[{}] MLPendingAckStore message append fail exception : {}\",\n+                    managedLedger.getName(), e);\n+            builder.recycle();\n+            pendingAckMetadataEntry.recycle();\n+            buf.release();\n+            completableFuture.completeExceptionally(e);\n+        } finally {\n+            outStream.recycle();\n+        }\n+        return completableFuture;\n+    }\n+\n+    class PendingAckReplay implements Runnable {\n+\n+        private final FillEntryQueueCallback fillEntryQueueCallback;\n+        private final PendingAckReplyCallBack pendingAckReplyCallBack;\n+\n+        PendingAckReplay(PendingAckReplyCallBack pendingAckReplyCallBack) {\n+            this.fillEntryQueueCallback = new FillEntryQueueCallback();\n+            this.pendingAckReplyCallBack = pendingAckReplyCallBack;\n+        }\n+\n+        @Override\n+        public void run() {\n+            while (lastConfirmedEntry.compareTo(currentLoadPosition) > 0) {\n+                fillEntryQueueCallback.fillQueue();\n+                Entry entry = entryQueue.poll();\n+                if (entry != null) {\n+                    ByteBuf buffer = entry.getDataBuffer();\n+                    currentLoadPosition = PositionImpl.get(entry.getLedgerId(), entry.getEntryId());\n+                    ByteBufCodedInputStream stream = ByteBufCodedInputStream.get(buffer);\n+                    PendingAckMetadataEntry.Builder pendingAckMetadataEntryBuilder =\n+                            PendingAckMetadataEntry.newBuilder();\n+                    PendingAckMetadataEntry pendingAckMetadataEntry = null;\n+                    try {\n+                        pendingAckMetadataEntry =\n+                                pendingAckMetadataEntryBuilder.mergeFrom(stream, null).build();\n+                        pendingAckReplyCallBack.handleMetadataEntry(pendingAckMetadataEntry);\n+                    } catch (Exception e) {\n+                        if (pendingAckMetadataEntry != null) {\n+                            log.error(\"TxnId : [{}:{}] MLPendingAckStore reply error!\",\n+                                    pendingAckMetadataEntry.getTxnidMostBits(),\n+                                    pendingAckMetadataEntry.getTxnidLeastBits(), e);\n+                        } else {\n+                            log.error(\"MLPendingAckStore reply error!\", e);\n+                        }\n+                    }\n+                    entry.release();\n+                    if (pendingAckMetadataEntry != null) {\n+                        pendingAckMetadataEntry.recycle();\n+                    }\n+                    pendingAckMetadataEntryBuilder.recycle();\n+                    stream.recycle();\n+                } else {\n+                    try {\n+                        Thread.sleep(1);\n+                    } catch (InterruptedException e) {\n+                        //no-op", "originalCommit": "8e26d8aed029ebdb2ec78e6092a4fdf82210c494", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzk3NzY2NA==", "url": "https://github.com/apache/pulsar/pull/8881#discussion_r557977664", "bodyText": "what is the recovery story for this error ?", "author": "eolivelli", "createdAt": "2021-01-15T07:55:10Z", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/transaction/pendingack/impl/MLPendingAckStore.java", "diffHunk": "@@ -0,0 +1,336 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.transaction.pendingack.impl;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import io.netty.util.Timer;\n+import org.apache.bookkeeper.mledger.AsyncCallbacks;\n+import org.apache.bookkeeper.mledger.Entry;\n+import org.apache.bookkeeper.mledger.ManagedCursor;\n+import org.apache.bookkeeper.mledger.ManagedLedger;\n+import org.apache.bookkeeper.mledger.ManagedLedgerException;\n+import org.apache.bookkeeper.mledger.Position;\n+import org.apache.bookkeeper.mledger.impl.PositionImpl;\n+import org.apache.commons.lang3.tuple.MutablePair;\n+import org.apache.pulsar.broker.transaction.pendingack.PendingAckReplyCallBack;\n+import org.apache.pulsar.broker.transaction.pendingack.PendingAckStore;\n+import org.apache.pulsar.broker.transaction.proto.TransactionPendingAck.PendingAckMetadata;\n+import org.apache.pulsar.broker.transaction.proto.TransactionPendingAck.PendingAckMetadataEntry;\n+import org.apache.pulsar.broker.transaction.proto.TransactionPendingAck.PendingAckOp;\n+import org.apache.pulsar.client.api.transaction.TxnID;\n+import org.apache.pulsar.common.allocator.PulsarByteBufAllocator;\n+import org.apache.pulsar.common.api.proto.PulsarApi.CommandAck.AckType;\n+import org.apache.pulsar.common.naming.TopicName;\n+import org.apache.pulsar.common.util.SafeCollectionUtils;\n+import org.apache.pulsar.common.util.protobuf.ByteBufCodedInputStream;\n+import org.apache.pulsar.common.util.protobuf.ByteBufCodedOutputStream;\n+import org.jctools.queues.MessagePassingQueue;\n+import org.jctools.queues.SpscArrayQueue;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The implement of the pending ack store by manageLedger.\n+ */\n+public class MLPendingAckStore implements PendingAckStore {\n+\n+\n+    private final ManagedLedger managedLedger;\n+\n+    private final ManagedCursor cursor;\n+\n+    private static final String PENDING_ACK_STORE_SUFFIX = \"-transaction-pendingack\";\n+\n+    private static final String PENDING_ACK_STORE_CURSOR_NAME = \"pendingack\";\n+\n+    private final SpscArrayQueue<Entry> entryQueue;\n+\n+    //this is for replay\n+    private final PositionImpl lastConfirmedEntry;\n+\n+    private PositionImpl currentLoadPosition;\n+\n+    private final Timer timer;\n+\n+    private final MLPendingAckStoreTimerTask mlPendingAckStoreTimerTask;\n+\n+    private final int intervalTime;\n+\n+    public MLPendingAckStore(ManagedLedger managedLedger, ManagedCursor cursor,\n+                             Timer timer, ManagedCursor subManagedCursor, int maxIntervalTime, int minIntervalTime) {\n+        this.managedLedger = managedLedger;\n+        this.cursor = cursor;\n+        this.currentLoadPosition = (PositionImpl) this.cursor.getMarkDeletedPosition();\n+        this.entryQueue = new SpscArrayQueue<>(2000);\n+        this.lastConfirmedEntry = (PositionImpl) managedLedger.getLastConfirmedEntry();\n+        this.timer = timer;\n+        this.intervalTime = minIntervalTime;\n+        this.mlPendingAckStoreTimerTask = new MLPendingAckStoreTimerTask(cursor, managedLedger,\n+                minIntervalTime, maxIntervalTime, subManagedCursor, this.timer);\n+    }\n+\n+    @Override\n+    public void replayAsync(PendingAckHandleImpl pendingAckHandle, ScheduledExecutorService transactionReplayExecutor) {\n+        transactionReplayExecutor\n+                .execute(new PendingAckReplay(new MLPendingAckReplyCallBack(this, pendingAckHandle)));\n+    }\n+\n+    //TODO can control the number of entry to read\n+    private void readAsync(int numberOfEntriesToRead,\n+                           AsyncCallbacks.ReadEntriesCallback readEntriesCallback) {\n+        cursor.asyncReadEntries(numberOfEntriesToRead, readEntriesCallback, System.nanoTime());\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> closeAsync() {\n+        CompletableFuture<Void> completableFuture = new CompletableFuture<>();\n+        cursor.asyncClose(new AsyncCallbacks.CloseCallback() {\n+            @Override\n+            public void closeComplete(Object ctx) {\n+                try {\n+                    managedLedger.close();\n+                } catch (Exception e) {\n+                    completableFuture.completeExceptionally(e);\n+                }\n+                completableFuture.complete(null);\n+            }\n+\n+            @Override\n+            public void closeFailed(ManagedLedgerException exception, Object ctx) {\n+                completableFuture.completeExceptionally(exception);\n+            }\n+        }, null);\n+        return completableFuture;\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> appendIndividualAck(TxnID txnID, List<MutablePair<PositionImpl, Integer>> positions) {\n+        PendingAckMetadataEntry.Builder builder = PendingAckMetadataEntry.newBuilder();\n+        builder.setPendingAckOp(PendingAckOp.ACK);\n+        builder.setAckType(AckType.Individual);\n+        positions.forEach(positionIntegerMutablePair -> {\n+            PendingAckMetadata.Builder metadataBuilder = PendingAckMetadata.newBuilder();\n+            PositionImpl position = positionIntegerMutablePair.getLeft();\n+            int batchSize = positionIntegerMutablePair.getRight();\n+            if (positionIntegerMutablePair.getLeft().getAckSet() != null) {\n+                metadataBuilder.addAllAckSet(SafeCollectionUtils.longArrayToList(position.getAckSet()));\n+                metadataBuilder.setBatchSize(batchSize);\n+            }\n+            metadataBuilder.setLedgerId(position.getLedgerId());\n+            metadataBuilder.setEntryId(position.getEntryId());\n+            PendingAckMetadata pendingAckMetadata = metadataBuilder.build();\n+            metadataBuilder.recycle();\n+            builder.addPendingAckMetadata(pendingAckMetadata);\n+        });\n+        return appendCommon(builder, txnID);\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> appendCumulativeAck(TxnID txnID, PositionImpl position) {\n+        PendingAckMetadataEntry.Builder builder = PendingAckMetadataEntry.newBuilder();\n+        builder.setPendingAckOp(PendingAckOp.ACK);\n+        builder.setAckType(AckType.Cumulative);\n+        PendingAckMetadata.Builder metadataBuilder = PendingAckMetadata.newBuilder();\n+        if (position.getAckSet() != null) {\n+            metadataBuilder.addAllAckSet(SafeCollectionUtils.longArrayToList(position.getAckSet()));\n+        }\n+        metadataBuilder.setLedgerId(position.getLedgerId());\n+        metadataBuilder.setEntryId(position.getEntryId());\n+        PendingAckMetadata pendingAckMetadata = metadataBuilder.build();\n+        metadataBuilder.recycle();\n+        builder.addPendingAckMetadata(pendingAckMetadata);\n+        return appendCommon(builder, txnID);\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> appendCommitMark(TxnID txnID, AckType ackType) {\n+        PendingAckMetadataEntry.Builder builder = PendingAckMetadataEntry.newBuilder();\n+        builder.setPendingAckOp(PendingAckOp.COMMIT);\n+        builder.setAckType(ackType);\n+        return appendCommon(builder, txnID);\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> appendAbortMark(TxnID txnID, AckType ackType) {\n+        PendingAckMetadataEntry.Builder builder = PendingAckMetadataEntry.newBuilder();\n+        builder.setPendingAckOp(PendingAckOp.ABORT);\n+        builder.setAckType(ackType);\n+        return appendCommon(builder, txnID);\n+    }\n+\n+    private CompletableFuture<Void> appendCommon(PendingAckMetadataEntry.Builder builder, TxnID txnID) {\n+        CompletableFuture<Void> completableFuture = new CompletableFuture<>();\n+        builder.setTxnidLeastBits(txnID.getLeastSigBits());\n+        builder.setTxnidMostBits(txnID.getMostSigBits());\n+        PendingAckMetadataEntry pendingAckMetadataEntry = builder.build();\n+        int transactionMetadataEntrySize = pendingAckMetadataEntry.getSerializedSize();\n+        ByteBuf buf = PulsarByteBufAllocator.DEFAULT.buffer(transactionMetadataEntrySize, transactionMetadataEntrySize);\n+        ByteBufCodedOutputStream outStream = ByteBufCodedOutputStream.get(buf);\n+        try {\n+            pendingAckMetadataEntry.writeTo(outStream);\n+            managedLedger.asyncAddEntry(buf, new AsyncCallbacks.AddEntryCallback() {\n+                @Override\n+                public void addComplete(Position position, Object ctx) {\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"[{}][{}] MLPendingAckStore message append success at {}, operation : {}\",\n+                                managedLedger.getName(), ctx, position, builder.getPendingAckOp());\n+                    }\n+                    builder.recycle();\n+                    pendingAckMetadataEntry.recycle();\n+                    buf.release();\n+                    completableFuture.complete(null);\n+                }\n+\n+                @Override\n+                public void addFailed(ManagedLedgerException exception, Object ctx) {\n+                    log.error(\"[{}][{}] MLPendingAckStore message append fail exception : {}, operation : {}\",\n+                            managedLedger.getName(), ctx, exception, builder.getPendingAckOp());\n+                    builder.recycle();\n+                    pendingAckMetadataEntry.recycle();\n+                    buf.release();\n+                    completableFuture.completeExceptionally(exception);\n+                }\n+            } , null);\n+        } catch (Exception e) {\n+            log.error(\"[{}] MLPendingAckStore message append fail exception : {}\",\n+                    managedLedger.getName(), e);\n+            builder.recycle();\n+            pendingAckMetadataEntry.recycle();\n+            buf.release();\n+            completableFuture.completeExceptionally(e);\n+        } finally {\n+            outStream.recycle();\n+        }\n+        return completableFuture;\n+    }\n+\n+    class PendingAckReplay implements Runnable {\n+\n+        private final FillEntryQueueCallback fillEntryQueueCallback;\n+        private final PendingAckReplyCallBack pendingAckReplyCallBack;\n+\n+        PendingAckReplay(PendingAckReplyCallBack pendingAckReplyCallBack) {\n+            this.fillEntryQueueCallback = new FillEntryQueueCallback();\n+            this.pendingAckReplyCallBack = pendingAckReplyCallBack;\n+        }\n+\n+        @Override\n+        public void run() {\n+            while (lastConfirmedEntry.compareTo(currentLoadPosition) > 0) {\n+                fillEntryQueueCallback.fillQueue();\n+                Entry entry = entryQueue.poll();\n+                if (entry != null) {\n+                    ByteBuf buffer = entry.getDataBuffer();\n+                    currentLoadPosition = PositionImpl.get(entry.getLedgerId(), entry.getEntryId());\n+                    ByteBufCodedInputStream stream = ByteBufCodedInputStream.get(buffer);\n+                    PendingAckMetadataEntry.Builder pendingAckMetadataEntryBuilder =\n+                            PendingAckMetadataEntry.newBuilder();\n+                    PendingAckMetadataEntry pendingAckMetadataEntry = null;\n+                    try {\n+                        pendingAckMetadataEntry =\n+                                pendingAckMetadataEntryBuilder.mergeFrom(stream, null).build();\n+                        pendingAckReplyCallBack.handleMetadataEntry(pendingAckMetadataEntry);\n+                    } catch (Exception e) {\n+                        if (pendingAckMetadataEntry != null) {\n+                            log.error(\"TxnId : [{}:{}] MLPendingAckStore reply error!\",\n+                                    pendingAckMetadataEntry.getTxnidMostBits(),\n+                                    pendingAckMetadataEntry.getTxnidLeastBits(), e);\n+                        } else {\n+                            log.error(\"MLPendingAckStore reply error!\", e);\n+                        }\n+                    }\n+                    entry.release();\n+                    if (pendingAckMetadataEntry != null) {\n+                        pendingAckMetadataEntry.recycle();\n+                    }\n+                    pendingAckMetadataEntryBuilder.recycle();\n+                    stream.recycle();\n+                } else {\n+                    try {\n+                        Thread.sleep(1);\n+                    } catch (InterruptedException e) {\n+                        //no-op\n+                    }\n+                }\n+            }\n+            pendingAckReplyCallBack.replayComplete();\n+        }\n+    }\n+\n+    class FillEntryQueueCallback implements AsyncCallbacks.ReadEntriesCallback {\n+\n+        private final AtomicLong outstandingReadsRequests = new AtomicLong(0);\n+\n+        public FillEntryQueueCallback() {\n+        }\n+\n+        void fillQueue() {\n+            if (entryQueue.size() < entryQueue.capacity() && outstandingReadsRequests.get() == 0) {\n+                if (cursor.hasMoreEntries()) {\n+                    outstandingReadsRequests.incrementAndGet();\n+                    readAsync(100, this);\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void readEntriesComplete(List<Entry> entries, Object ctx) {\n+            entryQueue.fill(new MessagePassingQueue.Supplier<Entry>() {\n+                private int i = 0;\n+                @Override\n+                public Entry get() {\n+                    Entry entry = entries.get(i);\n+                    i++;\n+                    return entry;\n+                }\n+            }, entries.size());\n+\n+            outstandingReadsRequests.decrementAndGet();\n+        }\n+\n+        @Override\n+        public void readEntriesFailed(ManagedLedgerException exception, Object ctx) {\n+            log.error(\"MLPendingAckStore stat reply fail!\", exception);\n+            outstandingReadsRequests.decrementAndGet();", "originalCommit": "8e26d8aed029ebdb2ec78e6092a4fdf82210c494", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxOTc1OTAwMw==", "url": "https://github.com/apache/pulsar/pull/8881#discussion_r619759003", "bodyText": "read pending ack entry fail", "author": "congbobo184", "createdAt": "2021-04-25T06:27:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzk3NzY2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzk4MTcyOQ==", "url": "https://github.com/apache/pulsar/pull/8881#discussion_r557981729", "bodyText": "what about creating a method in parent class MLPendingAckStoreProvider\nvoid ensureTimer() {\n     if (timer == null) {\n         synchronized(this) {\n             initialize();  \n       }\n    }\n}\n\nIMHO code will be more readable", "author": "eolivelli", "createdAt": "2021-01-15T07:57:19Z", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/transaction/pendingack/impl/MLPendingAckStoreProvider.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.transaction.pendingack.impl;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import io.netty.util.HashedWheelTimer;\n+import io.netty.util.Timer;\n+import io.netty.util.concurrent.DefaultThreadFactory;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.bookkeeper.mledger.AsyncCallbacks;\n+import org.apache.bookkeeper.mledger.ManagedCursor;\n+import org.apache.bookkeeper.mledger.ManagedLedger;\n+import org.apache.bookkeeper.mledger.ManagedLedgerException;\n+import org.apache.pulsar.broker.service.persistent.PersistentSubscription;\n+import org.apache.pulsar.broker.service.persistent.PersistentTopic;\n+import org.apache.pulsar.broker.transaction.pendingack.PendingAckStore;\n+import org.apache.pulsar.broker.transaction.pendingack.TransactionPendingAckStoreProvider;\n+import org.apache.pulsar.broker.transaction.pendingack.exceptions.TransactionPendingAckStoreProviderException;\n+import org.apache.pulsar.common.api.proto.PulsarApi.CommandSubscribe.InitialPosition;\n+import org.apache.pulsar.common.naming.TopicName;\n+\n+/**\n+ * Provider is for MLPendingAckStore.\n+ */\n+@Slf4j\n+public class MLPendingAckStoreProvider implements TransactionPendingAckStoreProvider {\n+\n+    private volatile Timer timer;\n+\n+    private static final long tickTimeMillis = 1L;\n+\n+    @Override\n+    public CompletableFuture<PendingAckStore> newPendingAckStore(PersistentSubscription subscription) {\n+        CompletableFuture<PendingAckStore> pendingAckStoreFuture = new CompletableFuture<>();\n+\n+        if (subscription == null) {\n+            pendingAckStoreFuture.completeExceptionally(\n+                    new TransactionPendingAckStoreProviderException(\"The subscription is null.\"));\n+            return pendingAckStoreFuture;\n+        }\n+\n+        PersistentTopic originPersistentTopic = (PersistentTopic) subscription.getTopic();\n+        String pendingAckTopicName = MLPendingAckStore\n+                .getTransactionPendingAckStoreSuffix(originPersistentTopic.getName(), subscription.getName());\n+\n+        originPersistentTopic.getBrokerService().getManagedLedgerFactory()\n+                .asyncOpen(TopicName.get(pendingAckTopicName).getPersistenceNamingEncoding(),\n+                        new AsyncCallbacks.OpenLedgerCallback() {\n+                            @Override\n+                            public void openLedgerComplete(ManagedLedger ledger, Object ctx) {\n+                                ledger.asyncOpenCursor(MLPendingAckStore.getTransactionPendingAckStoreCursorName(),\n+                                        InitialPosition.Earliest, new AsyncCallbacks.OpenCursorCallback() {\n+                                            @Override\n+                                            public void openCursorComplete(ManagedCursor cursor, Object ctx) {\n+                                                if (timer == null) {", "originalCommit": "8e26d8aed029ebdb2ec78e6092a4fdf82210c494", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzk5MDE4OQ==", "url": "https://github.com/apache/pulsar/pull/8881#discussion_r557990189", "bodyText": "this is very error prone,\ncan we detect an instance of a specific class of exception ?", "author": "eolivelli", "createdAt": "2021-01-15T08:01:49Z", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/transaction/pendingack/impl/MLPendingAckStoreTimerTask.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.transaction.pendingack.impl;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.util.Timeout;\n+import io.netty.util.Timer;\n+import io.netty.util.TimerTask;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.bookkeeper.mledger.AsyncCallbacks;\n+import org.apache.bookkeeper.mledger.Entry;\n+import org.apache.bookkeeper.mledger.ManagedCursor;\n+import org.apache.bookkeeper.mledger.ManagedLedger;\n+import org.apache.bookkeeper.mledger.ManagedLedgerException;\n+import org.apache.bookkeeper.mledger.impl.ManagedCursorImpl;\n+import org.apache.bookkeeper.mledger.impl.ManagedLedgerImpl;\n+import org.apache.bookkeeper.mledger.impl.PositionImpl;\n+import org.apache.pulsar.broker.transaction.proto.TransactionPendingAck.PendingAckMetadata;\n+import org.apache.pulsar.broker.transaction.proto.TransactionPendingAck.PendingAckMetadataEntry;\n+import org.apache.pulsar.common.api.proto.PulsarApi.CommandAck.AckType;\n+import org.apache.pulsar.common.util.protobuf.ByteBufCodedInputStream;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Pending ack timer task.\n+ */\n+@Slf4j\n+public class MLPendingAckStoreTimerTask implements TimerTask {\n+\n+    private int intervalTime;\n+\n+    private final int maxIntervalTime;\n+\n+    private final int minIntervalTime;\n+\n+    private final ManagedCursorImpl subManagedCursor;\n+\n+    private final ManagedLedgerImpl storeManagedLedger;\n+\n+    private final ManagedCursorImpl managedCursor;\n+\n+    private final Timer timer;\n+\n+    private volatile PositionImpl markDeletePosition;\n+\n+    public MLPendingAckStoreTimerTask(ManagedCursor managedCursor, ManagedLedger storeManagedLedger,\n+                                      int maxIntervalTime, int minIntervalTime,\n+                                      ManagedCursor subManageCursor, Timer timer) {\n+        this.intervalTime = minIntervalTime;\n+        this.maxIntervalTime = maxIntervalTime;\n+        this.minIntervalTime = minIntervalTime;\n+        this.managedCursor = (ManagedCursorImpl) managedCursor;\n+        this.subManagedCursor = (ManagedCursorImpl) subManageCursor;\n+        this.storeManagedLedger = (ManagedLedgerImpl) storeManagedLedger;\n+        this.markDeletePosition = (PositionImpl) managedCursor.getMarkDeletedPosition();\n+        this.timer = timer;\n+    }\n+\n+    @Override\n+    public void run(Timeout timeout) {\n+        if (this.managedCursor.getState().equals(\"Closed\")) {\n+            return;\n+        }\n+        try {\n+            // when no transaction ack operation in this pending ack store, it will increase the interval time\n+            if (markDeletePosition.compareTo((PositionImpl) storeManagedLedger.getLastConfirmedEntry()) == 0) {\n+                int time = intervalTime + minIntervalTime;\n+                if (time > maxIntervalTime) {\n+                    intervalTime = maxIntervalTime;\n+                } else {\n+                    intervalTime = time;\n+                }\n+                managedCursor.markDelete(markDeletePosition);\n+                timer.newTimeout(MLPendingAckStoreTimerTask.this, intervalTime, TimeUnit.SECONDS);\n+                return;\n+            } else {\n+                int time = intervalTime - minIntervalTime;\n+                if (time < minIntervalTime) {\n+                    intervalTime = minIntervalTime;\n+                } else {\n+                    intervalTime = time;\n+                }\n+            }\n+            // this while in order to find the last position witch can mark delete\n+            while (true) {\n+                PositionImpl nextPosition = storeManagedLedger.getNextValidPosition(markDeletePosition);\n+                Entry entry = getEntry(nextPosition).get();\n+                ByteBuf buffer = entry.getDataBuffer();\n+                ByteBufCodedInputStream stream = ByteBufCodedInputStream.get(buffer);\n+                PendingAckMetadataEntry.Builder pendingAckMetadataEntryBuilder =\n+                        PendingAckMetadataEntry.newBuilder();\n+                PendingAckMetadataEntry pendingAckMetadataEntry = null;\n+                try {\n+                    pendingAckMetadataEntry =\n+                            pendingAckMetadataEntryBuilder.mergeFrom(stream, null).build();\n+                    switch (pendingAckMetadataEntry.getPendingAckOp()) {\n+                        case ACK:\n+                            if (pendingAckMetadataEntry.getAckType() == AckType.Cumulative) {\n+                                PendingAckMetadata pendingAckMetadata =\n+                                        pendingAckMetadataEntry.getPendingAckMetadata(0);\n+                                handleAckCommon(PositionImpl.get(pendingAckMetadata.getLedgerId(),\n+                                        pendingAckMetadata.getEntryId()), nextPosition);\n+                            } else {\n+                                //this judge the pendingAckMetadataEntry is can delete\n+                                PositionImpl largestPosition = null;\n+                                List<PendingAckMetadata> metadataList =\n+                                        pendingAckMetadataEntry.getPendingAckMetadataList();\n+                                for (int i = 0; i < metadataList.size(); i++) {\n+                                    PendingAckMetadata pendingAckMetadata = metadataList.get(0);\n+                                    if (largestPosition == null) {\n+                                        largestPosition = PositionImpl.get(pendingAckMetadata.getLedgerId(),\n+                                                pendingAckMetadata.getEntryId());\n+                                    } else {\n+                                        PositionImpl comparePosition = PositionImpl\n+                                                .get(pendingAckMetadata.getLedgerId(),\n+                                                        pendingAckMetadata.getEntryId());\n+                                        if (largestPosition.compareTo(comparePosition) <  0) {\n+                                            largestPosition = comparePosition;\n+                                        }\n+\n+                                    }\n+                                }\n+                                if (largestPosition != null) {\n+                                    handleAckCommon(largestPosition, nextPosition);\n+                                }\n+                            }\n+                            break;\n+                        case ABORT:\n+                        case COMMIT:\n+                            markDeletePosition = nextPosition;\n+                            break;\n+                        default:\n+                            log.error(\"PendingAck timer task read illegal metadata state! {}\",\n+                                    pendingAckMetadataEntry.getPendingAckOp());\n+                    }\n+                } finally {\n+                    entry.release();\n+                    if (pendingAckMetadataEntry != null) {\n+                        pendingAckMetadataEntry.recycle();\n+                    }\n+                    pendingAckMetadataEntryBuilder.recycle();\n+                    stream.recycle();\n+                }\n+                // when markDeletePosition is not nextPosition, before markDeletePosition can delete\n+                if (markDeletePosition != nextPosition) {\n+                    this.managedCursor.markDelete(markDeletePosition);\n+                    break;\n+                }\n+            }\n+            this.timer.newTimeout(this, intervalTime, TimeUnit.MILLISECONDS);\n+        } catch (Exception e) {\n+            log.error(\"PendingAck timer task error!\", e);\n+            if (\"Cursor was already closed\".equals(e.getCause().getMessage())) {", "originalCommit": "8e26d8aed029ebdb2ec78e6092a4fdf82210c494", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a17e9596eba589777486cfd0589d90923260ad30", "url": "https://github.com/apache/pulsar/commit/a17e9596eba589777486cfd0589d90923260ad30", "message": "Transaction pending ack persistent", "committedDate": "2021-02-07T04:05:58Z", "type": "commit"}, {"oid": "45588c6d5c755db7995ab6d43e8289aee99ca074", "url": "https://github.com/apache/pulsar/commit/45588c6d5c755db7995ab6d43e8289aee99ca074", "message": "Fix some named", "committedDate": "2021-02-07T04:05:58Z", "type": "commit"}, {"oid": "516d7d224bedccef2054ef19ffc9a301f91cb469", "url": "https://github.com/apache/pulsar/commit/516d7d224bedccef2054ef19ffc9a301f91cb469", "message": "Merge remote-tracking branch 'apache/master' into congbobo184_transaction_pendingack_persistent\n\n# Conflicts:\n#\tpom.xml\n#\tpulsar-broker/src/main/java/org/apache/pulsar/broker/PulsarService.java\n#\tpulsar-broker/src/test/java/org/apache/pulsar/broker/service/TransactionMarkerDeleteTest.java\n#\tpulsar-broker/src/test/java/org/apache/pulsar/broker/service/persistent/PersistentSubscriptionTest.java\n#\tpulsar-broker/src/test/java/org/apache/pulsar/broker/transaction/TransactionTestBase.java", "committedDate": "2021-02-07T09:42:49Z", "type": "commit"}, {"oid": "98ea58bca66bd14b2076a37b3c761c741496fff4", "url": "https://github.com/apache/pulsar/commit/98ea58bca66bd14b2076a37b3c761c741496fff4", "message": "Merge branch 'congbobo184_transaction_pendingack_persistent' of https://github.com/congbobo184/pulsar into congbobo184_transaction_pendingack_persistent\n\n# Conflicts:\n#\tpom.xml\n#\tpulsar-broker/src/main/java/org/apache/pulsar/broker/PulsarService.java\n#\tpulsar-broker/src/main/java/org/apache/pulsar/broker/service/persistent/PersistentSubscription.java\n#\tpulsar-broker/src/main/java/org/apache/pulsar/broker/transaction/pendingack/PendingAckHandle.java\n#\tpulsar-broker/src/main/java/org/apache/pulsar/broker/transaction/pendingack/PendingAckReplyCallBack.java\n#\tpulsar-broker/src/main/java/org/apache/pulsar/broker/transaction/pendingack/PendingAckStore.java\n#\tpulsar-broker/src/main/java/org/apache/pulsar/broker/transaction/pendingack/TransactionPendingAckStoreProvider.java\n#\tpulsar-broker/src/main/java/org/apache/pulsar/broker/transaction/pendingack/impl/InMemoryPendingAckStore.java\n#\tpulsar-broker/src/main/java/org/apache/pulsar/broker/transaction/pendingack/impl/MLPendingAckReplyCallBack.java\n#\tpulsar-broker/src/main/java/org/apache/pulsar/broker/transaction/pendingack/impl/MLPendingAckStore.java\n#\tpulsar-broker/src/main/java/org/apache/pulsar/broker/transaction/pendingack/impl/MLPendingAckStoreProvider.java\n#\tpulsar-broker/src/main/java/org/apache/pulsar/broker/transaction/pendingack/impl/MLPendingAckStoreTimerTask.java\n#\tpulsar-broker/src/main/java/org/apache/pulsar/broker/transaction/pendingack/impl/PendingAckHandleDisabled.java\n#\tpulsar-broker/src/main/java/org/apache/pulsar/broker/transaction/pendingack/impl/PendingAckHandleImpl.java\n#\tpulsar-broker/src/test/java/org/apache/pulsar/broker/service/TransactionMarkerDeleteTest.java\n#\tpulsar-broker/src/test/java/org/apache/pulsar/broker/service/persistent/PersistentSubscriptionTest.java\n#\tpulsar-broker/src/test/java/org/apache/pulsar/broker/transaction/TransactionTestBase.java\n#\tpulsar-broker/src/test/java/org/apache/pulsar/broker/transaction/pendingack/PendingAckPersistentTest.java", "committedDate": "2021-02-07T09:49:21Z", "type": "commit"}, {"oid": "b7a9296be7e772401501a6d38c99830a560cd73f", "url": "https://github.com/apache/pulsar/commit/b7a9296be7e772401501a6d38c99830a560cd73f", "message": "Merge remote-tracking branch 'apache/master' into congbobo184_transaction_pendingack_persistent", "committedDate": "2021-02-07T09:50:32Z", "type": "commit"}, {"oid": "de975916c2d6eda49c669c9e9ca66610d10d5e98", "url": "https://github.com/apache/pulsar/commit/de975916c2d6eda49c669c9e9ca66610d10d5e98", "message": "Change exception", "committedDate": "2021-02-07T12:25:15Z", "type": "commit"}, {"oid": "ed268e1eb57b836a51d59f47fbc4ba8f59f74b32", "url": "https://github.com/apache/pulsar/commit/ed268e1eb57b836a51d59f47fbc4ba8f59f74b32", "message": "Fix some test", "committedDate": "2021-03-01T11:31:08Z", "type": "commit"}, {"oid": "14d8268013fc02fda04e1bfe908fbd31c2fda78e", "url": "https://github.com/apache/pulsar/commit/14d8268013fc02fda04e1bfe908fbd31c2fda78e", "message": "Fix pending ack test.", "committedDate": "2021-03-01T14:19:42Z", "type": "commit"}, {"oid": "0434d8e2488c33ab74bd72327410c42a78f0ce93", "url": "https://github.com/apache/pulsar/commit/0434d8e2488c33ab74bd72327410c42a78f0ce93", "message": "Merge branch 'master' into congbobo184_transaction_pendingack_persistent\n\n# Conflicts:\n#\tpulsar-broker/src/main/java/org/apache/pulsar/broker/transaction/pendingack/PendingAckHandle.java\n#\tpulsar-broker/src/main/java/org/apache/pulsar/broker/transaction/pendingack/impl/PendingAckHandleImpl.java", "committedDate": "2021-03-02T10:00:33Z", "type": "commit"}, {"oid": "79d0e7bc2eb6579a6715bf5f14c61625228a777a", "url": "https://github.com/apache/pulsar/commit/79d0e7bc2eb6579a6715bf5f14c61625228a777a", "message": "Fix some design", "committedDate": "2021-03-16T08:08:15Z", "type": "commit"}, {"oid": "3d38a40b610147e48c5233f4724757743dba04b2", "url": "https://github.com/apache/pulsar/commit/3d38a40b610147e48c5233f4724757743dba04b2", "message": "Fix the test", "committedDate": "2021-03-16T14:09:51Z", "type": "commit"}, {"oid": "5a12efc9e2136a6ec52d9f71377b74d0d03bc809", "url": "https://github.com/apache/pulsar/commit/5a12efc9e2136a6ec52d9f71377b74d0d03bc809", "message": "Delete the callback", "committedDate": "2021-03-17T11:02:59Z", "type": "commit"}, {"oid": "97851241c55b69e22f9cc6aba83b8aa0543ea8d3", "url": "https://github.com/apache/pulsar/commit/97851241c55b69e22f9cc6aba83b8aa0543ea8d3", "message": "Merge branch 'master' into congbobo184_transaction_pendingack_persistent\n\n# Conflicts:\n#\tpulsar-broker/src/test/java/org/apache/pulsar/broker/transaction/pendingack/PendingAckInMemoryDeleteTest.java\ndelete pending ack recover exception", "committedDate": "2021-03-24T06:26:10Z", "type": "commit"}, {"oid": "2347bc47b4dd3d878a58f76d0a46823f1eb4f20b", "url": "https://github.com/apache/pulsar/commit/2347bc47b4dd3d878a58f76d0a46823f1eb4f20b", "message": "Delete pending ack topic create pending ack", "committedDate": "2021-03-25T01:39:09Z", "type": "commit"}, {"oid": "8d29edb6def31eebf633e520324c26cbc253310a", "url": "https://github.com/apache/pulsar/commit/8d29edb6def31eebf633e520324c26cbc253310a", "message": "Merge branch 'master' into congbobo184_transaction_pendingack_persistent\n\n# Conflicts:\n#\tpulsar-broker/src/main/java/org/apache/pulsar/broker/PulsarService.java", "committedDate": "2021-04-20T08:10:32Z", "type": "commit"}, {"oid": "cb4b7be8a95c8eaef59ecd37a2007a17a0021c76", "url": "https://github.com/apache/pulsar/commit/cb4b7be8a95c8eaef59ecd37a2007a17a0021c76", "message": "Merge branch 'master' into congbobo184_transaction_pendingack_persistent\n\n# Conflicts:\n#\tpulsar-broker/src/main/java/org/apache/pulsar/broker/service/AbstractTopic.java\n#\tpulsar-broker/src/main/java/org/apache/pulsar/broker/service/persistent/PersistentTopic.java\n#\tpulsar-client/src/main/java/org/apache/pulsar/client/impl/ClientCnx.java", "committedDate": "2021-04-25T06:34:56Z", "type": "commit"}, {"oid": "3f79b567c965a280eeb56821b155ad302070dd18", "url": "https://github.com/apache/pulsar/commit/3f79b567c965a280eeb56821b155ad302070dd18", "message": "Add some debug log", "committedDate": "2021-04-25T09:06:49Z", "type": "commit"}, {"oid": "8a2c078ccee15be51bef5305ed1a017b60586134", "url": "https://github.com/apache/pulsar/commit/8a2c078ccee15be51bef5305ed1a017b60586134", "message": "Fix some codestyle", "committedDate": "2021-04-25T09:31:45Z", "type": "commit"}, {"oid": "b668c0ba32da31fbea471dda767e9b2bdd5caaad", "url": "https://github.com/apache/pulsar/commit/b668c0ba32da31fbea471dda767e9b2bdd5caaad", "message": "Fix some test", "committedDate": "2021-04-25T13:39:14Z", "type": "commit"}, {"oid": "3c2ae9b1cb00d6c8c8f180647cfbf5c896e1cb7d", "url": "https://github.com/apache/pulsar/commit/3c2ae9b1cb00d6c8c8f180647cfbf5c896e1cb7d", "message": "Fix some catch exception.", "committedDate": "2021-04-25T14:09:30Z", "type": "commit"}, {"oid": "9553edcd3044677819d72d60cb2cfe73de0cb54a", "url": "https://github.com/apache/pulsar/commit/9553edcd3044677819d72d60cb2cfe73de0cb54a", "message": "Merge branch 'master' into congbobo184_transaction_pendingack_persistent", "committedDate": "2021-05-10T00:56:48Z", "type": "commit"}, {"oid": "f9ac2134732f361abea73086e44a6b335646fe8d", "url": "https://github.com/apache/pulsar/commit/f9ac2134732f361abea73086e44a6b335646fe8d", "message": "Merge master and add some log", "committedDate": "2021-05-10T01:29:12Z", "type": "commit"}, {"oid": "23ed17cb1b3a6dffbf327fee7fa644e180cd9e49", "url": "https://github.com/apache/pulsar/commit/23ed17cb1b3a6dffbf327fee7fa644e180cd9e49", "message": "Merge branch 'master' into congbobo184_transaction_pendingack_persistent", "committedDate": "2021-05-12T09:03:31Z", "type": "commit"}, {"oid": "aa50b7444daa3bc572fb926499672b55f56198e5", "url": "https://github.com/apache/pulsar/commit/aa50b7444daa3bc572fb926499672b55f56198e5", "message": "Fix some comment", "committedDate": "2021-05-12T09:55:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyOTc4NzAyNQ==", "url": "https://github.com/apache/pulsar/pull/8881#discussion_r629787025", "bodyText": "Why do we need to catch the exception here? If the exception occurs, you already have .exceptionally to deal with this.", "author": "codelipenghui", "createdAt": "2021-05-11T01:32:29Z", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/nonpersistent/NonPersistentTopic.java", "diffHunk": "@@ -265,13 +265,23 @@ public void removeProducer(Producer producer) {\n \n         NonPersistentSubscription subscription = subscriptions.computeIfAbsent(subscriptionName,\n                 name -> new NonPersistentSubscription(this, subscriptionName));\n-\n-        try {\n-            Consumer consumer = new Consumer(subscription, subType, topic, consumerId, priorityLevel, consumerName, 0,\n-                    cnx, cnx.getAuthRole(), metadata, readCompacted, initialPosition, keySharedMeta);\n-            addConsumerToSubscription(subscription, consumer);\n+        Consumer consumer = new Consumer(subscription, subType, topic, consumerId, priorityLevel, consumerName, 0,\n+                cnx, cnx.getAuthRole(), metadata, readCompacted, initialPosition, keySharedMeta);\n+        addConsumerToSubscription(subscription, consumer).thenAccept(v -> {\n             if (!cnx.isActive()) {\n-                consumer.close();\n+                try {\n+                    consumer.close();\n+                } catch (BrokerServiceException e) {\n+                    if (e instanceof ConsumerBusyException) {\n+                        log.warn(\"[{}][{}] Consumer {} {} already connected\", topic, subscriptionName, consumerId,\n+                                consumerName);\n+                    } else if (e instanceof SubscriptionBusyException) {\n+                        log.warn(\"[{}][{}] {}\", topic, subscriptionName, e.getMessage());\n+                    }\n+\n+                    decrementUsageCount();\n+                    future.completeExceptionally(e);", "originalCommit": "f9ac2134732f361abea73086e44a6b335646fe8d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMDk5MTE1NA==", "url": "https://github.com/apache/pulsar/pull/8881#discussion_r630991154", "bodyText": "the close is Is a synchronous method, so we should catch the exception.", "author": "congbobo184", "createdAt": "2021-05-12T12:24:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyOTc4NzAyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyOTc4NzUzOQ==", "url": "https://github.com/apache/pulsar/pull/8881#discussion_r629787539", "bodyText": "It's better to get the Cause first and use it in the followings.", "author": "codelipenghui", "createdAt": "2021-05-11T01:34:17Z", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/nonpersistent/NonPersistentTopic.java", "diffHunk": "@@ -282,17 +292,18 @@ public void removeProducer(Producer producer) {\n                 log.info(\"[{}][{}] Created new subscription for {}\", topic, subscriptionName, consumerId);\n                 future.complete(consumer);\n             }\n-        } catch (BrokerServiceException e) {\n-            if (e instanceof ConsumerBusyException) {\n+        }).exceptionally(e -> {\n+            if (e.getCause() instanceof ConsumerBusyException) {", "originalCommit": "f9ac2134732f361abea73086e44a6b335646fe8d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyOTc4ODA3NA==", "url": "https://github.com/apache/pulsar/pull/8881#discussion_r629788074", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final String PENDING_ACK_STORE_CURSOR_NAME = \"pendingack\";\n          \n          \n            \n                private static final String PENDING_ACK_STORE_CURSOR_NAME = \"__pending_ack_state\";", "author": "codelipenghui", "createdAt": "2021-05-11T01:36:00Z", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/transaction/pendingack/impl/MLPendingAckStore.java", "diffHunk": "@@ -0,0 +1,396 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.transaction.pendingack.impl;\n+\n+import com.google.common.collect.ComparisonChain;\n+import io.netty.buffer.ByteBuf;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicLong;\n+import org.apache.bookkeeper.mledger.AsyncCallbacks;\n+import org.apache.bookkeeper.mledger.Entry;\n+import org.apache.bookkeeper.mledger.ManagedCursor;\n+import org.apache.bookkeeper.mledger.ManagedLedger;\n+import org.apache.bookkeeper.mledger.ManagedLedgerException;\n+import org.apache.bookkeeper.mledger.Position;\n+import org.apache.bookkeeper.mledger.impl.ManagedCursorImpl;\n+import org.apache.bookkeeper.mledger.impl.PositionImpl;\n+import org.apache.commons.lang3.tuple.MutablePair;\n+import org.apache.pulsar.broker.service.BrokerServiceException.PersistenceException;\n+import org.apache.pulsar.broker.transaction.pendingack.PendingAckReplyCallBack;\n+import org.apache.pulsar.broker.transaction.pendingack.PendingAckStore;\n+import org.apache.pulsar.broker.transaction.pendingack.proto.PendingAckMetadata;\n+import org.apache.pulsar.broker.transaction.pendingack.proto.PendingAckMetadataEntry;\n+import org.apache.pulsar.broker.transaction.pendingack.proto.PendingAckOp;\n+import org.apache.pulsar.client.api.transaction.TxnID;\n+import org.apache.pulsar.common.allocator.PulsarByteBufAllocator;\n+import org.apache.pulsar.common.api.proto.CommandAck.AckType;\n+import org.apache.pulsar.common.naming.TopicName;\n+import org.jctools.queues.MessagePassingQueue;\n+import org.jctools.queues.SpscArrayQueue;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The implement of the pending ack store by manageLedger.\n+ */\n+public class MLPendingAckStore implements PendingAckStore {\n+\n+\n+    private final ManagedLedger managedLedger;\n+\n+    private final ManagedCursor cursor;\n+\n+    public static final String PENDING_ACK_STORE_SUFFIX = \"__transaction_pendingack\";\n+\n+    private static final String PENDING_ACK_STORE_CURSOR_NAME = \"pendingack\";", "originalCommit": "f9ac2134732f361abea73086e44a6b335646fe8d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMDk3NTMzNQ==", "url": "https://github.com/apache/pulsar/pull/8881#discussion_r630975335", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static final String PENDING_ACK_STORE_SUFFIX = \"__transaction_pendingack\";\n          \n          \n            \n                public static final String PENDING_ACK_STORE_SUFFIX = \"__transaction_pending_ack\";", "author": "codelipenghui", "createdAt": "2021-05-12T12:00:00Z", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/transaction/pendingack/impl/MLPendingAckStore.java", "diffHunk": "@@ -0,0 +1,396 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.transaction.pendingack.impl;\n+\n+import com.google.common.collect.ComparisonChain;\n+import io.netty.buffer.ByteBuf;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicLong;\n+import org.apache.bookkeeper.mledger.AsyncCallbacks;\n+import org.apache.bookkeeper.mledger.Entry;\n+import org.apache.bookkeeper.mledger.ManagedCursor;\n+import org.apache.bookkeeper.mledger.ManagedLedger;\n+import org.apache.bookkeeper.mledger.ManagedLedgerException;\n+import org.apache.bookkeeper.mledger.Position;\n+import org.apache.bookkeeper.mledger.impl.ManagedCursorImpl;\n+import org.apache.bookkeeper.mledger.impl.PositionImpl;\n+import org.apache.commons.lang3.tuple.MutablePair;\n+import org.apache.pulsar.broker.service.BrokerServiceException.PersistenceException;\n+import org.apache.pulsar.broker.transaction.pendingack.PendingAckReplyCallBack;\n+import org.apache.pulsar.broker.transaction.pendingack.PendingAckStore;\n+import org.apache.pulsar.broker.transaction.pendingack.proto.PendingAckMetadata;\n+import org.apache.pulsar.broker.transaction.pendingack.proto.PendingAckMetadataEntry;\n+import org.apache.pulsar.broker.transaction.pendingack.proto.PendingAckOp;\n+import org.apache.pulsar.client.api.transaction.TxnID;\n+import org.apache.pulsar.common.allocator.PulsarByteBufAllocator;\n+import org.apache.pulsar.common.api.proto.CommandAck.AckType;\n+import org.apache.pulsar.common.naming.TopicName;\n+import org.jctools.queues.MessagePassingQueue;\n+import org.jctools.queues.SpscArrayQueue;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The implement of the pending ack store by manageLedger.\n+ */\n+public class MLPendingAckStore implements PendingAckStore {\n+\n+\n+    private final ManagedLedger managedLedger;\n+\n+    private final ManagedCursor cursor;\n+\n+    public static final String PENDING_ACK_STORE_SUFFIX = \"__transaction_pendingack\";", "originalCommit": "aa50b7444daa3bc572fb926499672b55f56198e5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9a58f9c0e3167493b0d610b293932175514dffe8", "url": "https://github.com/apache/pulsar/commit/9a58f9c0e3167493b0d610b293932175514dffe8", "message": "Fix some comment", "committedDate": "2021-05-12T12:39:30Z", "type": "commit"}]}