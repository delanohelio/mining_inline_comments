{"pr_number": 8744, "pr_title": "Package management bookkeeper storage implementation", "pr_createdAt": "2020-11-30T09:55:59Z", "pr_url": "https://github.com/apache/pulsar/pull/8744", "timeline": [{"oid": "baa84b1511b5736d74bf461a510c24f4bcff25a5", "url": "https://github.com/apache/pulsar/commit/baa84b1511b5736d74bf461a510c24f4bcff25a5", "message": "Add tests for the storage classes", "committedDate": "2020-11-30T10:00:20Z", "type": "forcePushed"}, {"oid": "4241932f494e792369c4fdc55e546821a12c5a41", "url": "https://github.com/apache/pulsar/commit/4241932f494e792369c4fdc55e546821a12c5a41", "message": "Init the bookkeeper packages storage module", "committedDate": "2020-12-01T02:14:52Z", "type": "commit"}, {"oid": "06ed857053f2e038dbdfe0ce260c8daf5af02b6e", "url": "https://github.com/apache/pulsar/commit/06ed857053f2e038dbdfe0ce260c8daf5af02b6e", "message": "Add implementation for the storage", "committedDate": "2020-12-01T02:14:55Z", "type": "commit"}, {"oid": "815ffe62383dfdcf7b7744e36bed02e5d7ce38c7", "url": "https://github.com/apache/pulsar/commit/815ffe62383dfdcf7b7744e36bed02e5d7ce38c7", "message": "Add tests for the storage classes", "committedDate": "2020-12-01T02:14:55Z", "type": "commit"}, {"oid": "815ffe62383dfdcf7b7744e36bed02e5d7ce38c7", "url": "https://github.com/apache/pulsar/commit/815ffe62383dfdcf7b7744e36bed02e5d7ce38c7", "message": "Add tests for the storage classes", "committedDate": "2020-12-01T02:14:55Z", "type": "forcePushed"}, {"oid": "b293e754809d0a33cd56b3dea8b12755dcd7f2f5", "url": "https://github.com/apache/pulsar/commit/b293e754809d0a33cd56b3dea8b12755dcd7f2f5", "message": "Fix the checkstyle issue", "committedDate": "2020-12-01T03:04:30Z", "type": "commit"}, {"oid": "96d5514e8e2e206df3c08b8b7cea4b2a98fc8095", "url": "https://github.com/apache/pulsar/commit/96d5514e8e2e206df3c08b8b7cea4b2a98fc8095", "message": "Fix the license issue", "committedDate": "2020-12-01T04:13:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDYyNjgyMA==", "url": "https://github.com/apache/pulsar/pull/8744#discussion_r534626820", "bodyText": "We should also close the DistributedLogManager?", "author": "codelipenghui", "createdAt": "2020-12-03T02:47:11Z", "path": "pulsar-package-management/bookkeeper-storage/src/main/java/org/apache/pulsar/packages/management/storage/bookkeeper/BookKeeperPackagesStorage.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.packages.management.storage.bookkeeper;\n+\n+import com.google.common.base.Strings;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.distributedlog.DistributedLogConfiguration;\n+import org.apache.distributedlog.DistributedLogConstants;\n+import org.apache.distributedlog.api.DistributedLogManager;\n+import org.apache.distributedlog.api.namespace.Namespace;\n+import org.apache.distributedlog.api.namespace.NamespaceBuilder;\n+import org.apache.distributedlog.exceptions.ZKException;\n+import org.apache.distributedlog.impl.metadata.BKDLConfig;\n+import org.apache.distributedlog.metadata.DLMetadata;\n+import org.apache.distributedlog.namespace.NamespaceDriver;\n+import org.apache.pulsar.packages.management.core.PackagesStorage;\n+import org.apache.pulsar.packages.management.core.PackagesStorageConfiguration;\n+import org.apache.zookeeper.KeeperException;\n+\n+\n+/**\n+ * Packages management storage implementation with bookkeeper.\n+ */\n+@Slf4j\n+public class BookKeeperPackagesStorage implements PackagesStorage {\n+\n+    private final static String NS_CLIENT_ID = \"packages-management\";\n+    final BookKeeperPackagesStorageConfiguration configuration;\n+    private Namespace namespace;\n+\n+    BookKeeperPackagesStorage(PackagesStorageConfiguration configuration) {\n+        this.configuration = new BookKeeperPackagesStorageConfiguration(configuration);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        DistributedLogConfiguration conf = new DistributedLogConfiguration()\n+            .setImmediateFlushEnabled(true)\n+            .setOutputBufferSize(0)\n+            .setWriteQuorumSize(configuration.getNumReplicas())\n+            .setEnsembleSize(configuration.getNumReplicas())\n+            .setAckQuorumSize(configuration.getNumReplicas())\n+            .setLockTimeout(DistributedLogConstants.LOCK_IMMEDIATE);\n+        if (!Strings.isNullOrEmpty(configuration.getBookkeeperClientAuthenticationPlugin())) {\n+            conf.setProperty(\"bkc.clientAuthProviderFactoryClass\",\n+                configuration.getBookkeeperClientAuthenticationPlugin());\n+            if (!Strings.isNullOrEmpty(configuration.getBookkeeperClientAuthenticationParametersName())) {\n+                conf.setProperty(\"bkc.\" + configuration.getBookkeeperClientAuthenticationParametersName(),\n+                    configuration.getBookkeeperClientAuthenticationParameters());\n+            }\n+        }\n+        try {\n+            this.namespace = NamespaceBuilder.newBuilder()\n+                .conf(conf).clientId(NS_CLIENT_ID).uri(initializeDlogNamespace()).build();\n+        } catch (IOException e) {\n+            throw new RuntimeException(\"Initialize distributed log for packages management service failed.\", e);\n+        }\n+        log.info(\"Packages management bookKeeper storage initialized successfully\");\n+    }\n+\n+    private URI initializeDlogNamespace() throws IOException {\n+        BKDLConfig bkdlConfig = new BKDLConfig(configuration.getZkServers(), configuration.getLedgersRootPath());\n+        DLMetadata dlMetadata = DLMetadata.create(bkdlConfig);\n+        URI dlogURI = URI.create(String.format(\"distributedlog://%s/pulsar/packages\", configuration.getZkServers()));\n+        try {\n+            dlMetadata.create(dlogURI);\n+        } catch (ZKException e) {\n+            if (e.getKeeperExceptionCode() == KeeperException.Code.NODEEXISTS) {\n+                return dlogURI;\n+            }\n+        }\n+        return dlogURI;\n+    }\n+\n+    private CompletableFuture<DistributedLogManager> openLogManagerAsync(String path) {\n+        CompletableFuture<DistributedLogManager> logFuture = new CompletableFuture<>();\n+        CompletableFuture.runAsync(() -> {\n+            try {\n+                logFuture.complete(namespace.openLog(path));\n+            } catch (IOException e) {\n+                logFuture.completeExceptionally(e);\n+            }\n+        });\n+        return logFuture;\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> writeAsync(String path, InputStream inputStream) {\n+        return openLogManagerAsync(path)\n+            .thenCompose(DLOutputStream::openWriterAsync)\n+            .thenCompose(dlOutputStream -> dlOutputStream.writeAsync(inputStream))\n+            .thenCompose(DLOutputStream::closeAsync);\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> readAsync(String path, OutputStream outputStream) {\n+        return openLogManagerAsync(path)\n+            .thenCompose(DLInputStream::openReaderAsync)\n+            .thenCompose(dlInputStream -> dlInputStream.readAsync(outputStream))\n+            .thenCompose(DLInputStream::closeAsync);\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> deleteAsync(String path) {\n+        return namespace.getNamespaceDriver().getLogMetadataStore().getLogLocation(path)\n+            .thenCompose(uri -> uri.map(value -> namespace.getNamespaceDriver()\n+                .getLogStreamMetadataStore(NamespaceDriver.Role.WRITER).deleteLog(value, path))\n+                .orElse(null));\n+    }\n+\n+\n+    @Override\n+    public CompletableFuture<List<String>> listAsync(String path) {\n+        return namespace.getNamespaceDriver().getLogMetadataStore().getLogs(path)\n+            .thenApply(logs -> {\n+                ArrayList<String> packages = new ArrayList<>();\n+                logs.forEachRemaining(packages::add);\n+                return packages;\n+            });\n+    }\n+\n+    @Override\n+    public CompletableFuture<Boolean> existAsync(String path) {\n+        CompletableFuture<Boolean> result = new CompletableFuture<>();\n+        namespace.getNamespaceDriver().getLogMetadataStore().getLogLocation(path)\n+            .whenComplete((uriOptional, throwable) -> {\n+                if (throwable != null) {\n+                    result.complete(false);\n+                    return;\n+                }\n+\n+                if (uriOptional.isPresent()) {\n+                    namespace.getNamespaceDriver()\n+                        .getLogStreamMetadataStore(NamespaceDriver.Role.WRITER)\n+                        .logExists(uriOptional.get(), path)\n+                        .whenComplete((ignore, e) -> {\n+                            if (e != null) {\n+                                result.complete(false);\n+                            } else {\n+                                result.complete(true);\n+                            }\n+                        });\n+                } else {\n+                    result.complete(false);\n+                }\n+            });\n+        return result;    }\n+\n+    @Override\n+    public CompletableFuture<Void> closeAsync() {\n+        return CompletableFuture.runAsync(() -> this.namespace.close());", "originalCommit": "96d5514e8e2e206df3c08b8b7cea4b2a98fc8095", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDYyOTUwNQ==", "url": "https://github.com/apache/pulsar/pull/8744#discussion_r534629505", "bodyText": "It closed at here https://github.com/apache/pulsar/pull/8744/files#diff-eb374311109d385162c647fec67fb23820f28aa8fc11c58dbdff2c859a51639dR118", "author": "zymap", "createdAt": "2020-12-03T02:54:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDYyNjgyMA=="}], "type": "inlineReview"}]}