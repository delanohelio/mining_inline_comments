{"pr_number": 8685, "pr_title": "PIP 68: Exclusive Producer", "pr_createdAt": "2020-11-24T15:59:45Z", "pr_url": "https://github.com/apache/pulsar/pull/8685", "timeline": [{"oid": "e6f7c8eaf00b53ea8a610c13c8d513233fbc3c1f", "url": "https://github.com/apache/pulsar/commit/e6f7c8eaf00b53ea8a610c13c8d513233fbc3c1f", "message": "PIP 68: Exclusive Producer", "committedDate": "2020-11-24T16:16:50Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE2NTU2Mw==", "url": "https://github.com/apache/pulsar/pull/8685#discussion_r530165563", "bodyText": "can we add debug log here with epoch.", "author": "rdhabalia", "createdAt": "2020-11-25T07:49:03Z", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/AbstractTopic.java", "diffHunk": "@@ -317,6 +332,94 @@ public String getReplicatorPrefix() {\n                 .checkConsumerCompatibility(id, schema, schemaCompatibilityStrategy);\n     }\n \n+    @Override\n+    public CompletableFuture<Optional<Long>> addProducer(Producer producer) {\n+        checkArgument(producer.getTopic() == this);\n+\n+        CompletableFuture<Optional<Long>> future = new CompletableFuture<>();\n+\n+        incrementTopicEpochIfNeeded(producer)\n+                .thenAccept(epoch -> {\n+                    lock.readLock().lock();\n+                    try {\n+                        brokerService.checkTopicNsOwnership(getName());\n+                        checkTopicFenced();\n+                        if (isTerminated()) {\n+                            log.warn(\"[{}] Attempting to add producer to a terminated topic\", topic);\n+                            throw new TopicTerminatedException(\"Topic was already terminated\");\n+                        }\n+                        internalAddProducer(producer);\n+\n+                        USAGE_COUNT_UPDATER.incrementAndGet(this);\n+                        if (log.isDebugEnabled()) {\n+                            log.debug(\"[{}] [{}] Added producer -- count: {}\", topic, producer.getProducerName(),\n+                                    USAGE_COUNT_UPDATER.get(this));\n+                        }\n+\n+                        future.complete(epoch);\n+                    } catch (Throwable e) {\n+                        future.completeExceptionally(e);\n+                    } finally {\n+                        lock.readLock().unlock();\n+                    }\n+                }).exceptionally(ex -> {\n+                    future.completeExceptionally(ex);\n+                    return null;\n+                });\n+\n+        return future;\n+    }\n+\n+    protected CompletableFuture<Optional<Long>> incrementTopicEpochIfNeeded(Producer producer) {\n+        lock.writeLock().lock();\n+        try {\n+            switch (producer.getAccessMode()) {\n+            case Shared:\n+                if (hasExclusiveProducer) {\n+                   return FutureUtil.failedFuture(new ProducerBusyException(\"Topic has an existing exclusive producer\"));\n+                } else {\n+                    // Normal producer getting added, we don't need a new epoch\n+                    return CompletableFuture.completedFuture(topicEpoch);\n+                }\n+\n+            case Exclusive:\n+                 if (hasExclusiveProducer || !producers.isEmpty()) {\n+                    return FutureUtil.failedFuture(new ProducerFencedException(\"Topic has existing producers\"));\n+                 } else if (producer.getTopicEpoch().isPresent() && producer.getTopicEpoch().get() < topicEpoch.orElse(-1L)){\n+                     // If a producer reconnects, but all the topic epoch has already moved forward, this producer needs to\n+                     // be fenced, because a new producer had been present in between.\n+                     return FutureUtil.failedFuture(new ProducerFencedException(\"Topic epoch has already moved\"));", "originalCommit": "6ef1fc1e3da5bd5a8707acfec1e184968814274f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUxODY3Nw==", "url": "https://github.com/apache/pulsar/pull/8685#discussion_r530518677", "bodyText": "Sure", "author": "merlimat", "createdAt": "2020-11-25T16:55:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE2NTU2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE2ODI1MQ==", "url": "https://github.com/apache/pulsar/pull/8685#discussion_r530168251", "bodyText": "can we avoid locking for normal producer usecase?\nif (producers.isEmpty() && producer.getAccessMode() == Shared) {\nreturn CompletableFuture.completedFuture(topicEpoch);\n}", "author": "rdhabalia", "createdAt": "2020-11-25T07:54:17Z", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/AbstractTopic.java", "diffHunk": "@@ -317,6 +332,94 @@ public String getReplicatorPrefix() {\n                 .checkConsumerCompatibility(id, schema, schemaCompatibilityStrategy);\n     }\n \n+    @Override\n+    public CompletableFuture<Optional<Long>> addProducer(Producer producer) {\n+        checkArgument(producer.getTopic() == this);\n+\n+        CompletableFuture<Optional<Long>> future = new CompletableFuture<>();\n+\n+        incrementTopicEpochIfNeeded(producer)\n+                .thenAccept(epoch -> {\n+                    lock.readLock().lock();\n+                    try {\n+                        brokerService.checkTopicNsOwnership(getName());\n+                        checkTopicFenced();\n+                        if (isTerminated()) {\n+                            log.warn(\"[{}] Attempting to add producer to a terminated topic\", topic);\n+                            throw new TopicTerminatedException(\"Topic was already terminated\");\n+                        }\n+                        internalAddProducer(producer);\n+\n+                        USAGE_COUNT_UPDATER.incrementAndGet(this);\n+                        if (log.isDebugEnabled()) {\n+                            log.debug(\"[{}] [{}] Added producer -- count: {}\", topic, producer.getProducerName(),\n+                                    USAGE_COUNT_UPDATER.get(this));\n+                        }\n+\n+                        future.complete(epoch);\n+                    } catch (Throwable e) {\n+                        future.completeExceptionally(e);\n+                    } finally {\n+                        lock.readLock().unlock();\n+                    }\n+                }).exceptionally(ex -> {\n+                    future.completeExceptionally(ex);\n+                    return null;\n+                });\n+\n+        return future;\n+    }\n+\n+    protected CompletableFuture<Optional<Long>> incrementTopicEpochIfNeeded(Producer producer) {\n+        lock.writeLock().lock();", "originalCommit": "6ef1fc1e3da5bd5a8707acfec1e184968814274f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE3NTE2Mw==", "url": "https://github.com/apache/pulsar/pull/8685#discussion_r530175163", "bodyText": "+1 to @rdhabalia suggestion", "author": "eolivelli", "createdAt": "2020-11-25T08:07:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE2ODI1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUyMDMyMw==", "url": "https://github.com/apache/pulsar/pull/8685#discussion_r530520323", "bodyText": "I'm not sure that we can avoid the locking, and I'm not sure that it's something to worry about in the context of adding a producer.\nActually, in the specific case there's still a race condition between updating the producers map, since the update to hasExclusiveProducer and the insertion into producers map should be atomic as well.", "author": "merlimat", "createdAt": "2020-11-25T16:57:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE2ODI1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE2OTEwNw==", "url": "https://github.com/apache/pulsar/pull/8685#discussion_r530169107", "bodyText": "is it possible to add producer-type if topic-stats if producer is exclusive for information and debugging.", "author": "rdhabalia", "createdAt": "2020-11-25T07:56:04Z", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/AbstractTopic.java", "diffHunk": "@@ -317,6 +332,94 @@ public String getReplicatorPrefix() {\n                 .checkConsumerCompatibility(id, schema, schemaCompatibilityStrategy);\n     }\n \n+    @Override\n+    public CompletableFuture<Optional<Long>> addProducer(Producer producer) {\n+        checkArgument(producer.getTopic() == this);\n+\n+        CompletableFuture<Optional<Long>> future = new CompletableFuture<>();\n+\n+        incrementTopicEpochIfNeeded(producer)\n+                .thenAccept(epoch -> {\n+                    lock.readLock().lock();\n+                    try {\n+                        brokerService.checkTopicNsOwnership(getName());\n+                        checkTopicFenced();\n+                        if (isTerminated()) {\n+                            log.warn(\"[{}] Attempting to add producer to a terminated topic\", topic);\n+                            throw new TopicTerminatedException(\"Topic was already terminated\");\n+                        }\n+                        internalAddProducer(producer);", "originalCommit": "6ef1fc1e3da5bd5a8707acfec1e184968814274f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUyMDQzNQ==", "url": "https://github.com/apache/pulsar/pull/8685#discussion_r530520435", "bodyText": "Sure", "author": "merlimat", "createdAt": "2020-11-25T16:58:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE2OTEwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE3MTAwNQ==", "url": "https://github.com/apache/pulsar/pull/8685#discussion_r530171005", "bodyText": "I have one suggestion. I am sure you must have thought about it but can't we rename WaitForExclusive with FailOver as it will be consistent to subscription type name and it will need no explanation and easy to understand.", "author": "rdhabalia", "createdAt": "2020-11-25T07:59:50Z", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/AbstractTopic.java", "diffHunk": "@@ -317,6 +332,94 @@ public String getReplicatorPrefix() {\n                 .checkConsumerCompatibility(id, schema, schemaCompatibilityStrategy);\n     }\n \n+    @Override\n+    public CompletableFuture<Optional<Long>> addProducer(Producer producer) {\n+        checkArgument(producer.getTopic() == this);\n+\n+        CompletableFuture<Optional<Long>> future = new CompletableFuture<>();\n+\n+        incrementTopicEpochIfNeeded(producer)\n+                .thenAccept(epoch -> {\n+                    lock.readLock().lock();\n+                    try {\n+                        brokerService.checkTopicNsOwnership(getName());\n+                        checkTopicFenced();\n+                        if (isTerminated()) {\n+                            log.warn(\"[{}] Attempting to add producer to a terminated topic\", topic);\n+                            throw new TopicTerminatedException(\"Topic was already terminated\");\n+                        }\n+                        internalAddProducer(producer);\n+\n+                        USAGE_COUNT_UPDATER.incrementAndGet(this);\n+                        if (log.isDebugEnabled()) {\n+                            log.debug(\"[{}] [{}] Added producer -- count: {}\", topic, producer.getProducerName(),\n+                                    USAGE_COUNT_UPDATER.get(this));\n+                        }\n+\n+                        future.complete(epoch);\n+                    } catch (Throwable e) {\n+                        future.completeExceptionally(e);\n+                    } finally {\n+                        lock.readLock().unlock();\n+                    }\n+                }).exceptionally(ex -> {\n+                    future.completeExceptionally(ex);\n+                    return null;\n+                });\n+\n+        return future;\n+    }\n+\n+    protected CompletableFuture<Optional<Long>> incrementTopicEpochIfNeeded(Producer producer) {\n+        lock.writeLock().lock();\n+        try {\n+            switch (producer.getAccessMode()) {\n+            case Shared:\n+                if (hasExclusiveProducer) {\n+                   return FutureUtil.failedFuture(new ProducerBusyException(\"Topic has an existing exclusive producer\"));\n+                } else {\n+                    // Normal producer getting added, we don't need a new epoch\n+                    return CompletableFuture.completedFuture(topicEpoch);\n+                }\n+\n+            case Exclusive:\n+                 if (hasExclusiveProducer || !producers.isEmpty()) {\n+                    return FutureUtil.failedFuture(new ProducerFencedException(\"Topic has existing producers\"));\n+                 } else if (producer.getTopicEpoch().isPresent() && producer.getTopicEpoch().get() < topicEpoch.orElse(-1L)){\n+                     // If a producer reconnects, but all the topic epoch has already moved forward, this producer needs to\n+                     // be fenced, because a new producer had been present in between.\n+                     return FutureUtil.failedFuture(new ProducerFencedException(\"Topic epoch has already moved\"));\n+                } else {\n+                    // There are currently no existing producers\n+                    hasExclusiveProducer = true;\n+\n+                    CompletableFuture<Optional<Long>> future = incrementTopicEpoch(topicEpoch).thenApply(epoch -> {\n+                        topicEpoch = Optional.of(epoch);\n+                        return topicEpoch;\n+                    });\n+\n+                    future.exceptionally(ex -> {\n+                        hasExclusiveProducer = false;\n+                        return null;\n+                    });\n+                    return future;\n+                }\n+\n+           // case WaitForExclusive:", "originalCommit": "6ef1fc1e3da5bd5a8707acfec1e184968814274f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUyMzIzMg==", "url": "https://github.com/apache/pulsar/pull/8685#discussion_r530523232", "bodyText": "The problem I see is that it's not exactly the same thing and that can confuse people:\n\nThe semantic of creating a WaitForExclusive is different because the newProducer()....create() call is hanging until that particular producer is selected, unlike in consumers where it's created immediately but it will not receive messages.\nThe use case is mostly different from \"failover\" for reliability purpose, since you can use WaitForExclusive to do leader election", "author": "merlimat", "createdAt": "2020-11-25T17:02:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE3MTAwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE3MjM0OQ==", "url": "https://github.com/apache/pulsar/pull/8685#discussion_r530172349", "bodyText": "shouldn't we need lock here else it may create a race condition and  producer with WaitForExclusive  may wait forever.", "author": "rdhabalia", "createdAt": "2020-11-25T08:02:26Z", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/AbstractTopic.java", "diffHunk": "@@ -451,7 +554,44 @@ private boolean isUserProvidedProducerName(Producer producer){\n         return producer.isUserProvidedProducerName() && !producer.getProducerName().startsWith(replicatorPrefix);\n     }\n \n-    protected abstract void handleProducerRemoved(Producer producer);\n+\n+    @Override\n+    public void removeProducer(Producer producer) {\n+        checkArgument(producer.getTopic() == this);\n+\n+        if (producers.remove(producer.getProducerName(), producer)) {\n+            handleProducerRemoved(producer);", "originalCommit": "6ef1fc1e3da5bd5a8707acfec1e184968814274f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUyNDU0MQ==", "url": "https://github.com/apache/pulsar/pull/8685#discussion_r530524541", "bodyText": "No lock needed there so far. Other changes are needed for WaitForExclusive, it's not implemented in this PR", "author": "merlimat", "createdAt": "2020-11-25T17:04:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE3MjM0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE3NTUxMQ==", "url": "https://github.com/apache/pulsar/pull/8685#discussion_r530175511", "bodyText": "is it possibile to log and/or to report in the exception who is the current exclusive producer ?", "author": "eolivelli", "createdAt": "2020-11-25T08:08:39Z", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/AbstractTopic.java", "diffHunk": "@@ -317,6 +332,94 @@ public String getReplicatorPrefix() {\n                 .checkConsumerCompatibility(id, schema, schemaCompatibilityStrategy);\n     }\n \n+    @Override\n+    public CompletableFuture<Optional<Long>> addProducer(Producer producer) {\n+        checkArgument(producer.getTopic() == this);\n+\n+        CompletableFuture<Optional<Long>> future = new CompletableFuture<>();\n+\n+        incrementTopicEpochIfNeeded(producer)\n+                .thenAccept(epoch -> {\n+                    lock.readLock().lock();\n+                    try {\n+                        brokerService.checkTopicNsOwnership(getName());\n+                        checkTopicFenced();\n+                        if (isTerminated()) {\n+                            log.warn(\"[{}] Attempting to add producer to a terminated topic\", topic);\n+                            throw new TopicTerminatedException(\"Topic was already terminated\");\n+                        }\n+                        internalAddProducer(producer);\n+\n+                        USAGE_COUNT_UPDATER.incrementAndGet(this);\n+                        if (log.isDebugEnabled()) {\n+                            log.debug(\"[{}] [{}] Added producer -- count: {}\", topic, producer.getProducerName(),\n+                                    USAGE_COUNT_UPDATER.get(this));\n+                        }\n+\n+                        future.complete(epoch);\n+                    } catch (Throwable e) {\n+                        future.completeExceptionally(e);\n+                    } finally {\n+                        lock.readLock().unlock();\n+                    }\n+                }).exceptionally(ex -> {\n+                    future.completeExceptionally(ex);\n+                    return null;\n+                });\n+\n+        return future;\n+    }\n+\n+    protected CompletableFuture<Optional<Long>> incrementTopicEpochIfNeeded(Producer producer) {\n+        lock.writeLock().lock();\n+        try {\n+            switch (producer.getAccessMode()) {\n+            case Shared:\n+                if (hasExclusiveProducer) {\n+                   return FutureUtil.failedFuture(new ProducerBusyException(\"Topic has an existing exclusive producer\"));", "originalCommit": "6ef1fc1e3da5bd5a8707acfec1e184968814274f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE3OTU5Ng==", "url": "https://github.com/apache/pulsar/pull/8685#discussion_r530179596", "bodyText": "nit: please move constants on top of the classs", "author": "eolivelli", "createdAt": "2020-11-25T08:16:16Z", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/persistent/PersistentTopic.java", "diffHunk": "@@ -460,33 +460,37 @@ public synchronized void addFailed(ManagedLedgerException exception, Object ctx)\n     }\n \n     @Override\n-    public void addProducer(Producer producer) throws BrokerServiceException {\n-        checkArgument(producer.getTopic() == this);\n+    public CompletableFuture<Optional<Long>> addProducer(Producer producer) {\n+        return super.addProducer(producer).thenApply(epoch -> {\n+            messageDeduplication.producerAdded(producer.getProducerName());\n \n-        lock.readLock().lock();\n-        try {\n-            brokerService.checkTopicNsOwnership(getName());\n+            // Start replication producers if not already\n+            startReplProducers();\n+            return epoch;\n+        });\n+    }\n \n-            checkTopicFenced();\n+    private static final String TOPIC_EPOCH_PROPERTY_NAME = \"pulsar.topic.epoch\";", "originalCommit": "6ef1fc1e3da5bd5a8707acfec1e184968814274f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c2d57bcc10bebcc91587d23496b57a0d54efa6be", "url": "https://github.com/apache/pulsar/commit/c2d57bcc10bebcc91587d23496b57a0d54efa6be", "message": "Addressed comments", "committedDate": "2020-12-01T18:53:05Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzkxNDc1NA==", "url": "https://github.com/apache/pulsar/pull/8685#discussion_r533914754", "bodyText": "What about setting a fixed seed? In order to have reproducible tests execution.", "author": "eolivelli", "createdAt": "2020-12-02T05:56:34Z", "path": "pulsar-broker/src/test/java/org/apache/pulsar/broker/service/BrokerTestBase.java", "diffHunk": "@@ -86,5 +88,11 @@ void runMessageExpiryCheck() {\n         }\n     }\n \n+    private static final Random random = new Random();", "originalCommit": "5254a9f38a2c296b249812dca5abc94acb80c87a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzkyNTE0NA==", "url": "https://github.com/apache/pulsar/pull/8685#discussion_r533925144", "bodyText": "This is just to get random topic names. We don't really need it to be reproducible.", "author": "merlimat", "createdAt": "2020-12-02T06:27:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzkxNDc1NA=="}], "type": "inlineReview"}, {"oid": "a60156f6d31cd5ed62f41c9ab08fe049af8c3f13", "url": "https://github.com/apache/pulsar/commit/a60156f6d31cd5ed62f41c9ab08fe049af8c3f13", "message": "PIP 68: Exclusive Producer", "committedDate": "2020-12-02T23:42:22Z", "type": "commit"}, {"oid": "3524cc00f57002a6f272d5e4f1560689f59405f9", "url": "https://github.com/apache/pulsar/commit/3524cc00f57002a6f272d5e4f1560689f59405f9", "message": "Added missing enums cases in C++", "committedDate": "2020-12-02T23:42:22Z", "type": "commit"}, {"oid": "1f86250bdc81a8174f34718f1b3b6e02ccaf836e", "url": "https://github.com/apache/pulsar/commit/1f86250bdc81a8174f34718f1b3b6e02ccaf836e", "message": "Addressed comments", "committedDate": "2020-12-02T23:42:22Z", "type": "commit"}, {"oid": "69a0a8f91e6624b8f5809c448295b26fa586eb1b", "url": "https://github.com/apache/pulsar/commit/69a0a8f91e6624b8f5809c448295b26fa586eb1b", "message": "Moved constant to top of file", "committedDate": "2020-12-02T23:42:22Z", "type": "commit"}, {"oid": "9c0dda252e4afa5ad541728ddbe93f641f4fa282", "url": "https://github.com/apache/pulsar/commit/9c0dda252e4afa5ad541728ddbe93f641f4fa282", "message": "Fix mistake in previous update", "committedDate": "2020-12-02T23:42:22Z", "type": "commit"}, {"oid": "eba7bbe04d50dd09a111eae521aa32e970262d6d", "url": "https://github.com/apache/pulsar/commit/eba7bbe04d50dd09a111eae521aa32e970262d6d", "message": "Added handling for topic deletion", "committedDate": "2020-12-02T23:42:22Z", "type": "commit"}, {"oid": "eba7bbe04d50dd09a111eae521aa32e970262d6d", "url": "https://github.com/apache/pulsar/commit/eba7bbe04d50dd09a111eae521aa32e970262d6d", "message": "Added handling for topic deletion", "committedDate": "2020-12-02T23:42:22Z", "type": "forcePushed"}]}