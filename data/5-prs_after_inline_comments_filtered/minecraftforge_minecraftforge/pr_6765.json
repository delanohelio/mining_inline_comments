{"pr_number": 6765, "pr_title": "[1.15.x] DataGenerator for LootTable, replacing shears item to shears tag", "pr_createdAt": "2020-06-12T07:45:08Z", "pr_url": "https://github.com/MinecraftForge/MinecraftForge/pull/6765", "timeline": [{"oid": "ec26e4c65d477759dfbe978785c0c9b68c426472", "url": "https://github.com/MinecraftForge/MinecraftForge/commit/ec26e4c65d477759dfbe978785c0c9b68c426472", "message": "DataGenerator for LootTable, replacing shears item to shears tag", "committedDate": "2020-06-12T07:38:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI3NDU2MQ==", "url": "https://github.com/MinecraftForge/MinecraftForge/pull/6765#discussion_r439274561", "bodyText": "Using access transformers might be better here, but involves removing final keyword", "author": "percivalalb", "createdAt": "2020-06-12T08:14:25Z", "path": "src/main/java/net/minecraftforge/common/data/ForgeLootTableProvider.java", "diffHunk": "@@ -0,0 +1,178 @@\n+package net.minecraftforge.common.data;\n+\n+import com.mojang.datafixers.util.Pair;\n+import net.minecraft.advancements.criterion.ItemPredicate;\n+import net.minecraft.data.DataGenerator;\n+import net.minecraft.data.LootTableProvider;\n+import net.minecraft.item.Item;\n+import net.minecraft.item.Items;\n+import net.minecraft.tags.Tag;\n+import net.minecraft.util.ResourceLocation;\n+import net.minecraft.world.storage.loot.*;\n+import net.minecraft.world.storage.loot.conditions.Alternative;\n+import net.minecraft.world.storage.loot.conditions.ILootCondition;\n+import net.minecraft.world.storage.loot.conditions.Inverted;\n+import net.minecraft.world.storage.loot.conditions.MatchTool;\n+import net.minecraftforge.common.Tags;\n+\n+import java.lang.reflect.Field;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.BiConsumer;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+public class ForgeLootTableProvider extends LootTableProvider {\n+\n+    public ForgeLootTableProvider(DataGenerator gen) {\n+        super(gen);\n+    }\n+\n+    @Override\n+    protected void validate(Map<ResourceLocation, LootTable> map, ValidationTracker validationtracker) {\n+        // do not validate against all registered loot tables\n+    }\n+\n+    @Override\n+    protected List<Pair<Supplier<Consumer<BiConsumer<ResourceLocation, LootTable.Builder>>>, LootParameterSet>> getTables() {\n+        return super.getTables().stream().map(pair -> {\n+            // provides new consumer with filtering only changed loot tables and replacing condition item to condition tag\n+            return new Pair<Supplier<Consumer<BiConsumer<ResourceLocation, LootTable.Builder>>>, LootParameterSet>(() -> replaceAndFilterChangesOnly(pair.getFirst().get()), pair.getSecond());\n+        }).collect(Collectors.toList());\n+    }\n+\n+    private Consumer<BiConsumer<ResourceLocation, LootTable.Builder>> replaceAndFilterChangesOnly(Consumer<BiConsumer<ResourceLocation, LootTable.Builder>> consumer) {\n+        return (newConsumer) -> consumer.accept((resourceLocation, builder) -> {\n+            if (findAndReplaceInLootTableBuilder(builder, Items.SHEARS, Tags.Items.SHEARS)) {\n+                newConsumer.accept(resourceLocation, builder);\n+            }\n+        });\n+    }\n+\n+    private boolean findAndReplaceInLootTableBuilder(LootTable.Builder builder, Item from, Tag<Item> to) {\n+        List<LootPool> lootPools = getField(LootTable.Builder.class, builder, 0);\n+        boolean found = false;\n+\n+        for (LootPool lootPool : lootPools) {\n+            if (findAndReplaceInLootPool(lootPool, from, to)) {\n+                found = true;\n+            }\n+        }\n+\n+        return found;\n+    }\n+\n+    private boolean findAndReplaceInLootPool(LootPool lootPool, Item from, Tag<Item> to) {\n+        List<LootEntry> lootEntries = getField(LootPool.class, lootPool, 1);\n+        List<ILootCondition> lootConditions = getField(LootPool.class, lootPool, 2);\n+        boolean found = false;\n+\n+        for (LootEntry lootEntry : lootEntries) {\n+            if (lootEntry instanceof ParentedLootEntry) {\n+                if (findAndReplaceInParentedLootEntry((ParentedLootEntry) lootEntry, from, to)) {\n+                    found = true;\n+                }\n+            }\n+        }\n+\n+        for (int i = 0; i < lootConditions.size(); i++) {\n+            ILootCondition lootCondition = lootConditions.get(i);\n+            if (lootCondition instanceof MatchTool && checkMatchTool((MatchTool) lootCondition, from)) {\n+                lootConditions.set(i, MatchTool.builder(ItemPredicate.Builder.create().tag(to)).build());\n+                found = true;\n+            } else if (lootCondition instanceof Inverted && findAndReplaceInInverted((Inverted) lootCondition, from, to)) {\n+                found = true;\n+            }\n+        }\n+\n+        return found;\n+    }\n+\n+    private boolean findAndReplaceInParentedLootEntry(ParentedLootEntry entry, Item from, Tag<Item> to) {\n+        LootEntry[] lootEntries = getField(ParentedLootEntry.class, entry, 0);\n+        boolean found = false;\n+\n+        for (LootEntry lootEntry : lootEntries) {\n+            if (findAndReplaceInLootEntry(lootEntry, from, to)) {\n+                found = true;\n+            }\n+        }\n+\n+        return found;\n+    }\n+\n+    private boolean findAndReplaceInLootEntry(LootEntry entry, Item from, Tag<Item> to) {\n+        ILootCondition[] lootConditions = getField(LootEntry.class, entry, 0);\n+        boolean found = false;\n+\n+        for (int i = 0; i < lootConditions.length; i++) {\n+            if (lootConditions[i] instanceof Alternative && findAndReplaceInAlternative((Alternative) lootConditions[i], from, to)) {\n+                found = true;\n+            } else if (lootConditions[i] instanceof MatchTool && checkMatchTool((MatchTool) lootConditions[i], from)) {\n+                lootConditions[i] = MatchTool.builder(ItemPredicate.Builder.create().tag(to)).build();\n+                found = true;\n+            }\n+        }\n+\n+        return found;\n+    }\n+\n+    private boolean findAndReplaceInAlternative(Alternative alternative, Item from, Tag<Item> to) {\n+        ILootCondition[] lootConditions = getField(Alternative.class, alternative, 0);\n+        boolean found = false;\n+\n+        for (int i = 0; i < lootConditions.length; i++) {\n+            if (lootConditions[i] instanceof MatchTool && checkMatchTool((MatchTool) lootConditions[i], from)) {\n+                lootConditions[i] = MatchTool.builder(ItemPredicate.Builder.create().tag(to)).build();\n+                found = true;\n+            }\n+        }\n+\n+        return found;\n+    }\n+\n+    private boolean findAndReplaceInInverted(Inverted inverted, Item from, Tag<Item> to) {\n+        ILootCondition lootCondition = getField(Inverted.class, inverted, 0);\n+\n+        if (lootCondition instanceof MatchTool && checkMatchTool((MatchTool) lootCondition, from)) {\n+            setField(Inverted.class, inverted, 0, MatchTool.builder(ItemPredicate.Builder.create().tag(to)).build());\n+            return true;\n+        } else if (lootCondition instanceof Alternative && findAndReplaceInAlternative((Alternative) lootCondition, from, to)) {\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    private boolean checkMatchTool(MatchTool lootCondition, Item expected) {\n+        ItemPredicate predicate = getField(MatchTool.class, lootCondition, 0);\n+        Item item = getField(ItemPredicate.class, predicate, 4);\n+        return item != null && item.equals(expected);\n+    }\n+\n+    private <T, R> void setField(Class<T> clz, T inst, int index, R value) {", "originalCommit": "ec26e4c65d477759dfbe978785c0c9b68c426472", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTM2ODgzMQ==", "url": "https://github.com/MinecraftForge/MinecraftForge/pull/6765#discussion_r439368831", "bodyText": "I dont think it will be better, if that changes will be visible for modders", "author": "yanny7", "createdAt": "2020-06-12T11:40:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI3NDU2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4OTUwMw==", "url": "https://github.com/MinecraftForge/MinecraftForge/pull/6765#discussion_r439689503", "bodyText": "probably better to add a getter, and then replace the whole Inverted instance instead of just the term inside.", "author": "LexManos", "createdAt": "2020-06-13T00:34:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI3NDU2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTczMDE1NA==", "url": "https://github.com/MinecraftForge/MinecraftForge/pull/6765#discussion_r439730154", "bodyText": "Removed setField method as proposed", "author": "yanny7", "createdAt": "2020-06-13T10:57:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI3NDU2MQ=="}], "type": "inlineReview"}, {"oid": "d7a36b87bddf17d24c1876590a125f8f6b64a1f4", "url": "https://github.com/MinecraftForge/MinecraftForge/commit/d7a36b87bddf17d24c1876590a125f8f6b64a1f4", "message": "Removed setField", "committedDate": "2020-06-13T10:54:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDAxNjY1Mw==", "url": "https://github.com/MinecraftForge/MinecraftForge/pull/6765#discussion_r440016653", "bodyText": "Depending on field order doesn't feel very safe, is there a reason this is used over ObfuscationReflectionHelper or a simple Access Transformer?", "author": "ichttt", "createdAt": "2020-06-15T08:37:32Z", "path": "src/main/java/net/minecraftforge/common/data/ForgeLootTableProvider.java", "diffHunk": "@@ -0,0 +1,162 @@\n+package net.minecraftforge.common.data;\n+\n+import com.mojang.datafixers.util.Pair;\n+import net.minecraft.advancements.criterion.ItemPredicate;\n+import net.minecraft.data.DataGenerator;\n+import net.minecraft.data.LootTableProvider;\n+import net.minecraft.item.Item;\n+import net.minecraft.item.Items;\n+import net.minecraft.tags.Tag;\n+import net.minecraft.util.ResourceLocation;\n+import net.minecraft.world.storage.loot.*;\n+import net.minecraft.world.storage.loot.conditions.Alternative;\n+import net.minecraft.world.storage.loot.conditions.ILootCondition;\n+import net.minecraft.world.storage.loot.conditions.Inverted;\n+import net.minecraft.world.storage.loot.conditions.MatchTool;\n+import net.minecraftforge.common.Tags;\n+\n+import java.lang.reflect.Field;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.BiConsumer;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+public class ForgeLootTableProvider extends LootTableProvider {\n+\n+    public ForgeLootTableProvider(DataGenerator gen) {\n+        super(gen);\n+    }\n+\n+    @Override\n+    protected void validate(Map<ResourceLocation, LootTable> map, ValidationTracker validationtracker) {\n+        // do not validate against all registered loot tables\n+    }\n+\n+    @Override\n+    protected List<Pair<Supplier<Consumer<BiConsumer<ResourceLocation, LootTable.Builder>>>, LootParameterSet>> getTables() {\n+        return super.getTables().stream().map(pair -> {\n+            // provides new consumer with filtering only changed loot tables and replacing condition item to condition tag\n+            return new Pair<Supplier<Consumer<BiConsumer<ResourceLocation, LootTable.Builder>>>, LootParameterSet>(() -> replaceAndFilterChangesOnly(pair.getFirst().get()), pair.getSecond());\n+        }).collect(Collectors.toList());\n+    }\n+\n+    private Consumer<BiConsumer<ResourceLocation, LootTable.Builder>> replaceAndFilterChangesOnly(Consumer<BiConsumer<ResourceLocation, LootTable.Builder>> consumer) {\n+        return (newConsumer) -> consumer.accept((resourceLocation, builder) -> {\n+            if (findAndReplaceInLootTableBuilder(builder, Items.SHEARS, Tags.Items.SHEARS)) {\n+                newConsumer.accept(resourceLocation, builder);\n+            }\n+        });\n+    }\n+\n+    private boolean findAndReplaceInLootTableBuilder(LootTable.Builder builder, Item from, Tag<Item> to) {\n+        List<LootPool> lootPools = getField(LootTable.Builder.class, builder, 0);\n+        boolean found = false;\n+\n+        for (LootPool lootPool : lootPools) {\n+            if (findAndReplaceInLootPool(lootPool, from, to)) {\n+                found = true;\n+            }\n+        }\n+\n+        return found;\n+    }\n+\n+    private boolean findAndReplaceInLootPool(LootPool lootPool, Item from, Tag<Item> to) {\n+        List<LootEntry> lootEntries = getField(LootPool.class, lootPool, 1);\n+        List<ILootCondition> lootConditions = getField(LootPool.class, lootPool, 2);\n+        boolean found = false;\n+\n+        for (LootEntry lootEntry : lootEntries) {\n+            if (lootEntry instanceof ParentedLootEntry) {\n+                if (findAndReplaceInParentedLootEntry((ParentedLootEntry) lootEntry, from, to)) {\n+                    found = true;\n+                }\n+            }\n+        }\n+\n+        for (int i = 0; i < lootConditions.size(); i++) {\n+            ILootCondition lootCondition = lootConditions.get(i);\n+            if (lootCondition instanceof MatchTool && checkMatchTool((MatchTool) lootCondition, from)) {\n+                lootConditions.set(i, MatchTool.builder(ItemPredicate.Builder.create().tag(to)).build());\n+                found = true;\n+            } else if (lootCondition instanceof Inverted) {\n+                ILootCondition invLootCondition = getField(Inverted.class, (Inverted) lootCondition, 0);\n+\n+                if (invLootCondition instanceof MatchTool && checkMatchTool((MatchTool) invLootCondition, from)) {\n+                    lootConditions.set(i, Inverted.builder(MatchTool.builder(ItemPredicate.Builder.create().tag(to))).build());\n+                    found = true;\n+                } else if (invLootCondition instanceof Alternative && findAndReplaceInAlternative((Alternative) invLootCondition, from, to)) {\n+                    found = true;\n+                }\n+            }\n+        }\n+\n+        return found;\n+    }\n+\n+    private boolean findAndReplaceInParentedLootEntry(ParentedLootEntry entry, Item from, Tag<Item> to) {\n+        LootEntry[] lootEntries = getField(ParentedLootEntry.class, entry, 0);\n+        boolean found = false;\n+\n+        for (LootEntry lootEntry : lootEntries) {\n+            if (findAndReplaceInLootEntry(lootEntry, from, to)) {\n+                found = true;\n+            }\n+        }\n+\n+        return found;\n+    }\n+\n+    private boolean findAndReplaceInLootEntry(LootEntry entry, Item from, Tag<Item> to) {\n+        ILootCondition[] lootConditions = getField(LootEntry.class, entry, 0);\n+        boolean found = false;\n+\n+        for (int i = 0; i < lootConditions.length; i++) {\n+            if (lootConditions[i] instanceof Alternative && findAndReplaceInAlternative((Alternative) lootConditions[i], from, to)) {\n+                found = true;\n+            } else if (lootConditions[i] instanceof MatchTool && checkMatchTool((MatchTool) lootConditions[i], from)) {\n+                lootConditions[i] = MatchTool.builder(ItemPredicate.Builder.create().tag(to)).build();\n+                found = true;\n+            }\n+        }\n+\n+        return found;\n+    }\n+\n+    private boolean findAndReplaceInAlternative(Alternative alternative, Item from, Tag<Item> to) {\n+        ILootCondition[] lootConditions = getField(Alternative.class, alternative, 0);\n+        boolean found = false;\n+\n+        for (int i = 0; i < lootConditions.length; i++) {\n+            if (lootConditions[i] instanceof MatchTool && checkMatchTool((MatchTool) lootConditions[i], from)) {\n+                lootConditions[i] = MatchTool.builder(ItemPredicate.Builder.create().tag(to)).build();\n+                found = true;\n+            }\n+        }\n+\n+        return found;\n+    }\n+\n+    private boolean checkMatchTool(MatchTool lootCondition, Item expected) {\n+        ItemPredicate predicate = getField(MatchTool.class, lootCondition, 0);\n+        Item item = getField(ItemPredicate.class, predicate, 4);\n+        return item != null && item.equals(expected);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private <T, R> R getField(Class<T> clz, T inst, int index)", "originalCommit": "d7a36b87bddf17d24c1876590a125f8f6b64a1f4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA0MTI1MA==", "url": "https://github.com/MinecraftForge/MinecraftForge/pull/6765#discussion_r440041250", "bodyText": "That's also what's happening in ForgeRecipeProvider, where obtaining the list or map of ingredients relies on the field ordering (why?). There should be a common consensus on the approach to follow.\nIMO ObfuscationReflectionHelper should be preferred over ATs (since these data Gens don't run at runtime and we don't really need to expose data) and field ordering.", "author": "TheSilkMiner", "createdAt": "2020-06-15T09:19:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDAxNjY1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM4NjE4Mg==", "url": "https://github.com/MinecraftForge/MinecraftForge/pull/6765#discussion_r440386182", "bodyText": "I was using ForgeRecipeProvider as example, but I can replace that by method from ObfuscationReflectionHelper", "author": "yanny7", "createdAt": "2020-06-15T19:06:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDAxNjY1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDAxNzc4Nw==", "url": "https://github.com/MinecraftForge/MinecraftForge/pull/6765#discussion_r440017787", "bodyText": "Should probably note that this is used for shears only right now", "author": "ichttt", "createdAt": "2020-06-15T08:39:38Z", "path": "src/main/java/net/minecraftforge/common/data/ForgeLootTableProvider.java", "diffHunk": "@@ -0,0 +1,162 @@\n+package net.minecraftforge.common.data;\n+\n+import com.mojang.datafixers.util.Pair;\n+import net.minecraft.advancements.criterion.ItemPredicate;\n+import net.minecraft.data.DataGenerator;\n+import net.minecraft.data.LootTableProvider;\n+import net.minecraft.item.Item;\n+import net.minecraft.item.Items;\n+import net.minecraft.tags.Tag;\n+import net.minecraft.util.ResourceLocation;\n+import net.minecraft.world.storage.loot.*;\n+import net.minecraft.world.storage.loot.conditions.Alternative;\n+import net.minecraft.world.storage.loot.conditions.ILootCondition;\n+import net.minecraft.world.storage.loot.conditions.Inverted;\n+import net.minecraft.world.storage.loot.conditions.MatchTool;\n+import net.minecraftforge.common.Tags;\n+\n+import java.lang.reflect.Field;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.BiConsumer;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+public class ForgeLootTableProvider extends LootTableProvider {", "originalCommit": "d7a36b87bddf17d24c1876590a125f8f6b64a1f4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDcxMDI3MA==", "url": "https://github.com/MinecraftForge/MinecraftForge/pull/6765#discussion_r440710270", "bodyText": "Added comment", "author": "yanny7", "createdAt": "2020-06-16T09:21:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDAxNzc4Nw=="}], "type": "inlineReview"}, {"oid": "a409ad26c8d897c99f9cf095e5103e8327f5d584", "url": "https://github.com/MinecraftForge/MinecraftForge/commit/a409ad26c8d897c99f9cf095e5103e8327f5d584", "message": "Removed getField", "committedDate": "2020-06-16T08:56:22Z", "type": "commit"}]}