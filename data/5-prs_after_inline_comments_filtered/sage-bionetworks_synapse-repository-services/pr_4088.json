{"pr_number": 4088, "pr_title": "PLFM-5753", "pr_createdAt": "2020-06-10T15:51:20Z", "pr_url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4088", "timeline": [{"oid": "50b4d8e82da5994e831aa905ad642f98bc809610", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/50b4d8e82da5994e831aa905ad642f98bc809610", "message": "Add functionality to return refresh tokens via an authorization code", "committedDate": "2020-06-10T15:53:33Z", "type": "forcePushed"}, {"oid": "1461308dc879e09048c9942e05101fa899701355", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/1461308dc879e09048c9942e05101fa899701355", "message": "temp push", "committedDate": "2020-06-10T18:02:40Z", "type": "forcePushed"}, {"oid": "9e2f46e58b4e9054f782775ee0f8fc85d5784935", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/9e2f46e58b4e9054f782775ee0f8fc85d5784935", "message": "temp push", "committedDate": "2020-06-12T15:35:27Z", "type": "forcePushed"}, {"oid": "29ceb07e02915d273bbee62e78daba58e7cc6283", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/29ceb07e02915d273bbee62e78daba58e7cc6283", "message": "temp push", "committedDate": "2020-06-12T15:47:43Z", "type": "forcePushed"}, {"oid": "2ab03f54a146f8ab073939203a7abba21b47a741", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/2ab03f54a146f8ab073939203a7abba21b47a741", "message": "Test style changes from code review", "committedDate": "2020-06-12T18:12:08Z", "type": "commit"}, {"oid": "2bf2e70e81a67a9ee97ba8a25243fbb95ea0d8a1", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/2bf2e70e81a67a9ee97ba8a25243fbb95ea0d8a1", "message": "Change method name for clarity/distinguish with future method", "committedDate": "2020-06-12T18:14:11Z", "type": "commit"}, {"oid": "55dde50b05998a4ca5d957ed077d0340ee7726bb", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/55dde50b05998a4ca5d957ed077d0340ee7726bb", "message": "Add functionality to return refresh tokens via an authorization code", "committedDate": "2020-06-12T18:14:11Z", "type": "commit"}, {"oid": "1feb954317adc1d4f942f0410f5eda7e0a98f0e6", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/1feb954317adc1d4f942f0410f5eda7e0a98f0e6", "message": "temp psuh", "committedDate": "2020-06-12T18:14:11Z", "type": "forcePushed"}, {"oid": "e9ea75e050a02d5fcd377e5e6d073cd89e358572", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/e9ea75e050a02d5fcd377e5e6d073cd89e358572", "message": "Add method to check if refresh token is active", "committedDate": "2020-06-15T13:50:47Z", "type": "commit"}, {"oid": "815a02776e80a9732bb1ddcac3247accb9e61570", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/815a02776e80a9732bb1ddcac3247accb9e61570", "message": "Check if the token is active before rotating it.", "committedDate": "2020-06-15T16:17:50Z", "type": "commit"}, {"oid": "815a02776e80a9732bb1ddcac3247accb9e61570", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/815a02776e80a9732bb1ddcac3247accb9e61570", "message": "Check if the token is active before rotating it.", "committedDate": "2020-06-15T16:17:50Z", "type": "forcePushed"}, {"oid": "5cc09a81215746bd102af7a81c5043c724079746", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/5cc09a81215746bd102af7a81c5043c724079746", "message": "Bump footer copyright year", "committedDate": "2020-06-15T22:46:36Z", "type": "commit"}, {"oid": "9fe8f7b644d5b300df13aa578666cdd6bc12d4f7", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/9fe8f7b644d5b300df13aa578666cdd6bc12d4f7", "message": "OIDC Manager, Service, and Controller for OAuth refresh tokens", "committedDate": "2020-06-15T22:47:15Z", "type": "commit"}, {"oid": "5832a0be9ca73455ea4ead718c35b043ad066a15", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/5832a0be9ca73455ea4ead718c35b043ad066a15", "message": "Change expected exception in test", "committedDate": "2020-06-16T13:49:26Z", "type": "commit"}, {"oid": "203cecc68e8a9b39e4daa4e4c67fec54c54e33b5", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/203cecc68e8a9b39e4daa4e4c67fec54c54e33b5", "message": "More OAuth2 Refresh Token integration tests", "committedDate": "2020-06-16T14:22:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTAxMzE0NQ==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4088#discussion_r441013145", "bodyText": "pass the deleted strings to the POJO parser to make sure it still works.", "author": "brucehoff", "createdAt": "2020-06-16T17:14:41Z", "path": "integration-test/src/test/java/org/sagebionetworks/ITOpenIDConnectTest.java", "diffHunk": "@@ -110,10 +124,18 @@ public void testClientNotVerified() throws Exception {\n \t\tauthorizationRequest.setRedirectUri(client.getRedirect_uris().get(0));\n \t\tauthorizationRequest.setResponseType(OAuthResponseType.code);\n \t\tauthorizationRequest.setScope(\"openid\");\n-\t\tauthorizationRequest.setClaims(\n-\t\t\t\t\"{\\\"id_token\\\":{\\\"userid\\\":\\\"null\\\",\\\"email\\\":null,\\\"is_certified\\\":null,\\\"team\\\":{\\\"values\\\":[\\\"2\\\"]}},\"+\n-\t\t\t\t \"\\\"userinfo\\\":{\\\"userid\\\":\\\"null\\\",\\\"email\\\":null,\\\"is_certified\\\":null,\\\"team\\\":{\\\"values\\\":[\\\"2\\\"]}}}\"\n-\t\t);\n+\t\tMap<String, OIDCClaimsRequestDetails> claimsToRequest = new HashMap<>();", "originalCommit": "203cecc68e8a9b39e4daa4e4c67fec54c54e33b5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYwNjEyOQ==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4088#discussion_r441606129", "bodyText": "This string in particular causes an issue. The value for the field \"userId\" is (string) \"null\" and not null. The JSON parser can't convert \"null\" to the OIDCClaimsRequestDetails object.\nThis means using the object in this PR instead of using the custom parser causes a breaking API change, (though the impact of the change may be small).", "author": "nickgros", "createdAt": "2020-06-17T14:50:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTAxMzE0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTAxODcwMQ==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4088#discussion_r441018701", "bodyText": "redundant", "author": "brucehoff", "createdAt": "2020-06-16T17:23:56Z", "path": "lib/lib-utils/src/test/java/org/sagebionetworks/util/EnumKeyedJsonMapUtilTest.java", "diffHunk": "@@ -0,0 +1,84 @@\n+package org.sagebionetworks.util;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.junit.jupiter.api.Test;\n+\n+public class EnumKeyedJsonMapUtilTest {\n+\n+\tprivate enum TestEnum {\n+\t\tALPHA,\n+\t\tBETA,\n+\t\tGAMMA\n+\t}\n+\n+\t@Test\n+\tpublic void testConvertToEnum() {\n+\t\tMap<String, String> stringMap = new HashMap<>();\n+\t\tstringMap.put(\"ALPHA\", \"alphaVal\");\n+\t\tstringMap.put(\"BETA\", \"betaVal\");\n+\t\tstringMap.put(\"GAMMA\", \"gammaVal\");\n+\n+\t\t// Call under test\n+\t\tMap<TestEnum, String> enumMap = EnumKeyedJsonMapUtil.convertToEnum(stringMap, TestEnum.class);\n+\n+\t\tassertEquals(3, enumMap.size());\n+\t\tassertEquals(stringMap.get(\"ALPHA\"), enumMap.get(TestEnum.ALPHA));\n+\t\tassertEquals(stringMap.get(\"BETA\"), enumMap.get(TestEnum.BETA));\n+\t\tassertEquals(stringMap.get(\"GAMMA\"), enumMap.get(TestEnum.GAMMA));\n+\t}\n+\n+\t@Test\n+\tpublic void testConvertToEnum_IllegalArgExc() {\n+\t\tMap<String, String> stringMap = new HashMap<>();\n+\t\tstringMap.put(\"ALPHA\", \"alphaVal\");\n+\t\tstringMap.put(\"BETA\", \"betaVal\");\n+\t\tstringMap.put(\"EPSILON\", \"epsilonVal\"); // not in the enum!\n+\n+\t\t// Call under test\n+\t\tMap<TestEnum, String> enumMap = EnumKeyedJsonMapUtil.convertToEnum(stringMap, TestEnum.class);\n+\n+\t\tassertEquals(2, enumMap.size());\n+\t\tassertEquals(stringMap.get(\"ALPHA\"), enumMap.get(TestEnum.ALPHA));\n+\t\tassertEquals(stringMap.get(\"BETA\"), enumMap.get(TestEnum.BETA));\n+\t\tassertNull(enumMap.get(TestEnum.GAMMA));\n+\n+\t}\n+\n+\n+\t@Test\n+\tpublic void testConvertToString() {\n+\t\tMap<TestEnum, String> enumMap = new HashMap<>();\n+\t\tenumMap.put(TestEnum.ALPHA, \"alphaVal\");\n+\t\tenumMap.put(TestEnum.BETA, \"betaVal\");\n+\t\tenumMap.put(TestEnum.GAMMA, \"gammaVal\");\n+\n+\t\t// Call under test\n+\t\tMap<String, String> stringMap = EnumKeyedJsonMapUtil.convertToString(enumMap);\n+\n+\t\tassertEquals(3, stringMap.size());\n+\t\tassertEquals(enumMap.get(TestEnum.ALPHA), stringMap.get(\"ALPHA\"));\n+\t\tassertEquals(enumMap.get(TestEnum.BETA), stringMap.get(\"BETA\"));\n+\t\tassertEquals(enumMap.get(TestEnum.GAMMA), stringMap.get(\"GAMMA\"));\n+\t}\n+\n+\n+\t@Test", "originalCommit": "203cecc68e8a9b39e4daa4e4c67fec54c54e33b5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTAyNTgwNw==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4088#discussion_r441025807", "bodyText": "I don't think this null check is necessary.", "author": "brucehoff", "createdAt": "2020-06-16T17:35:55Z", "path": "services/repository-managers/src/main/java/org/sagebionetworks/repo/manager/oauth/OpenIDConnectManagerImpl.java", "diffHunk": "@@ -346,16 +357,131 @@ public OIDCTokenResponse getAccessToken(String code, String verifiedClientId, St\n \t\tif (scopes.contains(OAuthScope.openid)) {\n \t\t\tString idTokenId = UUID.randomUUID().toString();\n \t\t\tMap<OIDCClaimName,Object> userInfo = getUserInfo(authorizationRequest.getUserId(), \n-\t\t\t\t\tscopes, ClaimsJsonUtil.getClaimsMapFromClaimsRequestParam(authorizationRequest.getClaims(), ID_TOKEN_CLAIMS_KEY));\n+\t\t\t\t\tscopes, EnumKeyedJsonMapUtil.convertToEnum(normalizedClaims.getId_token(), OIDCClaimName.class));\n \t\t\tString idToken = oidcTokenHelper.createOIDCIdToken(oauthEndpoint, ppid, oauthClientId, now, \n \t\t\t\t\tauthorizationRequest.getNonce(), authTime, idTokenId, userInfo);\n \t\t\tresult.setId_token(idToken);\n \t\t}\n \n+\t\t// A refresh token should only be issued when `offline_access` is requested.\n+\t\tboolean issueRefreshToken = scopes.contains(OAuthScope.offline_access);\n+\t\tString refreshTokenId = null;\n+\t\tif (issueRefreshToken) {\n+\n+\t\t\tOAuthRefreshTokenAndMetadata refreshToken = oauthRefreshTokenManager\n+\t\t\t\t\t.createRefreshToken(authorizationRequest.getUserId(),\n+\t\t\t\t\t\t\toauthClientId,\n+\t\t\t\t\t\t\tscopes,\n+\t\t\t\t\t\t\tnormalizedClaims\n+\t\t\t\t\t);\n+\t\t\trefreshTokenId = refreshToken.getMetadata().getTokenId();\n+\t\t\tresult.setRefresh_token(refreshToken.getRefreshToken());\n+\t\t}\n+\n \t\tString accessTokenId = UUID.randomUUID().toString();\n \t\tString accessToken = oidcTokenHelper.createOIDCaccessToken(oauthEndpoint, ppid, \n-\t\t\t\toauthClientId, now, authTime, null, accessTokenId, scopes,\n-\t\t\t\tClaimsJsonUtil.getClaimsMapFromClaimsRequestParam(authorizationRequest.getClaims(), USER_INFO_CLAIMS_KEY));\n+\t\t\t\toauthClientId, now, authTime, refreshTokenId, accessTokenId, scopes,\n+\t\t\t\tEnumKeyedJsonMapUtil.convertToEnum(normalizedClaims.getUserinfo(), OIDCClaimName.class));\n+\t\tresult.setAccess_token(accessToken);\n+\t\treturn result;\n+\t}\n+\n+\t/**\n+\t * Removes null fields and unrecognized claims from the OIDCClaimsRequest. Also replaces\n+\t * null objects with empty ones (a requirement for the {@link OAuthRefreshTokenManager}, if the\n+\t * claims are saved)\n+\t *\n+\t * Protected access for testing\n+\t * @param claims\n+\t * @return\n+\t */\n+\tprotected static OIDCClaimsRequest normalizeClaims(OIDCClaimsRequest claims) {\n+\t\tif (claims == null) {\n+\t\t\tclaims = new OIDCClaimsRequest();\n+\t\t}\n+\t\tif (claims.getId_token() == null) {\n+\t\t\tclaims.setId_token(Collections.emptyMap());\n+\t\t} else {\n+\t\t\t// Converting the key to enum and back to string will drop unrecognized claims\n+\t\t\tclaims.setId_token(\n+\t\t\t\t\tEnumKeyedJsonMapUtil.convertToString(\n+\t\t\t\t\t\t\tEnumKeyedJsonMapUtil.convertToEnum(claims.getId_token(), OIDCClaimName.class)\n+\t\t\t\t\t)\n+\t\t\t);\n+\t\t}\n+\t\tif (claims.getUserinfo() == null) {\n+\t\t\tclaims.setUserinfo(Collections.emptyMap());\n+\t\t} else {\n+\t\t\tclaims.setUserinfo(\n+\t\t\t\t\tEnumKeyedJsonMapUtil.convertToString(\n+\t\t\t\t\t\t\tEnumKeyedJsonMapUtil.convertToEnum(claims.getUserinfo(), OIDCClaimName.class)\n+\t\t\t\t\t)\n+\t\t\t);\n+\t\t}\n+\t\treturn claims;\n+\t}\n+\n+\t@WriteTransaction\n+\t@Override\n+\tpublic OIDCTokenResponse getTokenResponseWithRefreshToken(String refreshToken, String verifiedClientId, String scope, String oauthEndpoint) {\n+\t\tValidateArgument.required(refreshToken, \"Refresh Token\");\n+\t\tValidateArgument.required(verifiedClientId, \"OAuth Client ID\");\n+\t\tValidateArgument.required(oauthEndpoint, \"Authorization Endpoint\");\n+\t\t// scopes is not required\n+\n+\t\tvalidateClientVerificationStatus(verifiedClientId);\n+\t\tList<OAuthScope> scopes = parseScopeString(scope);\n+\n+\t\t// Retrieve the refresh token and rotate it.\n+\t\tOAuthRefreshTokenAndMetadata rotatedRefreshToken = oauthRefreshTokenManager.rotateRefreshToken(refreshToken);\n+\t\tOAuthRefreshTokenInformation refreshTokenMetadata = rotatedRefreshToken.getMetadata();\n+\n+\t\t// Ensure the client is permitted to use this refresh token\n+\t\tif (!refreshTokenMetadata.getClientId().equals(verifiedClientId)) {\n+\t\t\t// Defined by https://tools.ietf.org/html/rfc6749#section-5.2\n+\t\t\tthrow new IllegalArgumentException(\"invalid_grant\");\n+\t\t}\n+\n+\t\tif (scopes.isEmpty()) {\n+\t\t\t// Per RFC-6479 Section 6, if [the requested scope is] omitted[, it] is treated as equal to the scope originally granted by the resource owner. https://tools.ietf.org/html/rfc6749#section-6\n+\t\t\tscopes = refreshTokenMetadata.getScopes();\n+\t\t} else if (!refreshTokenMetadata.getScopes().containsAll(scopes)) { // Ensure the requested scopes are a subset of previously authorized scopes and claims\n+\t\t\t// Defined by https://tools.ietf.org/html/rfc6749#section-5.2\n+\t\t\tthrow new IllegalArgumentException(\"invalid_scope\");\n+\t\t}\n+\n+\t\t// In the JWT, we will need to supply both the current time and the date/time of the initial authorization\n+\t\tlong now = clock.currentTimeMillis();\n+\t\tDate authTime = null;\n+\t\tif (refreshTokenMetadata.getAuthorizedOn() != null) {", "originalCommit": "203cecc68e8a9b39e4daa4e4c67fec54c54e33b5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTAzMDI2MA==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4088#discussion_r441030260", "bodyText": "please make sure there is a test of the case in which a non-JWT is passes as an access token", "author": "brucehoff", "createdAt": "2020-06-16T17:43:45Z", "path": "services/repository-managers/src/main/java/org/sagebionetworks/repo/manager/oauth/OpenIDConnectManagerImpl.java", "diffHunk": "@@ -422,4 +548,41 @@ protected void validateClientVerificationStatus(String clientId) throws NotFound\n \t\t\tthrow new OAuthClientNotVerifiedException(\"The OAuth client (\" + clientId + \") is not verified.\");\n \t\t}\n \t}\n+\n+\t@WriteTransaction\n+\t@Override\n+\tpublic void revokeToken(OAuthTokenRevocationRequest revocationRequest) {\n+\t\tswitch (revocationRequest.getToken_type_hint()) {\n+\t\t\tcase access_token: // retrieve the refresh token ID from the JWT\n+\t\t\t\tString refreshTokenId = this.getRefreshTokenId(revocationRequest.getToken());", "originalCommit": "203cecc68e8a9b39e4daa4e4c67fec54c54e33b5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTAzMTA0Mw==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4088#discussion_r441031043", "bodyText": "\"This access token has no associated refresh token so it cannot be revoked.\"", "author": "brucehoff", "createdAt": "2020-06-16T17:45:06Z", "path": "services/repository-managers/src/main/java/org/sagebionetworks/repo/manager/oauth/OpenIDConnectManagerImpl.java", "diffHunk": "@@ -422,4 +548,41 @@ protected void validateClientVerificationStatus(String clientId) throws NotFound\n \t\t\tthrow new OAuthClientNotVerifiedException(\"The OAuth client (\" + clientId + \") is not verified.\");\n \t\t}\n \t}\n+\n+\t@WriteTransaction\n+\t@Override\n+\tpublic void revokeToken(OAuthTokenRevocationRequest revocationRequest) {\n+\t\tswitch (revocationRequest.getToken_type_hint()) {\n+\t\t\tcase access_token: // retrieve the refresh token ID from the JWT\n+\t\t\t\tString refreshTokenId = this.getRefreshTokenId(revocationRequest.getToken());\n+\t\t\t\tif (refreshTokenId == null) {\n+\t\t\t\t\t// Access tokens that were not issued alongside refresh tokens cannot be revoked.\n+\t\t\t\t\tthrow new IllegalArgumentException(\"The access token was not issued via a refresh token. It cannot be revoked.\");\n+\t\t\t\t}", "originalCommit": "203cecc68e8a9b39e4daa4e4c67fec54c54e33b5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTAzMzEwMQ==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4088#discussion_r441033101", "bodyText": "please add a method to OauthRefreshTokenManager:  revokeRefreshToken(String verifiedClientId, String refreshTokenId).", "author": "brucehoff", "createdAt": "2020-06-16T17:48:28Z", "path": "services/repository-managers/src/main/java/org/sagebionetworks/repo/manager/oauth/OpenIDConnectManagerImpl.java", "diffHunk": "@@ -422,4 +548,41 @@ protected void validateClientVerificationStatus(String clientId) throws NotFound\n \t\t\tthrow new OAuthClientNotVerifiedException(\"The OAuth client (\" + clientId + \") is not verified.\");\n \t\t}\n \t}\n+\n+\t@WriteTransaction\n+\t@Override\n+\tpublic void revokeToken(OAuthTokenRevocationRequest revocationRequest) {\n+\t\tswitch (revocationRequest.getToken_type_hint()) {\n+\t\t\tcase access_token: // retrieve the refresh token ID from the JWT\n+\t\t\t\tString refreshTokenId = this.getRefreshTokenId(revocationRequest.getToken());\n+\t\t\t\tif (refreshTokenId == null) {\n+\t\t\t\t\t// Access tokens that were not issued alongside refresh tokens cannot be revoked.\n+\t\t\t\t\tthrow new IllegalArgumentException(\"The access token was not issued via a refresh token. It cannot be revoked.\");\n+\t\t\t\t}\n+\t\t\t\t// Revoke via token doesn't require authorization, so we use the admin user\n+\t\t\t\tUserInfo adminUserInfo = userManager.getUserInfo(AuthorizationConstants.BOOTSTRAP_PRINCIPAL.THE_ADMIN_USER.getPrincipalId());\n+\t\t\t\toauthRefreshTokenManager.revokeRefreshToken(adminUserInfo, refreshTokenId);", "originalCommit": "203cecc68e8a9b39e4daa4e4c67fec54c54e33b5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA0MDYxOQ==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4088#discussion_r441040619", "bodyText": "add verifiedClientId", "author": "brucehoff", "createdAt": "2020-06-16T18:01:01Z", "path": "services/repository-managers/src/main/java/org/sagebionetworks/repo/manager/oauth/OpenIDConnectManagerImpl.java", "diffHunk": "@@ -422,4 +548,41 @@ protected void validateClientVerificationStatus(String clientId) throws NotFound\n \t\t\tthrow new OAuthClientNotVerifiedException(\"The OAuth client (\" + clientId + \") is not verified.\");\n \t\t}\n \t}\n+\n+\t@WriteTransaction\n+\t@Override\n+\tpublic void revokeToken(OAuthTokenRevocationRequest revocationRequest) {\n+\t\tswitch (revocationRequest.getToken_type_hint()) {\n+\t\t\tcase access_token: // retrieve the refresh token ID from the JWT\n+\t\t\t\tString refreshTokenId = this.getRefreshTokenId(revocationRequest.getToken());\n+\t\t\t\tif (refreshTokenId == null) {\n+\t\t\t\t\t// Access tokens that were not issued alongside refresh tokens cannot be revoked.\n+\t\t\t\t\tthrow new IllegalArgumentException(\"The access token was not issued via a refresh token. It cannot be revoked.\");\n+\t\t\t\t}\n+\t\t\t\t// Revoke via token doesn't require authorization, so we use the admin user\n+\t\t\t\tUserInfo adminUserInfo = userManager.getUserInfo(AuthorizationConstants.BOOTSTRAP_PRINCIPAL.THE_ADMIN_USER.getPrincipalId());\n+\t\t\t\toauthRefreshTokenManager.revokeRefreshToken(adminUserInfo, refreshTokenId);\n+\t\t\t\treturn;\n+\t\t\tcase refresh_token: // retrieve the token ID from the DAO using the token hash\n+\t\t\t\toauthRefreshTokenManager.revokeRefreshToken(revocationRequest.getToken());", "originalCommit": "203cecc68e8a9b39e4daa4e4c67fec54c54e33b5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA0NjI0Nw==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4088#discussion_r441046247", "bodyText": "remove this line", "author": "brucehoff", "createdAt": "2020-06-16T18:10:51Z", "path": "lib/jdomodels/src/test/java/org/sagebionetworks/repo/model/dbo/auth/OAuthRefreshTokenDaoAutowiredTest.java", "diffHunk": "@@ -433,4 +433,28 @@ void deleteLeastRecentlyUsedActiveTokens() {\n \t\tassertTrue(oauthRefreshTokenDao.getRefreshTokenMetadata(newToken1.getTokenId()).isPresent());\n \t\tassertTrue(oauthRefreshTokenDao.getRefreshTokenMetadata(newToken2.getTokenId()).isPresent());\n \t}\n+\n+\t@Test\n+\tpublic void testIsTokenActive() {\n+\t\tOAuthRefreshTokenInformation token = createRefreshToken(new Date(System.currentTimeMillis()));\n+\t\t// Call under test\n+\t\tassertTrue(oauthRefreshTokenDao.isTokenActive(token.getTokenId(), HALF_YEAR_DAYS));\n+\t}\n+\n+\t@Test\n+\tpublic void testIsTokenActive_deleted() {\n+\t\tOAuthRefreshTokenInformation token = createRefreshToken(new Date(System.currentTimeMillis()));\n+\t\toauthRefreshTokenDao.deleteToken(token.getTokenId());\n+\t\t// Call under test\n+\t\tassertFalse(oauthRefreshTokenDao.isTokenActive(token.getTokenId(), HALF_YEAR_DAYS));\n+\t}\n+\n+\t@Test\n+\tpublic void testIsTokenActive_expired() {\n+\t\t// Create token last used one year ago\n+\t\tOAuthRefreshTokenInformation token = createRefreshToken(new Date(System.currentTimeMillis() - ONE_YEAR_MILLIS));\n+\t\toauthRefreshTokenDao.deleteToken(token.getTokenId());", "originalCommit": "203cecc68e8a9b39e4daa4e4c67fec54c54e33b5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA1NDIzNw==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4088#discussion_r441054237", "bodyText": "it looks like some of the same set up is used >=4 times.  Please factor out the repeated code.", "author": "brucehoff", "createdAt": "2020-06-16T18:21:51Z", "path": "services/repository-managers/src/test/java/org/sagebionetworks/repo/manager/oauth/OpenIDConnectManagerImplAutowiredTest.java", "diffHunk": "@@ -106,54 +118,238 @@ public void tearDown() throws Exception {\n \n \t// the business logic is tested in detail in the unit tests.  This just does a basic authorization round-trip.\n \t@Test\n-\tpublic void testAuthorizationRoundTrip() throws Exception {\t\t\n+\tpublic void testAuthorizationCodeRoundTrip() throws Exception {\n \n \t\t// Verify the client\n \t\toauthClient = oauthClientManager.updateOpenIDConnectClientVerifiedStatus(adminUserInfo, oauthClient.getClient_id(), oauthClient.getEtag(), true);\n-\t\t\n+\n \t\tOIDCAuthorizationRequest authorizationRequest = new OIDCAuthorizationRequest();\n \t\tauthorizationRequest.setClientId(oauthClient.getClient_id());\n \t\tauthorizationRequest.setRedirectUri(oauthClient.getRedirect_uris().get(0));\n-\t\tauthorizationRequest.setScope(OAuthScope.openid.name());\n+\t\tauthorizationRequest.setScope(OAuthScope.openid.name() + \" \" + OAuthScope.offline_access.name());\n \t\tauthorizationRequest.setResponseType(OAuthResponseType.code);\n-\t\tauthorizationRequest.setClaims(\"{\\\"id_token\\\":{\\\"team\\\":{\\\"values\\\":[\\\"2\\\"]}},\\\"userinfo\\\":{\\\"team\\\":{\\\"values\\\":[\\\"2\\\"]}}}\");\n-\t\t\t\t\n+\t\tMap<String, OIDCClaimsRequestDetails> claimsToRequest = new HashMap<>();\n+\t\tOIDCClaimsRequestDetails teamClaimRequestDetails = new OIDCClaimsRequestDetails();\n+\t\tteamClaimRequestDetails.setValues(Collections.singletonList(\"2\"));\n+\t\tclaimsToRequest.put(OIDCClaimName.team.name(), teamClaimRequestDetails);\n+\t\tOIDCClaimsRequest claimsRequest = new OIDCClaimsRequest();\n+\t\tclaimsRequest.setId_token(claimsToRequest);\n+\t\tclaimsRequest.setUserinfo(claimsToRequest);\n+\t\tauthorizationRequest.setClaims(claimsRequest);\n+\n \t\t// method under test\n-\t\tOIDCAuthorizationRequestDescription description = \n+\t\tOIDCAuthorizationRequestDescription description =\n \t\t\t\topenIDConnectManager.getAuthenticationRequestDescription(authorizationRequest);\n-\t\t\n+\n \t\tassertNotNull(description);\n-\t\t\n+\n \t\t// method under test\n \t\tOAuthAuthorizationResponse authResponse = openIDConnectManager.\n \t\t\t\tauthorizeClient(userInfo, authorizationRequest);\n-\t\t\n+\n \t\tassertNotNull(authResponse.getAccess_code());\n-\t\t\n+\n \t\t// method under test\n-\t\tOIDCTokenResponse tokenResponse = \n-\t\t\t\topenIDConnectManager.getAccessToken(authResponse.getAccess_code(), \n+\t\tOIDCTokenResponse tokenResponse =\n+\t\t\t\topenIDConnectManager.getTokenResponseWithAuthorizationCode(authResponse.getAccess_code(),\n \t\t\t\t\t\toauthClient.getClient_id(), oauthClient.getRedirect_uris().get(0), OAUTH_ENDPOINT);\n-\t\t\n-\t\t\n+\n+\n \t\tassertNotNull(tokenResponse.getAccess_token());\n \t\tassertNotNull(tokenResponse.getId_token());\n-\t\t\n+\t\tassertNotNull(tokenResponse.getRefresh_token());\n+\n \t\toidcTokenHelper.validateJWT(tokenResponse.getId_token());\n-\t\t\n+\n+\t\t// method under test\n+\t\tJWTWrapper oidcUserInfo = (JWTWrapper) openIDConnectManager.getUserInfo(tokenResponse.getAccess_token(), OAUTH_ENDPOINT);\n+\n+\t\toidcTokenHelper.validateJWT(oidcUserInfo.getJwt());\n+\n+\t}\n+\n+\t@Test\n+\tpublic void testRefreshTokenRoundTrip() throws Exception {\n+\t\t// Verify the client\n+\t\toauthClient = oauthClientManager.updateOpenIDConnectClientVerifiedStatus(adminUserInfo, oauthClient.getClient_id(), oauthClient.getEtag(), true);", "originalCommit": "203cecc68e8a9b39e4daa4e4c67fec54c54e33b5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA1NjUxMA==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4088#discussion_r441056510", "bodyText": "I would just this one check in an earlier roundtrip test and delete this test", "author": "brucehoff", "createdAt": "2020-06-16T18:25:04Z", "path": "services/repository-managers/src/test/java/org/sagebionetworks/repo/manager/oauth/OpenIDConnectManagerImplAutowiredTest.java", "diffHunk": "@@ -106,54 +118,238 @@ public void tearDown() throws Exception {\n \n \t// the business logic is tested in detail in the unit tests.  This just does a basic authorization round-trip.\n \t@Test\n-\tpublic void testAuthorizationRoundTrip() throws Exception {\t\t\n+\tpublic void testAuthorizationCodeRoundTrip() throws Exception {\n \n \t\t// Verify the client\n \t\toauthClient = oauthClientManager.updateOpenIDConnectClientVerifiedStatus(adminUserInfo, oauthClient.getClient_id(), oauthClient.getEtag(), true);\n-\t\t\n+\n \t\tOIDCAuthorizationRequest authorizationRequest = new OIDCAuthorizationRequest();\n \t\tauthorizationRequest.setClientId(oauthClient.getClient_id());\n \t\tauthorizationRequest.setRedirectUri(oauthClient.getRedirect_uris().get(0));\n-\t\tauthorizationRequest.setScope(OAuthScope.openid.name());\n+\t\tauthorizationRequest.setScope(OAuthScope.openid.name() + \" \" + OAuthScope.offline_access.name());\n \t\tauthorizationRequest.setResponseType(OAuthResponseType.code);\n-\t\tauthorizationRequest.setClaims(\"{\\\"id_token\\\":{\\\"team\\\":{\\\"values\\\":[\\\"2\\\"]}},\\\"userinfo\\\":{\\\"team\\\":{\\\"values\\\":[\\\"2\\\"]}}}\");\n-\t\t\t\t\n+\t\tMap<String, OIDCClaimsRequestDetails> claimsToRequest = new HashMap<>();\n+\t\tOIDCClaimsRequestDetails teamClaimRequestDetails = new OIDCClaimsRequestDetails();\n+\t\tteamClaimRequestDetails.setValues(Collections.singletonList(\"2\"));\n+\t\tclaimsToRequest.put(OIDCClaimName.team.name(), teamClaimRequestDetails);\n+\t\tOIDCClaimsRequest claimsRequest = new OIDCClaimsRequest();\n+\t\tclaimsRequest.setId_token(claimsToRequest);\n+\t\tclaimsRequest.setUserinfo(claimsToRequest);\n+\t\tauthorizationRequest.setClaims(claimsRequest);\n+\n \t\t// method under test\n-\t\tOIDCAuthorizationRequestDescription description = \n+\t\tOIDCAuthorizationRequestDescription description =\n \t\t\t\topenIDConnectManager.getAuthenticationRequestDescription(authorizationRequest);\n-\t\t\n+\n \t\tassertNotNull(description);\n-\t\t\n+\n \t\t// method under test\n \t\tOAuthAuthorizationResponse authResponse = openIDConnectManager.\n \t\t\t\tauthorizeClient(userInfo, authorizationRequest);\n-\t\t\n+\n \t\tassertNotNull(authResponse.getAccess_code());\n-\t\t\n+\n \t\t// method under test\n-\t\tOIDCTokenResponse tokenResponse = \n-\t\t\t\topenIDConnectManager.getAccessToken(authResponse.getAccess_code(), \n+\t\tOIDCTokenResponse tokenResponse =\n+\t\t\t\topenIDConnectManager.getTokenResponseWithAuthorizationCode(authResponse.getAccess_code(),\n \t\t\t\t\t\toauthClient.getClient_id(), oauthClient.getRedirect_uris().get(0), OAUTH_ENDPOINT);\n-\t\t\n-\t\t\n+\n+\n \t\tassertNotNull(tokenResponse.getAccess_token());\n \t\tassertNotNull(tokenResponse.getId_token());\n-\t\t\n+\t\tassertNotNull(tokenResponse.getRefresh_token());\n+\n \t\toidcTokenHelper.validateJWT(tokenResponse.getId_token());\n-\t\t\n+\n+\t\t// method under test\n+\t\tJWTWrapper oidcUserInfo = (JWTWrapper) openIDConnectManager.getUserInfo(tokenResponse.getAccess_token(), OAUTH_ENDPOINT);\n+\n+\t\toidcTokenHelper.validateJWT(oidcUserInfo.getJwt());\n+\n+\t}\n+\n+\t@Test\n+\tpublic void testRefreshTokenRoundTrip() throws Exception {\n+\t\t// Verify the client\n+\t\toauthClient = oauthClientManager.updateOpenIDConnectClientVerifiedStatus(adminUserInfo, oauthClient.getClient_id(), oauthClient.getEtag(), true);\n+\n+\t\tOIDCAuthorizationRequest authorizationRequest = new OIDCAuthorizationRequest();\n+\t\tauthorizationRequest.setClientId(oauthClient.getClient_id());\n+\t\tauthorizationRequest.setRedirectUri(oauthClient.getRedirect_uris().get(0));\n+\t\tauthorizationRequest.setScope(OAuthScope.openid.name() + \" \" + OAuthScope.offline_access.name());\n+\t\tauthorizationRequest.setResponseType(OAuthResponseType.code);\n+\t\tMap<String, OIDCClaimsRequestDetails> claimsToRequest = new HashMap<>();\n+\t\tOIDCClaimsRequestDetails teamClaimRequestDetails = new OIDCClaimsRequestDetails();\n+\t\tteamClaimRequestDetails.setValues(Collections.singletonList(\"2\"));\n+\t\tclaimsToRequest.put(OIDCClaimName.team.name(), teamClaimRequestDetails);\n+\t\tOIDCClaimsRequest claimsRequest = new OIDCClaimsRequest();\n+\t\tclaimsRequest.setId_token(claimsToRequest);\n+\t\tclaimsRequest.setUserinfo(claimsToRequest);\n+\t\tauthorizationRequest.setClaims(claimsRequest);\n+\n+\t\t// tested in testAuthorizationCodeRoundTrip\n+\t\tOAuthAuthorizationResponse authResponse = openIDConnectManager.\n+\t\t\t\tauthorizeClient(userInfo, authorizationRequest);\n+\n+\t\t// tested in testAuthorizationCodeRoundTrip\n+\t\tOIDCTokenResponse tokenResponse =\n+\t\t\t\topenIDConnectManager.getTokenResponseWithAuthorizationCode(authResponse.getAccess_code(),\n+\t\t\t\t\t\toauthClient.getClient_id(), oauthClient.getRedirect_uris().get(0), OAUTH_ENDPOINT);\n+\n+\t\t// Use the refresh token to get a new access token\n \t\t// method under test\n-\t\tJWTWrapper oidcUserInfo = (JWTWrapper)openIDConnectManager.getUserInfo(tokenResponse.getAccess_token(), OAUTH_ENDPOINT);\n-\t\t\n+\t\tOIDCTokenResponse newTokenResponse =\n+\t\t\t\topenIDConnectManager.getTokenResponseWithRefreshToken(tokenResponse.getRefresh_token(), oauthClient.getClient_id(), null, OAUTH_ENDPOINT);\n+\n+\t\tassertNotNull(newTokenResponse.getAccess_token());\n+\t\tassertNotEquals(tokenResponse.getAccess_token(), newTokenResponse.getAccess_token());\n+\t\tassertNotNull(newTokenResponse.getId_token());\n+\t\tassertNotEquals(tokenResponse.getId_token(), newTokenResponse.getId_token());\n+\t\tassertNotNull(newTokenResponse.getRefresh_token());\n+\t\tassertNotEquals(tokenResponse.getRefresh_token(), newTokenResponse.getRefresh_token());\n+\n+\t\toidcTokenHelper.validateJWT(newTokenResponse.getId_token());\n+\n+\t\t// method under test\n+\t\tJWTWrapper oidcUserInfo = (JWTWrapper) openIDConnectManager.getUserInfo(newTokenResponse.getAccess_token(), OAUTH_ENDPOINT);\n+\n \t\toidcTokenHelper.validateJWT(oidcUserInfo.getJwt());\n-\t\t\n \t}\n-\t\n+\n+\t@Test\n+\tpublic void testRevokedRefreshToken() throws Exception {\n+\t\t// Verify the client\n+\t\toauthClient = oauthClientManager.updateOpenIDConnectClientVerifiedStatus(adminUserInfo, oauthClient.getClient_id(), oauthClient.getEtag(), true);\n+\n+\t\tOIDCAuthorizationRequest authorizationRequest = new OIDCAuthorizationRequest();\n+\t\tauthorizationRequest.setClientId(oauthClient.getClient_id());\n+\t\tauthorizationRequest.setRedirectUri(oauthClient.getRedirect_uris().get(0));\n+\t\tauthorizationRequest.setScope(OAuthScope.openid.name() + \" \" + OAuthScope.offline_access.name());\n+\t\tauthorizationRequest.setResponseType(OAuthResponseType.code);\n+\t\tMap<String, OIDCClaimsRequestDetails> claimsToRequest = new HashMap<>();\n+\t\tOIDCClaimsRequestDetails teamClaimRequestDetails = new OIDCClaimsRequestDetails();\n+\t\tteamClaimRequestDetails.setValues(Collections.singletonList(\"2\"));\n+\t\tclaimsToRequest.put(OIDCClaimName.team.name(), teamClaimRequestDetails);\n+\t\tOIDCClaimsRequest claimsRequest = new OIDCClaimsRequest();\n+\t\tclaimsRequest.setId_token(claimsToRequest);\n+\t\tclaimsRequest.setUserinfo(claimsToRequest);\n+\t\tauthorizationRequest.setClaims(claimsRequest);\n+\n+\t\t// tested in testAuthorizationCodeRoundTrip\n+\t\tOAuthAuthorizationResponse authResponse = openIDConnectManager.\n+\t\t\t\tauthorizeClient(userInfo, authorizationRequest);\n+\n+\t\t// tested in testAuthorizationCodeRoundTrip\n+\t\tOIDCTokenResponse tokenResponse =\n+\t\t\t\topenIDConnectManager.getTokenResponseWithAuthorizationCode(authResponse.getAccess_code(),\n+\t\t\t\t\t\toauthClient.getClient_id(), oauthClient.getRedirect_uris().get(0), OAUTH_ENDPOINT);\n+\n+\t\tOAuthTokenRevocationRequest revocationRequest = new OAuthTokenRevocationRequest();\n+\t\trevocationRequest.setToken(tokenResponse.getRefresh_token());\n+\t\trevocationRequest.setToken_type_hint(TokenTypeHint.refresh_token);\n+\n+\t\t// method under test\n+\t\topenIDConnectManager.revokeToken(revocationRequest);\n+\n+\t\t// Use the refresh token to get a new access token\n+\t\t// tested in testRefreshTokenRoundTrip\n+\t\tassertThrows(IllegalArgumentException.class, () ->\n+\t\t\t\topenIDConnectManager.getTokenResponseWithRefreshToken(tokenResponse.getRefresh_token(), oauthClient.getClient_id(), null, OAUTH_ENDPOINT));\n+\n+\t}\n+\n \t@Test\n \tpublic void testAuthorizationRequestWithReservedClientID() {\n \t\tOIDCAuthorizationRequest authorizationRequest = new OIDCAuthorizationRequest();\n \t\tauthorizationRequest.setClientId(AuthorizationConstants.SYNAPSE_OAUTH_CLIENT_ID);\n \n-\t\tassertThrows(IllegalArgumentException.class, ()->openIDConnectManager.authorizeClient(userInfo, authorizationRequest));\n+\t\tassertThrows(IllegalArgumentException.class, () -> openIDConnectManager.authorizeClient(userInfo, authorizationRequest));\n+\t}\n+\n+\t@Test\n+\tpublic void testRefreshTokenIdClaimInIdToken() {\n+\t\t/*\n+\t\t The refresh_token_id claim is used to add a refresh token ID to the access token.\n+\t\t The client can request this claim for the ID token, but nothing should happen.\n+\t\t */\n+\n+\t\t// Verify the client\n+\t\toauthClient = oauthClientManager.updateOpenIDConnectClientVerifiedStatus(adminUserInfo, oauthClient.getClient_id(), oauthClient.getEtag(), true);\n+\n+\t\tOIDCAuthorizationRequest authorizationRequest = new OIDCAuthorizationRequest();\n+\t\tauthorizationRequest.setClientId(oauthClient.getClient_id());\n+\t\tauthorizationRequest.setRedirectUri(oauthClient.getRedirect_uris().get(0));\n+\t\tauthorizationRequest.setScope(OAuthScope.openid.name() + \" \" + OAuthScope.offline_access.name());\n+\t\tauthorizationRequest.setResponseType(OAuthResponseType.code);\n+\t\tMap<String, OIDCClaimsRequestDetails> claimsToRequest = new HashMap<>();\n+\t\tclaimsToRequest.put(OIDCClaimName.email.name(), null);\n+\t\tclaimsToRequest.put(OIDCClaimName.refresh_token_id.name(), null); // !!\n+\t\tOIDCClaimsRequest claimsRequest = new OIDCClaimsRequest();\n+\t\tclaimsRequest.setId_token(claimsToRequest);\n+\t\tclaimsRequest.setUserinfo(claimsToRequest);\n+\t\tauthorizationRequest.setClaims(claimsRequest);\n+\n+\t\t// tested in testAuthorizationCodeRoundTrip\n+\t\tOAuthAuthorizationResponse authResponse = openIDConnectManager.\n+\t\t\t\tauthorizeClient(userInfo, authorizationRequest);\n+\n+\t\t// method under test\n+\t\tOIDCTokenResponse tokenResponse =\n+\t\t\t\topenIDConnectManager.getTokenResponseWithAuthorizationCode(authResponse.getAccess_code(),\n+\t\t\t\t\t\toauthClient.getClient_id(), oauthClient.getRedirect_uris().get(0), OAUTH_ENDPOINT);\n+\n+\t\t// Check the ID token\n+\t\toidcTokenHelper.validateJWT(tokenResponse.getId_token());\n+\t\tClaims idTokenClaims = oidcTokenHelper.parseJWT(tokenResponse.getId_token()).getBody();\n+\t\tassertTrue(idTokenClaims.containsKey(OIDCClaimName.email.name()));\n+\t\tassertFalse(idTokenClaims.containsKey(OIDCClaimName.refresh_token_id.name()));", "originalCommit": "203cecc68e8a9b39e4daa4e4c67fec54c54e33b5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "01ee6cc122388e031376b61e3b17a9c07e97c389", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/01ee6cc122388e031376b61e3b17a9c07e97c389", "message": "Remove accidental file change", "committedDate": "2020-06-17T15:58:39Z", "type": "commit"}, {"oid": "048c87456b5d23295cc861b56c1d6e732dac8165", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/048c87456b5d23295cc861b56c1d6e732dac8165", "message": "Code review changes from #4088", "committedDate": "2020-06-17T16:34:34Z", "type": "commit"}, {"oid": "07c8ea4fccb7981d55e2307d9bff23565fb1c8d8", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/07c8ea4fccb7981d55e2307d9bff23565fb1c8d8", "message": "Wrong null check removed", "committedDate": "2020-06-17T16:37:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTcxNjE4MA==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4088#discussion_r441716180", "bodyText": "let's keep the test!", "author": "brucehoff", "createdAt": "2020-06-17T17:39:03Z", "path": "services/repository-managers/src/test/java/org/sagebionetworks/repo/manager/oauth/OpenIDConnectManagerImplAutowiredTest.java", "diffHunk": "@@ -104,56 +118,245 @@ public void tearDown() throws Exception {\n \t\t}\n \t}\n \n+\tprivate static OIDCAuthorizationRequest createAuthorizationRequest(OAuthClient client) {\n+\t\tOIDCAuthorizationRequest authorizationRequest = new OIDCAuthorizationRequest();\n+\t\tauthorizationRequest.setClientId(client.getClient_id());\n+\t\tauthorizationRequest.setRedirectUri(client.getRedirect_uris().get(0));\n+\t\tauthorizationRequest.setScope(OAuthScope.openid.name() + \" \" + OAuthScope.offline_access.name());\n+\t\tauthorizationRequest.setResponseType(OAuthResponseType.code);\n+\t\tMap<String, OIDCClaimsRequestDetails> claimsToRequest = new HashMap<>();\n+\t\tOIDCClaimsRequestDetails teamClaimRequestDetails = new OIDCClaimsRequestDetails();\n+\t\tteamClaimRequestDetails.setValues(Collections.singletonList(\"2\"));\n+\t\tclaimsToRequest.put(OIDCClaimName.team.name(), teamClaimRequestDetails);\n+\t\tclaimsToRequest.put(OIDCClaimName.refresh_token_id.name(), null);\n+\t\tOIDCClaimsRequest claimsRequest = new OIDCClaimsRequest();\n+\t\tclaimsRequest.setId_token(claimsToRequest);\n+\t\tclaimsRequest.setUserinfo(claimsToRequest);\n+\t\tauthorizationRequest.setClaims(claimsRequest);\n+\t\treturn authorizationRequest;\n+\t}\n+\n \t// the business logic is tested in detail in the unit tests.  This just does a basic authorization round-trip.\n \t@Test\n-\tpublic void testAuthorizationRoundTrip() throws Exception {\t\t\n+\tpublic void testAuthorizationCodeRoundTrip() throws Exception {\n \n \t\t// Verify the client\n \t\toauthClient = oauthClientManager.updateOpenIDConnectClientVerifiedStatus(adminUserInfo, oauthClient.getClient_id(), oauthClient.getEtag(), true);\n-\t\t\n-\t\tOIDCAuthorizationRequest authorizationRequest = new OIDCAuthorizationRequest();\n-\t\tauthorizationRequest.setClientId(oauthClient.getClient_id());\n-\t\tauthorizationRequest.setRedirectUri(oauthClient.getRedirect_uris().get(0));\n-\t\tauthorizationRequest.setScope(OAuthScope.openid.name());\n-\t\tauthorizationRequest.setResponseType(OAuthResponseType.code);\n-\t\tauthorizationRequest.setClaims(\"{\\\"id_token\\\":{\\\"team\\\":{\\\"values\\\":[\\\"2\\\"]}},\\\"userinfo\\\":{\\\"team\\\":{\\\"values\\\":[\\\"2\\\"]}}}\");\n-\t\t\t\t\n+\n+\t\tOIDCAuthorizationRequest authorizationRequest = createAuthorizationRequest(oauthClient);\n+\n \t\t// method under test\n-\t\tOIDCAuthorizationRequestDescription description = \n+\t\tOIDCAuthorizationRequestDescription description =\n \t\t\t\topenIDConnectManager.getAuthenticationRequestDescription(authorizationRequest);\n-\t\t\n+\n \t\tassertNotNull(description);\n-\t\t\n+\n \t\t// method under test\n \t\tOAuthAuthorizationResponse authResponse = openIDConnectManager.\n \t\t\t\tauthorizeClient(userInfo, authorizationRequest);\n-\t\t\n+\n \t\tassertNotNull(authResponse.getAccess_code());\n-\t\t\n+\n \t\t// method under test\n-\t\tOIDCTokenResponse tokenResponse = \n-\t\t\t\topenIDConnectManager.getAccessToken(authResponse.getAccess_code(), \n+\t\tOIDCTokenResponse tokenResponse =\n+\t\t\t\topenIDConnectManager.generateTokenResponseWithAuthorizationCode(authResponse.getAccess_code(),\n \t\t\t\t\t\toauthClient.getClient_id(), oauthClient.getRedirect_uris().get(0), OAUTH_ENDPOINT);\n-\t\t\n-\t\t\n+\n+\n \t\tassertNotNull(tokenResponse.getAccess_token());\n \t\tassertNotNull(tokenResponse.getId_token());\n-\t\t\n+\t\tassertNotNull(tokenResponse.getRefresh_token());\n+\n \t\toidcTokenHelper.validateJWT(tokenResponse.getId_token());\n-\t\t\n+\n \t\t// method under test\n-\t\tJWTWrapper oidcUserInfo = (JWTWrapper)openIDConnectManager.getUserInfo(tokenResponse.getAccess_token(), OAUTH_ENDPOINT);\n-\t\t\n+\t\tJWTWrapper oidcUserInfo = (JWTWrapper) openIDConnectManager.getUserInfo(tokenResponse.getAccess_token(), OAUTH_ENDPOINT);\n+\n \t\toidcTokenHelper.validateJWT(oidcUserInfo.getJwt());\n-\t\t\n+\n+\t}\n+\n+\t@Test\n+\tpublic void testRefreshTokenRoundTrip() throws Exception {\n+\t\t// Verify the client\n+\t\toauthClient = oauthClientManager.updateOpenIDConnectClientVerifiedStatus(adminUserInfo, oauthClient.getClient_id(), oauthClient.getEtag(), true);\n+\n+\t\tOIDCAuthorizationRequest authorizationRequest = createAuthorizationRequest(oauthClient);\n+\n+\t\t// tested in testAuthorizationCodeRoundTrip\n+\t\tOAuthAuthorizationResponse authResponse = openIDConnectManager.\n+\t\t\t\tauthorizeClient(userInfo, authorizationRequest);\n+\n+\t\t// tested in testAuthorizationCodeRoundTrip\n+\t\tOIDCTokenResponse tokenResponse =\n+\t\t\t\topenIDConnectManager.generateTokenResponseWithAuthorizationCode(authResponse.getAccess_code(),\n+\t\t\t\t\t\toauthClient.getClient_id(), oauthClient.getRedirect_uris().get(0), OAUTH_ENDPOINT);\n+\n+\t\t// Use the refresh token to get a new access token\n+\t\t// method under test\n+\t\tOIDCTokenResponse newTokenResponse =\n+\t\t\t\topenIDConnectManager.generateTokenResponseWithRefreshToken(tokenResponse.getRefresh_token(), oauthClient.getClient_id(), null, OAUTH_ENDPOINT);\n+\n+\t\tassertNotNull(newTokenResponse.getAccess_token());\n+\t\tassertNotEquals(tokenResponse.getAccess_token(), newTokenResponse.getAccess_token());\n+\t\tassertNotNull(newTokenResponse.getId_token());\n+\t\tassertNotEquals(tokenResponse.getId_token(), newTokenResponse.getId_token());\n+\t\tassertNotNull(newTokenResponse.getRefresh_token());\n+\t\tassertNotEquals(tokenResponse.getRefresh_token(), newTokenResponse.getRefresh_token());\n+\n+\t\toidcTokenHelper.validateJWT(newTokenResponse.getId_token());\n+\n+\t\t// method under test\n+\t\tJWTWrapper oidcUserInfo = (JWTWrapper) openIDConnectManager.getUserInfo(newTokenResponse.getAccess_token(), OAUTH_ENDPOINT);\n+\n+\t\toidcTokenHelper.validateJWT(oidcUserInfo.getJwt());\n+\n+\t\t// Lastly, we requested the refresh_token_id claim, but we test that this claim doesn't not appear in the ID token or userinfo (because it doesn't make sense)\n+\t\tClaims idTokenClaims = oidcTokenHelper.parseJWT(tokenResponse.getId_token()).getBody();\n+\t\tassertFalse(idTokenClaims.containsKey(OIDCClaimName.refresh_token_id.name()));\n+\n+\n+\t\tClaims userInfoClaims = oidcTokenHelper.parseJWT(oidcUserInfo.getJwt()).getBody();\n+\t\tassertFalse(userInfoClaims.containsKey(OIDCClaimName.refresh_token_id.name()));\n+\n \t}\n-\t\n+\n+\t@Test\n+\tpublic void testRevokedRefreshToken() throws Exception {\n+\t\t// Verify the client\n+\t\toauthClient = oauthClientManager.updateOpenIDConnectClientVerifiedStatus(adminUserInfo, oauthClient.getClient_id(), oauthClient.getEtag(), true);\n+\n+\t\tOIDCAuthorizationRequest authorizationRequest = createAuthorizationRequest(oauthClient);\n+\n+\t\t// tested in testAuthorizationCodeRoundTrip\n+\t\tOAuthAuthorizationResponse authResponse = openIDConnectManager.\n+\t\t\t\tauthorizeClient(userInfo, authorizationRequest);\n+\n+\t\t// tested in testAuthorizationCodeRoundTrip\n+\t\tOIDCTokenResponse tokenResponse =\n+\t\t\t\topenIDConnectManager.generateTokenResponseWithAuthorizationCode(authResponse.getAccess_code(),\n+\t\t\t\t\t\toauthClient.getClient_id(), oauthClient.getRedirect_uris().get(0), OAUTH_ENDPOINT);\n+\n+\t\tOAuthTokenRevocationRequest revocationRequest = new OAuthTokenRevocationRequest();\n+\t\trevocationRequest.setToken(tokenResponse.getRefresh_token());\n+\t\trevocationRequest.setToken_type_hint(TokenTypeHint.refresh_token);\n+\n+\t\t// method under test\n+\t\topenIDConnectManager.revokeToken(oauthClient.getClient_id(), revocationRequest);\n+\n+\t\t// Use the refresh token to get a new access token\n+\t\t// tested in testRefreshTokenRoundTrip\n+\t\tassertThrows(IllegalArgumentException.class, () ->\n+\t\t\t\topenIDConnectManager.generateTokenResponseWithRefreshToken(tokenResponse.getRefresh_token(), oauthClient.getClient_id(), null, OAUTH_ENDPOINT));\n+\n+\t}\n+\n \t@Test\n \tpublic void testAuthorizationRequestWithReservedClientID() {\n \t\tOIDCAuthorizationRequest authorizationRequest = new OIDCAuthorizationRequest();\n \t\tauthorizationRequest.setClientId(AuthorizationConstants.SYNAPSE_OAUTH_CLIENT_ID);\n \n-\t\tassertThrows(IllegalArgumentException.class, ()->openIDConnectManager.authorizeClient(userInfo, authorizationRequest));\n+\t\tassertThrows(IllegalArgumentException.class, () -> openIDConnectManager.authorizeClient(userInfo, authorizationRequest));\n+\t}\n+\n+\t@Test\n+\tpublic void testRevokeAccessToken_invalidJwt() {\n+\t\tOAuthTokenRevocationRequest revocationRequest = new OAuthTokenRevocationRequest();\n+\t\trevocationRequest.setToken(\"not a JWT\");\n+\t\trevocationRequest.setToken_type_hint(TokenTypeHint.access_token);\n+\n+\t\tassertThrows(IllegalArgumentException.class, () -> openIDConnectManager.revokeToken(oauthClient.getClient_id(), revocationRequest));\n+\t}\n+\n+\t@Test\n+\tpublic void testGetTokenResponseWithRefreshTokenRollBackOnInvalidScopeRequest() {\n+\t\t/*\n+\t\t Using a refresh token should force the refresh token to rotate, so the old token no longer works.\n+\t\t One exception to this rule is if the client makes an invalid scope request, the refresh token rotation\n+\t\t should be rolled back.\n+\t\t */\n+\n+\t\t//  Verify the client\n+\t\toauthClient = oauthClientManager.updateOpenIDConnectClientVerifiedStatus(adminUserInfo, oauthClient.getClient_id(), oauthClient.getEtag(), true);\n+\n+\t\tOIDCAuthorizationRequest authorizationRequest = new OIDCAuthorizationRequest();\n+\t\tauthorizationRequest.setClientId(oauthClient.getClient_id());\n+\t\tauthorizationRequest.setRedirectUri(oauthClient.getRedirect_uris().get(0));\n+\t\tauthorizationRequest.setScope(OAuthScope.view.name() + \" \" + OAuthScope.offline_access.name());\n+\t\tauthorizationRequest.setResponseType(OAuthResponseType.code);\n+\n+\t\t// tested in testAuthorizationCodeRoundTrip\n+\t\tOAuthAuthorizationResponse authResponse = openIDConnectManager.\n+\t\t\t\tauthorizeClient(userInfo, authorizationRequest);\n+\n+\t\t// tested in testAuthorizationCodeRoundTrip\n+\t\tOIDCTokenResponse tokenResponse =\n+\t\t\t\topenIDConnectManager.generateTokenResponseWithAuthorizationCode(authResponse.getAccess_code(),\n+\t\t\t\t\t\toauthClient.getClient_id(), oauthClient.getRedirect_uris().get(0), OAUTH_ENDPOINT);\n+\n+\t\t// Try to use the refresh token to get a new access token, asking for a different scope than was originally granted\n+\t\t// method under test\n+\t\tassertThrows(IllegalArgumentException.class, () ->\n+\t\t\t\topenIDConnectManager.generateTokenResponseWithRefreshToken(tokenResponse.getRefresh_token(), oauthClient.getClient_id(), OAuthScope.download.name(), OAUTH_ENDPOINT)\n+\t\t);\n+\n+\t\t// Calling again with valid scope will only work if the refresh token was not rotated\n+\t\tOIDCTokenResponse newTokenResponse =\n+\t\t\t\topenIDConnectManager.generateTokenResponseWithRefreshToken(tokenResponse.getRefresh_token(), oauthClient.getClient_id(), \"\", OAUTH_ENDPOINT);\n+\n+\t\tassertNotNull(newTokenResponse);\n \t}\n \n+\n+\t@TemporaryCode(author = \"nickgrosenbacher\", comment = \"Ensures schema-to-pojo can parse strings that map to OIDCClaimsRequest\")", "originalCommit": "07c8ea4fccb7981d55e2307d9bff23565fb1c8d8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTcyODM0NQ==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4088#discussion_r441728345", "bodyText": "please remove claims as a request parameter to OpenIDController.getTokenResponse after double checking that the spec' does not require it.", "author": "brucehoff", "createdAt": "2020-06-17T17:59:15Z", "path": "services/repository-managers/src/test/java/org/sagebionetworks/repo/manager/oauth/OpenIDConnectManagerImplUnitTest.java", "diffHunk": "@@ -808,18 +898,217 @@ public void testGetAccessToken_noOpenIdScope() {\n \t}\n \t\n \t@Test\n-\tpublic void testGetAccessToken_clientUnverified() {\n+\tpublic void testGetTokenResponseWithAuthorizationCode_clientUnverified() {\n \t\tString code = \"Some code\";\n \t\t\n \t\twhen(mockOauthClientDao.isOauthClientVerified(OAUTH_CLIENT_ID)).thenReturn(false);\n \t\t\n \t\tassertThrows(OAuthClientNotVerifiedException.class, () -> {\n \t\t\t// method under test\n-\t\t\topenIDConnectManagerImpl.getAccessToken(code, OAUTH_CLIENT_ID, REDIRCT_URIS.get(0), OAUTH_ENDPOINT);\n+\t\t\topenIDConnectManagerImpl.generateTokenResponseWithAuthorizationCode(code, OAUTH_CLIENT_ID, REDIRCT_URIS.get(0), OAUTH_ENDPOINT);\n \t\t});\n \t\t\n \t\tverify(mockOauthClientDao).isOauthClientVerified(OAUTH_CLIENT_ID);\n-\t\t\n+\t}\n+\n+\tprivate OAuthRefreshTokenAndMetadata createRotatedToken() {\n+\t\tOAuthRefreshTokenAndMetadata refreshToken = new OAuthRefreshTokenAndMetadata();\n+\t\trefreshToken.setRefreshToken(\"new refresh token\");\n+\t\trefreshToken.setMetadata(new OAuthRefreshTokenInformation());\n+\t\trefreshToken.getMetadata().setTokenId(\"1234567\");\n+\t\trefreshToken.getMetadata().setClientId(OAUTH_CLIENT_ID);\n+\t\trefreshToken.getMetadata().setPrincipalId(USER_ID);\n+\t\trefreshToken.getMetadata().setScopes(Arrays.asList(OAuthScope.openid, OAuthScope.offline_access));\n+\t\tOIDCClaimsRequest grantedClaims = new OIDCClaimsRequest();\n+\t\tMap<String, OIDCClaimsRequestDetails> claimsMap = new HashMap<>();\n+\t\tfor (OIDCClaimName claim : mockClaimProviders.keySet()) {\n+\t\t\tclaimsMap.put(claim.name(), null);\n+\t\t}\n+\t\tgrantedClaims.setUserinfo(claimsMap);\n+\t\tgrantedClaims.setId_token(claimsMap);\n+\t\trefreshToken.getMetadata().setClaims(grantedClaims);\n+\t\treturn refreshToken;\n+\t}\n+\n+\t@Test\n+\tpublic void testGetTokenResponseWithRefreshToken_clientUnverified() {\n+\t\tString refreshToken = \"some-refresh-token\";\n+\n+\t\twhen(mockOauthClientDao.isOauthClientVerified(OAUTH_CLIENT_ID)).thenReturn(false);\n+\n+\t\tassertThrows(OAuthClientNotVerifiedException.class, () -> {\n+\t\t\t// method under test\n+\t\t\topenIDConnectManagerImpl.generateTokenResponseWithRefreshToken(refreshToken, OAUTH_CLIENT_ID, null, OAUTH_ENDPOINT);\n+\t\t});\n+\n+\t\tverify(mockOauthClientDao).isOauthClientVerified(OAUTH_CLIENT_ID);\n+\t}\n+\n+\n+\t@Test\n+\tpublic void testGetTokenResponseWithRefreshToken() {\n+\t\twhen(mockOauthClientDao.isOauthClientVerified(OAUTH_CLIENT_ID)).thenReturn(true);\n+\t\twhen(mockOauthClientDao.getSectorIdentifierSecretForClient(OAUTH_CLIENT_ID)).thenReturn(clientSpecificEncodingSecret);\n+\t\twhen(mockClock.currentTimeMillis()).thenReturn(System.currentTimeMillis());\n+\t\twhen(mockNotificationEmailDao.getNotificationEmailForPrincipal(USER_ID_LONG)).thenReturn(EMAIL);\n+\t\twhen(mockUserProfileManager.getCurrentVerificationSubmission(USER_ID_LONG)).thenReturn(verificationSubmission);\n+\n+\t\t// This will be the new token and metadata\n+\t\tOAuthRefreshTokenAndMetadata expectedRefreshTokenAndId = createRotatedToken();\n+\t\tDate initalAuthzOn = new Date(System.currentTimeMillis() - 1000 * 60 * 60 * 24);\n+\t\texpectedRefreshTokenAndId.getMetadata().setAuthorizedOn(initalAuthzOn);\n+\n+\t\tString refreshToken = \"pre-generated refresh token\";\n+\t\twhen(oauthRefreshTokenManager.rotateRefreshToken(refreshToken)).thenReturn(expectedRefreshTokenAndId);\n+\n+\n+\t\tString expectedIdToken = \"ID-TOKEN\";\n+\t\twhen(oidcTokenHelper.createOIDCIdToken(eq(OAUTH_ENDPOINT), eq(ppid), eq(OAUTH_CLIENT_ID), anyLong(),\n+\t\t\t\tisNull(), eq(initalAuthzOn), anyString(), userInfoCaptor.capture())).thenReturn(expectedIdToken);\n+\n+\t\tString expectedAccessToken = \"ACCESS-TOKEN\";\n+\t\twhen(oidcTokenHelper.createOIDCaccessToken(eq(OAUTH_ENDPOINT), eq(ppid), eq(OAUTH_CLIENT_ID), anyLong(),\n+\t\t\t\teq(initalAuthzOn), eq(expectedRefreshTokenAndId.getMetadata().getTokenId()), anyString(), scopesCaptor.capture(), claimsCaptor.capture())).thenReturn(expectedAccessToken);\n+\n+\t\tString scope = \"openid offline_access\";\n+\t\t// elsewhere we test that we correctly build up the requested user-info\n+\t\t// here we just spot check a few fields to make sure everything's wired up\n+\n+\t\t// method under test\n+\t\tOIDCTokenResponse tokenResponse = openIDConnectManagerImpl.generateTokenResponseWithRefreshToken(refreshToken, OAUTH_CLIENT_ID, scope, OAUTH_ENDPOINT);\n+\n+\t\t// verifying the mock token indirectly verifies all param's were correctly passed to oidcTokenHelper.createOIDCIdToken()\n+\t\tassertEquals(expectedIdToken, tokenResponse.getId_token());\n+\n+\t\t// just spot check a few fields to make sure everything's wired up\n+\t\tMap<OIDCClaimName, Object> userInfo = userInfoCaptor.getValue();\n+\t\tassertEquals(EMAIL, userInfo.get(OIDCClaimName.email));\n+\t\tassertTrue((Boolean)userInfo.get(OIDCClaimName.email_verified));\n+\t\tassertEquals(USER_ID, userInfo.get(OIDCClaimName.userid));\n+\n+\t\tassertEquals(expectedAccessToken, tokenResponse.getAccess_token());\n+\t\tassertEquals(Arrays.asList(OAuthScope.openid, OAuthScope.offline_access), scopesCaptor.getValue());\n+\t\tfor (OIDCClaimName claimName : mockClaimProviders.keySet()) {\n+\t\t\tassertTrue(claimsCaptor.getValue().containsKey(claimName));\n+\t\t\tassertNull(claimsCaptor.getValue().get(claimName));\n+\t\t}\n+\n+\t\tassertEquals(expectedRefreshTokenAndId.getRefreshToken(), tokenResponse.getRefresh_token());\n+\t}\n+\n+\n+\t@Test\n+\tpublic void testGetTokenResponseWithRefreshToken_invalidOrExpiredRefreshToken() {\n+\t\twhen(mockOauthClientDao.isOauthClientVerified(OAUTH_CLIENT_ID)).thenReturn(true);\n+\n+\t\t// Just check that the IllegalArgumentException passes through\n+\t\tString refreshToken = \"some-refresh-token\";\n+\t\twhen(oauthRefreshTokenManager.rotateRefreshToken(refreshToken)).thenThrow(new IllegalArgumentException());\n+\t\t// Call under test\n+\t\tassertThrows(IllegalArgumentException.class, () ->\n+\t\t\t\topenIDConnectManagerImpl.generateTokenResponseWithRefreshToken(refreshToken, OAUTH_CLIENT_ID, \"offline_access\", OAUTH_ENDPOINT));\n+\t}\n+\n+\t@Test\n+\tpublic void testGetTokenResponseWithRefreshToken_exceedingScope() {\n+\t\twhen(mockOauthClientDao.isOauthClientVerified(OAUTH_CLIENT_ID)).thenReturn(true);\n+\n+\t\t// This will be the new token and metadata\n+\t\tOAuthRefreshTokenAndMetadata expectedRefreshTokenAndId = createRotatedToken();\n+\n+\t\tString refreshToken = \"pre-generated refresh token\";\n+\t\twhen(oauthRefreshTokenManager.rotateRefreshToken(refreshToken)).thenReturn(expectedRefreshTokenAndId);\n+\n+\t\tString scope = \"openid offline_access authorize\"; // Authorize was not previously granted\n+\n+\t\t// method under test\n+\t\tassertThrows(IllegalArgumentException.class, () -> openIDConnectManagerImpl.generateTokenResponseWithRefreshToken(refreshToken, OAUTH_CLIENT_ID, scope, OAUTH_ENDPOINT));\n+\t}\n+\n+\t@Test\n+\tpublic void testGetTokenResponseWithRefreshToken_noOpenIdScope() {\n+\t\twhen(mockOauthClientDao.isOauthClientVerified(OAUTH_CLIENT_ID)).thenReturn(true);\n+\t\twhen(mockOauthClientDao.getSectorIdentifierSecretForClient(OAUTH_CLIENT_ID)).thenReturn(clientSpecificEncodingSecret);\n+\t\twhen(mockClock.currentTimeMillis()).thenReturn(System.currentTimeMillis());\n+\n+\t\t// This will be the new token and metadata\n+\t\tOAuthRefreshTokenAndMetadata expectedRefreshTokenAndId = createRotatedToken();\n+\t\tDate initalAuthzOn = new Date(System.currentTimeMillis() - 1000 * 60 * 60 * 24);\n+\t\texpectedRefreshTokenAndId.getMetadata().setAuthorizedOn(initalAuthzOn);\n+\n+\n+\t\tString refreshToken = \"pre-generated refresh token\";\n+\t\twhen(oauthRefreshTokenManager.rotateRefreshToken(refreshToken)).thenReturn(expectedRefreshTokenAndId);\n+\n+\t\tString expectedAccessToken = \"ACCESS-TOKEN\";\n+\t\twhen(oidcTokenHelper.createOIDCaccessToken(eq(OAUTH_ENDPOINT), eq(ppid), eq(OAUTH_CLIENT_ID), anyLong(),\n+\t\t\t\teq(initalAuthzOn), eq(expectedRefreshTokenAndId.getMetadata().getTokenId()), anyString(), scopesCaptor.capture(), claimsCaptor.capture())).thenReturn(expectedAccessToken);\n+\n+\t\tString scope = \"offline_access\"; // Do not request openid!\n+\t\t// elsewhere we test that we correctly build up the requested user-info\n+\t\t// here we just spot check a few fields to make sure everything's wired up\n+\n+\t\t// method under test\n+\t\tOIDCTokenResponse tokenResponse = openIDConnectManagerImpl.generateTokenResponseWithRefreshToken(refreshToken, OAUTH_CLIENT_ID, scope, OAUTH_ENDPOINT);\n+\n+\t\t// verifying the mock token indirectly verifies all param's were correctly passed to oidcTokenHelper.createOIDCIdToken()\n+\t\tassertNull(tokenResponse.getId_token());\n+\n+\t\tassertEquals(expectedAccessToken, tokenResponse.getAccess_token());\n+\t\tassertEquals(Collections.singletonList(OAuthScope.offline_access), scopesCaptor.getValue());\n+\t\tassertEquals(expectedRefreshTokenAndId.getRefreshToken(), tokenResponse.getRefresh_token());\n+\t}\n+\n+\t@Test\n+\tpublic void testGetTokenResponseWithRefreshToken_nullOrEmptyScope() {", "originalCommit": "07c8ea4fccb7981d55e2307d9bff23565fb1c8d8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "fad5071564fb4c17ad23e9a93946a31aeeb702ea", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/fad5071564fb4c17ad23e9a93946a31aeeb702ea", "message": "Remove claims from token endpoint (unused/not in spec)", "committedDate": "2020-06-17T18:14:04Z", "type": "commit"}, {"oid": "e29a5d52978a53027b8426a4134519cbfd47bf36", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/e29a5d52978a53027b8426a4134519cbfd47bf36", "message": "Remove TemporaryCode annotation from test", "committedDate": "2020-06-17T18:15:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc5ODU1NA==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4088#discussion_r441798554", "bodyText": "clients->client", "author": "brucehoff", "createdAt": "2020-06-17T19:58:01Z", "path": "services/repository/src/main/java/org/sagebionetworks/auth/controller/OpenIDConnectController.java", "diffHunk": "@@ -356,4 +364,146 @@ Object getUserInfoPOST(\n \t\treturn serviceProvider.getOpenIDConnectService().getUserInfo(accessToken, getEndpoint(uriComponentsBuilder));\n \t}\n \n+\t/**\n+\t * Get a paginated list of the OAuth 2 clients that currently have active refresh tokens that grant access to the user's\n+\t * Synapse identity and/or resources. OAuth 2.0 clients that have no active refresh tokens will not appear in this list.\n+\t *\n+\t * @throws NotFoundException\n+\t * @throws OAuthClientNotVerifiedException if the client is not verified\n+\t */\n+\t@RequiredScope({view})\n+\t@ResponseStatus(HttpStatus.OK)\n+\t@RequestMapping(value = UrlHelpers.OAUTH_2_AUDIT_CLIENTS, method = RequestMethod.GET)\n+\tpublic @ResponseBody\n+\tOAuthClientAuthorizationHistoryList getGrantedClientsForUser(\n+\t\t\t@RequestParam(value = AuthorizationConstants.USER_ID_PARAM) Long userId,\n+\t\t\t@RequestParam(value = UrlHelpers.NEXT_PAGE_TOKEN_PARAM, required=false) String nextPageToken\n+\t) throws NotFoundException {\n+\t\treturn serviceProvider.getOpenIDConnectService().getClientAuthorizationHistory(userId, nextPageToken);\n+\t}\n+\n+\t/**\n+\t * Get a paginated list of metadata about refresh tokens granted to a particular OAuth 2 clients on", "originalCommit": "e29a5d52978a53027b8426a4134519cbfd47bf36", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc5OTY2MQ==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4088#discussion_r441799661", "bodyText": "Users->Clients", "author": "brucehoff", "createdAt": "2020-06-17T20:00:21Z", "path": "services/repository/src/main/java/org/sagebionetworks/auth/controller/OpenIDConnectController.java", "diffHunk": "@@ -356,4 +364,146 @@ Object getUserInfoPOST(\n \t\treturn serviceProvider.getOpenIDConnectService().getUserInfo(accessToken, getEndpoint(uriComponentsBuilder));\n \t}\n \n+\t/**\n+\t * Get a paginated list of the OAuth 2 clients that currently have active refresh tokens that grant access to the user's\n+\t * Synapse identity and/or resources. OAuth 2.0 clients that have no active refresh tokens will not appear in this list.\n+\t *\n+\t * @throws NotFoundException\n+\t * @throws OAuthClientNotVerifiedException if the client is not verified\n+\t */\n+\t@RequiredScope({view})\n+\t@ResponseStatus(HttpStatus.OK)\n+\t@RequestMapping(value = UrlHelpers.OAUTH_2_AUDIT_CLIENTS, method = RequestMethod.GET)\n+\tpublic @ResponseBody\n+\tOAuthClientAuthorizationHistoryList getGrantedClientsForUser(\n+\t\t\t@RequestParam(value = AuthorizationConstants.USER_ID_PARAM) Long userId,\n+\t\t\t@RequestParam(value = UrlHelpers.NEXT_PAGE_TOKEN_PARAM, required=false) String nextPageToken\n+\t) throws NotFoundException {\n+\t\treturn serviceProvider.getOpenIDConnectService().getClientAuthorizationHistory(userId, nextPageToken);\n+\t}\n+\n+\t/**\n+\t * Get a paginated list of metadata about refresh tokens granted to a particular OAuth 2 clients on\n+\t * behalf of the requesting user. The token itself may not be retrieved.\n+\t * Refresh tokens that have been revoked will not be included in this list.\n+\t *\n+\t * @throws NotFoundException\n+\t */\n+\t@RequiredScope({view})\n+\t@ResponseStatus(HttpStatus.OK)\n+\t@RequestMapping(value = UrlHelpers.OAUTH_2_AUDIT_CLIENT_TOKENS, method = RequestMethod.GET)\n+\tpublic @ResponseBody\n+\tOAuthRefreshTokenInformationList getGrantedTokenMetadataForUserClientPair(\n+\t\t\t@RequestParam(value = AuthorizationConstants.USER_ID_PARAM) Long userId,\n+\t\t\t@PathVariable String clientId,\n+\t\t\t@RequestParam(value = UrlHelpers.NEXT_PAGE_TOKEN_PARAM, required=false) String nextPageToken\n+\t) throws NotFoundException {\n+\t\treturn serviceProvider.getOpenIDConnectService().getTokenMetadataForGrantedClient(userId, clientId, nextPageToken);\n+\t}\n+\n+\n+\t/**\n+\t * Retrieve the metadata for an OAuth 2.0 refresh token as an authenticated Synapse user.\n+\t *\n+\t * Users that wish to retrieve OAuth 2.0 refresh token metadata should use", "originalCommit": "e29a5d52978a53027b8426a4134519cbfd47bf36", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgwMDE2Mg==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4088#discussion_r441800162", "bodyText": "@RequiredScope({})", "author": "brucehoff", "createdAt": "2020-06-17T20:01:16Z", "path": "services/repository/src/main/java/org/sagebionetworks/auth/controller/OpenIDConnectController.java", "diffHunk": "@@ -356,4 +364,146 @@ Object getUserInfoPOST(\n \t\treturn serviceProvider.getOpenIDConnectService().getUserInfo(accessToken, getEndpoint(uriComponentsBuilder));\n \t}\n \n+\t/**\n+\t * Get a paginated list of the OAuth 2 clients that currently have active refresh tokens that grant access to the user's\n+\t * Synapse identity and/or resources. OAuth 2.0 clients that have no active refresh tokens will not appear in this list.\n+\t *\n+\t * @throws NotFoundException\n+\t * @throws OAuthClientNotVerifiedException if the client is not verified\n+\t */\n+\t@RequiredScope({view})\n+\t@ResponseStatus(HttpStatus.OK)\n+\t@RequestMapping(value = UrlHelpers.OAUTH_2_AUDIT_CLIENTS, method = RequestMethod.GET)\n+\tpublic @ResponseBody\n+\tOAuthClientAuthorizationHistoryList getGrantedClientsForUser(\n+\t\t\t@RequestParam(value = AuthorizationConstants.USER_ID_PARAM) Long userId,\n+\t\t\t@RequestParam(value = UrlHelpers.NEXT_PAGE_TOKEN_PARAM, required=false) String nextPageToken\n+\t) throws NotFoundException {\n+\t\treturn serviceProvider.getOpenIDConnectService().getClientAuthorizationHistory(userId, nextPageToken);\n+\t}\n+\n+\t/**\n+\t * Get a paginated list of metadata about refresh tokens granted to a particular OAuth 2 clients on\n+\t * behalf of the requesting user. The token itself may not be retrieved.\n+\t * Refresh tokens that have been revoked will not be included in this list.\n+\t *\n+\t * @throws NotFoundException\n+\t */\n+\t@RequiredScope({view})\n+\t@ResponseStatus(HttpStatus.OK)\n+\t@RequestMapping(value = UrlHelpers.OAUTH_2_AUDIT_CLIENT_TOKENS, method = RequestMethod.GET)\n+\tpublic @ResponseBody\n+\tOAuthRefreshTokenInformationList getGrantedTokenMetadataForUserClientPair(\n+\t\t\t@RequestParam(value = AuthorizationConstants.USER_ID_PARAM) Long userId,\n+\t\t\t@PathVariable String clientId,\n+\t\t\t@RequestParam(value = UrlHelpers.NEXT_PAGE_TOKEN_PARAM, required=false) String nextPageToken\n+\t) throws NotFoundException {\n+\t\treturn serviceProvider.getOpenIDConnectService().getTokenMetadataForGrantedClient(userId, clientId, nextPageToken);\n+\t}\n+\n+\n+\t/**\n+\t * Retrieve the metadata for an OAuth 2.0 refresh token as an authenticated Synapse user.\n+\t *\n+\t * Users that wish to retrieve OAuth 2.0 refresh token metadata should use\n+\t * <a href=\"${GET.oauth2.token.tokenId.metadata}\">GET /oauth2/token/{tokenId}/metadata</a>\n+\t *\n+\t * @throws NotFoundException\n+\t */\n+\t@RequiredScope({view})\n+\t@ResponseStatus(HttpStatus.OK)\n+\t@RequestMapping(value = UrlHelpers.OAUTH_2_AUDIT_TOKENS_ID_METADATA, method = RequestMethod.GET)\n+\tpublic @ResponseBody\n+\tOAuthRefreshTokenInformation getRefreshTokenMetadataAsUser(\n+\t\t\t@RequestParam(value = AuthorizationConstants.USER_ID_PARAM) Long userId,\n+\t\t\t@PathVariable String tokenId) throws NotFoundException {\n+\t\treturn serviceProvider.getOpenIDConnectService().getRefreshTokenMetadataAsUser(userId, tokenId);\n+\t}\n+\n+\t/**\n+\t * Retrieve the metadata for an OAuth 2.0 refresh token. The request should be made as an OAuth 2.0 client using\n+\t * basic authentication.\n+\t *\n+\t * Users that wish to retrieve OAuth 2.0 refresh token metadata should use\n+\t * <a href=\"${GET.oauth2.audit.tokens.tokenId.metadata}\">GET /oauth2/audit/tokens/{tokenId}/metadata</a>\n+\t *\n+\t * @throws NotFoundException\n+\t */\n+\t@RequiredScope({view})", "originalCommit": "e29a5d52978a53027b8426a4134519cbfd47bf36", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgwMTY0MA==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4088#discussion_r441801640", "bodyText": "@RequiredScope({authorize})", "author": "brucehoff", "createdAt": "2020-06-17T20:04:15Z", "path": "services/repository/src/main/java/org/sagebionetworks/auth/controller/OpenIDConnectController.java", "diffHunk": "@@ -356,4 +364,146 @@ Object getUserInfoPOST(\n \t\treturn serviceProvider.getOpenIDConnectService().getUserInfo(accessToken, getEndpoint(uriComponentsBuilder));\n \t}\n \n+\t/**\n+\t * Get a paginated list of the OAuth 2 clients that currently have active refresh tokens that grant access to the user's\n+\t * Synapse identity and/or resources. OAuth 2.0 clients that have no active refresh tokens will not appear in this list.\n+\t *\n+\t * @throws NotFoundException\n+\t * @throws OAuthClientNotVerifiedException if the client is not verified\n+\t */\n+\t@RequiredScope({view})\n+\t@ResponseStatus(HttpStatus.OK)\n+\t@RequestMapping(value = UrlHelpers.OAUTH_2_AUDIT_CLIENTS, method = RequestMethod.GET)\n+\tpublic @ResponseBody\n+\tOAuthClientAuthorizationHistoryList getGrantedClientsForUser(\n+\t\t\t@RequestParam(value = AuthorizationConstants.USER_ID_PARAM) Long userId,\n+\t\t\t@RequestParam(value = UrlHelpers.NEXT_PAGE_TOKEN_PARAM, required=false) String nextPageToken\n+\t) throws NotFoundException {\n+\t\treturn serviceProvider.getOpenIDConnectService().getClientAuthorizationHistory(userId, nextPageToken);\n+\t}\n+\n+\t/**\n+\t * Get a paginated list of metadata about refresh tokens granted to a particular OAuth 2 clients on\n+\t * behalf of the requesting user. The token itself may not be retrieved.\n+\t * Refresh tokens that have been revoked will not be included in this list.\n+\t *\n+\t * @throws NotFoundException\n+\t */\n+\t@RequiredScope({view})\n+\t@ResponseStatus(HttpStatus.OK)\n+\t@RequestMapping(value = UrlHelpers.OAUTH_2_AUDIT_CLIENT_TOKENS, method = RequestMethod.GET)\n+\tpublic @ResponseBody\n+\tOAuthRefreshTokenInformationList getGrantedTokenMetadataForUserClientPair(\n+\t\t\t@RequestParam(value = AuthorizationConstants.USER_ID_PARAM) Long userId,\n+\t\t\t@PathVariable String clientId,\n+\t\t\t@RequestParam(value = UrlHelpers.NEXT_PAGE_TOKEN_PARAM, required=false) String nextPageToken\n+\t) throws NotFoundException {\n+\t\treturn serviceProvider.getOpenIDConnectService().getTokenMetadataForGrantedClient(userId, clientId, nextPageToken);\n+\t}\n+\n+\n+\t/**\n+\t * Retrieve the metadata for an OAuth 2.0 refresh token as an authenticated Synapse user.\n+\t *\n+\t * Users that wish to retrieve OAuth 2.0 refresh token metadata should use\n+\t * <a href=\"${GET.oauth2.token.tokenId.metadata}\">GET /oauth2/token/{tokenId}/metadata</a>\n+\t *\n+\t * @throws NotFoundException\n+\t */\n+\t@RequiredScope({view})\n+\t@ResponseStatus(HttpStatus.OK)\n+\t@RequestMapping(value = UrlHelpers.OAUTH_2_AUDIT_TOKENS_ID_METADATA, method = RequestMethod.GET)\n+\tpublic @ResponseBody\n+\tOAuthRefreshTokenInformation getRefreshTokenMetadataAsUser(\n+\t\t\t@RequestParam(value = AuthorizationConstants.USER_ID_PARAM) Long userId,\n+\t\t\t@PathVariable String tokenId) throws NotFoundException {\n+\t\treturn serviceProvider.getOpenIDConnectService().getRefreshTokenMetadataAsUser(userId, tokenId);\n+\t}\n+\n+\t/**\n+\t * Retrieve the metadata for an OAuth 2.0 refresh token. The request should be made as an OAuth 2.0 client using\n+\t * basic authentication.\n+\t *\n+\t * Users that wish to retrieve OAuth 2.0 refresh token metadata should use\n+\t * <a href=\"${GET.oauth2.audit.tokens.tokenId.metadata}\">GET /oauth2/audit/tokens/{tokenId}/metadata</a>\n+\t *\n+\t * @throws NotFoundException\n+\t */\n+\t@RequiredScope({view})\n+\t@ResponseStatus(HttpStatus.OK)\n+\t@RequestMapping(value = UrlHelpers.OAUTH_2_TOKEN_ID_METADATA, method = RequestMethod.GET)\n+\tpublic @ResponseBody\n+\tOAuthRefreshTokenInformation getRefreshTokenMetadataAsClient(\n+\t\t\t@RequestHeader(value = AuthorizationConstants.OAUTH_VERIFIED_CLIENT_ID_HEADER) String verifiedClientId,\n+\t\t\t@PathVariable String tokenId) throws NotFoundException {\n+\t\treturn serviceProvider.getOpenIDConnectService().getRefreshTokenMetadataAsClient(verifiedClientId, tokenId);\n+\t}\n+\n+\t/**\n+\t * Update the metadata for a refresh token. At this time, the only field that a user may set is the 'name' field.\n+\t *\n+\t * @throws NotFoundException\n+\t */\n+\t@RequiredScope({view, modify})\n+\t@ResponseStatus(HttpStatus.OK)\n+\t@RequestMapping(value = UrlHelpers.OAUTH_2_AUDIT_TOKENS_ID_METADATA, method = RequestMethod.PUT)\n+\tpublic @ResponseBody\n+\tOAuthRefreshTokenInformation updateRefreshTokenMetadata(\n+\t\t\t@RequestParam(value = AuthorizationConstants.USER_ID_PARAM) Long userId,\n+\t\t\t@PathVariable String tokenId,\n+\t\t\t@RequestBody OAuthRefreshTokenInformation metadata) throws NotFoundException {\n+\t\treturn serviceProvider.getOpenIDConnectService().updateRefreshTokenMetadata(userId, tokenId, metadata);\n+\t}\n+\n+\t/**\n+\t * Revoke all refresh token and their related access tokens associated with a particular client and the requesting user.\n+\t * Note that access tokens that are not associated with refresh tokens cannot be revoked.\n+\t * Users that want to revoke one refresh token should use <a href=\"${POST.oauth2.audit.tokens.tokenId.revoke}\">POST /oauth2/audit/tokens/{tokenId}/revoke</a>.\n+\t *\n+\t * Additionally, Access tokens that are not associated with a refresh token cannot be revoked.\n+\t *\n+\t * OAuth 2.0 clients wishing to revoke a refresh token should use <a href=\"${POST.oauth2.revoke}\">POST /oauth2/revoke</a>\n+\t */\n+\t@RequiredScope({view, modify, authorize})", "originalCommit": "e29a5d52978a53027b8426a4134519cbfd47bf36", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgwMjI4NQ==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4088#discussion_r441802285", "bodyText": "HttpStatus.NO_CONTENT", "author": "brucehoff", "createdAt": "2020-06-17T20:05:36Z", "path": "services/repository/src/main/java/org/sagebionetworks/auth/controller/OpenIDConnectController.java", "diffHunk": "@@ -356,4 +364,146 @@ Object getUserInfoPOST(\n \t\treturn serviceProvider.getOpenIDConnectService().getUserInfo(accessToken, getEndpoint(uriComponentsBuilder));\n \t}\n \n+\t/**\n+\t * Get a paginated list of the OAuth 2 clients that currently have active refresh tokens that grant access to the user's\n+\t * Synapse identity and/or resources. OAuth 2.0 clients that have no active refresh tokens will not appear in this list.\n+\t *\n+\t * @throws NotFoundException\n+\t * @throws OAuthClientNotVerifiedException if the client is not verified\n+\t */\n+\t@RequiredScope({view})\n+\t@ResponseStatus(HttpStatus.OK)\n+\t@RequestMapping(value = UrlHelpers.OAUTH_2_AUDIT_CLIENTS, method = RequestMethod.GET)\n+\tpublic @ResponseBody\n+\tOAuthClientAuthorizationHistoryList getGrantedClientsForUser(\n+\t\t\t@RequestParam(value = AuthorizationConstants.USER_ID_PARAM) Long userId,\n+\t\t\t@RequestParam(value = UrlHelpers.NEXT_PAGE_TOKEN_PARAM, required=false) String nextPageToken\n+\t) throws NotFoundException {\n+\t\treturn serviceProvider.getOpenIDConnectService().getClientAuthorizationHistory(userId, nextPageToken);\n+\t}\n+\n+\t/**\n+\t * Get a paginated list of metadata about refresh tokens granted to a particular OAuth 2 clients on\n+\t * behalf of the requesting user. The token itself may not be retrieved.\n+\t * Refresh tokens that have been revoked will not be included in this list.\n+\t *\n+\t * @throws NotFoundException\n+\t */\n+\t@RequiredScope({view})\n+\t@ResponseStatus(HttpStatus.OK)\n+\t@RequestMapping(value = UrlHelpers.OAUTH_2_AUDIT_CLIENT_TOKENS, method = RequestMethod.GET)\n+\tpublic @ResponseBody\n+\tOAuthRefreshTokenInformationList getGrantedTokenMetadataForUserClientPair(\n+\t\t\t@RequestParam(value = AuthorizationConstants.USER_ID_PARAM) Long userId,\n+\t\t\t@PathVariable String clientId,\n+\t\t\t@RequestParam(value = UrlHelpers.NEXT_PAGE_TOKEN_PARAM, required=false) String nextPageToken\n+\t) throws NotFoundException {\n+\t\treturn serviceProvider.getOpenIDConnectService().getTokenMetadataForGrantedClient(userId, clientId, nextPageToken);\n+\t}\n+\n+\n+\t/**\n+\t * Retrieve the metadata for an OAuth 2.0 refresh token as an authenticated Synapse user.\n+\t *\n+\t * Users that wish to retrieve OAuth 2.0 refresh token metadata should use\n+\t * <a href=\"${GET.oauth2.token.tokenId.metadata}\">GET /oauth2/token/{tokenId}/metadata</a>\n+\t *\n+\t * @throws NotFoundException\n+\t */\n+\t@RequiredScope({view})\n+\t@ResponseStatus(HttpStatus.OK)\n+\t@RequestMapping(value = UrlHelpers.OAUTH_2_AUDIT_TOKENS_ID_METADATA, method = RequestMethod.GET)\n+\tpublic @ResponseBody\n+\tOAuthRefreshTokenInformation getRefreshTokenMetadataAsUser(\n+\t\t\t@RequestParam(value = AuthorizationConstants.USER_ID_PARAM) Long userId,\n+\t\t\t@PathVariable String tokenId) throws NotFoundException {\n+\t\treturn serviceProvider.getOpenIDConnectService().getRefreshTokenMetadataAsUser(userId, tokenId);\n+\t}\n+\n+\t/**\n+\t * Retrieve the metadata for an OAuth 2.0 refresh token. The request should be made as an OAuth 2.0 client using\n+\t * basic authentication.\n+\t *\n+\t * Users that wish to retrieve OAuth 2.0 refresh token metadata should use\n+\t * <a href=\"${GET.oauth2.audit.tokens.tokenId.metadata}\">GET /oauth2/audit/tokens/{tokenId}/metadata</a>\n+\t *\n+\t * @throws NotFoundException\n+\t */\n+\t@RequiredScope({view})\n+\t@ResponseStatus(HttpStatus.OK)\n+\t@RequestMapping(value = UrlHelpers.OAUTH_2_TOKEN_ID_METADATA, method = RequestMethod.GET)\n+\tpublic @ResponseBody\n+\tOAuthRefreshTokenInformation getRefreshTokenMetadataAsClient(\n+\t\t\t@RequestHeader(value = AuthorizationConstants.OAUTH_VERIFIED_CLIENT_ID_HEADER) String verifiedClientId,\n+\t\t\t@PathVariable String tokenId) throws NotFoundException {\n+\t\treturn serviceProvider.getOpenIDConnectService().getRefreshTokenMetadataAsClient(verifiedClientId, tokenId);\n+\t}\n+\n+\t/**\n+\t * Update the metadata for a refresh token. At this time, the only field that a user may set is the 'name' field.\n+\t *\n+\t * @throws NotFoundException\n+\t */\n+\t@RequiredScope({view, modify})\n+\t@ResponseStatus(HttpStatus.OK)\n+\t@RequestMapping(value = UrlHelpers.OAUTH_2_AUDIT_TOKENS_ID_METADATA, method = RequestMethod.PUT)\n+\tpublic @ResponseBody\n+\tOAuthRefreshTokenInformation updateRefreshTokenMetadata(\n+\t\t\t@RequestParam(value = AuthorizationConstants.USER_ID_PARAM) Long userId,\n+\t\t\t@PathVariable String tokenId,\n+\t\t\t@RequestBody OAuthRefreshTokenInformation metadata) throws NotFoundException {\n+\t\treturn serviceProvider.getOpenIDConnectService().updateRefreshTokenMetadata(userId, tokenId, metadata);\n+\t}\n+\n+\t/**\n+\t * Revoke all refresh token and their related access tokens associated with a particular client and the requesting user.\n+\t * Note that access tokens that are not associated with refresh tokens cannot be revoked.\n+\t * Users that want to revoke one refresh token should use <a href=\"${POST.oauth2.audit.tokens.tokenId.revoke}\">POST /oauth2/audit/tokens/{tokenId}/revoke</a>.\n+\t *\n+\t * Additionally, Access tokens that are not associated with a refresh token cannot be revoked.\n+\t *\n+\t * OAuth 2.0 clients wishing to revoke a refresh token should use <a href=\"${POST.oauth2.revoke}\">POST /oauth2/revoke</a>\n+\t */\n+\t@RequiredScope({view, modify, authorize})\n+\t@ResponseStatus(HttpStatus.OK)", "originalCommit": "e29a5d52978a53027b8426a4134519cbfd47bf36", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgwMzg2Mw==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4088#discussion_r441803863", "bodyText": "@RequiredScope({authorize})\nHttpStatus.NO_CONTENT", "author": "brucehoff", "createdAt": "2020-06-17T20:08:51Z", "path": "services/repository/src/main/java/org/sagebionetworks/auth/controller/OpenIDConnectController.java", "diffHunk": "@@ -356,4 +364,146 @@ Object getUserInfoPOST(\n \t\treturn serviceProvider.getOpenIDConnectService().getUserInfo(accessToken, getEndpoint(uriComponentsBuilder));\n \t}\n \n+\t/**\n+\t * Get a paginated list of the OAuth 2 clients that currently have active refresh tokens that grant access to the user's\n+\t * Synapse identity and/or resources. OAuth 2.0 clients that have no active refresh tokens will not appear in this list.\n+\t *\n+\t * @throws NotFoundException\n+\t * @throws OAuthClientNotVerifiedException if the client is not verified\n+\t */\n+\t@RequiredScope({view})\n+\t@ResponseStatus(HttpStatus.OK)\n+\t@RequestMapping(value = UrlHelpers.OAUTH_2_AUDIT_CLIENTS, method = RequestMethod.GET)\n+\tpublic @ResponseBody\n+\tOAuthClientAuthorizationHistoryList getGrantedClientsForUser(\n+\t\t\t@RequestParam(value = AuthorizationConstants.USER_ID_PARAM) Long userId,\n+\t\t\t@RequestParam(value = UrlHelpers.NEXT_PAGE_TOKEN_PARAM, required=false) String nextPageToken\n+\t) throws NotFoundException {\n+\t\treturn serviceProvider.getOpenIDConnectService().getClientAuthorizationHistory(userId, nextPageToken);\n+\t}\n+\n+\t/**\n+\t * Get a paginated list of metadata about refresh tokens granted to a particular OAuth 2 clients on\n+\t * behalf of the requesting user. The token itself may not be retrieved.\n+\t * Refresh tokens that have been revoked will not be included in this list.\n+\t *\n+\t * @throws NotFoundException\n+\t */\n+\t@RequiredScope({view})\n+\t@ResponseStatus(HttpStatus.OK)\n+\t@RequestMapping(value = UrlHelpers.OAUTH_2_AUDIT_CLIENT_TOKENS, method = RequestMethod.GET)\n+\tpublic @ResponseBody\n+\tOAuthRefreshTokenInformationList getGrantedTokenMetadataForUserClientPair(\n+\t\t\t@RequestParam(value = AuthorizationConstants.USER_ID_PARAM) Long userId,\n+\t\t\t@PathVariable String clientId,\n+\t\t\t@RequestParam(value = UrlHelpers.NEXT_PAGE_TOKEN_PARAM, required=false) String nextPageToken\n+\t) throws NotFoundException {\n+\t\treturn serviceProvider.getOpenIDConnectService().getTokenMetadataForGrantedClient(userId, clientId, nextPageToken);\n+\t}\n+\n+\n+\t/**\n+\t * Retrieve the metadata for an OAuth 2.0 refresh token as an authenticated Synapse user.\n+\t *\n+\t * Users that wish to retrieve OAuth 2.0 refresh token metadata should use\n+\t * <a href=\"${GET.oauth2.token.tokenId.metadata}\">GET /oauth2/token/{tokenId}/metadata</a>\n+\t *\n+\t * @throws NotFoundException\n+\t */\n+\t@RequiredScope({view})\n+\t@ResponseStatus(HttpStatus.OK)\n+\t@RequestMapping(value = UrlHelpers.OAUTH_2_AUDIT_TOKENS_ID_METADATA, method = RequestMethod.GET)\n+\tpublic @ResponseBody\n+\tOAuthRefreshTokenInformation getRefreshTokenMetadataAsUser(\n+\t\t\t@RequestParam(value = AuthorizationConstants.USER_ID_PARAM) Long userId,\n+\t\t\t@PathVariable String tokenId) throws NotFoundException {\n+\t\treturn serviceProvider.getOpenIDConnectService().getRefreshTokenMetadataAsUser(userId, tokenId);\n+\t}\n+\n+\t/**\n+\t * Retrieve the metadata for an OAuth 2.0 refresh token. The request should be made as an OAuth 2.0 client using\n+\t * basic authentication.\n+\t *\n+\t * Users that wish to retrieve OAuth 2.0 refresh token metadata should use\n+\t * <a href=\"${GET.oauth2.audit.tokens.tokenId.metadata}\">GET /oauth2/audit/tokens/{tokenId}/metadata</a>\n+\t *\n+\t * @throws NotFoundException\n+\t */\n+\t@RequiredScope({view})\n+\t@ResponseStatus(HttpStatus.OK)\n+\t@RequestMapping(value = UrlHelpers.OAUTH_2_TOKEN_ID_METADATA, method = RequestMethod.GET)\n+\tpublic @ResponseBody\n+\tOAuthRefreshTokenInformation getRefreshTokenMetadataAsClient(\n+\t\t\t@RequestHeader(value = AuthorizationConstants.OAUTH_VERIFIED_CLIENT_ID_HEADER) String verifiedClientId,\n+\t\t\t@PathVariable String tokenId) throws NotFoundException {\n+\t\treturn serviceProvider.getOpenIDConnectService().getRefreshTokenMetadataAsClient(verifiedClientId, tokenId);\n+\t}\n+\n+\t/**\n+\t * Update the metadata for a refresh token. At this time, the only field that a user may set is the 'name' field.\n+\t *\n+\t * @throws NotFoundException\n+\t */\n+\t@RequiredScope({view, modify})\n+\t@ResponseStatus(HttpStatus.OK)\n+\t@RequestMapping(value = UrlHelpers.OAUTH_2_AUDIT_TOKENS_ID_METADATA, method = RequestMethod.PUT)\n+\tpublic @ResponseBody\n+\tOAuthRefreshTokenInformation updateRefreshTokenMetadata(\n+\t\t\t@RequestParam(value = AuthorizationConstants.USER_ID_PARAM) Long userId,\n+\t\t\t@PathVariable String tokenId,\n+\t\t\t@RequestBody OAuthRefreshTokenInformation metadata) throws NotFoundException {\n+\t\treturn serviceProvider.getOpenIDConnectService().updateRefreshTokenMetadata(userId, tokenId, metadata);\n+\t}\n+\n+\t/**\n+\t * Revoke all refresh token and their related access tokens associated with a particular client and the requesting user.\n+\t * Note that access tokens that are not associated with refresh tokens cannot be revoked.\n+\t * Users that want to revoke one refresh token should use <a href=\"${POST.oauth2.audit.tokens.tokenId.revoke}\">POST /oauth2/audit/tokens/{tokenId}/revoke</a>.\n+\t *\n+\t * Additionally, Access tokens that are not associated with a refresh token cannot be revoked.\n+\t *\n+\t * OAuth 2.0 clients wishing to revoke a refresh token should use <a href=\"${POST.oauth2.revoke}\">POST /oauth2/revoke</a>\n+\t */\n+\t@RequiredScope({view, modify, authorize})\n+\t@ResponseStatus(HttpStatus.OK)\n+\t@RequestMapping(value = UrlHelpers.OAUTH_2_AUDIT_CLIENT_REVOKE, method = RequestMethod.POST)\n+\tpublic void revokeRefreshTokensForUserClientPair(\n+\t\t\t@RequestParam(value = AuthorizationConstants.USER_ID_PARAM) Long userId,\n+\t\t\t@PathVariable String clientId) throws NotFoundException {\n+\t\tserviceProvider.getOpenIDConnectService().revokeTokensForUserClientPair(userId, clientId);\n+\t}\n+\n+\t/**\n+\t * Revoke a particular refresh token and all of its related access tokens using its unique ID. The caller must be the the user/resource owner associated with the refresh token.\n+\t * Note that a client may be in possession of more than one refresh token, so users wishing to revoke all access should use\n+\t * <a href=\"${POST.oauth2.audit.grantedClients.clientId.revoke}\">POST /oauth2/audit/grantedClients/{clientId}/revoke</a>.\n+\t *\n+\t * Additionally, Access tokens that are not associated with a refresh token cannot be revoked.\n+\t *\n+\t * OAuth 2.0 clients wishing to revoke a refresh token should use <a href=\"${POST.oauth2.revoke}\">POST /oauth2/revoke</a>\n+\t */\n+\t@RequiredScope({view, modify, authorize})", "originalCommit": "e29a5d52978a53027b8426a4134519cbfd47bf36", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgwNDI5NA==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4088#discussion_r441804294", "bodyText": "The caller must be the client for which the token was generated.", "author": "brucehoff", "createdAt": "2020-06-17T20:09:46Z", "path": "services/repository/src/main/java/org/sagebionetworks/auth/controller/OpenIDConnectController.java", "diffHunk": "@@ -356,4 +364,146 @@ Object getUserInfoPOST(\n \t\treturn serviceProvider.getOpenIDConnectService().getUserInfo(accessToken, getEndpoint(uriComponentsBuilder));\n \t}\n \n+\t/**\n+\t * Get a paginated list of the OAuth 2 clients that currently have active refresh tokens that grant access to the user's\n+\t * Synapse identity and/or resources. OAuth 2.0 clients that have no active refresh tokens will not appear in this list.\n+\t *\n+\t * @throws NotFoundException\n+\t * @throws OAuthClientNotVerifiedException if the client is not verified\n+\t */\n+\t@RequiredScope({view})\n+\t@ResponseStatus(HttpStatus.OK)\n+\t@RequestMapping(value = UrlHelpers.OAUTH_2_AUDIT_CLIENTS, method = RequestMethod.GET)\n+\tpublic @ResponseBody\n+\tOAuthClientAuthorizationHistoryList getGrantedClientsForUser(\n+\t\t\t@RequestParam(value = AuthorizationConstants.USER_ID_PARAM) Long userId,\n+\t\t\t@RequestParam(value = UrlHelpers.NEXT_PAGE_TOKEN_PARAM, required=false) String nextPageToken\n+\t) throws NotFoundException {\n+\t\treturn serviceProvider.getOpenIDConnectService().getClientAuthorizationHistory(userId, nextPageToken);\n+\t}\n+\n+\t/**\n+\t * Get a paginated list of metadata about refresh tokens granted to a particular OAuth 2 clients on\n+\t * behalf of the requesting user. The token itself may not be retrieved.\n+\t * Refresh tokens that have been revoked will not be included in this list.\n+\t *\n+\t * @throws NotFoundException\n+\t */\n+\t@RequiredScope({view})\n+\t@ResponseStatus(HttpStatus.OK)\n+\t@RequestMapping(value = UrlHelpers.OAUTH_2_AUDIT_CLIENT_TOKENS, method = RequestMethod.GET)\n+\tpublic @ResponseBody\n+\tOAuthRefreshTokenInformationList getGrantedTokenMetadataForUserClientPair(\n+\t\t\t@RequestParam(value = AuthorizationConstants.USER_ID_PARAM) Long userId,\n+\t\t\t@PathVariable String clientId,\n+\t\t\t@RequestParam(value = UrlHelpers.NEXT_PAGE_TOKEN_PARAM, required=false) String nextPageToken\n+\t) throws NotFoundException {\n+\t\treturn serviceProvider.getOpenIDConnectService().getTokenMetadataForGrantedClient(userId, clientId, nextPageToken);\n+\t}\n+\n+\n+\t/**\n+\t * Retrieve the metadata for an OAuth 2.0 refresh token as an authenticated Synapse user.\n+\t *\n+\t * Users that wish to retrieve OAuth 2.0 refresh token metadata should use\n+\t * <a href=\"${GET.oauth2.token.tokenId.metadata}\">GET /oauth2/token/{tokenId}/metadata</a>\n+\t *\n+\t * @throws NotFoundException\n+\t */\n+\t@RequiredScope({view})\n+\t@ResponseStatus(HttpStatus.OK)\n+\t@RequestMapping(value = UrlHelpers.OAUTH_2_AUDIT_TOKENS_ID_METADATA, method = RequestMethod.GET)\n+\tpublic @ResponseBody\n+\tOAuthRefreshTokenInformation getRefreshTokenMetadataAsUser(\n+\t\t\t@RequestParam(value = AuthorizationConstants.USER_ID_PARAM) Long userId,\n+\t\t\t@PathVariable String tokenId) throws NotFoundException {\n+\t\treturn serviceProvider.getOpenIDConnectService().getRefreshTokenMetadataAsUser(userId, tokenId);\n+\t}\n+\n+\t/**\n+\t * Retrieve the metadata for an OAuth 2.0 refresh token. The request should be made as an OAuth 2.0 client using\n+\t * basic authentication.\n+\t *\n+\t * Users that wish to retrieve OAuth 2.0 refresh token metadata should use\n+\t * <a href=\"${GET.oauth2.audit.tokens.tokenId.metadata}\">GET /oauth2/audit/tokens/{tokenId}/metadata</a>\n+\t *\n+\t * @throws NotFoundException\n+\t */\n+\t@RequiredScope({view})\n+\t@ResponseStatus(HttpStatus.OK)\n+\t@RequestMapping(value = UrlHelpers.OAUTH_2_TOKEN_ID_METADATA, method = RequestMethod.GET)\n+\tpublic @ResponseBody\n+\tOAuthRefreshTokenInformation getRefreshTokenMetadataAsClient(\n+\t\t\t@RequestHeader(value = AuthorizationConstants.OAUTH_VERIFIED_CLIENT_ID_HEADER) String verifiedClientId,\n+\t\t\t@PathVariable String tokenId) throws NotFoundException {\n+\t\treturn serviceProvider.getOpenIDConnectService().getRefreshTokenMetadataAsClient(verifiedClientId, tokenId);\n+\t}\n+\n+\t/**\n+\t * Update the metadata for a refresh token. At this time, the only field that a user may set is the 'name' field.\n+\t *\n+\t * @throws NotFoundException\n+\t */\n+\t@RequiredScope({view, modify})\n+\t@ResponseStatus(HttpStatus.OK)\n+\t@RequestMapping(value = UrlHelpers.OAUTH_2_AUDIT_TOKENS_ID_METADATA, method = RequestMethod.PUT)\n+\tpublic @ResponseBody\n+\tOAuthRefreshTokenInformation updateRefreshTokenMetadata(\n+\t\t\t@RequestParam(value = AuthorizationConstants.USER_ID_PARAM) Long userId,\n+\t\t\t@PathVariable String tokenId,\n+\t\t\t@RequestBody OAuthRefreshTokenInformation metadata) throws NotFoundException {\n+\t\treturn serviceProvider.getOpenIDConnectService().updateRefreshTokenMetadata(userId, tokenId, metadata);\n+\t}\n+\n+\t/**\n+\t * Revoke all refresh token and their related access tokens associated with a particular client and the requesting user.\n+\t * Note that access tokens that are not associated with refresh tokens cannot be revoked.\n+\t * Users that want to revoke one refresh token should use <a href=\"${POST.oauth2.audit.tokens.tokenId.revoke}\">POST /oauth2/audit/tokens/{tokenId}/revoke</a>.\n+\t *\n+\t * Additionally, Access tokens that are not associated with a refresh token cannot be revoked.\n+\t *\n+\t * OAuth 2.0 clients wishing to revoke a refresh token should use <a href=\"${POST.oauth2.revoke}\">POST /oauth2/revoke</a>\n+\t */\n+\t@RequiredScope({view, modify, authorize})\n+\t@ResponseStatus(HttpStatus.OK)\n+\t@RequestMapping(value = UrlHelpers.OAUTH_2_AUDIT_CLIENT_REVOKE, method = RequestMethod.POST)\n+\tpublic void revokeRefreshTokensForUserClientPair(\n+\t\t\t@RequestParam(value = AuthorizationConstants.USER_ID_PARAM) Long userId,\n+\t\t\t@PathVariable String clientId) throws NotFoundException {\n+\t\tserviceProvider.getOpenIDConnectService().revokeTokensForUserClientPair(userId, clientId);\n+\t}\n+\n+\t/**\n+\t * Revoke a particular refresh token and all of its related access tokens using its unique ID. The caller must be the the user/resource owner associated with the refresh token.\n+\t * Note that a client may be in possession of more than one refresh token, so users wishing to revoke all access should use\n+\t * <a href=\"${POST.oauth2.audit.grantedClients.clientId.revoke}\">POST /oauth2/audit/grantedClients/{clientId}/revoke</a>.\n+\t *\n+\t * Additionally, Access tokens that are not associated with a refresh token cannot be revoked.\n+\t *\n+\t * OAuth 2.0 clients wishing to revoke a refresh token should use <a href=\"${POST.oauth2.revoke}\">POST /oauth2/revoke</a>\n+\t */\n+\t@RequiredScope({view, modify, authorize})\n+\t@ResponseStatus(HttpStatus.OK)\n+\t@RequestMapping(value = UrlHelpers.OAUTH_2_AUDIT_TOKENS_ID_REVOKE, method = RequestMethod.POST)\n+\tpublic void revokeRefreshToken(\n+\t\t\t@RequestParam(value = AuthorizationConstants.USER_ID_PARAM) Long userId,\n+\t\t\t@PathVariable String tokenId) throws NotFoundException {\n+\t\tserviceProvider.getOpenIDConnectService().revokeRefreshTokenAsUser(userId, tokenId);\n+\t}\n+\n+\t/**\n+\t * Revoke a particular refresh token using the token itself, or an associated access token. The caller must be the the user/resource owner associated with the refresh token.", "originalCommit": "e29a5d52978a53027b8426a4134519cbfd47bf36", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgwNDY3MQ==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4088#discussion_r441804671", "bodyText": "remove ll 497-8\nreturn NO_CONTENT", "author": "brucehoff", "createdAt": "2020-06-17T20:10:30Z", "path": "services/repository/src/main/java/org/sagebionetworks/auth/controller/OpenIDConnectController.java", "diffHunk": "@@ -356,4 +364,146 @@ Object getUserInfoPOST(\n \t\treturn serviceProvider.getOpenIDConnectService().getUserInfo(accessToken, getEndpoint(uriComponentsBuilder));\n \t}\n \n+\t/**\n+\t * Get a paginated list of the OAuth 2 clients that currently have active refresh tokens that grant access to the user's\n+\t * Synapse identity and/or resources. OAuth 2.0 clients that have no active refresh tokens will not appear in this list.\n+\t *\n+\t * @throws NotFoundException\n+\t * @throws OAuthClientNotVerifiedException if the client is not verified\n+\t */\n+\t@RequiredScope({view})\n+\t@ResponseStatus(HttpStatus.OK)\n+\t@RequestMapping(value = UrlHelpers.OAUTH_2_AUDIT_CLIENTS, method = RequestMethod.GET)\n+\tpublic @ResponseBody\n+\tOAuthClientAuthorizationHistoryList getGrantedClientsForUser(\n+\t\t\t@RequestParam(value = AuthorizationConstants.USER_ID_PARAM) Long userId,\n+\t\t\t@RequestParam(value = UrlHelpers.NEXT_PAGE_TOKEN_PARAM, required=false) String nextPageToken\n+\t) throws NotFoundException {\n+\t\treturn serviceProvider.getOpenIDConnectService().getClientAuthorizationHistory(userId, nextPageToken);\n+\t}\n+\n+\t/**\n+\t * Get a paginated list of metadata about refresh tokens granted to a particular OAuth 2 clients on\n+\t * behalf of the requesting user. The token itself may not be retrieved.\n+\t * Refresh tokens that have been revoked will not be included in this list.\n+\t *\n+\t * @throws NotFoundException\n+\t */\n+\t@RequiredScope({view})\n+\t@ResponseStatus(HttpStatus.OK)\n+\t@RequestMapping(value = UrlHelpers.OAUTH_2_AUDIT_CLIENT_TOKENS, method = RequestMethod.GET)\n+\tpublic @ResponseBody\n+\tOAuthRefreshTokenInformationList getGrantedTokenMetadataForUserClientPair(\n+\t\t\t@RequestParam(value = AuthorizationConstants.USER_ID_PARAM) Long userId,\n+\t\t\t@PathVariable String clientId,\n+\t\t\t@RequestParam(value = UrlHelpers.NEXT_PAGE_TOKEN_PARAM, required=false) String nextPageToken\n+\t) throws NotFoundException {\n+\t\treturn serviceProvider.getOpenIDConnectService().getTokenMetadataForGrantedClient(userId, clientId, nextPageToken);\n+\t}\n+\n+\n+\t/**\n+\t * Retrieve the metadata for an OAuth 2.0 refresh token as an authenticated Synapse user.\n+\t *\n+\t * Users that wish to retrieve OAuth 2.0 refresh token metadata should use\n+\t * <a href=\"${GET.oauth2.token.tokenId.metadata}\">GET /oauth2/token/{tokenId}/metadata</a>\n+\t *\n+\t * @throws NotFoundException\n+\t */\n+\t@RequiredScope({view})\n+\t@ResponseStatus(HttpStatus.OK)\n+\t@RequestMapping(value = UrlHelpers.OAUTH_2_AUDIT_TOKENS_ID_METADATA, method = RequestMethod.GET)\n+\tpublic @ResponseBody\n+\tOAuthRefreshTokenInformation getRefreshTokenMetadataAsUser(\n+\t\t\t@RequestParam(value = AuthorizationConstants.USER_ID_PARAM) Long userId,\n+\t\t\t@PathVariable String tokenId) throws NotFoundException {\n+\t\treturn serviceProvider.getOpenIDConnectService().getRefreshTokenMetadataAsUser(userId, tokenId);\n+\t}\n+\n+\t/**\n+\t * Retrieve the metadata for an OAuth 2.0 refresh token. The request should be made as an OAuth 2.0 client using\n+\t * basic authentication.\n+\t *\n+\t * Users that wish to retrieve OAuth 2.0 refresh token metadata should use\n+\t * <a href=\"${GET.oauth2.audit.tokens.tokenId.metadata}\">GET /oauth2/audit/tokens/{tokenId}/metadata</a>\n+\t *\n+\t * @throws NotFoundException\n+\t */\n+\t@RequiredScope({view})\n+\t@ResponseStatus(HttpStatus.OK)\n+\t@RequestMapping(value = UrlHelpers.OAUTH_2_TOKEN_ID_METADATA, method = RequestMethod.GET)\n+\tpublic @ResponseBody\n+\tOAuthRefreshTokenInformation getRefreshTokenMetadataAsClient(\n+\t\t\t@RequestHeader(value = AuthorizationConstants.OAUTH_VERIFIED_CLIENT_ID_HEADER) String verifiedClientId,\n+\t\t\t@PathVariable String tokenId) throws NotFoundException {\n+\t\treturn serviceProvider.getOpenIDConnectService().getRefreshTokenMetadataAsClient(verifiedClientId, tokenId);\n+\t}\n+\n+\t/**\n+\t * Update the metadata for a refresh token. At this time, the only field that a user may set is the 'name' field.\n+\t *\n+\t * @throws NotFoundException\n+\t */\n+\t@RequiredScope({view, modify})\n+\t@ResponseStatus(HttpStatus.OK)\n+\t@RequestMapping(value = UrlHelpers.OAUTH_2_AUDIT_TOKENS_ID_METADATA, method = RequestMethod.PUT)\n+\tpublic @ResponseBody\n+\tOAuthRefreshTokenInformation updateRefreshTokenMetadata(\n+\t\t\t@RequestParam(value = AuthorizationConstants.USER_ID_PARAM) Long userId,\n+\t\t\t@PathVariable String tokenId,\n+\t\t\t@RequestBody OAuthRefreshTokenInformation metadata) throws NotFoundException {\n+\t\treturn serviceProvider.getOpenIDConnectService().updateRefreshTokenMetadata(userId, tokenId, metadata);\n+\t}\n+\n+\t/**\n+\t * Revoke all refresh token and their related access tokens associated with a particular client and the requesting user.\n+\t * Note that access tokens that are not associated with refresh tokens cannot be revoked.\n+\t * Users that want to revoke one refresh token should use <a href=\"${POST.oauth2.audit.tokens.tokenId.revoke}\">POST /oauth2/audit/tokens/{tokenId}/revoke</a>.\n+\t *\n+\t * Additionally, Access tokens that are not associated with a refresh token cannot be revoked.\n+\t *\n+\t * OAuth 2.0 clients wishing to revoke a refresh token should use <a href=\"${POST.oauth2.revoke}\">POST /oauth2/revoke</a>\n+\t */\n+\t@RequiredScope({view, modify, authorize})\n+\t@ResponseStatus(HttpStatus.OK)\n+\t@RequestMapping(value = UrlHelpers.OAUTH_2_AUDIT_CLIENT_REVOKE, method = RequestMethod.POST)\n+\tpublic void revokeRefreshTokensForUserClientPair(\n+\t\t\t@RequestParam(value = AuthorizationConstants.USER_ID_PARAM) Long userId,\n+\t\t\t@PathVariable String clientId) throws NotFoundException {\n+\t\tserviceProvider.getOpenIDConnectService().revokeTokensForUserClientPair(userId, clientId);\n+\t}\n+\n+\t/**\n+\t * Revoke a particular refresh token and all of its related access tokens using its unique ID. The caller must be the the user/resource owner associated with the refresh token.\n+\t * Note that a client may be in possession of more than one refresh token, so users wishing to revoke all access should use\n+\t * <a href=\"${POST.oauth2.audit.grantedClients.clientId.revoke}\">POST /oauth2/audit/grantedClients/{clientId}/revoke</a>.\n+\t *\n+\t * Additionally, Access tokens that are not associated with a refresh token cannot be revoked.\n+\t *\n+\t * OAuth 2.0 clients wishing to revoke a refresh token should use <a href=\"${POST.oauth2.revoke}\">POST /oauth2/revoke</a>\n+\t */\n+\t@RequiredScope({view, modify, authorize})\n+\t@ResponseStatus(HttpStatus.OK)\n+\t@RequestMapping(value = UrlHelpers.OAUTH_2_AUDIT_TOKENS_ID_REVOKE, method = RequestMethod.POST)\n+\tpublic void revokeRefreshToken(\n+\t\t\t@RequestParam(value = AuthorizationConstants.USER_ID_PARAM) Long userId,\n+\t\t\t@PathVariable String tokenId) throws NotFoundException {\n+\t\tserviceProvider.getOpenIDConnectService().revokeRefreshTokenAsUser(userId, tokenId);\n+\t}\n+\n+\t/**\n+\t * Revoke a particular refresh token using the token itself, or an associated access token. The caller must be the the user/resource owner associated with the refresh token.\n+\t *\n+\t * OAuth 2.0 clients wishing to revoke a refresh token should use", "originalCommit": "e29a5d52978a53027b8426a4134519cbfd47bf36", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgwNjc3Ng==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4088#discussion_r441806776", "bodyText": "do other oauth providers publish their revocation endpoint in their discovery document and, if so, should we do it too?", "author": "brucehoff", "createdAt": "2020-06-17T20:14:25Z", "path": "services/repository/src/main/java/org/sagebionetworks/repo/web/UrlHelpers.java", "diffHunk": "@@ -1127,7 +1127,19 @@\n \tpublic static final String OAUTH_2_USER_INFO = AUTH_OAUTH_2+\"/userinfo\";\n \tpublic static final String OAUTH_2_JWKS = AUTH_OAUTH_2+\"/jwks\";\n \tpublic static final String OAUTH_2_AUTH_REQUEST_DESCRIPTION = AUTH_OAUTH_2+\"/description\";\n-\t\n+\tpublic static final String OAUTH_2_REVOKE = AUTH_OAUTH_2+\"/revoke\";", "originalCommit": "e29a5d52978a53027b8426a4134519cbfd47bf36", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgxMzUyNw==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4088#discussion_r441813527", "bodyText": "make this an instance variable (clientToDelete?)", "author": "brucehoff", "createdAt": "2020-06-17T20:28:04Z", "path": "integration-test/src/test/java/org/sagebionetworks/ITOpenIDConnectTest.java", "diffHunk": "@@ -334,4 +365,264 @@ public void testRoundTrip() throws Exception {\n \t\tclientToDelete=null;\n \t}\n \n+\tprivate OAuthClient setUpVerifiedOAuthClient() throws SynapseException {\n+\t\tOAuthClient client = new OAuthClient();\n+\t\tclient.setClient_name(\"some client\");\n+\t\tclient.setRedirect_uris(Collections.singletonList(\"https://foo.bar.com\"));\n+\t\tclient = synapseOne.createOAuthClient(client);\n+\t\tclientToDelete = client.getClient_id();\n+\t\treturn adminSynapse.updateOAuthClientVerifiedStatus(client.getClient_id(), client.getEtag(), true);\n+\t}\n+\n+\tprivate static OIDCAuthorizationRequest setUpAuthorizationRequest(OAuthClient client) throws Exception {\n+\t\tOIDCAuthorizationRequest authorizationRequest = new OIDCAuthorizationRequest();\n+\t\tauthorizationRequest.setClientId(client.getClient_id());\n+\t\tauthorizationRequest.setRedirectUri(client.getRedirect_uris().get(0));\n+\t\tauthorizationRequest.setResponseType(OAuthResponseType.code);\n+\t\tauthorizationRequest.setScope(\"openid offline_access\"); // offline_access is needed for a refresh token\n+\n+\t\tMap<String, OIDCClaimsRequestDetails> claimsToRequest = new HashMap<>();\n+\t\tclaimsToRequest.put(OIDCClaimName.userid.name(), null);\n+\t\tclaimsToRequest.put(OIDCClaimName.email.name(), null);\n+\t\tclaimsToRequest.put(OIDCClaimName.is_certified.name(), null);\n+\t\tOIDCClaimsRequestDetails teamClaimRequestDetails = new OIDCClaimsRequestDetails();\n+\t\tteamClaimRequestDetails.setValues(Collections.singletonList(\"2\"));\n+\t\tclaimsToRequest.put(OIDCClaimName.team.name(), teamClaimRequestDetails);\n+\t\tOIDCClaimsRequest claimsRequest = new OIDCClaimsRequest();\n+\t\tclaimsRequest.setId_token(claimsToRequest);\n+\t\tclaimsRequest.setUserinfo(claimsToRequest);\n+\t\tauthorizationRequest.setClaims(claimsRequest);\n+\n+\t\tString nonce = UUID.randomUUID().toString();\n+\t\tauthorizationRequest.setNonce(nonce);\n+\t\treturn  authorizationRequest;\n+\t}\n+\n+\t@Test\n+\tpublic void testRefreshTokenGrantTypeRoundTrip() throws Exception {\n+\t\tOAuthClient client = setUpVerifiedOAuthClient();\n+\t\tOAuthClientIdAndSecret secret = synapseOne.createOAuthClientSecret(client.getClient_id());\n+\n+\t\tOIDCAuthorizationRequest authorizationRequest = setUpAuthorizationRequest(client);\n+\n+\t\tOAuthAuthorizationResponse oauthAuthorizationResponse = synapseOne.authorizeClient(authorizationRequest);\n+\n+\t\t// Note, we use Basic auth to authorize the client when asking for an access token\n+\t\tOIDCTokenResponse tokenResponse = null;\n+\t\ttry {\n+\t\t\tsynapseAnonymous.setBasicAuthorizationCredentials(client.getClient_id(), secret.getClient_secret());\n+\t\t\ttokenResponse = synapseAnonymous.getTokenResponse(OAuthGrantType.authorization_code,\n+\t\t\t\t\toauthAuthorizationResponse.getAccess_code(), client.getRedirect_uris().get(0), null, null, null);\n+\t\t} finally {\n+\t\t\tsynapseAnonymous.removeAuthorizationHeader();\n+\t\t}\n+\n+\t\t// get another access token using our refresh token\n+\t\tOIDCTokenResponse newTokenResponse = null;\n+\t\ttry {\n+\t\t\tsynapseAnonymous.setBasicAuthorizationCredentials(client.getClient_id(), secret.getClient_secret());\n+\t\t\tnewTokenResponse = synapseAnonymous.getTokenResponse(OAuthGrantType.refresh_token, null,\n+\t\t\t\t\tclient.getRedirect_uris().get(0), tokenResponse.getRefresh_token(), null, null);\n+\n+\t\t} finally {\n+\t\t\tsynapseAnonymous.removeAuthorizationHeader();\n+\t\t}\n+\t\t// The refresh token should be rotated\n+\t\tassertFalse(StringUtils.isBlank(newTokenResponse.getRefresh_token()));\n+\t\tassertNotEquals(tokenResponse.getRefresh_token(), newTokenResponse.getRefresh_token());\n+\n+\t\t// New ID and access tokens should be retrieved\n+\t\tassertFalse(StringUtils.isBlank(newTokenResponse.getId_token()));\n+\t\tassertNotEquals(tokenResponse.getId_token(), newTokenResponse.getId_token());\n+\t\tassertFalse(StringUtils.isBlank(newTokenResponse.getAccess_token()));\n+\t\tassertNotEquals(tokenResponse.getAccess_token(), newTokenResponse.getAccess_token());\n+\n+\t\t// The old refresh token shouldn't work anymore.\n+\t\ttry {\n+\t\t\tsynapseAnonymous.setBasicAuthorizationCredentials(client.getClient_id(), secret.getClient_secret());\n+\t\t\tString clientUri = client.getRedirect_uris().get(0);\n+\t\t\tString oldRefreshToken = tokenResponse.getRefresh_token();\n+\t\t\tassertThrows(SynapseBadRequestException.class, () ->\n+\t\t\t\t\tsynapseAnonymous.getTokenResponse(OAuthGrantType.refresh_token, null,\n+\t\t\t\t\tclientUri, oldRefreshToken, null, null));\n+\t\t} finally {\n+\t\t\tsynapseAnonymous.removeAuthorizationHeader();\n+\t\t}\n+\n+\t\t// Both the old and the new access tokens should work\n+\t\ttry { // Get userInfo using old access token\n+\t\t\tsynapseAnonymous.setBearerAuthorizationToken(tokenResponse.getAccess_token());\n+\t\t\tJSONObject userInfo = synapseAnonymous.getUserInfoAsJSON();\n+\t\t\tassertTrue((Boolean)userInfo.get(\"is_certified\"));\n+\t\t} finally {\n+\t\t\tsynapseAnonymous.removeAuthorizationHeader();\n+\t\t}\n+\n+\t\t// The old refresh token should not work\n+\t\ttry {\n+\t\t\tsynapseAnonymous.setBasicAuthorizationCredentials(client.getClient_id(), secret.getClient_secret());\n+\t\t\tString clientUri = client.getRedirect_uris().get(0);\n+\t\t\tString refreshToken = tokenResponse.getRefresh_token();\n+\t\t\tassertThrows(SynapseBadRequestException.class, () ->\n+\t\t\t\t\tsynapseAnonymous.getTokenResponse(OAuthGrantType.refresh_token, null,\n+\t\t\t\t\t\t\tclientUri, refreshToken, null, null)\n+\t\t\t);\n+\t\t} finally {\n+\t\t\tsynapseAnonymous.removeAuthorizationHeader();\n+\t\t}\n+\n+\n+\t\ttry { // Get userInfo using new access token\n+\t\t\tsynapseAnonymous.setBearerAuthorizationToken(newTokenResponse.getAccess_token());\n+\t\t\tJSONObject userInfo = synapseAnonymous.getUserInfoAsJSON();\n+\t\t\tassertTrue((Boolean)userInfo.get(\"is_certified\"));\n+\t\t} finally {\n+\t\t\tsynapseAnonymous.removeAuthorizationHeader();\n+\t\t}\n+\n+\t\t// Audit clients -- there should only be one active client\n+\t\t// Call under test\n+\t\tOAuthClientAuthorizationHistoryList authzHistory = synapseOne.getClientAuthorizationHistory(null);\n+\t\tassertEquals(1, authzHistory.getResults().size());\n+\t\tassertNull(authzHistory.getNextPageToken());\n+\t\tassertEquals(client.getClient_id(), authzHistory.getResults().get(0).getClient().getClient_id());\n+\n+\t\t// Audit tokens -- there should only be one token for the sole active client\n+\t\t// Call under test\n+\t\tOAuthRefreshTokenInformationList tokenList = synapseOne.getRefreshTokenMetadataForAuthorizedClient(client.getClient_id(), null);\n+\t\tassertEquals(1, tokenList.getResults().size());\n+\t\tassertNull(tokenList.getNextPageToken());\n+\t\tassertEquals(synapseOne.getMyProfile().getOwnerId(), tokenList.getResults().get(0).getPrincipalId());\n+\t\tassertEquals(client.getClient_id(), tokenList.getResults().get(0).getClientId());\n+\t\tassertEquals(authorizationRequest.getClaims(), tokenList.getResults().get(0).getClaims());\n+\n+\t\t// Retrieving the refresh token metadata should yield the same result\n+\t\tOAuthRefreshTokenInformation metadata = synapseOne.getRefreshTokenMetadata(tokenList.getResults().get(0).getTokenId());\n+\t\tassertEquals(tokenList.getResults().get(0), metadata);\n+\n+\t\t// Rename the refresh token\n+\t\tmetadata.setName(\"a new refresh token name\");\n+\t\t// Call under test\n+\t\tsynapseOne.updateRefreshTokenMetadata(metadata);\n+\t\tOAuthRefreshTokenInformation newMetadata = synapseOne.getRefreshTokenMetadata(tokenList.getResults().get(0).getTokenId());\n+\n+\t\tassertEquals(metadata.getName(), newMetadata.getName());\n+\n+\t\t// The OAuth client should be able to get the refresh token metadata as well\n+\t\ttry {\n+\t\t\tsynapseAnonymous.setBasicAuthorizationCredentials(client.getClient_id(), secret.getClient_secret());\n+\t\t\tassertEquals(newMetadata, synapseAnonymous.getRefreshTokenMetadataAsOAuthClient(metadata.getTokenId()));\n+\t\t} finally {\n+\t\t\tsynapseAnonymous.removeAuthorizationHeader();\n+\t\t}\n+\n+\t\t// Revoke the refresh token\n+\t\tsynapseOne.revokeRefreshToken(metadata.getTokenId());\n+\n+\t\t// Client should be unable to use access token\n+\t\ttry {\n+\t\t\tsynapseAnonymous.setBearerAuthorizationToken(tokenResponse.getAccess_token());\n+\t\t\tassertThrows(SynapseUnauthorizedException.class, () ->\n+\t\t\t\t\tsynapseAnonymous.getUserInfoAsJSONWebToken()\n+\t\t\t);\n+\t\t} finally {\n+\t\t\tsynapseAnonymous.removeAuthorizationHeader();\n+\t\t}\n+\n+\t\t// Client should be unable to use refresh token\n+\t\ttry {\n+\t\t\tsynapseAnonymous.setBasicAuthorizationCredentials(client.getClient_id(), secret.getClient_secret());\n+\t\t\tString clientUri = client.getRedirect_uris().get(0);\n+\t\t\tString refreshToken = newTokenResponse.getRefresh_token();\n+\t\t\tassertThrows(SynapseBadRequestException.class, () ->\n+\t\t\t\t\tsynapseAnonymous.getTokenResponse(OAuthGrantType.refresh_token, null,\n+\t\t\t\t\t\t\tclientUri, refreshToken, null, null)\n+\t\t\t);\n+\t\t} finally {\n+\t\t\tsynapseAnonymous.removeAuthorizationHeader();\n+\t\t}\n+\n+\n+\t\tsynapseOne.deleteOAuthClient(client.getClient_id());\n+\t\tclientToDelete=null;\n+\t}\n+\n+\t@Test\n+\tpublic void testRevokeAllTokensFromClient() throws Exception {\n+\t\t// START Set up, use authorization code\n+\t\tOAuthClient client = setUpVerifiedOAuthClient();", "originalCommit": "e29a5d52978a53027b8426a4134519cbfd47bf36", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgxMzY5Mw==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4088#discussion_r441813693", "bodyText": "put this in AfterEach and check if client!=null before executing", "author": "brucehoff", "createdAt": "2020-06-17T20:28:24Z", "path": "integration-test/src/test/java/org/sagebionetworks/ITOpenIDConnectTest.java", "diffHunk": "@@ -334,4 +365,264 @@ public void testRoundTrip() throws Exception {\n \t\tclientToDelete=null;\n \t}\n \n+\tprivate OAuthClient setUpVerifiedOAuthClient() throws SynapseException {\n+\t\tOAuthClient client = new OAuthClient();\n+\t\tclient.setClient_name(\"some client\");\n+\t\tclient.setRedirect_uris(Collections.singletonList(\"https://foo.bar.com\"));\n+\t\tclient = synapseOne.createOAuthClient(client);\n+\t\tclientToDelete = client.getClient_id();\n+\t\treturn adminSynapse.updateOAuthClientVerifiedStatus(client.getClient_id(), client.getEtag(), true);\n+\t}\n+\n+\tprivate static OIDCAuthorizationRequest setUpAuthorizationRequest(OAuthClient client) throws Exception {\n+\t\tOIDCAuthorizationRequest authorizationRequest = new OIDCAuthorizationRequest();\n+\t\tauthorizationRequest.setClientId(client.getClient_id());\n+\t\tauthorizationRequest.setRedirectUri(client.getRedirect_uris().get(0));\n+\t\tauthorizationRequest.setResponseType(OAuthResponseType.code);\n+\t\tauthorizationRequest.setScope(\"openid offline_access\"); // offline_access is needed for a refresh token\n+\n+\t\tMap<String, OIDCClaimsRequestDetails> claimsToRequest = new HashMap<>();\n+\t\tclaimsToRequest.put(OIDCClaimName.userid.name(), null);\n+\t\tclaimsToRequest.put(OIDCClaimName.email.name(), null);\n+\t\tclaimsToRequest.put(OIDCClaimName.is_certified.name(), null);\n+\t\tOIDCClaimsRequestDetails teamClaimRequestDetails = new OIDCClaimsRequestDetails();\n+\t\tteamClaimRequestDetails.setValues(Collections.singletonList(\"2\"));\n+\t\tclaimsToRequest.put(OIDCClaimName.team.name(), teamClaimRequestDetails);\n+\t\tOIDCClaimsRequest claimsRequest = new OIDCClaimsRequest();\n+\t\tclaimsRequest.setId_token(claimsToRequest);\n+\t\tclaimsRequest.setUserinfo(claimsToRequest);\n+\t\tauthorizationRequest.setClaims(claimsRequest);\n+\n+\t\tString nonce = UUID.randomUUID().toString();\n+\t\tauthorizationRequest.setNonce(nonce);\n+\t\treturn  authorizationRequest;\n+\t}\n+\n+\t@Test\n+\tpublic void testRefreshTokenGrantTypeRoundTrip() throws Exception {\n+\t\tOAuthClient client = setUpVerifiedOAuthClient();\n+\t\tOAuthClientIdAndSecret secret = synapseOne.createOAuthClientSecret(client.getClient_id());\n+\n+\t\tOIDCAuthorizationRequest authorizationRequest = setUpAuthorizationRequest(client);\n+\n+\t\tOAuthAuthorizationResponse oauthAuthorizationResponse = synapseOne.authorizeClient(authorizationRequest);\n+\n+\t\t// Note, we use Basic auth to authorize the client when asking for an access token\n+\t\tOIDCTokenResponse tokenResponse = null;\n+\t\ttry {\n+\t\t\tsynapseAnonymous.setBasicAuthorizationCredentials(client.getClient_id(), secret.getClient_secret());\n+\t\t\ttokenResponse = synapseAnonymous.getTokenResponse(OAuthGrantType.authorization_code,\n+\t\t\t\t\toauthAuthorizationResponse.getAccess_code(), client.getRedirect_uris().get(0), null, null, null);\n+\t\t} finally {\n+\t\t\tsynapseAnonymous.removeAuthorizationHeader();\n+\t\t}\n+\n+\t\t// get another access token using our refresh token\n+\t\tOIDCTokenResponse newTokenResponse = null;\n+\t\ttry {\n+\t\t\tsynapseAnonymous.setBasicAuthorizationCredentials(client.getClient_id(), secret.getClient_secret());\n+\t\t\tnewTokenResponse = synapseAnonymous.getTokenResponse(OAuthGrantType.refresh_token, null,\n+\t\t\t\t\tclient.getRedirect_uris().get(0), tokenResponse.getRefresh_token(), null, null);\n+\n+\t\t} finally {\n+\t\t\tsynapseAnonymous.removeAuthorizationHeader();\n+\t\t}\n+\t\t// The refresh token should be rotated\n+\t\tassertFalse(StringUtils.isBlank(newTokenResponse.getRefresh_token()));\n+\t\tassertNotEquals(tokenResponse.getRefresh_token(), newTokenResponse.getRefresh_token());\n+\n+\t\t// New ID and access tokens should be retrieved\n+\t\tassertFalse(StringUtils.isBlank(newTokenResponse.getId_token()));\n+\t\tassertNotEquals(tokenResponse.getId_token(), newTokenResponse.getId_token());\n+\t\tassertFalse(StringUtils.isBlank(newTokenResponse.getAccess_token()));\n+\t\tassertNotEquals(tokenResponse.getAccess_token(), newTokenResponse.getAccess_token());\n+\n+\t\t// The old refresh token shouldn't work anymore.\n+\t\ttry {\n+\t\t\tsynapseAnonymous.setBasicAuthorizationCredentials(client.getClient_id(), secret.getClient_secret());\n+\t\t\tString clientUri = client.getRedirect_uris().get(0);\n+\t\t\tString oldRefreshToken = tokenResponse.getRefresh_token();\n+\t\t\tassertThrows(SynapseBadRequestException.class, () ->\n+\t\t\t\t\tsynapseAnonymous.getTokenResponse(OAuthGrantType.refresh_token, null,\n+\t\t\t\t\tclientUri, oldRefreshToken, null, null));\n+\t\t} finally {\n+\t\t\tsynapseAnonymous.removeAuthorizationHeader();\n+\t\t}\n+\n+\t\t// Both the old and the new access tokens should work\n+\t\ttry { // Get userInfo using old access token\n+\t\t\tsynapseAnonymous.setBearerAuthorizationToken(tokenResponse.getAccess_token());\n+\t\t\tJSONObject userInfo = synapseAnonymous.getUserInfoAsJSON();\n+\t\t\tassertTrue((Boolean)userInfo.get(\"is_certified\"));\n+\t\t} finally {\n+\t\t\tsynapseAnonymous.removeAuthorizationHeader();\n+\t\t}\n+\n+\t\t// The old refresh token should not work\n+\t\ttry {\n+\t\t\tsynapseAnonymous.setBasicAuthorizationCredentials(client.getClient_id(), secret.getClient_secret());\n+\t\t\tString clientUri = client.getRedirect_uris().get(0);\n+\t\t\tString refreshToken = tokenResponse.getRefresh_token();\n+\t\t\tassertThrows(SynapseBadRequestException.class, () ->\n+\t\t\t\t\tsynapseAnonymous.getTokenResponse(OAuthGrantType.refresh_token, null,\n+\t\t\t\t\t\t\tclientUri, refreshToken, null, null)\n+\t\t\t);\n+\t\t} finally {\n+\t\t\tsynapseAnonymous.removeAuthorizationHeader();\n+\t\t}\n+\n+\n+\t\ttry { // Get userInfo using new access token\n+\t\t\tsynapseAnonymous.setBearerAuthorizationToken(newTokenResponse.getAccess_token());\n+\t\t\tJSONObject userInfo = synapseAnonymous.getUserInfoAsJSON();\n+\t\t\tassertTrue((Boolean)userInfo.get(\"is_certified\"));\n+\t\t} finally {\n+\t\t\tsynapseAnonymous.removeAuthorizationHeader();\n+\t\t}\n+\n+\t\t// Audit clients -- there should only be one active client\n+\t\t// Call under test\n+\t\tOAuthClientAuthorizationHistoryList authzHistory = synapseOne.getClientAuthorizationHistory(null);\n+\t\tassertEquals(1, authzHistory.getResults().size());\n+\t\tassertNull(authzHistory.getNextPageToken());\n+\t\tassertEquals(client.getClient_id(), authzHistory.getResults().get(0).getClient().getClient_id());\n+\n+\t\t// Audit tokens -- there should only be one token for the sole active client\n+\t\t// Call under test\n+\t\tOAuthRefreshTokenInformationList tokenList = synapseOne.getRefreshTokenMetadataForAuthorizedClient(client.getClient_id(), null);\n+\t\tassertEquals(1, tokenList.getResults().size());\n+\t\tassertNull(tokenList.getNextPageToken());\n+\t\tassertEquals(synapseOne.getMyProfile().getOwnerId(), tokenList.getResults().get(0).getPrincipalId());\n+\t\tassertEquals(client.getClient_id(), tokenList.getResults().get(0).getClientId());\n+\t\tassertEquals(authorizationRequest.getClaims(), tokenList.getResults().get(0).getClaims());\n+\n+\t\t// Retrieving the refresh token metadata should yield the same result\n+\t\tOAuthRefreshTokenInformation metadata = synapseOne.getRefreshTokenMetadata(tokenList.getResults().get(0).getTokenId());\n+\t\tassertEquals(tokenList.getResults().get(0), metadata);\n+\n+\t\t// Rename the refresh token\n+\t\tmetadata.setName(\"a new refresh token name\");\n+\t\t// Call under test\n+\t\tsynapseOne.updateRefreshTokenMetadata(metadata);\n+\t\tOAuthRefreshTokenInformation newMetadata = synapseOne.getRefreshTokenMetadata(tokenList.getResults().get(0).getTokenId());\n+\n+\t\tassertEquals(metadata.getName(), newMetadata.getName());\n+\n+\t\t// The OAuth client should be able to get the refresh token metadata as well\n+\t\ttry {\n+\t\t\tsynapseAnonymous.setBasicAuthorizationCredentials(client.getClient_id(), secret.getClient_secret());\n+\t\t\tassertEquals(newMetadata, synapseAnonymous.getRefreshTokenMetadataAsOAuthClient(metadata.getTokenId()));\n+\t\t} finally {\n+\t\t\tsynapseAnonymous.removeAuthorizationHeader();\n+\t\t}\n+\n+\t\t// Revoke the refresh token\n+\t\tsynapseOne.revokeRefreshToken(metadata.getTokenId());\n+\n+\t\t// Client should be unable to use access token\n+\t\ttry {\n+\t\t\tsynapseAnonymous.setBearerAuthorizationToken(tokenResponse.getAccess_token());\n+\t\t\tassertThrows(SynapseUnauthorizedException.class, () ->\n+\t\t\t\t\tsynapseAnonymous.getUserInfoAsJSONWebToken()\n+\t\t\t);\n+\t\t} finally {\n+\t\t\tsynapseAnonymous.removeAuthorizationHeader();\n+\t\t}\n+\n+\t\t// Client should be unable to use refresh token\n+\t\ttry {\n+\t\t\tsynapseAnonymous.setBasicAuthorizationCredentials(client.getClient_id(), secret.getClient_secret());\n+\t\t\tString clientUri = client.getRedirect_uris().get(0);\n+\t\t\tString refreshToken = newTokenResponse.getRefresh_token();\n+\t\t\tassertThrows(SynapseBadRequestException.class, () ->\n+\t\t\t\t\tsynapseAnonymous.getTokenResponse(OAuthGrantType.refresh_token, null,\n+\t\t\t\t\t\t\tclientUri, refreshToken, null, null)\n+\t\t\t);\n+\t\t} finally {\n+\t\t\tsynapseAnonymous.removeAuthorizationHeader();\n+\t\t}\n+\n+\n+\t\tsynapseOne.deleteOAuthClient(client.getClient_id());\n+\t\tclientToDelete=null;\n+\t}\n+\n+\t@Test\n+\tpublic void testRevokeAllTokensFromClient() throws Exception {\n+\t\t// START Set up, use authorization code\n+\t\tOAuthClient client = setUpVerifiedOAuthClient();\n+\t\tOAuthClientIdAndSecret secret = synapseOne.createOAuthClientSecret(client.getClient_id());\n+\n+\t\tOIDCAuthorizationRequest authorizationRequest = setUpAuthorizationRequest(client);\n+\n+\t\tOAuthAuthorizationResponse oauthAuthorizationResponse = synapseOne.authorizeClient(authorizationRequest);\n+\n+\t\t// Note, we use Basic auth to authorize the client when asking for an access token\n+\t\tOIDCTokenResponse tokenResponse = null;\n+\t\ttry {\n+\t\t\tsynapseAnonymous.setBasicAuthorizationCredentials(client.getClient_id(), secret.getClient_secret());\n+\t\t\ttokenResponse = synapseAnonymous.getTokenResponse(OAuthGrantType.authorization_code,\n+\t\t\t\t\toauthAuthorizationResponse.getAccess_code(), client.getRedirect_uris().get(0), null, null, null);\n+\t\t} finally {\n+\t\t\tsynapseAnonymous.removeAuthorizationHeader();\n+\t\t}\n+\t\t// END Set up. We now have a refresh token\n+\n+\t\tOAuthRefreshTokenInformationList tokens = synapseOne.getRefreshTokenMetadataForAuthorizedClient(client.getClient_id(), null);\n+\t\tString tokenId = tokens.getResults().get(0).getTokenId();\n+\n+\t\t// Test revoking all refresh tokens from a client\n+\n+\t\t// Call under test\n+\t\tsynapseOne.revokeMyRefreshTokensFromClient(client.getClient_id());\n+\n+\t\tassertThrows(SynapseNotFoundException.class, () ->\n+\t\t\t\tsynapseOne.getRefreshTokenMetadata(tokenId));\n+\n+\t\tsynapseOne.deleteOAuthClient(client.getClient_id());", "originalCommit": "e29a5d52978a53027b8426a4134519cbfd47bf36", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgxNDI3NA==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4088#discussion_r441814274", "bodyText": "this.clientToDelete = setUp...", "author": "brucehoff", "createdAt": "2020-06-17T20:29:33Z", "path": "integration-test/src/test/java/org/sagebionetworks/ITOpenIDConnectTest.java", "diffHunk": "@@ -334,4 +365,264 @@ public void testRoundTrip() throws Exception {\n \t\tclientToDelete=null;\n \t}\n \n+\tprivate OAuthClient setUpVerifiedOAuthClient() throws SynapseException {\n+\t\tOAuthClient client = new OAuthClient();\n+\t\tclient.setClient_name(\"some client\");\n+\t\tclient.setRedirect_uris(Collections.singletonList(\"https://foo.bar.com\"));\n+\t\tclient = synapseOne.createOAuthClient(client);\n+\t\tclientToDelete = client.getClient_id();\n+\t\treturn adminSynapse.updateOAuthClientVerifiedStatus(client.getClient_id(), client.getEtag(), true);\n+\t}\n+\n+\tprivate static OIDCAuthorizationRequest setUpAuthorizationRequest(OAuthClient client) throws Exception {\n+\t\tOIDCAuthorizationRequest authorizationRequest = new OIDCAuthorizationRequest();\n+\t\tauthorizationRequest.setClientId(client.getClient_id());\n+\t\tauthorizationRequest.setRedirectUri(client.getRedirect_uris().get(0));\n+\t\tauthorizationRequest.setResponseType(OAuthResponseType.code);\n+\t\tauthorizationRequest.setScope(\"openid offline_access\"); // offline_access is needed for a refresh token\n+\n+\t\tMap<String, OIDCClaimsRequestDetails> claimsToRequest = new HashMap<>();\n+\t\tclaimsToRequest.put(OIDCClaimName.userid.name(), null);\n+\t\tclaimsToRequest.put(OIDCClaimName.email.name(), null);\n+\t\tclaimsToRequest.put(OIDCClaimName.is_certified.name(), null);\n+\t\tOIDCClaimsRequestDetails teamClaimRequestDetails = new OIDCClaimsRequestDetails();\n+\t\tteamClaimRequestDetails.setValues(Collections.singletonList(\"2\"));\n+\t\tclaimsToRequest.put(OIDCClaimName.team.name(), teamClaimRequestDetails);\n+\t\tOIDCClaimsRequest claimsRequest = new OIDCClaimsRequest();\n+\t\tclaimsRequest.setId_token(claimsToRequest);\n+\t\tclaimsRequest.setUserinfo(claimsToRequest);\n+\t\tauthorizationRequest.setClaims(claimsRequest);\n+\n+\t\tString nonce = UUID.randomUUID().toString();\n+\t\tauthorizationRequest.setNonce(nonce);\n+\t\treturn  authorizationRequest;\n+\t}\n+\n+\t@Test\n+\tpublic void testRefreshTokenGrantTypeRoundTrip() throws Exception {\n+\t\tOAuthClient client = setUpVerifiedOAuthClient();\n+\t\tOAuthClientIdAndSecret secret = synapseOne.createOAuthClientSecret(client.getClient_id());\n+\n+\t\tOIDCAuthorizationRequest authorizationRequest = setUpAuthorizationRequest(client);\n+\n+\t\tOAuthAuthorizationResponse oauthAuthorizationResponse = synapseOne.authorizeClient(authorizationRequest);\n+\n+\t\t// Note, we use Basic auth to authorize the client when asking for an access token\n+\t\tOIDCTokenResponse tokenResponse = null;\n+\t\ttry {\n+\t\t\tsynapseAnonymous.setBasicAuthorizationCredentials(client.getClient_id(), secret.getClient_secret());\n+\t\t\ttokenResponse = synapseAnonymous.getTokenResponse(OAuthGrantType.authorization_code,\n+\t\t\t\t\toauthAuthorizationResponse.getAccess_code(), client.getRedirect_uris().get(0), null, null, null);\n+\t\t} finally {\n+\t\t\tsynapseAnonymous.removeAuthorizationHeader();\n+\t\t}\n+\n+\t\t// get another access token using our refresh token\n+\t\tOIDCTokenResponse newTokenResponse = null;\n+\t\ttry {\n+\t\t\tsynapseAnonymous.setBasicAuthorizationCredentials(client.getClient_id(), secret.getClient_secret());\n+\t\t\tnewTokenResponse = synapseAnonymous.getTokenResponse(OAuthGrantType.refresh_token, null,\n+\t\t\t\t\tclient.getRedirect_uris().get(0), tokenResponse.getRefresh_token(), null, null);\n+\n+\t\t} finally {\n+\t\t\tsynapseAnonymous.removeAuthorizationHeader();\n+\t\t}\n+\t\t// The refresh token should be rotated\n+\t\tassertFalse(StringUtils.isBlank(newTokenResponse.getRefresh_token()));\n+\t\tassertNotEquals(tokenResponse.getRefresh_token(), newTokenResponse.getRefresh_token());\n+\n+\t\t// New ID and access tokens should be retrieved\n+\t\tassertFalse(StringUtils.isBlank(newTokenResponse.getId_token()));\n+\t\tassertNotEquals(tokenResponse.getId_token(), newTokenResponse.getId_token());\n+\t\tassertFalse(StringUtils.isBlank(newTokenResponse.getAccess_token()));\n+\t\tassertNotEquals(tokenResponse.getAccess_token(), newTokenResponse.getAccess_token());\n+\n+\t\t// The old refresh token shouldn't work anymore.\n+\t\ttry {\n+\t\t\tsynapseAnonymous.setBasicAuthorizationCredentials(client.getClient_id(), secret.getClient_secret());\n+\t\t\tString clientUri = client.getRedirect_uris().get(0);\n+\t\t\tString oldRefreshToken = tokenResponse.getRefresh_token();\n+\t\t\tassertThrows(SynapseBadRequestException.class, () ->\n+\t\t\t\t\tsynapseAnonymous.getTokenResponse(OAuthGrantType.refresh_token, null,\n+\t\t\t\t\tclientUri, oldRefreshToken, null, null));\n+\t\t} finally {\n+\t\t\tsynapseAnonymous.removeAuthorizationHeader();\n+\t\t}\n+\n+\t\t// Both the old and the new access tokens should work\n+\t\ttry { // Get userInfo using old access token\n+\t\t\tsynapseAnonymous.setBearerAuthorizationToken(tokenResponse.getAccess_token());\n+\t\t\tJSONObject userInfo = synapseAnonymous.getUserInfoAsJSON();\n+\t\t\tassertTrue((Boolean)userInfo.get(\"is_certified\"));\n+\t\t} finally {\n+\t\t\tsynapseAnonymous.removeAuthorizationHeader();\n+\t\t}\n+\n+\t\t// The old refresh token should not work\n+\t\ttry {\n+\t\t\tsynapseAnonymous.setBasicAuthorizationCredentials(client.getClient_id(), secret.getClient_secret());\n+\t\t\tString clientUri = client.getRedirect_uris().get(0);\n+\t\t\tString refreshToken = tokenResponse.getRefresh_token();\n+\t\t\tassertThrows(SynapseBadRequestException.class, () ->\n+\t\t\t\t\tsynapseAnonymous.getTokenResponse(OAuthGrantType.refresh_token, null,\n+\t\t\t\t\t\t\tclientUri, refreshToken, null, null)\n+\t\t\t);\n+\t\t} finally {\n+\t\t\tsynapseAnonymous.removeAuthorizationHeader();\n+\t\t}\n+\n+\n+\t\ttry { // Get userInfo using new access token\n+\t\t\tsynapseAnonymous.setBearerAuthorizationToken(newTokenResponse.getAccess_token());\n+\t\t\tJSONObject userInfo = synapseAnonymous.getUserInfoAsJSON();\n+\t\t\tassertTrue((Boolean)userInfo.get(\"is_certified\"));\n+\t\t} finally {\n+\t\t\tsynapseAnonymous.removeAuthorizationHeader();\n+\t\t}\n+\n+\t\t// Audit clients -- there should only be one active client\n+\t\t// Call under test\n+\t\tOAuthClientAuthorizationHistoryList authzHistory = synapseOne.getClientAuthorizationHistory(null);\n+\t\tassertEquals(1, authzHistory.getResults().size());\n+\t\tassertNull(authzHistory.getNextPageToken());\n+\t\tassertEquals(client.getClient_id(), authzHistory.getResults().get(0).getClient().getClient_id());\n+\n+\t\t// Audit tokens -- there should only be one token for the sole active client\n+\t\t// Call under test\n+\t\tOAuthRefreshTokenInformationList tokenList = synapseOne.getRefreshTokenMetadataForAuthorizedClient(client.getClient_id(), null);\n+\t\tassertEquals(1, tokenList.getResults().size());\n+\t\tassertNull(tokenList.getNextPageToken());\n+\t\tassertEquals(synapseOne.getMyProfile().getOwnerId(), tokenList.getResults().get(0).getPrincipalId());\n+\t\tassertEquals(client.getClient_id(), tokenList.getResults().get(0).getClientId());\n+\t\tassertEquals(authorizationRequest.getClaims(), tokenList.getResults().get(0).getClaims());\n+\n+\t\t// Retrieving the refresh token metadata should yield the same result\n+\t\tOAuthRefreshTokenInformation metadata = synapseOne.getRefreshTokenMetadata(tokenList.getResults().get(0).getTokenId());\n+\t\tassertEquals(tokenList.getResults().get(0), metadata);\n+\n+\t\t// Rename the refresh token\n+\t\tmetadata.setName(\"a new refresh token name\");\n+\t\t// Call under test\n+\t\tsynapseOne.updateRefreshTokenMetadata(metadata);\n+\t\tOAuthRefreshTokenInformation newMetadata = synapseOne.getRefreshTokenMetadata(tokenList.getResults().get(0).getTokenId());\n+\n+\t\tassertEquals(metadata.getName(), newMetadata.getName());\n+\n+\t\t// The OAuth client should be able to get the refresh token metadata as well\n+\t\ttry {\n+\t\t\tsynapseAnonymous.setBasicAuthorizationCredentials(client.getClient_id(), secret.getClient_secret());\n+\t\t\tassertEquals(newMetadata, synapseAnonymous.getRefreshTokenMetadataAsOAuthClient(metadata.getTokenId()));\n+\t\t} finally {\n+\t\t\tsynapseAnonymous.removeAuthorizationHeader();\n+\t\t}\n+\n+\t\t// Revoke the refresh token\n+\t\tsynapseOne.revokeRefreshToken(metadata.getTokenId());\n+\n+\t\t// Client should be unable to use access token\n+\t\ttry {\n+\t\t\tsynapseAnonymous.setBearerAuthorizationToken(tokenResponse.getAccess_token());\n+\t\t\tassertThrows(SynapseUnauthorizedException.class, () ->\n+\t\t\t\t\tsynapseAnonymous.getUserInfoAsJSONWebToken()\n+\t\t\t);\n+\t\t} finally {\n+\t\t\tsynapseAnonymous.removeAuthorizationHeader();\n+\t\t}\n+\n+\t\t// Client should be unable to use refresh token\n+\t\ttry {\n+\t\t\tsynapseAnonymous.setBasicAuthorizationCredentials(client.getClient_id(), secret.getClient_secret());\n+\t\t\tString clientUri = client.getRedirect_uris().get(0);\n+\t\t\tString refreshToken = newTokenResponse.getRefresh_token();\n+\t\t\tassertThrows(SynapseBadRequestException.class, () ->\n+\t\t\t\t\tsynapseAnonymous.getTokenResponse(OAuthGrantType.refresh_token, null,\n+\t\t\t\t\t\t\tclientUri, refreshToken, null, null)\n+\t\t\t);\n+\t\t} finally {\n+\t\t\tsynapseAnonymous.removeAuthorizationHeader();\n+\t\t}\n+\n+\n+\t\tsynapseOne.deleteOAuthClient(client.getClient_id());\n+\t\tclientToDelete=null;\n+\t}\n+\n+\t@Test\n+\tpublic void testRevokeAllTokensFromClient() throws Exception {\n+\t\t// START Set up, use authorization code\n+\t\tOAuthClient client = setUpVerifiedOAuthClient();\n+\t\tOAuthClientIdAndSecret secret = synapseOne.createOAuthClientSecret(client.getClient_id());\n+\n+\t\tOIDCAuthorizationRequest authorizationRequest = setUpAuthorizationRequest(client);\n+\n+\t\tOAuthAuthorizationResponse oauthAuthorizationResponse = synapseOne.authorizeClient(authorizationRequest);\n+\n+\t\t// Note, we use Basic auth to authorize the client when asking for an access token\n+\t\tOIDCTokenResponse tokenResponse = null;\n+\t\ttry {\n+\t\t\tsynapseAnonymous.setBasicAuthorizationCredentials(client.getClient_id(), secret.getClient_secret());\n+\t\t\ttokenResponse = synapseAnonymous.getTokenResponse(OAuthGrantType.authorization_code,\n+\t\t\t\t\toauthAuthorizationResponse.getAccess_code(), client.getRedirect_uris().get(0), null, null, null);\n+\t\t} finally {\n+\t\t\tsynapseAnonymous.removeAuthorizationHeader();\n+\t\t}\n+\t\t// END Set up. We now have a refresh token\n+\n+\t\tOAuthRefreshTokenInformationList tokens = synapseOne.getRefreshTokenMetadataForAuthorizedClient(client.getClient_id(), null);\n+\t\tString tokenId = tokens.getResults().get(0).getTokenId();\n+\n+\t\t// Test revoking all refresh tokens from a client\n+\n+\t\t// Call under test\n+\t\tsynapseOne.revokeMyRefreshTokensFromClient(client.getClient_id());\n+\n+\t\tassertThrows(SynapseNotFoundException.class, () ->\n+\t\t\t\tsynapseOne.getRefreshTokenMetadata(tokenId));\n+\n+\t\tsynapseOne.deleteOAuthClient(client.getClient_id());\n+\t\tclientToDelete=null;\n+\t}\n+\n+\t@Test\n+\tpublic void testRevokeTokensViaClient() throws Exception {\n+\t\t// START Set up, use authorization code\n+\t\tOAuthClient client = setUpVerifiedOAuthClient();", "originalCommit": "e29a5d52978a53027b8426a4134519cbfd47bf36", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgxNDY1OQ==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4088#discussion_r441814659", "bodyText": "synapseOne.deleteOAuthClient(clientToDelete.getClient_id());", "author": "brucehoff", "createdAt": "2020-06-17T20:30:15Z", "path": "integration-test/src/test/java/org/sagebionetworks/ITOpenIDConnectTest.java", "diffHunk": "@@ -334,4 +365,264 @@ public void testRoundTrip() throws Exception {\n \t\tclientToDelete=null;\n \t}\n \n+\tprivate OAuthClient setUpVerifiedOAuthClient() throws SynapseException {\n+\t\tOAuthClient client = new OAuthClient();\n+\t\tclient.setClient_name(\"some client\");\n+\t\tclient.setRedirect_uris(Collections.singletonList(\"https://foo.bar.com\"));\n+\t\tclient = synapseOne.createOAuthClient(client);\n+\t\tclientToDelete = client.getClient_id();\n+\t\treturn adminSynapse.updateOAuthClientVerifiedStatus(client.getClient_id(), client.getEtag(), true);\n+\t}\n+\n+\tprivate static OIDCAuthorizationRequest setUpAuthorizationRequest(OAuthClient client) throws Exception {\n+\t\tOIDCAuthorizationRequest authorizationRequest = new OIDCAuthorizationRequest();\n+\t\tauthorizationRequest.setClientId(client.getClient_id());\n+\t\tauthorizationRequest.setRedirectUri(client.getRedirect_uris().get(0));\n+\t\tauthorizationRequest.setResponseType(OAuthResponseType.code);\n+\t\tauthorizationRequest.setScope(\"openid offline_access\"); // offline_access is needed for a refresh token\n+\n+\t\tMap<String, OIDCClaimsRequestDetails> claimsToRequest = new HashMap<>();\n+\t\tclaimsToRequest.put(OIDCClaimName.userid.name(), null);\n+\t\tclaimsToRequest.put(OIDCClaimName.email.name(), null);\n+\t\tclaimsToRequest.put(OIDCClaimName.is_certified.name(), null);\n+\t\tOIDCClaimsRequestDetails teamClaimRequestDetails = new OIDCClaimsRequestDetails();\n+\t\tteamClaimRequestDetails.setValues(Collections.singletonList(\"2\"));\n+\t\tclaimsToRequest.put(OIDCClaimName.team.name(), teamClaimRequestDetails);\n+\t\tOIDCClaimsRequest claimsRequest = new OIDCClaimsRequest();\n+\t\tclaimsRequest.setId_token(claimsToRequest);\n+\t\tclaimsRequest.setUserinfo(claimsToRequest);\n+\t\tauthorizationRequest.setClaims(claimsRequest);\n+\n+\t\tString nonce = UUID.randomUUID().toString();\n+\t\tauthorizationRequest.setNonce(nonce);\n+\t\treturn  authorizationRequest;\n+\t}\n+\n+\t@Test\n+\tpublic void testRefreshTokenGrantTypeRoundTrip() throws Exception {\n+\t\tOAuthClient client = setUpVerifiedOAuthClient();\n+\t\tOAuthClientIdAndSecret secret = synapseOne.createOAuthClientSecret(client.getClient_id());\n+\n+\t\tOIDCAuthorizationRequest authorizationRequest = setUpAuthorizationRequest(client);\n+\n+\t\tOAuthAuthorizationResponse oauthAuthorizationResponse = synapseOne.authorizeClient(authorizationRequest);\n+\n+\t\t// Note, we use Basic auth to authorize the client when asking for an access token\n+\t\tOIDCTokenResponse tokenResponse = null;\n+\t\ttry {\n+\t\t\tsynapseAnonymous.setBasicAuthorizationCredentials(client.getClient_id(), secret.getClient_secret());\n+\t\t\ttokenResponse = synapseAnonymous.getTokenResponse(OAuthGrantType.authorization_code,\n+\t\t\t\t\toauthAuthorizationResponse.getAccess_code(), client.getRedirect_uris().get(0), null, null, null);\n+\t\t} finally {\n+\t\t\tsynapseAnonymous.removeAuthorizationHeader();\n+\t\t}\n+\n+\t\t// get another access token using our refresh token\n+\t\tOIDCTokenResponse newTokenResponse = null;\n+\t\ttry {\n+\t\t\tsynapseAnonymous.setBasicAuthorizationCredentials(client.getClient_id(), secret.getClient_secret());\n+\t\t\tnewTokenResponse = synapseAnonymous.getTokenResponse(OAuthGrantType.refresh_token, null,\n+\t\t\t\t\tclient.getRedirect_uris().get(0), tokenResponse.getRefresh_token(), null, null);\n+\n+\t\t} finally {\n+\t\t\tsynapseAnonymous.removeAuthorizationHeader();\n+\t\t}\n+\t\t// The refresh token should be rotated\n+\t\tassertFalse(StringUtils.isBlank(newTokenResponse.getRefresh_token()));\n+\t\tassertNotEquals(tokenResponse.getRefresh_token(), newTokenResponse.getRefresh_token());\n+\n+\t\t// New ID and access tokens should be retrieved\n+\t\tassertFalse(StringUtils.isBlank(newTokenResponse.getId_token()));\n+\t\tassertNotEquals(tokenResponse.getId_token(), newTokenResponse.getId_token());\n+\t\tassertFalse(StringUtils.isBlank(newTokenResponse.getAccess_token()));\n+\t\tassertNotEquals(tokenResponse.getAccess_token(), newTokenResponse.getAccess_token());\n+\n+\t\t// The old refresh token shouldn't work anymore.\n+\t\ttry {\n+\t\t\tsynapseAnonymous.setBasicAuthorizationCredentials(client.getClient_id(), secret.getClient_secret());\n+\t\t\tString clientUri = client.getRedirect_uris().get(0);\n+\t\t\tString oldRefreshToken = tokenResponse.getRefresh_token();\n+\t\t\tassertThrows(SynapseBadRequestException.class, () ->\n+\t\t\t\t\tsynapseAnonymous.getTokenResponse(OAuthGrantType.refresh_token, null,\n+\t\t\t\t\tclientUri, oldRefreshToken, null, null));\n+\t\t} finally {\n+\t\t\tsynapseAnonymous.removeAuthorizationHeader();\n+\t\t}\n+\n+\t\t// Both the old and the new access tokens should work\n+\t\ttry { // Get userInfo using old access token\n+\t\t\tsynapseAnonymous.setBearerAuthorizationToken(tokenResponse.getAccess_token());\n+\t\t\tJSONObject userInfo = synapseAnonymous.getUserInfoAsJSON();\n+\t\t\tassertTrue((Boolean)userInfo.get(\"is_certified\"));\n+\t\t} finally {\n+\t\t\tsynapseAnonymous.removeAuthorizationHeader();\n+\t\t}\n+\n+\t\t// The old refresh token should not work\n+\t\ttry {\n+\t\t\tsynapseAnonymous.setBasicAuthorizationCredentials(client.getClient_id(), secret.getClient_secret());\n+\t\t\tString clientUri = client.getRedirect_uris().get(0);\n+\t\t\tString refreshToken = tokenResponse.getRefresh_token();\n+\t\t\tassertThrows(SynapseBadRequestException.class, () ->\n+\t\t\t\t\tsynapseAnonymous.getTokenResponse(OAuthGrantType.refresh_token, null,\n+\t\t\t\t\t\t\tclientUri, refreshToken, null, null)\n+\t\t\t);\n+\t\t} finally {\n+\t\t\tsynapseAnonymous.removeAuthorizationHeader();\n+\t\t}\n+\n+\n+\t\ttry { // Get userInfo using new access token\n+\t\t\tsynapseAnonymous.setBearerAuthorizationToken(newTokenResponse.getAccess_token());\n+\t\t\tJSONObject userInfo = synapseAnonymous.getUserInfoAsJSON();\n+\t\t\tassertTrue((Boolean)userInfo.get(\"is_certified\"));\n+\t\t} finally {\n+\t\t\tsynapseAnonymous.removeAuthorizationHeader();\n+\t\t}\n+\n+\t\t// Audit clients -- there should only be one active client\n+\t\t// Call under test\n+\t\tOAuthClientAuthorizationHistoryList authzHistory = synapseOne.getClientAuthorizationHistory(null);\n+\t\tassertEquals(1, authzHistory.getResults().size());\n+\t\tassertNull(authzHistory.getNextPageToken());\n+\t\tassertEquals(client.getClient_id(), authzHistory.getResults().get(0).getClient().getClient_id());\n+\n+\t\t// Audit tokens -- there should only be one token for the sole active client\n+\t\t// Call under test\n+\t\tOAuthRefreshTokenInformationList tokenList = synapseOne.getRefreshTokenMetadataForAuthorizedClient(client.getClient_id(), null);\n+\t\tassertEquals(1, tokenList.getResults().size());\n+\t\tassertNull(tokenList.getNextPageToken());\n+\t\tassertEquals(synapseOne.getMyProfile().getOwnerId(), tokenList.getResults().get(0).getPrincipalId());\n+\t\tassertEquals(client.getClient_id(), tokenList.getResults().get(0).getClientId());\n+\t\tassertEquals(authorizationRequest.getClaims(), tokenList.getResults().get(0).getClaims());\n+\n+\t\t// Retrieving the refresh token metadata should yield the same result\n+\t\tOAuthRefreshTokenInformation metadata = synapseOne.getRefreshTokenMetadata(tokenList.getResults().get(0).getTokenId());\n+\t\tassertEquals(tokenList.getResults().get(0), metadata);\n+\n+\t\t// Rename the refresh token\n+\t\tmetadata.setName(\"a new refresh token name\");\n+\t\t// Call under test\n+\t\tsynapseOne.updateRefreshTokenMetadata(metadata);\n+\t\tOAuthRefreshTokenInformation newMetadata = synapseOne.getRefreshTokenMetadata(tokenList.getResults().get(0).getTokenId());\n+\n+\t\tassertEquals(metadata.getName(), newMetadata.getName());\n+\n+\t\t// The OAuth client should be able to get the refresh token metadata as well\n+\t\ttry {\n+\t\t\tsynapseAnonymous.setBasicAuthorizationCredentials(client.getClient_id(), secret.getClient_secret());\n+\t\t\tassertEquals(newMetadata, synapseAnonymous.getRefreshTokenMetadataAsOAuthClient(metadata.getTokenId()));\n+\t\t} finally {\n+\t\t\tsynapseAnonymous.removeAuthorizationHeader();\n+\t\t}\n+\n+\t\t// Revoke the refresh token\n+\t\tsynapseOne.revokeRefreshToken(metadata.getTokenId());\n+\n+\t\t// Client should be unable to use access token\n+\t\ttry {\n+\t\t\tsynapseAnonymous.setBearerAuthorizationToken(tokenResponse.getAccess_token());\n+\t\t\tassertThrows(SynapseUnauthorizedException.class, () ->\n+\t\t\t\t\tsynapseAnonymous.getUserInfoAsJSONWebToken()\n+\t\t\t);\n+\t\t} finally {\n+\t\t\tsynapseAnonymous.removeAuthorizationHeader();\n+\t\t}\n+\n+\t\t// Client should be unable to use refresh token\n+\t\ttry {\n+\t\t\tsynapseAnonymous.setBasicAuthorizationCredentials(client.getClient_id(), secret.getClient_secret());\n+\t\t\tString clientUri = client.getRedirect_uris().get(0);\n+\t\t\tString refreshToken = newTokenResponse.getRefresh_token();\n+\t\t\tassertThrows(SynapseBadRequestException.class, () ->\n+\t\t\t\t\tsynapseAnonymous.getTokenResponse(OAuthGrantType.refresh_token, null,\n+\t\t\t\t\t\t\tclientUri, refreshToken, null, null)\n+\t\t\t);\n+\t\t} finally {\n+\t\t\tsynapseAnonymous.removeAuthorizationHeader();\n+\t\t}\n+\n+\n+\t\tsynapseOne.deleteOAuthClient(client.getClient_id());\n+\t\tclientToDelete=null;\n+\t}\n+\n+\t@Test\n+\tpublic void testRevokeAllTokensFromClient() throws Exception {\n+\t\t// START Set up, use authorization code\n+\t\tOAuthClient client = setUpVerifiedOAuthClient();\n+\t\tOAuthClientIdAndSecret secret = synapseOne.createOAuthClientSecret(client.getClient_id());\n+\n+\t\tOIDCAuthorizationRequest authorizationRequest = setUpAuthorizationRequest(client);\n+\n+\t\tOAuthAuthorizationResponse oauthAuthorizationResponse = synapseOne.authorizeClient(authorizationRequest);\n+\n+\t\t// Note, we use Basic auth to authorize the client when asking for an access token\n+\t\tOIDCTokenResponse tokenResponse = null;\n+\t\ttry {\n+\t\t\tsynapseAnonymous.setBasicAuthorizationCredentials(client.getClient_id(), secret.getClient_secret());\n+\t\t\ttokenResponse = synapseAnonymous.getTokenResponse(OAuthGrantType.authorization_code,\n+\t\t\t\t\toauthAuthorizationResponse.getAccess_code(), client.getRedirect_uris().get(0), null, null, null);\n+\t\t} finally {\n+\t\t\tsynapseAnonymous.removeAuthorizationHeader();\n+\t\t}\n+\t\t// END Set up. We now have a refresh token\n+\n+\t\tOAuthRefreshTokenInformationList tokens = synapseOne.getRefreshTokenMetadataForAuthorizedClient(client.getClient_id(), null);\n+\t\tString tokenId = tokens.getResults().get(0).getTokenId();\n+\n+\t\t// Test revoking all refresh tokens from a client\n+\n+\t\t// Call under test\n+\t\tsynapseOne.revokeMyRefreshTokensFromClient(client.getClient_id());\n+\n+\t\tassertThrows(SynapseNotFoundException.class, () ->\n+\t\t\t\tsynapseOne.getRefreshTokenMetadata(tokenId));\n+\n+\t\tsynapseOne.deleteOAuthClient(client.getClient_id());\n+\t\tclientToDelete=null;\n+\t}\n+\n+\t@Test\n+\tpublic void testRevokeTokensViaClient() throws Exception {\n+\t\t// START Set up, use authorization code\n+\t\tOAuthClient client = setUpVerifiedOAuthClient();\n+\t\tOAuthClientIdAndSecret secret = synapseOne.createOAuthClientSecret(client.getClient_id());\n+\n+\t\tOIDCAuthorizationRequest authorizationRequest = setUpAuthorizationRequest(client);\n+\n+\t\tOAuthAuthorizationResponse oauthAuthorizationResponse = synapseOne.authorizeClient(authorizationRequest);\n+\n+\t\t// Note, we use Basic auth to authorize the client when asking for an access token\n+\t\tOIDCTokenResponse tokenResponse = null;\n+\t\ttry {\n+\t\t\tsynapseAnonymous.setBasicAuthorizationCredentials(client.getClient_id(), secret.getClient_secret());\n+\t\t\ttokenResponse = synapseAnonymous.getTokenResponse(OAuthGrantType.authorization_code,\n+\t\t\t\t\toauthAuthorizationResponse.getAccess_code(), client.getRedirect_uris().get(0), null, null, null);\n+\t\t} finally {\n+\t\t\tsynapseAnonymous.removeAuthorizationHeader();\n+\t\t}\n+\t\t// END Set up. We now have a refresh token\n+\n+\t\tOAuthRefreshTokenInformationList tokens = synapseOne.getRefreshTokenMetadataForAuthorizedClient(client.getClient_id(), null);\n+\t\tString tokenId = tokens.getResults().get(0).getTokenId();\n+\n+\t\t// Test revoking a token as a client\n+\t\tOAuthTokenRevocationRequest revocationRequest = new OAuthTokenRevocationRequest();\n+\t\trevocationRequest.setToken(tokenResponse.getRefresh_token());\n+\t\trevocationRequest.setToken_type_hint(TokenTypeHint.refresh_token);\n+\t\ttry {\n+\t\t\tsynapseAnonymous.setBasicAuthorizationCredentials(client.getClient_id(), secret.getClient_secret());\n+\t\t\t// Call under test\n+\t\t\tsynapseAnonymous.revokeToken(revocationRequest);\n+\t\t} finally {\n+\t\t\tsynapseAnonymous.removeAuthorizationHeader();\n+\t\t}\n+\n+\t\tassertThrows(SynapseNotFoundException.class, () ->\n+\t\t\t\tsynapseOne.getRefreshTokenMetadata(tokenId));\n+\n+\t\tsynapseOne.deleteOAuthClient(client.getClient_id());", "originalCommit": "e29a5d52978a53027b8426a4134519cbfd47bf36", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgyMTg5NQ==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4088#discussion_r441821895", "bodyText": "token->tokens", "author": "brucehoff", "createdAt": "2020-06-17T20:41:47Z", "path": "services/repository/src/main/java/org/sagebionetworks/auth/controller/OpenIDConnectController.java", "diffHunk": "@@ -356,4 +364,146 @@ Object getUserInfoPOST(\n \t\treturn serviceProvider.getOpenIDConnectService().getUserInfo(accessToken, getEndpoint(uriComponentsBuilder));\n \t}\n \n+\t/**\n+\t * Get a paginated list of the OAuth 2 clients that currently have active refresh tokens that grant access to the user's\n+\t * Synapse identity and/or resources. OAuth 2.0 clients that have no active refresh tokens will not appear in this list.\n+\t *\n+\t * @throws NotFoundException\n+\t * @throws OAuthClientNotVerifiedException if the client is not verified\n+\t */\n+\t@RequiredScope({view})\n+\t@ResponseStatus(HttpStatus.OK)\n+\t@RequestMapping(value = UrlHelpers.OAUTH_2_AUDIT_CLIENTS, method = RequestMethod.GET)\n+\tpublic @ResponseBody\n+\tOAuthClientAuthorizationHistoryList getGrantedClientsForUser(\n+\t\t\t@RequestParam(value = AuthorizationConstants.USER_ID_PARAM) Long userId,\n+\t\t\t@RequestParam(value = UrlHelpers.NEXT_PAGE_TOKEN_PARAM, required=false) String nextPageToken\n+\t) throws NotFoundException {\n+\t\treturn serviceProvider.getOpenIDConnectService().getClientAuthorizationHistory(userId, nextPageToken);\n+\t}\n+\n+\t/**\n+\t * Get a paginated list of metadata about refresh tokens granted to a particular OAuth 2 clients on\n+\t * behalf of the requesting user. The token itself may not be retrieved.\n+\t * Refresh tokens that have been revoked will not be included in this list.\n+\t *\n+\t * @throws NotFoundException\n+\t */\n+\t@RequiredScope({view})\n+\t@ResponseStatus(HttpStatus.OK)\n+\t@RequestMapping(value = UrlHelpers.OAUTH_2_AUDIT_CLIENT_TOKENS, method = RequestMethod.GET)\n+\tpublic @ResponseBody\n+\tOAuthRefreshTokenInformationList getGrantedTokenMetadataForUserClientPair(\n+\t\t\t@RequestParam(value = AuthorizationConstants.USER_ID_PARAM) Long userId,\n+\t\t\t@PathVariable String clientId,\n+\t\t\t@RequestParam(value = UrlHelpers.NEXT_PAGE_TOKEN_PARAM, required=false) String nextPageToken\n+\t) throws NotFoundException {\n+\t\treturn serviceProvider.getOpenIDConnectService().getTokenMetadataForGrantedClient(userId, clientId, nextPageToken);\n+\t}\n+\n+\n+\t/**\n+\t * Retrieve the metadata for an OAuth 2.0 refresh token as an authenticated Synapse user.\n+\t *\n+\t * Users that wish to retrieve OAuth 2.0 refresh token metadata should use\n+\t * <a href=\"${GET.oauth2.token.tokenId.metadata}\">GET /oauth2/token/{tokenId}/metadata</a>\n+\t *\n+\t * @throws NotFoundException\n+\t */\n+\t@RequiredScope({view})\n+\t@ResponseStatus(HttpStatus.OK)\n+\t@RequestMapping(value = UrlHelpers.OAUTH_2_AUDIT_TOKENS_ID_METADATA, method = RequestMethod.GET)\n+\tpublic @ResponseBody\n+\tOAuthRefreshTokenInformation getRefreshTokenMetadataAsUser(\n+\t\t\t@RequestParam(value = AuthorizationConstants.USER_ID_PARAM) Long userId,\n+\t\t\t@PathVariable String tokenId) throws NotFoundException {\n+\t\treturn serviceProvider.getOpenIDConnectService().getRefreshTokenMetadataAsUser(userId, tokenId);\n+\t}\n+\n+\t/**\n+\t * Retrieve the metadata for an OAuth 2.0 refresh token. The request should be made as an OAuth 2.0 client using\n+\t * basic authentication.\n+\t *\n+\t * Users that wish to retrieve OAuth 2.0 refresh token metadata should use\n+\t * <a href=\"${GET.oauth2.audit.tokens.tokenId.metadata}\">GET /oauth2/audit/tokens/{tokenId}/metadata</a>\n+\t *\n+\t * @throws NotFoundException\n+\t */\n+\t@RequiredScope({view})\n+\t@ResponseStatus(HttpStatus.OK)\n+\t@RequestMapping(value = UrlHelpers.OAUTH_2_TOKEN_ID_METADATA, method = RequestMethod.GET)\n+\tpublic @ResponseBody\n+\tOAuthRefreshTokenInformation getRefreshTokenMetadataAsClient(\n+\t\t\t@RequestHeader(value = AuthorizationConstants.OAUTH_VERIFIED_CLIENT_ID_HEADER) String verifiedClientId,\n+\t\t\t@PathVariable String tokenId) throws NotFoundException {\n+\t\treturn serviceProvider.getOpenIDConnectService().getRefreshTokenMetadataAsClient(verifiedClientId, tokenId);\n+\t}\n+\n+\t/**\n+\t * Update the metadata for a refresh token. At this time, the only field that a user may set is the 'name' field.\n+\t *\n+\t * @throws NotFoundException\n+\t */\n+\t@RequiredScope({view, modify})\n+\t@ResponseStatus(HttpStatus.OK)\n+\t@RequestMapping(value = UrlHelpers.OAUTH_2_AUDIT_TOKENS_ID_METADATA, method = RequestMethod.PUT)\n+\tpublic @ResponseBody\n+\tOAuthRefreshTokenInformation updateRefreshTokenMetadata(\n+\t\t\t@RequestParam(value = AuthorizationConstants.USER_ID_PARAM) Long userId,\n+\t\t\t@PathVariable String tokenId,\n+\t\t\t@RequestBody OAuthRefreshTokenInformation metadata) throws NotFoundException {\n+\t\treturn serviceProvider.getOpenIDConnectService().updateRefreshTokenMetadata(userId, tokenId, metadata);\n+\t}\n+\n+\t/**\n+\t * Revoke all refresh token and their related access tokens associated with a particular client and the requesting user.", "originalCommit": "e29a5d52978a53027b8426a4134519cbfd47bf36", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8a47f6e2b4fa62e235d8ad3d314fd2fdc5f95315", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/8a47f6e2b4fa62e235d8ad3d314fd2fdc5f95315", "message": "Another batch of code review changes #4088", "committedDate": "2020-06-18T12:48:01Z", "type": "commit"}, {"oid": "55ad2c950357772afc7fbc481081f4665d34f731", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/55ad2c950357772afc7fbc481081f4665d34f731", "message": "Merge remote-tracking branch 'upstream/develop' into PLFM-5753.1", "committedDate": "2020-06-18T12:57:48Z", "type": "commit"}, {"oid": "afc12b6209c616b143b2281a4e28cd8b77b69af9", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/afc12b6209c616b143b2281a4e28cd8b77b69af9", "message": "Fix discovery document test", "committedDate": "2020-06-18T14:56:37Z", "type": "commit"}]}