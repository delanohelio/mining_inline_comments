{"pr_number": 4189, "pr_title": "PLFM-6195: Unified exception handling", "pr_createdAt": "2020-09-03T00:32:39Z", "pr_url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4189", "timeline": [{"oid": "1b76c834b9a62c8fc6bcc7d8787bc23812f2e6e8", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/1b76c834b9a62c8fc6bcc7d8787bc23812f2e6e8", "message": "PLFM-6195: Unified exception handling", "committedDate": "2020-09-03T00:30:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzMxMzcxNA==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4189#discussion_r483313714", "bodyText": "might want the full name", "author": "john-hill", "createdAt": "2020-09-03T23:59:05Z", "path": "services/repository/src/test/java/org/sagebionetworks/repo/web/filter/UnexpectedExceptionFilterTest.java", "diffHunk": "@@ -1,89 +1,168 @@\n package org.sagebionetworks.repo.web.filter;\r\n \r\n+import static org.junit.jupiter.api.Assertions.assertEquals;\r\n import static org.mockito.ArgumentMatchers.any;\r\n import static org.mockito.ArgumentMatchers.anyInt;\r\n import static org.mockito.Mockito.doThrow;\r\n import static org.mockito.Mockito.never;\r\n import static org.mockito.Mockito.verify;\r\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\r\n import static org.mockito.Mockito.when;\r\n \r\n import java.io.IOException;\r\n import java.io.PrintWriter;\r\n+import java.util.Collections;\r\n+import java.util.Date;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n \r\n import javax.servlet.FilterChain;\r\n import javax.servlet.ServletException;\r\n-import javax.servlet.ServletRequest;\r\n-import javax.servlet.ServletResponse;\r\n import javax.servlet.http.HttpServletRequest;\r\n import javax.servlet.http.HttpServletResponse;\r\n \r\n import org.apache.http.HttpStatus;\r\n-import org.junit.Before;\r\n-import org.junit.Test;\r\n-import org.junit.runner.RunWith;\r\n+import org.junit.jupiter.api.BeforeEach;\r\n+import org.junit.jupiter.api.Test;\r\n+import org.junit.jupiter.api.extension.ExtendWith;\r\n+import org.mockito.ArgumentCaptor;\r\n+import org.mockito.Captor;\r\n+import org.mockito.InjectMocks;\r\n import org.mockito.Mock;\r\n-import org.mockito.junit.MockitoJUnitRunner;\r\n+import org.mockito.junit.jupiter.MockitoExtension;\r\n+import org.sagebionetworks.StackConfiguration;\r\n+import org.sagebionetworks.cloudwatch.Consumer;\r\n+import org.sagebionetworks.cloudwatch.MetricUtils;\r\n+import org.sagebionetworks.cloudwatch.ProfileData;\r\n import org.sagebionetworks.repo.model.AuthorizationConstants;\r\n import org.springframework.http.MediaType;\r\n-import org.springframework.web.servlet.NoHandlerFoundException;\r\n+import org.springframework.web.servlet.HandlerExceptionResolver;\r\n+import org.springframework.web.servlet.ModelAndView;\r\n \r\n-@RunWith(MockitoJUnitRunner.class)\r\n+import com.amazonaws.services.cloudwatch.model.StandardUnit;\r\n+import com.google.common.collect.ImmutableList;\r\n+\r\n+@ExtendWith(MockitoExtension.class)\r\n public class UnexpectedExceptionFilterTest {\r\n \r\n \t@Mock\r\n-\tHttpServletRequest mockRequest;\r\n+\tprivate StackConfiguration mockStackConfig;\r\n \t@Mock\r\n-\tHttpServletResponse mockResponse;\r\n+\tprivate Consumer mockConsumer;\r\n \t@Mock\r\n-\tFilterChain mockChain;\r\n+\tprivate HttpServletRequest mockRequest;\r\n \t@Mock\r\n-\tPrintWriter mockWriter;\r\n-\r\n-\tUnexpectedExceptionFilter filter;\r\n-\r\n+\tprivate HttpServletResponse mockResponse;\r\n+\t@Mock\r\n+\tprivate FilterChain mockChain;\r\n+\t@Mock\r\n+\tprivate PrintWriter mockWriter;\r\n+\t@Mock\r\n+\tprivate HandlerExceptionResolver mockExceptionResolver;\r\n+\t\r\n+\t@InjectMocks\r\n+\tprivate UnexpectedExceptionFilter filter;\r\n+\t\r\n+\t@Captor\r\n+\tprivate ArgumentCaptor<List<ProfileData>> dataCaptor;\r\n \r\n-\t@Before\r\n-\tpublic void before() throws IOException{\r\n-\t\tfilter = new UnexpectedExceptionFilter();\r\n-\t\twhen(mockResponse.getWriter()).thenReturn(mockWriter);\r\n+\tprivate String stackInstance = \"stackInstance\";\r\n+\tprivate String requestUri = \"/some/path\";\r\n+\t\r\n+\t@BeforeEach\r\n+\tpublic void before() {\r\n+\t\tfilter.configureExceptionResolvers(Collections.singletonList(mockExceptionResolver));\r\n \t}\r\n \t\r\n \t@Test\r\n-\tpublic void testNoException() throws IOException, ServletException{\r\n+\tpublic void testWithNoException() throws IOException, ServletException{\r\n \t\tfilter.doFilter(mockRequest, mockResponse, mockChain);\r\n \t\t// The response should not be changed\r\n \t\tverify(mockResponse, never()).setStatus(anyInt());\r\n \t\tverify(mockResponse, never()).getWriter();\r\n \t}\r\n \r\n-\t/**\r\n-\t * We expect the server to recover from exceptions, so 503 is returned.\r\n-\t * @throws IOException\r\n-\t * @throws ServletException\r\n-\t */\r\n \t@Test\r\n-\tpublic void testServletException() throws IOException, ServletException{\r\n-\t\tServletException error = new ServletException(\"Exception\");\r\n-\t\tdoThrow(error).when(mockChain).doFilter(any(ServletRequest.class), any(ServletResponse.class));\r\n+\tpublic void testWithUnresolvedException() throws IOException, ServletException {\r\n+\t\tServletException exception = new ServletException(\"Exception\");\r\n+\t\t\r\n+\t\tdoThrow(exception).when(mockChain).doFilter(any(), any());\r\n+\t\t\r\n+\t\twhen(mockRequest.getRequestURI()).thenReturn(requestUri);\r\n+\t\twhen(mockExceptionResolver.resolveException(any(), any(), any(), any())).thenReturn(null);\r\n+\t\twhen(mockResponse.getWriter()).thenReturn(mockWriter);\r\n+\t\twhen(mockStackConfig.getStackInstance()).thenReturn(stackInstance);\r\n+\t\t\r\n+\t\t// Call under test\r\n \t\tfilter.doFilter(mockRequest, mockResponse, mockChain);\r\n-\t\t// The response should not be changed\r\n-\t\tverify(mockResponse).setStatus(HttpStatus.SC_SERVICE_UNAVAILABLE);\r\n+\t\t\r\n+\t\tverify(mockConsumer).addProfileData(dataCaptor.capture());\r\n+\t\t\r\n+\t\tList<ProfileData> profileData = dataCaptor.getValue();\r\n+\t\t\r\n+\t\tList<ProfileData> expectedData = ImmutableList.of(\r\n+\t\t\t\texpectedProfileData(profileData.get(0).getTimestamp(), exception, false, requestUri),\r\n+\t\t\t\texpectedProfileData(profileData.get(1).getTimestamp(), exception, true, requestUri)\r\n+\t\t);\t\t\r\n+\t\t\r\n+\t\tassertEquals(expectedData, profileData);\r\n+\t\r\n+\t\tverify(mockExceptionResolver).resolveException(mockRequest, mockResponse, null, exception);\r\n+\t\tverify(mockResponse).setStatus(HttpStatus.SC_INTERNAL_SERVER_ERROR);\r\n \t\tverify(mockResponse).setContentType(MediaType.APPLICATION_JSON_VALUE);\r\n-\t\tverify(mockWriter).println(\"{\\\"reason\\\":\\\"Server error, try again later: Exception\\\"}\");\r\n+\t\tverify(mockResponse).getWriter();\r\n+\t\tverify(mockWriter).println(AuthorizationConstants.REASON_SERVER_ERROR);\r\n \t}\r\n \t\r\n-\t/**\r\n-\t * We do not expect the server to recover from errors, so 500 is returned.\r\n-\t * @throws IOException\r\n-\t * @throws ServletException\r\n-\t */\r\n \t@Test\r\n-\tpublic void testOutOfMemoryError() throws IOException, ServletException{\r\n-\t\tOutOfMemoryError error = new OutOfMemoryError(\"Exception\");\r\n-\t\tdoThrow(error).when(mockChain).doFilter(any(ServletRequest.class), any(ServletResponse.class));\r\n+\tpublic void testWithResolvedException() throws IOException, ServletException {\r\n+\t\tServletException exception = new ServletException(\"Exception\");\r\n+\t\t\r\n+\t\tdoThrow(exception).when(mockChain).doFilter(any(), any());\r\n+\t\t\r\n+\t\twhen(mockRequest.getRequestURI()).thenReturn(requestUri);\r\n+\t\twhen(mockExceptionResolver.resolveException(any(), any(), any(), any())).thenReturn(new ModelAndView());\r\n+\t\twhen(mockStackConfig.getStackInstance()).thenReturn(stackInstance);\r\n+\t\t\r\n+\t\t// Call under test\r\n \t\tfilter.doFilter(mockRequest, mockResponse, mockChain);\r\n-\t\t// The response should not be changed\r\n-\t\tverify(mockResponse).setStatus(HttpStatus.SC_INTERNAL_SERVER_ERROR);\r\n-\t\tverify(mockWriter).println(AuthorizationConstants.REASON_SERVER_ERROR);\r\n+\t\t\r\n+\t\tverify(mockConsumer).addProfileData(dataCaptor.capture());\r\n+\t\t\r\n+\t\tList<ProfileData> profileData = dataCaptor.getValue();\r\n+\t\t\r\n+\t\tList<ProfileData> expectedData = ImmutableList.of(\r\n+\t\t\t\texpectedProfileData(profileData.get(0).getTimestamp(), exception, false, requestUri),\r\n+\t\t\t\texpectedProfileData(profileData.get(1).getTimestamp(), exception, true, requestUri)\r\n+\t\t);\t\t\r\n+\t\t\r\n+\t\tassertEquals(expectedData, profileData);\r\n+\t\r\n+\t\tverify(mockExceptionResolver).resolveException(mockRequest, mockResponse, null, exception);\r\n+\t\tverifyNoMoreInteractions(mockResponse);\r\n+\t}\r\n+\t\r\n+\tprivate ProfileData expectedProfileData(Date timestamp, Throwable ex, boolean withMessage, String uri) {\r\n+\t\tProfileData logEvent = new ProfileData();\r\n+\r\n+\t\tlogEvent.setNamespace(\"UnexpectedExceptionFilter - \" + stackInstance);\r\n+\t\tlogEvent.setName(\"UnhandledException\");\r\n+\t\tlogEvent.setValue(1.0);\r\n+\t\tlogEvent.setUnit(StandardUnit.Count.toString());\r\n+\t\tlogEvent.setTimestamp(timestamp);\r\n+\t\t\r\n+\t\tMap<String, String> dimensions = new HashMap<>();\r\n+\r\n+\t\tlogEvent.setDimension(dimensions);\r\n+\t\t\r\n+\t\tdimensions.put(\"exceptionClass\", ex.getClass().getSimpleName());\r\n+\t\tdimensions.put(\"requestUri\", uri);\r", "originalCommit": "1b76c834b9a62c8fc6bcc7d8787bc23812f2e6e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}