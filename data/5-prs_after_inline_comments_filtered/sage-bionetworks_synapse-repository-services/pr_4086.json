{"pr_number": 4086, "pr_title": "PLFM-5753 / PLFM-6120 - OAuth refresh token manager", "pr_createdAt": "2020-06-09T14:43:45Z", "pr_url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4086", "timeline": [{"oid": "410873e3026924d2eb19cc5270906e9032ec9cdb", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/410873e3026924d2eb19cc5270906e9032ec9cdb", "message": "OAuth refresh token manager and unit tests", "committedDate": "2020-06-09T14:42:30Z", "type": "commit"}, {"oid": "6777a0471c1d3524b6a674df0b41e133c43054ad", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/6777a0471c1d3524b6a674df0b41e133c43054ad", "message": "SHA256 hex strings have length=64", "committedDate": "2020-06-09T18:15:11Z", "type": "commit"}, {"oid": "fe05dc4302e24ba6e4fb24880ffc6379ec3434ab", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/fe05dc4302e24ba6e4fb24880ffc6379ec3434ab", "message": "Handle queryForObject exception if there are 0 results", "committedDate": "2020-06-09T18:16:29Z", "type": "commit"}, {"oid": "dbeeba269a7a7d8592d20a2bfa396af793b43590", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/dbeeba269a7a7d8592d20a2bfa396af793b43590", "message": "Refresh token manager cleanup", "committedDate": "2020-06-09T18:18:23Z", "type": "commit"}, {"oid": "01e6f8a6c2676bf541738032aadccc365f065cd5", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/01e6f8a6c2676bf541738032aadccc365f065cd5", "message": "Add refresh_token_id claim to access token JWTs", "committedDate": "2020-06-09T18:27:04Z", "type": "commit"}, {"oid": "ffb708664fbc964b7213d7ab2f7e00d4b313d12d", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/ffb708664fbc964b7213d7ab2f7e00d4b313d12d", "message": "Add refresh token manager autowired tests", "committedDate": "2020-06-09T18:27:23Z", "type": "commit"}, {"oid": "cee4d27254ba92e06eda8dcb4627cd31a5d1ed41", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/cee4d27254ba92e06eda8dcb4627cd31a5d1ed41", "message": "Fix method signature; refresh tokens cannot be issued yet", "committedDate": "2020-06-09T18:43:53Z", "type": "commit"}, {"oid": "a43835dacad3a6ccc8ca01925f88b190aa46449c", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/a43835dacad3a6ccc8ca01925f88b190aa46449c", "message": "Fix arguments in unit test", "committedDate": "2020-06-09T19:15:27Z", "type": "commit"}, {"oid": "a56521b66059f5270be4b834cc1c8ccbdf061dc7", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/a56521b66059f5270be4b834cc1c8ccbdf061dc7", "message": "Simplify getting/rotating a refresh token via the token itself.", "committedDate": "2020-06-10T19:47:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI4OTk0OA==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4086#discussion_r438289948", "bodyText": "clientId seems unnecessary", "author": "brucehoff", "createdAt": "2020-06-10T17:24:50Z", "path": "services/repository-managers/src/main/java/org/sagebionetworks/repo/manager/oauth/OAuthRefreshTokenManager.java", "diffHunk": "@@ -0,0 +1,129 @@\n+package org.sagebionetworks.repo.manager.oauth;\n+\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.sagebionetworks.repo.model.UnauthorizedException;\n+import org.sagebionetworks.repo.model.UserInfo;\n+import org.sagebionetworks.repo.model.oauth.OAuthClientAuthorizationHistoryList;\n+import org.sagebionetworks.repo.model.oauth.OAuthRefreshTokenInformation;\n+import org.sagebionetworks.repo.model.oauth.OAuthRefreshTokenInformationList;\n+import org.sagebionetworks.repo.model.oauth.OAuthScope;\n+import org.sagebionetworks.repo.model.oauth.OAuthTokenRevocationRequest;\n+import org.sagebionetworks.repo.model.oauth.OIDCClaimsRequest;\n+import org.sagebionetworks.repo.web.NotFoundException;\n+\n+/**\n+ * The OAuthRefreshToken manager is used to create, retrieve, and manipulate the refresh tokens that grant OAuth clients\n+ * long-lived access to user resources.\n+ *\n+ * See also the {@link OpenIDConnectManager}.\n+ */\n+public interface OAuthRefreshTokenManager {\n+\n+\t/**\n+\t * Creates an OAuth 2.0 refresh token, which can be used to grant an OAuth client long-lived, revocable access\n+\t * to a user's resources\n+\t *\n+\t * @param userId\n+\t * @param clientId the client authorized to access the resources\n+\t * @param scopes the {@link OAuthScope}s that the client is authorized to access with.\n+\t * @param claims the OIDC claims that have been granted to the client. the {@link OIDCClaimsRequest} object also\n+\t *                 specifies when that information is contained in the OIDC id_token, or returned when the client\n+\t *                 makes a request at the userinfo endpoint\n+\t * @return a generated refresh token, and the refresh token's unique ID.\n+\t */\n+\tOAuthRefreshTokenAndId createRefreshToken(String userId, String clientId, List<OAuthScope> scopes, OIDCClaimsRequest claims);\n+\n+\t/**\n+\t * Retrieves token metadata, if it exists, using the unhashed token and associated {@link org.sagebionetworks.repo.model.oauth.OAuthClient} ID.\n+\t * This retrieval locks the row so that it may be updated. Therefore, a caller must use a {@link org.sagebionetworks.repo.transactions.WriteTransaction}.\n+\t * @param token the unhashed token\n+\t * @param clientId the associated client ID\n+\t * @return an {@link Optional} containing the token metadata, if it exists. Otherwise, an empty optional.\n+\t */\n+\tOptional<OAuthRefreshTokenInformation> getRefreshTokenMetadataForUpdate(String token, String clientId);", "originalCommit": "a43835dacad3a6ccc8ca01925f88b190aa46449c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI5MTU5MA==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4086#discussion_r438291590", "bodyText": "Nick says this is wrong.\nIt's not clear to me what should be returned when a refresh token is rotated.", "author": "brucehoff", "createdAt": "2020-06-10T17:27:26Z", "path": "services/repository-managers/src/main/java/org/sagebionetworks/repo/manager/oauth/OAuthRefreshTokenManager.java", "diffHunk": "@@ -0,0 +1,129 @@\n+package org.sagebionetworks.repo.manager.oauth;\n+\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.sagebionetworks.repo.model.UnauthorizedException;\n+import org.sagebionetworks.repo.model.UserInfo;\n+import org.sagebionetworks.repo.model.oauth.OAuthClientAuthorizationHistoryList;\n+import org.sagebionetworks.repo.model.oauth.OAuthRefreshTokenInformation;\n+import org.sagebionetworks.repo.model.oauth.OAuthRefreshTokenInformationList;\n+import org.sagebionetworks.repo.model.oauth.OAuthScope;\n+import org.sagebionetworks.repo.model.oauth.OAuthTokenRevocationRequest;\n+import org.sagebionetworks.repo.model.oauth.OIDCClaimsRequest;\n+import org.sagebionetworks.repo.web.NotFoundException;\n+\n+/**\n+ * The OAuthRefreshToken manager is used to create, retrieve, and manipulate the refresh tokens that grant OAuth clients\n+ * long-lived access to user resources.\n+ *\n+ * See also the {@link OpenIDConnectManager}.\n+ */\n+public interface OAuthRefreshTokenManager {\n+\n+\t/**\n+\t * Creates an OAuth 2.0 refresh token, which can be used to grant an OAuth client long-lived, revocable access\n+\t * to a user's resources\n+\t *\n+\t * @param userId\n+\t * @param clientId the client authorized to access the resources\n+\t * @param scopes the {@link OAuthScope}s that the client is authorized to access with.\n+\t * @param claims the OIDC claims that have been granted to the client. the {@link OIDCClaimsRequest} object also\n+\t *                 specifies when that information is contained in the OIDC id_token, or returned when the client\n+\t *                 makes a request at the userinfo endpoint\n+\t * @return a generated refresh token, and the refresh token's unique ID.\n+\t */\n+\tOAuthRefreshTokenAndId createRefreshToken(String userId, String clientId, List<OAuthScope> scopes, OIDCClaimsRequest claims);\n+\n+\t/**\n+\t * Retrieves token metadata, if it exists, using the unhashed token and associated {@link org.sagebionetworks.repo.model.oauth.OAuthClient} ID.\n+\t * This retrieval locks the row so that it may be updated. Therefore, a caller must use a {@link org.sagebionetworks.repo.transactions.WriteTransaction}.\n+\t * @param token the unhashed token\n+\t * @param clientId the associated client ID\n+\t * @return an {@link Optional} containing the token metadata, if it exists. Otherwise, an empty optional.\n+\t */\n+\tOptional<OAuthRefreshTokenInformation> getRefreshTokenMetadataForUpdate(String token, String clientId);\n+\n+\t/**\n+\t * Updates the hash for a refresh token and returns the new hash. Metadata (such as the token name) will be retained,", "originalCommit": "a43835dacad3a6ccc8ca01925f88b190aa46449c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMwMTc3NA==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4086#discussion_r438301774", "bodyText": "can this be combined with getRefreshTokenMetadataForUpdate into a single method that rolls back if the transaction it's in throws an exception (e.g. BadRequest)?", "author": "brucehoff", "createdAt": "2020-06-10T17:44:32Z", "path": "services/repository-managers/src/main/java/org/sagebionetworks/repo/manager/oauth/OAuthRefreshTokenManager.java", "diffHunk": "@@ -0,0 +1,129 @@\n+package org.sagebionetworks.repo.manager.oauth;\n+\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.sagebionetworks.repo.model.UnauthorizedException;\n+import org.sagebionetworks.repo.model.UserInfo;\n+import org.sagebionetworks.repo.model.oauth.OAuthClientAuthorizationHistoryList;\n+import org.sagebionetworks.repo.model.oauth.OAuthRefreshTokenInformation;\n+import org.sagebionetworks.repo.model.oauth.OAuthRefreshTokenInformationList;\n+import org.sagebionetworks.repo.model.oauth.OAuthScope;\n+import org.sagebionetworks.repo.model.oauth.OAuthTokenRevocationRequest;\n+import org.sagebionetworks.repo.model.oauth.OIDCClaimsRequest;\n+import org.sagebionetworks.repo.web.NotFoundException;\n+\n+/**\n+ * The OAuthRefreshToken manager is used to create, retrieve, and manipulate the refresh tokens that grant OAuth clients\n+ * long-lived access to user resources.\n+ *\n+ * See also the {@link OpenIDConnectManager}.\n+ */\n+public interface OAuthRefreshTokenManager {\n+\n+\t/**\n+\t * Creates an OAuth 2.0 refresh token, which can be used to grant an OAuth client long-lived, revocable access\n+\t * to a user's resources\n+\t *\n+\t * @param userId\n+\t * @param clientId the client authorized to access the resources\n+\t * @param scopes the {@link OAuthScope}s that the client is authorized to access with.\n+\t * @param claims the OIDC claims that have been granted to the client. the {@link OIDCClaimsRequest} object also\n+\t *                 specifies when that information is contained in the OIDC id_token, or returned when the client\n+\t *                 makes a request at the userinfo endpoint\n+\t * @return a generated refresh token, and the refresh token's unique ID.\n+\t */\n+\tOAuthRefreshTokenAndId createRefreshToken(String userId, String clientId, List<OAuthScope> scopes, OIDCClaimsRequest claims);\n+\n+\t/**\n+\t * Retrieves token metadata, if it exists, using the unhashed token and associated {@link org.sagebionetworks.repo.model.oauth.OAuthClient} ID.\n+\t * This retrieval locks the row so that it may be updated. Therefore, a caller must use a {@link org.sagebionetworks.repo.transactions.WriteTransaction}.\n+\t * @param token the unhashed token\n+\t * @param clientId the associated client ID\n+\t * @return an {@link Optional} containing the token metadata, if it exists. Otherwise, an empty optional.\n+\t */\n+\tOptional<OAuthRefreshTokenInformation> getRefreshTokenMetadataForUpdate(String token, String clientId);\n+\n+\t/**\n+\t * Updates the hash for a refresh token and returns the new hash. Metadata (such as the token name) will be retained,\n+\t * but certain fields may be updated (such as the Etag and the Last Used date).\n+\t *\n+\t * Prior to calling this method, the row should be locked with {@link #getRefreshTokenMetadataForUpdate}. Thus, an exception will\n+\t * be thrown if calling this method unless already in a {@link org.sagebionetworks.repo.transactions.WriteTransaction}\n+\t * @param tokenId\n+\t * @return\n+\t */\n+\tString rotateRefreshToken(String tokenId);", "originalCommit": "a43835dacad3a6ccc8ca01925f88b190aa46449c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMwNTgyNA==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4086#discussion_r438305824", "bodyText": "don't need clientId", "author": "brucehoff", "createdAt": "2020-06-10T17:51:23Z", "path": "services/repository-managers/src/main/java/org/sagebionetworks/repo/manager/oauth/OAuthRefreshTokenManager.java", "diffHunk": "@@ -0,0 +1,129 @@\n+package org.sagebionetworks.repo.manager.oauth;\n+\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.sagebionetworks.repo.model.UnauthorizedException;\n+import org.sagebionetworks.repo.model.UserInfo;\n+import org.sagebionetworks.repo.model.oauth.OAuthClientAuthorizationHistoryList;\n+import org.sagebionetworks.repo.model.oauth.OAuthRefreshTokenInformation;\n+import org.sagebionetworks.repo.model.oauth.OAuthRefreshTokenInformationList;\n+import org.sagebionetworks.repo.model.oauth.OAuthScope;\n+import org.sagebionetworks.repo.model.oauth.OAuthTokenRevocationRequest;\n+import org.sagebionetworks.repo.model.oauth.OIDCClaimsRequest;\n+import org.sagebionetworks.repo.web.NotFoundException;\n+\n+/**\n+ * The OAuthRefreshToken manager is used to create, retrieve, and manipulate the refresh tokens that grant OAuth clients\n+ * long-lived access to user resources.\n+ *\n+ * See also the {@link OpenIDConnectManager}.\n+ */\n+public interface OAuthRefreshTokenManager {\n+\n+\t/**\n+\t * Creates an OAuth 2.0 refresh token, which can be used to grant an OAuth client long-lived, revocable access\n+\t * to a user's resources\n+\t *\n+\t * @param userId\n+\t * @param clientId the client authorized to access the resources\n+\t * @param scopes the {@link OAuthScope}s that the client is authorized to access with.\n+\t * @param claims the OIDC claims that have been granted to the client. the {@link OIDCClaimsRequest} object also\n+\t *                 specifies when that information is contained in the OIDC id_token, or returned when the client\n+\t *                 makes a request at the userinfo endpoint\n+\t * @return a generated refresh token, and the refresh token's unique ID.\n+\t */\n+\tOAuthRefreshTokenAndId createRefreshToken(String userId, String clientId, List<OAuthScope> scopes, OIDCClaimsRequest claims);\n+\n+\t/**\n+\t * Retrieves token metadata, if it exists, using the unhashed token and associated {@link org.sagebionetworks.repo.model.oauth.OAuthClient} ID.\n+\t * This retrieval locks the row so that it may be updated. Therefore, a caller must use a {@link org.sagebionetworks.repo.transactions.WriteTransaction}.\n+\t * @param token the unhashed token\n+\t * @param clientId the associated client ID\n+\t * @return an {@link Optional} containing the token metadata, if it exists. Otherwise, an empty optional.\n+\t */\n+\tOptional<OAuthRefreshTokenInformation> getRefreshTokenMetadataForUpdate(String token, String clientId);\n+\n+\t/**\n+\t * Updates the hash for a refresh token and returns the new hash. Metadata (such as the token name) will be retained,\n+\t * but certain fields may be updated (such as the Etag and the Last Used date).\n+\t *\n+\t * Prior to calling this method, the row should be locked with {@link #getRefreshTokenMetadataForUpdate}. Thus, an exception will\n+\t * be thrown if calling this method unless already in a {@link org.sagebionetworks.repo.transactions.WriteTransaction}\n+\t * @param tokenId\n+\t * @return\n+\t */\n+\tString rotateRefreshToken(String tokenId);\n+\n+\t/**\n+\t * Retrieve an OAuth 2.0 refresh token's metadata using the tokens' ID, on behalf of a user\n+\t * @param userInfo\n+\t * @param tokenId\n+\t * @return\n+\t * @throws NotFoundException if the token does not exist\n+\t * @throws UnauthorizedException if the token is not associated with the user\n+\t */\n+\tOAuthRefreshTokenInformation getRefreshTokenMetadata(UserInfo userInfo, String tokenId) throws NotFoundException, UnauthorizedException;\n+\n+\t/**\n+\t * Retrieve an OAuth 2.0 refresh token's metadata using the tokens' ID, on behalf of a client\n+\t * @param clientId\n+\t * @param tokenId\n+\t * @return\n+\t * @throws NotFoundException if the token does not exist\n+\t * @throws UnauthorizedException if the token is not associated with the client\n+\t */\n+\tOAuthRefreshTokenInformation getRefreshTokenMetadata(String clientId, String tokenId) throws NotFoundException, UnauthorizedException;\n+\n+\t/**\n+\t * Retrieve a paginated record of which clients are currently granted OAuth 2.0 access to a user via active refresh tokens\n+\t * @param userInfo the user whose records should be retrieved\n+\t * @param nextPageToken {@link org.sagebionetworks.repo.model.NextPageToken} token for pagination\n+\t * @return\n+\t */\n+\tOAuthClientAuthorizationHistoryList getAuthorizedClientHistory(UserInfo userInfo, String nextPageToken);\n+\n+\t/**\n+\t * Retrieve a paginated list of metadata for active refresh tokens between a particular user and client\n+\t *\n+\t * @param userInfo\n+\t * @param clientId\n+\t * @param nextPageToken {@link org.sagebionetworks.repo.model.NextPageToken} token for pagination\n+\t * @return\n+\t */\n+\tOAuthRefreshTokenInformationList getMetadataForActiveRefreshTokens(UserInfo userInfo, String clientId, String nextPageToken);\n+\n+\t/**\n+\t * Revoke all refresh tokens between a particular user and a particular client.\n+\t * @param userInfo\n+\t * @param clientId\n+\t */\n+\tvoid revokeRefreshTokensForUserClientPair(UserInfo userInfo, String clientId);\n+\n+\t/**\n+\t * Revoke a particular refresh token using a token ID\n+\t *\n+\t * @param userInfo\n+\t * @param tokenId\n+\t * @throws NotFoundException if the token does not exist\n+\t * @throws UnauthorizedException if the token is not associated with the user\n+\t */\n+\tvoid revokeRefreshToken(UserInfo userInfo, String tokenId) throws NotFoundException, UnauthorizedException;\n+\n+\t/**\n+\t * Revokes a refresh token using the token itself. This method is usually invoked by an OAuth client, but a client\n+\t * ID is not required because if this is called by an unauthorized party, the token should be revoked anyways.\n+\t * @param clientId\n+\t * @param revocationRequest\n+\t */\n+\tvoid revokeRefreshToken(String clientId, OAuthTokenRevocationRequest revocationRequest) throws NotFoundException;", "originalCommit": "a43835dacad3a6ccc8ca01925f88b190aa46449c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA0Mzc4MQ==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4086#discussion_r439043781", "bodyText": "A more standard method signature would be:\nOAuthRefreshTokenAndMetadata  rotateToken(String refreshToken)\nit's understood that if an exception is thrown the transaction will rollback.", "author": "brucehoff", "createdAt": "2020-06-11T20:14:10Z", "path": "services/repository-managers/src/main/java/org/sagebionetworks/repo/manager/oauth/OAuthRefreshTokenManager.java", "diffHunk": "@@ -0,0 +1,117 @@\n+package org.sagebionetworks.repo.manager.oauth;\n+\n+import java.util.List;\n+\n+import org.sagebionetworks.repo.model.UnauthorizedException;\n+import org.sagebionetworks.repo.model.UserInfo;\n+import org.sagebionetworks.repo.model.oauth.OAuthClientAuthorizationHistoryList;\n+import org.sagebionetworks.repo.model.oauth.OAuthRefreshTokenInformation;\n+import org.sagebionetworks.repo.model.oauth.OAuthRefreshTokenInformationList;\n+import org.sagebionetworks.repo.model.oauth.OAuthScope;\n+import org.sagebionetworks.repo.model.oauth.OAuthTokenRevocationRequest;\n+import org.sagebionetworks.repo.model.oauth.OIDCClaimsRequest;\n+import org.sagebionetworks.repo.web.NotFoundException;\n+\n+/**\n+ * The OAuthRefreshToken manager is used to create, retrieve, and manipulate the refresh tokens that grant OAuth clients\n+ * long-lived access to user resources.\n+ *\n+ * See also the {@link OpenIDConnectManager}.\n+ */\n+public interface OAuthRefreshTokenManager {\n+\n+\t/**\n+\t * Creates an OAuth 2.0 refresh token, which can be used to grant an OAuth client long-lived, revocable access\n+\t * to a user's resources\n+\t *\n+\t * @param userId\n+\t * @param clientId the client authorized to access the resources\n+\t * @param scopes the {@link OAuthScope}s that the client is authorized to access with.\n+\t * @param claims the OIDC claims that have been granted to the client. the {@link OIDCClaimsRequest} object also\n+\t *                 specifies when that information is contained in the OIDC id_token, or returned when the client\n+\t *                 makes a request at the userinfo endpoint\n+\t * @return a generated refresh token, and the refresh token's unique ID.\n+\t */\n+\tOAuthRefreshTokenAndMetadata createRefreshToken(String userId, String clientId, List<OAuthScope> scopes, OIDCClaimsRequest claims);\n+\n+\t/**\n+\t * Retrieves token metadata, using the unhashed token and associated {@link org.sagebionetworks.repo.model.oauth.OAuthClient} ID.\n+\t * This retrieval locks the row so that it is not changed until the transaction completes.\n+\t * Therefore, the caller must use {@link org.sagebionetworks.repo.transactions.WriteTransaction}.\n+\t * @param refreshToken the unhashed refresh token\n+\t * @return the new token and token ID\n+\t * @throws IllegalArgumentException if the passed refresh token does not match an existing refresh token\n+\t */\n+\tOAuthRefreshTokenAndMetadata getRefreshTokenMetadataForUpdateAndRotate(String refreshToken) throws IllegalArgumentException;\n+", "originalCommit": "a56521b66059f5270be4b834cc1c8ccbdf061dc7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA0OTgwOA==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4086#discussion_r439049808", "bodyText": "Rotates the token and returns the metadata....", "author": "brucehoff", "createdAt": "2020-06-11T20:22:01Z", "path": "services/repository-managers/src/main/java/org/sagebionetworks/repo/manager/oauth/OAuthRefreshTokenManager.java", "diffHunk": "@@ -0,0 +1,117 @@\n+package org.sagebionetworks.repo.manager.oauth;\n+\n+import java.util.List;\n+\n+import org.sagebionetworks.repo.model.UnauthorizedException;\n+import org.sagebionetworks.repo.model.UserInfo;\n+import org.sagebionetworks.repo.model.oauth.OAuthClientAuthorizationHistoryList;\n+import org.sagebionetworks.repo.model.oauth.OAuthRefreshTokenInformation;\n+import org.sagebionetworks.repo.model.oauth.OAuthRefreshTokenInformationList;\n+import org.sagebionetworks.repo.model.oauth.OAuthScope;\n+import org.sagebionetworks.repo.model.oauth.OAuthTokenRevocationRequest;\n+import org.sagebionetworks.repo.model.oauth.OIDCClaimsRequest;\n+import org.sagebionetworks.repo.web.NotFoundException;\n+\n+/**\n+ * The OAuthRefreshToken manager is used to create, retrieve, and manipulate the refresh tokens that grant OAuth clients\n+ * long-lived access to user resources.\n+ *\n+ * See also the {@link OpenIDConnectManager}.\n+ */\n+public interface OAuthRefreshTokenManager {\n+\n+\t/**\n+\t * Creates an OAuth 2.0 refresh token, which can be used to grant an OAuth client long-lived, revocable access\n+\t * to a user's resources\n+\t *\n+\t * @param userId\n+\t * @param clientId the client authorized to access the resources\n+\t * @param scopes the {@link OAuthScope}s that the client is authorized to access with.\n+\t * @param claims the OIDC claims that have been granted to the client. the {@link OIDCClaimsRequest} object also\n+\t *                 specifies when that information is contained in the OIDC id_token, or returned when the client\n+\t *                 makes a request at the userinfo endpoint\n+\t * @return a generated refresh token, and the refresh token's unique ID.\n+\t */\n+\tOAuthRefreshTokenAndMetadata createRefreshToken(String userId, String clientId, List<OAuthScope> scopes, OIDCClaimsRequest claims);\n+\n+\t/**\n+\t * Retrieves token metadata, using the unhashed token and associated {@link org.sagebionetworks.repo.model.oauth.OAuthClient} ID.", "originalCommit": "a56521b66059f5270be4b834cc1c8ccbdf061dc7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA1MTQxOQ==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4086#discussion_r439051419", "bodyText": "@param clientId validated clientId", "author": "brucehoff", "createdAt": "2020-06-11T20:24:22Z", "path": "services/repository-managers/src/main/java/org/sagebionetworks/repo/manager/oauth/OAuthRefreshTokenManager.java", "diffHunk": "@@ -0,0 +1,117 @@\n+package org.sagebionetworks.repo.manager.oauth;\n+\n+import java.util.List;\n+\n+import org.sagebionetworks.repo.model.UnauthorizedException;\n+import org.sagebionetworks.repo.model.UserInfo;\n+import org.sagebionetworks.repo.model.oauth.OAuthClientAuthorizationHistoryList;\n+import org.sagebionetworks.repo.model.oauth.OAuthRefreshTokenInformation;\n+import org.sagebionetworks.repo.model.oauth.OAuthRefreshTokenInformationList;\n+import org.sagebionetworks.repo.model.oauth.OAuthScope;\n+import org.sagebionetworks.repo.model.oauth.OAuthTokenRevocationRequest;\n+import org.sagebionetworks.repo.model.oauth.OIDCClaimsRequest;\n+import org.sagebionetworks.repo.web.NotFoundException;\n+\n+/**\n+ * The OAuthRefreshToken manager is used to create, retrieve, and manipulate the refresh tokens that grant OAuth clients\n+ * long-lived access to user resources.\n+ *\n+ * See also the {@link OpenIDConnectManager}.\n+ */\n+public interface OAuthRefreshTokenManager {\n+\n+\t/**\n+\t * Creates an OAuth 2.0 refresh token, which can be used to grant an OAuth client long-lived, revocable access\n+\t * to a user's resources\n+\t *\n+\t * @param userId\n+\t * @param clientId the client authorized to access the resources\n+\t * @param scopes the {@link OAuthScope}s that the client is authorized to access with.\n+\t * @param claims the OIDC claims that have been granted to the client. the {@link OIDCClaimsRequest} object also\n+\t *                 specifies when that information is contained in the OIDC id_token, or returned when the client\n+\t *                 makes a request at the userinfo endpoint\n+\t * @return a generated refresh token, and the refresh token's unique ID.\n+\t */\n+\tOAuthRefreshTokenAndMetadata createRefreshToken(String userId, String clientId, List<OAuthScope> scopes, OIDCClaimsRequest claims);\n+\n+\t/**\n+\t * Retrieves token metadata, using the unhashed token and associated {@link org.sagebionetworks.repo.model.oauth.OAuthClient} ID.\n+\t * This retrieval locks the row so that it is not changed until the transaction completes.\n+\t * Therefore, the caller must use {@link org.sagebionetworks.repo.transactions.WriteTransaction}.\n+\t * @param refreshToken the unhashed refresh token\n+\t * @return the new token and token ID\n+\t * @throws IllegalArgumentException if the passed refresh token does not match an existing refresh token\n+\t */\n+\tOAuthRefreshTokenAndMetadata getRefreshTokenMetadataForUpdateAndRotate(String refreshToken) throws IllegalArgumentException;\n+\n+\t/**\n+\t * Retrieve an OAuth 2.0 refresh token's metadata using the tokens' ID, on behalf of a user\n+\t * @param userInfo\n+\t * @param tokenId\n+\t * @return\n+\t * @throws NotFoundException if the token does not exist\n+\t * @throws UnauthorizedException if the token is not associated with the user\n+\t */\n+\tOAuthRefreshTokenInformation getRefreshTokenMetadata(UserInfo userInfo, String tokenId) throws NotFoundException, UnauthorizedException;\n+\n+\t/**\n+\t * Retrieve an OAuth 2.0 refresh token's metadata using the tokens' ID, on behalf of a client\n+\t * @param clientId", "originalCommit": "a56521b66059f5270be4b834cc1c8ccbdf061dc7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA1MzQ0NA==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4086#discussion_r439053444", "bodyText": "anyways -> anyway", "author": "brucehoff", "createdAt": "2020-06-11T20:28:35Z", "path": "services/repository-managers/src/main/java/org/sagebionetworks/repo/manager/oauth/OAuthRefreshTokenManager.java", "diffHunk": "@@ -0,0 +1,117 @@\n+package org.sagebionetworks.repo.manager.oauth;\n+\n+import java.util.List;\n+\n+import org.sagebionetworks.repo.model.UnauthorizedException;\n+import org.sagebionetworks.repo.model.UserInfo;\n+import org.sagebionetworks.repo.model.oauth.OAuthClientAuthorizationHistoryList;\n+import org.sagebionetworks.repo.model.oauth.OAuthRefreshTokenInformation;\n+import org.sagebionetworks.repo.model.oauth.OAuthRefreshTokenInformationList;\n+import org.sagebionetworks.repo.model.oauth.OAuthScope;\n+import org.sagebionetworks.repo.model.oauth.OAuthTokenRevocationRequest;\n+import org.sagebionetworks.repo.model.oauth.OIDCClaimsRequest;\n+import org.sagebionetworks.repo.web.NotFoundException;\n+\n+/**\n+ * The OAuthRefreshToken manager is used to create, retrieve, and manipulate the refresh tokens that grant OAuth clients\n+ * long-lived access to user resources.\n+ *\n+ * See also the {@link OpenIDConnectManager}.\n+ */\n+public interface OAuthRefreshTokenManager {\n+\n+\t/**\n+\t * Creates an OAuth 2.0 refresh token, which can be used to grant an OAuth client long-lived, revocable access\n+\t * to a user's resources\n+\t *\n+\t * @param userId\n+\t * @param clientId the client authorized to access the resources\n+\t * @param scopes the {@link OAuthScope}s that the client is authorized to access with.\n+\t * @param claims the OIDC claims that have been granted to the client. the {@link OIDCClaimsRequest} object also\n+\t *                 specifies when that information is contained in the OIDC id_token, or returned when the client\n+\t *                 makes a request at the userinfo endpoint\n+\t * @return a generated refresh token, and the refresh token's unique ID.\n+\t */\n+\tOAuthRefreshTokenAndMetadata createRefreshToken(String userId, String clientId, List<OAuthScope> scopes, OIDCClaimsRequest claims);\n+\n+\t/**\n+\t * Retrieves token metadata, using the unhashed token and associated {@link org.sagebionetworks.repo.model.oauth.OAuthClient} ID.\n+\t * This retrieval locks the row so that it is not changed until the transaction completes.\n+\t * Therefore, the caller must use {@link org.sagebionetworks.repo.transactions.WriteTransaction}.\n+\t * @param refreshToken the unhashed refresh token\n+\t * @return the new token and token ID\n+\t * @throws IllegalArgumentException if the passed refresh token does not match an existing refresh token\n+\t */\n+\tOAuthRefreshTokenAndMetadata getRefreshTokenMetadataForUpdateAndRotate(String refreshToken) throws IllegalArgumentException;\n+\n+\t/**\n+\t * Retrieve an OAuth 2.0 refresh token's metadata using the tokens' ID, on behalf of a user\n+\t * @param userInfo\n+\t * @param tokenId\n+\t * @return\n+\t * @throws NotFoundException if the token does not exist\n+\t * @throws UnauthorizedException if the token is not associated with the user\n+\t */\n+\tOAuthRefreshTokenInformation getRefreshTokenMetadata(UserInfo userInfo, String tokenId) throws NotFoundException, UnauthorizedException;\n+\n+\t/**\n+\t * Retrieve an OAuth 2.0 refresh token's metadata using the tokens' ID, on behalf of a client\n+\t * @param clientId\n+\t * @param tokenId\n+\t * @return\n+\t * @throws NotFoundException if the token does not exist\n+\t * @throws UnauthorizedException if the token is not associated with the client\n+\t */\n+\tOAuthRefreshTokenInformation getRefreshTokenMetadata(String clientId, String tokenId) throws NotFoundException, UnauthorizedException;\n+\n+\t/**\n+\t * Retrieve a paginated record of which clients are currently granted OAuth 2.0 access to a user via active refresh tokens\n+\t * @param userInfo the user whose records should be retrieved\n+\t * @param nextPageToken {@link org.sagebionetworks.repo.model.NextPageToken} token for pagination\n+\t * @return\n+\t */\n+\tOAuthClientAuthorizationHistoryList getAuthorizedClientHistory(UserInfo userInfo, String nextPageToken);\n+\n+\t/**\n+\t * Retrieve a paginated list of metadata for active refresh tokens between a particular user and client\n+\t *\n+\t * @param userInfo\n+\t * @param clientId\n+\t * @param nextPageToken {@link org.sagebionetworks.repo.model.NextPageToken} token for pagination\n+\t * @return\n+\t */\n+\tOAuthRefreshTokenInformationList getMetadataForActiveRefreshTokens(UserInfo userInfo, String clientId, String nextPageToken);\n+\n+\t/**\n+\t * Revoke all refresh tokens between a particular user and a particular client.\n+\t * @param userInfo\n+\t * @param clientId\n+\t */\n+\tvoid revokeRefreshTokensForUserClientPair(UserInfo userInfo, String clientId);\n+\n+\t/**\n+\t * Revoke a particular refresh token using a token ID\n+\t *\n+\t * @param userInfo\n+\t * @param tokenId\n+\t * @throws NotFoundException if the token does not exist\n+\t * @throws UnauthorizedException if the token is not associated with the user\n+\t */\n+\tvoid revokeRefreshToken(UserInfo userInfo, String tokenId) throws NotFoundException, UnauthorizedException;\n+\n+\t/**\n+\t * Revokes a refresh token using the token itself. This method is usually invoked by an OAuth client, but a client\n+\t * ID is not required because if this is called by an unauthorized party, the token should be revoked anyways.", "originalCommit": "a56521b66059f5270be4b834cc1c8ccbdf061dc7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA1Mzk2OA==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4086#discussion_r439053968", "bodyText": "token -> token's", "author": "brucehoff", "createdAt": "2020-06-11T20:29:42Z", "path": "services/repository-managers/src/main/java/org/sagebionetworks/repo/manager/oauth/OAuthRefreshTokenManager.java", "diffHunk": "@@ -0,0 +1,117 @@\n+package org.sagebionetworks.repo.manager.oauth;\n+\n+import java.util.List;\n+\n+import org.sagebionetworks.repo.model.UnauthorizedException;\n+import org.sagebionetworks.repo.model.UserInfo;\n+import org.sagebionetworks.repo.model.oauth.OAuthClientAuthorizationHistoryList;\n+import org.sagebionetworks.repo.model.oauth.OAuthRefreshTokenInformation;\n+import org.sagebionetworks.repo.model.oauth.OAuthRefreshTokenInformationList;\n+import org.sagebionetworks.repo.model.oauth.OAuthScope;\n+import org.sagebionetworks.repo.model.oauth.OAuthTokenRevocationRequest;\n+import org.sagebionetworks.repo.model.oauth.OIDCClaimsRequest;\n+import org.sagebionetworks.repo.web.NotFoundException;\n+\n+/**\n+ * The OAuthRefreshToken manager is used to create, retrieve, and manipulate the refresh tokens that grant OAuth clients\n+ * long-lived access to user resources.\n+ *\n+ * See also the {@link OpenIDConnectManager}.\n+ */\n+public interface OAuthRefreshTokenManager {\n+\n+\t/**\n+\t * Creates an OAuth 2.0 refresh token, which can be used to grant an OAuth client long-lived, revocable access\n+\t * to a user's resources\n+\t *\n+\t * @param userId\n+\t * @param clientId the client authorized to access the resources\n+\t * @param scopes the {@link OAuthScope}s that the client is authorized to access with.\n+\t * @param claims the OIDC claims that have been granted to the client. the {@link OIDCClaimsRequest} object also\n+\t *                 specifies when that information is contained in the OIDC id_token, or returned when the client\n+\t *                 makes a request at the userinfo endpoint\n+\t * @return a generated refresh token, and the refresh token's unique ID.\n+\t */\n+\tOAuthRefreshTokenAndMetadata createRefreshToken(String userId, String clientId, List<OAuthScope> scopes, OIDCClaimsRequest claims);\n+\n+\t/**\n+\t * Retrieves token metadata, using the unhashed token and associated {@link org.sagebionetworks.repo.model.oauth.OAuthClient} ID.\n+\t * This retrieval locks the row so that it is not changed until the transaction completes.\n+\t * Therefore, the caller must use {@link org.sagebionetworks.repo.transactions.WriteTransaction}.\n+\t * @param refreshToken the unhashed refresh token\n+\t * @return the new token and token ID\n+\t * @throws IllegalArgumentException if the passed refresh token does not match an existing refresh token\n+\t */\n+\tOAuthRefreshTokenAndMetadata getRefreshTokenMetadataForUpdateAndRotate(String refreshToken) throws IllegalArgumentException;\n+\n+\t/**\n+\t * Retrieve an OAuth 2.0 refresh token's metadata using the tokens' ID, on behalf of a user\n+\t * @param userInfo\n+\t * @param tokenId\n+\t * @return\n+\t * @throws NotFoundException if the token does not exist\n+\t * @throws UnauthorizedException if the token is not associated with the user\n+\t */\n+\tOAuthRefreshTokenInformation getRefreshTokenMetadata(UserInfo userInfo, String tokenId) throws NotFoundException, UnauthorizedException;\n+\n+\t/**\n+\t * Retrieve an OAuth 2.0 refresh token's metadata using the tokens' ID, on behalf of a client\n+\t * @param clientId\n+\t * @param tokenId\n+\t * @return\n+\t * @throws NotFoundException if the token does not exist\n+\t * @throws UnauthorizedException if the token is not associated with the client\n+\t */\n+\tOAuthRefreshTokenInformation getRefreshTokenMetadata(String clientId, String tokenId) throws NotFoundException, UnauthorizedException;\n+\n+\t/**\n+\t * Retrieve a paginated record of which clients are currently granted OAuth 2.0 access to a user via active refresh tokens\n+\t * @param userInfo the user whose records should be retrieved\n+\t * @param nextPageToken {@link org.sagebionetworks.repo.model.NextPageToken} token for pagination\n+\t * @return\n+\t */\n+\tOAuthClientAuthorizationHistoryList getAuthorizedClientHistory(UserInfo userInfo, String nextPageToken);\n+\n+\t/**\n+\t * Retrieve a paginated list of metadata for active refresh tokens between a particular user and client\n+\t *\n+\t * @param userInfo\n+\t * @param clientId\n+\t * @param nextPageToken {@link org.sagebionetworks.repo.model.NextPageToken} token for pagination\n+\t * @return\n+\t */\n+\tOAuthRefreshTokenInformationList getMetadataForActiveRefreshTokens(UserInfo userInfo, String clientId, String nextPageToken);\n+\n+\t/**\n+\t * Revoke all refresh tokens between a particular user and a particular client.\n+\t * @param userInfo\n+\t * @param clientId\n+\t */\n+\tvoid revokeRefreshTokensForUserClientPair(UserInfo userInfo, String clientId);\n+\n+\t/**\n+\t * Revoke a particular refresh token using a token ID\n+\t *\n+\t * @param userInfo\n+\t * @param tokenId\n+\t * @throws NotFoundException if the token does not exist\n+\t * @throws UnauthorizedException if the token is not associated with the user\n+\t */\n+\tvoid revokeRefreshToken(UserInfo userInfo, String tokenId) throws NotFoundException, UnauthorizedException;\n+\n+\t/**\n+\t * Revokes a refresh token using the token itself. This method is usually invoked by an OAuth client, but a client\n+\t * ID is not required because if this is called by an unauthorized party, the token should be revoked anyways.\n+\t * @param revocationRequest\n+\t */\n+\tvoid revokeRefreshToken(OAuthTokenRevocationRequest revocationRequest) throws NotFoundException;\n+\n+\t/**\n+\t * Updates a token metadata.", "originalCommit": "a56521b66059f5270be4b834cc1c8ccbdf061dc7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA1NjY3Mg==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4086#discussion_r439056672", "bodyText": "-1", "author": "brucehoff", "createdAt": "2020-06-11T20:35:33Z", "path": "services/repository-managers/src/main/java/org/sagebionetworks/repo/manager/oauth/OAuthRefreshTokenManagerImpl.java", "diffHunk": "@@ -0,0 +1,262 @@\n+package org.sagebionetworks.repo.manager.oauth;\n+\n+import java.util.List;\n+import java.util.UUID;\n+\n+import org.apache.commons.codec.digest.DigestUtils;\n+import org.sagebionetworks.repo.manager.PrivateFieldUtils;\n+import org.sagebionetworks.repo.model.ConflictingUpdateException;\n+import org.sagebionetworks.repo.model.UnauthorizedException;\n+import org.sagebionetworks.repo.model.UserInfo;\n+import org.sagebionetworks.repo.model.auth.OAuthClientDao;\n+import org.sagebionetworks.repo.model.auth.OAuthRefreshTokenDao;\n+import org.sagebionetworks.repo.model.oauth.OAuthClientAuthorizationHistory;\n+import org.sagebionetworks.repo.model.oauth.OAuthClientAuthorizationHistoryList;\n+import org.sagebionetworks.repo.model.oauth.OAuthRefreshTokenInformation;\n+import org.sagebionetworks.repo.model.oauth.OAuthRefreshTokenInformationList;\n+import org.sagebionetworks.repo.model.oauth.OAuthScope;\n+import org.sagebionetworks.repo.model.oauth.OAuthTokenRevocationRequest;\n+import org.sagebionetworks.repo.model.oauth.OIDCClaimName;\n+import org.sagebionetworks.repo.model.oauth.OIDCClaimsRequest;\n+import org.sagebionetworks.repo.transactions.MandatoryWriteTransaction;\n+import org.sagebionetworks.repo.transactions.WriteTransaction;\n+import org.sagebionetworks.repo.web.NotFoundException;\n+import org.sagebionetworks.securitytools.PBKDF2Utils;\n+import org.sagebionetworks.util.Clock;\n+import org.sagebionetworks.util.ValidateArgument;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+import io.jsonwebtoken.Claims;\n+import io.jsonwebtoken.JwsHeader;\n+import io.jsonwebtoken.Jwt;\n+\n+public class OAuthRefreshTokenManagerImpl implements OAuthRefreshTokenManager {\n+\n+\t@Autowired\n+\tOAuthClientDao oauthClientDao;\n+\n+\t@Autowired\n+\tOAuthRefreshTokenDao oauthRefreshTokenDao;\n+\n+\t@Autowired\n+\tOIDCTokenHelper oidcTokenHelper;\n+\n+\t@Autowired\n+\tClock clock;\n+\n+\t/**\n+\t * The maximum number of days a refresh token can go unused and still\n+\t * be considered active. A refresh token is \"used\" when it is used\n+\t * to issue a new access token.\n+\t */\n+\tprivate static final Long REFRESH_TOKEN_LEASE_DURATION_DAYS = 180L;\n+\n+\t// The maximum number of refresh tokens that can be issued between a user-client pair.\n+\tprivate static final Long MAX_REFRESH_TOKENS_PER_CLIENT_PER_USER = 100L;\n+\n+\tpublic static boolean canViewAndAlterTokenMetadata(UserInfo userInfo, OAuthRefreshTokenInformation metadata) {\n+\t\treturn userInfo.getId().toString().equals(metadata.getPrincipalId()) || userInfo.isAdmin();\n+\t}\n+\n+\t@WriteTransaction\n+\t@Override\n+\tpublic OAuthRefreshTokenAndMetadata createRefreshToken(String userId, String clientId, List<OAuthScope> scopes, OIDCClaimsRequest claims) {\n+\t\tValidateArgument.required(userId, \"userId\");\n+\t\tValidateArgument.required(clientId, \"clientId\");\n+\t\t// The OpenIDConnectManager will handle if scope/claims are semantically valid\n+\t\t// Here, just require that scope be non-null, and the claims maps be non-null\n+\t\tValidateArgument.required(scopes, \"scopes\");\n+\t\tValidateArgument.required(claims, \"claims\");\n+\t\tValidateArgument.required(claims.getId_token(), \"id_token claims\");\n+\t\tValidateArgument.required(claims.getUserinfo(), \"userinfo claims\");\n+\n+\t\tString token = generateRefreshToken();\n+\t\tString hash = hashToken(token); // Save the hash, not the token\n+\n+\t\t// Before we create the token, ensure the user/client pair is under the max tokens limit\n+\t\toauthRefreshTokenDao.deleteLeastRecentlyUsedTokensOverLimit(userId, clientId, MAX_REFRESH_TOKENS_PER_CLIENT_PER_USER);", "originalCommit": "a56521b66059f5270be4b834cc1c8ccbdf061dc7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA1OTQyMg==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4086#discussion_r439059422", "bodyText": "make sure we don't let anonymous through", "author": "brucehoff", "createdAt": "2020-06-11T20:41:16Z", "path": "services/repository-managers/src/main/java/org/sagebionetworks/repo/manager/oauth/OAuthRefreshTokenManagerImpl.java", "diffHunk": "@@ -0,0 +1,262 @@\n+package org.sagebionetworks.repo.manager.oauth;\n+\n+import java.util.List;\n+import java.util.UUID;\n+\n+import org.apache.commons.codec.digest.DigestUtils;\n+import org.sagebionetworks.repo.manager.PrivateFieldUtils;\n+import org.sagebionetworks.repo.model.ConflictingUpdateException;\n+import org.sagebionetworks.repo.model.UnauthorizedException;\n+import org.sagebionetworks.repo.model.UserInfo;\n+import org.sagebionetworks.repo.model.auth.OAuthClientDao;\n+import org.sagebionetworks.repo.model.auth.OAuthRefreshTokenDao;\n+import org.sagebionetworks.repo.model.oauth.OAuthClientAuthorizationHistory;\n+import org.sagebionetworks.repo.model.oauth.OAuthClientAuthorizationHistoryList;\n+import org.sagebionetworks.repo.model.oauth.OAuthRefreshTokenInformation;\n+import org.sagebionetworks.repo.model.oauth.OAuthRefreshTokenInformationList;\n+import org.sagebionetworks.repo.model.oauth.OAuthScope;\n+import org.sagebionetworks.repo.model.oauth.OAuthTokenRevocationRequest;\n+import org.sagebionetworks.repo.model.oauth.OIDCClaimName;\n+import org.sagebionetworks.repo.model.oauth.OIDCClaimsRequest;\n+import org.sagebionetworks.repo.transactions.MandatoryWriteTransaction;\n+import org.sagebionetworks.repo.transactions.WriteTransaction;\n+import org.sagebionetworks.repo.web.NotFoundException;\n+import org.sagebionetworks.securitytools.PBKDF2Utils;\n+import org.sagebionetworks.util.Clock;\n+import org.sagebionetworks.util.ValidateArgument;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+import io.jsonwebtoken.Claims;\n+import io.jsonwebtoken.JwsHeader;\n+import io.jsonwebtoken.Jwt;\n+\n+public class OAuthRefreshTokenManagerImpl implements OAuthRefreshTokenManager {\n+\n+\t@Autowired\n+\tOAuthClientDao oauthClientDao;\n+\n+\t@Autowired\n+\tOAuthRefreshTokenDao oauthRefreshTokenDao;\n+\n+\t@Autowired\n+\tOIDCTokenHelper oidcTokenHelper;\n+\n+\t@Autowired\n+\tClock clock;\n+\n+\t/**\n+\t * The maximum number of days a refresh token can go unused and still\n+\t * be considered active. A refresh token is \"used\" when it is used\n+\t * to issue a new access token.\n+\t */\n+\tprivate static final Long REFRESH_TOKEN_LEASE_DURATION_DAYS = 180L;\n+\n+\t// The maximum number of refresh tokens that can be issued between a user-client pair.\n+\tprivate static final Long MAX_REFRESH_TOKENS_PER_CLIENT_PER_USER = 100L;\n+\n+\tpublic static boolean canViewAndAlterTokenMetadata(UserInfo userInfo, OAuthRefreshTokenInformation metadata) {\n+\t\treturn userInfo.getId().toString().equals(metadata.getPrincipalId()) || userInfo.isAdmin();\n+\t}\n+\n+\t@WriteTransaction\n+\t@Override\n+\tpublic OAuthRefreshTokenAndMetadata createRefreshToken(String userId, String clientId, List<OAuthScope> scopes, OIDCClaimsRequest claims) {", "originalCommit": "a56521b66059f5270be4b834cc1c8ccbdf061dc7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA2MDQ5NQ==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4086#discussion_r439060495", "bodyText": "don't throw exception, just do nothing", "author": "brucehoff", "createdAt": "2020-06-11T20:43:39Z", "path": "services/repository-managers/src/main/java/org/sagebionetworks/repo/manager/oauth/OAuthRefreshTokenManagerImpl.java", "diffHunk": "@@ -0,0 +1,262 @@\n+package org.sagebionetworks.repo.manager.oauth;\n+\n+import java.util.List;\n+import java.util.UUID;\n+\n+import org.apache.commons.codec.digest.DigestUtils;\n+import org.sagebionetworks.repo.manager.PrivateFieldUtils;\n+import org.sagebionetworks.repo.model.ConflictingUpdateException;\n+import org.sagebionetworks.repo.model.UnauthorizedException;\n+import org.sagebionetworks.repo.model.UserInfo;\n+import org.sagebionetworks.repo.model.auth.OAuthClientDao;\n+import org.sagebionetworks.repo.model.auth.OAuthRefreshTokenDao;\n+import org.sagebionetworks.repo.model.oauth.OAuthClientAuthorizationHistory;\n+import org.sagebionetworks.repo.model.oauth.OAuthClientAuthorizationHistoryList;\n+import org.sagebionetworks.repo.model.oauth.OAuthRefreshTokenInformation;\n+import org.sagebionetworks.repo.model.oauth.OAuthRefreshTokenInformationList;\n+import org.sagebionetworks.repo.model.oauth.OAuthScope;\n+import org.sagebionetworks.repo.model.oauth.OAuthTokenRevocationRequest;\n+import org.sagebionetworks.repo.model.oauth.OIDCClaimName;\n+import org.sagebionetworks.repo.model.oauth.OIDCClaimsRequest;\n+import org.sagebionetworks.repo.transactions.MandatoryWriteTransaction;\n+import org.sagebionetworks.repo.transactions.WriteTransaction;\n+import org.sagebionetworks.repo.web.NotFoundException;\n+import org.sagebionetworks.securitytools.PBKDF2Utils;\n+import org.sagebionetworks.util.Clock;\n+import org.sagebionetworks.util.ValidateArgument;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+import io.jsonwebtoken.Claims;\n+import io.jsonwebtoken.JwsHeader;\n+import io.jsonwebtoken.Jwt;\n+\n+public class OAuthRefreshTokenManagerImpl implements OAuthRefreshTokenManager {\n+\n+\t@Autowired\n+\tOAuthClientDao oauthClientDao;\n+\n+\t@Autowired\n+\tOAuthRefreshTokenDao oauthRefreshTokenDao;\n+\n+\t@Autowired\n+\tOIDCTokenHelper oidcTokenHelper;\n+\n+\t@Autowired\n+\tClock clock;\n+\n+\t/**\n+\t * The maximum number of days a refresh token can go unused and still\n+\t * be considered active. A refresh token is \"used\" when it is used\n+\t * to issue a new access token.\n+\t */\n+\tprivate static final Long REFRESH_TOKEN_LEASE_DURATION_DAYS = 180L;\n+\n+\t// The maximum number of refresh tokens that can be issued between a user-client pair.\n+\tprivate static final Long MAX_REFRESH_TOKENS_PER_CLIENT_PER_USER = 100L;\n+\n+\tpublic static boolean canViewAndAlterTokenMetadata(UserInfo userInfo, OAuthRefreshTokenInformation metadata) {\n+\t\treturn userInfo.getId().toString().equals(metadata.getPrincipalId()) || userInfo.isAdmin();\n+\t}\n+\n+\t@WriteTransaction\n+\t@Override\n+\tpublic OAuthRefreshTokenAndMetadata createRefreshToken(String userId, String clientId, List<OAuthScope> scopes, OIDCClaimsRequest claims) {\n+\t\tValidateArgument.required(userId, \"userId\");\n+\t\tValidateArgument.required(clientId, \"clientId\");\n+\t\t// The OpenIDConnectManager will handle if scope/claims are semantically valid\n+\t\t// Here, just require that scope be non-null, and the claims maps be non-null\n+\t\tValidateArgument.required(scopes, \"scopes\");\n+\t\tValidateArgument.required(claims, \"claims\");\n+\t\tValidateArgument.required(claims.getId_token(), \"id_token claims\");\n+\t\tValidateArgument.required(claims.getUserinfo(), \"userinfo claims\");\n+\n+\t\tString token = generateRefreshToken();\n+\t\tString hash = hashToken(token); // Save the hash, not the token\n+\n+\t\t// Before we create the token, ensure the user/client pair is under the max tokens limit\n+\t\toauthRefreshTokenDao.deleteLeastRecentlyUsedTokensOverLimit(userId, clientId, MAX_REFRESH_TOKENS_PER_CLIENT_PER_USER);\n+\n+\t\t// Create the token\n+\t\tOAuthRefreshTokenInformation tokenMetadata = new OAuthRefreshTokenInformation();\n+\t\ttokenMetadata.setPrincipalId(userId);\n+\t\ttokenMetadata.setClientId(clientId);\n+\t\ttokenMetadata.setScopes(scopes);\n+\t\ttokenMetadata.setClaims(claims);\n+\t\ttokenMetadata.setName(UUID.randomUUID().toString());\n+\t\ttokenMetadata.setLastUsed(clock.now());\n+\t\ttokenMetadata.setAuthorizedOn(clock.now());\n+\t\ttokenMetadata.setModifiedOn(clock.now());\n+\t\ttokenMetadata.setEtag(UUID.randomUUID().toString());\n+\n+\t\ttokenMetadata = oauthRefreshTokenDao.createRefreshToken(hash, tokenMetadata);\n+\n+\t\t// Return the unhashed token and ID\n+\t\tOAuthRefreshTokenAndMetadata tokenAndId = new OAuthRefreshTokenAndMetadata();\n+\t\ttokenAndId.setRefreshToken(token);\n+\t\ttokenAndId.setMetadata(tokenMetadata);\n+\t\treturn tokenAndId;\n+\t}\n+\n+\t@MandatoryWriteTransaction\n+\t@Override\n+\tpublic OAuthRefreshTokenAndMetadata getRefreshTokenMetadataForUpdateAndRotate(String refreshToken) {\n+\t\tString hash = hashToken(refreshToken);\n+\t\tOAuthRefreshTokenInformation metadata = oauthRefreshTokenDao.getMatchingTokenByHashForUpdate(hash)\n+\t\t\t\t.orElseThrow(() -> new IllegalArgumentException(\"The token does not match an existing token\"));\n+\n+\t\tString newToken = generateRefreshToken();\n+\t\tString newHash = hashToken(newToken);\n+\n+\t\t// Update the etag, and last used date (not modified on, which tells when the name was last changed)\n+\t\tmetadata.setLastUsed(clock.now());\n+\t\tmetadata.setEtag(UUID.randomUUID().toString());\n+\n+\t\toauthRefreshTokenDao.updateTokenHash(metadata, newHash);\n+\n+\t\tOAuthRefreshTokenInformation updatedMetadata = oauthRefreshTokenDao.getRefreshTokenMetadata(metadata.getTokenId())\n+\t\t\t\t.orElseThrow(() -> new IllegalStateException(\"Could not retrieve refresh token metadata after updating it.\"));\n+\n+\t\tOAuthRefreshTokenAndMetadata tokenAndMetadata = new OAuthRefreshTokenAndMetadata();\n+\t\ttokenAndMetadata.setRefreshToken(newToken);\n+\t\ttokenAndMetadata.setMetadata(updatedMetadata);\n+\t\treturn tokenAndMetadata;\n+\n+\t}\n+\n+\t@Override\n+\tpublic OAuthRefreshTokenInformation getRefreshTokenMetadata(UserInfo userInfo, String tokenId) throws NotFoundException {\n+\t\tOAuthRefreshTokenInformation metadata = oauthRefreshTokenDao.getRefreshTokenMetadata(tokenId)\n+\t\t\t\t.orElseThrow(() -> new NotFoundException(\"Refresh token with ID: \" + tokenId + \" does not exist\"));\n+\t\tif (!canViewAndAlterTokenMetadata(userInfo, metadata)) {\n+\t\t\tthrow new UnauthorizedException(\"You do not have permission to view this token metadata\");\n+\t\t}\n+\t\treturn metadata;\n+\t}\n+\n+\t@Override\n+\tpublic OAuthRefreshTokenInformation getRefreshTokenMetadata(String clientId, String tokenId) throws NotFoundException {\n+\t\tOAuthRefreshTokenInformation metadata = oauthRefreshTokenDao.getRefreshTokenMetadata(tokenId)\n+\t\t\t\t.orElseThrow(() -> new NotFoundException(\"Refresh token with ID: \" + tokenId + \" does not exist\"));\n+\t\tif (!clientId.equals(metadata.getClientId())) {\n+\t\t\tthrow new UnauthorizedException(\"You do not have permission to view this token metadata\");\n+\t\t}\n+\t\treturn metadata;\n+\t}\n+\n+\t@Override\n+\tpublic OAuthClientAuthorizationHistoryList getAuthorizedClientHistory(UserInfo userInfo, String nextPageToken) {\n+\t\tOAuthClientAuthorizationHistoryList results = oauthClientDao.getAuthorizedClientHistory(userInfo.getId().toString(), nextPageToken, REFRESH_TOKEN_LEASE_DURATION_DAYS);\n+\t\tfor (OAuthClientAuthorizationHistory result : results.getResults()) {\n+\t\t\tPrivateFieldUtils.clearPrivateFields(result.getClient());\n+\t\t}\n+\t\treturn results;\n+\t}\n+\n+\t@Override\n+\tpublic OAuthRefreshTokenInformationList getMetadataForActiveRefreshTokens(UserInfo userInfo, String clientId, String nextPageToken) {\n+\t\treturn oauthRefreshTokenDao.getActiveTokenInformation(userInfo.getId().toString(), clientId, nextPageToken, REFRESH_TOKEN_LEASE_DURATION_DAYS);\n+\t}\n+\n+\t@WriteTransaction\n+\t@Override\n+\tpublic void revokeRefreshTokensForUserClientPair(UserInfo userInfo, String clientId) {\n+\t\t// Verify that tokens exist for the pair\n+\t\tOAuthRefreshTokenInformationList tokens = oauthRefreshTokenDao.getActiveTokenInformation(userInfo.getId().toString(), clientId, null, REFRESH_TOKEN_LEASE_DURATION_DAYS);\n+\t\tif (tokens.getResults().size() == 0) {\n+\t\t\tthrow new NotFoundException(\"Refresh tokens have not been granted to client \" + clientId);", "originalCommit": "a56521b66059f5270be4b834cc1c8ccbdf061dc7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA2MTk2NA==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4086#discussion_r439061964", "bodyText": "we agreed that this manager should only revoke refresh tokens.", "author": "brucehoff", "createdAt": "2020-06-11T20:46:54Z", "path": "services/repository-managers/src/main/java/org/sagebionetworks/repo/manager/oauth/OAuthRefreshTokenManagerImpl.java", "diffHunk": "@@ -0,0 +1,262 @@\n+package org.sagebionetworks.repo.manager.oauth;\n+\n+import java.util.List;\n+import java.util.UUID;\n+\n+import org.apache.commons.codec.digest.DigestUtils;\n+import org.sagebionetworks.repo.manager.PrivateFieldUtils;\n+import org.sagebionetworks.repo.model.ConflictingUpdateException;\n+import org.sagebionetworks.repo.model.UnauthorizedException;\n+import org.sagebionetworks.repo.model.UserInfo;\n+import org.sagebionetworks.repo.model.auth.OAuthClientDao;\n+import org.sagebionetworks.repo.model.auth.OAuthRefreshTokenDao;\n+import org.sagebionetworks.repo.model.oauth.OAuthClientAuthorizationHistory;\n+import org.sagebionetworks.repo.model.oauth.OAuthClientAuthorizationHistoryList;\n+import org.sagebionetworks.repo.model.oauth.OAuthRefreshTokenInformation;\n+import org.sagebionetworks.repo.model.oauth.OAuthRefreshTokenInformationList;\n+import org.sagebionetworks.repo.model.oauth.OAuthScope;\n+import org.sagebionetworks.repo.model.oauth.OAuthTokenRevocationRequest;\n+import org.sagebionetworks.repo.model.oauth.OIDCClaimName;\n+import org.sagebionetworks.repo.model.oauth.OIDCClaimsRequest;\n+import org.sagebionetworks.repo.transactions.MandatoryWriteTransaction;\n+import org.sagebionetworks.repo.transactions.WriteTransaction;\n+import org.sagebionetworks.repo.web.NotFoundException;\n+import org.sagebionetworks.securitytools.PBKDF2Utils;\n+import org.sagebionetworks.util.Clock;\n+import org.sagebionetworks.util.ValidateArgument;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+import io.jsonwebtoken.Claims;\n+import io.jsonwebtoken.JwsHeader;\n+import io.jsonwebtoken.Jwt;\n+\n+public class OAuthRefreshTokenManagerImpl implements OAuthRefreshTokenManager {\n+\n+\t@Autowired\n+\tOAuthClientDao oauthClientDao;\n+\n+\t@Autowired\n+\tOAuthRefreshTokenDao oauthRefreshTokenDao;\n+\n+\t@Autowired\n+\tOIDCTokenHelper oidcTokenHelper;\n+\n+\t@Autowired\n+\tClock clock;\n+\n+\t/**\n+\t * The maximum number of days a refresh token can go unused and still\n+\t * be considered active. A refresh token is \"used\" when it is used\n+\t * to issue a new access token.\n+\t */\n+\tprivate static final Long REFRESH_TOKEN_LEASE_DURATION_DAYS = 180L;\n+\n+\t// The maximum number of refresh tokens that can be issued between a user-client pair.\n+\tprivate static final Long MAX_REFRESH_TOKENS_PER_CLIENT_PER_USER = 100L;\n+\n+\tpublic static boolean canViewAndAlterTokenMetadata(UserInfo userInfo, OAuthRefreshTokenInformation metadata) {\n+\t\treturn userInfo.getId().toString().equals(metadata.getPrincipalId()) || userInfo.isAdmin();\n+\t}\n+\n+\t@WriteTransaction\n+\t@Override\n+\tpublic OAuthRefreshTokenAndMetadata createRefreshToken(String userId, String clientId, List<OAuthScope> scopes, OIDCClaimsRequest claims) {\n+\t\tValidateArgument.required(userId, \"userId\");\n+\t\tValidateArgument.required(clientId, \"clientId\");\n+\t\t// The OpenIDConnectManager will handle if scope/claims are semantically valid\n+\t\t// Here, just require that scope be non-null, and the claims maps be non-null\n+\t\tValidateArgument.required(scopes, \"scopes\");\n+\t\tValidateArgument.required(claims, \"claims\");\n+\t\tValidateArgument.required(claims.getId_token(), \"id_token claims\");\n+\t\tValidateArgument.required(claims.getUserinfo(), \"userinfo claims\");\n+\n+\t\tString token = generateRefreshToken();\n+\t\tString hash = hashToken(token); // Save the hash, not the token\n+\n+\t\t// Before we create the token, ensure the user/client pair is under the max tokens limit\n+\t\toauthRefreshTokenDao.deleteLeastRecentlyUsedTokensOverLimit(userId, clientId, MAX_REFRESH_TOKENS_PER_CLIENT_PER_USER);\n+\n+\t\t// Create the token\n+\t\tOAuthRefreshTokenInformation tokenMetadata = new OAuthRefreshTokenInformation();\n+\t\ttokenMetadata.setPrincipalId(userId);\n+\t\ttokenMetadata.setClientId(clientId);\n+\t\ttokenMetadata.setScopes(scopes);\n+\t\ttokenMetadata.setClaims(claims);\n+\t\ttokenMetadata.setName(UUID.randomUUID().toString());\n+\t\ttokenMetadata.setLastUsed(clock.now());\n+\t\ttokenMetadata.setAuthorizedOn(clock.now());\n+\t\ttokenMetadata.setModifiedOn(clock.now());\n+\t\ttokenMetadata.setEtag(UUID.randomUUID().toString());\n+\n+\t\ttokenMetadata = oauthRefreshTokenDao.createRefreshToken(hash, tokenMetadata);\n+\n+\t\t// Return the unhashed token and ID\n+\t\tOAuthRefreshTokenAndMetadata tokenAndId = new OAuthRefreshTokenAndMetadata();\n+\t\ttokenAndId.setRefreshToken(token);\n+\t\ttokenAndId.setMetadata(tokenMetadata);\n+\t\treturn tokenAndId;\n+\t}\n+\n+\t@MandatoryWriteTransaction\n+\t@Override\n+\tpublic OAuthRefreshTokenAndMetadata getRefreshTokenMetadataForUpdateAndRotate(String refreshToken) {\n+\t\tString hash = hashToken(refreshToken);\n+\t\tOAuthRefreshTokenInformation metadata = oauthRefreshTokenDao.getMatchingTokenByHashForUpdate(hash)\n+\t\t\t\t.orElseThrow(() -> new IllegalArgumentException(\"The token does not match an existing token\"));\n+\n+\t\tString newToken = generateRefreshToken();\n+\t\tString newHash = hashToken(newToken);\n+\n+\t\t// Update the etag, and last used date (not modified on, which tells when the name was last changed)\n+\t\tmetadata.setLastUsed(clock.now());\n+\t\tmetadata.setEtag(UUID.randomUUID().toString());\n+\n+\t\toauthRefreshTokenDao.updateTokenHash(metadata, newHash);\n+\n+\t\tOAuthRefreshTokenInformation updatedMetadata = oauthRefreshTokenDao.getRefreshTokenMetadata(metadata.getTokenId())\n+\t\t\t\t.orElseThrow(() -> new IllegalStateException(\"Could not retrieve refresh token metadata after updating it.\"));\n+\n+\t\tOAuthRefreshTokenAndMetadata tokenAndMetadata = new OAuthRefreshTokenAndMetadata();\n+\t\ttokenAndMetadata.setRefreshToken(newToken);\n+\t\ttokenAndMetadata.setMetadata(updatedMetadata);\n+\t\treturn tokenAndMetadata;\n+\n+\t}\n+\n+\t@Override\n+\tpublic OAuthRefreshTokenInformation getRefreshTokenMetadata(UserInfo userInfo, String tokenId) throws NotFoundException {\n+\t\tOAuthRefreshTokenInformation metadata = oauthRefreshTokenDao.getRefreshTokenMetadata(tokenId)\n+\t\t\t\t.orElseThrow(() -> new NotFoundException(\"Refresh token with ID: \" + tokenId + \" does not exist\"));\n+\t\tif (!canViewAndAlterTokenMetadata(userInfo, metadata)) {\n+\t\t\tthrow new UnauthorizedException(\"You do not have permission to view this token metadata\");\n+\t\t}\n+\t\treturn metadata;\n+\t}\n+\n+\t@Override\n+\tpublic OAuthRefreshTokenInformation getRefreshTokenMetadata(String clientId, String tokenId) throws NotFoundException {\n+\t\tOAuthRefreshTokenInformation metadata = oauthRefreshTokenDao.getRefreshTokenMetadata(tokenId)\n+\t\t\t\t.orElseThrow(() -> new NotFoundException(\"Refresh token with ID: \" + tokenId + \" does not exist\"));\n+\t\tif (!clientId.equals(metadata.getClientId())) {\n+\t\t\tthrow new UnauthorizedException(\"You do not have permission to view this token metadata\");\n+\t\t}\n+\t\treturn metadata;\n+\t}\n+\n+\t@Override\n+\tpublic OAuthClientAuthorizationHistoryList getAuthorizedClientHistory(UserInfo userInfo, String nextPageToken) {\n+\t\tOAuthClientAuthorizationHistoryList results = oauthClientDao.getAuthorizedClientHistory(userInfo.getId().toString(), nextPageToken, REFRESH_TOKEN_LEASE_DURATION_DAYS);\n+\t\tfor (OAuthClientAuthorizationHistory result : results.getResults()) {\n+\t\t\tPrivateFieldUtils.clearPrivateFields(result.getClient());\n+\t\t}\n+\t\treturn results;\n+\t}\n+\n+\t@Override\n+\tpublic OAuthRefreshTokenInformationList getMetadataForActiveRefreshTokens(UserInfo userInfo, String clientId, String nextPageToken) {\n+\t\treturn oauthRefreshTokenDao.getActiveTokenInformation(userInfo.getId().toString(), clientId, nextPageToken, REFRESH_TOKEN_LEASE_DURATION_DAYS);\n+\t}\n+\n+\t@WriteTransaction\n+\t@Override\n+\tpublic void revokeRefreshTokensForUserClientPair(UserInfo userInfo, String clientId) {\n+\t\t// Verify that tokens exist for the pair\n+\t\tOAuthRefreshTokenInformationList tokens = oauthRefreshTokenDao.getActiveTokenInformation(userInfo.getId().toString(), clientId, null, REFRESH_TOKEN_LEASE_DURATION_DAYS);\n+\t\tif (tokens.getResults().size() == 0) {\n+\t\t\tthrow new NotFoundException(\"Refresh tokens have not been granted to client \" + clientId);\n+\t\t} else {\n+\t\t\toauthRefreshTokenDao.deleteAllTokensForUserClientPair(userInfo.getId().toString(), clientId);\n+\t\t}\n+\t}\n+\n+\t@WriteTransaction\n+\t@Override\n+\tpublic void revokeRefreshToken(UserInfo userInfo, String tokenId) {\n+\t\tOAuthRefreshTokenInformation metadata = oauthRefreshTokenDao.getRefreshTokenMetadata(tokenId)\n+\t\t\t\t.orElseThrow(() -> new NotFoundException(\"Refresh token with ID:\" + tokenId + \" does not exist\"));\n+\n+\t\tif (!canViewAndAlterTokenMetadata(userInfo, metadata)) {\n+\t\t\tthrow new UnauthorizedException(\"The specified token is owned by a different user and cannot be revoked\");\n+\t\t}\n+\n+\t\toauthRefreshTokenDao.deleteToken(tokenId);\n+\t}\n+\n+\t@WriteTransaction\n+\t@Override\n+\tpublic void revokeRefreshToken(OAuthTokenRevocationRequest revocationRequest) {", "originalCommit": "a56521b66059f5270be4b834cc1c8ccbdf061dc7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA2NzQwOA==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4086#discussion_r439067408", "bodyText": "I'm worried about spurious build failures when the test runs fast.\nassertTrue(updatedMetadata.getModifiedOn().getTime()>=metadata.getModifiedOn().getTime());", "author": "brucehoff", "createdAt": "2020-06-11T20:58:39Z", "path": "services/repository-managers/src/test/java/org/sagebionetworks/repo/manager/oauth/OAuthRefreshTokenManagerAutowiredTest.java", "diffHunk": "@@ -0,0 +1,353 @@\n+package org.sagebionetworks.repo.manager.oauth;\n+\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.UUID;\n+\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.platform.commons.util.StringUtils;\n+import org.sagebionetworks.repo.manager.UserManager;\n+import org.sagebionetworks.repo.model.AuthorizationConstants.BOOTSTRAP_PRINCIPAL;\n+import org.sagebionetworks.repo.model.UnauthorizedException;\n+import org.sagebionetworks.repo.model.UserInfo;\n+import org.sagebionetworks.repo.model.auth.NewUser;\n+import org.sagebionetworks.repo.model.dbo.persistence.DBOCredential;\n+import org.sagebionetworks.repo.model.dbo.persistence.DBOTermsOfUseAgreement;\n+import org.sagebionetworks.repo.model.oauth.OAuthClient;\n+import org.sagebionetworks.repo.model.oauth.OAuthClientAuthorizationHistory;\n+import org.sagebionetworks.repo.model.oauth.OAuthClientAuthorizationHistoryList;\n+import org.sagebionetworks.repo.model.oauth.OAuthRefreshTokenInformation;\n+import org.sagebionetworks.repo.model.oauth.OAuthRefreshTokenInformationList;\n+import org.sagebionetworks.repo.model.oauth.OAuthScope;\n+import org.sagebionetworks.repo.model.oauth.OAuthTokenRevocationRequest;\n+import org.sagebionetworks.repo.model.oauth.OIDCClaimName;\n+import org.sagebionetworks.repo.model.oauth.OIDCClaimsRequest;\n+import org.sagebionetworks.repo.model.oauth.OIDCClaimsRequestDetails;\n+import org.sagebionetworks.repo.model.oauth.OIDCSigningAlgorithm;\n+import org.sagebionetworks.repo.model.oauth.TokenTypeHint;\n+import org.sagebionetworks.repo.web.NotFoundException;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.dao.DataAccessException;\n+import org.springframework.test.context.ContextConfiguration;\n+import org.springframework.test.context.junit.jupiter.SpringExtension;\n+import org.springframework.transaction.IllegalTransactionStateException;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+\n+@ExtendWith(SpringExtension.class)\n+@ContextConfiguration(locations = { \"classpath:test-context.xml\" })\n+public class OAuthRefreshTokenManagerAutowiredTest {\n+\tprivate static final String CLIENT_1_NAME = \"some client\";\n+\tprivate static final String CLIENT_1_URI = \"https://client1.uri.com/index.html\";\n+\tprivate static final String CLIENT_2_NAME = \"a different client\";\n+\tprivate static final String CLIENT_2_URI = \"https://client2.uri.com/index.html\";\n+\tprivate static final String POLICY_URI = \"https://client.uri.com/policy.html\";\n+\tprivate static final String TOS_URI = \"https://client.uri.com/termsOfService.html\";\n+\tprivate static final List<String> REDIRCT_URIS = Collections.singletonList(\"https://client.com/redir\");\n+\n+\t@Autowired\n+\tprivate UserManager userManager;\n+\n+\t@Autowired\n+\tOAuthClientManager oauthClientManager;\n+\t\n+\t@Autowired\n+\tOIDCTokenHelper tokenHelper;\n+\n+\t@Autowired\n+\tOAuthRefreshTokenManager refreshTokenManager;\n+\t\n+\tprivate UserInfo adminUserInfo;\n+\tprivate UserInfo user1;\n+\tprivate UserInfo user2;\n+\tprivate OAuthClient client1;\n+\tprivate OAuthClient client2;\n+\n+\tprivate List<OAuthScope> scopes;\n+\tprivate OIDCClaimsRequest claims;\n+\n+\tprivate OAuthClient createOAuthClient(UserInfo owner, String name, String uri) throws Exception {\n+\t\tOAuthClient toCreate = new OAuthClient();\n+\t\ttoCreate.setClient_name(name);\n+\t\ttoCreate.setClient_uri(uri);\n+\t\ttoCreate.setCreatedOn(new Date(System.currentTimeMillis()));\n+\t\ttoCreate.setModifiedOn(new Date(System.currentTimeMillis()));\n+\t\ttoCreate.setPolicy_uri(POLICY_URI);\n+\t\ttoCreate.setRedirect_uris(REDIRCT_URIS);\n+\t\ttoCreate.setTos_uri(TOS_URI);\n+\t\ttoCreate.setUserinfo_signed_response_alg(OIDCSigningAlgorithm.RS256);\n+\n+\t\treturn oauthClientManager.createOpenIDConnectClient(user1, toCreate);\n+\t}\n+\n+\t@BeforeEach\n+\tpublic void beforeEach() throws Exception {\n+\t\t// Scopes and claims just need placeholder values\n+\t\tscopes = Arrays.asList(OAuthScope.openid, OAuthScope.modify);\n+\t\tclaims = new OIDCClaimsRequest();\n+\t\tOIDCClaimsRequestDetails claimDetail = new OIDCClaimsRequestDetails();\n+\t\tclaimDetail.setEssential(true);\n+\t\tclaimDetail.setValue(\"532523\");\n+\t\tclaims.setUserinfo(Collections.singletonMap(OIDCClaimName.team.name(), claimDetail));\n+\t\tclaims.setId_token(Collections.emptyMap());\n+\n+\t\t// Create two users\n+\t\tadminUserInfo = userManager.getUserInfo(BOOTSTRAP_PRINCIPAL.THE_ADMIN_USER.getPrincipalId());\n+\t\tDBOCredential cred = new DBOCredential();\n+\t\tcred.setSecretKey(\"\");\n+\t\tNewUser nu1 = new NewUser();\n+\t\tnu1.setEmail(UUID.randomUUID().toString() + \"@test.com\");\n+\t\tnu1.setUserName(UUID.randomUUID().toString());\n+\n+\t\tDBOTermsOfUseAgreement tou = new DBOTermsOfUseAgreement();\n+\t\ttou.setAgreesToTermsOfUse(Boolean.TRUE);\n+\n+\t\tNewUser nu2 = new NewUser();\n+\t\tnu2.setEmail(UUID.randomUUID().toString() + \"@test.com\");\n+\t\tnu2.setUserName(UUID.randomUUID().toString());\n+\n+\t\tuser1 = userManager.createOrGetTestUser(adminUserInfo, nu1, cred, tou);\n+\t\tuser2 = userManager.createOrGetTestUser(adminUserInfo, nu2, cred, tou);\n+\n+\t\t// Create two clients\n+\t\tclient1 = createOAuthClient(user1, CLIENT_1_NAME, CLIENT_1_URI);\n+\t\tclient2 = createOAuthClient(user1, CLIENT_2_NAME, CLIENT_2_URI);\n+\n+\t}\n+\t\n+\t@AfterEach\n+\tpublic void afterEach() throws Exception {\n+\t\ttry {\n+\t\t\toauthClientManager.deleteOpenIDConnectClient(adminUserInfo, client1.getClient_id());\n+\t\t\toauthClientManager.deleteOpenIDConnectClient(adminUserInfo, client2.getClient_id());\n+\t\t} catch (NotFoundException e) {\n+\t\t\t// stale ID, no deletion necessary\n+\t\t}\n+\t\ttry {\n+\t\t\tuserManager.deletePrincipal(adminUserInfo, user1.getId());\n+\t\t\tuserManager.deletePrincipal(adminUserInfo, user2.getId());\n+\t\t} catch (DataAccessException e) {\n+\t\t}\n+\t}\n+\n+\n+\t@Transactional\n+\t@Test\n+\tpublic void testRefreshTokenRoundTrip() throws Exception {\n+\t\t// Create a refresh token\n+\t\tOAuthRefreshTokenAndMetadata token = refreshTokenManager.createRefreshToken(user1.getId().toString(), client1.getClient_id(), scopes, claims);\n+\t\tassertNotNull(token);\n+\t\tassertTrue(StringUtils.isNotBlank(token.getRefreshToken()));\n+\t\tassertNotNull(token.getMetadata());\n+\n+\t\t// Retrieving the token with the token ID\n+\t\tOAuthRefreshTokenInformation retrievedViaId = refreshTokenManager.getRefreshTokenMetadata(user1, token.getMetadata().getTokenId());\n+\t\tassertNotNull(retrievedViaId);\n+\t\tassertEquals(token.getMetadata(), retrievedViaId);\n+\t\tassertEquals(user1.getId().toString(), retrievedViaId.getPrincipalId());\n+\t\tassertEquals(client1.getClient_id(), retrievedViaId.getClientId());\n+\t\tassertNotNull(retrievedViaId.getName());\n+\t\tassertNotNull(retrievedViaId.getEtag());\n+\t\tassertNotNull(retrievedViaId.getModifiedOn());\n+\t\tassertNotNull(retrievedViaId.getLastUsed());\n+\t\tassertNotNull(retrievedViaId.getAuthorizedOn());\n+\t\tassertEquals(scopes, retrievedViaId.getScopes());\n+\t\tassertEquals(claims, retrievedViaId.getClaims());\n+\n+\t\t// Retrieve the token with the token, causing a token refresh\n+\t\tOAuthRefreshTokenAndMetadata retrievedViaToken = refreshTokenManager.getRefreshTokenMetadataForUpdateAndRotate(token.getRefreshToken());\n+\t\tassertNotNull(retrievedViaToken);\n+\t\tassertTrue(StringUtils.isNotBlank(retrievedViaToken.getRefreshToken()));\n+\t\tassertNotEquals(retrievedViaToken.getRefreshToken(), token.getRefreshToken()); // The token should be different\n+\t\tassertNotNull(retrievedViaToken.getMetadata());\n+\t\t// Last used and Etag will have changed\n+\t\tassertNotEquals(token.getMetadata().getEtag(), retrievedViaToken.getMetadata().getEtag());\n+\t\tassertNotEquals(token.getMetadata().getLastUsed(), retrievedViaToken.getMetadata().getLastUsed());\n+\t\t// Everything else will be equal\n+\t\ttoken.getMetadata().setEtag(retrievedViaToken.getMetadata().getEtag());\n+\t\ttoken.getMetadata().setLastUsed(retrievedViaToken.getMetadata().getLastUsed());\n+\t\tassertEquals(token.getMetadata(), retrievedViaToken.getMetadata());\n+\n+\t\t// Should get IllegalArgumentException when trying to retrieve via the old hash\n+\t\tassertThrows(IllegalArgumentException.class, () -> refreshTokenManager.getRefreshTokenMetadataForUpdateAndRotate(token.getRefreshToken()));\n+\n+\t\t// Other user should get unauthz on attempt to retrieve via ID\n+\t\tassertThrows(UnauthorizedException.class, () -> refreshTokenManager.getRefreshTokenMetadata(user2, token.getMetadata().getTokenId()));\n+\n+\t\t// Update a refresh token's metadata\n+\t\tOAuthRefreshTokenInformation metadata = retrievedViaToken.getMetadata();\n+\t\tString customName = \"my token name\";\n+\t\tmetadata.setName(customName);\n+\t\tOAuthRefreshTokenInformation updatedMetadata = refreshTokenManager.updateRefreshTokenMetadata(user1, metadata);\n+\t\tassertEquals(customName, updatedMetadata.getName());\n+\t\tassertNotEquals(metadata.getEtag(), updatedMetadata.getEtag());\n+\t\tassertNotEquals(metadata.getModifiedOn(), updatedMetadata.getModifiedOn());", "originalCommit": "a56521b66059f5270be4b834cc1c8ccbdf061dc7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a5f3ce40740be8021f48b9cab56e2aec90e84663", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/a5f3ce40740be8021f48b9cab56e2aec90e84663", "message": "Code review changes to simplify OAuthRefreshTokenManager", "committedDate": "2020-06-12T14:53:36Z", "type": "commit"}, {"oid": "84258b0fc2acdf1d0e98b95e6ff7a0aa94ce6ed1", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/84258b0fc2acdf1d0e98b95e6ff7a0aa94ce6ed1", "message": "Convert assertNotEquals(Date1, Date2) to assertTrue(Date2.getTime >= Date1.getTime)", "committedDate": "2020-06-12T15:42:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU0NDAyMA==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4086#discussion_r439544020", "bodyText": "fix comments", "author": "brucehoff", "createdAt": "2020-06-12T17:12:41Z", "path": "services/repository-managers/src/test/java/org/sagebionetworks/repo/manager/oauth/OAuthRefreshTokenManagerAutowiredTest.java", "diffHunk": "@@ -0,0 +1,342 @@\n+package org.sagebionetworks.repo.manager.oauth;\n+\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.UUID;\n+\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.platform.commons.util.StringUtils;\n+import org.sagebionetworks.repo.manager.UserManager;\n+import org.sagebionetworks.repo.model.AuthorizationConstants.BOOTSTRAP_PRINCIPAL;\n+import org.sagebionetworks.repo.model.UnauthorizedException;\n+import org.sagebionetworks.repo.model.UserInfo;\n+import org.sagebionetworks.repo.model.auth.NewUser;\n+import org.sagebionetworks.repo.model.dbo.persistence.DBOCredential;\n+import org.sagebionetworks.repo.model.dbo.persistence.DBOTermsOfUseAgreement;\n+import org.sagebionetworks.repo.model.oauth.OAuthClient;\n+import org.sagebionetworks.repo.model.oauth.OAuthClientAuthorizationHistory;\n+import org.sagebionetworks.repo.model.oauth.OAuthClientAuthorizationHistoryList;\n+import org.sagebionetworks.repo.model.oauth.OAuthRefreshTokenInformation;\n+import org.sagebionetworks.repo.model.oauth.OAuthRefreshTokenInformationList;\n+import org.sagebionetworks.repo.model.oauth.OAuthScope;\n+import org.sagebionetworks.repo.model.oauth.OIDCClaimName;\n+import org.sagebionetworks.repo.model.oauth.OIDCClaimsRequest;\n+import org.sagebionetworks.repo.model.oauth.OIDCClaimsRequestDetails;\n+import org.sagebionetworks.repo.model.oauth.OIDCSigningAlgorithm;\n+import org.sagebionetworks.repo.web.NotFoundException;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.dao.DataAccessException;\n+import org.springframework.test.context.ContextConfiguration;\n+import org.springframework.test.context.junit.jupiter.SpringExtension;\n+import org.springframework.transaction.IllegalTransactionStateException;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+\n+@ExtendWith(SpringExtension.class)\n+@ContextConfiguration(locations = { \"classpath:test-context.xml\" })\n+public class OAuthRefreshTokenManagerAutowiredTest {\n+\tprivate static final String CLIENT_1_NAME = \"some client\";\n+\tprivate static final String CLIENT_1_URI = \"https://client1.uri.com/index.html\";\n+\tprivate static final String CLIENT_2_NAME = \"a different client\";\n+\tprivate static final String CLIENT_2_URI = \"https://client2.uri.com/index.html\";\n+\tprivate static final String POLICY_URI = \"https://client.uri.com/policy.html\";\n+\tprivate static final String TOS_URI = \"https://client.uri.com/termsOfService.html\";\n+\tprivate static final List<String> REDIRCT_URIS = Collections.singletonList(\"https://client.com/redir\");\n+\n+\t@Autowired\n+\tprivate UserManager userManager;\n+\n+\t@Autowired\n+\tOAuthClientManager oauthClientManager;\n+\t\n+\t@Autowired\n+\tOIDCTokenHelper tokenHelper;\n+\n+\t@Autowired\n+\tOAuthRefreshTokenManager refreshTokenManager;\n+\t\n+\tprivate UserInfo adminUserInfo;\n+\tprivate UserInfo user1;\n+\tprivate UserInfo user2;\n+\tprivate OAuthClient client1;\n+\tprivate OAuthClient client2;\n+\n+\tprivate List<OAuthScope> scopes;\n+\tprivate OIDCClaimsRequest claims;\n+\n+\tprivate OAuthClient createOAuthClient(UserInfo owner, String name, String uri) throws Exception {\n+\t\tOAuthClient toCreate = new OAuthClient();\n+\t\ttoCreate.setClient_name(name);\n+\t\ttoCreate.setClient_uri(uri);\n+\t\ttoCreate.setCreatedOn(new Date(System.currentTimeMillis()));\n+\t\ttoCreate.setModifiedOn(new Date(System.currentTimeMillis()));\n+\t\ttoCreate.setPolicy_uri(POLICY_URI);\n+\t\ttoCreate.setRedirect_uris(REDIRCT_URIS);\n+\t\ttoCreate.setTos_uri(TOS_URI);\n+\t\ttoCreate.setUserinfo_signed_response_alg(OIDCSigningAlgorithm.RS256);\n+\n+\t\treturn oauthClientManager.createOpenIDConnectClient(user1, toCreate);\n+\t}\n+\n+\t@BeforeEach\n+\tpublic void beforeEach() throws Exception {\n+\t\t// Scopes and claims just need placeholder values\n+\t\tscopes = Arrays.asList(OAuthScope.openid, OAuthScope.modify);\n+\t\tclaims = new OIDCClaimsRequest();\n+\t\tOIDCClaimsRequestDetails claimDetail = new OIDCClaimsRequestDetails();\n+\t\tclaimDetail.setEssential(true);\n+\t\tclaimDetail.setValue(\"532523\");\n+\t\tclaims.setUserinfo(Collections.singletonMap(OIDCClaimName.team.name(), claimDetail));\n+\t\tclaims.setId_token(Collections.emptyMap());\n+\n+\t\t// Create two users\n+\t\tadminUserInfo = userManager.getUserInfo(BOOTSTRAP_PRINCIPAL.THE_ADMIN_USER.getPrincipalId());\n+\t\tDBOCredential cred = new DBOCredential();\n+\t\tcred.setSecretKey(\"\");\n+\t\tNewUser nu1 = new NewUser();\n+\t\tnu1.setEmail(UUID.randomUUID().toString() + \"@test.com\");\n+\t\tnu1.setUserName(UUID.randomUUID().toString());\n+\n+\t\tDBOTermsOfUseAgreement tou = new DBOTermsOfUseAgreement();\n+\t\ttou.setAgreesToTermsOfUse(Boolean.TRUE);\n+\n+\t\tNewUser nu2 = new NewUser();\n+\t\tnu2.setEmail(UUID.randomUUID().toString() + \"@test.com\");\n+\t\tnu2.setUserName(UUID.randomUUID().toString());\n+\n+\t\tuser1 = userManager.createOrGetTestUser(adminUserInfo, nu1, cred, tou);\n+\t\tuser2 = userManager.createOrGetTestUser(adminUserInfo, nu2, cred, tou);\n+\n+\t\t// Create two clients\n+\t\tclient1 = createOAuthClient(user1, CLIENT_1_NAME, CLIENT_1_URI);\n+\t\tclient2 = createOAuthClient(user1, CLIENT_2_NAME, CLIENT_2_URI);\n+\n+\t}\n+\t\n+\t@AfterEach\n+\tpublic void afterEach() throws Exception {\n+\t\ttry {\n+\t\t\toauthClientManager.deleteOpenIDConnectClient(adminUserInfo, client1.getClient_id());\n+\t\t\toauthClientManager.deleteOpenIDConnectClient(adminUserInfo, client2.getClient_id());\n+\t\t} catch (NotFoundException e) {\n+\t\t\t// stale ID, no deletion necessary\n+\t\t}\n+\t\ttry {\n+\t\t\tuserManager.deletePrincipal(adminUserInfo, user1.getId());\n+\t\t\tuserManager.deletePrincipal(adminUserInfo, user2.getId());\n+\t\t} catch (DataAccessException e) {\n+\t\t}\n+\t}\n+\n+\n+\t@Transactional\n+\t@Test\n+\tpublic void testRefreshTokenRoundTrip() throws Exception {\n+\t\t// Create a refresh token\n+\t\tOAuthRefreshTokenAndMetadata token = refreshTokenManager.createRefreshToken(user1.getId().toString(), client1.getClient_id(), scopes, claims);\n+\t\tassertNotNull(token);\n+\t\tassertTrue(StringUtils.isNotBlank(token.getRefreshToken()));\n+\t\tOAuthRefreshTokenInformation tokenMetadata = token.getMetadata();\n+\t\tassertNotNull(tokenMetadata);\n+\t\tassertEquals(user1.getId().toString(), tokenMetadata.getPrincipalId());\n+\t\tassertEquals(client1.getClient_id(), tokenMetadata.getClientId());\n+\t\tassertNotNull(tokenMetadata.getName());\n+\t\tassertNotNull(tokenMetadata.getEtag());\n+\t\tassertNotNull(tokenMetadata.getModifiedOn());\n+\t\tassertNotNull(tokenMetadata.getLastUsed());\n+\t\tassertNotNull(tokenMetadata.getAuthorizedOn());\n+\t\tassertEquals(scopes, tokenMetadata.getScopes());\n+\t\tassertEquals(claims, tokenMetadata.getClaims());\n+\n+\t\t// Retrieving the token with the token ID as a user\n+\t\tOAuthRefreshTokenInformation retrievedViaId = refreshTokenManager.getRefreshTokenMetadata(user1, token.getMetadata().getTokenId());\n+\t\tassertNotNull(retrievedViaId);\n+\t\tassertEquals(token.getMetadata(), retrievedViaId);\n+\n+\t\t// Retrieving the token with the token ID as a verified client\n+\t\tretrievedViaId = refreshTokenManager.getRefreshTokenMetadata(client1.getClient_id(), token.getMetadata().getTokenId());\n+\t\tassertNotNull(retrievedViaId);\n+\t\tassertEquals(token.getMetadata(), retrievedViaId);\n+\n+\n+\t\t// Retrieve the token with the token, causing a token refresh\n+\t\tOAuthRefreshTokenAndMetadata retrievedViaToken = refreshTokenManager.rotateRefreshToken(token.getRefreshToken());\n+\t\tassertNotNull(retrievedViaToken);\n+\t\tassertTrue(StringUtils.isNotBlank(retrievedViaToken.getRefreshToken()));\n+\t\tassertNotEquals(retrievedViaToken.getRefreshToken(), token.getRefreshToken()); // The token should be different\n+\t\tassertNotNull(retrievedViaToken.getMetadata());\n+\t\t// Last used and Etag will have changed\n+\t\tassertNotEquals(token.getMetadata().getEtag(), retrievedViaToken.getMetadata().getEtag());\n+\t\tassertTrue(retrievedViaToken.getMetadata().getLastUsed().getTime() >= token.getMetadata().getLastUsed().getTime());\n+\t\t// Everything else will be equal\n+\t\ttoken.getMetadata().setEtag(retrievedViaToken.getMetadata().getEtag());\n+\t\ttoken.getMetadata().setLastUsed(retrievedViaToken.getMetadata().getLastUsed());\n+\t\tassertEquals(token.getMetadata(), retrievedViaToken.getMetadata());\n+\n+\t\t// Should get IllegalArgumentException when trying to retrieve via the old hash\n+\t\tassertThrows(IllegalArgumentException.class, () -> refreshTokenManager.rotateRefreshToken(token.getRefreshToken()));\n+\n+\t\t// Other user should get unauthz on attempt to retrieve via ID\n+\t\tassertThrows(UnauthorizedException.class, () -> refreshTokenManager.getRefreshTokenMetadata(user2, token.getMetadata().getTokenId()));\n+\n+\t\t// Other client should get unauthz on attempt to retrieve via ID\n+\t\tassertThrows(UnauthorizedException.class, () -> refreshTokenManager.getRefreshTokenMetadata(client2.getClient_id(), token.getMetadata().getTokenId()));\n+\n+\n+\t\t// Update a refresh token's metadata\n+\t\tOAuthRefreshTokenInformation metadata = retrievedViaToken.getMetadata();\n+\t\tString customName = \"my token name\";\n+\t\tmetadata.setName(customName);\n+\t\tOAuthRefreshTokenInformation updatedMetadata = refreshTokenManager.updateRefreshTokenMetadata(user1, metadata);\n+\t\tassertEquals(customName, updatedMetadata.getName());\n+\t\tassertNotEquals(metadata.getEtag(), updatedMetadata.getEtag());\n+\t\tassertTrue(updatedMetadata.getModifiedOn().getTime() >= metadata.getModifiedOn().getTime());\n+\t\t// Everything else should be equal\n+\t\tmetadata.setName(updatedMetadata.getName());\n+\t\tmetadata.setEtag(updatedMetadata.getEtag());\n+\t\tmetadata.setModifiedOn(updatedMetadata.getModifiedOn());\n+\t\tassertEquals(metadata, updatedMetadata);\n+\n+\t\t// Other user should get unauthz on attempt to update\n+\t\tassertThrows(UnauthorizedException.class, () -> refreshTokenManager.updateRefreshTokenMetadata(user2, updatedMetadata));\n+\n+\t\t// Revoke a refresh token\n+\t\t// Test unauthz first\n+\t\tassertThrows(UnauthorizedException.class, () -> refreshTokenManager.revokeRefreshToken(user2, token.getMetadata().getTokenId()));\n+\t\trefreshTokenManager.revokeRefreshToken(user1, token.getMetadata().getTokenId());\n+\n+\t\t// Should get NFE because token is revoked/deleted.\n+\t\tassertThrows(NotFoundException.class, () -> refreshTokenManager.getRefreshTokenMetadata(user1, token.getMetadata().getTokenId()));\n+\t\t// Should get IllegalArgumentException when trying to retrieve via hash\n+\t\tassertThrows(IllegalArgumentException.class, () -> refreshTokenManager.rotateRefreshToken(retrievedViaToken.getRefreshToken()));\n+\n+\t}\n+\n+\t@Test\n+\tpublic void testAuditAndRevokeTokensForUserClientPair() throws Exception {\n+\t\t// Create two tokens for client 1, one token for client 2\n+\t\tOAuthRefreshTokenAndMetadata client1Token1 = refreshTokenManager.createRefreshToken(user1.getId().toString(), client1.getClient_id(), scopes, claims);\n+\t\tOAuthRefreshTokenAndMetadata client1Token2 = refreshTokenManager.createRefreshToken(user1.getId().toString(), client1.getClient_id(), scopes, claims);\n+\t\tOAuthRefreshTokenAndMetadata client2Token = refreshTokenManager.createRefreshToken(user1.getId().toString(), client2.getClient_id(), scopes, claims);\n+\n+\t\t// Audit clients\n+\t\tOAuthClientAuthorizationHistoryList historyList = refreshTokenManager.getAuthorizedClientHistory(user1, null);\n+\t\tassertEquals(2, historyList.getResults().size());\n+\t\tassertNull(historyList.getNextPageToken());\n+\t\tOAuthClientAuthorizationHistory client1History = null;\n+\t\tOAuthClientAuthorizationHistory client2History = null;\n+\t\tfor (OAuthClientAuthorizationHistory history : historyList.getResults()) {\n+\t\t\tif (history.getClient().getClient_id().equals(client1.getClient_id())) {\n+\t\t\t\tclient1History = history;\n+\t\t\t} else if (history.getClient().getClient_id().equals(client2.getClient_id())) {\n+\t\t\t\tclient2History = history;\n+\t\t\t} else {\n+\t\t\t\tfail(\"Found an unexpected OAuthClientAuthorizationHistory record.\");\n+\t\t\t}\n+\t\t}\n+\t\tassertNotNull(client1History);\n+\t\tassertNull(client1History.getClient().getCreatedBy()); // Public fields should have been removed", "originalCommit": "84258b0fc2acdf1d0e98b95e6ff7a0aa94ce6ed1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU0NDI3Mg==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4086#discussion_r439544272", "bodyText": "client1History -> client2History", "author": "brucehoff", "createdAt": "2020-06-12T17:13:12Z", "path": "services/repository-managers/src/test/java/org/sagebionetworks/repo/manager/oauth/OAuthRefreshTokenManagerAutowiredTest.java", "diffHunk": "@@ -0,0 +1,342 @@\n+package org.sagebionetworks.repo.manager.oauth;\n+\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.UUID;\n+\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.platform.commons.util.StringUtils;\n+import org.sagebionetworks.repo.manager.UserManager;\n+import org.sagebionetworks.repo.model.AuthorizationConstants.BOOTSTRAP_PRINCIPAL;\n+import org.sagebionetworks.repo.model.UnauthorizedException;\n+import org.sagebionetworks.repo.model.UserInfo;\n+import org.sagebionetworks.repo.model.auth.NewUser;\n+import org.sagebionetworks.repo.model.dbo.persistence.DBOCredential;\n+import org.sagebionetworks.repo.model.dbo.persistence.DBOTermsOfUseAgreement;\n+import org.sagebionetworks.repo.model.oauth.OAuthClient;\n+import org.sagebionetworks.repo.model.oauth.OAuthClientAuthorizationHistory;\n+import org.sagebionetworks.repo.model.oauth.OAuthClientAuthorizationHistoryList;\n+import org.sagebionetworks.repo.model.oauth.OAuthRefreshTokenInformation;\n+import org.sagebionetworks.repo.model.oauth.OAuthRefreshTokenInformationList;\n+import org.sagebionetworks.repo.model.oauth.OAuthScope;\n+import org.sagebionetworks.repo.model.oauth.OIDCClaimName;\n+import org.sagebionetworks.repo.model.oauth.OIDCClaimsRequest;\n+import org.sagebionetworks.repo.model.oauth.OIDCClaimsRequestDetails;\n+import org.sagebionetworks.repo.model.oauth.OIDCSigningAlgorithm;\n+import org.sagebionetworks.repo.web.NotFoundException;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.dao.DataAccessException;\n+import org.springframework.test.context.ContextConfiguration;\n+import org.springframework.test.context.junit.jupiter.SpringExtension;\n+import org.springframework.transaction.IllegalTransactionStateException;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+\n+@ExtendWith(SpringExtension.class)\n+@ContextConfiguration(locations = { \"classpath:test-context.xml\" })\n+public class OAuthRefreshTokenManagerAutowiredTest {\n+\tprivate static final String CLIENT_1_NAME = \"some client\";\n+\tprivate static final String CLIENT_1_URI = \"https://client1.uri.com/index.html\";\n+\tprivate static final String CLIENT_2_NAME = \"a different client\";\n+\tprivate static final String CLIENT_2_URI = \"https://client2.uri.com/index.html\";\n+\tprivate static final String POLICY_URI = \"https://client.uri.com/policy.html\";\n+\tprivate static final String TOS_URI = \"https://client.uri.com/termsOfService.html\";\n+\tprivate static final List<String> REDIRCT_URIS = Collections.singletonList(\"https://client.com/redir\");\n+\n+\t@Autowired\n+\tprivate UserManager userManager;\n+\n+\t@Autowired\n+\tOAuthClientManager oauthClientManager;\n+\t\n+\t@Autowired\n+\tOIDCTokenHelper tokenHelper;\n+\n+\t@Autowired\n+\tOAuthRefreshTokenManager refreshTokenManager;\n+\t\n+\tprivate UserInfo adminUserInfo;\n+\tprivate UserInfo user1;\n+\tprivate UserInfo user2;\n+\tprivate OAuthClient client1;\n+\tprivate OAuthClient client2;\n+\n+\tprivate List<OAuthScope> scopes;\n+\tprivate OIDCClaimsRequest claims;\n+\n+\tprivate OAuthClient createOAuthClient(UserInfo owner, String name, String uri) throws Exception {\n+\t\tOAuthClient toCreate = new OAuthClient();\n+\t\ttoCreate.setClient_name(name);\n+\t\ttoCreate.setClient_uri(uri);\n+\t\ttoCreate.setCreatedOn(new Date(System.currentTimeMillis()));\n+\t\ttoCreate.setModifiedOn(new Date(System.currentTimeMillis()));\n+\t\ttoCreate.setPolicy_uri(POLICY_URI);\n+\t\ttoCreate.setRedirect_uris(REDIRCT_URIS);\n+\t\ttoCreate.setTos_uri(TOS_URI);\n+\t\ttoCreate.setUserinfo_signed_response_alg(OIDCSigningAlgorithm.RS256);\n+\n+\t\treturn oauthClientManager.createOpenIDConnectClient(user1, toCreate);\n+\t}\n+\n+\t@BeforeEach\n+\tpublic void beforeEach() throws Exception {\n+\t\t// Scopes and claims just need placeholder values\n+\t\tscopes = Arrays.asList(OAuthScope.openid, OAuthScope.modify);\n+\t\tclaims = new OIDCClaimsRequest();\n+\t\tOIDCClaimsRequestDetails claimDetail = new OIDCClaimsRequestDetails();\n+\t\tclaimDetail.setEssential(true);\n+\t\tclaimDetail.setValue(\"532523\");\n+\t\tclaims.setUserinfo(Collections.singletonMap(OIDCClaimName.team.name(), claimDetail));\n+\t\tclaims.setId_token(Collections.emptyMap());\n+\n+\t\t// Create two users\n+\t\tadminUserInfo = userManager.getUserInfo(BOOTSTRAP_PRINCIPAL.THE_ADMIN_USER.getPrincipalId());\n+\t\tDBOCredential cred = new DBOCredential();\n+\t\tcred.setSecretKey(\"\");\n+\t\tNewUser nu1 = new NewUser();\n+\t\tnu1.setEmail(UUID.randomUUID().toString() + \"@test.com\");\n+\t\tnu1.setUserName(UUID.randomUUID().toString());\n+\n+\t\tDBOTermsOfUseAgreement tou = new DBOTermsOfUseAgreement();\n+\t\ttou.setAgreesToTermsOfUse(Boolean.TRUE);\n+\n+\t\tNewUser nu2 = new NewUser();\n+\t\tnu2.setEmail(UUID.randomUUID().toString() + \"@test.com\");\n+\t\tnu2.setUserName(UUID.randomUUID().toString());\n+\n+\t\tuser1 = userManager.createOrGetTestUser(adminUserInfo, nu1, cred, tou);\n+\t\tuser2 = userManager.createOrGetTestUser(adminUserInfo, nu2, cred, tou);\n+\n+\t\t// Create two clients\n+\t\tclient1 = createOAuthClient(user1, CLIENT_1_NAME, CLIENT_1_URI);\n+\t\tclient2 = createOAuthClient(user1, CLIENT_2_NAME, CLIENT_2_URI);\n+\n+\t}\n+\t\n+\t@AfterEach\n+\tpublic void afterEach() throws Exception {\n+\t\ttry {\n+\t\t\toauthClientManager.deleteOpenIDConnectClient(adminUserInfo, client1.getClient_id());\n+\t\t\toauthClientManager.deleteOpenIDConnectClient(adminUserInfo, client2.getClient_id());\n+\t\t} catch (NotFoundException e) {\n+\t\t\t// stale ID, no deletion necessary\n+\t\t}\n+\t\ttry {\n+\t\t\tuserManager.deletePrincipal(adminUserInfo, user1.getId());\n+\t\t\tuserManager.deletePrincipal(adminUserInfo, user2.getId());\n+\t\t} catch (DataAccessException e) {\n+\t\t}\n+\t}\n+\n+\n+\t@Transactional\n+\t@Test\n+\tpublic void testRefreshTokenRoundTrip() throws Exception {\n+\t\t// Create a refresh token\n+\t\tOAuthRefreshTokenAndMetadata token = refreshTokenManager.createRefreshToken(user1.getId().toString(), client1.getClient_id(), scopes, claims);\n+\t\tassertNotNull(token);\n+\t\tassertTrue(StringUtils.isNotBlank(token.getRefreshToken()));\n+\t\tOAuthRefreshTokenInformation tokenMetadata = token.getMetadata();\n+\t\tassertNotNull(tokenMetadata);\n+\t\tassertEquals(user1.getId().toString(), tokenMetadata.getPrincipalId());\n+\t\tassertEquals(client1.getClient_id(), tokenMetadata.getClientId());\n+\t\tassertNotNull(tokenMetadata.getName());\n+\t\tassertNotNull(tokenMetadata.getEtag());\n+\t\tassertNotNull(tokenMetadata.getModifiedOn());\n+\t\tassertNotNull(tokenMetadata.getLastUsed());\n+\t\tassertNotNull(tokenMetadata.getAuthorizedOn());\n+\t\tassertEquals(scopes, tokenMetadata.getScopes());\n+\t\tassertEquals(claims, tokenMetadata.getClaims());\n+\n+\t\t// Retrieving the token with the token ID as a user\n+\t\tOAuthRefreshTokenInformation retrievedViaId = refreshTokenManager.getRefreshTokenMetadata(user1, token.getMetadata().getTokenId());\n+\t\tassertNotNull(retrievedViaId);\n+\t\tassertEquals(token.getMetadata(), retrievedViaId);\n+\n+\t\t// Retrieving the token with the token ID as a verified client\n+\t\tretrievedViaId = refreshTokenManager.getRefreshTokenMetadata(client1.getClient_id(), token.getMetadata().getTokenId());\n+\t\tassertNotNull(retrievedViaId);\n+\t\tassertEquals(token.getMetadata(), retrievedViaId);\n+\n+\n+\t\t// Retrieve the token with the token, causing a token refresh\n+\t\tOAuthRefreshTokenAndMetadata retrievedViaToken = refreshTokenManager.rotateRefreshToken(token.getRefreshToken());\n+\t\tassertNotNull(retrievedViaToken);\n+\t\tassertTrue(StringUtils.isNotBlank(retrievedViaToken.getRefreshToken()));\n+\t\tassertNotEquals(retrievedViaToken.getRefreshToken(), token.getRefreshToken()); // The token should be different\n+\t\tassertNotNull(retrievedViaToken.getMetadata());\n+\t\t// Last used and Etag will have changed\n+\t\tassertNotEquals(token.getMetadata().getEtag(), retrievedViaToken.getMetadata().getEtag());\n+\t\tassertTrue(retrievedViaToken.getMetadata().getLastUsed().getTime() >= token.getMetadata().getLastUsed().getTime());\n+\t\t// Everything else will be equal\n+\t\ttoken.getMetadata().setEtag(retrievedViaToken.getMetadata().getEtag());\n+\t\ttoken.getMetadata().setLastUsed(retrievedViaToken.getMetadata().getLastUsed());\n+\t\tassertEquals(token.getMetadata(), retrievedViaToken.getMetadata());\n+\n+\t\t// Should get IllegalArgumentException when trying to retrieve via the old hash\n+\t\tassertThrows(IllegalArgumentException.class, () -> refreshTokenManager.rotateRefreshToken(token.getRefreshToken()));\n+\n+\t\t// Other user should get unauthz on attempt to retrieve via ID\n+\t\tassertThrows(UnauthorizedException.class, () -> refreshTokenManager.getRefreshTokenMetadata(user2, token.getMetadata().getTokenId()));\n+\n+\t\t// Other client should get unauthz on attempt to retrieve via ID\n+\t\tassertThrows(UnauthorizedException.class, () -> refreshTokenManager.getRefreshTokenMetadata(client2.getClient_id(), token.getMetadata().getTokenId()));\n+\n+\n+\t\t// Update a refresh token's metadata\n+\t\tOAuthRefreshTokenInformation metadata = retrievedViaToken.getMetadata();\n+\t\tString customName = \"my token name\";\n+\t\tmetadata.setName(customName);\n+\t\tOAuthRefreshTokenInformation updatedMetadata = refreshTokenManager.updateRefreshTokenMetadata(user1, metadata);\n+\t\tassertEquals(customName, updatedMetadata.getName());\n+\t\tassertNotEquals(metadata.getEtag(), updatedMetadata.getEtag());\n+\t\tassertTrue(updatedMetadata.getModifiedOn().getTime() >= metadata.getModifiedOn().getTime());\n+\t\t// Everything else should be equal\n+\t\tmetadata.setName(updatedMetadata.getName());\n+\t\tmetadata.setEtag(updatedMetadata.getEtag());\n+\t\tmetadata.setModifiedOn(updatedMetadata.getModifiedOn());\n+\t\tassertEquals(metadata, updatedMetadata);\n+\n+\t\t// Other user should get unauthz on attempt to update\n+\t\tassertThrows(UnauthorizedException.class, () -> refreshTokenManager.updateRefreshTokenMetadata(user2, updatedMetadata));\n+\n+\t\t// Revoke a refresh token\n+\t\t// Test unauthz first\n+\t\tassertThrows(UnauthorizedException.class, () -> refreshTokenManager.revokeRefreshToken(user2, token.getMetadata().getTokenId()));\n+\t\trefreshTokenManager.revokeRefreshToken(user1, token.getMetadata().getTokenId());\n+\n+\t\t// Should get NFE because token is revoked/deleted.\n+\t\tassertThrows(NotFoundException.class, () -> refreshTokenManager.getRefreshTokenMetadata(user1, token.getMetadata().getTokenId()));\n+\t\t// Should get IllegalArgumentException when trying to retrieve via hash\n+\t\tassertThrows(IllegalArgumentException.class, () -> refreshTokenManager.rotateRefreshToken(retrievedViaToken.getRefreshToken()));\n+\n+\t}\n+\n+\t@Test\n+\tpublic void testAuditAndRevokeTokensForUserClientPair() throws Exception {\n+\t\t// Create two tokens for client 1, one token for client 2\n+\t\tOAuthRefreshTokenAndMetadata client1Token1 = refreshTokenManager.createRefreshToken(user1.getId().toString(), client1.getClient_id(), scopes, claims);\n+\t\tOAuthRefreshTokenAndMetadata client1Token2 = refreshTokenManager.createRefreshToken(user1.getId().toString(), client1.getClient_id(), scopes, claims);\n+\t\tOAuthRefreshTokenAndMetadata client2Token = refreshTokenManager.createRefreshToken(user1.getId().toString(), client2.getClient_id(), scopes, claims);\n+\n+\t\t// Audit clients\n+\t\tOAuthClientAuthorizationHistoryList historyList = refreshTokenManager.getAuthorizedClientHistory(user1, null);\n+\t\tassertEquals(2, historyList.getResults().size());\n+\t\tassertNull(historyList.getNextPageToken());\n+\t\tOAuthClientAuthorizationHistory client1History = null;\n+\t\tOAuthClientAuthorizationHistory client2History = null;\n+\t\tfor (OAuthClientAuthorizationHistory history : historyList.getResults()) {\n+\t\t\tif (history.getClient().getClient_id().equals(client1.getClient_id())) {\n+\t\t\t\tclient1History = history;\n+\t\t\t} else if (history.getClient().getClient_id().equals(client2.getClient_id())) {\n+\t\t\t\tclient2History = history;\n+\t\t\t} else {\n+\t\t\t\tfail(\"Found an unexpected OAuthClientAuthorizationHistory record.\");\n+\t\t\t}\n+\t\t}\n+\t\tassertNotNull(client1History);\n+\t\tassertNull(client1History.getClient().getCreatedBy()); // Public fields should have been removed\n+\t\tassertNotNull(client2History);\n+\t\tassertNull(client1History.getClient().getCreatedBy()); // Public fields should have been removed", "originalCommit": "84258b0fc2acdf1d0e98b95e6ff7a0aa94ce6ed1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU0NTM0OA==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4086#discussion_r439545348", "bodyText": "// method under test", "author": "brucehoff", "createdAt": "2020-06-12T17:15:29Z", "path": "services/repository-managers/src/test/java/org/sagebionetworks/repo/manager/oauth/OAuthRefreshTokenManagerAutowiredTest.java", "diffHunk": "@@ -0,0 +1,342 @@\n+package org.sagebionetworks.repo.manager.oauth;\n+\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.UUID;\n+\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.platform.commons.util.StringUtils;\n+import org.sagebionetworks.repo.manager.UserManager;\n+import org.sagebionetworks.repo.model.AuthorizationConstants.BOOTSTRAP_PRINCIPAL;\n+import org.sagebionetworks.repo.model.UnauthorizedException;\n+import org.sagebionetworks.repo.model.UserInfo;\n+import org.sagebionetworks.repo.model.auth.NewUser;\n+import org.sagebionetworks.repo.model.dbo.persistence.DBOCredential;\n+import org.sagebionetworks.repo.model.dbo.persistence.DBOTermsOfUseAgreement;\n+import org.sagebionetworks.repo.model.oauth.OAuthClient;\n+import org.sagebionetworks.repo.model.oauth.OAuthClientAuthorizationHistory;\n+import org.sagebionetworks.repo.model.oauth.OAuthClientAuthorizationHistoryList;\n+import org.sagebionetworks.repo.model.oauth.OAuthRefreshTokenInformation;\n+import org.sagebionetworks.repo.model.oauth.OAuthRefreshTokenInformationList;\n+import org.sagebionetworks.repo.model.oauth.OAuthScope;\n+import org.sagebionetworks.repo.model.oauth.OIDCClaimName;\n+import org.sagebionetworks.repo.model.oauth.OIDCClaimsRequest;\n+import org.sagebionetworks.repo.model.oauth.OIDCClaimsRequestDetails;\n+import org.sagebionetworks.repo.model.oauth.OIDCSigningAlgorithm;\n+import org.sagebionetworks.repo.web.NotFoundException;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.dao.DataAccessException;\n+import org.springframework.test.context.ContextConfiguration;\n+import org.springframework.test.context.junit.jupiter.SpringExtension;\n+import org.springframework.transaction.IllegalTransactionStateException;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+\n+@ExtendWith(SpringExtension.class)\n+@ContextConfiguration(locations = { \"classpath:test-context.xml\" })\n+public class OAuthRefreshTokenManagerAutowiredTest {\n+\tprivate static final String CLIENT_1_NAME = \"some client\";\n+\tprivate static final String CLIENT_1_URI = \"https://client1.uri.com/index.html\";\n+\tprivate static final String CLIENT_2_NAME = \"a different client\";\n+\tprivate static final String CLIENT_2_URI = \"https://client2.uri.com/index.html\";\n+\tprivate static final String POLICY_URI = \"https://client.uri.com/policy.html\";\n+\tprivate static final String TOS_URI = \"https://client.uri.com/termsOfService.html\";\n+\tprivate static final List<String> REDIRCT_URIS = Collections.singletonList(\"https://client.com/redir\");\n+\n+\t@Autowired\n+\tprivate UserManager userManager;\n+\n+\t@Autowired\n+\tOAuthClientManager oauthClientManager;\n+\t\n+\t@Autowired\n+\tOIDCTokenHelper tokenHelper;\n+\n+\t@Autowired\n+\tOAuthRefreshTokenManager refreshTokenManager;\n+\t\n+\tprivate UserInfo adminUserInfo;\n+\tprivate UserInfo user1;\n+\tprivate UserInfo user2;\n+\tprivate OAuthClient client1;\n+\tprivate OAuthClient client2;\n+\n+\tprivate List<OAuthScope> scopes;\n+\tprivate OIDCClaimsRequest claims;\n+\n+\tprivate OAuthClient createOAuthClient(UserInfo owner, String name, String uri) throws Exception {\n+\t\tOAuthClient toCreate = new OAuthClient();\n+\t\ttoCreate.setClient_name(name);\n+\t\ttoCreate.setClient_uri(uri);\n+\t\ttoCreate.setCreatedOn(new Date(System.currentTimeMillis()));\n+\t\ttoCreate.setModifiedOn(new Date(System.currentTimeMillis()));\n+\t\ttoCreate.setPolicy_uri(POLICY_URI);\n+\t\ttoCreate.setRedirect_uris(REDIRCT_URIS);\n+\t\ttoCreate.setTos_uri(TOS_URI);\n+\t\ttoCreate.setUserinfo_signed_response_alg(OIDCSigningAlgorithm.RS256);\n+\n+\t\treturn oauthClientManager.createOpenIDConnectClient(user1, toCreate);\n+\t}\n+\n+\t@BeforeEach\n+\tpublic void beforeEach() throws Exception {\n+\t\t// Scopes and claims just need placeholder values\n+\t\tscopes = Arrays.asList(OAuthScope.openid, OAuthScope.modify);\n+\t\tclaims = new OIDCClaimsRequest();\n+\t\tOIDCClaimsRequestDetails claimDetail = new OIDCClaimsRequestDetails();\n+\t\tclaimDetail.setEssential(true);\n+\t\tclaimDetail.setValue(\"532523\");\n+\t\tclaims.setUserinfo(Collections.singletonMap(OIDCClaimName.team.name(), claimDetail));\n+\t\tclaims.setId_token(Collections.emptyMap());\n+\n+\t\t// Create two users\n+\t\tadminUserInfo = userManager.getUserInfo(BOOTSTRAP_PRINCIPAL.THE_ADMIN_USER.getPrincipalId());\n+\t\tDBOCredential cred = new DBOCredential();\n+\t\tcred.setSecretKey(\"\");\n+\t\tNewUser nu1 = new NewUser();\n+\t\tnu1.setEmail(UUID.randomUUID().toString() + \"@test.com\");\n+\t\tnu1.setUserName(UUID.randomUUID().toString());\n+\n+\t\tDBOTermsOfUseAgreement tou = new DBOTermsOfUseAgreement();\n+\t\ttou.setAgreesToTermsOfUse(Boolean.TRUE);\n+\n+\t\tNewUser nu2 = new NewUser();\n+\t\tnu2.setEmail(UUID.randomUUID().toString() + \"@test.com\");\n+\t\tnu2.setUserName(UUID.randomUUID().toString());\n+\n+\t\tuser1 = userManager.createOrGetTestUser(adminUserInfo, nu1, cred, tou);\n+\t\tuser2 = userManager.createOrGetTestUser(adminUserInfo, nu2, cred, tou);\n+\n+\t\t// Create two clients\n+\t\tclient1 = createOAuthClient(user1, CLIENT_1_NAME, CLIENT_1_URI);\n+\t\tclient2 = createOAuthClient(user1, CLIENT_2_NAME, CLIENT_2_URI);\n+\n+\t}\n+\t\n+\t@AfterEach\n+\tpublic void afterEach() throws Exception {\n+\t\ttry {\n+\t\t\toauthClientManager.deleteOpenIDConnectClient(adminUserInfo, client1.getClient_id());\n+\t\t\toauthClientManager.deleteOpenIDConnectClient(adminUserInfo, client2.getClient_id());\n+\t\t} catch (NotFoundException e) {\n+\t\t\t// stale ID, no deletion necessary\n+\t\t}\n+\t\ttry {\n+\t\t\tuserManager.deletePrincipal(adminUserInfo, user1.getId());\n+\t\t\tuserManager.deletePrincipal(adminUserInfo, user2.getId());\n+\t\t} catch (DataAccessException e) {\n+\t\t}\n+\t}\n+\n+\n+\t@Transactional\n+\t@Test\n+\tpublic void testRefreshTokenRoundTrip() throws Exception {\n+\t\t// Create a refresh token\n+\t\tOAuthRefreshTokenAndMetadata token = refreshTokenManager.createRefreshToken(user1.getId().toString(), client1.getClient_id(), scopes, claims);\n+\t\tassertNotNull(token);\n+\t\tassertTrue(StringUtils.isNotBlank(token.getRefreshToken()));\n+\t\tOAuthRefreshTokenInformation tokenMetadata = token.getMetadata();\n+\t\tassertNotNull(tokenMetadata);\n+\t\tassertEquals(user1.getId().toString(), tokenMetadata.getPrincipalId());\n+\t\tassertEquals(client1.getClient_id(), tokenMetadata.getClientId());\n+\t\tassertNotNull(tokenMetadata.getName());\n+\t\tassertNotNull(tokenMetadata.getEtag());\n+\t\tassertNotNull(tokenMetadata.getModifiedOn());\n+\t\tassertNotNull(tokenMetadata.getLastUsed());\n+\t\tassertNotNull(tokenMetadata.getAuthorizedOn());\n+\t\tassertEquals(scopes, tokenMetadata.getScopes());\n+\t\tassertEquals(claims, tokenMetadata.getClaims());\n+\n+\t\t// Retrieving the token with the token ID as a user\n+\t\tOAuthRefreshTokenInformation retrievedViaId = refreshTokenManager.getRefreshTokenMetadata(user1, token.getMetadata().getTokenId());\n+\t\tassertNotNull(retrievedViaId);\n+\t\tassertEquals(token.getMetadata(), retrievedViaId);\n+\n+\t\t// Retrieving the token with the token ID as a verified client\n+\t\tretrievedViaId = refreshTokenManager.getRefreshTokenMetadata(client1.getClient_id(), token.getMetadata().getTokenId());\n+\t\tassertNotNull(retrievedViaId);\n+\t\tassertEquals(token.getMetadata(), retrievedViaId);\n+\n+\n+\t\t// Retrieve the token with the token, causing a token refresh\n+\t\tOAuthRefreshTokenAndMetadata retrievedViaToken = refreshTokenManager.rotateRefreshToken(token.getRefreshToken());\n+\t\tassertNotNull(retrievedViaToken);\n+\t\tassertTrue(StringUtils.isNotBlank(retrievedViaToken.getRefreshToken()));\n+\t\tassertNotEquals(retrievedViaToken.getRefreshToken(), token.getRefreshToken()); // The token should be different\n+\t\tassertNotNull(retrievedViaToken.getMetadata());\n+\t\t// Last used and Etag will have changed\n+\t\tassertNotEquals(token.getMetadata().getEtag(), retrievedViaToken.getMetadata().getEtag());\n+\t\tassertTrue(retrievedViaToken.getMetadata().getLastUsed().getTime() >= token.getMetadata().getLastUsed().getTime());\n+\t\t// Everything else will be equal\n+\t\ttoken.getMetadata().setEtag(retrievedViaToken.getMetadata().getEtag());\n+\t\ttoken.getMetadata().setLastUsed(retrievedViaToken.getMetadata().getLastUsed());\n+\t\tassertEquals(token.getMetadata(), retrievedViaToken.getMetadata());\n+\n+\t\t// Should get IllegalArgumentException when trying to retrieve via the old hash\n+\t\tassertThrows(IllegalArgumentException.class, () -> refreshTokenManager.rotateRefreshToken(token.getRefreshToken()));\n+\n+\t\t// Other user should get unauthz on attempt to retrieve via ID\n+\t\tassertThrows(UnauthorizedException.class, () -> refreshTokenManager.getRefreshTokenMetadata(user2, token.getMetadata().getTokenId()));\n+\n+\t\t// Other client should get unauthz on attempt to retrieve via ID\n+\t\tassertThrows(UnauthorizedException.class, () -> refreshTokenManager.getRefreshTokenMetadata(client2.getClient_id(), token.getMetadata().getTokenId()));\n+\n+\n+\t\t// Update a refresh token's metadata\n+\t\tOAuthRefreshTokenInformation metadata = retrievedViaToken.getMetadata();\n+\t\tString customName = \"my token name\";\n+\t\tmetadata.setName(customName);\n+\t\tOAuthRefreshTokenInformation updatedMetadata = refreshTokenManager.updateRefreshTokenMetadata(user1, metadata);\n+\t\tassertEquals(customName, updatedMetadata.getName());\n+\t\tassertNotEquals(metadata.getEtag(), updatedMetadata.getEtag());\n+\t\tassertTrue(updatedMetadata.getModifiedOn().getTime() >= metadata.getModifiedOn().getTime());\n+\t\t// Everything else should be equal\n+\t\tmetadata.setName(updatedMetadata.getName());\n+\t\tmetadata.setEtag(updatedMetadata.getEtag());\n+\t\tmetadata.setModifiedOn(updatedMetadata.getModifiedOn());\n+\t\tassertEquals(metadata, updatedMetadata);\n+\n+\t\t// Other user should get unauthz on attempt to update\n+\t\tassertThrows(UnauthorizedException.class, () -> refreshTokenManager.updateRefreshTokenMetadata(user2, updatedMetadata));\n+\n+\t\t// Revoke a refresh token\n+\t\t// Test unauthz first\n+\t\tassertThrows(UnauthorizedException.class, () -> refreshTokenManager.revokeRefreshToken(user2, token.getMetadata().getTokenId()));\n+\t\trefreshTokenManager.revokeRefreshToken(user1, token.getMetadata().getTokenId());\n+\n+\t\t// Should get NFE because token is revoked/deleted.\n+\t\tassertThrows(NotFoundException.class, () -> refreshTokenManager.getRefreshTokenMetadata(user1, token.getMetadata().getTokenId()));\n+\t\t// Should get IllegalArgumentException when trying to retrieve via hash\n+\t\tassertThrows(IllegalArgumentException.class, () -> refreshTokenManager.rotateRefreshToken(retrievedViaToken.getRefreshToken()));\n+\n+\t}\n+\n+\t@Test\n+\tpublic void testAuditAndRevokeTokensForUserClientPair() throws Exception {\n+\t\t// Create two tokens for client 1, one token for client 2\n+\t\tOAuthRefreshTokenAndMetadata client1Token1 = refreshTokenManager.createRefreshToken(user1.getId().toString(), client1.getClient_id(), scopes, claims);\n+\t\tOAuthRefreshTokenAndMetadata client1Token2 = refreshTokenManager.createRefreshToken(user1.getId().toString(), client1.getClient_id(), scopes, claims);\n+\t\tOAuthRefreshTokenAndMetadata client2Token = refreshTokenManager.createRefreshToken(user1.getId().toString(), client2.getClient_id(), scopes, claims);\n+\n+\t\t// Audit clients\n+\t\tOAuthClientAuthorizationHistoryList historyList = refreshTokenManager.getAuthorizedClientHistory(user1, null);", "originalCommit": "84258b0fc2acdf1d0e98b95e6ff7a0aa94ce6ed1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU0NTQ3OA==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4086#discussion_r439545478", "bodyText": "// method under test", "author": "brucehoff", "createdAt": "2020-06-12T17:15:45Z", "path": "services/repository-managers/src/test/java/org/sagebionetworks/repo/manager/oauth/OAuthRefreshTokenManagerAutowiredTest.java", "diffHunk": "@@ -0,0 +1,342 @@\n+package org.sagebionetworks.repo.manager.oauth;\n+\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.UUID;\n+\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.platform.commons.util.StringUtils;\n+import org.sagebionetworks.repo.manager.UserManager;\n+import org.sagebionetworks.repo.model.AuthorizationConstants.BOOTSTRAP_PRINCIPAL;\n+import org.sagebionetworks.repo.model.UnauthorizedException;\n+import org.sagebionetworks.repo.model.UserInfo;\n+import org.sagebionetworks.repo.model.auth.NewUser;\n+import org.sagebionetworks.repo.model.dbo.persistence.DBOCredential;\n+import org.sagebionetworks.repo.model.dbo.persistence.DBOTermsOfUseAgreement;\n+import org.sagebionetworks.repo.model.oauth.OAuthClient;\n+import org.sagebionetworks.repo.model.oauth.OAuthClientAuthorizationHistory;\n+import org.sagebionetworks.repo.model.oauth.OAuthClientAuthorizationHistoryList;\n+import org.sagebionetworks.repo.model.oauth.OAuthRefreshTokenInformation;\n+import org.sagebionetworks.repo.model.oauth.OAuthRefreshTokenInformationList;\n+import org.sagebionetworks.repo.model.oauth.OAuthScope;\n+import org.sagebionetworks.repo.model.oauth.OIDCClaimName;\n+import org.sagebionetworks.repo.model.oauth.OIDCClaimsRequest;\n+import org.sagebionetworks.repo.model.oauth.OIDCClaimsRequestDetails;\n+import org.sagebionetworks.repo.model.oauth.OIDCSigningAlgorithm;\n+import org.sagebionetworks.repo.web.NotFoundException;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.dao.DataAccessException;\n+import org.springframework.test.context.ContextConfiguration;\n+import org.springframework.test.context.junit.jupiter.SpringExtension;\n+import org.springframework.transaction.IllegalTransactionStateException;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+\n+@ExtendWith(SpringExtension.class)\n+@ContextConfiguration(locations = { \"classpath:test-context.xml\" })\n+public class OAuthRefreshTokenManagerAutowiredTest {\n+\tprivate static final String CLIENT_1_NAME = \"some client\";\n+\tprivate static final String CLIENT_1_URI = \"https://client1.uri.com/index.html\";\n+\tprivate static final String CLIENT_2_NAME = \"a different client\";\n+\tprivate static final String CLIENT_2_URI = \"https://client2.uri.com/index.html\";\n+\tprivate static final String POLICY_URI = \"https://client.uri.com/policy.html\";\n+\tprivate static final String TOS_URI = \"https://client.uri.com/termsOfService.html\";\n+\tprivate static final List<String> REDIRCT_URIS = Collections.singletonList(\"https://client.com/redir\");\n+\n+\t@Autowired\n+\tprivate UserManager userManager;\n+\n+\t@Autowired\n+\tOAuthClientManager oauthClientManager;\n+\t\n+\t@Autowired\n+\tOIDCTokenHelper tokenHelper;\n+\n+\t@Autowired\n+\tOAuthRefreshTokenManager refreshTokenManager;\n+\t\n+\tprivate UserInfo adminUserInfo;\n+\tprivate UserInfo user1;\n+\tprivate UserInfo user2;\n+\tprivate OAuthClient client1;\n+\tprivate OAuthClient client2;\n+\n+\tprivate List<OAuthScope> scopes;\n+\tprivate OIDCClaimsRequest claims;\n+\n+\tprivate OAuthClient createOAuthClient(UserInfo owner, String name, String uri) throws Exception {\n+\t\tOAuthClient toCreate = new OAuthClient();\n+\t\ttoCreate.setClient_name(name);\n+\t\ttoCreate.setClient_uri(uri);\n+\t\ttoCreate.setCreatedOn(new Date(System.currentTimeMillis()));\n+\t\ttoCreate.setModifiedOn(new Date(System.currentTimeMillis()));\n+\t\ttoCreate.setPolicy_uri(POLICY_URI);\n+\t\ttoCreate.setRedirect_uris(REDIRCT_URIS);\n+\t\ttoCreate.setTos_uri(TOS_URI);\n+\t\ttoCreate.setUserinfo_signed_response_alg(OIDCSigningAlgorithm.RS256);\n+\n+\t\treturn oauthClientManager.createOpenIDConnectClient(user1, toCreate);\n+\t}\n+\n+\t@BeforeEach\n+\tpublic void beforeEach() throws Exception {\n+\t\t// Scopes and claims just need placeholder values\n+\t\tscopes = Arrays.asList(OAuthScope.openid, OAuthScope.modify);\n+\t\tclaims = new OIDCClaimsRequest();\n+\t\tOIDCClaimsRequestDetails claimDetail = new OIDCClaimsRequestDetails();\n+\t\tclaimDetail.setEssential(true);\n+\t\tclaimDetail.setValue(\"532523\");\n+\t\tclaims.setUserinfo(Collections.singletonMap(OIDCClaimName.team.name(), claimDetail));\n+\t\tclaims.setId_token(Collections.emptyMap());\n+\n+\t\t// Create two users\n+\t\tadminUserInfo = userManager.getUserInfo(BOOTSTRAP_PRINCIPAL.THE_ADMIN_USER.getPrincipalId());\n+\t\tDBOCredential cred = new DBOCredential();\n+\t\tcred.setSecretKey(\"\");\n+\t\tNewUser nu1 = new NewUser();\n+\t\tnu1.setEmail(UUID.randomUUID().toString() + \"@test.com\");\n+\t\tnu1.setUserName(UUID.randomUUID().toString());\n+\n+\t\tDBOTermsOfUseAgreement tou = new DBOTermsOfUseAgreement();\n+\t\ttou.setAgreesToTermsOfUse(Boolean.TRUE);\n+\n+\t\tNewUser nu2 = new NewUser();\n+\t\tnu2.setEmail(UUID.randomUUID().toString() + \"@test.com\");\n+\t\tnu2.setUserName(UUID.randomUUID().toString());\n+\n+\t\tuser1 = userManager.createOrGetTestUser(adminUserInfo, nu1, cred, tou);\n+\t\tuser2 = userManager.createOrGetTestUser(adminUserInfo, nu2, cred, tou);\n+\n+\t\t// Create two clients\n+\t\tclient1 = createOAuthClient(user1, CLIENT_1_NAME, CLIENT_1_URI);\n+\t\tclient2 = createOAuthClient(user1, CLIENT_2_NAME, CLIENT_2_URI);\n+\n+\t}\n+\t\n+\t@AfterEach\n+\tpublic void afterEach() throws Exception {\n+\t\ttry {\n+\t\t\toauthClientManager.deleteOpenIDConnectClient(adminUserInfo, client1.getClient_id());\n+\t\t\toauthClientManager.deleteOpenIDConnectClient(adminUserInfo, client2.getClient_id());\n+\t\t} catch (NotFoundException e) {\n+\t\t\t// stale ID, no deletion necessary\n+\t\t}\n+\t\ttry {\n+\t\t\tuserManager.deletePrincipal(adminUserInfo, user1.getId());\n+\t\t\tuserManager.deletePrincipal(adminUserInfo, user2.getId());\n+\t\t} catch (DataAccessException e) {\n+\t\t}\n+\t}\n+\n+\n+\t@Transactional\n+\t@Test\n+\tpublic void testRefreshTokenRoundTrip() throws Exception {\n+\t\t// Create a refresh token\n+\t\tOAuthRefreshTokenAndMetadata token = refreshTokenManager.createRefreshToken(user1.getId().toString(), client1.getClient_id(), scopes, claims);\n+\t\tassertNotNull(token);\n+\t\tassertTrue(StringUtils.isNotBlank(token.getRefreshToken()));\n+\t\tOAuthRefreshTokenInformation tokenMetadata = token.getMetadata();\n+\t\tassertNotNull(tokenMetadata);\n+\t\tassertEquals(user1.getId().toString(), tokenMetadata.getPrincipalId());\n+\t\tassertEquals(client1.getClient_id(), tokenMetadata.getClientId());\n+\t\tassertNotNull(tokenMetadata.getName());\n+\t\tassertNotNull(tokenMetadata.getEtag());\n+\t\tassertNotNull(tokenMetadata.getModifiedOn());\n+\t\tassertNotNull(tokenMetadata.getLastUsed());\n+\t\tassertNotNull(tokenMetadata.getAuthorizedOn());\n+\t\tassertEquals(scopes, tokenMetadata.getScopes());\n+\t\tassertEquals(claims, tokenMetadata.getClaims());\n+\n+\t\t// Retrieving the token with the token ID as a user\n+\t\tOAuthRefreshTokenInformation retrievedViaId = refreshTokenManager.getRefreshTokenMetadata(user1, token.getMetadata().getTokenId());\n+\t\tassertNotNull(retrievedViaId);\n+\t\tassertEquals(token.getMetadata(), retrievedViaId);\n+\n+\t\t// Retrieving the token with the token ID as a verified client\n+\t\tretrievedViaId = refreshTokenManager.getRefreshTokenMetadata(client1.getClient_id(), token.getMetadata().getTokenId());\n+\t\tassertNotNull(retrievedViaId);\n+\t\tassertEquals(token.getMetadata(), retrievedViaId);\n+\n+\n+\t\t// Retrieve the token with the token, causing a token refresh\n+\t\tOAuthRefreshTokenAndMetadata retrievedViaToken = refreshTokenManager.rotateRefreshToken(token.getRefreshToken());\n+\t\tassertNotNull(retrievedViaToken);\n+\t\tassertTrue(StringUtils.isNotBlank(retrievedViaToken.getRefreshToken()));\n+\t\tassertNotEquals(retrievedViaToken.getRefreshToken(), token.getRefreshToken()); // The token should be different\n+\t\tassertNotNull(retrievedViaToken.getMetadata());\n+\t\t// Last used and Etag will have changed\n+\t\tassertNotEquals(token.getMetadata().getEtag(), retrievedViaToken.getMetadata().getEtag());\n+\t\tassertTrue(retrievedViaToken.getMetadata().getLastUsed().getTime() >= token.getMetadata().getLastUsed().getTime());\n+\t\t// Everything else will be equal\n+\t\ttoken.getMetadata().setEtag(retrievedViaToken.getMetadata().getEtag());\n+\t\ttoken.getMetadata().setLastUsed(retrievedViaToken.getMetadata().getLastUsed());\n+\t\tassertEquals(token.getMetadata(), retrievedViaToken.getMetadata());\n+\n+\t\t// Should get IllegalArgumentException when trying to retrieve via the old hash\n+\t\tassertThrows(IllegalArgumentException.class, () -> refreshTokenManager.rotateRefreshToken(token.getRefreshToken()));\n+\n+\t\t// Other user should get unauthz on attempt to retrieve via ID\n+\t\tassertThrows(UnauthorizedException.class, () -> refreshTokenManager.getRefreshTokenMetadata(user2, token.getMetadata().getTokenId()));\n+\n+\t\t// Other client should get unauthz on attempt to retrieve via ID\n+\t\tassertThrows(UnauthorizedException.class, () -> refreshTokenManager.getRefreshTokenMetadata(client2.getClient_id(), token.getMetadata().getTokenId()));\n+\n+\n+\t\t// Update a refresh token's metadata\n+\t\tOAuthRefreshTokenInformation metadata = retrievedViaToken.getMetadata();\n+\t\tString customName = \"my token name\";\n+\t\tmetadata.setName(customName);\n+\t\tOAuthRefreshTokenInformation updatedMetadata = refreshTokenManager.updateRefreshTokenMetadata(user1, metadata);\n+\t\tassertEquals(customName, updatedMetadata.getName());\n+\t\tassertNotEquals(metadata.getEtag(), updatedMetadata.getEtag());\n+\t\tassertTrue(updatedMetadata.getModifiedOn().getTime() >= metadata.getModifiedOn().getTime());\n+\t\t// Everything else should be equal\n+\t\tmetadata.setName(updatedMetadata.getName());\n+\t\tmetadata.setEtag(updatedMetadata.getEtag());\n+\t\tmetadata.setModifiedOn(updatedMetadata.getModifiedOn());\n+\t\tassertEquals(metadata, updatedMetadata);\n+\n+\t\t// Other user should get unauthz on attempt to update\n+\t\tassertThrows(UnauthorizedException.class, () -> refreshTokenManager.updateRefreshTokenMetadata(user2, updatedMetadata));\n+\n+\t\t// Revoke a refresh token\n+\t\t// Test unauthz first\n+\t\tassertThrows(UnauthorizedException.class, () -> refreshTokenManager.revokeRefreshToken(user2, token.getMetadata().getTokenId()));\n+\t\trefreshTokenManager.revokeRefreshToken(user1, token.getMetadata().getTokenId());\n+\n+\t\t// Should get NFE because token is revoked/deleted.\n+\t\tassertThrows(NotFoundException.class, () -> refreshTokenManager.getRefreshTokenMetadata(user1, token.getMetadata().getTokenId()));\n+\t\t// Should get IllegalArgumentException when trying to retrieve via hash\n+\t\tassertThrows(IllegalArgumentException.class, () -> refreshTokenManager.rotateRefreshToken(retrievedViaToken.getRefreshToken()));\n+\n+\t}\n+\n+\t@Test\n+\tpublic void testAuditAndRevokeTokensForUserClientPair() throws Exception {\n+\t\t// Create two tokens for client 1, one token for client 2\n+\t\tOAuthRefreshTokenAndMetadata client1Token1 = refreshTokenManager.createRefreshToken(user1.getId().toString(), client1.getClient_id(), scopes, claims);\n+\t\tOAuthRefreshTokenAndMetadata client1Token2 = refreshTokenManager.createRefreshToken(user1.getId().toString(), client1.getClient_id(), scopes, claims);\n+\t\tOAuthRefreshTokenAndMetadata client2Token = refreshTokenManager.createRefreshToken(user1.getId().toString(), client2.getClient_id(), scopes, claims);\n+\n+\t\t// Audit clients\n+\t\tOAuthClientAuthorizationHistoryList historyList = refreshTokenManager.getAuthorizedClientHistory(user1, null);\n+\t\tassertEquals(2, historyList.getResults().size());\n+\t\tassertNull(historyList.getNextPageToken());\n+\t\tOAuthClientAuthorizationHistory client1History = null;\n+\t\tOAuthClientAuthorizationHistory client2History = null;\n+\t\tfor (OAuthClientAuthorizationHistory history : historyList.getResults()) {\n+\t\t\tif (history.getClient().getClient_id().equals(client1.getClient_id())) {\n+\t\t\t\tclient1History = history;\n+\t\t\t} else if (history.getClient().getClient_id().equals(client2.getClient_id())) {\n+\t\t\t\tclient2History = history;\n+\t\t\t} else {\n+\t\t\t\tfail(\"Found an unexpected OAuthClientAuthorizationHistory record.\");\n+\t\t\t}\n+\t\t}\n+\t\tassertNotNull(client1History);\n+\t\tassertNull(client1History.getClient().getCreatedBy()); // Public fields should have been removed\n+\t\tassertNotNull(client2History);\n+\t\tassertNull(client1History.getClient().getCreatedBy()); // Public fields should have been removed\n+\n+\t\tOAuthClientAuthorizationHistoryList user2HistoryList = refreshTokenManager.getAuthorizedClientHistory(user2, null);\n+\t\tassertTrue(user2HistoryList.getResults().isEmpty());\n+\t\tassertNull(user2HistoryList.getNextPageToken());\n+\n+\t\t// Audit tokens\n+\t\tOAuthRefreshTokenInformationList client1TokenList = refreshTokenManager.getMetadataForActiveRefreshTokens(user1, client1.getClient_id(), null);", "originalCommit": "84258b0fc2acdf1d0e98b95e6ff7a0aa94ce6ed1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU0NjE2MQ==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4086#discussion_r439546161", "bodyText": "// method under test", "author": "brucehoff", "createdAt": "2020-06-12T17:17:10Z", "path": "services/repository-managers/src/test/java/org/sagebionetworks/repo/manager/oauth/OAuthRefreshTokenManagerAutowiredTest.java", "diffHunk": "@@ -0,0 +1,342 @@\n+package org.sagebionetworks.repo.manager.oauth;\n+\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.UUID;\n+\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.platform.commons.util.StringUtils;\n+import org.sagebionetworks.repo.manager.UserManager;\n+import org.sagebionetworks.repo.model.AuthorizationConstants.BOOTSTRAP_PRINCIPAL;\n+import org.sagebionetworks.repo.model.UnauthorizedException;\n+import org.sagebionetworks.repo.model.UserInfo;\n+import org.sagebionetworks.repo.model.auth.NewUser;\n+import org.sagebionetworks.repo.model.dbo.persistence.DBOCredential;\n+import org.sagebionetworks.repo.model.dbo.persistence.DBOTermsOfUseAgreement;\n+import org.sagebionetworks.repo.model.oauth.OAuthClient;\n+import org.sagebionetworks.repo.model.oauth.OAuthClientAuthorizationHistory;\n+import org.sagebionetworks.repo.model.oauth.OAuthClientAuthorizationHistoryList;\n+import org.sagebionetworks.repo.model.oauth.OAuthRefreshTokenInformation;\n+import org.sagebionetworks.repo.model.oauth.OAuthRefreshTokenInformationList;\n+import org.sagebionetworks.repo.model.oauth.OAuthScope;\n+import org.sagebionetworks.repo.model.oauth.OIDCClaimName;\n+import org.sagebionetworks.repo.model.oauth.OIDCClaimsRequest;\n+import org.sagebionetworks.repo.model.oauth.OIDCClaimsRequestDetails;\n+import org.sagebionetworks.repo.model.oauth.OIDCSigningAlgorithm;\n+import org.sagebionetworks.repo.web.NotFoundException;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.dao.DataAccessException;\n+import org.springframework.test.context.ContextConfiguration;\n+import org.springframework.test.context.junit.jupiter.SpringExtension;\n+import org.springframework.transaction.IllegalTransactionStateException;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+\n+@ExtendWith(SpringExtension.class)\n+@ContextConfiguration(locations = { \"classpath:test-context.xml\" })\n+public class OAuthRefreshTokenManagerAutowiredTest {\n+\tprivate static final String CLIENT_1_NAME = \"some client\";\n+\tprivate static final String CLIENT_1_URI = \"https://client1.uri.com/index.html\";\n+\tprivate static final String CLIENT_2_NAME = \"a different client\";\n+\tprivate static final String CLIENT_2_URI = \"https://client2.uri.com/index.html\";\n+\tprivate static final String POLICY_URI = \"https://client.uri.com/policy.html\";\n+\tprivate static final String TOS_URI = \"https://client.uri.com/termsOfService.html\";\n+\tprivate static final List<String> REDIRCT_URIS = Collections.singletonList(\"https://client.com/redir\");\n+\n+\t@Autowired\n+\tprivate UserManager userManager;\n+\n+\t@Autowired\n+\tOAuthClientManager oauthClientManager;\n+\t\n+\t@Autowired\n+\tOIDCTokenHelper tokenHelper;\n+\n+\t@Autowired\n+\tOAuthRefreshTokenManager refreshTokenManager;\n+\t\n+\tprivate UserInfo adminUserInfo;\n+\tprivate UserInfo user1;\n+\tprivate UserInfo user2;\n+\tprivate OAuthClient client1;\n+\tprivate OAuthClient client2;\n+\n+\tprivate List<OAuthScope> scopes;\n+\tprivate OIDCClaimsRequest claims;\n+\n+\tprivate OAuthClient createOAuthClient(UserInfo owner, String name, String uri) throws Exception {\n+\t\tOAuthClient toCreate = new OAuthClient();\n+\t\ttoCreate.setClient_name(name);\n+\t\ttoCreate.setClient_uri(uri);\n+\t\ttoCreate.setCreatedOn(new Date(System.currentTimeMillis()));\n+\t\ttoCreate.setModifiedOn(new Date(System.currentTimeMillis()));\n+\t\ttoCreate.setPolicy_uri(POLICY_URI);\n+\t\ttoCreate.setRedirect_uris(REDIRCT_URIS);\n+\t\ttoCreate.setTos_uri(TOS_URI);\n+\t\ttoCreate.setUserinfo_signed_response_alg(OIDCSigningAlgorithm.RS256);\n+\n+\t\treturn oauthClientManager.createOpenIDConnectClient(user1, toCreate);\n+\t}\n+\n+\t@BeforeEach\n+\tpublic void beforeEach() throws Exception {\n+\t\t// Scopes and claims just need placeholder values\n+\t\tscopes = Arrays.asList(OAuthScope.openid, OAuthScope.modify);\n+\t\tclaims = new OIDCClaimsRequest();\n+\t\tOIDCClaimsRequestDetails claimDetail = new OIDCClaimsRequestDetails();\n+\t\tclaimDetail.setEssential(true);\n+\t\tclaimDetail.setValue(\"532523\");\n+\t\tclaims.setUserinfo(Collections.singletonMap(OIDCClaimName.team.name(), claimDetail));\n+\t\tclaims.setId_token(Collections.emptyMap());\n+\n+\t\t// Create two users\n+\t\tadminUserInfo = userManager.getUserInfo(BOOTSTRAP_PRINCIPAL.THE_ADMIN_USER.getPrincipalId());\n+\t\tDBOCredential cred = new DBOCredential();\n+\t\tcred.setSecretKey(\"\");\n+\t\tNewUser nu1 = new NewUser();\n+\t\tnu1.setEmail(UUID.randomUUID().toString() + \"@test.com\");\n+\t\tnu1.setUserName(UUID.randomUUID().toString());\n+\n+\t\tDBOTermsOfUseAgreement tou = new DBOTermsOfUseAgreement();\n+\t\ttou.setAgreesToTermsOfUse(Boolean.TRUE);\n+\n+\t\tNewUser nu2 = new NewUser();\n+\t\tnu2.setEmail(UUID.randomUUID().toString() + \"@test.com\");\n+\t\tnu2.setUserName(UUID.randomUUID().toString());\n+\n+\t\tuser1 = userManager.createOrGetTestUser(adminUserInfo, nu1, cred, tou);\n+\t\tuser2 = userManager.createOrGetTestUser(adminUserInfo, nu2, cred, tou);\n+\n+\t\t// Create two clients\n+\t\tclient1 = createOAuthClient(user1, CLIENT_1_NAME, CLIENT_1_URI);\n+\t\tclient2 = createOAuthClient(user1, CLIENT_2_NAME, CLIENT_2_URI);\n+\n+\t}\n+\t\n+\t@AfterEach\n+\tpublic void afterEach() throws Exception {\n+\t\ttry {\n+\t\t\toauthClientManager.deleteOpenIDConnectClient(adminUserInfo, client1.getClient_id());\n+\t\t\toauthClientManager.deleteOpenIDConnectClient(adminUserInfo, client2.getClient_id());\n+\t\t} catch (NotFoundException e) {\n+\t\t\t// stale ID, no deletion necessary\n+\t\t}\n+\t\ttry {\n+\t\t\tuserManager.deletePrincipal(adminUserInfo, user1.getId());\n+\t\t\tuserManager.deletePrincipal(adminUserInfo, user2.getId());\n+\t\t} catch (DataAccessException e) {\n+\t\t}\n+\t}\n+\n+\n+\t@Transactional\n+\t@Test\n+\tpublic void testRefreshTokenRoundTrip() throws Exception {\n+\t\t// Create a refresh token\n+\t\tOAuthRefreshTokenAndMetadata token = refreshTokenManager.createRefreshToken(user1.getId().toString(), client1.getClient_id(), scopes, claims);\n+\t\tassertNotNull(token);\n+\t\tassertTrue(StringUtils.isNotBlank(token.getRefreshToken()));\n+\t\tOAuthRefreshTokenInformation tokenMetadata = token.getMetadata();\n+\t\tassertNotNull(tokenMetadata);\n+\t\tassertEquals(user1.getId().toString(), tokenMetadata.getPrincipalId());\n+\t\tassertEquals(client1.getClient_id(), tokenMetadata.getClientId());\n+\t\tassertNotNull(tokenMetadata.getName());\n+\t\tassertNotNull(tokenMetadata.getEtag());\n+\t\tassertNotNull(tokenMetadata.getModifiedOn());\n+\t\tassertNotNull(tokenMetadata.getLastUsed());\n+\t\tassertNotNull(tokenMetadata.getAuthorizedOn());\n+\t\tassertEquals(scopes, tokenMetadata.getScopes());\n+\t\tassertEquals(claims, tokenMetadata.getClaims());\n+\n+\t\t// Retrieving the token with the token ID as a user\n+\t\tOAuthRefreshTokenInformation retrievedViaId = refreshTokenManager.getRefreshTokenMetadata(user1, token.getMetadata().getTokenId());\n+\t\tassertNotNull(retrievedViaId);\n+\t\tassertEquals(token.getMetadata(), retrievedViaId);\n+\n+\t\t// Retrieving the token with the token ID as a verified client\n+\t\tretrievedViaId = refreshTokenManager.getRefreshTokenMetadata(client1.getClient_id(), token.getMetadata().getTokenId());\n+\t\tassertNotNull(retrievedViaId);\n+\t\tassertEquals(token.getMetadata(), retrievedViaId);\n+\n+\n+\t\t// Retrieve the token with the token, causing a token refresh\n+\t\tOAuthRefreshTokenAndMetadata retrievedViaToken = refreshTokenManager.rotateRefreshToken(token.getRefreshToken());\n+\t\tassertNotNull(retrievedViaToken);\n+\t\tassertTrue(StringUtils.isNotBlank(retrievedViaToken.getRefreshToken()));\n+\t\tassertNotEquals(retrievedViaToken.getRefreshToken(), token.getRefreshToken()); // The token should be different\n+\t\tassertNotNull(retrievedViaToken.getMetadata());\n+\t\t// Last used and Etag will have changed\n+\t\tassertNotEquals(token.getMetadata().getEtag(), retrievedViaToken.getMetadata().getEtag());\n+\t\tassertTrue(retrievedViaToken.getMetadata().getLastUsed().getTime() >= token.getMetadata().getLastUsed().getTime());\n+\t\t// Everything else will be equal\n+\t\ttoken.getMetadata().setEtag(retrievedViaToken.getMetadata().getEtag());\n+\t\ttoken.getMetadata().setLastUsed(retrievedViaToken.getMetadata().getLastUsed());\n+\t\tassertEquals(token.getMetadata(), retrievedViaToken.getMetadata());\n+\n+\t\t// Should get IllegalArgumentException when trying to retrieve via the old hash\n+\t\tassertThrows(IllegalArgumentException.class, () -> refreshTokenManager.rotateRefreshToken(token.getRefreshToken()));\n+\n+\t\t// Other user should get unauthz on attempt to retrieve via ID\n+\t\tassertThrows(UnauthorizedException.class, () -> refreshTokenManager.getRefreshTokenMetadata(user2, token.getMetadata().getTokenId()));\n+\n+\t\t// Other client should get unauthz on attempt to retrieve via ID\n+\t\tassertThrows(UnauthorizedException.class, () -> refreshTokenManager.getRefreshTokenMetadata(client2.getClient_id(), token.getMetadata().getTokenId()));\n+\n+\n+\t\t// Update a refresh token's metadata\n+\t\tOAuthRefreshTokenInformation metadata = retrievedViaToken.getMetadata();\n+\t\tString customName = \"my token name\";\n+\t\tmetadata.setName(customName);\n+\t\tOAuthRefreshTokenInformation updatedMetadata = refreshTokenManager.updateRefreshTokenMetadata(user1, metadata);\n+\t\tassertEquals(customName, updatedMetadata.getName());\n+\t\tassertNotEquals(metadata.getEtag(), updatedMetadata.getEtag());\n+\t\tassertTrue(updatedMetadata.getModifiedOn().getTime() >= metadata.getModifiedOn().getTime());\n+\t\t// Everything else should be equal\n+\t\tmetadata.setName(updatedMetadata.getName());\n+\t\tmetadata.setEtag(updatedMetadata.getEtag());\n+\t\tmetadata.setModifiedOn(updatedMetadata.getModifiedOn());\n+\t\tassertEquals(metadata, updatedMetadata);\n+\n+\t\t// Other user should get unauthz on attempt to update\n+\t\tassertThrows(UnauthorizedException.class, () -> refreshTokenManager.updateRefreshTokenMetadata(user2, updatedMetadata));\n+\n+\t\t// Revoke a refresh token\n+\t\t// Test unauthz first\n+\t\tassertThrows(UnauthorizedException.class, () -> refreshTokenManager.revokeRefreshToken(user2, token.getMetadata().getTokenId()));\n+\t\trefreshTokenManager.revokeRefreshToken(user1, token.getMetadata().getTokenId());\n+\n+\t\t// Should get NFE because token is revoked/deleted.\n+\t\tassertThrows(NotFoundException.class, () -> refreshTokenManager.getRefreshTokenMetadata(user1, token.getMetadata().getTokenId()));\n+\t\t// Should get IllegalArgumentException when trying to retrieve via hash\n+\t\tassertThrows(IllegalArgumentException.class, () -> refreshTokenManager.rotateRefreshToken(retrievedViaToken.getRefreshToken()));\n+\n+\t}\n+\n+\t@Test\n+\tpublic void testAuditAndRevokeTokensForUserClientPair() throws Exception {\n+\t\t// Create two tokens for client 1, one token for client 2\n+\t\tOAuthRefreshTokenAndMetadata client1Token1 = refreshTokenManager.createRefreshToken(user1.getId().toString(), client1.getClient_id(), scopes, claims);\n+\t\tOAuthRefreshTokenAndMetadata client1Token2 = refreshTokenManager.createRefreshToken(user1.getId().toString(), client1.getClient_id(), scopes, claims);\n+\t\tOAuthRefreshTokenAndMetadata client2Token = refreshTokenManager.createRefreshToken(user1.getId().toString(), client2.getClient_id(), scopes, claims);\n+\n+\t\t// Audit clients\n+\t\tOAuthClientAuthorizationHistoryList historyList = refreshTokenManager.getAuthorizedClientHistory(user1, null);\n+\t\tassertEquals(2, historyList.getResults().size());\n+\t\tassertNull(historyList.getNextPageToken());\n+\t\tOAuthClientAuthorizationHistory client1History = null;\n+\t\tOAuthClientAuthorizationHistory client2History = null;\n+\t\tfor (OAuthClientAuthorizationHistory history : historyList.getResults()) {\n+\t\t\tif (history.getClient().getClient_id().equals(client1.getClient_id())) {\n+\t\t\t\tclient1History = history;\n+\t\t\t} else if (history.getClient().getClient_id().equals(client2.getClient_id())) {\n+\t\t\t\tclient2History = history;\n+\t\t\t} else {\n+\t\t\t\tfail(\"Found an unexpected OAuthClientAuthorizationHistory record.\");\n+\t\t\t}\n+\t\t}\n+\t\tassertNotNull(client1History);\n+\t\tassertNull(client1History.getClient().getCreatedBy()); // Public fields should have been removed\n+\t\tassertNotNull(client2History);\n+\t\tassertNull(client1History.getClient().getCreatedBy()); // Public fields should have been removed\n+\n+\t\tOAuthClientAuthorizationHistoryList user2HistoryList = refreshTokenManager.getAuthorizedClientHistory(user2, null);\n+\t\tassertTrue(user2HistoryList.getResults().isEmpty());\n+\t\tassertNull(user2HistoryList.getNextPageToken());\n+\n+\t\t// Audit tokens\n+\t\tOAuthRefreshTokenInformationList client1TokenList = refreshTokenManager.getMetadataForActiveRefreshTokens(user1, client1.getClient_id(), null);\n+\t\tassertEquals(2, client1TokenList.getResults().size());\n+\t\tassertNull(client1TokenList.getNextPageToken());\n+\t\tOAuthRefreshTokenInformation token1FromList = null;\n+\t\tOAuthRefreshTokenInformation token2FromList = null;\n+\t\tfor (OAuthRefreshTokenInformation tokenInformation : client1TokenList.getResults()) {\n+\t\t\tif (tokenInformation.getTokenId().equals(client1Token1.getMetadata().getTokenId())) {\n+\t\t\t\ttoken1FromList = tokenInformation;\n+\t\t\t} else if (tokenInformation.getTokenId().equals(client1Token2.getMetadata().getTokenId())) {\n+\t\t\t\ttoken2FromList = tokenInformation;\n+\t\t\t} else {\n+\t\t\t\tfail(\"Found an unexpected OAuthClientAuthorizationHistory record.\");\n+\t\t\t}\n+\t\t}\n+\t\tassertNotNull(token1FromList);\n+\t\tassertNotNull(token2FromList);\n+\n+\t\tOAuthRefreshTokenInformationList client2TokenList = refreshTokenManager.getMetadataForActiveRefreshTokens(user1, client2.getClient_id(), null);\n+\t\tassertEquals(1, client2TokenList.getResults().size());\n+\t\tassertNull(client2TokenList.getNextPageToken());\n+\t\tassertEquals(client2Token.getMetadata().getTokenId(), client2TokenList.getResults().get(0).getTokenId());\n+\n+\t\tOAuthRefreshTokenInformationList user2TokenList = refreshTokenManager.getMetadataForActiveRefreshTokens(user2, client1.getClient_id(), null);\n+\t\tassertTrue(user2TokenList.getResults().isEmpty());\n+\t\tassertNull(client2TokenList.getNextPageToken());\n+\n+\t\t// Revoke tokens\n+\t\t// Create a token between client 1 and user 2 (to ensure it isn't accidentally revoked when user 1 revokes client 1's tokens)\n+\t\tOAuthRefreshTokenAndMetadata user2Token = refreshTokenManager.createRefreshToken(user2.getId().toString(), client1.getClient_id(), scopes, claims);\n+\n+\t\trefreshTokenManager.revokeRefreshTokensForUserClientPair(user1, client1.getClient_id());", "originalCommit": "84258b0fc2acdf1d0e98b95e6ff7a0aa94ce6ed1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU0Njk5OQ==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4086#discussion_r439546999", "bodyText": "client2History = historyList.getResults().get(0);", "author": "brucehoff", "createdAt": "2020-06-12T17:18:57Z", "path": "services/repository-managers/src/test/java/org/sagebionetworks/repo/manager/oauth/OAuthRefreshTokenManagerAutowiredTest.java", "diffHunk": "@@ -0,0 +1,342 @@\n+package org.sagebionetworks.repo.manager.oauth;\n+\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.UUID;\n+\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.platform.commons.util.StringUtils;\n+import org.sagebionetworks.repo.manager.UserManager;\n+import org.sagebionetworks.repo.model.AuthorizationConstants.BOOTSTRAP_PRINCIPAL;\n+import org.sagebionetworks.repo.model.UnauthorizedException;\n+import org.sagebionetworks.repo.model.UserInfo;\n+import org.sagebionetworks.repo.model.auth.NewUser;\n+import org.sagebionetworks.repo.model.dbo.persistence.DBOCredential;\n+import org.sagebionetworks.repo.model.dbo.persistence.DBOTermsOfUseAgreement;\n+import org.sagebionetworks.repo.model.oauth.OAuthClient;\n+import org.sagebionetworks.repo.model.oauth.OAuthClientAuthorizationHistory;\n+import org.sagebionetworks.repo.model.oauth.OAuthClientAuthorizationHistoryList;\n+import org.sagebionetworks.repo.model.oauth.OAuthRefreshTokenInformation;\n+import org.sagebionetworks.repo.model.oauth.OAuthRefreshTokenInformationList;\n+import org.sagebionetworks.repo.model.oauth.OAuthScope;\n+import org.sagebionetworks.repo.model.oauth.OIDCClaimName;\n+import org.sagebionetworks.repo.model.oauth.OIDCClaimsRequest;\n+import org.sagebionetworks.repo.model.oauth.OIDCClaimsRequestDetails;\n+import org.sagebionetworks.repo.model.oauth.OIDCSigningAlgorithm;\n+import org.sagebionetworks.repo.web.NotFoundException;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.dao.DataAccessException;\n+import org.springframework.test.context.ContextConfiguration;\n+import org.springframework.test.context.junit.jupiter.SpringExtension;\n+import org.springframework.transaction.IllegalTransactionStateException;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+\n+@ExtendWith(SpringExtension.class)\n+@ContextConfiguration(locations = { \"classpath:test-context.xml\" })\n+public class OAuthRefreshTokenManagerAutowiredTest {\n+\tprivate static final String CLIENT_1_NAME = \"some client\";\n+\tprivate static final String CLIENT_1_URI = \"https://client1.uri.com/index.html\";\n+\tprivate static final String CLIENT_2_NAME = \"a different client\";\n+\tprivate static final String CLIENT_2_URI = \"https://client2.uri.com/index.html\";\n+\tprivate static final String POLICY_URI = \"https://client.uri.com/policy.html\";\n+\tprivate static final String TOS_URI = \"https://client.uri.com/termsOfService.html\";\n+\tprivate static final List<String> REDIRCT_URIS = Collections.singletonList(\"https://client.com/redir\");\n+\n+\t@Autowired\n+\tprivate UserManager userManager;\n+\n+\t@Autowired\n+\tOAuthClientManager oauthClientManager;\n+\t\n+\t@Autowired\n+\tOIDCTokenHelper tokenHelper;\n+\n+\t@Autowired\n+\tOAuthRefreshTokenManager refreshTokenManager;\n+\t\n+\tprivate UserInfo adminUserInfo;\n+\tprivate UserInfo user1;\n+\tprivate UserInfo user2;\n+\tprivate OAuthClient client1;\n+\tprivate OAuthClient client2;\n+\n+\tprivate List<OAuthScope> scopes;\n+\tprivate OIDCClaimsRequest claims;\n+\n+\tprivate OAuthClient createOAuthClient(UserInfo owner, String name, String uri) throws Exception {\n+\t\tOAuthClient toCreate = new OAuthClient();\n+\t\ttoCreate.setClient_name(name);\n+\t\ttoCreate.setClient_uri(uri);\n+\t\ttoCreate.setCreatedOn(new Date(System.currentTimeMillis()));\n+\t\ttoCreate.setModifiedOn(new Date(System.currentTimeMillis()));\n+\t\ttoCreate.setPolicy_uri(POLICY_URI);\n+\t\ttoCreate.setRedirect_uris(REDIRCT_URIS);\n+\t\ttoCreate.setTos_uri(TOS_URI);\n+\t\ttoCreate.setUserinfo_signed_response_alg(OIDCSigningAlgorithm.RS256);\n+\n+\t\treturn oauthClientManager.createOpenIDConnectClient(user1, toCreate);\n+\t}\n+\n+\t@BeforeEach\n+\tpublic void beforeEach() throws Exception {\n+\t\t// Scopes and claims just need placeholder values\n+\t\tscopes = Arrays.asList(OAuthScope.openid, OAuthScope.modify);\n+\t\tclaims = new OIDCClaimsRequest();\n+\t\tOIDCClaimsRequestDetails claimDetail = new OIDCClaimsRequestDetails();\n+\t\tclaimDetail.setEssential(true);\n+\t\tclaimDetail.setValue(\"532523\");\n+\t\tclaims.setUserinfo(Collections.singletonMap(OIDCClaimName.team.name(), claimDetail));\n+\t\tclaims.setId_token(Collections.emptyMap());\n+\n+\t\t// Create two users\n+\t\tadminUserInfo = userManager.getUserInfo(BOOTSTRAP_PRINCIPAL.THE_ADMIN_USER.getPrincipalId());\n+\t\tDBOCredential cred = new DBOCredential();\n+\t\tcred.setSecretKey(\"\");\n+\t\tNewUser nu1 = new NewUser();\n+\t\tnu1.setEmail(UUID.randomUUID().toString() + \"@test.com\");\n+\t\tnu1.setUserName(UUID.randomUUID().toString());\n+\n+\t\tDBOTermsOfUseAgreement tou = new DBOTermsOfUseAgreement();\n+\t\ttou.setAgreesToTermsOfUse(Boolean.TRUE);\n+\n+\t\tNewUser nu2 = new NewUser();\n+\t\tnu2.setEmail(UUID.randomUUID().toString() + \"@test.com\");\n+\t\tnu2.setUserName(UUID.randomUUID().toString());\n+\n+\t\tuser1 = userManager.createOrGetTestUser(adminUserInfo, nu1, cred, tou);\n+\t\tuser2 = userManager.createOrGetTestUser(adminUserInfo, nu2, cred, tou);\n+\n+\t\t// Create two clients\n+\t\tclient1 = createOAuthClient(user1, CLIENT_1_NAME, CLIENT_1_URI);\n+\t\tclient2 = createOAuthClient(user1, CLIENT_2_NAME, CLIENT_2_URI);\n+\n+\t}\n+\t\n+\t@AfterEach\n+\tpublic void afterEach() throws Exception {\n+\t\ttry {\n+\t\t\toauthClientManager.deleteOpenIDConnectClient(adminUserInfo, client1.getClient_id());\n+\t\t\toauthClientManager.deleteOpenIDConnectClient(adminUserInfo, client2.getClient_id());\n+\t\t} catch (NotFoundException e) {\n+\t\t\t// stale ID, no deletion necessary\n+\t\t}\n+\t\ttry {\n+\t\t\tuserManager.deletePrincipal(adminUserInfo, user1.getId());\n+\t\t\tuserManager.deletePrincipal(adminUserInfo, user2.getId());\n+\t\t} catch (DataAccessException e) {\n+\t\t}\n+\t}\n+\n+\n+\t@Transactional\n+\t@Test\n+\tpublic void testRefreshTokenRoundTrip() throws Exception {\n+\t\t// Create a refresh token\n+\t\tOAuthRefreshTokenAndMetadata token = refreshTokenManager.createRefreshToken(user1.getId().toString(), client1.getClient_id(), scopes, claims);\n+\t\tassertNotNull(token);\n+\t\tassertTrue(StringUtils.isNotBlank(token.getRefreshToken()));\n+\t\tOAuthRefreshTokenInformation tokenMetadata = token.getMetadata();\n+\t\tassertNotNull(tokenMetadata);\n+\t\tassertEquals(user1.getId().toString(), tokenMetadata.getPrincipalId());\n+\t\tassertEquals(client1.getClient_id(), tokenMetadata.getClientId());\n+\t\tassertNotNull(tokenMetadata.getName());\n+\t\tassertNotNull(tokenMetadata.getEtag());\n+\t\tassertNotNull(tokenMetadata.getModifiedOn());\n+\t\tassertNotNull(tokenMetadata.getLastUsed());\n+\t\tassertNotNull(tokenMetadata.getAuthorizedOn());\n+\t\tassertEquals(scopes, tokenMetadata.getScopes());\n+\t\tassertEquals(claims, tokenMetadata.getClaims());\n+\n+\t\t// Retrieving the token with the token ID as a user\n+\t\tOAuthRefreshTokenInformation retrievedViaId = refreshTokenManager.getRefreshTokenMetadata(user1, token.getMetadata().getTokenId());\n+\t\tassertNotNull(retrievedViaId);\n+\t\tassertEquals(token.getMetadata(), retrievedViaId);\n+\n+\t\t// Retrieving the token with the token ID as a verified client\n+\t\tretrievedViaId = refreshTokenManager.getRefreshTokenMetadata(client1.getClient_id(), token.getMetadata().getTokenId());\n+\t\tassertNotNull(retrievedViaId);\n+\t\tassertEquals(token.getMetadata(), retrievedViaId);\n+\n+\n+\t\t// Retrieve the token with the token, causing a token refresh\n+\t\tOAuthRefreshTokenAndMetadata retrievedViaToken = refreshTokenManager.rotateRefreshToken(token.getRefreshToken());\n+\t\tassertNotNull(retrievedViaToken);\n+\t\tassertTrue(StringUtils.isNotBlank(retrievedViaToken.getRefreshToken()));\n+\t\tassertNotEquals(retrievedViaToken.getRefreshToken(), token.getRefreshToken()); // The token should be different\n+\t\tassertNotNull(retrievedViaToken.getMetadata());\n+\t\t// Last used and Etag will have changed\n+\t\tassertNotEquals(token.getMetadata().getEtag(), retrievedViaToken.getMetadata().getEtag());\n+\t\tassertTrue(retrievedViaToken.getMetadata().getLastUsed().getTime() >= token.getMetadata().getLastUsed().getTime());\n+\t\t// Everything else will be equal\n+\t\ttoken.getMetadata().setEtag(retrievedViaToken.getMetadata().getEtag());\n+\t\ttoken.getMetadata().setLastUsed(retrievedViaToken.getMetadata().getLastUsed());\n+\t\tassertEquals(token.getMetadata(), retrievedViaToken.getMetadata());\n+\n+\t\t// Should get IllegalArgumentException when trying to retrieve via the old hash\n+\t\tassertThrows(IllegalArgumentException.class, () -> refreshTokenManager.rotateRefreshToken(token.getRefreshToken()));\n+\n+\t\t// Other user should get unauthz on attempt to retrieve via ID\n+\t\tassertThrows(UnauthorizedException.class, () -> refreshTokenManager.getRefreshTokenMetadata(user2, token.getMetadata().getTokenId()));\n+\n+\t\t// Other client should get unauthz on attempt to retrieve via ID\n+\t\tassertThrows(UnauthorizedException.class, () -> refreshTokenManager.getRefreshTokenMetadata(client2.getClient_id(), token.getMetadata().getTokenId()));\n+\n+\n+\t\t// Update a refresh token's metadata\n+\t\tOAuthRefreshTokenInformation metadata = retrievedViaToken.getMetadata();\n+\t\tString customName = \"my token name\";\n+\t\tmetadata.setName(customName);\n+\t\tOAuthRefreshTokenInformation updatedMetadata = refreshTokenManager.updateRefreshTokenMetadata(user1, metadata);\n+\t\tassertEquals(customName, updatedMetadata.getName());\n+\t\tassertNotEquals(metadata.getEtag(), updatedMetadata.getEtag());\n+\t\tassertTrue(updatedMetadata.getModifiedOn().getTime() >= metadata.getModifiedOn().getTime());\n+\t\t// Everything else should be equal\n+\t\tmetadata.setName(updatedMetadata.getName());\n+\t\tmetadata.setEtag(updatedMetadata.getEtag());\n+\t\tmetadata.setModifiedOn(updatedMetadata.getModifiedOn());\n+\t\tassertEquals(metadata, updatedMetadata);\n+\n+\t\t// Other user should get unauthz on attempt to update\n+\t\tassertThrows(UnauthorizedException.class, () -> refreshTokenManager.updateRefreshTokenMetadata(user2, updatedMetadata));\n+\n+\t\t// Revoke a refresh token\n+\t\t// Test unauthz first\n+\t\tassertThrows(UnauthorizedException.class, () -> refreshTokenManager.revokeRefreshToken(user2, token.getMetadata().getTokenId()));\n+\t\trefreshTokenManager.revokeRefreshToken(user1, token.getMetadata().getTokenId());\n+\n+\t\t// Should get NFE because token is revoked/deleted.\n+\t\tassertThrows(NotFoundException.class, () -> refreshTokenManager.getRefreshTokenMetadata(user1, token.getMetadata().getTokenId()));\n+\t\t// Should get IllegalArgumentException when trying to retrieve via hash\n+\t\tassertThrows(IllegalArgumentException.class, () -> refreshTokenManager.rotateRefreshToken(retrievedViaToken.getRefreshToken()));\n+\n+\t}\n+\n+\t@Test\n+\tpublic void testAuditAndRevokeTokensForUserClientPair() throws Exception {\n+\t\t// Create two tokens for client 1, one token for client 2\n+\t\tOAuthRefreshTokenAndMetadata client1Token1 = refreshTokenManager.createRefreshToken(user1.getId().toString(), client1.getClient_id(), scopes, claims);\n+\t\tOAuthRefreshTokenAndMetadata client1Token2 = refreshTokenManager.createRefreshToken(user1.getId().toString(), client1.getClient_id(), scopes, claims);\n+\t\tOAuthRefreshTokenAndMetadata client2Token = refreshTokenManager.createRefreshToken(user1.getId().toString(), client2.getClient_id(), scopes, claims);\n+\n+\t\t// Audit clients\n+\t\tOAuthClientAuthorizationHistoryList historyList = refreshTokenManager.getAuthorizedClientHistory(user1, null);\n+\t\tassertEquals(2, historyList.getResults().size());\n+\t\tassertNull(historyList.getNextPageToken());\n+\t\tOAuthClientAuthorizationHistory client1History = null;\n+\t\tOAuthClientAuthorizationHistory client2History = null;\n+\t\tfor (OAuthClientAuthorizationHistory history : historyList.getResults()) {\n+\t\t\tif (history.getClient().getClient_id().equals(client1.getClient_id())) {\n+\t\t\t\tclient1History = history;\n+\t\t\t} else if (history.getClient().getClient_id().equals(client2.getClient_id())) {\n+\t\t\t\tclient2History = history;\n+\t\t\t} else {\n+\t\t\t\tfail(\"Found an unexpected OAuthClientAuthorizationHistory record.\");\n+\t\t\t}\n+\t\t}\n+\t\tassertNotNull(client1History);\n+\t\tassertNull(client1History.getClient().getCreatedBy()); // Public fields should have been removed\n+\t\tassertNotNull(client2History);\n+\t\tassertNull(client1History.getClient().getCreatedBy()); // Public fields should have been removed\n+\n+\t\tOAuthClientAuthorizationHistoryList user2HistoryList = refreshTokenManager.getAuthorizedClientHistory(user2, null);\n+\t\tassertTrue(user2HistoryList.getResults().isEmpty());\n+\t\tassertNull(user2HistoryList.getNextPageToken());\n+\n+\t\t// Audit tokens\n+\t\tOAuthRefreshTokenInformationList client1TokenList = refreshTokenManager.getMetadataForActiveRefreshTokens(user1, client1.getClient_id(), null);\n+\t\tassertEquals(2, client1TokenList.getResults().size());\n+\t\tassertNull(client1TokenList.getNextPageToken());\n+\t\tOAuthRefreshTokenInformation token1FromList = null;\n+\t\tOAuthRefreshTokenInformation token2FromList = null;\n+\t\tfor (OAuthRefreshTokenInformation tokenInformation : client1TokenList.getResults()) {\n+\t\t\tif (tokenInformation.getTokenId().equals(client1Token1.getMetadata().getTokenId())) {\n+\t\t\t\ttoken1FromList = tokenInformation;\n+\t\t\t} else if (tokenInformation.getTokenId().equals(client1Token2.getMetadata().getTokenId())) {\n+\t\t\t\ttoken2FromList = tokenInformation;\n+\t\t\t} else {\n+\t\t\t\tfail(\"Found an unexpected OAuthClientAuthorizationHistory record.\");\n+\t\t\t}\n+\t\t}\n+\t\tassertNotNull(token1FromList);\n+\t\tassertNotNull(token2FromList);\n+\n+\t\tOAuthRefreshTokenInformationList client2TokenList = refreshTokenManager.getMetadataForActiveRefreshTokens(user1, client2.getClient_id(), null);\n+\t\tassertEquals(1, client2TokenList.getResults().size());\n+\t\tassertNull(client2TokenList.getNextPageToken());\n+\t\tassertEquals(client2Token.getMetadata().getTokenId(), client2TokenList.getResults().get(0).getTokenId());\n+\n+\t\tOAuthRefreshTokenInformationList user2TokenList = refreshTokenManager.getMetadataForActiveRefreshTokens(user2, client1.getClient_id(), null);\n+\t\tassertTrue(user2TokenList.getResults().isEmpty());\n+\t\tassertNull(client2TokenList.getNextPageToken());\n+\n+\t\t// Revoke tokens\n+\t\t// Create a token between client 1 and user 2 (to ensure it isn't accidentally revoked when user 1 revokes client 1's tokens)\n+\t\tOAuthRefreshTokenAndMetadata user2Token = refreshTokenManager.createRefreshToken(user2.getId().toString(), client1.getClient_id(), scopes, claims);\n+\n+\t\trefreshTokenManager.revokeRefreshTokensForUserClientPair(user1, client1.getClient_id());\n+\n+\t\t// Verify tokens are gone\n+\t\tclient1TokenList = refreshTokenManager.getMetadataForActiveRefreshTokens(user1, client1.getClient_id(), null);\n+\t\tassertTrue(client1TokenList.getResults().isEmpty());\n+\n+\t\t// Verify that tokens between other clients or users are not gone\n+\t\tclient2TokenList = refreshTokenManager.getMetadataForActiveRefreshTokens(user1, client2.getClient_id(), null);\n+\t\tassertFalse(client2TokenList.getResults().isEmpty());\n+\n+\t\tuser2TokenList = refreshTokenManager.getMetadataForActiveRefreshTokens(user2, client1.getClient_id(), null);\n+\t\tassertFalse(user2TokenList.getResults().isEmpty());\n+\n+\t\t// Audit clients -- client 1 should be gone from user 1's list\n+\t\thistoryList = refreshTokenManager.getAuthorizedClientHistory(user1, null);\n+\t\tassertEquals(1, historyList.getResults().size());\n+\t\tassertNull(historyList.getNextPageToken());\n+\t\tclient1History = null;\n+\t\tclient2History = null;\n+\t\tfor (OAuthClientAuthorizationHistory history : historyList.getResults()) {\n+\t\t\tif (history.getClient().getClient_id().equals(client1.getClient_id())) {", "originalCommit": "84258b0fc2acdf1d0e98b95e6ff7a0aa94ce6ed1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU0ODAxNQ==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4086#discussion_r439548015", "bodyText": "EXPECTED_LEASE_DURATION_DAYS", "author": "brucehoff", "createdAt": "2020-06-12T17:21:08Z", "path": "services/repository-managers/src/test/java/org/sagebionetworks/repo/manager/oauth/OAuthRefreshTokenManagerImplUnitTest.java", "diffHunk": "@@ -0,0 +1,514 @@\n+package org.sagebionetworks.repo.manager.oauth;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.UUID;\n+\n+import org.apache.commons.codec.digest.DigestUtils;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.platform.commons.util.StringUtils;\n+import org.mockito.InjectMocks;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import org.sagebionetworks.repo.model.AuthorizationConstants;\n+import org.sagebionetworks.repo.model.ConflictingUpdateException;\n+import org.sagebionetworks.repo.model.UnauthorizedException;\n+import org.sagebionetworks.repo.model.UserInfo;\n+import org.sagebionetworks.repo.model.auth.OAuthClientDao;\n+import org.sagebionetworks.repo.model.auth.OAuthRefreshTokenDao;\n+import org.sagebionetworks.repo.model.oauth.OAuthClientAuthorizationHistoryList;\n+import org.sagebionetworks.repo.model.oauth.OAuthRefreshTokenInformation;\n+import org.sagebionetworks.repo.model.oauth.OAuthRefreshTokenInformationList;\n+import org.sagebionetworks.repo.model.oauth.OAuthScope;\n+import org.sagebionetworks.repo.model.oauth.OIDCClaimsRequest;\n+import org.sagebionetworks.repo.web.NotFoundException;\n+import org.sagebionetworks.util.Clock;\n+\n+@ExtendWith(MockitoExtension.class)\n+public class OAuthRefreshTokenManagerImplUnitTest {\n+\n+\t@Mock\n+\tOAuthClientDao mockOAuthClientDao;\n+\n+\t@Mock\n+\tOAuthRefreshTokenDao mockOAuthRefreshTokenDao;\n+\n+\t@Mock\n+\tClock clock;\n+\n+\t@InjectMocks\n+\tOAuthRefreshTokenManagerImpl oauthRefreshTokenManager;\n+\n+\tprivate static final Long EXPECTED_LEASE_DURATION = 180L;", "originalCommit": "84258b0fc2acdf1d0e98b95e6ff7a0aa94ce6ed1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU1MzM1Nw==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4086#discussion_r439553357", "bodyText": "To make consistent with other tests:\nArgumentCaptor< OAuthRefreshTokenInformation> captor = ArgumentCaptor.forClass(OAuthRefreshTokenInformation.class);\nwhen(mockOAuthRefreshTokenDao.createRefreshToken(anyString(), captor.capture())).thenReturn(whatever);\n// ... call method under test\nOAuthRefreshTokenInformation captured = captor.Value();\nassertTrue(StringUtils.isNotBlank(captured.getName()));", "author": "brucehoff", "createdAt": "2020-06-12T17:31:46Z", "path": "services/repository-managers/src/test/java/org/sagebionetworks/repo/manager/oauth/OAuthRefreshTokenManagerImplUnitTest.java", "diffHunk": "@@ -0,0 +1,514 @@\n+package org.sagebionetworks.repo.manager.oauth;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.UUID;\n+\n+import org.apache.commons.codec.digest.DigestUtils;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.platform.commons.util.StringUtils;\n+import org.mockito.InjectMocks;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import org.sagebionetworks.repo.model.AuthorizationConstants;\n+import org.sagebionetworks.repo.model.ConflictingUpdateException;\n+import org.sagebionetworks.repo.model.UnauthorizedException;\n+import org.sagebionetworks.repo.model.UserInfo;\n+import org.sagebionetworks.repo.model.auth.OAuthClientDao;\n+import org.sagebionetworks.repo.model.auth.OAuthRefreshTokenDao;\n+import org.sagebionetworks.repo.model.oauth.OAuthClientAuthorizationHistoryList;\n+import org.sagebionetworks.repo.model.oauth.OAuthRefreshTokenInformation;\n+import org.sagebionetworks.repo.model.oauth.OAuthRefreshTokenInformationList;\n+import org.sagebionetworks.repo.model.oauth.OAuthScope;\n+import org.sagebionetworks.repo.model.oauth.OIDCClaimsRequest;\n+import org.sagebionetworks.repo.web.NotFoundException;\n+import org.sagebionetworks.util.Clock;\n+\n+@ExtendWith(MockitoExtension.class)\n+public class OAuthRefreshTokenManagerImplUnitTest {\n+\n+\t@Mock\n+\tOAuthClientDao mockOAuthClientDao;\n+\n+\t@Mock\n+\tOAuthRefreshTokenDao mockOAuthRefreshTokenDao;\n+\n+\t@Mock\n+\tClock clock;\n+\n+\t@InjectMocks\n+\tOAuthRefreshTokenManagerImpl oauthRefreshTokenManager;\n+\n+\tprivate static final Long EXPECTED_LEASE_DURATION = 180L;\n+\tprivate static final Long EXPECTED_MAX_REFRESH_TOKENS = 100L;\n+\n+\t// Some constants to simplify test setup\n+\tprivate static final String TOKEN_ID = \"1234\";\n+\tprivate static final String USER_ID = \"4321\";\n+\tprivate static final String CLIENT_ID = \"67890\";\n+\n+\tprivate static final UserInfo USER_INFO = new UserInfo(false, Long.valueOf(USER_ID));\n+\n+\t@Test\n+\tpublic void testCreateRefreshToken() {\n+\t\tList<OAuthScope> scopes = Arrays.asList(OAuthScope.authorize, OAuthScope.openid);\n+\t\tOIDCClaimsRequest claimsRequest = new OIDCClaimsRequest();\n+\t\tclaimsRequest.setUserinfo(Collections.emptyMap());\n+\t\tclaimsRequest.setId_token(Collections.emptyMap());\n+\n+\t\twhen(clock.now()).thenReturn(new Date()); // Ensure all 'clock.now()' calls return the same time\n+\t\twhen(mockOAuthRefreshTokenDao.createRefreshToken(anyString(), any(OAuthRefreshTokenInformation.class)))", "originalCommit": "84258b0fc2acdf1d0e98b95e6ff7a0aa94ce6ed1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU1NDc4Nw==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4086#discussion_r439554787", "bodyText": "\"testRotateToken()\"", "author": "brucehoff", "createdAt": "2020-06-12T17:34:46Z", "path": "services/repository-managers/src/test/java/org/sagebionetworks/repo/manager/oauth/OAuthRefreshTokenManagerImplUnitTest.java", "diffHunk": "@@ -0,0 +1,514 @@\n+package org.sagebionetworks.repo.manager.oauth;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.UUID;\n+\n+import org.apache.commons.codec.digest.DigestUtils;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.platform.commons.util.StringUtils;\n+import org.mockito.InjectMocks;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import org.sagebionetworks.repo.model.AuthorizationConstants;\n+import org.sagebionetworks.repo.model.ConflictingUpdateException;\n+import org.sagebionetworks.repo.model.UnauthorizedException;\n+import org.sagebionetworks.repo.model.UserInfo;\n+import org.sagebionetworks.repo.model.auth.OAuthClientDao;\n+import org.sagebionetworks.repo.model.auth.OAuthRefreshTokenDao;\n+import org.sagebionetworks.repo.model.oauth.OAuthClientAuthorizationHistoryList;\n+import org.sagebionetworks.repo.model.oauth.OAuthRefreshTokenInformation;\n+import org.sagebionetworks.repo.model.oauth.OAuthRefreshTokenInformationList;\n+import org.sagebionetworks.repo.model.oauth.OAuthScope;\n+import org.sagebionetworks.repo.model.oauth.OIDCClaimsRequest;\n+import org.sagebionetworks.repo.web.NotFoundException;\n+import org.sagebionetworks.util.Clock;\n+\n+@ExtendWith(MockitoExtension.class)\n+public class OAuthRefreshTokenManagerImplUnitTest {\n+\n+\t@Mock\n+\tOAuthClientDao mockOAuthClientDao;\n+\n+\t@Mock\n+\tOAuthRefreshTokenDao mockOAuthRefreshTokenDao;\n+\n+\t@Mock\n+\tClock clock;\n+\n+\t@InjectMocks\n+\tOAuthRefreshTokenManagerImpl oauthRefreshTokenManager;\n+\n+\tprivate static final Long EXPECTED_LEASE_DURATION = 180L;\n+\tprivate static final Long EXPECTED_MAX_REFRESH_TOKENS = 100L;\n+\n+\t// Some constants to simplify test setup\n+\tprivate static final String TOKEN_ID = \"1234\";\n+\tprivate static final String USER_ID = \"4321\";\n+\tprivate static final String CLIENT_ID = \"67890\";\n+\n+\tprivate static final UserInfo USER_INFO = new UserInfo(false, Long.valueOf(USER_ID));\n+\n+\t@Test\n+\tpublic void testCreateRefreshToken() {\n+\t\tList<OAuthScope> scopes = Arrays.asList(OAuthScope.authorize, OAuthScope.openid);\n+\t\tOIDCClaimsRequest claimsRequest = new OIDCClaimsRequest();\n+\t\tclaimsRequest.setUserinfo(Collections.emptyMap());\n+\t\tclaimsRequest.setId_token(Collections.emptyMap());\n+\n+\t\twhen(clock.now()).thenReturn(new Date()); // Ensure all 'clock.now()' calls return the same time\n+\t\twhen(mockOAuthRefreshTokenDao.createRefreshToken(anyString(), any(OAuthRefreshTokenInformation.class)))\n+\t\t\t.thenAnswer(i -> {\n+\t\t\t\tOAuthRefreshTokenInformation tokenInfo = i.getArgument(1, OAuthRefreshTokenInformation.class);\n+\n+\t\t\t\t// Make sure the fields in the object the DAO receives match what should be set\n+\t\t\t\tassertEquals(USER_ID, tokenInfo.getPrincipalId());\n+\t\t\t\tassertEquals(CLIENT_ID, tokenInfo.getClientId());\n+\t\t\t\tassertEquals(scopes, tokenInfo.getScopes());\n+\t\t\t\tassertEquals(claimsRequest, tokenInfo.getClaims());\n+\t\t\t\tassertTrue(StringUtils.isNotBlank(tokenInfo.getName()));\n+\t\t\t\tassertTrue(StringUtils.isNotBlank(tokenInfo.getEtag()));\n+\t\t\t\tassertEquals(clock.now(), tokenInfo.getLastUsed());\n+\t\t\t\tassertEquals(clock.now(), tokenInfo.getAuthorizedOn());\n+\t\t\t\tassertEquals(clock.now(), tokenInfo.getModifiedOn());\n+\n+\t\t\t\ttokenInfo.setTokenId(TOKEN_ID); // The DAO will set an ID\n+\t\t\t\treturn tokenInfo;\n+\t\t\t});\n+\n+\n+\t\t// Call under test\n+\t\tOAuthRefreshTokenAndMetadata actual = oauthRefreshTokenManager.createRefreshToken(USER_ID, CLIENT_ID, scopes, claimsRequest);\n+\t\tassertNotNull(actual);\n+\t\tassertEquals(TOKEN_ID, actual.getMetadata().getTokenId());\n+\t\tassertTrue(StringUtils.isNotBlank(actual.getRefreshToken()));\n+\n+\t\tverify(mockOAuthRefreshTokenDao).deleteLeastRecentlyUsedTokensOverLimit(USER_ID, CLIENT_ID, EXPECTED_MAX_REFRESH_TOKENS - 1);\n+\t\tverify(mockOAuthRefreshTokenDao).createRefreshToken(anyString(), any(OAuthRefreshTokenInformation.class));\n+\t}\n+\n+\t@Test\n+\tpublic void testCreateRefreshToken_anonymousUser() {\n+\t\tString anonymousUser = AuthorizationConstants.BOOTSTRAP_PRINCIPAL.ANONYMOUS_USER.getPrincipalId().toString();\n+\n+\t\tList<OAuthScope> scopes = Arrays.asList(OAuthScope.authorize, OAuthScope.openid);\n+\t\tOIDCClaimsRequest claimsRequest = new OIDCClaimsRequest();\n+\t\tclaimsRequest.setUserinfo(Collections.emptyMap());\n+\t\tclaimsRequest.setId_token(Collections.emptyMap());\n+\n+\t\tassertThrows(UnauthorizedException.class, () -> oauthRefreshTokenManager.createRefreshToken(anonymousUser, CLIENT_ID, scopes, claimsRequest));\n+\t}\n+\n+\t@Test\n+\tpublic void testGetTokenMetadataForUpdateAndRotate() {", "originalCommit": "84258b0fc2acdf1d0e98b95e6ff7a0aa94ce6ed1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU1NTU5Mw==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4086#discussion_r439555593", "bodyText": "use ArgumentCaptor, please.", "author": "brucehoff", "createdAt": "2020-06-12T17:36:24Z", "path": "services/repository-managers/src/test/java/org/sagebionetworks/repo/manager/oauth/OAuthRefreshTokenManagerImplUnitTest.java", "diffHunk": "@@ -0,0 +1,514 @@\n+package org.sagebionetworks.repo.manager.oauth;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.UUID;\n+\n+import org.apache.commons.codec.digest.DigestUtils;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.platform.commons.util.StringUtils;\n+import org.mockito.InjectMocks;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import org.sagebionetworks.repo.model.AuthorizationConstants;\n+import org.sagebionetworks.repo.model.ConflictingUpdateException;\n+import org.sagebionetworks.repo.model.UnauthorizedException;\n+import org.sagebionetworks.repo.model.UserInfo;\n+import org.sagebionetworks.repo.model.auth.OAuthClientDao;\n+import org.sagebionetworks.repo.model.auth.OAuthRefreshTokenDao;\n+import org.sagebionetworks.repo.model.oauth.OAuthClientAuthorizationHistoryList;\n+import org.sagebionetworks.repo.model.oauth.OAuthRefreshTokenInformation;\n+import org.sagebionetworks.repo.model.oauth.OAuthRefreshTokenInformationList;\n+import org.sagebionetworks.repo.model.oauth.OAuthScope;\n+import org.sagebionetworks.repo.model.oauth.OIDCClaimsRequest;\n+import org.sagebionetworks.repo.web.NotFoundException;\n+import org.sagebionetworks.util.Clock;\n+\n+@ExtendWith(MockitoExtension.class)\n+public class OAuthRefreshTokenManagerImplUnitTest {\n+\n+\t@Mock\n+\tOAuthClientDao mockOAuthClientDao;\n+\n+\t@Mock\n+\tOAuthRefreshTokenDao mockOAuthRefreshTokenDao;\n+\n+\t@Mock\n+\tClock clock;\n+\n+\t@InjectMocks\n+\tOAuthRefreshTokenManagerImpl oauthRefreshTokenManager;\n+\n+\tprivate static final Long EXPECTED_LEASE_DURATION = 180L;\n+\tprivate static final Long EXPECTED_MAX_REFRESH_TOKENS = 100L;\n+\n+\t// Some constants to simplify test setup\n+\tprivate static final String TOKEN_ID = \"1234\";\n+\tprivate static final String USER_ID = \"4321\";\n+\tprivate static final String CLIENT_ID = \"67890\";\n+\n+\tprivate static final UserInfo USER_INFO = new UserInfo(false, Long.valueOf(USER_ID));\n+\n+\t@Test\n+\tpublic void testCreateRefreshToken() {\n+\t\tList<OAuthScope> scopes = Arrays.asList(OAuthScope.authorize, OAuthScope.openid);\n+\t\tOIDCClaimsRequest claimsRequest = new OIDCClaimsRequest();\n+\t\tclaimsRequest.setUserinfo(Collections.emptyMap());\n+\t\tclaimsRequest.setId_token(Collections.emptyMap());\n+\n+\t\twhen(clock.now()).thenReturn(new Date()); // Ensure all 'clock.now()' calls return the same time\n+\t\twhen(mockOAuthRefreshTokenDao.createRefreshToken(anyString(), any(OAuthRefreshTokenInformation.class)))\n+\t\t\t.thenAnswer(i -> {\n+\t\t\t\tOAuthRefreshTokenInformation tokenInfo = i.getArgument(1, OAuthRefreshTokenInformation.class);\n+\n+\t\t\t\t// Make sure the fields in the object the DAO receives match what should be set\n+\t\t\t\tassertEquals(USER_ID, tokenInfo.getPrincipalId());\n+\t\t\t\tassertEquals(CLIENT_ID, tokenInfo.getClientId());\n+\t\t\t\tassertEquals(scopes, tokenInfo.getScopes());\n+\t\t\t\tassertEquals(claimsRequest, tokenInfo.getClaims());\n+\t\t\t\tassertTrue(StringUtils.isNotBlank(tokenInfo.getName()));\n+\t\t\t\tassertTrue(StringUtils.isNotBlank(tokenInfo.getEtag()));\n+\t\t\t\tassertEquals(clock.now(), tokenInfo.getLastUsed());\n+\t\t\t\tassertEquals(clock.now(), tokenInfo.getAuthorizedOn());\n+\t\t\t\tassertEquals(clock.now(), tokenInfo.getModifiedOn());\n+\n+\t\t\t\ttokenInfo.setTokenId(TOKEN_ID); // The DAO will set an ID\n+\t\t\t\treturn tokenInfo;\n+\t\t\t});\n+\n+\n+\t\t// Call under test\n+\t\tOAuthRefreshTokenAndMetadata actual = oauthRefreshTokenManager.createRefreshToken(USER_ID, CLIENT_ID, scopes, claimsRequest);\n+\t\tassertNotNull(actual);\n+\t\tassertEquals(TOKEN_ID, actual.getMetadata().getTokenId());\n+\t\tassertTrue(StringUtils.isNotBlank(actual.getRefreshToken()));\n+\n+\t\tverify(mockOAuthRefreshTokenDao).deleteLeastRecentlyUsedTokensOverLimit(USER_ID, CLIENT_ID, EXPECTED_MAX_REFRESH_TOKENS - 1);\n+\t\tverify(mockOAuthRefreshTokenDao).createRefreshToken(anyString(), any(OAuthRefreshTokenInformation.class));\n+\t}\n+\n+\t@Test\n+\tpublic void testCreateRefreshToken_anonymousUser() {\n+\t\tString anonymousUser = AuthorizationConstants.BOOTSTRAP_PRINCIPAL.ANONYMOUS_USER.getPrincipalId().toString();\n+\n+\t\tList<OAuthScope> scopes = Arrays.asList(OAuthScope.authorize, OAuthScope.openid);\n+\t\tOIDCClaimsRequest claimsRequest = new OIDCClaimsRequest();\n+\t\tclaimsRequest.setUserinfo(Collections.emptyMap());\n+\t\tclaimsRequest.setId_token(Collections.emptyMap());\n+\n+\t\tassertThrows(UnauthorizedException.class, () -> oauthRefreshTokenManager.createRefreshToken(anonymousUser, CLIENT_ID, scopes, claimsRequest));\n+\t}\n+\n+\t@Test\n+\tpublic void testGetTokenMetadataForUpdateAndRotate() {\n+\t\tString token = \"token val\";\n+\t\tString oldEtag = \"an etag that should be changed\";\n+\t\twhen(clock.now()).thenReturn(new Date()); // Ensure all 'clock.now()' calls return the same time\n+\t\tDate oldDate = new Date(clock.now().getTime() - 10000); // For old dates, use different time than clock.now() returns\n+\t\tassertNotEquals(oldDate, clock.now()); // sanity check\n+\t\tOAuthRefreshTokenInformation existingToken = new OAuthRefreshTokenInformation();\n+\t\texistingToken.setTokenId(TOKEN_ID);\n+\t\texistingToken.setPrincipalId(USER_ID);\n+\t\texistingToken.setModifiedOn(oldDate); // Should not be updated\n+\t\texistingToken.setLastUsed(oldDate); // Should be updated\n+\t\texistingToken.setEtag(oldEtag);\n+\n+\t\twhen(mockOAuthRefreshTokenDao.getMatchingTokenByHashForUpdate(DigestUtils.sha256Hex(token))).thenReturn(Optional.of(existingToken));", "originalCommit": "84258b0fc2acdf1d0e98b95e6ff7a0aa94ce6ed1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU1ODcxMA==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4086#discussion_r439558710", "bodyText": "argumentcator", "author": "brucehoff", "createdAt": "2020-06-12T17:43:17Z", "path": "services/repository-managers/src/test/java/org/sagebionetworks/repo/manager/oauth/OAuthRefreshTokenManagerImplUnitTest.java", "diffHunk": "@@ -0,0 +1,514 @@\n+package org.sagebionetworks.repo.manager.oauth;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.UUID;\n+\n+import org.apache.commons.codec.digest.DigestUtils;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.platform.commons.util.StringUtils;\n+import org.mockito.InjectMocks;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import org.sagebionetworks.repo.model.AuthorizationConstants;\n+import org.sagebionetworks.repo.model.ConflictingUpdateException;\n+import org.sagebionetworks.repo.model.UnauthorizedException;\n+import org.sagebionetworks.repo.model.UserInfo;\n+import org.sagebionetworks.repo.model.auth.OAuthClientDao;\n+import org.sagebionetworks.repo.model.auth.OAuthRefreshTokenDao;\n+import org.sagebionetworks.repo.model.oauth.OAuthClientAuthorizationHistoryList;\n+import org.sagebionetworks.repo.model.oauth.OAuthRefreshTokenInformation;\n+import org.sagebionetworks.repo.model.oauth.OAuthRefreshTokenInformationList;\n+import org.sagebionetworks.repo.model.oauth.OAuthScope;\n+import org.sagebionetworks.repo.model.oauth.OIDCClaimsRequest;\n+import org.sagebionetworks.repo.web.NotFoundException;\n+import org.sagebionetworks.util.Clock;\n+\n+@ExtendWith(MockitoExtension.class)\n+public class OAuthRefreshTokenManagerImplUnitTest {\n+\n+\t@Mock\n+\tOAuthClientDao mockOAuthClientDao;\n+\n+\t@Mock\n+\tOAuthRefreshTokenDao mockOAuthRefreshTokenDao;\n+\n+\t@Mock\n+\tClock clock;\n+\n+\t@InjectMocks\n+\tOAuthRefreshTokenManagerImpl oauthRefreshTokenManager;\n+\n+\tprivate static final Long EXPECTED_LEASE_DURATION = 180L;\n+\tprivate static final Long EXPECTED_MAX_REFRESH_TOKENS = 100L;\n+\n+\t// Some constants to simplify test setup\n+\tprivate static final String TOKEN_ID = \"1234\";\n+\tprivate static final String USER_ID = \"4321\";\n+\tprivate static final String CLIENT_ID = \"67890\";\n+\n+\tprivate static final UserInfo USER_INFO = new UserInfo(false, Long.valueOf(USER_ID));\n+\n+\t@Test\n+\tpublic void testCreateRefreshToken() {\n+\t\tList<OAuthScope> scopes = Arrays.asList(OAuthScope.authorize, OAuthScope.openid);\n+\t\tOIDCClaimsRequest claimsRequest = new OIDCClaimsRequest();\n+\t\tclaimsRequest.setUserinfo(Collections.emptyMap());\n+\t\tclaimsRequest.setId_token(Collections.emptyMap());\n+\n+\t\twhen(clock.now()).thenReturn(new Date()); // Ensure all 'clock.now()' calls return the same time\n+\t\twhen(mockOAuthRefreshTokenDao.createRefreshToken(anyString(), any(OAuthRefreshTokenInformation.class)))\n+\t\t\t.thenAnswer(i -> {\n+\t\t\t\tOAuthRefreshTokenInformation tokenInfo = i.getArgument(1, OAuthRefreshTokenInformation.class);\n+\n+\t\t\t\t// Make sure the fields in the object the DAO receives match what should be set\n+\t\t\t\tassertEquals(USER_ID, tokenInfo.getPrincipalId());\n+\t\t\t\tassertEquals(CLIENT_ID, tokenInfo.getClientId());\n+\t\t\t\tassertEquals(scopes, tokenInfo.getScopes());\n+\t\t\t\tassertEquals(claimsRequest, tokenInfo.getClaims());\n+\t\t\t\tassertTrue(StringUtils.isNotBlank(tokenInfo.getName()));\n+\t\t\t\tassertTrue(StringUtils.isNotBlank(tokenInfo.getEtag()));\n+\t\t\t\tassertEquals(clock.now(), tokenInfo.getLastUsed());\n+\t\t\t\tassertEquals(clock.now(), tokenInfo.getAuthorizedOn());\n+\t\t\t\tassertEquals(clock.now(), tokenInfo.getModifiedOn());\n+\n+\t\t\t\ttokenInfo.setTokenId(TOKEN_ID); // The DAO will set an ID\n+\t\t\t\treturn tokenInfo;\n+\t\t\t});\n+\n+\n+\t\t// Call under test\n+\t\tOAuthRefreshTokenAndMetadata actual = oauthRefreshTokenManager.createRefreshToken(USER_ID, CLIENT_ID, scopes, claimsRequest);\n+\t\tassertNotNull(actual);\n+\t\tassertEquals(TOKEN_ID, actual.getMetadata().getTokenId());\n+\t\tassertTrue(StringUtils.isNotBlank(actual.getRefreshToken()));\n+\n+\t\tverify(mockOAuthRefreshTokenDao).deleteLeastRecentlyUsedTokensOverLimit(USER_ID, CLIENT_ID, EXPECTED_MAX_REFRESH_TOKENS - 1);\n+\t\tverify(mockOAuthRefreshTokenDao).createRefreshToken(anyString(), any(OAuthRefreshTokenInformation.class));\n+\t}\n+\n+\t@Test\n+\tpublic void testCreateRefreshToken_anonymousUser() {\n+\t\tString anonymousUser = AuthorizationConstants.BOOTSTRAP_PRINCIPAL.ANONYMOUS_USER.getPrincipalId().toString();\n+\n+\t\tList<OAuthScope> scopes = Arrays.asList(OAuthScope.authorize, OAuthScope.openid);\n+\t\tOIDCClaimsRequest claimsRequest = new OIDCClaimsRequest();\n+\t\tclaimsRequest.setUserinfo(Collections.emptyMap());\n+\t\tclaimsRequest.setId_token(Collections.emptyMap());\n+\n+\t\tassertThrows(UnauthorizedException.class, () -> oauthRefreshTokenManager.createRefreshToken(anonymousUser, CLIENT_ID, scopes, claimsRequest));\n+\t}\n+\n+\t@Test\n+\tpublic void testGetTokenMetadataForUpdateAndRotate() {\n+\t\tString token = \"token val\";\n+\t\tString oldEtag = \"an etag that should be changed\";\n+\t\twhen(clock.now()).thenReturn(new Date()); // Ensure all 'clock.now()' calls return the same time\n+\t\tDate oldDate = new Date(clock.now().getTime() - 10000); // For old dates, use different time than clock.now() returns\n+\t\tassertNotEquals(oldDate, clock.now()); // sanity check\n+\t\tOAuthRefreshTokenInformation existingToken = new OAuthRefreshTokenInformation();\n+\t\texistingToken.setTokenId(TOKEN_ID);\n+\t\texistingToken.setPrincipalId(USER_ID);\n+\t\texistingToken.setModifiedOn(oldDate); // Should not be updated\n+\t\texistingToken.setLastUsed(oldDate); // Should be updated\n+\t\texistingToken.setEtag(oldEtag);\n+\n+\t\twhen(mockOAuthRefreshTokenDao.getMatchingTokenByHashForUpdate(DigestUtils.sha256Hex(token))).thenReturn(Optional.of(existingToken));\n+\t\tdoAnswer(invocation -> {\n+\t\t\t// Verify that a hashed token was generated and passed\n+\t\t\tString hashedToken = invocation.getArgument(1, String.class);\n+\t\t\tassertTrue(StringUtils.isNotBlank(hashedToken));\n+\n+\t\t\t// Verify that the token was modified\n+\t\t\tOAuthRefreshTokenInformation tokenInfo = invocation.getArgument(0, OAuthRefreshTokenInformation.class);\n+\t\t\tassertEquals(TOKEN_ID, tokenInfo.getTokenId());\n+\t\t\tassertEquals(USER_ID, tokenInfo.getPrincipalId());\n+\t\t\tassertEquals(clock.now(), tokenInfo.getLastUsed());\n+\t\t\tassertEquals(oldDate, tokenInfo.getModifiedOn());\n+\t\t\tassertNotEquals(oldEtag, tokenInfo.getEtag());\n+\t\t\treturn null;\n+\t\t}).when(mockOAuthRefreshTokenDao).updateTokenHash(any(OAuthRefreshTokenInformation.class), anyString());\n+\n+\t\t// Note that this object won't have the altered metadata, but we check that it has been altered in the above answer\n+\t\twhen(mockOAuthRefreshTokenDao.getRefreshTokenMetadata(TOKEN_ID)).thenReturn(Optional.of(existingToken));\n+\n+\t\t// Call under test\n+\t\tOAuthRefreshTokenAndMetadata actual = oauthRefreshTokenManager.rotateRefreshToken(token);\n+\n+\t\tassertEquals(existingToken, actual.getMetadata());\n+\t\tassertTrue(StringUtils.isNotBlank(actual.getRefreshToken()));\n+\t\tassertNotEquals(token, actual.getRefreshToken());\n+\n+\t\tverify(mockOAuthRefreshTokenDao).getMatchingTokenByHashForUpdate(DigestUtils.sha256Hex(token));\n+\t\tverify(mockOAuthRefreshTokenDao).updateTokenHash(any(OAuthRefreshTokenInformation.class), anyString());\n+\n+\t}\n+\n+\t@Test\n+\tpublic void testGetTokenForUpdateAndRotateRefreshToken_IllegalArgumentOnNonmatchingToken() {\n+\t\twhen(mockOAuthRefreshTokenDao.getMatchingTokenByHashForUpdate(anyString())).thenReturn(Optional.empty());\n+\n+\t\t// Call under test\n+\t\tassertThrows(IllegalArgumentException.class, () -> oauthRefreshTokenManager.rotateRefreshToken(\"token\"));\n+\t}\n+\n+\n+\t@Test\n+\tpublic void testGetTokenForUpdateAndRotateRefreshToken_IllegalStateOnFailedRetrieval() {\n+\t\tOAuthRefreshTokenInformation existingToken = new OAuthRefreshTokenInformation();\n+\t\texistingToken.setTokenId(TOKEN_ID);\n+\t\texistingToken.setPrincipalId(USER_ID);\n+\t\texistingToken.setModifiedOn(new Date());\n+\t\texistingToken.setLastUsed(new Date());\n+\t\texistingToken.setEtag(UUID.randomUUID().toString());\n+\n+\t\twhen(mockOAuthRefreshTokenDao.getMatchingTokenByHashForUpdate(anyString())).thenReturn(Optional.of(existingToken));\n+\t\twhen(mockOAuthRefreshTokenDao.getRefreshTokenMetadata(TOKEN_ID)).thenReturn(Optional.empty());\n+\t\t// Call under test\n+\t\tassertThrows(IllegalStateException.class, () -> oauthRefreshTokenManager.rotateRefreshToken(\"token\"));\n+\t}\n+\n+\t@Test\n+\tpublic void testGetTokenMetadataWithUserInfo() {\n+\t\tOAuthRefreshTokenInformation expected = new OAuthRefreshTokenInformation();\n+\t\texpected.setTokenId(TOKEN_ID);\n+\t\texpected.setPrincipalId(USER_ID);\n+\n+\t\twhen(mockOAuthRefreshTokenDao.getRefreshTokenMetadata(TOKEN_ID)).thenReturn(Optional.of(expected));\n+\n+\t\t// Call under test\n+\t\tOAuthRefreshTokenInformation actual = oauthRefreshTokenManager.getRefreshTokenMetadata(USER_INFO, TOKEN_ID);\n+\n+\t\tassertEquals(expected, actual);\n+\t\tverify(mockOAuthRefreshTokenDao).getRefreshTokenMetadata(TOKEN_ID);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetTokenMetadataWithUserInfo_NotFound() {\n+\t\twhen(mockOAuthRefreshTokenDao.getRefreshTokenMetadata(TOKEN_ID)).thenReturn(Optional.empty());\n+\n+\t\t// Call under test\n+\t\tassertThrows(NotFoundException.class, () -> oauthRefreshTokenManager.getRefreshTokenMetadata(USER_INFO, TOKEN_ID));\n+\n+\t\tverify(mockOAuthRefreshTokenDao).getRefreshTokenMetadata(TOKEN_ID);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetTokenMetadataWithUserInfo_Unauthorized() {\n+\t\tOAuthRefreshTokenInformation expected = new OAuthRefreshTokenInformation();\n+\t\texpected.setTokenId(TOKEN_ID);\n+\t\texpected.setPrincipalId(\"some other user ID\");\n+\n+\t\twhen(mockOAuthRefreshTokenDao.getRefreshTokenMetadata(TOKEN_ID)).thenReturn(Optional.of(expected));\n+\n+\t\t// Call under test\n+\t\tassertThrows(UnauthorizedException.class, () -> oauthRefreshTokenManager.getRefreshTokenMetadata(USER_INFO, TOKEN_ID));\n+\n+\t\tverify(mockOAuthRefreshTokenDao).getRefreshTokenMetadata(TOKEN_ID);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetTokenMetadataWithClientId() {\n+\t\tOAuthRefreshTokenInformation expected = new OAuthRefreshTokenInformation();\n+\t\texpected.setTokenId(TOKEN_ID);\n+\t\texpected.setClientId(CLIENT_ID);\n+\n+\t\twhen(mockOAuthRefreshTokenDao.getRefreshTokenMetadata(TOKEN_ID)).thenReturn(Optional.of(expected));\n+\n+\t\t// Call under test\n+\t\tOAuthRefreshTokenInformation actual = oauthRefreshTokenManager.getRefreshTokenMetadata(CLIENT_ID, TOKEN_ID);\n+\n+\t\tassertEquals(expected, actual);\n+\t\tverify(mockOAuthRefreshTokenDao).getRefreshTokenMetadata(TOKEN_ID);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetTokenMetadataWithClientId_NotFound() {\n+\t\twhen(mockOAuthRefreshTokenDao.getRefreshTokenMetadata(TOKEN_ID)).thenReturn(Optional.empty());\n+\n+\t\t// Call under test\n+\t\tassertThrows(NotFoundException.class, () -> oauthRefreshTokenManager.getRefreshTokenMetadata(CLIENT_ID, TOKEN_ID));\n+\n+\t\tverify(mockOAuthRefreshTokenDao).getRefreshTokenMetadata(TOKEN_ID);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetTokenMetadataWithClientId_Unauthorized() {\n+\t\tOAuthRefreshTokenInformation expected = new OAuthRefreshTokenInformation();\n+\t\texpected.setTokenId(TOKEN_ID);\n+\t\texpected.setClientId(\"some other client ID\");\n+\n+\t\twhen(mockOAuthRefreshTokenDao.getRefreshTokenMetadata(TOKEN_ID)).thenReturn(Optional.of(expected));\n+\n+\t\t// Call under test\n+\t\tassertThrows(UnauthorizedException.class, () -> oauthRefreshTokenManager.getRefreshTokenMetadata(CLIENT_ID, TOKEN_ID));\n+\n+\t\tverify(mockOAuthRefreshTokenDao).getRefreshTokenMetadata(TOKEN_ID);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetClientHistory() {\n+\t\tString nextPageToken = \"initial npt\";\n+\n+\t\tOAuthClientAuthorizationHistoryList expected = new OAuthClientAuthorizationHistoryList();\n+\t\texpected.setResults(Collections.emptyList());\n+\t\texpected.setNextPageToken(\"some new nextpagetoken\");\n+\n+\t\twhen(mockOAuthClientDao.getAuthorizedClientHistory(USER_ID, nextPageToken, EXPECTED_LEASE_DURATION)).thenReturn(expected);\n+\n+\t\t// Call under test\n+\t\tOAuthClientAuthorizationHistoryList actual = oauthRefreshTokenManager.getAuthorizedClientHistory(USER_INFO, nextPageToken);\n+\n+\t\tassertEquals(expected, actual);\n+\t\tverify(mockOAuthClientDao).getAuthorizedClientHistory(USER_ID, nextPageToken, EXPECTED_LEASE_DURATION);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetActiveRefreshTokensMetadata() {\n+\t\tString nextPageToken = \"initial npt\";\n+\n+\t\tOAuthRefreshTokenInformationList expected = new OAuthRefreshTokenInformationList();\n+\t\texpected.setResults(Collections.emptyList());\n+\t\texpected.setNextPageToken(\"some new nextpagetoken\");\n+\n+\t\twhen(mockOAuthRefreshTokenDao.getActiveTokenInformation(USER_ID, CLIENT_ID, nextPageToken, EXPECTED_LEASE_DURATION)).thenReturn(expected);\n+\n+\t\t// Call under test\n+\t\tOAuthRefreshTokenInformationList actual = oauthRefreshTokenManager.getMetadataForActiveRefreshTokens(USER_INFO, CLIENT_ID, nextPageToken);\n+\n+\t\tassertEquals(expected, actual);\n+\t\tverify(mockOAuthRefreshTokenDao).getActiveTokenInformation(USER_ID, CLIENT_ID, nextPageToken, EXPECTED_LEASE_DURATION);\n+\t}\n+\n+\t@Test\n+\tpublic void testRevokeTokensForUserClientPair() {\n+\t\tOAuthRefreshTokenInformationList existingTokens = new OAuthRefreshTokenInformationList();\n+\t\texistingTokens.setResults(Collections.singletonList(new OAuthRefreshTokenInformation())); // need a list of length >= 1\n+\n+\t\t// Call under test\n+\t\toauthRefreshTokenManager.revokeRefreshTokensForUserClientPair(USER_INFO, CLIENT_ID);\n+\n+\t\tverify(mockOAuthRefreshTokenDao).deleteAllTokensForUserClientPair(USER_ID, CLIENT_ID);\n+\t}\n+\n+\t@Test\n+\tpublic void testRevokeTokenAsUser() {\n+\t\tOAuthRefreshTokenInformation existingToken = new OAuthRefreshTokenInformation();\n+\t\texistingToken.setTokenId(TOKEN_ID);\n+\t\texistingToken.setPrincipalId(USER_ID);\n+\n+\t\twhen(mockOAuthRefreshTokenDao.getRefreshTokenMetadata(TOKEN_ID)).thenReturn(Optional.of(existingToken));\n+\n+\t\t// Call under test\n+\t\toauthRefreshTokenManager.revokeRefreshToken(USER_INFO, TOKEN_ID);\n+\n+\t\tverify(mockOAuthRefreshTokenDao).getRefreshTokenMetadata(TOKEN_ID);\n+\t\tverify(mockOAuthRefreshTokenDao).deleteToken(TOKEN_ID);\n+\t}\n+\n+\t@Test\n+\tpublic void testRevokeTokenAsUser_NotFound() {\n+\t\twhen(mockOAuthRefreshTokenDao.getRefreshTokenMetadata(TOKEN_ID)).thenReturn(Optional.empty());\n+\n+\t\t// Call under test\n+\t\tassertThrows(NotFoundException.class, () -> oauthRefreshTokenManager.revokeRefreshToken(USER_INFO, TOKEN_ID));\n+\n+\t\tverify(mockOAuthRefreshTokenDao).getRefreshTokenMetadata(TOKEN_ID);\n+\t\tverify(mockOAuthRefreshTokenDao, never()).deleteToken(TOKEN_ID);\n+\t}\n+\n+\t@Test\n+\tpublic void testRevokeTokenAsUser_Unauthorized() {\n+\t\tOAuthRefreshTokenInformation existingToken = new OAuthRefreshTokenInformation();\n+\t\texistingToken.setTokenId(TOKEN_ID);\n+\t\texistingToken.setPrincipalId(\"some other user ID\");\n+\n+\t\twhen(mockOAuthRefreshTokenDao.getRefreshTokenMetadata(TOKEN_ID)).thenReturn(Optional.of(existingToken));\n+\n+\t\t// Call under test\n+\t\tassertThrows(UnauthorizedException.class, () -> oauthRefreshTokenManager.revokeRefreshToken(USER_INFO, TOKEN_ID));\n+\n+\t\tverify(mockOAuthRefreshTokenDao).getRefreshTokenMetadata(TOKEN_ID);\n+\t\tverify(mockOAuthRefreshTokenDao, never()).deleteToken(TOKEN_ID);\n+\t}\n+\n+\t@Test\n+\tpublic void testUpdateToken() {\n+\t\twhen(clock.now()).thenReturn(new Date());\n+\n+\t\tString oldName = \"old name\";\n+\t\tString newName = \"new name\";\n+\t\tString oldEtag = \"abcd\";\n+\n+\t\tOAuthRefreshTokenInformation newMetadata = new OAuthRefreshTokenInformation();\n+\t\tnewMetadata.setTokenId(TOKEN_ID);\n+\t\tnewMetadata.setPrincipalId(USER_ID);\n+\t\tnewMetadata.setName(newName);\n+\t\tnewMetadata.setEtag(oldEtag);\n+\t\tnewMetadata.setModifiedOn(new Date(clock.now().getTime() - 100000));\n+\n+\t\tOAuthRefreshTokenInformation retrievedFromDao = new OAuthRefreshTokenInformation();\n+\t\tretrievedFromDao.setTokenId(TOKEN_ID);\n+\t\tretrievedFromDao.setPrincipalId(USER_ID);\n+\t\tretrievedFromDao.setName(oldName);\n+\t\tretrievedFromDao.setEtag(oldEtag);\n+\t\tnewMetadata.setModifiedOn(new Date(clock.now().getTime() - 100000));\n+\n+\n+\t\twhen(mockOAuthRefreshTokenDao.getRefreshTokenMetadata(TOKEN_ID)).thenReturn(Optional.of(retrievedFromDao));\n+\n+\t\tdoAnswer(invocation -> {\n+\t\t\t// Verify that the fields were updated by the manager when passed to DAO", "originalCommit": "84258b0fc2acdf1d0e98b95e6ff7a0aa94ce6ed1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}