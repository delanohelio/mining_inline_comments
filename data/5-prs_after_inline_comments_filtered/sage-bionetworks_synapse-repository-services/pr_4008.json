{"pr_number": 4008, "pr_title": "controllers and workers, need a few more worker tests", "pr_createdAt": "2020-04-18T01:43:15Z", "pr_url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4008", "timeline": [{"oid": "e5934972f6edcc480bf826f1c81a55fdb3576b09", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/e5934972f6edcc480bf826f1c81a55fdb3576b09", "message": "controllers and workers, need a few more worker tests", "committedDate": "2020-04-18T01:41:31Z", "type": "commit"}, {"oid": "41e686d59f9262fcda6a2194f508c5abb0b0b450", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/41e686d59f9262fcda6a2194f508c5abb0b0b450", "message": "Merge branch 'develop' into PLFM-6161-bit.", "committedDate": "2020-04-18T01:44:09Z", "type": "commit"}, {"oid": "322b80d3dcf2c553f1f6663b6ceea8eb989178a8", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/322b80d3dcf2c553f1f6663b6ceea8eb989178a8", "message": "fixed broken URL", "committedDate": "2020-04-20T22:34:59Z", "type": "commit"}, {"oid": "153de9a86574f31917d34765f880ff9c2c2828c2", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/153de9a86574f31917d34765f880ff9c2c2828c2", "message": "getting schemas with names and version", "committedDate": "2020-04-21T21:17:23Z", "type": "commit"}, {"oid": "7d992f17e242abbe8673ea7d2fadd94e1be39c22", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/7d992f17e242abbe8673ea7d2fadd94e1be39c22", "message": "crud round trip with tests", "committedDate": "2020-04-22T02:53:09Z", "type": "commit"}, {"oid": "e5b135f67c919427f91194db53c5d1bb0d40f7fc", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/e5b135f67c919427f91194db53c5d1bb0d40f7fc", "message": "added latest version table and reworked dao", "committedDate": "2020-04-25T03:09:02Z", "type": "commit"}, {"oid": "8b3def4f0183192701bc64444afd1ea1ab0305eb", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/8b3def4f0183192701bc64444afd1ea1ab0305eb", "message": "cache latest version, support for deleting versions, and pushed dao logic to the dao", "committedDate": "2020-04-27T22:40:52Z", "type": "commit"}, {"oid": "875432e5923f6c1a33c2b115f9dea34d2b3515aa", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/875432e5923f6c1a33c2b115f9dea34d2b3515aa", "message": "merge develop and add scopes to json schema controller", "committedDate": "2020-04-27T22:48:57Z", "type": "commit"}, {"oid": "b7ab950d66569dedcb77d15bfc43d23b610e95fe", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/b7ab950d66569dedcb77d15bfc43d23b610e95fe", "message": "missing etag flag", "committedDate": "2020-04-27T23:12:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjgyOTE1MQ==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4008#discussion_r416829151", "bodyText": "Pull this out in a variable to construct the request object", "author": "marcomarasca", "createdAt": "2020-04-28T18:23:57Z", "path": "services/repository-managers/src/main/java/org/sagebionetworks/repo/manager/schema/JsonSchemaManagerImpl.java", "diffHunk": "@@ -176,65 +169,77 @@ public CreateSchemaResponse createJsonSchema(UserInfo user, CreateSchemaRequest\n \n \t\tSchemaId schemaId = SchemaIdParser.parseSchemaId(request.getSchema().get$id());\n \n-\t\tString semanticVersionString = getAndValidateSemanticVersion(schemaId.getSemanticVersion());\n+\t\tString semanticVersionString = null;\n+\t\tif(schemaId.getSemanticVersion() != null) {\n+\t\t\tsemanticVersionString = schemaId.getSemanticVersion().toString();\n+\t\t}\n+\t\tString schemaNameString = schemaId.getSchemaName().toString();\n \n-\t\t// Does the user have update on the organization\n+\t\t// User must have create on the organization.\n \t\tOrganization organization = organizationDao.getOrganizationByName(schemaId.getOrganizationName().toString());\n-\t\taclDao.canAccess(user, organization.getId(), ObjectType.ORGANIZATION, ACCESS_TYPE.UPDATE)\n+\t\taclDao.canAccess(user, organization.getId(), ObjectType.ORGANIZATION, ACCESS_TYPE.CREATE)\n \t\t\t\t.checkAuthorizationOrElseThrow();\n-\n-\t\t// Create or get the root schema\n-\t\tSchemaInfo schemaRoot = jsonSchemaDao\n-\t\t\t\t.createSchemaIfDoesNotExist(new NewSchemaRequest().withOrganizationId(organization.getId())\n-\t\t\t\t\t\t.withSchemaName(schemaId.getSchemaName().toString()).withCreatedBy(user.getId()));\n-\t\t// Create or get the JSON blob\n-\t\tString jsonBlobId = createJsonBlobIfDoesNotExist(request.getSchema());\n-\n-\t\t// Unconditionally create a new version.\n-\t\tJsonSchemaVersionInfo versionInfo = jsonSchemaDao\n-\t\t\t\t.createNewVersion(new NewVersionRequest().withSchemaId(schemaRoot.getNumericId())\n-\t\t\t\t\t\t.withSemanticVersion(semanticVersionString).withCreatedBy(user.getId()).withBlobId(jsonBlobId));\n+\t\t\n+\t\tJsonSchemaVersionInfo info = jsonSchemaDao.createNewSchemaVersion(\n+\t\t\t\tnew NewSchemaVersionRequest().withOrganizationId(organization.getId()).withCreatedBy(user.getId())", "originalCommit": "b7ab950d66569dedcb77d15bfc43d23b610e95fe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjgzMTc5Nw==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4008#discussion_r416831797", "bodyText": "You could use StringUtils.trimToNull for semanticVersion", "author": "marcomarasca", "createdAt": "2020-04-28T18:28:01Z", "path": "services/repository-managers/src/main/java/org/sagebionetworks/repo/manager/schema/JsonSchemaManagerImpl.java", "diffHunk": "@@ -176,65 +169,77 @@ public CreateSchemaResponse createJsonSchema(UserInfo user, CreateSchemaRequest\n \n \t\tSchemaId schemaId = SchemaIdParser.parseSchemaId(request.getSchema().get$id());\n \n-\t\tString semanticVersionString = getAndValidateSemanticVersion(schemaId.getSemanticVersion());\n+\t\tString semanticVersionString = null;\n+\t\tif(schemaId.getSemanticVersion() != null) {\n+\t\t\tsemanticVersionString = schemaId.getSemanticVersion().toString();\n+\t\t}\n+\t\tString schemaNameString = schemaId.getSchemaName().toString();\n \n-\t\t// Does the user have update on the organization\n+\t\t// User must have create on the organization.\n \t\tOrganization organization = organizationDao.getOrganizationByName(schemaId.getOrganizationName().toString());\n-\t\taclDao.canAccess(user, organization.getId(), ObjectType.ORGANIZATION, ACCESS_TYPE.UPDATE)\n+\t\taclDao.canAccess(user, organization.getId(), ObjectType.ORGANIZATION, ACCESS_TYPE.CREATE)\n \t\t\t\t.checkAuthorizationOrElseThrow();\n-\n-\t\t// Create or get the root schema\n-\t\tSchemaInfo schemaRoot = jsonSchemaDao\n-\t\t\t\t.createSchemaIfDoesNotExist(new NewSchemaRequest().withOrganizationId(organization.getId())\n-\t\t\t\t\t\t.withSchemaName(schemaId.getSchemaName().toString()).withCreatedBy(user.getId()));\n-\t\t// Create or get the JSON blob\n-\t\tString jsonBlobId = createJsonBlobIfDoesNotExist(request.getSchema());\n-\n-\t\t// Unconditionally create a new version.\n-\t\tJsonSchemaVersionInfo versionInfo = jsonSchemaDao\n-\t\t\t\t.createNewVersion(new NewVersionRequest().withSchemaId(schemaRoot.getNumericId())\n-\t\t\t\t\t\t.withSemanticVersion(semanticVersionString).withCreatedBy(user.getId()).withBlobId(jsonBlobId));\n+\t\t\n+\t\tJsonSchemaVersionInfo info = jsonSchemaDao.createNewSchemaVersion(\n+\t\t\t\tnew NewSchemaVersionRequest().withOrganizationId(organization.getId()).withCreatedBy(user.getId())\n+\t\t\t\t\t\t.withSchemaName(schemaNameString).withSemanticVersion(semanticVersionString).withJsonSchema(request.getSchema()));\n \n \t\tCreateSchemaResponse response = new CreateSchemaResponse();\n-\t\tresponse.setNewVersionInfo(versionInfo);\n+\t\tresponse.setNewVersionInfo(info);\n \t\treturn response;\n \t}\n \n-\t/**\n-\t * Create a new JSON blob if the one does not already exist for the given\n-\t * schema.\n-\t * \n-\t * @param schema\n-\t * @return\n-\t */\n-\tString createJsonBlobIfDoesNotExist(JsonSchema schema) {\n-\t\tValidateArgument.required(schema, \"schema\");\n-\t\tString schemaJson = null;\n-\t\ttry {\n-\t\t\tschemaJson = EntityFactory.createJSONStringForEntity(schema);\n-\t\t} catch (JSONObjectAdapterException e) {\n-\t\t\tthrow new IllegalArgumentException(e);\n+\t@Override\n+\tpublic JsonSchema getSchema(String organizationName, String schemaName, String semanticVersion) {\n+\t\tValidateArgument.required(organizationName, \"organizationName\");\n+\t\tValidateArgument.required(schemaName, \"schemaName\");\n+\t\torganizationName = organizationName.trim();\n+\t\tschemaName = schemaName.trim();\n+\t\tString versionId = null;\n+\t\tif(semanticVersion == null || semanticVersion.trim().isEmpty()) {", "originalCommit": "b7ab950d66569dedcb77d15bfc43d23b610e95fe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjgzMzkwOA==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4008#discussion_r416833908", "bodyText": "Might not need the spy anymore", "author": "marcomarasca", "createdAt": "2020-04-28T18:31:23Z", "path": "services/repository-managers/src/test/java/org/sagebionetworks/repo/manager/schema/JsonSchemaManagerImplTest.java", "diffHunk": "@@ -534,133 +529,294 @@ public void testGetOrganizationByNameTrim() {\n \t}\n \n \t@Test\n-\tpublic void testCreateJsonBlobIfDoesNotExist() {\n-\t\twhen(mockSchemaDao.createJsonBlobIfDoesNotExist(any(), any())).thenReturn(jsonBlobId);\n+\tpublic void testCreateJsonSchema() {\n+\t\twhen(mockOrganizationDao.getOrganizationByName(any())).thenReturn(organization);\n+\t\twhen(mockAclDao.canAccess(any(UserInfo.class), any(), any(), any()))\n+\t\t\t\t.thenReturn(AuthorizationStatus.authorized());\n+\t\twhen(mockSchemaDao.createNewSchemaVersion(any())).thenReturn(versionInfo);\n \t\t// call under test\n-\t\tString blobId = manager.createJsonBlobIfDoesNotExist(schema);\n-\t\tassertEquals(jsonBlobId, blobId);\n-\t\tverify(mockSchemaDao).createJsonBlobIfDoesNotExist(schemaJson, schemaJsonSHA256Hex);\n+\t\tCreateSchemaResponse response = managerSpy.createJsonSchema(user, createSchemaRequest);", "originalCommit": "b7ab950d66569dedcb77d15bfc43d23b610e95fe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjgzNDE3Nw==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4008#discussion_r416834177", "bodyText": "duplicate", "author": "marcomarasca", "createdAt": "2020-04-28T18:31:50Z", "path": "services/repository-managers/src/test/java/org/sagebionetworks/repo/manager/schema/JsonSchemaManagerImplTest.java", "diffHunk": "@@ -534,133 +529,294 @@ public void testGetOrganizationByNameTrim() {\n \t}\n \n \t@Test\n-\tpublic void testCreateJsonBlobIfDoesNotExist() {\n-\t\twhen(mockSchemaDao.createJsonBlobIfDoesNotExist(any(), any())).thenReturn(jsonBlobId);\n+\tpublic void testCreateJsonSchema() {\n+\t\twhen(mockOrganizationDao.getOrganizationByName(any())).thenReturn(organization);\n+\t\twhen(mockAclDao.canAccess(any(UserInfo.class), any(), any(), any()))\n+\t\t\t\t.thenReturn(AuthorizationStatus.authorized());\n+\t\twhen(mockSchemaDao.createNewSchemaVersion(any())).thenReturn(versionInfo);\n \t\t// call under test\n-\t\tString blobId = manager.createJsonBlobIfDoesNotExist(schema);\n-\t\tassertEquals(jsonBlobId, blobId);\n-\t\tverify(mockSchemaDao).createJsonBlobIfDoesNotExist(schemaJson, schemaJsonSHA256Hex);\n+\t\tCreateSchemaResponse response = managerSpy.createJsonSchema(user, createSchemaRequest);\n+\t\tassertNotNull(response);\n+\t\tassertEquals(versionInfo, response.getNewVersionInfo());\n+\t\tassertEquals(versionInfo, response.getNewVersionInfo());\n+\t\tverify(mockOrganizationDao).getOrganizationByName(organizationName);\n+\t\tverify(mockAclDao).canAccess(user, organization.getId(), ObjectType.ORGANIZATION, ACCESS_TYPE.CREATE);\n+\t\tNewSchemaVersionRequest expectedNewSchemaRequest = new NewSchemaVersionRequest()\n+\t\t\t\t.withOrganizationId(organization.getId()).withSchemaName(schemaName).withCreatedBy(user.getId())\n+\t\t\t\t.withJsonSchema(schema).withSemanticVersion(semanticVersionString);\n+\t\tverify(mockSchemaDao).createNewSchemaVersion(expectedNewSchemaRequest);\n \t}\n \n \t@Test\n-\tpublic void testCreateJsonBlobIfDoesNotExistNullSchema() {\n-\t\tschema = null;\n+\tpublic void testCreateJsonSchemaNullVersion() {\n+\t\twhen(mockOrganizationDao.getOrganizationByName(any())).thenReturn(organization);\n+\t\twhen(mockAclDao.canAccess(any(UserInfo.class), any(), any(), any()))\n+\t\t\t\t.thenReturn(AuthorizationStatus.authorized());\n+\t\twhen(mockSchemaDao.createNewSchemaVersion(any())).thenReturn(versionInfo);\n+\t\tschema.set$id(organizationName + \"/\" + schemaName);\n \t\t// call under test\n+\t\tCreateSchemaResponse response = managerSpy.createJsonSchema(user, createSchemaRequest);\n+\t\tassertNotNull(response);\n+\t\tassertEquals(versionInfo, response.getNewVersionInfo());\n+\t\tassertEquals(versionInfo, response.getNewVersionInfo());", "originalCommit": "b7ab950d66569dedcb77d15bfc43d23b610e95fe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjgzNzUxNQ==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4008#discussion_r416837515", "bodyText": "we can use a common patter using \"with\" after the method name, e.g. testDeleteSchemaVersionWithNullSemanticVersion", "author": "marcomarasca", "createdAt": "2020-04-28T18:37:16Z", "path": "services/repository-managers/src/test/java/org/sagebionetworks/repo/manager/schema/JsonSchemaManagerImplTest.java", "diffHunk": "@@ -534,133 +529,294 @@ public void testGetOrganizationByNameTrim() {\n \t}\n \n \t@Test\n-\tpublic void testCreateJsonBlobIfDoesNotExist() {\n-\t\twhen(mockSchemaDao.createJsonBlobIfDoesNotExist(any(), any())).thenReturn(jsonBlobId);\n+\tpublic void testCreateJsonSchema() {\n+\t\twhen(mockOrganizationDao.getOrganizationByName(any())).thenReturn(organization);\n+\t\twhen(mockAclDao.canAccess(any(UserInfo.class), any(), any(), any()))\n+\t\t\t\t.thenReturn(AuthorizationStatus.authorized());\n+\t\twhen(mockSchemaDao.createNewSchemaVersion(any())).thenReturn(versionInfo);\n \t\t// call under test\n-\t\tString blobId = manager.createJsonBlobIfDoesNotExist(schema);\n-\t\tassertEquals(jsonBlobId, blobId);\n-\t\tverify(mockSchemaDao).createJsonBlobIfDoesNotExist(schemaJson, schemaJsonSHA256Hex);\n+\t\tCreateSchemaResponse response = managerSpy.createJsonSchema(user, createSchemaRequest);\n+\t\tassertNotNull(response);\n+\t\tassertEquals(versionInfo, response.getNewVersionInfo());\n+\t\tassertEquals(versionInfo, response.getNewVersionInfo());\n+\t\tverify(mockOrganizationDao).getOrganizationByName(organizationName);\n+\t\tverify(mockAclDao).canAccess(user, organization.getId(), ObjectType.ORGANIZATION, ACCESS_TYPE.CREATE);\n+\t\tNewSchemaVersionRequest expectedNewSchemaRequest = new NewSchemaVersionRequest()\n+\t\t\t\t.withOrganizationId(organization.getId()).withSchemaName(schemaName).withCreatedBy(user.getId())\n+\t\t\t\t.withJsonSchema(schema).withSemanticVersion(semanticVersionString);\n+\t\tverify(mockSchemaDao).createNewSchemaVersion(expectedNewSchemaRequest);\n \t}\n \n \t@Test\n-\tpublic void testCreateJsonBlobIfDoesNotExistNullSchema() {\n-\t\tschema = null;\n+\tpublic void testCreateJsonSchemaNullVersion() {\n+\t\twhen(mockOrganizationDao.getOrganizationByName(any())).thenReturn(organization);\n+\t\twhen(mockAclDao.canAccess(any(UserInfo.class), any(), any(), any()))\n+\t\t\t\t.thenReturn(AuthorizationStatus.authorized());\n+\t\twhen(mockSchemaDao.createNewSchemaVersion(any())).thenReturn(versionInfo);\n+\t\tschema.set$id(organizationName + \"/\" + schemaName);\n \t\t// call under test\n+\t\tCreateSchemaResponse response = managerSpy.createJsonSchema(user, createSchemaRequest);\n+\t\tassertNotNull(response);\n+\t\tassertEquals(versionInfo, response.getNewVersionInfo());\n+\t\tassertEquals(versionInfo, response.getNewVersionInfo());\n+\t\tverify(mockOrganizationDao).getOrganizationByName(organizationName);\n+\t\tverify(mockAclDao).canAccess(user, organization.getId(), ObjectType.ORGANIZATION, ACCESS_TYPE.CREATE);\n+\t\tNewSchemaVersionRequest expectedNewSchemaRequest = new NewSchemaVersionRequest()\n+\t\t\t\t.withOrganizationId(organization.getId()).withSchemaName(schemaName).withCreatedBy(user.getId())\n+\t\t\t\t.withJsonSchema(schema).withSemanticVersion(null);\n+\t\tverify(mockSchemaDao).createNewSchemaVersion(expectedNewSchemaRequest);\n+\t}\n+\n+\t@Test\n+\tpublic void testCreateJsonSchemaAnonymous() {\n+\t\tString message = assertThrows(UnauthorizedException.class, () -> {\n+\t\t\tmanager.createJsonSchema(anonymousUser, createSchemaRequest);\n+\t\t}).getMessage();\n+\t\tassertEquals(\"Must login to perform this action\", message);\n+\t}\n+\n+\t@Test\n+\tpublic void testCreateJsonSchemaUnauthorized() {\n+\t\twhen(mockOrganizationDao.getOrganizationByName(any())).thenReturn(organization);\n+\t\twhen(mockAclDao.canAccess(any(UserInfo.class), any(), any(), any()))\n+\t\t\t\t.thenReturn(AuthorizationStatus.accessDenied(\"no\"));\n+\t\tString message = assertThrows(UnauthorizedException.class, () -> {\n+\t\t\tmanager.createJsonSchema(user, createSchemaRequest);\n+\t\t}).getMessage();\n+\t\tassertEquals(\"no\", message);\n+\t\tverify(mockAclDao).canAccess(user, organization.getId(), ObjectType.ORGANIZATION, ACCESS_TYPE.CREATE);\n+\t}\n+\n+\t@Test\n+\tpublic void testCreateJsonSchemaNullUser() {\n+\t\tuser = null;\n+\t\tassertThrows(IllegalArgumentException.class, () -> {\n+\t\t\tmanager.createJsonSchema(user, createSchemaRequest);\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testCreateJsonSchemaNullRequest() {\n+\t\tcreateSchemaRequest = null;\n \t\tassertThrows(IllegalArgumentException.class, () -> {\n-\t\t\tmanager.createJsonBlobIfDoesNotExist(schema);\n+\t\t\tmanager.createJsonSchema(user, createSchemaRequest);\n \t\t});\n \t}\n \n \t@Test\n-\tpublic void testGetAndValidateSemanticVersion() {\n-\t\tSemanticVersion version = schemaId.getSemanticVersion();\n-\t\tassertNotNull(version);\n+\tpublic void testCreateJsonSchemaNullSchema() {\n+\t\tcreateSchemaRequest.setSchema(null);\n+\t\tassertThrows(IllegalArgumentException.class, () -> {\n+\t\t\tmanager.createJsonSchema(user, createSchemaRequest);\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testGetSchemaWithVersion() {\n+\t\twhen(mockSchemaDao.getVersionId(any(), any(), any())).thenReturn(versionId);\n+\t\twhen(mockSchemaDao.getSchema(any())).thenReturn(schema);\n \t\t// call under test\n-\t\tString versionString = manager.getAndValidateSemanticVersion(version);\n-\t\tassertEquals(semanticVersionString, versionString);\n+\t\tJsonSchema result = manager.getSchema(organizationName, schemaName, semanticVersionString);\n+\t\tassertEquals(schema, result);\n+\t\tverify(mockSchemaDao).getVersionId(organizationName, schemaName, semanticVersionString);\n+\t\tverify(mockSchemaDao, never()).getLatestVersionId(any(), any());\n+\t\tverify(mockSchemaDao).getSchema(versionId);\n \t}\n \n \t@Test\n-\tpublic void testGetAndValidateSemanticVersionNull() {\n-\t\tSemanticVersion version = null;\n+\tpublic void testGetSchemaWithVersionTrim() {\n+\t\twhen(mockSchemaDao.getVersionId(any(), any(), any())).thenReturn(versionId);\n+\t\twhen(mockSchemaDao.getSchema(any())).thenReturn(schema);\n \t\t// call under test\n-\t\tString versionString = manager.getAndValidateSemanticVersion(version);\n-\t\tassertNull(versionString);\n+\t\tJsonSchema result = manager.getSchema(organizationName + \"\\n\", schemaName + \" \", semanticVersionString + \"\\t\");\n+\t\tassertEquals(schema, result);\n+\t\tverify(mockSchemaDao).getVersionId(organizationName, schemaName, semanticVersionString);\n+\t\tverify(mockSchemaDao, never()).getLatestVersionId(any(), any());\n+\t\tverify(mockSchemaDao).getSchema(versionId);\n \t}\n \n \t@Test\n-\tpublic void testGetAndValidateSemanticVersionAtLimit() throws ParseException {\n-\t\tString prefix = \"2.3.1+\";\n-\t\tString version = prefix\n-\t\t\t\t+ StringUtils.repeat('a', JsonSchemaManagerImpl.MAX_SEMANTIC_VERSION_CHARS - prefix.length());\n-\t\tassertEquals(JsonSchemaManagerImpl.MAX_SEMANTIC_VERSION_CHARS, version.length());\n-\t\tSemanticVersion semanticVersion = new SchemaIdParser(version).semanticVersion();\n+\tpublic void testGetSchemaNullVersion() {\n+\t\twhen(mockSchemaDao.getLatestVersionId(any(), any())).thenReturn(versionId);\n+\t\twhen(mockSchemaDao.getSchema(any())).thenReturn(schema);\n+\t\tsemanticVersionString = null;\n \t\t// call under test\n-\t\tString versionString = manager.getAndValidateSemanticVersion(semanticVersion);\n-\t\tassertEquals(version, versionString);\n+\t\tJsonSchema result = manager.getSchema(organizationName, schemaName, semanticVersionString);\n+\t\tassertEquals(schema, result);\n+\t\tverify(mockSchemaDao, never()).getVersionId(any(), any(), any());\n+\t\tverify(mockSchemaDao).getLatestVersionId(organizationName, schemaName);\n+\t\tverify(mockSchemaDao).getSchema(versionId);\n \t}\n \n \t@Test\n-\tpublic void testGetAndValidateSemanticVersionOverLimit() throws ParseException {\n-\t\tString prefix = \"2.3.1+\";\n-\t\tString version = prefix\n-\t\t\t\t+ StringUtils.repeat('a', JsonSchemaManagerImpl.MAX_SEMANTIC_VERSION_CHARS - prefix.length() + 1);\n-\t\tassertEquals(JsonSchemaManagerImpl.MAX_SEMANTIC_VERSION_CHARS + 1, version.length());\n-\t\tSemanticVersion semanticVersion = new SchemaIdParser(version).semanticVersion();\n-\t\tString message = assertThrows(IllegalArgumentException.class, () -> {\n+\tpublic void testGetSchemaNullVersionTrim() {\n+\t\twhen(mockSchemaDao.getLatestVersionId(any(), any())).thenReturn(versionId);\n+\t\twhen(mockSchemaDao.getSchema(any())).thenReturn(schema);\n+\t\tsemanticVersionString = null;\n+\t\t// call under test\n+\t\tJsonSchema result = manager.getSchema(organizationName + \" \", schemaName + \" \\t\", semanticVersionString);\n+\t\tassertEquals(schema, result);\n+\t\tverify(mockSchemaDao, never()).getVersionId(any(), any(), any());\n+\t\tverify(mockSchemaDao).getLatestVersionId(organizationName, schemaName);\n+\t\tverify(mockSchemaDao).getSchema(versionId);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetSchemaEmptyVersion() {\n+\t\twhen(mockSchemaDao.getLatestVersionId(any(), any())).thenReturn(versionId);\n+\t\twhen(mockSchemaDao.getSchema(any())).thenReturn(schema);\n+\t\tsemanticVersionString = \" \";\n+\t\t// call under test\n+\t\tJsonSchema result = manager.getSchema(organizationName, schemaName, semanticVersionString);\n+\t\tassertEquals(schema, result);\n+\t\tverify(mockSchemaDao, never()).getVersionId(any(), any(), any());\n+\t\tverify(mockSchemaDao).getLatestVersionId(organizationName, schemaName);\n+\t\tverify(mockSchemaDao).getSchema(versionId);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetSchemaNullOrganization() {\n+\t\torganizationName = null;\n+\t\tassertThrows(IllegalArgumentException.class, () -> {\n+\t\t\tmanager.getSchema(organizationName, schemaName, semanticVersionString);\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testGetSchemaNullSchemaName() {\n+\t\tschemaName = null;\n+\t\tassertThrows(IllegalArgumentException.class, () -> {\n+\t\t\tmanager.getSchema(organizationName, schemaName, semanticVersionString);\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testDeleteSchema() {\n+\t\twhen(mockSchemaDao.getVersionLatestInfo(any(), any())).thenReturn(versionInfo);\n+\t\twhen(mockAclDao.canAccess(any(UserInfo.class), any(), any(), any()))\n+\t\t\t\t.thenReturn(AuthorizationStatus.authorized());\n+\n+\t\t// call under test\n+\t\tmanager.deleteSchemaAllVersion(user, organizationName, schemaName);\n+\t\tverify(mockAclDao).canAccess(user, organization.getId(), ObjectType.ORGANIZATION, ACCESS_TYPE.DELETE);\n+\t\tverify(mockSchemaDao).deleteSchema(versionInfo.getSchemaId());\n+\t}\n+\n+\t@Test\n+\tpublic void testDeleteSchemaAdmin() {\n+\t\twhen(mockSchemaDao.getVersionLatestInfo(any(), any())).thenReturn(versionInfo);\n+\t\t// call under test\n+\t\tmanager.deleteSchemaAllVersion(adminUser, organizationName, schemaName);\n+\t\tverify(mockAclDao, never()).canAccess(user, organization.getId(), ObjectType.ORGANIZATION, ACCESS_TYPE.DELETE);\n+\t\tverify(mockSchemaDao).deleteSchema(versionInfo.getSchemaId());\n+\t}\n+\n+\t@Test\n+\tpublic void testDeleteSchemaUnauthorized() {\n+\t\twhen(mockSchemaDao.getVersionLatestInfo(any(), any())).thenReturn(versionInfo);\n+\t\twhen(mockAclDao.canAccess(any(UserInfo.class), any(), any(), any()))\n+\t\t\t\t.thenReturn(AuthorizationStatus.accessDenied(\"nope\"));\n+\t\tassertThrows(UnauthorizedException.class, () -> {\n \t\t\t// call under test\n-\t\t\tmanager.getAndValidateSemanticVersion(semanticVersion);\n-\t\t}).getMessage();\n-\t\tassertEquals(\"Semantic version must be 250 characters or less\", message);\n+\t\t\tmanager.deleteSchemaAllVersion(user, organizationName, schemaName);\n+\t\t});\n+\t\tverify(mockAclDao).canAccess(user, organization.getId(), ObjectType.ORGANIZATION, ACCESS_TYPE.DELETE);\n+\t\tverify(mockSchemaDao, never()).deleteSchema(any());\n \t}\n \n \t@Test\n-\tpublic void testCreateJsonSchema() {\n-\t\twhen(mockOrganizationDao.getOrganizationByName(any())).thenReturn(organization);\n+\tpublic void testDeleteSchemaNullUser() {\n+\t\tuser = null;\n+\t\tassertThrows(IllegalArgumentException.class, () -> {\n+\t\t\tmanager.deleteSchemaAllVersion(user, organizationName, schemaName);\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testDeleteSchemaNullOrganization() {\n+\t\torganizationName = null;\n+\t\tassertThrows(IllegalArgumentException.class, () -> {\n+\t\t\tmanager.deleteSchemaAllVersion(user, organizationName, schemaName);\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testDeleteSchemaNullSchema() {\n+\t\tschemaName = null;\n+\t\tassertThrows(IllegalArgumentException.class, () -> {\n+\t\t\tmanager.deleteSchemaAllVersion(user, organizationName, schemaName);\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testDeleteSchemaVersion() {\n+\t\twhen(mockSchemaDao.getVersionInfo(any(), any(), any())).thenReturn(versionInfo);\n \t\twhen(mockAclDao.canAccess(any(UserInfo.class), any(), any(), any()))\n \t\t\t\t.thenReturn(AuthorizationStatus.authorized());\n-\t\twhen(mockSchemaDao.createSchemaIfDoesNotExist(any())).thenReturn(schemaInfo);\n-\t\twhen(mockSchemaDao.createJsonBlobIfDoesNotExist(any(), any())).thenReturn(jsonBlobId);\n-\t\twhen(mockSchemaDao.createNewVersion(any())).thenReturn(versionInfo);\n \t\t// call under test\n-\t\tCreateSchemaResponse response = managerSpy.createJsonSchema(user, createSchemaRequest);\n-\t\tassertNotNull(response);\n-\t\tassertEquals(versionInfo, response.getNewVersionInfo());\n-\t\tverify(managerSpy).getAndValidateSemanticVersion(schemaId.getSemanticVersion());\n-\t\tassertEquals(versionInfo, response.getNewVersionInfo());\n-\t\tverify(mockOrganizationDao).getOrganizationByName(organizationName);\n-\t\tverify(mockAclDao).canAccess(user, organization.getId(), ObjectType.ORGANIZATION, ACCESS_TYPE.UPDATE);\n-\t\tNewSchemaRequest expectedNewSchemaRequest = new NewSchemaRequest().withOrganizationId(organization.getId())\n-\t\t\t\t.withSchemaName(schemaName).withCreatedBy(user.getId());\n-\t\tverify(mockSchemaDao).createSchemaIfDoesNotExist(expectedNewSchemaRequest);\n-\t\tverify(managerSpy).createJsonBlobIfDoesNotExist(schema);\n-\t\tverify(mockSchemaDao).createJsonBlobIfDoesNotExist(schemaJson, schemaJsonSHA256Hex);\n-\t\tNewVersionRequest expectedNewVersionRequest = new NewVersionRequest().withSchemaId(schemaInfo.getNumericId())\n-\t\t\t\t.withCreatedBy(user.getId()).withBlobId(jsonBlobId).withSemanticVersion(semanticVersionString);\n-\t\tverify(mockSchemaDao).createNewVersion(expectedNewVersionRequest);\n+\t\tmanager.deleteSchemaVersion(user, organizationName, schemaName, semanticVersionString);\n+\t\tverify(mockSchemaDao).getVersionInfo(organizationName, schemaName, semanticVersionString);\n+\t\tverify(mockAclDao).canAccess(user, organization.getId(), ObjectType.ORGANIZATION, ACCESS_TYPE.DELETE);\n+\t\tverify(mockSchemaDao).deleteSchemaVersion(versionId);\n \t}\n \t\n \t@Test\n-\tpublic void testCreateJsonSchemaAnonymous() {\n-\t\tString message = assertThrows(UnauthorizedException.class, ()->{\n-\t\t\t manager.createJsonSchema(anonymousUser, createSchemaRequest);\n-\t\t}).getMessage();\n-\t\tassertEquals(\"Must login to perform this action\", message);\n+\tpublic void testDeleteSchemaVersionUnauthorized() {\n+\t\twhen(mockSchemaDao.getVersionInfo(any(), any(), any())).thenReturn(versionInfo);\n+\t\twhen(mockAclDao.canAccess(any(UserInfo.class), any(), any(), any()))\n+\t\t\t\t.thenReturn(AuthorizationStatus.accessDenied(\"naw\"));\n+\t\tassertThrows(UnauthorizedException.class, ()->{\n+\t\t\t// call under test\n+\t\t\tmanager.deleteSchemaVersion(user, organizationName, schemaName, semanticVersionString);\n+\t\t});\n+\t\tverify(mockSchemaDao).getVersionInfo(organizationName, schemaName, semanticVersionString);\n+\t\tverify(mockAclDao).canAccess(user, organization.getId(), ObjectType.ORGANIZATION, ACCESS_TYPE.DELETE);\n+\t\tverify(mockSchemaDao, never()).deleteSchemaVersion(any());\n \t}\n \t\n \t@Test\n-\tpublic void testCreateJsonSchemaUnauthorized() {\n-\t\twhen(mockOrganizationDao.getOrganizationByName(any())).thenReturn(organization);\n-\t\twhen(mockAclDao.canAccess(any(UserInfo.class), any(), any(), any()))\n-\t\t\t\t.thenReturn(AuthorizationStatus.accessDenied(\"no\"));\n-\t\tString message = assertThrows(UnauthorizedException.class, ()->{\n-\t\t\tmanager.createJsonSchema(user, createSchemaRequest);\n-\t\t}).getMessage();\n-\t\tassertEquals(\"no\", message);\n-\t\tverify(mockAclDao).canAccess(user, organization.getId(), ObjectType.ORGANIZATION, ACCESS_TYPE.UPDATE);\n+\tpublic void testDeleteSchemaVersionAdmin() {\n+\t\twhen(mockSchemaDao.getVersionInfo(any(), any(), any())).thenReturn(versionInfo);\n+\t\t// call under test\n+\t\tmanager.deleteSchemaVersion(adminUser, organizationName, schemaName, semanticVersionString);\n+\t\tverify(mockSchemaDao).getVersionInfo(organizationName, schemaName, semanticVersionString);\n+\t\tverify(mockAclDao, never()).canAccess(any(UserInfo.class), any(), any(), any());\n+\t\tverify(mockSchemaDao).deleteSchemaVersion(versionId);\n \t}\n \t\n \t@Test\n-\tpublic void testCreateJsonSchemaNullUser() {\n+\tpublic void testDeleteSchemaVersionNullUser() {\n \t\tuser = null;\n \t\tassertThrows(IllegalArgumentException.class, ()->{\n-\t\t\tmanager.createJsonSchema(user, createSchemaRequest);\n+\t\t\t// call under test\n+\t\t\tmanager.deleteSchemaVersion(user, organizationName, schemaName, semanticVersionString);\n \t\t});\n \t}\n \t\n \t@Test\n-\tpublic void testCreateJsonSchemaNullRequest() {\n-\t\tcreateSchemaRequest = null;\n+\tpublic void testDeleteSchemaVersionNullOrganizationName() {\n+\t\torganizationName = null;\n \t\tassertThrows(IllegalArgumentException.class, ()->{\n-\t\t\tmanager.createJsonSchema(user, createSchemaRequest);\n+\t\t\t// call under test\n+\t\t\tmanager.deleteSchemaVersion(user, organizationName, schemaName, semanticVersionString);\n \t\t});\n \t}\n \t\n \t@Test\n-\tpublic void testCreateJsonSchemaNullSchema() {\n-\t\tcreateSchemaRequest.setSchema(null);\n+\tpublic void testDeleteSchemaVersionNullSchemaName() {\n+\t\tschemaName = null;\n \t\tassertThrows(IllegalArgumentException.class, ()->{\n-\t\t\tmanager.createJsonSchema(user, createSchemaRequest);\n+\t\t\t// call under test\n+\t\t\tmanager.deleteSchemaVersion(user, organizationName, schemaName, semanticVersionString);\n+\t\t});\n+\t}\n+\t\n+\t@Test\n+\tpublic void testDeleteSchemaVersionNullSemanticVersion() {", "originalCommit": "b7ab950d66569dedcb77d15bfc43d23b610e95fe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk2MDE0MA==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4008#discussion_r416960140", "bodyText": "Change to getSchemaIdForUpdate? Move to the end of the class and comment with // For testing purposes (if we cannot make the Impl autowiring work.", "author": "marcomarasca", "createdAt": "2020-04-28T22:23:40Z", "path": "lib/jdomodels/src/main/java/org/sagebionetworks/repo/model/dbo/schema/JsonSchemaDao.java", "diffHunk": "@@ -1,64 +1,160 @@\n package org.sagebionetworks.repo.model.dbo.schema;\n \n+import org.sagebionetworks.repo.model.schema.JsonSchema;\n import org.sagebionetworks.repo.model.schema.JsonSchemaVersionInfo;\n-import org.sagebionetworks.repo.model.schema.SchemaInfo;\n \n public interface JsonSchemaDao {\n \n \t/**\n-\t * Create a JSON schema if it does not already exist.\n+\t * Lookup the schemaId given an organizationId and schema name, and lock on the\n+\t * row using FOR UPDATE.\n \t * \n-\t * @param request\n-\t * @return The returned SchemaInfo.id will either be the ID of the newly created\n-\t *         schema or the ID of the existing schema.\n+\t * @param organizationId\n+\t * @param schemaName\n+\t * @return schemaId\n \t */\n-\tSchemaInfo createSchemaIfDoesNotExist(NewSchemaRequest request);\n+\tString getSchemaInfoForUpdate(String organizationId, String schemaName);", "originalCommit": "b7ab950d66569dedcb77d15bfc43d23b610e95fe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk2MDY3Mg==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4008#discussion_r416960672", "bodyText": "Add // For testing", "author": "marcomarasca", "createdAt": "2020-04-28T22:25:07Z", "path": "lib/jdomodels/src/main/java/org/sagebionetworks/repo/model/dbo/schema/JsonSchemaDao.java", "diffHunk": "@@ -1,64 +1,160 @@\n package org.sagebionetworks.repo.model.dbo.schema;\n \n+import org.sagebionetworks.repo.model.schema.JsonSchema;\n import org.sagebionetworks.repo.model.schema.JsonSchemaVersionInfo;\n-import org.sagebionetworks.repo.model.schema.SchemaInfo;\n \n public interface JsonSchemaDao {\n \n \t/**\n-\t * Create a JSON schema if it does not already exist.\n+\t * Lookup the schemaId given an organizationId and schema name, and lock on the\n+\t * row using FOR UPDATE.\n \t * \n-\t * @param request\n-\t * @return The returned SchemaInfo.id will either be the ID of the newly created\n-\t *         schema or the ID of the existing schema.\n+\t * @param organizationId\n+\t * @param schemaName\n+\t * @return schemaId\n \t */\n-\tSchemaInfo createSchemaIfDoesNotExist(NewSchemaRequest request);\n+\tString getSchemaInfoForUpdate(String organizationId, String schemaName);\n \n \t/**\n-\t * Lookup a SchemaInfo from an organization name and schema name.\n+\t * Get the JSON data ID for the provide sha256hex\n+\t * \n+\t * @param sha256hex\n+\t * @return\n+\t */\n+\tString getJsonBlobId(String sha256hex);\n+\n+\t/**\n+\t * Get the version information for the given version ID\n+\t * \n+\t * @param versionId\n+\t * @return\n+\t */\n+\tJsonSchemaVersionInfo getVersionInfo(String versionId);\n+\n+\t/**\n+\t * Get the versionId for a specific schema version.\n \t * \n \t * @param organizationName\n \t * @param schemaName\n+\t * @param semanticVersion\n \t * @return\n \t */\n-\tSchemaInfo getSchemaInfoForUpdate(String organizationName, String schemaName);\n+\tString getVersionId(String organizationName, String schemaName, String semanticVersion);\n \n \t/**\n-\t * Create a new JSON blob if the one does not already exist for the given\n-\t * sha256hex.\n+\t * Get the JsonSchemaVersionInfo for a specific version.\n \t * \n-\t * @param json\n-\t * @param sha256hex\n-\t * @return If a new JSON blob is created then the new ID will be returned, else\n-\t *         the existing ID will be returned.\n+\t * @param organizationName\n+\t * @param schemaName\n+\t * @param semanticVersion\n+\t * @return\n \t */\n-\tString createJsonBlobIfDoesNotExist(String json, String sha256hex);\n+\tJsonSchemaVersionInfo getVersionInfo(String organizationName, String schemaName, String semanticVersion);\n \n \t/**\n-\t * Get the JSON data ID for the provide sha256hex\n+\t * Get the versionId of the latest version for a schema.\n \t * \n-\t * @param sha256hex\n+\t * @param organizationName\n+\t * @param schemaName\n \t * @return\n \t */\n-\tString getJsonBlobId(String sha256hex);\n-\t\n+\tString getLatestVersionId(String organizationName, String schemaName);\n+\n \t/**\n-\t * Create a new version for a JSON schema.\n+\t * Get the latest JsonSchemaVersionInfo for a schema.\n+\t * \n+\t * @param organizationName\n+\t * @param schemaNames\n+\t * @return\n+\t */\n+\tJsonSchemaVersionInfo getVersionLatestInfo(String organizationName, String schemaName);\n+\n+\t/**\n+\t * Truncate all data.\n+\t */\n+\tvoid trunacteAll();", "originalCommit": "b7ab950d66569dedcb77d15bfc43d23b610e95fe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk2MDkyMQ==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4008#discussion_r416960921", "bodyText": "boolean?", "author": "marcomarasca", "createdAt": "2020-04-28T22:25:46Z", "path": "lib/jdomodels/src/main/java/org/sagebionetworks/repo/model/dbo/schema/JsonSchemaDao.java", "diffHunk": "@@ -1,64 +1,160 @@\n package org.sagebionetworks.repo.model.dbo.schema;\n \n+import org.sagebionetworks.repo.model.schema.JsonSchema;\n import org.sagebionetworks.repo.model.schema.JsonSchemaVersionInfo;\n-import org.sagebionetworks.repo.model.schema.SchemaInfo;\n \n public interface JsonSchemaDao {\n \n \t/**\n-\t * Create a JSON schema if it does not already exist.\n+\t * Lookup the schemaId given an organizationId and schema name, and lock on the\n+\t * row using FOR UPDATE.\n \t * \n-\t * @param request\n-\t * @return The returned SchemaInfo.id will either be the ID of the newly created\n-\t *         schema or the ID of the existing schema.\n+\t * @param organizationId\n+\t * @param schemaName\n+\t * @return schemaId\n \t */\n-\tSchemaInfo createSchemaIfDoesNotExist(NewSchemaRequest request);\n+\tString getSchemaInfoForUpdate(String organizationId, String schemaName);\n \n \t/**\n-\t * Lookup a SchemaInfo from an organization name and schema name.\n+\t * Get the JSON data ID for the provide sha256hex\n+\t * \n+\t * @param sha256hex\n+\t * @return\n+\t */\n+\tString getJsonBlobId(String sha256hex);\n+\n+\t/**\n+\t * Get the version information for the given version ID\n+\t * \n+\t * @param versionId\n+\t * @return\n+\t */\n+\tJsonSchemaVersionInfo getVersionInfo(String versionId);\n+\n+\t/**\n+\t * Get the versionId for a specific schema version.\n \t * \n \t * @param organizationName\n \t * @param schemaName\n+\t * @param semanticVersion\n \t * @return\n \t */\n-\tSchemaInfo getSchemaInfoForUpdate(String organizationName, String schemaName);\n+\tString getVersionId(String organizationName, String schemaName, String semanticVersion);\n \n \t/**\n-\t * Create a new JSON blob if the one does not already exist for the given\n-\t * sha256hex.\n+\t * Get the JsonSchemaVersionInfo for a specific version.\n \t * \n-\t * @param json\n-\t * @param sha256hex\n-\t * @return If a new JSON blob is created then the new ID will be returned, else\n-\t *         the existing ID will be returned.\n+\t * @param organizationName\n+\t * @param schemaName\n+\t * @param semanticVersion\n+\t * @return\n \t */\n-\tString createJsonBlobIfDoesNotExist(String json, String sha256hex);\n+\tJsonSchemaVersionInfo getVersionInfo(String organizationName, String schemaName, String semanticVersion);\n \n \t/**\n-\t * Get the JSON data ID for the provide sha256hex\n+\t * Get the versionId of the latest version for a schema.\n \t * \n-\t * @param sha256hex\n+\t * @param organizationName\n+\t * @param schemaName\n \t * @return\n \t */\n-\tString getJsonBlobId(String sha256hex);\n-\t\n+\tString getLatestVersionId(String organizationName, String schemaName);\n+\n \t/**\n-\t * Create a new version for a JSON schema.\n+\t * Get the latest JsonSchemaVersionInfo for a schema.\n+\t * \n+\t * @param organizationName\n+\t * @param schemaNames\n+\t * @return\n+\t */\n+\tJsonSchemaVersionInfo getVersionLatestInfo(String organizationName, String schemaName);\n+\n+\t/**\n+\t * Truncate all data.\n+\t */\n+\tvoid trunacteAll();\n+\n+\t/**\n+\t * Get the schema for the given version ID.\n+\t * \n+\t * @param organizationName\n+\t * @param schemaName\n+\t * @return\n+\t */\n+\tJsonSchema getSchema(String versionId);\n+\n+\t/**\n+\t * Attempt to delete the given schema.\n+\t * \n+\t * @param schemaId\n+\t */\n+\tint deleteSchema(String schemaId);", "originalCommit": "b7ab950d66569dedcb77d15bfc43d23b610e95fe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk2NTM3MQ==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4008#discussion_r416965371", "bodyText": "Extract the query to a string, so that can be easily debugged", "author": "marcomarasca", "createdAt": "2020-04-28T22:37:01Z", "path": "lib/jdomodels/src/main/java/org/sagebionetworks/repo/model/dbo/schema/JsonSchemaDaoImpl.java", "diffHunk": "@@ -166,14 +221,155 @@ public JsonSchemaVersionInfo createNewVersion(NewVersionRequest request) {\n \tpublic JsonSchemaVersionInfo getVersionInfo(String versionId) {\n \t\tValidateArgument.required(versionId, \"versionId\");\n \t\ttry {\n-\t\t\treturn jdbcTemplate.queryForObject(\n-\t\t\t\t\t\"SELECT V.*, B.\" + COL_JSON_SCHEMA_BLOB_SHA256 + \" FROM \" + TABLE_JSON_SCHEMA_VERSION\n-\t\t\t\t\t\t\t+ \" V INNER JOIN \" + TABLE_JSON_SCHEMA_BLOB + \" B ON (V.\" + COL_JSON_SCHEMA_VER_BLOB_ID\n-\t\t\t\t\t\t\t+ \"=B.\" + COL_JSON_SCHEMA_BLOB_ID + \") WHERE V.\" + COL_JSON_SCHEMA_VER_ID + \"=?\",\n-\t\t\t\t\tSCHEMA_VERSION_INFO_MAPPER, versionId);\n+\t\t\treturn jdbcTemplate.queryForObject(\"SELECT O.\" + COL_ORGANIZATION_ID + \", O.\" + COL_ORGANIZATION_NAME", "originalCommit": "b7ab950d66569dedcb77d15bfc43d23b610e95fe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk2NTUyNQ==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4008#discussion_r416965525", "bodyText": "Maintain consistency between JOIN vs INNER JOIN", "author": "marcomarasca", "createdAt": "2020-04-28T22:37:28Z", "path": "lib/jdomodels/src/main/java/org/sagebionetworks/repo/model/dbo/schema/JsonSchemaDaoImpl.java", "diffHunk": "@@ -166,14 +221,155 @@ public JsonSchemaVersionInfo createNewVersion(NewVersionRequest request) {\n \tpublic JsonSchemaVersionInfo getVersionInfo(String versionId) {\n \t\tValidateArgument.required(versionId, \"versionId\");\n \t\ttry {\n-\t\t\treturn jdbcTemplate.queryForObject(\n-\t\t\t\t\t\"SELECT V.*, B.\" + COL_JSON_SCHEMA_BLOB_SHA256 + \" FROM \" + TABLE_JSON_SCHEMA_VERSION\n-\t\t\t\t\t\t\t+ \" V INNER JOIN \" + TABLE_JSON_SCHEMA_BLOB + \" B ON (V.\" + COL_JSON_SCHEMA_VER_BLOB_ID\n-\t\t\t\t\t\t\t+ \"=B.\" + COL_JSON_SCHEMA_BLOB_ID + \") WHERE V.\" + COL_JSON_SCHEMA_VER_ID + \"=?\",\n-\t\t\t\t\tSCHEMA_VERSION_INFO_MAPPER, versionId);\n+\t\t\treturn jdbcTemplate.queryForObject(\"SELECT O.\" + COL_ORGANIZATION_ID + \", O.\" + COL_ORGANIZATION_NAME\n+\t\t\t\t\t+ \", S.\" + COL_JSON_SCHEMA_ID + \", S.\" + COL_JSON_SCHEMA_NAME + \", V.*, B.\"\n+\t\t\t\t\t+ COL_JSON_SCHEMA_BLOB_SHA256 + \" FROM \" + TABLE_JSON_SCHEMA_VERSION + \" V INNER JOIN \"", "originalCommit": "b7ab950d66569dedcb77d15bfc43d23b610e95fe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3MDEwMg==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4008#discussion_r416970102", "bodyText": "Might use an Optional as return value", "author": "marcomarasca", "createdAt": "2020-04-28T22:49:25Z", "path": "lib/jdomodels/src/main/java/org/sagebionetworks/repo/model/dbo/schema/JsonSchemaDaoImpl.java", "diffHunk": "@@ -166,14 +221,155 @@ public JsonSchemaVersionInfo createNewVersion(NewVersionRequest request) {\n \tpublic JsonSchemaVersionInfo getVersionInfo(String versionId) {\n \t\tValidateArgument.required(versionId, \"versionId\");\n \t\ttry {\n-\t\t\treturn jdbcTemplate.queryForObject(\n-\t\t\t\t\t\"SELECT V.*, B.\" + COL_JSON_SCHEMA_BLOB_SHA256 + \" FROM \" + TABLE_JSON_SCHEMA_VERSION\n-\t\t\t\t\t\t\t+ \" V INNER JOIN \" + TABLE_JSON_SCHEMA_BLOB + \" B ON (V.\" + COL_JSON_SCHEMA_VER_BLOB_ID\n-\t\t\t\t\t\t\t+ \"=B.\" + COL_JSON_SCHEMA_BLOB_ID + \") WHERE V.\" + COL_JSON_SCHEMA_VER_ID + \"=?\",\n-\t\t\t\t\tSCHEMA_VERSION_INFO_MAPPER, versionId);\n+\t\t\treturn jdbcTemplate.queryForObject(\"SELECT O.\" + COL_ORGANIZATION_ID + \", O.\" + COL_ORGANIZATION_NAME\n+\t\t\t\t\t+ \", S.\" + COL_JSON_SCHEMA_ID + \", S.\" + COL_JSON_SCHEMA_NAME + \", V.*, B.\"\n+\t\t\t\t\t+ COL_JSON_SCHEMA_BLOB_SHA256 + \" FROM \" + TABLE_JSON_SCHEMA_VERSION + \" V INNER JOIN \"\n+\t\t\t\t\t+ TABLE_JSON_SCHEMA_BLOB + \" B ON (V.\" + COL_JSON_SCHEMA_VER_BLOB_ID + \"=B.\"\n+\t\t\t\t\t+ COL_JSON_SCHEMA_BLOB_ID + \") JOIN \" + TABLE_JSON_SCHEMA + \" S ON (V.\"\n+\t\t\t\t\t+ COL_JSON_SCHEMA_VER_SCHEMA_ID + \" = S.\" + COL_JSON_SCHEMA_ID + \" ) JOIN \" + TABLE_ORGANIZATION\n+\t\t\t\t\t+ \" O ON (S.\" + COL_JSON_SCHEMA_ORG_ID + \" = O.\" + COL_ORGANIZATION_ID + \") WHERE V.\"\n+\t\t\t\t\t+ COL_JSON_SCHEMA_VER_ID + \"=?\", SCHEMA_VERSION_INFO_MAPPER, versionId);\n \t\t} catch (EmptyResultDataAccessException e) {\n \t\t\tthrow new NotFoundException(\"JSON version not found for versionId: \" + versionId);\n \t\t}\n \t}\n \n+\t@WriteTransaction\n+\t@Override\n+\tpublic JsonSchemaVersionInfo createNewSchemaVersion(NewSchemaVersionRequest request) {\n+\t\tValidateArgument.required(request, \"request\");\n+\t\tValidateArgument.required(request.getOrganizationId(), \"request.organizationId\");\n+\t\tValidateArgument.required(request.getCreatedBy(), \"request.createdBy\");\n+\t\tValidateArgument.required(request.getSchemaName(), \"request.schemaName\");\n+\t\tValidateArgument.required(request.getJsonSchema(), \"request.jsonSchema\");\n+\t\tif (request.getSchemaName().length() > MAX_SCHEMA_NAME_CHARS) {\n+\t\t\tthrow new IllegalArgumentException(\"Schema name must be \" + MAX_SCHEMA_NAME_CHARS + \" characters or less\");\n+\t\t}\n+\t\tif (request.getSemanticVersion() != null) {\n+\t\t\tif (request.getSemanticVersion().length() > MAX_SEMANTIC_VERSION_CHARS) {\n+\t\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t\t\"Semantic version must be \" + MAX_SEMANTIC_VERSION_CHARS + \" characters or less\");\n+\t\t\t}\n+\t\t}\n+\t\tString schemaId = createSchemaIfDoesNotExist(request.getOrganizationId(), request.getSchemaName(),\n+\t\t\t\trequest.getCreatedBy());\n+\t\tString blobId = createJsonBlobIfDoesNotExist(request.getJsonSchema());\n+\t\treturn createNewVersion(schemaId, request.getSemanticVersion(), request.getCreatedBy(), blobId);\n+\t}\n+\n+\t@WriteTransaction\n+\t@Override\n+\tpublic int deleteSchema(String schemaId) {\n+\t\tValidateArgument.required(schemaId, \"schemaId\");\n+\t\tjdbcTemplate.update(\"DELETE FROM \" + TABLE_JSON_SCHEMA_LATEST_VERSION + \" WHERE \"\n+\t\t\t\t+ COL_JSON_SCHEMA_LATEST_VER_SCHEMA_ID + \" = ?\", schemaId);\n+\t\tjdbcTemplate.update(\n+\t\t\t\t\"DELETE FROM \" + TABLE_JSON_SCHEMA_VERSION + \" WHERE \" + COL_JSON_SCHEMA_VER_SCHEMA_ID + \" = ?\",\n+\t\t\t\tschemaId);\n+\t\treturn jdbcTemplate.update(\"DELETE FROM \" + TABLE_JSON_SCHEMA + \" WHERE \" + COL_JSON_SCHEMA_ID + \" = ?\",\n+\t\t\t\tschemaId);\n+\t}\n+\n+\t@WriteTransaction\n+\t@Override\n+\tpublic String getSchemaIdForUpdate(String versionId) {\n+\t\tValidateArgument.required(versionId, \"versionId\");\n+\t\ttry {\n+\t\t\treturn jdbcTemplate.queryForObject(\"SELECT \" + COL_JSON_SCHEMA_VER_SCHEMA_ID + \" FROM \"\n+\t\t\t\t\t+ TABLE_JSON_SCHEMA_VERSION + \" WHERE \" + COL_JSON_SCHEMA_VER_ID + \" = ? FOR UPDATE\", String.class,\n+\t\t\t\t\tversionId);\n+\t\t} catch (EmptyResultDataAccessException e) {\n+\t\t\tthrow new NotFoundException(\"JSON schema not found for versionId: \" + versionId);\n+\t\t}\n+\t}\n+\n+\t@WriteTransaction\n+\t@Override\n+\tpublic void deleteSchemaVersion(String versionId) {\n+\t\tValidateArgument.required(versionId, \"versionId\");\n+\t\t// lock on the schema\n+\t\tString schemaId = getSchemaIdForUpdate(versionId);\n+\t\t// clear the latest version cache\n+\t\tjdbcTemplate.update(\"DELETE FROM \" + TABLE_JSON_SCHEMA_LATEST_VERSION + \" WHERE \"\n+\t\t\t\t+ COL_JSON_SCHEMA_LATEST_VER_SCHEMA_ID + \" = ?\", schemaId);\n+\t\t// delete the requested version\n+\t\tjdbcTemplate.update(\"DELETE FROM \" + TABLE_JSON_SCHEMA_VERSION + \" WHERE \" + COL_JSON_SCHEMA_VER_ID + \" = ?\",\n+\t\t\t\tversionId);\n+\t\t// find the latest version for the schema\n+\t\tLong latestVersionId = findLatestVersionId(schemaId);\n+\t\tif (latestVersionId == null) {\n+\t\t\t// deleted the last version so delete the schema.\n+\t\t\tdeleteSchema(schemaId);\n+\t\t} else {\n+\t\t\tsetLatestVersion(schemaId, latestVersionId);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic String getVersionId(String organizationName, String schemaName, String semanticVersion) {\n+\t\tValidateArgument.required(organizationName, \"organizationName\");\n+\t\tValidateArgument.required(schemaName, \"schemaName\");\n+\t\tValidateArgument.required(semanticVersion, \"semanticVersion\");\n+\t\tString sql = \"SELECT V.\" + COL_JSON_SCHEMA_VER_ID + \" FROM \" + TABLE_ORGANIZATION + \" O JOIN \"\n+\t\t\t\t+ TABLE_JSON_SCHEMA + \" S ON (O.\" + COL_ORGANIZATION_ID + \" = S.\" + COL_JSON_SCHEMA_ORG_ID + \") JOIN \"\n+\t\t\t\t+ TABLE_JSON_SCHEMA_VERSION + \" V ON (S.\" + COL_JSON_SCHEMA_ID + \" = V.\" + COL_JSON_SCHEMA_VER_SCHEMA_ID\n+\t\t\t\t+ \") WHERE O.\" + COL_ORGANIZATION_NAME + \" = ? AND S.\" + COL_JSON_SCHEMA_NAME + \" = ? AND V.\"\n+\t\t\t\t+ COL_JSON_SCHEMA_VER_SEMANTIC + \" = ?\";\n+\t\ttry {\n+\t\t\treturn jdbcTemplate.queryForObject(sql, String.class, organizationName, schemaName, semanticVersion);\n+\t\t} catch (EmptyResultDataAccessException e) {\n+\t\t\tthrow new NotFoundException(\"JSON Schema not found for organizationName: '\" + organizationName\n+\t\t\t\t\t+ \"' and schemaName: '\" + schemaName + \"' and semanticVersion: '\" + semanticVersion + \"'\");\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic String getLatestVersionId(String organizationName, String schemaName) {\n+\t\tValidateArgument.required(organizationName, \"organizationName\");\n+\t\tValidateArgument.required(schemaName, \"schemaName\");\n+\t\ttry {\n+\t\t\treturn jdbcTemplate.queryForObject(\"SELECT L.\" + COL_JSON_SCHEMA_LATEST_VER_VER_ID + \" FROM \"\n+\t\t\t\t\t+ TABLE_ORGANIZATION + \" O JOIN \" + TABLE_JSON_SCHEMA + \" S ON (O.\" + COL_ORGANIZATION_ID + \" = S.\"\n+\t\t\t\t\t+ COL_JSON_SCHEMA_ORG_ID + \") JOIN \" + TABLE_JSON_SCHEMA_LATEST_VERSION + \" L ON (S.\"\n+\t\t\t\t\t+ COL_JSON_SCHEMA_ID + \" = L.\" + COL_JSON_SCHEMA_LATEST_VER_SCHEMA_ID + \") WHERE O.\"\n+\t\t\t\t\t+ COL_ORGANIZATION_NAME + \" = ? AND \" + COL_JSON_SCHEMA_NAME + \" = ?\", String.class,\n+\t\t\t\t\torganizationName, schemaName);\n+\t\t} catch (EmptyResultDataAccessException e) {\n+\t\t\tthrow new NotFoundException(\"JSON Schema not found for organizationName: '\" + organizationName\n+\t\t\t\t\t+ \"' and schemaName: '\" + schemaName + \"'\");\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic JsonSchema getSchema(String versionId) {\n+\t\tValidateArgument.required(versionId, \"versionId\");\n+\t\ttry {\n+\t\t\treturn jdbcTemplate.queryForObject(\n+\t\t\t\t\t\"SELECT B.\" + COL_JSON_SCHEMA_BLOB_BLOB + \" FROM \" + TABLE_JSON_SCHEMA_VERSION + \" V JOIN \"\n+\t\t\t\t\t\t\t+ TABLE_JSON_SCHEMA_BLOB + \" B ON (V.\" + COL_JSON_SCHEMA_VER_BLOB_ID + \" = B.\"\n+\t\t\t\t\t\t\t+ COL_JSON_SCHEMA_BLOB_ID + \") WHERE V.\" + COL_JSON_SCHEMA_VER_ID + \" = ?\",\n+\t\t\t\t\tSCHEMA_MAPPER, versionId);\n+\t\t} catch (EmptyResultDataAccessException e) {\n+\t\t\tthrow new NotFoundException(\"JSON Schema not found for versionId: '\" + versionId + \"'\");\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic JsonSchemaVersionInfo getVersionInfo(String organizationName, String schemaName, String semanticVersion) {\n+\t\tString versionId = getVersionId(organizationName, schemaName, semanticVersion);\n+\t\treturn getVersionInfo(versionId);\n+\t}\n+\n+\t@Override\n+\tpublic JsonSchemaVersionInfo getVersionLatestInfo(String organizationName, String schemaName) {\n+\t\tString versionId = getLatestVersionId(organizationName, schemaName);\n+\t\treturn getVersionInfo(versionId);\n+\t}\n+\n+\t@Override\n+\tpublic Long findLatestVersionId(String schemaId) {", "originalCommit": "b7ab950d66569dedcb77d15bfc43d23b610e95fe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3OTE3OQ==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4008#discussion_r416979179", "bodyText": "Add assert on the message", "author": "marcomarasca", "createdAt": "2020-04-28T23:14:22Z", "path": "lib/jdomodels/src/test/java/org/sagebionetworks/repo/model/dbo/schema/JsonSchemaDaoImplTest.java", "diffHunk": "@@ -318,4 +308,532 @@ public void testGetVersionInfoNullId() {\n \t\t});\n \t}\n \n+\t@Test\n+\tpublic void testCreateNewSchemaVersion() {\n+\t\t// Call under test\n+\t\tJsonSchemaVersionInfo info = jsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\tassertNotNull(info);\n+\t\tassertEquals(organizationId, info.getOrganizationId());\n+\t\tassertEquals(organizationName, info.getOrganizationName());\n+\t\tassertNotNull(info.getSchemaId());\n+\t\tassertEquals(schemaName, info.getSchemaName());\n+\t\tassertEquals(createdBy.toString(), info.getCreatedBy());\n+\t\tassertEquals(semanticVersion, info.getSemanticVersion());\n+\t\tassertNotNull(info.getVersionId());\n+\t\tassertEquals(schemaJsonSha256Hex ,info.getJsonSHA256Hex());\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVersionSchemaNameAtLimit() {\n+\t\tString schemaName = StringUtils.repeat(\"a\", JsonSchemaDaoImpl.MAX_SCHEMA_NAME_CHARS);\n+\t\tnewSchemaVersionRequest.withSchemaName(schemaName);\n+\t\tJsonSchemaVersionInfo info = jsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\tassertNotNull(info);\n+\t\tassertEquals(schemaName, info.getSchemaName());\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVersionSchemaNameOverLimit() {\n+\t\tString schemaName = StringUtils.repeat(\"a\", JsonSchemaDaoImpl.MAX_SCHEMA_NAME_CHARS+1);\n+\t\tnewSchemaVersionRequest.withSchemaName(schemaName);\n+\t\tString message = assertThrows(IllegalArgumentException.class, ()->{\n+\t\t\tjsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\t}).getMessage();\n+\t\tassertEquals(\"Schema name must be \"+JsonSchemaDaoImpl.MAX_SCHEMA_NAME_CHARS+\" characters or less\", message);\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVersionSemanticVersionAtLimit() {\n+\t\tsemanticVersion = StringUtils.repeat(\"a\", JsonSchemaDaoImpl.MAX_SEMANTIC_VERSION_CHARS);\n+\t\tnewSchemaVersionRequest.withSemanticVersion(semanticVersion);\n+\t\tJsonSchemaVersionInfo info = jsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\tassertNotNull(info);\n+\t\tassertEquals(semanticVersion, info.getSemanticVersion());\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVersionSemanticVersionOverLimit() {\n+\t\tsemanticVersion = StringUtils.repeat(\"a\", JsonSchemaDaoImpl.MAX_SEMANTIC_VERSION_CHARS+1);\n+\t\tnewSchemaVersionRequest.withSemanticVersion(semanticVersion);\n+\t\tString message = assertThrows(IllegalArgumentException.class, ()->{\n+\t\t\tjsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\t}).getMessage();\n+\t\tassertEquals(\"Semantic version must be \"+JsonSchemaDaoImpl.MAX_SEMANTIC_VERSION_CHARS+\" characters or less\", message);\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVerionNullRequest() {\n+\t\tnewSchemaVersionRequest = null;\n+\t\tassertThrows(IllegalArgumentException.class, ()->{\n+\t\t\tjsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\t});\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVerionNullRequestNullOrganizationId() {\n+\t\tnewSchemaVersionRequest.withOrganizationId(null);\n+\t\tassertThrows(IllegalArgumentException.class, ()->{\n+\t\t\tjsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\t});\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVerionNullRequestNullSchemaName() {\n+\t\tnewSchemaVersionRequest.withSchemaName(null);\n+\t\tassertThrows(IllegalArgumentException.class, ()->{\n+\t\t\tjsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\t});\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVerionNullRequestNullCreatedBy() {\n+\t\tnewSchemaVersionRequest.withCreatedBy(null);\n+\t\tassertThrows(IllegalArgumentException.class, ()->{\n+\t\t\tjsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\t});\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVersionNullSemanticVersion() {\n+\t\tsemanticVersion = null;\n+\t\tnewSchemaVersionRequest.withSemanticVersion(semanticVersion);\n+\t\tJsonSchemaVersionInfo info = jsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\tassertNotNull(info);\n+\t\tassertEquals(semanticVersion, info.getSemanticVersion());\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVerionNullSchema() {\n+\t\tnewSchemaVersionRequest.withJsonSchema(null);\n+\t\tassertThrows(IllegalArgumentException.class, ()->{\n+\t\t\tjsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\t});\n+\t}\n+\n+\t/**\n+\t * Helper to create a new JSON schema with the given $id\n+\t * \n+\t * @param schema\n+\t * @return\n+\t * @throws JSONObjectAdapterException\n+\t */\n+\tJsonSchemaVersionInfo createNewSchemaVersion(String id, int index) throws JSONObjectAdapterException {\n+\t\tSchemaId schemaId = SchemaIdParser.parseSchemaId(id);\n+\t\tString organizationName = schemaId.getOrganizationName().toString();\n+\t\tString schemaName = schemaId.getSchemaName().toString();\n+\t\tString semanticVersion = null;\n+\t\tif (schemaId.getSemanticVersion() != null) {\n+\t\t\tsemanticVersion = schemaId.getSemanticVersion().toString();\n+\t\t}\n+\t\tOrganization organization = null;\n+\t\ttry {\n+\t\t\torganization = organizationDao.getOrganizationByName(organizationName);\n+\t\t} catch (NotFoundException e) {\n+\t\t\torganization = organizationDao.createOrganization(organizationName, adminUserId);\n+\t\t}\n+\t\tschema = new JsonSchema();\n+\t\tschema.set$id(id);\n+\t\tschema.setDescription(\"index:\" + index);\n+\t\treturn jsonSchemaDao.createNewSchemaVersion(\n+\t\t\t\tnew NewSchemaVersionRequest().withOrganizationId(organization.getId()).withCreatedBy(createdBy)\n+\t\t\t\t\t\t.withJsonSchema(schema).withSchemaName(schemaName).withSemanticVersion(semanticVersion));\n+\t}\n+\n+\t/**\n+\t * Helper to get the SHA-256 hex string for a given schema.\n+\t * \n+\t * @param schema\n+\t * @return\n+\t * @throws JSONObjectAdapterException\n+\t */\n+\tstatic String getSchemaSHA256Hex(JsonSchema schema) throws JSONObjectAdapterException {\n+\t\tString json = EntityFactory.createJSONStringForEntity(schema);\n+\t\treturn DigestUtils.sha256Hex(json);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetLatestVersion() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar/1.0.1\", index++);\n+\t\tJsonSchemaVersionInfo lastVersion = createNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\tcreateNewSchemaVersion(\"other.org/foo.bar\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar.other\", index++);\n+\t\t// Call under test\n+\t\tString versionId = jsonSchemaDao.getLatestVersionId(\"my.org.edu\", \"foo.bar\");\n+\t\tassertEquals(lastVersion.getVersionId(), versionId);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetLatestVersionOrganziationNotFound() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\tString message = assertThrows(NotFoundException.class, () -> {\n+\t\t\tjsonSchemaDao.getLatestVersionId(\"other.org\", \"foo.bar\");\n+\t\t}).getMessage();\n+\t\tassertEquals(\"JSON Schema not found for organizationName: 'other.org' and schemaName: 'foo.bar'\", message);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetLatestVersionSchemaNameNotFound() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\tString message = assertThrows(NotFoundException.class, () -> {\n+\t\t\tjsonSchemaDao.getLatestVersionId(\"my.org.edu\", \"other.schema.name\");\n+\t\t}).getMessage();\n+\t\tassertEquals(\"JSON Schema not found for organizationName: 'my.org.edu' and schemaName: 'other.schema.name'\",\n+\t\t\t\tmessage);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetSchemaLatestVersionNullOrganization() {\n+\t\tString organizationName = null;\n+\t\tString schemaName = \"other.schema.name\";\n+\t\tassertThrows(IllegalArgumentException.class, () -> {\n+\t\t\tjsonSchemaDao.getLatestVersionId(organizationName, schemaName);\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testGetSchemaLatestVersionNullSchema() {\n+\t\tString organizationName = \"my.org.edu\";\n+\t\tString schemaName = null;\n+\t\tassertThrows(IllegalArgumentException.class, () -> {\n+\t\t\tjsonSchemaDao.getLatestVersionId(organizationName, schemaName);\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testGetVersionId() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar/0.0.1\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\tJsonSchemaVersionInfo expected = createNewSchemaVersion(\"my.org.edu/foo.bar/1.0.1\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\tcreateNewSchemaVersion(\"other.org/foo.bar\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar.other\", index++);\n+\n+\t\tString organizationName = \"my.org.edu\";\n+\t\tString schemaName = \"foo.bar\";\n+\t\tString semanticVersion = \"1.0.1\";\n+\t\t// call under test\n+\t\tString versionId = jsonSchemaDao.getVersionId(organizationName, schemaName, semanticVersion);\n+\t\tassertNotNull(versionId);\n+\t\tassertEquals(expected.getVersionId(), versionId);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetVersionIdNotFound() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar/0.0.1\", index++);\n+\n+\t\tString organizationName = \"my.org.edu\";\n+\t\tString schemaName = \"foo.bar\";\n+\t\tString semanticVersion = \"1.0.1\";\n+\t\t// call under test\n+\t\tString message = assertThrows(NotFoundException.class, () -> {\n+\t\t\tjsonSchemaDao.getVersionId(organizationName, schemaName, semanticVersion);\n+\t\t}).getMessage();\n+\t\tassertEquals(\n+\t\t\t\t\"JSON Schema not found for organizationName: 'my.org.edu' and schemaName: 'foo.bar' and semanticVersion: '1.0.1'\",\n+\t\t\t\tmessage);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetVersionIdNullOrgName() throws JSONObjectAdapterException {\n+\t\tString organizationName = null;\n+\t\tString schemaName = \"foo.bar\";\n+\t\tString semanticVersion = \"1.0.1\";\n+\t\t// call under test\n+\t\tassertThrows(IllegalArgumentException.class, () -> {\n+\t\t\tjsonSchemaDao.getVersionId(organizationName, schemaName, semanticVersion);\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testGetVersionIdNullSchemaName() throws JSONObjectAdapterException {\n+\t\tString organizationName = \"my.org.edu\";\n+\t\tString schemaName = null;\n+\t\tString semanticVersion = \"1.0.1\";\n+\t\t// call under test\n+\t\tassertThrows(IllegalArgumentException.class, () -> {\n+\t\t\tjsonSchemaDao.getVersionId(organizationName, schemaName, semanticVersion);\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testGetVersionIdNullSemanticVersion() throws JSONObjectAdapterException {\n+\t\tString organizationName = \"my.org.edu\";\n+\t\tString schemaName = \"foo.bar\";\n+\t\tString semanticVersion = null;\n+\t\t// call under test\n+\t\tassertThrows(IllegalArgumentException.class, () -> {\n+\t\t\tjsonSchemaDao.getVersionId(organizationName, schemaName, semanticVersion);\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testGetVersionInfoTripple() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar/0.0.1\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\tJsonSchemaVersionInfo expected = createNewSchemaVersion(\"my.org.edu/foo.bar/1.0.1\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\tcreateNewSchemaVersion(\"other.org/foo.bar\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar.other\", index++);\n+\n+\t\t// call under test\n+\t\tJsonSchemaVersionInfo resultInfo = jsonSchemaDao.getVersionInfo(\"my.org.edu\", \"foo.bar\", \"1.0.1\");\n+\t\tassertEquals(expected, resultInfo);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetSchemaVersionOrganizationNotFound() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar/1.0.1\", index++);\n+\t\tString message = assertThrows(NotFoundException.class, () -> {\n+\t\t\tjsonSchemaDao.getVersionInfo(\"other.org\", \"foo.bar\", \"1.0.1\");\n+\t\t}).getMessage();\n+\t\tassertEquals(\n+\t\t\t\t\"JSON Schema not found for organizationName: 'other.org' and schemaName: 'foo.bar' and semanticVersion: '1.0.1'\",\n+\t\t\t\tmessage);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetSchemaVersionSchemaNameNotFound() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar/1.0.1\", index++);\n+\t\tassertThrows(NotFoundException.class, () -> {\n+\t\t\tjsonSchemaDao.getVersionInfo(\"my.org.edu\", \"foo.bar.bar\", \"1.0.1\");\n+\t\t});", "originalCommit": "b7ab950d66569dedcb77d15bfc43d23b610e95fe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3OTMxNg==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4008#discussion_r416979316", "bodyText": "Add assert on message", "author": "marcomarasca", "createdAt": "2020-04-28T23:14:43Z", "path": "lib/jdomodels/src/test/java/org/sagebionetworks/repo/model/dbo/schema/JsonSchemaDaoImplTest.java", "diffHunk": "@@ -318,4 +308,532 @@ public void testGetVersionInfoNullId() {\n \t\t});\n \t}\n \n+\t@Test\n+\tpublic void testCreateNewSchemaVersion() {\n+\t\t// Call under test\n+\t\tJsonSchemaVersionInfo info = jsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\tassertNotNull(info);\n+\t\tassertEquals(organizationId, info.getOrganizationId());\n+\t\tassertEquals(organizationName, info.getOrganizationName());\n+\t\tassertNotNull(info.getSchemaId());\n+\t\tassertEquals(schemaName, info.getSchemaName());\n+\t\tassertEquals(createdBy.toString(), info.getCreatedBy());\n+\t\tassertEquals(semanticVersion, info.getSemanticVersion());\n+\t\tassertNotNull(info.getVersionId());\n+\t\tassertEquals(schemaJsonSha256Hex ,info.getJsonSHA256Hex());\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVersionSchemaNameAtLimit() {\n+\t\tString schemaName = StringUtils.repeat(\"a\", JsonSchemaDaoImpl.MAX_SCHEMA_NAME_CHARS);\n+\t\tnewSchemaVersionRequest.withSchemaName(schemaName);\n+\t\tJsonSchemaVersionInfo info = jsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\tassertNotNull(info);\n+\t\tassertEquals(schemaName, info.getSchemaName());\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVersionSchemaNameOverLimit() {\n+\t\tString schemaName = StringUtils.repeat(\"a\", JsonSchemaDaoImpl.MAX_SCHEMA_NAME_CHARS+1);\n+\t\tnewSchemaVersionRequest.withSchemaName(schemaName);\n+\t\tString message = assertThrows(IllegalArgumentException.class, ()->{\n+\t\t\tjsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\t}).getMessage();\n+\t\tassertEquals(\"Schema name must be \"+JsonSchemaDaoImpl.MAX_SCHEMA_NAME_CHARS+\" characters or less\", message);\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVersionSemanticVersionAtLimit() {\n+\t\tsemanticVersion = StringUtils.repeat(\"a\", JsonSchemaDaoImpl.MAX_SEMANTIC_VERSION_CHARS);\n+\t\tnewSchemaVersionRequest.withSemanticVersion(semanticVersion);\n+\t\tJsonSchemaVersionInfo info = jsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\tassertNotNull(info);\n+\t\tassertEquals(semanticVersion, info.getSemanticVersion());\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVersionSemanticVersionOverLimit() {\n+\t\tsemanticVersion = StringUtils.repeat(\"a\", JsonSchemaDaoImpl.MAX_SEMANTIC_VERSION_CHARS+1);\n+\t\tnewSchemaVersionRequest.withSemanticVersion(semanticVersion);\n+\t\tString message = assertThrows(IllegalArgumentException.class, ()->{\n+\t\t\tjsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\t}).getMessage();\n+\t\tassertEquals(\"Semantic version must be \"+JsonSchemaDaoImpl.MAX_SEMANTIC_VERSION_CHARS+\" characters or less\", message);\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVerionNullRequest() {\n+\t\tnewSchemaVersionRequest = null;\n+\t\tassertThrows(IllegalArgumentException.class, ()->{\n+\t\t\tjsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\t});\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVerionNullRequestNullOrganizationId() {\n+\t\tnewSchemaVersionRequest.withOrganizationId(null);\n+\t\tassertThrows(IllegalArgumentException.class, ()->{\n+\t\t\tjsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\t});\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVerionNullRequestNullSchemaName() {\n+\t\tnewSchemaVersionRequest.withSchemaName(null);\n+\t\tassertThrows(IllegalArgumentException.class, ()->{\n+\t\t\tjsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\t});\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVerionNullRequestNullCreatedBy() {\n+\t\tnewSchemaVersionRequest.withCreatedBy(null);\n+\t\tassertThrows(IllegalArgumentException.class, ()->{\n+\t\t\tjsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\t});\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVersionNullSemanticVersion() {\n+\t\tsemanticVersion = null;\n+\t\tnewSchemaVersionRequest.withSemanticVersion(semanticVersion);\n+\t\tJsonSchemaVersionInfo info = jsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\tassertNotNull(info);\n+\t\tassertEquals(semanticVersion, info.getSemanticVersion());\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVerionNullSchema() {\n+\t\tnewSchemaVersionRequest.withJsonSchema(null);\n+\t\tassertThrows(IllegalArgumentException.class, ()->{\n+\t\t\tjsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\t});\n+\t}\n+\n+\t/**\n+\t * Helper to create a new JSON schema with the given $id\n+\t * \n+\t * @param schema\n+\t * @return\n+\t * @throws JSONObjectAdapterException\n+\t */\n+\tJsonSchemaVersionInfo createNewSchemaVersion(String id, int index) throws JSONObjectAdapterException {\n+\t\tSchemaId schemaId = SchemaIdParser.parseSchemaId(id);\n+\t\tString organizationName = schemaId.getOrganizationName().toString();\n+\t\tString schemaName = schemaId.getSchemaName().toString();\n+\t\tString semanticVersion = null;\n+\t\tif (schemaId.getSemanticVersion() != null) {\n+\t\t\tsemanticVersion = schemaId.getSemanticVersion().toString();\n+\t\t}\n+\t\tOrganization organization = null;\n+\t\ttry {\n+\t\t\torganization = organizationDao.getOrganizationByName(organizationName);\n+\t\t} catch (NotFoundException e) {\n+\t\t\torganization = organizationDao.createOrganization(organizationName, adminUserId);\n+\t\t}\n+\t\tschema = new JsonSchema();\n+\t\tschema.set$id(id);\n+\t\tschema.setDescription(\"index:\" + index);\n+\t\treturn jsonSchemaDao.createNewSchemaVersion(\n+\t\t\t\tnew NewSchemaVersionRequest().withOrganizationId(organization.getId()).withCreatedBy(createdBy)\n+\t\t\t\t\t\t.withJsonSchema(schema).withSchemaName(schemaName).withSemanticVersion(semanticVersion));\n+\t}\n+\n+\t/**\n+\t * Helper to get the SHA-256 hex string for a given schema.\n+\t * \n+\t * @param schema\n+\t * @return\n+\t * @throws JSONObjectAdapterException\n+\t */\n+\tstatic String getSchemaSHA256Hex(JsonSchema schema) throws JSONObjectAdapterException {\n+\t\tString json = EntityFactory.createJSONStringForEntity(schema);\n+\t\treturn DigestUtils.sha256Hex(json);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetLatestVersion() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar/1.0.1\", index++);\n+\t\tJsonSchemaVersionInfo lastVersion = createNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\tcreateNewSchemaVersion(\"other.org/foo.bar\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar.other\", index++);\n+\t\t// Call under test\n+\t\tString versionId = jsonSchemaDao.getLatestVersionId(\"my.org.edu\", \"foo.bar\");\n+\t\tassertEquals(lastVersion.getVersionId(), versionId);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetLatestVersionOrganziationNotFound() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\tString message = assertThrows(NotFoundException.class, () -> {\n+\t\t\tjsonSchemaDao.getLatestVersionId(\"other.org\", \"foo.bar\");\n+\t\t}).getMessage();\n+\t\tassertEquals(\"JSON Schema not found for organizationName: 'other.org' and schemaName: 'foo.bar'\", message);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetLatestVersionSchemaNameNotFound() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\tString message = assertThrows(NotFoundException.class, () -> {\n+\t\t\tjsonSchemaDao.getLatestVersionId(\"my.org.edu\", \"other.schema.name\");\n+\t\t}).getMessage();\n+\t\tassertEquals(\"JSON Schema not found for organizationName: 'my.org.edu' and schemaName: 'other.schema.name'\",\n+\t\t\t\tmessage);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetSchemaLatestVersionNullOrganization() {\n+\t\tString organizationName = null;\n+\t\tString schemaName = \"other.schema.name\";\n+\t\tassertThrows(IllegalArgumentException.class, () -> {\n+\t\t\tjsonSchemaDao.getLatestVersionId(organizationName, schemaName);\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testGetSchemaLatestVersionNullSchema() {\n+\t\tString organizationName = \"my.org.edu\";\n+\t\tString schemaName = null;\n+\t\tassertThrows(IllegalArgumentException.class, () -> {\n+\t\t\tjsonSchemaDao.getLatestVersionId(organizationName, schemaName);\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testGetVersionId() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar/0.0.1\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\tJsonSchemaVersionInfo expected = createNewSchemaVersion(\"my.org.edu/foo.bar/1.0.1\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\tcreateNewSchemaVersion(\"other.org/foo.bar\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar.other\", index++);\n+\n+\t\tString organizationName = \"my.org.edu\";\n+\t\tString schemaName = \"foo.bar\";\n+\t\tString semanticVersion = \"1.0.1\";\n+\t\t// call under test\n+\t\tString versionId = jsonSchemaDao.getVersionId(organizationName, schemaName, semanticVersion);\n+\t\tassertNotNull(versionId);\n+\t\tassertEquals(expected.getVersionId(), versionId);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetVersionIdNotFound() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar/0.0.1\", index++);\n+\n+\t\tString organizationName = \"my.org.edu\";\n+\t\tString schemaName = \"foo.bar\";\n+\t\tString semanticVersion = \"1.0.1\";\n+\t\t// call under test\n+\t\tString message = assertThrows(NotFoundException.class, () -> {\n+\t\t\tjsonSchemaDao.getVersionId(organizationName, schemaName, semanticVersion);\n+\t\t}).getMessage();\n+\t\tassertEquals(\n+\t\t\t\t\"JSON Schema not found for organizationName: 'my.org.edu' and schemaName: 'foo.bar' and semanticVersion: '1.0.1'\",\n+\t\t\t\tmessage);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetVersionIdNullOrgName() throws JSONObjectAdapterException {\n+\t\tString organizationName = null;\n+\t\tString schemaName = \"foo.bar\";\n+\t\tString semanticVersion = \"1.0.1\";\n+\t\t// call under test\n+\t\tassertThrows(IllegalArgumentException.class, () -> {\n+\t\t\tjsonSchemaDao.getVersionId(organizationName, schemaName, semanticVersion);\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testGetVersionIdNullSchemaName() throws JSONObjectAdapterException {\n+\t\tString organizationName = \"my.org.edu\";\n+\t\tString schemaName = null;\n+\t\tString semanticVersion = \"1.0.1\";\n+\t\t// call under test\n+\t\tassertThrows(IllegalArgumentException.class, () -> {\n+\t\t\tjsonSchemaDao.getVersionId(organizationName, schemaName, semanticVersion);\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testGetVersionIdNullSemanticVersion() throws JSONObjectAdapterException {\n+\t\tString organizationName = \"my.org.edu\";\n+\t\tString schemaName = \"foo.bar\";\n+\t\tString semanticVersion = null;\n+\t\t// call under test\n+\t\tassertThrows(IllegalArgumentException.class, () -> {\n+\t\t\tjsonSchemaDao.getVersionId(organizationName, schemaName, semanticVersion);\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testGetVersionInfoTripple() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar/0.0.1\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\tJsonSchemaVersionInfo expected = createNewSchemaVersion(\"my.org.edu/foo.bar/1.0.1\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\tcreateNewSchemaVersion(\"other.org/foo.bar\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar.other\", index++);\n+\n+\t\t// call under test\n+\t\tJsonSchemaVersionInfo resultInfo = jsonSchemaDao.getVersionInfo(\"my.org.edu\", \"foo.bar\", \"1.0.1\");\n+\t\tassertEquals(expected, resultInfo);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetSchemaVersionOrganizationNotFound() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar/1.0.1\", index++);\n+\t\tString message = assertThrows(NotFoundException.class, () -> {\n+\t\t\tjsonSchemaDao.getVersionInfo(\"other.org\", \"foo.bar\", \"1.0.1\");\n+\t\t}).getMessage();\n+\t\tassertEquals(\n+\t\t\t\t\"JSON Schema not found for organizationName: 'other.org' and schemaName: 'foo.bar' and semanticVersion: '1.0.1'\",\n+\t\t\t\tmessage);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetSchemaVersionSchemaNameNotFound() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar/1.0.1\", index++);\n+\t\tassertThrows(NotFoundException.class, () -> {\n+\t\t\tjsonSchemaDao.getVersionInfo(\"my.org.edu\", \"foo.bar.bar\", \"1.0.1\");\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testGetVersionInfoWithVersionNotFound() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar/1.0.1\", index++);\n+\t\tassertThrows(NotFoundException.class, () -> {\n+\t\t\tjsonSchemaDao.getVersionInfo(\"my.org.edu\", \"foo.bar\", \"1.0.2\");\n+\t\t});", "originalCommit": "b7ab950d66569dedcb77d15bfc43d23b610e95fe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3OTgzMA==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4008#discussion_r416979830", "bodyText": "Add in a different schema (org or name) and make sure it does not get deleted (maybe with same semanticVersion)", "author": "marcomarasca", "createdAt": "2020-04-28T23:16:07Z", "path": "lib/jdomodels/src/test/java/org/sagebionetworks/repo/model/dbo/schema/JsonSchemaDaoImplTest.java", "diffHunk": "@@ -318,4 +308,532 @@ public void testGetVersionInfoNullId() {\n \t\t});\n \t}\n \n+\t@Test\n+\tpublic void testCreateNewSchemaVersion() {\n+\t\t// Call under test\n+\t\tJsonSchemaVersionInfo info = jsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\tassertNotNull(info);\n+\t\tassertEquals(organizationId, info.getOrganizationId());\n+\t\tassertEquals(organizationName, info.getOrganizationName());\n+\t\tassertNotNull(info.getSchemaId());\n+\t\tassertEquals(schemaName, info.getSchemaName());\n+\t\tassertEquals(createdBy.toString(), info.getCreatedBy());\n+\t\tassertEquals(semanticVersion, info.getSemanticVersion());\n+\t\tassertNotNull(info.getVersionId());\n+\t\tassertEquals(schemaJsonSha256Hex ,info.getJsonSHA256Hex());\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVersionSchemaNameAtLimit() {\n+\t\tString schemaName = StringUtils.repeat(\"a\", JsonSchemaDaoImpl.MAX_SCHEMA_NAME_CHARS);\n+\t\tnewSchemaVersionRequest.withSchemaName(schemaName);\n+\t\tJsonSchemaVersionInfo info = jsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\tassertNotNull(info);\n+\t\tassertEquals(schemaName, info.getSchemaName());\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVersionSchemaNameOverLimit() {\n+\t\tString schemaName = StringUtils.repeat(\"a\", JsonSchemaDaoImpl.MAX_SCHEMA_NAME_CHARS+1);\n+\t\tnewSchemaVersionRequest.withSchemaName(schemaName);\n+\t\tString message = assertThrows(IllegalArgumentException.class, ()->{\n+\t\t\tjsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\t}).getMessage();\n+\t\tassertEquals(\"Schema name must be \"+JsonSchemaDaoImpl.MAX_SCHEMA_NAME_CHARS+\" characters or less\", message);\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVersionSemanticVersionAtLimit() {\n+\t\tsemanticVersion = StringUtils.repeat(\"a\", JsonSchemaDaoImpl.MAX_SEMANTIC_VERSION_CHARS);\n+\t\tnewSchemaVersionRequest.withSemanticVersion(semanticVersion);\n+\t\tJsonSchemaVersionInfo info = jsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\tassertNotNull(info);\n+\t\tassertEquals(semanticVersion, info.getSemanticVersion());\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVersionSemanticVersionOverLimit() {\n+\t\tsemanticVersion = StringUtils.repeat(\"a\", JsonSchemaDaoImpl.MAX_SEMANTIC_VERSION_CHARS+1);\n+\t\tnewSchemaVersionRequest.withSemanticVersion(semanticVersion);\n+\t\tString message = assertThrows(IllegalArgumentException.class, ()->{\n+\t\t\tjsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\t}).getMessage();\n+\t\tassertEquals(\"Semantic version must be \"+JsonSchemaDaoImpl.MAX_SEMANTIC_VERSION_CHARS+\" characters or less\", message);\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVerionNullRequest() {\n+\t\tnewSchemaVersionRequest = null;\n+\t\tassertThrows(IllegalArgumentException.class, ()->{\n+\t\t\tjsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\t});\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVerionNullRequestNullOrganizationId() {\n+\t\tnewSchemaVersionRequest.withOrganizationId(null);\n+\t\tassertThrows(IllegalArgumentException.class, ()->{\n+\t\t\tjsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\t});\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVerionNullRequestNullSchemaName() {\n+\t\tnewSchemaVersionRequest.withSchemaName(null);\n+\t\tassertThrows(IllegalArgumentException.class, ()->{\n+\t\t\tjsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\t});\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVerionNullRequestNullCreatedBy() {\n+\t\tnewSchemaVersionRequest.withCreatedBy(null);\n+\t\tassertThrows(IllegalArgumentException.class, ()->{\n+\t\t\tjsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\t});\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVersionNullSemanticVersion() {\n+\t\tsemanticVersion = null;\n+\t\tnewSchemaVersionRequest.withSemanticVersion(semanticVersion);\n+\t\tJsonSchemaVersionInfo info = jsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\tassertNotNull(info);\n+\t\tassertEquals(semanticVersion, info.getSemanticVersion());\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVerionNullSchema() {\n+\t\tnewSchemaVersionRequest.withJsonSchema(null);\n+\t\tassertThrows(IllegalArgumentException.class, ()->{\n+\t\t\tjsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\t});\n+\t}\n+\n+\t/**\n+\t * Helper to create a new JSON schema with the given $id\n+\t * \n+\t * @param schema\n+\t * @return\n+\t * @throws JSONObjectAdapterException\n+\t */\n+\tJsonSchemaVersionInfo createNewSchemaVersion(String id, int index) throws JSONObjectAdapterException {\n+\t\tSchemaId schemaId = SchemaIdParser.parseSchemaId(id);\n+\t\tString organizationName = schemaId.getOrganizationName().toString();\n+\t\tString schemaName = schemaId.getSchemaName().toString();\n+\t\tString semanticVersion = null;\n+\t\tif (schemaId.getSemanticVersion() != null) {\n+\t\t\tsemanticVersion = schemaId.getSemanticVersion().toString();\n+\t\t}\n+\t\tOrganization organization = null;\n+\t\ttry {\n+\t\t\torganization = organizationDao.getOrganizationByName(organizationName);\n+\t\t} catch (NotFoundException e) {\n+\t\t\torganization = organizationDao.createOrganization(organizationName, adminUserId);\n+\t\t}\n+\t\tschema = new JsonSchema();\n+\t\tschema.set$id(id);\n+\t\tschema.setDescription(\"index:\" + index);\n+\t\treturn jsonSchemaDao.createNewSchemaVersion(\n+\t\t\t\tnew NewSchemaVersionRequest().withOrganizationId(organization.getId()).withCreatedBy(createdBy)\n+\t\t\t\t\t\t.withJsonSchema(schema).withSchemaName(schemaName).withSemanticVersion(semanticVersion));\n+\t}\n+\n+\t/**\n+\t * Helper to get the SHA-256 hex string for a given schema.\n+\t * \n+\t * @param schema\n+\t * @return\n+\t * @throws JSONObjectAdapterException\n+\t */\n+\tstatic String getSchemaSHA256Hex(JsonSchema schema) throws JSONObjectAdapterException {\n+\t\tString json = EntityFactory.createJSONStringForEntity(schema);\n+\t\treturn DigestUtils.sha256Hex(json);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetLatestVersion() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar/1.0.1\", index++);\n+\t\tJsonSchemaVersionInfo lastVersion = createNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\tcreateNewSchemaVersion(\"other.org/foo.bar\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar.other\", index++);\n+\t\t// Call under test\n+\t\tString versionId = jsonSchemaDao.getLatestVersionId(\"my.org.edu\", \"foo.bar\");\n+\t\tassertEquals(lastVersion.getVersionId(), versionId);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetLatestVersionOrganziationNotFound() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\tString message = assertThrows(NotFoundException.class, () -> {\n+\t\t\tjsonSchemaDao.getLatestVersionId(\"other.org\", \"foo.bar\");\n+\t\t}).getMessage();\n+\t\tassertEquals(\"JSON Schema not found for organizationName: 'other.org' and schemaName: 'foo.bar'\", message);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetLatestVersionSchemaNameNotFound() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\tString message = assertThrows(NotFoundException.class, () -> {\n+\t\t\tjsonSchemaDao.getLatestVersionId(\"my.org.edu\", \"other.schema.name\");\n+\t\t}).getMessage();\n+\t\tassertEquals(\"JSON Schema not found for organizationName: 'my.org.edu' and schemaName: 'other.schema.name'\",\n+\t\t\t\tmessage);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetSchemaLatestVersionNullOrganization() {\n+\t\tString organizationName = null;\n+\t\tString schemaName = \"other.schema.name\";\n+\t\tassertThrows(IllegalArgumentException.class, () -> {\n+\t\t\tjsonSchemaDao.getLatestVersionId(organizationName, schemaName);\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testGetSchemaLatestVersionNullSchema() {\n+\t\tString organizationName = \"my.org.edu\";\n+\t\tString schemaName = null;\n+\t\tassertThrows(IllegalArgumentException.class, () -> {\n+\t\t\tjsonSchemaDao.getLatestVersionId(organizationName, schemaName);\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testGetVersionId() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar/0.0.1\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\tJsonSchemaVersionInfo expected = createNewSchemaVersion(\"my.org.edu/foo.bar/1.0.1\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\tcreateNewSchemaVersion(\"other.org/foo.bar\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar.other\", index++);\n+\n+\t\tString organizationName = \"my.org.edu\";\n+\t\tString schemaName = \"foo.bar\";\n+\t\tString semanticVersion = \"1.0.1\";\n+\t\t// call under test\n+\t\tString versionId = jsonSchemaDao.getVersionId(organizationName, schemaName, semanticVersion);\n+\t\tassertNotNull(versionId);\n+\t\tassertEquals(expected.getVersionId(), versionId);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetVersionIdNotFound() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar/0.0.1\", index++);\n+\n+\t\tString organizationName = \"my.org.edu\";\n+\t\tString schemaName = \"foo.bar\";\n+\t\tString semanticVersion = \"1.0.1\";\n+\t\t// call under test\n+\t\tString message = assertThrows(NotFoundException.class, () -> {\n+\t\t\tjsonSchemaDao.getVersionId(organizationName, schemaName, semanticVersion);\n+\t\t}).getMessage();\n+\t\tassertEquals(\n+\t\t\t\t\"JSON Schema not found for organizationName: 'my.org.edu' and schemaName: 'foo.bar' and semanticVersion: '1.0.1'\",\n+\t\t\t\tmessage);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetVersionIdNullOrgName() throws JSONObjectAdapterException {\n+\t\tString organizationName = null;\n+\t\tString schemaName = \"foo.bar\";\n+\t\tString semanticVersion = \"1.0.1\";\n+\t\t// call under test\n+\t\tassertThrows(IllegalArgumentException.class, () -> {\n+\t\t\tjsonSchemaDao.getVersionId(organizationName, schemaName, semanticVersion);\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testGetVersionIdNullSchemaName() throws JSONObjectAdapterException {\n+\t\tString organizationName = \"my.org.edu\";\n+\t\tString schemaName = null;\n+\t\tString semanticVersion = \"1.0.1\";\n+\t\t// call under test\n+\t\tassertThrows(IllegalArgumentException.class, () -> {\n+\t\t\tjsonSchemaDao.getVersionId(organizationName, schemaName, semanticVersion);\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testGetVersionIdNullSemanticVersion() throws JSONObjectAdapterException {\n+\t\tString organizationName = \"my.org.edu\";\n+\t\tString schemaName = \"foo.bar\";\n+\t\tString semanticVersion = null;\n+\t\t// call under test\n+\t\tassertThrows(IllegalArgumentException.class, () -> {\n+\t\t\tjsonSchemaDao.getVersionId(organizationName, schemaName, semanticVersion);\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testGetVersionInfoTripple() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar/0.0.1\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\tJsonSchemaVersionInfo expected = createNewSchemaVersion(\"my.org.edu/foo.bar/1.0.1\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\tcreateNewSchemaVersion(\"other.org/foo.bar\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar.other\", index++);\n+\n+\t\t// call under test\n+\t\tJsonSchemaVersionInfo resultInfo = jsonSchemaDao.getVersionInfo(\"my.org.edu\", \"foo.bar\", \"1.0.1\");\n+\t\tassertEquals(expected, resultInfo);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetSchemaVersionOrganizationNotFound() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar/1.0.1\", index++);\n+\t\tString message = assertThrows(NotFoundException.class, () -> {\n+\t\t\tjsonSchemaDao.getVersionInfo(\"other.org\", \"foo.bar\", \"1.0.1\");\n+\t\t}).getMessage();\n+\t\tassertEquals(\n+\t\t\t\t\"JSON Schema not found for organizationName: 'other.org' and schemaName: 'foo.bar' and semanticVersion: '1.0.1'\",\n+\t\t\t\tmessage);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetSchemaVersionSchemaNameNotFound() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar/1.0.1\", index++);\n+\t\tassertThrows(NotFoundException.class, () -> {\n+\t\t\tjsonSchemaDao.getVersionInfo(\"my.org.edu\", \"foo.bar.bar\", \"1.0.1\");\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testGetVersionInfoWithVersionNotFound() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar/1.0.1\", index++);\n+\t\tassertThrows(NotFoundException.class, () -> {\n+\t\t\tjsonSchemaDao.getVersionInfo(\"my.org.edu\", \"foo.bar\", \"1.0.2\");\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testGetVersionInfoWithVersionNullOrganization() throws JSONObjectAdapterException {\n+\t\tString organizationName = null;\n+\t\tString schemaName = \"other.schema.name\";\n+\t\tString semanticVersion = \"1.0.2\";\n+\t\tassertThrows(IllegalArgumentException.class, () -> {\n+\t\t\tjsonSchemaDao.getVersionInfo(organizationName, schemaName, semanticVersion);\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testGetVersionInfoWithVersionNullSchema() throws JSONObjectAdapterException {\n+\t\tString organizationName = \"my.org.edu\";\n+\t\tString schemaName = null;\n+\t\tString semanticVersion = \"1.0.2\";\n+\t\tassertThrows(IllegalArgumentException.class, () -> {\n+\t\t\tjsonSchemaDao.getVersionInfo(organizationName, schemaName, semanticVersion);\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testGetVersionInfoWithVersionNullVersion() throws JSONObjectAdapterException {\n+\t\tString organizationName = \"my.org.edu\";\n+\t\tString schemaName = \"other.schema.name\";\n+\t\tString semanticVersion = null;\n+\t\tassertThrows(IllegalArgumentException.class, () -> {\n+\t\t\tjsonSchemaDao.getVersionInfo(organizationName, schemaName, semanticVersion);\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testDeleteSchema() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar/1.0.1\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar/1.0.2\", index++);\n+\t\tJsonSchemaVersionInfo lastInfo = createNewSchemaVersion(\"my.org.edu/foo.bar\", index++);", "originalCommit": "b7ab950d66569dedcb77d15bfc43d23b610e95fe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk4MTc1Nw==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4008#discussion_r416981757", "bodyText": "use the toDelete variable", "author": "marcomarasca", "createdAt": "2020-04-28T23:21:17Z", "path": "lib/jdomodels/src/test/java/org/sagebionetworks/repo/model/dbo/schema/JsonSchemaDaoImplTest.java", "diffHunk": "@@ -318,4 +308,532 @@ public void testGetVersionInfoNullId() {\n \t\t});\n \t}\n \n+\t@Test\n+\tpublic void testCreateNewSchemaVersion() {\n+\t\t// Call under test\n+\t\tJsonSchemaVersionInfo info = jsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\tassertNotNull(info);\n+\t\tassertEquals(organizationId, info.getOrganizationId());\n+\t\tassertEquals(organizationName, info.getOrganizationName());\n+\t\tassertNotNull(info.getSchemaId());\n+\t\tassertEquals(schemaName, info.getSchemaName());\n+\t\tassertEquals(createdBy.toString(), info.getCreatedBy());\n+\t\tassertEquals(semanticVersion, info.getSemanticVersion());\n+\t\tassertNotNull(info.getVersionId());\n+\t\tassertEquals(schemaJsonSha256Hex ,info.getJsonSHA256Hex());\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVersionSchemaNameAtLimit() {\n+\t\tString schemaName = StringUtils.repeat(\"a\", JsonSchemaDaoImpl.MAX_SCHEMA_NAME_CHARS);\n+\t\tnewSchemaVersionRequest.withSchemaName(schemaName);\n+\t\tJsonSchemaVersionInfo info = jsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\tassertNotNull(info);\n+\t\tassertEquals(schemaName, info.getSchemaName());\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVersionSchemaNameOverLimit() {\n+\t\tString schemaName = StringUtils.repeat(\"a\", JsonSchemaDaoImpl.MAX_SCHEMA_NAME_CHARS+1);\n+\t\tnewSchemaVersionRequest.withSchemaName(schemaName);\n+\t\tString message = assertThrows(IllegalArgumentException.class, ()->{\n+\t\t\tjsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\t}).getMessage();\n+\t\tassertEquals(\"Schema name must be \"+JsonSchemaDaoImpl.MAX_SCHEMA_NAME_CHARS+\" characters or less\", message);\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVersionSemanticVersionAtLimit() {\n+\t\tsemanticVersion = StringUtils.repeat(\"a\", JsonSchemaDaoImpl.MAX_SEMANTIC_VERSION_CHARS);\n+\t\tnewSchemaVersionRequest.withSemanticVersion(semanticVersion);\n+\t\tJsonSchemaVersionInfo info = jsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\tassertNotNull(info);\n+\t\tassertEquals(semanticVersion, info.getSemanticVersion());\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVersionSemanticVersionOverLimit() {\n+\t\tsemanticVersion = StringUtils.repeat(\"a\", JsonSchemaDaoImpl.MAX_SEMANTIC_VERSION_CHARS+1);\n+\t\tnewSchemaVersionRequest.withSemanticVersion(semanticVersion);\n+\t\tString message = assertThrows(IllegalArgumentException.class, ()->{\n+\t\t\tjsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\t}).getMessage();\n+\t\tassertEquals(\"Semantic version must be \"+JsonSchemaDaoImpl.MAX_SEMANTIC_VERSION_CHARS+\" characters or less\", message);\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVerionNullRequest() {\n+\t\tnewSchemaVersionRequest = null;\n+\t\tassertThrows(IllegalArgumentException.class, ()->{\n+\t\t\tjsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\t});\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVerionNullRequestNullOrganizationId() {\n+\t\tnewSchemaVersionRequest.withOrganizationId(null);\n+\t\tassertThrows(IllegalArgumentException.class, ()->{\n+\t\t\tjsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\t});\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVerionNullRequestNullSchemaName() {\n+\t\tnewSchemaVersionRequest.withSchemaName(null);\n+\t\tassertThrows(IllegalArgumentException.class, ()->{\n+\t\t\tjsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\t});\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVerionNullRequestNullCreatedBy() {\n+\t\tnewSchemaVersionRequest.withCreatedBy(null);\n+\t\tassertThrows(IllegalArgumentException.class, ()->{\n+\t\t\tjsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\t});\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVersionNullSemanticVersion() {\n+\t\tsemanticVersion = null;\n+\t\tnewSchemaVersionRequest.withSemanticVersion(semanticVersion);\n+\t\tJsonSchemaVersionInfo info = jsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\tassertNotNull(info);\n+\t\tassertEquals(semanticVersion, info.getSemanticVersion());\n+\t}\n+\t\n+\t@Test\n+\tpublic void testCreateNewSchemaVerionNullSchema() {\n+\t\tnewSchemaVersionRequest.withJsonSchema(null);\n+\t\tassertThrows(IllegalArgumentException.class, ()->{\n+\t\t\tjsonSchemaDao.createNewSchemaVersion(newSchemaVersionRequest);\n+\t\t});\n+\t}\n+\n+\t/**\n+\t * Helper to create a new JSON schema with the given $id\n+\t * \n+\t * @param schema\n+\t * @return\n+\t * @throws JSONObjectAdapterException\n+\t */\n+\tJsonSchemaVersionInfo createNewSchemaVersion(String id, int index) throws JSONObjectAdapterException {\n+\t\tSchemaId schemaId = SchemaIdParser.parseSchemaId(id);\n+\t\tString organizationName = schemaId.getOrganizationName().toString();\n+\t\tString schemaName = schemaId.getSchemaName().toString();\n+\t\tString semanticVersion = null;\n+\t\tif (schemaId.getSemanticVersion() != null) {\n+\t\t\tsemanticVersion = schemaId.getSemanticVersion().toString();\n+\t\t}\n+\t\tOrganization organization = null;\n+\t\ttry {\n+\t\t\torganization = organizationDao.getOrganizationByName(organizationName);\n+\t\t} catch (NotFoundException e) {\n+\t\t\torganization = organizationDao.createOrganization(organizationName, adminUserId);\n+\t\t}\n+\t\tschema = new JsonSchema();\n+\t\tschema.set$id(id);\n+\t\tschema.setDescription(\"index:\" + index);\n+\t\treturn jsonSchemaDao.createNewSchemaVersion(\n+\t\t\t\tnew NewSchemaVersionRequest().withOrganizationId(organization.getId()).withCreatedBy(createdBy)\n+\t\t\t\t\t\t.withJsonSchema(schema).withSchemaName(schemaName).withSemanticVersion(semanticVersion));\n+\t}\n+\n+\t/**\n+\t * Helper to get the SHA-256 hex string for a given schema.\n+\t * \n+\t * @param schema\n+\t * @return\n+\t * @throws JSONObjectAdapterException\n+\t */\n+\tstatic String getSchemaSHA256Hex(JsonSchema schema) throws JSONObjectAdapterException {\n+\t\tString json = EntityFactory.createJSONStringForEntity(schema);\n+\t\treturn DigestUtils.sha256Hex(json);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetLatestVersion() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar/1.0.1\", index++);\n+\t\tJsonSchemaVersionInfo lastVersion = createNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\tcreateNewSchemaVersion(\"other.org/foo.bar\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar.other\", index++);\n+\t\t// Call under test\n+\t\tString versionId = jsonSchemaDao.getLatestVersionId(\"my.org.edu\", \"foo.bar\");\n+\t\tassertEquals(lastVersion.getVersionId(), versionId);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetLatestVersionOrganziationNotFound() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\tString message = assertThrows(NotFoundException.class, () -> {\n+\t\t\tjsonSchemaDao.getLatestVersionId(\"other.org\", \"foo.bar\");\n+\t\t}).getMessage();\n+\t\tassertEquals(\"JSON Schema not found for organizationName: 'other.org' and schemaName: 'foo.bar'\", message);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetLatestVersionSchemaNameNotFound() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\tString message = assertThrows(NotFoundException.class, () -> {\n+\t\t\tjsonSchemaDao.getLatestVersionId(\"my.org.edu\", \"other.schema.name\");\n+\t\t}).getMessage();\n+\t\tassertEquals(\"JSON Schema not found for organizationName: 'my.org.edu' and schemaName: 'other.schema.name'\",\n+\t\t\t\tmessage);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetSchemaLatestVersionNullOrganization() {\n+\t\tString organizationName = null;\n+\t\tString schemaName = \"other.schema.name\";\n+\t\tassertThrows(IllegalArgumentException.class, () -> {\n+\t\t\tjsonSchemaDao.getLatestVersionId(organizationName, schemaName);\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testGetSchemaLatestVersionNullSchema() {\n+\t\tString organizationName = \"my.org.edu\";\n+\t\tString schemaName = null;\n+\t\tassertThrows(IllegalArgumentException.class, () -> {\n+\t\t\tjsonSchemaDao.getLatestVersionId(organizationName, schemaName);\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testGetVersionId() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar/0.0.1\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\tJsonSchemaVersionInfo expected = createNewSchemaVersion(\"my.org.edu/foo.bar/1.0.1\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\tcreateNewSchemaVersion(\"other.org/foo.bar\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar.other\", index++);\n+\n+\t\tString organizationName = \"my.org.edu\";\n+\t\tString schemaName = \"foo.bar\";\n+\t\tString semanticVersion = \"1.0.1\";\n+\t\t// call under test\n+\t\tString versionId = jsonSchemaDao.getVersionId(organizationName, schemaName, semanticVersion);\n+\t\tassertNotNull(versionId);\n+\t\tassertEquals(expected.getVersionId(), versionId);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetVersionIdNotFound() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar/0.0.1\", index++);\n+\n+\t\tString organizationName = \"my.org.edu\";\n+\t\tString schemaName = \"foo.bar\";\n+\t\tString semanticVersion = \"1.0.1\";\n+\t\t// call under test\n+\t\tString message = assertThrows(NotFoundException.class, () -> {\n+\t\t\tjsonSchemaDao.getVersionId(organizationName, schemaName, semanticVersion);\n+\t\t}).getMessage();\n+\t\tassertEquals(\n+\t\t\t\t\"JSON Schema not found for organizationName: 'my.org.edu' and schemaName: 'foo.bar' and semanticVersion: '1.0.1'\",\n+\t\t\t\tmessage);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetVersionIdNullOrgName() throws JSONObjectAdapterException {\n+\t\tString organizationName = null;\n+\t\tString schemaName = \"foo.bar\";\n+\t\tString semanticVersion = \"1.0.1\";\n+\t\t// call under test\n+\t\tassertThrows(IllegalArgumentException.class, () -> {\n+\t\t\tjsonSchemaDao.getVersionId(organizationName, schemaName, semanticVersion);\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testGetVersionIdNullSchemaName() throws JSONObjectAdapterException {\n+\t\tString organizationName = \"my.org.edu\";\n+\t\tString schemaName = null;\n+\t\tString semanticVersion = \"1.0.1\";\n+\t\t// call under test\n+\t\tassertThrows(IllegalArgumentException.class, () -> {\n+\t\t\tjsonSchemaDao.getVersionId(organizationName, schemaName, semanticVersion);\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testGetVersionIdNullSemanticVersion() throws JSONObjectAdapterException {\n+\t\tString organizationName = \"my.org.edu\";\n+\t\tString schemaName = \"foo.bar\";\n+\t\tString semanticVersion = null;\n+\t\t// call under test\n+\t\tassertThrows(IllegalArgumentException.class, () -> {\n+\t\t\tjsonSchemaDao.getVersionId(organizationName, schemaName, semanticVersion);\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testGetVersionInfoTripple() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar/0.0.1\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\tJsonSchemaVersionInfo expected = createNewSchemaVersion(\"my.org.edu/foo.bar/1.0.1\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\tcreateNewSchemaVersion(\"other.org/foo.bar\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar.other\", index++);\n+\n+\t\t// call under test\n+\t\tJsonSchemaVersionInfo resultInfo = jsonSchemaDao.getVersionInfo(\"my.org.edu\", \"foo.bar\", \"1.0.1\");\n+\t\tassertEquals(expected, resultInfo);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetSchemaVersionOrganizationNotFound() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar/1.0.1\", index++);\n+\t\tString message = assertThrows(NotFoundException.class, () -> {\n+\t\t\tjsonSchemaDao.getVersionInfo(\"other.org\", \"foo.bar\", \"1.0.1\");\n+\t\t}).getMessage();\n+\t\tassertEquals(\n+\t\t\t\t\"JSON Schema not found for organizationName: 'other.org' and schemaName: 'foo.bar' and semanticVersion: '1.0.1'\",\n+\t\t\t\tmessage);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetSchemaVersionSchemaNameNotFound() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar/1.0.1\", index++);\n+\t\tassertThrows(NotFoundException.class, () -> {\n+\t\t\tjsonSchemaDao.getVersionInfo(\"my.org.edu\", \"foo.bar.bar\", \"1.0.1\");\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testGetVersionInfoWithVersionNotFound() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar/1.0.1\", index++);\n+\t\tassertThrows(NotFoundException.class, () -> {\n+\t\t\tjsonSchemaDao.getVersionInfo(\"my.org.edu\", \"foo.bar\", \"1.0.2\");\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testGetVersionInfoWithVersionNullOrganization() throws JSONObjectAdapterException {\n+\t\tString organizationName = null;\n+\t\tString schemaName = \"other.schema.name\";\n+\t\tString semanticVersion = \"1.0.2\";\n+\t\tassertThrows(IllegalArgumentException.class, () -> {\n+\t\t\tjsonSchemaDao.getVersionInfo(organizationName, schemaName, semanticVersion);\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testGetVersionInfoWithVersionNullSchema() throws JSONObjectAdapterException {\n+\t\tString organizationName = \"my.org.edu\";\n+\t\tString schemaName = null;\n+\t\tString semanticVersion = \"1.0.2\";\n+\t\tassertThrows(IllegalArgumentException.class, () -> {\n+\t\t\tjsonSchemaDao.getVersionInfo(organizationName, schemaName, semanticVersion);\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testGetVersionInfoWithVersionNullVersion() throws JSONObjectAdapterException {\n+\t\tString organizationName = \"my.org.edu\";\n+\t\tString schemaName = \"other.schema.name\";\n+\t\tString semanticVersion = null;\n+\t\tassertThrows(IllegalArgumentException.class, () -> {\n+\t\t\tjsonSchemaDao.getVersionInfo(organizationName, schemaName, semanticVersion);\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testDeleteSchema() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar/1.0.1\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar/1.0.2\", index++);\n+\t\tJsonSchemaVersionInfo lastInfo = createNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\tString schemaName = \"foo.bar\";\n+\t\tString schemaId = jsonSchemaDao.getSchemaInfoForUpdate(lastInfo.getOrganizationId(), schemaName);\n+\t\t// call under test\n+\t\tint rowsUpdated = jsonSchemaDao.deleteSchema(schemaId);\n+\t\tassertEquals(1, rowsUpdated);\n+\t\tassertThrows(NotFoundException.class, () -> {\n+\t\t\tjsonSchemaDao.getSchemaInfoForUpdate(organizationName, schemaName);\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testDeleteSchemaNotFound() throws JSONObjectAdapterException {\n+\t\tString schemaId = \"-1\";\n+\t\t// call under test\n+\t\tint rowsUpdated = jsonSchemaDao.deleteSchema(schemaId);\n+\t\tassertEquals(0, rowsUpdated);\n+\t}\n+\n+\t@Test\n+\tpublic void testDeleteSchemaNullId() throws JSONObjectAdapterException {\n+\t\tString schemaId = null;\n+\t\tassertThrows(IllegalArgumentException.class, () -> {\n+\t\t\tjsonSchemaDao.deleteSchema(schemaId);\n+\t\t});\n+\t}\n+\t\n+\t@Test\n+\tpublic void testFindLatestVersion() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tJsonSchemaVersionInfo one = createNewSchemaVersion(\"my.org.edu/foo.bar/1.0.1\", index++);\n+\t\tJsonSchemaVersionInfo two = createNewSchemaVersion(\"my.org.edu/foo.bar/1.0.2\", index++);\n+\t\tJsonSchemaVersionInfo three = createNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\tJsonSchemaVersionInfo otherOrg = createNewSchemaVersion(\"another.org/foo.bar\", index++);\n+\t\tJsonSchemaVersionInfo otherName = createNewSchemaVersion(\"my.org.edu/other.name\", index++);\n+\t\t// Call under test\n+\t\tLong versionId = jsonSchemaDao.findLatestVersionId(one.getSchemaId());\n+\t\tassertEquals(three.getVersionId(), versionId.toString());\n+\t\t// call under test\n+\t\tversionId = jsonSchemaDao.findLatestVersionId(otherOrg.getSchemaId());\n+\t\tassertEquals(otherOrg.getVersionId(), versionId.toString());\n+\t\t// call under test\n+\t\tversionId = jsonSchemaDao.findLatestVersionId(otherName.getSchemaId());\n+\t\tassertEquals(otherName.getVersionId(), versionId.toString());\n+\t}\n+\t\n+\t@Test\n+\tpublic void testFindLatestVersionDoesNotExist() {\n+\t\tString schemaId = \"-1\";\n+\t\tLong latestVerion = jsonSchemaDao.findLatestVersionId(schemaId);\n+\t\tassertNull(latestVerion);\n+\t}\n+\t\n+\t@Test\n+\tpublic void testFindLatestVersionNullSchemaId() {\n+\t\tString schemaId = null;\n+\t\tassertThrows(IllegalArgumentException.class, ()->{\n+\t\t\tjsonSchemaDao.findLatestVersionId(schemaId);\n+\t\t});\n+\t}\n+\t\n+\t@Test\n+\tpublic void testGetSchemaIdForUpdate() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tJsonSchemaVersionInfo one = createNewSchemaVersion(\"my.org.edu/foo.bar/1.0.1\", index++);\n+\t\t// call under test\n+\t\tString schemaId = jsonSchemaDao.getSchemaIdForUpdate(one.getVersionId());\n+\t\tassertEquals(one.getSchemaId(), schemaId);\n+\t}\n+\t\n+\t@Test\n+\tpublic void testGetSchemaIdForUpdateNotFound() throws JSONObjectAdapterException {\n+\t\tString versionId = \"-1\";\n+\t\tString message = assertThrows(NotFoundException.class, ()->{\n+\t\t\tjsonSchemaDao.getSchemaIdForUpdate(versionId);\n+\t\t}).getMessage();\n+\t\tassertEquals(\"JSON schema not found for versionId: -1\", message);\n+\t}\n+\n+\t@Test\n+\tpublic void testDeleteVersionNotLatest() throws JSONObjectAdapterException {\n+\t\tint index = 0;\n+\t\tJsonSchemaVersionInfo stillExists = createNewSchemaVersion(\"my.org.edu/foo.bar/1.0.1\", index++);\n+\t\tJsonSchemaVersionInfo toDelete = createNewSchemaVersion(\"my.org.edu/foo.bar/1.0.2\", index++);\n+\t\tcreateNewSchemaVersion(\"my.org.edu/foo.bar\", index++);\n+\t\t// call under test\n+\t\tjsonSchemaDao.deleteSchemaVersion(toDelete.getVersionId());\n+\t\tassertThrows(NotFoundException.class, () -> {\n+\t\t\tjsonSchemaDao.getVersionInfo(\"my.org.edu\", \"foo.bar\", \"1.0.2\");", "originalCommit": "b7ab950d66569dedcb77d15bfc43d23b610e95fe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}