{"pr_number": 4145, "pr_title": "Plfm 6326", "pr_createdAt": "2020-07-24T00:06:26Z", "pr_url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4145", "timeline": [{"oid": "ee94adc30e3e9269b0fcc409f5ac561b690d49e2", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/ee94adc30e3e9269b0fcc409f5ac561b690d49e2", "message": "code review changes", "committedDate": "2020-07-16T18:36:15Z", "type": "commit"}, {"oid": "1536bd1b763cb5ba6b66481579f903e7199113d8", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/1536bd1b763cb5ba6b66481579f903e7199113d8", "message": "support for accepting and returning a JSONObject in the web services", "committedDate": "2020-07-18T02:10:46Z", "type": "commit"}, {"oid": "f14c307c9d636e36cdbfa2a7320a9aa952d58348", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/f14c307c9d636e36cdbfa2a7320a9aa952d58348", "message": "before node refactor", "committedDate": "2020-07-21T17:42:30Z", "type": "commit"}, {"oid": "f6c6e4084907f27e30b0802f573cab19fa990e70", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/f6c6e4084907f27e30b0802f573cab19fa990e70", "message": "using a translator", "committedDate": "2020-07-22T03:25:08Z", "type": "commit"}, {"oid": "81324d508333354a75216f0901583fb147fcc12a", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/81324d508333354a75216f0901583fb147fcc12a", "message": "still not perfect", "committedDate": "2020-07-23T03:48:54Z", "type": "commit"}, {"oid": "f1c6f418ca1fc949ee057ebdbb76a3181e7b0cdd", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/f1c6f418ca1fc949ee057ebdbb76a3181e7b0cdd", "message": "finished tests for AnnotationsTranslator", "committedDate": "2020-07-24T00:04:40Z", "type": "commit"}, {"oid": "5ff83b50c7aed128bd88fe329aa686e2a7d0e16d", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/5ff83b50c7aed128bd88fe329aa686e2a7d0e16d", "message": "entity manager unit tests and fixed integration test", "committedDate": "2020-07-24T02:14:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDIzODAxMw==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4145#discussion_r460238013", "bodyText": "Can remove this", "author": "marcomarasca", "createdAt": "2020-07-24T19:08:09Z", "path": "integration-test/src/test/java/org/sagebionetworks/ITJsonSchemaControllerTest.java", "diffHunk": "@@ -378,6 +382,38 @@ public void bindSchemaToEntity() throws Exception {\n \t\t\tsynapse.getJsonSchemaBindingForEntity(folderId);\n \t\t});\n \t}\n+\t\n+\t@Test\n+\tpublic void testGetEntityJson() throws SynapseException {\n+\t\tproject = new Project();\n+\t\tproject = synapse.createEntity(project);\n+\t\t// Call under test\n+\t\tJSONObject projectJSON = synapse.getEntityJson(project.getId());\n+\t\tassertNotNull(projectJSON);\n+\t\tassertEquals(project.getName(), projectJSON.get(\"name\"));\n+\t\tassertEquals(project.getId(), projectJSON.get(\"id\"));\n+\t}\n+\t\n+\t@Test\n+\tpublic void testUpdateEntityJson() throws SynapseException {\n+\t\tproject = new Project();\n+\t\tproject = synapse.createEntity(project);\n+\t\tJSONObject projectJSON = synapse.getEntityJson(project.getId());\n+\t\tassertNotNull(projectJSON);\n+\t\tprojectJSON.put(\"sample\", \"some value\");\n+\t\t// call under test\n+\t\tJSONObject updatedJson = synapse.updateEntityJson(project.getId(), projectJSON);\n+\t\tassertEquals(\"some value\", updatedJson.getString(\"sample\"));\n+\t\tSystem.out.println(projectJSON.toString(5));", "originalCommit": "5ff83b50c7aed128bd88fe329aa686e2a7d0e16d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI0NTM5MA==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4145#discussion_r460245390", "bodyText": "Might be worth to add a comment that auth checks are done downstream", "author": "marcomarasca", "createdAt": "2020-07-24T19:24:27Z", "path": "services/repository-managers/src/main/java/org/sagebionetworks/repo/manager/EntityManagerImpl.java", "diffHunk": "@@ -559,4 +580,40 @@ public void clearBoundSchema(UserInfo userInfo, String id) {\n \t\tentityPermissionsManager.hasAccess(id, ACCESS_TYPE.DELETE, userInfo).checkAuthorizationOrElseThrow();\n \t\tjsonSchemaManager.clearBoundSchema(KeyFactory.stringToKey(id), BoundObjectType.entity);\n \t}\n+\n+\t@Override\n+\tpublic JSONObject getEntityJson(UserInfo userInfo, String entityId) {\n+\t\tValidateArgument.required(userInfo, \"userInfo\");\n+\t\tValidateArgument.required(entityId, \"entityId\");\n+\t\tentityPermissionsManager.hasAccess(entityId, ACCESS_TYPE.READ, userInfo).checkAuthorizationOrElseThrow();\n+\t\treturn getEntityJson(entityId);\n+\t}\n+\t\n+\t@Override\n+\tpublic JSONObject getEntityJson(String entityId) {\n+\t\treturn getEntityJsonSubject(entityId).toJson();\n+\t}\n+\n+\t@Override\n+\tpublic JSONObject updateEntityJson(UserInfo userInfo, String entityId, JSONObject jsonObject) {\n+\t\tValidateArgument.required(userInfo, \"userInfo\");\n+\t\tValidateArgument.required(entityId, \"entityId\");\n+\t\tValidateArgument.required(jsonObject, \"jsonObject\");\n+\t\tEntityType type = nodeManager.getNodeType(userInfo, entityId);", "originalCommit": "5ff83b50c7aed128bd88fe329aa686e2a7d0e16d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI1MjI2OA==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4145#discussion_r460252268", "bodyText": "Potential null pointer (double check)", "author": "marcomarasca", "createdAt": "2020-07-24T19:39:49Z", "path": "services/repository-managers/src/main/java/org/sagebionetworks/repo/manager/schema/AnnotationsTranslatorImpl.java", "diffHunk": "@@ -0,0 +1,379 @@\n+package org.sagebionetworks.repo.manager.schema;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.sagebionetworks.repo.model.Entity;\n+import org.sagebionetworks.repo.model.annotation.v2.Annotations;\n+import org.sagebionetworks.repo.model.annotation.v2.AnnotationsValue;\n+import org.sagebionetworks.repo.model.annotation.v2.AnnotationsValueType;\n+import org.sagebionetworks.schema.FORMAT;\n+import org.sagebionetworks.schema.adapter.JSONObjectAdapterException;\n+import org.sagebionetworks.schema.adapter.org.json.JSONObjectAdapterImpl;\n+import org.sagebionetworks.schema.adapter.org.json.JsonDateUtils;\n+import org.sagebionetworks.util.ValidateArgument;\n+import org.springframework.stereotype.Service;\n+\n+import com.google.common.collect.Lists;\n+\n+@Service\n+public class AnnotationsTranslatorImpl implements AnnotationsTranslator {\n+\n+\tprivate static final String ID = \"id\";\n+\tprivate static final String ETAG = \"etag\";\n+\tpublic static final String CONCRETE_TYPE = \"concreteType\";\n+\n+\t@Override\n+\tpublic JSONObject writeToJsonObject(Entity entity, Annotations annotations) {\n+\t\tValidateArgument.required(entity, \"entity\");\n+\t\tValidateArgument.required(annotations, \"annotations\");\n+\t\tJSONObject jsonObject = new JSONObject();\n+\t\twriteAnnotationsToJSONObject(annotations, jsonObject);\n+\t\tJSONObjectAdapterImpl adapter = new JSONObjectAdapterImpl(jsonObject);\n+\t\ttry {\n+\t\t\t// write the entity second to override any conflicts.\n+\t\t\tentity.writeToJSONObject(adapter);\n+\t\t} catch (JSONObjectAdapterException e) {\n+\t\t\tthrow new IllegalStateException(e);\n+\t\t}\n+\t\treturn jsonObject;\n+\t}\n+\n+\t@Override\n+\tpublic Annotations readFromJsonObject(Class<? extends Entity> entityClass, JSONObject jsonObject) {\n+\t\tValidateArgument.required(entityClass, \"entity\");\n+\t\tValidateArgument.required(jsonObject, \"jsonObject\");\n+\t\tvalidateHasKeys(Lists.newArrayList(ID, ETAG, CONCRETE_TYPE), jsonObject);\n+\t\tString entityId = jsonObject.getString(ID);\n+\t\tif (!entityClass.getName().equals(jsonObject.get(CONCRETE_TYPE))) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t\"The value of 'concreteType' does not match the type of Entity: '\" + entityId + \"'\");\n+\t\t}\n+\t\tAnnotations annotations = new Annotations();\n+\t\tannotations.setId(entityId);\n+\t\tannotations.setEtag(jsonObject.getString(ETAG));\n+\t\tMap<String, AnnotationsValue> map = new LinkedHashMap<String, AnnotationsValue>();\n+\t\tannotations.setAnnotations(map);\n+\t\tjsonObject.keySet().stream().filter(key -> canUseKey(entityClass, key)).forEach((key) -> {\n+\t\t\tAnnotationsValue annValue = getAnnotationValueFromJsonObject(key, jsonObject);\n+\t\t\tmap.put(key, annValue);\n+\t\t});\n+\t\treturn annotations;\n+\t}\n+\n+\tvoid validateHasKeys(List<String> expectedKeys, JSONObject jsonObject) {\n+\t\tfor (String expectedKey : expectedKeys) {\n+\t\t\tif (!jsonObject.has(expectedKey)) {\n+\t\t\t\tthrow new IllegalArgumentException(\"Expected JSON to include key: '\" + expectedKey + \"'\");\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Read a single AnnotationValue for the given key from the given JSONObject.\n+\t * \n+\t * @param key\n+\t * @param jsonObject\n+\t * @return\n+\t */\n+\tAnnotationsValue getAnnotationValueFromJsonObject(String key, JSONObject jsonObject) {\n+\t\treturn Stream.of(attemptToReadAsJSONArray(key, jsonObject), attemptToReadAsDouble(key, jsonObject),\n+\t\t\t\tattemptToReadAsTimestamp(key, jsonObject), attemptToReadAsLong(key, jsonObject),\n+\t\t\t\tattemptToReadAsString(key, jsonObject)).filter(Optional::isPresent).findFirst().get().get();\n+\t}\n+\n+\t/**\n+\t * Attempt to read the value for the given key as a string. Note: This should\n+\t * always work as any type can be read as a string.\n+\t * \n+\t * @param key\n+\t * @param jsonObject\n+\t * @return\n+\t */\n+\tOptional<AnnotationsValue> attemptToReadAsString(String key, JSONObject jsonObject) {\n+\t\ttry {\n+\t\t\tString value = jsonObject.getString(key);\n+\t\t\tAnnotationsValue annValue = new AnnotationsValue();\n+\t\t\tannValue.setType(AnnotationsValueType.STRING);\n+\t\t\tannValue.setValue(java.util.Collections.singletonList(value));\n+\t\t\treturn Optional.of(annValue);\n+\t\t} catch (JSONException e) {\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Attempt to read the value from the given key as a DATE_TIME formated string.\n+\t * An empty Optional will be returned if the value is not a DATE_TIME formated\n+\t * string.\n+\t * \n+\t * @param key\n+\t * @param jsonObject\n+\t * @return\n+\t */\n+\tOptional<AnnotationsValue> attemptToReadAsTimestamp(String key, JSONObject jsonObject) {\n+\t\ttry {\n+\t\t\tString value = jsonObject.getString(key);\n+\t\t\tlong timeMS = JsonDateUtils.convertStringToDate(FORMAT.DATE_TIME, value).getTime();\n+\t\t\tAnnotationsValue annValue = new AnnotationsValue();\n+\t\t\tannValue.setType(AnnotationsValueType.TIMESTAMP_MS);\n+\t\t\tannValue.setValue(java.util.Collections.singletonList(Long.toString(timeMS)));\n+\t\t\treturn Optional.of(annValue);\n+\t\t} catch (IllegalArgumentException e) {\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Attempt to read the value at the given index as a string. Note: This should\n+\t * always work as any type can be read as a string.\n+\t * \n+\t * @param index\n+\t * @param array\n+\t * @return\n+\t */\n+\tOptional<ListValue> attemptToReadAsString(int index, JSONArray array) {\n+\t\ttry {\n+\t\t\tString value = array.getString(index);\n+\t\t\treturn Optional.of(new ListValue(AnnotationsValueType.STRING, value));\n+\t\t} catch (JSONException e) {\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Attempt to read the value at the given index as a DATE_TIME formated string.\n+\t * If the value is not a DATE_TIME formated string an empty optional will be\n+\t * returned.\n+\t * \n+\t * @param index\n+\t * @param array\n+\t * @return\n+\t */\n+\tOptional<ListValue> attemptToReadAsTimestamp(int index, JSONArray array) {\n+\t\ttry {\n+\t\t\tString value = array.getString(index);\n+\t\t\tlong timeMS = JsonDateUtils.convertStringToDate(FORMAT.DATE_TIME, value).getTime();\n+\t\t\treturn Optional.of(new ListValue(AnnotationsValueType.TIMESTAMP_MS, Long.toString(timeMS)));\n+\t\t} catch (IllegalArgumentException e) {\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Attempt to read the value for the given key as a double. If the value is not\n+\t * a double an empty optional will be returned.\n+\t * \n+\t * @param key\n+\t * @param jsonObject\n+\t * @return\n+\t */\n+\tOptional<AnnotationsValue> attemptToReadAsDouble(String key, JSONObject jsonObject) {\n+\t\ttry {\n+\t\t\tDouble value = jsonObject.getDouble(key);\n+\t\t\tString testString = jsonObject.getString(key);\n+\t\t\tif (!testString.equals(value.toString())) {\n+\t\t\t\t// data loss\n+\t\t\t\treturn Optional.empty();\n+\t\t\t}\n+\t\t\tAnnotationsValue annValue = new AnnotationsValue();\n+\t\t\tannValue.setType(AnnotationsValueType.DOUBLE);\n+\t\t\tannValue.setValue(java.util.Collections.singletonList(value.toString()));\n+\t\t\treturn Optional.of(annValue);\n+\t\t} catch (JSONException e) {\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Attempt to read the value for the given index as a double. If the value is\n+\t * not a double an empty optional will be returned.\n+\t * \n+\t * @param index\n+\t * @param array\n+\t * @return\n+\t */\n+\tOptional<ListValue> attemptToReadAsDouble(int index, JSONArray array) {\n+\t\ttry {\n+\t\t\tDouble value = array.getDouble(index);\n+\t\t\tString testString = array.getString(index);\n+\t\t\tif (!testString.equals(value.toString())) {\n+\t\t\t\t// data loss\n+\t\t\t\treturn Optional.empty();\n+\t\t\t}\n+\t\t\treturn Optional.of(new ListValue(AnnotationsValueType.DOUBLE, value.toString()));\n+\t\t} catch (JSONException e) {\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Attempt to read the value for the given key as a long. If the value is not a\n+\t * long an empty optional will be returned.\n+\t * \n+\t * @param key\n+\t * @param jsonObject\n+\t * @return\n+\t */\n+\tOptional<AnnotationsValue> attemptToReadAsLong(String key, JSONObject jsonObject) {\n+\t\ttry {\n+\t\t\tLong value = jsonObject.getLong(key);\n+\t\t\tAnnotationsValue annValue = new AnnotationsValue();\n+\t\t\tannValue.setType(AnnotationsValueType.LONG);\n+\t\t\tannValue.setValue(java.util.Collections.singletonList(value.toString()));\n+\t\t\treturn Optional.of(annValue);\n+\t\t} catch (JSONException e) {\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Attempt to read the value at the given index as a long. If the value is not a\n+\t * long an empty optional will be returned.\n+\t * \n+\t * @param index\n+\t * @param array\n+\t * @return\n+\t */\n+\tOptional<ListValue> attemptToReadAsLong(int index, JSONArray array) {\n+\t\ttry {\n+\t\t\tLong value = array.getLong(index);\n+\t\t\treturn Optional.of(new ListValue(AnnotationsValueType.LONG, value.toString()));\n+\t\t} catch (JSONException e) {\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Attempt to read the value for the given key as a JSONArray. If the value is\n+\t * not a JSONArray an empty optional will be returned.\n+\t * \n+\t * @param key\n+\t * @param jsonObject\n+\t * @return\n+\t */\n+\tOptional<AnnotationsValue> attemptToReadAsJSONArray(String key, JSONObject jsonObject) {\n+\t\ttry {\n+\t\t\tJSONArray array = jsonObject.getJSONArray(key);\n+\t\t\tList<String> valueList = new ArrayList<String>(array.length());\n+\t\t\tAnnotationsValueType lastType = null;\n+\t\t\tfor (int i = 0; i < array.length(); i++) {\n+\t\t\t\tListValue listValue = Stream\n+\t\t\t\t\t\t.of(attemptToReadAsDouble(i, array), attemptToReadAsTimestamp(i, array),\n+\t\t\t\t\t\t\t\tattemptToReadAsLong(i, array), attemptToReadAsString(i, array))\n+\t\t\t\t\t\t.filter(Optional::isPresent).findFirst().get().get();\n+\t\t\t\tif (lastType != null && !lastType.equals(listValue.getType())) {\n+\t\t\t\t\tthrow new IllegalArgumentException(\"List of mixed types found for key: '\" + key + \"'\");\n+\t\t\t\t}\n+\t\t\t\tlastType = listValue.getType();\n+\t\t\t\tvalueList.add(listValue.getValue());\n+\t\t\t}\n+\t\t\tAnnotationsValue annValue = new AnnotationsValue();\n+\t\t\tannValue.setType(lastType);\n+\t\t\tannValue.setValue(valueList);\n+\t\t\treturn Optional.of(annValue);\n+\t\t} catch (JSONException e) {\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Field names of an Entity cannot be used as annotation keys. All other keys\n+\t * are valid.\n+\t * \n+\t * @param clazz\n+\t * @param key\n+\t * @return\n+\t */\n+\tpublic static boolean canUseKey(Class clazz, String key) {\n+\t\ttry {\n+\t\t\tclazz.getDeclaredField(key);\n+\t\t\treturn false;\n+\t\t} catch (NoSuchFieldException e) {\n+\t\t\treturn true;\n+\t\t} catch (SecurityException e) {\n+\t\t\tthrow new RuntimeException(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Write the provided annotations to the provided JSONObject. Note: The\n+\t * resulting JSON format is not the same as the format used to write Annotations\n+\t * in API requests.\n+\t * \n+\t * @param toWrite\n+\t * @param jsonObject\n+\t */\n+\tvoid writeAnnotationsToJSONObject(Annotations toWrite, JSONObject jsonObject) {\n+\t\tfor (Entry<String, AnnotationsValue> entry : toWrite.getAnnotations().entrySet()) {\n+\t\t\twriteAnnotationValue(entry.getKey(), entry.getValue(), jsonObject);\n+\t\t}\n+\t}\n+\n+\tvoid writeAnnotationValue(String key, AnnotationsValue value, JSONObject jsonObject) {\n+\t\tif (value.getValue() != null) {", "originalCommit": "5ff83b50c7aed128bd88fe329aa686e2a7d0e16d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI1NjYwNA==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4145#discussion_r460256604", "bodyText": "We can extract the logic to translate the \"String value\" to a JSON String value by type, having a single toJsonValue(AnnotationValueType type, String value) that can be reused for both the single and multiple case.", "author": "marcomarasca", "createdAt": "2020-07-24T19:49:44Z", "path": "services/repository-managers/src/main/java/org/sagebionetworks/repo/manager/schema/AnnotationsTranslatorImpl.java", "diffHunk": "@@ -0,0 +1,379 @@\n+package org.sagebionetworks.repo.manager.schema;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.sagebionetworks.repo.model.Entity;\n+import org.sagebionetworks.repo.model.annotation.v2.Annotations;\n+import org.sagebionetworks.repo.model.annotation.v2.AnnotationsValue;\n+import org.sagebionetworks.repo.model.annotation.v2.AnnotationsValueType;\n+import org.sagebionetworks.schema.FORMAT;\n+import org.sagebionetworks.schema.adapter.JSONObjectAdapterException;\n+import org.sagebionetworks.schema.adapter.org.json.JSONObjectAdapterImpl;\n+import org.sagebionetworks.schema.adapter.org.json.JsonDateUtils;\n+import org.sagebionetworks.util.ValidateArgument;\n+import org.springframework.stereotype.Service;\n+\n+import com.google.common.collect.Lists;\n+\n+@Service\n+public class AnnotationsTranslatorImpl implements AnnotationsTranslator {\n+\n+\tprivate static final String ID = \"id\";\n+\tprivate static final String ETAG = \"etag\";\n+\tpublic static final String CONCRETE_TYPE = \"concreteType\";\n+\n+\t@Override\n+\tpublic JSONObject writeToJsonObject(Entity entity, Annotations annotations) {\n+\t\tValidateArgument.required(entity, \"entity\");\n+\t\tValidateArgument.required(annotations, \"annotations\");\n+\t\tJSONObject jsonObject = new JSONObject();\n+\t\twriteAnnotationsToJSONObject(annotations, jsonObject);\n+\t\tJSONObjectAdapterImpl adapter = new JSONObjectAdapterImpl(jsonObject);\n+\t\ttry {\n+\t\t\t// write the entity second to override any conflicts.\n+\t\t\tentity.writeToJSONObject(adapter);\n+\t\t} catch (JSONObjectAdapterException e) {\n+\t\t\tthrow new IllegalStateException(e);\n+\t\t}\n+\t\treturn jsonObject;\n+\t}\n+\n+\t@Override\n+\tpublic Annotations readFromJsonObject(Class<? extends Entity> entityClass, JSONObject jsonObject) {\n+\t\tValidateArgument.required(entityClass, \"entity\");\n+\t\tValidateArgument.required(jsonObject, \"jsonObject\");\n+\t\tvalidateHasKeys(Lists.newArrayList(ID, ETAG, CONCRETE_TYPE), jsonObject);\n+\t\tString entityId = jsonObject.getString(ID);\n+\t\tif (!entityClass.getName().equals(jsonObject.get(CONCRETE_TYPE))) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t\"The value of 'concreteType' does not match the type of Entity: '\" + entityId + \"'\");\n+\t\t}\n+\t\tAnnotations annotations = new Annotations();\n+\t\tannotations.setId(entityId);\n+\t\tannotations.setEtag(jsonObject.getString(ETAG));\n+\t\tMap<String, AnnotationsValue> map = new LinkedHashMap<String, AnnotationsValue>();\n+\t\tannotations.setAnnotations(map);\n+\t\tjsonObject.keySet().stream().filter(key -> canUseKey(entityClass, key)).forEach((key) -> {\n+\t\t\tAnnotationsValue annValue = getAnnotationValueFromJsonObject(key, jsonObject);\n+\t\t\tmap.put(key, annValue);\n+\t\t});\n+\t\treturn annotations;\n+\t}\n+\n+\tvoid validateHasKeys(List<String> expectedKeys, JSONObject jsonObject) {\n+\t\tfor (String expectedKey : expectedKeys) {\n+\t\t\tif (!jsonObject.has(expectedKey)) {\n+\t\t\t\tthrow new IllegalArgumentException(\"Expected JSON to include key: '\" + expectedKey + \"'\");\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Read a single AnnotationValue for the given key from the given JSONObject.\n+\t * \n+\t * @param key\n+\t * @param jsonObject\n+\t * @return\n+\t */\n+\tAnnotationsValue getAnnotationValueFromJsonObject(String key, JSONObject jsonObject) {\n+\t\treturn Stream.of(attemptToReadAsJSONArray(key, jsonObject), attemptToReadAsDouble(key, jsonObject),\n+\t\t\t\tattemptToReadAsTimestamp(key, jsonObject), attemptToReadAsLong(key, jsonObject),\n+\t\t\t\tattemptToReadAsString(key, jsonObject)).filter(Optional::isPresent).findFirst().get().get();\n+\t}\n+\n+\t/**\n+\t * Attempt to read the value for the given key as a string. Note: This should\n+\t * always work as any type can be read as a string.\n+\t * \n+\t * @param key\n+\t * @param jsonObject\n+\t * @return\n+\t */\n+\tOptional<AnnotationsValue> attemptToReadAsString(String key, JSONObject jsonObject) {\n+\t\ttry {\n+\t\t\tString value = jsonObject.getString(key);\n+\t\t\tAnnotationsValue annValue = new AnnotationsValue();\n+\t\t\tannValue.setType(AnnotationsValueType.STRING);\n+\t\t\tannValue.setValue(java.util.Collections.singletonList(value));\n+\t\t\treturn Optional.of(annValue);\n+\t\t} catch (JSONException e) {\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Attempt to read the value from the given key as a DATE_TIME formated string.\n+\t * An empty Optional will be returned if the value is not a DATE_TIME formated\n+\t * string.\n+\t * \n+\t * @param key\n+\t * @param jsonObject\n+\t * @return\n+\t */\n+\tOptional<AnnotationsValue> attemptToReadAsTimestamp(String key, JSONObject jsonObject) {\n+\t\ttry {\n+\t\t\tString value = jsonObject.getString(key);\n+\t\t\tlong timeMS = JsonDateUtils.convertStringToDate(FORMAT.DATE_TIME, value).getTime();\n+\t\t\tAnnotationsValue annValue = new AnnotationsValue();\n+\t\t\tannValue.setType(AnnotationsValueType.TIMESTAMP_MS);\n+\t\t\tannValue.setValue(java.util.Collections.singletonList(Long.toString(timeMS)));\n+\t\t\treturn Optional.of(annValue);\n+\t\t} catch (IllegalArgumentException e) {\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Attempt to read the value at the given index as a string. Note: This should\n+\t * always work as any type can be read as a string.\n+\t * \n+\t * @param index\n+\t * @param array\n+\t * @return\n+\t */\n+\tOptional<ListValue> attemptToReadAsString(int index, JSONArray array) {\n+\t\ttry {\n+\t\t\tString value = array.getString(index);\n+\t\t\treturn Optional.of(new ListValue(AnnotationsValueType.STRING, value));\n+\t\t} catch (JSONException e) {\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Attempt to read the value at the given index as a DATE_TIME formated string.\n+\t * If the value is not a DATE_TIME formated string an empty optional will be\n+\t * returned.\n+\t * \n+\t * @param index\n+\t * @param array\n+\t * @return\n+\t */\n+\tOptional<ListValue> attemptToReadAsTimestamp(int index, JSONArray array) {\n+\t\ttry {\n+\t\t\tString value = array.getString(index);\n+\t\t\tlong timeMS = JsonDateUtils.convertStringToDate(FORMAT.DATE_TIME, value).getTime();\n+\t\t\treturn Optional.of(new ListValue(AnnotationsValueType.TIMESTAMP_MS, Long.toString(timeMS)));\n+\t\t} catch (IllegalArgumentException e) {\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Attempt to read the value for the given key as a double. If the value is not\n+\t * a double an empty optional will be returned.\n+\t * \n+\t * @param key\n+\t * @param jsonObject\n+\t * @return\n+\t */\n+\tOptional<AnnotationsValue> attemptToReadAsDouble(String key, JSONObject jsonObject) {\n+\t\ttry {\n+\t\t\tDouble value = jsonObject.getDouble(key);\n+\t\t\tString testString = jsonObject.getString(key);\n+\t\t\tif (!testString.equals(value.toString())) {\n+\t\t\t\t// data loss\n+\t\t\t\treturn Optional.empty();\n+\t\t\t}\n+\t\t\tAnnotationsValue annValue = new AnnotationsValue();\n+\t\t\tannValue.setType(AnnotationsValueType.DOUBLE);\n+\t\t\tannValue.setValue(java.util.Collections.singletonList(value.toString()));\n+\t\t\treturn Optional.of(annValue);\n+\t\t} catch (JSONException e) {\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Attempt to read the value for the given index as a double. If the value is\n+\t * not a double an empty optional will be returned.\n+\t * \n+\t * @param index\n+\t * @param array\n+\t * @return\n+\t */\n+\tOptional<ListValue> attemptToReadAsDouble(int index, JSONArray array) {\n+\t\ttry {\n+\t\t\tDouble value = array.getDouble(index);\n+\t\t\tString testString = array.getString(index);\n+\t\t\tif (!testString.equals(value.toString())) {\n+\t\t\t\t// data loss\n+\t\t\t\treturn Optional.empty();\n+\t\t\t}\n+\t\t\treturn Optional.of(new ListValue(AnnotationsValueType.DOUBLE, value.toString()));\n+\t\t} catch (JSONException e) {\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Attempt to read the value for the given key as a long. If the value is not a\n+\t * long an empty optional will be returned.\n+\t * \n+\t * @param key\n+\t * @param jsonObject\n+\t * @return\n+\t */\n+\tOptional<AnnotationsValue> attemptToReadAsLong(String key, JSONObject jsonObject) {\n+\t\ttry {\n+\t\t\tLong value = jsonObject.getLong(key);\n+\t\t\tAnnotationsValue annValue = new AnnotationsValue();\n+\t\t\tannValue.setType(AnnotationsValueType.LONG);\n+\t\t\tannValue.setValue(java.util.Collections.singletonList(value.toString()));\n+\t\t\treturn Optional.of(annValue);\n+\t\t} catch (JSONException e) {\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Attempt to read the value at the given index as a long. If the value is not a\n+\t * long an empty optional will be returned.\n+\t * \n+\t * @param index\n+\t * @param array\n+\t * @return\n+\t */\n+\tOptional<ListValue> attemptToReadAsLong(int index, JSONArray array) {\n+\t\ttry {\n+\t\t\tLong value = array.getLong(index);\n+\t\t\treturn Optional.of(new ListValue(AnnotationsValueType.LONG, value.toString()));\n+\t\t} catch (JSONException e) {\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Attempt to read the value for the given key as a JSONArray. If the value is\n+\t * not a JSONArray an empty optional will be returned.\n+\t * \n+\t * @param key\n+\t * @param jsonObject\n+\t * @return\n+\t */\n+\tOptional<AnnotationsValue> attemptToReadAsJSONArray(String key, JSONObject jsonObject) {\n+\t\ttry {\n+\t\t\tJSONArray array = jsonObject.getJSONArray(key);\n+\t\t\tList<String> valueList = new ArrayList<String>(array.length());\n+\t\t\tAnnotationsValueType lastType = null;\n+\t\t\tfor (int i = 0; i < array.length(); i++) {\n+\t\t\t\tListValue listValue = Stream\n+\t\t\t\t\t\t.of(attemptToReadAsDouble(i, array), attemptToReadAsTimestamp(i, array),\n+\t\t\t\t\t\t\t\tattemptToReadAsLong(i, array), attemptToReadAsString(i, array))\n+\t\t\t\t\t\t.filter(Optional::isPresent).findFirst().get().get();\n+\t\t\t\tif (lastType != null && !lastType.equals(listValue.getType())) {\n+\t\t\t\t\tthrow new IllegalArgumentException(\"List of mixed types found for key: '\" + key + \"'\");\n+\t\t\t\t}\n+\t\t\t\tlastType = listValue.getType();\n+\t\t\t\tvalueList.add(listValue.getValue());\n+\t\t\t}\n+\t\t\tAnnotationsValue annValue = new AnnotationsValue();\n+\t\t\tannValue.setType(lastType);\n+\t\t\tannValue.setValue(valueList);\n+\t\t\treturn Optional.of(annValue);\n+\t\t} catch (JSONException e) {\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Field names of an Entity cannot be used as annotation keys. All other keys\n+\t * are valid.\n+\t * \n+\t * @param clazz\n+\t * @param key\n+\t * @return\n+\t */\n+\tpublic static boolean canUseKey(Class clazz, String key) {\n+\t\ttry {\n+\t\t\tclazz.getDeclaredField(key);\n+\t\t\treturn false;\n+\t\t} catch (NoSuchFieldException e) {\n+\t\t\treturn true;\n+\t\t} catch (SecurityException e) {\n+\t\t\tthrow new RuntimeException(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Write the provided annotations to the provided JSONObject. Note: The\n+\t * resulting JSON format is not the same as the format used to write Annotations\n+\t * in API requests.\n+\t * \n+\t * @param toWrite\n+\t * @param jsonObject\n+\t */\n+\tvoid writeAnnotationsToJSONObject(Annotations toWrite, JSONObject jsonObject) {\n+\t\tfor (Entry<String, AnnotationsValue> entry : toWrite.getAnnotations().entrySet()) {\n+\t\t\twriteAnnotationValue(entry.getKey(), entry.getValue(), jsonObject);\n+\t\t}\n+\t}\n+\n+\tvoid writeAnnotationValue(String key, AnnotationsValue value, JSONObject jsonObject) {\n+\t\tif (value.getValue() != null) {\n+\t\t\tif (value.getValue().size() > 1) {\n+\t\t\t\twriteAnnotationValueList(key, value.getType(), value.getValue(), jsonObject);\n+\t\t\t} else {\n+\t\t\t\twriteAnnotationSingle(key, value.getType(), value.getValue().get(0), jsonObject);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tvoid writeAnnotationSingle(String key, AnnotationsValueType type, String value, JSONObject jsonObject) {\n+\t\tswitch (type) {", "originalCommit": "5ff83b50c7aed128bd88fe329aa686e2a7d0e16d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI1ODY3NQ==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4145#discussion_r460258675", "bodyText": "We might need to exclude static fields", "author": "marcomarasca", "createdAt": "2020-07-24T19:54:35Z", "path": "services/repository-managers/src/main/java/org/sagebionetworks/repo/manager/schema/AnnotationsTranslatorImpl.java", "diffHunk": "@@ -0,0 +1,379 @@\n+package org.sagebionetworks.repo.manager.schema;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.sagebionetworks.repo.model.Entity;\n+import org.sagebionetworks.repo.model.annotation.v2.Annotations;\n+import org.sagebionetworks.repo.model.annotation.v2.AnnotationsValue;\n+import org.sagebionetworks.repo.model.annotation.v2.AnnotationsValueType;\n+import org.sagebionetworks.schema.FORMAT;\n+import org.sagebionetworks.schema.adapter.JSONObjectAdapterException;\n+import org.sagebionetworks.schema.adapter.org.json.JSONObjectAdapterImpl;\n+import org.sagebionetworks.schema.adapter.org.json.JsonDateUtils;\n+import org.sagebionetworks.util.ValidateArgument;\n+import org.springframework.stereotype.Service;\n+\n+import com.google.common.collect.Lists;\n+\n+@Service\n+public class AnnotationsTranslatorImpl implements AnnotationsTranslator {\n+\n+\tprivate static final String ID = \"id\";\n+\tprivate static final String ETAG = \"etag\";\n+\tpublic static final String CONCRETE_TYPE = \"concreteType\";\n+\n+\t@Override\n+\tpublic JSONObject writeToJsonObject(Entity entity, Annotations annotations) {\n+\t\tValidateArgument.required(entity, \"entity\");\n+\t\tValidateArgument.required(annotations, \"annotations\");\n+\t\tJSONObject jsonObject = new JSONObject();\n+\t\twriteAnnotationsToJSONObject(annotations, jsonObject);\n+\t\tJSONObjectAdapterImpl adapter = new JSONObjectAdapterImpl(jsonObject);\n+\t\ttry {\n+\t\t\t// write the entity second to override any conflicts.\n+\t\t\tentity.writeToJSONObject(adapter);\n+\t\t} catch (JSONObjectAdapterException e) {\n+\t\t\tthrow new IllegalStateException(e);\n+\t\t}\n+\t\treturn jsonObject;\n+\t}\n+\n+\t@Override\n+\tpublic Annotations readFromJsonObject(Class<? extends Entity> entityClass, JSONObject jsonObject) {\n+\t\tValidateArgument.required(entityClass, \"entity\");\n+\t\tValidateArgument.required(jsonObject, \"jsonObject\");\n+\t\tvalidateHasKeys(Lists.newArrayList(ID, ETAG, CONCRETE_TYPE), jsonObject);\n+\t\tString entityId = jsonObject.getString(ID);\n+\t\tif (!entityClass.getName().equals(jsonObject.get(CONCRETE_TYPE))) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t\"The value of 'concreteType' does not match the type of Entity: '\" + entityId + \"'\");\n+\t\t}\n+\t\tAnnotations annotations = new Annotations();\n+\t\tannotations.setId(entityId);\n+\t\tannotations.setEtag(jsonObject.getString(ETAG));\n+\t\tMap<String, AnnotationsValue> map = new LinkedHashMap<String, AnnotationsValue>();\n+\t\tannotations.setAnnotations(map);\n+\t\tjsonObject.keySet().stream().filter(key -> canUseKey(entityClass, key)).forEach((key) -> {\n+\t\t\tAnnotationsValue annValue = getAnnotationValueFromJsonObject(key, jsonObject);\n+\t\t\tmap.put(key, annValue);\n+\t\t});\n+\t\treturn annotations;\n+\t}\n+\n+\tvoid validateHasKeys(List<String> expectedKeys, JSONObject jsonObject) {\n+\t\tfor (String expectedKey : expectedKeys) {\n+\t\t\tif (!jsonObject.has(expectedKey)) {\n+\t\t\t\tthrow new IllegalArgumentException(\"Expected JSON to include key: '\" + expectedKey + \"'\");\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Read a single AnnotationValue for the given key from the given JSONObject.\n+\t * \n+\t * @param key\n+\t * @param jsonObject\n+\t * @return\n+\t */\n+\tAnnotationsValue getAnnotationValueFromJsonObject(String key, JSONObject jsonObject) {\n+\t\treturn Stream.of(attemptToReadAsJSONArray(key, jsonObject), attemptToReadAsDouble(key, jsonObject),\n+\t\t\t\tattemptToReadAsTimestamp(key, jsonObject), attemptToReadAsLong(key, jsonObject),\n+\t\t\t\tattemptToReadAsString(key, jsonObject)).filter(Optional::isPresent).findFirst().get().get();\n+\t}\n+\n+\t/**\n+\t * Attempt to read the value for the given key as a string. Note: This should\n+\t * always work as any type can be read as a string.\n+\t * \n+\t * @param key\n+\t * @param jsonObject\n+\t * @return\n+\t */\n+\tOptional<AnnotationsValue> attemptToReadAsString(String key, JSONObject jsonObject) {\n+\t\ttry {\n+\t\t\tString value = jsonObject.getString(key);\n+\t\t\tAnnotationsValue annValue = new AnnotationsValue();\n+\t\t\tannValue.setType(AnnotationsValueType.STRING);\n+\t\t\tannValue.setValue(java.util.Collections.singletonList(value));\n+\t\t\treturn Optional.of(annValue);\n+\t\t} catch (JSONException e) {\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Attempt to read the value from the given key as a DATE_TIME formated string.\n+\t * An empty Optional will be returned if the value is not a DATE_TIME formated\n+\t * string.\n+\t * \n+\t * @param key\n+\t * @param jsonObject\n+\t * @return\n+\t */\n+\tOptional<AnnotationsValue> attemptToReadAsTimestamp(String key, JSONObject jsonObject) {\n+\t\ttry {\n+\t\t\tString value = jsonObject.getString(key);\n+\t\t\tlong timeMS = JsonDateUtils.convertStringToDate(FORMAT.DATE_TIME, value).getTime();\n+\t\t\tAnnotationsValue annValue = new AnnotationsValue();\n+\t\t\tannValue.setType(AnnotationsValueType.TIMESTAMP_MS);\n+\t\t\tannValue.setValue(java.util.Collections.singletonList(Long.toString(timeMS)));\n+\t\t\treturn Optional.of(annValue);\n+\t\t} catch (IllegalArgumentException e) {\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Attempt to read the value at the given index as a string. Note: This should\n+\t * always work as any type can be read as a string.\n+\t * \n+\t * @param index\n+\t * @param array\n+\t * @return\n+\t */\n+\tOptional<ListValue> attemptToReadAsString(int index, JSONArray array) {\n+\t\ttry {\n+\t\t\tString value = array.getString(index);\n+\t\t\treturn Optional.of(new ListValue(AnnotationsValueType.STRING, value));\n+\t\t} catch (JSONException e) {\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Attempt to read the value at the given index as a DATE_TIME formated string.\n+\t * If the value is not a DATE_TIME formated string an empty optional will be\n+\t * returned.\n+\t * \n+\t * @param index\n+\t * @param array\n+\t * @return\n+\t */\n+\tOptional<ListValue> attemptToReadAsTimestamp(int index, JSONArray array) {\n+\t\ttry {\n+\t\t\tString value = array.getString(index);\n+\t\t\tlong timeMS = JsonDateUtils.convertStringToDate(FORMAT.DATE_TIME, value).getTime();\n+\t\t\treturn Optional.of(new ListValue(AnnotationsValueType.TIMESTAMP_MS, Long.toString(timeMS)));\n+\t\t} catch (IllegalArgumentException e) {\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Attempt to read the value for the given key as a double. If the value is not\n+\t * a double an empty optional will be returned.\n+\t * \n+\t * @param key\n+\t * @param jsonObject\n+\t * @return\n+\t */\n+\tOptional<AnnotationsValue> attemptToReadAsDouble(String key, JSONObject jsonObject) {\n+\t\ttry {\n+\t\t\tDouble value = jsonObject.getDouble(key);\n+\t\t\tString testString = jsonObject.getString(key);\n+\t\t\tif (!testString.equals(value.toString())) {\n+\t\t\t\t// data loss\n+\t\t\t\treturn Optional.empty();\n+\t\t\t}\n+\t\t\tAnnotationsValue annValue = new AnnotationsValue();\n+\t\t\tannValue.setType(AnnotationsValueType.DOUBLE);\n+\t\t\tannValue.setValue(java.util.Collections.singletonList(value.toString()));\n+\t\t\treturn Optional.of(annValue);\n+\t\t} catch (JSONException e) {\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Attempt to read the value for the given index as a double. If the value is\n+\t * not a double an empty optional will be returned.\n+\t * \n+\t * @param index\n+\t * @param array\n+\t * @return\n+\t */\n+\tOptional<ListValue> attemptToReadAsDouble(int index, JSONArray array) {\n+\t\ttry {\n+\t\t\tDouble value = array.getDouble(index);\n+\t\t\tString testString = array.getString(index);\n+\t\t\tif (!testString.equals(value.toString())) {\n+\t\t\t\t// data loss\n+\t\t\t\treturn Optional.empty();\n+\t\t\t}\n+\t\t\treturn Optional.of(new ListValue(AnnotationsValueType.DOUBLE, value.toString()));\n+\t\t} catch (JSONException e) {\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Attempt to read the value for the given key as a long. If the value is not a\n+\t * long an empty optional will be returned.\n+\t * \n+\t * @param key\n+\t * @param jsonObject\n+\t * @return\n+\t */\n+\tOptional<AnnotationsValue> attemptToReadAsLong(String key, JSONObject jsonObject) {\n+\t\ttry {\n+\t\t\tLong value = jsonObject.getLong(key);\n+\t\t\tAnnotationsValue annValue = new AnnotationsValue();\n+\t\t\tannValue.setType(AnnotationsValueType.LONG);\n+\t\t\tannValue.setValue(java.util.Collections.singletonList(value.toString()));\n+\t\t\treturn Optional.of(annValue);\n+\t\t} catch (JSONException e) {\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Attempt to read the value at the given index as a long. If the value is not a\n+\t * long an empty optional will be returned.\n+\t * \n+\t * @param index\n+\t * @param array\n+\t * @return\n+\t */\n+\tOptional<ListValue> attemptToReadAsLong(int index, JSONArray array) {\n+\t\ttry {\n+\t\t\tLong value = array.getLong(index);\n+\t\t\treturn Optional.of(new ListValue(AnnotationsValueType.LONG, value.toString()));\n+\t\t} catch (JSONException e) {\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Attempt to read the value for the given key as a JSONArray. If the value is\n+\t * not a JSONArray an empty optional will be returned.\n+\t * \n+\t * @param key\n+\t * @param jsonObject\n+\t * @return\n+\t */\n+\tOptional<AnnotationsValue> attemptToReadAsJSONArray(String key, JSONObject jsonObject) {\n+\t\ttry {\n+\t\t\tJSONArray array = jsonObject.getJSONArray(key);\n+\t\t\tList<String> valueList = new ArrayList<String>(array.length());\n+\t\t\tAnnotationsValueType lastType = null;\n+\t\t\tfor (int i = 0; i < array.length(); i++) {\n+\t\t\t\tListValue listValue = Stream\n+\t\t\t\t\t\t.of(attemptToReadAsDouble(i, array), attemptToReadAsTimestamp(i, array),\n+\t\t\t\t\t\t\t\tattemptToReadAsLong(i, array), attemptToReadAsString(i, array))\n+\t\t\t\t\t\t.filter(Optional::isPresent).findFirst().get().get();\n+\t\t\t\tif (lastType != null && !lastType.equals(listValue.getType())) {\n+\t\t\t\t\tthrow new IllegalArgumentException(\"List of mixed types found for key: '\" + key + \"'\");\n+\t\t\t\t}\n+\t\t\t\tlastType = listValue.getType();\n+\t\t\t\tvalueList.add(listValue.getValue());\n+\t\t\t}\n+\t\t\tAnnotationsValue annValue = new AnnotationsValue();\n+\t\t\tannValue.setType(lastType);\n+\t\t\tannValue.setValue(valueList);\n+\t\t\treturn Optional.of(annValue);\n+\t\t} catch (JSONException e) {\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Field names of an Entity cannot be used as annotation keys. All other keys\n+\t * are valid.\n+\t * \n+\t * @param clazz\n+\t * @param key\n+\t * @return\n+\t */\n+\tpublic static boolean canUseKey(Class clazz, String key) {\n+\t\ttry {\n+\t\t\tclazz.getDeclaredField(key);", "originalCommit": "5ff83b50c7aed128bd88fe329aa686e2a7d0e16d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI2MzgzMg==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4145#discussion_r460263832", "bodyText": "import java.util.Collections", "author": "marcomarasca", "createdAt": "2020-07-24T20:06:32Z", "path": "services/repository-managers/src/main/java/org/sagebionetworks/repo/manager/schema/AnnotationsTranslatorImpl.java", "diffHunk": "@@ -0,0 +1,379 @@\n+package org.sagebionetworks.repo.manager.schema;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.sagebionetworks.repo.model.Entity;\n+import org.sagebionetworks.repo.model.annotation.v2.Annotations;\n+import org.sagebionetworks.repo.model.annotation.v2.AnnotationsValue;\n+import org.sagebionetworks.repo.model.annotation.v2.AnnotationsValueType;\n+import org.sagebionetworks.schema.FORMAT;\n+import org.sagebionetworks.schema.adapter.JSONObjectAdapterException;\n+import org.sagebionetworks.schema.adapter.org.json.JSONObjectAdapterImpl;\n+import org.sagebionetworks.schema.adapter.org.json.JsonDateUtils;\n+import org.sagebionetworks.util.ValidateArgument;\n+import org.springframework.stereotype.Service;\n+\n+import com.google.common.collect.Lists;\n+\n+@Service\n+public class AnnotationsTranslatorImpl implements AnnotationsTranslator {\n+\n+\tprivate static final String ID = \"id\";\n+\tprivate static final String ETAG = \"etag\";\n+\tpublic static final String CONCRETE_TYPE = \"concreteType\";\n+\n+\t@Override\n+\tpublic JSONObject writeToJsonObject(Entity entity, Annotations annotations) {\n+\t\tValidateArgument.required(entity, \"entity\");\n+\t\tValidateArgument.required(annotations, \"annotations\");\n+\t\tJSONObject jsonObject = new JSONObject();\n+\t\twriteAnnotationsToJSONObject(annotations, jsonObject);\n+\t\tJSONObjectAdapterImpl adapter = new JSONObjectAdapterImpl(jsonObject);\n+\t\ttry {\n+\t\t\t// write the entity second to override any conflicts.\n+\t\t\tentity.writeToJSONObject(adapter);\n+\t\t} catch (JSONObjectAdapterException e) {\n+\t\t\tthrow new IllegalStateException(e);\n+\t\t}\n+\t\treturn jsonObject;\n+\t}\n+\n+\t@Override\n+\tpublic Annotations readFromJsonObject(Class<? extends Entity> entityClass, JSONObject jsonObject) {\n+\t\tValidateArgument.required(entityClass, \"entity\");\n+\t\tValidateArgument.required(jsonObject, \"jsonObject\");\n+\t\tvalidateHasKeys(Lists.newArrayList(ID, ETAG, CONCRETE_TYPE), jsonObject);\n+\t\tString entityId = jsonObject.getString(ID);\n+\t\tif (!entityClass.getName().equals(jsonObject.get(CONCRETE_TYPE))) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t\"The value of 'concreteType' does not match the type of Entity: '\" + entityId + \"'\");\n+\t\t}\n+\t\tAnnotations annotations = new Annotations();\n+\t\tannotations.setId(entityId);\n+\t\tannotations.setEtag(jsonObject.getString(ETAG));\n+\t\tMap<String, AnnotationsValue> map = new LinkedHashMap<String, AnnotationsValue>();\n+\t\tannotations.setAnnotations(map);\n+\t\tjsonObject.keySet().stream().filter(key -> canUseKey(entityClass, key)).forEach((key) -> {\n+\t\t\tAnnotationsValue annValue = getAnnotationValueFromJsonObject(key, jsonObject);\n+\t\t\tmap.put(key, annValue);\n+\t\t});\n+\t\treturn annotations;\n+\t}\n+\n+\tvoid validateHasKeys(List<String> expectedKeys, JSONObject jsonObject) {\n+\t\tfor (String expectedKey : expectedKeys) {\n+\t\t\tif (!jsonObject.has(expectedKey)) {\n+\t\t\t\tthrow new IllegalArgumentException(\"Expected JSON to include key: '\" + expectedKey + \"'\");\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Read a single AnnotationValue for the given key from the given JSONObject.\n+\t * \n+\t * @param key\n+\t * @param jsonObject\n+\t * @return\n+\t */\n+\tAnnotationsValue getAnnotationValueFromJsonObject(String key, JSONObject jsonObject) {\n+\t\treturn Stream.of(attemptToReadAsJSONArray(key, jsonObject), attemptToReadAsDouble(key, jsonObject),\n+\t\t\t\tattemptToReadAsTimestamp(key, jsonObject), attemptToReadAsLong(key, jsonObject),\n+\t\t\t\tattemptToReadAsString(key, jsonObject)).filter(Optional::isPresent).findFirst().get().get();\n+\t}\n+\n+\t/**\n+\t * Attempt to read the value for the given key as a string. Note: This should\n+\t * always work as any type can be read as a string.\n+\t * \n+\t * @param key\n+\t * @param jsonObject\n+\t * @return\n+\t */\n+\tOptional<AnnotationsValue> attemptToReadAsString(String key, JSONObject jsonObject) {\n+\t\ttry {\n+\t\t\tString value = jsonObject.getString(key);\n+\t\t\tAnnotationsValue annValue = new AnnotationsValue();\n+\t\t\tannValue.setType(AnnotationsValueType.STRING);\n+\t\t\tannValue.setValue(java.util.Collections.singletonList(value));\n+\t\t\treturn Optional.of(annValue);\n+\t\t} catch (JSONException e) {\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Attempt to read the value from the given key as a DATE_TIME formated string.\n+\t * An empty Optional will be returned if the value is not a DATE_TIME formated\n+\t * string.\n+\t * \n+\t * @param key\n+\t * @param jsonObject\n+\t * @return\n+\t */\n+\tOptional<AnnotationsValue> attemptToReadAsTimestamp(String key, JSONObject jsonObject) {\n+\t\ttry {\n+\t\t\tString value = jsonObject.getString(key);\n+\t\t\tlong timeMS = JsonDateUtils.convertStringToDate(FORMAT.DATE_TIME, value).getTime();\n+\t\t\tAnnotationsValue annValue = new AnnotationsValue();\n+\t\t\tannValue.setType(AnnotationsValueType.TIMESTAMP_MS);\n+\t\t\tannValue.setValue(java.util.Collections.singletonList(Long.toString(timeMS)));\n+\t\t\treturn Optional.of(annValue);\n+\t\t} catch (IllegalArgumentException e) {\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Attempt to read the value at the given index as a string. Note: This should\n+\t * always work as any type can be read as a string.\n+\t * \n+\t * @param index\n+\t * @param array\n+\t * @return\n+\t */\n+\tOptional<ListValue> attemptToReadAsString(int index, JSONArray array) {\n+\t\ttry {\n+\t\t\tString value = array.getString(index);\n+\t\t\treturn Optional.of(new ListValue(AnnotationsValueType.STRING, value));\n+\t\t} catch (JSONException e) {\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Attempt to read the value at the given index as a DATE_TIME formated string.\n+\t * If the value is not a DATE_TIME formated string an empty optional will be\n+\t * returned.\n+\t * \n+\t * @param index\n+\t * @param array\n+\t * @return\n+\t */\n+\tOptional<ListValue> attemptToReadAsTimestamp(int index, JSONArray array) {\n+\t\ttry {\n+\t\t\tString value = array.getString(index);\n+\t\t\tlong timeMS = JsonDateUtils.convertStringToDate(FORMAT.DATE_TIME, value).getTime();\n+\t\t\treturn Optional.of(new ListValue(AnnotationsValueType.TIMESTAMP_MS, Long.toString(timeMS)));\n+\t\t} catch (IllegalArgumentException e) {\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Attempt to read the value for the given key as a double. If the value is not\n+\t * a double an empty optional will be returned.\n+\t * \n+\t * @param key\n+\t * @param jsonObject\n+\t * @return\n+\t */\n+\tOptional<AnnotationsValue> attemptToReadAsDouble(String key, JSONObject jsonObject) {\n+\t\ttry {\n+\t\t\tDouble value = jsonObject.getDouble(key);\n+\t\t\tString testString = jsonObject.getString(key);\n+\t\t\tif (!testString.equals(value.toString())) {\n+\t\t\t\t// data loss\n+\t\t\t\treturn Optional.empty();\n+\t\t\t}\n+\t\t\tAnnotationsValue annValue = new AnnotationsValue();\n+\t\t\tannValue.setType(AnnotationsValueType.DOUBLE);\n+\t\t\tannValue.setValue(java.util.Collections.singletonList(value.toString()));", "originalCommit": "5ff83b50c7aed128bd88fe329aa686e2a7d0e16d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI2NTA1MQ==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4145#discussion_r460265051", "bodyText": "The findFirst() might return an empty optional, we should consider doing an orElseThrow().", "author": "marcomarasca", "createdAt": "2020-07-24T20:09:43Z", "path": "services/repository-managers/src/main/java/org/sagebionetworks/repo/manager/schema/AnnotationsTranslatorImpl.java", "diffHunk": "@@ -0,0 +1,379 @@\n+package org.sagebionetworks.repo.manager.schema;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.sagebionetworks.repo.model.Entity;\n+import org.sagebionetworks.repo.model.annotation.v2.Annotations;\n+import org.sagebionetworks.repo.model.annotation.v2.AnnotationsValue;\n+import org.sagebionetworks.repo.model.annotation.v2.AnnotationsValueType;\n+import org.sagebionetworks.schema.FORMAT;\n+import org.sagebionetworks.schema.adapter.JSONObjectAdapterException;\n+import org.sagebionetworks.schema.adapter.org.json.JSONObjectAdapterImpl;\n+import org.sagebionetworks.schema.adapter.org.json.JsonDateUtils;\n+import org.sagebionetworks.util.ValidateArgument;\n+import org.springframework.stereotype.Service;\n+\n+import com.google.common.collect.Lists;\n+\n+@Service\n+public class AnnotationsTranslatorImpl implements AnnotationsTranslator {\n+\n+\tprivate static final String ID = \"id\";\n+\tprivate static final String ETAG = \"etag\";\n+\tpublic static final String CONCRETE_TYPE = \"concreteType\";\n+\n+\t@Override\n+\tpublic JSONObject writeToJsonObject(Entity entity, Annotations annotations) {\n+\t\tValidateArgument.required(entity, \"entity\");\n+\t\tValidateArgument.required(annotations, \"annotations\");\n+\t\tJSONObject jsonObject = new JSONObject();\n+\t\twriteAnnotationsToJSONObject(annotations, jsonObject);\n+\t\tJSONObjectAdapterImpl adapter = new JSONObjectAdapterImpl(jsonObject);\n+\t\ttry {\n+\t\t\t// write the entity second to override any conflicts.\n+\t\t\tentity.writeToJSONObject(adapter);\n+\t\t} catch (JSONObjectAdapterException e) {\n+\t\t\tthrow new IllegalStateException(e);\n+\t\t}\n+\t\treturn jsonObject;\n+\t}\n+\n+\t@Override\n+\tpublic Annotations readFromJsonObject(Class<? extends Entity> entityClass, JSONObject jsonObject) {\n+\t\tValidateArgument.required(entityClass, \"entity\");\n+\t\tValidateArgument.required(jsonObject, \"jsonObject\");\n+\t\tvalidateHasKeys(Lists.newArrayList(ID, ETAG, CONCRETE_TYPE), jsonObject);\n+\t\tString entityId = jsonObject.getString(ID);\n+\t\tif (!entityClass.getName().equals(jsonObject.get(CONCRETE_TYPE))) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t\"The value of 'concreteType' does not match the type of Entity: '\" + entityId + \"'\");\n+\t\t}\n+\t\tAnnotations annotations = new Annotations();\n+\t\tannotations.setId(entityId);\n+\t\tannotations.setEtag(jsonObject.getString(ETAG));\n+\t\tMap<String, AnnotationsValue> map = new LinkedHashMap<String, AnnotationsValue>();\n+\t\tannotations.setAnnotations(map);\n+\t\tjsonObject.keySet().stream().filter(key -> canUseKey(entityClass, key)).forEach((key) -> {\n+\t\t\tAnnotationsValue annValue = getAnnotationValueFromJsonObject(key, jsonObject);\n+\t\t\tmap.put(key, annValue);\n+\t\t});\n+\t\treturn annotations;\n+\t}\n+\n+\tvoid validateHasKeys(List<String> expectedKeys, JSONObject jsonObject) {\n+\t\tfor (String expectedKey : expectedKeys) {\n+\t\t\tif (!jsonObject.has(expectedKey)) {\n+\t\t\t\tthrow new IllegalArgumentException(\"Expected JSON to include key: '\" + expectedKey + \"'\");\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Read a single AnnotationValue for the given key from the given JSONObject.\n+\t * \n+\t * @param key\n+\t * @param jsonObject\n+\t * @return\n+\t */\n+\tAnnotationsValue getAnnotationValueFromJsonObject(String key, JSONObject jsonObject) {\n+\t\treturn Stream.of(attemptToReadAsJSONArray(key, jsonObject), attemptToReadAsDouble(key, jsonObject),\n+\t\t\t\tattemptToReadAsTimestamp(key, jsonObject), attemptToReadAsLong(key, jsonObject),\n+\t\t\t\tattemptToReadAsString(key, jsonObject)).filter(Optional::isPresent).findFirst().get().get();", "originalCommit": "5ff83b50c7aed128bd88fe329aa686e2a7d0e16d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI2NTc4Mw==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4145#discussion_r460265783", "bodyText": "Catch JSONException", "author": "marcomarasca", "createdAt": "2020-07-24T20:11:42Z", "path": "services/repository-managers/src/main/java/org/sagebionetworks/repo/manager/schema/AnnotationsTranslatorImpl.java", "diffHunk": "@@ -0,0 +1,379 @@\n+package org.sagebionetworks.repo.manager.schema;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.sagebionetworks.repo.model.Entity;\n+import org.sagebionetworks.repo.model.annotation.v2.Annotations;\n+import org.sagebionetworks.repo.model.annotation.v2.AnnotationsValue;\n+import org.sagebionetworks.repo.model.annotation.v2.AnnotationsValueType;\n+import org.sagebionetworks.schema.FORMAT;\n+import org.sagebionetworks.schema.adapter.JSONObjectAdapterException;\n+import org.sagebionetworks.schema.adapter.org.json.JSONObjectAdapterImpl;\n+import org.sagebionetworks.schema.adapter.org.json.JsonDateUtils;\n+import org.sagebionetworks.util.ValidateArgument;\n+import org.springframework.stereotype.Service;\n+\n+import com.google.common.collect.Lists;\n+\n+@Service\n+public class AnnotationsTranslatorImpl implements AnnotationsTranslator {\n+\n+\tprivate static final String ID = \"id\";\n+\tprivate static final String ETAG = \"etag\";\n+\tpublic static final String CONCRETE_TYPE = \"concreteType\";\n+\n+\t@Override\n+\tpublic JSONObject writeToJsonObject(Entity entity, Annotations annotations) {\n+\t\tValidateArgument.required(entity, \"entity\");\n+\t\tValidateArgument.required(annotations, \"annotations\");\n+\t\tJSONObject jsonObject = new JSONObject();\n+\t\twriteAnnotationsToJSONObject(annotations, jsonObject);\n+\t\tJSONObjectAdapterImpl adapter = new JSONObjectAdapterImpl(jsonObject);\n+\t\ttry {\n+\t\t\t// write the entity second to override any conflicts.\n+\t\t\tentity.writeToJSONObject(adapter);\n+\t\t} catch (JSONObjectAdapterException e) {\n+\t\t\tthrow new IllegalStateException(e);\n+\t\t}\n+\t\treturn jsonObject;\n+\t}\n+\n+\t@Override\n+\tpublic Annotations readFromJsonObject(Class<? extends Entity> entityClass, JSONObject jsonObject) {\n+\t\tValidateArgument.required(entityClass, \"entity\");\n+\t\tValidateArgument.required(jsonObject, \"jsonObject\");\n+\t\tvalidateHasKeys(Lists.newArrayList(ID, ETAG, CONCRETE_TYPE), jsonObject);\n+\t\tString entityId = jsonObject.getString(ID);\n+\t\tif (!entityClass.getName().equals(jsonObject.get(CONCRETE_TYPE))) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t\"The value of 'concreteType' does not match the type of Entity: '\" + entityId + \"'\");\n+\t\t}\n+\t\tAnnotations annotations = new Annotations();\n+\t\tannotations.setId(entityId);\n+\t\tannotations.setEtag(jsonObject.getString(ETAG));\n+\t\tMap<String, AnnotationsValue> map = new LinkedHashMap<String, AnnotationsValue>();\n+\t\tannotations.setAnnotations(map);\n+\t\tjsonObject.keySet().stream().filter(key -> canUseKey(entityClass, key)).forEach((key) -> {\n+\t\t\tAnnotationsValue annValue = getAnnotationValueFromJsonObject(key, jsonObject);\n+\t\t\tmap.put(key, annValue);\n+\t\t});\n+\t\treturn annotations;\n+\t}\n+\n+\tvoid validateHasKeys(List<String> expectedKeys, JSONObject jsonObject) {\n+\t\tfor (String expectedKey : expectedKeys) {\n+\t\t\tif (!jsonObject.has(expectedKey)) {\n+\t\t\t\tthrow new IllegalArgumentException(\"Expected JSON to include key: '\" + expectedKey + \"'\");\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Read a single AnnotationValue for the given key from the given JSONObject.\n+\t * \n+\t * @param key\n+\t * @param jsonObject\n+\t * @return\n+\t */\n+\tAnnotationsValue getAnnotationValueFromJsonObject(String key, JSONObject jsonObject) {\n+\t\treturn Stream.of(attemptToReadAsJSONArray(key, jsonObject), attemptToReadAsDouble(key, jsonObject),\n+\t\t\t\tattemptToReadAsTimestamp(key, jsonObject), attemptToReadAsLong(key, jsonObject),\n+\t\t\t\tattemptToReadAsString(key, jsonObject)).filter(Optional::isPresent).findFirst().get().get();\n+\t}\n+\n+\t/**\n+\t * Attempt to read the value for the given key as a string. Note: This should\n+\t * always work as any type can be read as a string.\n+\t * \n+\t * @param key\n+\t * @param jsonObject\n+\t * @return\n+\t */\n+\tOptional<AnnotationsValue> attemptToReadAsString(String key, JSONObject jsonObject) {\n+\t\ttry {\n+\t\t\tString value = jsonObject.getString(key);\n+\t\t\tAnnotationsValue annValue = new AnnotationsValue();\n+\t\t\tannValue.setType(AnnotationsValueType.STRING);\n+\t\t\tannValue.setValue(java.util.Collections.singletonList(value));\n+\t\t\treturn Optional.of(annValue);\n+\t\t} catch (JSONException e) {\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Attempt to read the value from the given key as a DATE_TIME formated string.\n+\t * An empty Optional will be returned if the value is not a DATE_TIME formated\n+\t * string.\n+\t * \n+\t * @param key\n+\t * @param jsonObject\n+\t * @return\n+\t */\n+\tOptional<AnnotationsValue> attemptToReadAsTimestamp(String key, JSONObject jsonObject) {\n+\t\ttry {\n+\t\t\tString value = jsonObject.getString(key);\n+\t\t\tlong timeMS = JsonDateUtils.convertStringToDate(FORMAT.DATE_TIME, value).getTime();\n+\t\t\tAnnotationsValue annValue = new AnnotationsValue();\n+\t\t\tannValue.setType(AnnotationsValueType.TIMESTAMP_MS);\n+\t\t\tannValue.setValue(java.util.Collections.singletonList(Long.toString(timeMS)));\n+\t\t\treturn Optional.of(annValue);\n+\t\t} catch (IllegalArgumentException e) {", "originalCommit": "5ff83b50c7aed128bd88fe329aa686e2a7d0e16d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI2NjA5Nw==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4145#discussion_r460266097", "bodyText": "catch JSONException", "author": "marcomarasca", "createdAt": "2020-07-24T20:12:30Z", "path": "services/repository-managers/src/main/java/org/sagebionetworks/repo/manager/schema/AnnotationsTranslatorImpl.java", "diffHunk": "@@ -0,0 +1,379 @@\n+package org.sagebionetworks.repo.manager.schema;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.sagebionetworks.repo.model.Entity;\n+import org.sagebionetworks.repo.model.annotation.v2.Annotations;\n+import org.sagebionetworks.repo.model.annotation.v2.AnnotationsValue;\n+import org.sagebionetworks.repo.model.annotation.v2.AnnotationsValueType;\n+import org.sagebionetworks.schema.FORMAT;\n+import org.sagebionetworks.schema.adapter.JSONObjectAdapterException;\n+import org.sagebionetworks.schema.adapter.org.json.JSONObjectAdapterImpl;\n+import org.sagebionetworks.schema.adapter.org.json.JsonDateUtils;\n+import org.sagebionetworks.util.ValidateArgument;\n+import org.springframework.stereotype.Service;\n+\n+import com.google.common.collect.Lists;\n+\n+@Service\n+public class AnnotationsTranslatorImpl implements AnnotationsTranslator {\n+\n+\tprivate static final String ID = \"id\";\n+\tprivate static final String ETAG = \"etag\";\n+\tpublic static final String CONCRETE_TYPE = \"concreteType\";\n+\n+\t@Override\n+\tpublic JSONObject writeToJsonObject(Entity entity, Annotations annotations) {\n+\t\tValidateArgument.required(entity, \"entity\");\n+\t\tValidateArgument.required(annotations, \"annotations\");\n+\t\tJSONObject jsonObject = new JSONObject();\n+\t\twriteAnnotationsToJSONObject(annotations, jsonObject);\n+\t\tJSONObjectAdapterImpl adapter = new JSONObjectAdapterImpl(jsonObject);\n+\t\ttry {\n+\t\t\t// write the entity second to override any conflicts.\n+\t\t\tentity.writeToJSONObject(adapter);\n+\t\t} catch (JSONObjectAdapterException e) {\n+\t\t\tthrow new IllegalStateException(e);\n+\t\t}\n+\t\treturn jsonObject;\n+\t}\n+\n+\t@Override\n+\tpublic Annotations readFromJsonObject(Class<? extends Entity> entityClass, JSONObject jsonObject) {\n+\t\tValidateArgument.required(entityClass, \"entity\");\n+\t\tValidateArgument.required(jsonObject, \"jsonObject\");\n+\t\tvalidateHasKeys(Lists.newArrayList(ID, ETAG, CONCRETE_TYPE), jsonObject);\n+\t\tString entityId = jsonObject.getString(ID);\n+\t\tif (!entityClass.getName().equals(jsonObject.get(CONCRETE_TYPE))) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t\"The value of 'concreteType' does not match the type of Entity: '\" + entityId + \"'\");\n+\t\t}\n+\t\tAnnotations annotations = new Annotations();\n+\t\tannotations.setId(entityId);\n+\t\tannotations.setEtag(jsonObject.getString(ETAG));\n+\t\tMap<String, AnnotationsValue> map = new LinkedHashMap<String, AnnotationsValue>();\n+\t\tannotations.setAnnotations(map);\n+\t\tjsonObject.keySet().stream().filter(key -> canUseKey(entityClass, key)).forEach((key) -> {\n+\t\t\tAnnotationsValue annValue = getAnnotationValueFromJsonObject(key, jsonObject);\n+\t\t\tmap.put(key, annValue);\n+\t\t});\n+\t\treturn annotations;\n+\t}\n+\n+\tvoid validateHasKeys(List<String> expectedKeys, JSONObject jsonObject) {\n+\t\tfor (String expectedKey : expectedKeys) {\n+\t\t\tif (!jsonObject.has(expectedKey)) {\n+\t\t\t\tthrow new IllegalArgumentException(\"Expected JSON to include key: '\" + expectedKey + \"'\");\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Read a single AnnotationValue for the given key from the given JSONObject.\n+\t * \n+\t * @param key\n+\t * @param jsonObject\n+\t * @return\n+\t */\n+\tAnnotationsValue getAnnotationValueFromJsonObject(String key, JSONObject jsonObject) {\n+\t\treturn Stream.of(attemptToReadAsJSONArray(key, jsonObject), attemptToReadAsDouble(key, jsonObject),\n+\t\t\t\tattemptToReadAsTimestamp(key, jsonObject), attemptToReadAsLong(key, jsonObject),\n+\t\t\t\tattemptToReadAsString(key, jsonObject)).filter(Optional::isPresent).findFirst().get().get();\n+\t}\n+\n+\t/**\n+\t * Attempt to read the value for the given key as a string. Note: This should\n+\t * always work as any type can be read as a string.\n+\t * \n+\t * @param key\n+\t * @param jsonObject\n+\t * @return\n+\t */\n+\tOptional<AnnotationsValue> attemptToReadAsString(String key, JSONObject jsonObject) {\n+\t\ttry {\n+\t\t\tString value = jsonObject.getString(key);\n+\t\t\tAnnotationsValue annValue = new AnnotationsValue();\n+\t\t\tannValue.setType(AnnotationsValueType.STRING);\n+\t\t\tannValue.setValue(java.util.Collections.singletonList(value));\n+\t\t\treturn Optional.of(annValue);\n+\t\t} catch (JSONException e) {\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Attempt to read the value from the given key as a DATE_TIME formated string.\n+\t * An empty Optional will be returned if the value is not a DATE_TIME formated\n+\t * string.\n+\t * \n+\t * @param key\n+\t * @param jsonObject\n+\t * @return\n+\t */\n+\tOptional<AnnotationsValue> attemptToReadAsTimestamp(String key, JSONObject jsonObject) {\n+\t\ttry {\n+\t\t\tString value = jsonObject.getString(key);\n+\t\t\tlong timeMS = JsonDateUtils.convertStringToDate(FORMAT.DATE_TIME, value).getTime();\n+\t\t\tAnnotationsValue annValue = new AnnotationsValue();\n+\t\t\tannValue.setType(AnnotationsValueType.TIMESTAMP_MS);\n+\t\t\tannValue.setValue(java.util.Collections.singletonList(Long.toString(timeMS)));\n+\t\t\treturn Optional.of(annValue);\n+\t\t} catch (IllegalArgumentException e) {\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Attempt to read the value at the given index as a string. Note: This should\n+\t * always work as any type can be read as a string.\n+\t * \n+\t * @param index\n+\t * @param array\n+\t * @return\n+\t */\n+\tOptional<ListValue> attemptToReadAsString(int index, JSONArray array) {\n+\t\ttry {\n+\t\t\tString value = array.getString(index);\n+\t\t\treturn Optional.of(new ListValue(AnnotationsValueType.STRING, value));\n+\t\t} catch (JSONException e) {\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Attempt to read the value at the given index as a DATE_TIME formated string.\n+\t * If the value is not a DATE_TIME formated string an empty optional will be\n+\t * returned.\n+\t * \n+\t * @param index\n+\t * @param array\n+\t * @return\n+\t */\n+\tOptional<ListValue> attemptToReadAsTimestamp(int index, JSONArray array) {\n+\t\ttry {\n+\t\t\tString value = array.getString(index);\n+\t\t\tlong timeMS = JsonDateUtils.convertStringToDate(FORMAT.DATE_TIME, value).getTime();\n+\t\t\treturn Optional.of(new ListValue(AnnotationsValueType.TIMESTAMP_MS, Long.toString(timeMS)));\n+\t\t} catch (IllegalArgumentException e) {", "originalCommit": "5ff83b50c7aed128bd88fe329aa686e2a7d0e16d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI2NjU5NA==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4145#discussion_r460266594", "bodyText": "hashCode and equals", "author": "marcomarasca", "createdAt": "2020-07-24T20:13:57Z", "path": "services/repository-managers/src/main/java/org/sagebionetworks/repo/manager/schema/EntityJsonSubject.java", "diffHunk": "@@ -0,0 +1,44 @@\n+package org.sagebionetworks.repo.manager.schema;\n+\n+import org.json.JSONObject;\n+import org.sagebionetworks.repo.model.Entity;\n+import org.sagebionetworks.repo.model.schema.ObjectType;\n+\n+/**\n+ * Basic Entity implementation of JsonSubject.\n+ *\n+ */\n+public class EntityJsonSubject implements JsonSubject {\n+\n+\tString entityId;\n+\tString entityEtag;\n+\tJSONObject json;\n+\n+\tpublic EntityJsonSubject(Entity entity, JSONObject json) {\n+\t\tsuper();\n+\t\tthis.entityId = entity.getId();\n+\t\tthis.entityEtag = entity.getEtag();\n+\t\tthis.json = json;\n+\t}\n+\n+\t@Override\n+\tpublic String getObjectId() {\n+\t\treturn this.entityId;\n+\t}\n+\n+\t@Override\n+\tpublic ObjectType getObjectType() {\n+\t\treturn ObjectType.entity;\n+\t}\n+\n+\t@Override\n+\tpublic String getObjectEtag() {\n+\t\treturn this.entityEtag;\n+\t}\n+\n+\t@Override\n+\tpublic JSONObject toJson() {\n+\t\treturn this.json;\n+\t}\n+", "originalCommit": "5ff83b50c7aed128bd88fe329aa686e2a7d0e16d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI2ODU1Mg==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4145#discussion_r460268552", "bodyText": "DO we need all mockito? :D", "author": "marcomarasca", "createdAt": "2020-07-24T20:18:42Z", "path": "services/repository-managers/src/test/java/org/sagebionetworks/repo/manager/EntityManagerImplUnitTest.java", "diffHunk": "@@ -13,7 +13,7 @@\n import static org.mockito.ArgumentMatchers.eq;\n import static org.mockito.ArgumentMatchers.notNull;\n import static org.mockito.ArgumentMatchers.same;\n-import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.*;", "originalCommit": "5ff83b50c7aed128bd88fe329aa686e2a7d0e16d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI2OTc0Ng==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4145#discussion_r460269746", "bodyText": "Unauthorized", "author": "marcomarasca", "createdAt": "2020-07-24T20:21:21Z", "path": "services/repository-managers/src/test/java/org/sagebionetworks/repo/manager/EntityManagerImplUnitTest.java", "diffHunk": "@@ -745,35 +758,170 @@ public void testClearBoundSchema() {\n \t\tverify(mockPermissionsManager).hasAccess(entityId, ACCESS_TYPE.DELETE, mockUser);\n \t\tverify(mockJsonSchemaManager).clearBoundSchema(123L, BoundObjectType.entity);\n \t}\n-\t\n+\n \t@Test\n \tpublic void testClearBoundSchemaWithUnauthorized() {\n \t\tString entityId = \"syn123\";\n-\t\twhen(mockPermissionsManager.hasAccess(any(), any(), any())).thenReturn(AuthorizationStatus.accessDenied(\"nope\"));\n-\t\tassertThrows(UnauthorizedException.class, ()->{\n+\t\twhen(mockPermissionsManager.hasAccess(any(), any(), any()))\n+\t\t\t\t.thenReturn(AuthorizationStatus.accessDenied(\"nope\"));\n+\t\tassertThrows(UnauthorizedException.class, () -> {\n \t\t\t// call under test\n \t\t\tentityManager.clearBoundSchema(mockUser, entityId);\n \t\t});\n \t\tverify(mockPermissionsManager).hasAccess(entityId, ACCESS_TYPE.DELETE, mockUser);\n \t\tverify(mockJsonSchemaManager, never()).clearBoundSchema(any(), any());\n \t}\n-\t\n+\n \t@Test\n \tpublic void testClearBoundSchemaWithNullEntityId() {\n \t\tString entityId = null;\n-\t\tassertThrows(IllegalArgumentException.class, ()->{\n+\t\tassertThrows(IllegalArgumentException.class, () -> {\n \t\t\t// call under test\n \t\t\tentityManager.clearBoundSchema(mockUser, entityId);\n \t\t});\n \t}\n-\t\n+\n \t@Test\n \tpublic void testClearBoundSchemaWithNullUser() {\n \t\tString entityId = \"syn123\";\n \t\tmockUser = null;\n-\t\tassertThrows(IllegalArgumentException.class, ()->{\n+\t\tassertThrows(IllegalArgumentException.class, () -> {\n \t\t\t// call under test\n \t\t\tentityManager.clearBoundSchema(mockUser, entityId);\n \t\t});\n \t}\n+\n+\t@Test\n+\tpublic void testGetEntityJson() {\n+\t\tString entityId = \"syn123\";\n+\t\twhen(mockPermissionsManager.hasAccess(any(), any(), any())).thenReturn(AuthorizationStatus.authorized());\n+\t\tProject project = new Project();\n+\t\tproject.setId(entityId);\n+\t\tdoReturn(project).when(entityManagerSpy).getEntity(any(String.class), any());\n+\t\torg.sagebionetworks.repo.model.annotation.v2.Annotations annos = new org.sagebionetworks.repo.model.annotation.v2.Annotations();\n+\t\twhen(mockNodeManager.getUserAnnotations(any())).thenReturn(annos);\n+\t\tJSONObject jsonResult = new JSONObject();\n+\t\twhen(mockAnnotationTranslator.writeToJsonObject(any(), any())).thenReturn(jsonResult);\n+\t\t// call under test\n+\t\tJSONObject object = entityManagerSpy.getEntityJson(mockUser, entityId);\n+\t\tassertNotNull(object);\n+\t\tassertEquals(jsonResult, object);\n+\t\tverify(mockPermissionsManager).hasAccess(entityId, ACCESS_TYPE.READ, mockUser);\n+\t\tverify(entityManagerSpy).getEntity(entityId, null);\n+\t\tverify(mockNodeManager).getUserAnnotations(entityId);\n+\t\tverify(mockAnnotationTranslator).writeToJsonObject(project, annos);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetEntityJsonWithUnauthrorized() {", "originalCommit": "5ff83b50c7aed128bd88fe329aa686e2a7d0e16d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI3MzQzNg==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4145#discussion_r460273436", "bodyText": "UPDATE AND READ", "author": "marcomarasca", "createdAt": "2020-07-24T20:30:15Z", "path": "services/repository/src/main/java/org/sagebionetworks/repo/web/controller/EntityController.java", "diffHunk": "@@ -1595,19 +1600,68 @@ public void filePreviewRedirectURLForVersion(\n \t * used to validate this Entity or its children.\n \t * <p>\n \t * Note: The caller must be granted the\n-\t * <a href=\"${org.sagebionetworks.repo.model.ACCESS_TYPE}\" >ACCESS_TYPE.DELETE</a>\n-\t * permission on the Entity.\n+\t * <a href=\"${org.sagebionetworks.repo.model.ACCESS_TYPE}\"\n+\t * >ACCESS_TYPE.DELETE</a> permission on the Entity.\n \t * </p>\n+\t * \n \t * @param userId\n \t * @param id\n \t * @return\n \t */\n \t@RequiredScope({ modify })\n \t@ResponseStatus(HttpStatus.NO_CONTENT)\n \t@RequestMapping(value = { UrlHelpers.ENTITY_BIND_JSON_SCHEMA }, method = RequestMethod.DELETE)\n-\tpublic void clearBoundSchema(\n-\t\t\t@RequestParam(value = AuthorizationConstants.USER_ID_PARAM) Long userId,\n+\tpublic void clearBoundSchema(@RequestParam(value = AuthorizationConstants.USER_ID_PARAM) Long userId,\n \t\t\t@PathVariable(required = true) String id) {\n \t\tserviceProvider.getEntityService().clearBoundSchema(userId, id);\n \t}\n+\n+\t/**\n+\t * Get the raw JSON for the given entity. The resulting JSON can be used for the\n+\t * validation of a entity against a\n+\t * <a href=\"${org.sagebionetworks.repo.model.schema.JsonSchema}\">JsonSchema</a>.\n+\t * <p>\n+\t * Note: The caller must be granted the\n+\t * <a href=\"${org.sagebionetworks.repo.model.ACCESS_TYPE}\" >ACCESS_TYPE.READ</a>\n+\t * permission on the Entity.\n+\t * </p>\n+\t * \n+\t * @param userId\n+\t * @param id\n+\t * @return\n+\t */\n+\t@RequiredScope({ view })\n+\t@ResponseStatus(HttpStatus.OK)\n+\t@RequestMapping(value = { UrlHelpers.ENTITY_ID_JSON }, method = RequestMethod.GET)\n+\tpublic @ResponseBody JSONObject getEntityJson(\n+\t\t\t@RequestParam(value = AuthorizationConstants.USER_ID_PARAM) Long userId,\n+\t\t\t@PathVariable(required = true) String id) {\n+\t\treturn serviceProvider.getEntityService().getEntityJson(userId, id);\n+\t}\n+\n+\t/**\n+\t * Update the annotations of an entity using the raw JSON of the entity.\n+\t * <p>\n+\t * See: <a href=\"${GET.entity.id.json}\">GET entity/{id}/json</a> to get the\n+\t * JSON of an entity.\n+\t * </p>\n+\t * <p>\n+\t * Note: The caller must be granted the\n+\t * <a href=\"${org.sagebionetworks.repo.model.ACCESS_TYPE}\" >ACCESS_TYPE.UPDATE</a>", "originalCommit": "5ff83b50c7aed128bd88fe329aa686e2a7d0e16d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}