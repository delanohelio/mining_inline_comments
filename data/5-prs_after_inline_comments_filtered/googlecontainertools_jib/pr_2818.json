{"pr_number": 2818, "pr_title": "Build Command for building from cli", "pr_createdAt": "2020-10-12T23:02:37Z", "pr_url": "https://github.com/GoogleContainerTools/jib/pull/2818", "timeline": [{"oid": "d92dd673cdc0232632a516b8f9f3ea91e0bc2904", "url": "https://github.com/GoogleContainerTools/jib/commit/d92dd673cdc0232632a516b8f9f3ea91e0bc2904", "message": "Create containerizer and build a container for CLI.", "committedDate": "2020-10-14T05:16:31Z", "type": "forcePushed"}, {"oid": "e5c15ca2da1c7b86238f7a722054cb2c7543747e", "url": "https://github.com/GoogleContainerTools/jib/commit/e5c15ca2da1c7b86238f7a722054cb2c7543747e", "message": "Create containerizer and build a container for CLI.", "committedDate": "2020-10-14T22:46:57Z", "type": "forcePushed"}, {"oid": "ad00ae9617dea48db1983254c28de411b17512a9", "url": "https://github.com/GoogleContainerTools/jib/commit/ad00ae9617dea48db1983254c28de411b17512a9", "message": "Create containerizer and build a container for CLI.", "committedDate": "2020-10-15T19:07:41Z", "type": "forcePushed"}, {"oid": "c66ce2f6cf51e6e8cf2f0188b090f09f07796941", "url": "https://github.com/GoogleContainerTools/jib/commit/c66ce2f6cf51e6e8cf2f0188b090f09f07796941", "message": "Create containerizer and build a container for CLI.", "committedDate": "2020-10-15T19:17:51Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc4NzM1Ng==", "url": "https://github.com/GoogleContainerTools/jib/pull/2818#discussion_r505787356", "bodyText": "Remove.", "author": "chanseokoh", "createdAt": "2020-10-15T19:28:09Z", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/api/Containerizer.java", "diffHunk": "@@ -109,6 +109,7 @@ public static Containerizer to(TarImage tarImage) {\n \n     ImageConfiguration imageConfiguration =\n         ImageConfiguration.builder(tarImage.getImageReference().get()).build();\n+    // ImageConfiguration.builder(tarImage.getImageReference().get()).setTarPath(tarImage.getPath()).build();", "originalCommit": "c66ce2f6cf51e6e8cf2f0188b090f09f07796941", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc4OTQ3Mw==", "url": "https://github.com/GoogleContainerTools/jib/pull/2818#discussion_r505789473", "bodyText": "It's not possible to have both --username and --to-username given, right? Is it worth checking that here?\nPreconditions.checkArgument(!(buildOptions.getUsernamePassword().isPresent() && buildOptinos.getToUsernamePassword.isPresent()));", "author": "chanseokoh", "createdAt": "2020-10-15T19:31:56Z", "path": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/cli2/Containerizers.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.cli.cli2;\n+\n+import static com.google.cloud.tools.jib.api.Jib.DOCKER_DAEMON_IMAGE_PREFIX;\n+import static com.google.cloud.tools.jib.api.Jib.REGISTRY_IMAGE_PREFIX;\n+import static com.google.cloud.tools.jib.api.Jib.TAR_IMAGE_PREFIX;\n+\n+import com.google.cloud.tools.jib.api.Containerizer;\n+import com.google.cloud.tools.jib.api.DockerDaemonImage;\n+import com.google.cloud.tools.jib.api.ImageReference;\n+import com.google.cloud.tools.jib.api.InvalidImageReferenceException;\n+import com.google.cloud.tools.jib.api.LogEvent;\n+import com.google.cloud.tools.jib.api.RegistryImage;\n+import com.google.cloud.tools.jib.api.TarImage;\n+import com.google.cloud.tools.jib.cli.cli2.logging.CliLogger;\n+import com.google.cloud.tools.jib.event.events.ProgressEvent;\n+import com.google.cloud.tools.jib.event.progress.ProgressEventHandler;\n+import com.google.cloud.tools.jib.frontend.CredentialRetrieverFactory;\n+import com.google.cloud.tools.jib.global.JibSystemProperties;\n+import com.google.cloud.tools.jib.plugins.common.logging.ConsoleLogger;\n+import com.google.cloud.tools.jib.plugins.common.logging.ProgressDisplayGenerator;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+\n+/** Helper class for creating Containerizers from JibCli specifications. */\n+public class Containerizers {\n+\n+  /**\n+   * Create a Containerizer from a jibcli command line specification.\n+   *\n+   * @param buildOptions JibCli options\n+   * @return a populated Containerizer\n+   * @throws InvalidImageReferenceException if the image reference could not be parsed\n+   */\n+  public static Containerizer from(JibCli buildOptions) throws InvalidImageReferenceException {\n+    ConsoleLogger logger =\n+        CliLogger.newLogger(buildOptions.getVerbosity(), buildOptions.getConsoleOutput());\n+\n+    Containerizer containerizer = create(buildOptions, logger);\n+\n+    applyLogger(containerizer, logger);\n+    applyConfiguration(containerizer, buildOptions);\n+\n+    return containerizer;\n+  }\n+\n+  static Containerizer create(JibCli buildOptions, ConsoleLogger logger)\n+      throws InvalidImageReferenceException {\n+    String imageSpec = buildOptions.getTargetImage();\n+    if (imageSpec.startsWith(DOCKER_DAEMON_IMAGE_PREFIX)) {\n+      // TODO: allow setting docker env and docker executable (along with path/env)\n+      return Containerizer.to(\n+          DockerDaemonImage.named(imageSpec.replaceFirst(DOCKER_DAEMON_IMAGE_PREFIX, \"\")));\n+    }\n+    if (imageSpec.startsWith(TAR_IMAGE_PREFIX)) {\n+      return Containerizer.to(\n+          TarImage.at(Paths.get(imageSpec.replaceFirst(TAR_IMAGE_PREFIX, \"\")))\n+              .named(buildOptions.getName()));\n+    }\n+    ImageReference imageReference =\n+        ImageReference.parse(imageSpec.replaceFirst(REGISTRY_IMAGE_PREFIX, \"\"));\n+    RegistryImage registryImage = RegistryImage.named(imageReference);\n+    applyCredentialConfig(\n+        registryImage,\n+        CredentialRetrieverFactory.forImage(\n+            imageReference, logEvent -> logger.log(logEvent.getLevel(), logEvent.getMessage())),\n+        buildOptions);\n+    return Containerizer.to(registryImage);\n+  }\n+\n+  static void applyCredentialConfig(\n+      RegistryImage registryImage, CredentialRetrieverFactory factory, JibCli buildOptions) {\n+    if (buildOptions.getUsernamePassword().isPresent()) {", "originalCommit": "c66ce2f6cf51e6e8cf2f0188b090f09f07796941", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgzNTYwOA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2818#discussion_r505835608", "bodyText": "From the cli, it's impossible. It could be a verify, but this is tested in the JibCli test.", "author": "loosebazooka", "createdAt": "2020-10-15T20:48:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc4OTQ3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc5MDg3MQ==", "url": "https://github.com/GoogleContainerTools/jib/pull/2818#discussion_r505790871", "bodyText": "I think this needs a little more work for Windows (as in DefaultCredentialRetrievers.asList()). Add a TODO?", "author": "chanseokoh", "createdAt": "2020-10-15T19:34:39Z", "path": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/cli2/Containerizers.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.cli.cli2;\n+\n+import static com.google.cloud.tools.jib.api.Jib.DOCKER_DAEMON_IMAGE_PREFIX;\n+import static com.google.cloud.tools.jib.api.Jib.REGISTRY_IMAGE_PREFIX;\n+import static com.google.cloud.tools.jib.api.Jib.TAR_IMAGE_PREFIX;\n+\n+import com.google.cloud.tools.jib.api.Containerizer;\n+import com.google.cloud.tools.jib.api.DockerDaemonImage;\n+import com.google.cloud.tools.jib.api.ImageReference;\n+import com.google.cloud.tools.jib.api.InvalidImageReferenceException;\n+import com.google.cloud.tools.jib.api.LogEvent;\n+import com.google.cloud.tools.jib.api.RegistryImage;\n+import com.google.cloud.tools.jib.api.TarImage;\n+import com.google.cloud.tools.jib.cli.cli2.logging.CliLogger;\n+import com.google.cloud.tools.jib.event.events.ProgressEvent;\n+import com.google.cloud.tools.jib.event.progress.ProgressEventHandler;\n+import com.google.cloud.tools.jib.frontend.CredentialRetrieverFactory;\n+import com.google.cloud.tools.jib.global.JibSystemProperties;\n+import com.google.cloud.tools.jib.plugins.common.logging.ConsoleLogger;\n+import com.google.cloud.tools.jib.plugins.common.logging.ProgressDisplayGenerator;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+\n+/** Helper class for creating Containerizers from JibCli specifications. */\n+public class Containerizers {\n+\n+  /**\n+   * Create a Containerizer from a jibcli command line specification.\n+   *\n+   * @param buildOptions JibCli options\n+   * @return a populated Containerizer\n+   * @throws InvalidImageReferenceException if the image reference could not be parsed\n+   */\n+  public static Containerizer from(JibCli buildOptions) throws InvalidImageReferenceException {\n+    ConsoleLogger logger =\n+        CliLogger.newLogger(buildOptions.getVerbosity(), buildOptions.getConsoleOutput());\n+\n+    Containerizer containerizer = create(buildOptions, logger);\n+\n+    applyLogger(containerizer, logger);\n+    applyConfiguration(containerizer, buildOptions);\n+\n+    return containerizer;\n+  }\n+\n+  static Containerizer create(JibCli buildOptions, ConsoleLogger logger)\n+      throws InvalidImageReferenceException {\n+    String imageSpec = buildOptions.getTargetImage();\n+    if (imageSpec.startsWith(DOCKER_DAEMON_IMAGE_PREFIX)) {\n+      // TODO: allow setting docker env and docker executable (along with path/env)\n+      return Containerizer.to(\n+          DockerDaemonImage.named(imageSpec.replaceFirst(DOCKER_DAEMON_IMAGE_PREFIX, \"\")));\n+    }\n+    if (imageSpec.startsWith(TAR_IMAGE_PREFIX)) {\n+      return Containerizer.to(\n+          TarImage.at(Paths.get(imageSpec.replaceFirst(TAR_IMAGE_PREFIX, \"\")))\n+              .named(buildOptions.getName()));\n+    }\n+    ImageReference imageReference =\n+        ImageReference.parse(imageSpec.replaceFirst(REGISTRY_IMAGE_PREFIX, \"\"));\n+    RegistryImage registryImage = RegistryImage.named(imageReference);\n+    applyCredentialConfig(\n+        registryImage,\n+        CredentialRetrieverFactory.forImage(\n+            imageReference, logEvent -> logger.log(logEvent.getLevel(), logEvent.getMessage())),\n+        buildOptions);\n+    return Containerizer.to(registryImage);\n+  }\n+\n+  static void applyCredentialConfig(\n+      RegistryImage registryImage, CredentialRetrieverFactory factory, JibCli buildOptions) {\n+    if (buildOptions.getUsernamePassword().isPresent()) {\n+      registryImage.addCredentialRetriever(buildOptions::getUsernamePassword);\n+    } else if (buildOptions.getToUsernamePassword().isPresent()) {\n+      registryImage.addCredentialRetriever(buildOptions::getToUsernamePassword);\n+    }\n+    for (String credentialHelper : buildOptions.getCredentialHelpers()) {\n+      Path path = Paths.get(credentialHelper);\n+      if (Files.exists(path)) {\n+        registryImage.addCredentialRetriever(factory.dockerCredentialHelper(path));\n+      } else {", "originalCommit": "c66ce2f6cf51e6e8cf2f0188b090f09f07796941", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgzMjczMw==", "url": "https://github.com/GoogleContainerTools/jib/pull/2818#discussion_r505832733", "bodyText": "oh didn't know about this, basically just pulled this out of brian's code. I can just use that instead.", "author": "loosebazooka", "createdAt": "2020-10-15T20:44:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc5MDg3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgzNDU3Ng==", "url": "https://github.com/GoogleContainerTools/jib/pull/2818#discussion_r505834576", "bodyText": "Yeah, Brian must have copied the old DefaultCredentialRetrievers code, and then we fixed some Windows issues not long ago.", "author": "chanseokoh", "createdAt": "2020-10-15T20:46:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc5MDg3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc5NTAyNQ==", "url": "https://github.com/GoogleContainerTools/jib/pull/2818#discussion_r505795025", "bodyText": "We haven't finalized if we'll have a default build output directory somewhere, but we if do, it may make sense to put the application cache into it. But I feel a bit weird for a CLI tool like this to create some output directory.", "author": "chanseokoh", "createdAt": "2020-10-15T19:42:08Z", "path": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/cli2/Containerizers.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.cli.cli2;\n+\n+import static com.google.cloud.tools.jib.api.Jib.DOCKER_DAEMON_IMAGE_PREFIX;\n+import static com.google.cloud.tools.jib.api.Jib.REGISTRY_IMAGE_PREFIX;\n+import static com.google.cloud.tools.jib.api.Jib.TAR_IMAGE_PREFIX;\n+\n+import com.google.cloud.tools.jib.api.Containerizer;\n+import com.google.cloud.tools.jib.api.DockerDaemonImage;\n+import com.google.cloud.tools.jib.api.ImageReference;\n+import com.google.cloud.tools.jib.api.InvalidImageReferenceException;\n+import com.google.cloud.tools.jib.api.LogEvent;\n+import com.google.cloud.tools.jib.api.RegistryImage;\n+import com.google.cloud.tools.jib.api.TarImage;\n+import com.google.cloud.tools.jib.cli.cli2.logging.CliLogger;\n+import com.google.cloud.tools.jib.event.events.ProgressEvent;\n+import com.google.cloud.tools.jib.event.progress.ProgressEventHandler;\n+import com.google.cloud.tools.jib.frontend.CredentialRetrieverFactory;\n+import com.google.cloud.tools.jib.global.JibSystemProperties;\n+import com.google.cloud.tools.jib.plugins.common.logging.ConsoleLogger;\n+import com.google.cloud.tools.jib.plugins.common.logging.ProgressDisplayGenerator;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+\n+/** Helper class for creating Containerizers from JibCli specifications. */\n+public class Containerizers {\n+\n+  /**\n+   * Create a Containerizer from a jibcli command line specification.\n+   *\n+   * @param buildOptions JibCli options\n+   * @return a populated Containerizer\n+   * @throws InvalidImageReferenceException if the image reference could not be parsed\n+   */\n+  public static Containerizer from(JibCli buildOptions) throws InvalidImageReferenceException {\n+    ConsoleLogger logger =\n+        CliLogger.newLogger(buildOptions.getVerbosity(), buildOptions.getConsoleOutput());\n+\n+    Containerizer containerizer = create(buildOptions, logger);\n+\n+    applyLogger(containerizer, logger);\n+    applyConfiguration(containerizer, buildOptions);\n+\n+    return containerizer;\n+  }\n+\n+  static Containerizer create(JibCli buildOptions, ConsoleLogger logger)\n+      throws InvalidImageReferenceException {\n+    String imageSpec = buildOptions.getTargetImage();\n+    if (imageSpec.startsWith(DOCKER_DAEMON_IMAGE_PREFIX)) {\n+      // TODO: allow setting docker env and docker executable (along with path/env)\n+      return Containerizer.to(\n+          DockerDaemonImage.named(imageSpec.replaceFirst(DOCKER_DAEMON_IMAGE_PREFIX, \"\")));\n+    }\n+    if (imageSpec.startsWith(TAR_IMAGE_PREFIX)) {\n+      return Containerizer.to(\n+          TarImage.at(Paths.get(imageSpec.replaceFirst(TAR_IMAGE_PREFIX, \"\")))\n+              .named(buildOptions.getName()));\n+    }\n+    ImageReference imageReference =\n+        ImageReference.parse(imageSpec.replaceFirst(REGISTRY_IMAGE_PREFIX, \"\"));\n+    RegistryImage registryImage = RegistryImage.named(imageReference);\n+    applyCredentialConfig(\n+        registryImage,\n+        CredentialRetrieverFactory.forImage(\n+            imageReference, logEvent -> logger.log(logEvent.getLevel(), logEvent.getMessage())),\n+        buildOptions);\n+    return Containerizer.to(registryImage);\n+  }\n+\n+  static void applyCredentialConfig(\n+      RegistryImage registryImage, CredentialRetrieverFactory factory, JibCli buildOptions) {\n+    if (buildOptions.getUsernamePassword().isPresent()) {\n+      registryImage.addCredentialRetriever(buildOptions::getUsernamePassword);\n+    } else if (buildOptions.getToUsernamePassword().isPresent()) {\n+      registryImage.addCredentialRetriever(buildOptions::getToUsernamePassword);\n+    }\n+    for (String credentialHelper : buildOptions.getCredentialHelpers()) {\n+      Path path = Paths.get(credentialHelper);\n+      if (Files.exists(path)) {\n+        registryImage.addCredentialRetriever(factory.dockerCredentialHelper(path));\n+      } else {\n+        registryImage.addCredentialRetriever(factory.dockerCredentialHelper(credentialHelper));\n+      }\n+    }\n+    // then add any other known helpers\n+    registryImage.addCredentialRetriever(factory.dockerConfig());\n+    registryImage.addCredentialRetriever(factory.wellKnownCredentialHelpers());\n+    registryImage.addCredentialRetriever(factory.googleApplicationDefaultCredentials());\n+  }\n+\n+  static void applyConfiguration(Containerizer containerizer, JibCli buildOptions) {\n+    containerizer.setToolName(VersionInfo.TOOL_NAME);\n+    containerizer.setToolVersion(VersionInfo.getVersionSimple());\n+\n+    // TODO: it's strange that we use system properties to set these\n+    // TODO: perhaps we should expose these as configuration options on the containerizer\n+    if (buildOptions.isSendCredentialsOverHttp()) {\n+      System.setProperty(JibSystemProperties.SEND_CREDENTIALS_OVER_HTTP, Boolean.TRUE.toString());\n+    }\n+    if (buildOptions.isSerialize()) {\n+      System.setProperty(JibSystemProperties.SERIALIZE, Boolean.TRUE.toString());\n+    }\n+\n+    containerizer.setAllowInsecureRegistries(buildOptions.isAllowInsecureRegistries());\n+    buildOptions.getBaseImageCache().ifPresent(containerizer::setBaseImageLayersCache);\n+    buildOptions.getApplicationCache().ifPresent(containerizer::setApplicationLayersCache);", "originalCommit": "c66ce2f6cf51e6e8cf2f0188b090f09f07796941", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgzMDM4Mw==", "url": "https://github.com/GoogleContainerTools/jib/pull/2818#discussion_r505830383", "bodyText": "the default behavior is to use a temporary directory right now.", "author": "loosebazooka", "createdAt": "2020-10-15T20:42:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc5NTAyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc5NjE2MQ==", "url": "https://github.com/GoogleContainerTools/jib/pull/2818#discussion_r505796161", "bodyText": "nit: final", "author": "chanseokoh", "createdAt": "2020-10-15T19:43:52Z", "path": "jib-cli/src/test/java/com/google/cloud/tools/jib/cli/cli2/ContainerizersTest.java", "diffHunk": "@@ -0,0 +1,275 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.cli.cli2;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static com.google.common.truth.Truth8.assertThat;\n+import static org.mockito.Mockito.any;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.when;\n+\n+import com.google.cloud.tools.jib.api.CacheDirectoryCreationException;\n+import com.google.cloud.tools.jib.api.Containerizer;\n+import com.google.cloud.tools.jib.api.ContainerizerTestProxy;\n+import com.google.cloud.tools.jib.api.Credential;\n+import com.google.cloud.tools.jib.api.CredentialRetriever;\n+import com.google.cloud.tools.jib.api.InvalidImageReferenceException;\n+import com.google.cloud.tools.jib.api.RegistryImage;\n+import com.google.cloud.tools.jib.configuration.ImageConfiguration;\n+import com.google.cloud.tools.jib.frontend.CredentialRetrieverFactory;\n+import com.google.cloud.tools.jib.global.JibSystemProperties;\n+import com.google.cloud.tools.jib.registry.credentials.CredentialRetrievalException;\n+import com.google.common.collect.ImmutableSet;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.contrib.java.lang.system.RestoreSystemProperties;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.RunWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n+import picocli.CommandLine;\n+\n+public class ContainerizersTest {\n+\n+  @Rule public TemporaryFolder temporaryFolder = new TemporaryFolder();\n+  // Containerizers will add system properties based on cli properties\n+  @Rule public RestoreSystemProperties restoreSystemProperties = new RestoreSystemProperties();", "originalCommit": "c66ce2f6cf51e6e8cf2f0188b090f09f07796941", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc5Njk0Mw==", "url": "https://github.com/GoogleContainerTools/jib/pull/2818#discussion_r505796943", "bodyText": "final", "author": "chanseokoh", "createdAt": "2020-10-15T19:45:21Z", "path": "jib-cli/src/test/java/com/google/cloud/tools/jib/cli/cli2/ContainerizersTest.java", "diffHunk": "@@ -0,0 +1,275 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.cli.cli2;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static com.google.common.truth.Truth8.assertThat;\n+import static org.mockito.Mockito.any;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.when;\n+\n+import com.google.cloud.tools.jib.api.CacheDirectoryCreationException;\n+import com.google.cloud.tools.jib.api.Containerizer;\n+import com.google.cloud.tools.jib.api.ContainerizerTestProxy;\n+import com.google.cloud.tools.jib.api.Credential;\n+import com.google.cloud.tools.jib.api.CredentialRetriever;\n+import com.google.cloud.tools.jib.api.InvalidImageReferenceException;\n+import com.google.cloud.tools.jib.api.RegistryImage;\n+import com.google.cloud.tools.jib.configuration.ImageConfiguration;\n+import com.google.cloud.tools.jib.frontend.CredentialRetrieverFactory;\n+import com.google.cloud.tools.jib.global.JibSystemProperties;\n+import com.google.cloud.tools.jib.registry.credentials.CredentialRetrievalException;\n+import com.google.common.collect.ImmutableSet;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.contrib.java.lang.system.RestoreSystemProperties;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.RunWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n+import picocli.CommandLine;\n+\n+public class ContainerizersTest {\n+\n+  @Rule public TemporaryFolder temporaryFolder = new TemporaryFolder();\n+  // Containerizers will add system properties based on cli properties\n+  @Rule public RestoreSystemProperties restoreSystemProperties = new RestoreSystemProperties();\n+\n+  @Test\n+  public void testApplyConfiguration_defaults() throws InvalidImageReferenceException {\n+    JibCli buildOptions = CommandLine.populateCommand(new JibCli(), \"-t\", \"test-image-ref\");\n+\n+    ContainerizerTestProxy containerizer =\n+        new ContainerizerTestProxy(Containerizers.from(buildOptions));\n+\n+    assertThat(Boolean.getBoolean(JibSystemProperties.SEND_CREDENTIALS_OVER_HTTP)).isFalse();\n+    assertThat(Boolean.getBoolean(JibSystemProperties.SERIALIZE)).isFalse();\n+    assertThat(containerizer.getToolName()).isEqualTo(VersionInfo.TOOL_NAME);\n+    assertThat(containerizer.getToolVersion()).isEqualTo(VersionInfo.getVersionSimple());\n+    assertThat(Boolean.getBoolean(\"sendCredentialsOverHttp\")).isFalse();\n+    assertThat(containerizer.getAllowInsecureRegistries()).isFalse();\n+    assertThat(containerizer.getBaseImageLayersCacheDirectory())\n+        .isEqualTo(Containerizer.DEFAULT_BASE_CACHE_DIRECTORY);\n+    // it's a little hard to test applicationLayersCacheDirectory defaults here, so intentionally\n+    // skipped\n+    assertThat(containerizer.getAdditionalTags()).isEqualTo(ImmutableSet.of());\n+  }\n+\n+  @Test\n+  public void testApplyConfiguration_withValues()\n+      throws InvalidImageReferenceException, CacheDirectoryCreationException {\n+    JibCli buildOptions =\n+        CommandLine.populateCommand(\n+            new JibCli(),\n+            \"-t=test-image-ref\",\n+            \"--send-credentials-over-http\",\n+            \"--allow-insecure-registries\",\n+            \"--base-image-cache=./bi-cache\",\n+            \"--application-cache=./app-cache\",\n+            \"--additional-tags=tag1,tag2\",\n+            \"--serialize\");\n+\n+    ContainerizerTestProxy containerizer =\n+        new ContainerizerTestProxy(Containerizers.from(buildOptions));\n+\n+    assertThat(Boolean.getBoolean(JibSystemProperties.SEND_CREDENTIALS_OVER_HTTP)).isTrue();\n+    assertThat(Boolean.getBoolean(JibSystemProperties.SERIALIZE)).isTrue();\n+    assertThat(containerizer.getAllowInsecureRegistries()).isTrue();\n+    assertThat(containerizer.getBaseImageLayersCacheDirectory()).isEqualTo(Paths.get(\"./bi-cache\"));\n+    assertThat(containerizer.getApplicationsLayersCacheDirectory())\n+        .isEqualTo(Paths.get(\"./app-cache\"));\n+    assertThat(containerizer.getAdditionalTags()).isEqualTo(ImmutableSet.of(\"tag1\", \"tag2\"));\n+  }\n+\n+  @Test\n+  public void testFrom_dockerDaemonImage() throws InvalidImageReferenceException {\n+    JibCli buildOptions =\n+        CommandLine.populateCommand(new JibCli(), \"-t\", \"docker://gcr.io/test/test-image-ref\");\n+    ContainerizerTestProxy containerizer =\n+        new ContainerizerTestProxy(Containerizers.from(buildOptions));\n+\n+    assertThat(containerizer.getDescription()).isEqualTo(\"Building image to Docker daemon\");\n+    ImageConfiguration config = containerizer.getImageConfiguration();\n+\n+    assertThat(config.getCredentialRetrievers()).isEmpty();\n+    assertThat(config.getDockerClient()).isEmpty();\n+    assertThat(config.getImage().toString()).isEqualTo(\"gcr.io/test/test-image-ref\");\n+    assertThat(config.getTarPath()).isEmpty();\n+  }\n+\n+  @Test\n+  public void testFrom_tarImage() throws InvalidImageReferenceException, IOException {\n+    Path tarPath = temporaryFolder.getRoot().toPath().resolve(\"test-tar.tar\");\n+    JibCli buildOptions =\n+        CommandLine.populateCommand(\n+            new JibCli(),\n+            \"-t\",\n+            \"tar://\" + tarPath.toAbsolutePath(),\n+            \"--name\",\n+            \"gcr.io/test/test-image-ref\");\n+    ContainerizerTestProxy containerizer =\n+        new ContainerizerTestProxy(Containerizers.from(buildOptions));\n+\n+    assertThat(containerizer.getDescription()).isEqualTo(\"Building image tarball\");\n+    ImageConfiguration config = containerizer.getImageConfiguration();\n+\n+    assertThat(config.getCredentialRetrievers()).isEmpty();\n+    assertThat(config.getDockerClient()).isEmpty();\n+    assertThat(config.getImage().toString()).isEqualTo(\"gcr.io/test/test-image-ref\");\n+    assertThat(config.getTarPath()).isEmpty(); // weird, but the way jib currently works\n+  }\n+\n+  @Test\n+  public void testFrom_registryImage() throws InvalidImageReferenceException, IOException {\n+    JibCli buildOptions =\n+        CommandLine.populateCommand(new JibCli(), \"-t\", \"registry://gcr.io/test/test-image-ref\");\n+    ContainerizerTestProxy containerizer =\n+        new ContainerizerTestProxy(Containerizers.from(buildOptions));\n+\n+    // description from Containerizer.java\n+    assertThat(containerizer.getDescription()).isEqualTo(\"Building and pushing image\");\n+    ImageConfiguration config = containerizer.getImageConfiguration();\n+\n+    assertThat(config.getCredentialRetrievers()).isNotEmpty();\n+    assertThat(config.getDockerClient()).isEmpty();\n+    assertThat(config.getImage().toString()).isEqualTo(\"gcr.io/test/test-image-ref\");\n+    assertThat(config.getTarPath()).isEmpty();\n+  }\n+\n+  @RunWith(MockitoJUnitRunner.class)\n+  public static class CrendentialConfigurationTests {\n+\n+    @Rule public TemporaryFolder testRoot = new TemporaryFolder();", "originalCommit": "c66ce2f6cf51e6e8cf2f0188b090f09f07796941", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc5NzAxOA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2818#discussion_r505797018", "bodyText": "private", "author": "chanseokoh", "createdAt": "2020-10-15T19:45:28Z", "path": "jib-cli/src/test/java/com/google/cloud/tools/jib/cli/cli2/ContainerizersTest.java", "diffHunk": "@@ -0,0 +1,275 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.cli.cli2;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static com.google.common.truth.Truth8.assertThat;\n+import static org.mockito.Mockito.any;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.when;\n+\n+import com.google.cloud.tools.jib.api.CacheDirectoryCreationException;\n+import com.google.cloud.tools.jib.api.Containerizer;\n+import com.google.cloud.tools.jib.api.ContainerizerTestProxy;\n+import com.google.cloud.tools.jib.api.Credential;\n+import com.google.cloud.tools.jib.api.CredentialRetriever;\n+import com.google.cloud.tools.jib.api.InvalidImageReferenceException;\n+import com.google.cloud.tools.jib.api.RegistryImage;\n+import com.google.cloud.tools.jib.configuration.ImageConfiguration;\n+import com.google.cloud.tools.jib.frontend.CredentialRetrieverFactory;\n+import com.google.cloud.tools.jib.global.JibSystemProperties;\n+import com.google.cloud.tools.jib.registry.credentials.CredentialRetrievalException;\n+import com.google.common.collect.ImmutableSet;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.contrib.java.lang.system.RestoreSystemProperties;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.RunWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n+import picocli.CommandLine;\n+\n+public class ContainerizersTest {\n+\n+  @Rule public TemporaryFolder temporaryFolder = new TemporaryFolder();\n+  // Containerizers will add system properties based on cli properties\n+  @Rule public RestoreSystemProperties restoreSystemProperties = new RestoreSystemProperties();\n+\n+  @Test\n+  public void testApplyConfiguration_defaults() throws InvalidImageReferenceException {\n+    JibCli buildOptions = CommandLine.populateCommand(new JibCli(), \"-t\", \"test-image-ref\");\n+\n+    ContainerizerTestProxy containerizer =\n+        new ContainerizerTestProxy(Containerizers.from(buildOptions));\n+\n+    assertThat(Boolean.getBoolean(JibSystemProperties.SEND_CREDENTIALS_OVER_HTTP)).isFalse();\n+    assertThat(Boolean.getBoolean(JibSystemProperties.SERIALIZE)).isFalse();\n+    assertThat(containerizer.getToolName()).isEqualTo(VersionInfo.TOOL_NAME);\n+    assertThat(containerizer.getToolVersion()).isEqualTo(VersionInfo.getVersionSimple());\n+    assertThat(Boolean.getBoolean(\"sendCredentialsOverHttp\")).isFalse();\n+    assertThat(containerizer.getAllowInsecureRegistries()).isFalse();\n+    assertThat(containerizer.getBaseImageLayersCacheDirectory())\n+        .isEqualTo(Containerizer.DEFAULT_BASE_CACHE_DIRECTORY);\n+    // it's a little hard to test applicationLayersCacheDirectory defaults here, so intentionally\n+    // skipped\n+    assertThat(containerizer.getAdditionalTags()).isEqualTo(ImmutableSet.of());\n+  }\n+\n+  @Test\n+  public void testApplyConfiguration_withValues()\n+      throws InvalidImageReferenceException, CacheDirectoryCreationException {\n+    JibCli buildOptions =\n+        CommandLine.populateCommand(\n+            new JibCli(),\n+            \"-t=test-image-ref\",\n+            \"--send-credentials-over-http\",\n+            \"--allow-insecure-registries\",\n+            \"--base-image-cache=./bi-cache\",\n+            \"--application-cache=./app-cache\",\n+            \"--additional-tags=tag1,tag2\",\n+            \"--serialize\");\n+\n+    ContainerizerTestProxy containerizer =\n+        new ContainerizerTestProxy(Containerizers.from(buildOptions));\n+\n+    assertThat(Boolean.getBoolean(JibSystemProperties.SEND_CREDENTIALS_OVER_HTTP)).isTrue();\n+    assertThat(Boolean.getBoolean(JibSystemProperties.SERIALIZE)).isTrue();\n+    assertThat(containerizer.getAllowInsecureRegistries()).isTrue();\n+    assertThat(containerizer.getBaseImageLayersCacheDirectory()).isEqualTo(Paths.get(\"./bi-cache\"));\n+    assertThat(containerizer.getApplicationsLayersCacheDirectory())\n+        .isEqualTo(Paths.get(\"./app-cache\"));\n+    assertThat(containerizer.getAdditionalTags()).isEqualTo(ImmutableSet.of(\"tag1\", \"tag2\"));\n+  }\n+\n+  @Test\n+  public void testFrom_dockerDaemonImage() throws InvalidImageReferenceException {\n+    JibCli buildOptions =\n+        CommandLine.populateCommand(new JibCli(), \"-t\", \"docker://gcr.io/test/test-image-ref\");\n+    ContainerizerTestProxy containerizer =\n+        new ContainerizerTestProxy(Containerizers.from(buildOptions));\n+\n+    assertThat(containerizer.getDescription()).isEqualTo(\"Building image to Docker daemon\");\n+    ImageConfiguration config = containerizer.getImageConfiguration();\n+\n+    assertThat(config.getCredentialRetrievers()).isEmpty();\n+    assertThat(config.getDockerClient()).isEmpty();\n+    assertThat(config.getImage().toString()).isEqualTo(\"gcr.io/test/test-image-ref\");\n+    assertThat(config.getTarPath()).isEmpty();\n+  }\n+\n+  @Test\n+  public void testFrom_tarImage() throws InvalidImageReferenceException, IOException {\n+    Path tarPath = temporaryFolder.getRoot().toPath().resolve(\"test-tar.tar\");\n+    JibCli buildOptions =\n+        CommandLine.populateCommand(\n+            new JibCli(),\n+            \"-t\",\n+            \"tar://\" + tarPath.toAbsolutePath(),\n+            \"--name\",\n+            \"gcr.io/test/test-image-ref\");\n+    ContainerizerTestProxy containerizer =\n+        new ContainerizerTestProxy(Containerizers.from(buildOptions));\n+\n+    assertThat(containerizer.getDescription()).isEqualTo(\"Building image tarball\");\n+    ImageConfiguration config = containerizer.getImageConfiguration();\n+\n+    assertThat(config.getCredentialRetrievers()).isEmpty();\n+    assertThat(config.getDockerClient()).isEmpty();\n+    assertThat(config.getImage().toString()).isEqualTo(\"gcr.io/test/test-image-ref\");\n+    assertThat(config.getTarPath()).isEmpty(); // weird, but the way jib currently works\n+  }\n+\n+  @Test\n+  public void testFrom_registryImage() throws InvalidImageReferenceException, IOException {\n+    JibCli buildOptions =\n+        CommandLine.populateCommand(new JibCli(), \"-t\", \"registry://gcr.io/test/test-image-ref\");\n+    ContainerizerTestProxy containerizer =\n+        new ContainerizerTestProxy(Containerizers.from(buildOptions));\n+\n+    // description from Containerizer.java\n+    assertThat(containerizer.getDescription()).isEqualTo(\"Building and pushing image\");\n+    ImageConfiguration config = containerizer.getImageConfiguration();\n+\n+    assertThat(config.getCredentialRetrievers()).isNotEmpty();\n+    assertThat(config.getDockerClient()).isEmpty();\n+    assertThat(config.getImage().toString()).isEqualTo(\"gcr.io/test/test-image-ref\");\n+    assertThat(config.getTarPath()).isEmpty();\n+  }\n+\n+  @RunWith(MockitoJUnitRunner.class)\n+  public static class CrendentialConfigurationTests {\n+\n+    @Rule public TemporaryFolder testRoot = new TemporaryFolder();\n+\n+    @Mock CredentialRetrieverFactory mockCredentialRetrieverFactory;\n+    @Mock CredentialRetriever mockCredentialRetriever;\n+    @Mock RegistryImage mockRegistryImage;\n+\n+    @Mock CredentialRetriever mockCredentialRetrieverFromPath;\n+    @Mock CredentialRetriever mockCredentialRetrieverFromString;", "originalCommit": "c66ce2f6cf51e6e8cf2f0188b090f09f07796941", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc5ODAzMg==", "url": "https://github.com/GoogleContainerTools/jib/pull/2818#discussion_r505798032", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  // verify we added our intended credential helper\n          \n          \n            \n                  // verify we added our intended credential retriever", "author": "chanseokoh", "createdAt": "2020-10-15T19:47:33Z", "path": "jib-cli/src/test/java/com/google/cloud/tools/jib/cli/cli2/ContainerizersTest.java", "diffHunk": "@@ -0,0 +1,275 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.cli.cli2;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static com.google.common.truth.Truth8.assertThat;\n+import static org.mockito.Mockito.any;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.when;\n+\n+import com.google.cloud.tools.jib.api.CacheDirectoryCreationException;\n+import com.google.cloud.tools.jib.api.Containerizer;\n+import com.google.cloud.tools.jib.api.ContainerizerTestProxy;\n+import com.google.cloud.tools.jib.api.Credential;\n+import com.google.cloud.tools.jib.api.CredentialRetriever;\n+import com.google.cloud.tools.jib.api.InvalidImageReferenceException;\n+import com.google.cloud.tools.jib.api.RegistryImage;\n+import com.google.cloud.tools.jib.configuration.ImageConfiguration;\n+import com.google.cloud.tools.jib.frontend.CredentialRetrieverFactory;\n+import com.google.cloud.tools.jib.global.JibSystemProperties;\n+import com.google.cloud.tools.jib.registry.credentials.CredentialRetrievalException;\n+import com.google.common.collect.ImmutableSet;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.contrib.java.lang.system.RestoreSystemProperties;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.RunWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n+import picocli.CommandLine;\n+\n+public class ContainerizersTest {\n+\n+  @Rule public TemporaryFolder temporaryFolder = new TemporaryFolder();\n+  // Containerizers will add system properties based on cli properties\n+  @Rule public RestoreSystemProperties restoreSystemProperties = new RestoreSystemProperties();\n+\n+  @Test\n+  public void testApplyConfiguration_defaults() throws InvalidImageReferenceException {\n+    JibCli buildOptions = CommandLine.populateCommand(new JibCli(), \"-t\", \"test-image-ref\");\n+\n+    ContainerizerTestProxy containerizer =\n+        new ContainerizerTestProxy(Containerizers.from(buildOptions));\n+\n+    assertThat(Boolean.getBoolean(JibSystemProperties.SEND_CREDENTIALS_OVER_HTTP)).isFalse();\n+    assertThat(Boolean.getBoolean(JibSystemProperties.SERIALIZE)).isFalse();\n+    assertThat(containerizer.getToolName()).isEqualTo(VersionInfo.TOOL_NAME);\n+    assertThat(containerizer.getToolVersion()).isEqualTo(VersionInfo.getVersionSimple());\n+    assertThat(Boolean.getBoolean(\"sendCredentialsOverHttp\")).isFalse();\n+    assertThat(containerizer.getAllowInsecureRegistries()).isFalse();\n+    assertThat(containerizer.getBaseImageLayersCacheDirectory())\n+        .isEqualTo(Containerizer.DEFAULT_BASE_CACHE_DIRECTORY);\n+    // it's a little hard to test applicationLayersCacheDirectory defaults here, so intentionally\n+    // skipped\n+    assertThat(containerizer.getAdditionalTags()).isEqualTo(ImmutableSet.of());\n+  }\n+\n+  @Test\n+  public void testApplyConfiguration_withValues()\n+      throws InvalidImageReferenceException, CacheDirectoryCreationException {\n+    JibCli buildOptions =\n+        CommandLine.populateCommand(\n+            new JibCli(),\n+            \"-t=test-image-ref\",\n+            \"--send-credentials-over-http\",\n+            \"--allow-insecure-registries\",\n+            \"--base-image-cache=./bi-cache\",\n+            \"--application-cache=./app-cache\",\n+            \"--additional-tags=tag1,tag2\",\n+            \"--serialize\");\n+\n+    ContainerizerTestProxy containerizer =\n+        new ContainerizerTestProxy(Containerizers.from(buildOptions));\n+\n+    assertThat(Boolean.getBoolean(JibSystemProperties.SEND_CREDENTIALS_OVER_HTTP)).isTrue();\n+    assertThat(Boolean.getBoolean(JibSystemProperties.SERIALIZE)).isTrue();\n+    assertThat(containerizer.getAllowInsecureRegistries()).isTrue();\n+    assertThat(containerizer.getBaseImageLayersCacheDirectory()).isEqualTo(Paths.get(\"./bi-cache\"));\n+    assertThat(containerizer.getApplicationsLayersCacheDirectory())\n+        .isEqualTo(Paths.get(\"./app-cache\"));\n+    assertThat(containerizer.getAdditionalTags()).isEqualTo(ImmutableSet.of(\"tag1\", \"tag2\"));\n+  }\n+\n+  @Test\n+  public void testFrom_dockerDaemonImage() throws InvalidImageReferenceException {\n+    JibCli buildOptions =\n+        CommandLine.populateCommand(new JibCli(), \"-t\", \"docker://gcr.io/test/test-image-ref\");\n+    ContainerizerTestProxy containerizer =\n+        new ContainerizerTestProxy(Containerizers.from(buildOptions));\n+\n+    assertThat(containerizer.getDescription()).isEqualTo(\"Building image to Docker daemon\");\n+    ImageConfiguration config = containerizer.getImageConfiguration();\n+\n+    assertThat(config.getCredentialRetrievers()).isEmpty();\n+    assertThat(config.getDockerClient()).isEmpty();\n+    assertThat(config.getImage().toString()).isEqualTo(\"gcr.io/test/test-image-ref\");\n+    assertThat(config.getTarPath()).isEmpty();\n+  }\n+\n+  @Test\n+  public void testFrom_tarImage() throws InvalidImageReferenceException, IOException {\n+    Path tarPath = temporaryFolder.getRoot().toPath().resolve(\"test-tar.tar\");\n+    JibCli buildOptions =\n+        CommandLine.populateCommand(\n+            new JibCli(),\n+            \"-t\",\n+            \"tar://\" + tarPath.toAbsolutePath(),\n+            \"--name\",\n+            \"gcr.io/test/test-image-ref\");\n+    ContainerizerTestProxy containerizer =\n+        new ContainerizerTestProxy(Containerizers.from(buildOptions));\n+\n+    assertThat(containerizer.getDescription()).isEqualTo(\"Building image tarball\");\n+    ImageConfiguration config = containerizer.getImageConfiguration();\n+\n+    assertThat(config.getCredentialRetrievers()).isEmpty();\n+    assertThat(config.getDockerClient()).isEmpty();\n+    assertThat(config.getImage().toString()).isEqualTo(\"gcr.io/test/test-image-ref\");\n+    assertThat(config.getTarPath()).isEmpty(); // weird, but the way jib currently works\n+  }\n+\n+  @Test\n+  public void testFrom_registryImage() throws InvalidImageReferenceException, IOException {\n+    JibCli buildOptions =\n+        CommandLine.populateCommand(new JibCli(), \"-t\", \"registry://gcr.io/test/test-image-ref\");\n+    ContainerizerTestProxy containerizer =\n+        new ContainerizerTestProxy(Containerizers.from(buildOptions));\n+\n+    // description from Containerizer.java\n+    assertThat(containerizer.getDescription()).isEqualTo(\"Building and pushing image\");\n+    ImageConfiguration config = containerizer.getImageConfiguration();\n+\n+    assertThat(config.getCredentialRetrievers()).isNotEmpty();\n+    assertThat(config.getDockerClient()).isEmpty();\n+    assertThat(config.getImage().toString()).isEqualTo(\"gcr.io/test/test-image-ref\");\n+    assertThat(config.getTarPath()).isEmpty();\n+  }\n+\n+  @RunWith(MockitoJUnitRunner.class)\n+  public static class CrendentialConfigurationTests {\n+\n+    @Rule public TemporaryFolder testRoot = new TemporaryFolder();\n+\n+    @Mock CredentialRetrieverFactory mockCredentialRetrieverFactory;\n+    @Mock CredentialRetriever mockCredentialRetriever;\n+    @Mock RegistryImage mockRegistryImage;\n+\n+    @Mock CredentialRetriever mockCredentialRetrieverFromPath;\n+    @Mock CredentialRetriever mockCredentialRetrieverFromString;\n+\n+    @Before\n+    public void setupMocks() {\n+      when(mockCredentialRetrieverFactory.dockerConfig()).thenReturn(mockCredentialRetriever);\n+      when(mockCredentialRetrieverFactory.wellKnownCredentialHelpers())\n+          .thenReturn(mockCredentialRetriever);\n+      when(mockCredentialRetrieverFactory.googleApplicationDefaultCredentials())\n+          .thenReturn(mockCredentialRetriever);\n+\n+      when(mockCredentialRetrieverFactory.dockerCredentialHelper(any(Path.class)))\n+          .thenReturn(mockCredentialRetrieverFromPath);\n+      when(mockCredentialRetrieverFactory.dockerCredentialHelper(any(String.class)))\n+          .thenReturn(mockCredentialRetrieverFromString);\n+    }\n+\n+    @Test\n+    public void testApplyCredentialConfig_credhelperString() {\n+      JibCli buildOptions =\n+          CommandLine.populateCommand(\n+              new JibCli(), \"--target=ignored.io/igored/ignored\", \"--credential-helper=any-string\");\n+      Containerizers.applyCredentialConfig(\n+          mockRegistryImage, mockCredentialRetrieverFactory, buildOptions);\n+\n+      // verify we added our intended credential helper\n+      verify(mockRegistryImage).addCredentialRetriever(mockCredentialRetrieverFromString);\n+      // auto added credentials\n+      verify(mockRegistryImage, times(3)).addCredentialRetriever(mockCredentialRetriever);\n+      verifyNoMoreInteractions(mockRegistryImage);\n+    }\n+\n+    @Test\n+    public void testApplyCredentialConfig_credhelperFile() throws IOException {\n+      Path credHelperFile = testRoot.newFile(\"cred-helper.sh\").toPath();\n+      JibCli buildOptions =\n+          CommandLine.populateCommand(\n+              new JibCli(),\n+              \"--target=ignored.io/igored/ignored\",\n+              \"--credential-helper\",\n+              credHelperFile.toAbsolutePath().toString());\n+      Containerizers.applyCredentialConfig(\n+          mockRegistryImage, mockCredentialRetrieverFactory, buildOptions);\n+\n+      // verify we added our intended credential helper\n+      verify(mockRegistryImage).addCredentialRetriever(mockCredentialRetrieverFromPath);\n+      // auto added credentials\n+      verify(mockRegistryImage, times(3)).addCredentialRetriever(mockCredentialRetriever);\n+      verifyNoMoreInteractions(mockRegistryImage);\n+    }\n+\n+    @Test\n+    public void testApplyCredentialConfig_usernamePassword() throws CredentialRetrievalException {\n+      JibCli buildOptions =\n+          CommandLine.populateCommand(\n+              new JibCli(),\n+              \"--target=ignored.io/igored/ignored\",\n+              \"--username=test-username\",\n+              \"--password=test-password\");\n+      Containerizers.applyCredentialConfig(\n+          mockRegistryImage, mockCredentialRetrieverFactory, buildOptions);\n+\n+      // verify we added our intended credential helper", "originalCommit": "c66ce2f6cf51e6e8cf2f0188b090f09f07796941", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc5ODEzNw==", "url": "https://github.com/GoogleContainerTools/jib/pull/2818#discussion_r505798137", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  // verify we added our intended credential helper\n          \n          \n            \n                  // verify we added our intended credential retriever", "author": "chanseokoh", "createdAt": "2020-10-15T19:47:46Z", "path": "jib-cli/src/test/java/com/google/cloud/tools/jib/cli/cli2/ContainerizersTest.java", "diffHunk": "@@ -0,0 +1,275 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.cli.cli2;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static com.google.common.truth.Truth8.assertThat;\n+import static org.mockito.Mockito.any;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.when;\n+\n+import com.google.cloud.tools.jib.api.CacheDirectoryCreationException;\n+import com.google.cloud.tools.jib.api.Containerizer;\n+import com.google.cloud.tools.jib.api.ContainerizerTestProxy;\n+import com.google.cloud.tools.jib.api.Credential;\n+import com.google.cloud.tools.jib.api.CredentialRetriever;\n+import com.google.cloud.tools.jib.api.InvalidImageReferenceException;\n+import com.google.cloud.tools.jib.api.RegistryImage;\n+import com.google.cloud.tools.jib.configuration.ImageConfiguration;\n+import com.google.cloud.tools.jib.frontend.CredentialRetrieverFactory;\n+import com.google.cloud.tools.jib.global.JibSystemProperties;\n+import com.google.cloud.tools.jib.registry.credentials.CredentialRetrievalException;\n+import com.google.common.collect.ImmutableSet;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.contrib.java.lang.system.RestoreSystemProperties;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.RunWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n+import picocli.CommandLine;\n+\n+public class ContainerizersTest {\n+\n+  @Rule public TemporaryFolder temporaryFolder = new TemporaryFolder();\n+  // Containerizers will add system properties based on cli properties\n+  @Rule public RestoreSystemProperties restoreSystemProperties = new RestoreSystemProperties();\n+\n+  @Test\n+  public void testApplyConfiguration_defaults() throws InvalidImageReferenceException {\n+    JibCli buildOptions = CommandLine.populateCommand(new JibCli(), \"-t\", \"test-image-ref\");\n+\n+    ContainerizerTestProxy containerizer =\n+        new ContainerizerTestProxy(Containerizers.from(buildOptions));\n+\n+    assertThat(Boolean.getBoolean(JibSystemProperties.SEND_CREDENTIALS_OVER_HTTP)).isFalse();\n+    assertThat(Boolean.getBoolean(JibSystemProperties.SERIALIZE)).isFalse();\n+    assertThat(containerizer.getToolName()).isEqualTo(VersionInfo.TOOL_NAME);\n+    assertThat(containerizer.getToolVersion()).isEqualTo(VersionInfo.getVersionSimple());\n+    assertThat(Boolean.getBoolean(\"sendCredentialsOverHttp\")).isFalse();\n+    assertThat(containerizer.getAllowInsecureRegistries()).isFalse();\n+    assertThat(containerizer.getBaseImageLayersCacheDirectory())\n+        .isEqualTo(Containerizer.DEFAULT_BASE_CACHE_DIRECTORY);\n+    // it's a little hard to test applicationLayersCacheDirectory defaults here, so intentionally\n+    // skipped\n+    assertThat(containerizer.getAdditionalTags()).isEqualTo(ImmutableSet.of());\n+  }\n+\n+  @Test\n+  public void testApplyConfiguration_withValues()\n+      throws InvalidImageReferenceException, CacheDirectoryCreationException {\n+    JibCli buildOptions =\n+        CommandLine.populateCommand(\n+            new JibCli(),\n+            \"-t=test-image-ref\",\n+            \"--send-credentials-over-http\",\n+            \"--allow-insecure-registries\",\n+            \"--base-image-cache=./bi-cache\",\n+            \"--application-cache=./app-cache\",\n+            \"--additional-tags=tag1,tag2\",\n+            \"--serialize\");\n+\n+    ContainerizerTestProxy containerizer =\n+        new ContainerizerTestProxy(Containerizers.from(buildOptions));\n+\n+    assertThat(Boolean.getBoolean(JibSystemProperties.SEND_CREDENTIALS_OVER_HTTP)).isTrue();\n+    assertThat(Boolean.getBoolean(JibSystemProperties.SERIALIZE)).isTrue();\n+    assertThat(containerizer.getAllowInsecureRegistries()).isTrue();\n+    assertThat(containerizer.getBaseImageLayersCacheDirectory()).isEqualTo(Paths.get(\"./bi-cache\"));\n+    assertThat(containerizer.getApplicationsLayersCacheDirectory())\n+        .isEqualTo(Paths.get(\"./app-cache\"));\n+    assertThat(containerizer.getAdditionalTags()).isEqualTo(ImmutableSet.of(\"tag1\", \"tag2\"));\n+  }\n+\n+  @Test\n+  public void testFrom_dockerDaemonImage() throws InvalidImageReferenceException {\n+    JibCli buildOptions =\n+        CommandLine.populateCommand(new JibCli(), \"-t\", \"docker://gcr.io/test/test-image-ref\");\n+    ContainerizerTestProxy containerizer =\n+        new ContainerizerTestProxy(Containerizers.from(buildOptions));\n+\n+    assertThat(containerizer.getDescription()).isEqualTo(\"Building image to Docker daemon\");\n+    ImageConfiguration config = containerizer.getImageConfiguration();\n+\n+    assertThat(config.getCredentialRetrievers()).isEmpty();\n+    assertThat(config.getDockerClient()).isEmpty();\n+    assertThat(config.getImage().toString()).isEqualTo(\"gcr.io/test/test-image-ref\");\n+    assertThat(config.getTarPath()).isEmpty();\n+  }\n+\n+  @Test\n+  public void testFrom_tarImage() throws InvalidImageReferenceException, IOException {\n+    Path tarPath = temporaryFolder.getRoot().toPath().resolve(\"test-tar.tar\");\n+    JibCli buildOptions =\n+        CommandLine.populateCommand(\n+            new JibCli(),\n+            \"-t\",\n+            \"tar://\" + tarPath.toAbsolutePath(),\n+            \"--name\",\n+            \"gcr.io/test/test-image-ref\");\n+    ContainerizerTestProxy containerizer =\n+        new ContainerizerTestProxy(Containerizers.from(buildOptions));\n+\n+    assertThat(containerizer.getDescription()).isEqualTo(\"Building image tarball\");\n+    ImageConfiguration config = containerizer.getImageConfiguration();\n+\n+    assertThat(config.getCredentialRetrievers()).isEmpty();\n+    assertThat(config.getDockerClient()).isEmpty();\n+    assertThat(config.getImage().toString()).isEqualTo(\"gcr.io/test/test-image-ref\");\n+    assertThat(config.getTarPath()).isEmpty(); // weird, but the way jib currently works\n+  }\n+\n+  @Test\n+  public void testFrom_registryImage() throws InvalidImageReferenceException, IOException {\n+    JibCli buildOptions =\n+        CommandLine.populateCommand(new JibCli(), \"-t\", \"registry://gcr.io/test/test-image-ref\");\n+    ContainerizerTestProxy containerizer =\n+        new ContainerizerTestProxy(Containerizers.from(buildOptions));\n+\n+    // description from Containerizer.java\n+    assertThat(containerizer.getDescription()).isEqualTo(\"Building and pushing image\");\n+    ImageConfiguration config = containerizer.getImageConfiguration();\n+\n+    assertThat(config.getCredentialRetrievers()).isNotEmpty();\n+    assertThat(config.getDockerClient()).isEmpty();\n+    assertThat(config.getImage().toString()).isEqualTo(\"gcr.io/test/test-image-ref\");\n+    assertThat(config.getTarPath()).isEmpty();\n+  }\n+\n+  @RunWith(MockitoJUnitRunner.class)\n+  public static class CrendentialConfigurationTests {\n+\n+    @Rule public TemporaryFolder testRoot = new TemporaryFolder();\n+\n+    @Mock CredentialRetrieverFactory mockCredentialRetrieverFactory;\n+    @Mock CredentialRetriever mockCredentialRetriever;\n+    @Mock RegistryImage mockRegistryImage;\n+\n+    @Mock CredentialRetriever mockCredentialRetrieverFromPath;\n+    @Mock CredentialRetriever mockCredentialRetrieverFromString;\n+\n+    @Before\n+    public void setupMocks() {\n+      when(mockCredentialRetrieverFactory.dockerConfig()).thenReturn(mockCredentialRetriever);\n+      when(mockCredentialRetrieverFactory.wellKnownCredentialHelpers())\n+          .thenReturn(mockCredentialRetriever);\n+      when(mockCredentialRetrieverFactory.googleApplicationDefaultCredentials())\n+          .thenReturn(mockCredentialRetriever);\n+\n+      when(mockCredentialRetrieverFactory.dockerCredentialHelper(any(Path.class)))\n+          .thenReturn(mockCredentialRetrieverFromPath);\n+      when(mockCredentialRetrieverFactory.dockerCredentialHelper(any(String.class)))\n+          .thenReturn(mockCredentialRetrieverFromString);\n+    }\n+\n+    @Test\n+    public void testApplyCredentialConfig_credhelperString() {\n+      JibCli buildOptions =\n+          CommandLine.populateCommand(\n+              new JibCli(), \"--target=ignored.io/igored/ignored\", \"--credential-helper=any-string\");\n+      Containerizers.applyCredentialConfig(\n+          mockRegistryImage, mockCredentialRetrieverFactory, buildOptions);\n+\n+      // verify we added our intended credential helper\n+      verify(mockRegistryImage).addCredentialRetriever(mockCredentialRetrieverFromString);\n+      // auto added credentials\n+      verify(mockRegistryImage, times(3)).addCredentialRetriever(mockCredentialRetriever);\n+      verifyNoMoreInteractions(mockRegistryImage);\n+    }\n+\n+    @Test\n+    public void testApplyCredentialConfig_credhelperFile() throws IOException {\n+      Path credHelperFile = testRoot.newFile(\"cred-helper.sh\").toPath();\n+      JibCli buildOptions =\n+          CommandLine.populateCommand(\n+              new JibCli(),\n+              \"--target=ignored.io/igored/ignored\",\n+              \"--credential-helper\",\n+              credHelperFile.toAbsolutePath().toString());\n+      Containerizers.applyCredentialConfig(\n+          mockRegistryImage, mockCredentialRetrieverFactory, buildOptions);\n+\n+      // verify we added our intended credential helper\n+      verify(mockRegistryImage).addCredentialRetriever(mockCredentialRetrieverFromPath);\n+      // auto added credentials\n+      verify(mockRegistryImage, times(3)).addCredentialRetriever(mockCredentialRetriever);\n+      verifyNoMoreInteractions(mockRegistryImage);\n+    }\n+\n+    @Test\n+    public void testApplyCredentialConfig_usernamePassword() throws CredentialRetrievalException {\n+      JibCli buildOptions =\n+          CommandLine.populateCommand(\n+              new JibCli(),\n+              \"--target=ignored.io/igored/ignored\",\n+              \"--username=test-username\",\n+              \"--password=test-password\");\n+      Containerizers.applyCredentialConfig(\n+          mockRegistryImage, mockCredentialRetrieverFactory, buildOptions);\n+\n+      // verify we added our intended credential helper\n+      ArgumentCaptor<CredentialRetriever> captor =\n+          ArgumentCaptor.forClass(CredentialRetriever.class);\n+      verify(mockRegistryImage, times(4)).addCredentialRetriever(captor.capture());\n+      List<CredentialRetriever> configuredRetrievers = captor.getAllValues();\n+\n+      assertThat(configuredRetrievers).hasSize(4);\n+      // remove all auto added credentials\n+      for (int i = 0; i < 3; i++) {\n+        assertThat(configuredRetrievers.remove(mockCredentialRetriever)).isTrue();\n+      }\n+      // check if our credential was added\n+      assertThat(configuredRetrievers.get(0).retrieve())\n+          .hasValue(Credential.from(\"test-username\", \"test-password\"));\n+    }\n+\n+    @Test\n+    public void testApplyCredentialConfig_toUsernamePassword() throws CredentialRetrievalException {\n+      JibCli buildOptions =\n+          CommandLine.populateCommand(\n+              new JibCli(),\n+              \"--target=ignored.io/igored/ignored\",\n+              \"--to-username=test-username\",\n+              \"--to-password=test-password\");\n+      Containerizers.applyCredentialConfig(\n+          mockRegistryImage, mockCredentialRetrieverFactory, buildOptions);\n+\n+      // verify we added our intended credential helper", "originalCommit": "c66ce2f6cf51e6e8cf2f0188b090f09f07796941", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "cc8637cc99c7302b66b618ddf47798c3bcd0a6e9", "url": "https://github.com/GoogleContainerTools/jib/commit/cc8637cc99c7302b66b618ddf47798c3bcd0a6e9", "message": "fixes", "committedDate": "2020-10-15T20:47:20Z", "type": "forcePushed"}, {"oid": "50de51dc18ab630c36d1d89264c9954d3e625ac9", "url": "https://github.com/GoogleContainerTools/jib/commit/50de51dc18ab630c36d1d89264c9954d3e625ac9", "message": "Create containerizer and build a container for CLI.", "committedDate": "2020-10-19T15:25:19Z", "type": "forcePushed"}, {"oid": "7dfa5754d6d2945df095c0e591f018c0664b0f4a", "url": "https://github.com/GoogleContainerTools/jib/commit/7dfa5754d6d2945df095c0e591f018c0664b0f4a", "message": "Create containerizer and build a container for CLI.", "committedDate": "2020-10-19T18:17:47Z", "type": "forcePushed"}, {"oid": "3e236fd4027337c7b212eb77b9f5d42f10387dda", "url": "https://github.com/GoogleContainerTools/jib/commit/3e236fd4027337c7b212eb77b9f5d42f10387dda", "message": "Create containerizer and build a container for CLI.", "committedDate": "2020-10-19T19:49:09Z", "type": "commit"}, {"oid": "3e236fd4027337c7b212eb77b9f5d42f10387dda", "url": "https://github.com/GoogleContainerTools/jib/commit/3e236fd4027337c7b212eb77b9f5d42f10387dda", "message": "Create containerizer and build a container for CLI.", "committedDate": "2020-10-19T19:49:09Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA5MTI2Nw==", "url": "https://github.com/GoogleContainerTools/jib/pull/2818#discussion_r508091267", "bodyText": "Nit: for consistency, we can use .forEach(containerizer::withAdditionalTag)?", "author": "chanseokoh", "createdAt": "2020-10-19T22:08:31Z", "path": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/cli2/Containerizers.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.cli.cli2;\n+\n+import static com.google.cloud.tools.jib.api.Jib.DOCKER_DAEMON_IMAGE_PREFIX;\n+import static com.google.cloud.tools.jib.api.Jib.REGISTRY_IMAGE_PREFIX;\n+import static com.google.cloud.tools.jib.api.Jib.TAR_IMAGE_PREFIX;\n+\n+import com.google.cloud.tools.jib.api.Containerizer;\n+import com.google.cloud.tools.jib.api.DockerDaemonImage;\n+import com.google.cloud.tools.jib.api.ImageReference;\n+import com.google.cloud.tools.jib.api.InvalidImageReferenceException;\n+import com.google.cloud.tools.jib.api.LogEvent;\n+import com.google.cloud.tools.jib.api.RegistryImage;\n+import com.google.cloud.tools.jib.api.TarImage;\n+import com.google.cloud.tools.jib.cli.cli2.logging.CliLogger;\n+import com.google.cloud.tools.jib.event.events.ProgressEvent;\n+import com.google.cloud.tools.jib.event.progress.ProgressEventHandler;\n+import com.google.cloud.tools.jib.frontend.CredentialRetrieverFactory;\n+import com.google.cloud.tools.jib.global.JibSystemProperties;\n+import com.google.cloud.tools.jib.plugins.common.DefaultCredentialRetrievers;\n+import com.google.cloud.tools.jib.plugins.common.logging.ConsoleLogger;\n+import com.google.cloud.tools.jib.plugins.common.logging.ProgressDisplayGenerator;\n+import java.io.FileNotFoundException;\n+import java.nio.file.Paths;\n+import java.util.List;\n+\n+/** Helper class for creating Containerizers from JibCli specifications. */\n+public class Containerizers {\n+\n+  /**\n+   * Create a Containerizer from a jibcli command line specification.\n+   *\n+   * @param buildOptions JibCli options\n+   * @return a populated Containerizer\n+   * @throws InvalidImageReferenceException if the image reference could not be parsed\n+   * @throws FileNotFoundException if a credential helper file is not found\n+   */\n+  public static Containerizer from(JibCli buildOptions)\n+      throws InvalidImageReferenceException, FileNotFoundException {\n+    ConsoleLogger logger =\n+        CliLogger.newLogger(buildOptions.getVerbosity(), buildOptions.getConsoleOutput());\n+\n+    Containerizer containerizer = create(buildOptions, logger);\n+\n+    applyHandlers(containerizer, logger);\n+    applyConfiguration(containerizer, buildOptions);\n+\n+    return containerizer;\n+  }\n+\n+  static Containerizer create(JibCli buildOptions, ConsoleLogger logger)\n+      throws InvalidImageReferenceException, FileNotFoundException {\n+    String imageSpec = buildOptions.getTargetImage();\n+    if (imageSpec.startsWith(DOCKER_DAEMON_IMAGE_PREFIX)) {\n+      // TODO: allow setting docker env and docker executable (along with path/env)\n+      return Containerizer.to(\n+          DockerDaemonImage.named(imageSpec.replaceFirst(DOCKER_DAEMON_IMAGE_PREFIX, \"\")));\n+    }\n+    if (imageSpec.startsWith(TAR_IMAGE_PREFIX)) {\n+      return Containerizer.to(\n+          TarImage.at(Paths.get(imageSpec.replaceFirst(TAR_IMAGE_PREFIX, \"\")))\n+              .named(buildOptions.getName()));\n+    }\n+    ImageReference imageReference =\n+        ImageReference.parse(imageSpec.replaceFirst(REGISTRY_IMAGE_PREFIX, \"\"));\n+    RegistryImage registryImage = RegistryImage.named(imageReference);\n+    DefaultCredentialRetrievers defaultCredentialRetrievers =\n+        DefaultCredentialRetrievers.init(\n+            CredentialRetrieverFactory.forImage(\n+                imageReference,\n+                logEvent -> logger.log(logEvent.getLevel(), logEvent.getMessage())));\n+    Credentials.getToCredentialRetrievers(buildOptions, defaultCredentialRetrievers)\n+        .forEach(registryImage::addCredentialRetriever);\n+    return Containerizer.to(registryImage);\n+  }\n+\n+  static void applyConfiguration(Containerizer containerizer, JibCli buildOptions) {\n+    containerizer.setToolName(VersionInfo.TOOL_NAME);\n+    containerizer.setToolVersion(VersionInfo.getVersionSimple());\n+\n+    // TODO: it's strange that we use system properties to set these\n+    // TODO: perhaps we should expose these as configuration options on the containerizer\n+    if (buildOptions.isSendCredentialsOverHttp()) {\n+      System.setProperty(JibSystemProperties.SEND_CREDENTIALS_OVER_HTTP, Boolean.TRUE.toString());\n+    }\n+    if (buildOptions.isSerialize()) {\n+      System.setProperty(JibSystemProperties.SERIALIZE, Boolean.TRUE.toString());\n+    }\n+\n+    containerizer.setAllowInsecureRegistries(buildOptions.isAllowInsecureRegistries());\n+    buildOptions.getBaseImageCache().ifPresent(containerizer::setBaseImageLayersCache);\n+    buildOptions.getApplicationCache().ifPresent(containerizer::setApplicationLayersCache);\n+\n+    for (String tag : buildOptions.getAdditionalTags()) {\n+      containerizer.withAdditionalTag(tag);\n+    }", "originalCommit": "3e236fd4027337c7b212eb77b9f5d42f10387dda", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA5MTUxMw==", "url": "https://github.com/GoogleContainerTools/jib/pull/2818#discussion_r508091513", "bodyText": "Can all there methods private?", "author": "chanseokoh", "createdAt": "2020-10-19T22:09:08Z", "path": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/cli2/Containerizers.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.cli.cli2;\n+\n+import static com.google.cloud.tools.jib.api.Jib.DOCKER_DAEMON_IMAGE_PREFIX;\n+import static com.google.cloud.tools.jib.api.Jib.REGISTRY_IMAGE_PREFIX;\n+import static com.google.cloud.tools.jib.api.Jib.TAR_IMAGE_PREFIX;\n+\n+import com.google.cloud.tools.jib.api.Containerizer;\n+import com.google.cloud.tools.jib.api.DockerDaemonImage;\n+import com.google.cloud.tools.jib.api.ImageReference;\n+import com.google.cloud.tools.jib.api.InvalidImageReferenceException;\n+import com.google.cloud.tools.jib.api.LogEvent;\n+import com.google.cloud.tools.jib.api.RegistryImage;\n+import com.google.cloud.tools.jib.api.TarImage;\n+import com.google.cloud.tools.jib.cli.cli2.logging.CliLogger;\n+import com.google.cloud.tools.jib.event.events.ProgressEvent;\n+import com.google.cloud.tools.jib.event.progress.ProgressEventHandler;\n+import com.google.cloud.tools.jib.frontend.CredentialRetrieverFactory;\n+import com.google.cloud.tools.jib.global.JibSystemProperties;\n+import com.google.cloud.tools.jib.plugins.common.DefaultCredentialRetrievers;\n+import com.google.cloud.tools.jib.plugins.common.logging.ConsoleLogger;\n+import com.google.cloud.tools.jib.plugins.common.logging.ProgressDisplayGenerator;\n+import java.io.FileNotFoundException;\n+import java.nio.file.Paths;\n+import java.util.List;\n+\n+/** Helper class for creating Containerizers from JibCli specifications. */\n+public class Containerizers {\n+\n+  /**\n+   * Create a Containerizer from a jibcli command line specification.\n+   *\n+   * @param buildOptions JibCli options\n+   * @return a populated Containerizer\n+   * @throws InvalidImageReferenceException if the image reference could not be parsed\n+   * @throws FileNotFoundException if a credential helper file is not found\n+   */\n+  public static Containerizer from(JibCli buildOptions)\n+      throws InvalidImageReferenceException, FileNotFoundException {\n+    ConsoleLogger logger =\n+        CliLogger.newLogger(buildOptions.getVerbosity(), buildOptions.getConsoleOutput());\n+\n+    Containerizer containerizer = create(buildOptions, logger);\n+\n+    applyHandlers(containerizer, logger);\n+    applyConfiguration(containerizer, buildOptions);\n+\n+    return containerizer;\n+  }\n+\n+  static Containerizer create(JibCli buildOptions, ConsoleLogger logger)", "originalCommit": "3e236fd4027337c7b212eb77b9f5d42f10387dda", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "55fa66da9b6359417951c74458ba809875cae0c7", "url": "https://github.com/GoogleContainerTools/jib/commit/55fa66da9b6359417951c74458ba809875cae0c7", "message": "comments", "committedDate": "2020-10-19T23:19:32Z", "type": "commit"}, {"oid": "a8f5ed7b0baac5a851ef42564686924191f60d55", "url": "https://github.com/GoogleContainerTools/jib/commit/a8f5ed7b0baac5a851ef42564686924191f60d55", "message": "accesors", "committedDate": "2020-10-20T01:34:04Z", "type": "commit"}]}