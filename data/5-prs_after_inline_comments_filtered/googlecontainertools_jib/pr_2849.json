{"pr_number": 2849, "pr_title": "Fill in directories for files added by filter.", "pr_createdAt": "2020-10-20T02:49:11Z", "pr_url": "https://github.com/GoogleContainerTools/jib/pull/2849", "timeline": [{"oid": "f7a71093c50e7de292885eb55ae3c844b1b105ec", "url": "https://github.com/GoogleContainerTools/jib/commit/f7a71093c50e7de292885eb55ae3c844b1b105ec", "message": "Fill in directories for files added by filter.\n\nThis happens where parent directories are filtered\nbut need to be filled in for files in those\ndirectories", "committedDate": "2020-10-20T02:46:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM2NDM0OQ==", "url": "https://github.com/GoogleContainerTools/jib/pull/2849#discussion_r508364349", "bodyText": "Actually these need to be added in reverse order", "author": "loosebazooka", "createdAt": "2020-10-20T09:50:47Z", "path": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java", "diffHunk": "@@ -96,49 +104,72 @@\n                     .map(Layers::toPathMatcher)\n                     .collect(Collectors.toList());\n             try (Stream<Path> dirWalk = Files.walk(src)) {\n-              dirWalk\n-                  // filter out against excludes\n-                  .filter(path -> excludes.stream().noneMatch(exclude -> exclude.matches(path)))\n-                  .filter(\n-                      path -> {\n-                        // if there are no includes directives, include everything\n-                        if (includes.isEmpty()) {\n-                          return true;\n-                        }\n-                        // TODO: if <dest>/path/to/file.txt is included because of a pattern like\n-                        // TODO: **/file.txt, ensure we create <dest>/path and <dest>/path/to with\n-                        // TODO: the correct directory properties here\n-                        // if there are includes directives, only include those specified\n-                        for (PathMatcher matcher : includes) {\n-                          if (matcher.matches(path)) {\n-                            return true;\n-                          }\n-                        }\n-                        return false;\n-                      })\n-                  .map(\n-                      path -> {\n-                        Path relative = src.relativize(path);\n-                        if (Files.isDirectory(path) || Files.isRegularFile(path)) {\n-                          return new FileEntry(\n-                              path,\n-                              dest.resolve(relative),\n-                              Files.isDirectory(path)\n-                                  ? filePropertiesStack.getDirectoryPermissions()\n-                                  : filePropertiesStack.getFilePermissions(),\n-                              filePropertiesStack.getModificationTime(),\n-                              filePropertiesStack.getOwnership());\n-                        } else {\n-                          throw new UnsupportedOperationException(\n-                              \"Cannot create FileLayers from non-file, non-directory: \"\n-                                  + path.toString());\n-                        }\n-                      })\n-                  .forEach(layerBuiler::addEntry);\n+              List<Path> filtered =\n+                  dirWalk\n+                      // filter out against excludes\n+                      .filter(path -> excludes.stream().noneMatch(exclude -> exclude.matches(path)))\n+                      .filter(\n+                          path -> {\n+                            // if there are no includes directives, include everything\n+                            if (includes.isEmpty()) {\n+                              return true;\n+                            }\n+                            // if there are includes directives, only include those specified\n+                            for (PathMatcher matcher : includes) {\n+                              if (matcher.matches(path)) {\n+                                return true;\n+                              }\n+                            }\n+                            return false;\n+                          })\n+                      .collect(Collectors.toList());\n+\n+              BiFunction<Path, FilePermissions, FileEntry> newEntry =\n+                  (file, permission) ->\n+                      new FileEntry(\n+                          file,\n+                          dest.resolve(src.relativize(file)),\n+                          permission,\n+                          filePropertiesStack.getModificationTime(),\n+                          filePropertiesStack.getOwnership());\n+\n+              Set<Path> addedDirectories = new HashSet<>();\n+              for (Path path : filtered) {\n+                if (!Files.isDirectory(path) && !Files.isRegularFile(path)) {\n+                  throw new UnsupportedOperationException(\n+                      \"Cannot create FileLayers from non-file, non-directory: \" + src.toString());\n+                }\n+\n+                if (Files.isDirectory(path)) {\n+                  addedDirectories.add(path);\n+                  layerBuiler.addEntry(\n+                      newEntry.apply(path, filePropertiesStack.getDirectoryPermissions()));\n+                } else if (Files.isRegularFile(path)) {\n+                  if (!path.startsWith(src)) {\n+                    // if we end up in a situation where the file added is somehow outside of the\n+                    // tree then we do not know how to properly handle it at the moment. It could\n+                    // be from a link scenario that we do not understand.\n+                    throw new IllegalStateException(\n+                        src.toString() + \" is not a parent of \" + path.toString());\n+                  }\n+                  Path parent = path.getParent();\n+                  while (true) {", "originalCommit": "f7a71093c50e7de292885eb55ae3c844b1b105ec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODU0MjI4Ng==", "url": "https://github.com/GoogleContainerTools/jib/pull/2849#discussion_r508542286", "bodyText": "Actually reproducible layer builder should sort these.", "author": "loosebazooka", "createdAt": "2020-10-20T14:11:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM2NDM0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODYwMTU2OA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2849#discussion_r508601568", "bodyText": "Is this primarily to guard against symlinks?", "author": "chanseokoh", "createdAt": "2020-10-20T15:21:09Z", "path": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java", "diffHunk": "@@ -71,6 +75,10 @@\n           Path src = rawSrc.isAbsolute() ? rawSrc : buildRoot.resolve(rawSrc);\n           AbsoluteUnixPath dest = copySpec.getDest();\n \n+          if (!Files.isDirectory(src) && !Files.isRegularFile(src)) {", "originalCommit": "f7a71093c50e7de292885eb55ae3c844b1b105ec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY1ODYxNg==", "url": "https://github.com/GoogleContainerTools/jib/pull/2849#discussion_r508658616", "bodyText": "Yeah there's two checks. One for non existence and one for unknown types. Perhaps the messaging should be different", "author": "loosebazooka", "createdAt": "2020-10-20T16:11:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODYwMTU2OA=="}], "type": "inlineReview"}, {"oid": "89b4dd9cc37bdbae206791ac24f4a63af5c6e25b", "url": "https://github.com/GoogleContainerTools/jib/commit/89b4dd9cc37bdbae206791ac24f4a63af5c6e25b", "message": "Update jib-cli/src/test/resources/buildfiles/layers/includesExcludesTest/layers.yaml\n\nCo-authored-by: Chanseok Oh <chanseok@google.com>", "committedDate": "2020-10-20T20:45:44Z", "type": "commit"}, {"oid": "aee292e24431501710dd0af146a5c123fd520c72", "url": "https://github.com/GoogleContainerTools/jib/commit/aee292e24431501710dd0af146a5c123fd520c72", "message": "Merge remote-tracking branch 'origin/master' into parentDirs", "committedDate": "2020-10-22T14:29:15Z", "type": "commit"}]}