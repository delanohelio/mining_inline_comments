{"pr_number": 2711, "pr_title": "Implement new manifest cache design: cache manifest lists and manifest+config pairs", "pr_createdAt": "2020-08-20T15:14:48Z", "pr_url": "https://github.com/GoogleContainerTools/jib/pull/2711", "timeline": [{"oid": "4f9c1bc536bee93a0f0d3038ca5b981b6d3892c2", "url": "https://github.com/GoogleContainerTools/jib/commit/4f9c1bc536bee93a0f0d3038ca5b981b6d3892c2", "message": "Implement new manifests_configs.json cache", "committedDate": "2020-08-13T19:13:55Z", "type": "commit"}, {"oid": "f480cf1829789d97493b0e05326c409ac0486440", "url": "https://github.com/GoogleContainerTools/jib/commit/f480cf1829789d97493b0e05326c409ac0486440", "message": "Merge branch 'master' into manifest-cache", "committedDate": "2020-08-13T19:18:29Z", "type": "commit"}, {"oid": "abeb080a2f9d0606a7ada30ae15d9a7e8b35d0de", "url": "https://github.com/GoogleContainerTools/jib/commit/abeb080a2f9d0606a7ada30ae15d9a7e8b35d0de", "message": "wip", "committedDate": "2020-08-13T19:30:39Z", "type": "commit"}, {"oid": "e643c543e1604983c46b480e399ef2652abff6f1", "url": "https://github.com/GoogleContainerTools/jib/commit/e643c543e1604983c46b480e399ef2652abff6f1", "message": "Implement new manfiest+container config cache", "committedDate": "2020-08-16T15:45:54Z", "type": "commit"}, {"oid": "1682e3b3bbba37351105ea41755f7e56a4d583f5", "url": "https://github.com/GoogleContainerTools/jib/commit/1682e3b3bbba37351105ea41755f7e56a4d583f5", "message": "Revert unnecessary code", "committedDate": "2020-08-17T13:07:45Z", "type": "commit"}, {"oid": "999125ef6906c4334612496b77f54e16f1f755bc", "url": "https://github.com/GoogleContainerTools/jib/commit/999125ef6906c4334612496b77f54e16f1f755bc", "message": "Revert filter(...) to original code to avoid false NullAway positives", "committedDate": "2020-08-17T16:20:01Z", "type": "commit"}, {"oid": "2166d2bf3b631b71dc2653a0aa93314eea3af668", "url": "https://github.com/GoogleContainerTools/jib/commit/2166d2bf3b631b71dc2653a0aa93314eea3af668", "message": "Convert to polymorphic JSON de-/serialization", "committedDate": "2020-08-18T14:18:55Z", "type": "commit"}, {"oid": "595bd1962921f5b59ea5ecf1049b12a6e5610860", "url": "https://github.com/GoogleContainerTools/jib/commit/595bd1962921f5b59ea5ecf1049b12a6e5610860", "message": "Add manifest+config cache JSON template", "committedDate": "2020-08-18T14:29:48Z", "type": "commit"}, {"oid": "5e2c6bcf688b5df766f6535fd950a7655196a404", "url": "https://github.com/GoogleContainerTools/jib/commit/5e2c6bcf688b5df766f6535fd950a7655196a404", "message": "Fix tests", "committedDate": "2020-08-18T14:44:31Z", "type": "commit"}, {"oid": "a53417dd8f1fc9808d3b0edae23f2b09001582e0", "url": "https://github.com/GoogleContainerTools/jib/commit/a53417dd8f1fc9808d3b0edae23f2b09001582e0", "message": "Update code comment", "committedDate": "2020-08-18T17:36:54Z", "type": "commit"}, {"oid": "126d30d0204d6544c7a58071884f77060cf139f0", "url": "https://github.com/GoogleContainerTools/jib/commit/126d30d0204d6544c7a58071884f77060cf139f0", "message": "Merge branch 'prepare-manifest-cache' into manifest-cache", "committedDate": "2020-08-18T21:55:05Z", "type": "commit"}, {"oid": "be8d91fadc60cb601c3d39d4b699de9d964ef0dd", "url": "https://github.com/GoogleContainerTools/jib/commit/be8d91fadc60cb601c3d39d4b699de9d964ef0dd", "message": "Fix tests", "committedDate": "2020-08-18T22:11:42Z", "type": "commit"}, {"oid": "c6bada415e26d5dd179e7ce663c8575d909bdc5c", "url": "https://github.com/GoogleContainerTools/jib/commit/c6bada415e26d5dd179e7ce663c8575d909bdc5c", "message": "Fix wrong cache validation", "committedDate": "2020-08-19T14:23:53Z", "type": "commit"}, {"oid": "38e00c976b11780285428f5f8393998da6ff52df", "url": "https://github.com/GoogleContainerTools/jib/commit/38e00c976b11780285428f5f8393998da6ff52df", "message": "Simplify test code", "committedDate": "2020-08-19T14:42:12Z", "type": "commit"}, {"oid": "ca69545e40e2adb2cde5fa9cb701ae3b1eca7c51", "url": "https://github.com/GoogleContainerTools/jib/commit/ca69545e40e2adb2cde5fa9cb701ae3b1eca7c51", "message": "Add CacheStorageReader tests", "committedDate": "2020-08-19T15:22:08Z", "type": "commit"}, {"oid": "badb776f62e45c82885e05055657b73bcb95c2bc", "url": "https://github.com/GoogleContainerTools/jib/commit/badb776f62e45c82885e05055657b73bcb95c2bc", "message": "Add tests", "committedDate": "2020-08-19T15:40:55Z", "type": "commit"}, {"oid": "c8ad480f29198f1b5d87a391c84f60192ed4bf26", "url": "https://github.com/GoogleContainerTools/jib/commit/c8ad480f29198f1b5d87a391c84f60192ed4bf26", "message": "Revert unintended debug code", "committedDate": "2020-08-19T15:42:16Z", "type": "commit"}, {"oid": "e20a8367cc8da6e76bad540c994a77dd91e5dfe4", "url": "https://github.com/GoogleContainerTools/jib/commit/e20a8367cc8da6e76bad540c994a77dd91e5dfe4", "message": "Fix bug in writing metadata cache", "committedDate": "2020-08-19T16:21:05Z", "type": "commit"}, {"oid": "4bfe4ef3c58d55393d688b6d2004b4aa77db1560", "url": "https://github.com/GoogleContainerTools/jib/commit/4bfe4ef3c58d55393d688b6d2004b4aa77db1560", "message": "Add tests", "committedDate": "2020-08-19T16:25:28Z", "type": "commit"}, {"oid": "5cadf8c6bd0a25cc45bb929385faf13de8a67f36", "url": "https://github.com/GoogleContainerTools/jib/commit/5cadf8c6bd0a25cc45bb929385faf13de8a67f36", "message": "Add tests", "committedDate": "2020-08-19T17:43:23Z", "type": "commit"}, {"oid": "bcd17f4be005730a6e5b1ba2d737595dee53b867", "url": "https://github.com/GoogleContainerTools/jib/commit/bcd17f4be005730a6e5b1ba2d737595dee53b867", "message": "Update comments", "committedDate": "2020-08-19T18:21:17Z", "type": "commit"}, {"oid": "dfab7ce329f1dc31e152e30c7296b706828fb487", "url": "https://github.com/GoogleContainerTools/jib/commit/dfab7ce329f1dc31e152e30c7296b706828fb487", "message": "Update Javadocs", "committedDate": "2020-08-19T18:39:03Z", "type": "commit"}, {"oid": "c52ebb8523d7cc071c718e2583085ae911ea1df0", "url": "https://github.com/GoogleContainerTools/jib/commit/c52ebb8523d7cc071c718e2583085ae911ea1df0", "message": "Rename variables", "committedDate": "2020-08-19T18:42:49Z", "type": "commit"}, {"oid": "f0a920374f3dac6c50302d1bc8ed477269df2ee2", "url": "https://github.com/GoogleContainerTools/jib/commit/f0a920374f3dac6c50302d1bc8ed477269df2ee2", "message": "Merge branch 'master' of https://github.com/GoogleContainerTools/jib into manifest-cache", "committedDate": "2020-08-20T14:49:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA4ODU4NA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2711#discussion_r474088584", "bodyText": "Maybe we should check if the platform of the image being returned matches the platform specified by the user . We can use the  Preconditions.checkState(checkImagePlatform(Image image), \"image doesn't match user specified platform\").", "author": "louismurerwa", "createdAt": "2020-08-20T15:49:48Z", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/PullBaseImageStep.java", "diffHunk": "@@ -215,139 +218,133 @@ private boolean checkImagePlatform(Image image) {\n       RegistryClient registryClient, ProgressEventDispatcher progressEventDispatcher)\n       throws IOException, RegistryException, LayerPropertyNotFoundException,\n           LayerCountMismatchException, BadContainerConfigurationFormatException {\n+    Cache cache = buildContext.getBaseImageLayersCache();\n+    ImageConfiguration baseImageConfig = buildContext.getBaseImageConfiguration();\n+\n     ManifestAndDigest<?> manifestAndDigest =\n-        registryClient.pullManifest(buildContext.getBaseImageConfiguration().getImageQualifier());\n+        registryClient.pullManifest(baseImageConfig.getImageQualifier());\n     ManifestTemplate manifestTemplate = manifestAndDigest.getManifest();\n \n+    if (manifestTemplate instanceof V21ManifestTemplate) {\n+      V21ManifestTemplate v21Manifest = (V21ManifestTemplate) manifestTemplate;\n+      cache.writeMetadata(baseImageConfig.getImage(), v21Manifest);\n+      return Collections.singletonList(JsonToImageTranslator.toImage(v21Manifest));", "originalCommit": "f0a920374f3dac6c50302d1bc8ed477269df2ee2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA5NzQ3NQ==", "url": "https://github.com/GoogleContainerTools/jib/pull/2711#discussion_r474097475", "bodyText": "This is one of the TODO items you're tracking. We should handle it properly, but as a separate PR on its own.\nHowever, note that we shouldn't fail a build even if the platform doesn't match.", "author": "chanseokoh", "createdAt": "2020-08-20T16:03:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA4ODU4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA5NDU3Ng==", "url": "https://github.com/GoogleContainerTools/jib/pull/2711#discussion_r474094576", "bodyText": "What about the OciManifestListTemplate ?", "author": "louismurerwa", "createdAt": "2020-08-20T15:58:39Z", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/PullBaseImageStep.java", "diffHunk": "@@ -215,139 +218,133 @@ private boolean checkImagePlatform(Image image) {\n       RegistryClient registryClient, ProgressEventDispatcher progressEventDispatcher)\n       throws IOException, RegistryException, LayerPropertyNotFoundException,\n           LayerCountMismatchException, BadContainerConfigurationFormatException {\n+    Cache cache = buildContext.getBaseImageLayersCache();\n+    ImageConfiguration baseImageConfig = buildContext.getBaseImageConfiguration();\n+\n     ManifestAndDigest<?> manifestAndDigest =\n-        registryClient.pullManifest(buildContext.getBaseImageConfiguration().getImageQualifier());\n+        registryClient.pullManifest(baseImageConfig.getImageQualifier());\n     ManifestTemplate manifestTemplate = manifestAndDigest.getManifest();\n \n+    if (manifestTemplate instanceof V21ManifestTemplate) {\n+      V21ManifestTemplate v21Manifest = (V21ManifestTemplate) manifestTemplate;\n+      cache.writeMetadata(baseImageConfig.getImage(), v21Manifest);\n+      return Collections.singletonList(JsonToImageTranslator.toImage(v21Manifest));\n+    }\n+\n+    ManifestTemplate manifestList = null;\n+    List<BuildableManifestTemplate> manifests = new ArrayList<>();\n+    List<ContainerConfigurationTemplate> containerConfigs = new ArrayList<>();\n     // If a manifest list, search for the manifests matching the given platforms.\n     if (manifestTemplate instanceof V22ManifestListTemplate) {\n-      ImmutableList.Builder<Image> images = ImmutableList.builder();\n-\n+      manifestList = manifestTemplate;\n       for (Platform platform : buildContext.getContainerConfiguration().getPlatforms()) {\n         manifestAndDigest =\n             obtainPlatformSpecificImageManifest(\n-                registryClient, (V22ManifestListTemplate) manifestTemplate, platform);\n-        images.add(jsonManifestToImage(manifestAndDigest, registryClient, progressEventDispatcher));\n+                registryClient, (V22ManifestListTemplate) manifestList, platform);\n+\n+        manifests.add((BuildableManifestTemplate) manifestAndDigest.getManifest());\n+        containerConfigs.add(\n+            pullContainerConfigJson(manifestAndDigest, registryClient, progressEventDispatcher));\n       }\n-      return images.build();\n+\n+    } else {\n+      // V22ManifestTemplate or OciManifestTemplate", "originalCommit": "f0a920374f3dac6c50302d1bc8ed477269df2ee2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA5ODkzMw==", "url": "https://github.com/GoogleContainerTools/jib/pull/2711#discussion_r474098933", "bodyText": "That's why I added the comment\n// TODO: support OciIndexTemplate once AbstractManifestPuller starts to accept it.\n\nbelow. (Note OciIndexTemplate is what you call by \"OCI manifest list\" here.) Supporting an OCI image index is another TODO item that you're tracking.", "author": "chanseokoh", "createdAt": "2020-08-20T16:05:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA5NDU3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEyMDAwMA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2711#discussion_r474120000", "bodyText": "Makes sense ,  I wasn't aware of the fact that OciIndexTemplate = Oci manifest list", "author": "louismurerwa", "createdAt": "2020-08-20T16:37:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA5NDU3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDM3ODA2Ng==", "url": "https://github.com/GoogleContainerTools/jib/pull/2711#discussion_r474378066", "bodyText": "perhaps we should add a bug to track this?", "author": "loosebazooka", "createdAt": "2020-08-21T02:48:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA5NDU3Ng=="}], "type": "inlineReview"}, {"oid": "bb0c901c4930a84230800ec17fe5735e6d1c34e8", "url": "https://github.com/GoogleContainerTools/jib/commit/bb0c901c4930a84230800ec17fe5735e6d1c34e8", "message": "Refactor code", "committedDate": "2020-08-21T19:39:12Z", "type": "commit"}, {"oid": "1c5c7a36d4a3df504e466d2e9701fe5c0d238193", "url": "https://github.com/GoogleContainerTools/jib/commit/1c5c7a36d4a3df504e466d2e9701fe5c0d238193", "message": "Refactor code", "committedDate": "2020-08-21T19:59:39Z", "type": "commit"}, {"oid": "0908e25e6c0a384acf5d6d0917b576751b96f372", "url": "https://github.com/GoogleContainerTools/jib/commit/0908e25e6c0a384acf5d6d0917b576751b96f372", "message": "Merge branch 'manifest-cache' of https://github.com/GoogleContainerTools/jib into manifest-cache", "committedDate": "2020-08-21T20:01:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTAxMTI3MA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2711#discussion_r475011270", "bodyText": "looks like you decided to keep it this way for now?", "author": "loosebazooka", "createdAt": "2020-08-21T23:36:59Z", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/cache/CacheStorageWriter.java", "diffHunk": "@@ -296,42 +302,59 @@ CachedLayer writeTarLayer(DescriptorDigest diffId, Blob compressedBlob) throws I\n   }\n \n   /**\n-   * Saves the manifest and container configuration for a V2.2 or OCI image.\n+   * Saves image metadata (a manifest list and a list of manifest/container configuration pairs) for\n+   * an image reference.\n    *\n    * @param imageReference the image reference to store the metadata for\n-   * @param manifestTemplate the manifest\n-   * @param containerConfiguration the container configuration\n+   * @param manifestList the V2.2 manifest list or OCI image index. Can be null.\n+   * @param manifests the V2.2 or OCI manifests\n+   * @param containerConfigurations the container configurations\n    */\n   void writeMetadata(\n       ImageReference imageReference,\n-      BuildableManifestTemplate manifestTemplate,\n-      ContainerConfigurationTemplate containerConfiguration)\n+      @Nullable ManifestTemplate manifestList,", "originalCommit": "0908e25e6c0a384acf5d6d0917b576751b96f372", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTYzNjc4OA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2711#discussion_r475636788", "bodyText": "I have been working on changing this to accept ImageMetadataTemplate since our last meeting. Still working on it. Because you've already gone through this PR, maybe it's better to avoid further changing this PR a lot. I can do the API refactoring in a follow-up.", "author": "chanseokoh", "createdAt": "2020-08-24T14:04:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTAxMTI3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTcyNjU2MA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2711#discussion_r475726560", "bodyText": "I decided to change the API in this PR. It enables refactoring the code in a more readable way, I think.", "author": "chanseokoh", "createdAt": "2020-08-24T16:07:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTAxMTI3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTA5MDUyNA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2711#discussion_r475090524", "bodyText": "Just for my own understanding: It seems like we weren't writing cached data at all in this step before? Was that being done somewhere else?", "author": "loosebazooka", "createdAt": "2020-08-22T13:29:47Z", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/PullBaseImageStep.java", "diffHunk": "@@ -215,139 +218,133 @@ private boolean checkImagePlatform(Image image) {\n       RegistryClient registryClient, ProgressEventDispatcher progressEventDispatcher)\n       throws IOException, RegistryException, LayerPropertyNotFoundException,\n           LayerCountMismatchException, BadContainerConfigurationFormatException {\n+    Cache cache = buildContext.getBaseImageLayersCache();", "originalCommit": "0908e25e6c0a384acf5d6d0917b576751b96f372", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTYzMDkzOA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2711#discussion_r475630938", "bodyText": "Correct. The current code writes (caches) a single manifest (+container config) after downloading them in jsonManifestToImage(). (That is, Cache.writeMetadata() was called only in jsonManifestToImage()). Now, this PR moved writeMetadata() out of jsonManifestToImage() into this method, as we need to cache all the manifests all at once at the end.", "author": "chanseokoh", "createdAt": "2020-08-24T13:58:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTA5MDUyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTA5ODU4Mw==", "url": "https://github.com/GoogleContainerTools/jib/pull/2711#discussion_r475098583", "bodyText": "This seems like it should be at the info level.", "author": "loosebazooka", "createdAt": "2020-08-22T14:54:41Z", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/PullBaseImageStep.java", "diffHunk": "@@ -215,139 +218,133 @@ private boolean checkImagePlatform(Image image) {\n       RegistryClient registryClient, ProgressEventDispatcher progressEventDispatcher)\n       throws IOException, RegistryException, LayerPropertyNotFoundException,\n           LayerCountMismatchException, BadContainerConfigurationFormatException {\n+    Cache cache = buildContext.getBaseImageLayersCache();\n+    ImageConfiguration baseImageConfig = buildContext.getBaseImageConfiguration();\n+\n     ManifestAndDigest<?> manifestAndDigest =\n-        registryClient.pullManifest(buildContext.getBaseImageConfiguration().getImageQualifier());\n+        registryClient.pullManifest(baseImageConfig.getImageQualifier());\n     ManifestTemplate manifestTemplate = manifestAndDigest.getManifest();\n \n+    if (manifestTemplate instanceof V21ManifestTemplate) {\n+      V21ManifestTemplate v21Manifest = (V21ManifestTemplate) manifestTemplate;\n+      cache.writeMetadata(baseImageConfig.getImage(), v21Manifest);\n+      return Collections.singletonList(JsonToImageTranslator.toImage(v21Manifest));\n+    }\n+\n+    ManifestTemplate manifestList = null;\n+    List<BuildableManifestTemplate> manifests = new ArrayList<>();\n+    List<ContainerConfigurationTemplate> containerConfigs = new ArrayList<>();\n     // If a manifest list, search for the manifests matching the given platforms.\n     if (manifestTemplate instanceof V22ManifestListTemplate) {\n-      ImmutableList.Builder<Image> images = ImmutableList.builder();\n-\n+      manifestList = manifestTemplate;\n       for (Platform platform : buildContext.getContainerConfiguration().getPlatforms()) {\n         manifestAndDigest =\n             obtainPlatformSpecificImageManifest(\n-                registryClient, (V22ManifestListTemplate) manifestTemplate, platform);\n-        images.add(jsonManifestToImage(manifestAndDigest, registryClient, progressEventDispatcher));\n+                registryClient, (V22ManifestListTemplate) manifestList, platform);\n+\n+        manifests.add((BuildableManifestTemplate) manifestAndDigest.getManifest());\n+        containerConfigs.add(\n+            pullContainerConfigJson(manifestAndDigest, registryClient, progressEventDispatcher));\n       }\n-      return images.build();\n+\n+    } else {\n+      // V22ManifestTemplate or OciManifestTemplate\n+      // TODO: support OciIndexTemplate once AbstractManifestPuller starts to accept it.\n+      manifests = Collections.singletonList((BuildableManifestTemplate) manifestTemplate);\n+      containerConfigs =\n+          Collections.singletonList(\n+              pullContainerConfigJson(manifestAndDigest, registryClient, progressEventDispatcher));\n     }\n \n-    return Collections.singletonList(\n-        jsonManifestToImage(manifestAndDigest, registryClient, progressEventDispatcher));\n+    cache.writeMetadata(baseImageConfig.getImage(), manifestList, manifests, containerConfigs);\n+\n+    ImmutableList.Builder<Image> images = ImmutableList.builder();\n+    for (int i = 0; i < manifests.size(); i++) {\n+      images.add(JsonToImageTranslator.toImage(manifests.get(i), containerConfigs.get(i)));\n+    }\n+    return images.build();\n   }\n \n   /**\n    * Looks through a manifest list for the manifest matching the {@code platform} and downloads and\n    * returns the first manifest it finds.\n    */\n+  // TODO: support OciIndexTemplate once AbstractManifestPuller starts to accept it.\n   @VisibleForTesting\n   ManifestAndDigest<?> obtainPlatformSpecificImageManifest(\n       RegistryClient registryClient,\n       V22ManifestListTemplate manifestListTemplate,\n       Platform platform)\n       throws IOException, RegistryException {\n     EventHandlers eventHandlers = buildContext.getEventHandlers();\n+    String message = \"Searching for architecture=%s, os=%s in the base image manifest list\";\n     eventHandlers.dispatch(\n-        LogEvent.lifecycle(\n-            \"The base image reference is a manifest list, searching for architecture=\"\n-                + platform.getArchitecture()\n-                + \", os=\"\n-                + platform.getOs()));\n+        LogEvent.lifecycle(String.format(message, platform.getArchitecture(), platform.getOs())));", "originalCommit": "0908e25e6c0a384acf5d6d0917b576751b96f372", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTYzNTY4NA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2711#discussion_r475635684", "bodyText": "I had the same question. It has been lifecycle from the start, and I guess the reasoning is to let the user easily see that the base image they use is a manifest list and not a manifest. I think that's helpful. But now that we start supporting configuring platforms, I also think we don't have to be verbose on this. Let's go for INFO.", "author": "chanseokoh", "createdAt": "2020-08-24T14:02:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTA5ODU4Mw=="}], "type": "inlineReview"}, {"oid": "b3a0c893335555a0aeb63c704e24bad4ae192476", "url": "https://github.com/GoogleContainerTools/jib/commit/b3a0c893335555a0aeb63c704e24bad4ae192476", "message": "Decrease log level (lifecycle -> info)", "committedDate": "2020-08-24T14:11:03Z", "type": "commit"}, {"oid": "b92f1ff8d84c5ae281b6cee5c186768d778b47d2", "url": "https://github.com/GoogleContainerTools/jib/commit/b92f1ff8d84c5ae281b6cee5c186768d778b47d2", "message": "New cache API / refactor code", "committedDate": "2020-08-24T16:11:10Z", "type": "forcePushed"}, {"oid": "8a57ce21b8b6a27899220d268c5caab0bddd01a5", "url": "https://github.com/GoogleContainerTools/jib/commit/8a57ce21b8b6a27899220d268c5caab0bddd01a5", "message": "New cache API / refactor code", "committedDate": "2020-08-24T16:12:27Z", "type": "commit"}, {"oid": "8a57ce21b8b6a27899220d268c5caab0bddd01a5", "url": "https://github.com/GoogleContainerTools/jib/commit/8a57ce21b8b6a27899220d268c5caab0bddd01a5", "message": "New cache API / refactor code", "committedDate": "2020-08-24T16:12:27Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc4NTg3NA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2711#discussion_r475785874", "bodyText": "Does this then throw an error for OciIndexTemplate? Perhaps we can give the user a better error message (I thought Verify is for catching programming/integration issues?)", "author": "loosebazooka", "createdAt": "2020-08-24T17:40:58Z", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/PullBaseImageStep.java", "diffHunk": "@@ -215,139 +218,135 @@ private boolean checkImagePlatform(Image image) {\n       RegistryClient registryClient, ProgressEventDispatcher progressEventDispatcher)\n       throws IOException, RegistryException, LayerPropertyNotFoundException,\n           LayerCountMismatchException, BadContainerConfigurationFormatException {\n+    Cache cache = buildContext.getBaseImageLayersCache();\n+    EventHandlers eventHandlers = buildContext.getEventHandlers();\n+    ImageConfiguration baseImageConfig = buildContext.getBaseImageConfiguration();\n+\n     ManifestAndDigest<?> manifestAndDigest =\n-        registryClient.pullManifest(buildContext.getBaseImageConfiguration().getImageQualifier());\n+        registryClient.pullManifest(baseImageConfig.getImageQualifier());\n+    eventHandlers.dispatch(\n+        LogEvent.lifecycle(\"Using base image with digest: \" + manifestAndDigest.getDigest()));\n+\n     ManifestTemplate manifestTemplate = manifestAndDigest.getManifest();\n+    if (manifestTemplate instanceof V21ManifestTemplate) {\n+      V21ManifestTemplate v21Manifest = (V21ManifestTemplate) manifestTemplate;\n+      cache.writeMetadata(baseImageConfig.getImage(), v21Manifest);\n+      return Collections.singletonList(JsonToImageTranslator.toImage(v21Manifest));\n+\n+    } else if (manifestTemplate instanceof BuildableManifestTemplate) {\n+      // V22ManifestTemplate or OciManifestTemplate\n+      BuildableManifestTemplate imageManifest = (BuildableManifestTemplate) manifestTemplate;\n+      ContainerConfigurationTemplate containerConfig =\n+          pullContainerConfigJson(manifestAndDigest, registryClient, progressEventDispatcher);\n+      cache.writeMetadata(baseImageConfig.getImage(), imageManifest, containerConfig);\n+      return Collections.singletonList(\n+          JsonToImageTranslator.toImage(imageManifest, containerConfig));\n+    }\n+\n+    // TODO: support OciIndexTemplate once AbstractManifestPuller starts to accept it.\n+    Verify.verify(manifestTemplate instanceof V22ManifestListTemplate);", "originalCommit": "8a57ce21b8b6a27899220d268c5caab0bddd01a5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTgyMDc4NA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2711#discussion_r475820784", "bodyText": "Basically the refactored code doesn't change the current behavior in this regard. The current code would simply break with ClassCastException if manifestTemplate could ever be of OciIndexTemplate, as it can't cast OciInexTemplate into BuildableManifestTemplate in jsonManifestToImage(). That is, it's an impossible condition; we never see OciIndexTemplate, as the manifest puller doesn't tell a registry that it can accept an OCI image index. All the registries in practice so far have been returning a Docker manifest list.", "author": "chanseokoh", "createdAt": "2020-08-24T18:43:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc4NTg3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc4NjYxOQ==", "url": "https://github.com/GoogleContainerTools/jib/pull/2711#discussion_r475786619", "bodyText": "Similarly here, what happens when schema version is not 2, does this just kill our build with a confusing error message?", "author": "loosebazooka", "createdAt": "2020-08-24T17:42:17Z", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/PullBaseImageStep.java", "diffHunk": "@@ -215,139 +218,135 @@ private boolean checkImagePlatform(Image image) {\n       RegistryClient registryClient, ProgressEventDispatcher progressEventDispatcher)\n       throws IOException, RegistryException, LayerPropertyNotFoundException,\n           LayerCountMismatchException, BadContainerConfigurationFormatException {\n+    Cache cache = buildContext.getBaseImageLayersCache();\n+    EventHandlers eventHandlers = buildContext.getEventHandlers();\n+    ImageConfiguration baseImageConfig = buildContext.getBaseImageConfiguration();\n+\n     ManifestAndDigest<?> manifestAndDigest =\n-        registryClient.pullManifest(buildContext.getBaseImageConfiguration().getImageQualifier());\n+        registryClient.pullManifest(baseImageConfig.getImageQualifier());\n+    eventHandlers.dispatch(\n+        LogEvent.lifecycle(\"Using base image with digest: \" + manifestAndDigest.getDigest()));\n+\n     ManifestTemplate manifestTemplate = manifestAndDigest.getManifest();\n+    if (manifestTemplate instanceof V21ManifestTemplate) {\n+      V21ManifestTemplate v21Manifest = (V21ManifestTemplate) manifestTemplate;\n+      cache.writeMetadata(baseImageConfig.getImage(), v21Manifest);\n+      return Collections.singletonList(JsonToImageTranslator.toImage(v21Manifest));\n+\n+    } else if (manifestTemplate instanceof BuildableManifestTemplate) {\n+      // V22ManifestTemplate or OciManifestTemplate\n+      BuildableManifestTemplate imageManifest = (BuildableManifestTemplate) manifestTemplate;\n+      ContainerConfigurationTemplate containerConfig =\n+          pullContainerConfigJson(manifestAndDigest, registryClient, progressEventDispatcher);\n+      cache.writeMetadata(baseImageConfig.getImage(), imageManifest, containerConfig);\n+      return Collections.singletonList(\n+          JsonToImageTranslator.toImage(imageManifest, containerConfig));\n+    }\n+\n+    // TODO: support OciIndexTemplate once AbstractManifestPuller starts to accept it.\n+    Verify.verify(manifestTemplate instanceof V22ManifestListTemplate);\n \n+    List<ManifestAndConfigTemplate> manifestsAndConfigs = new ArrayList<>();\n+    ImmutableList.Builder<Image> images = ImmutableList.builder();\n     // If a manifest list, search for the manifests matching the given platforms.\n-    if (manifestTemplate instanceof V22ManifestListTemplate) {\n-      ImmutableList.Builder<Image> images = ImmutableList.builder();\n-\n-      for (Platform platform : buildContext.getContainerConfiguration().getPlatforms()) {\n-        manifestAndDigest =\n-            obtainPlatformSpecificImageManifest(\n-                registryClient, (V22ManifestListTemplate) manifestTemplate, platform);\n-        images.add(jsonManifestToImage(manifestAndDigest, registryClient, progressEventDispatcher));\n-      }\n-      return images.build();\n+    for (Platform platform : buildContext.getContainerConfiguration().getPlatforms()) {\n+      String message = \"Searching for architecture=%s, os=%s in the base image manifest list\";\n+      eventHandlers.dispatch(\n+          LogEvent.info(String.format(message, platform.getArchitecture(), platform.getOs())));\n+\n+      ManifestAndDigest<?> imageManifestAndDigest =\n+          obtainPlatformSpecificImageManifest(\n+              registryClient, (V22ManifestListTemplate) manifestTemplate, platform);\n+\n+      BuildableManifestTemplate imageManifest =\n+          (BuildableManifestTemplate) imageManifestAndDigest.getManifest();\n+      ContainerConfigurationTemplate containerConfig =\n+          pullContainerConfigJson(imageManifestAndDigest, registryClient, progressEventDispatcher);\n+\n+      manifestsAndConfigs.add(new ManifestAndConfigTemplate(imageManifest, containerConfig));\n+      images.add(JsonToImageTranslator.toImage(imageManifest, containerConfig));\n     }\n \n-    return Collections.singletonList(\n-        jsonManifestToImage(manifestAndDigest, registryClient, progressEventDispatcher));\n+    cache.writeMetadata(\n+        baseImageConfig.getImage(),\n+        new ImageMetadataTemplate(manifestTemplate /* manifest list */, manifestsAndConfigs));\n+    return images.build();\n   }\n \n   /**\n    * Looks through a manifest list for the manifest matching the {@code platform} and downloads and\n    * returns the first manifest it finds.\n    */\n+  // TODO: support OciIndexTemplate once AbstractManifestPuller starts to accept it.\n   @VisibleForTesting\n   ManifestAndDigest<?> obtainPlatformSpecificImageManifest(\n       RegistryClient registryClient,\n       V22ManifestListTemplate manifestListTemplate,\n       Platform platform)\n       throws IOException, RegistryException {\n     EventHandlers eventHandlers = buildContext.getEventHandlers();\n-    eventHandlers.dispatch(\n-        LogEvent.lifecycle(\n-            \"The base image reference is a manifest list, searching for architecture=\"\n-                + platform.getArchitecture()\n-                + \", os=\"\n-                + platform.getOs()));\n \n     List<String> digests =\n         manifestListTemplate.getDigestsForPlatform(platform.getArchitecture(), platform.getOs());\n     if (digests.size() == 0) {\n       String errorMessage =\n           buildContext.getBaseImageConfiguration().getImage()\n-              + \" is a manifest list, but the list does not contain an image manifest for the platform architecture=\"\n-              + platform.getArchitecture()\n-              + \", os=\"\n-              + platform.getOs()\n-              + \". If your intention was to specify a platform for your image,\"\n-              + \" see https://github.com/GoogleContainerTools/jib/blob/master/docs/faq.md#how-do-i-specify-a-platform-in-the-manifest-list-or-oci-index-of-a-base-image\"\n-              + \" to learn more about specifying a platform\";\n-\n-      eventHandlers.dispatch(LogEvent.error(errorMessage));\n+              + \" is a manifest list, but the list does not contain an image for architecture=%s, \"\n+              + \"os=%s. If your intention was to specify a platform for your image, see \"\n+              + \"https://github.com/GoogleContainerTools/jib/blob/master/docs/faq.md#how-do-i-specify-a-platform-in-the-manifest-list-or-oci-index-of-a-base-image\";\n+      eventHandlers.dispatch(\n+          LogEvent.error(\n+              String.format(errorMessage, platform.getArchitecture(), platform.getOs())));\n       throw new RegistryException(errorMessage);\n     }\n+    // TODO: pull multiple manifests (+ container configs) in parallel. (It will be simpler to pull\n+    // a manifest+container config pair in sequence. That is, calling pullContainerConfigJson here.)\n     return registryClient.pullManifest(digests.get(0));\n   }\n \n   /**\n-   * Converts a JSON manifest to an {@link Image}.\n+   * Pulls a container configuration JSON specified in the given manifest.\n    *\n-   * @param manifestAndDigest a manifest list and digest of a {@link Image}\n+   * @param manifestAndDigest a manifest JSON and its digest\n    * @param registryClient to communicate with remote registry\n-   * @param progressEventDispatcher the {@link ProgressEventDispatcher} for emitting {@link\n+   * @param progressDispatcher the {@link ProgressEventDispatcher} for emitting {@link\n    *     ProgressEvent}s\n-   * @return {@link Image}\n+   * @return pulled {@link ContainerConfigurationTemplate}\n    * @throws IOException when an I/O exception occurs during the pulling\n    * @throws LayerCountMismatchException if the manifest and configuration contain conflicting layer\n    *     information\n    * @throws LayerPropertyNotFoundException if adding image layers fails\n    * @throws BadContainerConfigurationFormatException if the container configuration is in a bad\n    *     format\n    */\n-  private Image jsonManifestToImage(\n+  private ContainerConfigurationTemplate pullContainerConfigJson(\n       ManifestAndDigest<?> manifestAndDigest,\n       RegistryClient registryClient,\n-      ProgressEventDispatcher progressEventDispatcher)\n-      throws IOException, LayerPropertyNotFoundException, BadContainerConfigurationFormatException,\n-          UnknownManifestFormatException, LayerCountMismatchException {\n-    EventHandlers eventHandlers = buildContext.getEventHandlers();\n-    ManifestTemplate manifestTemplate = manifestAndDigest.getManifest();\n-    switch (manifestTemplate.getSchemaVersion()) {\n-      case 1:\n-        V21ManifestTemplate v21ManifestTemplate = (V21ManifestTemplate) manifestTemplate;\n-        buildContext\n-            .getBaseImageLayersCache()\n-            .writeMetadata(\n-                buildContext.getBaseImageConfiguration().getImage(), v21ManifestTemplate);\n-        return JsonToImageTranslator.toImage(v21ManifestTemplate);\n-\n-      case 2:\n-        eventHandlers.dispatch(\n-            LogEvent.lifecycle(\"Using base image with digest: \" + manifestAndDigest.getDigest()));\n-        BuildableManifestTemplate buildableManifestTemplate =\n-            (BuildableManifestTemplate) manifestTemplate;\n-        if (buildableManifestTemplate.getContainerConfiguration() == null\n-            || buildableManifestTemplate.getContainerConfiguration().getDigest() == null) {\n-          throw new UnknownManifestFormatException(\n-              \"Invalid container configuration in Docker V2.2/OCI manifest: \\n\"\n-                  + JsonTemplateMapper.toUtf8String(buildableManifestTemplate));\n-        }\n-\n-        DescriptorDigest containerConfigurationDigest =\n-            buildableManifestTemplate.getContainerConfiguration().getDigest();\n-\n-        try (ThrottledProgressEventDispatcherWrapper progressEventDispatcherWrapper =\n-            new ThrottledProgressEventDispatcherWrapper(\n-                progressEventDispatcher.newChildProducer(),\n-                \"pull container configuration \" + containerConfigurationDigest)) {\n-          String containerConfigurationString =\n-              Blobs.writeToString(\n-                  registryClient.pullBlob(\n-                      containerConfigurationDigest,\n-                      progressEventDispatcherWrapper::setProgressTarget,\n-                      progressEventDispatcherWrapper::dispatchProgress));\n-\n-          ContainerConfigurationTemplate containerConfigurationTemplate =\n-              JsonTemplateMapper.readJson(\n-                  containerConfigurationString, ContainerConfigurationTemplate.class);\n-          buildContext\n-              .getBaseImageLayersCache()\n-              .writeMetadata(\n-                  buildContext.getBaseImageConfiguration().getImage(),\n-                  buildableManifestTemplate,\n-                  containerConfigurationTemplate);\n-\n-          return JsonToImageTranslator.toImage(\n-              buildableManifestTemplate, containerConfigurationTemplate);\n-        }\n+      ProgressEventDispatcher progressDispatcher)\n+      throws IOException, LayerPropertyNotFoundException, UnknownManifestFormatException {\n+    BuildableManifestTemplate manifest =\n+        (BuildableManifestTemplate) manifestAndDigest.getManifest();\n+    Preconditions.checkArgument(manifest.getSchemaVersion() == 2);", "originalCommit": "8a57ce21b8b6a27899220d268c5caab0bddd01a5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTgyNDg3Mw==", "url": "https://github.com/GoogleContainerTools/jib/pull/2711#discussion_r475824873", "bodyText": "Will kill the build. It's an impossible condition the user should never hit. If we see it, it's a bug for us to fix. That is, we should pull a container config only when it's a schema 2 (i.e., when OciImageTemplate or V22ManifestTemplate), because the V2.1 manifest embeds a container config.\nBut actually, BuildableManifestTemplate is always schema version 2. The check line is only to help us locate places to update more easily in the future when a schema version 3 is introduced in the spec.", "author": "chanseokoh", "createdAt": "2020-08-24T18:50:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc4NjYxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc4NzAxMA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2711#discussion_r475787010", "bodyText": "I thought we also write 2.1 manifests down to cache?", "author": "loosebazooka", "createdAt": "2020-08-24T17:43:04Z", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/cache/Cache.java", "diffHunk": "@@ -66,32 +69,52 @@ private Cache(CacheStorageFiles cacheStorageFiles) {\n   }\n \n   /**\n-   * Saves a manifest and container configuration for a V2.2 or OCI image.\n+   * Saves image metadata (a manifest list and a list of manifest/container configuration pairs) for\n+   * an image reference.\n    *\n-   * @param imageReference the image reference to save the manifest and container configuration for\n-   * @param manifestTemplate the V2.2 or OCI manifest\n-   * @param containerConfigurationTemplate the container configuration\n+   * @param imageReference the image reference to save the metadata for\n+   * @param metadata the image metadata\n+   * @throws IOException if an I/O exception occurs\n+   */\n+  public void writeMetadata(ImageReference imageReference, ImageMetadataTemplate metadata)\n+      throws IOException {\n+    cacheStorageWriter.writeMetadata(imageReference, metadata);\n+  }\n+\n+  /**\n+   * Saves a schema 2 manifest for an image reference. This is a simple wrapper around {@link\n+   * #writeMetadata(ImageReference, ImageMetadataTemplate)} to save a single manifest without a\n+   * manifest list.\n+   *\n+   * @param imageReference the image reference to save the manifest for\n+   * @param manifest the V2.2 or OCI manifest", "originalCommit": "8a57ce21b8b6a27899220d268c5caab0bddd01a5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTgyNjAxNw==", "url": "https://github.com/GoogleContainerTools/jib/pull/2711#discussion_r475826017", "bodyText": "Yes, we have a dedicated API for V2.1 on  line 113 (line 92 in old code).", "author": "chanseokoh", "createdAt": "2020-08-24T18:53:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc4NzAxMA=="}], "type": "inlineReview"}]}