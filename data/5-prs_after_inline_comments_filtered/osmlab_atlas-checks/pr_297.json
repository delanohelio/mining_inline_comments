{"pr_number": 297, "pr_title": "InvalidMultiPolygonRelationCheck Geometry Enhancement", "pr_createdAt": "2020-05-12T23:12:30Z", "pr_url": "https://github.com/osmlab/atlas-checks/pull/297", "timeline": [{"oid": "e95d3c3b6a333be7449c7aa45feb01e130cab38e", "url": "https://github.com/osmlab/atlas-checks/commit/e95d3c3b6a333be7449c7aa45feb01e130cab38e", "message": "geometry check; refactor", "committedDate": "2020-04-16T20:15:03Z", "type": "commit"}, {"oid": "ce677f2ac01f884d1e97f7683409d51770bec05a", "url": "https://github.com/osmlab/atlas-checks/commit/ce677f2ac01f884d1e97f7683409d51770bec05a", "message": "ignore one member", "committedDate": "2020-04-21T17:25:46Z", "type": "commit"}, {"oid": "3fc4def677c92a254fd0bd77151b5a3bc51316a3", "url": "https://github.com/osmlab/atlas-checks/commit/3fc4def677c92a254fd0bd77151b5a3bc51316a3", "message": "ignore country slicing", "committedDate": "2020-05-01T18:48:32Z", "type": "commit"}, {"oid": "dc8d91fa5597f6303c09e146d5d88ddac9c171d4", "url": "https://github.com/osmlab/atlas-checks/commit/dc8d91fa5597f6303c09e146d5d88ddac9c171d4", "message": "Merge branch 'dev' into dev-multiPolyGeomCheck", "committedDate": "2020-05-13T15:23:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc1MDY4OQ==", "url": "https://github.com/osmlab/atlas-checks/pull/297#discussion_r424750689", "bodyText": "nit: Could be outerToInners.forEach((key, value) -> {}))", "author": "sayas01", "createdAt": "2020-05-13T21:48:19Z", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/relations/InvalidMultiPolygonRelationCheck.java", "diffHunk": "@@ -185,43 +161,254 @@ else if (!relationMember.getRole().equals(RelationTypeTag.MULTIPOLYGON_ROLE_INNE\n         return FALLBACK_INSTRUCTIONS;\n     }\n \n-    private Optional<String> checkClosedLoop(final Relation relation)\n+    /**\n+     * Check that a multipolygon {@link Relation} has valid geometry.\n+     *\n+     * @param multipolygonRelation\n+     *            {@link Relation} of type multipolygon\n+     * @return an Optional containing a {@link Tuple} containing a {@link Set} of {@link String}\n+     *         instructions for invalid geometries and a {@link Set} of {@link Location}s marking\n+     *         the invalid geometries\n+     */\n+    private Optional<Tuple<Set<String>, Set<Location>>> checkGeometry(\n+            final Relation multipolygonRelation)\n     {\n+        // Try converting the Relation to a MultiPolygon. If it works check that the geometries\n+        // don't overlap.\n         try\n         {\n-            RELATION_OR_AREA_TO_MULTI_POLYGON_CONVERTER.convert(relation);\n+            return Optional.of(checkOverlap(\n+                    RELATION_OR_AREA_TO_MULTI_POLYGON_CONVERTER.convert(multipolygonRelation),\n+                    multipolygonRelation.getOsmIdentifier()));\n         }\n+        // Catch open polygons and mark the broken locations\n         catch (final MultiplePolyLineToPolygonsConverter.OpenPolygonException exception)\n         {\n             final List<Location> openLocations = exception.getOpenLocations();\n             final Set<AtlasObject> objects = openLocations.stream()\n-                    .flatMap(location -> this.filterMembers(relation, location))\n+                    .flatMap(location -> this.filterMembers(multipolygonRelation, location))\n                     .collect(Collectors.toSet());\n-            final Set<Long> memberIds = relation.members().stream()\n+            final Set<Long> memberIds = multipolygonRelation.members().stream()\n                     .map(member -> member.getEntity().getOsmIdentifier())\n                     .collect(Collectors.toSet());\n \n             if (!objects.isEmpty() && !memberIds.isEmpty())\n             {\n-                return Optional\n-                        .of(this.getLocalizedInstruction(CLOSED_LOOP_INSTRUCTION_FORMAT_INDEX,\n-                                relation.getOsmIdentifier(), memberIds, openLocations));\n+                return Optional.of(Tuple.createTuple(\n+                        Collections.singleton(this.getLocalizedInstruction(\n+                                CLOSED_LOOP_INSTRUCTION_FORMAT_INDEX,\n+                                multipolygonRelation.getOsmIdentifier(), memberIds, openLocations)),\n+                        new HashSet<>(openLocations)));\n             }\n             else\n             {\n-                logger.warn(\"Unable to find members in relation {} containing the locations : {}\",\n-                        relation, openLocations);\n+                logger.warn(\n+                        \"Unable to find members in multipolygonRelation {} containing the locations : {}\",\n+                        multipolygonRelation, openLocations);\n+            }\n+        }\n+        catch (final CoreException exception)\n+        {\n+            // Catch multipolygon relations with no outer members\n+            if (exception.getMessage().equals(\"Unable to find outer polygon.\"))\n+            {\n+                return Optional.of(Tuple.createTuple(\n+                        Collections.singleton(\n+                                this.getLocalizedInstruction(MISSING_OUTER_INSTRUCTION_FORMAT_INDEX,\n+                                        multipolygonRelation.getOsmIdentifier())),\n+                        Collections.emptySet()));\n             }\n+            // Catch inner members that are not inside an outer member\n+            if (exception.getMessage().contains(\"Malformed MultiPolygon: inner has no outer host\"))\n+            {\n+                return Optional\n+                        .of(Tuple.createTuple(\n+                                Collections.singleton(this.getLocalizedInstruction(\n+                                        INNER_MISSING_OUTER_INSTRUCTION_FORMAT_INDEX,\n+                                        multipolygonRelation.getOsmIdentifier())),\n+                                Collections.emptySet()));\n+            }\n+\n+            // Ignore other core exceptions\n+            logger.warn(\"Unable to convert multipolygonRelation {}. {}\",\n+                    multipolygonRelation.getOsmIdentifier(), exception.getMessage());\n         }\n         catch (final Exception exception)\n         {\n-            logger.warn(\"Unable to convert relation {}. {}\", relation.getOsmIdentifier(),\n-                    exception.getMessage());\n+            logger.warn(\"Unable to convert multipolygonRelation {}. {}\",\n+                    multipolygonRelation.getOsmIdentifier(), exception.getMessage());\n         }\n \n         return Optional.empty();\n     }\n \n+    /**\n+     * Check that inner polygons do not intersect any outers and do not overlap other inners. Inners\n+     * are allowed to touch other inners.\n+     *\n+     * @param outerToInners\n+     *            {@link MultiMap} of outer {@link Polygon}s to inner {@link Polygon}s\n+     * @return a {@link Set} of {@link Tuple}s containing {@link Polygon}s that invalidly overlap\n+     */\n+    private Set<Tuple<Polygon, Polygon>> checkInnerOverlap(\n+            final MultiMap<Polygon, Polygon> outerToInners)\n+    {\n+        final Set<Tuple<Polygon, Polygon>> problematicPolygons = new HashSet<>();\n+\n+        outerToInners.entrySet().forEach(entry ->", "originalCommit": "dc8d91fa5597f6303c09e146d5d88ddac9c171d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc1Nzc3Ng==", "url": "https://github.com/osmlab/atlas-checks/pull/297#discussion_r424757776", "bodyText": "Not sure if this is the best way to assign instructions for the different cases. The instructions could get changed in the future. Something to look out for.", "author": "sayas01", "createdAt": "2020-05-13T22:05:00Z", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/relations/InvalidMultiPolygonRelationCheck.java", "diffHunk": "@@ -185,43 +161,254 @@ else if (!relationMember.getRole().equals(RelationTypeTag.MULTIPOLYGON_ROLE_INNE\n         return FALLBACK_INSTRUCTIONS;\n     }\n \n-    private Optional<String> checkClosedLoop(final Relation relation)\n+    /**\n+     * Check that a multipolygon {@link Relation} has valid geometry.\n+     *\n+     * @param multipolygonRelation\n+     *            {@link Relation} of type multipolygon\n+     * @return an Optional containing a {@link Tuple} containing a {@link Set} of {@link String}\n+     *         instructions for invalid geometries and a {@link Set} of {@link Location}s marking\n+     *         the invalid geometries\n+     */\n+    private Optional<Tuple<Set<String>, Set<Location>>> checkGeometry(\n+            final Relation multipolygonRelation)\n     {\n+        // Try converting the Relation to a MultiPolygon. If it works check that the geometries\n+        // don't overlap.\n         try\n         {\n-            RELATION_OR_AREA_TO_MULTI_POLYGON_CONVERTER.convert(relation);\n+            return Optional.of(checkOverlap(\n+                    RELATION_OR_AREA_TO_MULTI_POLYGON_CONVERTER.convert(multipolygonRelation),\n+                    multipolygonRelation.getOsmIdentifier()));\n         }\n+        // Catch open polygons and mark the broken locations\n         catch (final MultiplePolyLineToPolygonsConverter.OpenPolygonException exception)\n         {\n             final List<Location> openLocations = exception.getOpenLocations();\n             final Set<AtlasObject> objects = openLocations.stream()\n-                    .flatMap(location -> this.filterMembers(relation, location))\n+                    .flatMap(location -> this.filterMembers(multipolygonRelation, location))\n                     .collect(Collectors.toSet());\n-            final Set<Long> memberIds = relation.members().stream()\n+            final Set<Long> memberIds = multipolygonRelation.members().stream()\n                     .map(member -> member.getEntity().getOsmIdentifier())\n                     .collect(Collectors.toSet());\n \n             if (!objects.isEmpty() && !memberIds.isEmpty())\n             {\n-                return Optional\n-                        .of(this.getLocalizedInstruction(CLOSED_LOOP_INSTRUCTION_FORMAT_INDEX,\n-                                relation.getOsmIdentifier(), memberIds, openLocations));\n+                return Optional.of(Tuple.createTuple(\n+                        Collections.singleton(this.getLocalizedInstruction(\n+                                CLOSED_LOOP_INSTRUCTION_FORMAT_INDEX,\n+                                multipolygonRelation.getOsmIdentifier(), memberIds, openLocations)),\n+                        new HashSet<>(openLocations)));\n             }\n             else\n             {\n-                logger.warn(\"Unable to find members in relation {} containing the locations : {}\",\n-                        relation, openLocations);\n+                logger.warn(\n+                        \"Unable to find members in multipolygonRelation {} containing the locations : {}\",\n+                        multipolygonRelation, openLocations);\n+            }\n+        }\n+        catch (final CoreException exception)\n+        {\n+            // Catch multipolygon relations with no outer members\n+            if (exception.getMessage().equals(\"Unable to find outer polygon.\"))", "originalCommit": "dc8d91fa5597f6303c09e146d5d88ddac9c171d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc3MDkxNg==", "url": "https://github.com/osmlab/atlas-checks/pull/297#discussion_r424770916", "bodyText": "It's not ideal, but if it does change it should be caught by the unit tests.", "author": "Bentleysb", "createdAt": "2020-05-13T22:39:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc1Nzc3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc1MzQyNw==", "url": "https://github.com/osmlab/atlas-checks/pull/297#discussion_r424753427", "bodyText": "Should this come with a general flag indicating misplaced relation members?", "author": "seancoulter", "createdAt": "2020-05-13T21:54:42Z", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/relations/InvalidMultiPolygonRelationCheck.java", "diffHunk": "@@ -185,43 +161,254 @@ else if (!relationMember.getRole().equals(RelationTypeTag.MULTIPOLYGON_ROLE_INNE\n         return FALLBACK_INSTRUCTIONS;\n     }\n \n-    private Optional<String> checkClosedLoop(final Relation relation)\n+    /**\n+     * Check that a multipolygon {@link Relation} has valid geometry.\n+     *\n+     * @param multipolygonRelation\n+     *            {@link Relation} of type multipolygon\n+     * @return an Optional containing a {@link Tuple} containing a {@link Set} of {@link String}\n+     *         instructions for invalid geometries and a {@link Set} of {@link Location}s marking\n+     *         the invalid geometries\n+     */\n+    private Optional<Tuple<Set<String>, Set<Location>>> checkGeometry(\n+            final Relation multipolygonRelation)\n     {\n+        // Try converting the Relation to a MultiPolygon. If it works check that the geometries\n+        // don't overlap.\n         try\n         {\n-            RELATION_OR_AREA_TO_MULTI_POLYGON_CONVERTER.convert(relation);\n+            return Optional.of(checkOverlap(\n+                    RELATION_OR_AREA_TO_MULTI_POLYGON_CONVERTER.convert(multipolygonRelation),\n+                    multipolygonRelation.getOsmIdentifier()));\n         }\n+        // Catch open polygons and mark the broken locations\n         catch (final MultiplePolyLineToPolygonsConverter.OpenPolygonException exception)\n         {\n             final List<Location> openLocations = exception.getOpenLocations();\n             final Set<AtlasObject> objects = openLocations.stream()\n-                    .flatMap(location -> this.filterMembers(relation, location))\n+                    .flatMap(location -> this.filterMembers(multipolygonRelation, location))\n                     .collect(Collectors.toSet());\n-            final Set<Long> memberIds = relation.members().stream()\n+            final Set<Long> memberIds = multipolygonRelation.members().stream()\n                     .map(member -> member.getEntity().getOsmIdentifier())\n                     .collect(Collectors.toSet());\n \n             if (!objects.isEmpty() && !memberIds.isEmpty())\n             {\n-                return Optional\n-                        .of(this.getLocalizedInstruction(CLOSED_LOOP_INSTRUCTION_FORMAT_INDEX,\n-                                relation.getOsmIdentifier(), memberIds, openLocations));\n+                return Optional.of(Tuple.createTuple(\n+                        Collections.singleton(this.getLocalizedInstruction(\n+                                CLOSED_LOOP_INSTRUCTION_FORMAT_INDEX,\n+                                multipolygonRelation.getOsmIdentifier(), memberIds, openLocations)),\n+                        new HashSet<>(openLocations)));\n             }\n             else\n             {\n-                logger.warn(\"Unable to find members in relation {} containing the locations : {}\",\n-                        relation, openLocations);\n+                logger.warn(", "originalCommit": "dc8d91fa5597f6303c09e146d5d88ddac9c171d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc3MDk0MQ==", "url": "https://github.com/osmlab/atlas-checks/pull/297#discussion_r424770941", "bodyText": "This was just part of the refactor, not a new addition, so I had not really looked into that. I think you're right that it probably should be flagged. However, I would need to do some investigation to make sure it was not done like this to ignore atlas data errors, or something of that sort. I think that might be good to investigate outside this PR.", "author": "Bentleysb", "createdAt": "2020-05-13T22:39:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc1MzQyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc1NTcyMw==", "url": "https://github.com/osmlab/atlas-checks/pull/297#discussion_r424755723", "bodyText": "\ud83d\udc4d", "author": "seancoulter", "createdAt": "2020-05-13T22:00:09Z", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/relations/InvalidMultiPolygonRelationCheck.java", "diffHunk": "@@ -185,43 +161,254 @@ else if (!relationMember.getRole().equals(RelationTypeTag.MULTIPOLYGON_ROLE_INNE\n         return FALLBACK_INSTRUCTIONS;\n     }\n \n-    private Optional<String> checkClosedLoop(final Relation relation)\n+    /**\n+     * Check that a multipolygon {@link Relation} has valid geometry.\n+     *\n+     * @param multipolygonRelation\n+     *            {@link Relation} of type multipolygon\n+     * @return an Optional containing a {@link Tuple} containing a {@link Set} of {@link String}\n+     *         instructions for invalid geometries and a {@link Set} of {@link Location}s marking\n+     *         the invalid geometries\n+     */\n+    private Optional<Tuple<Set<String>, Set<Location>>> checkGeometry(\n+            final Relation multipolygonRelation)\n     {\n+        // Try converting the Relation to a MultiPolygon. If it works check that the geometries\n+        // don't overlap.\n         try\n         {\n-            RELATION_OR_AREA_TO_MULTI_POLYGON_CONVERTER.convert(relation);\n+            return Optional.of(checkOverlap(\n+                    RELATION_OR_AREA_TO_MULTI_POLYGON_CONVERTER.convert(multipolygonRelation),\n+                    multipolygonRelation.getOsmIdentifier()));\n         }\n+        // Catch open polygons and mark the broken locations\n         catch (final MultiplePolyLineToPolygonsConverter.OpenPolygonException exception)\n         {\n             final List<Location> openLocations = exception.getOpenLocations();\n             final Set<AtlasObject> objects = openLocations.stream()\n-                    .flatMap(location -> this.filterMembers(relation, location))\n+                    .flatMap(location -> this.filterMembers(multipolygonRelation, location))\n                     .collect(Collectors.toSet());\n-            final Set<Long> memberIds = relation.members().stream()\n+            final Set<Long> memberIds = multipolygonRelation.members().stream()\n                     .map(member -> member.getEntity().getOsmIdentifier())\n                     .collect(Collectors.toSet());\n \n             if (!objects.isEmpty() && !memberIds.isEmpty())\n             {\n-                return Optional\n-                        .of(this.getLocalizedInstruction(CLOSED_LOOP_INSTRUCTION_FORMAT_INDEX,\n-                                relation.getOsmIdentifier(), memberIds, openLocations));\n+                return Optional.of(Tuple.createTuple(\n+                        Collections.singleton(this.getLocalizedInstruction(\n+                                CLOSED_LOOP_INSTRUCTION_FORMAT_INDEX,\n+                                multipolygonRelation.getOsmIdentifier(), memberIds, openLocations)),\n+                        new HashSet<>(openLocations)));\n             }\n             else\n             {\n-                logger.warn(\"Unable to find members in relation {} containing the locations : {}\",\n-                        relation, openLocations);\n+                logger.warn(\n+                        \"Unable to find members in multipolygonRelation {} containing the locations : {}\",\n+                        multipolygonRelation, openLocations);\n+            }\n+        }\n+        catch (final CoreException exception)\n+        {\n+            // Catch multipolygon relations with no outer members\n+            if (exception.getMessage().equals(\"Unable to find outer polygon.\"))\n+            {\n+                return Optional.of(Tuple.createTuple(\n+                        Collections.singleton(\n+                                this.getLocalizedInstruction(MISSING_OUTER_INSTRUCTION_FORMAT_INDEX,\n+                                        multipolygonRelation.getOsmIdentifier())),\n+                        Collections.emptySet()));\n             }\n+            // Catch inner members that are not inside an outer member\n+            if (exception.getMessage().contains(\"Malformed MultiPolygon: inner has no outer host\"))\n+            {\n+                return Optional\n+                        .of(Tuple.createTuple(\n+                                Collections.singleton(this.getLocalizedInstruction(\n+                                        INNER_MISSING_OUTER_INSTRUCTION_FORMAT_INDEX,\n+                                        multipolygonRelation.getOsmIdentifier())),\n+                                Collections.emptySet()));\n+            }\n+\n+            // Ignore other core exceptions\n+            logger.warn(\"Unable to convert multipolygonRelation {}. {}\",\n+                    multipolygonRelation.getOsmIdentifier(), exception.getMessage());\n         }\n         catch (final Exception exception)\n         {\n-            logger.warn(\"Unable to convert relation {}. {}\", relation.getOsmIdentifier(),\n-                    exception.getMessage());\n+            logger.warn(\"Unable to convert multipolygonRelation {}. {}\",\n+                    multipolygonRelation.getOsmIdentifier(), exception.getMessage());\n         }\n \n         return Optional.empty();\n     }\n \n+    /**\n+     * Check that inner polygons do not intersect any outers and do not overlap other inners. Inners\n+     * are allowed to touch other inners.\n+     *\n+     * @param outerToInners\n+     *            {@link MultiMap} of outer {@link Polygon}s to inner {@link Polygon}s\n+     * @return a {@link Set} of {@link Tuple}s containing {@link Polygon}s that invalidly overlap\n+     */\n+    private Set<Tuple<Polygon, Polygon>> checkInnerOverlap(\n+            final MultiMap<Polygon, Polygon> outerToInners)\n+    {\n+        final Set<Tuple<Polygon, Polygon>> problematicPolygons = new HashSet<>();\n+\n+        outerToInners.entrySet().forEach(entry ->\n+        {\n+            // Loop through each combination of inner polygons only once to check for overlap\n+            for (int index1 = 0; index1 < entry.getValue().size() - 1; index1++)", "originalCommit": "dc8d91fa5597f6303c09e146d5d88ddac9c171d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6f8fe9049ee2c6aaf9d6637425ae73968afe6a4e", "url": "https://github.com/osmlab/atlas-checks/commit/6f8fe9049ee2c6aaf9d6637425ae73968afe6a4e", "message": "better forEach", "committedDate": "2020-05-13T22:44:35Z", "type": "commit"}]}