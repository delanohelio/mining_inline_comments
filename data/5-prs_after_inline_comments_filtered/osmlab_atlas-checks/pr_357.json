{"pr_number": 357, "pr_title": "Generic Tag Checking (Osmose 3050, 3150, and 4090)", "pr_createdAt": "2020-09-08T14:18:49Z", "pr_url": "https://github.com/osmlab/atlas-checks/pull/357", "timeline": [{"oid": "07832a3079d4889a276ee49920667bb5c01b5e50", "url": "https://github.com/osmlab/atlas-checks/commit/07832a3079d4889a276ee49920667bb5c01b5e50", "message": "InvalidTagsCheck: Check for unwanted tags on objects\n\n* Skip tags that are checked by other tests (requires use of an\n  annotation). This check uses reflection to get annotated fields.\n* Check for unwanted tags on objects using OSM Wiki Data\n* Use TagInfo information to expound upon issues detected by OSM Wiki\n  Data.\n* OSM Wiki Data is used for regex checking, when the Wiki Data has a\n  regex.\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2020-09-08T22:40:14Z", "type": "forcePushed"}, {"oid": "f474eb95010c58f65230c8c07f1fee24203591fb", "url": "https://github.com/osmlab/atlas-checks/commit/f474eb95010c58f65230c8c07f1fee24203591fb", "message": "InvalidTagsCheck: Check for unwanted tags on objects\n\n* Skip tags that are checked by other tests (requires use of an\n  annotation). This check uses reflection to get annotated fields.\n* Check for unwanted tags on objects using OSM Wiki Data\n* Use TagInfo information to expound upon issues detected by OSM Wiki\n  Data.\n* OSM Wiki Data is used for regex checking, when the Wiki Data has a\n  regex.\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2020-09-09T21:44:53Z", "type": "forcePushed"}, {"oid": "68621da56de54e30c3f1a151a519cb9b42c3f805", "url": "https://github.com/osmlab/atlas-checks/commit/68621da56de54e30c3f1a151a519cb9b42c3f805", "message": "InvalidTagsCheck: SonarLint and some better organization\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2020-09-10T13:13:36Z", "type": "forcePushed"}, {"oid": "20af11e03774e6028ebbfeebd1a7c81690a491c5", "url": "https://github.com/osmlab/atlas-checks/commit/20af11e03774e6028ebbfeebd1a7c81690a491c5", "message": "InvalidTagsCheckTest: Add configuration method for databases\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2020-09-22T20:06:12Z", "type": "forcePushed"}, {"oid": "5e3808dfa9ea5b82bf94bf8f079ba9b6a7805266", "url": "https://github.com/osmlab/atlas-checks/commit/5e3808dfa9ea5b82bf94bf8f079ba9b6a7805266", "message": "InvalidTagsCheck: Documentation + Fix Suggestions\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2020-09-23T22:32:39Z", "type": "forcePushed"}, {"oid": "de73e0329829f3c726cb394201276118ac9781a8", "url": "https://github.com/osmlab/atlas-checks/commit/de73e0329829f3c726cb394201276118ac9781a8", "message": "FIXUP: Checkstyle\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2020-09-28T18:25:44Z", "type": "forcePushed"}, {"oid": "0296d4d0544e801a198a186462487f2014c8fac5", "url": "https://github.com/osmlab/atlas-checks/commit/0296d4d0544e801a198a186462487f2014c8fac5", "message": "GenericTagCheck: Add tests and some formatting fixes\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2020-11-13T17:51:36Z", "type": "forcePushed"}, {"oid": "a8e77a45d3c87074ff89ecb07c951bb66efd7b1e", "url": "https://github.com/osmlab/atlas-checks/commit/a8e77a45d3c87074ff89ecb07c951bb66efd7b1e", "message": "GenericTagCheck: Move fallback out of InvalidTagsCheck\n\n* Add tests and some formatting fixes\n* Move discrete code functions into separate methods", "committedDate": "2020-11-19T20:02:11Z", "type": "forcePushed"}, {"oid": "467bd146c5840938cb7dc1c0ebd5fe7f3d2236d6", "url": "https://github.com/osmlab/atlas-checks/commit/467bd146c5840938cb7dc1c0ebd5fe7f3d2236d6", "message": "GenericTagCheck: Add generic test for tag checking (using OSM Wiki Data and TagInfo)\n\nAbbreviatedNameCheck: Improve validCheckForObject\n* Only objects with names are valid checks.\n\nGenericTagCheck: Check for unpopular tags with taginfo\n* Implement Autocloseable and check for that in RunnableCheck (if\n  implemented, close)\n* Add SQLiteUtils in an effort to allow the DB connection to be\n  serialized (and significantly reduce time from reopening db)\n* Check for unwanted tags on objects using OSM Wiki Data\n* Use TagInfo information to expound upon issues detected by OSM Wiki\n  Data.\n* OSM Wiki Data is used for regex checking, when the Wiki Data has a\n  regex.\n* Account for P17 (redirect to) when a bad tag is encountered.\n\nSQLite:\n* Dependencies: Add SQLite\n* Cache gets for DB\n  * Assumption: DB doesn't change during the run\n\n    This brought the runtime on a MacBook 2017 (i7 w/ 16GB ram) from 14\n    hours to 2 hours (and a bit). The runtime for the dev/master branch was\n    also about 2 hours (and a bit).\n\n    The countries run were AIA, CYM, DMA, NZL, and SMR. There was no real\n    noticeable difference with BLZ.\n* Store a copy of the retrieved data without null values in SQLiteUtils\n\nTagInfo: Add download script\nWikiData: Add download script\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2020-11-19T20:08:20Z", "type": "forcePushed"}, {"oid": "dd04c146d01304ed90262e6a4a6f69aa2058a093", "url": "https://github.com/osmlab/atlas-checks/commit/dd04c146d01304ed90262e6a4a6f69aa2058a093", "message": "GenericTagCheck: Add generic test for tag checking (using OSM Wiki Data and TagInfo)\n\nAbbreviatedNameCheck: Improve validCheckForObject\n* Only objects with names are valid checks.\n\nGenericTagCheck: Check for unpopular tags with taginfo\n* Implement Autocloseable and check for that in RunnableCheck (if\n  implemented, close)\n* Add SQLiteUtils in an effort to allow the DB connection to be\n  serialized (and significantly reduce time from reopening db)\n* Check for unwanted tags on objects using OSM Wiki Data\n* Use TagInfo information to expound upon issues detected by OSM Wiki\n  Data.\n* OSM Wiki Data is used for regex checking, when the Wiki Data has a\n  regex.\n* Account for P17 (redirect to) when a bad tag is encountered.\n\nSQLite:\n* Dependencies: Add SQLite\n* Cache gets for DB\n  * Assumption: DB doesn't change during the run\n\n    This brought the runtime on a MacBook 2017 (i7 w/ 16GB ram) from 14\n    hours to 2 hours (and a bit). The runtime for the dev/master branch was\n    also about 2 hours (and a bit).\n\n    The countries run were AIA, CYM, DMA, NZL, and SMR. There was no real\n    noticeable difference with BLZ.\n* Store a copy of the retrieved data without null values in SQLiteUtils\n\nTagInfo: Add download script\nWikiData: Add download script\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2020-11-19T20:22:54Z", "type": "forcePushed"}, {"oid": "8719e529008683abda63b6d20dba449113673744", "url": "https://github.com/osmlab/atlas-checks/commit/8719e529008683abda63b6d20dba449113673744", "message": "GenericTagCheck: Don't add autofixes when not everything will be fixed\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2020-11-24T17:32:17Z", "type": "forcePushed"}, {"oid": "0d0d99ee3c7d8af9e78be9415dec2911bab5cb57", "url": "https://github.com/osmlab/atlas-checks/commit/0d0d99ee3c7d8af9e78be9415dec2911bab5cb57", "message": "GenericTagCheck: Add generic test for tag checking (using OSM Wiki Data and TagInfo)\n\nAbbreviatedNameCheck: Improve validCheckForObject\n* Only objects with names are valid checks.\n\nGenericTagCheck: Check for unpopular tags with taginfo\n* Implement Autocloseable and check for that in RunnableCheck (if\n  implemented, close)\n* Add SQLiteUtils in an effort to allow the DB connection to be\n  serialized (and significantly reduce time from reopening db)\n* Check for unwanted tags on objects using OSM Wiki Data\n* Use TagInfo information to expound upon issues detected by OSM Wiki\n  Data.\n* OSM Wiki Data is used for regex checking, when the Wiki Data has a\n  regex.\n* Account for P17 (redirect to) when a bad tag is encountered.\n\nSQLite:\n* Dependencies: Add SQLite\n* Cache gets for DB\n  * Assumption: DB doesn't change during the run\n\n    This brought the runtime on a MacBook 2017 (i7 w/ 16GB ram) from 14\n    hours to 2 hours (and a bit). The runtime for the dev/master branch was\n    also about 2 hours (and a bit).\n\n    The countries run were AIA, CYM, DMA, NZL, and SMR. There was no real\n    noticeable difference with BLZ.\n* Store a copy of the retrieved data without null values in SQLiteUtils\n\nTagInfo: Add download script\nWikiData: Add download script\n        * Update older entries and write changes to a file\n\n        This means that changes can be inspected and verified (future task:\n        insert into an HTML page with links so people can more easily tell if\n        the change is relevant or not).\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2020-11-25T19:14:57Z", "type": "forcePushed"}, {"oid": "4968de9c1f4cf78456d6f8d4115f3654b5d2f20e", "url": "https://github.com/osmlab/atlas-checks/commit/4968de9c1f4cf78456d6f8d4115f3654b5d2f20e", "message": "GenericTagCheck: Add generic test for tag checking (using OSM Wiki Data and TagInfo)\n\nAbbreviatedNameCheck: Improve validCheckForObject\n* Only objects with names are valid checks.\n\nGenericTagCheck: Check for unpopular tags with taginfo\n* Implement Autocloseable and check for that in RunnableCheck (if\n  implemented, close)\n* Add SQLiteUtils in an effort to allow the DB connection to be\n  serialized (and significantly reduce time from reopening db)\n* Check for unwanted tags on objects using OSM Wiki Data\n* Use TagInfo information to expound upon issues detected by OSM Wiki\n  Data.\n* OSM Wiki Data is used for regex checking, when the Wiki Data has a\n  regex.\n* Account for P17 (redirect to) when a bad tag is encountered.\n\nSQLite:\n* Dependencies: Add SQLite\n* Cache gets for DB\n  * Assumption: DB doesn't change during the run\n\n    This brought the runtime on a MacBook 2017 (i7 w/ 16GB ram) from 14\n    hours to 2 hours (and a bit). The runtime for the dev/master branch was\n    also about 2 hours (and a bit).\n\n    The countries run were AIA, CYM, DMA, NZL, and SMR. There was no real\n    noticeable difference with BLZ.\n* Store a copy of the retrieved data without null values in SQLiteUtils\n\nTagInfo: Add download script\nWikiData: Add download script\n        * Update older entries and write changes to a file\n\n        This means that changes can be inspected and verified (future task:\n        insert into an HTML page with links so people can more easily tell if\n        the change is relevant or not).\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2020-11-25T19:19:04Z", "type": "forcePushed"}, {"oid": "0fcf12a9456e712ed167ceb12410e50a8536f897", "url": "https://github.com/osmlab/atlas-checks/commit/0fcf12a9456e712ed167ceb12410e50a8536f897", "message": "GenericTagCheck: Add method stubs for country and relation checks", "committedDate": "2020-11-30T19:27:38Z", "type": "forcePushed"}, {"oid": "d5ce5e595bdc9c5a3a14ff8077f756862b466c11", "url": "https://github.com/osmlab/atlas-checks/commit/d5ce5e595bdc9c5a3a14ff8077f756862b466c11", "message": "GenericTagCheck: Add generic test for tag checking (using OSM Wiki Data and TagInfo)\n\nAbbreviatedNameCheck: Improve validCheckForObject\n* Only objects with names are valid checks.\n\nGenericTagCheck: Check for unpopular tags with taginfo\n* Implement Autocloseable and check for that in RunnableCheck (if\n  implemented, close)\n* Add SQLiteUtils in an effort to allow the DB connection to be\n  serialized (and significantly reduce time from reopening db)\n* Check for unwanted tags on objects using OSM Wiki Data\n* Use TagInfo information to expound upon issues detected by OSM Wiki\n  Data.\n* OSM Wiki Data is used for regex checking, when the Wiki Data has a\n  regex.\n* Account for P17 (redirect to) when a bad tag is encountered.\n\nSQLite:\n* Dependencies: Add SQLite\n* Cache gets for DB\n  * Assumption: DB doesn't change during the run\n\n    This brought the runtime on a MacBook 2017 (i7 w/ 16GB ram) from 14\n    hours to 2 hours (and a bit). The runtime for the dev/master branch was\n    also about 2 hours (and a bit).\n\n    The countries run were AIA, CYM, DMA, NZL, and SMR. There was no real\n    noticeable difference with BLZ.\n* Store a copy of the retrieved data without null values in SQLiteUtils\n\nTagInfo: Add download script\nWikiData: Add download script\n        * Update older entries and write changes to a file\n\n        This means that changes can be inspected and verified (future task:\n        insert into an HTML page with links so people can more easily tell if\n        the change is relevant or not).\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2020-12-30T18:17:54Z", "type": "forcePushed"}, {"oid": "6e8daceeb4cee9de81fde07098945d1dda3e0505", "url": "https://github.com/osmlab/atlas-checks/commit/6e8daceeb4cee9de81fde07098945d1dda3e0505", "message": "GenericTagCheck: Add generic test for tag checking (using OSM Wiki Data and TagInfo)\n\nAbbreviatedNameCheck: Improve validCheckForObject\n* Only objects with names are valid checks.\n\nGenericTagCheck: Check for unpopular tags with taginfo\n* Implement Autocloseable and check for that in RunnableCheck (if\n  implemented, close)\n* Add SQLiteUtils in an effort to allow the DB connection to be\n  serialized (and significantly reduce time from reopening db)\n* Check for unwanted tags on objects using OSM Wiki Data\n* Use TagInfo information to expound upon issues detected by OSM Wiki\n  Data.\n* OSM Wiki Data is used for regex checking, when the Wiki Data has a\n  regex.\n* Account for P17 (redirect to) when a bad tag is encountered.\n\nSQLite:\n* Dependencies: Add SQLite\n* Cache gets for DB\n  * Assumption: DB doesn't change during the run\n\n    This brought the runtime on a MacBook 2017 (i7 w/ 16GB ram) from 14\n    hours to 2 hours (and a bit). The runtime for the dev/master branch was\n    also about 2 hours (and a bit).\n\n    The countries run were AIA, CYM, DMA, NZL, and SMR. There was no real\n    noticeable difference with BLZ.\n* Store a copy of the retrieved data without null values in SQLiteUtils\n\nTagInfo: Add download script\nWikiData: Add download script\n        * Update older entries and write changes to a file\n\n        This means that changes can be inspected and verified (future task:\n        insert into an HTML page with links so people can more easily tell if\n        the change is relevant or not).\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2020-12-30T19:29:36Z", "type": "forcePushed"}, {"oid": "efae0e7a7ff3f6ea62255c92b0f6306a00311bd8", "url": "https://github.com/osmlab/atlas-checks/commit/efae0e7a7ff3f6ea62255c92b0f6306a00311bd8", "message": "GenericTagCheck: Mutation testing coverage\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2021-01-05T18:28:39Z", "type": "forcePushed"}, {"oid": "45b7e6e5fe7b5f3c96b00f5e1cb26544ebfa0831", "url": "https://github.com/osmlab/atlas-checks/commit/45b7e6e5fe7b5f3c96b00f5e1cb26544ebfa0831", "message": "FIXUP\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2021-01-12T23:53:50Z", "type": "forcePushed"}, {"oid": "89e4aeb45c6c77a109977601606198a8225e3dc8", "url": "https://github.com/osmlab/atlas-checks/commit/89e4aeb45c6c77a109977601606198a8225e3dc8", "message": "GenericTagCheck: Update text to include links for wiki data items\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2021-04-07T19:36:57Z", "type": "forcePushed"}, {"oid": "4eb7bca0cb44799dc57f4a51114e07b9404e74fe", "url": "https://github.com/osmlab/atlas-checks/commit/4eb7bca0cb44799dc57f4a51114e07b9404e74fe", "message": "GenericTagCheck: Update text to include links for wiki data items\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2021-04-07T20:52:43Z", "type": "forcePushed"}, {"oid": "b93472489fa786ccf03648ddefacca2244f270d5", "url": "https://github.com/osmlab/atlas-checks/commit/b93472489fa786ccf03648ddefacca2244f270d5", "message": "GenericTagCheck: Add checks for relations and tags that should only be in specific locations.\n\n* SQLiteUtils: Store file fetcher for use on computation nodes\n* FeatureChange: Add interfaces for remove/replace tag changes\n* WikiData: When duplicate unique keys appear, print out what was being inserted\n* GenericTagCheck: Attempt to avoid using edges in flags\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2021-04-07T20:58:26Z", "type": "forcePushed"}, {"oid": "89e4aeb45c6c77a109977601606198a8225e3dc8", "url": "https://github.com/osmlab/atlas-checks/commit/89e4aeb45c6c77a109977601606198a8225e3dc8", "message": "GenericTagCheck: Update text to include links for wiki data items\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2021-04-07T19:36:57Z", "type": "forcePushed"}, {"oid": "b93472489fa786ccf03648ddefacca2244f270d5", "url": "https://github.com/osmlab/atlas-checks/commit/b93472489fa786ccf03648ddefacca2244f270d5", "message": "GenericTagCheck: Add checks for relations and tags that should only be in specific locations.\n\n* SQLiteUtils: Store file fetcher for use on computation nodes\n* FeatureChange: Add interfaces for remove/replace tag changes\n* WikiData: When duplicate unique keys appear, print out what was being inserted\n* GenericTagCheck: Attempt to avoid using edges in flags\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2021-04-07T20:58:26Z", "type": "forcePushed"}, {"oid": "0e79c9bf909bba0cfe1108aa793d0a74893c1793", "url": "https://github.com/osmlab/atlas-checks/commit/0e79c9bf909bba0cfe1108aa793d0a74893c1793", "message": "GenericTagCheck: Add generic test for tag checking (using OSM Wiki Data and TagInfo)\n\nAbbreviatedNameCheck: Improve validCheckForObject\n* Only objects with names are valid checks.\n\nGenericTagCheck: Check for unpopular tags with taginfo\n* Implement Autocloseable and check for that in RunnableCheck (if\n  implemented, close)\n* Add SQLiteUtils in an effort to allow the DB connection to be\n  serialized (and significantly reduce time from reopening db)\n* Check for unwanted tags on objects using OSM Wiki Data\n* Use TagInfo information to expound upon issues detected by OSM Wiki\n  Data.\n* OSM Wiki Data is used for regex checking, when the Wiki Data has a\n  regex.\n* Account for P17 (redirect to) when a bad tag is encountered.\n* Add checks for relations and tags that should only be in specific locations.\n* Attempt to avoid using edges in flags\n\nSQLite:\n* Dependencies: Add SQLite\n* Cache gets for DB\n  * Assumption: DB doesn't change during the run\n\n    This brought the runtime on a MacBook 2017 (i7 w/ 16GB ram) from 14\n    hours to 2 hours (and a bit). The runtime for the dev/master branch was\n    also about 2 hours (and a bit).\n\n    The countries run were AIA, CYM, DMA, NZL, and SMR. There was no real\n    noticeable difference with BLZ.\n* Store a copy of the retrieved data without null values in SQLiteUtils\n* Store file fetcher for use on computation nodes\n\nTagInfo: Add download script\nWikiData: Add download script\n* Update older entries and write changes to a file\n\n  This means that changes can be inspected and verified (future task:\n  insert into an HTML page with links so people can more easily tell if\n  the change is relevant or not).\n* When duplicate unique keys appear, print out what was being inserted\n\n* FeatureChange: Add interfaces for remove/replace tag changes\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2021-04-08T17:34:34Z", "type": "forcePushed"}, {"oid": "b93472489fa786ccf03648ddefacca2244f270d5", "url": "https://github.com/osmlab/atlas-checks/commit/b93472489fa786ccf03648ddefacca2244f270d5", "message": "GenericTagCheck: Add checks for relations and tags that should only be in specific locations.\n\n* SQLiteUtils: Store file fetcher for use on computation nodes\n* FeatureChange: Add interfaces for remove/replace tag changes\n* WikiData: When duplicate unique keys appear, print out what was being inserted\n* GenericTagCheck: Attempt to avoid using edges in flags\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2021-04-07T20:58:26Z", "type": "forcePushed"}, {"oid": "6de6a55a77f08594b4a379dc0d1ccc1151e0b475", "url": "https://github.com/osmlab/atlas-checks/commit/6de6a55a77f08594b4a379dc0d1ccc1151e0b475", "message": "GenericTagCheck: Add generic test for tag checking (using OSM Wiki Data and TagInfo)\n\nAbbreviatedNameCheck: Improve validCheckForObject\n* Only objects with names are valid checks.\n\nGenericTagCheck: Check for unpopular tags with taginfo\n* Implement Autocloseable and check for that in RunnableCheck (if\n  implemented, close)\n* Add SQLiteUtils in an effort to allow the DB connection to be\n  serialized (and significantly reduce time from reopening db)\n* Check for unwanted tags on objects using OSM Wiki Data\n* Use TagInfo information to expound upon issues detected by OSM Wiki\n  Data.\n* OSM Wiki Data is used for regex checking, when the Wiki Data has a\n  regex.\n* Account for P17 (redirect to) when a bad tag is encountered.\n* Add checks for relations and tags that should only be in specific locations.\n* Attempt to avoid using edges in flags\n\nSQLite:\n* Dependencies: Add SQLite\n* Cache gets for DB\n  * Assumption: DB doesn't change during the run\n\n    This brought the runtime on a MacBook 2017 (i7 w/ 16GB ram) from 14\n    hours to 2 hours (and a bit). The runtime for the dev/master branch was\n    also about 2 hours (and a bit).\n\n    The countries run were AIA, CYM, DMA, NZL, and SMR. There was no real\n    noticeable difference with BLZ.\n* Store a copy of the retrieved data without null values in SQLiteUtils\n* Store file fetcher for use on computation nodes\n\nTagInfo: Add download script\nWikiData: Add download script\n* Update older entries and write changes to a file\n\n  This means that changes can be inspected and verified (future task:\n  insert into an HTML page with links so people can more easily tell if\n  the change is relevant or not).\n* When duplicate unique keys appear, print out what was being inserted\n\n* FeatureChange: Add interfaces for remove/replace tag changes\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2021-04-12T13:14:45Z", "type": "forcePushed"}, {"oid": "b93472489fa786ccf03648ddefacca2244f270d5", "url": "https://github.com/osmlab/atlas-checks/commit/b93472489fa786ccf03648ddefacca2244f270d5", "message": "GenericTagCheck: Add checks for relations and tags that should only be in specific locations.\n\n* SQLiteUtils: Store file fetcher for use on computation nodes\n* FeatureChange: Add interfaces for remove/replace tag changes\n* WikiData: When duplicate unique keys appear, print out what was being inserted\n* GenericTagCheck: Attempt to avoid using edges in flags\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2021-04-07T20:58:26Z", "type": "forcePushed"}, {"oid": "6de6a55a77f08594b4a379dc0d1ccc1151e0b475", "url": "https://github.com/osmlab/atlas-checks/commit/6de6a55a77f08594b4a379dc0d1ccc1151e0b475", "message": "GenericTagCheck: Add generic test for tag checking (using OSM Wiki Data and TagInfo)\n\nAbbreviatedNameCheck: Improve validCheckForObject\n* Only objects with names are valid checks.\n\nGenericTagCheck: Check for unpopular tags with taginfo\n* Implement Autocloseable and check for that in RunnableCheck (if\n  implemented, close)\n* Add SQLiteUtils in an effort to allow the DB connection to be\n  serialized (and significantly reduce time from reopening db)\n* Check for unwanted tags on objects using OSM Wiki Data\n* Use TagInfo information to expound upon issues detected by OSM Wiki\n  Data.\n* OSM Wiki Data is used for regex checking, when the Wiki Data has a\n  regex.\n* Account for P17 (redirect to) when a bad tag is encountered.\n* Add checks for relations and tags that should only be in specific locations.\n* Attempt to avoid using edges in flags\n\nSQLite:\n* Dependencies: Add SQLite\n* Cache gets for DB\n  * Assumption: DB doesn't change during the run\n\n    This brought the runtime on a MacBook 2017 (i7 w/ 16GB ram) from 14\n    hours to 2 hours (and a bit). The runtime for the dev/master branch was\n    also about 2 hours (and a bit).\n\n    The countries run were AIA, CYM, DMA, NZL, and SMR. There was no real\n    noticeable difference with BLZ.\n* Store a copy of the retrieved data without null values in SQLiteUtils\n* Store file fetcher for use on computation nodes\n\nTagInfo: Add download script\nWikiData: Add download script\n* Update older entries and write changes to a file\n\n  This means that changes can be inspected and verified (future task:\n  insert into an HTML page with links so people can more easily tell if\n  the change is relevant or not).\n* When duplicate unique keys appear, print out what was being inserted\n\n* FeatureChange: Add interfaces for remove/replace tag changes\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2021-04-12T13:14:45Z", "type": "forcePushed"}, {"oid": "b93472489fa786ccf03648ddefacca2244f270d5", "url": "https://github.com/osmlab/atlas-checks/commit/b93472489fa786ccf03648ddefacca2244f270d5", "message": "GenericTagCheck: Add checks for relations and tags that should only be in specific locations.\n\n* SQLiteUtils: Store file fetcher for use on computation nodes\n* FeatureChange: Add interfaces for remove/replace tag changes\n* WikiData: When duplicate unique keys appear, print out what was being inserted\n* GenericTagCheck: Attempt to avoid using edges in flags\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2021-04-07T20:58:26Z", "type": "forcePushed"}, {"oid": "b93472489fa786ccf03648ddefacca2244f270d5", "url": "https://github.com/osmlab/atlas-checks/commit/b93472489fa786ccf03648ddefacca2244f270d5", "message": "GenericTagCheck: Add checks for relations and tags that should only be in specific locations.\n\n* SQLiteUtils: Store file fetcher for use on computation nodes\n* FeatureChange: Add interfaces for remove/replace tag changes\n* WikiData: When duplicate unique keys appear, print out what was being inserted\n* GenericTagCheck: Attempt to avoid using edges in flags\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2021-04-07T20:58:26Z", "type": "forcePushed"}, {"oid": "c722599e05d7d2ba2bd117470a4fbf222ec893f7", "url": "https://github.com/osmlab/atlas-checks/commit/c722599e05d7d2ba2bd117470a4fbf222ec893f7", "message": "GenericTagCheck: Add generic test for tag checking (using OSM Wiki Data and TagInfo)\n\nAbbreviatedNameCheck: Improve validCheckForObject\n* Only objects with names are valid checks.\n\nFeatureChange: Add interfaces for remove/replace tag changes\n\nGenericTagCheck: Check for unpopular tags with taginfo\n* Implement Autocloseable and check for that in RunnableCheck (if\n  implemented, close)\n* Add SQLiteUtils in an effort to allow the DB connection to be\n  serialized (and significantly reduce time from reopening db)\n* Check for unwanted tags on objects using OSM Wiki Data\n* Use TagInfo information to expound upon issues detected by OSM Wiki\n  Data.\n* OSM Wiki Data is used for regex checking, when the Wiki Data has a\n  regex.\n* Account for P17 (redirect to) when a bad tag is encountered.\n\nSQLite:\n* Dependencies: Add SQLite\n* Cache gets for DB\n  * Assumption: DB doesn't change during the run\n\n    This brought the runtime on a MacBook 2017 (i7 w/ 16GB ram) from 14\n    hours to 2 hours (and a bit). The runtime for the dev/master branch was\n    also about 2 hours (and a bit).\n\n    The countries run were AIA, CYM, DMA, NZL, and SMR. There was no real\n    noticeable difference with BLZ.\n* Store a copy of the retrieved data without null values in SQLiteUtils\n* Store file fetcher for use on computation nodes\n\nTagInfo: Add download script\nWikiData: Add download script\n* Update older entries and write changes to a file\n\n  This means that changes can be inspected and verified (future task:\n  insert into an HTML page with links so people can more easily tell if\n  the change is relevant or not).\n* When duplicate unique keys appear, print out what was being inserted\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2021-06-16T14:24:10Z", "type": "forcePushed"}, {"oid": "b93472489fa786ccf03648ddefacca2244f270d5", "url": "https://github.com/osmlab/atlas-checks/commit/b93472489fa786ccf03648ddefacca2244f270d5", "message": "GenericTagCheck: Add checks for relations and tags that should only be in specific locations.\n\n* SQLiteUtils: Store file fetcher for use on computation nodes\n* FeatureChange: Add interfaces for remove/replace tag changes\n* WikiData: When duplicate unique keys appear, print out what was being inserted\n* GenericTagCheck: Attempt to avoid using edges in flags\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2021-04-07T20:58:26Z", "type": "forcePushed"}, {"oid": "c3810a7a81523dda96ea4614be6b76da6ca108f3", "url": "https://github.com/osmlab/atlas-checks/commit/c3810a7a81523dda96ea4614be6b76da6ca108f3", "message": "FIXUP: GenericTagCheck: Improve wording for some tasks\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2021-06-16T15:03:50Z", "type": "forcePushed"}, {"oid": "b93472489fa786ccf03648ddefacca2244f270d5", "url": "https://github.com/osmlab/atlas-checks/commit/b93472489fa786ccf03648ddefacca2244f270d5", "message": "GenericTagCheck: Add checks for relations and tags that should only be in specific locations.\n\n* SQLiteUtils: Store file fetcher for use on computation nodes\n* FeatureChange: Add interfaces for remove/replace tag changes\n* WikiData: When duplicate unique keys appear, print out what was being inserted\n* GenericTagCheck: Attempt to avoid using edges in flags\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2021-04-07T20:58:26Z", "type": "forcePushed"}, {"oid": "e72d38256ec3c029927bddf033aef77e0c9a99ed", "url": "https://github.com/osmlab/atlas-checks/commit/e72d38256ec3c029927bddf033aef77e0c9a99ed", "message": "FIXUP: Formatting\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2021-06-16T17:52:46Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1ODE4OTY1OA==", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r658189658", "bodyText": "One more to convert to var\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            final WikiData roleInfo = this\n          \n          \n            \n                            final var roleInfo = this", "author": "atiannicelli", "createdAt": "2021-06-24T18:31:58Z", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/GenericTagCheck.java", "diffHunk": "@@ -0,0 +1,939 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import java.text.MessageFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import java.util.function.Predicate;\n+import java.util.function.UnaryOperator;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.base.ExternalDataFetcher;\n+import org.openstreetmap.atlas.checks.database.taginfo.TagInfoKeyTagCommon;\n+import org.openstreetmap.atlas.checks.database.taginfo.TagInfoKeys;\n+import org.openstreetmap.atlas.checks.database.taginfo.TagInfoTags;\n+import org.openstreetmap.atlas.checks.database.wikidata.WikiData;\n+import org.openstreetmap.atlas.checks.database.wikidata.WikiDataItem;\n+import org.openstreetmap.atlas.checks.database.wikidata.WikiProperty;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.AtlasToOsmType;\n+import org.openstreetmap.atlas.checks.utility.KeyFullyCheckedUtils;\n+import org.openstreetmap.atlas.checks.utility.SQLiteUtils;\n+import org.openstreetmap.atlas.checks.utility.feature_change.IFeatureChange;\n+import org.openstreetmap.atlas.checks.utility.feature_change.RemoveTagFeatureChange;\n+import org.openstreetmap.atlas.checks.utility.feature_change.ReplaceTagFeatureChange;\n+import org.openstreetmap.atlas.geography.atlas.change.FeatureChange;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Relation;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMember;\n+import org.openstreetmap.atlas.locale.IsoCountry;\n+import org.openstreetmap.atlas.streaming.resource.Resource;\n+import org.openstreetmap.atlas.tags.ISOCountryTag;\n+import org.openstreetmap.atlas.tags.Taggable;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.testing.TestTaggable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Generic tag check using OSM Wiki Data and Tag Info databases.\n+ *\n+ * @author Taylor Smock\n+ */\n+public class GenericTagCheck extends BaseCheck<String>\n+{\n+    private static final long serialVersionUID = 5150282147895785829L;\n+    private static final String DEFAULT_NR_TAGS_INSTRUCTION = \"OSM feature {0,number,#} has invalid tags\";\n+    private static final String DEFAULT_INSTRUCTION = \"Check the following tags for missing, conflicting, or incorrect values: {0}\";\n+    private static final String INSTRUCTION_CONFLICTING_TAGS = \"Check the following tags for missing, conflicting, or incorrect values: {0}\";\n+    private static final String INSTRUCTION_INVALID_TAGS = \"OSM feature {0,number,#} has invalid tags\";\n+    private static final String INSTRUCTION_MISMATCHED_REGEX = \"{0} does not match the regex {1} for the key {2} (see https://wiki.osm.org/Item:{3})\";\n+    private static final String INSTRUCTION_PROHIBITED_USAGE = \"{0}={1} is prohibited on {2}. To determine whether to remove or change this tag please see this tag's Wiki Data page, https://wiki.osm.org/Item:{3} or the associated documentation Wiki Page on the Wiki Data page).\";\n+    private static final String INSTRUCTION_REPLACE = \"{0} should probably be replaced with {1} (see https://wiki.osm.org/Item:{2})\";\n+    private static final String INSTRUCTION_TAGINFO_POPULAR = \"{0} is probably an undocumented {1} ({2} instances). This should be documented on the wiki at https://wiki.osm.org/{3} and in the OpenStreetMap Wiki Data ( https://wiki.osm.org/Data_items ).\";\n+    private static final String INSTRUCTION_TAGINFO_UNPOPULAR = \"{0} is an unpopular key ({1} instances)\";\n+    private static final String INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION = \"{0}={1} should not be used in {2} (see https://wiki.osm.org/Item:{3})\";\n+    private static final String INSTRUCTION_UNDOCUMENTED_POPULAR_TAG = \"{0}={1} is not currently documented. Its global popularity ({2} uses) may merit adding wiki documentation for this value. Please consider adding a new Wiki Data page for {0}={1}.\";\n+    private static final String INSTRUCTION_UNKNOWN_RELATION_ROLE = \"{0}={1} is an unknown relation role for {0} ({2} {3,number,#} on relation {4,number,#}, see https://wiki.osm.org/Item:{5})\";\n+    private static final String INSTRUCTION_UNKNOWN_RELATION_TYPE = \"type={0} is an unknown relation type (relation {1,number,#}, see https://wiki.osm.org/Item:{2})\";\n+    private static final String INSTRUCTION_WELL_DEFINED_TAG_UNKNOWN_VALUE = \"{0} is not a well-known value for {1}\";\n+    private static final String INSTRUCTION_WIKI_DATA_REMOVAL = \"{0}={1} should probably be removed (it is {2}, see https://wiki.osm.org/Item:{3})\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Stream.of(DEFAULT_NR_TAGS_INSTRUCTION,\n+            DEFAULT_INSTRUCTION, INSTRUCTION_INVALID_TAGS, INSTRUCTION_CONFLICTING_TAGS,\n+            INSTRUCTION_MISMATCHED_REGEX, INSTRUCTION_UNDOCUMENTED_POPULAR_TAG,\n+            INSTRUCTION_WELL_DEFINED_TAG_UNKNOWN_VALUE, INSTRUCTION_WIKI_DATA_REMOVAL,\n+            INSTRUCTION_PROHIBITED_USAGE, INSTRUCTION_TAGINFO_UNPOPULAR,\n+            INSTRUCTION_TAGINFO_POPULAR, INSTRUCTION_REPLACE, INSTRUCTION_UNKNOWN_RELATION_ROLE,\n+            INSTRUCTION_UNKNOWN_RELATION_TYPE, INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION)\n+            .collect(Collectors.toCollection(ArrayList::new));\n+    private static final long DEFAULT_MIN_TAG_USAGE = 100;\n+\n+    private static final String DEFAULT_WIKI_TABLE = \"wiki_data\";\n+    private static final String DEFAULT_TAGINFO_TAG_TABLE = \"tags\";\n+    private static final String DEFAULT_TAGINFO_KEY_TABLE = \"keys\";\n+\n+    private static final Logger logger = LoggerFactory.getLogger(GenericTagCheck.class);\n+\n+    private final Long minTagUsage;\n+    // Due to serialization, this *cannot* be final\n+    private transient Collection<Predicate<Taggable>> ignoreTags = KeyFullyCheckedUtils\n+            .populateIgnoreTags();\n+\n+    private static final List<String> DEFAULT_TAGS_TO_REMOVE = Arrays.asList(\"abandoned\",\n+            \"discardable\", \"imported\", \"obsolete\", \"rejected\");\n+    private final List<String> tagsToRemove;\n+    private SQLiteUtils sqliteUtilsTagInfoTagTable;\n+    private SQLiteUtils sqliteUtilsTagInfoKeyTable;\n+    private SQLiteUtils sqliteUtilsWikiData;\n+    private static final String DEFAULT_TAGINFO_DB = \"taginfo-db.db\";\n+    private static final String DEFAULT_WIKIDATA_DB = \"wikidata.db\";\n+    private static final int DEFAULT_TAG_PERCENTAGE_KEY = 10;\n+    private final String tagInfoDB;\n+    private final String wikiDataDB;\n+    private final String wikiTable;\n+    private final String tagInfoTagTable;\n+    private final String tagInfoKeyTable;\n+    private final int popularTagPercentageKey;\n+\n+    /**\n+     * Check if an object is an area (i.e., an actual Area object OR a multipolygon)\n+     *\n+     * @param object\n+     *            The object to check\n+     * @return {@code true} if the object is an area\n+     */\n+    private static boolean isArea(final Taggable object)\n+    {\n+        return object instanceof Area\n+                || (object instanceof Relation && ((Relation) object).isMultiPolygon());\n+    }\n+\n+    /**\n+     * Check if an object may be an area\n+     *\n+     * @param object\n+     *            The object to check\n+     * @return {@code true} if the object <i>may</i> be an area.\n+     */\n+    private static boolean isClosedLine(final Taggable object)\n+    {\n+        return object instanceof LineItem && ((LineItem) object).isClosed();\n+    }\n+\n+    /**\n+     * Convert a tag entry into a string\n+     *\n+     * @param tag\n+     *            The tag to convert\n+     * @return A &ltkey&gt=&ltvalue&gt string\n+     */\n+    private static String tagToString(final Map.Entry<String, String> tag)\n+    {\n+        return Stream.of(tag.getKey(), tag.getValue()).filter(Objects::nonNull)\n+                .filter(string -> !string.isBlank()).collect(Collectors.joining(\"=\"));\n+    }\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     * @param fileFetcher\n+     *            A fetcher to get external data with\n+     */\n+    public GenericTagCheck(final Configuration configuration, final ExternalDataFetcher fileFetcher)\n+    {\n+        super(configuration);\n+        this.minTagUsage = this.configurationValue(configuration, \"tag.usage.min\",\n+                DEFAULT_MIN_TAG_USAGE);\n+\n+        this.tagsToRemove = this.configurationValue(configuration, \"wikidata.tag_removal\",\n+                DEFAULT_TAGS_TO_REMOVE);\n+        this.wikiTable = DEFAULT_WIKI_TABLE;\n+        this.tagInfoTagTable = DEFAULT_TAGINFO_TAG_TABLE;\n+        this.tagInfoKeyTable = DEFAULT_TAGINFO_KEY_TABLE;\n+        this.tagInfoDB = this.configurationValue(configuration, \"db.taginfo\", DEFAULT_TAGINFO_DB);\n+        this.wikiDataDB = this.configurationValue(configuration, \"db.wikidata\",\n+                DEFAULT_WIKIDATA_DB);\n+\n+        // At time of implementation, this.configurationValue(..., ..., Integer) returns\n+        // a Long.\n+        this.popularTagPercentageKey = this\n+                .configurationValue(configuration, \"tag.percentage_of_key_for_popular\",\n+                        ((Integer) DEFAULT_TAG_PERCENTAGE_KEY).longValue())\n+                .intValue();\n+\n+        // No matter what the atlas is, we need the db files. But only if we can get\n+        // them.\n+        if (fileFetcher == null)\n+        {\n+            return;\n+        }\n+        for (final String file : Arrays.asList(this.tagInfoDB, this.wikiDataDB))\n+        {\n+            final Optional<Resource> resource = fileFetcher.apply(file);\n+            if (!resource.isPresent() && logger.isDebugEnabled())\n+            {\n+                logger.debug(MessageFormat.format(\"{0} is not present\", file));\n+            }\n+        }\n+        this.fetchWikiData(fileFetcher);\n+        this.fetchTagInfo(fileFetcher);\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return !object.getOsmTags().isEmpty()\n+                && !this.isFlagged(this.getUniqueOSMIdentifier(object));\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        // Test against each filter and create an instruction if the object passes\n+        final Map<String, Collection<IFeatureChange>> instructions = new TreeMap<>();\n+\n+        if (this.sqliteUtilsTagInfoTagTable != null && this.sqliteUtilsWikiData != null)\n+        {\n+            if (this.ignoreTags == null || this.ignoreTags.isEmpty())\n+            {\n+                this.ignoreTags = KeyFullyCheckedUtils.populateIgnoreTags();\n+            }\n+            this.flagTags(object, instructions);\n+        }\n+\n+        if (!instructions.isEmpty())\n+        {\n+            // Mark objects flagged by their class and id to allow for the same id in\n+            // different object types\n+            this.markAsFlagged(this.getUniqueOSMIdentifier(object));\n+\n+            // Create a flag with generic instructions\n+            final String instruction = this.getLocalizedInstruction(\n+                    FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_INVALID_TAGS),\n+                    object.getOsmIdentifier());\n+            // If the object is an edge add the edges with the same OSM id\n+            final CheckFlag flag = (object instanceof Edge)\n+                    ? this.createFlag(((Edge) object).getMainEdge(), instruction)\n+                    : this.createFlag(object, instruction);\n+\n+            // Add the specific instructions\n+            instructions.keySet().forEach(flag::addInstruction);\n+            /*\n+             * Only add autofixes when instructions are the same size as the changes. This avoids\n+             * situations where a change is available and is valid, but there is an additional issue\n+             * that is not able to be automatically fixed. If MapRoulette ever supports a method to\n+             * indicate that a change partially fixes the flag, this can be changed back to {@code\n+             * changes.isEmpty()}.\n+             */\n+            if (instructions.entrySet().stream().noneMatch(entry -> entry.getValue().isEmpty()))\n+            {\n+                flag.addFixSuggestions(Collections.singleton(\n+                        IFeatureChange.createFeatureChange(FeatureChange::add, (AtlasEntity) object,\n+                                instructions.values().stream().flatMap(Collection::stream)\n+                                        .filter(Objects::nonNull).distinct()\n+                                        .collect(Collectors.toList()))));\n+            }\n+            return Optional.of(flag);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Check for country specific rules\n+     *\n+     * @param instructions\n+     *            The instructions for the object\n+     * @param object\n+     *            The taggable object which should have country tags\n+     * @param tag\n+     *            The actual tag we are checking\n+     * @param wikiMap\n+     *            The map of wiki information\n+     * @return {@code true} if the check failed (i.e., an instruction has been generated)\n+     */\n+    private boolean checkCountrySpecific(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Taggable object, final Map.Entry<String, String> tag, final WikiData wikiMap)\n+    {\n+        // P48 shouldn't be used on actual key/tag items\n+        if (wikiMap != null && (!wikiMap.getMustOnlyBeUsedInRegionP29().isEmpty()\n+                || !wikiMap.getNotToBeUsedInRegionP30().isEmpty()))\n+        {\n+            /* Create a function that converts country/region wiki data into ISO3 codes */\n+            final UnaryOperator<Collection<String>> toWikiData = countries -> countries.stream()\n+                    .map(this::getWikiDataId)\n+                    .filter(Objects::nonNull/* Ignore values that aren't in the db */)\n+                    .map(WikiData::getGeographicCodeP49)\n+                    .filter(Objects::nonNull/* Q21351 has a null value here */)\n+                    .flatMap(Collection::stream)\n+                    .map(IsoCountry::iso3ForIso2/* Convert ISO2 to ISO3 codes */)\n+                    .filter(Optional::isPresent).map(Optional::get).collect(Collectors.toList());\n+            // Object ISOCountryTags appear to be ISO3 codes.\n+            final List<String> countries = Iterables.asList(ISOCountryTag.all(object));\n+            String instruction = null;\n+            // The region keys are one or the other, but should never be both.\n+            if (!wikiMap.getMustOnlyBeUsedInRegionP29().isEmpty())\n+            {\n+                final Collection<String> onlyUsedInRegion = toWikiData\n+                        .apply(wikiMap.getMustOnlyBeUsedInRegionP29());\n+                // Some primitives may cross country lines, so if any country is a valid region,\n+                // continue on.\n+                if (countries.stream().noneMatch(onlyUsedInRegion::contains))\n+                {\n+                    instruction = INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION;\n+                }\n+            }\n+            // check on P30 becomes redundant due to earlier check.\n+            else\n+            {\n+                final Collection<String> notUsedInRegion = toWikiData\n+                        .apply(wikiMap.getNotToBeUsedInRegionP30());\n+                // If countries is empty, then don't bother checking. Otherwise, allMatch\n+                // returns true.\n+                if (!countries.isEmpty() && countries.stream().allMatch(notUsedInRegion::contains))\n+                {\n+                    instruction = INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION;\n+                }\n+            }\n+            // If the tag shouldn't be used in the region/area, it should be removed\n+            if (instruction != null)\n+            {\n+                instructions.put(\n+                        this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS.indexOf(instruction),\n+                                tag.getKey(), tag.getValue(), String.join(\", \", countries),\n+                                wikiMap.getId()),\n+                        Collections.singleton(new RemoveTagFeatureChange(tag)));\n+            }\n+\n+            return instruction != null;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check for fallback issues (mostly unpopular/popular tags not caught by wiki checks)\n+     *\n+     * @param instructions\n+     *            The instructions to add to\n+     * @param tag\n+     *            The tag to check\n+     * @param keyInfo\n+     *            The information for the key\n+     * @param popular\n+     *            {@code true} if the key is \"popular\"\n+     * @param tagOccurrence\n+     *            The information from TagInfo for the tag\n+     * @param keyOccurrence\n+     *            The information from TagInfo for the key\n+     */\n+    private void checkFallback(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Map.Entry<String, String> tag, final WikiData keyInfo, final boolean popular,\n+            final TagInfoTags tagOccurrence, final TagInfoKeys keyOccurrence)\n+    {\n+        if (keyInfo == null)\n+        {\n+            final String count;\n+            final Map.Entry<String, String> messageTag;\n+            if (tagOccurrence.getCountAll() != null)\n+            {\n+                count = tagOccurrence.getCountAll().toString();\n+                messageTag = tag;\n+            }\n+            else if (keyOccurrence.getCountAll() != null)\n+            {\n+                count = keyOccurrence.getCountAll().toString();\n+                messageTag = Map.entry(tag.getKey(), \"\");\n+            }\n+            else\n+            {\n+                count = \"<\" + this.minTagUsage.toString();\n+                messageTag = tag;\n+            }\n+            // Check for unpopular/bad tags not already caught by wiki check\n+            if (!popular)\n+            {\n+                instructions.put(this.getLocalizedInstruction(\n+                        FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_TAGINFO_UNPOPULAR),\n+                        tagToString(tag), count), Collections.emptyList());\n+            }\n+            else\n+            {\n+                final String type = messageTag.getValue().isBlank() ? \"Key\" : \"Tag\";\n+                instructions.put(this.getLocalizedInstruction(\n+                        FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_TAGINFO_POPULAR),\n+                        tagToString(messageTag), type.toLowerCase(Locale.ENGLISH), count,\n+                        new StringBuilder(type).append(':').append(tagToString(messageTag))\n+                                .toString()),\n+                        Collections.emptyList());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Check if a wiki data item for a tag redirects to another tag, and if so, create an\n+     * instruction and change for that.\n+     *\n+     * @param instructions\n+     *            The instructions collection to add to\n+     * @param changes\n+     *            The changes collection to add to\n+     * @param tag\n+     *            The tag to check\n+     * @param checkInfo\n+     *            Wiki Data information (more specific)\n+     * @return {@code true} if the tag fails the regex\n+     */\n+    private boolean checkRedirectTo(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Map.Entry<String, String> tag, final WikiData checkInfo)\n+    {\n+        if (checkInfo != null && !checkInfo.getRedirectToP17().isEmpty())\n+        {\n+            final String value = checkInfo.getInstanceOfP2().contains(\"key\")\n+                    ? checkInfo.getPermanentKeyIdP16()\n+                    : checkInfo.getPermanentTagIdP19();\n+            final Collection<String> redirects = checkInfo.getRedirectToP17();\n+            final Map<String, String> replacements = redirects.stream().map(replacementId ->\n+\n+            WikiData.getWikiData(this.sqliteUtilsWikiData.getRows(Map.of(\"id\", replacementId)))\n+\n+            ).filter(Objects::nonNull).map(this::parseTags).filter(Objects::nonNull)\n+                    .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n+            final Collection<IFeatureChange> featureChanges;\n+            if (!replacements.isEmpty())\n+            {\n+                featureChanges = new ArrayList<>();\n+                featureChanges.add(new RemoveTagFeatureChange(tag));\n+                for (final Map.Entry<String, String> newTag : replacements.entrySet())\n+                {\n+                    featureChanges.add(new ReplaceTagFeatureChange(tag, newTag));\n+                }\n+            }\n+            else\n+            {\n+                featureChanges = Collections.emptyList();\n+            }\n+\n+            instructions.put(\n+                    this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_REPLACE),\n+                            value,\n+                            replacements.entrySet().stream().map(GenericTagCheck::tagToString)\n+                                    .collect(Collectors.joining(\", \")),\n+                            checkInfo.getId()),\n+                    featureChanges);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check regexes for a tag\n+     *\n+     * @param instructions\n+     *            The instruction collection to append instructions to\n+     * @param tag\n+     *            The specific tag to check\n+     * @param checkInfo\n+     *            Wiki Data information (specific, if available)\n+     * @return {@code true} if the regex failed\n+     */\n+    private boolean checkRegex(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Map.Entry<String, String> tag, final WikiData checkInfo)\n+    {\n+        // \"P13\" is \"value validation regex\". We must wrap with \"^(\" and \")$\"\n+        if (checkInfo != null && checkInfo.getValueValidationRegexP13() != null)\n+        {\n+            // Reuse the compiled patterns\n+            final var pattern = checkInfo.getValueValidationRegexP13();\n+            if (!pattern.matcher(tag.getValue()).matches())\n+            {\n+                instructions.put(this.getLocalizedInstruction(\n+                        FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_MISMATCHED_REGEX), tag.getValue(),\n+                        pattern.toString(), tag.getKey(), checkInfo.getId()),\n+                        Collections.emptyList());\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Do relation specific checks\n+     *\n+     * @param instructions\n+     *            Instructions to add to\n+     * @param The\n+     *            object to check\n+     * @param checkInfo\n+     *            The wiki information for the tag to be checked\n+     * @param tag\n+     *            The tag to be checked\n+     * @return {@code true} if the relation had a problem\n+     */\n+    private boolean checkRelations(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Taggable object, final Map.Entry<String, String> tag, final WikiData checkInfo)\n+    {\n+        if (checkInfo != null && object instanceof Relation && checkInfo.isUseOnRelationsP36()\n+                && \"type\".equals(tag.getKey()))\n+        {\n+            final var relation = (Relation) object;\n+            final var relationInfo = this.getWikiData(\n+                    Map.of(WikiProperty.PERMANENT_RELATION_TYPE_ID_P41.getId(), tag.getValue()));\n+            if (relationInfo == null)\n+            {\n+                instructions.put(\n+                        this.getLocalizedInstruction(\n+                                FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_UNKNOWN_RELATION_TYPE),\n+                                tag.getValue(), relation.getOsmIdentifier(), checkInfo.getId()),\n+                        Collections.emptyList());\n+                return true;\n+            }\n+            final Collection<String> additionalInstructions = new TreeSet<>();\n+            for (final RelationMember relationMember : relation.members())\n+            {\n+                // Empty roles should exist in WikiData\n+                final String role = relationMember.getRole();\n+                final WikiData roleInfo = this", "originalCommit": "65dab299c4c81c793bf8ef2cd78e368bd4332a13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1ODIwMTM4MA==", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r658201380", "bodyText": "It is always fun when you miss one.\n8999207", "author": "tsmock", "createdAt": "2021-06-24T18:50:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1ODE4OTY1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTA4NDU5NA==", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r669084594", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    catch (final IOException e)\n          \n          \n            \n                    catch (final IOException exception)", "author": "Bentleysb", "createdAt": "2021-07-13T20:25:14Z", "path": "src/main/java/org/openstreetmap/atlas/checks/utility/KeyFullyCheckedUtils.java", "diffHunk": "@@ -0,0 +1,181 @@\n+package org.openstreetmap.atlas.checks.utility;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.text.MessageFormat;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+\n+import org.apache.commons.lang3.reflect.FieldUtils;\n+import org.openstreetmap.atlas.checks.validation.tag.GenericTagCheck;\n+import org.openstreetmap.atlas.checks.validation.tag.InvalidTagsCheck;\n+import org.openstreetmap.atlas.tags.Taggable;\n+import org.openstreetmap.atlas.tags.annotations.validation.Validators;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.reflect.ClassPath;\n+import com.google.common.reflect.ClassPath.ClassInfo;\n+\n+/**\n+ * Utils to find fully checked keys (only use this for generic tests, such as\n+ * {@link GenericTagCheck}).\n+ *\n+ * @author Taylor Smock\n+ */\n+public final class KeyFullyCheckedUtils\n+{\n+    private static final Logger logger = LoggerFactory.getLogger(KeyFullyCheckedUtils.class);\n+\n+    /**\n+     * Populate ignore tags using reflection and looking for annotations using\n+     * {@link KeyFullyChecked} in the current package.\n+     *\n+     * @return A collection of predicates to use to determine if a tag should be ignored.\n+     */\n+    public static Collection<Predicate<Taggable>> populateIgnoreTags()\n+    {\n+        final List<TaggableFilter> filters = new ArrayList<>();\n+        final List<Predicate<Taggable>> predicateFilters = new ArrayList<>();\n+        final var classLoader = InvalidTagsCheck.class.getClassLoader();\n+        Set<ClassInfo> classInfoList;\n+        try\n+        {\n+            classInfoList = ClassPath.from(classLoader)\n+                    .getTopLevelClassesRecursive(InvalidTagsCheck.class.getPackageName());\n+        }\n+        catch (final IOException e)", "originalCommit": "fe33333d169d44c3bb679decd0c7f055d3ed27dd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTA5MTc0OA==", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r669091748", "bodyText": "I'm guessing this was to test something?", "author": "Bentleysb", "createdAt": "2021-07-13T20:36:26Z", "path": "src/test/java/org/openstreetmap/atlas/checks/validation/intersections/BigNodeBadDataCheckTest.java", "diffHunk": "@@ -73,6 +73,11 @@ private boolean runTest(final Atlas atlas, final Configuration config,\n \n         bigNodes.forEach(bigNode ->\n         {\n+            if (bigNode.nodes().stream().mapToLong(node -> node.getOsmIdentifier())\n+                    .anyMatch(number -> number == 812034701L))\n+            {\n+                logger.info(\"found something\");\n+            }", "originalCommit": "fe33333d169d44c3bb679decd0c7f055d3ed27dd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTgxNDIyNQ==", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r669814225", "bodyText": "Yes. I think I was having issues with a test failing somewhere when I was updating to newer atlas/atlas-generator versions.", "author": "tsmock", "createdAt": "2021-07-14T17:28:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTA5MTc0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTA5NjA3MA==", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r669096070", "bodyText": "The main edge does not encompass all edges with the same ID. It is just the main direction of a way setioned edge.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                ? this.createFlag(((Edge) object).getMainEdge(), instruction)\n          \n          \n            \n                               ? this.createFlag(new OsmWayWalker((Edge) object).collectEdges(), instruction)", "author": "Bentleysb", "createdAt": "2021-07-13T20:42:57Z", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/GenericTagCheck.java", "diffHunk": "@@ -0,0 +1,940 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import java.text.MessageFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import java.util.function.Predicate;\n+import java.util.function.UnaryOperator;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.base.ExternalDataFetcher;\n+import org.openstreetmap.atlas.checks.database.taginfo.TagInfoKeyTagCommon;\n+import org.openstreetmap.atlas.checks.database.taginfo.TagInfoKeys;\n+import org.openstreetmap.atlas.checks.database.taginfo.TagInfoTags;\n+import org.openstreetmap.atlas.checks.database.wikidata.WikiData;\n+import org.openstreetmap.atlas.checks.database.wikidata.WikiDataItem;\n+import org.openstreetmap.atlas.checks.database.wikidata.WikiProperty;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.AtlasToOsmType;\n+import org.openstreetmap.atlas.checks.utility.KeyFullyCheckedUtils;\n+import org.openstreetmap.atlas.checks.utility.SQLiteUtils;\n+import org.openstreetmap.atlas.checks.utility.feature_change.IFeatureChange;\n+import org.openstreetmap.atlas.checks.utility.feature_change.RemoveTagFeatureChange;\n+import org.openstreetmap.atlas.checks.utility.feature_change.ReplaceTagFeatureChange;\n+import org.openstreetmap.atlas.geography.atlas.change.FeatureChange;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Relation;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMember;\n+import org.openstreetmap.atlas.locale.IsoCountry;\n+import org.openstreetmap.atlas.streaming.resource.Resource;\n+import org.openstreetmap.atlas.tags.ISOCountryTag;\n+import org.openstreetmap.atlas.tags.Taggable;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.testing.TestTaggable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Generic tag check using OSM Wiki Data and Tag Info databases.\n+ *\n+ * @author Taylor Smock\n+ */\n+public class GenericTagCheck extends BaseCheck<String>\n+{\n+    private static final long serialVersionUID = 5150282147895785829L;\n+    private static final String DEFAULT_NR_TAGS_INSTRUCTION = \"OSM feature {0,number,#} has invalid tags\";\n+    private static final String DEFAULT_INSTRUCTION = \"Check the following tags for missing, conflicting, or incorrect values: {0}\";\n+    private static final String INSTRUCTION_CONFLICTING_TAGS = \"Check the following tags for missing, conflicting, or incorrect values: {0}\";\n+    private static final String INSTRUCTION_INVALID_TAGS = \"OSM feature {0,number,#} has invalid tags\";\n+    private static final String INSTRUCTION_MISMATCHED_REGEX = \"{0} does not match the regex {1} for the key {2} (see https://wiki.osm.org/Item:{3})\";\n+    private static final String INSTRUCTION_PROHIBITED_USAGE = \"{0}={1} is prohibited on {2}. To determine whether to remove or change this tag please see this tag's Wiki Data page, https://wiki.osm.org/Item:{3} or the associated documentation Wiki Page on the Wiki Data page).\";\n+    private static final String INSTRUCTION_REPLACE = \"{0} should probably be replaced with {1} (see https://wiki.osm.org/Item:{2})\";\n+    private static final String INSTRUCTION_TAGINFO_POPULAR = \"{0} is probably an undocumented {1} ({2} instances). This should be documented on the wiki at https://wiki.osm.org/{3} and in the OpenStreetMap Wiki Data ( https://wiki.osm.org/Data_items ).\";\n+    private static final String INSTRUCTION_TAGINFO_UNPOPULAR = \"{0} is an unpopular key ({1} instances)\";\n+    private static final String INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION = \"{0}={1} should not be used in {2} (see https://wiki.osm.org/Item:{3})\";\n+    private static final String INSTRUCTION_UNDOCUMENTED_POPULAR_TAG = \"{0}={1} is not currently documented. Its global popularity ({2} uses) may merit adding wiki documentation for this value. Please consider adding a new Wiki Data page for {0}={1}.\";\n+    private static final String INSTRUCTION_UNKNOWN_RELATION_ROLE = \"{0}={1} is an unknown relation role for {0} ({2} {3,number,#} on relation {4,number,#}, see https://wiki.osm.org/Item:{5})\";\n+    private static final String INSTRUCTION_UNKNOWN_RELATION_TYPE = \"type={0} is an unknown relation type (relation {1,number,#}, see https://wiki.osm.org/Item:{2})\";\n+    private static final String INSTRUCTION_WELL_DEFINED_TAG_UNKNOWN_VALUE = \"{0} is not a well-known value for {1}\";\n+    private static final String INSTRUCTION_WIKI_DATA_REMOVAL = \"{0}={1} should probably be removed (it is {2}, see https://wiki.osm.org/Item:{3})\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Stream.of(DEFAULT_NR_TAGS_INSTRUCTION,\n+            DEFAULT_INSTRUCTION, INSTRUCTION_INVALID_TAGS, INSTRUCTION_CONFLICTING_TAGS,\n+            INSTRUCTION_MISMATCHED_REGEX, INSTRUCTION_UNDOCUMENTED_POPULAR_TAG,\n+            INSTRUCTION_WELL_DEFINED_TAG_UNKNOWN_VALUE, INSTRUCTION_WIKI_DATA_REMOVAL,\n+            INSTRUCTION_PROHIBITED_USAGE, INSTRUCTION_TAGINFO_UNPOPULAR,\n+            INSTRUCTION_TAGINFO_POPULAR, INSTRUCTION_REPLACE, INSTRUCTION_UNKNOWN_RELATION_ROLE,\n+            INSTRUCTION_UNKNOWN_RELATION_TYPE, INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION)\n+            .collect(Collectors.toCollection(ArrayList::new));\n+    private static final long DEFAULT_MIN_TAG_USAGE = 100;\n+\n+    private static final String DEFAULT_WIKI_TABLE = \"wiki_data\";\n+    private static final String DEFAULT_TAGINFO_TAG_TABLE = \"tags\";\n+    private static final String DEFAULT_TAGINFO_KEY_TABLE = \"keys\";\n+\n+    private static final Logger logger = LoggerFactory.getLogger(GenericTagCheck.class);\n+\n+    private final Long minTagUsage;\n+    // Due to serialization, this *cannot* be final\n+    private transient Collection<Predicate<Taggable>> ignoreTags = KeyFullyCheckedUtils\n+            .populateIgnoreTags();\n+\n+    private static final List<String> DEFAULT_TAGS_TO_REMOVE = Arrays.asList(\"abandoned\",\n+            \"discardable\", \"imported\", \"obsolete\", \"rejected\");\n+    private final List<String> tagsToRemove;\n+    private SQLiteUtils sqliteUtilsTagInfoTagTable;\n+    private SQLiteUtils sqliteUtilsTagInfoKeyTable;\n+    private SQLiteUtils sqliteUtilsWikiData;\n+    private static final String DEFAULT_TAGINFO_DB = \"taginfo-db.db\";\n+    private static final String DEFAULT_WIKIDATA_DB = \"wikidata.db\";\n+    private static final int DEFAULT_TAG_PERCENTAGE_KEY = 10;\n+    private final String tagInfoDB;\n+    private final String wikiDataDB;\n+    private final String wikiTable;\n+    private final String tagInfoTagTable;\n+    private final String tagInfoKeyTable;\n+    private final int popularTagPercentageKey;\n+\n+    /**\n+     * Check if an object is an area (i.e., an actual Area object OR a multipolygon)\n+     *\n+     * @param object\n+     *            The object to check\n+     * @return {@code true} if the object is an area\n+     */\n+    private static boolean isArea(final Taggable object)\n+    {\n+        return object instanceof Area\n+                || (object instanceof Relation && ((Relation) object).isMultiPolygon());\n+    }\n+\n+    /**\n+     * Check if an object may be an area\n+     *\n+     * @param object\n+     *            The object to check\n+     * @return {@code true} if the object <i>may</i> be an area.\n+     */\n+    private static boolean isClosedLine(final Taggable object)\n+    {\n+        return object instanceof LineItem && ((LineItem) object).isClosed();\n+    }\n+\n+    /**\n+     * Convert a tag entry into a string\n+     *\n+     * @param tag\n+     *            The tag to convert\n+     * @return A &ltkey&gt=&ltvalue&gt string\n+     */\n+    private static String tagToString(final Map.Entry<String, String> tag)\n+    {\n+        return Stream.of(tag.getKey(), tag.getValue()).filter(Objects::nonNull)\n+                .filter(string -> !string.isBlank()).collect(Collectors.joining(\"=\"));\n+    }\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     * @param fileFetcher\n+     *            A fetcher to get external data with\n+     */\n+    public GenericTagCheck(final Configuration configuration, final ExternalDataFetcher fileFetcher)\n+    {\n+        super(configuration);\n+        this.minTagUsage = this.configurationValue(configuration, \"tag.usage.min\",\n+                DEFAULT_MIN_TAG_USAGE);\n+\n+        this.tagsToRemove = this.configurationValue(configuration, \"wikidata.tag_removal\",\n+                DEFAULT_TAGS_TO_REMOVE);\n+        this.wikiTable = DEFAULT_WIKI_TABLE;\n+        this.tagInfoTagTable = DEFAULT_TAGINFO_TAG_TABLE;\n+        this.tagInfoKeyTable = DEFAULT_TAGINFO_KEY_TABLE;\n+        this.tagInfoDB = this.configurationValue(configuration, \"db.taginfo\", DEFAULT_TAGINFO_DB);\n+        this.wikiDataDB = this.configurationValue(configuration, \"db.wikidata\",\n+                DEFAULT_WIKIDATA_DB);\n+\n+        // At time of implementation, this.configurationValue(..., ..., Integer) returns\n+        // a Long.\n+        this.popularTagPercentageKey = this\n+                .configurationValue(configuration, \"tag.percentage_of_key_for_popular\",\n+                        ((Integer) DEFAULT_TAG_PERCENTAGE_KEY).longValue())\n+                .intValue();\n+\n+        // No matter what the atlas is, we need the db files. But only if we can get\n+        // them.\n+        if (fileFetcher == null)\n+        {\n+            return;\n+        }\n+        for (final String file : Arrays.asList(this.tagInfoDB, this.wikiDataDB))\n+        {\n+            final Optional<Resource> resource = fileFetcher.apply(file);\n+            if (!resource.isPresent() && logger.isDebugEnabled())\n+            {\n+                logger.debug(MessageFormat.format(\"{0} is not present\", file));\n+            }\n+        }\n+        this.fetchWikiData(fileFetcher);\n+        this.fetchTagInfo(fileFetcher);\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return !object.getOsmTags().isEmpty()\n+                && !this.isFlagged(this.getUniqueOSMIdentifier(object));\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        // Test against each filter and create an instruction if the object passes\n+        final Map<String, Collection<IFeatureChange>> instructions = new TreeMap<>();\n+\n+        if (this.sqliteUtilsTagInfoTagTable != null && this.sqliteUtilsWikiData != null)\n+        {\n+            if (this.ignoreTags == null || this.ignoreTags.isEmpty())\n+            {\n+                this.ignoreTags = KeyFullyCheckedUtils.populateIgnoreTags();\n+            }\n+            this.flagTags(object, instructions);\n+        }\n+\n+        if (!instructions.isEmpty())\n+        {\n+            // Mark objects flagged by their class and id to allow for the same id in\n+            // different object types\n+            this.markAsFlagged(this.getUniqueOSMIdentifier(object));\n+\n+            // Create a flag with generic instructions\n+            final String instruction = this.getLocalizedInstruction(\n+                    FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_INVALID_TAGS),\n+                    object.getOsmIdentifier());\n+            // If the object is an edge add the edges with the same OSM id\n+            final CheckFlag flag = (object instanceof Edge)\n+                    ? this.createFlag(((Edge) object).getMainEdge(), instruction)", "originalCommit": "fe33333d169d44c3bb679decd0c7f055d3ed27dd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTc4NjIwNQ==", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r669786205", "bodyText": "nit: please avoid single letter variable", "author": "sayas01", "createdAt": "2021-07-14T16:47:59Z", "path": "src/main/java/org/openstreetmap/atlas/checks/database/wikidata/WikiDataItem.java", "diffHunk": "@@ -0,0 +1,138 @@\n+// License: GPL. For details, see LICENSE file.\n+package org.openstreetmap.atlas.checks.database.wikidata;\n+\n+import java.text.MessageFormat;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * WikiDataItem special entries\n+ *\n+ * @author Taylor Smock\n+ */\n+public enum WikiDataItem implements WikiItemInterface\n+{\n+    // OSM Concepts\n+    ELEMENT_Q9,\n+    KEY_Q7,\n+    TAG_Q2,\n+    /** Status of the key/tag */\n+    STATUS_Q11,\n+    /** Allowed on nodes/ways/relations/areas */\n+    STATUS_Q8010,\n+    // Statuses (STATUS_Q11)\n+    DE_FACTO_Q13(STATUS_Q11),\n+    IN_USE_Q14(STATUS_Q11),\n+    APPROVED_Q15(STATUS_Q11),\n+    REJECTED_Q16(STATUS_Q11),\n+    VOTING_Q17(STATUS_Q11),\n+    DRAFT_Q18(STATUS_Q11),\n+    ABANDONED_Q19(STATUS_Q11),\n+    PROPOSED_Q20(STATUS_Q11),\n+    OBSOLETE_Q5060(STATUS_Q11),\n+    DEPRECATED_Q5061(STATUS_Q11),\n+    DISCARDABLE_Q7550(STATUS_Q11),\n+    IMPORTED_Q21146(STATUS_Q11),\n+    // Statuses (STATUS_Q8010)\n+    IS_ALLOWED_Q8000(STATUS_Q8010),\n+    IS_PROHIBITED_Q8001(STATUS_Q8010),\n+    // Special\n+    WELL_KNOWN_VALUES_Q8,\n+    GROUP_Q12,\n+    OSM_CONCEPT_Q10,\n+    SANDBOX_Q2761;\n+\n+    @Nullable\n+    private final WikiDataItem parent;\n+    @Nonnull\n+    private final String pid;\n+    @Nonnull\n+    private final String rName;\n+\n+    /**\n+     * Get a well-known wiki data item from a value\n+     *\n+     * @param value\n+     *            The value to look for\n+     * @return A WikiDataItem or {@code null}\n+     */\n+    public static WikiDataItem fromValue(final String value)\n+    {\n+        WikiDataItem rItem = Stream.of(WikiDataItem.values())\n+                .filter(p -> p.getId().equalsIgnoreCase(value)).findFirst().orElse(null);", "originalCommit": "9f9616fed683129eba242736296db4af5c8edbcd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "66eb8e0d9487e96220bb2c32434857e66de81d09", "url": "https://github.com/osmlab/atlas-checks/commit/66eb8e0d9487e96220bb2c32434857e66de81d09", "message": "InvalidMultiPolygonRelationCheck: Extract AtlasToOsmType code\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2021-07-14T18:27:49Z", "type": "commit"}, {"oid": "c8228d2c5f6ab535b3c97ac290f87d7a7d67a2a3", "url": "https://github.com/osmlab/atlas-checks/commit/c8228d2c5f6ab535b3c97ac290f87d7a7d67a2a3", "message": "GenericTagCheck: Add generic test for tag checking (using OSM Wiki Data and TagInfo)\n\nAbbreviatedNameCheck: Improve validCheckForObject\n* Only objects with names are valid checks.\n\nFeatureChange: Add interfaces for remove/replace tag changes\n\nGenericTagCheck: Check for unpopular tags with taginfo\n* Implement Autocloseable and check for that in RunnableCheck (if\n  implemented, close)\n* Add SQLiteUtils in an effort to allow the DB connection to be\n  serialized (and significantly reduce time from reopening db)\n* Check for unwanted tags on objects using OSM Wiki Data\n* Use TagInfo information to expound upon issues detected by OSM Wiki\n  Data.\n* OSM Wiki Data is used for regex checking, when the Wiki Data has a\n  regex.\n* Account for P17 (redirect to) when a bad tag is encountered.\n\nSQLite:\n* Dependencies: Add SQLite\n* Cache gets for DB\n  * Assumption: DB doesn't change during the run\n\n    This brought the runtime on a MacBook 2017 (i7 w/ 16GB ram) from 14\n    hours to 2 hours (and a bit). The runtime for the dev/master branch was\n    also about 2 hours (and a bit).\n\n    The countries run were AIA, CYM, DMA, NZL, and SMR. There was no real\n    noticeable difference with BLZ.\n* Store a copy of the retrieved data without null values in SQLiteUtils\n* Store file fetcher for use on computation nodes\n\nTagInfo: Add download script\nWikiData: Add download script\n* Update older entries and write changes to a file\n\n  This means that changes can be inspected and verified (future task:\n  insert into an HTML page with links so people can more easily tell if\n  the change is relevant or not).\n* When duplicate unique keys appear, print out what was being inserted\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2021-07-14T18:27:49Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTc4OTE5OA==", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r669789198", "bodyText": "Looks good, feel like this could be in Atlas project.", "author": "sayas01", "createdAt": "2021-07-14T16:52:09Z", "path": "src/main/java/org/openstreetmap/atlas/checks/utility/AtlasToOsmType.java", "diffHunk": "@@ -0,0 +1,47 @@\n+package org.openstreetmap.atlas.checks.utility;\n+\n+import java.util.EnumMap;\n+\n+import javax.annotation.Nullable;\n+\n+import org.openstreetmap.atlas.checks.validation.relations.InvalidMultiPolygonRelationCheck;\n+import org.openstreetmap.atlas.geography.atlas.items.ItemType;\n+\n+/**\n+ * Convert Atlas ItemTypes into OSM types\n+ *\n+ * @author Taylor Smock, extracted from {@link InvalidMultiPolygonRelationCheck}.\n+ */\n+public final class AtlasToOsmType", "originalCommit": "9f9616fed683129eba242736296db4af5c8edbcd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTk4NDg2MQ==", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r669984861", "bodyText": "It probably could be. I think I didn't do that since I've got a few projects with various moving parts, and I didn't want to deal with yet another one at the time, and then forgot about it.\nI've had too many PR's that depend upon other PR's that depend upon yet another PR...", "author": "tsmock", "createdAt": "2021-07-14T22:02:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTc4OTE5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTk5MzM1MQ==", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r669993351", "bodyText": "This can defiantly be something that is done later.", "author": "Bentleysb", "createdAt": "2021-07-14T22:21:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTc4OTE5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTk5Mzk3NQ==", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r669993975", "bodyText": "Yp!!", "author": "sayas01", "createdAt": "2021-07-14T22:23:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTc4OTE5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTk3NjA5MA==", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r669976090", "bodyText": "unused param", "author": "sayas01", "createdAt": "2021-07-14T21:44:44Z", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/GenericTagCheck.java", "diffHunk": "@@ -0,0 +1,941 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import java.text.MessageFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import java.util.function.Predicate;\n+import java.util.function.UnaryOperator;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.base.ExternalDataFetcher;\n+import org.openstreetmap.atlas.checks.database.taginfo.TagInfoKeyTagCommon;\n+import org.openstreetmap.atlas.checks.database.taginfo.TagInfoKeys;\n+import org.openstreetmap.atlas.checks.database.taginfo.TagInfoTags;\n+import org.openstreetmap.atlas.checks.database.wikidata.WikiData;\n+import org.openstreetmap.atlas.checks.database.wikidata.WikiDataItem;\n+import org.openstreetmap.atlas.checks.database.wikidata.WikiProperty;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.AtlasToOsmType;\n+import org.openstreetmap.atlas.checks.utility.KeyFullyCheckedUtils;\n+import org.openstreetmap.atlas.checks.utility.SQLiteUtils;\n+import org.openstreetmap.atlas.checks.utility.feature_change.IFeatureChange;\n+import org.openstreetmap.atlas.checks.utility.feature_change.RemoveTagFeatureChange;\n+import org.openstreetmap.atlas.checks.utility.feature_change.ReplaceTagFeatureChange;\n+import org.openstreetmap.atlas.geography.atlas.change.FeatureChange;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Relation;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMember;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.locale.IsoCountry;\n+import org.openstreetmap.atlas.streaming.resource.Resource;\n+import org.openstreetmap.atlas.tags.ISOCountryTag;\n+import org.openstreetmap.atlas.tags.Taggable;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.testing.TestTaggable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Generic tag check using OSM Wiki Data and Tag Info databases.\n+ *\n+ * @author Taylor Smock\n+ */\n+public class GenericTagCheck extends BaseCheck<String>\n+{\n+    private static final long serialVersionUID = 5150282147895785829L;\n+    private static final String DEFAULT_NR_TAGS_INSTRUCTION = \"OSM feature {0,number,#} has invalid tags\";\n+    private static final String DEFAULT_INSTRUCTION = \"Check the following tags for missing, conflicting, or incorrect values: {0}\";\n+    private static final String INSTRUCTION_CONFLICTING_TAGS = \"Check the following tags for missing, conflicting, or incorrect values: {0}\";\n+    private static final String INSTRUCTION_INVALID_TAGS = \"OSM feature {0,number,#} has invalid tags\";\n+    private static final String INSTRUCTION_MISMATCHED_REGEX = \"{0} does not match the regex {1} for the key {2} (see https://wiki.osm.org/Item:{3})\";\n+    private static final String INSTRUCTION_PROHIBITED_USAGE = \"{0}={1} is prohibited on {2}. To determine whether to remove or change this tag please see this tag's Wiki Data page, https://wiki.osm.org/Item:{3} or the associated documentation Wiki Page on the Wiki Data page).\";\n+    private static final String INSTRUCTION_REPLACE = \"{0} should probably be replaced with {1} (see https://wiki.osm.org/Item:{2})\";\n+    private static final String INSTRUCTION_TAGINFO_POPULAR = \"{0} is probably an undocumented {1} ({2} instances). This should be documented on the wiki at https://wiki.osm.org/{3} and in the OpenStreetMap Wiki Data ( https://wiki.osm.org/Data_items ).\";\n+    private static final String INSTRUCTION_TAGINFO_UNPOPULAR = \"{0} is an unpopular key ({1} instances)\";\n+    private static final String INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION = \"{0}={1} should not be used in {2} (see https://wiki.osm.org/Item:{3})\";\n+    private static final String INSTRUCTION_UNDOCUMENTED_POPULAR_TAG = \"{0}={1} is not currently documented. Its global popularity ({2} uses) may merit adding wiki documentation for this value. Please consider adding a new Wiki Data page for {0}={1}.\";\n+    private static final String INSTRUCTION_UNKNOWN_RELATION_ROLE = \"{0}={1} is an unknown relation role for {0} ({2} {3,number,#} on relation {4,number,#}, see https://wiki.osm.org/Item:{5})\";\n+    private static final String INSTRUCTION_UNKNOWN_RELATION_TYPE = \"type={0} is an unknown relation type (relation {1,number,#}, see https://wiki.osm.org/Item:{2})\";\n+    private static final String INSTRUCTION_WELL_DEFINED_TAG_UNKNOWN_VALUE = \"{0} is not a well-known value for {1}\";\n+    private static final String INSTRUCTION_WIKI_DATA_REMOVAL = \"{0}={1} should probably be removed (it is {2}, see https://wiki.osm.org/Item:{3})\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Stream.of(DEFAULT_NR_TAGS_INSTRUCTION,\n+            DEFAULT_INSTRUCTION, INSTRUCTION_INVALID_TAGS, INSTRUCTION_CONFLICTING_TAGS,\n+            INSTRUCTION_MISMATCHED_REGEX, INSTRUCTION_UNDOCUMENTED_POPULAR_TAG,\n+            INSTRUCTION_WELL_DEFINED_TAG_UNKNOWN_VALUE, INSTRUCTION_WIKI_DATA_REMOVAL,\n+            INSTRUCTION_PROHIBITED_USAGE, INSTRUCTION_TAGINFO_UNPOPULAR,\n+            INSTRUCTION_TAGINFO_POPULAR, INSTRUCTION_REPLACE, INSTRUCTION_UNKNOWN_RELATION_ROLE,\n+            INSTRUCTION_UNKNOWN_RELATION_TYPE, INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION)\n+            .collect(Collectors.toCollection(ArrayList::new));\n+    private static final long DEFAULT_MIN_TAG_USAGE = 100;\n+\n+    private static final String DEFAULT_WIKI_TABLE = \"wiki_data\";\n+    private static final String DEFAULT_TAGINFO_TAG_TABLE = \"tags\";\n+    private static final String DEFAULT_TAGINFO_KEY_TABLE = \"keys\";\n+\n+    private static final Logger logger = LoggerFactory.getLogger(GenericTagCheck.class);\n+\n+    private final Long minTagUsage;\n+    // Due to serialization, this *cannot* be final\n+    private transient Collection<Predicate<Taggable>> ignoreTags = KeyFullyCheckedUtils\n+            .populateIgnoreTags();\n+\n+    private static final List<String> DEFAULT_TAGS_TO_REMOVE = Arrays.asList(\"abandoned\",\n+            \"discardable\", \"imported\", \"obsolete\", \"rejected\");\n+    private final List<String> tagsToRemove;\n+    private SQLiteUtils sqliteUtilsTagInfoTagTable;\n+    private SQLiteUtils sqliteUtilsTagInfoKeyTable;\n+    private SQLiteUtils sqliteUtilsWikiData;\n+    private static final String DEFAULT_TAGINFO_DB = \"taginfo-db.db\";\n+    private static final String DEFAULT_WIKIDATA_DB = \"wikidata.db\";\n+    private static final int DEFAULT_TAG_PERCENTAGE_KEY = 10;\n+    private final String tagInfoDB;\n+    private final String wikiDataDB;\n+    private final String wikiTable;\n+    private final String tagInfoTagTable;\n+    private final String tagInfoKeyTable;\n+    private final int popularTagPercentageKey;\n+\n+    /**\n+     * Check if an object is an area (i.e., an actual Area object OR a multipolygon)\n+     *\n+     * @param object\n+     *            The object to check\n+     * @return {@code true} if the object is an area\n+     */\n+    private static boolean isArea(final Taggable object)\n+    {\n+        return object instanceof Area\n+                || (object instanceof Relation && ((Relation) object).isMultiPolygon());\n+    }\n+\n+    /**\n+     * Check if an object may be an area\n+     *\n+     * @param object\n+     *            The object to check\n+     * @return {@code true} if the object <i>may</i> be an area.\n+     */\n+    private static boolean isClosedLine(final Taggable object)\n+    {\n+        return object instanceof LineItem && ((LineItem) object).isClosed();\n+    }\n+\n+    /**\n+     * Convert a tag entry into a string\n+     *\n+     * @param tag\n+     *            The tag to convert\n+     * @return A &ltkey&gt=&ltvalue&gt string\n+     */\n+    private static String tagToString(final Map.Entry<String, String> tag)\n+    {\n+        return Stream.of(tag.getKey(), tag.getValue()).filter(Objects::nonNull)\n+                .filter(string -> !string.isBlank()).collect(Collectors.joining(\"=\"));\n+    }\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     * @param fileFetcher\n+     *            A fetcher to get external data with\n+     */\n+    public GenericTagCheck(final Configuration configuration, final ExternalDataFetcher fileFetcher)\n+    {\n+        super(configuration);\n+        this.minTagUsage = this.configurationValue(configuration, \"tag.usage.min\",\n+                DEFAULT_MIN_TAG_USAGE);\n+\n+        this.tagsToRemove = this.configurationValue(configuration, \"wikidata.tag_removal\",\n+                DEFAULT_TAGS_TO_REMOVE);\n+        this.wikiTable = DEFAULT_WIKI_TABLE;\n+        this.tagInfoTagTable = DEFAULT_TAGINFO_TAG_TABLE;\n+        this.tagInfoKeyTable = DEFAULT_TAGINFO_KEY_TABLE;\n+        this.tagInfoDB = this.configurationValue(configuration, \"db.taginfo\", DEFAULT_TAGINFO_DB);\n+        this.wikiDataDB = this.configurationValue(configuration, \"db.wikidata\",\n+                DEFAULT_WIKIDATA_DB);\n+\n+        // At time of implementation, this.configurationValue(..., ..., Integer) returns\n+        // a Long.\n+        this.popularTagPercentageKey = this\n+                .configurationValue(configuration, \"tag.percentage_of_key_for_popular\",\n+                        ((Integer) DEFAULT_TAG_PERCENTAGE_KEY).longValue())\n+                .intValue();\n+\n+        // No matter what the atlas is, we need the db files. But only if we can get\n+        // them.\n+        if (fileFetcher == null)\n+        {\n+            return;\n+        }\n+        for (final String file : Arrays.asList(this.tagInfoDB, this.wikiDataDB))\n+        {\n+            final Optional<Resource> resource = fileFetcher.apply(file);\n+            if (!resource.isPresent() && logger.isDebugEnabled())\n+            {\n+                logger.debug(MessageFormat.format(\"{0} is not present\", file));\n+            }\n+        }\n+        this.fetchWikiData(fileFetcher);\n+        this.fetchTagInfo(fileFetcher);\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return !object.getOsmTags().isEmpty()\n+                && !this.isFlagged(this.getUniqueOSMIdentifier(object));\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        // Test against each filter and create an instruction if the object passes\n+        final Map<String, Collection<IFeatureChange>> instructions = new TreeMap<>();\n+\n+        if (this.sqliteUtilsTagInfoTagTable != null && this.sqliteUtilsWikiData != null)\n+        {\n+            if (this.ignoreTags == null || this.ignoreTags.isEmpty())\n+            {\n+                this.ignoreTags = KeyFullyCheckedUtils.populateIgnoreTags();\n+            }\n+            this.flagTags(object, instructions);\n+        }\n+\n+        if (!instructions.isEmpty())\n+        {\n+            // Mark objects flagged by their class and id to allow for the same id in\n+            // different object types\n+            this.markAsFlagged(this.getUniqueOSMIdentifier(object));\n+\n+            // Create a flag with generic instructions\n+            final String instruction = this.getLocalizedInstruction(\n+                    FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_INVALID_TAGS),\n+                    object.getOsmIdentifier());\n+            // If the object is an edge add the edges with the same OSM id\n+            final CheckFlag flag = (object instanceof Edge)\n+                    ? this.createFlag(new OsmWayWalker((Edge) object).collectEdges(), instruction)\n+                    : this.createFlag(object, instruction);\n+\n+            // Add the specific instructions\n+            instructions.keySet().forEach(flag::addInstruction);\n+            /*\n+             * Only add autofixes when instructions are the same size as the changes. This avoids\n+             * situations where a change is available and is valid, but there is an additional issue\n+             * that is not able to be automatically fixed. If MapRoulette ever supports a method to\n+             * indicate that a change partially fixes the flag, this can be changed back to {@code\n+             * changes.isEmpty()}.\n+             */\n+            if (instructions.entrySet().stream().noneMatch(entry -> entry.getValue().isEmpty()))\n+            {\n+                flag.addFixSuggestions(Collections.singleton(\n+                        IFeatureChange.createFeatureChange(FeatureChange::add, (AtlasEntity) object,\n+                                instructions.values().stream().flatMap(Collection::stream)\n+                                        .filter(Objects::nonNull).distinct()\n+                                        .collect(Collectors.toList()))));\n+            }\n+            return Optional.of(flag);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Check for country specific rules\n+     *\n+     * @param instructions\n+     *            The instructions for the object\n+     * @param object\n+     *            The taggable object which should have country tags\n+     * @param tag\n+     *            The actual tag we are checking\n+     * @param wikiMap\n+     *            The map of wiki information\n+     * @return {@code true} if the check failed (i.e., an instruction has been generated)\n+     */\n+    private boolean checkCountrySpecific(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Taggable object, final Map.Entry<String, String> tag, final WikiData wikiMap)\n+    {\n+        // P48 shouldn't be used on actual key/tag items\n+        if (wikiMap != null && (!wikiMap.getMustOnlyBeUsedInRegionP29().isEmpty()\n+                || !wikiMap.getNotToBeUsedInRegionP30().isEmpty()))\n+        {\n+            /* Create a function that converts country/region wiki data into ISO3 codes */\n+            final UnaryOperator<Collection<String>> toWikiData = countries -> countries.stream()\n+                    .map(this::getWikiDataId)\n+                    .filter(Objects::nonNull/* Ignore values that aren't in the db */)\n+                    .map(WikiData::getGeographicCodeP49)\n+                    .filter(Objects::nonNull/* Q21351 has a null value here */)\n+                    .flatMap(Collection::stream)\n+                    .map(IsoCountry::iso3ForIso2/* Convert ISO2 to ISO3 codes */)\n+                    .filter(Optional::isPresent).map(Optional::get).collect(Collectors.toList());\n+            // Object ISOCountryTags appear to be ISO3 codes.\n+            final List<String> countries = Iterables.asList(ISOCountryTag.all(object));\n+            String instruction = null;\n+            // The region keys are one or the other, but should never be both.\n+            if (!wikiMap.getMustOnlyBeUsedInRegionP29().isEmpty())\n+            {\n+                final Collection<String> onlyUsedInRegion = toWikiData\n+                        .apply(wikiMap.getMustOnlyBeUsedInRegionP29());\n+                // Some primitives may cross country lines, so if any country is a valid region,\n+                // continue on.\n+                if (countries.stream().noneMatch(onlyUsedInRegion::contains))\n+                {\n+                    instruction = INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION;\n+                }\n+            }\n+            // check on P30 becomes redundant due to earlier check.\n+            else\n+            {\n+                final Collection<String> notUsedInRegion = toWikiData\n+                        .apply(wikiMap.getNotToBeUsedInRegionP30());\n+                // If countries is empty, then don't bother checking. Otherwise, allMatch\n+                // returns true.\n+                if (!countries.isEmpty() && countries.stream().allMatch(notUsedInRegion::contains))\n+                {\n+                    instruction = INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION;\n+                }\n+            }\n+            // If the tag shouldn't be used in the region/area, it should be removed\n+            if (instruction != null)\n+            {\n+                instructions.put(\n+                        this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS.indexOf(instruction),\n+                                tag.getKey(), tag.getValue(), String.join(\", \", countries),\n+                                wikiMap.getId()),\n+                        Collections.singleton(new RemoveTagFeatureChange(tag)));\n+            }\n+\n+            return instruction != null;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check for fallback issues (mostly unpopular/popular tags not caught by wiki checks)\n+     *\n+     * @param instructions\n+     *            The instructions to add to\n+     * @param tag\n+     *            The tag to check\n+     * @param keyInfo\n+     *            The information for the key\n+     * @param popular\n+     *            {@code true} if the key is \"popular\"\n+     * @param tagOccurrence\n+     *            The information from TagInfo for the tag\n+     * @param keyOccurrence\n+     *            The information from TagInfo for the key\n+     */\n+    private void checkFallback(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Map.Entry<String, String> tag, final WikiData keyInfo, final boolean popular,\n+            final TagInfoTags tagOccurrence, final TagInfoKeys keyOccurrence)\n+    {\n+        if (keyInfo == null)\n+        {\n+            final String count;\n+            final Map.Entry<String, String> messageTag;\n+            if (tagOccurrence.getCountAll() != null)\n+            {\n+                count = tagOccurrence.getCountAll().toString();\n+                messageTag = tag;\n+            }\n+            else if (keyOccurrence.getCountAll() != null)\n+            {\n+                count = keyOccurrence.getCountAll().toString();\n+                messageTag = Map.entry(tag.getKey(), \"\");\n+            }\n+            else\n+            {\n+                count = \"<\" + this.minTagUsage.toString();\n+                messageTag = tag;\n+            }\n+            // Check for unpopular/bad tags not already caught by wiki check\n+            if (!popular)\n+            {\n+                instructions.put(this.getLocalizedInstruction(\n+                        FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_TAGINFO_UNPOPULAR),\n+                        tagToString(tag), count), Collections.emptyList());\n+            }\n+            else\n+            {\n+                final String type = messageTag.getValue().isBlank() ? \"Key\" : \"Tag\";\n+                instructions.put(this.getLocalizedInstruction(\n+                        FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_TAGINFO_POPULAR),\n+                        tagToString(messageTag), type.toLowerCase(Locale.ENGLISH), count,\n+                        new StringBuilder(type).append(':').append(tagToString(messageTag))\n+                                .toString()),\n+                        Collections.emptyList());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Check if a wiki data item for a tag redirects to another tag, and if so, create an\n+     * instruction and change for that.\n+     *\n+     * @param instructions\n+     *            The instructions collection to add to\n+     * @param changes", "originalCommit": "ac3dad22c01430cc121a5c7ef7a7018f1d2cd6ed", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTk3Njc5NQ==", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r669976795", "bodyText": "@param object", "author": "sayas01", "createdAt": "2021-07-14T21:46:11Z", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/GenericTagCheck.java", "diffHunk": "@@ -0,0 +1,941 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import java.text.MessageFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import java.util.function.Predicate;\n+import java.util.function.UnaryOperator;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.base.ExternalDataFetcher;\n+import org.openstreetmap.atlas.checks.database.taginfo.TagInfoKeyTagCommon;\n+import org.openstreetmap.atlas.checks.database.taginfo.TagInfoKeys;\n+import org.openstreetmap.atlas.checks.database.taginfo.TagInfoTags;\n+import org.openstreetmap.atlas.checks.database.wikidata.WikiData;\n+import org.openstreetmap.atlas.checks.database.wikidata.WikiDataItem;\n+import org.openstreetmap.atlas.checks.database.wikidata.WikiProperty;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.AtlasToOsmType;\n+import org.openstreetmap.atlas.checks.utility.KeyFullyCheckedUtils;\n+import org.openstreetmap.atlas.checks.utility.SQLiteUtils;\n+import org.openstreetmap.atlas.checks.utility.feature_change.IFeatureChange;\n+import org.openstreetmap.atlas.checks.utility.feature_change.RemoveTagFeatureChange;\n+import org.openstreetmap.atlas.checks.utility.feature_change.ReplaceTagFeatureChange;\n+import org.openstreetmap.atlas.geography.atlas.change.FeatureChange;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Relation;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMember;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.locale.IsoCountry;\n+import org.openstreetmap.atlas.streaming.resource.Resource;\n+import org.openstreetmap.atlas.tags.ISOCountryTag;\n+import org.openstreetmap.atlas.tags.Taggable;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.testing.TestTaggable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Generic tag check using OSM Wiki Data and Tag Info databases.\n+ *\n+ * @author Taylor Smock\n+ */\n+public class GenericTagCheck extends BaseCheck<String>\n+{\n+    private static final long serialVersionUID = 5150282147895785829L;\n+    private static final String DEFAULT_NR_TAGS_INSTRUCTION = \"OSM feature {0,number,#} has invalid tags\";\n+    private static final String DEFAULT_INSTRUCTION = \"Check the following tags for missing, conflicting, or incorrect values: {0}\";\n+    private static final String INSTRUCTION_CONFLICTING_TAGS = \"Check the following tags for missing, conflicting, or incorrect values: {0}\";\n+    private static final String INSTRUCTION_INVALID_TAGS = \"OSM feature {0,number,#} has invalid tags\";\n+    private static final String INSTRUCTION_MISMATCHED_REGEX = \"{0} does not match the regex {1} for the key {2} (see https://wiki.osm.org/Item:{3})\";\n+    private static final String INSTRUCTION_PROHIBITED_USAGE = \"{0}={1} is prohibited on {2}. To determine whether to remove or change this tag please see this tag's Wiki Data page, https://wiki.osm.org/Item:{3} or the associated documentation Wiki Page on the Wiki Data page).\";\n+    private static final String INSTRUCTION_REPLACE = \"{0} should probably be replaced with {1} (see https://wiki.osm.org/Item:{2})\";\n+    private static final String INSTRUCTION_TAGINFO_POPULAR = \"{0} is probably an undocumented {1} ({2} instances). This should be documented on the wiki at https://wiki.osm.org/{3} and in the OpenStreetMap Wiki Data ( https://wiki.osm.org/Data_items ).\";\n+    private static final String INSTRUCTION_TAGINFO_UNPOPULAR = \"{0} is an unpopular key ({1} instances)\";\n+    private static final String INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION = \"{0}={1} should not be used in {2} (see https://wiki.osm.org/Item:{3})\";\n+    private static final String INSTRUCTION_UNDOCUMENTED_POPULAR_TAG = \"{0}={1} is not currently documented. Its global popularity ({2} uses) may merit adding wiki documentation for this value. Please consider adding a new Wiki Data page for {0}={1}.\";\n+    private static final String INSTRUCTION_UNKNOWN_RELATION_ROLE = \"{0}={1} is an unknown relation role for {0} ({2} {3,number,#} on relation {4,number,#}, see https://wiki.osm.org/Item:{5})\";\n+    private static final String INSTRUCTION_UNKNOWN_RELATION_TYPE = \"type={0} is an unknown relation type (relation {1,number,#}, see https://wiki.osm.org/Item:{2})\";\n+    private static final String INSTRUCTION_WELL_DEFINED_TAG_UNKNOWN_VALUE = \"{0} is not a well-known value for {1}\";\n+    private static final String INSTRUCTION_WIKI_DATA_REMOVAL = \"{0}={1} should probably be removed (it is {2}, see https://wiki.osm.org/Item:{3})\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Stream.of(DEFAULT_NR_TAGS_INSTRUCTION,\n+            DEFAULT_INSTRUCTION, INSTRUCTION_INVALID_TAGS, INSTRUCTION_CONFLICTING_TAGS,\n+            INSTRUCTION_MISMATCHED_REGEX, INSTRUCTION_UNDOCUMENTED_POPULAR_TAG,\n+            INSTRUCTION_WELL_DEFINED_TAG_UNKNOWN_VALUE, INSTRUCTION_WIKI_DATA_REMOVAL,\n+            INSTRUCTION_PROHIBITED_USAGE, INSTRUCTION_TAGINFO_UNPOPULAR,\n+            INSTRUCTION_TAGINFO_POPULAR, INSTRUCTION_REPLACE, INSTRUCTION_UNKNOWN_RELATION_ROLE,\n+            INSTRUCTION_UNKNOWN_RELATION_TYPE, INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION)\n+            .collect(Collectors.toCollection(ArrayList::new));\n+    private static final long DEFAULT_MIN_TAG_USAGE = 100;\n+\n+    private static final String DEFAULT_WIKI_TABLE = \"wiki_data\";\n+    private static final String DEFAULT_TAGINFO_TAG_TABLE = \"tags\";\n+    private static final String DEFAULT_TAGINFO_KEY_TABLE = \"keys\";\n+\n+    private static final Logger logger = LoggerFactory.getLogger(GenericTagCheck.class);\n+\n+    private final Long minTagUsage;\n+    // Due to serialization, this *cannot* be final\n+    private transient Collection<Predicate<Taggable>> ignoreTags = KeyFullyCheckedUtils\n+            .populateIgnoreTags();\n+\n+    private static final List<String> DEFAULT_TAGS_TO_REMOVE = Arrays.asList(\"abandoned\",\n+            \"discardable\", \"imported\", \"obsolete\", \"rejected\");\n+    private final List<String> tagsToRemove;\n+    private SQLiteUtils sqliteUtilsTagInfoTagTable;\n+    private SQLiteUtils sqliteUtilsTagInfoKeyTable;\n+    private SQLiteUtils sqliteUtilsWikiData;\n+    private static final String DEFAULT_TAGINFO_DB = \"taginfo-db.db\";\n+    private static final String DEFAULT_WIKIDATA_DB = \"wikidata.db\";\n+    private static final int DEFAULT_TAG_PERCENTAGE_KEY = 10;\n+    private final String tagInfoDB;\n+    private final String wikiDataDB;\n+    private final String wikiTable;\n+    private final String tagInfoTagTable;\n+    private final String tagInfoKeyTable;\n+    private final int popularTagPercentageKey;\n+\n+    /**\n+     * Check if an object is an area (i.e., an actual Area object OR a multipolygon)\n+     *\n+     * @param object\n+     *            The object to check\n+     * @return {@code true} if the object is an area\n+     */\n+    private static boolean isArea(final Taggable object)\n+    {\n+        return object instanceof Area\n+                || (object instanceof Relation && ((Relation) object).isMultiPolygon());\n+    }\n+\n+    /**\n+     * Check if an object may be an area\n+     *\n+     * @param object\n+     *            The object to check\n+     * @return {@code true} if the object <i>may</i> be an area.\n+     */\n+    private static boolean isClosedLine(final Taggable object)\n+    {\n+        return object instanceof LineItem && ((LineItem) object).isClosed();\n+    }\n+\n+    /**\n+     * Convert a tag entry into a string\n+     *\n+     * @param tag\n+     *            The tag to convert\n+     * @return A &ltkey&gt=&ltvalue&gt string\n+     */\n+    private static String tagToString(final Map.Entry<String, String> tag)\n+    {\n+        return Stream.of(tag.getKey(), tag.getValue()).filter(Objects::nonNull)\n+                .filter(string -> !string.isBlank()).collect(Collectors.joining(\"=\"));\n+    }\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     * @param fileFetcher\n+     *            A fetcher to get external data with\n+     */\n+    public GenericTagCheck(final Configuration configuration, final ExternalDataFetcher fileFetcher)\n+    {\n+        super(configuration);\n+        this.minTagUsage = this.configurationValue(configuration, \"tag.usage.min\",\n+                DEFAULT_MIN_TAG_USAGE);\n+\n+        this.tagsToRemove = this.configurationValue(configuration, \"wikidata.tag_removal\",\n+                DEFAULT_TAGS_TO_REMOVE);\n+        this.wikiTable = DEFAULT_WIKI_TABLE;\n+        this.tagInfoTagTable = DEFAULT_TAGINFO_TAG_TABLE;\n+        this.tagInfoKeyTable = DEFAULT_TAGINFO_KEY_TABLE;\n+        this.tagInfoDB = this.configurationValue(configuration, \"db.taginfo\", DEFAULT_TAGINFO_DB);\n+        this.wikiDataDB = this.configurationValue(configuration, \"db.wikidata\",\n+                DEFAULT_WIKIDATA_DB);\n+\n+        // At time of implementation, this.configurationValue(..., ..., Integer) returns\n+        // a Long.\n+        this.popularTagPercentageKey = this\n+                .configurationValue(configuration, \"tag.percentage_of_key_for_popular\",\n+                        ((Integer) DEFAULT_TAG_PERCENTAGE_KEY).longValue())\n+                .intValue();\n+\n+        // No matter what the atlas is, we need the db files. But only if we can get\n+        // them.\n+        if (fileFetcher == null)\n+        {\n+            return;\n+        }\n+        for (final String file : Arrays.asList(this.tagInfoDB, this.wikiDataDB))\n+        {\n+            final Optional<Resource> resource = fileFetcher.apply(file);\n+            if (!resource.isPresent() && logger.isDebugEnabled())\n+            {\n+                logger.debug(MessageFormat.format(\"{0} is not present\", file));\n+            }\n+        }\n+        this.fetchWikiData(fileFetcher);\n+        this.fetchTagInfo(fileFetcher);\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return !object.getOsmTags().isEmpty()\n+                && !this.isFlagged(this.getUniqueOSMIdentifier(object));\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        // Test against each filter and create an instruction if the object passes\n+        final Map<String, Collection<IFeatureChange>> instructions = new TreeMap<>();\n+\n+        if (this.sqliteUtilsTagInfoTagTable != null && this.sqliteUtilsWikiData != null)\n+        {\n+            if (this.ignoreTags == null || this.ignoreTags.isEmpty())\n+            {\n+                this.ignoreTags = KeyFullyCheckedUtils.populateIgnoreTags();\n+            }\n+            this.flagTags(object, instructions);\n+        }\n+\n+        if (!instructions.isEmpty())\n+        {\n+            // Mark objects flagged by their class and id to allow for the same id in\n+            // different object types\n+            this.markAsFlagged(this.getUniqueOSMIdentifier(object));\n+\n+            // Create a flag with generic instructions\n+            final String instruction = this.getLocalizedInstruction(\n+                    FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_INVALID_TAGS),\n+                    object.getOsmIdentifier());\n+            // If the object is an edge add the edges with the same OSM id\n+            final CheckFlag flag = (object instanceof Edge)\n+                    ? this.createFlag(new OsmWayWalker((Edge) object).collectEdges(), instruction)\n+                    : this.createFlag(object, instruction);\n+\n+            // Add the specific instructions\n+            instructions.keySet().forEach(flag::addInstruction);\n+            /*\n+             * Only add autofixes when instructions are the same size as the changes. This avoids\n+             * situations where a change is available and is valid, but there is an additional issue\n+             * that is not able to be automatically fixed. If MapRoulette ever supports a method to\n+             * indicate that a change partially fixes the flag, this can be changed back to {@code\n+             * changes.isEmpty()}.\n+             */\n+            if (instructions.entrySet().stream().noneMatch(entry -> entry.getValue().isEmpty()))\n+            {\n+                flag.addFixSuggestions(Collections.singleton(\n+                        IFeatureChange.createFeatureChange(FeatureChange::add, (AtlasEntity) object,\n+                                instructions.values().stream().flatMap(Collection::stream)\n+                                        .filter(Objects::nonNull).distinct()\n+                                        .collect(Collectors.toList()))));\n+            }\n+            return Optional.of(flag);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Check for country specific rules\n+     *\n+     * @param instructions\n+     *            The instructions for the object\n+     * @param object\n+     *            The taggable object which should have country tags\n+     * @param tag\n+     *            The actual tag we are checking\n+     * @param wikiMap\n+     *            The map of wiki information\n+     * @return {@code true} if the check failed (i.e., an instruction has been generated)\n+     */\n+    private boolean checkCountrySpecific(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Taggable object, final Map.Entry<String, String> tag, final WikiData wikiMap)\n+    {\n+        // P48 shouldn't be used on actual key/tag items\n+        if (wikiMap != null && (!wikiMap.getMustOnlyBeUsedInRegionP29().isEmpty()\n+                || !wikiMap.getNotToBeUsedInRegionP30().isEmpty()))\n+        {\n+            /* Create a function that converts country/region wiki data into ISO3 codes */\n+            final UnaryOperator<Collection<String>> toWikiData = countries -> countries.stream()\n+                    .map(this::getWikiDataId)\n+                    .filter(Objects::nonNull/* Ignore values that aren't in the db */)\n+                    .map(WikiData::getGeographicCodeP49)\n+                    .filter(Objects::nonNull/* Q21351 has a null value here */)\n+                    .flatMap(Collection::stream)\n+                    .map(IsoCountry::iso3ForIso2/* Convert ISO2 to ISO3 codes */)\n+                    .filter(Optional::isPresent).map(Optional::get).collect(Collectors.toList());\n+            // Object ISOCountryTags appear to be ISO3 codes.\n+            final List<String> countries = Iterables.asList(ISOCountryTag.all(object));\n+            String instruction = null;\n+            // The region keys are one or the other, but should never be both.\n+            if (!wikiMap.getMustOnlyBeUsedInRegionP29().isEmpty())\n+            {\n+                final Collection<String> onlyUsedInRegion = toWikiData\n+                        .apply(wikiMap.getMustOnlyBeUsedInRegionP29());\n+                // Some primitives may cross country lines, so if any country is a valid region,\n+                // continue on.\n+                if (countries.stream().noneMatch(onlyUsedInRegion::contains))\n+                {\n+                    instruction = INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION;\n+                }\n+            }\n+            // check on P30 becomes redundant due to earlier check.\n+            else\n+            {\n+                final Collection<String> notUsedInRegion = toWikiData\n+                        .apply(wikiMap.getNotToBeUsedInRegionP30());\n+                // If countries is empty, then don't bother checking. Otherwise, allMatch\n+                // returns true.\n+                if (!countries.isEmpty() && countries.stream().allMatch(notUsedInRegion::contains))\n+                {\n+                    instruction = INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION;\n+                }\n+            }\n+            // If the tag shouldn't be used in the region/area, it should be removed\n+            if (instruction != null)\n+            {\n+                instructions.put(\n+                        this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS.indexOf(instruction),\n+                                tag.getKey(), tag.getValue(), String.join(\", \", countries),\n+                                wikiMap.getId()),\n+                        Collections.singleton(new RemoveTagFeatureChange(tag)));\n+            }\n+\n+            return instruction != null;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check for fallback issues (mostly unpopular/popular tags not caught by wiki checks)\n+     *\n+     * @param instructions\n+     *            The instructions to add to\n+     * @param tag\n+     *            The tag to check\n+     * @param keyInfo\n+     *            The information for the key\n+     * @param popular\n+     *            {@code true} if the key is \"popular\"\n+     * @param tagOccurrence\n+     *            The information from TagInfo for the tag\n+     * @param keyOccurrence\n+     *            The information from TagInfo for the key\n+     */\n+    private void checkFallback(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Map.Entry<String, String> tag, final WikiData keyInfo, final boolean popular,\n+            final TagInfoTags tagOccurrence, final TagInfoKeys keyOccurrence)\n+    {\n+        if (keyInfo == null)\n+        {\n+            final String count;\n+            final Map.Entry<String, String> messageTag;\n+            if (tagOccurrence.getCountAll() != null)\n+            {\n+                count = tagOccurrence.getCountAll().toString();\n+                messageTag = tag;\n+            }\n+            else if (keyOccurrence.getCountAll() != null)\n+            {\n+                count = keyOccurrence.getCountAll().toString();\n+                messageTag = Map.entry(tag.getKey(), \"\");\n+            }\n+            else\n+            {\n+                count = \"<\" + this.minTagUsage.toString();\n+                messageTag = tag;\n+            }\n+            // Check for unpopular/bad tags not already caught by wiki check\n+            if (!popular)\n+            {\n+                instructions.put(this.getLocalizedInstruction(\n+                        FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_TAGINFO_UNPOPULAR),\n+                        tagToString(tag), count), Collections.emptyList());\n+            }\n+            else\n+            {\n+                final String type = messageTag.getValue().isBlank() ? \"Key\" : \"Tag\";\n+                instructions.put(this.getLocalizedInstruction(\n+                        FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_TAGINFO_POPULAR),\n+                        tagToString(messageTag), type.toLowerCase(Locale.ENGLISH), count,\n+                        new StringBuilder(type).append(':').append(tagToString(messageTag))\n+                                .toString()),\n+                        Collections.emptyList());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Check if a wiki data item for a tag redirects to another tag, and if so, create an\n+     * instruction and change for that.\n+     *\n+     * @param instructions\n+     *            The instructions collection to add to\n+     * @param changes\n+     *            The changes collection to add to\n+     * @param tag\n+     *            The tag to check\n+     * @param checkInfo\n+     *            Wiki Data information (more specific)\n+     * @return {@code true} if the tag fails the regex\n+     */\n+    private boolean checkRedirectTo(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Map.Entry<String, String> tag, final WikiData checkInfo)\n+    {\n+        if (checkInfo != null && !checkInfo.getRedirectToP17().isEmpty())\n+        {\n+            final String value = checkInfo.getInstanceOfP2().contains(\"key\")\n+                    ? checkInfo.getPermanentKeyIdP16()\n+                    : checkInfo.getPermanentTagIdP19();\n+            final Collection<String> redirects = checkInfo.getRedirectToP17();\n+            final Map<String, String> replacements = redirects.stream().map(replacementId ->\n+\n+            WikiData.getWikiData(this.sqliteUtilsWikiData.getRows(Map.of(\"id\", replacementId)))\n+\n+            ).filter(Objects::nonNull).map(this::parseTags).filter(Objects::nonNull)\n+                    .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n+            final Collection<IFeatureChange> featureChanges;\n+            if (!replacements.isEmpty())\n+            {\n+                featureChanges = new ArrayList<>();\n+                featureChanges.add(new RemoveTagFeatureChange(tag));\n+                for (final Map.Entry<String, String> newTag : replacements.entrySet())\n+                {\n+                    featureChanges.add(new ReplaceTagFeatureChange(tag, newTag));\n+                }\n+            }\n+            else\n+            {\n+                featureChanges = Collections.emptyList();\n+            }\n+\n+            instructions.put(\n+                    this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_REPLACE),\n+                            value,\n+                            replacements.entrySet().stream().map(GenericTagCheck::tagToString)\n+                                    .collect(Collectors.joining(\", \")),\n+                            checkInfo.getId()),\n+                    featureChanges);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check regexes for a tag\n+     *\n+     * @param instructions\n+     *            The instruction collection to append instructions to\n+     * @param tag\n+     *            The specific tag to check\n+     * @param checkInfo\n+     *            Wiki Data information (specific, if available)\n+     * @return {@code true} if the regex failed\n+     */\n+    private boolean checkRegex(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Map.Entry<String, String> tag, final WikiData checkInfo)\n+    {\n+        // \"P13\" is \"value validation regex\". We must wrap with \"^(\" and \")$\"\n+        if (checkInfo != null && checkInfo.getValueValidationRegexP13() != null)\n+        {\n+            // Reuse the compiled patterns\n+            final var pattern = checkInfo.getValueValidationRegexP13();\n+            if (!pattern.matcher(tag.getValue()).matches())\n+            {\n+                instructions.put(this.getLocalizedInstruction(\n+                        FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_MISMATCHED_REGEX), tag.getValue(),\n+                        pattern.toString(), tag.getKey(), checkInfo.getId()),\n+                        Collections.emptyList());\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Do relation specific checks\n+     *\n+     * @param instructions\n+     *            Instructions to add to\n+     * @param The", "originalCommit": "ac3dad22c01430cc121a5c7ef7a7018f1d2cd6ed", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTk3NzA2Nw==", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r669977067", "bodyText": "unused param", "author": "sayas01", "createdAt": "2021-07-14T21:46:44Z", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/GenericTagCheck.java", "diffHunk": "@@ -0,0 +1,941 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import java.text.MessageFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import java.util.function.Predicate;\n+import java.util.function.UnaryOperator;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.base.ExternalDataFetcher;\n+import org.openstreetmap.atlas.checks.database.taginfo.TagInfoKeyTagCommon;\n+import org.openstreetmap.atlas.checks.database.taginfo.TagInfoKeys;\n+import org.openstreetmap.atlas.checks.database.taginfo.TagInfoTags;\n+import org.openstreetmap.atlas.checks.database.wikidata.WikiData;\n+import org.openstreetmap.atlas.checks.database.wikidata.WikiDataItem;\n+import org.openstreetmap.atlas.checks.database.wikidata.WikiProperty;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.AtlasToOsmType;\n+import org.openstreetmap.atlas.checks.utility.KeyFullyCheckedUtils;\n+import org.openstreetmap.atlas.checks.utility.SQLiteUtils;\n+import org.openstreetmap.atlas.checks.utility.feature_change.IFeatureChange;\n+import org.openstreetmap.atlas.checks.utility.feature_change.RemoveTagFeatureChange;\n+import org.openstreetmap.atlas.checks.utility.feature_change.ReplaceTagFeatureChange;\n+import org.openstreetmap.atlas.geography.atlas.change.FeatureChange;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Relation;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMember;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.locale.IsoCountry;\n+import org.openstreetmap.atlas.streaming.resource.Resource;\n+import org.openstreetmap.atlas.tags.ISOCountryTag;\n+import org.openstreetmap.atlas.tags.Taggable;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.testing.TestTaggable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Generic tag check using OSM Wiki Data and Tag Info databases.\n+ *\n+ * @author Taylor Smock\n+ */\n+public class GenericTagCheck extends BaseCheck<String>\n+{\n+    private static final long serialVersionUID = 5150282147895785829L;\n+    private static final String DEFAULT_NR_TAGS_INSTRUCTION = \"OSM feature {0,number,#} has invalid tags\";\n+    private static final String DEFAULT_INSTRUCTION = \"Check the following tags for missing, conflicting, or incorrect values: {0}\";\n+    private static final String INSTRUCTION_CONFLICTING_TAGS = \"Check the following tags for missing, conflicting, or incorrect values: {0}\";\n+    private static final String INSTRUCTION_INVALID_TAGS = \"OSM feature {0,number,#} has invalid tags\";\n+    private static final String INSTRUCTION_MISMATCHED_REGEX = \"{0} does not match the regex {1} for the key {2} (see https://wiki.osm.org/Item:{3})\";\n+    private static final String INSTRUCTION_PROHIBITED_USAGE = \"{0}={1} is prohibited on {2}. To determine whether to remove or change this tag please see this tag's Wiki Data page, https://wiki.osm.org/Item:{3} or the associated documentation Wiki Page on the Wiki Data page).\";\n+    private static final String INSTRUCTION_REPLACE = \"{0} should probably be replaced with {1} (see https://wiki.osm.org/Item:{2})\";\n+    private static final String INSTRUCTION_TAGINFO_POPULAR = \"{0} is probably an undocumented {1} ({2} instances). This should be documented on the wiki at https://wiki.osm.org/{3} and in the OpenStreetMap Wiki Data ( https://wiki.osm.org/Data_items ).\";\n+    private static final String INSTRUCTION_TAGINFO_UNPOPULAR = \"{0} is an unpopular key ({1} instances)\";\n+    private static final String INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION = \"{0}={1} should not be used in {2} (see https://wiki.osm.org/Item:{3})\";\n+    private static final String INSTRUCTION_UNDOCUMENTED_POPULAR_TAG = \"{0}={1} is not currently documented. Its global popularity ({2} uses) may merit adding wiki documentation for this value. Please consider adding a new Wiki Data page for {0}={1}.\";\n+    private static final String INSTRUCTION_UNKNOWN_RELATION_ROLE = \"{0}={1} is an unknown relation role for {0} ({2} {3,number,#} on relation {4,number,#}, see https://wiki.osm.org/Item:{5})\";\n+    private static final String INSTRUCTION_UNKNOWN_RELATION_TYPE = \"type={0} is an unknown relation type (relation {1,number,#}, see https://wiki.osm.org/Item:{2})\";\n+    private static final String INSTRUCTION_WELL_DEFINED_TAG_UNKNOWN_VALUE = \"{0} is not a well-known value for {1}\";\n+    private static final String INSTRUCTION_WIKI_DATA_REMOVAL = \"{0}={1} should probably be removed (it is {2}, see https://wiki.osm.org/Item:{3})\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Stream.of(DEFAULT_NR_TAGS_INSTRUCTION,\n+            DEFAULT_INSTRUCTION, INSTRUCTION_INVALID_TAGS, INSTRUCTION_CONFLICTING_TAGS,\n+            INSTRUCTION_MISMATCHED_REGEX, INSTRUCTION_UNDOCUMENTED_POPULAR_TAG,\n+            INSTRUCTION_WELL_DEFINED_TAG_UNKNOWN_VALUE, INSTRUCTION_WIKI_DATA_REMOVAL,\n+            INSTRUCTION_PROHIBITED_USAGE, INSTRUCTION_TAGINFO_UNPOPULAR,\n+            INSTRUCTION_TAGINFO_POPULAR, INSTRUCTION_REPLACE, INSTRUCTION_UNKNOWN_RELATION_ROLE,\n+            INSTRUCTION_UNKNOWN_RELATION_TYPE, INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION)\n+            .collect(Collectors.toCollection(ArrayList::new));\n+    private static final long DEFAULT_MIN_TAG_USAGE = 100;\n+\n+    private static final String DEFAULT_WIKI_TABLE = \"wiki_data\";\n+    private static final String DEFAULT_TAGINFO_TAG_TABLE = \"tags\";\n+    private static final String DEFAULT_TAGINFO_KEY_TABLE = \"keys\";\n+\n+    private static final Logger logger = LoggerFactory.getLogger(GenericTagCheck.class);\n+\n+    private final Long minTagUsage;\n+    // Due to serialization, this *cannot* be final\n+    private transient Collection<Predicate<Taggable>> ignoreTags = KeyFullyCheckedUtils\n+            .populateIgnoreTags();\n+\n+    private static final List<String> DEFAULT_TAGS_TO_REMOVE = Arrays.asList(\"abandoned\",\n+            \"discardable\", \"imported\", \"obsolete\", \"rejected\");\n+    private final List<String> tagsToRemove;\n+    private SQLiteUtils sqliteUtilsTagInfoTagTable;\n+    private SQLiteUtils sqliteUtilsTagInfoKeyTable;\n+    private SQLiteUtils sqliteUtilsWikiData;\n+    private static final String DEFAULT_TAGINFO_DB = \"taginfo-db.db\";\n+    private static final String DEFAULT_WIKIDATA_DB = \"wikidata.db\";\n+    private static final int DEFAULT_TAG_PERCENTAGE_KEY = 10;\n+    private final String tagInfoDB;\n+    private final String wikiDataDB;\n+    private final String wikiTable;\n+    private final String tagInfoTagTable;\n+    private final String tagInfoKeyTable;\n+    private final int popularTagPercentageKey;\n+\n+    /**\n+     * Check if an object is an area (i.e., an actual Area object OR a multipolygon)\n+     *\n+     * @param object\n+     *            The object to check\n+     * @return {@code true} if the object is an area\n+     */\n+    private static boolean isArea(final Taggable object)\n+    {\n+        return object instanceof Area\n+                || (object instanceof Relation && ((Relation) object).isMultiPolygon());\n+    }\n+\n+    /**\n+     * Check if an object may be an area\n+     *\n+     * @param object\n+     *            The object to check\n+     * @return {@code true} if the object <i>may</i> be an area.\n+     */\n+    private static boolean isClosedLine(final Taggable object)\n+    {\n+        return object instanceof LineItem && ((LineItem) object).isClosed();\n+    }\n+\n+    /**\n+     * Convert a tag entry into a string\n+     *\n+     * @param tag\n+     *            The tag to convert\n+     * @return A &ltkey&gt=&ltvalue&gt string\n+     */\n+    private static String tagToString(final Map.Entry<String, String> tag)\n+    {\n+        return Stream.of(tag.getKey(), tag.getValue()).filter(Objects::nonNull)\n+                .filter(string -> !string.isBlank()).collect(Collectors.joining(\"=\"));\n+    }\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     * @param fileFetcher\n+     *            A fetcher to get external data with\n+     */\n+    public GenericTagCheck(final Configuration configuration, final ExternalDataFetcher fileFetcher)\n+    {\n+        super(configuration);\n+        this.minTagUsage = this.configurationValue(configuration, \"tag.usage.min\",\n+                DEFAULT_MIN_TAG_USAGE);\n+\n+        this.tagsToRemove = this.configurationValue(configuration, \"wikidata.tag_removal\",\n+                DEFAULT_TAGS_TO_REMOVE);\n+        this.wikiTable = DEFAULT_WIKI_TABLE;\n+        this.tagInfoTagTable = DEFAULT_TAGINFO_TAG_TABLE;\n+        this.tagInfoKeyTable = DEFAULT_TAGINFO_KEY_TABLE;\n+        this.tagInfoDB = this.configurationValue(configuration, \"db.taginfo\", DEFAULT_TAGINFO_DB);\n+        this.wikiDataDB = this.configurationValue(configuration, \"db.wikidata\",\n+                DEFAULT_WIKIDATA_DB);\n+\n+        // At time of implementation, this.configurationValue(..., ..., Integer) returns\n+        // a Long.\n+        this.popularTagPercentageKey = this\n+                .configurationValue(configuration, \"tag.percentage_of_key_for_popular\",\n+                        ((Integer) DEFAULT_TAG_PERCENTAGE_KEY).longValue())\n+                .intValue();\n+\n+        // No matter what the atlas is, we need the db files. But only if we can get\n+        // them.\n+        if (fileFetcher == null)\n+        {\n+            return;\n+        }\n+        for (final String file : Arrays.asList(this.tagInfoDB, this.wikiDataDB))\n+        {\n+            final Optional<Resource> resource = fileFetcher.apply(file);\n+            if (!resource.isPresent() && logger.isDebugEnabled())\n+            {\n+                logger.debug(MessageFormat.format(\"{0} is not present\", file));\n+            }\n+        }\n+        this.fetchWikiData(fileFetcher);\n+        this.fetchTagInfo(fileFetcher);\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return !object.getOsmTags().isEmpty()\n+                && !this.isFlagged(this.getUniqueOSMIdentifier(object));\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        // Test against each filter and create an instruction if the object passes\n+        final Map<String, Collection<IFeatureChange>> instructions = new TreeMap<>();\n+\n+        if (this.sqliteUtilsTagInfoTagTable != null && this.sqliteUtilsWikiData != null)\n+        {\n+            if (this.ignoreTags == null || this.ignoreTags.isEmpty())\n+            {\n+                this.ignoreTags = KeyFullyCheckedUtils.populateIgnoreTags();\n+            }\n+            this.flagTags(object, instructions);\n+        }\n+\n+        if (!instructions.isEmpty())\n+        {\n+            // Mark objects flagged by their class and id to allow for the same id in\n+            // different object types\n+            this.markAsFlagged(this.getUniqueOSMIdentifier(object));\n+\n+            // Create a flag with generic instructions\n+            final String instruction = this.getLocalizedInstruction(\n+                    FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_INVALID_TAGS),\n+                    object.getOsmIdentifier());\n+            // If the object is an edge add the edges with the same OSM id\n+            final CheckFlag flag = (object instanceof Edge)\n+                    ? this.createFlag(new OsmWayWalker((Edge) object).collectEdges(), instruction)\n+                    : this.createFlag(object, instruction);\n+\n+            // Add the specific instructions\n+            instructions.keySet().forEach(flag::addInstruction);\n+            /*\n+             * Only add autofixes when instructions are the same size as the changes. This avoids\n+             * situations where a change is available and is valid, but there is an additional issue\n+             * that is not able to be automatically fixed. If MapRoulette ever supports a method to\n+             * indicate that a change partially fixes the flag, this can be changed back to {@code\n+             * changes.isEmpty()}.\n+             */\n+            if (instructions.entrySet().stream().noneMatch(entry -> entry.getValue().isEmpty()))\n+            {\n+                flag.addFixSuggestions(Collections.singleton(\n+                        IFeatureChange.createFeatureChange(FeatureChange::add, (AtlasEntity) object,\n+                                instructions.values().stream().flatMap(Collection::stream)\n+                                        .filter(Objects::nonNull).distinct()\n+                                        .collect(Collectors.toList()))));\n+            }\n+            return Optional.of(flag);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Check for country specific rules\n+     *\n+     * @param instructions\n+     *            The instructions for the object\n+     * @param object\n+     *            The taggable object which should have country tags\n+     * @param tag\n+     *            The actual tag we are checking\n+     * @param wikiMap\n+     *            The map of wiki information\n+     * @return {@code true} if the check failed (i.e., an instruction has been generated)\n+     */\n+    private boolean checkCountrySpecific(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Taggable object, final Map.Entry<String, String> tag, final WikiData wikiMap)\n+    {\n+        // P48 shouldn't be used on actual key/tag items\n+        if (wikiMap != null && (!wikiMap.getMustOnlyBeUsedInRegionP29().isEmpty()\n+                || !wikiMap.getNotToBeUsedInRegionP30().isEmpty()))\n+        {\n+            /* Create a function that converts country/region wiki data into ISO3 codes */\n+            final UnaryOperator<Collection<String>> toWikiData = countries -> countries.stream()\n+                    .map(this::getWikiDataId)\n+                    .filter(Objects::nonNull/* Ignore values that aren't in the db */)\n+                    .map(WikiData::getGeographicCodeP49)\n+                    .filter(Objects::nonNull/* Q21351 has a null value here */)\n+                    .flatMap(Collection::stream)\n+                    .map(IsoCountry::iso3ForIso2/* Convert ISO2 to ISO3 codes */)\n+                    .filter(Optional::isPresent).map(Optional::get).collect(Collectors.toList());\n+            // Object ISOCountryTags appear to be ISO3 codes.\n+            final List<String> countries = Iterables.asList(ISOCountryTag.all(object));\n+            String instruction = null;\n+            // The region keys are one or the other, but should never be both.\n+            if (!wikiMap.getMustOnlyBeUsedInRegionP29().isEmpty())\n+            {\n+                final Collection<String> onlyUsedInRegion = toWikiData\n+                        .apply(wikiMap.getMustOnlyBeUsedInRegionP29());\n+                // Some primitives may cross country lines, so if any country is a valid region,\n+                // continue on.\n+                if (countries.stream().noneMatch(onlyUsedInRegion::contains))\n+                {\n+                    instruction = INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION;\n+                }\n+            }\n+            // check on P30 becomes redundant due to earlier check.\n+            else\n+            {\n+                final Collection<String> notUsedInRegion = toWikiData\n+                        .apply(wikiMap.getNotToBeUsedInRegionP30());\n+                // If countries is empty, then don't bother checking. Otherwise, allMatch\n+                // returns true.\n+                if (!countries.isEmpty() && countries.stream().allMatch(notUsedInRegion::contains))\n+                {\n+                    instruction = INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION;\n+                }\n+            }\n+            // If the tag shouldn't be used in the region/area, it should be removed\n+            if (instruction != null)\n+            {\n+                instructions.put(\n+                        this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS.indexOf(instruction),\n+                                tag.getKey(), tag.getValue(), String.join(\", \", countries),\n+                                wikiMap.getId()),\n+                        Collections.singleton(new RemoveTagFeatureChange(tag)));\n+            }\n+\n+            return instruction != null;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check for fallback issues (mostly unpopular/popular tags not caught by wiki checks)\n+     *\n+     * @param instructions\n+     *            The instructions to add to\n+     * @param tag\n+     *            The tag to check\n+     * @param keyInfo\n+     *            The information for the key\n+     * @param popular\n+     *            {@code true} if the key is \"popular\"\n+     * @param tagOccurrence\n+     *            The information from TagInfo for the tag\n+     * @param keyOccurrence\n+     *            The information from TagInfo for the key\n+     */\n+    private void checkFallback(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Map.Entry<String, String> tag, final WikiData keyInfo, final boolean popular,\n+            final TagInfoTags tagOccurrence, final TagInfoKeys keyOccurrence)\n+    {\n+        if (keyInfo == null)\n+        {\n+            final String count;\n+            final Map.Entry<String, String> messageTag;\n+            if (tagOccurrence.getCountAll() != null)\n+            {\n+                count = tagOccurrence.getCountAll().toString();\n+                messageTag = tag;\n+            }\n+            else if (keyOccurrence.getCountAll() != null)\n+            {\n+                count = keyOccurrence.getCountAll().toString();\n+                messageTag = Map.entry(tag.getKey(), \"\");\n+            }\n+            else\n+            {\n+                count = \"<\" + this.minTagUsage.toString();\n+                messageTag = tag;\n+            }\n+            // Check for unpopular/bad tags not already caught by wiki check\n+            if (!popular)\n+            {\n+                instructions.put(this.getLocalizedInstruction(\n+                        FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_TAGINFO_UNPOPULAR),\n+                        tagToString(tag), count), Collections.emptyList());\n+            }\n+            else\n+            {\n+                final String type = messageTag.getValue().isBlank() ? \"Key\" : \"Tag\";\n+                instructions.put(this.getLocalizedInstruction(\n+                        FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_TAGINFO_POPULAR),\n+                        tagToString(messageTag), type.toLowerCase(Locale.ENGLISH), count,\n+                        new StringBuilder(type).append(':').append(tagToString(messageTag))\n+                                .toString()),\n+                        Collections.emptyList());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Check if a wiki data item for a tag redirects to another tag, and if so, create an\n+     * instruction and change for that.\n+     *\n+     * @param instructions\n+     *            The instructions collection to add to\n+     * @param changes\n+     *            The changes collection to add to\n+     * @param tag\n+     *            The tag to check\n+     * @param checkInfo\n+     *            Wiki Data information (more specific)\n+     * @return {@code true} if the tag fails the regex\n+     */\n+    private boolean checkRedirectTo(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Map.Entry<String, String> tag, final WikiData checkInfo)\n+    {\n+        if (checkInfo != null && !checkInfo.getRedirectToP17().isEmpty())\n+        {\n+            final String value = checkInfo.getInstanceOfP2().contains(\"key\")\n+                    ? checkInfo.getPermanentKeyIdP16()\n+                    : checkInfo.getPermanentTagIdP19();\n+            final Collection<String> redirects = checkInfo.getRedirectToP17();\n+            final Map<String, String> replacements = redirects.stream().map(replacementId ->\n+\n+            WikiData.getWikiData(this.sqliteUtilsWikiData.getRows(Map.of(\"id\", replacementId)))\n+\n+            ).filter(Objects::nonNull).map(this::parseTags).filter(Objects::nonNull)\n+                    .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n+            final Collection<IFeatureChange> featureChanges;\n+            if (!replacements.isEmpty())\n+            {\n+                featureChanges = new ArrayList<>();\n+                featureChanges.add(new RemoveTagFeatureChange(tag));\n+                for (final Map.Entry<String, String> newTag : replacements.entrySet())\n+                {\n+                    featureChanges.add(new ReplaceTagFeatureChange(tag, newTag));\n+                }\n+            }\n+            else\n+            {\n+                featureChanges = Collections.emptyList();\n+            }\n+\n+            instructions.put(\n+                    this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_REPLACE),\n+                            value,\n+                            replacements.entrySet().stream().map(GenericTagCheck::tagToString)\n+                                    .collect(Collectors.joining(\", \")),\n+                            checkInfo.getId()),\n+                    featureChanges);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check regexes for a tag\n+     *\n+     * @param instructions\n+     *            The instruction collection to append instructions to\n+     * @param tag\n+     *            The specific tag to check\n+     * @param checkInfo\n+     *            Wiki Data information (specific, if available)\n+     * @return {@code true} if the regex failed\n+     */\n+    private boolean checkRegex(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Map.Entry<String, String> tag, final WikiData checkInfo)\n+    {\n+        // \"P13\" is \"value validation regex\". We must wrap with \"^(\" and \")$\"\n+        if (checkInfo != null && checkInfo.getValueValidationRegexP13() != null)\n+        {\n+            // Reuse the compiled patterns\n+            final var pattern = checkInfo.getValueValidationRegexP13();\n+            if (!pattern.matcher(tag.getValue()).matches())\n+            {\n+                instructions.put(this.getLocalizedInstruction(\n+                        FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_MISMATCHED_REGEX), tag.getValue(),\n+                        pattern.toString(), tag.getKey(), checkInfo.getId()),\n+                        Collections.emptyList());\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Do relation specific checks\n+     *\n+     * @param instructions\n+     *            Instructions to add to\n+     * @param The\n+     *            object to check\n+     * @param checkInfo\n+     *            The wiki information for the tag to be checked\n+     * @param tag\n+     *            The tag to be checked\n+     * @return {@code true} if the relation had a problem\n+     */\n+    private boolean checkRelations(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Taggable object, final Map.Entry<String, String> tag, final WikiData checkInfo)\n+    {\n+        if (checkInfo != null && object instanceof Relation && checkInfo.isUseOnRelationsP36()\n+                && \"type\".equals(tag.getKey()))\n+        {\n+            final var relation = (Relation) object;\n+            final var relationInfo = this.getWikiData(\n+                    Map.of(WikiProperty.PERMANENT_RELATION_TYPE_ID_P41.getId(), tag.getValue()));\n+            if (relationInfo == null)\n+            {\n+                instructions.put(\n+                        this.getLocalizedInstruction(\n+                                FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_UNKNOWN_RELATION_TYPE),\n+                                tag.getValue(), relation.getOsmIdentifier(), checkInfo.getId()),\n+                        Collections.emptyList());\n+                return true;\n+            }\n+            final Collection<String> additionalInstructions = new TreeSet<>();\n+            for (final RelationMember relationMember : relation.members())\n+            {\n+                // Empty roles should exist in WikiData\n+                final String role = relationMember.getRole();\n+                final var roleInfo = this\n+                        .getWikiData(Map.of(WikiProperty.RELATION_ROLE_ID_P21.getId(),\n+                                relationInfo.getPermanentRelationTypeIdP41() + \"=\" + role));\n+                if (roleInfo == null)\n+                {\n+                    final var roleMember = relationMember.getEntity();\n+                    additionalInstructions.add(this.getLocalizedInstruction(\n+                            FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_UNKNOWN_RELATION_ROLE),\n+                            relationInfo.getPermanentRelationTypeIdP41(), role,\n+                            AtlasToOsmType.convert(roleMember.getType()),\n+                            roleMember.getOsmIdentifier(), relation.getOsmIdentifier(),\n+                            checkInfo.getId()));\n+                }\n+            }\n+            additionalInstructions\n+                    .forEach(instruction -> instructions.put(instruction, Collections.emptyList()));\n+            return !additionalInstructions.isEmpty();\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check the status of a tag\n+     *\n+     * @param instructions\n+     *            The instruction collection to append instructions to\n+     * @param changes", "originalCommit": "ac3dad22c01430cc121a5c7ef7a7018f1d2cd6ed", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTk3NzE1NQ==", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r669977155", "bodyText": "unused param", "author": "sayas01", "createdAt": "2021-07-14T21:46:57Z", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/GenericTagCheck.java", "diffHunk": "@@ -0,0 +1,941 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import java.text.MessageFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import java.util.function.Predicate;\n+import java.util.function.UnaryOperator;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.base.ExternalDataFetcher;\n+import org.openstreetmap.atlas.checks.database.taginfo.TagInfoKeyTagCommon;\n+import org.openstreetmap.atlas.checks.database.taginfo.TagInfoKeys;\n+import org.openstreetmap.atlas.checks.database.taginfo.TagInfoTags;\n+import org.openstreetmap.atlas.checks.database.wikidata.WikiData;\n+import org.openstreetmap.atlas.checks.database.wikidata.WikiDataItem;\n+import org.openstreetmap.atlas.checks.database.wikidata.WikiProperty;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.AtlasToOsmType;\n+import org.openstreetmap.atlas.checks.utility.KeyFullyCheckedUtils;\n+import org.openstreetmap.atlas.checks.utility.SQLiteUtils;\n+import org.openstreetmap.atlas.checks.utility.feature_change.IFeatureChange;\n+import org.openstreetmap.atlas.checks.utility.feature_change.RemoveTagFeatureChange;\n+import org.openstreetmap.atlas.checks.utility.feature_change.ReplaceTagFeatureChange;\n+import org.openstreetmap.atlas.geography.atlas.change.FeatureChange;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Relation;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMember;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.locale.IsoCountry;\n+import org.openstreetmap.atlas.streaming.resource.Resource;\n+import org.openstreetmap.atlas.tags.ISOCountryTag;\n+import org.openstreetmap.atlas.tags.Taggable;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.testing.TestTaggable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Generic tag check using OSM Wiki Data and Tag Info databases.\n+ *\n+ * @author Taylor Smock\n+ */\n+public class GenericTagCheck extends BaseCheck<String>\n+{\n+    private static final long serialVersionUID = 5150282147895785829L;\n+    private static final String DEFAULT_NR_TAGS_INSTRUCTION = \"OSM feature {0,number,#} has invalid tags\";\n+    private static final String DEFAULT_INSTRUCTION = \"Check the following tags for missing, conflicting, or incorrect values: {0}\";\n+    private static final String INSTRUCTION_CONFLICTING_TAGS = \"Check the following tags for missing, conflicting, or incorrect values: {0}\";\n+    private static final String INSTRUCTION_INVALID_TAGS = \"OSM feature {0,number,#} has invalid tags\";\n+    private static final String INSTRUCTION_MISMATCHED_REGEX = \"{0} does not match the regex {1} for the key {2} (see https://wiki.osm.org/Item:{3})\";\n+    private static final String INSTRUCTION_PROHIBITED_USAGE = \"{0}={1} is prohibited on {2}. To determine whether to remove or change this tag please see this tag's Wiki Data page, https://wiki.osm.org/Item:{3} or the associated documentation Wiki Page on the Wiki Data page).\";\n+    private static final String INSTRUCTION_REPLACE = \"{0} should probably be replaced with {1} (see https://wiki.osm.org/Item:{2})\";\n+    private static final String INSTRUCTION_TAGINFO_POPULAR = \"{0} is probably an undocumented {1} ({2} instances). This should be documented on the wiki at https://wiki.osm.org/{3} and in the OpenStreetMap Wiki Data ( https://wiki.osm.org/Data_items ).\";\n+    private static final String INSTRUCTION_TAGINFO_UNPOPULAR = \"{0} is an unpopular key ({1} instances)\";\n+    private static final String INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION = \"{0}={1} should not be used in {2} (see https://wiki.osm.org/Item:{3})\";\n+    private static final String INSTRUCTION_UNDOCUMENTED_POPULAR_TAG = \"{0}={1} is not currently documented. Its global popularity ({2} uses) may merit adding wiki documentation for this value. Please consider adding a new Wiki Data page for {0}={1}.\";\n+    private static final String INSTRUCTION_UNKNOWN_RELATION_ROLE = \"{0}={1} is an unknown relation role for {0} ({2} {3,number,#} on relation {4,number,#}, see https://wiki.osm.org/Item:{5})\";\n+    private static final String INSTRUCTION_UNKNOWN_RELATION_TYPE = \"type={0} is an unknown relation type (relation {1,number,#}, see https://wiki.osm.org/Item:{2})\";\n+    private static final String INSTRUCTION_WELL_DEFINED_TAG_UNKNOWN_VALUE = \"{0} is not a well-known value for {1}\";\n+    private static final String INSTRUCTION_WIKI_DATA_REMOVAL = \"{0}={1} should probably be removed (it is {2}, see https://wiki.osm.org/Item:{3})\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Stream.of(DEFAULT_NR_TAGS_INSTRUCTION,\n+            DEFAULT_INSTRUCTION, INSTRUCTION_INVALID_TAGS, INSTRUCTION_CONFLICTING_TAGS,\n+            INSTRUCTION_MISMATCHED_REGEX, INSTRUCTION_UNDOCUMENTED_POPULAR_TAG,\n+            INSTRUCTION_WELL_DEFINED_TAG_UNKNOWN_VALUE, INSTRUCTION_WIKI_DATA_REMOVAL,\n+            INSTRUCTION_PROHIBITED_USAGE, INSTRUCTION_TAGINFO_UNPOPULAR,\n+            INSTRUCTION_TAGINFO_POPULAR, INSTRUCTION_REPLACE, INSTRUCTION_UNKNOWN_RELATION_ROLE,\n+            INSTRUCTION_UNKNOWN_RELATION_TYPE, INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION)\n+            .collect(Collectors.toCollection(ArrayList::new));\n+    private static final long DEFAULT_MIN_TAG_USAGE = 100;\n+\n+    private static final String DEFAULT_WIKI_TABLE = \"wiki_data\";\n+    private static final String DEFAULT_TAGINFO_TAG_TABLE = \"tags\";\n+    private static final String DEFAULT_TAGINFO_KEY_TABLE = \"keys\";\n+\n+    private static final Logger logger = LoggerFactory.getLogger(GenericTagCheck.class);\n+\n+    private final Long minTagUsage;\n+    // Due to serialization, this *cannot* be final\n+    private transient Collection<Predicate<Taggable>> ignoreTags = KeyFullyCheckedUtils\n+            .populateIgnoreTags();\n+\n+    private static final List<String> DEFAULT_TAGS_TO_REMOVE = Arrays.asList(\"abandoned\",\n+            \"discardable\", \"imported\", \"obsolete\", \"rejected\");\n+    private final List<String> tagsToRemove;\n+    private SQLiteUtils sqliteUtilsTagInfoTagTable;\n+    private SQLiteUtils sqliteUtilsTagInfoKeyTable;\n+    private SQLiteUtils sqliteUtilsWikiData;\n+    private static final String DEFAULT_TAGINFO_DB = \"taginfo-db.db\";\n+    private static final String DEFAULT_WIKIDATA_DB = \"wikidata.db\";\n+    private static final int DEFAULT_TAG_PERCENTAGE_KEY = 10;\n+    private final String tagInfoDB;\n+    private final String wikiDataDB;\n+    private final String wikiTable;\n+    private final String tagInfoTagTable;\n+    private final String tagInfoKeyTable;\n+    private final int popularTagPercentageKey;\n+\n+    /**\n+     * Check if an object is an area (i.e., an actual Area object OR a multipolygon)\n+     *\n+     * @param object\n+     *            The object to check\n+     * @return {@code true} if the object is an area\n+     */\n+    private static boolean isArea(final Taggable object)\n+    {\n+        return object instanceof Area\n+                || (object instanceof Relation && ((Relation) object).isMultiPolygon());\n+    }\n+\n+    /**\n+     * Check if an object may be an area\n+     *\n+     * @param object\n+     *            The object to check\n+     * @return {@code true} if the object <i>may</i> be an area.\n+     */\n+    private static boolean isClosedLine(final Taggable object)\n+    {\n+        return object instanceof LineItem && ((LineItem) object).isClosed();\n+    }\n+\n+    /**\n+     * Convert a tag entry into a string\n+     *\n+     * @param tag\n+     *            The tag to convert\n+     * @return A &ltkey&gt=&ltvalue&gt string\n+     */\n+    private static String tagToString(final Map.Entry<String, String> tag)\n+    {\n+        return Stream.of(tag.getKey(), tag.getValue()).filter(Objects::nonNull)\n+                .filter(string -> !string.isBlank()).collect(Collectors.joining(\"=\"));\n+    }\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     * @param fileFetcher\n+     *            A fetcher to get external data with\n+     */\n+    public GenericTagCheck(final Configuration configuration, final ExternalDataFetcher fileFetcher)\n+    {\n+        super(configuration);\n+        this.minTagUsage = this.configurationValue(configuration, \"tag.usage.min\",\n+                DEFAULT_MIN_TAG_USAGE);\n+\n+        this.tagsToRemove = this.configurationValue(configuration, \"wikidata.tag_removal\",\n+                DEFAULT_TAGS_TO_REMOVE);\n+        this.wikiTable = DEFAULT_WIKI_TABLE;\n+        this.tagInfoTagTable = DEFAULT_TAGINFO_TAG_TABLE;\n+        this.tagInfoKeyTable = DEFAULT_TAGINFO_KEY_TABLE;\n+        this.tagInfoDB = this.configurationValue(configuration, \"db.taginfo\", DEFAULT_TAGINFO_DB);\n+        this.wikiDataDB = this.configurationValue(configuration, \"db.wikidata\",\n+                DEFAULT_WIKIDATA_DB);\n+\n+        // At time of implementation, this.configurationValue(..., ..., Integer) returns\n+        // a Long.\n+        this.popularTagPercentageKey = this\n+                .configurationValue(configuration, \"tag.percentage_of_key_for_popular\",\n+                        ((Integer) DEFAULT_TAG_PERCENTAGE_KEY).longValue())\n+                .intValue();\n+\n+        // No matter what the atlas is, we need the db files. But only if we can get\n+        // them.\n+        if (fileFetcher == null)\n+        {\n+            return;\n+        }\n+        for (final String file : Arrays.asList(this.tagInfoDB, this.wikiDataDB))\n+        {\n+            final Optional<Resource> resource = fileFetcher.apply(file);\n+            if (!resource.isPresent() && logger.isDebugEnabled())\n+            {\n+                logger.debug(MessageFormat.format(\"{0} is not present\", file));\n+            }\n+        }\n+        this.fetchWikiData(fileFetcher);\n+        this.fetchTagInfo(fileFetcher);\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return !object.getOsmTags().isEmpty()\n+                && !this.isFlagged(this.getUniqueOSMIdentifier(object));\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        // Test against each filter and create an instruction if the object passes\n+        final Map<String, Collection<IFeatureChange>> instructions = new TreeMap<>();\n+\n+        if (this.sqliteUtilsTagInfoTagTable != null && this.sqliteUtilsWikiData != null)\n+        {\n+            if (this.ignoreTags == null || this.ignoreTags.isEmpty())\n+            {\n+                this.ignoreTags = KeyFullyCheckedUtils.populateIgnoreTags();\n+            }\n+            this.flagTags(object, instructions);\n+        }\n+\n+        if (!instructions.isEmpty())\n+        {\n+            // Mark objects flagged by their class and id to allow for the same id in\n+            // different object types\n+            this.markAsFlagged(this.getUniqueOSMIdentifier(object));\n+\n+            // Create a flag with generic instructions\n+            final String instruction = this.getLocalizedInstruction(\n+                    FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_INVALID_TAGS),\n+                    object.getOsmIdentifier());\n+            // If the object is an edge add the edges with the same OSM id\n+            final CheckFlag flag = (object instanceof Edge)\n+                    ? this.createFlag(new OsmWayWalker((Edge) object).collectEdges(), instruction)\n+                    : this.createFlag(object, instruction);\n+\n+            // Add the specific instructions\n+            instructions.keySet().forEach(flag::addInstruction);\n+            /*\n+             * Only add autofixes when instructions are the same size as the changes. This avoids\n+             * situations where a change is available and is valid, but there is an additional issue\n+             * that is not able to be automatically fixed. If MapRoulette ever supports a method to\n+             * indicate that a change partially fixes the flag, this can be changed back to {@code\n+             * changes.isEmpty()}.\n+             */\n+            if (instructions.entrySet().stream().noneMatch(entry -> entry.getValue().isEmpty()))\n+            {\n+                flag.addFixSuggestions(Collections.singleton(\n+                        IFeatureChange.createFeatureChange(FeatureChange::add, (AtlasEntity) object,\n+                                instructions.values().stream().flatMap(Collection::stream)\n+                                        .filter(Objects::nonNull).distinct()\n+                                        .collect(Collectors.toList()))));\n+            }\n+            return Optional.of(flag);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Check for country specific rules\n+     *\n+     * @param instructions\n+     *            The instructions for the object\n+     * @param object\n+     *            The taggable object which should have country tags\n+     * @param tag\n+     *            The actual tag we are checking\n+     * @param wikiMap\n+     *            The map of wiki information\n+     * @return {@code true} if the check failed (i.e., an instruction has been generated)\n+     */\n+    private boolean checkCountrySpecific(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Taggable object, final Map.Entry<String, String> tag, final WikiData wikiMap)\n+    {\n+        // P48 shouldn't be used on actual key/tag items\n+        if (wikiMap != null && (!wikiMap.getMustOnlyBeUsedInRegionP29().isEmpty()\n+                || !wikiMap.getNotToBeUsedInRegionP30().isEmpty()))\n+        {\n+            /* Create a function that converts country/region wiki data into ISO3 codes */\n+            final UnaryOperator<Collection<String>> toWikiData = countries -> countries.stream()\n+                    .map(this::getWikiDataId)\n+                    .filter(Objects::nonNull/* Ignore values that aren't in the db */)\n+                    .map(WikiData::getGeographicCodeP49)\n+                    .filter(Objects::nonNull/* Q21351 has a null value here */)\n+                    .flatMap(Collection::stream)\n+                    .map(IsoCountry::iso3ForIso2/* Convert ISO2 to ISO3 codes */)\n+                    .filter(Optional::isPresent).map(Optional::get).collect(Collectors.toList());\n+            // Object ISOCountryTags appear to be ISO3 codes.\n+            final List<String> countries = Iterables.asList(ISOCountryTag.all(object));\n+            String instruction = null;\n+            // The region keys are one or the other, but should never be both.\n+            if (!wikiMap.getMustOnlyBeUsedInRegionP29().isEmpty())\n+            {\n+                final Collection<String> onlyUsedInRegion = toWikiData\n+                        .apply(wikiMap.getMustOnlyBeUsedInRegionP29());\n+                // Some primitives may cross country lines, so if any country is a valid region,\n+                // continue on.\n+                if (countries.stream().noneMatch(onlyUsedInRegion::contains))\n+                {\n+                    instruction = INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION;\n+                }\n+            }\n+            // check on P30 becomes redundant due to earlier check.\n+            else\n+            {\n+                final Collection<String> notUsedInRegion = toWikiData\n+                        .apply(wikiMap.getNotToBeUsedInRegionP30());\n+                // If countries is empty, then don't bother checking. Otherwise, allMatch\n+                // returns true.\n+                if (!countries.isEmpty() && countries.stream().allMatch(notUsedInRegion::contains))\n+                {\n+                    instruction = INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION;\n+                }\n+            }\n+            // If the tag shouldn't be used in the region/area, it should be removed\n+            if (instruction != null)\n+            {\n+                instructions.put(\n+                        this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS.indexOf(instruction),\n+                                tag.getKey(), tag.getValue(), String.join(\", \", countries),\n+                                wikiMap.getId()),\n+                        Collections.singleton(new RemoveTagFeatureChange(tag)));\n+            }\n+\n+            return instruction != null;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check for fallback issues (mostly unpopular/popular tags not caught by wiki checks)\n+     *\n+     * @param instructions\n+     *            The instructions to add to\n+     * @param tag\n+     *            The tag to check\n+     * @param keyInfo\n+     *            The information for the key\n+     * @param popular\n+     *            {@code true} if the key is \"popular\"\n+     * @param tagOccurrence\n+     *            The information from TagInfo for the tag\n+     * @param keyOccurrence\n+     *            The information from TagInfo for the key\n+     */\n+    private void checkFallback(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Map.Entry<String, String> tag, final WikiData keyInfo, final boolean popular,\n+            final TagInfoTags tagOccurrence, final TagInfoKeys keyOccurrence)\n+    {\n+        if (keyInfo == null)\n+        {\n+            final String count;\n+            final Map.Entry<String, String> messageTag;\n+            if (tagOccurrence.getCountAll() != null)\n+            {\n+                count = tagOccurrence.getCountAll().toString();\n+                messageTag = tag;\n+            }\n+            else if (keyOccurrence.getCountAll() != null)\n+            {\n+                count = keyOccurrence.getCountAll().toString();\n+                messageTag = Map.entry(tag.getKey(), \"\");\n+            }\n+            else\n+            {\n+                count = \"<\" + this.minTagUsage.toString();\n+                messageTag = tag;\n+            }\n+            // Check for unpopular/bad tags not already caught by wiki check\n+            if (!popular)\n+            {\n+                instructions.put(this.getLocalizedInstruction(\n+                        FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_TAGINFO_UNPOPULAR),\n+                        tagToString(tag), count), Collections.emptyList());\n+            }\n+            else\n+            {\n+                final String type = messageTag.getValue().isBlank() ? \"Key\" : \"Tag\";\n+                instructions.put(this.getLocalizedInstruction(\n+                        FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_TAGINFO_POPULAR),\n+                        tagToString(messageTag), type.toLowerCase(Locale.ENGLISH), count,\n+                        new StringBuilder(type).append(':').append(tagToString(messageTag))\n+                                .toString()),\n+                        Collections.emptyList());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Check if a wiki data item for a tag redirects to another tag, and if so, create an\n+     * instruction and change for that.\n+     *\n+     * @param instructions\n+     *            The instructions collection to add to\n+     * @param changes\n+     *            The changes collection to add to\n+     * @param tag\n+     *            The tag to check\n+     * @param checkInfo\n+     *            Wiki Data information (more specific)\n+     * @return {@code true} if the tag fails the regex\n+     */\n+    private boolean checkRedirectTo(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Map.Entry<String, String> tag, final WikiData checkInfo)\n+    {\n+        if (checkInfo != null && !checkInfo.getRedirectToP17().isEmpty())\n+        {\n+            final String value = checkInfo.getInstanceOfP2().contains(\"key\")\n+                    ? checkInfo.getPermanentKeyIdP16()\n+                    : checkInfo.getPermanentTagIdP19();\n+            final Collection<String> redirects = checkInfo.getRedirectToP17();\n+            final Map<String, String> replacements = redirects.stream().map(replacementId ->\n+\n+            WikiData.getWikiData(this.sqliteUtilsWikiData.getRows(Map.of(\"id\", replacementId)))\n+\n+            ).filter(Objects::nonNull).map(this::parseTags).filter(Objects::nonNull)\n+                    .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n+            final Collection<IFeatureChange> featureChanges;\n+            if (!replacements.isEmpty())\n+            {\n+                featureChanges = new ArrayList<>();\n+                featureChanges.add(new RemoveTagFeatureChange(tag));\n+                for (final Map.Entry<String, String> newTag : replacements.entrySet())\n+                {\n+                    featureChanges.add(new ReplaceTagFeatureChange(tag, newTag));\n+                }\n+            }\n+            else\n+            {\n+                featureChanges = Collections.emptyList();\n+            }\n+\n+            instructions.put(\n+                    this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_REPLACE),\n+                            value,\n+                            replacements.entrySet().stream().map(GenericTagCheck::tagToString)\n+                                    .collect(Collectors.joining(\", \")),\n+                            checkInfo.getId()),\n+                    featureChanges);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check regexes for a tag\n+     *\n+     * @param instructions\n+     *            The instruction collection to append instructions to\n+     * @param tag\n+     *            The specific tag to check\n+     * @param checkInfo\n+     *            Wiki Data information (specific, if available)\n+     * @return {@code true} if the regex failed\n+     */\n+    private boolean checkRegex(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Map.Entry<String, String> tag, final WikiData checkInfo)\n+    {\n+        // \"P13\" is \"value validation regex\". We must wrap with \"^(\" and \")$\"\n+        if (checkInfo != null && checkInfo.getValueValidationRegexP13() != null)\n+        {\n+            // Reuse the compiled patterns\n+            final var pattern = checkInfo.getValueValidationRegexP13();\n+            if (!pattern.matcher(tag.getValue()).matches())\n+            {\n+                instructions.put(this.getLocalizedInstruction(\n+                        FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_MISMATCHED_REGEX), tag.getValue(),\n+                        pattern.toString(), tag.getKey(), checkInfo.getId()),\n+                        Collections.emptyList());\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Do relation specific checks\n+     *\n+     * @param instructions\n+     *            Instructions to add to\n+     * @param The\n+     *            object to check\n+     * @param checkInfo\n+     *            The wiki information for the tag to be checked\n+     * @param tag\n+     *            The tag to be checked\n+     * @return {@code true} if the relation had a problem\n+     */\n+    private boolean checkRelations(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Taggable object, final Map.Entry<String, String> tag, final WikiData checkInfo)\n+    {\n+        if (checkInfo != null && object instanceof Relation && checkInfo.isUseOnRelationsP36()\n+                && \"type\".equals(tag.getKey()))\n+        {\n+            final var relation = (Relation) object;\n+            final var relationInfo = this.getWikiData(\n+                    Map.of(WikiProperty.PERMANENT_RELATION_TYPE_ID_P41.getId(), tag.getValue()));\n+            if (relationInfo == null)\n+            {\n+                instructions.put(\n+                        this.getLocalizedInstruction(\n+                                FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_UNKNOWN_RELATION_TYPE),\n+                                tag.getValue(), relation.getOsmIdentifier(), checkInfo.getId()),\n+                        Collections.emptyList());\n+                return true;\n+            }\n+            final Collection<String> additionalInstructions = new TreeSet<>();\n+            for (final RelationMember relationMember : relation.members())\n+            {\n+                // Empty roles should exist in WikiData\n+                final String role = relationMember.getRole();\n+                final var roleInfo = this\n+                        .getWikiData(Map.of(WikiProperty.RELATION_ROLE_ID_P21.getId(),\n+                                relationInfo.getPermanentRelationTypeIdP41() + \"=\" + role));\n+                if (roleInfo == null)\n+                {\n+                    final var roleMember = relationMember.getEntity();\n+                    additionalInstructions.add(this.getLocalizedInstruction(\n+                            FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_UNKNOWN_RELATION_ROLE),\n+                            relationInfo.getPermanentRelationTypeIdP41(), role,\n+                            AtlasToOsmType.convert(roleMember.getType()),\n+                            roleMember.getOsmIdentifier(), relation.getOsmIdentifier(),\n+                            checkInfo.getId()));\n+                }\n+            }\n+            additionalInstructions\n+                    .forEach(instruction -> instructions.put(instruction, Collections.emptyList()));\n+            return !additionalInstructions.isEmpty();\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check the status of a tag\n+     *\n+     * @param instructions\n+     *            The instruction collection to append instructions to\n+     * @param changes\n+     *            The changes to add a change to (removal)\n+     * @param tag\n+     *            The specific tag to check\n+     * @param checkInfo\n+     *            Wiki Data information (specific, if available)\n+     * @param wellKnown\n+     *            If the tag has well-defined values\n+     * @return {@code true} if the tag should be removed (change already added to {@code changes})\n+     */\n+    private boolean checkStatus(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Map.Entry<String, String> tag, final WikiData checkInfo, final boolean wellKnown)\n+    {\n+        if (wellKnown && checkInfo != null && checkInfo.getStatusP6() != null\n+                && this.tagsToRemove.stream().anyMatch(t -> checkInfo.getStatusP6().matches(t)))\n+        {\n+            instructions.put(\n+                    this.getLocalizedInstruction(\n+                            FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_WIKI_DATA_REMOVAL),\n+                            tag.getKey(), tag.getValue(),\n+                            checkInfo.getStatusP6().getDescriptor().toLowerCase(Locale.ENGLISH),\n+                            checkInfo.getId()),\n+                    Collections.singleton(new RemoveTagFeatureChange(tag)));\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check for instances where a key is well-known but the value is not one of the well-known\n+     * values.\n+     *\n+     * @param instructions\n+     *            The instructions to add to\n+     * @param changes", "originalCommit": "ac3dad22c01430cc121a5c7ef7a7018f1d2cd6ed", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTk3NzQyOA==", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r669977428", "bodyText": "unused param", "author": "sayas01", "createdAt": "2021-07-14T21:47:28Z", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/GenericTagCheck.java", "diffHunk": "@@ -0,0 +1,941 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import java.text.MessageFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import java.util.function.Predicate;\n+import java.util.function.UnaryOperator;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.base.ExternalDataFetcher;\n+import org.openstreetmap.atlas.checks.database.taginfo.TagInfoKeyTagCommon;\n+import org.openstreetmap.atlas.checks.database.taginfo.TagInfoKeys;\n+import org.openstreetmap.atlas.checks.database.taginfo.TagInfoTags;\n+import org.openstreetmap.atlas.checks.database.wikidata.WikiData;\n+import org.openstreetmap.atlas.checks.database.wikidata.WikiDataItem;\n+import org.openstreetmap.atlas.checks.database.wikidata.WikiProperty;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.AtlasToOsmType;\n+import org.openstreetmap.atlas.checks.utility.KeyFullyCheckedUtils;\n+import org.openstreetmap.atlas.checks.utility.SQLiteUtils;\n+import org.openstreetmap.atlas.checks.utility.feature_change.IFeatureChange;\n+import org.openstreetmap.atlas.checks.utility.feature_change.RemoveTagFeatureChange;\n+import org.openstreetmap.atlas.checks.utility.feature_change.ReplaceTagFeatureChange;\n+import org.openstreetmap.atlas.geography.atlas.change.FeatureChange;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Relation;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMember;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.locale.IsoCountry;\n+import org.openstreetmap.atlas.streaming.resource.Resource;\n+import org.openstreetmap.atlas.tags.ISOCountryTag;\n+import org.openstreetmap.atlas.tags.Taggable;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.testing.TestTaggable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Generic tag check using OSM Wiki Data and Tag Info databases.\n+ *\n+ * @author Taylor Smock\n+ */\n+public class GenericTagCheck extends BaseCheck<String>\n+{\n+    private static final long serialVersionUID = 5150282147895785829L;\n+    private static final String DEFAULT_NR_TAGS_INSTRUCTION = \"OSM feature {0,number,#} has invalid tags\";\n+    private static final String DEFAULT_INSTRUCTION = \"Check the following tags for missing, conflicting, or incorrect values: {0}\";\n+    private static final String INSTRUCTION_CONFLICTING_TAGS = \"Check the following tags for missing, conflicting, or incorrect values: {0}\";\n+    private static final String INSTRUCTION_INVALID_TAGS = \"OSM feature {0,number,#} has invalid tags\";\n+    private static final String INSTRUCTION_MISMATCHED_REGEX = \"{0} does not match the regex {1} for the key {2} (see https://wiki.osm.org/Item:{3})\";\n+    private static final String INSTRUCTION_PROHIBITED_USAGE = \"{0}={1} is prohibited on {2}. To determine whether to remove or change this tag please see this tag's Wiki Data page, https://wiki.osm.org/Item:{3} or the associated documentation Wiki Page on the Wiki Data page).\";\n+    private static final String INSTRUCTION_REPLACE = \"{0} should probably be replaced with {1} (see https://wiki.osm.org/Item:{2})\";\n+    private static final String INSTRUCTION_TAGINFO_POPULAR = \"{0} is probably an undocumented {1} ({2} instances). This should be documented on the wiki at https://wiki.osm.org/{3} and in the OpenStreetMap Wiki Data ( https://wiki.osm.org/Data_items ).\";\n+    private static final String INSTRUCTION_TAGINFO_UNPOPULAR = \"{0} is an unpopular key ({1} instances)\";\n+    private static final String INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION = \"{0}={1} should not be used in {2} (see https://wiki.osm.org/Item:{3})\";\n+    private static final String INSTRUCTION_UNDOCUMENTED_POPULAR_TAG = \"{0}={1} is not currently documented. Its global popularity ({2} uses) may merit adding wiki documentation for this value. Please consider adding a new Wiki Data page for {0}={1}.\";\n+    private static final String INSTRUCTION_UNKNOWN_RELATION_ROLE = \"{0}={1} is an unknown relation role for {0} ({2} {3,number,#} on relation {4,number,#}, see https://wiki.osm.org/Item:{5})\";\n+    private static final String INSTRUCTION_UNKNOWN_RELATION_TYPE = \"type={0} is an unknown relation type (relation {1,number,#}, see https://wiki.osm.org/Item:{2})\";\n+    private static final String INSTRUCTION_WELL_DEFINED_TAG_UNKNOWN_VALUE = \"{0} is not a well-known value for {1}\";\n+    private static final String INSTRUCTION_WIKI_DATA_REMOVAL = \"{0}={1} should probably be removed (it is {2}, see https://wiki.osm.org/Item:{3})\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Stream.of(DEFAULT_NR_TAGS_INSTRUCTION,\n+            DEFAULT_INSTRUCTION, INSTRUCTION_INVALID_TAGS, INSTRUCTION_CONFLICTING_TAGS,\n+            INSTRUCTION_MISMATCHED_REGEX, INSTRUCTION_UNDOCUMENTED_POPULAR_TAG,\n+            INSTRUCTION_WELL_DEFINED_TAG_UNKNOWN_VALUE, INSTRUCTION_WIKI_DATA_REMOVAL,\n+            INSTRUCTION_PROHIBITED_USAGE, INSTRUCTION_TAGINFO_UNPOPULAR,\n+            INSTRUCTION_TAGINFO_POPULAR, INSTRUCTION_REPLACE, INSTRUCTION_UNKNOWN_RELATION_ROLE,\n+            INSTRUCTION_UNKNOWN_RELATION_TYPE, INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION)\n+            .collect(Collectors.toCollection(ArrayList::new));\n+    private static final long DEFAULT_MIN_TAG_USAGE = 100;\n+\n+    private static final String DEFAULT_WIKI_TABLE = \"wiki_data\";\n+    private static final String DEFAULT_TAGINFO_TAG_TABLE = \"tags\";\n+    private static final String DEFAULT_TAGINFO_KEY_TABLE = \"keys\";\n+\n+    private static final Logger logger = LoggerFactory.getLogger(GenericTagCheck.class);\n+\n+    private final Long minTagUsage;\n+    // Due to serialization, this *cannot* be final\n+    private transient Collection<Predicate<Taggable>> ignoreTags = KeyFullyCheckedUtils\n+            .populateIgnoreTags();\n+\n+    private static final List<String> DEFAULT_TAGS_TO_REMOVE = Arrays.asList(\"abandoned\",\n+            \"discardable\", \"imported\", \"obsolete\", \"rejected\");\n+    private final List<String> tagsToRemove;\n+    private SQLiteUtils sqliteUtilsTagInfoTagTable;\n+    private SQLiteUtils sqliteUtilsTagInfoKeyTable;\n+    private SQLiteUtils sqliteUtilsWikiData;\n+    private static final String DEFAULT_TAGINFO_DB = \"taginfo-db.db\";\n+    private static final String DEFAULT_WIKIDATA_DB = \"wikidata.db\";\n+    private static final int DEFAULT_TAG_PERCENTAGE_KEY = 10;\n+    private final String tagInfoDB;\n+    private final String wikiDataDB;\n+    private final String wikiTable;\n+    private final String tagInfoTagTable;\n+    private final String tagInfoKeyTable;\n+    private final int popularTagPercentageKey;\n+\n+    /**\n+     * Check if an object is an area (i.e., an actual Area object OR a multipolygon)\n+     *\n+     * @param object\n+     *            The object to check\n+     * @return {@code true} if the object is an area\n+     */\n+    private static boolean isArea(final Taggable object)\n+    {\n+        return object instanceof Area\n+                || (object instanceof Relation && ((Relation) object).isMultiPolygon());\n+    }\n+\n+    /**\n+     * Check if an object may be an area\n+     *\n+     * @param object\n+     *            The object to check\n+     * @return {@code true} if the object <i>may</i> be an area.\n+     */\n+    private static boolean isClosedLine(final Taggable object)\n+    {\n+        return object instanceof LineItem && ((LineItem) object).isClosed();\n+    }\n+\n+    /**\n+     * Convert a tag entry into a string\n+     *\n+     * @param tag\n+     *            The tag to convert\n+     * @return A &ltkey&gt=&ltvalue&gt string\n+     */\n+    private static String tagToString(final Map.Entry<String, String> tag)\n+    {\n+        return Stream.of(tag.getKey(), tag.getValue()).filter(Objects::nonNull)\n+                .filter(string -> !string.isBlank()).collect(Collectors.joining(\"=\"));\n+    }\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     * @param fileFetcher\n+     *            A fetcher to get external data with\n+     */\n+    public GenericTagCheck(final Configuration configuration, final ExternalDataFetcher fileFetcher)\n+    {\n+        super(configuration);\n+        this.minTagUsage = this.configurationValue(configuration, \"tag.usage.min\",\n+                DEFAULT_MIN_TAG_USAGE);\n+\n+        this.tagsToRemove = this.configurationValue(configuration, \"wikidata.tag_removal\",\n+                DEFAULT_TAGS_TO_REMOVE);\n+        this.wikiTable = DEFAULT_WIKI_TABLE;\n+        this.tagInfoTagTable = DEFAULT_TAGINFO_TAG_TABLE;\n+        this.tagInfoKeyTable = DEFAULT_TAGINFO_KEY_TABLE;\n+        this.tagInfoDB = this.configurationValue(configuration, \"db.taginfo\", DEFAULT_TAGINFO_DB);\n+        this.wikiDataDB = this.configurationValue(configuration, \"db.wikidata\",\n+                DEFAULT_WIKIDATA_DB);\n+\n+        // At time of implementation, this.configurationValue(..., ..., Integer) returns\n+        // a Long.\n+        this.popularTagPercentageKey = this\n+                .configurationValue(configuration, \"tag.percentage_of_key_for_popular\",\n+                        ((Integer) DEFAULT_TAG_PERCENTAGE_KEY).longValue())\n+                .intValue();\n+\n+        // No matter what the atlas is, we need the db files. But only if we can get\n+        // them.\n+        if (fileFetcher == null)\n+        {\n+            return;\n+        }\n+        for (final String file : Arrays.asList(this.tagInfoDB, this.wikiDataDB))\n+        {\n+            final Optional<Resource> resource = fileFetcher.apply(file);\n+            if (!resource.isPresent() && logger.isDebugEnabled())\n+            {\n+                logger.debug(MessageFormat.format(\"{0} is not present\", file));\n+            }\n+        }\n+        this.fetchWikiData(fileFetcher);\n+        this.fetchTagInfo(fileFetcher);\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return !object.getOsmTags().isEmpty()\n+                && !this.isFlagged(this.getUniqueOSMIdentifier(object));\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        // Test against each filter and create an instruction if the object passes\n+        final Map<String, Collection<IFeatureChange>> instructions = new TreeMap<>();\n+\n+        if (this.sqliteUtilsTagInfoTagTable != null && this.sqliteUtilsWikiData != null)\n+        {\n+            if (this.ignoreTags == null || this.ignoreTags.isEmpty())\n+            {\n+                this.ignoreTags = KeyFullyCheckedUtils.populateIgnoreTags();\n+            }\n+            this.flagTags(object, instructions);\n+        }\n+\n+        if (!instructions.isEmpty())\n+        {\n+            // Mark objects flagged by their class and id to allow for the same id in\n+            // different object types\n+            this.markAsFlagged(this.getUniqueOSMIdentifier(object));\n+\n+            // Create a flag with generic instructions\n+            final String instruction = this.getLocalizedInstruction(\n+                    FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_INVALID_TAGS),\n+                    object.getOsmIdentifier());\n+            // If the object is an edge add the edges with the same OSM id\n+            final CheckFlag flag = (object instanceof Edge)\n+                    ? this.createFlag(new OsmWayWalker((Edge) object).collectEdges(), instruction)\n+                    : this.createFlag(object, instruction);\n+\n+            // Add the specific instructions\n+            instructions.keySet().forEach(flag::addInstruction);\n+            /*\n+             * Only add autofixes when instructions are the same size as the changes. This avoids\n+             * situations where a change is available and is valid, but there is an additional issue\n+             * that is not able to be automatically fixed. If MapRoulette ever supports a method to\n+             * indicate that a change partially fixes the flag, this can be changed back to {@code\n+             * changes.isEmpty()}.\n+             */\n+            if (instructions.entrySet().stream().noneMatch(entry -> entry.getValue().isEmpty()))\n+            {\n+                flag.addFixSuggestions(Collections.singleton(\n+                        IFeatureChange.createFeatureChange(FeatureChange::add, (AtlasEntity) object,\n+                                instructions.values().stream().flatMap(Collection::stream)\n+                                        .filter(Objects::nonNull).distinct()\n+                                        .collect(Collectors.toList()))));\n+            }\n+            return Optional.of(flag);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Check for country specific rules\n+     *\n+     * @param instructions\n+     *            The instructions for the object\n+     * @param object\n+     *            The taggable object which should have country tags\n+     * @param tag\n+     *            The actual tag we are checking\n+     * @param wikiMap\n+     *            The map of wiki information\n+     * @return {@code true} if the check failed (i.e., an instruction has been generated)\n+     */\n+    private boolean checkCountrySpecific(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Taggable object, final Map.Entry<String, String> tag, final WikiData wikiMap)\n+    {\n+        // P48 shouldn't be used on actual key/tag items\n+        if (wikiMap != null && (!wikiMap.getMustOnlyBeUsedInRegionP29().isEmpty()\n+                || !wikiMap.getNotToBeUsedInRegionP30().isEmpty()))\n+        {\n+            /* Create a function that converts country/region wiki data into ISO3 codes */\n+            final UnaryOperator<Collection<String>> toWikiData = countries -> countries.stream()\n+                    .map(this::getWikiDataId)\n+                    .filter(Objects::nonNull/* Ignore values that aren't in the db */)\n+                    .map(WikiData::getGeographicCodeP49)\n+                    .filter(Objects::nonNull/* Q21351 has a null value here */)\n+                    .flatMap(Collection::stream)\n+                    .map(IsoCountry::iso3ForIso2/* Convert ISO2 to ISO3 codes */)\n+                    .filter(Optional::isPresent).map(Optional::get).collect(Collectors.toList());\n+            // Object ISOCountryTags appear to be ISO3 codes.\n+            final List<String> countries = Iterables.asList(ISOCountryTag.all(object));\n+            String instruction = null;\n+            // The region keys are one or the other, but should never be both.\n+            if (!wikiMap.getMustOnlyBeUsedInRegionP29().isEmpty())\n+            {\n+                final Collection<String> onlyUsedInRegion = toWikiData\n+                        .apply(wikiMap.getMustOnlyBeUsedInRegionP29());\n+                // Some primitives may cross country lines, so if any country is a valid region,\n+                // continue on.\n+                if (countries.stream().noneMatch(onlyUsedInRegion::contains))\n+                {\n+                    instruction = INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION;\n+                }\n+            }\n+            // check on P30 becomes redundant due to earlier check.\n+            else\n+            {\n+                final Collection<String> notUsedInRegion = toWikiData\n+                        .apply(wikiMap.getNotToBeUsedInRegionP30());\n+                // If countries is empty, then don't bother checking. Otherwise, allMatch\n+                // returns true.\n+                if (!countries.isEmpty() && countries.stream().allMatch(notUsedInRegion::contains))\n+                {\n+                    instruction = INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION;\n+                }\n+            }\n+            // If the tag shouldn't be used in the region/area, it should be removed\n+            if (instruction != null)\n+            {\n+                instructions.put(\n+                        this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS.indexOf(instruction),\n+                                tag.getKey(), tag.getValue(), String.join(\", \", countries),\n+                                wikiMap.getId()),\n+                        Collections.singleton(new RemoveTagFeatureChange(tag)));\n+            }\n+\n+            return instruction != null;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check for fallback issues (mostly unpopular/popular tags not caught by wiki checks)\n+     *\n+     * @param instructions\n+     *            The instructions to add to\n+     * @param tag\n+     *            The tag to check\n+     * @param keyInfo\n+     *            The information for the key\n+     * @param popular\n+     *            {@code true} if the key is \"popular\"\n+     * @param tagOccurrence\n+     *            The information from TagInfo for the tag\n+     * @param keyOccurrence\n+     *            The information from TagInfo for the key\n+     */\n+    private void checkFallback(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Map.Entry<String, String> tag, final WikiData keyInfo, final boolean popular,\n+            final TagInfoTags tagOccurrence, final TagInfoKeys keyOccurrence)\n+    {\n+        if (keyInfo == null)\n+        {\n+            final String count;\n+            final Map.Entry<String, String> messageTag;\n+            if (tagOccurrence.getCountAll() != null)\n+            {\n+                count = tagOccurrence.getCountAll().toString();\n+                messageTag = tag;\n+            }\n+            else if (keyOccurrence.getCountAll() != null)\n+            {\n+                count = keyOccurrence.getCountAll().toString();\n+                messageTag = Map.entry(tag.getKey(), \"\");\n+            }\n+            else\n+            {\n+                count = \"<\" + this.minTagUsage.toString();\n+                messageTag = tag;\n+            }\n+            // Check for unpopular/bad tags not already caught by wiki check\n+            if (!popular)\n+            {\n+                instructions.put(this.getLocalizedInstruction(\n+                        FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_TAGINFO_UNPOPULAR),\n+                        tagToString(tag), count), Collections.emptyList());\n+            }\n+            else\n+            {\n+                final String type = messageTag.getValue().isBlank() ? \"Key\" : \"Tag\";\n+                instructions.put(this.getLocalizedInstruction(\n+                        FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_TAGINFO_POPULAR),\n+                        tagToString(messageTag), type.toLowerCase(Locale.ENGLISH), count,\n+                        new StringBuilder(type).append(':').append(tagToString(messageTag))\n+                                .toString()),\n+                        Collections.emptyList());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Check if a wiki data item for a tag redirects to another tag, and if so, create an\n+     * instruction and change for that.\n+     *\n+     * @param instructions\n+     *            The instructions collection to add to\n+     * @param changes\n+     *            The changes collection to add to\n+     * @param tag\n+     *            The tag to check\n+     * @param checkInfo\n+     *            Wiki Data information (more specific)\n+     * @return {@code true} if the tag fails the regex\n+     */\n+    private boolean checkRedirectTo(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Map.Entry<String, String> tag, final WikiData checkInfo)\n+    {\n+        if (checkInfo != null && !checkInfo.getRedirectToP17().isEmpty())\n+        {\n+            final String value = checkInfo.getInstanceOfP2().contains(\"key\")\n+                    ? checkInfo.getPermanentKeyIdP16()\n+                    : checkInfo.getPermanentTagIdP19();\n+            final Collection<String> redirects = checkInfo.getRedirectToP17();\n+            final Map<String, String> replacements = redirects.stream().map(replacementId ->\n+\n+            WikiData.getWikiData(this.sqliteUtilsWikiData.getRows(Map.of(\"id\", replacementId)))\n+\n+            ).filter(Objects::nonNull).map(this::parseTags).filter(Objects::nonNull)\n+                    .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n+            final Collection<IFeatureChange> featureChanges;\n+            if (!replacements.isEmpty())\n+            {\n+                featureChanges = new ArrayList<>();\n+                featureChanges.add(new RemoveTagFeatureChange(tag));\n+                for (final Map.Entry<String, String> newTag : replacements.entrySet())\n+                {\n+                    featureChanges.add(new ReplaceTagFeatureChange(tag, newTag));\n+                }\n+            }\n+            else\n+            {\n+                featureChanges = Collections.emptyList();\n+            }\n+\n+            instructions.put(\n+                    this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_REPLACE),\n+                            value,\n+                            replacements.entrySet().stream().map(GenericTagCheck::tagToString)\n+                                    .collect(Collectors.joining(\", \")),\n+                            checkInfo.getId()),\n+                    featureChanges);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check regexes for a tag\n+     *\n+     * @param instructions\n+     *            The instruction collection to append instructions to\n+     * @param tag\n+     *            The specific tag to check\n+     * @param checkInfo\n+     *            Wiki Data information (specific, if available)\n+     * @return {@code true} if the regex failed\n+     */\n+    private boolean checkRegex(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Map.Entry<String, String> tag, final WikiData checkInfo)\n+    {\n+        // \"P13\" is \"value validation regex\". We must wrap with \"^(\" and \")$\"\n+        if (checkInfo != null && checkInfo.getValueValidationRegexP13() != null)\n+        {\n+            // Reuse the compiled patterns\n+            final var pattern = checkInfo.getValueValidationRegexP13();\n+            if (!pattern.matcher(tag.getValue()).matches())\n+            {\n+                instructions.put(this.getLocalizedInstruction(\n+                        FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_MISMATCHED_REGEX), tag.getValue(),\n+                        pattern.toString(), tag.getKey(), checkInfo.getId()),\n+                        Collections.emptyList());\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Do relation specific checks\n+     *\n+     * @param instructions\n+     *            Instructions to add to\n+     * @param The\n+     *            object to check\n+     * @param checkInfo\n+     *            The wiki information for the tag to be checked\n+     * @param tag\n+     *            The tag to be checked\n+     * @return {@code true} if the relation had a problem\n+     */\n+    private boolean checkRelations(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Taggable object, final Map.Entry<String, String> tag, final WikiData checkInfo)\n+    {\n+        if (checkInfo != null && object instanceof Relation && checkInfo.isUseOnRelationsP36()\n+                && \"type\".equals(tag.getKey()))\n+        {\n+            final var relation = (Relation) object;\n+            final var relationInfo = this.getWikiData(\n+                    Map.of(WikiProperty.PERMANENT_RELATION_TYPE_ID_P41.getId(), tag.getValue()));\n+            if (relationInfo == null)\n+            {\n+                instructions.put(\n+                        this.getLocalizedInstruction(\n+                                FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_UNKNOWN_RELATION_TYPE),\n+                                tag.getValue(), relation.getOsmIdentifier(), checkInfo.getId()),\n+                        Collections.emptyList());\n+                return true;\n+            }\n+            final Collection<String> additionalInstructions = new TreeSet<>();\n+            for (final RelationMember relationMember : relation.members())\n+            {\n+                // Empty roles should exist in WikiData\n+                final String role = relationMember.getRole();\n+                final var roleInfo = this\n+                        .getWikiData(Map.of(WikiProperty.RELATION_ROLE_ID_P21.getId(),\n+                                relationInfo.getPermanentRelationTypeIdP41() + \"=\" + role));\n+                if (roleInfo == null)\n+                {\n+                    final var roleMember = relationMember.getEntity();\n+                    additionalInstructions.add(this.getLocalizedInstruction(\n+                            FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_UNKNOWN_RELATION_ROLE),\n+                            relationInfo.getPermanentRelationTypeIdP41(), role,\n+                            AtlasToOsmType.convert(roleMember.getType()),\n+                            roleMember.getOsmIdentifier(), relation.getOsmIdentifier(),\n+                            checkInfo.getId()));\n+                }\n+            }\n+            additionalInstructions\n+                    .forEach(instruction -> instructions.put(instruction, Collections.emptyList()));\n+            return !additionalInstructions.isEmpty();\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check the status of a tag\n+     *\n+     * @param instructions\n+     *            The instruction collection to append instructions to\n+     * @param changes\n+     *            The changes to add a change to (removal)\n+     * @param tag\n+     *            The specific tag to check\n+     * @param checkInfo\n+     *            Wiki Data information (specific, if available)\n+     * @param wellKnown\n+     *            If the tag has well-defined values\n+     * @return {@code true} if the tag should be removed (change already added to {@code changes})\n+     */\n+    private boolean checkStatus(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Map.Entry<String, String> tag, final WikiData checkInfo, final boolean wellKnown)\n+    {\n+        if (wellKnown && checkInfo != null && checkInfo.getStatusP6() != null\n+                && this.tagsToRemove.stream().anyMatch(t -> checkInfo.getStatusP6().matches(t)))\n+        {\n+            instructions.put(\n+                    this.getLocalizedInstruction(\n+                            FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_WIKI_DATA_REMOVAL),\n+                            tag.getKey(), tag.getValue(),\n+                            checkInfo.getStatusP6().getDescriptor().toLowerCase(Locale.ENGLISH),\n+                            checkInfo.getId()),\n+                    Collections.singleton(new RemoveTagFeatureChange(tag)));\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check for instances where a key is well-known but the value is not one of the well-known\n+     * values.\n+     *\n+     * @param instructions\n+     *            The instructions to add to\n+     * @param changes\n+     *            The changes to add to\n+     * @param tag\n+     *            The tag to check\n+     * @param checkInfo\n+     *            Wiki Data information (more specific)\n+     * @param wellKnown\n+     *            {@code true} if values are well-known\n+     * @param popular\n+     *            {@code true} if the tag is popular\n+     * @param tagOccurrence\n+     *            The TagInfo information for the tag\n+     * @return {@code true} if an issue was found\n+     */\n+    private boolean checkUndocumentedPopularWellDefined(\n+            final Map<String, Collection<IFeatureChange>> instructions,\n+            final Map.Entry<String, String> tag, final WikiData checkInfo, final boolean wellKnown,\n+            final boolean popular, final TagInfoTags tagOccurrence)\n+    {\n+        if (wellKnown && checkInfo == null)\n+        {\n+            if (popular)\n+            {\n+                instructions.put(\n+                        this.getLocalizedInstruction(\n+                                FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_UNDOCUMENTED_POPULAR_TAG),\n+                                tag.getKey(), tag.getValue(), tagOccurrence.getCountAll()),\n+                        Collections.emptyList());\n+            }\n+            else\n+            {\n+                instructions.put(\n+                        this.getLocalizedInstruction(\n+                                FALLBACK_INSTRUCTIONS\n+                                        .indexOf(INSTRUCTION_WELL_DEFINED_TAG_UNKNOWN_VALUE),\n+                                tag.getValue(), tag.getKey()),\n+                        Collections.singleton(new RemoveTagFeatureChange(tag)));\n+            }\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check the tag against wiki data for cases where it should not appear on the object.\n+     *\n+     * @param changes", "originalCommit": "ac3dad22c01430cc121a5c7ef7a7018f1d2cd6ed", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1a01ae743d679f93b0f630a081dd54556013720d", "url": "https://github.com/osmlab/atlas-checks/commit/1a01ae743d679f93b0f630a081dd54556013720d", "message": "GenericTagCheck: Add generic test for tag checking (using OSM Wiki Data and TagInfo)\n\nAbbreviatedNameCheck: Improve validCheckForObject\n* Only objects with names are valid checks.\n\nFeatureChange: Add interfaces for remove/replace tag changes\n\nGenericTagCheck: Check for unpopular tags with taginfo\n* Implement Autocloseable and check for that in RunnableCheck (if\n  implemented, close)\n* Add SQLiteUtils in an effort to allow the DB connection to be\n  serialized (and significantly reduce time from reopening db)\n* Check for unwanted tags on objects using OSM Wiki Data\n* Use TagInfo information to expound upon issues detected by OSM Wiki\n  Data.\n* OSM Wiki Data is used for regex checking, when the Wiki Data has a\n  regex.\n* Account for P17 (redirect to) when a bad tag is encountered.\n\nSQLite:\n* Dependencies: Add SQLite\n* Cache gets for DB\n  * Assumption: DB doesn't change during the run\n\n    This brought the runtime on a MacBook 2017 (i7 w/ 16GB ram) from 14\n    hours to 2 hours (and a bit). The runtime for the dev/master branch was\n    also about 2 hours (and a bit).\n\n    The countries run were AIA, CYM, DMA, NZL, and SMR. There was no real\n    noticeable difference with BLZ.\n* Store a copy of the retrieved data without null values in SQLiteUtils\n* Store file fetcher for use on computation nodes\n\nTagInfo: Add download script\nWikiData: Add download script\n* Update older entries and write changes to a file\n\n  This means that changes can be inspected and verified (future task:\n  insert into an HTML page with links so people can more easily tell if\n  the change is relevant or not).\n* When duplicate unique keys appear, print out what was being inserted\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2021-07-14T22:11:37Z", "type": "commit"}, {"oid": "1a01ae743d679f93b0f630a081dd54556013720d", "url": "https://github.com/osmlab/atlas-checks/commit/1a01ae743d679f93b0f630a081dd54556013720d", "message": "GenericTagCheck: Add generic test for tag checking (using OSM Wiki Data and TagInfo)\n\nAbbreviatedNameCheck: Improve validCheckForObject\n* Only objects with names are valid checks.\n\nFeatureChange: Add interfaces for remove/replace tag changes\n\nGenericTagCheck: Check for unpopular tags with taginfo\n* Implement Autocloseable and check for that in RunnableCheck (if\n  implemented, close)\n* Add SQLiteUtils in an effort to allow the DB connection to be\n  serialized (and significantly reduce time from reopening db)\n* Check for unwanted tags on objects using OSM Wiki Data\n* Use TagInfo information to expound upon issues detected by OSM Wiki\n  Data.\n* OSM Wiki Data is used for regex checking, when the Wiki Data has a\n  regex.\n* Account for P17 (redirect to) when a bad tag is encountered.\n\nSQLite:\n* Dependencies: Add SQLite\n* Cache gets for DB\n  * Assumption: DB doesn't change during the run\n\n    This brought the runtime on a MacBook 2017 (i7 w/ 16GB ram) from 14\n    hours to 2 hours (and a bit). The runtime for the dev/master branch was\n    also about 2 hours (and a bit).\n\n    The countries run were AIA, CYM, DMA, NZL, and SMR. There was no real\n    noticeable difference with BLZ.\n* Store a copy of the retrieved data without null values in SQLiteUtils\n* Store file fetcher for use on computation nodes\n\nTagInfo: Add download script\nWikiData: Add download script\n* Update older entries and write changes to a file\n\n  This means that changes can be inspected and verified (future task:\n  insert into an HTML page with links so people can more easily tell if\n  the change is relevant or not).\n* When duplicate unique keys appear, print out what was being inserted\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>", "committedDate": "2021-07-14T22:11:37Z", "type": "forcePushed"}]}