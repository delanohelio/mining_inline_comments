{"pr_number": 315, "pr_title": "Vlad missing roundabout tag", "pr_createdAt": "2020-06-11T16:58:38Z", "pr_url": "https://github.com/osmlab/atlas-checks/pull/315", "timeline": [{"oid": "b396ac0d62dd6810d5c839e1422eb6eac3db41d0", "url": "https://github.com/osmlab/atlas-checks/commit/b396ac0d62dd6810d5c839e1422eb6eac3db41d0", "message": "fix traversing via reversed edges.", "committedDate": "2020-06-03T04:13:01Z", "type": "commit"}, {"oid": "21fee62f00824547522524afe9d2d4d5971ac63a", "url": "https://github.com/osmlab/atlas-checks/commit/21fee62f00824547522524afe9d2d4d5971ac63a", "message": "fix traversing via reversed edges.", "committedDate": "2020-06-03T06:56:40Z", "type": "commit"}, {"oid": "ce96b000a0226a5932adb57b723be33a41bc6546", "url": "https://github.com/osmlab/atlas-checks/commit/ce96b000a0226a5932adb57b723be33a41bc6546", "message": "fix traversing via reversed edges.", "committedDate": "2020-06-03T13:51:26Z", "type": "commit"}, {"oid": "7901a0453dd3e746651b4a8f0f2d69bb96ab961c", "url": "https://github.com/osmlab/atlas-checks/commit/7901a0453dd3e746651b4a8f0f2d69bb96ab961c", "message": "adding original OSM identifier for convenient debugging", "committedDate": "2020-06-05T13:23:43Z", "type": "commit"}, {"oid": "02b050429d36316e5ed7107384b199c9253a5a89", "url": "https://github.com/osmlab/atlas-checks/commit/02b050429d36316e5ed7107384b199c9253a5a89", "message": "Atlas new check for roundabout missing tag", "committedDate": "2020-06-11T03:19:07Z", "type": "commit"}, {"oid": "f3a35accdc45e731dfaace84547f1979c4405389", "url": "https://github.com/osmlab/atlas-checks/commit/f3a35accdc45e731dfaace84547f1979c4405389", "message": "Atlas new check for roundabout missing tag", "committedDate": "2020-06-11T03:19:42Z", "type": "commit"}, {"oid": "4fd4a3691c04e644ba092a5df37ba4c4508362a1", "url": "https://github.com/osmlab/atlas-checks/commit/4fd4a3691c04e644ba092a5df37ba4c4508362a1", "message": "Fixed Style issues", "committedDate": "2020-06-11T22:12:24Z", "type": "commit"}, {"oid": "86cd14112b7d69f188ea86d4baf089ae026bc613", "url": "https://github.com/osmlab/atlas-checks/commit/86cd14112b7d69f188ea86d4baf089ae026bc613", "message": "Fixed Style issues", "committedDate": "2020-06-11T22:36:17Z", "type": "commit"}, {"oid": "3c9faa43c984dc79e3c56f87c53542845d0e10cf", "url": "https://github.com/osmlab/atlas-checks/commit/3c9faa43c984dc79e3c56f87c53542845d0e10cf", "message": "Fixed Style issues", "committedDate": "2020-06-11T22:50:59Z", "type": "commit"}, {"oid": "246c3afa7796336818fed345285f556b044e670c", "url": "https://github.com/osmlab/atlas-checks/commit/246c3afa7796336818fed345285f556b044e670c", "message": "Merge latest changes from dev branch. And enable default check run", "committedDate": "2020-06-11T23:17:07Z", "type": "commit"}, {"oid": "5f9b4059a680d537413d34776d5ddb9c9f2beb93", "url": "https://github.com/osmlab/atlas-checks/commit/5f9b4059a680d537413d34776d5ddb9c9f2beb93", "message": "Fixed Style issues", "committedDate": "2020-06-11T23:17:23Z", "type": "commit"}, {"oid": "84e3424cad4f01d9fd8e571f91a2bd9b07be5e6c", "url": "https://github.com/osmlab/atlas-checks/commit/84e3424cad4f01d9fd8e571f91a2bd9b07be5e6c", "message": "Fixed Style issues", "committedDate": "2020-06-11T23:33:28Z", "type": "commit"}, {"oid": "7f40781bfe1489ef9baa22c8ed6c7ef9984f4ac7", "url": "https://github.com/osmlab/atlas-checks/commit/7f40781bfe1489ef9baa22c8ed6c7ef9984f4ac7", "message": "Fixed spotless check", "committedDate": "2020-06-11T23:38:31Z", "type": "commit"}, {"oid": "79952e49aa546a26310d6b7cc37f0e0a942804e7", "url": "https://github.com/osmlab/atlas-checks/commit/79952e49aa546a26310d6b7cc37f0e0a942804e7", "message": "Fixed spotless check", "committedDate": "2020-06-11T23:38:59Z", "type": "commit"}, {"oid": "5932f3f7701686c0f7c21190ffa85476e22128e4", "url": "https://github.com/osmlab/atlas-checks/commit/5932f3f7701686c0f7c21190ffa85476e22128e4", "message": "merging if statements", "committedDate": "2020-06-11T23:56:34Z", "type": "commit"}, {"oid": "1fc2532275ecf7f6cfe20c6132a4b0e10f4836d6", "url": "https://github.com/osmlab/atlas-checks/commit/1fc2532275ecf7f6cfe20c6132a4b0e10f4836d6", "message": "adding more unit test coverage", "committedDate": "2020-06-12T00:55:47Z", "type": "commit"}, {"oid": "dc581db8fb866895854aa96e68c2af1183b9feea", "url": "https://github.com/osmlab/atlas-checks/commit/dc581db8fb866895854aa96e68c2af1183b9feea", "message": "adding more unit test coverage", "committedDate": "2020-06-12T01:00:02Z", "type": "commit"}, {"oid": "a38d21649ceab4c02b57b3d45dbd6d1ac49df566", "url": "https://github.com/osmlab/atlas-checks/commit/a38d21649ceab4c02b57b3d45dbd6d1ac49df566", "message": "minor correction", "committedDate": "2020-06-18T17:34:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUxNzY4Ng==", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r442517686", "bodyText": "Because you know you are dealing with the first edge section, you could just check that the in Edges contain an edge with the same OSM id. That would save you having to traverse along the whole Way.", "author": "Bentleysb", "createdAt": "2020-06-18T21:40:01Z", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/RoundaboutMissingTagCheck.java", "diffHunk": "@@ -0,0 +1,196 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.tags.AreaTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.ServiceTag;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.tuples.Tuple;\n+\n+/**\n+ * Flags edges that are closed shaped and have minimum of two intersections with navigable roads.\n+ * {@link RoundaboutMissingTagCheck#MINIMUM_INTERSECTION} connections. See\n+ * https://wiki.openstreetmap.org/wiki/Tag:junction%3Droundabout for more information about\n+ * roundabouts\n+ *\n+ * @author vladlemberg\n+ */\n+\n+public class RoundaboutMissingTagCheck extends BaseCheck<Long>\n+{\n+    // Instructions\n+    public static final String MISSING_JUNCTION_TAG_INSTRUCTION = \"This edge might be a roundabout\";\n+    // Minimum intersection with Navigable Roads\n+    private static final int MINIMUM_INTERSECTION = 2;\n+    private static final int MODULUS = 10;\n+    private static final int FIRST_EDGE_SECTION = 1;\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays\n+            .asList(MISSING_JUNCTION_TAG_INSTRUCTION);\n+    private static final double MAX_THRESHOLD_DEGREES_DEFAULT = 40.0;\n+    private static final double MIN_THRESHOLD_DEGREES_DEFAULT = 10.0;\n+    private final Angle maxAngleThreshold;\n+    private final Angle minAngleThreshold;\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public RoundaboutMissingTagCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.maxAngleThreshold = configurationValue(configuration, \"threshold.degrees\",\n+                MAX_THRESHOLD_DEGREES_DEFAULT, Angle::degrees);\n+        this.minAngleThreshold = configurationValue(configuration, \"threshold.degrees\",\n+                MIN_THRESHOLD_DEGREES_DEFAULT, Angle::degrees);\n+    }\n+\n+    /**\n+     * Validates if given {@link AtlasObject} is actually an {@link Edge} and is a potential\n+     * roundabout and also corresponding OSM identifier shouldn't be flagged before (this is for\n+     * avoiding duplicate flags)\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return object instanceof Edge && !this.isFlagged(object.getOsmIdentifier());\n+    }\n+\n+    /**\n+     * Flags an {@link Edge} is its circular shape and connected to at least\n+     * {@link RoundaboutMissingTagCheck#MINIMUM_INTERSECTION} navigable roads. {@link Edge} doesn't\n+     * have junction=roundabout or area=yes tags.\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edge = (Edge) object;\n+\n+        // process only first sectioned Edge\n+        if (edge.getIdentifier() % MODULUS == FIRST_EDGE_SECTION && edge.isMasterEdge()\n+                && HighwayTag.isCarNavigableHighway(edge) && edge.getTag(JunctionTag.KEY).isEmpty()\n+                && edge.getTag(AreaTag.KEY).isEmpty() && isPartOfClosedWay(edge)\n+                && intersectingWithMoreThan(edge))\n+        {\n+            // rebuild original OSM Way geometry\n+            final PolyLine originalGeom = buildOriginalOsmWayGeometry(edge);\n+            // check maximum angle\n+            final List<Tuple<Angle, Location>> maxOffendingAngles = originalGeom\n+                    .anglesGreaterThanOrEqualTo(this.maxAngleThreshold);\n+            // check minimum angle\n+            final List<Tuple<Angle, Location>> minOffendingAngles = originalGeom\n+                    .anglesLessThanOrEqualTo(this.minAngleThreshold);\n+\n+            if (maxOffendingAngles.isEmpty() && minOffendingAngles.isEmpty())\n+            {\n+                this.markAsFlagged(object.getOsmIdentifier());\n+                return Optional.of(createFlag(new OsmWayWalker(edge).collectEdges(),\n+                        this.getLocalizedInstruction(0)));\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Build original OSW way geometry from all MasterEdge sections\n+     *\n+     * @param edge\n+     *            entity to check\n+     * @return original Way geometry polyline\n+     */\n+    private PolyLine buildOriginalOsmWayGeometry(final Edge edge)\n+    {\n+        // Identify all sections of original OSM way\n+        final Set<Edge> edgesFormingOSMWay = new OsmWayWalker(edge).collectEdges().stream()\n+                .filter(Edge::isMasterEdge).collect(Collectors.toSet());\n+\n+        // Sort sectioned Edges by Ids\n+        final List<Edge> sortedEdges = new ArrayList<>(edgesFormingOSMWay);\n+        sortedEdges.sort(Comparator.comparingLong(AtlasObject::getIdentifier));\n+\n+        // Build original OSM polyline\n+        PolyLine geometry = new PolyLine(sortedEdges.get(0).getRawGeometry());\n+        for (int i = 1; i < sortedEdges.size(); i++)\n+        {\n+            geometry = geometry.append(sortedEdges.get(i).asPolyLine());\n+        }\n+        return geometry;\n+    }\n+\n+    /**\n+     * Check if original OSM Way is intersecting with CAR_NAVIGABLE_HIGHWAYS. See {@link HighwayTag}\n+     *\n+     * @param edge\n+     *            entity to check\n+     * @return true if way intersecting with more more than\n+     *         {@link RoundaboutMissingTagCheck#MINIMUM_INTERSECTION}\n+     */\n+    private boolean intersectingWithMoreThan(final Edge edge)\n+    {\n+        // Identify all sections of original OSM way\n+        final Set<Edge> edgesFormingOSMWay = new OsmWayWalker(edge).collectEdges().stream()\n+                .filter(Edge::isMasterEdge).collect(Collectors.toSet());\n+        final Set<Long> connectedEdges = new HashSet<>();\n+        edgesFormingOSMWay.forEach(obj -> obj.connectedEdges().stream().filter(Edge::isMasterEdge)\n+                // intersection with navigable roads\n+                .filter(HighwayTag::isCarNavigableHighway)\n+                .filter(e -> e.getTag(ServiceTag.KEY).isEmpty())\n+                // de-duplication sectioned edges\n+                .forEach(wayId -> connectedEdges.add(wayId.getOsmIdentifier())));\n+        return connectedEdges.size() > MINIMUM_INTERSECTION;\n+    }\n+\n+    /**\n+     * Check if Edge is part of Closed Way. See https://wiki.openstreetmap.org/wiki/Item:Q4669\n+     *\n+     * @param edge\n+     *            entity to check\n+     * @return true if edge is part of closed way.\n+     */\n+    private boolean isPartOfClosedWay(final Edge edge)\n+    {\n+        final HashSet<Long> wayIds = new HashSet<>();\n+        Edge nextEdge = edge;\n+        // Loop through out going edges with the same OSM id\n+        while (nextEdge != null)\n+        {\n+            wayIds.add(nextEdge.getIdentifier());\n+            final List<Edge> nextEdgeList = Iterables.stream(nextEdge.outEdges())\n+                    .filter(Edge::isMasterEdge)\n+                    .filter(outEdge -> outEdge.getOsmIdentifier() == edge.getOsmIdentifier())\n+                    .collectToList();\n+            nextEdge = nextEdgeList.isEmpty() ? null : nextEdgeList.get(0);\n+            // If original edge is found, the way is closed\n+            if (nextEdge != null && wayIds.contains(nextEdge.getIdentifier()))", "originalCommit": "a38d21649ceab4c02b57b3d45dbd6d1ac49df566", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU3MTY0Nw==", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r442571647", "bodyText": "Thanks for suggestion!", "author": "vladlemberg", "createdAt": "2020-06-19T00:36:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUxNzY4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk1MDY5NA==", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r442950694", "bodyText": "In this case every way will be closedWay. Instead of \"contain\" we need:\nreturn Edges.get(0).start().getLocation().equals(Edges.get(Edges.size()-1).end().getLocation());\nit slower than Edge Walker.", "author": "vladlemberg", "createdAt": "2020-06-19T16:59:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUxNzY4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDM1ODQ2Nw==", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r444358467", "bodyText": "What about using edge.inEdges().stream().filter(e -> e.getOsmIdentifier() == edge.getOsmIdentifier()).count() == 1?", "author": "Bentleysb", "createdAt": "2020-06-23T16:36:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUxNzY4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ1OTY4OQ==", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r444459689", "bodyText": "slick suggestion! need to add our favorite .filter(Edge::isMasterEdge) to make it complete. thanks a lot!!", "author": "vladlemberg", "createdAt": "2020-06-23T19:33:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUxNzY4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUxOTA5Mw==", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r442519093", "bodyText": "You use the way walker 3 times to collect the entire way (here, in buildOriginalOsmWayGeometry, and in intersectingWithMoreThan). While this is not a super expensive function, its repeated use can add up. It might be a bit better to call it once and then pass the edge set to each of the places that need it.", "author": "Bentleysb", "createdAt": "2020-06-18T21:43:28Z", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/RoundaboutMissingTagCheck.java", "diffHunk": "@@ -0,0 +1,196 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.tags.AreaTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.ServiceTag;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.tuples.Tuple;\n+\n+/**\n+ * Flags edges that are closed shaped and have minimum of two intersections with navigable roads.\n+ * {@link RoundaboutMissingTagCheck#MINIMUM_INTERSECTION} connections. See\n+ * https://wiki.openstreetmap.org/wiki/Tag:junction%3Droundabout for more information about\n+ * roundabouts\n+ *\n+ * @author vladlemberg\n+ */\n+\n+public class RoundaboutMissingTagCheck extends BaseCheck<Long>\n+{\n+    // Instructions\n+    public static final String MISSING_JUNCTION_TAG_INSTRUCTION = \"This edge might be a roundabout\";\n+    // Minimum intersection with Navigable Roads\n+    private static final int MINIMUM_INTERSECTION = 2;\n+    private static final int MODULUS = 10;\n+    private static final int FIRST_EDGE_SECTION = 1;\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays\n+            .asList(MISSING_JUNCTION_TAG_INSTRUCTION);\n+    private static final double MAX_THRESHOLD_DEGREES_DEFAULT = 40.0;\n+    private static final double MIN_THRESHOLD_DEGREES_DEFAULT = 10.0;\n+    private final Angle maxAngleThreshold;\n+    private final Angle minAngleThreshold;\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public RoundaboutMissingTagCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.maxAngleThreshold = configurationValue(configuration, \"threshold.degrees\",\n+                MAX_THRESHOLD_DEGREES_DEFAULT, Angle::degrees);\n+        this.minAngleThreshold = configurationValue(configuration, \"threshold.degrees\",\n+                MIN_THRESHOLD_DEGREES_DEFAULT, Angle::degrees);\n+    }\n+\n+    /**\n+     * Validates if given {@link AtlasObject} is actually an {@link Edge} and is a potential\n+     * roundabout and also corresponding OSM identifier shouldn't be flagged before (this is for\n+     * avoiding duplicate flags)\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return object instanceof Edge && !this.isFlagged(object.getOsmIdentifier());\n+    }\n+\n+    /**\n+     * Flags an {@link Edge} is its circular shape and connected to at least\n+     * {@link RoundaboutMissingTagCheck#MINIMUM_INTERSECTION} navigable roads. {@link Edge} doesn't\n+     * have junction=roundabout or area=yes tags.\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edge = (Edge) object;\n+\n+        // process only first sectioned Edge\n+        if (edge.getIdentifier() % MODULUS == FIRST_EDGE_SECTION && edge.isMasterEdge()\n+                && HighwayTag.isCarNavigableHighway(edge) && edge.getTag(JunctionTag.KEY).isEmpty()\n+                && edge.getTag(AreaTag.KEY).isEmpty() && isPartOfClosedWay(edge)\n+                && intersectingWithMoreThan(edge))\n+        {\n+            // rebuild original OSM Way geometry\n+            final PolyLine originalGeom = buildOriginalOsmWayGeometry(edge);\n+            // check maximum angle\n+            final List<Tuple<Angle, Location>> maxOffendingAngles = originalGeom\n+                    .anglesGreaterThanOrEqualTo(this.maxAngleThreshold);\n+            // check minimum angle\n+            final List<Tuple<Angle, Location>> minOffendingAngles = originalGeom\n+                    .anglesLessThanOrEqualTo(this.minAngleThreshold);\n+\n+            if (maxOffendingAngles.isEmpty() && minOffendingAngles.isEmpty())\n+            {\n+                this.markAsFlagged(object.getOsmIdentifier());\n+                return Optional.of(createFlag(new OsmWayWalker(edge).collectEdges(),", "originalCommit": "a38d21649ceab4c02b57b3d45dbd6d1ac49df566", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUzMTcwOA==", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r442531708", "bodyText": "Thanks for suggestion!", "author": "vladlemberg", "createdAt": "2020-06-18T22:16:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUxOTA5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk0NjIyNg==", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r442946226", "bodyText": "compilation time. tested against China data on local:\n1 - use WayWalker in each method - 7,48 min (current)\n2 - call WayWalker only ones and pass Set Edges to every method - 9,64 min\n3 - make Set Edges static - 8,50 minutes.", "author": "vladlemberg", "createdAt": "2020-06-19T16:48:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUxOTA5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUxOTIzMw==", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r442519233", "bodyText": "Why is this being added?", "author": "Bentleysb", "createdAt": "2020-06-18T21:43:49Z", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/OverlappingEdgeCheck.java", "diffHunk": "@@ -184,6 +184,7 @@ private boolean isPartOfClosedWay(final Edge object)\n         {\n             wayIds.add(nextEdge.getIdentifier());\n             final List<Edge> nextEdgeList = Iterables.stream(nextEdge.outEdges())\n+                    .filter(Edge::isMasterEdge)", "originalCommit": "a38d21649ceab4c02b57b3d45dbd6d1ac49df566", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUzMDEwMA==", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r442530100", "bodyText": "its a bug. please refer #302.", "author": "vladlemberg", "createdAt": "2020-06-18T22:11:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUxOTIzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDM1NTM1Ng==", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r444355356", "bodyText": "For tracking purposes, I think this would be better in a separate PR.", "author": "Bentleysb", "createdAt": "2020-06-23T16:31:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUxOTIzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ5NDUyNw==", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r444494527", "bodyText": "@Bentleysb This one has also been added. I think the branch is out of date with the dev branch.", "author": "sayas01", "createdAt": "2020-06-23T20:42:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUxOTIzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ5NTkxOQ==", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r444495919", "bodyText": "@Bentleysb This has also been added in a prev PR. I think this branch is out of date with the dev branch.", "author": "sayas01", "createdAt": "2020-06-23T20:45:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUxOTIzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUxOTUxNw==", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r442519517", "bodyText": "Is there a reason for this change? It appears to be redundant as the atlas identifier already contains the OSM id.", "author": "Bentleysb", "createdAt": "2020-06-18T21:44:34Z", "path": "src/main/java/org/openstreetmap/atlas/checks/base/BaseCheck.java", "diffHunk": "@@ -128,8 +128,8 @@ public BaseCheck(final Configuration configuration)\n         }\n         catch (final Exception oops)\n         {\n-            logger.error(String.format(\"%s failed on feature %s.\", this.getCheckName(),\n-                    object.getIdentifier()), oops);\n+            logger.error(String.format(\"%s failed on feature %s (%s).\", this.getCheckName(),\n+                    object.getIdentifier(), object.getOsmIdentifier()), oops);", "originalCommit": "a38d21649ceab4c02b57b3d45dbd6d1ac49df566", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUyNTM2OQ==", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r442525369", "bodyText": "yes. for debugging purpose its very convenient to copy original OSM id instead of playing with sectioned id in cases where original ID ends with 0 or small.", "author": "vladlemberg", "createdAt": "2020-06-18T21:59:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUxOTUxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ5MDQ4Nw==", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r444490487", "bodyText": "@Bentleysb this change was integrated in https://github.com/osmlab/atlas-checks/pull/305/files", "author": "sayas01", "createdAt": "2020-06-23T20:34:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUxOTUxNw=="}], "type": "inlineReview"}, {"oid": "06a360af1a7c0405b142aa62cc801835279fa722", "url": "https://github.com/osmlab/atlas-checks/commit/06a360af1a7c0405b142aa62cc801835279fa722", "message": "add MD doc file and check description in available checks.", "committedDate": "2020-06-23T01:03:42Z", "type": "commit"}, {"oid": "25018e1f85a92876ce0eb774b6f570bec4dc3fa9", "url": "https://github.com/osmlab/atlas-checks/commit/25018e1f85a92876ce0eb774b6f570bec4dc3fa9", "message": "fix style issue", "committedDate": "2020-06-23T01:15:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ5NTQ3Ng==", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r444495476", "bodyText": "Could you update this description to include \"missing junction=roundabout\" ?", "author": "sayas01", "createdAt": "2020-06-23T20:44:15Z", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/RoundaboutMissingTagCheck.java", "diffHunk": "@@ -0,0 +1,193 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.tags.AreaTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.ServiceTag;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.tuples.Tuple;\n+\n+/**\n+ * Flags edges that are closed shaped and have minimum of two intersections with navigable roads.", "originalCommit": "25018e1f85a92876ce0eb774b6f570bec4dc3fa9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU1OTU2Ng==", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r444559566", "bodyText": "thanks! added.", "author": "vladlemberg", "createdAt": "2020-06-23T23:18:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ5NTQ3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ5Njc2Ng==", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r444496766", "bodyText": "nit: asList could be replaced with Collections.singletonList as it has just one item in it.", "author": "sayas01", "createdAt": "2020-06-23T20:46:49Z", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/RoundaboutMissingTagCheck.java", "diffHunk": "@@ -0,0 +1,193 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.tags.AreaTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.ServiceTag;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.tuples.Tuple;\n+\n+/**\n+ * Flags edges that are closed shaped and have minimum of two intersections with navigable roads.\n+ * {@link RoundaboutMissingTagCheck#MINIMUM_INTERSECTION} connections. See\n+ * https://wiki.openstreetmap.org/wiki/Tag:junction%3Droundabout for more information about\n+ * roundabouts\n+ *\n+ * @author vladlemberg\n+ */\n+\n+public class RoundaboutMissingTagCheck extends BaseCheck<Long>\n+{\n+    // Instructions\n+    public static final String MISSING_JUNCTION_TAG_INSTRUCTION = \"This edge might be a roundabout\";\n+    // Minimum intersection with Navigable Roads\n+    private static final int MINIMUM_INTERSECTION = 2;\n+    private static final int MODULUS = 10;\n+    private static final int FIRST_EDGE_SECTION = 1;\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays\n+            .asList(MISSING_JUNCTION_TAG_INSTRUCTION);", "originalCommit": "25018e1f85a92876ce0eb774b6f570bec4dc3fa9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ5OTIyNg==", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r444499226", "bodyText": "Shouldn't there be two separate config keys, \"threshold.degrees.maximum\" and \"threshold.degrees.minimum\" ?", "author": "sayas01", "createdAt": "2020-06-23T20:51:33Z", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/RoundaboutMissingTagCheck.java", "diffHunk": "@@ -0,0 +1,193 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.tags.AreaTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.ServiceTag;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.tuples.Tuple;\n+\n+/**\n+ * Flags edges that are closed shaped and have minimum of two intersections with navigable roads.\n+ * {@link RoundaboutMissingTagCheck#MINIMUM_INTERSECTION} connections. See\n+ * https://wiki.openstreetmap.org/wiki/Tag:junction%3Droundabout for more information about\n+ * roundabouts\n+ *\n+ * @author vladlemberg\n+ */\n+\n+public class RoundaboutMissingTagCheck extends BaseCheck<Long>\n+{\n+    // Instructions\n+    public static final String MISSING_JUNCTION_TAG_INSTRUCTION = \"This edge might be a roundabout\";\n+    // Minimum intersection with Navigable Roads\n+    private static final int MINIMUM_INTERSECTION = 2;\n+    private static final int MODULUS = 10;\n+    private static final int FIRST_EDGE_SECTION = 1;\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays\n+            .asList(MISSING_JUNCTION_TAG_INSTRUCTION);\n+    private static final double MAX_THRESHOLD_DEGREES_DEFAULT = 40.0;\n+    private static final double MIN_THRESHOLD_DEGREES_DEFAULT = 10.0;\n+    private final Angle maxAngleThreshold;\n+    private final Angle minAngleThreshold;\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public RoundaboutMissingTagCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.maxAngleThreshold = configurationValue(configuration, \"threshold.degrees\",\n+                MAX_THRESHOLD_DEGREES_DEFAULT, Angle::degrees);\n+        this.minAngleThreshold = configurationValue(configuration, \"threshold.degrees\",\n+                MIN_THRESHOLD_DEGREES_DEFAULT, Angle::degrees);", "originalCommit": "25018e1f85a92876ce0eb774b6f570bec4dc3fa9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU2OTA4OA==", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r444569088", "bodyText": "added", "author": "vladlemberg", "createdAt": "2020-06-23T23:51:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ5OTIyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDUwNzM4Ng==", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r444507386", "bodyText": "nit: these could be combined to one statement  new OsmWayWalker(edge).collectEdges().stream() .filter(Edge::isMasterEdge).distinct() .sorted(Comparator.comparingLong(AtlasObject::getIdentifier)) .collect(Collectors.toList());", "author": "sayas01", "createdAt": "2020-06-23T21:03:46Z", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/RoundaboutMissingTagCheck.java", "diffHunk": "@@ -0,0 +1,193 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.tags.AreaTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.ServiceTag;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.tuples.Tuple;\n+\n+/**\n+ * Flags edges that are closed shaped and have minimum of two intersections with navigable roads.\n+ * {@link RoundaboutMissingTagCheck#MINIMUM_INTERSECTION} connections. See\n+ * https://wiki.openstreetmap.org/wiki/Tag:junction%3Droundabout for more information about\n+ * roundabouts\n+ *\n+ * @author vladlemberg\n+ */\n+\n+public class RoundaboutMissingTagCheck extends BaseCheck<Long>\n+{\n+    // Instructions\n+    public static final String MISSING_JUNCTION_TAG_INSTRUCTION = \"This edge might be a roundabout\";\n+    // Minimum intersection with Navigable Roads\n+    private static final int MINIMUM_INTERSECTION = 2;\n+    private static final int MODULUS = 10;\n+    private static final int FIRST_EDGE_SECTION = 1;\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays\n+            .asList(MISSING_JUNCTION_TAG_INSTRUCTION);\n+    private static final double MAX_THRESHOLD_DEGREES_DEFAULT = 40.0;\n+    private static final double MIN_THRESHOLD_DEGREES_DEFAULT = 10.0;\n+    private final Angle maxAngleThreshold;\n+    private final Angle minAngleThreshold;\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public RoundaboutMissingTagCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.maxAngleThreshold = configurationValue(configuration, \"threshold.degrees\",\n+                MAX_THRESHOLD_DEGREES_DEFAULT, Angle::degrees);\n+        this.minAngleThreshold = configurationValue(configuration, \"threshold.degrees\",\n+                MIN_THRESHOLD_DEGREES_DEFAULT, Angle::degrees);\n+    }\n+\n+    /**\n+     * Validates if given {@link AtlasObject} is actually an {@link Edge} and is a potential\n+     * roundabout and also corresponding OSM identifier shouldn't be flagged before (this is for\n+     * avoiding duplicate flags)\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return object instanceof Edge && !this.isFlagged(object.getOsmIdentifier())\n+                && object.getIdentifier() % MODULUS == FIRST_EDGE_SECTION\n+                && ((Edge) object).isMasterEdge() && HighwayTag.isCarNavigableHighway(object)\n+                && object.getTag(JunctionTag.KEY).isEmpty() && object.getTag(AreaTag.KEY).isEmpty()\n+                && isPartOfClosedWay((Edge) object) && intersectingWithMoreThan((Edge) object);\n+    }\n+\n+    /**\n+     * Flags an {@link Edge} is its circular shape and connected to at least\n+     * {@link RoundaboutMissingTagCheck#MINIMUM_INTERSECTION} navigable roads. {@link Edge} doesn't\n+     * have junction=roundabout or area=yes tags.\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edge = (Edge) object;\n+\n+        final PolyLine originalGeom = buildOriginalOsmWayGeometry(edge);\n+        // check maximum angle\n+        final List<Tuple<Angle, Location>> maxOffendingAngles = originalGeom\n+                .anglesGreaterThanOrEqualTo(this.maxAngleThreshold);\n+        // check minimum angle\n+        final List<Tuple<Angle, Location>> minOffendingAngles = originalGeom\n+                .anglesLessThanOrEqualTo(this.minAngleThreshold);\n+\n+        if (maxOffendingAngles.isEmpty() && minOffendingAngles.isEmpty())\n+        {\n+            this.markAsFlagged(object.getOsmIdentifier());\n+            return Optional.of(createFlag(new OsmWayWalker(edge).collectEdges(),\n+                    this.getLocalizedInstruction(0)));\n+        }\n+\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Build original OSW way geometry from all MasterEdge sections\n+     *\n+     * @param edge\n+     *            entity to check\n+     * @return original Way geometry polyline\n+     */\n+    private PolyLine buildOriginalOsmWayGeometry(final Edge edge)\n+    {\n+        // Identify all sections of original OSM way\n+        final Set<Edge> edgesFormingOSMWay = new OsmWayWalker(edge).collectEdges().stream()\n+                .filter(Edge::isMasterEdge).collect(Collectors.toSet());\n+\n+        // Sort sectioned Edges by Ids\n+        final List<Edge> sortedEdges = new ArrayList<>(edgesFormingOSMWay);\n+        sortedEdges.sort(Comparator.comparingLong(AtlasObject::getIdentifier));", "originalCommit": "25018e1f85a92876ce0eb774b6f570bec4dc3fa9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDUwODQwMw==", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r444508403", "bodyText": "Please avoid single letter variable names.", "author": "sayas01", "createdAt": "2020-06-23T21:05:52Z", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/RoundaboutMissingTagCheck.java", "diffHunk": "@@ -0,0 +1,193 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.tags.AreaTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.ServiceTag;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.tuples.Tuple;\n+\n+/**\n+ * Flags edges that are closed shaped and have minimum of two intersections with navigable roads.\n+ * {@link RoundaboutMissingTagCheck#MINIMUM_INTERSECTION} connections. See\n+ * https://wiki.openstreetmap.org/wiki/Tag:junction%3Droundabout for more information about\n+ * roundabouts\n+ *\n+ * @author vladlemberg\n+ */\n+\n+public class RoundaboutMissingTagCheck extends BaseCheck<Long>\n+{\n+    // Instructions\n+    public static final String MISSING_JUNCTION_TAG_INSTRUCTION = \"This edge might be a roundabout\";\n+    // Minimum intersection with Navigable Roads\n+    private static final int MINIMUM_INTERSECTION = 2;\n+    private static final int MODULUS = 10;\n+    private static final int FIRST_EDGE_SECTION = 1;\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays\n+            .asList(MISSING_JUNCTION_TAG_INSTRUCTION);\n+    private static final double MAX_THRESHOLD_DEGREES_DEFAULT = 40.0;\n+    private static final double MIN_THRESHOLD_DEGREES_DEFAULT = 10.0;\n+    private final Angle maxAngleThreshold;\n+    private final Angle minAngleThreshold;\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public RoundaboutMissingTagCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.maxAngleThreshold = configurationValue(configuration, \"threshold.degrees\",\n+                MAX_THRESHOLD_DEGREES_DEFAULT, Angle::degrees);\n+        this.minAngleThreshold = configurationValue(configuration, \"threshold.degrees\",\n+                MIN_THRESHOLD_DEGREES_DEFAULT, Angle::degrees);\n+    }\n+\n+    /**\n+     * Validates if given {@link AtlasObject} is actually an {@link Edge} and is a potential\n+     * roundabout and also corresponding OSM identifier shouldn't be flagged before (this is for\n+     * avoiding duplicate flags)\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return object instanceof Edge && !this.isFlagged(object.getOsmIdentifier())\n+                && object.getIdentifier() % MODULUS == FIRST_EDGE_SECTION\n+                && ((Edge) object).isMasterEdge() && HighwayTag.isCarNavigableHighway(object)\n+                && object.getTag(JunctionTag.KEY).isEmpty() && object.getTag(AreaTag.KEY).isEmpty()\n+                && isPartOfClosedWay((Edge) object) && intersectingWithMoreThan((Edge) object);\n+    }\n+\n+    /**\n+     * Flags an {@link Edge} is its circular shape and connected to at least\n+     * {@link RoundaboutMissingTagCheck#MINIMUM_INTERSECTION} navigable roads. {@link Edge} doesn't\n+     * have junction=roundabout or area=yes tags.\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edge = (Edge) object;\n+\n+        final PolyLine originalGeom = buildOriginalOsmWayGeometry(edge);\n+        // check maximum angle\n+        final List<Tuple<Angle, Location>> maxOffendingAngles = originalGeom\n+                .anglesGreaterThanOrEqualTo(this.maxAngleThreshold);\n+        // check minimum angle\n+        final List<Tuple<Angle, Location>> minOffendingAngles = originalGeom\n+                .anglesLessThanOrEqualTo(this.minAngleThreshold);\n+\n+        if (maxOffendingAngles.isEmpty() && minOffendingAngles.isEmpty())\n+        {\n+            this.markAsFlagged(object.getOsmIdentifier());\n+            return Optional.of(createFlag(new OsmWayWalker(edge).collectEdges(),\n+                    this.getLocalizedInstruction(0)));\n+        }\n+\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Build original OSW way geometry from all MasterEdge sections\n+     *\n+     * @param edge\n+     *            entity to check\n+     * @return original Way geometry polyline\n+     */\n+    private PolyLine buildOriginalOsmWayGeometry(final Edge edge)\n+    {\n+        // Identify all sections of original OSM way\n+        final Set<Edge> edgesFormingOSMWay = new OsmWayWalker(edge).collectEdges().stream()\n+                .filter(Edge::isMasterEdge).collect(Collectors.toSet());\n+\n+        // Sort sectioned Edges by Ids\n+        final List<Edge> sortedEdges = new ArrayList<>(edgesFormingOSMWay);\n+        sortedEdges.sort(Comparator.comparingLong(AtlasObject::getIdentifier));\n+\n+        // Build original OSM polyline\n+        PolyLine geometry = new PolyLine(sortedEdges.get(0).getRawGeometry());\n+        for (int i = 1; i < sortedEdges.size(); i++)", "originalCommit": "25018e1f85a92876ce0eb774b6f570bec4dc3fa9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDUxMDYyNg==", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r444510626", "bodyText": "Same as my prev comment. .filter(edge -> edge.getTag(ServiceTag.KEY).isEmpty())", "author": "sayas01", "createdAt": "2020-06-23T21:10:25Z", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/RoundaboutMissingTagCheck.java", "diffHunk": "@@ -0,0 +1,193 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.tags.AreaTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.ServiceTag;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.tuples.Tuple;\n+\n+/**\n+ * Flags edges that are closed shaped and have minimum of two intersections with navigable roads.\n+ * {@link RoundaboutMissingTagCheck#MINIMUM_INTERSECTION} connections. See\n+ * https://wiki.openstreetmap.org/wiki/Tag:junction%3Droundabout for more information about\n+ * roundabouts\n+ *\n+ * @author vladlemberg\n+ */\n+\n+public class RoundaboutMissingTagCheck extends BaseCheck<Long>\n+{\n+    // Instructions\n+    public static final String MISSING_JUNCTION_TAG_INSTRUCTION = \"This edge might be a roundabout\";\n+    // Minimum intersection with Navigable Roads\n+    private static final int MINIMUM_INTERSECTION = 2;\n+    private static final int MODULUS = 10;\n+    private static final int FIRST_EDGE_SECTION = 1;\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays\n+            .asList(MISSING_JUNCTION_TAG_INSTRUCTION);\n+    private static final double MAX_THRESHOLD_DEGREES_DEFAULT = 40.0;\n+    private static final double MIN_THRESHOLD_DEGREES_DEFAULT = 10.0;\n+    private final Angle maxAngleThreshold;\n+    private final Angle minAngleThreshold;\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public RoundaboutMissingTagCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.maxAngleThreshold = configurationValue(configuration, \"threshold.degrees\",\n+                MAX_THRESHOLD_DEGREES_DEFAULT, Angle::degrees);\n+        this.minAngleThreshold = configurationValue(configuration, \"threshold.degrees\",\n+                MIN_THRESHOLD_DEGREES_DEFAULT, Angle::degrees);\n+    }\n+\n+    /**\n+     * Validates if given {@link AtlasObject} is actually an {@link Edge} and is a potential\n+     * roundabout and also corresponding OSM identifier shouldn't be flagged before (this is for\n+     * avoiding duplicate flags)\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return object instanceof Edge && !this.isFlagged(object.getOsmIdentifier())\n+                && object.getIdentifier() % MODULUS == FIRST_EDGE_SECTION\n+                && ((Edge) object).isMasterEdge() && HighwayTag.isCarNavigableHighway(object)\n+                && object.getTag(JunctionTag.KEY).isEmpty() && object.getTag(AreaTag.KEY).isEmpty()\n+                && isPartOfClosedWay((Edge) object) && intersectingWithMoreThan((Edge) object);\n+    }\n+\n+    /**\n+     * Flags an {@link Edge} is its circular shape and connected to at least\n+     * {@link RoundaboutMissingTagCheck#MINIMUM_INTERSECTION} navigable roads. {@link Edge} doesn't\n+     * have junction=roundabout or area=yes tags.\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edge = (Edge) object;\n+\n+        final PolyLine originalGeom = buildOriginalOsmWayGeometry(edge);\n+        // check maximum angle\n+        final List<Tuple<Angle, Location>> maxOffendingAngles = originalGeom\n+                .anglesGreaterThanOrEqualTo(this.maxAngleThreshold);\n+        // check minimum angle\n+        final List<Tuple<Angle, Location>> minOffendingAngles = originalGeom\n+                .anglesLessThanOrEqualTo(this.minAngleThreshold);\n+\n+        if (maxOffendingAngles.isEmpty() && minOffendingAngles.isEmpty())\n+        {\n+            this.markAsFlagged(object.getOsmIdentifier());\n+            return Optional.of(createFlag(new OsmWayWalker(edge).collectEdges(),\n+                    this.getLocalizedInstruction(0)));\n+        }\n+\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Build original OSW way geometry from all MasterEdge sections\n+     *\n+     * @param edge\n+     *            entity to check\n+     * @return original Way geometry polyline\n+     */\n+    private PolyLine buildOriginalOsmWayGeometry(final Edge edge)\n+    {\n+        // Identify all sections of original OSM way\n+        final Set<Edge> edgesFormingOSMWay = new OsmWayWalker(edge).collectEdges().stream()\n+                .filter(Edge::isMasterEdge).collect(Collectors.toSet());\n+\n+        // Sort sectioned Edges by Ids\n+        final List<Edge> sortedEdges = new ArrayList<>(edgesFormingOSMWay);\n+        sortedEdges.sort(Comparator.comparingLong(AtlasObject::getIdentifier));\n+\n+        // Build original OSM polyline\n+        PolyLine geometry = new PolyLine(sortedEdges.get(0).getRawGeometry());\n+        for (int i = 1; i < sortedEdges.size(); i++)\n+        {\n+            geometry = geometry.append(sortedEdges.get(i).asPolyLine());\n+        }\n+        return geometry;\n+    }\n+\n+    /**\n+     * Check if original OSM Way is intersecting with CAR_NAVIGABLE_HIGHWAYS. See {@link HighwayTag}\n+     *\n+     * @param edge\n+     *            entity to check\n+     * @return true if way intersecting with more more than\n+     *         {@link RoundaboutMissingTagCheck#MINIMUM_INTERSECTION}\n+     */\n+    private boolean intersectingWithMoreThan(final Edge edge)\n+    {\n+        // Identify all sections of original OSM way\n+        final Set<Edge> edgesFormingOSMWay = new OsmWayWalker(edge).collectEdges().stream()\n+                .filter(Edge::isMasterEdge).collect(Collectors.toSet());\n+        final Set<Long> connectedEdges = new HashSet<>();\n+        edgesFormingOSMWay.forEach(obj -> obj.connectedEdges().stream().filter(Edge::isMasterEdge)\n+                // intersection with navigable roads\n+                .filter(HighwayTag::isCarNavigableHighway)\n+                .filter(e -> e.getTag(ServiceTag.KEY).isEmpty())", "originalCommit": "25018e1f85a92876ce0eb774b6f570bec4dc3fa9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ5OTQ1MQ==", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r444499451", "bodyText": "Nice. Unrelated to this PR, I think we should update ReverseIdentifierFactory.getWaySectionIndex(atlas id) for this as it seems to be gaining popularity", "author": "seancoulter", "createdAt": "2020-06-23T20:51:58Z", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/RoundaboutMissingTagCheck.java", "diffHunk": "@@ -0,0 +1,193 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.tags.AreaTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.ServiceTag;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.tuples.Tuple;\n+\n+/**\n+ * Flags edges that are closed shaped and have minimum of two intersections with navigable roads.\n+ * {@link RoundaboutMissingTagCheck#MINIMUM_INTERSECTION} connections. See\n+ * https://wiki.openstreetmap.org/wiki/Tag:junction%3Droundabout for more information about\n+ * roundabouts\n+ *\n+ * @author vladlemberg\n+ */\n+\n+public class RoundaboutMissingTagCheck extends BaseCheck<Long>\n+{\n+    // Instructions\n+    public static final String MISSING_JUNCTION_TAG_INSTRUCTION = \"This edge might be a roundabout\";\n+    // Minimum intersection with Navigable Roads\n+    private static final int MINIMUM_INTERSECTION = 2;\n+    private static final int MODULUS = 10;\n+    private static final int FIRST_EDGE_SECTION = 1;\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays\n+            .asList(MISSING_JUNCTION_TAG_INSTRUCTION);\n+    private static final double MAX_THRESHOLD_DEGREES_DEFAULT = 40.0;\n+    private static final double MIN_THRESHOLD_DEGREES_DEFAULT = 10.0;\n+    private final Angle maxAngleThreshold;\n+    private final Angle minAngleThreshold;\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public RoundaboutMissingTagCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.maxAngleThreshold = configurationValue(configuration, \"threshold.degrees\",\n+                MAX_THRESHOLD_DEGREES_DEFAULT, Angle::degrees);\n+        this.minAngleThreshold = configurationValue(configuration, \"threshold.degrees\",\n+                MIN_THRESHOLD_DEGREES_DEFAULT, Angle::degrees);\n+    }\n+\n+    /**\n+     * Validates if given {@link AtlasObject} is actually an {@link Edge} and is a potential\n+     * roundabout and also corresponding OSM identifier shouldn't be flagged before (this is for\n+     * avoiding duplicate flags)\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return object instanceof Edge && !this.isFlagged(object.getOsmIdentifier())\n+                && object.getIdentifier() % MODULUS == FIRST_EDGE_SECTION", "originalCommit": "25018e1f85a92876ce0eb774b6f570bec4dc3fa9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDUwMjQ0MA==", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r444502440", "bodyText": "OSM Way walker should give you master edges by default, so no need to filter", "author": "seancoulter", "createdAt": "2020-06-23T20:55:18Z", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/RoundaboutMissingTagCheck.java", "diffHunk": "@@ -0,0 +1,193 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.tags.AreaTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.ServiceTag;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.tuples.Tuple;\n+\n+/**\n+ * Flags edges that are closed shaped and have minimum of two intersections with navigable roads.\n+ * {@link RoundaboutMissingTagCheck#MINIMUM_INTERSECTION} connections. See\n+ * https://wiki.openstreetmap.org/wiki/Tag:junction%3Droundabout for more information about\n+ * roundabouts\n+ *\n+ * @author vladlemberg\n+ */\n+\n+public class RoundaboutMissingTagCheck extends BaseCheck<Long>\n+{\n+    // Instructions\n+    public static final String MISSING_JUNCTION_TAG_INSTRUCTION = \"This edge might be a roundabout\";\n+    // Minimum intersection with Navigable Roads\n+    private static final int MINIMUM_INTERSECTION = 2;\n+    private static final int MODULUS = 10;\n+    private static final int FIRST_EDGE_SECTION = 1;\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays\n+            .asList(MISSING_JUNCTION_TAG_INSTRUCTION);\n+    private static final double MAX_THRESHOLD_DEGREES_DEFAULT = 40.0;\n+    private static final double MIN_THRESHOLD_DEGREES_DEFAULT = 10.0;\n+    private final Angle maxAngleThreshold;\n+    private final Angle minAngleThreshold;\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public RoundaboutMissingTagCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.maxAngleThreshold = configurationValue(configuration, \"threshold.degrees\",\n+                MAX_THRESHOLD_DEGREES_DEFAULT, Angle::degrees);\n+        this.minAngleThreshold = configurationValue(configuration, \"threshold.degrees\",\n+                MIN_THRESHOLD_DEGREES_DEFAULT, Angle::degrees);\n+    }\n+\n+    /**\n+     * Validates if given {@link AtlasObject} is actually an {@link Edge} and is a potential\n+     * roundabout and also corresponding OSM identifier shouldn't be flagged before (this is for\n+     * avoiding duplicate flags)\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return object instanceof Edge && !this.isFlagged(object.getOsmIdentifier())\n+                && object.getIdentifier() % MODULUS == FIRST_EDGE_SECTION\n+                && ((Edge) object).isMasterEdge() && HighwayTag.isCarNavigableHighway(object)\n+                && object.getTag(JunctionTag.KEY).isEmpty() && object.getTag(AreaTag.KEY).isEmpty()\n+                && isPartOfClosedWay((Edge) object) && intersectingWithMoreThan((Edge) object);\n+    }\n+\n+    /**\n+     * Flags an {@link Edge} is its circular shape and connected to at least\n+     * {@link RoundaboutMissingTagCheck#MINIMUM_INTERSECTION} navigable roads. {@link Edge} doesn't\n+     * have junction=roundabout or area=yes tags.\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edge = (Edge) object;\n+\n+        final PolyLine originalGeom = buildOriginalOsmWayGeometry(edge);\n+        // check maximum angle\n+        final List<Tuple<Angle, Location>> maxOffendingAngles = originalGeom\n+                .anglesGreaterThanOrEqualTo(this.maxAngleThreshold);\n+        // check minimum angle\n+        final List<Tuple<Angle, Location>> minOffendingAngles = originalGeom\n+                .anglesLessThanOrEqualTo(this.minAngleThreshold);\n+\n+        if (maxOffendingAngles.isEmpty() && minOffendingAngles.isEmpty())\n+        {\n+            this.markAsFlagged(object.getOsmIdentifier());\n+            return Optional.of(createFlag(new OsmWayWalker(edge).collectEdges(),\n+                    this.getLocalizedInstruction(0)));\n+        }\n+\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Build original OSW way geometry from all MasterEdge sections\n+     *\n+     * @param edge\n+     *            entity to check\n+     * @return original Way geometry polyline\n+     */\n+    private PolyLine buildOriginalOsmWayGeometry(final Edge edge)\n+    {\n+        // Identify all sections of original OSM way\n+        final Set<Edge> edgesFormingOSMWay = new OsmWayWalker(edge).collectEdges().stream()\n+                .filter(Edge::isMasterEdge).collect(Collectors.toSet());", "originalCommit": "25018e1f85a92876ce0eb774b6f570bec4dc3fa9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU1NDgxMw==", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r444554813", "bodyText": "Thanks!", "author": "vladlemberg", "createdAt": "2020-06-23T23:03:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDUwMjQ0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDUwNTE3OA==", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r444505178", "bodyText": "The way walker you used actually sorts by way section id (TreeSet) already so you could try using the default behavior. Ordering is defined in the WaySectionComparator", "author": "seancoulter", "createdAt": "2020-06-23T20:59:36Z", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/RoundaboutMissingTagCheck.java", "diffHunk": "@@ -0,0 +1,193 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.tags.AreaTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.ServiceTag;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.tuples.Tuple;\n+\n+/**\n+ * Flags edges that are closed shaped and have minimum of two intersections with navigable roads.\n+ * {@link RoundaboutMissingTagCheck#MINIMUM_INTERSECTION} connections. See\n+ * https://wiki.openstreetmap.org/wiki/Tag:junction%3Droundabout for more information about\n+ * roundabouts\n+ *\n+ * @author vladlemberg\n+ */\n+\n+public class RoundaboutMissingTagCheck extends BaseCheck<Long>\n+{\n+    // Instructions\n+    public static final String MISSING_JUNCTION_TAG_INSTRUCTION = \"This edge might be a roundabout\";\n+    // Minimum intersection with Navigable Roads\n+    private static final int MINIMUM_INTERSECTION = 2;\n+    private static final int MODULUS = 10;\n+    private static final int FIRST_EDGE_SECTION = 1;\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays\n+            .asList(MISSING_JUNCTION_TAG_INSTRUCTION);\n+    private static final double MAX_THRESHOLD_DEGREES_DEFAULT = 40.0;\n+    private static final double MIN_THRESHOLD_DEGREES_DEFAULT = 10.0;\n+    private final Angle maxAngleThreshold;\n+    private final Angle minAngleThreshold;\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public RoundaboutMissingTagCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.maxAngleThreshold = configurationValue(configuration, \"threshold.degrees\",\n+                MAX_THRESHOLD_DEGREES_DEFAULT, Angle::degrees);\n+        this.minAngleThreshold = configurationValue(configuration, \"threshold.degrees\",\n+                MIN_THRESHOLD_DEGREES_DEFAULT, Angle::degrees);\n+    }\n+\n+    /**\n+     * Validates if given {@link AtlasObject} is actually an {@link Edge} and is a potential\n+     * roundabout and also corresponding OSM identifier shouldn't be flagged before (this is for\n+     * avoiding duplicate flags)\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return object instanceof Edge && !this.isFlagged(object.getOsmIdentifier())\n+                && object.getIdentifier() % MODULUS == FIRST_EDGE_SECTION\n+                && ((Edge) object).isMasterEdge() && HighwayTag.isCarNavigableHighway(object)\n+                && object.getTag(JunctionTag.KEY).isEmpty() && object.getTag(AreaTag.KEY).isEmpty()\n+                && isPartOfClosedWay((Edge) object) && intersectingWithMoreThan((Edge) object);\n+    }\n+\n+    /**\n+     * Flags an {@link Edge} is its circular shape and connected to at least\n+     * {@link RoundaboutMissingTagCheck#MINIMUM_INTERSECTION} navigable roads. {@link Edge} doesn't\n+     * have junction=roundabout or area=yes tags.\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edge = (Edge) object;\n+\n+        final PolyLine originalGeom = buildOriginalOsmWayGeometry(edge);\n+        // check maximum angle\n+        final List<Tuple<Angle, Location>> maxOffendingAngles = originalGeom\n+                .anglesGreaterThanOrEqualTo(this.maxAngleThreshold);\n+        // check minimum angle\n+        final List<Tuple<Angle, Location>> minOffendingAngles = originalGeom\n+                .anglesLessThanOrEqualTo(this.minAngleThreshold);\n+\n+        if (maxOffendingAngles.isEmpty() && minOffendingAngles.isEmpty())\n+        {\n+            this.markAsFlagged(object.getOsmIdentifier());\n+            return Optional.of(createFlag(new OsmWayWalker(edge).collectEdges(),\n+                    this.getLocalizedInstruction(0)));\n+        }\n+\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Build original OSW way geometry from all MasterEdge sections\n+     *\n+     * @param edge\n+     *            entity to check\n+     * @return original Way geometry polyline\n+     */\n+    private PolyLine buildOriginalOsmWayGeometry(final Edge edge)\n+    {\n+        // Identify all sections of original OSM way\n+        final Set<Edge> edgesFormingOSMWay = new OsmWayWalker(edge).collectEdges().stream()\n+                .filter(Edge::isMasterEdge).collect(Collectors.toSet());\n+\n+        // Sort sectioned Edges by Ids\n+        final List<Edge> sortedEdges = new ArrayList<>(edgesFormingOSMWay);\n+        sortedEdges.sort(Comparator.comparingLong(AtlasObject::getIdentifier));", "originalCommit": "25018e1f85a92876ce0eb774b6f570bec4dc3fa9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA1Njg2OQ==", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r445056869", "bodyText": "thanks!", "author": "vladlemberg", "createdAt": "2020-06-24T17:30:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDUwNTE3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDUwODQ4OQ==", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r444508489", "bodyText": "Nice, would be cool to have this pulled out into the Edge class or something sometime down the line", "author": "seancoulter", "createdAt": "2020-06-23T21:06:02Z", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/RoundaboutMissingTagCheck.java", "diffHunk": "@@ -0,0 +1,193 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.tags.AreaTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.ServiceTag;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.tuples.Tuple;\n+\n+/**\n+ * Flags edges that are closed shaped and have minimum of two intersections with navigable roads.\n+ * {@link RoundaboutMissingTagCheck#MINIMUM_INTERSECTION} connections. See\n+ * https://wiki.openstreetmap.org/wiki/Tag:junction%3Droundabout for more information about\n+ * roundabouts\n+ *\n+ * @author vladlemberg\n+ */\n+\n+public class RoundaboutMissingTagCheck extends BaseCheck<Long>\n+{\n+    // Instructions\n+    public static final String MISSING_JUNCTION_TAG_INSTRUCTION = \"This edge might be a roundabout\";\n+    // Minimum intersection with Navigable Roads\n+    private static final int MINIMUM_INTERSECTION = 2;\n+    private static final int MODULUS = 10;\n+    private static final int FIRST_EDGE_SECTION = 1;\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays\n+            .asList(MISSING_JUNCTION_TAG_INSTRUCTION);\n+    private static final double MAX_THRESHOLD_DEGREES_DEFAULT = 40.0;\n+    private static final double MIN_THRESHOLD_DEGREES_DEFAULT = 10.0;\n+    private final Angle maxAngleThreshold;\n+    private final Angle minAngleThreshold;\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public RoundaboutMissingTagCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.maxAngleThreshold = configurationValue(configuration, \"threshold.degrees\",\n+                MAX_THRESHOLD_DEGREES_DEFAULT, Angle::degrees);\n+        this.minAngleThreshold = configurationValue(configuration, \"threshold.degrees\",\n+                MIN_THRESHOLD_DEGREES_DEFAULT, Angle::degrees);\n+    }\n+\n+    /**\n+     * Validates if given {@link AtlasObject} is actually an {@link Edge} and is a potential\n+     * roundabout and also corresponding OSM identifier shouldn't be flagged before (this is for\n+     * avoiding duplicate flags)\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return object instanceof Edge && !this.isFlagged(object.getOsmIdentifier())\n+                && object.getIdentifier() % MODULUS == FIRST_EDGE_SECTION\n+                && ((Edge) object).isMasterEdge() && HighwayTag.isCarNavigableHighway(object)\n+                && object.getTag(JunctionTag.KEY).isEmpty() && object.getTag(AreaTag.KEY).isEmpty()\n+                && isPartOfClosedWay((Edge) object) && intersectingWithMoreThan((Edge) object);\n+    }\n+\n+    /**\n+     * Flags an {@link Edge} is its circular shape and connected to at least\n+     * {@link RoundaboutMissingTagCheck#MINIMUM_INTERSECTION} navigable roads. {@link Edge} doesn't\n+     * have junction=roundabout or area=yes tags.\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edge = (Edge) object;\n+\n+        final PolyLine originalGeom = buildOriginalOsmWayGeometry(edge);\n+        // check maximum angle\n+        final List<Tuple<Angle, Location>> maxOffendingAngles = originalGeom\n+                .anglesGreaterThanOrEqualTo(this.maxAngleThreshold);\n+        // check minimum angle\n+        final List<Tuple<Angle, Location>> minOffendingAngles = originalGeom\n+                .anglesLessThanOrEqualTo(this.minAngleThreshold);\n+\n+        if (maxOffendingAngles.isEmpty() && minOffendingAngles.isEmpty())\n+        {\n+            this.markAsFlagged(object.getOsmIdentifier());\n+            return Optional.of(createFlag(new OsmWayWalker(edge).collectEdges(),\n+                    this.getLocalizedInstruction(0)));\n+        }\n+\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Build original OSW way geometry from all MasterEdge sections\n+     *\n+     * @param edge\n+     *            entity to check\n+     * @return original Way geometry polyline\n+     */\n+    private PolyLine buildOriginalOsmWayGeometry(final Edge edge)\n+    {\n+        // Identify all sections of original OSM way\n+        final Set<Edge> edgesFormingOSMWay = new OsmWayWalker(edge).collectEdges().stream()\n+                .filter(Edge::isMasterEdge).collect(Collectors.toSet());\n+\n+        // Sort sectioned Edges by Ids\n+        final List<Edge> sortedEdges = new ArrayList<>(edgesFormingOSMWay);\n+        sortedEdges.sort(Comparator.comparingLong(AtlasObject::getIdentifier));\n+\n+        // Build original OSM polyline\n+        PolyLine geometry = new PolyLine(sortedEdges.get(0).getRawGeometry());\n+        for (int i = 1; i < sortedEdges.size(); i++)", "originalCommit": "25018e1f85a92876ce0eb774b6f570bec4dc3fa9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU1NTUwMw==", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r444555503", "bodyText": "Thanks!", "author": "vladlemberg", "createdAt": "2020-06-23T23:05:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDUwODQ4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDUwOTAxOA==", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r444509018", "bodyText": "We could cache the waywalker call at the beginning of this method", "author": "seancoulter", "createdAt": "2020-06-23T21:07:09Z", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/RoundaboutMissingTagCheck.java", "diffHunk": "@@ -0,0 +1,193 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.tags.AreaTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.ServiceTag;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.tuples.Tuple;\n+\n+/**\n+ * Flags edges that are closed shaped and have minimum of two intersections with navigable roads.\n+ * {@link RoundaboutMissingTagCheck#MINIMUM_INTERSECTION} connections. See\n+ * https://wiki.openstreetmap.org/wiki/Tag:junction%3Droundabout for more information about\n+ * roundabouts\n+ *\n+ * @author vladlemberg\n+ */\n+\n+public class RoundaboutMissingTagCheck extends BaseCheck<Long>\n+{\n+    // Instructions\n+    public static final String MISSING_JUNCTION_TAG_INSTRUCTION = \"This edge might be a roundabout\";\n+    // Minimum intersection with Navigable Roads\n+    private static final int MINIMUM_INTERSECTION = 2;\n+    private static final int MODULUS = 10;\n+    private static final int FIRST_EDGE_SECTION = 1;\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays\n+            .asList(MISSING_JUNCTION_TAG_INSTRUCTION);\n+    private static final double MAX_THRESHOLD_DEGREES_DEFAULT = 40.0;\n+    private static final double MIN_THRESHOLD_DEGREES_DEFAULT = 10.0;\n+    private final Angle maxAngleThreshold;\n+    private final Angle minAngleThreshold;\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public RoundaboutMissingTagCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.maxAngleThreshold = configurationValue(configuration, \"threshold.degrees\",\n+                MAX_THRESHOLD_DEGREES_DEFAULT, Angle::degrees);\n+        this.minAngleThreshold = configurationValue(configuration, \"threshold.degrees\",\n+                MIN_THRESHOLD_DEGREES_DEFAULT, Angle::degrees);\n+    }\n+\n+    /**\n+     * Validates if given {@link AtlasObject} is actually an {@link Edge} and is a potential\n+     * roundabout and also corresponding OSM identifier shouldn't be flagged before (this is for\n+     * avoiding duplicate flags)\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return object instanceof Edge && !this.isFlagged(object.getOsmIdentifier())\n+                && object.getIdentifier() % MODULUS == FIRST_EDGE_SECTION\n+                && ((Edge) object).isMasterEdge() && HighwayTag.isCarNavigableHighway(object)\n+                && object.getTag(JunctionTag.KEY).isEmpty() && object.getTag(AreaTag.KEY).isEmpty()\n+                && isPartOfClosedWay((Edge) object) && intersectingWithMoreThan((Edge) object);\n+    }\n+\n+    /**\n+     * Flags an {@link Edge} is its circular shape and connected to at least\n+     * {@link RoundaboutMissingTagCheck#MINIMUM_INTERSECTION} navigable roads. {@link Edge} doesn't\n+     * have junction=roundabout or area=yes tags.\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edge = (Edge) object;\n+\n+        final PolyLine originalGeom = buildOriginalOsmWayGeometry(edge);\n+        // check maximum angle\n+        final List<Tuple<Angle, Location>> maxOffendingAngles = originalGeom\n+                .anglesGreaterThanOrEqualTo(this.maxAngleThreshold);\n+        // check minimum angle\n+        final List<Tuple<Angle, Location>> minOffendingAngles = originalGeom\n+                .anglesLessThanOrEqualTo(this.minAngleThreshold);\n+\n+        if (maxOffendingAngles.isEmpty() && minOffendingAngles.isEmpty())\n+        {\n+            this.markAsFlagged(object.getOsmIdentifier());\n+            return Optional.of(createFlag(new OsmWayWalker(edge).collectEdges(),", "originalCommit": "25018e1f85a92876ce0eb774b6f570bec4dc3fa9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDUxMDQ3OA==", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r444510478", "bodyText": "Or potentially in the validCheckForObject method, as I see now the usage is out of this scope", "author": "seancoulter", "createdAt": "2020-06-23T21:10:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDUwOTAxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA1NjMwNw==", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r445056307", "bodyText": "yes. tested it, however it significantly slowing down the performance.\ncompilation time. tested against China data on local:\n1 - use WayWalker in each method - 7,48 min (current)\n2 - cache WayWalker and pass Set Edges to every method - 9,64 min", "author": "vladlemberg", "createdAt": "2020-06-24T17:29:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDUwOTAxOA=="}], "type": "inlineReview"}, {"oid": "5106dcae632cec5aefe8f667d804a74bdfeb329d", "url": "https://github.com/osmlab/atlas-checks/commit/5106dcae632cec5aefe8f667d804a74bdfeb329d", "message": "added code review suggestions.", "committedDate": "2020-06-24T17:44:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTEwODc0MQ==", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r445108741", "bodyText": "@vladlemberg Just one more request to clean up this class a bit. You can import @TestAtlas.Node, @TestAtlas.Node etc. here.", "author": "sayas01", "createdAt": "2020-06-24T19:04:04Z", "path": "src/test/java/org/openstreetmap/atlas/checks/validation/linear/edges/RoundaboutMissingTagCheckTestRule.java", "diffHunk": "@@ -0,0 +1,267 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.utilities.testing.CoreTestRule;\n+import org.openstreetmap.atlas.utilities.testing.TestAtlas;\n+\n+/**\n+ * {@link RoundaboutMissingTagCheckTest} data generator\n+ *\n+ * @author vladlemberg\n+ */\n+\n+public class RoundaboutMissingTagCheckTestRule extends CoreTestRule\n+{\n+    // roundabout nodes\n+    private static final String TEST_NODE_VERTEX_1 = \"37.3293541,-121.9156701\";\n+    private static final String TEST_NODE_SHP_1 = \"37.3293187,-121.9157123\";\n+    private static final String TEST_NODE_SHP_2 = \"37.3292841,-121.9157281\";\n+    private static final String TEST_NODE_SHP_3 = \"37.3292474,-121.9157280\";\n+    private static final String TEST_NODE_VERTEX_2 = \"37.3292026,-121.9157035\";\n+    private static final String TEST_NODE_SHP_4 = \"37.3291717,-121.9156569\";\n+    private static final String TEST_NODE_SHP_5 = \"37.3291612,-121.9156132\";\n+    private static final String TEST_NODE_SHP_6 = \"37.3291632,-121.9155676\";\n+    private static final String TEST_NODE_VERTEX_3 = \"37.3291845,-121.9155131\";\n+    private static final String TEST_NODE_SHP_7 = \"37.3292123,-121.9154833\";\n+    private static final String TEST_NODE_SHP_8 = \"37.3292464,-121.9154672\";\n+    private static final String TEST_NODE_SHP_9 = \"37.3292949,-121.9154700\";\n+    private static final String TEST_NODE_VERTEX_4 = \"37.3293277,-121.9154900\";\n+    private static final String TEST_NODE_SHP_10 = \"37.3293534,-121.9155234\";\n+    private static final String TEST_NODE_SHP_11 = \"37.3293683,-121.9155658\";\n+    private static final String TEST_NODE_SHP_12 = \"37.3293686,-121.9156274\";\n+    // connected way nodes\n+    private static final String TEST_NODE_5 = \"37.3303971,-121.9139893\";\n+    private static final String TEST_NODE_6 = \"37.3281316,-121.9170493\";\n+\n+    @TestAtlas(\n+            // nodes\n+            nodes = { @TestAtlas.Node(coordinates = @TestAtlas.Loc(value = TEST_NODE_VERTEX_1)),", "originalCommit": "5106dcae632cec5aefe8f667d804a74bdfeb329d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTEwOTk2OA==", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r445109968", "bodyText": "nit: this.isPartOfClosedWay((Edge) object) && this.intersectingWithMoreThan((Edge) object)", "author": "sayas01", "createdAt": "2020-06-24T19:06:26Z", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/RoundaboutMissingTagCheck.java", "diffHunk": "@@ -0,0 +1,169 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.tags.AreaTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.ServiceTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.tuples.Tuple;\n+\n+/**\n+ * Flags edges that are closed and round shaped without junction=roundabout tag and have minimum of\n+ * two intersections with navigable roads {@link RoundaboutMissingTagCheck#MINIMUM_INTERSECTION}\n+ * connections. See https://wiki.openstreetmap.org/wiki/Tag:junction%3Droundabout for more\n+ * information about roundabouts\n+ * \n+ * @author vladlemberg\n+ */\n+\n+public class RoundaboutMissingTagCheck extends BaseCheck<Long>\n+{\n+    // Instructions\n+    public static final String MISSING_JUNCTION_TAG_INSTRUCTION = \"This edge might be a roundabout\";\n+    // Minimum intersection with Navigable Roads\n+    private static final int MINIMUM_INTERSECTION = 2;\n+    private static final int MODULUS = 10;\n+    private static final int FIRST_EDGE_SECTION = 1;\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Collections\n+            .singletonList(MISSING_JUNCTION_TAG_INSTRUCTION);\n+    private static final double MAX_THRESHOLD_DEGREES_DEFAULT = 40.0;\n+    private static final double MIN_THRESHOLD_DEGREES_DEFAULT = 10.0;\n+    private final Angle maxAngleThreshold;\n+    private final Angle minAngleThreshold;\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public RoundaboutMissingTagCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.maxAngleThreshold = configurationValue(configuration, \"angle.threshold.maximum_degree\",\n+                MAX_THRESHOLD_DEGREES_DEFAULT, Angle::degrees);\n+        this.minAngleThreshold = configurationValue(configuration, \"angle.threshold.minimum_degree\",\n+                MIN_THRESHOLD_DEGREES_DEFAULT, Angle::degrees);\n+    }\n+\n+    /**\n+     * Validates if given {@link AtlasObject} is actually an {@link Edge} and is a potential\n+     * roundabout and also corresponding OSM identifier shouldn't be flagged before (this is for\n+     * avoiding duplicate flags)\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return object instanceof Edge && !this.isFlagged(object.getOsmIdentifier())\n+                && object.getIdentifier() % MODULUS == FIRST_EDGE_SECTION\n+                && ((Edge) object).isMasterEdge() && HighwayTag.isCarNavigableHighway(object)\n+                && object.getTag(JunctionTag.KEY).isEmpty() && object.getTag(AreaTag.KEY).isEmpty()\n+                && isPartOfClosedWay((Edge) object) && intersectingWithMoreThan((Edge) object);", "originalCommit": "5106dcae632cec5aefe8f667d804a74bdfeb329d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "40bce512872223014a76c495e3fb63b2f02b947a", "url": "https://github.com/osmlab/atlas-checks/commit/40bce512872223014a76c495e3fb63b2f02b947a", "message": "added code review suggestions.", "committedDate": "2020-06-24T21:13:17Z", "type": "commit"}]}