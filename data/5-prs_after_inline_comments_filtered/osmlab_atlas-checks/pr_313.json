{"pr_number": 313, "pr_title": "Conditional restriction check", "pr_createdAt": "2020-06-11T06:30:14Z", "pr_url": "https://github.com/osmlab/atlas-checks/pull/313", "timeline": [{"oid": "31ad39029ed77106d38732b6b5ef41d37a34efe8", "url": "https://github.com/osmlab/atlas-checks/commit/31ad39029ed77106d38732b6b5ef41d37a34efe8", "message": "Merge pull request #1 from osmlab/dev\n\nUpdated from head", "committedDate": "2020-05-05T08:16:33Z", "type": "commit"}, {"oid": "b8a5ae347c133469c937a79c054fcf0c0a4b35f4", "url": "https://github.com/osmlab/atlas-checks/commit/b8a5ae347c133469c937a79c054fcf0c0a4b35f4", "message": "Conditional Restriction check\n\n- started check for conditional restriction tag format\n- key format check implemented\n- conditional value format check to be done\n- added corresponding test class", "committedDate": "2020-06-09T13:32:15Z", "type": "commit"}, {"oid": "30fefd4d2796b7ed17c1a37c8354adde66233b49", "url": "https://github.com/osmlab/atlas-checks/commit/30fefd4d2796b7ed17c1a37c8354adde66233b49", "message": "Conditional Restriction check value\n\n- finished implementing the value check\n- added corresponding test cases", "committedDate": "2020-06-10T12:43:32Z", "type": "commit"}, {"oid": "effdf40607e949013255f103073e355b98376ce6", "url": "https://github.com/osmlab/atlas-checks/commit/effdf40607e949013255f103073e355b98376ce6", "message": "Added missing values\n\n- upon searching existing tags, added\nsome missing values that can comprise a correct\nconditional restriction", "committedDate": "2020-06-11T06:21:34Z", "type": "commit"}, {"oid": "6000041ef4b59258378fad2137b0959e0e11afbf", "url": "https://github.com/osmlab/atlas-checks/commit/6000041ef4b59258378fad2137b0959e0e11afbf", "message": "Conditional Restriction check - checkstyle fix\n\n- fixed code style to pass the spotless checks", "committedDate": "2020-06-16T08:03:15Z", "type": "commit"}, {"oid": "83cda97265c80b42228ba237ee984fed07155a57", "url": "https://github.com/osmlab/atlas-checks/commit/83cda97265c80b42228ba237ee984fed07155a57", "message": "Conditional Restriction check minor fix\n\n- added missing restriction type and dot character as\npossible in the value format", "committedDate": "2020-06-17T13:06:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDM4MzcyNg==", "url": "https://github.com/osmlab/atlas-checks/pull/313#discussion_r444383726", "bodyText": "By using a return statement here the check may miss flagging the value if it is also bad, and flagging other tags if an object has multiple bad conditional tags. Thus it could take multiple cycles of running the check and editing the feature to fully fix the problems. It would probably be better to add the instruction to a list of generated instructions for this feature, and flag the feature later if that list is not empty. You can see an example of this sort of arrangement in RoundaboutValenceCheck.", "author": "Bentleysb", "createdAt": "2020-06-23T17:18:24Z", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/ConditionalRestrictionCheck.java", "diffHunk": "@@ -0,0 +1,178 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Flags conditional restriction tags that do not follow the scheme provided on the OSM wiki.\n+ * {@literal <restriction-type>[:<transportation mode>][:<direction>]:conditional\n+ * = <restriction-value> @ <condition>[;<restriction-value> @ <condition>]}\n+ *\n+ * @author laura\n+ * @see <a href=\"https://wiki.openstreetmap.org/wiki/Conditional_restrictions\">wiki</a> for more\n+ *      information.\n+ */\n+public class ConditionalRestrictionCheck extends BaseCheck<String>\n+{\n+\n+    private static final long serialVersionUID = 6726352951073801440L;\n+\n+    public static final String CONDITIONAL = \":conditional\";\n+    private static final List<String> RESTRICTION_TYPES = List.of(\"access\", \"restriction\",\n+            \"maxspeed\", \"minspeed\", \"maxweight\", \"maxaxleload\", \"maxheight\", \"maxlength\", \"maxstay\",\n+            \"maxgcweight\", \"maxgcweightrating\", \"interval\", \"duration\", \"overtaking\", \"oneway\",\n+            \"fee\", \"toll\", \"noexit\", \"snowplowing\", \"disabled\", \"lanes\", \"parking\");\n+    private static final List<String> TRANSPORTATION_MODE = List.of(\"foot\", \"ski\", \"inline_skates\",\n+            \"horse\", \"vehicle\", \"bicycle\", \"carriage\", \"trailer\", \"caravan\", \"motor_vehicle\",\n+            \"motorcycle\", \"moped\", \"mofa\", \"motorcar\", \"motorhome\", \"tourist_bus\", \"coach\", \"goods\",\n+            \"hgv\", \"hgv_articulated\", \"agricultural\", \"golf_cart\", \"atv\", \"snowmobile\", \"psv\",\n+            \"bus\", \"minibus\", \"share_taxi\", \"taxi\", \"hov\", \"hazmat\", \"emergency\", \"canoe\",\n+            \"electric_vehicle\");\n+    private static final List<String> DIRECTION = List.of(\"forward\", \"backward\", \"left\", \"right\",\n+            \"both\");\n+    private static final List<String> ACCESS_RESTRICTION_VALUE = List.of(\"yes\", \"no\", \"private\",\n+            \"permissive\", \"destination\", \"delivery\", \"customers\", \"designated\", \"use_sidepath\",\n+            \"dismount\", \"agricultural\", \"forestry\", \"discouraged\", \"official\", \"lane\");\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(\n+            \"The conditional key {0} does not respect the \\\"<restriction-type>[:<transportation mode>][:<direction>]:conditional\\\" format\",\n+            \"The conditional value {0} does not respect the format \\\"<restriction-value> @ <condition>[;<restriction-value> @ <condition>]\\\" \");\n+    public static final int TWO_PARTS = 2;\n+    public static final int THREE_PARTS = 3;\n+    public static final int FOUR_PARTS = 4;\n+\n+    public ConditionalRestrictionCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+    }\n+\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        // all elements that have a tag containing \":conditional\"\n+        return object.getOsmTags().keySet().stream().anyMatch(key -> key.contains(CONDITIONAL));\n+    }\n+\n+    /**\n+     * Checks if the conditional restrictions respects the format\n+     *\n+     * @param object\n+     *            the atlas object containing a conditional tag\n+     * @return an optional {@link CheckFlag} object\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final List<String> conditionalKeys = object.getOsmTags().keySet().stream()\n+                .filter(key -> key.contains(CONDITIONAL)).collect(Collectors.toList());\n+        for (final String key : conditionalKeys)\n+        {\n+            if (!isKeyValid(key))\n+            {\n+                return Optional.of(this.createFlag(object, this.getLocalizedInstruction(0, key)));", "originalCommit": "83cda97265c80b42228ba237ee984fed07155a57", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "45cac9d8bfa0a9b1a706e15fa7c04a4bd7b5742e", "url": "https://github.com/osmlab/atlas-checks/commit/45cac9d8bfa0a9b1a706e15fa7c04a4bd7b5742e", "message": "Conditional Restriction check - PR fixes\n\n- changes per PR comments\n- added md files\n- added multiple instructions per object to capture any possible\nissue with it", "committedDate": "2020-06-25T15:17:06Z", "type": "commit"}, {"oid": "cd45bf54b58731daf0105cf3bbe1d8ab7981ca7b", "url": "https://github.com/osmlab/atlas-checks/commit/cd45bf54b58731daf0105cf3bbe1d8ab7981ca7b", "message": "Test update\n\n- updated tests with code changes", "committedDate": "2020-06-26T05:33:18Z", "type": "commit"}, {"oid": "a6c8fbd0b70c648811d93af920715301363f2209", "url": "https://github.com/osmlab/atlas-checks/commit/a6c8fbd0b70c648811d93af920715301363f2209", "message": "Validation changes\n\nUpon validating, some exceptions from the existing rules\nhad to be added:\n- transportation and lanes can be reversed and represent\nthe number of lanes or which can be used accordingly\n- | is a valid value character\n- added missing restriction types and access values\n- added exception for access:lanes", "committedDate": "2020-07-02T11:32:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE4ODUwOQ==", "url": "https://github.com/osmlab/atlas-checks/pull/313#discussion_r449188509", "bodyText": "Please add this keyword when accessing the methods.", "author": "sayas01", "createdAt": "2020-07-02T18:08:50Z", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/ConditionalRestrictionCheck.java", "diffHunk": "@@ -0,0 +1,223 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Flags conditional restriction tags that do not follow the scheme provided on the OSM wiki.\n+ * {@literal <restriction-type>[:<transportation mode>][:<direction>]:conditional\n+ * = <restriction-value> @ <condition>[;<restriction-value> @ <condition>]}\n+ *\n+ * @author laura\n+ * @see <a href=\"https://wiki.openstreetmap.org/wiki/Conditional_restrictions\">wiki</a> for more\n+ *      information.\n+ */\n+public class ConditionalRestrictionCheck extends BaseCheck<String>\n+{\n+\n+    private static final long serialVersionUID = 6726352951073801440L;\n+\n+    public static final String CONDITIONAL = \":conditional\";\n+    private static final List<String> RESTRICTION_TYPES = List.of(\"access\", \"restriction\",\n+            \"maxspeed\", \"minspeed\", \"maxweight\", \"maxaxleload\", \"maxheight\", \"maxlength\", \"maxstay\",\n+            \"maxgcweight\", \"maxgcweightrating\", \"interval\", \"duration\", \"overtaking\", \"oneway\",\n+            \"fee\", \"toll\", \"noexit\", \"snowplowing\", \"disabled\", \"lanes\", \"parking\");\n+    private static final List<String> TRANSPORTATION_MODE = List.of(\"foot\", \"ski\", \"inline_skates\",\n+            \"horse\", \"vehicle\", \"bicycle\", \"carriage\", \"trailer\", \"caravan\", \"motor_vehicle\",\n+            \"motorcycle\", \"moped\", \"mofa\", \"motorcar\", \"motorhome\", \"tourist_bus\", \"coach\", \"goods\",\n+            \"hgv\", \"hgv_articulated\", \"agricultural\", \"golf_cart\", \"atv\", \"snowmobile\", \"psv\",\n+            \"bus\", \"minibus\", \"share_taxi\", \"taxi\", \"hov\", \"hazmat\", \"emergency\", \"canoe\",\n+            \"electric_vehicle\", \"cycleway\", \"busway\");\n+    private static final List<String> DIRECTION = List.of(\"forward\", \"backward\", \"left\", \"right\",\n+            \"both\");\n+    private static final List<String> ACCESS_RESTRICTION_VALUE = List.of(\"yes\", \"no\", \"private\",\n+            \"permissive\", \"destination\", \"delivery\", \"customers\", \"designated\", \"use_sidepath\",\n+            \"dismount\", \"agricultural\", \"forestry\", \"discouraged\", \"official\", \"lane\",\n+            \"share_busway\", \"opposite_share_busway\");\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(\n+            \"The conditional key \\\"{0}\\\" does not respect the \\\"<restriction-type>[:<transportation mode>][:<direction>]:conditional\\\" format\",\n+            \"The conditional value \\\"{0}\\\" does not respect the format \\\"<restriction-value> @ <condition>[;<restriction-value> @ <condition>]\\\" \",\n+            \"The element with id {0,number,#} does not follow the conditional restriction pattern.\");\n+    public static final int TWO_PARTS = 2;\n+    public static final int THREE_PARTS = 3;\n+    public static final int FOUR_PARTS = 4;\n+\n+    public ConditionalRestrictionCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+    }\n+\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        // all elements that have a tag containing \":conditional\"\n+        return object.getOsmTags().keySet().stream().anyMatch(key -> key.contains(CONDITIONAL));\n+    }\n+\n+    /**\n+     * Checks if the conditional restrictions respects the format\n+     *\n+     * @param object\n+     *            the atlas object containing a conditional tag\n+     * @return an optional {@link CheckFlag} object\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Set<String> instructions = new HashSet<>();\n+\n+        final List<String> conditionalKeys = object.getOsmTags().keySet().stream()\n+                .filter(key -> key.contains(CONDITIONAL)).collect(Collectors.toList());\n+        for (final String key : conditionalKeys)\n+        {\n+            if (!isKeyValid(key))", "originalCommit": "a6c8fbd0b70c648811d93af920715301363f2209", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE4OTY2NA==", "url": "https://github.com/osmlab/atlas-checks/pull/313#discussion_r449189664", "bodyText": "The CommonConstants class cab be leveraged here: \n  \n    \n      atlas-checks/src/main/java/org/openstreetmap/atlas/checks/constants/CommonConstants.java\n    \n    \n         Line 28\n      in\n      d070ac4\n    \n    \n    \n    \n\n        \n          \n           public static final String COLON = \":\";", "author": "sayas01", "createdAt": "2020-07-02T18:11:17Z", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/ConditionalRestrictionCheck.java", "diffHunk": "@@ -0,0 +1,223 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Flags conditional restriction tags that do not follow the scheme provided on the OSM wiki.\n+ * {@literal <restriction-type>[:<transportation mode>][:<direction>]:conditional\n+ * = <restriction-value> @ <condition>[;<restriction-value> @ <condition>]}\n+ *\n+ * @author laura\n+ * @see <a href=\"https://wiki.openstreetmap.org/wiki/Conditional_restrictions\">wiki</a> for more\n+ *      information.\n+ */\n+public class ConditionalRestrictionCheck extends BaseCheck<String>\n+{\n+\n+    private static final long serialVersionUID = 6726352951073801440L;\n+\n+    public static final String CONDITIONAL = \":conditional\";\n+    private static final List<String> RESTRICTION_TYPES = List.of(\"access\", \"restriction\",\n+            \"maxspeed\", \"minspeed\", \"maxweight\", \"maxaxleload\", \"maxheight\", \"maxlength\", \"maxstay\",\n+            \"maxgcweight\", \"maxgcweightrating\", \"interval\", \"duration\", \"overtaking\", \"oneway\",\n+            \"fee\", \"toll\", \"noexit\", \"snowplowing\", \"disabled\", \"lanes\", \"parking\");\n+    private static final List<String> TRANSPORTATION_MODE = List.of(\"foot\", \"ski\", \"inline_skates\",\n+            \"horse\", \"vehicle\", \"bicycle\", \"carriage\", \"trailer\", \"caravan\", \"motor_vehicle\",\n+            \"motorcycle\", \"moped\", \"mofa\", \"motorcar\", \"motorhome\", \"tourist_bus\", \"coach\", \"goods\",\n+            \"hgv\", \"hgv_articulated\", \"agricultural\", \"golf_cart\", \"atv\", \"snowmobile\", \"psv\",\n+            \"bus\", \"minibus\", \"share_taxi\", \"taxi\", \"hov\", \"hazmat\", \"emergency\", \"canoe\",\n+            \"electric_vehicle\", \"cycleway\", \"busway\");\n+    private static final List<String> DIRECTION = List.of(\"forward\", \"backward\", \"left\", \"right\",\n+            \"both\");\n+    private static final List<String> ACCESS_RESTRICTION_VALUE = List.of(\"yes\", \"no\", \"private\",\n+            \"permissive\", \"destination\", \"delivery\", \"customers\", \"designated\", \"use_sidepath\",\n+            \"dismount\", \"agricultural\", \"forestry\", \"discouraged\", \"official\", \"lane\",\n+            \"share_busway\", \"opposite_share_busway\");\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(\n+            \"The conditional key \\\"{0}\\\" does not respect the \\\"<restriction-type>[:<transportation mode>][:<direction>]:conditional\\\" format\",\n+            \"The conditional value \\\"{0}\\\" does not respect the format \\\"<restriction-value> @ <condition>[;<restriction-value> @ <condition>]\\\" \",\n+            \"The element with id {0,number,#} does not follow the conditional restriction pattern.\");\n+    public static final int TWO_PARTS = 2;\n+    public static final int THREE_PARTS = 3;\n+    public static final int FOUR_PARTS = 4;\n+\n+    public ConditionalRestrictionCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+    }\n+\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        // all elements that have a tag containing \":conditional\"\n+        return object.getOsmTags().keySet().stream().anyMatch(key -> key.contains(CONDITIONAL));\n+    }\n+\n+    /**\n+     * Checks if the conditional restrictions respects the format\n+     *\n+     * @param object\n+     *            the atlas object containing a conditional tag\n+     * @return an optional {@link CheckFlag} object\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Set<String> instructions = new HashSet<>();\n+\n+        final List<String> conditionalKeys = object.getOsmTags().keySet().stream()\n+                .filter(key -> key.contains(CONDITIONAL)).collect(Collectors.toList());\n+        for (final String key : conditionalKeys)\n+        {\n+            if (!isKeyValid(key))\n+            {\n+                instructions.add(this.getLocalizedInstruction(0, key));\n+            }\n+            final String value = object.getOsmTags().get(key);\n+            if (!isValueValid(value, key))\n+            {\n+                instructions.add(this.getLocalizedInstruction(1, value));\n+            }\n+        }\n+        if (!instructions.isEmpty())\n+        {\n+            final CheckFlag flag = this.createFlag(object,\n+                    this.getLocalizedInstruction(2, object.getOsmIdentifier()));\n+            instructions.forEach(flag::addInstruction);\n+            return Optional.of(flag);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    private boolean containsTransportationMode(final String key)\n+    {\n+        final String[] parts = key.split(\":\");", "originalCommit": "a6c8fbd0b70c648811d93af920715301363f2209", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE5MDE2NQ==", "url": "https://github.com/osmlab/atlas-checks/pull/313#discussion_r449190165", "bodyText": "Any reason why these are set to access public?", "author": "sayas01", "createdAt": "2020-07-02T18:12:20Z", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/ConditionalRestrictionCheck.java", "diffHunk": "@@ -0,0 +1,223 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Flags conditional restriction tags that do not follow the scheme provided on the OSM wiki.\n+ * {@literal <restriction-type>[:<transportation mode>][:<direction>]:conditional\n+ * = <restriction-value> @ <condition>[;<restriction-value> @ <condition>]}\n+ *\n+ * @author laura\n+ * @see <a href=\"https://wiki.openstreetmap.org/wiki/Conditional_restrictions\">wiki</a> for more\n+ *      information.\n+ */\n+public class ConditionalRestrictionCheck extends BaseCheck<String>\n+{\n+\n+    private static final long serialVersionUID = 6726352951073801440L;\n+\n+    public static final String CONDITIONAL = \":conditional\";\n+    private static final List<String> RESTRICTION_TYPES = List.of(\"access\", \"restriction\",\n+            \"maxspeed\", \"minspeed\", \"maxweight\", \"maxaxleload\", \"maxheight\", \"maxlength\", \"maxstay\",\n+            \"maxgcweight\", \"maxgcweightrating\", \"interval\", \"duration\", \"overtaking\", \"oneway\",\n+            \"fee\", \"toll\", \"noexit\", \"snowplowing\", \"disabled\", \"lanes\", \"parking\");\n+    private static final List<String> TRANSPORTATION_MODE = List.of(\"foot\", \"ski\", \"inline_skates\",\n+            \"horse\", \"vehicle\", \"bicycle\", \"carriage\", \"trailer\", \"caravan\", \"motor_vehicle\",\n+            \"motorcycle\", \"moped\", \"mofa\", \"motorcar\", \"motorhome\", \"tourist_bus\", \"coach\", \"goods\",\n+            \"hgv\", \"hgv_articulated\", \"agricultural\", \"golf_cart\", \"atv\", \"snowmobile\", \"psv\",\n+            \"bus\", \"minibus\", \"share_taxi\", \"taxi\", \"hov\", \"hazmat\", \"emergency\", \"canoe\",\n+            \"electric_vehicle\", \"cycleway\", \"busway\");\n+    private static final List<String> DIRECTION = List.of(\"forward\", \"backward\", \"left\", \"right\",\n+            \"both\");\n+    private static final List<String> ACCESS_RESTRICTION_VALUE = List.of(\"yes\", \"no\", \"private\",\n+            \"permissive\", \"destination\", \"delivery\", \"customers\", \"designated\", \"use_sidepath\",\n+            \"dismount\", \"agricultural\", \"forestry\", \"discouraged\", \"official\", \"lane\",\n+            \"share_busway\", \"opposite_share_busway\");\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(\n+            \"The conditional key \\\"{0}\\\" does not respect the \\\"<restriction-type>[:<transportation mode>][:<direction>]:conditional\\\" format\",\n+            \"The conditional value \\\"{0}\\\" does not respect the format \\\"<restriction-value> @ <condition>[;<restriction-value> @ <condition>]\\\" \",\n+            \"The element with id {0,number,#} does not follow the conditional restriction pattern.\");\n+    public static final int TWO_PARTS = 2;\n+    public static final int THREE_PARTS = 3;\n+    public static final int FOUR_PARTS = 4;", "originalCommit": "a6c8fbd0b70c648811d93af920715301363f2209", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE5MjY3Mw==", "url": "https://github.com/osmlab/atlas-checks/pull/313#discussion_r449192673", "bodyText": "This could be made static to avoid recompilation for each instance of the class.", "author": "sayas01", "createdAt": "2020-07-02T18:17:36Z", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/ConditionalRestrictionCheck.java", "diffHunk": "@@ -0,0 +1,223 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Flags conditional restriction tags that do not follow the scheme provided on the OSM wiki.\n+ * {@literal <restriction-type>[:<transportation mode>][:<direction>]:conditional\n+ * = <restriction-value> @ <condition>[;<restriction-value> @ <condition>]}\n+ *\n+ * @author laura\n+ * @see <a href=\"https://wiki.openstreetmap.org/wiki/Conditional_restrictions\">wiki</a> for more\n+ *      information.\n+ */\n+public class ConditionalRestrictionCheck extends BaseCheck<String>\n+{\n+\n+    private static final long serialVersionUID = 6726352951073801440L;\n+\n+    public static final String CONDITIONAL = \":conditional\";\n+    private static final List<String> RESTRICTION_TYPES = List.of(\"access\", \"restriction\",\n+            \"maxspeed\", \"minspeed\", \"maxweight\", \"maxaxleload\", \"maxheight\", \"maxlength\", \"maxstay\",\n+            \"maxgcweight\", \"maxgcweightrating\", \"interval\", \"duration\", \"overtaking\", \"oneway\",\n+            \"fee\", \"toll\", \"noexit\", \"snowplowing\", \"disabled\", \"lanes\", \"parking\");\n+    private static final List<String> TRANSPORTATION_MODE = List.of(\"foot\", \"ski\", \"inline_skates\",\n+            \"horse\", \"vehicle\", \"bicycle\", \"carriage\", \"trailer\", \"caravan\", \"motor_vehicle\",\n+            \"motorcycle\", \"moped\", \"mofa\", \"motorcar\", \"motorhome\", \"tourist_bus\", \"coach\", \"goods\",\n+            \"hgv\", \"hgv_articulated\", \"agricultural\", \"golf_cart\", \"atv\", \"snowmobile\", \"psv\",\n+            \"bus\", \"minibus\", \"share_taxi\", \"taxi\", \"hov\", \"hazmat\", \"emergency\", \"canoe\",\n+            \"electric_vehicle\", \"cycleway\", \"busway\");\n+    private static final List<String> DIRECTION = List.of(\"forward\", \"backward\", \"left\", \"right\",\n+            \"both\");\n+    private static final List<String> ACCESS_RESTRICTION_VALUE = List.of(\"yes\", \"no\", \"private\",\n+            \"permissive\", \"destination\", \"delivery\", \"customers\", \"designated\", \"use_sidepath\",\n+            \"dismount\", \"agricultural\", \"forestry\", \"discouraged\", \"official\", \"lane\",\n+            \"share_busway\", \"opposite_share_busway\");\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(\n+            \"The conditional key \\\"{0}\\\" does not respect the \\\"<restriction-type>[:<transportation mode>][:<direction>]:conditional\\\" format\",\n+            \"The conditional value \\\"{0}\\\" does not respect the format \\\"<restriction-value> @ <condition>[;<restriction-value> @ <condition>]\\\" \",\n+            \"The element with id {0,number,#} does not follow the conditional restriction pattern.\");\n+    public static final int TWO_PARTS = 2;\n+    public static final int THREE_PARTS = 3;\n+    public static final int FOUR_PARTS = 4;\n+\n+    public ConditionalRestrictionCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+    }\n+\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        // all elements that have a tag containing \":conditional\"\n+        return object.getOsmTags().keySet().stream().anyMatch(key -> key.contains(CONDITIONAL));\n+    }\n+\n+    /**\n+     * Checks if the conditional restrictions respects the format\n+     *\n+     * @param object\n+     *            the atlas object containing a conditional tag\n+     * @return an optional {@link CheckFlag} object\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Set<String> instructions = new HashSet<>();\n+\n+        final List<String> conditionalKeys = object.getOsmTags().keySet().stream()\n+                .filter(key -> key.contains(CONDITIONAL)).collect(Collectors.toList());\n+        for (final String key : conditionalKeys)\n+        {\n+            if (!isKeyValid(key))\n+            {\n+                instructions.add(this.getLocalizedInstruction(0, key));\n+            }\n+            final String value = object.getOsmTags().get(key);\n+            if (!isValueValid(value, key))\n+            {\n+                instructions.add(this.getLocalizedInstruction(1, value));\n+            }\n+        }\n+        if (!instructions.isEmpty())\n+        {\n+            final CheckFlag flag = this.createFlag(object,\n+                    this.getLocalizedInstruction(2, object.getOsmIdentifier()));\n+            instructions.forEach(flag::addInstruction);\n+            return Optional.of(flag);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    private boolean containsTransportationMode(final String key)\n+    {\n+        final String[] parts = key.split(\":\");\n+        for (final String part : parts)\n+        {\n+            if (isTransportationMode(part))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean isAccessType(final String value)\n+    {\n+        return \"access\".equals(value);\n+    }\n+\n+    private boolean isAccessValue(final String value)\n+    {\n+        return ACCESS_RESTRICTION_VALUE.contains(value);\n+    }\n+\n+    private boolean isDirection(final String value)\n+    {\n+        return DIRECTION.contains(value);\n+    }\n+\n+    private boolean isKeyValid(final String key)\n+    {\n+        final String[] parts = key.split(\":\");\n+        // access:lanes is a valid exception for lanes on second position\n+        final boolean isAccessLanes = parts.length > 2\n+                && (isAccessType(parts[0]) && isLanes(parts[1]));\n+        switch (parts.length)\n+        {\n+            // starts with 2 because they all contain the conditional part\n+            case TWO_PARTS:\n+                return isRestrictionType(parts[0]) || isTransportationMode(parts[0]);\n+            case THREE_PARTS:\n+                final boolean isRestrictionTypeFormat = isRestrictionType(parts[0])\n+                        && (isTransportationMode(parts[1]) || isDirection(parts[1]));\n+                final boolean isTransportTypeFormat = isTransportationMode(parts[0])\n+                        && (isDirection(parts[1]) || isLanes(parts[1]));\n+                return isRestrictionTypeFormat || isTransportTypeFormat || isAccessLanes;\n+            case FOUR_PARTS:\n+                final boolean isRestrictionTransport = isRestrictionType(parts[0])\n+                        && isTransportationMode(parts[1]);\n+                final boolean isTransportLanes = isTransportationMode(parts[0])\n+                        && isLanes(parts[1]);\n+                return (isRestrictionTransport || isTransportLanes || isAccessLanes)\n+                        && isDirection(parts[2]);\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean isLanes(final String value)\n+    {\n+        return \"lanes\".equals(value);\n+    }\n+\n+    private boolean isNotLanesType(final String key)\n+    {\n+        final String[] parts = key.split(\":\");\n+        return !isLanes(parts[0]);\n+    }\n+\n+    private boolean isRestrictionType(final String value)\n+    {\n+        return RESTRICTION_TYPES.contains(value);\n+    }\n+\n+    private boolean isTransportationMode(final String value)\n+    {\n+        return TRANSPORTATION_MODE.contains(value);\n+    }\n+\n+    private boolean isValueValid(final String value, final String key)\n+    {\n+        boolean isValid = true;\n+        final Pattern valuePattern = Pattern.compile(", "originalCommit": "a6c8fbd0b70c648811d93af920715301363f2209", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE5NDM5Mw==", "url": "https://github.com/osmlab/atlas-checks/pull/313#discussion_r449194393", "bodyText": "I think this variable is not required. We can simply return true/false based on the condition. For example:  if (!trimmedPart.isEmpty() && !isAccessValue(trimmedPart)) { return false; }", "author": "sayas01", "createdAt": "2020-07-02T18:21:11Z", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/ConditionalRestrictionCheck.java", "diffHunk": "@@ -0,0 +1,223 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Flags conditional restriction tags that do not follow the scheme provided on the OSM wiki.\n+ * {@literal <restriction-type>[:<transportation mode>][:<direction>]:conditional\n+ * = <restriction-value> @ <condition>[;<restriction-value> @ <condition>]}\n+ *\n+ * @author laura\n+ * @see <a href=\"https://wiki.openstreetmap.org/wiki/Conditional_restrictions\">wiki</a> for more\n+ *      information.\n+ */\n+public class ConditionalRestrictionCheck extends BaseCheck<String>\n+{\n+\n+    private static final long serialVersionUID = 6726352951073801440L;\n+\n+    public static final String CONDITIONAL = \":conditional\";\n+    private static final List<String> RESTRICTION_TYPES = List.of(\"access\", \"restriction\",\n+            \"maxspeed\", \"minspeed\", \"maxweight\", \"maxaxleload\", \"maxheight\", \"maxlength\", \"maxstay\",\n+            \"maxgcweight\", \"maxgcweightrating\", \"interval\", \"duration\", \"overtaking\", \"oneway\",\n+            \"fee\", \"toll\", \"noexit\", \"snowplowing\", \"disabled\", \"lanes\", \"parking\");\n+    private static final List<String> TRANSPORTATION_MODE = List.of(\"foot\", \"ski\", \"inline_skates\",\n+            \"horse\", \"vehicle\", \"bicycle\", \"carriage\", \"trailer\", \"caravan\", \"motor_vehicle\",\n+            \"motorcycle\", \"moped\", \"mofa\", \"motorcar\", \"motorhome\", \"tourist_bus\", \"coach\", \"goods\",\n+            \"hgv\", \"hgv_articulated\", \"agricultural\", \"golf_cart\", \"atv\", \"snowmobile\", \"psv\",\n+            \"bus\", \"minibus\", \"share_taxi\", \"taxi\", \"hov\", \"hazmat\", \"emergency\", \"canoe\",\n+            \"electric_vehicle\", \"cycleway\", \"busway\");\n+    private static final List<String> DIRECTION = List.of(\"forward\", \"backward\", \"left\", \"right\",\n+            \"both\");\n+    private static final List<String> ACCESS_RESTRICTION_VALUE = List.of(\"yes\", \"no\", \"private\",\n+            \"permissive\", \"destination\", \"delivery\", \"customers\", \"designated\", \"use_sidepath\",\n+            \"dismount\", \"agricultural\", \"forestry\", \"discouraged\", \"official\", \"lane\",\n+            \"share_busway\", \"opposite_share_busway\");\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(\n+            \"The conditional key \\\"{0}\\\" does not respect the \\\"<restriction-type>[:<transportation mode>][:<direction>]:conditional\\\" format\",\n+            \"The conditional value \\\"{0}\\\" does not respect the format \\\"<restriction-value> @ <condition>[;<restriction-value> @ <condition>]\\\" \",\n+            \"The element with id {0,number,#} does not follow the conditional restriction pattern.\");\n+    public static final int TWO_PARTS = 2;\n+    public static final int THREE_PARTS = 3;\n+    public static final int FOUR_PARTS = 4;\n+\n+    public ConditionalRestrictionCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+    }\n+\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        // all elements that have a tag containing \":conditional\"\n+        return object.getOsmTags().keySet().stream().anyMatch(key -> key.contains(CONDITIONAL));\n+    }\n+\n+    /**\n+     * Checks if the conditional restrictions respects the format\n+     *\n+     * @param object\n+     *            the atlas object containing a conditional tag\n+     * @return an optional {@link CheckFlag} object\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Set<String> instructions = new HashSet<>();\n+\n+        final List<String> conditionalKeys = object.getOsmTags().keySet().stream()\n+                .filter(key -> key.contains(CONDITIONAL)).collect(Collectors.toList());\n+        for (final String key : conditionalKeys)\n+        {\n+            if (!isKeyValid(key))\n+            {\n+                instructions.add(this.getLocalizedInstruction(0, key));\n+            }\n+            final String value = object.getOsmTags().get(key);\n+            if (!isValueValid(value, key))\n+            {\n+                instructions.add(this.getLocalizedInstruction(1, value));\n+            }\n+        }\n+        if (!instructions.isEmpty())\n+        {\n+            final CheckFlag flag = this.createFlag(object,\n+                    this.getLocalizedInstruction(2, object.getOsmIdentifier()));\n+            instructions.forEach(flag::addInstruction);\n+            return Optional.of(flag);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    private boolean containsTransportationMode(final String key)\n+    {\n+        final String[] parts = key.split(\":\");\n+        for (final String part : parts)\n+        {\n+            if (isTransportationMode(part))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean isAccessType(final String value)\n+    {\n+        return \"access\".equals(value);\n+    }\n+\n+    private boolean isAccessValue(final String value)\n+    {\n+        return ACCESS_RESTRICTION_VALUE.contains(value);\n+    }\n+\n+    private boolean isDirection(final String value)\n+    {\n+        return DIRECTION.contains(value);\n+    }\n+\n+    private boolean isKeyValid(final String key)\n+    {\n+        final String[] parts = key.split(\":\");\n+        // access:lanes is a valid exception for lanes on second position\n+        final boolean isAccessLanes = parts.length > 2\n+                && (isAccessType(parts[0]) && isLanes(parts[1]));\n+        switch (parts.length)\n+        {\n+            // starts with 2 because they all contain the conditional part\n+            case TWO_PARTS:\n+                return isRestrictionType(parts[0]) || isTransportationMode(parts[0]);\n+            case THREE_PARTS:\n+                final boolean isRestrictionTypeFormat = isRestrictionType(parts[0])\n+                        && (isTransportationMode(parts[1]) || isDirection(parts[1]));\n+                final boolean isTransportTypeFormat = isTransportationMode(parts[0])\n+                        && (isDirection(parts[1]) || isLanes(parts[1]));\n+                return isRestrictionTypeFormat || isTransportTypeFormat || isAccessLanes;\n+            case FOUR_PARTS:\n+                final boolean isRestrictionTransport = isRestrictionType(parts[0])\n+                        && isTransportationMode(parts[1]);\n+                final boolean isTransportLanes = isTransportationMode(parts[0])\n+                        && isLanes(parts[1]);\n+                return (isRestrictionTransport || isTransportLanes || isAccessLanes)\n+                        && isDirection(parts[2]);\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean isLanes(final String value)\n+    {\n+        return \"lanes\".equals(value);\n+    }\n+\n+    private boolean isNotLanesType(final String key)\n+    {\n+        final String[] parts = key.split(\":\");\n+        return !isLanes(parts[0]);\n+    }\n+\n+    private boolean isRestrictionType(final String value)\n+    {\n+        return RESTRICTION_TYPES.contains(value);\n+    }\n+\n+    private boolean isTransportationMode(final String value)\n+    {\n+        return TRANSPORTATION_MODE.contains(value);\n+    }\n+\n+    private boolean isValueValid(final String value, final String key)\n+    {\n+        boolean isValid = true;", "originalCommit": "a6c8fbd0b70c648811d93af920715301363f2209", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "53511267adc33971601a730387422341404a76ea", "url": "https://github.com/osmlab/atlas-checks/commit/53511267adc33971601a730387422341404a76ea", "message": "PR comment changes\n\nMade minor code changes based on the pull request\ncomments", "committedDate": "2020-07-03T08:24:13Z", "type": "commit"}, {"oid": "3ad847f2025790fd4f22de7fa4fe64acd71f3ef2", "url": "https://github.com/osmlab/atlas-checks/commit/3ad847f2025790fd4f22de7fa4fe64acd71f3ef2", "message": "Merge pull request #2 from osmlab/dev\n\nMerge Head", "committedDate": "2020-07-03T08:46:34Z", "type": "commit"}, {"oid": "c5c0a14c16d2fce52aa2723141d12e67cd07eab0", "url": "https://github.com/osmlab/atlas-checks/commit/c5c0a14c16d2fce52aa2723141d12e67cd07eab0", "message": "Merge branch 'dev' into conditional-restriction-check", "committedDate": "2020-07-03T10:32:44Z", "type": "commit"}, {"oid": "d2723c05ce98652bec61041eb8a0b9eaeb18ce7f", "url": "https://github.com/osmlab/atlas-checks/commit/d2723c05ce98652bec61041eb8a0b9eaeb18ce7f", "message": "Bug fix\n\nRemoved unnecessary variable creation", "committedDate": "2020-07-03T10:37:29Z", "type": "commit"}]}