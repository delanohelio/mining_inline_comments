{"pr_number": 385, "pr_title": "CheckFlag Deserializer and OpenStreetMapCheckFlagConverter", "pr_createdAt": "2020-10-16T22:25:48Z", "pr_url": "https://github.com/osmlab/atlas-checks/pull/385", "timeline": [{"oid": "12a8bab5e27f8c4f88d175d446ec17ec49bf99a2", "url": "https://github.com/osmlab/atlas-checks/commit/12a8bab5e27f8c4f88d175d446ec17ec49bf99a2", "message": "full flag deserializer & OSMify CheckFlag", "committedDate": "2020-10-16T20:23:33Z", "type": "commit"}, {"oid": "127870375b8abe78679c3c387f2d99215353a870", "url": "https://github.com/osmlab/atlas-checks/commit/127870375b8abe78679c3c387f2d99215353a870", "message": "merge latest", "committedDate": "2020-10-16T20:25:27Z", "type": "commit"}, {"oid": "789a32e85da5dbff2d833d3918111f36c041f487", "url": "https://github.com/osmlab/atlas-checks/commit/789a32e85da5dbff2d833d3918111f36c041f487", "message": "revert generator change", "committedDate": "2020-10-16T22:03:55Z", "type": "commit"}, {"oid": "662516af576cb2b127b29a3a93143fa564c7c2de", "url": "https://github.com/osmlab/atlas-checks/commit/662516af576cb2b127b29a3a93143fa564c7c2de", "message": "revert basecheck change", "committedDate": "2020-10-16T22:07:48Z", "type": "commit"}, {"oid": "7dbe9d5a70a5eec2cf4fc97ae9cfd18ed99df44c", "url": "https://github.com/osmlab/atlas-checks/commit/7dbe9d5a70a5eec2cf4fc97ae9cfd18ed99df44c", "message": "merge latest", "committedDate": "2020-10-23T20:03:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk3Nzg2Nw==", "url": "https://github.com/osmlab/atlas-checks/pull/385#discussion_r512977867", "bodyText": "Would this sort order be useful outside of this method's context, for example as a public method? in case other tools need to use this", "author": "seancoulter", "createdAt": "2020-10-27T19:39:04Z", "path": "src/main/java/org/openstreetmap/atlas/checks/flag/serializer/CheckFlagDeserializer.java", "diffHunk": "@@ -51,15 +96,303 @@ public CheckFlag deserialize(final JsonElement json, final Type typeOfT,\n         final JsonObject full = json.getAsJsonObject();\n         final JsonObject properties = full.get(PROPERTIES).getAsJsonObject();\n         final String checkName = properties.get(GENERATOR).getAsString();\n-        final String instruction = properties.get(INSTRUCTIONS).getAsString();\n-        final String flagIdentifier = properties.get(IDENTIFIERS) == null\n-                ? properties.get(ID).getAsString()\n-                // Convert array of ids into comma delimited string\n-                : parseIdentifiers((JsonArray) properties.get(IDENTIFIERS));\n+        // Split the instructions using the new line character and remove the prepended instruction\n+        // number\n+        final List<String> instructions = Arrays\n+                .stream(properties.get(INSTRUCTIONS).getAsString().split(\"\\n\"))\n+                .map(instruction -> instruction.replaceAll(\"^\\\\d+\\\\. \",\n+                        CommonConstants.EMPTY_STRING))\n+                .collect(Collectors.toList());\n+        final String flagIdentifier = properties.get(ID).getAsString();\n         final CheckFlag flag = new CheckFlag(flagIdentifier);\n-        flag.addInstruction(instruction);\n+        flag.addInstructions(instructions);\n         flag.setChallengeName(checkName);\n \n+        final GeoJsonItem geojsonItem = GEOJSON_PARSER_GSON.deserialize(GSON.toJson(json));\n+\n+        // This should never be the case\n+        if (!(geojsonItem instanceof FeatureCollection))\n+        {\n+            return flag;\n+        }\n+\n+        // Deserialize all features and their fix suggestions\n+        ((FeatureCollection) geojsonItem).getFeatures().forEach(feature ->\n+        {\n+            // If the feature is a synthetic point just add its geometry\n+            if (feature.getProperties().asMap().containsKey(SyntheticHighlightPointTag.KEY)\n+                    && feature.getGeometry() instanceof Point)\n+            {\n+                flag.addPoint(((Point) feature.getGeometry()).toAtlasGeometry());\n+            }\n+            else\n+            {\n+                // Convert the geojson feature into and AtlasEntity and add it to the flag\n+                GeoJsonFeatureToAtlasEntityConverter.convert(feature).ifPresent(entity ->\n+                {\n+                    // If it is a relation, we need to add its geometry separately\n+                    if (entity instanceof Relation)\n+                    {\n+                        flag.addObject(new FlaggedRelation((Relation) entity,\n+                                ((MultiPolygon) feature.getGeometry()).toAtlasGeometry()));\n+                    }\n+                    else\n+                    {\n+                        flag.addObject(entity);\n+                    }\n+                    // If there is a fix suggestion for the object, reconstruct it to a\n+                    // FeatureChange and add it to the flag\n+                    if (full.has(FIX_SUGGESTIONS))\n+                    {\n+                        this.getFixSuggestion(entity, full.get(FIX_SUGGESTIONS).getAsJsonObject())\n+                                .ifPresent(flag::addFixSuggestion);\n+                    }\n+                });\n+            }\n+        });\n+\n         return flag;\n     }\n+\n+    /**\n+     * Apply geometry change descriptors to a CompleteEntity.\n+     *\n+     * @param afterView\n+     *            {@link CompleteEntity} to apply the change to\n+     * @param descriptors\n+     *            {@link Lists}\n+     */\n+    private void applyGeometryChanges(final CompleteEntity afterView,\n+            final List<JsonObject> descriptors)\n+    {\n+        // Copy the geometry to apply the changes to\n+        final List<Location> newGeometry = Lists.newArrayList(afterView.getGeometry());\n+\n+        // Sort the geometry changes by position and type, as order of application matters\n+        descriptors.stream()\n+                .sorted(Comparator.comparingInt(descriptor -> Integer\n+                        .valueOf(descriptor.get(POSITION).getAsString().split(\"/\")[0])))\n+                .sorted(Comparator.comparing(descriptor -> ChangeDescriptorType.valueOf(\n+                        descriptor.get(GeoJsonConstants.TYPE).getAsString().toUpperCase())))", "originalCommit": "7dbe9d5a70a5eec2cf4fc97ae9cfd18ed99df44c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA2ODYwMw==", "url": "https://github.com/osmlab/atlas-checks/pull/385#discussion_r513068603", "bodyText": "Also I believe the current sorting scheme is only sorting by type (as it's the terminal operation)-- if we wanted to achieve sorting by position then type, we could use Comparator.thenComparing()", "author": "seancoulter", "createdAt": "2020-10-27T22:23:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk3Nzg2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYwMTUwMg==", "url": "https://github.com/osmlab/atlas-checks/pull/385#discussion_r513601502", "bodyText": "The effect here is that it is sorted by type and then position. However I had forgotten about .thenComparing so I have updated this to use that.", "author": "Bentleysb", "createdAt": "2020-10-28T16:47:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk3Nzg2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYyMTIzNA==", "url": "https://github.com/osmlab/atlas-checks/pull/385#discussion_r513621234", "bodyText": "This sorting was arrived at through a bit of a trial and error process, as it is somewhat hard to decipher the exact system that is used to arrive at the change descriptions for this. The descriptors are created using a list diff form the git/github algorithms. I tested a bunch of geometry changes with combination of adds, removes and replaces in different places, and this appeared to work every time to rebuild from the diff.", "author": "Bentleysb", "createdAt": "2020-10-28T17:14:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk3Nzg2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzAzODA5OA==", "url": "https://github.com/osmlab/atlas-checks/pull/385#discussion_r513038098", "bodyText": "any potential side effects if the remove operation leaves the relation bean empty?", "author": "seancoulter", "createdAt": "2020-10-27T21:17:20Z", "path": "src/main/java/org/openstreetmap/atlas/checks/flag/serializer/CheckFlagDeserializer.java", "diffHunk": "@@ -51,15 +96,303 @@ public CheckFlag deserialize(final JsonElement json, final Type typeOfT,\n         final JsonObject full = json.getAsJsonObject();\n         final JsonObject properties = full.get(PROPERTIES).getAsJsonObject();\n         final String checkName = properties.get(GENERATOR).getAsString();\n-        final String instruction = properties.get(INSTRUCTIONS).getAsString();\n-        final String flagIdentifier = properties.get(IDENTIFIERS) == null\n-                ? properties.get(ID).getAsString()\n-                // Convert array of ids into comma delimited string\n-                : parseIdentifiers((JsonArray) properties.get(IDENTIFIERS));\n+        // Split the instructions using the new line character and remove the prepended instruction\n+        // number\n+        final List<String> instructions = Arrays\n+                .stream(properties.get(INSTRUCTIONS).getAsString().split(\"\\n\"))\n+                .map(instruction -> instruction.replaceAll(\"^\\\\d+\\\\. \",\n+                        CommonConstants.EMPTY_STRING))\n+                .collect(Collectors.toList());\n+        final String flagIdentifier = properties.get(ID).getAsString();\n         final CheckFlag flag = new CheckFlag(flagIdentifier);\n-        flag.addInstruction(instruction);\n+        flag.addInstructions(instructions);\n         flag.setChallengeName(checkName);\n \n+        final GeoJsonItem geojsonItem = GEOJSON_PARSER_GSON.deserialize(GSON.toJson(json));\n+\n+        // This should never be the case\n+        if (!(geojsonItem instanceof FeatureCollection))\n+        {\n+            return flag;\n+        }\n+\n+        // Deserialize all features and their fix suggestions\n+        ((FeatureCollection) geojsonItem).getFeatures().forEach(feature ->\n+        {\n+            // If the feature is a synthetic point just add its geometry\n+            if (feature.getProperties().asMap().containsKey(SyntheticHighlightPointTag.KEY)\n+                    && feature.getGeometry() instanceof Point)\n+            {\n+                flag.addPoint(((Point) feature.getGeometry()).toAtlasGeometry());\n+            }\n+            else\n+            {\n+                // Convert the geojson feature into and AtlasEntity and add it to the flag\n+                GeoJsonFeatureToAtlasEntityConverter.convert(feature).ifPresent(entity ->\n+                {\n+                    // If it is a relation, we need to add its geometry separately\n+                    if (entity instanceof Relation)\n+                    {\n+                        flag.addObject(new FlaggedRelation((Relation) entity,\n+                                ((MultiPolygon) feature.getGeometry()).toAtlasGeometry()));\n+                    }\n+                    else\n+                    {\n+                        flag.addObject(entity);\n+                    }\n+                    // If there is a fix suggestion for the object, reconstruct it to a\n+                    // FeatureChange and add it to the flag\n+                    if (full.has(FIX_SUGGESTIONS))\n+                    {\n+                        this.getFixSuggestion(entity, full.get(FIX_SUGGESTIONS).getAsJsonObject())\n+                                .ifPresent(flag::addFixSuggestion);\n+                    }\n+                });\n+            }\n+        });\n+\n         return flag;\n     }\n+\n+    /**\n+     * Apply geometry change descriptors to a CompleteEntity.\n+     *\n+     * @param afterView\n+     *            {@link CompleteEntity} to apply the change to\n+     * @param descriptors\n+     *            {@link Lists}\n+     */\n+    private void applyGeometryChanges(final CompleteEntity afterView,\n+            final List<JsonObject> descriptors)\n+    {\n+        // Copy the geometry to apply the changes to\n+        final List<Location> newGeometry = Lists.newArrayList(afterView.getGeometry());\n+\n+        // Sort the geometry changes by position and type, as order of application matters\n+        descriptors.stream()\n+                .sorted(Comparator.comparingInt(descriptor -> Integer\n+                        .valueOf(descriptor.get(POSITION).getAsString().split(\"/\")[0])))\n+                .sorted(Comparator.comparing(descriptor -> ChangeDescriptorType.valueOf(\n+                        descriptor.get(GeoJsonConstants.TYPE).getAsString().toUpperCase())))\n+                // Apply each change\n+                .forEach(descriptor ->\n+                {\n+                    final Integer position = Integer\n+                            .valueOf(descriptor.get(POSITION).getAsString().split(\"/\")[0]);\n+                    switch (ChangeDescriptorType.valueOf(\n+                            descriptor.get(GeoJsonConstants.TYPE).getAsString().toUpperCase()))\n+                    {\n+                        // Apply added location in reverse order so that they push each other\n+                        // forward from the given position\n+                        case ADD:\n+                            Lists.reverse(this.convertWktToLocations(\n+                                    descriptor.get(AFTER_VIEW).getAsString()))\n+                                    .forEach(location -> newGeometry.add(position, location));\n+                            break;\n+                        // Just remove the location at the position\n+                        case REMOVE:\n+                            newGeometry.remove(position.intValue());\n+                            break;\n+                        // Updates must override one existing location, but may add beyond the\n+                        // current length of the geometry\n+                        case UPDATE:\n+                            final List<Location> updateLocations = this.convertWktToLocations(\n+                                    descriptor.get(AFTER_VIEW).getAsString());\n+                            for (int index = 0; index < updateLocations.size(); index++)\n+                            {\n+                                // If this is an existing position, replace it\n+                                if (newGeometry.size() > position + index)\n+                                {\n+                                    newGeometry.set(position + index, updateLocations.get(index));\n+                                }\n+                                // Else add to the end\n+                                else\n+                                {\n+                                    newGeometry.add(updateLocations.get(index));\n+                                }\n+                            }\n+                            break;\n+                        default:\n+                            break;\n+                    }\n+                });\n+\n+        afterView.withGeometry(newGeometry);\n+    }\n+\n+    /**\n+     * Apply a relation member change descriptor to a CompleteEntity.\n+     *\n+     * @param afterView\n+     *            {@link CompleteEntity}\n+     * @param descriptor\n+     *            {@link JsonObject} relation member change descriptor\n+     */\n+    private void applyRelationMemberChange(final CompleteEntity afterView,\n+            final JsonObject descriptor)\n+    {\n+        // Only apply to relations\n+        if (afterView instanceof CompleteRelation)\n+        {\n+            // Generate a bean item form the description\n+            final RelationBean.RelationBeanItem member = new RelationBean.RelationBeanItem(\n+                    descriptor.get(ID).getAsLong(), descriptor.get(ROLE).getAsString(),\n+                    ItemType.valueOf(descriptor.get(ITEM_TYPE).getAsString().toUpperCase()));\n+\n+            // Get the existing relation bean. A RelationBean must be used to apply the change\n+            // because the bounds of the member cannot be automatically calculated\n+            final RelationBean bean = ((CompleteRelation) afterView).getBean();\n+\n+            switch (ChangeDescriptorType\n+                    .valueOf(descriptor.get(GeoJsonConstants.TYPE).getAsString().toUpperCase()))\n+            {\n+                // Add the new member to the bean and add the bean to the relation\n+                case ADD:\n+                    bean.add(member);\n+                    ((CompleteRelation) afterView).withMembers(bean,\n+                            ((CompleteRelation) afterView).bounds());\n+                    break;\n+                // Remove the member from the bean and add the bean to the relation\n+                case REMOVE:\n+                    bean.removeItem(member);\n+                    ((CompleteRelation) afterView).withMembers(bean,", "originalCommit": "7dbe9d5a70a5eec2cf4fc97ae9cfd18ed99df44c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYwMTU0Mw==", "url": "https://github.com/osmlab/atlas-checks/pull/385#discussion_r513601543", "bodyText": "It could have some side effects to downstream processes if they assume that there aren't pointless relations with no members, but the check flag that gets created will still be valid.", "author": "Bentleysb", "createdAt": "2020-10-28T16:47:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzAzODA5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzAzODY4OQ==", "url": "https://github.com/osmlab/atlas-checks/pull/385#discussion_r513038689", "bodyText": "Might be useful to log the ParseException as well", "author": "seancoulter", "createdAt": "2020-10-27T21:18:37Z", "path": "src/main/java/org/openstreetmap/atlas/checks/flag/serializer/CheckFlagDeserializer.java", "diffHunk": "@@ -51,15 +96,303 @@ public CheckFlag deserialize(final JsonElement json, final Type typeOfT,\n         final JsonObject full = json.getAsJsonObject();\n         final JsonObject properties = full.get(PROPERTIES).getAsJsonObject();\n         final String checkName = properties.get(GENERATOR).getAsString();\n-        final String instruction = properties.get(INSTRUCTIONS).getAsString();\n-        final String flagIdentifier = properties.get(IDENTIFIERS) == null\n-                ? properties.get(ID).getAsString()\n-                // Convert array of ids into comma delimited string\n-                : parseIdentifiers((JsonArray) properties.get(IDENTIFIERS));\n+        // Split the instructions using the new line character and remove the prepended instruction\n+        // number\n+        final List<String> instructions = Arrays\n+                .stream(properties.get(INSTRUCTIONS).getAsString().split(\"\\n\"))\n+                .map(instruction -> instruction.replaceAll(\"^\\\\d+\\\\. \",\n+                        CommonConstants.EMPTY_STRING))\n+                .collect(Collectors.toList());\n+        final String flagIdentifier = properties.get(ID).getAsString();\n         final CheckFlag flag = new CheckFlag(flagIdentifier);\n-        flag.addInstruction(instruction);\n+        flag.addInstructions(instructions);\n         flag.setChallengeName(checkName);\n \n+        final GeoJsonItem geojsonItem = GEOJSON_PARSER_GSON.deserialize(GSON.toJson(json));\n+\n+        // This should never be the case\n+        if (!(geojsonItem instanceof FeatureCollection))\n+        {\n+            return flag;\n+        }\n+\n+        // Deserialize all features and their fix suggestions\n+        ((FeatureCollection) geojsonItem).getFeatures().forEach(feature ->\n+        {\n+            // If the feature is a synthetic point just add its geometry\n+            if (feature.getProperties().asMap().containsKey(SyntheticHighlightPointTag.KEY)\n+                    && feature.getGeometry() instanceof Point)\n+            {\n+                flag.addPoint(((Point) feature.getGeometry()).toAtlasGeometry());\n+            }\n+            else\n+            {\n+                // Convert the geojson feature into and AtlasEntity and add it to the flag\n+                GeoJsonFeatureToAtlasEntityConverter.convert(feature).ifPresent(entity ->\n+                {\n+                    // If it is a relation, we need to add its geometry separately\n+                    if (entity instanceof Relation)\n+                    {\n+                        flag.addObject(new FlaggedRelation((Relation) entity,\n+                                ((MultiPolygon) feature.getGeometry()).toAtlasGeometry()));\n+                    }\n+                    else\n+                    {\n+                        flag.addObject(entity);\n+                    }\n+                    // If there is a fix suggestion for the object, reconstruct it to a\n+                    // FeatureChange and add it to the flag\n+                    if (full.has(FIX_SUGGESTIONS))\n+                    {\n+                        this.getFixSuggestion(entity, full.get(FIX_SUGGESTIONS).getAsJsonObject())\n+                                .ifPresent(flag::addFixSuggestion);\n+                    }\n+                });\n+            }\n+        });\n+\n         return flag;\n     }\n+\n+    /**\n+     * Apply geometry change descriptors to a CompleteEntity.\n+     *\n+     * @param afterView\n+     *            {@link CompleteEntity} to apply the change to\n+     * @param descriptors\n+     *            {@link Lists}\n+     */\n+    private void applyGeometryChanges(final CompleteEntity afterView,\n+            final List<JsonObject> descriptors)\n+    {\n+        // Copy the geometry to apply the changes to\n+        final List<Location> newGeometry = Lists.newArrayList(afterView.getGeometry());\n+\n+        // Sort the geometry changes by position and type, as order of application matters\n+        descriptors.stream()\n+                .sorted(Comparator.comparingInt(descriptor -> Integer\n+                        .valueOf(descriptor.get(POSITION).getAsString().split(\"/\")[0])))\n+                .sorted(Comparator.comparing(descriptor -> ChangeDescriptorType.valueOf(\n+                        descriptor.get(GeoJsonConstants.TYPE).getAsString().toUpperCase())))\n+                // Apply each change\n+                .forEach(descriptor ->\n+                {\n+                    final Integer position = Integer\n+                            .valueOf(descriptor.get(POSITION).getAsString().split(\"/\")[0]);\n+                    switch (ChangeDescriptorType.valueOf(\n+                            descriptor.get(GeoJsonConstants.TYPE).getAsString().toUpperCase()))\n+                    {\n+                        // Apply added location in reverse order so that they push each other\n+                        // forward from the given position\n+                        case ADD:\n+                            Lists.reverse(this.convertWktToLocations(\n+                                    descriptor.get(AFTER_VIEW).getAsString()))\n+                                    .forEach(location -> newGeometry.add(position, location));\n+                            break;\n+                        // Just remove the location at the position\n+                        case REMOVE:\n+                            newGeometry.remove(position.intValue());\n+                            break;\n+                        // Updates must override one existing location, but may add beyond the\n+                        // current length of the geometry\n+                        case UPDATE:\n+                            final List<Location> updateLocations = this.convertWktToLocations(\n+                                    descriptor.get(AFTER_VIEW).getAsString());\n+                            for (int index = 0; index < updateLocations.size(); index++)\n+                            {\n+                                // If this is an existing position, replace it\n+                                if (newGeometry.size() > position + index)\n+                                {\n+                                    newGeometry.set(position + index, updateLocations.get(index));\n+                                }\n+                                // Else add to the end\n+                                else\n+                                {\n+                                    newGeometry.add(updateLocations.get(index));\n+                                }\n+                            }\n+                            break;\n+                        default:\n+                            break;\n+                    }\n+                });\n+\n+        afterView.withGeometry(newGeometry);\n+    }\n+\n+    /**\n+     * Apply a relation member change descriptor to a CompleteEntity.\n+     *\n+     * @param afterView\n+     *            {@link CompleteEntity}\n+     * @param descriptor\n+     *            {@link JsonObject} relation member change descriptor\n+     */\n+    private void applyRelationMemberChange(final CompleteEntity afterView,\n+            final JsonObject descriptor)\n+    {\n+        // Only apply to relations\n+        if (afterView instanceof CompleteRelation)\n+        {\n+            // Generate a bean item form the description\n+            final RelationBean.RelationBeanItem member = new RelationBean.RelationBeanItem(\n+                    descriptor.get(ID).getAsLong(), descriptor.get(ROLE).getAsString(),\n+                    ItemType.valueOf(descriptor.get(ITEM_TYPE).getAsString().toUpperCase()));\n+\n+            // Get the existing relation bean. A RelationBean must be used to apply the change\n+            // because the bounds of the member cannot be automatically calculated\n+            final RelationBean bean = ((CompleteRelation) afterView).getBean();\n+\n+            switch (ChangeDescriptorType\n+                    .valueOf(descriptor.get(GeoJsonConstants.TYPE).getAsString().toUpperCase()))\n+            {\n+                // Add the new member to the bean and add the bean to the relation\n+                case ADD:\n+                    bean.add(member);\n+                    ((CompleteRelation) afterView).withMembers(bean,\n+                            ((CompleteRelation) afterView).bounds());\n+                    break;\n+                // Remove the member from the bean and add the bean to the relation\n+                case REMOVE:\n+                    bean.removeItem(member);\n+                    ((CompleteRelation) afterView).withMembers(bean,\n+                            ((CompleteRelation) afterView).bounds());\n+                    break;\n+                default:\n+                    break;\n+\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Apply a tag change descriptor to a CompleteEntity.\n+     *\n+     * @param afterView\n+     *            {@link CompleteEntity}\n+     * @param descriptor\n+     *            {@link JsonObject} tag change descriptor\n+     */\n+    private void applyTagChange(final CompleteEntity afterView, final JsonObject descriptor)\n+    {\n+        final String key = descriptor.get(\"key\").getAsString();\n+        final String value = descriptor.get(\"value\").getAsString();\n+\n+        switch (ChangeDescriptorType\n+                .valueOf(descriptor.get(GeoJsonConstants.TYPE).getAsString().toUpperCase()))\n+        {\n+            case ADD:\n+                afterView.withAddedTag(key, value);\n+                break;\n+            case REMOVE:\n+                afterView.withRemovedTag(key);\n+                break;\n+            case UPDATE:\n+                afterView.withReplacedTag(key, key, value);\n+                break;\n+            default:\n+                break;\n+        }\n+    }\n+\n+    /**\n+     * Convert a WKT point, linestring, or polygon to a List of Locations\n+     *\n+     * @param wkt\n+     *            {@link String}\n+     * @return {@link List} of {@link Location}s\n+     */\n+    private List<Location> convertWktToLocations(final String wkt)\n+    {\n+        try\n+        {\n+            return Lists.newArrayList(COORDINATE_ARRAY_CONVERTER.backwardConvert(\n+                    new CoordinateArraySequence(WKT_READER.read(wkt).getCoordinates())));\n+        }\n+        catch (final ParseException parseException)\n+        {\n+            throw new CoreException(\"Cannot parse wkt : {}\", wkt);", "originalCommit": "7dbe9d5a70a5eec2cf4fc97ae9cfd18ed99df44c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYwMTU3OQ==", "url": "https://github.com/osmlab/atlas-checks/pull/385#discussion_r513601579", "bodyText": "Good call.", "author": "Bentleysb", "createdAt": "2020-10-28T16:47:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzAzODY4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA2Mjk0OA==", "url": "https://github.com/osmlab/atlas-checks/pull/385#discussion_r513062948", "bodyText": "\"concatenate\" when it comes to Polylines really means merging them together, correct?", "author": "seancoulter", "createdAt": "2020-10-27T22:09:54Z", "path": "src/main/java/org/openstreetmap/atlas/checks/utility/OpenStreetMapCheckFlagConverter.java", "diffHunk": "@@ -0,0 +1,209 @@\n+package org.openstreetmap.atlas.checks.utility;\n+\n+import static org.openstreetmap.atlas.checks.flag.CheckFlag.NULL_IDENTIFIERS;\n+\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.openstreetmap.atlas.checks.constants.CommonConstants;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.flag.FlaggedObject;\n+import org.openstreetmap.atlas.checks.flag.FlaggedPolyline;\n+import org.openstreetmap.atlas.exception.CoreException;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.atlas.change.FeatureChange;\n+import org.openstreetmap.atlas.geography.atlas.complete.CompleteEdge;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.ItemType;\n+\n+/**\n+ * Utility to convert a {@link CheckFlag} into an OpenStreetMap like {@link CheckFlag}. This\n+ * currently means removing {@link org.openstreetmap.atlas.geography.atlas.items.Point} based\n+ * {@link FlaggedObject}s and {@link FeatureChange} suggestions that are also flagged as a node, and\n+ * merging the geometries of {@link Edge} based {@link FlaggedObject}s and suggestions that share an\n+ * OSM ID.\n+ *\n+ * @author bbreithaupt\n+ */\n+public final class OpenStreetMapCheckFlagConverter\n+{\n+\n+    /**\n+     * Attempt to create an OpenStreetMap CheckFlag by removing\n+     * {@link org.openstreetmap.atlas.geography.atlas.items.Point}s duplicatly flagged as\n+     * {@link org.openstreetmap.atlas.geography.atlas.items.Node}s, and merging {@link Edge}s that\n+     * share an OSM ID.\n+     *\n+     * @param flag\n+     *            {@link CheckFlag}\n+     * @return {@link Optional} OSM {@link CheckFlag}\n+     */\n+    public static Optional<CheckFlag> openStreetMapify(final CheckFlag flag)\n+    {\n+        // Copy the identifier and instructions\n+        final CheckFlag newFlag = new CheckFlag(flag.getIdentifier());\n+        newFlag.addInstructions(flag.getRawInstructions());\n+\n+        // Map objects by their unique osm id\n+        final Map<String, Set<FlaggedObject>> objectsMap = new HashMap<>();\n+        flag.getFlaggedObjects().forEach(object ->\n+        {\n+            final String osmIdentifier = object.getUniqueIdentifier().replaceFirst(\"\\\\d{6}$\",\n+                    CommonConstants.EMPTY_STRING);\n+            objectsMap.putIfAbsent(osmIdentifier, new HashSet<>());\n+            objectsMap.get(osmIdentifier).add(object);\n+        });\n+\n+        // Map feature changes by their unique osm id\n+        final Map<String, Set<FeatureChange>> suggestionMap = new HashMap<>();\n+        flag.getFixSuggestions().forEach(suggestion ->\n+        {\n+            final String osmIdentifier = String.format(\"%s%s\",\n+                    StringUtils.capitalize(suggestion.getBeforeView().getType().toString()),\n+                    suggestion.getBeforeView().getOsmIdentifier());\n+            suggestionMap.putIfAbsent(osmIdentifier, new HashSet<>());\n+            suggestionMap.get(osmIdentifier).add(suggestion);\n+        });\n+\n+        try\n+        {\n+            // Re-add points\n+            objectsMap.entrySet().stream()\n+                    .filter(entry -> entry.getKey().equalsIgnoreCase(NULL_IDENTIFIERS))\n+                    .flatMap(entry -> entry.getValue().stream()).forEach(newFlag::addObject);\n+            // Convert and add atlas based features\n+            convertFlaggedObjects(objectsMap, newFlag);\n+            // Convert and add suggestions\n+            convertFixSuggestions(suggestionMap, newFlag);\n+        }\n+        catch (final CoreException exception)\n+        {\n+            return Optional.empty();\n+        }\n+\n+        return Optional.of(newFlag);\n+    }\n+\n+    /**\n+     * Merge {@link FeatureChange} fix suggestions to make them OSMified.\n+     *\n+     * @param suggestionMap\n+     *            {@link Map} of {@link FeatureChange}s by unique OSM ID\n+     * @param newFlag\n+     *            {@link CheckFlag} to add the converted suggestions to\n+     */\n+    private static void convertFixSuggestions(final Map<String, Set<FeatureChange>> suggestionMap,\n+            final CheckFlag newFlag)\n+    {\n+        // Go through each entry\n+        suggestionMap.entrySet().stream().flatMap(entry ->\n+        {\n+            // Use the first feature change as a base for the merged one\n+            final FeatureChange firstFeatureChange = entry.getValue().iterator().next();\n+            switch (entry.getValue().iterator().next().getBeforeView().getType())\n+            {\n+                // Merge edge FeatureChanges by concatenating the geometries of the before and after\n+                // views and applying them to a copy of the first feature change\n+                case EDGE:\n+                    // Sort the before views and concatenate their geometries\n+                    final Optional<PolyLine> concatenatedBeforePolyline = entry.getValue().stream()\n+                            .map(FeatureChange::getBeforeView)\n+                            .sorted(Comparator.comparing(AtlasEntity::getIdentifier))\n+                            .map(entity -> ((Edge) entity).asPolyLine()).reduce(PolyLine::append);", "originalCommit": "7dbe9d5a70a5eec2cf4fc97ae9cfd18ed99df44c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYwMTYxOQ==", "url": "https://github.com/osmlab/atlas-checks/pull/385#discussion_r513601619", "bodyText": "yes", "author": "Bentleysb", "createdAt": "2020-10-28T16:47:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA2Mjk0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA3NzEwMQ==", "url": "https://github.com/osmlab/atlas-checks/pull/385#discussion_r513077101", "bodyText": "Just a thought-- since the flagged object conversion is lossy in terms of relation identifiers and other feature-dependent data, we might want to (if not already) have some way of recovering that or at least merging it with the existing feature when we're applying fix suggestions in MR", "author": "seancoulter", "createdAt": "2020-10-27T22:45:53Z", "path": "src/main/java/org/openstreetmap/atlas/checks/flag/serializer/GeoJsonFeatureToAtlasEntityConverter.java", "diffHunk": "@@ -0,0 +1,203 @@\n+package org.openstreetmap.atlas.checks.flag.serializer;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.TreeSet;\n+\n+import org.openstreetmap.atlas.geography.Polygon;\n+import org.openstreetmap.atlas.geography.atlas.builder.RelationBean;\n+import org.openstreetmap.atlas.geography.atlas.complete.CompleteArea;\n+import org.openstreetmap.atlas.geography.atlas.complete.CompleteEdge;\n+import org.openstreetmap.atlas.geography.atlas.complete.CompleteLine;\n+import org.openstreetmap.atlas.geography.atlas.complete.CompleteNode;\n+import org.openstreetmap.atlas.geography.atlas.complete.CompletePoint;\n+import org.openstreetmap.atlas.geography.atlas.complete.CompleteRelation;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.ItemType;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Relation;\n+import org.openstreetmap.atlas.geography.geojson.GeoJsonUtils;\n+import org.openstreetmap.atlas.geography.geojson.parser.domain.feature.Feature;\n+import org.openstreetmap.atlas.geography.geojson.parser.domain.geometry.LineString;\n+import org.openstreetmap.atlas.geography.geojson.parser.domain.geometry.MultiPolygon;\n+import org.openstreetmap.atlas.geography.geojson.parser.domain.geometry.Point;\n+\n+/**\n+ * A GeoJson {@link Feature} to an {@link AtlasEntity} converter.\n+ *\n+ * @author bbreithaupt\n+ */\n+public final class GeoJsonFeatureToAtlasEntityConverter\n+{\n+    private static final List<String> metaProperties = Arrays.asList(GeoJsonUtils.ITEM_TYPE,\n+            GeoJsonUtils.IDENTIFIER, GeoJsonUtils.OSM_IDENTIFIER, \"relations\", \"members\", \"flag:id\",\n+            \"flag:type\");\n+    private static final Long DEFAULT_IDENTIFIER = 0L;\n+\n+    /**\n+     * Attempt to convert a GeoJson {@link Feature} to an {@link AtlasEntity}.\n+     *\n+     * @param feature\n+     *            {@link Feature}\n+     * @return an {@link Optional} {@link AtlasEntity}\n+     */\n+    public static Optional<AtlasEntity> convert(final Feature feature)", "originalCommit": "7dbe9d5a70a5eec2cf4fc97ae9cfd18ed99df44c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYwMTY2OA==", "url": "https://github.com/osmlab/atlas-checks/pull/385#discussion_r513601668", "bodyText": "Initially this should not be a problem while we are focusing on tag change suggestions, but this will likely be something we need to look at for other types of suggestions.", "author": "Bentleysb", "createdAt": "2020-10-28T16:47:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA3NzEwMQ=="}], "type": "inlineReview"}, {"oid": "e09a1a488cd678cfdd9612b35526a59f58c3fab1", "url": "https://github.com/osmlab/atlas-checks/commit/e09a1a488cd678cfdd9612b35526a59f58c3fab1", "message": "clean up", "committedDate": "2020-10-28T16:47:05Z", "type": "commit"}, {"oid": "95ac132bcdc049442c36c34f6682f41c42e04e43", "url": "https://github.com/osmlab/atlas-checks/commit/95ac132bcdc049442c36c34f6682f41c42e04e43", "message": "sonar", "committedDate": "2020-11-02T16:56:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk3NTg2Nw==", "url": "https://github.com/osmlab/atlas-checks/pull/385#discussion_r516975867", "bodyText": "Why is the null check removed?", "author": "sayas01", "createdAt": "2020-11-03T21:50:22Z", "path": "src/main/java/org/openstreetmap/atlas/checks/flag/serializer/CheckFlagDeserializer.java", "diffHunk": "@@ -51,15 +96,306 @@ public CheckFlag deserialize(final JsonElement json, final Type typeOfT,\n         final JsonObject full = json.getAsJsonObject();\n         final JsonObject properties = full.get(PROPERTIES).getAsJsonObject();\n         final String checkName = properties.get(GENERATOR).getAsString();\n-        final String instruction = properties.get(INSTRUCTIONS).getAsString();\n-        final String flagIdentifier = properties.get(IDENTIFIERS) == null", "originalCommit": "95ac132bcdc049442c36c34f6682f41c42e04e43", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzAxMjA1MA==", "url": "https://github.com/osmlab/atlas-checks/pull/385#discussion_r517012050", "bodyText": "This is removed because it is no longer using the unique identifiers for the new flags identifier. The new flag now will have the same identifier as the old, and the unique identifiers can again be calculated from the flagged objects. Essentially, this was a bit of a hack because everything was not being deserialized previously.", "author": "Bentleysb", "createdAt": "2020-11-03T23:19:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk3NTg2Nw=="}], "type": "inlineReview"}]}