{"pr_number": 258, "pr_title": "Add new AtGradeSignPostCheck", "pr_createdAt": "2020-02-11T01:41:56Z", "pr_url": "https://github.com/osmlab/atlas-checks/pull/258", "timeline": [{"oid": "67e387c8f0b642b31e3180a8792cdcb04ebbdf41", "url": "https://github.com/osmlab/atlas-checks/commit/67e387c8f0b642b31e3180a8792cdcb04ebbdf41", "message": "Add check", "committedDate": "2019-12-12T21:02:53Z", "type": "commit"}, {"oid": "ff799ed2e133336896e01bdb1328a74809bba63a", "url": "https://github.com/osmlab/atlas-checks/commit/ff799ed2e133336896e01bdb1328a74809bba63a", "message": "Fix merge conflict", "committedDate": "2019-12-12T21:06:19Z", "type": "commit"}, {"oid": "5486d4bad61f3567abfd4be8bfaa1df70cfc7912", "url": "https://github.com/osmlab/atlas-checks/commit/5486d4bad61f3567abfd4be8bfaa1df70cfc7912", "message": "Handle roundabouts", "committedDate": "2019-12-30T15:42:05Z", "type": "commit"}, {"oid": "fc4cf847871fa61fe29a76bfa0f19b7eae407d37", "url": "https://github.com/osmlab/atlas-checks/commit/fc4cf847871fa61fe29a76bfa0f19b7eae407d37", "message": "spotless and checkstyle", "committedDate": "2019-12-30T16:02:00Z", "type": "commit"}, {"oid": "ec9ea3ead53da54baf749590de8ba27f49a3fc9b", "url": "https://github.com/osmlab/atlas-checks/commit/ec9ea3ead53da54baf749590de8ba27f49a3fc9b", "message": "Update roundabout req", "committedDate": "2020-01-13T19:37:22Z", "type": "commit"}, {"oid": "f54200ef1370e830448f9a28037c2a388376fdaf", "url": "https://github.com/osmlab/atlas-checks/commit/f54200ef1370e830448f9a28037c2a388376fdaf", "message": "Use edge direction", "committedDate": "2020-01-27T15:48:53Z", "type": "commit"}, {"oid": "2884ff9bf62ae1e8415910075640e9cac74b20e6", "url": "https://github.com/osmlab/atlas-checks/commit/2884ff9bf62ae1e8415910075640e9cac74b20e6", "message": "Spotless", "committedDate": "2020-01-27T15:53:26Z", "type": "commit"}, {"oid": "509288f8288a8f20bb58d6947c8e4455c082adf1", "url": "https://github.com/osmlab/atlas-checks/commit/509288f8288a8f20bb58d6947c8e4455c082adf1", "message": "Update java doc and spotless", "committedDate": "2020-02-10T18:23:21Z", "type": "commit"}, {"oid": "5e07b9dc729136d5a8fc3bd22a92b1b75a769ea7", "url": "https://github.com/osmlab/atlas-checks/commit/5e07b9dc729136d5a8fc3bd22a92b1b75a769ea7", "message": "Add doc", "committedDate": "2020-02-10T19:12:25Z", "type": "commit"}, {"oid": "29281e60fefe5576b35e81d8e0772a50caf7bc61", "url": "https://github.com/osmlab/atlas-checks/commit/29281e60fefe5576b35e81d8e0772a50caf7bc61", "message": "Fix typo", "committedDate": "2020-02-10T19:18:16Z", "type": "commit"}, {"oid": "6f2239017f4951d2520044fe65dc0c14fed6adf8", "url": "https://github.com/osmlab/atlas-checks/commit/6f2239017f4951d2520044fe65dc0c14fed6adf8", "message": "Merge branch 'dev' of https://github.com/osmlab/atlas-checks into at-grade", "committedDate": "2020-02-10T19:18:44Z", "type": "commit"}, {"oid": "8a4ce050970fd521195a3b958f0d3473d016b486", "url": "https://github.com/osmlab/atlas-checks/commit/8a4ce050970fd521195a3b958f0d3473d016b486", "message": "Fix checkstyle errors", "committedDate": "2020-02-10T19:39:29Z", "type": "commit"}, {"oid": "db2251159588145501afe20f2f81706ba7dfb349", "url": "https://github.com/osmlab/atlas-checks/commit/db2251159588145501afe20f2f81706ba7dfb349", "message": "Clean up", "committedDate": "2020-02-11T01:29:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM2MDAyNQ==", "url": "https://github.com/osmlab/atlas-checks/pull/258#discussion_r380360025", "bodyText": "Couldn't this just be done by using the keys from the connected highway types map? It looks like it would be a problem if the filter and map had different highway types, as the filter is used in populateInEdgeToOutEdgeMaps to check that the map will have the correct key.", "author": "Bentleysb", "createdAt": "2020-02-17T20:44:53Z", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/AtGradeSignPostCheck.java", "diffHunk": "@@ -0,0 +1,644 @@\n+package org.openstreetmap.atlas.checks.validation.intersections;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Relation;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMember;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMemberList;\n+import org.openstreetmap.atlas.geography.atlas.walker.SimpleEdgeWalker;\n+import org.openstreetmap.atlas.tags.DestinationForwardTag;\n+import org.openstreetmap.atlas.tags.DestinationTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.LevelTag;\n+import org.openstreetmap.atlas.tags.OneWayTag;\n+import org.openstreetmap.atlas.tags.RelationTypeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.StringList;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.direction.EdgeDirectionComparator;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+\n+import com.google.common.collect.ImmutableMap;\n+\n+/**\n+ * Check flags at-grade intersections with missing destination_sign tags or destinations_sign\n+ * relations. An at-grade intersection is an intersection between two edges at the same z-level. In\n+ * case of roundabout edges, intersection between exit edge and roundabout edge are checked for\n+ * either destination_sign relation or destination:forward tag, in case of bi-directional exit edge,\n+ * or destination tag, in case of unidirectional exit edge.\n+ *\n+ * @author sayas01\n+ */\n+public class AtGradeSignPostCheck extends BaseCheck<String>\n+{\n+    /**\n+     * A class for holding flagged intersection items and corresponding flag instruction index\n+     */\n+    private class FlaggedIntersection\n+    {\n+        private int instructionIndex;\n+        private Set<AtlasEntity> setOfFlaggedItems;\n+\n+        FlaggedIntersection(final int instructionIndex, final Set<AtlasEntity> setOfFlaggedItems)\n+        {\n+            this.instructionIndex = instructionIndex;\n+            this.setOfFlaggedItems = setOfFlaggedItems;\n+        }\n+\n+        private Set<AtlasEntity> getFlaggedItems()\n+        {\n+            return this.setOfFlaggedItems;\n+        }\n+\n+        private Integer getInstructionIndex()\n+        {\n+            return this.instructionIndex;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = -7428641176420422187L;\n+    // Valid highway types to be considered for the check\n+    private static final String HIGHWAY_FILTER_DEFAULT = \"highway->trunk,primary,secondary\";\n+    // Primary road (inEdge) connected to trunk, primary, secondary roads (outEdges) are treated as\n+    // valid intersection\n+    private static final List<String> CONNECTIONS_TO_PRIMARY = Arrays.asList(\"trunk\", \"primary\",\n+            \"secondary\");\n+    // Trunk road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_TRUNK = Collections.singletonList(\"primary\");\n+    // Secondary road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_SECONDARY = Collections\n+            .singletonList(\"primary\");\n+    private static final ImmutableMap<String, List<String>> CONNECTED_HIGHWAY_TYPES_MAP = ImmutableMap\n+            .of(\"primary\", CONNECTIONS_TO_PRIMARY, \"trunk\", CONNECTIONS_TO_TRUNK, \"secondary\",\n+                    CONNECTIONS_TO_SECONDARY);\n+    private static final String NO_DESTINATION_SIGN_RELATION_INSTRUCTION = \"Node {0,number,#} forms an at-grade junction but is not part of \"\n+            + \"a destination sign relation. Verify and create a destination sign relation with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, \" + \"as \\\"to\\\" and \\\"from\\\" members.\";\n+    private static final String DESTINATION_SIGN_RELATION_MISSING_DESTINATION_TAG_INSTRUCTION = \"Node {0,number,#} form an at-grade junction. It is part of destination sign relation(s): \"\n+            + \"{1}\" + \"but the relation(s) are missing \\\"destination\\\" tags.\";\n+    private static final String INCOMPLETE_DESTINATION_RELATION_INSTRUCTION = \"Node {0,number,#} forms an \"\n+            + \"at-grade junction and is part of destination sign relation(s). But the following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String ROUNDABOUT_EDGE_MISSING_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction with connected edges. Add destination sign relations with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, as \\\"to\\\" and \\\"from\\\" members and add destination sign tag to the connected edges.\";\n+    private static final String ROUNDABOUT_EDGE_INCOMPLETE_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction. It is part of destination sign relation(s). Either the existing relations are missing destination sign tag or following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Either add destination tags to existing relations or create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String NON_ROUNDABOUT_INTERSECTION_MAP = \"nonRoundaboutMatchingEdgesMap\";\n+    private static final String ROUNDABOUT_INTERSECTION_MAP = \"roundaboutMatchingEdgesMap\";\n+\n+    private static final int INSTRUCTION_INDEX_ZERO = 0;\n+    private static final int INSTRUCTION_INDEX_ONE = 1;\n+    private static final int INSTRUCTION_INDEX_TWO = 2;\n+    private static final int INSTRUCTION_INDEX_THREE = 3;\n+    private static final int INSTRUCTION_INDEX_FOUR = 4;\n+\n+    private static final int MINIMUM_NODE_VALENCE = 3;\n+    private static final Angle DEFAULT_OPPOSITE_DIRECTION_LOWER_LIMIT = Angle.degrees(171);\n+    private static final Angle DEFAULT_OPPOSITE_DIRECTION_UPPER_LIMIT = Angle.degrees(-171);\n+    private static final Angle DEFAULT_SAME_DIRECTION_LOWER_LIMIT = Angle.degrees(-100);\n+    private static final Angle DEFAULT_SAME_DIRECTION_UPPER_LIMIT = Angle.degrees(9);\n+    private static final EdgeDirectionComparator EDGE_DIRECTION_COMPARATOR = new EdgeDirectionComparator(\n+            DEFAULT_OPPOSITE_DIRECTION_LOWER_LIMIT, DEFAULT_OPPOSITE_DIRECTION_UPPER_LIMIT,\n+            DEFAULT_SAME_DIRECTION_LOWER_LIMIT, DEFAULT_SAME_DIRECTION_UPPER_LIMIT);\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(\n+            NO_DESTINATION_SIGN_RELATION_INSTRUCTION,\n+            DESTINATION_SIGN_RELATION_MISSING_DESTINATION_TAG_INSTRUCTION,\n+            INCOMPLETE_DESTINATION_RELATION_INSTRUCTION,\n+            ROUNDABOUT_EDGE_MISSING_DESTINATION_SIGN_RELATION,\n+            ROUNDABOUT_EDGE_INCOMPLETE_DESTINATION_SIGN_RELATION);\n+\n+    private final TaggableFilter highwayFilter;\n+    private Map<String, List<String>> connectedHighwayTypes;\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public AtGradeSignPostCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.highwayFilter = configurationValue(configuration, \"highway.filter\",", "originalCommit": "db2251159588145501afe20f2f81706ba7dfb349", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM2MTE1MQ==", "url": "https://github.com/osmlab/atlas-checks/pull/258#discussion_r380361151", "bodyText": "Old debug statement?", "author": "Bentleysb", "createdAt": "2020-02-17T20:48:42Z", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/AtGradeSignPostCheck.java", "diffHunk": "@@ -0,0 +1,644 @@\n+package org.openstreetmap.atlas.checks.validation.intersections;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Relation;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMember;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMemberList;\n+import org.openstreetmap.atlas.geography.atlas.walker.SimpleEdgeWalker;\n+import org.openstreetmap.atlas.tags.DestinationForwardTag;\n+import org.openstreetmap.atlas.tags.DestinationTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.LevelTag;\n+import org.openstreetmap.atlas.tags.OneWayTag;\n+import org.openstreetmap.atlas.tags.RelationTypeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.StringList;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.direction.EdgeDirectionComparator;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+\n+import com.google.common.collect.ImmutableMap;\n+\n+/**\n+ * Check flags at-grade intersections with missing destination_sign tags or destinations_sign\n+ * relations. An at-grade intersection is an intersection between two edges at the same z-level. In\n+ * case of roundabout edges, intersection between exit edge and roundabout edge are checked for\n+ * either destination_sign relation or destination:forward tag, in case of bi-directional exit edge,\n+ * or destination tag, in case of unidirectional exit edge.\n+ *\n+ * @author sayas01\n+ */\n+public class AtGradeSignPostCheck extends BaseCheck<String>\n+{\n+    /**\n+     * A class for holding flagged intersection items and corresponding flag instruction index\n+     */\n+    private class FlaggedIntersection\n+    {\n+        private int instructionIndex;\n+        private Set<AtlasEntity> setOfFlaggedItems;\n+\n+        FlaggedIntersection(final int instructionIndex, final Set<AtlasEntity> setOfFlaggedItems)\n+        {\n+            this.instructionIndex = instructionIndex;\n+            this.setOfFlaggedItems = setOfFlaggedItems;\n+        }\n+\n+        private Set<AtlasEntity> getFlaggedItems()\n+        {\n+            return this.setOfFlaggedItems;\n+        }\n+\n+        private Integer getInstructionIndex()\n+        {\n+            return this.instructionIndex;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = -7428641176420422187L;\n+    // Valid highway types to be considered for the check\n+    private static final String HIGHWAY_FILTER_DEFAULT = \"highway->trunk,primary,secondary\";\n+    // Primary road (inEdge) connected to trunk, primary, secondary roads (outEdges) are treated as\n+    // valid intersection\n+    private static final List<String> CONNECTIONS_TO_PRIMARY = Arrays.asList(\"trunk\", \"primary\",\n+            \"secondary\");\n+    // Trunk road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_TRUNK = Collections.singletonList(\"primary\");\n+    // Secondary road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_SECONDARY = Collections\n+            .singletonList(\"primary\");\n+    private static final ImmutableMap<String, List<String>> CONNECTED_HIGHWAY_TYPES_MAP = ImmutableMap\n+            .of(\"primary\", CONNECTIONS_TO_PRIMARY, \"trunk\", CONNECTIONS_TO_TRUNK, \"secondary\",\n+                    CONNECTIONS_TO_SECONDARY);\n+    private static final String NO_DESTINATION_SIGN_RELATION_INSTRUCTION = \"Node {0,number,#} forms an at-grade junction but is not part of \"\n+            + \"a destination sign relation. Verify and create a destination sign relation with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, \" + \"as \\\"to\\\" and \\\"from\\\" members.\";\n+    private static final String DESTINATION_SIGN_RELATION_MISSING_DESTINATION_TAG_INSTRUCTION = \"Node {0,number,#} form an at-grade junction. It is part of destination sign relation(s): \"\n+            + \"{1}\" + \"but the relation(s) are missing \\\"destination\\\" tags.\";\n+    private static final String INCOMPLETE_DESTINATION_RELATION_INSTRUCTION = \"Node {0,number,#} forms an \"\n+            + \"at-grade junction and is part of destination sign relation(s). But the following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String ROUNDABOUT_EDGE_MISSING_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction with connected edges. Add destination sign relations with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, as \\\"to\\\" and \\\"from\\\" members and add destination sign tag to the connected edges.\";\n+    private static final String ROUNDABOUT_EDGE_INCOMPLETE_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction. It is part of destination sign relation(s). Either the existing relations are missing destination sign tag or following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Either add destination tags to existing relations or create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String NON_ROUNDABOUT_INTERSECTION_MAP = \"nonRoundaboutMatchingEdgesMap\";\n+    private static final String ROUNDABOUT_INTERSECTION_MAP = \"roundaboutMatchingEdgesMap\";\n+\n+    private static final int INSTRUCTION_INDEX_ZERO = 0;\n+    private static final int INSTRUCTION_INDEX_ONE = 1;\n+    private static final int INSTRUCTION_INDEX_TWO = 2;\n+    private static final int INSTRUCTION_INDEX_THREE = 3;\n+    private static final int INSTRUCTION_INDEX_FOUR = 4;\n+\n+    private static final int MINIMUM_NODE_VALENCE = 3;\n+    private static final Angle DEFAULT_OPPOSITE_DIRECTION_LOWER_LIMIT = Angle.degrees(171);\n+    private static final Angle DEFAULT_OPPOSITE_DIRECTION_UPPER_LIMIT = Angle.degrees(-171);\n+    private static final Angle DEFAULT_SAME_DIRECTION_LOWER_LIMIT = Angle.degrees(-100);\n+    private static final Angle DEFAULT_SAME_DIRECTION_UPPER_LIMIT = Angle.degrees(9);\n+    private static final EdgeDirectionComparator EDGE_DIRECTION_COMPARATOR = new EdgeDirectionComparator(\n+            DEFAULT_OPPOSITE_DIRECTION_LOWER_LIMIT, DEFAULT_OPPOSITE_DIRECTION_UPPER_LIMIT,\n+            DEFAULT_SAME_DIRECTION_LOWER_LIMIT, DEFAULT_SAME_DIRECTION_UPPER_LIMIT);\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(\n+            NO_DESTINATION_SIGN_RELATION_INSTRUCTION,\n+            DESTINATION_SIGN_RELATION_MISSING_DESTINATION_TAG_INSTRUCTION,\n+            INCOMPLETE_DESTINATION_RELATION_INSTRUCTION,\n+            ROUNDABOUT_EDGE_MISSING_DESTINATION_SIGN_RELATION,\n+            ROUNDABOUT_EDGE_INCOMPLETE_DESTINATION_SIGN_RELATION);\n+\n+    private final TaggableFilter highwayFilter;\n+    private Map<String, List<String>> connectedHighwayTypes;\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public AtGradeSignPostCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.highwayFilter = configurationValue(configuration, \"highway.filter\",\n+                HIGHWAY_FILTER_DEFAULT, TaggableFilter::forDefinition);\n+        this.connectedHighwayTypes = this.configurationValue(configuration,\n+                \"connected.highway.types\", CONNECTED_HIGHWAY_TYPES_MAP);\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return object instanceof Node && ((Node) object).valence() >= MINIMUM_NODE_VALENCE\n+                && !this.isFlagged(String.valueOf(object.getIdentifier()));\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        if (String.valueOf(object.getOsmIdentifier()).equals(\"1720823768\"))\n+        {\n+            System.out.println(object);\n+        }", "originalCommit": "db2251159588145501afe20f2f81706ba7dfb349", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM3NTkyOA==", "url": "https://github.com/osmlab/atlas-checks/pull/258#discussion_r380375928", "bodyText": "Yp! Removed it! :)", "author": "sayas01", "createdAt": "2020-02-17T21:47:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM2MTE1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM2NDUyNw==", "url": "https://github.com/osmlab/atlas-checks/pull/258#discussion_r380364527", "bodyText": "This description seems a little confusing,as it seems that the inputs are already filtered for items that aren't part of destination sign relations.", "author": "Bentleysb", "createdAt": "2020-02-17T21:01:39Z", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/AtGradeSignPostCheck.java", "diffHunk": "@@ -0,0 +1,644 @@\n+package org.openstreetmap.atlas.checks.validation.intersections;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Relation;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMember;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMemberList;\n+import org.openstreetmap.atlas.geography.atlas.walker.SimpleEdgeWalker;\n+import org.openstreetmap.atlas.tags.DestinationForwardTag;\n+import org.openstreetmap.atlas.tags.DestinationTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.LevelTag;\n+import org.openstreetmap.atlas.tags.OneWayTag;\n+import org.openstreetmap.atlas.tags.RelationTypeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.StringList;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.direction.EdgeDirectionComparator;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+\n+import com.google.common.collect.ImmutableMap;\n+\n+/**\n+ * Check flags at-grade intersections with missing destination_sign tags or destinations_sign\n+ * relations. An at-grade intersection is an intersection between two edges at the same z-level. In\n+ * case of roundabout edges, intersection between exit edge and roundabout edge are checked for\n+ * either destination_sign relation or destination:forward tag, in case of bi-directional exit edge,\n+ * or destination tag, in case of unidirectional exit edge.\n+ *\n+ * @author sayas01\n+ */\n+public class AtGradeSignPostCheck extends BaseCheck<String>\n+{\n+    /**\n+     * A class for holding flagged intersection items and corresponding flag instruction index\n+     */\n+    private class FlaggedIntersection\n+    {\n+        private int instructionIndex;\n+        private Set<AtlasEntity> setOfFlaggedItems;\n+\n+        FlaggedIntersection(final int instructionIndex, final Set<AtlasEntity> setOfFlaggedItems)\n+        {\n+            this.instructionIndex = instructionIndex;\n+            this.setOfFlaggedItems = setOfFlaggedItems;\n+        }\n+\n+        private Set<AtlasEntity> getFlaggedItems()\n+        {\n+            return this.setOfFlaggedItems;\n+        }\n+\n+        private Integer getInstructionIndex()\n+        {\n+            return this.instructionIndex;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = -7428641176420422187L;\n+    // Valid highway types to be considered for the check\n+    private static final String HIGHWAY_FILTER_DEFAULT = \"highway->trunk,primary,secondary\";\n+    // Primary road (inEdge) connected to trunk, primary, secondary roads (outEdges) are treated as\n+    // valid intersection\n+    private static final List<String> CONNECTIONS_TO_PRIMARY = Arrays.asList(\"trunk\", \"primary\",\n+            \"secondary\");\n+    // Trunk road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_TRUNK = Collections.singletonList(\"primary\");\n+    // Secondary road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_SECONDARY = Collections\n+            .singletonList(\"primary\");\n+    private static final ImmutableMap<String, List<String>> CONNECTED_HIGHWAY_TYPES_MAP = ImmutableMap\n+            .of(\"primary\", CONNECTIONS_TO_PRIMARY, \"trunk\", CONNECTIONS_TO_TRUNK, \"secondary\",\n+                    CONNECTIONS_TO_SECONDARY);\n+    private static final String NO_DESTINATION_SIGN_RELATION_INSTRUCTION = \"Node {0,number,#} forms an at-grade junction but is not part of \"\n+            + \"a destination sign relation. Verify and create a destination sign relation with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, \" + \"as \\\"to\\\" and \\\"from\\\" members.\";\n+    private static final String DESTINATION_SIGN_RELATION_MISSING_DESTINATION_TAG_INSTRUCTION = \"Node {0,number,#} form an at-grade junction. It is part of destination sign relation(s): \"\n+            + \"{1}\" + \"but the relation(s) are missing \\\"destination\\\" tags.\";\n+    private static final String INCOMPLETE_DESTINATION_RELATION_INSTRUCTION = \"Node {0,number,#} forms an \"\n+            + \"at-grade junction and is part of destination sign relation(s). But the following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String ROUNDABOUT_EDGE_MISSING_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction with connected edges. Add destination sign relations with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, as \\\"to\\\" and \\\"from\\\" members and add destination sign tag to the connected edges.\";\n+    private static final String ROUNDABOUT_EDGE_INCOMPLETE_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction. It is part of destination sign relation(s). Either the existing relations are missing destination sign tag or following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Either add destination tags to existing relations or create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String NON_ROUNDABOUT_INTERSECTION_MAP = \"nonRoundaboutMatchingEdgesMap\";\n+    private static final String ROUNDABOUT_INTERSECTION_MAP = \"roundaboutMatchingEdgesMap\";\n+\n+    private static final int INSTRUCTION_INDEX_ZERO = 0;\n+    private static final int INSTRUCTION_INDEX_ONE = 1;\n+    private static final int INSTRUCTION_INDEX_TWO = 2;\n+    private static final int INSTRUCTION_INDEX_THREE = 3;\n+    private static final int INSTRUCTION_INDEX_FOUR = 4;\n+\n+    private static final int MINIMUM_NODE_VALENCE = 3;\n+    private static final Angle DEFAULT_OPPOSITE_DIRECTION_LOWER_LIMIT = Angle.degrees(171);\n+    private static final Angle DEFAULT_OPPOSITE_DIRECTION_UPPER_LIMIT = Angle.degrees(-171);\n+    private static final Angle DEFAULT_SAME_DIRECTION_LOWER_LIMIT = Angle.degrees(-100);\n+    private static final Angle DEFAULT_SAME_DIRECTION_UPPER_LIMIT = Angle.degrees(9);\n+    private static final EdgeDirectionComparator EDGE_DIRECTION_COMPARATOR = new EdgeDirectionComparator(\n+            DEFAULT_OPPOSITE_DIRECTION_LOWER_LIMIT, DEFAULT_OPPOSITE_DIRECTION_UPPER_LIMIT,\n+            DEFAULT_SAME_DIRECTION_LOWER_LIMIT, DEFAULT_SAME_DIRECTION_UPPER_LIMIT);\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(\n+            NO_DESTINATION_SIGN_RELATION_INSTRUCTION,\n+            DESTINATION_SIGN_RELATION_MISSING_DESTINATION_TAG_INSTRUCTION,\n+            INCOMPLETE_DESTINATION_RELATION_INSTRUCTION,\n+            ROUNDABOUT_EDGE_MISSING_DESTINATION_SIGN_RELATION,\n+            ROUNDABOUT_EDGE_INCOMPLETE_DESTINATION_SIGN_RELATION);\n+\n+    private final TaggableFilter highwayFilter;\n+    private Map<String, List<String>> connectedHighwayTypes;\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public AtGradeSignPostCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.highwayFilter = configurationValue(configuration, \"highway.filter\",\n+                HIGHWAY_FILTER_DEFAULT, TaggableFilter::forDefinition);\n+        this.connectedHighwayTypes = this.configurationValue(configuration,\n+                \"connected.highway.types\", CONNECTED_HIGHWAY_TYPES_MAP);\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return object instanceof Node && ((Node) object).valence() >= MINIMUM_NODE_VALENCE\n+                && !this.isFlagged(String.valueOf(object.getIdentifier()));\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        if (String.valueOf(object.getOsmIdentifier()).equals(\"1720823768\"))\n+        {\n+            System.out.println(object);\n+        }\n+        final Node intersectingNode = (Node) object;\n+        // Filter and sort all in edges that have valid highway types\n+        final List<Edge> inEdges = intersectingNode.inEdges().stream()\n+                .filter(this::isValidIntersectingEdge)\n+                .sorted(Comparator.comparingLong(AtlasObject::getIdentifier))\n+                .collect(Collectors.toList());\n+        // Filter all out edges that have valid highway types\n+        final Set<Edge> outEdges = intersectingNode.outEdges().stream()\n+                .filter(this::isValidIntersectingEdge).collect(Collectors.toSet());\n+        // Terminate if there isn't at least one inEdge or two out edges with valid highway types\n+        if (inEdges.isEmpty() || outEdges.size() < 2)\n+        {\n+            return Optional.empty();\n+        }\n+        // For each inEdge, get the list of potentially matching out edges\n+        // Matching out edges are based on z level and highway type.\n+        // For each inEdge, store the inEdge and corresponding outEdges in inEdgeToOutEdgeMap\n+        // If any of the out edge is a roundabout edge, store the roundabout edges and the inEdge in\n+        // roundAboutInEdgeToOutEdgeMap\n+        final Map<String, Map<AtlasEntity, Set<AtlasEntity>>> mapOfMatchingInAndOutEdges = this\n+                .populateInEdgeToOutEdgeMaps(inEdges, outEdges);\n+        final Map<AtlasEntity, Set<AtlasEntity>> inEdgeToOutEdgeMap = mapOfMatchingInAndOutEdges\n+                .getOrDefault(NON_ROUNDABOUT_INTERSECTION_MAP, null);\n+        final Map<AtlasEntity, Set<AtlasEntity>> roundAboutInEdgeToOutEdgeMap = mapOfMatchingInAndOutEdges\n+                .getOrDefault(ROUNDABOUT_INTERSECTION_MAP, null);\n+        // If there are no valid intersection, return Optional.empty()\n+        if ((inEdgeToOutEdgeMap == null || inEdgeToOutEdgeMap.isEmpty())\n+                && (roundAboutInEdgeToOutEdgeMap == null || roundAboutInEdgeToOutEdgeMap.isEmpty()))\n+        {\n+            return Optional.empty();\n+        }\n+        // Collect all destination sign relations, the node is a member of\n+        final Optional<Set<Relation>> destinationSignRelations = this\n+                .getParentDestinationSignRelations(intersectingNode);\n+        final FlaggedIntersection flaggedIntersection = destinationSignRelations.isEmpty()\n+                ? this.getIntersectionsWithNoDestinationSignRelation(roundAboutInEdgeToOutEdgeMap,\n+                        inEdgeToOutEdgeMap, intersectingNode)\n+                : this.getIntersectionsWithIncompleteDestinationSignRelation(\n+                        roundAboutInEdgeToOutEdgeMap, inEdgeToOutEdgeMap, intersectingNode,\n+                        destinationSignRelations.get());\n+        final int instructionIndex = flaggedIntersection.getInstructionIndex();\n+        final Set<AtlasEntity> entitiesToBeFlagged = flaggedIntersection.getFlaggedItems();\n+        if (instructionIndex == -1)\n+        {\n+            return Optional.empty();\n+        }\n+        final List<String> identifiers = this.getIdentifiers(entitiesToBeFlagged);\n+        entitiesToBeFlagged.add(intersectingNode);\n+        this.markAsFlagged(String.valueOf(intersectingNode.getIdentifier()));\n+        return Optional.of(\n+                this.createFlag(entitiesToBeFlagged, this.getLocalizedInstruction(instructionIndex,\n+                        intersectingNode.getIdentifier(), new StringList(identifiers).join(\", \"))));\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Collects all edges that are not part of a relation\n+     *\n+     * @param fromEdge\n+     *            inEdge\n+     * @param toEdges\n+     *            set of out edges\n+     * @param destinationSignRelations\n+     *            set of existing destination sign relations\n+     * @return Optional<Set<AtlasEntity>> if there are edges that are not part of destination sign\n+     *         relations\n+     */\n+    private Optional<Set<AtlasEntity>> connectedEdgesNotPartOfRelation(final AtlasEntity fromEdge,\n+            final Set<AtlasEntity> toEdges, final Set<Relation> destinationSignRelations)\n+    {\n+        final Set<AtlasEntity> outEdges = new HashSet<>(toEdges);\n+        final Set<AtlasEntity> filteredOutEdges = outEdges.stream()\n+                .filter(outEdge -> this.isMissingDestinationTag((Edge) outEdge))\n+                .collect(Collectors.toSet());\n+        final Set<AtlasEntity> allRelationMembers = destinationSignRelations.stream()\n+                .flatMap(destinationSignRelation ->\n+                {\n+                    final RelationMemberList relationMembers = destinationSignRelation\n+                            .allKnownOsmMembers();\n+                    return relationMembers.stream().map(RelationMember::getEntity);\n+                }).collect(Collectors.toSet());\n+        if (!allRelationMembers.contains(fromEdge))\n+        {\n+            filteredOutEdges.add(fromEdge);\n+            return Optional.of(filteredOutEdges);\n+        }\n+        allRelationMembers.forEach(filteredOutEdges::remove);\n+        if (!filteredOutEdges.isEmpty())\n+        {\n+            filteredOutEdges.add(fromEdge);\n+            return Optional.of(filteredOutEdges);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Collect all roundabout edges and exit edges that are missing destination sign relations or\n+     * missing destination sign tags\n+     *\n+     * @param roundAboutInEdgeToOutEdgeMap\n+     *            Map<AtlasEntity, Set<AtlasEntity>> where key is inEdge and value is set of\n+     *            outEdges of the rounabout\n+     * @param destinationSignRelations\n+     *            set of existing destoination sign relations\n+     * @return set of edges that meet the above criteria\n+     */\n+    private Set<AtlasEntity> getAllRoundaboutEdgesMissingTagsOrRelations(\n+            final Map<AtlasEntity, Set<AtlasEntity>> roundAboutInEdgeToOutEdgeMap,\n+            final Set<Relation> destinationSignRelations)\n+    {\n+        final Set<AtlasEntity> entitiesToBeFlagged = new HashSet<>();\n+        roundAboutInEdgeToOutEdgeMap.forEach((inEdge, setOfOutEdge) ->\n+        {\n+            final Optional<AtlasEntity> roundaboutEdge = setOfOutEdge.stream()\n+                    .filter(JunctionTag::isRoundabout).findFirst();\n+            final Optional<AtlasEntity> roundaboutExitEdge = setOfOutEdge.stream()\n+                    .filter(outEdge -> !JunctionTag.isRoundabout(outEdge)).findFirst();\n+            if (roundaboutEdge.isPresent() && roundaboutExitEdge.isPresent())\n+            {\n+                final Set<AtlasEntity> roundaboutEdges = this\n+                        .getRoundaboutEdges((Edge) roundaboutEdge.get());\n+                final AtlasEntity exitEdge = roundaboutExitEdge.get();\n+                // If the destination sign relation is missing destination tag, flag it\n+                if (this.isMissingDestinationTag((Edge) exitEdge))\n+                {\n+                    entitiesToBeFlagged.addAll(roundaboutEdges);\n+                    entitiesToBeFlagged.add(roundaboutExitEdge.get());\n+                }\n+                final Optional<Set<AtlasEntity>> roundAboutEdgesNotPartOfRelations = this\n+                        .connectedEdgesNotPartOfRelation(exitEdge, roundaboutEdges,\n+                                destinationSignRelations);\n+                // If there are missing destination sign relations, flag it\n+                roundAboutEdgesNotPartOfRelations.ifPresent(entitiesToBeFlagged::addAll);\n+            }\n+        });\n+        return entitiesToBeFlagged;\n+    }\n+\n+    /**\n+     * @param inEdgeToOutEdgeMap\n+     *            inEdge to outEdge map\n+     * @param destinationSignRelations\n+     *            destinationSignRelations\n+     * @return\n+     */\n+    private Set<AtlasEntity> getConnectedEdgesNotFormDestinationRelation(\n+            final Map<AtlasEntity, Set<AtlasEntity>> inEdgeToOutEdgeMap,\n+            final Set<Relation> destinationSignRelations)\n+    {\n+        return inEdgeToOutEdgeMap.entrySet().stream().flatMap(atlasEntitySetEntry ->\n+        {\n+            final AtlasEntity key = atlasEntitySetEntry.getKey();\n+            return this.connectedEdgesNotPartOfRelation(key, inEdgeToOutEdgeMap.get(key),\n+                    destinationSignRelations).stream();\n+        }).flatMap(Collection::stream).collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * Collects all atlas identifiers of given set of {@link AtlasObject}s\n+     *\n+     * @param objects\n+     *            set of {@link AtlasObject}s\n+     * @return {@link Iterable<String>} containing the atlas identifiers of input objects\n+     */\n+    private List<String> getIdentifiers(final Set<AtlasEntity> objects)\n+    {\n+        return Iterables.stream(objects).map(AtlasEntity::getIdentifier).map(String::valueOf)\n+                .collectToList();\n+    }\n+\n+    /**\n+     * Node could be part of multiple destination_sign relations. This method collect the\n+     * intersecting items that are not part of existing destination_sign relation of the node or if\n+     * the relations are missing a destination_sign tag.\n+     *\n+     * @param roundAboutInEdgeToOutEdgeMap\n+     *            map with roundabout inEdge and outEdges\n+     * @param inEdgeToOutEdgeMap\n+     *            map with non-roundabout inEdge and outEdges\n+     * @param intersectingNode\n+     *            {@link Node}\n+     * @param destinationSignRelations\n+     *            set of relations the node is a member of\n+     * @return FlaggedIntersection with instruction index and set of flagged items with incomplete\n+     *         destination_sign relation\n+     */\n+    private FlaggedIntersection getIntersectionsWithIncompleteDestinationSignRelation(\n+            final Map<AtlasEntity, Set<AtlasEntity>> roundAboutInEdgeToOutEdgeMap,\n+            final Map<AtlasEntity, Set<AtlasEntity>> inEdgeToOutEdgeMap,\n+            final Node intersectingNode, final Set<Relation> destinationSignRelations)\n+    {\n+        // If the node is part of destination sign relation, check if destination tag of the\n+        // relation is missing or if there are any missing relations that the node could be part of\n+        // based on from and to edges\n+        final Set<AtlasEntity> entitiesToBeFlagged = new HashSet<>();\n+        int instructionIndex = -1;\n+        // Flag all roundabout edges that are missing destination sign relations or missing\n+        // destination sign tags for existing relations\n+        if (!roundAboutInEdgeToOutEdgeMap.isEmpty())\n+        {\n+            final Set<AtlasEntity> allRoundaboutEdgesMissingTagsOrRelations = this\n+                    .getAllRoundaboutEdgesMissingTagsOrRelations(roundAboutInEdgeToOutEdgeMap,\n+                            destinationSignRelations);\n+            if (!allRoundaboutEdgesMissingTagsOrRelations.isEmpty())\n+            {\n+                entitiesToBeFlagged.addAll(allRoundaboutEdgesMissingTagsOrRelations);\n+                instructionIndex = INSTRUCTION_INDEX_FOUR;\n+            }\n+        }\n+        else\n+        {\n+            final Set<Relation> destinationSignRelationsMissingTag = this\n+                    .getRelationsWithMissingDestinationTag(destinationSignRelations);\n+            // Flag if destination sign tag is missing\n+            if (!destinationSignRelationsMissingTag.isEmpty())\n+            {\n+                this.markAsFlagged(String.valueOf(intersectingNode.getIdentifier()));\n+                instructionIndex = INSTRUCTION_INDEX_ONE;\n+                entitiesToBeFlagged.addAll(destinationSignRelationsMissingTag);\n+            }\n+            else if (inEdgeToOutEdgeMap != null)\n+            {\n+                // If there are any missing destination sign relation that the node should be\n+                // part of, flag it\n+                final Set<AtlasEntity> connectedEdgesNotFormDestinationRelation = this\n+                        .getConnectedEdgesNotFormDestinationRelation(inEdgeToOutEdgeMap,\n+                                destinationSignRelations);\n+                if (!connectedEdgesNotFormDestinationRelation.isEmpty())\n+                {\n+                    instructionIndex = INSTRUCTION_INDEX_TWO;\n+                    entitiesToBeFlagged.addAll(connectedEdgesNotFormDestinationRelation);\n+                }\n+            }\n+        }\n+        return new FlaggedIntersection(instructionIndex, entitiesToBeFlagged);\n+    }\n+\n+    /**\n+     * Get items part of intersection that is not part of any destination_sign relations", "originalCommit": "db2251159588145501afe20f2f81706ba7dfb349", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM3NTczMA==", "url": "https://github.com/osmlab/atlas-checks/pull/258#discussion_r380375730", "bodyText": "This method returns intersections that do not have destination sign relations. The params for this method are not filtered prior based on destination_sign relation. I have slightly updated the comment. Let me know if it is still unclear. I will be happy to be more descriptive.", "author": "sayas01", "createdAt": "2020-02-17T21:46:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM2NDUyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM3ODg0Mw==", "url": "https://github.com/osmlab/atlas-checks/pull/258#discussion_r380378843", "bodyText": "Perhaps I am just missing something obvious here, but I am not seeing where the filtering for destination signs is happening. It looks the only filtering is for roundabout tags, and then everything gets added to the entitiesToBeFlagged set.", "author": "Bentleysb", "createdAt": "2020-02-17T21:59:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM2NDUyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM4OTA0MQ==", "url": "https://github.com/osmlab/atlas-checks/pull/258#discussion_r380389041", "bodyText": "My bad! This method is called only if there is no destination_sign relation. This method simply flags the items in the input hashmaps. Since the flag method was getting long, I just pulled out the section that flags the items in the maps to this method. I have renamed the method and replaced the java doc for the method.", "author": "sayas01", "createdAt": "2020-02-17T22:46:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM2NDUyNw=="}], "type": "inlineReview"}, {"oid": "b9242add79c0332241a77bfa90fc14f1806c14f2", "url": "https://github.com/osmlab/atlas-checks/commit/b9242add79c0332241a77bfa90fc14f1806c14f2", "message": "Address Pr comments", "committedDate": "2020-02-17T21:44:20Z", "type": "commit"}, {"oid": "2665d9daf49c32d4cc12bf542ad505b3362aa8f7", "url": "https://github.com/osmlab/atlas-checks/commit/2665d9daf49c32d4cc12bf542ad505b3362aa8f7", "message": "Rename method for clarity", "committedDate": "2020-02-17T22:42:36Z", "type": "commit"}, {"oid": "7fbcc941f882ff8dca54d269c4e6ff99635b504b", "url": "https://github.com/osmlab/atlas-checks/commit/7fbcc941f882ff8dca54d269c4e6ff99635b504b", "message": "Spotlessapply", "committedDate": "2020-02-17T22:45:07Z", "type": "commit"}, {"oid": "60a9a68b1ebe9c4e30cac68c0ade131804091085", "url": "https://github.com/osmlab/atlas-checks/commit/60a9a68b1ebe9c4e30cac68c0ade131804091085", "message": "Fix checkstyle and update doc", "committedDate": "2020-02-18T23:24:34Z", "type": "commit"}, {"oid": "8035384cfe3212181922deb14c8aca5d7fce691e", "url": "https://github.com/osmlab/atlas-checks/commit/8035384cfe3212181922deb14c8aca5d7fce691e", "message": "Add challenge config", "committedDate": "2020-02-19T19:31:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUyNzkyNw==", "url": "https://github.com/osmlab/atlas-checks/pull/258#discussion_r381527927", "bodyText": "Why don't we put only the edges in filteredByHighways that are explicitly roundabouts in roundAboutInEdgeToOutEdgeMap? And the rest in inEdgeToOutEdgeMap", "author": "seancoulter", "createdAt": "2020-02-19T20:33:12Z", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/AtGradeSignPostCheck.java", "diffHunk": "@@ -0,0 +1,634 @@\n+package org.openstreetmap.atlas.checks.validation.intersections;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Relation;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMember;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMemberList;\n+import org.openstreetmap.atlas.geography.atlas.walker.SimpleEdgeWalker;\n+import org.openstreetmap.atlas.tags.DestinationForwardTag;\n+import org.openstreetmap.atlas.tags.DestinationTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.LevelTag;\n+import org.openstreetmap.atlas.tags.OneWayTag;\n+import org.openstreetmap.atlas.tags.RelationTypeTag;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.StringList;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.direction.EdgeDirectionComparator;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+\n+import com.google.common.collect.ImmutableMap;\n+\n+/**\n+ * Check flags at-grade intersections with missing destination_sign tags or destinations_sign\n+ * relations. An at-grade intersection is an intersection between two edges at the same z-level. In\n+ * case of roundabout edges, intersection between exit edge and roundabout edge are checked for\n+ * either destination_sign relation or destination:forward tag, in case of bi-directional exit edge,\n+ * or destination tag, in case of unidirectional exit edge.\n+ *\n+ * @author sayas01\n+ */\n+public class AtGradeSignPostCheck extends BaseCheck<String>\n+{\n+    /**\n+     * A class for holding flagged intersection items and corresponding flag instruction index\n+     */\n+    private class FlaggedIntersection\n+    {\n+        private int instructionIndex;\n+        private Set<AtlasEntity> setOfFlaggedItems;\n+\n+        FlaggedIntersection(final int instructionIndex, final Set<AtlasEntity> setOfFlaggedItems)\n+        {\n+            this.instructionIndex = instructionIndex;\n+            this.setOfFlaggedItems = setOfFlaggedItems;\n+        }\n+\n+        private Set<AtlasEntity> getFlaggedItems()\n+        {\n+            return this.setOfFlaggedItems;\n+        }\n+\n+        private Integer getInstructionIndex()\n+        {\n+            return this.instructionIndex;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = -7428641176420422187L;\n+    // Primary road (inEdge) connected to trunk, primary, secondary roads (outEdges) are treated as\n+    // valid intersection\n+    private static final List<String> CONNECTIONS_TO_PRIMARY = Arrays.asList(\"trunk\", \"primary\",\n+            \"secondary\");\n+    // Trunk road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_TRUNK = Collections.singletonList(\"primary\");\n+    // Secondary road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_SECONDARY = Collections\n+            .singletonList(\"primary\");\n+    private static final ImmutableMap<String, List<String>> CONNECTED_HIGHWAY_TYPES_MAP = ImmutableMap\n+            .of(\"primary\", CONNECTIONS_TO_PRIMARY, \"trunk\", CONNECTIONS_TO_TRUNK, \"secondary\",\n+                    CONNECTIONS_TO_SECONDARY);\n+    private static final String NO_DESTINATION_SIGN_RELATION_INSTRUCTION = \"Node {0,number,#} forms an at-grade junction but is not part of \"\n+            + \"a destination sign relation. Verify and create a destination sign relation with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, \" + \"as \\\"to\\\" and \\\"from\\\" members.\";\n+    private static final String DESTINATION_SIGN_RELATION_MISSING_DESTINATION_TAG_INSTRUCTION = \"Node {0,number,#} form an at-grade junction. It is part of destination sign relation(s): \"\n+            + \"{1}\" + \"but the relation(s) are missing \\\"destination\\\" tags.\";\n+    private static final String INCOMPLETE_DESTINATION_RELATION_INSTRUCTION = \"Node {0,number,#} forms an \"\n+            + \"at-grade junction and is part of destination sign relation(s). But the following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String ROUNDABOUT_EDGE_MISSING_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction with connected edges. Add destination sign relations with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, as \\\"to\\\" and \\\"from\\\" members and add destination sign tag to the connected edges.\";\n+    private static final String ROUNDABOUT_EDGE_INCOMPLETE_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction. It is part of destination sign relation(s). Either the existing relations are missing destination sign tag or following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Either add destination tags to existing relations or create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String NON_ROUNDABOUT_INTERSECTION_MAP = \"nonRoundaboutMatchingEdgesMap\";\n+    private static final String ROUNDABOUT_INTERSECTION_MAP = \"roundaboutMatchingEdgesMap\";\n+\n+    private static final int INSTRUCTION_INDEX_ZERO = 0;\n+    private static final int INSTRUCTION_INDEX_ONE = 1;\n+    private static final int INSTRUCTION_INDEX_TWO = 2;\n+    private static final int INSTRUCTION_INDEX_THREE = 3;\n+    private static final int INSTRUCTION_INDEX_FOUR = 4;\n+\n+    private static final int MINIMUM_NODE_VALENCE = 3;\n+    private static final Angle DEFAULT_OPPOSITE_DIRECTION_LOWER_LIMIT = Angle.degrees(171);\n+    private static final Angle DEFAULT_OPPOSITE_DIRECTION_UPPER_LIMIT = Angle.degrees(-171);\n+    private static final Angle DEFAULT_SAME_DIRECTION_LOWER_LIMIT = Angle.degrees(-100);\n+    private static final Angle DEFAULT_SAME_DIRECTION_UPPER_LIMIT = Angle.degrees(9);\n+    private static final EdgeDirectionComparator EDGE_DIRECTION_COMPARATOR = new EdgeDirectionComparator(\n+            DEFAULT_OPPOSITE_DIRECTION_LOWER_LIMIT, DEFAULT_OPPOSITE_DIRECTION_UPPER_LIMIT,\n+            DEFAULT_SAME_DIRECTION_LOWER_LIMIT, DEFAULT_SAME_DIRECTION_UPPER_LIMIT);\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(\n+            NO_DESTINATION_SIGN_RELATION_INSTRUCTION,\n+            DESTINATION_SIGN_RELATION_MISSING_DESTINATION_TAG_INSTRUCTION,\n+            INCOMPLETE_DESTINATION_RELATION_INSTRUCTION,\n+            ROUNDABOUT_EDGE_MISSING_DESTINATION_SIGN_RELATION,\n+            ROUNDABOUT_EDGE_INCOMPLETE_DESTINATION_SIGN_RELATION);\n+\n+    private final Set<String> highwayFilter;\n+    private Map<String, List<String>> connectedHighwayTypes;\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public AtGradeSignPostCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.connectedHighwayTypes = this.configurationValue(configuration,\n+                \"connected.highway.types\", CONNECTED_HIGHWAY_TYPES_MAP);\n+        this.highwayFilter = new HashSet<>(this.connectedHighwayTypes.keySet());\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return object instanceof Node && ((Node) object).valence() >= MINIMUM_NODE_VALENCE\n+                && !this.isFlagged(String.valueOf(object.getIdentifier()));\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Node intersectingNode = (Node) object;\n+        // Filter and sort all in edges that have valid highway types\n+        final List<Edge> inEdges = intersectingNode.inEdges().stream()\n+                .filter(this::isValidIntersectingEdge)\n+                .sorted(Comparator.comparingLong(AtlasObject::getIdentifier))\n+                .collect(Collectors.toList());\n+        // Filter all out edges that have valid highway types\n+        final Set<Edge> outEdges = intersectingNode.outEdges().stream()\n+                .filter(this::isValidIntersectingEdge).collect(Collectors.toSet());\n+        // Terminate if there isn't at least one inEdge or two out edges with valid highway types\n+        if (inEdges.isEmpty() || outEdges.size() < 2)\n+        {\n+            return Optional.empty();\n+        }\n+        // For each inEdge, get the list of potentially matching out edges\n+        // Matching out edges are based on z level and highway type.\n+        // For each inEdge, store the inEdge and corresponding outEdges in inEdgeToOutEdgeMap\n+        // If any of the out edge is a roundabout edge, store the roundabout edges and the inEdge in\n+        // roundAboutInEdgeToOutEdgeMap\n+        final Map<String, Map<AtlasEntity, Set<AtlasEntity>>> mapOfMatchingInAndOutEdges = this\n+                .populateInEdgeToOutEdgeMaps(inEdges, outEdges);\n+        final Map<AtlasEntity, Set<AtlasEntity>> inEdgeToOutEdgeMap = mapOfMatchingInAndOutEdges\n+                .getOrDefault(NON_ROUNDABOUT_INTERSECTION_MAP, null);\n+        final Map<AtlasEntity, Set<AtlasEntity>> roundAboutInEdgeToOutEdgeMap = mapOfMatchingInAndOutEdges\n+                .getOrDefault(ROUNDABOUT_INTERSECTION_MAP, null);\n+        // If there are no valid intersection, return Optional.empty()\n+        if ((inEdgeToOutEdgeMap == null || inEdgeToOutEdgeMap.isEmpty())\n+                && (roundAboutInEdgeToOutEdgeMap == null || roundAboutInEdgeToOutEdgeMap.isEmpty()))\n+        {\n+            return Optional.empty();\n+        }\n+        // Collect all destination sign relations, the node is a member of\n+        final Optional<Set<Relation>> destinationSignRelations = this\n+                .getParentDestinationSignRelations(intersectingNode);\n+        final FlaggedIntersection flaggedIntersection = destinationSignRelations.isEmpty()\n+                ? this.getFlaggedIntersection(roundAboutInEdgeToOutEdgeMap, inEdgeToOutEdgeMap)\n+                : this.getIntersectionsWithIncompleteDestinationSignRelation(\n+                        roundAboutInEdgeToOutEdgeMap, inEdgeToOutEdgeMap, intersectingNode,\n+                        destinationSignRelations.get());\n+        final int instructionIndex = flaggedIntersection.getInstructionIndex();\n+        final Set<AtlasEntity> entitiesToBeFlagged = flaggedIntersection.getFlaggedItems();\n+        if (instructionIndex == -1)\n+        {\n+            return Optional.empty();\n+        }\n+        final List<String> identifiers = this.getIdentifiers(entitiesToBeFlagged);\n+        entitiesToBeFlagged.add(intersectingNode);\n+        this.markAsFlagged(String.valueOf(intersectingNode.getIdentifier()));\n+        return Optional.of(\n+                this.createFlag(entitiesToBeFlagged, this.getLocalizedInstruction(instructionIndex,\n+                        intersectingNode.getIdentifier(), new StringList(identifiers).join(\", \"))));\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Collects all edges that are not part of a relation\n+     *\n+     * @param fromEdge\n+     *            inEdge\n+     * @param toEdges\n+     *            set of out edges\n+     * @param destinationSignRelations\n+     *            set of existing destination sign relations\n+     * @return Optional<Set<AtlasEntity>> if there are edges that are not part of destination sign\n+     *         relations\n+     */\n+    private Optional<Set<AtlasEntity>> connectedEdgesNotPartOfRelation(final AtlasEntity fromEdge,\n+            final Set<AtlasEntity> toEdges, final Set<Relation> destinationSignRelations)\n+    {\n+        final Set<AtlasEntity> outEdges = new HashSet<>(toEdges);\n+        final Set<AtlasEntity> filteredOutEdges = outEdges.stream()\n+                .filter(outEdge -> this.isMissingDestinationTag((Edge) outEdge))\n+                .collect(Collectors.toSet());\n+        final Set<AtlasEntity> allRelationMembers = destinationSignRelations.stream()\n+                .flatMap(destinationSignRelation ->\n+                {\n+                    final RelationMemberList relationMembers = destinationSignRelation\n+                            .allKnownOsmMembers();\n+                    return relationMembers.stream().map(RelationMember::getEntity);\n+                }).collect(Collectors.toSet());\n+        if (!allRelationMembers.contains(fromEdge))\n+        {\n+            filteredOutEdges.add(fromEdge);\n+            return Optional.of(filteredOutEdges);\n+        }\n+        allRelationMembers.forEach(filteredOutEdges::remove);\n+        if (!filteredOutEdges.isEmpty())\n+        {\n+            filteredOutEdges.add(fromEdge);\n+            return Optional.of(filteredOutEdges);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Collect all roundabout edges and exit edges that are missing destination sign relations or\n+     * missing destination sign tags\n+     *\n+     * @param roundAboutInEdgeToOutEdgeMap\n+     *            Map<AtlasEntity, Set<AtlasEntity>> where key is inEdge and value is set of\n+     *            outEdges of the rounabout\n+     * @param destinationSignRelations\n+     *            set of existing destoination sign relations\n+     * @return set of edges that meet the above criteria\n+     */\n+    private Set<AtlasEntity> getAllRoundaboutEdgesMissingTagsOrRelations(\n+            final Map<AtlasEntity, Set<AtlasEntity>> roundAboutInEdgeToOutEdgeMap,\n+            final Set<Relation> destinationSignRelations)\n+    {\n+        final Set<AtlasEntity> entitiesToBeFlagged = new HashSet<>();\n+        roundAboutInEdgeToOutEdgeMap.forEach((inEdge, setOfOutEdge) ->\n+        {\n+            final Optional<AtlasEntity> roundaboutEdge = setOfOutEdge.stream()\n+                    .filter(JunctionTag::isRoundabout).findFirst();\n+            final Optional<AtlasEntity> roundaboutExitEdge = setOfOutEdge.stream()\n+                    .filter(outEdge -> !JunctionTag.isRoundabout(outEdge)).findFirst();\n+            if (roundaboutEdge.isPresent() && roundaboutExitEdge.isPresent())\n+            {\n+                final Set<AtlasEntity> roundaboutEdges = this\n+                        .getRoundaboutEdges((Edge) roundaboutEdge.get());\n+                final AtlasEntity exitEdge = roundaboutExitEdge.get();\n+                // If the destination sign relation is missing destination tag, flag it\n+                if (this.isMissingDestinationTag((Edge) exitEdge))\n+                {\n+                    entitiesToBeFlagged.addAll(roundaboutEdges);\n+                    entitiesToBeFlagged.add(roundaboutExitEdge.get());\n+                }\n+                final Optional<Set<AtlasEntity>> roundAboutEdgesNotPartOfRelations = this\n+                        .connectedEdgesNotPartOfRelation(exitEdge, roundaboutEdges,\n+                                destinationSignRelations);\n+                // If there are missing destination sign relations, flag it\n+                roundAboutEdgesNotPartOfRelations.ifPresent(entitiesToBeFlagged::addAll);\n+            }\n+        });\n+        return entitiesToBeFlagged;\n+    }\n+\n+    /**\n+     * @param inEdgeToOutEdgeMap\n+     *            inEdge to outEdge map\n+     * @param destinationSignRelations\n+     *            destinationSignRelations\n+     * @return\n+     */\n+    private Set<AtlasEntity> getConnectedEdgesNotFormDestinationRelation(\n+            final Map<AtlasEntity, Set<AtlasEntity>> inEdgeToOutEdgeMap,\n+            final Set<Relation> destinationSignRelations)\n+    {\n+        return inEdgeToOutEdgeMap.entrySet().stream().flatMap(atlasEntitySetEntry ->\n+        {\n+            final AtlasEntity key = atlasEntitySetEntry.getKey();\n+            return this.connectedEdgesNotPartOfRelation(key, inEdgeToOutEdgeMap.get(key),\n+                    destinationSignRelations).stream();\n+        }).flatMap(Collection::stream).collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * Return a FlaggedIntersection with the items in the input params and appropriate instruction\n+     * index based on the input params.\n+     *\n+     * @param roundAboutInEdgeToOutEdgeMap\n+     *            map with roundabout inEdge and outEdges\n+     * @param inEdgeToOutEdgeMap\n+     *            map with non-roundabout inEdge and outEdges\n+     * @return FlaggedIntersection with instruction index and set of flagged items based on the\n+     *         input params\n+     */\n+    private FlaggedIntersection getFlaggedIntersection(\n+            final Map<AtlasEntity, Set<AtlasEntity>> roundAboutInEdgeToOutEdgeMap,\n+            final Map<AtlasEntity, Set<AtlasEntity>> inEdgeToOutEdgeMap)\n+    {\n+        final Set<AtlasEntity> entitiesToBeFlagged = new HashSet<>();\n+        int instructionIndex = -1;\n+        // Flag all in and out edges\n+        if (roundAboutInEdgeToOutEdgeMap.isEmpty() && inEdgeToOutEdgeMap != null)\n+        {\n+            inEdgeToOutEdgeMap.forEach((inEdge, setOfOutEdge) ->\n+            {\n+                entitiesToBeFlagged.add(inEdge);\n+                entitiesToBeFlagged.addAll(setOfOutEdge);\n+            });\n+            if (!entitiesToBeFlagged.isEmpty())\n+            {\n+                //\n+                instructionIndex = INSTRUCTION_INDEX_ZERO;\n+            }\n+        }\n+        // Flag all roundabout edges\n+        else\n+        {\n+            roundAboutInEdgeToOutEdgeMap.forEach((inEdge, setOfOutEdge) ->\n+            {\n+                // Ideally there would only be one roundabout edge and one exit edge per node\n+                final Optional<AtlasEntity> roundaboutEdge = JunctionTag.isRoundabout(inEdge)\n+                        ? Optional.of(inEdge)\n+                        : setOfOutEdge.stream().filter(JunctionTag::isRoundabout).findFirst();\n+                final Optional<AtlasEntity> roundaboutExitEdge = setOfOutEdge.stream()\n+                        .filter(outEdge -> !JunctionTag.isRoundabout(outEdge)).findFirst();\n+                if (roundaboutEdge.isPresent() && roundaboutExitEdge.isPresent())\n+                {\n+                    entitiesToBeFlagged\n+                            .addAll(this.getRoundaboutEdges((Edge) roundaboutEdge.get()));\n+                    entitiesToBeFlagged.add(roundaboutExitEdge.get());\n+                }\n+            });\n+            if (!entitiesToBeFlagged.isEmpty())\n+            {\n+                instructionIndex = INSTRUCTION_INDEX_THREE;\n+            }\n+        }\n+        return new FlaggedIntersection(instructionIndex, entitiesToBeFlagged);\n+    }\n+\n+    /**\n+     * Collects all atlas identifiers of given set of {@link AtlasObject}s\n+     *\n+     * @param objects\n+     *            set of {@link AtlasObject}s\n+     * @return {@link Iterable<String>} containing the atlas identifiers of input objects\n+     */\n+    private List<String> getIdentifiers(final Set<AtlasEntity> objects)\n+    {\n+        return Iterables.stream(objects).map(AtlasEntity::getIdentifier).map(String::valueOf)\n+                .collectToList();\n+    }\n+\n+    /**\n+     * Node could be part of multiple destination_sign relations. This method collect the\n+     * intersecting items that are not part of existing destination_sign relation of the node or if\n+     * the relations are missing a destination_sign tag.\n+     *\n+     * @param roundAboutInEdgeToOutEdgeMap\n+     *            map with roundabout inEdge and outEdges\n+     * @param inEdgeToOutEdgeMap\n+     *            map with non-roundabout inEdge and outEdges\n+     * @param intersectingNode\n+     *            {@link Node}\n+     * @param destinationSignRelations\n+     *            set of relations the node is a member of\n+     * @return FlaggedIntersection with instruction index and set of flagged items with incomplete\n+     *         destination_sign relation\n+     */\n+    private FlaggedIntersection getIntersectionsWithIncompleteDestinationSignRelation(\n+            final Map<AtlasEntity, Set<AtlasEntity>> roundAboutInEdgeToOutEdgeMap,\n+            final Map<AtlasEntity, Set<AtlasEntity>> inEdgeToOutEdgeMap,\n+            final Node intersectingNode, final Set<Relation> destinationSignRelations)\n+    {\n+        // If the node is part of destination sign relation, check if destination tag of the\n+        // relation is missing or if there are any missing relations that the node could be part of\n+        // based on from and to edges\n+        final Set<AtlasEntity> entitiesToBeFlagged = new HashSet<>();\n+        int instructionIndex = -1;\n+        // Flag all roundabout edges that are missing destination sign relations or missing\n+        // destination sign tags for existing relations\n+        if (!roundAboutInEdgeToOutEdgeMap.isEmpty())\n+        {\n+            final Set<AtlasEntity> allRoundaboutEdgesMissingTagsOrRelations = this\n+                    .getAllRoundaboutEdgesMissingTagsOrRelations(roundAboutInEdgeToOutEdgeMap,\n+                            destinationSignRelations);\n+            if (!allRoundaboutEdgesMissingTagsOrRelations.isEmpty())\n+            {\n+                entitiesToBeFlagged.addAll(allRoundaboutEdgesMissingTagsOrRelations);\n+                instructionIndex = INSTRUCTION_INDEX_FOUR;\n+            }\n+        }\n+        else\n+        {\n+            final Set<Relation> destinationSignRelationsMissingTag = this\n+                    .getRelationsWithMissingDestinationTag(destinationSignRelations);\n+            // Flag if destination sign tag is missing\n+            if (!destinationSignRelationsMissingTag.isEmpty())\n+            {\n+                this.markAsFlagged(String.valueOf(intersectingNode.getIdentifier()));\n+                instructionIndex = INSTRUCTION_INDEX_ONE;\n+                entitiesToBeFlagged.addAll(destinationSignRelationsMissingTag);\n+            }\n+            else if (inEdgeToOutEdgeMap != null)\n+            {\n+                // If there are any missing destination sign relation that the node should be\n+                // part of, flag it\n+                final Set<AtlasEntity> connectedEdgesNotFormDestinationRelation = this\n+                        .getConnectedEdgesNotFormDestinationRelation(inEdgeToOutEdgeMap,\n+                                destinationSignRelations);\n+                if (!connectedEdgesNotFormDestinationRelation.isEmpty())\n+                {\n+                    instructionIndex = INSTRUCTION_INDEX_TWO;\n+                    entitiesToBeFlagged.addAll(connectedEdgesNotFormDestinationRelation);\n+                }\n+            }\n+        }\n+        return new FlaggedIntersection(instructionIndex, entitiesToBeFlagged);\n+    }\n+\n+    /**\n+     * Collect all destination sign relations that the input atlas entity is member of.\n+     *\n+     * @param atlasEntity\n+     *            any {@link AtlasEntity}\n+     * @return Optional<Set<Relation>> that the atlasEntity is member of\n+     */\n+    private Optional<Set<Relation>> getParentDestinationSignRelations(final AtlasEntity atlasEntity)\n+    {\n+        final Set<Relation> setOfDestinationSignRelations = atlasEntity.relations().stream()\n+                .filter(relation -> RelationTypeTag.DESTINATION_SIGN.toString()\n+                        .equalsIgnoreCase(relation.tag(RelationTypeTag.KEY)))\n+                .collect(Collectors.toSet());\n+        return setOfDestinationSignRelations.isEmpty() ? Optional.empty()\n+                : Optional.of(setOfDestinationSignRelations);\n+    }\n+\n+    /**\n+     * Collects all destination sign relations with missing destination sign tag\n+     *\n+     * @param destinationSignRelations\n+     *            set of destination sign relations\n+     * @return set of relations with missing destination sign tag\n+     */\n+    private Set<Relation> getRelationsWithMissingDestinationTag(\n+            final Set<Relation> destinationSignRelations)\n+    {\n+        return destinationSignRelations.stream()\n+                .filter(relation -> relation.tag(DestinationTag.KEY) == null)\n+                .collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * Collects all roundabout edges starting with the given given\n+     *\n+     * @param startEdge\n+     *            {@link Edge}\n+     * @return Set of roundabout edges\n+     */\n+    private Set<AtlasEntity> getRoundaboutEdges(final Edge startEdge)\n+    {\n+        return new SimpleEdgeWalker(startEdge, this.isRoundaboutEdge()).collectEdges().stream()\n+                .map(AtlasEntity.class::cast).collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * Checks if given outEdge is at the same z level and in the same direction as that of the\n+     * inEdge\n+     *\n+     * @param inEdge\n+     *            inEdge\n+     * @param outEdge\n+     *            outEdge\n+     * @return true if the outEdge matches the above criteria for the given inEdge\n+     */\n+    private boolean isMatchingOutEdge(final Edge inEdge, final Edge outEdge)\n+    {\n+        return LevelTag.areOnSameLevel(inEdge, outEdge) && LayerTag.areOnSameLayer(inEdge, outEdge)\n+                && EDGE_DIRECTION_COMPARATOR.isSameDirection(inEdge, outEdge, true);\n+    }\n+\n+    /**\n+     * Checks if the edge is missing DestinationForwardTag if two way or is missing a destination\n+     * tag if one way\n+     *\n+     * @param edge\n+     *            any edge\n+     * @return true if the edge is missing the destination tags\n+     */\n+    private boolean isMissingDestinationTag(final Edge edge)\n+    {\n+        return (OneWayTag.isExplicitlyTwoWay(edge) && edge.tag(DestinationForwardTag.KEY) == null)\n+                || (!OneWayTag.isExplicitlyTwoWay(edge) && edge.tag(DestinationTag.KEY) == null);\n+    }\n+\n+    /**\n+     * Function for {@link SimpleEdgeWalker} that gathers connected edges that are part of a\n+     * roundabout.\n+     *\n+     * @return {@link Function} for {@link SimpleEdgeWalker}\n+     */\n+    private Function<Edge, Stream<Edge>> isRoundaboutEdge()\n+    {\n+        return edge -> edge.connectedEdges().stream()\n+                .filter(connected -> JunctionTag.isRoundabout(connected)\n+                        && HighwayTag.isCarNavigableHighway(connected));\n+    }\n+\n+    /**\n+     * Checks if given edge is a valid intersecting edge for an at-grade intersection\n+     *\n+     * @param edge\n+     *            edge\n+     * @return true if the edge is valid intersecting edge\n+     */\n+    private boolean isValidIntersectingEdge(final Edge edge)\n+    {\n+        return edge.isMasterEdge() && HighwayTag.highwayTag(edge).isPresent()\n+                && this.highwayFilter.contains(edge.highwayTag().getTagValue());\n+    }\n+\n+    /**\n+     * Collect matching out edges and corresponding in edge in a map. Store the roundabout edges and\n+     * non roundabout edges in separate maps.\n+     *\n+     * @param inEdges\n+     *            List<Edge> inEdges\n+     * @param outEdges\n+     *            Set<Edge> outEdges\n+     * @return Map<String, Map<AtlasEntity, Set<AtlasEntity>>> with Map of inEdge to outEdges for\n+     *         roundabout and non roundabout edges\n+     */\n+    private Map<String, Map<AtlasEntity, Set<AtlasEntity>>> populateInEdgeToOutEdgeMaps(\n+            final List<Edge> inEdges, final Set<Edge> outEdges)\n+    {\n+        final Map<AtlasEntity, Set<AtlasEntity>> inEdgeToOutEdgeMap = new HashMap<>();\n+        final Map<AtlasEntity, Set<AtlasEntity>> roundAboutInEdgeToOutEdgeMap = new HashMap<>();\n+        inEdges.forEach(inEdge ->\n+        {\n+            final Optional<HighwayTag> highwayTag = HighwayTag.highwayTag(inEdge);\n+            if (highwayTag.isPresent()\n+                    && this.connectedHighwayTypes.containsKey(highwayTag.get().getTagValue()))\n+            {\n+                // Filter out edges based on level and layer tags and valid highway types\n+                final Set<AtlasEntity> filteredOutEdges = outEdges.stream()\n+                        .filter(outEdge -> this.isMatchingOutEdge(inEdge, outEdge))\n+                        .collect(Collectors.toSet());\n+                // There should be at least 2 valid outEdges\n+                if (filteredOutEdges.size() >= 2)\n+                {\n+                    final String inEdgeHighwayType = highwayTag.get().getTagValue();\n+                    final List<String> validHighwayTypesOfOutEdge = this.connectedHighwayTypes\n+                            .get(inEdgeHighwayType);\n+                    final Set<AtlasEntity> filteredByHighways = filteredOutEdges.stream()\n+                            .filter(atlasEntity ->\n+                            {\n+                                final Optional<HighwayTag> atlasEntityHighway = HighwayTag\n+                                        .highwayTag(atlasEntity);\n+                                return atlasEntityHighway.isPresent() && validHighwayTypesOfOutEdge\n+                                        .contains(atlasEntityHighway.get().getTagValue());\n+                            }).collect(Collectors.toSet());\n+                    // If any of the edges is a roundabout, add it to roundabout map\n+                    if (filteredByHighways.stream().anyMatch(JunctionTag::isRoundabout)\n+                            || JunctionTag.isRoundabout(inEdge))\n+                    {\n+                        roundAboutInEdgeToOutEdgeMap.put(inEdge, filteredByHighways);", "originalCommit": "8035384cfe3212181922deb14c8aca5d7fce691e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUzMTQzNw==", "url": "https://github.com/osmlab/atlas-checks/pull/258#discussion_r381531437", "bodyText": "So if there is at least one roundabout edge, then the intersection should be in roundAboutInEdgeToOutEdgeMap. If one of the inEdge is an entrance to a roundabout and outEdge is exit to a roundabout, there will not be a roundabout tag to these edges and I do not want them to be added to inEdgeToOutEdgeMap. This way, I can be sure to assign roundabout instruction to the intersection of these edges.", "author": "sayas01", "createdAt": "2020-02-19T20:40:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUyNzkyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUyODkyNg==", "url": "https://github.com/osmlab/atlas-checks/pull/258#discussion_r381528926", "bodyText": "typo: given -> edge", "author": "seancoulter", "createdAt": "2020-02-19T20:35:21Z", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/AtGradeSignPostCheck.java", "diffHunk": "@@ -0,0 +1,634 @@\n+package org.openstreetmap.atlas.checks.validation.intersections;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Relation;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMember;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMemberList;\n+import org.openstreetmap.atlas.geography.atlas.walker.SimpleEdgeWalker;\n+import org.openstreetmap.atlas.tags.DestinationForwardTag;\n+import org.openstreetmap.atlas.tags.DestinationTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.LevelTag;\n+import org.openstreetmap.atlas.tags.OneWayTag;\n+import org.openstreetmap.atlas.tags.RelationTypeTag;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.StringList;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.direction.EdgeDirectionComparator;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+\n+import com.google.common.collect.ImmutableMap;\n+\n+/**\n+ * Check flags at-grade intersections with missing destination_sign tags or destinations_sign\n+ * relations. An at-grade intersection is an intersection between two edges at the same z-level. In\n+ * case of roundabout edges, intersection between exit edge and roundabout edge are checked for\n+ * either destination_sign relation or destination:forward tag, in case of bi-directional exit edge,\n+ * or destination tag, in case of unidirectional exit edge.\n+ *\n+ * @author sayas01\n+ */\n+public class AtGradeSignPostCheck extends BaseCheck<String>\n+{\n+    /**\n+     * A class for holding flagged intersection items and corresponding flag instruction index\n+     */\n+    private class FlaggedIntersection\n+    {\n+        private int instructionIndex;\n+        private Set<AtlasEntity> setOfFlaggedItems;\n+\n+        FlaggedIntersection(final int instructionIndex, final Set<AtlasEntity> setOfFlaggedItems)\n+        {\n+            this.instructionIndex = instructionIndex;\n+            this.setOfFlaggedItems = setOfFlaggedItems;\n+        }\n+\n+        private Set<AtlasEntity> getFlaggedItems()\n+        {\n+            return this.setOfFlaggedItems;\n+        }\n+\n+        private Integer getInstructionIndex()\n+        {\n+            return this.instructionIndex;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = -7428641176420422187L;\n+    // Primary road (inEdge) connected to trunk, primary, secondary roads (outEdges) are treated as\n+    // valid intersection\n+    private static final List<String> CONNECTIONS_TO_PRIMARY = Arrays.asList(\"trunk\", \"primary\",\n+            \"secondary\");\n+    // Trunk road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_TRUNK = Collections.singletonList(\"primary\");\n+    // Secondary road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_SECONDARY = Collections\n+            .singletonList(\"primary\");\n+    private static final ImmutableMap<String, List<String>> CONNECTED_HIGHWAY_TYPES_MAP = ImmutableMap\n+            .of(\"primary\", CONNECTIONS_TO_PRIMARY, \"trunk\", CONNECTIONS_TO_TRUNK, \"secondary\",\n+                    CONNECTIONS_TO_SECONDARY);\n+    private static final String NO_DESTINATION_SIGN_RELATION_INSTRUCTION = \"Node {0,number,#} forms an at-grade junction but is not part of \"\n+            + \"a destination sign relation. Verify and create a destination sign relation with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, \" + \"as \\\"to\\\" and \\\"from\\\" members.\";\n+    private static final String DESTINATION_SIGN_RELATION_MISSING_DESTINATION_TAG_INSTRUCTION = \"Node {0,number,#} form an at-grade junction. It is part of destination sign relation(s): \"\n+            + \"{1}\" + \"but the relation(s) are missing \\\"destination\\\" tags.\";\n+    private static final String INCOMPLETE_DESTINATION_RELATION_INSTRUCTION = \"Node {0,number,#} forms an \"\n+            + \"at-grade junction and is part of destination sign relation(s). But the following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String ROUNDABOUT_EDGE_MISSING_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction with connected edges. Add destination sign relations with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, as \\\"to\\\" and \\\"from\\\" members and add destination sign tag to the connected edges.\";\n+    private static final String ROUNDABOUT_EDGE_INCOMPLETE_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction. It is part of destination sign relation(s). Either the existing relations are missing destination sign tag or following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Either add destination tags to existing relations or create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String NON_ROUNDABOUT_INTERSECTION_MAP = \"nonRoundaboutMatchingEdgesMap\";\n+    private static final String ROUNDABOUT_INTERSECTION_MAP = \"roundaboutMatchingEdgesMap\";\n+\n+    private static final int INSTRUCTION_INDEX_ZERO = 0;\n+    private static final int INSTRUCTION_INDEX_ONE = 1;\n+    private static final int INSTRUCTION_INDEX_TWO = 2;\n+    private static final int INSTRUCTION_INDEX_THREE = 3;\n+    private static final int INSTRUCTION_INDEX_FOUR = 4;\n+\n+    private static final int MINIMUM_NODE_VALENCE = 3;\n+    private static final Angle DEFAULT_OPPOSITE_DIRECTION_LOWER_LIMIT = Angle.degrees(171);\n+    private static final Angle DEFAULT_OPPOSITE_DIRECTION_UPPER_LIMIT = Angle.degrees(-171);\n+    private static final Angle DEFAULT_SAME_DIRECTION_LOWER_LIMIT = Angle.degrees(-100);\n+    private static final Angle DEFAULT_SAME_DIRECTION_UPPER_LIMIT = Angle.degrees(9);\n+    private static final EdgeDirectionComparator EDGE_DIRECTION_COMPARATOR = new EdgeDirectionComparator(\n+            DEFAULT_OPPOSITE_DIRECTION_LOWER_LIMIT, DEFAULT_OPPOSITE_DIRECTION_UPPER_LIMIT,\n+            DEFAULT_SAME_DIRECTION_LOWER_LIMIT, DEFAULT_SAME_DIRECTION_UPPER_LIMIT);\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(\n+            NO_DESTINATION_SIGN_RELATION_INSTRUCTION,\n+            DESTINATION_SIGN_RELATION_MISSING_DESTINATION_TAG_INSTRUCTION,\n+            INCOMPLETE_DESTINATION_RELATION_INSTRUCTION,\n+            ROUNDABOUT_EDGE_MISSING_DESTINATION_SIGN_RELATION,\n+            ROUNDABOUT_EDGE_INCOMPLETE_DESTINATION_SIGN_RELATION);\n+\n+    private final Set<String> highwayFilter;\n+    private Map<String, List<String>> connectedHighwayTypes;\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public AtGradeSignPostCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.connectedHighwayTypes = this.configurationValue(configuration,\n+                \"connected.highway.types\", CONNECTED_HIGHWAY_TYPES_MAP);\n+        this.highwayFilter = new HashSet<>(this.connectedHighwayTypes.keySet());\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return object instanceof Node && ((Node) object).valence() >= MINIMUM_NODE_VALENCE\n+                && !this.isFlagged(String.valueOf(object.getIdentifier()));\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Node intersectingNode = (Node) object;\n+        // Filter and sort all in edges that have valid highway types\n+        final List<Edge> inEdges = intersectingNode.inEdges().stream()\n+                .filter(this::isValidIntersectingEdge)\n+                .sorted(Comparator.comparingLong(AtlasObject::getIdentifier))\n+                .collect(Collectors.toList());\n+        // Filter all out edges that have valid highway types\n+        final Set<Edge> outEdges = intersectingNode.outEdges().stream()\n+                .filter(this::isValidIntersectingEdge).collect(Collectors.toSet());\n+        // Terminate if there isn't at least one inEdge or two out edges with valid highway types\n+        if (inEdges.isEmpty() || outEdges.size() < 2)\n+        {\n+            return Optional.empty();\n+        }\n+        // For each inEdge, get the list of potentially matching out edges\n+        // Matching out edges are based on z level and highway type.\n+        // For each inEdge, store the inEdge and corresponding outEdges in inEdgeToOutEdgeMap\n+        // If any of the out edge is a roundabout edge, store the roundabout edges and the inEdge in\n+        // roundAboutInEdgeToOutEdgeMap\n+        final Map<String, Map<AtlasEntity, Set<AtlasEntity>>> mapOfMatchingInAndOutEdges = this\n+                .populateInEdgeToOutEdgeMaps(inEdges, outEdges);\n+        final Map<AtlasEntity, Set<AtlasEntity>> inEdgeToOutEdgeMap = mapOfMatchingInAndOutEdges\n+                .getOrDefault(NON_ROUNDABOUT_INTERSECTION_MAP, null);\n+        final Map<AtlasEntity, Set<AtlasEntity>> roundAboutInEdgeToOutEdgeMap = mapOfMatchingInAndOutEdges\n+                .getOrDefault(ROUNDABOUT_INTERSECTION_MAP, null);\n+        // If there are no valid intersection, return Optional.empty()\n+        if ((inEdgeToOutEdgeMap == null || inEdgeToOutEdgeMap.isEmpty())\n+                && (roundAboutInEdgeToOutEdgeMap == null || roundAboutInEdgeToOutEdgeMap.isEmpty()))\n+        {\n+            return Optional.empty();\n+        }\n+        // Collect all destination sign relations, the node is a member of\n+        final Optional<Set<Relation>> destinationSignRelations = this\n+                .getParentDestinationSignRelations(intersectingNode);\n+        final FlaggedIntersection flaggedIntersection = destinationSignRelations.isEmpty()\n+                ? this.getFlaggedIntersection(roundAboutInEdgeToOutEdgeMap, inEdgeToOutEdgeMap)\n+                : this.getIntersectionsWithIncompleteDestinationSignRelation(\n+                        roundAboutInEdgeToOutEdgeMap, inEdgeToOutEdgeMap, intersectingNode,\n+                        destinationSignRelations.get());\n+        final int instructionIndex = flaggedIntersection.getInstructionIndex();\n+        final Set<AtlasEntity> entitiesToBeFlagged = flaggedIntersection.getFlaggedItems();\n+        if (instructionIndex == -1)\n+        {\n+            return Optional.empty();\n+        }\n+        final List<String> identifiers = this.getIdentifiers(entitiesToBeFlagged);\n+        entitiesToBeFlagged.add(intersectingNode);\n+        this.markAsFlagged(String.valueOf(intersectingNode.getIdentifier()));\n+        return Optional.of(\n+                this.createFlag(entitiesToBeFlagged, this.getLocalizedInstruction(instructionIndex,\n+                        intersectingNode.getIdentifier(), new StringList(identifiers).join(\", \"))));\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Collects all edges that are not part of a relation\n+     *\n+     * @param fromEdge\n+     *            inEdge\n+     * @param toEdges\n+     *            set of out edges\n+     * @param destinationSignRelations\n+     *            set of existing destination sign relations\n+     * @return Optional<Set<AtlasEntity>> if there are edges that are not part of destination sign\n+     *         relations\n+     */\n+    private Optional<Set<AtlasEntity>> connectedEdgesNotPartOfRelation(final AtlasEntity fromEdge,\n+            final Set<AtlasEntity> toEdges, final Set<Relation> destinationSignRelations)\n+    {\n+        final Set<AtlasEntity> outEdges = new HashSet<>(toEdges);\n+        final Set<AtlasEntity> filteredOutEdges = outEdges.stream()\n+                .filter(outEdge -> this.isMissingDestinationTag((Edge) outEdge))\n+                .collect(Collectors.toSet());\n+        final Set<AtlasEntity> allRelationMembers = destinationSignRelations.stream()\n+                .flatMap(destinationSignRelation ->\n+                {\n+                    final RelationMemberList relationMembers = destinationSignRelation\n+                            .allKnownOsmMembers();\n+                    return relationMembers.stream().map(RelationMember::getEntity);\n+                }).collect(Collectors.toSet());\n+        if (!allRelationMembers.contains(fromEdge))\n+        {\n+            filteredOutEdges.add(fromEdge);\n+            return Optional.of(filteredOutEdges);\n+        }\n+        allRelationMembers.forEach(filteredOutEdges::remove);\n+        if (!filteredOutEdges.isEmpty())\n+        {\n+            filteredOutEdges.add(fromEdge);\n+            return Optional.of(filteredOutEdges);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Collect all roundabout edges and exit edges that are missing destination sign relations or\n+     * missing destination sign tags\n+     *\n+     * @param roundAboutInEdgeToOutEdgeMap\n+     *            Map<AtlasEntity, Set<AtlasEntity>> where key is inEdge and value is set of\n+     *            outEdges of the rounabout\n+     * @param destinationSignRelations\n+     *            set of existing destoination sign relations\n+     * @return set of edges that meet the above criteria\n+     */\n+    private Set<AtlasEntity> getAllRoundaboutEdgesMissingTagsOrRelations(\n+            final Map<AtlasEntity, Set<AtlasEntity>> roundAboutInEdgeToOutEdgeMap,\n+            final Set<Relation> destinationSignRelations)\n+    {\n+        final Set<AtlasEntity> entitiesToBeFlagged = new HashSet<>();\n+        roundAboutInEdgeToOutEdgeMap.forEach((inEdge, setOfOutEdge) ->\n+        {\n+            final Optional<AtlasEntity> roundaboutEdge = setOfOutEdge.stream()\n+                    .filter(JunctionTag::isRoundabout).findFirst();\n+            final Optional<AtlasEntity> roundaboutExitEdge = setOfOutEdge.stream()\n+                    .filter(outEdge -> !JunctionTag.isRoundabout(outEdge)).findFirst();\n+            if (roundaboutEdge.isPresent() && roundaboutExitEdge.isPresent())\n+            {\n+                final Set<AtlasEntity> roundaboutEdges = this\n+                        .getRoundaboutEdges((Edge) roundaboutEdge.get());\n+                final AtlasEntity exitEdge = roundaboutExitEdge.get();\n+                // If the destination sign relation is missing destination tag, flag it\n+                if (this.isMissingDestinationTag((Edge) exitEdge))\n+                {\n+                    entitiesToBeFlagged.addAll(roundaboutEdges);\n+                    entitiesToBeFlagged.add(roundaboutExitEdge.get());\n+                }\n+                final Optional<Set<AtlasEntity>> roundAboutEdgesNotPartOfRelations = this\n+                        .connectedEdgesNotPartOfRelation(exitEdge, roundaboutEdges,\n+                                destinationSignRelations);\n+                // If there are missing destination sign relations, flag it\n+                roundAboutEdgesNotPartOfRelations.ifPresent(entitiesToBeFlagged::addAll);\n+            }\n+        });\n+        return entitiesToBeFlagged;\n+    }\n+\n+    /**\n+     * @param inEdgeToOutEdgeMap\n+     *            inEdge to outEdge map\n+     * @param destinationSignRelations\n+     *            destinationSignRelations\n+     * @return\n+     */\n+    private Set<AtlasEntity> getConnectedEdgesNotFormDestinationRelation(\n+            final Map<AtlasEntity, Set<AtlasEntity>> inEdgeToOutEdgeMap,\n+            final Set<Relation> destinationSignRelations)\n+    {\n+        return inEdgeToOutEdgeMap.entrySet().stream().flatMap(atlasEntitySetEntry ->\n+        {\n+            final AtlasEntity key = atlasEntitySetEntry.getKey();\n+            return this.connectedEdgesNotPartOfRelation(key, inEdgeToOutEdgeMap.get(key),\n+                    destinationSignRelations).stream();\n+        }).flatMap(Collection::stream).collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * Return a FlaggedIntersection with the items in the input params and appropriate instruction\n+     * index based on the input params.\n+     *\n+     * @param roundAboutInEdgeToOutEdgeMap\n+     *            map with roundabout inEdge and outEdges\n+     * @param inEdgeToOutEdgeMap\n+     *            map with non-roundabout inEdge and outEdges\n+     * @return FlaggedIntersection with instruction index and set of flagged items based on the\n+     *         input params\n+     */\n+    private FlaggedIntersection getFlaggedIntersection(\n+            final Map<AtlasEntity, Set<AtlasEntity>> roundAboutInEdgeToOutEdgeMap,\n+            final Map<AtlasEntity, Set<AtlasEntity>> inEdgeToOutEdgeMap)\n+    {\n+        final Set<AtlasEntity> entitiesToBeFlagged = new HashSet<>();\n+        int instructionIndex = -1;\n+        // Flag all in and out edges\n+        if (roundAboutInEdgeToOutEdgeMap.isEmpty() && inEdgeToOutEdgeMap != null)\n+        {\n+            inEdgeToOutEdgeMap.forEach((inEdge, setOfOutEdge) ->\n+            {\n+                entitiesToBeFlagged.add(inEdge);\n+                entitiesToBeFlagged.addAll(setOfOutEdge);\n+            });\n+            if (!entitiesToBeFlagged.isEmpty())\n+            {\n+                //\n+                instructionIndex = INSTRUCTION_INDEX_ZERO;\n+            }\n+        }\n+        // Flag all roundabout edges\n+        else\n+        {\n+            roundAboutInEdgeToOutEdgeMap.forEach((inEdge, setOfOutEdge) ->\n+            {\n+                // Ideally there would only be one roundabout edge and one exit edge per node\n+                final Optional<AtlasEntity> roundaboutEdge = JunctionTag.isRoundabout(inEdge)\n+                        ? Optional.of(inEdge)\n+                        : setOfOutEdge.stream().filter(JunctionTag::isRoundabout).findFirst();\n+                final Optional<AtlasEntity> roundaboutExitEdge = setOfOutEdge.stream()\n+                        .filter(outEdge -> !JunctionTag.isRoundabout(outEdge)).findFirst();\n+                if (roundaboutEdge.isPresent() && roundaboutExitEdge.isPresent())\n+                {\n+                    entitiesToBeFlagged\n+                            .addAll(this.getRoundaboutEdges((Edge) roundaboutEdge.get()));\n+                    entitiesToBeFlagged.add(roundaboutExitEdge.get());\n+                }\n+            });\n+            if (!entitiesToBeFlagged.isEmpty())\n+            {\n+                instructionIndex = INSTRUCTION_INDEX_THREE;\n+            }\n+        }\n+        return new FlaggedIntersection(instructionIndex, entitiesToBeFlagged);\n+    }\n+\n+    /**\n+     * Collects all atlas identifiers of given set of {@link AtlasObject}s\n+     *\n+     * @param objects\n+     *            set of {@link AtlasObject}s\n+     * @return {@link Iterable<String>} containing the atlas identifiers of input objects\n+     */\n+    private List<String> getIdentifiers(final Set<AtlasEntity> objects)\n+    {\n+        return Iterables.stream(objects).map(AtlasEntity::getIdentifier).map(String::valueOf)\n+                .collectToList();\n+    }\n+\n+    /**\n+     * Node could be part of multiple destination_sign relations. This method collect the\n+     * intersecting items that are not part of existing destination_sign relation of the node or if\n+     * the relations are missing a destination_sign tag.\n+     *\n+     * @param roundAboutInEdgeToOutEdgeMap\n+     *            map with roundabout inEdge and outEdges\n+     * @param inEdgeToOutEdgeMap\n+     *            map with non-roundabout inEdge and outEdges\n+     * @param intersectingNode\n+     *            {@link Node}\n+     * @param destinationSignRelations\n+     *            set of relations the node is a member of\n+     * @return FlaggedIntersection with instruction index and set of flagged items with incomplete\n+     *         destination_sign relation\n+     */\n+    private FlaggedIntersection getIntersectionsWithIncompleteDestinationSignRelation(\n+            final Map<AtlasEntity, Set<AtlasEntity>> roundAboutInEdgeToOutEdgeMap,\n+            final Map<AtlasEntity, Set<AtlasEntity>> inEdgeToOutEdgeMap,\n+            final Node intersectingNode, final Set<Relation> destinationSignRelations)\n+    {\n+        // If the node is part of destination sign relation, check if destination tag of the\n+        // relation is missing or if there are any missing relations that the node could be part of\n+        // based on from and to edges\n+        final Set<AtlasEntity> entitiesToBeFlagged = new HashSet<>();\n+        int instructionIndex = -1;\n+        // Flag all roundabout edges that are missing destination sign relations or missing\n+        // destination sign tags for existing relations\n+        if (!roundAboutInEdgeToOutEdgeMap.isEmpty())\n+        {\n+            final Set<AtlasEntity> allRoundaboutEdgesMissingTagsOrRelations = this\n+                    .getAllRoundaboutEdgesMissingTagsOrRelations(roundAboutInEdgeToOutEdgeMap,\n+                            destinationSignRelations);\n+            if (!allRoundaboutEdgesMissingTagsOrRelations.isEmpty())\n+            {\n+                entitiesToBeFlagged.addAll(allRoundaboutEdgesMissingTagsOrRelations);\n+                instructionIndex = INSTRUCTION_INDEX_FOUR;\n+            }\n+        }\n+        else\n+        {\n+            final Set<Relation> destinationSignRelationsMissingTag = this\n+                    .getRelationsWithMissingDestinationTag(destinationSignRelations);\n+            // Flag if destination sign tag is missing\n+            if (!destinationSignRelationsMissingTag.isEmpty())\n+            {\n+                this.markAsFlagged(String.valueOf(intersectingNode.getIdentifier()));\n+                instructionIndex = INSTRUCTION_INDEX_ONE;\n+                entitiesToBeFlagged.addAll(destinationSignRelationsMissingTag);\n+            }\n+            else if (inEdgeToOutEdgeMap != null)\n+            {\n+                // If there are any missing destination sign relation that the node should be\n+                // part of, flag it\n+                final Set<AtlasEntity> connectedEdgesNotFormDestinationRelation = this\n+                        .getConnectedEdgesNotFormDestinationRelation(inEdgeToOutEdgeMap,\n+                                destinationSignRelations);\n+                if (!connectedEdgesNotFormDestinationRelation.isEmpty())\n+                {\n+                    instructionIndex = INSTRUCTION_INDEX_TWO;\n+                    entitiesToBeFlagged.addAll(connectedEdgesNotFormDestinationRelation);\n+                }\n+            }\n+        }\n+        return new FlaggedIntersection(instructionIndex, entitiesToBeFlagged);\n+    }\n+\n+    /**\n+     * Collect all destination sign relations that the input atlas entity is member of.\n+     *\n+     * @param atlasEntity\n+     *            any {@link AtlasEntity}\n+     * @return Optional<Set<Relation>> that the atlasEntity is member of\n+     */\n+    private Optional<Set<Relation>> getParentDestinationSignRelations(final AtlasEntity atlasEntity)\n+    {\n+        final Set<Relation> setOfDestinationSignRelations = atlasEntity.relations().stream()\n+                .filter(relation -> RelationTypeTag.DESTINATION_SIGN.toString()\n+                        .equalsIgnoreCase(relation.tag(RelationTypeTag.KEY)))\n+                .collect(Collectors.toSet());\n+        return setOfDestinationSignRelations.isEmpty() ? Optional.empty()\n+                : Optional.of(setOfDestinationSignRelations);\n+    }\n+\n+    /**\n+     * Collects all destination sign relations with missing destination sign tag\n+     *\n+     * @param destinationSignRelations\n+     *            set of destination sign relations\n+     * @return set of relations with missing destination sign tag\n+     */\n+    private Set<Relation> getRelationsWithMissingDestinationTag(\n+            final Set<Relation> destinationSignRelations)\n+    {\n+        return destinationSignRelations.stream()\n+                .filter(relation -> relation.tag(DestinationTag.KEY) == null)\n+                .collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * Collects all roundabout edges starting with the given given", "originalCommit": "8035384cfe3212181922deb14c8aca5d7fce691e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d97e797fe21d16c2d7faee68ec943e4a6e2b30cc", "url": "https://github.com/osmlab/atlas-checks/commit/d97e797fe21d16c2d7faee68ec943e4a6e2b30cc", "message": "Typo", "committedDate": "2020-02-19T20:42:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUzMzQwOA==", "url": "https://github.com/osmlab/atlas-checks/pull/258#discussion_r381533408", "bodyText": "Is there any way we could have a nonempty roundAboutInEdgeToOutEdgeMap and inEdgeToOutEdgeMap? If so there should be a case to handle flagging both", "author": "seancoulter", "createdAt": "2020-02-19T20:44:32Z", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/AtGradeSignPostCheck.java", "diffHunk": "@@ -0,0 +1,634 @@\n+package org.openstreetmap.atlas.checks.validation.intersections;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Relation;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMember;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMemberList;\n+import org.openstreetmap.atlas.geography.atlas.walker.SimpleEdgeWalker;\n+import org.openstreetmap.atlas.tags.DestinationForwardTag;\n+import org.openstreetmap.atlas.tags.DestinationTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.LevelTag;\n+import org.openstreetmap.atlas.tags.OneWayTag;\n+import org.openstreetmap.atlas.tags.RelationTypeTag;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.StringList;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.direction.EdgeDirectionComparator;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+\n+import com.google.common.collect.ImmutableMap;\n+\n+/**\n+ * Check flags at-grade intersections with missing destination_sign tags or destinations_sign\n+ * relations. An at-grade intersection is an intersection between two edges at the same z-level. In\n+ * case of roundabout edges, intersection between exit edge and roundabout edge are checked for\n+ * either destination_sign relation or destination:forward tag, in case of bi-directional exit edge,\n+ * or destination tag, in case of unidirectional exit edge.\n+ *\n+ * @author sayas01\n+ */\n+public class AtGradeSignPostCheck extends BaseCheck<String>\n+{\n+    /**\n+     * A class for holding flagged intersection items and corresponding flag instruction index\n+     */\n+    private class FlaggedIntersection\n+    {\n+        private int instructionIndex;\n+        private Set<AtlasEntity> setOfFlaggedItems;\n+\n+        FlaggedIntersection(final int instructionIndex, final Set<AtlasEntity> setOfFlaggedItems)\n+        {\n+            this.instructionIndex = instructionIndex;\n+            this.setOfFlaggedItems = setOfFlaggedItems;\n+        }\n+\n+        private Set<AtlasEntity> getFlaggedItems()\n+        {\n+            return this.setOfFlaggedItems;\n+        }\n+\n+        private Integer getInstructionIndex()\n+        {\n+            return this.instructionIndex;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = -7428641176420422187L;\n+    // Primary road (inEdge) connected to trunk, primary, secondary roads (outEdges) are treated as\n+    // valid intersection\n+    private static final List<String> CONNECTIONS_TO_PRIMARY = Arrays.asList(\"trunk\", \"primary\",\n+            \"secondary\");\n+    // Trunk road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_TRUNK = Collections.singletonList(\"primary\");\n+    // Secondary road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_SECONDARY = Collections\n+            .singletonList(\"primary\");\n+    private static final ImmutableMap<String, List<String>> CONNECTED_HIGHWAY_TYPES_MAP = ImmutableMap\n+            .of(\"primary\", CONNECTIONS_TO_PRIMARY, \"trunk\", CONNECTIONS_TO_TRUNK, \"secondary\",\n+                    CONNECTIONS_TO_SECONDARY);\n+    private static final String NO_DESTINATION_SIGN_RELATION_INSTRUCTION = \"Node {0,number,#} forms an at-grade junction but is not part of \"\n+            + \"a destination sign relation. Verify and create a destination sign relation with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, \" + \"as \\\"to\\\" and \\\"from\\\" members.\";\n+    private static final String DESTINATION_SIGN_RELATION_MISSING_DESTINATION_TAG_INSTRUCTION = \"Node {0,number,#} form an at-grade junction. It is part of destination sign relation(s): \"\n+            + \"{1}\" + \"but the relation(s) are missing \\\"destination\\\" tags.\";\n+    private static final String INCOMPLETE_DESTINATION_RELATION_INSTRUCTION = \"Node {0,number,#} forms an \"\n+            + \"at-grade junction and is part of destination sign relation(s). But the following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String ROUNDABOUT_EDGE_MISSING_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction with connected edges. Add destination sign relations with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, as \\\"to\\\" and \\\"from\\\" members and add destination sign tag to the connected edges.\";\n+    private static final String ROUNDABOUT_EDGE_INCOMPLETE_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction. It is part of destination sign relation(s). Either the existing relations are missing destination sign tag or following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Either add destination tags to existing relations or create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String NON_ROUNDABOUT_INTERSECTION_MAP = \"nonRoundaboutMatchingEdgesMap\";\n+    private static final String ROUNDABOUT_INTERSECTION_MAP = \"roundaboutMatchingEdgesMap\";\n+\n+    private static final int INSTRUCTION_INDEX_ZERO = 0;\n+    private static final int INSTRUCTION_INDEX_ONE = 1;\n+    private static final int INSTRUCTION_INDEX_TWO = 2;\n+    private static final int INSTRUCTION_INDEX_THREE = 3;\n+    private static final int INSTRUCTION_INDEX_FOUR = 4;\n+\n+    private static final int MINIMUM_NODE_VALENCE = 3;\n+    private static final Angle DEFAULT_OPPOSITE_DIRECTION_LOWER_LIMIT = Angle.degrees(171);\n+    private static final Angle DEFAULT_OPPOSITE_DIRECTION_UPPER_LIMIT = Angle.degrees(-171);\n+    private static final Angle DEFAULT_SAME_DIRECTION_LOWER_LIMIT = Angle.degrees(-100);\n+    private static final Angle DEFAULT_SAME_DIRECTION_UPPER_LIMIT = Angle.degrees(9);\n+    private static final EdgeDirectionComparator EDGE_DIRECTION_COMPARATOR = new EdgeDirectionComparator(\n+            DEFAULT_OPPOSITE_DIRECTION_LOWER_LIMIT, DEFAULT_OPPOSITE_DIRECTION_UPPER_LIMIT,\n+            DEFAULT_SAME_DIRECTION_LOWER_LIMIT, DEFAULT_SAME_DIRECTION_UPPER_LIMIT);\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(\n+            NO_DESTINATION_SIGN_RELATION_INSTRUCTION,\n+            DESTINATION_SIGN_RELATION_MISSING_DESTINATION_TAG_INSTRUCTION,\n+            INCOMPLETE_DESTINATION_RELATION_INSTRUCTION,\n+            ROUNDABOUT_EDGE_MISSING_DESTINATION_SIGN_RELATION,\n+            ROUNDABOUT_EDGE_INCOMPLETE_DESTINATION_SIGN_RELATION);\n+\n+    private final Set<String> highwayFilter;\n+    private Map<String, List<String>> connectedHighwayTypes;\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public AtGradeSignPostCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.connectedHighwayTypes = this.configurationValue(configuration,\n+                \"connected.highway.types\", CONNECTED_HIGHWAY_TYPES_MAP);\n+        this.highwayFilter = new HashSet<>(this.connectedHighwayTypes.keySet());\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return object instanceof Node && ((Node) object).valence() >= MINIMUM_NODE_VALENCE\n+                && !this.isFlagged(String.valueOf(object.getIdentifier()));\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Node intersectingNode = (Node) object;\n+        // Filter and sort all in edges that have valid highway types\n+        final List<Edge> inEdges = intersectingNode.inEdges().stream()\n+                .filter(this::isValidIntersectingEdge)\n+                .sorted(Comparator.comparingLong(AtlasObject::getIdentifier))\n+                .collect(Collectors.toList());\n+        // Filter all out edges that have valid highway types\n+        final Set<Edge> outEdges = intersectingNode.outEdges().stream()\n+                .filter(this::isValidIntersectingEdge).collect(Collectors.toSet());\n+        // Terminate if there isn't at least one inEdge or two out edges with valid highway types\n+        if (inEdges.isEmpty() || outEdges.size() < 2)\n+        {\n+            return Optional.empty();\n+        }\n+        // For each inEdge, get the list of potentially matching out edges\n+        // Matching out edges are based on z level and highway type.\n+        // For each inEdge, store the inEdge and corresponding outEdges in inEdgeToOutEdgeMap\n+        // If any of the out edge is a roundabout edge, store the roundabout edges and the inEdge in\n+        // roundAboutInEdgeToOutEdgeMap\n+        final Map<String, Map<AtlasEntity, Set<AtlasEntity>>> mapOfMatchingInAndOutEdges = this\n+                .populateInEdgeToOutEdgeMaps(inEdges, outEdges);\n+        final Map<AtlasEntity, Set<AtlasEntity>> inEdgeToOutEdgeMap = mapOfMatchingInAndOutEdges\n+                .getOrDefault(NON_ROUNDABOUT_INTERSECTION_MAP, null);\n+        final Map<AtlasEntity, Set<AtlasEntity>> roundAboutInEdgeToOutEdgeMap = mapOfMatchingInAndOutEdges\n+                .getOrDefault(ROUNDABOUT_INTERSECTION_MAP, null);\n+        // If there are no valid intersection, return Optional.empty()\n+        if ((inEdgeToOutEdgeMap == null || inEdgeToOutEdgeMap.isEmpty())\n+                && (roundAboutInEdgeToOutEdgeMap == null || roundAboutInEdgeToOutEdgeMap.isEmpty()))\n+        {\n+            return Optional.empty();\n+        }\n+        // Collect all destination sign relations, the node is a member of\n+        final Optional<Set<Relation>> destinationSignRelations = this\n+                .getParentDestinationSignRelations(intersectingNode);\n+        final FlaggedIntersection flaggedIntersection = destinationSignRelations.isEmpty()\n+                ? this.getFlaggedIntersection(roundAboutInEdgeToOutEdgeMap, inEdgeToOutEdgeMap)\n+                : this.getIntersectionsWithIncompleteDestinationSignRelation(\n+                        roundAboutInEdgeToOutEdgeMap, inEdgeToOutEdgeMap, intersectingNode,\n+                        destinationSignRelations.get());\n+        final int instructionIndex = flaggedIntersection.getInstructionIndex();\n+        final Set<AtlasEntity> entitiesToBeFlagged = flaggedIntersection.getFlaggedItems();\n+        if (instructionIndex == -1)\n+        {\n+            return Optional.empty();\n+        }\n+        final List<String> identifiers = this.getIdentifiers(entitiesToBeFlagged);\n+        entitiesToBeFlagged.add(intersectingNode);\n+        this.markAsFlagged(String.valueOf(intersectingNode.getIdentifier()));\n+        return Optional.of(\n+                this.createFlag(entitiesToBeFlagged, this.getLocalizedInstruction(instructionIndex,\n+                        intersectingNode.getIdentifier(), new StringList(identifiers).join(\", \"))));\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Collects all edges that are not part of a relation\n+     *\n+     * @param fromEdge\n+     *            inEdge\n+     * @param toEdges\n+     *            set of out edges\n+     * @param destinationSignRelations\n+     *            set of existing destination sign relations\n+     * @return Optional<Set<AtlasEntity>> if there are edges that are not part of destination sign\n+     *         relations\n+     */\n+    private Optional<Set<AtlasEntity>> connectedEdgesNotPartOfRelation(final AtlasEntity fromEdge,\n+            final Set<AtlasEntity> toEdges, final Set<Relation> destinationSignRelations)\n+    {\n+        final Set<AtlasEntity> outEdges = new HashSet<>(toEdges);\n+        final Set<AtlasEntity> filteredOutEdges = outEdges.stream()\n+                .filter(outEdge -> this.isMissingDestinationTag((Edge) outEdge))\n+                .collect(Collectors.toSet());\n+        final Set<AtlasEntity> allRelationMembers = destinationSignRelations.stream()\n+                .flatMap(destinationSignRelation ->\n+                {\n+                    final RelationMemberList relationMembers = destinationSignRelation\n+                            .allKnownOsmMembers();\n+                    return relationMembers.stream().map(RelationMember::getEntity);\n+                }).collect(Collectors.toSet());\n+        if (!allRelationMembers.contains(fromEdge))\n+        {\n+            filteredOutEdges.add(fromEdge);\n+            return Optional.of(filteredOutEdges);\n+        }\n+        allRelationMembers.forEach(filteredOutEdges::remove);\n+        if (!filteredOutEdges.isEmpty())\n+        {\n+            filteredOutEdges.add(fromEdge);\n+            return Optional.of(filteredOutEdges);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Collect all roundabout edges and exit edges that are missing destination sign relations or\n+     * missing destination sign tags\n+     *\n+     * @param roundAboutInEdgeToOutEdgeMap\n+     *            Map<AtlasEntity, Set<AtlasEntity>> where key is inEdge and value is set of\n+     *            outEdges of the rounabout\n+     * @param destinationSignRelations\n+     *            set of existing destoination sign relations\n+     * @return set of edges that meet the above criteria\n+     */\n+    private Set<AtlasEntity> getAllRoundaboutEdgesMissingTagsOrRelations(\n+            final Map<AtlasEntity, Set<AtlasEntity>> roundAboutInEdgeToOutEdgeMap,\n+            final Set<Relation> destinationSignRelations)\n+    {\n+        final Set<AtlasEntity> entitiesToBeFlagged = new HashSet<>();\n+        roundAboutInEdgeToOutEdgeMap.forEach((inEdge, setOfOutEdge) ->\n+        {\n+            final Optional<AtlasEntity> roundaboutEdge = setOfOutEdge.stream()\n+                    .filter(JunctionTag::isRoundabout).findFirst();\n+            final Optional<AtlasEntity> roundaboutExitEdge = setOfOutEdge.stream()\n+                    .filter(outEdge -> !JunctionTag.isRoundabout(outEdge)).findFirst();\n+            if (roundaboutEdge.isPresent() && roundaboutExitEdge.isPresent())\n+            {\n+                final Set<AtlasEntity> roundaboutEdges = this\n+                        .getRoundaboutEdges((Edge) roundaboutEdge.get());\n+                final AtlasEntity exitEdge = roundaboutExitEdge.get();\n+                // If the destination sign relation is missing destination tag, flag it\n+                if (this.isMissingDestinationTag((Edge) exitEdge))\n+                {\n+                    entitiesToBeFlagged.addAll(roundaboutEdges);\n+                    entitiesToBeFlagged.add(roundaboutExitEdge.get());\n+                }\n+                final Optional<Set<AtlasEntity>> roundAboutEdgesNotPartOfRelations = this\n+                        .connectedEdgesNotPartOfRelation(exitEdge, roundaboutEdges,\n+                                destinationSignRelations);\n+                // If there are missing destination sign relations, flag it\n+                roundAboutEdgesNotPartOfRelations.ifPresent(entitiesToBeFlagged::addAll);\n+            }\n+        });\n+        return entitiesToBeFlagged;\n+    }\n+\n+    /**\n+     * @param inEdgeToOutEdgeMap\n+     *            inEdge to outEdge map\n+     * @param destinationSignRelations\n+     *            destinationSignRelations\n+     * @return\n+     */\n+    private Set<AtlasEntity> getConnectedEdgesNotFormDestinationRelation(\n+            final Map<AtlasEntity, Set<AtlasEntity>> inEdgeToOutEdgeMap,\n+            final Set<Relation> destinationSignRelations)\n+    {\n+        return inEdgeToOutEdgeMap.entrySet().stream().flatMap(atlasEntitySetEntry ->\n+        {\n+            final AtlasEntity key = atlasEntitySetEntry.getKey();\n+            return this.connectedEdgesNotPartOfRelation(key, inEdgeToOutEdgeMap.get(key),\n+                    destinationSignRelations).stream();\n+        }).flatMap(Collection::stream).collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * Return a FlaggedIntersection with the items in the input params and appropriate instruction\n+     * index based on the input params.\n+     *\n+     * @param roundAboutInEdgeToOutEdgeMap\n+     *            map with roundabout inEdge and outEdges\n+     * @param inEdgeToOutEdgeMap\n+     *            map with non-roundabout inEdge and outEdges\n+     * @return FlaggedIntersection with instruction index and set of flagged items based on the\n+     *         input params\n+     */\n+    private FlaggedIntersection getFlaggedIntersection(\n+            final Map<AtlasEntity, Set<AtlasEntity>> roundAboutInEdgeToOutEdgeMap,\n+            final Map<AtlasEntity, Set<AtlasEntity>> inEdgeToOutEdgeMap)\n+    {\n+        final Set<AtlasEntity> entitiesToBeFlagged = new HashSet<>();\n+        int instructionIndex = -1;\n+        // Flag all in and out edges\n+        if (roundAboutInEdgeToOutEdgeMap.isEmpty() && inEdgeToOutEdgeMap != null)", "originalCommit": "8035384cfe3212181922deb14c8aca5d7fce691e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUzNzQyMg==", "url": "https://github.com/osmlab/atlas-checks/pull/258#discussion_r381537422", "bodyText": "No there will not be because populateInEdgeToOutEdgeMaps method populates either roundAboutInEdgeToOutEdgeMap or inEdgeToOutEdgeMap based on presence of roundabout edges in the output.", "author": "sayas01", "createdAt": "2020-02-19T20:52:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUzMzQwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUzNjY4MA==", "url": "https://github.com/osmlab/atlas-checks/pull/258#discussion_r381536680", "bodyText": "Just wondering where we get these values from?", "author": "smaheshwaram", "createdAt": "2020-02-19T20:51:16Z", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/AtGradeSignPostCheck.java", "diffHunk": "@@ -0,0 +1,634 @@\n+package org.openstreetmap.atlas.checks.validation.intersections;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Relation;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMember;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMemberList;\n+import org.openstreetmap.atlas.geography.atlas.walker.SimpleEdgeWalker;\n+import org.openstreetmap.atlas.tags.DestinationForwardTag;\n+import org.openstreetmap.atlas.tags.DestinationTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.LevelTag;\n+import org.openstreetmap.atlas.tags.OneWayTag;\n+import org.openstreetmap.atlas.tags.RelationTypeTag;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.StringList;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.direction.EdgeDirectionComparator;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+\n+import com.google.common.collect.ImmutableMap;\n+\n+/**\n+ * Check flags at-grade intersections with missing destination_sign tags or destinations_sign\n+ * relations. An at-grade intersection is an intersection between two edges at the same z-level. In\n+ * case of roundabout edges, intersection between exit edge and roundabout edge are checked for\n+ * either destination_sign relation or destination:forward tag, in case of bi-directional exit edge,\n+ * or destination tag, in case of unidirectional exit edge.\n+ *\n+ * @author sayas01\n+ */\n+public class AtGradeSignPostCheck extends BaseCheck<String>\n+{\n+    /**\n+     * A class for holding flagged intersection items and corresponding flag instruction index\n+     */\n+    private class FlaggedIntersection\n+    {\n+        private int instructionIndex;\n+        private Set<AtlasEntity> setOfFlaggedItems;\n+\n+        FlaggedIntersection(final int instructionIndex, final Set<AtlasEntity> setOfFlaggedItems)\n+        {\n+            this.instructionIndex = instructionIndex;\n+            this.setOfFlaggedItems = setOfFlaggedItems;\n+        }\n+\n+        private Set<AtlasEntity> getFlaggedItems()\n+        {\n+            return this.setOfFlaggedItems;\n+        }\n+\n+        private Integer getInstructionIndex()\n+        {\n+            return this.instructionIndex;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = -7428641176420422187L;\n+    // Primary road (inEdge) connected to trunk, primary, secondary roads (outEdges) are treated as\n+    // valid intersection\n+    private static final List<String> CONNECTIONS_TO_PRIMARY = Arrays.asList(\"trunk\", \"primary\",\n+            \"secondary\");\n+    // Trunk road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_TRUNK = Collections.singletonList(\"primary\");\n+    // Secondary road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_SECONDARY = Collections\n+            .singletonList(\"primary\");\n+    private static final ImmutableMap<String, List<String>> CONNECTED_HIGHWAY_TYPES_MAP = ImmutableMap\n+            .of(\"primary\", CONNECTIONS_TO_PRIMARY, \"trunk\", CONNECTIONS_TO_TRUNK, \"secondary\",\n+                    CONNECTIONS_TO_SECONDARY);\n+    private static final String NO_DESTINATION_SIGN_RELATION_INSTRUCTION = \"Node {0,number,#} forms an at-grade junction but is not part of \"\n+            + \"a destination sign relation. Verify and create a destination sign relation with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, \" + \"as \\\"to\\\" and \\\"from\\\" members.\";\n+    private static final String DESTINATION_SIGN_RELATION_MISSING_DESTINATION_TAG_INSTRUCTION = \"Node {0,number,#} form an at-grade junction. It is part of destination sign relation(s): \"\n+            + \"{1}\" + \"but the relation(s) are missing \\\"destination\\\" tags.\";\n+    private static final String INCOMPLETE_DESTINATION_RELATION_INSTRUCTION = \"Node {0,number,#} forms an \"\n+            + \"at-grade junction and is part of destination sign relation(s). But the following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String ROUNDABOUT_EDGE_MISSING_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction with connected edges. Add destination sign relations with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, as \\\"to\\\" and \\\"from\\\" members and add destination sign tag to the connected edges.\";\n+    private static final String ROUNDABOUT_EDGE_INCOMPLETE_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction. It is part of destination sign relation(s). Either the existing relations are missing destination sign tag or following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Either add destination tags to existing relations or create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String NON_ROUNDABOUT_INTERSECTION_MAP = \"nonRoundaboutMatchingEdgesMap\";\n+    private static final String ROUNDABOUT_INTERSECTION_MAP = \"roundaboutMatchingEdgesMap\";\n+\n+    private static final int INSTRUCTION_INDEX_ZERO = 0;\n+    private static final int INSTRUCTION_INDEX_ONE = 1;\n+    private static final int INSTRUCTION_INDEX_TWO = 2;\n+    private static final int INSTRUCTION_INDEX_THREE = 3;\n+    private static final int INSTRUCTION_INDEX_FOUR = 4;\n+\n+    private static final int MINIMUM_NODE_VALENCE = 3;\n+    private static final Angle DEFAULT_OPPOSITE_DIRECTION_LOWER_LIMIT = Angle.degrees(171);", "originalCommit": "8035384cfe3212181922deb14c8aca5d7fce691e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU1MTU2MA==", "url": "https://github.com/osmlab/atlas-checks/pull/258#discussion_r381551560", "bodyText": "The default values used in the edge direction comparator class was giving FPs. So I used custom angles based on the analysis of outputs for various angles.", "author": "sayas01", "createdAt": "2020-02-19T21:21:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUzNjY4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUzNzY0MQ==", "url": "https://github.com/osmlab/atlas-checks/pull/258#discussion_r381537641", "bodyText": "getOrDefault returns default value if no value is returned for a given key. I don't see the purpose of it since you are setting default value as null.", "author": "smaheshwaram", "createdAt": "2020-02-19T20:53:25Z", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/AtGradeSignPostCheck.java", "diffHunk": "@@ -0,0 +1,634 @@\n+package org.openstreetmap.atlas.checks.validation.intersections;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Relation;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMember;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMemberList;\n+import org.openstreetmap.atlas.geography.atlas.walker.SimpleEdgeWalker;\n+import org.openstreetmap.atlas.tags.DestinationForwardTag;\n+import org.openstreetmap.atlas.tags.DestinationTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.LevelTag;\n+import org.openstreetmap.atlas.tags.OneWayTag;\n+import org.openstreetmap.atlas.tags.RelationTypeTag;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.StringList;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.direction.EdgeDirectionComparator;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+\n+import com.google.common.collect.ImmutableMap;\n+\n+/**\n+ * Check flags at-grade intersections with missing destination_sign tags or destinations_sign\n+ * relations. An at-grade intersection is an intersection between two edges at the same z-level. In\n+ * case of roundabout edges, intersection between exit edge and roundabout edge are checked for\n+ * either destination_sign relation or destination:forward tag, in case of bi-directional exit edge,\n+ * or destination tag, in case of unidirectional exit edge.\n+ *\n+ * @author sayas01\n+ */\n+public class AtGradeSignPostCheck extends BaseCheck<String>\n+{\n+    /**\n+     * A class for holding flagged intersection items and corresponding flag instruction index\n+     */\n+    private class FlaggedIntersection\n+    {\n+        private int instructionIndex;\n+        private Set<AtlasEntity> setOfFlaggedItems;\n+\n+        FlaggedIntersection(final int instructionIndex, final Set<AtlasEntity> setOfFlaggedItems)\n+        {\n+            this.instructionIndex = instructionIndex;\n+            this.setOfFlaggedItems = setOfFlaggedItems;\n+        }\n+\n+        private Set<AtlasEntity> getFlaggedItems()\n+        {\n+            return this.setOfFlaggedItems;\n+        }\n+\n+        private Integer getInstructionIndex()\n+        {\n+            return this.instructionIndex;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = -7428641176420422187L;\n+    // Primary road (inEdge) connected to trunk, primary, secondary roads (outEdges) are treated as\n+    // valid intersection\n+    private static final List<String> CONNECTIONS_TO_PRIMARY = Arrays.asList(\"trunk\", \"primary\",\n+            \"secondary\");\n+    // Trunk road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_TRUNK = Collections.singletonList(\"primary\");\n+    // Secondary road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_SECONDARY = Collections\n+            .singletonList(\"primary\");\n+    private static final ImmutableMap<String, List<String>> CONNECTED_HIGHWAY_TYPES_MAP = ImmutableMap\n+            .of(\"primary\", CONNECTIONS_TO_PRIMARY, \"trunk\", CONNECTIONS_TO_TRUNK, \"secondary\",\n+                    CONNECTIONS_TO_SECONDARY);\n+    private static final String NO_DESTINATION_SIGN_RELATION_INSTRUCTION = \"Node {0,number,#} forms an at-grade junction but is not part of \"\n+            + \"a destination sign relation. Verify and create a destination sign relation with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, \" + \"as \\\"to\\\" and \\\"from\\\" members.\";\n+    private static final String DESTINATION_SIGN_RELATION_MISSING_DESTINATION_TAG_INSTRUCTION = \"Node {0,number,#} form an at-grade junction. It is part of destination sign relation(s): \"\n+            + \"{1}\" + \"but the relation(s) are missing \\\"destination\\\" tags.\";\n+    private static final String INCOMPLETE_DESTINATION_RELATION_INSTRUCTION = \"Node {0,number,#} forms an \"\n+            + \"at-grade junction and is part of destination sign relation(s). But the following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String ROUNDABOUT_EDGE_MISSING_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction with connected edges. Add destination sign relations with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, as \\\"to\\\" and \\\"from\\\" members and add destination sign tag to the connected edges.\";\n+    private static final String ROUNDABOUT_EDGE_INCOMPLETE_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction. It is part of destination sign relation(s). Either the existing relations are missing destination sign tag or following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Either add destination tags to existing relations or create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String NON_ROUNDABOUT_INTERSECTION_MAP = \"nonRoundaboutMatchingEdgesMap\";\n+    private static final String ROUNDABOUT_INTERSECTION_MAP = \"roundaboutMatchingEdgesMap\";\n+\n+    private static final int INSTRUCTION_INDEX_ZERO = 0;\n+    private static final int INSTRUCTION_INDEX_ONE = 1;\n+    private static final int INSTRUCTION_INDEX_TWO = 2;\n+    private static final int INSTRUCTION_INDEX_THREE = 3;\n+    private static final int INSTRUCTION_INDEX_FOUR = 4;\n+\n+    private static final int MINIMUM_NODE_VALENCE = 3;\n+    private static final Angle DEFAULT_OPPOSITE_DIRECTION_LOWER_LIMIT = Angle.degrees(171);\n+    private static final Angle DEFAULT_OPPOSITE_DIRECTION_UPPER_LIMIT = Angle.degrees(-171);\n+    private static final Angle DEFAULT_SAME_DIRECTION_LOWER_LIMIT = Angle.degrees(-100);\n+    private static final Angle DEFAULT_SAME_DIRECTION_UPPER_LIMIT = Angle.degrees(9);\n+    private static final EdgeDirectionComparator EDGE_DIRECTION_COMPARATOR = new EdgeDirectionComparator(\n+            DEFAULT_OPPOSITE_DIRECTION_LOWER_LIMIT, DEFAULT_OPPOSITE_DIRECTION_UPPER_LIMIT,\n+            DEFAULT_SAME_DIRECTION_LOWER_LIMIT, DEFAULT_SAME_DIRECTION_UPPER_LIMIT);\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(\n+            NO_DESTINATION_SIGN_RELATION_INSTRUCTION,\n+            DESTINATION_SIGN_RELATION_MISSING_DESTINATION_TAG_INSTRUCTION,\n+            INCOMPLETE_DESTINATION_RELATION_INSTRUCTION,\n+            ROUNDABOUT_EDGE_MISSING_DESTINATION_SIGN_RELATION,\n+            ROUNDABOUT_EDGE_INCOMPLETE_DESTINATION_SIGN_RELATION);\n+\n+    private final Set<String> highwayFilter;\n+    private Map<String, List<String>> connectedHighwayTypes;\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public AtGradeSignPostCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.connectedHighwayTypes = this.configurationValue(configuration,\n+                \"connected.highway.types\", CONNECTED_HIGHWAY_TYPES_MAP);\n+        this.highwayFilter = new HashSet<>(this.connectedHighwayTypes.keySet());\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return object instanceof Node && ((Node) object).valence() >= MINIMUM_NODE_VALENCE\n+                && !this.isFlagged(String.valueOf(object.getIdentifier()));\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Node intersectingNode = (Node) object;\n+        // Filter and sort all in edges that have valid highway types\n+        final List<Edge> inEdges = intersectingNode.inEdges().stream()\n+                .filter(this::isValidIntersectingEdge)\n+                .sorted(Comparator.comparingLong(AtlasObject::getIdentifier))\n+                .collect(Collectors.toList());\n+        // Filter all out edges that have valid highway types\n+        final Set<Edge> outEdges = intersectingNode.outEdges().stream()\n+                .filter(this::isValidIntersectingEdge).collect(Collectors.toSet());\n+        // Terminate if there isn't at least one inEdge or two out edges with valid highway types\n+        if (inEdges.isEmpty() || outEdges.size() < 2)\n+        {\n+            return Optional.empty();\n+        }\n+        // For each inEdge, get the list of potentially matching out edges\n+        // Matching out edges are based on z level and highway type.\n+        // For each inEdge, store the inEdge and corresponding outEdges in inEdgeToOutEdgeMap\n+        // If any of the out edge is a roundabout edge, store the roundabout edges and the inEdge in\n+        // roundAboutInEdgeToOutEdgeMap\n+        final Map<String, Map<AtlasEntity, Set<AtlasEntity>>> mapOfMatchingInAndOutEdges = this\n+                .populateInEdgeToOutEdgeMaps(inEdges, outEdges);\n+        final Map<AtlasEntity, Set<AtlasEntity>> inEdgeToOutEdgeMap = mapOfMatchingInAndOutEdges\n+                .getOrDefault(NON_ROUNDABOUT_INTERSECTION_MAP, null);", "originalCommit": "8035384cfe3212181922deb14c8aca5d7fce691e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU0MzQ5NQ==", "url": "https://github.com/osmlab/atlas-checks/pull/258#discussion_r381543495", "bodyText": "Also, can we name the variable as nonRoundaboutInEdgeToOutEdgeMap instead of inEdgeToOutEdgeMap.", "author": "smaheshwaram", "createdAt": "2020-02-19T21:04:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUzNzY0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU1NTAwMQ==", "url": "https://github.com/osmlab/atlas-checks/pull/258#discussion_r381555001", "bodyText": "done!", "author": "sayas01", "createdAt": "2020-02-19T21:28:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUzNzY0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU0ODI5NQ==", "url": "https://github.com/osmlab/atlas-checks/pull/258#discussion_r381548295", "bodyText": "Are we verifying that getFlaggedItems() is not null or not empty. Because, setOfFlaggedItems variable can be null.", "author": "smaheshwaram", "createdAt": "2020-02-19T21:14:48Z", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/AtGradeSignPostCheck.java", "diffHunk": "@@ -0,0 +1,634 @@\n+package org.openstreetmap.atlas.checks.validation.intersections;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Relation;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMember;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMemberList;\n+import org.openstreetmap.atlas.geography.atlas.walker.SimpleEdgeWalker;\n+import org.openstreetmap.atlas.tags.DestinationForwardTag;\n+import org.openstreetmap.atlas.tags.DestinationTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.LevelTag;\n+import org.openstreetmap.atlas.tags.OneWayTag;\n+import org.openstreetmap.atlas.tags.RelationTypeTag;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.StringList;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.direction.EdgeDirectionComparator;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+\n+import com.google.common.collect.ImmutableMap;\n+\n+/**\n+ * Check flags at-grade intersections with missing destination_sign tags or destinations_sign\n+ * relations. An at-grade intersection is an intersection between two edges at the same z-level. In\n+ * case of roundabout edges, intersection between exit edge and roundabout edge are checked for\n+ * either destination_sign relation or destination:forward tag, in case of bi-directional exit edge,\n+ * or destination tag, in case of unidirectional exit edge.\n+ *\n+ * @author sayas01\n+ */\n+public class AtGradeSignPostCheck extends BaseCheck<String>\n+{\n+    /**\n+     * A class for holding flagged intersection items and corresponding flag instruction index\n+     */\n+    private class FlaggedIntersection\n+    {\n+        private int instructionIndex;\n+        private Set<AtlasEntity> setOfFlaggedItems;\n+\n+        FlaggedIntersection(final int instructionIndex, final Set<AtlasEntity> setOfFlaggedItems)\n+        {\n+            this.instructionIndex = instructionIndex;\n+            this.setOfFlaggedItems = setOfFlaggedItems;\n+        }\n+\n+        private Set<AtlasEntity> getFlaggedItems()\n+        {\n+            return this.setOfFlaggedItems;\n+        }\n+\n+        private Integer getInstructionIndex()\n+        {\n+            return this.instructionIndex;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = -7428641176420422187L;\n+    // Primary road (inEdge) connected to trunk, primary, secondary roads (outEdges) are treated as\n+    // valid intersection\n+    private static final List<String> CONNECTIONS_TO_PRIMARY = Arrays.asList(\"trunk\", \"primary\",\n+            \"secondary\");\n+    // Trunk road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_TRUNK = Collections.singletonList(\"primary\");\n+    // Secondary road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_SECONDARY = Collections\n+            .singletonList(\"primary\");\n+    private static final ImmutableMap<String, List<String>> CONNECTED_HIGHWAY_TYPES_MAP = ImmutableMap\n+            .of(\"primary\", CONNECTIONS_TO_PRIMARY, \"trunk\", CONNECTIONS_TO_TRUNK, \"secondary\",\n+                    CONNECTIONS_TO_SECONDARY);\n+    private static final String NO_DESTINATION_SIGN_RELATION_INSTRUCTION = \"Node {0,number,#} forms an at-grade junction but is not part of \"\n+            + \"a destination sign relation. Verify and create a destination sign relation with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, \" + \"as \\\"to\\\" and \\\"from\\\" members.\";\n+    private static final String DESTINATION_SIGN_RELATION_MISSING_DESTINATION_TAG_INSTRUCTION = \"Node {0,number,#} form an at-grade junction. It is part of destination sign relation(s): \"\n+            + \"{1}\" + \"but the relation(s) are missing \\\"destination\\\" tags.\";\n+    private static final String INCOMPLETE_DESTINATION_RELATION_INSTRUCTION = \"Node {0,number,#} forms an \"\n+            + \"at-grade junction and is part of destination sign relation(s). But the following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String ROUNDABOUT_EDGE_MISSING_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction with connected edges. Add destination sign relations with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, as \\\"to\\\" and \\\"from\\\" members and add destination sign tag to the connected edges.\";\n+    private static final String ROUNDABOUT_EDGE_INCOMPLETE_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction. It is part of destination sign relation(s). Either the existing relations are missing destination sign tag or following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Either add destination tags to existing relations or create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String NON_ROUNDABOUT_INTERSECTION_MAP = \"nonRoundaboutMatchingEdgesMap\";\n+    private static final String ROUNDABOUT_INTERSECTION_MAP = \"roundaboutMatchingEdgesMap\";\n+\n+    private static final int INSTRUCTION_INDEX_ZERO = 0;\n+    private static final int INSTRUCTION_INDEX_ONE = 1;\n+    private static final int INSTRUCTION_INDEX_TWO = 2;\n+    private static final int INSTRUCTION_INDEX_THREE = 3;\n+    private static final int INSTRUCTION_INDEX_FOUR = 4;\n+\n+    private static final int MINIMUM_NODE_VALENCE = 3;\n+    private static final Angle DEFAULT_OPPOSITE_DIRECTION_LOWER_LIMIT = Angle.degrees(171);\n+    private static final Angle DEFAULT_OPPOSITE_DIRECTION_UPPER_LIMIT = Angle.degrees(-171);\n+    private static final Angle DEFAULT_SAME_DIRECTION_LOWER_LIMIT = Angle.degrees(-100);\n+    private static final Angle DEFAULT_SAME_DIRECTION_UPPER_LIMIT = Angle.degrees(9);\n+    private static final EdgeDirectionComparator EDGE_DIRECTION_COMPARATOR = new EdgeDirectionComparator(\n+            DEFAULT_OPPOSITE_DIRECTION_LOWER_LIMIT, DEFAULT_OPPOSITE_DIRECTION_UPPER_LIMIT,\n+            DEFAULT_SAME_DIRECTION_LOWER_LIMIT, DEFAULT_SAME_DIRECTION_UPPER_LIMIT);\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(\n+            NO_DESTINATION_SIGN_RELATION_INSTRUCTION,\n+            DESTINATION_SIGN_RELATION_MISSING_DESTINATION_TAG_INSTRUCTION,\n+            INCOMPLETE_DESTINATION_RELATION_INSTRUCTION,\n+            ROUNDABOUT_EDGE_MISSING_DESTINATION_SIGN_RELATION,\n+            ROUNDABOUT_EDGE_INCOMPLETE_DESTINATION_SIGN_RELATION);\n+\n+    private final Set<String> highwayFilter;\n+    private Map<String, List<String>> connectedHighwayTypes;\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public AtGradeSignPostCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.connectedHighwayTypes = this.configurationValue(configuration,\n+                \"connected.highway.types\", CONNECTED_HIGHWAY_TYPES_MAP);\n+        this.highwayFilter = new HashSet<>(this.connectedHighwayTypes.keySet());\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return object instanceof Node && ((Node) object).valence() >= MINIMUM_NODE_VALENCE\n+                && !this.isFlagged(String.valueOf(object.getIdentifier()));\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Node intersectingNode = (Node) object;\n+        // Filter and sort all in edges that have valid highway types\n+        final List<Edge> inEdges = intersectingNode.inEdges().stream()\n+                .filter(this::isValidIntersectingEdge)\n+                .sorted(Comparator.comparingLong(AtlasObject::getIdentifier))\n+                .collect(Collectors.toList());\n+        // Filter all out edges that have valid highway types\n+        final Set<Edge> outEdges = intersectingNode.outEdges().stream()\n+                .filter(this::isValidIntersectingEdge).collect(Collectors.toSet());\n+        // Terminate if there isn't at least one inEdge or two out edges with valid highway types\n+        if (inEdges.isEmpty() || outEdges.size() < 2)\n+        {\n+            return Optional.empty();\n+        }\n+        // For each inEdge, get the list of potentially matching out edges\n+        // Matching out edges are based on z level and highway type.\n+        // For each inEdge, store the inEdge and corresponding outEdges in inEdgeToOutEdgeMap\n+        // If any of the out edge is a roundabout edge, store the roundabout edges and the inEdge in\n+        // roundAboutInEdgeToOutEdgeMap\n+        final Map<String, Map<AtlasEntity, Set<AtlasEntity>>> mapOfMatchingInAndOutEdges = this\n+                .populateInEdgeToOutEdgeMaps(inEdges, outEdges);\n+        final Map<AtlasEntity, Set<AtlasEntity>> inEdgeToOutEdgeMap = mapOfMatchingInAndOutEdges\n+                .getOrDefault(NON_ROUNDABOUT_INTERSECTION_MAP, null);\n+        final Map<AtlasEntity, Set<AtlasEntity>> roundAboutInEdgeToOutEdgeMap = mapOfMatchingInAndOutEdges\n+                .getOrDefault(ROUNDABOUT_INTERSECTION_MAP, null);\n+        // If there are no valid intersection, return Optional.empty()\n+        if ((inEdgeToOutEdgeMap == null || inEdgeToOutEdgeMap.isEmpty())\n+                && (roundAboutInEdgeToOutEdgeMap == null || roundAboutInEdgeToOutEdgeMap.isEmpty()))\n+        {\n+            return Optional.empty();\n+        }\n+        // Collect all destination sign relations, the node is a member of\n+        final Optional<Set<Relation>> destinationSignRelations = this\n+                .getParentDestinationSignRelations(intersectingNode);\n+        final FlaggedIntersection flaggedIntersection = destinationSignRelations.isEmpty()\n+                ? this.getFlaggedIntersection(roundAboutInEdgeToOutEdgeMap, inEdgeToOutEdgeMap)\n+                : this.getIntersectionsWithIncompleteDestinationSignRelation(\n+                        roundAboutInEdgeToOutEdgeMap, inEdgeToOutEdgeMap, intersectingNode,\n+                        destinationSignRelations.get());\n+        final int instructionIndex = flaggedIntersection.getInstructionIndex();\n+        final Set<AtlasEntity> entitiesToBeFlagged = flaggedIntersection.getFlaggedItems();", "originalCommit": "d97e797fe21d16c2d7faee68ec943e4a6e2b30cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU1NzA2Mw==", "url": "https://github.com/osmlab/atlas-checks/pull/258#discussion_r381557063", "bodyText": "he instructionIndex is updated only if there is some item to be flagged and the line 217 ensures that Optional.empty() is returned if there are no flaggedItems.", "author": "sayas01", "createdAt": "2020-02-19T21:32:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU0ODI5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU2MDcwMQ==", "url": "https://github.com/osmlab/atlas-checks/pull/258#discussion_r381560701", "bodyText": "Yes, you are right. instructionIndex will be -1 if no items to be flagged and also getFlaggedItems() can be null because setOfFlaggedItems is not set anywhere. So, please move the if condition above this line.", "author": "smaheshwaram", "createdAt": "2020-02-19T21:40:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU0ODI5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU2NDM0Mw==", "url": "https://github.com/osmlab/atlas-checks/pull/258#discussion_r381564343", "bodyText": "flaggedIntersection.getFlaggedItems() wouldn't be null in any case. It would be an empty set. But if instructionIndex =-1, flaggedIntersection.getFlaggedItems() need not be called and so I moved the line as requested.", "author": "sayas01", "createdAt": "2020-02-19T21:47:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU0ODI5NQ=="}], "type": "inlineReview"}, {"oid": "60445867757e9fbeae497cf4bb26c8d800b954c1", "url": "https://github.com/osmlab/atlas-checks/commit/60445867757e9fbeae497cf4bb26c8d800b954c1", "message": "Rename variable", "committedDate": "2020-02-19T21:33:37Z", "type": "commit"}, {"oid": "1143eb0de01bb6527871016d678b7a6821d146ae", "url": "https://github.com/osmlab/atlas-checks/commit/1143eb0de01bb6527871016d678b7a6821d146ae", "message": "SpotlessApply", "committedDate": "2020-02-19T21:36:36Z", "type": "commit"}, {"oid": "a52b6f9419860e2e14c775090c239b380470c97a", "url": "https://github.com/osmlab/atlas-checks/commit/a52b6f9419860e2e14c775090c239b380470c97a", "message": "nit", "committedDate": "2020-02-19T21:44:18Z", "type": "commit"}, {"oid": "2d3213ca06635c3543d37032f05d7e78846c7219", "url": "https://github.com/osmlab/atlas-checks/commit/2d3213ca06635c3543d37032f05d7e78846c7219", "message": "Rename variable", "committedDate": "2020-02-19T21:55:50Z", "type": "commit"}, {"oid": "efd0e4876faf58d471dc3b9e69f6015b1c6353ee", "url": "https://github.com/osmlab/atlas-checks/commit/efd0e4876faf58d471dc3b9e69f6015b1c6353ee", "message": "Fix checkstyle issues", "committedDate": "2020-02-19T21:59:25Z", "type": "commit"}, {"oid": "75471cb394c39464d1f55a89de9fae956dc75dc6", "url": "https://github.com/osmlab/atlas-checks/commit/75471cb394c39464d1f55a89de9fae956dc75dc6", "message": "remove enabled config key", "committedDate": "2020-02-19T22:13:51Z", "type": "commit"}, {"oid": "02d68d19ae1d7b2eea65beeb38f1b7cefd157b4b", "url": "https://github.com/osmlab/atlas-checks/commit/02d68d19ae1d7b2eea65beeb38f1b7cefd157b4b", "message": "Merge branch 'dev' into at-grade", "committedDate": "2020-02-19T22:17:28Z", "type": "commit"}, {"oid": "2eb3056141fea7eef49aff35b81ed88d1c73a04c", "url": "https://github.com/osmlab/atlas-checks/commit/2eb3056141fea7eef49aff35b81ed88d1c73a04c", "message": "Merge branch 'dev' into at-grade", "committedDate": "2020-02-19T22:22:36Z", "type": "commit"}]}