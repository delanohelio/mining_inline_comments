{"pr_number": 381, "pr_title": "Suddenhighwaytypechange", "pr_createdAt": "2020-10-08T03:05:45Z", "pr_url": "https://github.com/osmlab/atlas-checks/pull/381", "timeline": [{"oid": "d0ef53a7d94d800f42b2ac80ac13c5ae8086cfff", "url": "https://github.com/osmlab/atlas-checks/commit/d0ef53a7d94d800f42b2ac80ac13c5ae8086cfff", "message": "new suddenhighwaytypechangecheck with simplified logic and more inline with osmose issue 1090.", "committedDate": "2020-09-29T11:39:13Z", "type": "commit"}, {"oid": "855df26dd723d04515c096b26182e7ee7bffcdf3", "url": "https://github.com/osmlab/atlas-checks/commit/855df26dd723d04515c096b26182e7ee7bffcdf3", "message": "Updated check and required documents", "committedDate": "2020-10-07T18:32:49Z", "type": "commit"}, {"oid": "91fb0f15c734bdc9d609a439e36eaac72af4535c", "url": "https://github.com/osmlab/atlas-checks/commit/91fb0f15c734bdc9d609a439e36eaac72af4535c", "message": "Fixed test issues", "committedDate": "2020-10-07T19:00:36Z", "type": "commit"}, {"oid": "ad9255764ce04849a1ea1c82f1e24acf93dd8cdd", "url": "https://github.com/osmlab/atlas-checks/commit/ad9255764ce04849a1ea1c82f1e24acf93dd8cdd", "message": "Replacing strings with HighwayType.", "committedDate": "2020-10-07T20:01:14Z", "type": "commit"}, {"oid": "a73e25c24729c7ef9cab1746a90a16c038510c16", "url": "https://github.com/osmlab/atlas-checks/commit/a73e25c24729c7ef9cab1746a90a16c038510c16", "message": "Merge branch 'dev' of https://github.com/osmlab/atlas-checks into suddenhighwaytypechange", "committedDate": "2020-10-08T02:24:23Z", "type": "commit"}, {"oid": "4d1ffedc32e6560ebf4931aac252ebe0b134777b", "url": "https://github.com/osmlab/atlas-checks/commit/4d1ffedc32e6560ebf4931aac252ebe0b134777b", "message": "removing config default value", "committedDate": "2020-10-08T02:26:24Z", "type": "commit"}, {"oid": "611f5206c455406e618cc4028959ae0afc72173a", "url": "https://github.com/osmlab/atlas-checks/commit/611f5206c455406e618cc4028959ae0afc72173a", "message": "updating documentation regarding the suddenhighwaytypechangecheck", "committedDate": "2020-10-08T02:43:30Z", "type": "commit"}, {"oid": "2384e77448ea6a27a896584f944c6ac4caf9be68", "url": "https://github.com/osmlab/atlas-checks/commit/2384e77448ea6a27a896584f944c6ac4caf9be68", "message": "spotless apply", "committedDate": "2020-10-08T03:10:14Z", "type": "commit"}, {"oid": "307f7c487adac64da39b7182aab9b5bb69a8a547", "url": "https://github.com/osmlab/atlas-checks/commit/307f7c487adac64da39b7182aab9b5bb69a8a547", "message": "fixing sonar cloud errors and spotless", "committedDate": "2020-10-08T03:34:29Z", "type": "commit"}, {"oid": "576ed3978119f9cf89079802ba051bae4053f368", "url": "https://github.com/osmlab/atlas-checks/commit/576ed3978119f9cf89079802ba051bae4053f368", "message": "Update SuddenHighwayTypeChangeCheck.java", "committedDate": "2020-10-08T04:00:18Z", "type": "commit"}, {"oid": "3465eb10499fe62684837db7eefb646f32d8db3f", "url": "https://github.com/osmlab/atlas-checks/commit/3465eb10499fe62684837db7eefb646f32d8db3f", "message": "Update SuddenHighwayTypeChangeCheck.java", "committedDate": "2020-10-08T04:10:15Z", "type": "commit"}, {"oid": "76a2e278cf73adc74b2934256ccb033f35f752e6", "url": "https://github.com/osmlab/atlas-checks/commit/76a2e278cf73adc74b2934256ccb033f35f752e6", "message": "Update SuddenHighwayTypeChangeCheck.java", "committedDate": "2020-10-08T04:29:28Z", "type": "commit"}, {"oid": "4cd288b4027e6dc4c380356e054e72ef42c2d895", "url": "https://github.com/osmlab/atlas-checks/commit/4cd288b4027e6dc4c380356e054e72ef42c2d895", "message": "Update SuddenHighwayTypeChangeCheck.java", "committedDate": "2020-10-08T04:30:36Z", "type": "commit"}, {"oid": "4a5ddf96ffe6bc5b09137d997ba56a767c8cbb34", "url": "https://github.com/osmlab/atlas-checks/commit/4a5ddf96ffe6bc5b09137d997ba56a767c8cbb34", "message": "Update SuddenHighwayTypeChangeCheck.java", "committedDate": "2020-10-08T04:38:35Z", "type": "commit"}, {"oid": "3fd0adfeb1430af5b30ccf8f8947e63f9a5200d3", "url": "https://github.com/osmlab/atlas-checks/commit/3fd0adfeb1430af5b30ccf8f8947e63f9a5200d3", "message": "consolidated conditionals to simplify final method", "committedDate": "2020-10-08T05:08:39Z", "type": "commit"}, {"oid": "21b9bb7faa6100d6756be5c21abc125663b2b779", "url": "https://github.com/osmlab/atlas-checks/commit/21b9bb7faa6100d6756be5c21abc125663b2b779", "message": "Update SuddenHighwayTypeChangeCheck.java", "committedDate": "2020-10-08T05:11:46Z", "type": "commit"}, {"oid": "b4a73f5841b873943b8c96799c459896abb788c4", "url": "https://github.com/osmlab/atlas-checks/commit/b4a73f5841b873943b8c96799c459896abb788c4", "message": "Update SuddenHighwayTypeChangeCheck.java", "committedDate": "2020-10-08T05:17:21Z", "type": "commit"}, {"oid": "fe336dff3d5fac8a806da4210bd4108d3d962ba5", "url": "https://github.com/osmlab/atlas-checks/commit/fe336dff3d5fac8a806da4210bd4108d3d962ba5", "message": "Update SuddenHighwayTypeChangeCheck.java", "committedDate": "2020-10-08T06:09:44Z", "type": "commit"}, {"oid": "a4a3aca11a35c5dd1fc45feb2150acf197487be2", "url": "https://github.com/osmlab/atlas-checks/commit/a4a3aca11a35c5dd1fc45feb2150acf197487be2", "message": "Update SuddenHighwayTypeChangeCheck.java", "committedDate": "2020-10-08T06:13:50Z", "type": "commit"}, {"oid": "4d10b0f71b167cf9bd528e2a7979ec1fe69ea516", "url": "https://github.com/osmlab/atlas-checks/commit/4d10b0f71b167cf9bd528e2a7979ec1fe69ea516", "message": "Update SuddenHighwayTypeChangeCheck.java", "committedDate": "2020-10-08T06:35:37Z", "type": "commit"}, {"oid": "f809e8d93172aa13dadb6b2184baf3529825bdfe", "url": "https://github.com/osmlab/atlas-checks/commit/f809e8d93172aa13dadb6b2184baf3529825bdfe", "message": "removing marking connected edges as flagged to maximize detections.", "committedDate": "2020-10-08T08:36:51Z", "type": "commit"}, {"oid": "b145c7ae978794d317fab0edcd2c693f2460175e", "url": "https://github.com/osmlab/atlas-checks/commit/b145c7ae978794d317fab0edcd2c693f2460175e", "message": "Update SuddenHighwayTypeChangeCheck.java", "committedDate": "2020-10-08T08:41:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc1MDAyMw==", "url": "https://github.com/osmlab/atlas-checks/pull/381#discussion_r508750023", "bodyText": "Could we have some documentation here? Even if it's just something  copy pasted from the check's readme -- makes it easier to know what the check does without searching for docs", "author": "seancoulter", "createdAt": "2020-10-20T18:32:50Z", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/SuddenHighwayTypeChangeCheck.java", "diffHunk": "@@ -0,0 +1,248 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Auto generated Check template", "originalCommit": "b145c7ae978794d317fab0edcd2c693f2460175e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDYxOTk1Ng==", "url": "https://github.com/osmlab/atlas-checks/pull/381#discussion_r510619956", "bodyText": "updated! Let me know if there should be more", "author": "reichg", "createdAt": "2020-10-23T05:37:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc1MDAyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc1MDkxOQ==", "url": "https://github.com/osmlab/atlas-checks/pull/381#discussion_r508750919", "bodyText": "Hate to be a stickler, but some method docs would be helpful, if not actually the standard for new checks", "author": "seancoulter", "createdAt": "2020-10-20T18:34:23Z", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/SuddenHighwayTypeChangeCheck.java", "diffHunk": "@@ -0,0 +1,248 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Auto generated Check template\n+ *\n+ * @author v-garei\n+ */\n+public class SuddenHighwayTypeChangeCheck extends BaseCheck<Long>\n+{\n+    private static final String SUDDEN_HIGHWAY_TYPE_CHANGE_INSTRUCTION = \"Way {0,number,#} has a connected edge which jumps significantly in highway classification. Please make sure the highway tag is not suspicious.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Collections\n+            .singletonList(SUDDEN_HIGHWAY_TYPE_CHANGE_INSTRUCTION);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private final HighwayTag minHighwayType;\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public SuddenHighwayTypeChangeCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        if (TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && !isFlagged(object.getOsmIdentifier()))\n+        {\n+            final Edge edge = (Edge) object;\n+            return HighwayTag.isCarNavigableHighway(edge) && HighwayTag.highwayTag(edge).isPresent()\n+                    && edge.highwayTag().isMoreImportantThanOrEqualTo(this.minHighwayType)\n+                    && !JunctionTag.isRoundabout(edge) && !JunctionTag.isCircular(edge);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edgeBeingVerified = (Edge) object;\n+\n+        final List<Edge> completeWayEdges = new ArrayList<>(\n+                new OsmWayWalker(edgeBeingVerified).collectEdges());\n+\n+        final Node firstEdgeStartNode = completeWayEdges.get(0).start();\n+        final Node lastEdgeEndNode = completeWayEdges.get(completeWayEdges.size() - 1).end();\n+\n+        final Set<Edge> firstEdgeStartNodeEdges = firstEdgeStartNode.connectedEdges();\n+        firstEdgeStartNodeEdges\n+                .removeIf(edge -> edge.getOsmIdentifier() == edgeBeingVerified.getOsmIdentifier());\n+        final Set<Edge> lastEdgeEndNodeEdges = lastEdgeEndNode.connectedEdges();\n+        lastEdgeEndNodeEdges\n+                .removeIf(edge -> edge.getOsmIdentifier() == edgeBeingVerified.getOsmIdentifier());\n+\n+        HighwayTag edgeBeingVerifiedHighwayTag = HighwayTag.NO;\n+        final Optional<HighwayTag> edgeBeingVerifiedHighwayTagOptional = HighwayTag\n+                .highwayTag(edgeBeingVerified);\n+        if (edgeBeingVerifiedHighwayTagOptional.isPresent())\n+        {\n+            edgeBeingVerifiedHighwayTag = edgeBeingVerifiedHighwayTagOptional.get();\n+        }\n+\n+        final Set<HighwayTag> firstEdgeStartNodeEdgesHighwayTags = this\n+                .getHighwayTags(firstEdgeStartNodeEdges);\n+        final Set<HighwayTag> lastEdgeEndNodeEdgesHighwayTags = this\n+                .getHighwayTags(lastEdgeEndNodeEdges);\n+\n+        // Check ways' first edge's connected edges for suspiciously large highway tag jumps.\n+        for (final Edge firstEdgeEdge : firstEdgeStartNodeEdges)\n+        {\n+            final Optional<HighwayTag> firstEdgeEdgeHighwayTagOptional = HighwayTag\n+                    .highwayTag(firstEdgeEdge);\n+            if (firstEdgeEdgeHighwayTagOptional.isPresent()\n+                    && edgeBeingVerifiedHighwayTagOptional.isPresent()\n+                    && !firstEdgeStartNodeEdgesHighwayTags.contains(edgeBeingVerifiedHighwayTag)\n+                    && !this.edgeIsRoundaboutOrCircular(firstEdgeEdge))\n+            {\n+                final HighwayTag firstEdgeEdgeHighwayTag = firstEdgeEdgeHighwayTagOptional.get();\n+\n+                // All cases\n+                if (this.isCaseOne(edgeBeingVerifiedHighwayTag, firstEdgeEdgeHighwayTag)\n+                        || this.isCaseTwo(edgeBeingVerifiedHighwayTag, firstEdgeEdgeHighwayTag)\n+                        || this.isCaseThree(edgeBeingVerifiedHighwayTag, firstEdgeEdgeHighwayTag))\n+                {\n+                    markAsFlagged(edgeBeingVerified.getOsmIdentifier());\n+                    return Optional.of(this.createFlag(object,\n+                            this.getLocalizedInstruction(0, object.getOsmIdentifier())));\n+                }\n+            }\n+        }\n+\n+        // Check ways' last edge's connected edges for suspiciously large highway tag jumps\n+        for (final Edge lastEdgeEdge : lastEdgeEndNodeEdges)\n+        {\n+            final Optional<HighwayTag> lastEdgeEdgeHighwayTagOptional = HighwayTag\n+                    .highwayTag(lastEdgeEdge);\n+            if (lastEdgeEdgeHighwayTagOptional.isPresent()\n+                    && edgeBeingVerifiedHighwayTagOptional.isPresent()\n+                    && !lastEdgeEndNodeEdgesHighwayTags.contains(edgeBeingVerifiedHighwayTag)\n+                    && !this.edgeIsRoundaboutOrCircular(lastEdgeEdge))\n+            {\n+                final HighwayTag lastEdgeEdgeHighwayTag = lastEdgeEdgeHighwayTagOptional.get();\n+\n+                // All cases\n+                if (this.isCaseOne(edgeBeingVerifiedHighwayTag, lastEdgeEdgeHighwayTag)\n+                        || this.isCaseTwo(edgeBeingVerifiedHighwayTag, lastEdgeEdgeHighwayTag)\n+                        || this.isCaseThree(edgeBeingVerifiedHighwayTag, lastEdgeEdgeHighwayTag))\n+                {\n+                    markAsFlagged(edgeBeingVerified.getOsmIdentifier());\n+                    return Optional.of(this.createFlag(object,\n+                            this.getLocalizedInstruction(0, object.getOsmIdentifier())));\n+                }\n+            }\n+        }\n+        markAsFlagged(edgeBeingVerified.getOsmIdentifier());\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    private boolean edgeBeingVerifiedCaseOne(final HighwayTag edgeHighwayTag)", "originalCommit": "b145c7ae978794d317fab0edcd2c693f2460175e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDYxOTI1OQ==", "url": "https://github.com/osmlab/atlas-checks/pull/381#discussion_r510619259", "bodyText": "updated!", "author": "reichg", "createdAt": "2020-10-23T05:36:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc1MDkxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc1MzQwNQ==", "url": "https://github.com/osmlab/atlas-checks/pull/381#discussion_r508753405", "bodyText": "HighwayTag.highwayTag(edge).isPresent() would be redundant after HighwayTag.isCarNavigableHighway(edge)", "author": "seancoulter", "createdAt": "2020-10-20T18:37:28Z", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/SuddenHighwayTypeChangeCheck.java", "diffHunk": "@@ -0,0 +1,248 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Auto generated Check template\n+ *\n+ * @author v-garei\n+ */\n+public class SuddenHighwayTypeChangeCheck extends BaseCheck<Long>\n+{\n+    private static final String SUDDEN_HIGHWAY_TYPE_CHANGE_INSTRUCTION = \"Way {0,number,#} has a connected edge which jumps significantly in highway classification. Please make sure the highway tag is not suspicious.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Collections\n+            .singletonList(SUDDEN_HIGHWAY_TYPE_CHANGE_INSTRUCTION);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private final HighwayTag minHighwayType;\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public SuddenHighwayTypeChangeCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        if (TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && !isFlagged(object.getOsmIdentifier()))\n+        {\n+            final Edge edge = (Edge) object;\n+            return HighwayTag.isCarNavigableHighway(edge) && HighwayTag.highwayTag(edge).isPresent()", "originalCommit": "b145c7ae978794d317fab0edcd2c693f2460175e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDYxOTA2MA==", "url": "https://github.com/osmlab/atlas-checks/pull/381#discussion_r510619060", "bodyText": "updated!", "author": "reichg", "createdAt": "2020-10-23T05:36:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc1MzQwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc1OTc4NQ==", "url": "https://github.com/osmlab/atlas-checks/pull/381#discussion_r508759785", "bodyText": "This should be doable just by:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    HighwayTag edgeBeingVerifiedHighwayTag = HighwayTag.NO;\n          \n          \n            \n                    final Optional<HighwayTag> edgeBeingVerifiedHighwayTagOptional = HighwayTag\n          \n          \n            \n                            .highwayTag(edgeBeingVerified);\n          \n          \n            \n                    if (edgeBeingVerifiedHighwayTagOptional.isPresent())\n          \n          \n            \n                    {\n          \n          \n            \n                        edgeBeingVerifiedHighwayTag = edgeBeingVerifiedHighwayTagOptional.get();\n          \n          \n            \n                    }\n          \n          \n            \n                    final HighwayTag edgeBeingVerifiedHighwayTag = HighwayTag.highwayTag(edgeBeingVerified).orElse(HighwayTag.NO);\n          \n      \n    \n    \n  \n\nthanks to built-ins", "author": "seancoulter", "createdAt": "2020-10-20T18:44:57Z", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/SuddenHighwayTypeChangeCheck.java", "diffHunk": "@@ -0,0 +1,248 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Auto generated Check template\n+ *\n+ * @author v-garei\n+ */\n+public class SuddenHighwayTypeChangeCheck extends BaseCheck<Long>\n+{\n+    private static final String SUDDEN_HIGHWAY_TYPE_CHANGE_INSTRUCTION = \"Way {0,number,#} has a connected edge which jumps significantly in highway classification. Please make sure the highway tag is not suspicious.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Collections\n+            .singletonList(SUDDEN_HIGHWAY_TYPE_CHANGE_INSTRUCTION);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private final HighwayTag minHighwayType;\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public SuddenHighwayTypeChangeCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        if (TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && !isFlagged(object.getOsmIdentifier()))\n+        {\n+            final Edge edge = (Edge) object;\n+            return HighwayTag.isCarNavigableHighway(edge) && HighwayTag.highwayTag(edge).isPresent()\n+                    && edge.highwayTag().isMoreImportantThanOrEqualTo(this.minHighwayType)\n+                    && !JunctionTag.isRoundabout(edge) && !JunctionTag.isCircular(edge);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edgeBeingVerified = (Edge) object;\n+\n+        final List<Edge> completeWayEdges = new ArrayList<>(\n+                new OsmWayWalker(edgeBeingVerified).collectEdges());\n+\n+        final Node firstEdgeStartNode = completeWayEdges.get(0).start();\n+        final Node lastEdgeEndNode = completeWayEdges.get(completeWayEdges.size() - 1).end();\n+\n+        final Set<Edge> firstEdgeStartNodeEdges = firstEdgeStartNode.connectedEdges();\n+        firstEdgeStartNodeEdges\n+                .removeIf(edge -> edge.getOsmIdentifier() == edgeBeingVerified.getOsmIdentifier());\n+        final Set<Edge> lastEdgeEndNodeEdges = lastEdgeEndNode.connectedEdges();\n+        lastEdgeEndNodeEdges\n+                .removeIf(edge -> edge.getOsmIdentifier() == edgeBeingVerified.getOsmIdentifier());\n+\n+        HighwayTag edgeBeingVerifiedHighwayTag = HighwayTag.NO;\n+        final Optional<HighwayTag> edgeBeingVerifiedHighwayTagOptional = HighwayTag\n+                .highwayTag(edgeBeingVerified);\n+        if (edgeBeingVerifiedHighwayTagOptional.isPresent())\n+        {\n+            edgeBeingVerifiedHighwayTag = edgeBeingVerifiedHighwayTagOptional.get();\n+        }", "originalCommit": "b145c7ae978794d317fab0edcd2c693f2460175e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDYxODg0NA==", "url": "https://github.com/osmlab/atlas-checks/pull/381#discussion_r510618844", "bodyText": "updated!", "author": "reichg", "createdAt": "2020-10-23T05:36:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc1OTc4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc2MjE5Mg==", "url": "https://github.com/osmlab/atlas-checks/pull/381#discussion_r508762192", "bodyText": "this might need to be changed if you use the suggestion I made last ^\n&& !edgeBeingVerifiedHighwayTag.equals(HighwayTag.NO)", "author": "seancoulter", "createdAt": "2020-10-20T18:48:33Z", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/SuddenHighwayTypeChangeCheck.java", "diffHunk": "@@ -0,0 +1,248 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Auto generated Check template\n+ *\n+ * @author v-garei\n+ */\n+public class SuddenHighwayTypeChangeCheck extends BaseCheck<Long>\n+{\n+    private static final String SUDDEN_HIGHWAY_TYPE_CHANGE_INSTRUCTION = \"Way {0,number,#} has a connected edge which jumps significantly in highway classification. Please make sure the highway tag is not suspicious.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Collections\n+            .singletonList(SUDDEN_HIGHWAY_TYPE_CHANGE_INSTRUCTION);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private final HighwayTag minHighwayType;\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public SuddenHighwayTypeChangeCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        if (TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && !isFlagged(object.getOsmIdentifier()))\n+        {\n+            final Edge edge = (Edge) object;\n+            return HighwayTag.isCarNavigableHighway(edge) && HighwayTag.highwayTag(edge).isPresent()\n+                    && edge.highwayTag().isMoreImportantThanOrEqualTo(this.minHighwayType)\n+                    && !JunctionTag.isRoundabout(edge) && !JunctionTag.isCircular(edge);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edgeBeingVerified = (Edge) object;\n+\n+        final List<Edge> completeWayEdges = new ArrayList<>(\n+                new OsmWayWalker(edgeBeingVerified).collectEdges());\n+\n+        final Node firstEdgeStartNode = completeWayEdges.get(0).start();\n+        final Node lastEdgeEndNode = completeWayEdges.get(completeWayEdges.size() - 1).end();\n+\n+        final Set<Edge> firstEdgeStartNodeEdges = firstEdgeStartNode.connectedEdges();\n+        firstEdgeStartNodeEdges\n+                .removeIf(edge -> edge.getOsmIdentifier() == edgeBeingVerified.getOsmIdentifier());\n+        final Set<Edge> lastEdgeEndNodeEdges = lastEdgeEndNode.connectedEdges();\n+        lastEdgeEndNodeEdges\n+                .removeIf(edge -> edge.getOsmIdentifier() == edgeBeingVerified.getOsmIdentifier());\n+\n+        HighwayTag edgeBeingVerifiedHighwayTag = HighwayTag.NO;\n+        final Optional<HighwayTag> edgeBeingVerifiedHighwayTagOptional = HighwayTag\n+                .highwayTag(edgeBeingVerified);\n+        if (edgeBeingVerifiedHighwayTagOptional.isPresent())\n+        {\n+            edgeBeingVerifiedHighwayTag = edgeBeingVerifiedHighwayTagOptional.get();\n+        }\n+\n+        final Set<HighwayTag> firstEdgeStartNodeEdgesHighwayTags = this\n+                .getHighwayTags(firstEdgeStartNodeEdges);\n+        final Set<HighwayTag> lastEdgeEndNodeEdgesHighwayTags = this\n+                .getHighwayTags(lastEdgeEndNodeEdges);\n+\n+        // Check ways' first edge's connected edges for suspiciously large highway tag jumps.\n+        for (final Edge firstEdgeEdge : firstEdgeStartNodeEdges)\n+        {\n+            final Optional<HighwayTag> firstEdgeEdgeHighwayTagOptional = HighwayTag\n+                    .highwayTag(firstEdgeEdge);\n+            if (firstEdgeEdgeHighwayTagOptional.isPresent()\n+                    && edgeBeingVerifiedHighwayTagOptional.isPresent()", "originalCommit": "b145c7ae978794d317fab0edcd2c693f2460175e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDYxODY5NA==", "url": "https://github.com/osmlab/atlas-checks/pull/381#discussion_r510618694", "bodyText": "updated", "author": "reichg", "createdAt": "2020-10-23T05:36:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc2MjE5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc2MzUyNQ==", "url": "https://github.com/osmlab/atlas-checks/pull/381#discussion_r508763525", "bodyText": "do you think this loop and the one prior could be put into a method, and parameterized with firstEdgeStartNodeEdgesHighwayTags and then lastEdgeEndNodeEdgesHighwayTags ?", "author": "seancoulter", "createdAt": "2020-10-20T18:50:56Z", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/SuddenHighwayTypeChangeCheck.java", "diffHunk": "@@ -0,0 +1,248 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Auto generated Check template\n+ *\n+ * @author v-garei\n+ */\n+public class SuddenHighwayTypeChangeCheck extends BaseCheck<Long>\n+{\n+    private static final String SUDDEN_HIGHWAY_TYPE_CHANGE_INSTRUCTION = \"Way {0,number,#} has a connected edge which jumps significantly in highway classification. Please make sure the highway tag is not suspicious.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Collections\n+            .singletonList(SUDDEN_HIGHWAY_TYPE_CHANGE_INSTRUCTION);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private final HighwayTag minHighwayType;\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public SuddenHighwayTypeChangeCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        if (TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && !isFlagged(object.getOsmIdentifier()))\n+        {\n+            final Edge edge = (Edge) object;\n+            return HighwayTag.isCarNavigableHighway(edge) && HighwayTag.highwayTag(edge).isPresent()\n+                    && edge.highwayTag().isMoreImportantThanOrEqualTo(this.minHighwayType)\n+                    && !JunctionTag.isRoundabout(edge) && !JunctionTag.isCircular(edge);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edgeBeingVerified = (Edge) object;\n+\n+        final List<Edge> completeWayEdges = new ArrayList<>(\n+                new OsmWayWalker(edgeBeingVerified).collectEdges());\n+\n+        final Node firstEdgeStartNode = completeWayEdges.get(0).start();\n+        final Node lastEdgeEndNode = completeWayEdges.get(completeWayEdges.size() - 1).end();\n+\n+        final Set<Edge> firstEdgeStartNodeEdges = firstEdgeStartNode.connectedEdges();\n+        firstEdgeStartNodeEdges\n+                .removeIf(edge -> edge.getOsmIdentifier() == edgeBeingVerified.getOsmIdentifier());\n+        final Set<Edge> lastEdgeEndNodeEdges = lastEdgeEndNode.connectedEdges();\n+        lastEdgeEndNodeEdges\n+                .removeIf(edge -> edge.getOsmIdentifier() == edgeBeingVerified.getOsmIdentifier());\n+\n+        HighwayTag edgeBeingVerifiedHighwayTag = HighwayTag.NO;\n+        final Optional<HighwayTag> edgeBeingVerifiedHighwayTagOptional = HighwayTag\n+                .highwayTag(edgeBeingVerified);\n+        if (edgeBeingVerifiedHighwayTagOptional.isPresent())\n+        {\n+            edgeBeingVerifiedHighwayTag = edgeBeingVerifiedHighwayTagOptional.get();\n+        }\n+\n+        final Set<HighwayTag> firstEdgeStartNodeEdgesHighwayTags = this\n+                .getHighwayTags(firstEdgeStartNodeEdges);\n+        final Set<HighwayTag> lastEdgeEndNodeEdgesHighwayTags = this\n+                .getHighwayTags(lastEdgeEndNodeEdges);\n+\n+        // Check ways' first edge's connected edges for suspiciously large highway tag jumps.\n+        for (final Edge firstEdgeEdge : firstEdgeStartNodeEdges)\n+        {\n+            final Optional<HighwayTag> firstEdgeEdgeHighwayTagOptional = HighwayTag\n+                    .highwayTag(firstEdgeEdge);\n+            if (firstEdgeEdgeHighwayTagOptional.isPresent()\n+                    && edgeBeingVerifiedHighwayTagOptional.isPresent()\n+                    && !firstEdgeStartNodeEdgesHighwayTags.contains(edgeBeingVerifiedHighwayTag)\n+                    && !this.edgeIsRoundaboutOrCircular(firstEdgeEdge))\n+            {\n+                final HighwayTag firstEdgeEdgeHighwayTag = firstEdgeEdgeHighwayTagOptional.get();\n+\n+                // All cases\n+                if (this.isCaseOne(edgeBeingVerifiedHighwayTag, firstEdgeEdgeHighwayTag)\n+                        || this.isCaseTwo(edgeBeingVerifiedHighwayTag, firstEdgeEdgeHighwayTag)\n+                        || this.isCaseThree(edgeBeingVerifiedHighwayTag, firstEdgeEdgeHighwayTag))\n+                {\n+                    markAsFlagged(edgeBeingVerified.getOsmIdentifier());\n+                    return Optional.of(this.createFlag(object,\n+                            this.getLocalizedInstruction(0, object.getOsmIdentifier())));\n+                }\n+            }\n+        }\n+\n+        // Check ways' last edge's connected edges for suspiciously large highway tag jumps\n+        for (final Edge lastEdgeEdge : lastEdgeEndNodeEdges)", "originalCommit": "b145c7ae978794d317fab0edcd2c693f2460175e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDYxODU2NA==", "url": "https://github.com/osmlab/atlas-checks/pull/381#discussion_r510618564", "bodyText": "Did my best to implement these in methods. I have it working with same results and eliminates code smell.", "author": "reichg", "createdAt": "2020-10-23T05:36:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc2MzUyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgyMjg2Ng==", "url": "https://github.com/osmlab/atlas-checks/pull/381#discussion_r508822866", "bodyText": "It would be good to have a true positive tests for each of the 3 cases.", "author": "Bentleysb", "createdAt": "2020-10-20T20:36:43Z", "path": "src/test/java/org/openstreetmap/atlas/checks/validation/linear/edges/SuddenHighwayTypeChangeCheckTest.java", "diffHunk": "@@ -0,0 +1,39 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.openstreetmap.atlas.checks.configuration.ConfigurationResolver;\n+import org.openstreetmap.atlas.checks.validation.verifier.ConsumerBasedExpectedCheckVerifier;\n+\n+/**\n+ * Tests for {@link SuddenHighwayTypeChangeCheck}\n+ *\n+ * @author v-garei\n+ */\n+public class SuddenHighwayTypeChangeCheckTest\n+{\n+\n+    @Rule\n+    public SuddenHighwayTypeChangeCheckTestRule setup = new SuddenHighwayTypeChangeCheckTestRule();\n+\n+    @Rule\n+    public ConsumerBasedExpectedCheckVerifier verifier = new ConsumerBasedExpectedCheckVerifier();\n+\n+    private final SuddenHighwayTypeChangeCheck check = new SuddenHighwayTypeChangeCheck(\n+            ConfigurationResolver.inlineConfiguration(\n+                    \"{\\\"SuddenHighwayTypeChangeCheck\\\": {\\\"minHighwayType\\\": \\\"tertiary\\\"}}\"));\n+\n+    @Test\n+    public void testFalsePositiveSuddenHighwayTypeChangeCheck()\n+    {\n+        this.verifier.actual(this.setup.falsePositiveSuddenHighwayTypeChangeCheck(), this.check);\n+        this.verifier.verifyEmpty();\n+    }\n+\n+    @Test\n+    public void testTruePositiveSuddenHighwayTypeChangeCheck()", "originalCommit": "b145c7ae978794d317fab0edcd2c693f2460175e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDYxNTA2MA==", "url": "https://github.com/osmlab/atlas-checks/pull/381#discussion_r510615060", "bodyText": "each case has been added in test", "author": "reichg", "createdAt": "2020-10-23T05:32:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgyMjg2Ng=="}], "type": "inlineReview"}, {"oid": "64a896df16c342500a852cbabda5aea658ba5235", "url": "https://github.com/osmlab/atlas-checks/commit/64a896df16c342500a852cbabda5aea658ba5235", "message": "Merge branch 'dev' of https://github.com/reichg/atlas-checks into suddenhighwaytypechange", "committedDate": "2020-10-21T22:05:59Z", "type": "commit"}, {"oid": "7f05399c46b97df296b43651f7b0d18717041222", "url": "https://github.com/osmlab/atlas-checks/commit/7f05399c46b97df296b43651f7b0d18717041222", "message": "fixing change requests from pull request.", "committedDate": "2020-10-22T16:25:39Z", "type": "commit"}, {"oid": "ffe4f2fb3f34b83f6eb7d23dfd5329558d68a3de", "url": "https://github.com/osmlab/atlas-checks/commit/ffe4f2fb3f34b83f6eb7d23dfd5329558d68a3de", "message": "updated test checks for cases and addressed comments", "committedDate": "2020-10-22T22:56:48Z", "type": "commit"}, {"oid": "b7c091748d14eff77ffed2832480727b5308373f", "url": "https://github.com/osmlab/atlas-checks/commit/b7c091748d14eff77ffed2832480727b5308373f", "message": "fixed config", "committedDate": "2020-10-22T23:08:41Z", "type": "commit"}, {"oid": "a14362b32236bf65a5b26eec00446d99206648cb", "url": "https://github.com/osmlab/atlas-checks/commit/a14362b32236bf65a5b26eec00446d99206648cb", "message": "fixing code smells", "committedDate": "2020-10-23T05:02:09Z", "type": "commit"}, {"oid": "b77dcdf8a1622e52230bcad10eee2d12c4c50e0a", "url": "https://github.com/osmlab/atlas-checks/commit/b77dcdf8a1622e52230bcad10eee2d12c4c50e0a", "message": "hopefully last spotless apply", "committedDate": "2020-10-23T05:05:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTA2MzczNw==", "url": "https://github.com/osmlab/atlas-checks/pull/381#discussion_r511063737", "bodyText": "nit: I think you can return true here", "author": "seancoulter", "createdAt": "2020-10-23T18:26:31Z", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/SuddenHighwayTypeChangeCheck.java", "diffHunk": "@@ -0,0 +1,361 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * This check identifies ways that make suspiciously large jumps in highway classification\n+ *\n+ * @author v-garei\n+ */\n+public class SuddenHighwayTypeChangeCheck extends BaseCheck<Long>\n+{\n+    private static final String SUDDEN_HIGHWAY_TYPE_CHANGE_INSTRUCTION = \"Way {0,number,#} has a connected edge which jumps significantly in highway classification. Please make sure the highway tag is not suspicious.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Collections\n+            .singletonList(SUDDEN_HIGHWAY_TYPE_CHANGE_INSTRUCTION);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private final HighwayTag minHighwayType;\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     * \n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public SuddenHighwayTypeChangeCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     * \n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        if (TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && !isFlagged(object.getOsmIdentifier()))\n+        {\n+            final Edge edge = (Edge) object;\n+            return HighwayTag.isCarNavigableHighway(edge)\n+                    && edge.highwayTag().isMoreImportantThanOrEqualTo(this.minHighwayType)\n+                    && !JunctionTag.isRoundabout(edge) && !JunctionTag.isCircular(edge);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     * \n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edgeBeingVerified = (Edge) object;\n+\n+        final List<Edge> completeWayEdges = new ArrayList<>(\n+                new OsmWayWalker(edgeBeingVerified).collectEdges());\n+\n+        final Node firstEdgeStartNode = completeWayEdges.get(0).start();\n+        final Node lastEdgeEndNode = completeWayEdges.get(completeWayEdges.size() - 1).end();\n+\n+        final Set<Edge> firstEdgeStartNodeEdges = firstEdgeStartNode.connectedEdges();\n+        firstEdgeStartNodeEdges\n+                .removeIf(edge -> edge.getOsmIdentifier() == edgeBeingVerified.getOsmIdentifier());\n+        final Set<Edge> lastEdgeEndNodeEdges = lastEdgeEndNode.connectedEdges();\n+        lastEdgeEndNodeEdges\n+                .removeIf(edge -> edge.getOsmIdentifier() == edgeBeingVerified.getOsmIdentifier());\n+\n+        final HighwayTag edgeBeingVerifiedHighwayTag = HighwayTag.highwayTag(edgeBeingVerified)\n+                .orElse(HighwayTag.NO);\n+\n+        final Set<HighwayTag> firstEdgeStartNodeEdgesHighwayTags = this\n+                .getHighwayTags(firstEdgeStartNodeEdges);\n+        final Set<HighwayTag> lastEdgeEndNodeEdgesHighwayTags = this\n+                .getHighwayTags(lastEdgeEndNodeEdges);\n+\n+        // Check ways' first and last edge's connected edges for suspiciously large highway tag\n+        // jumps.\n+        if (this.firstEdgeStartNodeEdgesHighwayTags(edgeBeingVerifiedHighwayTag,\n+                firstEdgeStartNodeEdges, firstEdgeStartNodeEdgesHighwayTags)\n+                || this.lastEdgeEndNodeEdgesHighwayTage(edgeBeingVerifiedHighwayTag,\n+                        lastEdgeEndNodeEdges, lastEdgeEndNodeEdgesHighwayTags))\n+        {\n+            markAsFlagged(object.getOsmIdentifier());\n+            return Optional.of(\n+                    createFlag(object, this.getLocalizedInstruction(0, object.getOsmIdentifier())));\n+        }\n+\n+        markAsFlagged(edgeBeingVerified.getOsmIdentifier());\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Case one: edge being verified is motorway, primary, trunk\n+     * \n+     * @param edgeHighwayTag\n+     *            tag for edge being verified\n+     * @return boolean\n+     */\n+    private boolean edgeBeingVerifiedCaseOne(final HighwayTag edgeHighwayTag)\n+    {\n+        return HighwayTag.MOTORWAY.equals(edgeHighwayTag)\n+                || HighwayTag.PRIMARY.equals(edgeHighwayTag)\n+                || HighwayTag.TRUNK.equals(edgeHighwayTag);\n+    }\n+\n+    /**\n+     * Case three: edge being verified is tertiary or tertiary_link\n+     * \n+     * @param edgeHighwayTag\n+     *            tag for edge being verified\n+     * @return boolean\n+     */\n+    private boolean edgeBeingVerifiedCaseThree(final HighwayTag edgeHighwayTag)\n+    {\n+        return HighwayTag.TERTIARY.equals(edgeHighwayTag)\n+                || HighwayTag.TERTIARY_LINK.equals(edgeHighwayTag);\n+    }\n+\n+    /**\n+     * case two: edge being verified is any link but tertiary.\n+     * \n+     * @param edgeHighwayTag\n+     *            tag for edge being verified\n+     * @return boolean\n+     */\n+    private boolean edgeBeingVerifiedCaseTwo(final HighwayTag edgeHighwayTag)\n+    {\n+        return HighwayTag.MOTORWAY_LINK.equals(edgeHighwayTag)\n+                || HighwayTag.PRIMARY_LINK.equals(edgeHighwayTag)\n+                || HighwayTag.TRUNK_LINK.equals(edgeHighwayTag)\n+                || HighwayTag.SECONDARY.equals(edgeHighwayTag)\n+                || HighwayTag.SECONDARY_LINK.equals(edgeHighwayTag);\n+    }\n+\n+    /**\n+     * case one: edge checked against is tertiary, residential, service, or unclassified\n+     * \n+     * @param edgeHighwayTag\n+     *            connected edge highway tag\n+     * @return boolean\n+     */\n+    private boolean edgeCheckedAgainstCaseOne(final HighwayTag edgeHighwayTag)\n+    {\n+        return HighwayTag.TERTIARY.equals(edgeHighwayTag)\n+                || HighwayTag.UNCLASSIFIED.equals(edgeHighwayTag)\n+                || HighwayTag.RESIDENTIAL.equals(edgeHighwayTag)\n+                || HighwayTag.SERVICE.equals(edgeHighwayTag);\n+    }\n+\n+    /**\n+     * case three: edge checked against is living_Street, service, or track\n+     * \n+     * @param edgeHighwayTag\n+     *            connected edge highway tag\n+     * @return boolean\n+     */\n+    private boolean edgeCheckedAgainstCaseThree(final HighwayTag edgeHighwayTag)\n+    {\n+        return HighwayTag.LIVING_STREET.equals(edgeHighwayTag)\n+                || HighwayTag.TRACK.equals(edgeHighwayTag)\n+                || HighwayTag.SERVICE.equals(edgeHighwayTag);\n+    }\n+\n+    /**\n+     * case two: edge checked against is residential, service, or unclassified\n+     * \n+     * @param edgeHighwayTag\n+     *            connected edge highway tag\n+     * @return boolean\n+     */\n+    private boolean edgeCheckedAgainstCaseTwo(final HighwayTag edgeHighwayTag)\n+    {\n+        return HighwayTag.UNCLASSIFIED.equals(edgeHighwayTag)\n+                || HighwayTag.RESIDENTIAL.equals(edgeHighwayTag)\n+                || HighwayTag.SERVICE.equals(edgeHighwayTag);\n+    }\n+\n+    /**\n+     * checks if edge is roundabout or circular\n+     * \n+     * @param edge\n+     *            edge to check if roundabout or circular\n+     * @return boolean\n+     */\n+    private boolean edgeIsRoundaboutOrCircular(final Edge edge)\n+    {\n+        return JunctionTag.isCircular(edge) || JunctionTag.isRoundabout(edge);\n+    }\n+\n+    /**\n+     * checks if edge being verified's first edge start node connected edges make suspicious jumps\n+     * \n+     * @param edgeBeingVerifiedHighwayTag\n+     *            edge being verified highway tag\n+     * @param firstEdgeStartNodeEdges\n+     *            first edge start node edges\n+     * @param firstEdgeStartNodeEdgesHighwayTags\n+     *            first edge start node edge highway tags\n+     * @return boolean\n+     */\n+    private boolean firstEdgeStartNodeEdgesHighwayTags(final HighwayTag edgeBeingVerifiedHighwayTag,\n+            final Set<Edge> firstEdgeStartNodeEdges,\n+            final Set<HighwayTag> firstEdgeStartNodeEdgesHighwayTags)\n+    {\n+        boolean suspiciousJump = false;\n+        for (final Edge firstEdgeEdge : firstEdgeStartNodeEdges)\n+        {\n+            final HighwayTag firstEdgeEdgeHighwayTag = HighwayTag.highwayTag(firstEdgeEdge)\n+                    .orElse(HighwayTag.NO);\n+            if ((!edgeBeingVerifiedHighwayTag.equals(HighwayTag.NO)\n+                    && !firstEdgeEdgeHighwayTag.equals(HighwayTag.NO)\n+                    && !firstEdgeStartNodeEdgesHighwayTags.contains(edgeBeingVerifiedHighwayTag)\n+                    && !this.edgeIsRoundaboutOrCircular(firstEdgeEdge))\n+                    && (this.isCaseOne(edgeBeingVerifiedHighwayTag, firstEdgeEdgeHighwayTag)\n+                            || this.isCaseTwo(edgeBeingVerifiedHighwayTag, firstEdgeEdgeHighwayTag)\n+                            || this.isCaseThree(edgeBeingVerifiedHighwayTag,\n+                                    firstEdgeEdgeHighwayTag)))\n+            {\n+                suspiciousJump = true;", "originalCommit": "b77dcdf8a1622e52230bcad10eee2d12c4c50e0a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTA4MzU3OQ==", "url": "https://github.com/osmlab/atlas-checks/pull/381#discussion_r511083579", "bodyText": "yup, agreed on this! fixed", "author": "reichg", "createdAt": "2020-10-23T18:54:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTA2MzczNw=="}], "type": "inlineReview"}, {"oid": "7ecb1b47fe06b2aa8319ea8f7bf9f8aa601efdd2", "url": "https://github.com/osmlab/atlas-checks/commit/7ecb1b47fe06b2aa8319ea8f7bf9f8aa601efdd2", "message": "fixed config", "committedDate": "2020-10-23T18:38:44Z", "type": "commit"}, {"oid": "739c72cef66ba6023ae084d778ed6006d9adad58", "url": "https://github.com/osmlab/atlas-checks/commit/739c72cef66ba6023ae084d778ed6006d9adad58", "message": "siplified the main functions with return true or false", "committedDate": "2020-10-23T18:55:28Z", "type": "commit"}]}