{"pr_number": 287, "pr_title": "LCWB enhancement - borders,ferries,fords", "pr_createdAt": "2020-04-23T20:22:31Z", "pr_url": "https://github.com/osmlab/atlas-checks/pull/287", "timeline": [{"oid": "1740b1173399074ff84ac718962493337c01fcb9", "url": "https://github.com/osmlab/atlas-checks/commit/1740b1173399074ff84ac718962493337c01fcb9", "message": "better border relation flagging", "committedDate": "2020-04-22T20:55:44Z", "type": "commit"}, {"oid": "eaa9205645ea81794333a76f6dcb87d4c7253bdb", "url": "https://github.com/osmlab/atlas-checks/commit/eaa9205645ea81794333a76f6dcb87d4c7253bdb", "message": "refine floating feature logix", "committedDate": "2020-04-23T06:18:16Z", "type": "commit"}, {"oid": "5b8eb3070500a376eb6a024e9a695414c9c17e08", "url": "https://github.com/osmlab/atlas-checks/commit/5b8eb3070500a376eb6a024e9a695414c9c17e08", "message": "spotless", "committedDate": "2020-04-23T07:46:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY4NDE3MA==", "url": "https://github.com/osmlab/atlas-checks/pull/287#discussion_r417684170", "bodyText": "While this seems like it works -- this solution feels a bit hacky. We've ran into this issue before and proposed parsing the identifier to verify whether or not the feature has been sliced at the border -- this too felt like a hack.\nI would defer to atlas to provide a better (reusable) solution to verify if a feature has been country sliced -- as its shown to be useful in other checks.", "author": "danielduhh", "createdAt": "2020-04-30T00:11:40Z", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/LineCrossingWaterBodyCheck.java", "diffHunk": "@@ -329,29 +335,61 @@ private boolean intersectionsAreExplicit(final GeometricSurface waterbody,\n                 .haveExplicitLocationsForIntersections(polygon, lineItem));\n     }\n \n+    /**\n+     * If the waterbody is an area, the intersection is valid. If it's not an area, it's a\n+     * multipolygon, and we make sure that either 1. The intersection is at an outer member of the\n+     * multipolygon and the outer member was not synthetically created by the atlas slicing process.\n+     * It's estimated that if the outer member doesn't have the {@link LastEditTimeTag}, it likely\n+     * did not come from an OSM feature, which suggests it was created due to atlas slicing and\n+     * would therefore not be a geometrically accurate member of the relation. 2. The intersecting\n+     * feature is entirely floating in an outer member of the relation, and not\n+     * intersecting/floating in any of the inner members. The inner members are typically islands so\n+     * we avoid flagging in the latter scenario. The outer member must still have the LastEditTime\n+     * tag\n+     *\n+     * @param waterbody\n+     *            the GeometricSurface representation of the waterbody\n+     * @param object\n+     *            the AtlasEntity representation of the waterbody\n+     * @param intersectingFeature\n+     *            the intersecting building/road/line\n+     * @return true if either of the 2 above conditions are satisfied, false otherwise\n+     */\n+    private boolean intersectsValidPartOfWaterbody(final GeometricSurface waterbody,\n+            final AtlasObject object, final PolyLine intersectingFeature)\n+    {\n+        return !(waterbody instanceof MultiPolygon) || ((Relation) object).members().stream()\n+                .filter(member -> member.getRole().equals(\"outer\"))\n+                .map(member -> new Tuple<>(member.getEntity(),\n+                        new Polygon(member.getEntity() instanceof Area ? (Area) member.getEntity()\n+                                : (LineItem) member.getEntity())))\n+                .anyMatch(member -> (intersectingFeature.intersects(member.getSecond())\n+                        || (intersectingFeature.within(member.getSecond())\n+                                && ((MultiPolygon) waterbody).inners().stream().noneMatch(\n+                                        innerMember -> intersectingFeature.intersects(innerMember)\n+                                                || intersectingFeature.within(innerMember))))\n+                        && member.getFirst().lastEdit().isPresent());", "originalCommit": "5b8eb3070500a376eb6a024e9a695414c9c17e08", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MTMwNw==", "url": "https://github.com/osmlab/atlas-checks/pull/287#discussion_r422361307", "bodyText": "I agree that this should definitely be in Atlas. However, just to get a short term solution/discussion going, I did a minor change on this logic to be more in line with how country slicing works- we're now making sure the relation member has any tag other than the IsoCountryTag and SyntheticNearestNeighborCountryCodeTag. These two tags are synthetically added to a relation member that's been sliced at the border. The new logic should validate the same features as the previous method since all validated members should still have the LastEditTimeTag/other OSM specific tags.\nThis change is at 28a3ce6#diff-829f2e37322d264fb3b26e180abc731eR404", "author": "seancoulter", "createdAt": "2020-05-08T20:37:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY4NDE3MA=="}], "type": "inlineReview"}, {"oid": "ad94ce8feea8e6d4fd2b0ed704d6a21b6377e5b2", "url": "https://github.com/osmlab/atlas-checks/commit/ad94ce8feea8e6d4fd2b0ed704d6a21b6377e5b2", "message": "Merge branch 'dev' into lcwbBorderRelationFix", "committedDate": "2020-05-04T16:59:57Z", "type": "commit"}, {"oid": "ca0158a32b0a9abdafa885548050102f3628942c", "url": "https://github.com/osmlab/atlas-checks/commit/ca0158a32b0a9abdafa885548050102f3628942c", "message": "new border tag attempt 1", "committedDate": "2020-05-05T20:30:53Z", "type": "commit"}, {"oid": "28a3ce651b64e477b9b6e46a6868e0e78f273b64", "url": "https://github.com/osmlab/atlas-checks/commit/28a3ce651b64e477b9b6e46a6868e0e78f273b64", "message": "allow fording/ferry roads; edit border relation logic", "committedDate": "2020-05-08T20:29:18Z", "type": "commit"}, {"oid": "446221903b118ea099b5ef514c5d2232ef96de54", "url": "https://github.com/osmlab/atlas-checks/commit/446221903b118ea099b5ef514c5d2232ef96de54", "message": "Merge branch 'lcwbBorderRelationFix' of https://github.com/seancoulter/atlas-checks into lcwbBorderRelationFix", "committedDate": "2020-05-08T20:29:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE1NDg4OA==", "url": "https://github.com/osmlab/atlas-checks/pull/287#discussion_r423154888", "bodyText": "I believe this comment is out of date", "author": "danielduhh", "createdAt": "2020-05-11T16:13:28Z", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/LineCrossingWaterBodyCheck.java", "diffHunk": "@@ -329,29 +368,63 @@ private boolean intersectionsAreExplicit(final GeometricSurface waterbody,\n                 .haveExplicitLocationsForIntersections(polygon, lineItem));\n     }\n \n+    /**\n+     * If the waterbody is an area, the intersection is valid. If it's not an area, it's a\n+     * multipolygon, and we make sure that either 1. The intersection is at an outer member of the\n+     * multipolygon and the outer member was not synthetically created by the atlas slicing process.\n+     * It's estimated that if the outer member doesn't have the {@link LastEditTimeTag}, it likely", "originalCommit": "446221903b118ea099b5ef514c5d2232ef96de54", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE1NjY4OQ==", "url": "https://github.com/osmlab/atlas-checks/pull/287#discussion_r423156689", "bodyText": "Can the ford use case addition be added to the lines.non_offending configurable list?", "author": "danielduhh", "createdAt": "2020-05-11T16:16:12Z", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/LineCrossingWaterBodyCheck.java", "diffHunk": "@@ -293,31 +302,61 @@ public boolean validCheckForObject(final AtlasObject object)\n      *            {@link AtlasItem} crossing\n      * @return whether given {@link AtlasItem} can cross a water body\n      */\n-    private boolean canCrossWaterBody(final AtlasItem crossingItem)\n+    private boolean canCrossWaterBody(final AtlasItem crossingItem,\n+            final GeometricSurface waterbody)\n     {\n-        // In the following cases, given item can cross a water body\n-\n-        return this.canCrossWaterBodyFilter.test(crossingItem)\n+        // In the following cases, given line can cross a water body\n+        if (this.canCrossWaterBodyFilter.test(crossingItem)\n                 // It has a tag starting with addr\n                 || crossingItem.containsKeyStartsWith(Collections.singleton(ADDRESS_PREFIX_KEY))\n                 // If crossing item is a line and meets the conditions for a boundary\n-                || crossingItem instanceof Line && isBoundary(crossingItem);\n+                || crossingItem instanceof Line && isBoundary(crossingItem))\n+        {\n+            return true;\n+        }\n+\n+        // Each intersection between the Edge & waterbody should have a Node in the atlas\n+        if (!(crossingItem instanceof Edge)\n+                || !this.intersectionsAreExplicit(waterbody, (Edge) crossingItem))\n+        {\n+            return false;\n+        }\n+\n+        // All intersections between the street and waterbody\n+        final Set<Location> intersections = waterbody instanceof Polygon\n+                ? ((Polygon) waterbody).intersections(((Edge) crossingItem).asPolyLine())\n+                : ((MultiPolygon) waterbody).outers().stream()\n+                        .flatMap(polygon -> polygon\n+                                .intersections(((Edge) crossingItem).asPolyLine()).stream())\n+                        .collect(Collectors.toSet());\n+        final Predicate<AtlasItem> hasFordTag = item -> !item.getTag(FordTag.KEY)", "originalCommit": "446221903b118ea099b5ef514c5d2232ef96de54", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE2MTgxNw==", "url": "https://github.com/osmlab/atlas-checks/pull/287#discussion_r423161817", "bodyText": "This could be updated to now check for\n\nsynthetic nearest neighbor tag\nmissing iso tag", "author": "danielduhh", "createdAt": "2020-05-11T16:24:11Z", "path": "src/test/java/org/openstreetmap/atlas/checks/validation/intersections/LineCrossingWaterBodyCheckTestRule.java", "diffHunk": "@@ -461,7 +461,8 @@\n             @Node(coordinates = @Loc(value = AREA_LOCATION_3)),\n             @Node(coordinates = @Loc(value = LOCATION_OUTSIDE_AREA_1)),\n             @Node(coordinates = @Loc(value = AREA_LOCATION_BETWEEN_2_AND_3)) }, areas = {\n-                    @Area(id = \"100\", coordinates = { @Loc(AREA_LOCATION_1), @Loc(AREA_LOCATION_2),\n+                    @Area(id = \"100\", tags = \"last_edit_time=20200422\", coordinates = {", "originalCommit": "446221903b118ea099b5ef514c5d2232ef96de54", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE2MjIxNg==", "url": "https://github.com/osmlab/atlas-checks/pull/287#discussion_r423162216", "bodyText": "\ud83e\udd2f", "author": "danielduhh", "createdAt": "2020-05-11T16:24:49Z", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/LineCrossingWaterBodyCheck.java", "diffHunk": "@@ -329,29 +368,63 @@ private boolean intersectionsAreExplicit(final GeometricSurface waterbody,\n                 .haveExplicitLocationsForIntersections(polygon, lineItem));\n     }\n \n+    /**\n+     * If the waterbody is an area, the intersection is valid. If it's not an area, it's a\n+     * multipolygon, and we make sure that either 1. The intersection is at an outer member of the\n+     * multipolygon and the outer member was not synthetically created by the atlas slicing process.\n+     * It's estimated that if the outer member doesn't have the {@link LastEditTimeTag}, it likely\n+     * did not come from an OSM feature, which suggests it was created due to atlas slicing and\n+     * would therefore not be a geometrically accurate member of the relation. 2. The intersecting\n+     * feature is entirely floating in an outer member of the relation, and not\n+     * intersecting/floating in any of the inner members. The inner members are typically islands so\n+     * we avoid flagging in the latter scenario. The outer member must still have the LastEditTime\n+     * tag\n+     *\n+     * @param waterbody\n+     *            the GeometricSurface representation of the waterbody\n+     * @param object\n+     *            the AtlasEntity representation of the waterbody\n+     * @param intersectingFeature\n+     *            the intersecting building/road/line\n+     * @return true if either of the 2 above conditions are satisfied, false otherwise\n+     */\n+    private boolean intersectsValidPartOfWaterbody(final GeometricSurface waterbody,\n+            final AtlasObject object, final PolyLine intersectingFeature)\n+    {\n+        return !(waterbody instanceof MultiPolygon) || ((Relation) object).members().stream()", "originalCommit": "446221903b118ea099b5ef514c5d2232ef96de54", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE2MjQwNA==", "url": "https://github.com/osmlab/atlas-checks/pull/287#discussion_r423162404", "bodyText": "I will leave this up to you but this is a bit hard to follow \ud83d\ude04", "author": "danielduhh", "createdAt": "2020-05-11T16:25:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE2MjIxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM3MTU2OA==", "url": "https://github.com/osmlab/atlas-checks/pull/287#discussion_r423371568", "bodyText": "Added some comments and some clarification in the method docstring.. ec536cc#diff-829f2e37322d264fb3b26e180abc731eR380", "author": "seancoulter", "createdAt": "2020-05-11T23:13:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE2MjIxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM3Mzc5Mw==", "url": "https://github.com/osmlab/atlas-checks/pull/287#discussion_r423373793", "bodyText": "Awesome! Thanks for the updates", "author": "danielduhh", "createdAt": "2020-05-11T23:20:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE2MjIxNg=="}], "type": "inlineReview"}, {"oid": "ec536cc2f39f151ad87b4e767e0316fa5ba4818f", "url": "https://github.com/osmlab/atlas-checks/commit/ec536cc2f39f151ad87b4e767e0316fa5ba4818f", "message": "address comments, unit tests, small fixes", "committedDate": "2020-05-11T23:12:03Z", "type": "commit"}, {"oid": "ae54e77f93ff4f88a3db07dea74c203acc16350e", "url": "https://github.com/osmlab/atlas-checks/commit/ae54e77f93ff4f88a3db07dea74c203acc16350e", "message": "add non offending nodes configurable", "committedDate": "2020-05-12T02:40:37Z", "type": "commit"}, {"oid": "741baa0c3cacd3b885710c9508c714c7e67c26df", "url": "https://github.com/osmlab/atlas-checks/commit/741baa0c3cacd3b885710c9508c714c7e67c26df", "message": "Merge branch 'dev' into lcwbBorderRelationFix", "committedDate": "2020-05-12T16:45:59Z", "type": "commit"}, {"oid": "fe1d98f18b630b3394e93b3194bea6a823dacbcc", "url": "https://github.com/osmlab/atlas-checks/commit/fe1d98f18b630b3394e93b3194bea6a823dacbcc", "message": "bump test coverage", "committedDate": "2020-05-13T02:38:43Z", "type": "commit"}, {"oid": "5b1c9b86181c6db585b998ffa6a8aeeb24eadd45", "url": "https://github.com/osmlab/atlas-checks/commit/5b1c9b86181c6db585b998ffa6a8aeeb24eadd45", "message": "Merge branch 'lcwbBorderRelationFix' of https://github.com/seancoulter/atlas-checks into lcwbBorderRelationFix", "committedDate": "2020-05-13T02:38:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDU0NTc3OQ==", "url": "https://github.com/osmlab/atlas-checks/pull/287#discussion_r424545779", "bodyText": "I think the use of SyntheticNearestNeighborCountryCodeTag in country slicing has been removed by osmlab/atlas#627.", "author": "Bentleysb", "createdAt": "2020-05-13T15:50:47Z", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/LineCrossingWaterBodyCheck.java", "diffHunk": "@@ -329,29 +380,72 @@ private boolean intersectionsAreExplicit(final GeometricSurface waterbody,\n                 .haveExplicitLocationsForIntersections(polygon, lineItem));\n     }\n \n+    /**\n+     * If the waterbody is an area, the intersection is flaggable. If it's not an area, it's a\n+     * multipolygon, and we make sure that either 1. The intersection is at an outer member of the\n+     * multipolygon and the outer member was not synthetically created by the atlas slicing process.\n+     * It's estimated that if the outer member only has the {@link ISOCountryTag} and\n+     * {@link SyntheticNearestNeighborCountryCodeTag}, it was created due to atlas slicing and would\n+     * therefore not be a geometrically accurate member of the relation. 2. The intersecting feature\n+     * is entirely floating in an outer member of the relation, and not intersecting/floating in any\n+     * of the inner members. The inner members are typically islands so we avoid flagging in the\n+     * latter scenario. The outer member must still have only the 2 tags mentioned above\n+     *\n+     * @param waterbody\n+     *            the GeometricSurface representation of the waterbody\n+     * @param object\n+     *            the AtlasEntity representation of the waterbody\n+     * @param intersectingFeature\n+     *            the intersecting building/road/line\n+     * @return true if either of the 2 above conditions are satisfied, false otherwise\n+     */\n+    private boolean intersectsValidPartOfWaterbody(final GeometricSurface waterbody,\n+            final AtlasObject object, final PolyLine intersectingFeature)\n+    {\n+        // The waterbody is not an area, or...\n+        return !(waterbody instanceof MultiPolygon)\n+                // Map all outer multipolygon members to a tuple of its AtlasEntity and the entity's\n+                // geometric Polygon, and check for appropriate intersection/containment/tagging\n+                || ((Relation) object).members().stream()\n+                        .flatMap(member -> member.getEntity() instanceof Relation\n+                                ? ((Relation) member.getEntity()).members().stream()\n+                                : Stream.of(member))\n+                        .filter(member -> member.getRole().equals(\"outer\"))\n+                        .map(member -> new Tuple<>(member.getEntity(),\n+                                new Polygon(member.getEntity() instanceof Area\n+                                        ? (Area) member.getEntity()\n+                                        : (LineItem) member.getEntity())))\n+                        .anyMatch(member -> (intersectingFeature.intersects(member.getSecond())\n+                                || (intersectingFeature.within(member.getSecond())\n+                                        && ((MultiPolygon) waterbody).inners().stream()\n+                                                .noneMatch(innerMember -> intersectingFeature\n+                                                        .intersects(innerMember)\n+                                                        || intersectingFeature\n+                                                                .within(innerMember))))\n+                                && (member.getFirst().getTags().keySet().stream().anyMatch(\n+                                        key -> !(key.equals(ISOCountryTag.KEY) || key.equals(\n+                                                SyntheticNearestNeighborCountryCodeTag.KEY)))));", "originalCommit": "5b1c9b86181c6db585b998ffa6a8aeeb24eadd45", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDczODI0OQ==", "url": "https://github.com/osmlab/atlas-checks/pull/287#discussion_r424738249", "bodyText": "Good catch. Taking that out so we now only check if the feature has a tag other than the IsoCountryTag", "author": "seancoulter", "createdAt": "2020-05-13T21:21:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDU0NTc3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc0MTczOQ==", "url": "https://github.com/osmlab/atlas-checks/pull/287#discussion_r424741739", "bodyText": "According to https://github.com/osmlab/atlas/blob/f9ebfa344fb5891e3a21a2e790ea3f153230d4ec/src/main/java/org/openstreetmap/atlas/geography/atlas/raw/slicing/RawAtlasSlicer.java#L442, synthetically added relation members at borders would only have the IsoCountryTag tag. So checking for any tag other than that is looking like a good/straightforward estimation for whether or not the feature was synthetically created, especially considering that features not synthetically created would have OSM tags as well.", "author": "seancoulter", "createdAt": "2020-05-13T21:28:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDU0NTc3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc0MjE3Mg==", "url": "https://github.com/osmlab/atlas-checks/pull/287#discussion_r424742172", "bodyText": "nice! thanks for looking into it", "author": "danielduhh", "createdAt": "2020-05-13T21:29:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDU0NTc3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc0Mjc0Mw==", "url": "https://github.com/osmlab/atlas-checks/pull/287#discussion_r424742743", "bodyText": "So to clarify.. if the feature only contains a iso country code, we can assume it was synthetically added.", "author": "danielduhh", "createdAt": "2020-05-13T21:30:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDU0NTc3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc0NDY4OQ==", "url": "https://github.com/osmlab/atlas-checks/pull/287#discussion_r424744689", "bodyText": "as far as multipolygon relation members go, that's the idea.", "author": "seancoulter", "createdAt": "2020-05-13T21:35:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDU0NTc3OQ=="}], "type": "inlineReview"}, {"oid": "bdf234e039673b465e4d6366c2f8d8583019ef96", "url": "https://github.com/osmlab/atlas-checks/commit/bdf234e039673b465e4d6366c2f8d8583019ef96", "message": "add docs and take out nearest neighbor", "committedDate": "2020-05-13T21:32:31Z", "type": "commit"}]}