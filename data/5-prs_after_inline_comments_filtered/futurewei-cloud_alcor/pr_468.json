{"pr_number": 468, "pr_title": "[Fundamental] Sub-level programming through Subnet and Route Mgr", "pr_createdAt": "2020-11-10T02:59:50Z", "pr_url": "https://github.com/futurewei-cloud/alcor/pull/468", "timeline": [{"oid": "24b9b76ae349f277ac55f1cc11e81636d1569b6d", "url": "https://github.com/futurewei-cloud/alcor/commit/24b9b76ae349f277ac55f1cc11e81636d1569b6d", "message": "commit message", "committedDate": "2020-10-07T21:49:22Z", "type": "commit"}, {"oid": "08ec421662ef56559a388e6c7308aa47cfd07a6b", "url": "https://github.com/futurewei-cloud/alcor/commit/08ec421662ef56559a388e6c7308aa47cfd07a6b", "message": "Merge branch 'master' of https://github.com/futurewei-cloud/alcor into new_master", "committedDate": "2020-10-07T22:00:25Z", "type": "commit"}, {"oid": "2507b8fc44a4ca94da310b73c11453cec9f2504b", "url": "https://github.com/futurewei-cloud/alcor/commit/2507b8fc44a4ca94da310b73c11453cec9f2504b", "message": "Merge branch 'master' of https://github.com/futurewei-cloud/alcor into new_master", "committedDate": "2020-10-15T17:12:49Z", "type": "commit"}, {"oid": "8cab6bfa9573926c29b9f8dbbeab732a9de1da7e", "url": "https://github.com/futurewei-cloud/alcor/commit/8cab6bfa9573926c29b9f8dbbeab732a9de1da7e", "message": "Merge branch 'master' of https://github.com/futurewei-cloud/alcor into new_master", "committedDate": "2020-10-15T23:33:06Z", "type": "commit"}, {"oid": "d9d2a5822429286e2b01ce0842f16cb70dc5168f", "url": "https://github.com/futurewei-cloud/alcor/commit/d9d2a5822429286e2b01ce0842f16cb70dc5168f", "message": "Merge branch 'master' of https://github.com/futurewei-cloud/alcor into new_master", "committedDate": "2020-10-16T16:57:50Z", "type": "commit"}, {"oid": "daba98ee8949b91b2b77f74c6fbb30529355ee51", "url": "https://github.com/futurewei-cloud/alcor/commit/daba98ee8949b91b2b77f74c6fbb30529355ee51", "message": "Merge branch 'master' of https://github.com/futurewei-cloud/alcor into new_master", "committedDate": "2020-10-20T00:03:13Z", "type": "commit"}, {"oid": "b813735c5032b70928a2304007875824f5ccedca", "url": "https://github.com/futurewei-cloud/alcor/commit/b813735c5032b70928a2304007875824f5ccedca", "message": "Merge branch 'master' of https://github.com/futurewei-cloud/alcor into new_master", "committedDate": "2020-10-22T17:43:05Z", "type": "commit"}, {"oid": "fd9a9847b0f42c5a7fd089ea09fa6f24233d008e", "url": "https://github.com/futurewei-cloud/alcor/commit/fd9a9847b0f42c5a7fd089ea09fa6f24233d008e", "message": "Merge branch 'master' of https://github.com/futurewei-cloud/alcor into new_master", "committedDate": "2020-10-28T19:40:54Z", "type": "commit"}, {"oid": "e44875aa2fa685b2252647f413c704dce7a21611", "url": "https://github.com/futurewei-cloud/alcor/commit/e44875aa2fa685b2252647f413c704dce7a21611", "message": "Merge branch 'master' of https://github.com/futurewei-cloud/alcor into new_master", "committedDate": "2020-10-29T18:42:59Z", "type": "commit"}, {"oid": "98dcf0dbb1c950ee71a0d663a7042cbce30d24ed", "url": "https://github.com/futurewei-cloud/alcor/commit/98dcf0dbb1c950ee71a0d663a7042cbce30d24ed", "message": "Merge branch 'master' of https://github.com/futurewei-cloud/alcor into new_master", "committedDate": "2020-10-30T22:44:46Z", "type": "commit"}, {"oid": "a9c3a47d74ba5fffbe13746ee4e33af0fbb394fe", "url": "https://github.com/futurewei-cloud/alcor/commit/a9c3a47d74ba5fffbe13746ee4e33af0fbb394fe", "message": "Merge branch 'master' of https://github.com/futurewei-cloud/alcor into new_master", "committedDate": "2020-11-03T23:40:18Z", "type": "commit"}, {"oid": "f058bd1edef55af8ab0e25cb7b043fa6c04c272f", "url": "https://github.com/futurewei-cloud/alcor/commit/f058bd1edef55af8ab0e25cb7b043fa6c04c272f", "message": "Merge branch 'master' of https://github.com/futurewei-cloud/alcor into new_master", "committedDate": "2020-11-05T07:42:35Z", "type": "commit"}, {"oid": "08d4a6f7da0d94caef77156cbb27fa05965eff9a", "url": "https://github.com/futurewei-cloud/alcor/commit/08d4a6f7da0d94caef77156cbb27fa05965eff9a", "message": "Merge branch 'master' of https://github.com/futurewei-cloud/alcor into new_master", "committedDate": "2020-11-05T19:07:01Z", "type": "commit"}, {"oid": "0e8fa34440bb90f63e2558da60638aab65a3be1b", "url": "https://github.com/futurewei-cloud/alcor/commit/0e8fa34440bb90f63e2558da60638aab65a3be1b", "message": "update", "committedDate": "2020-11-10T02:57:54Z", "type": "commit"}, {"oid": "6e787b5782cb5a0c96ad2e0629169a3e329cbdd6", "url": "https://github.com/futurewei-cloud/alcor/commit/6e787b5782cb5a0c96ad2e0629169a3e329cbdd6", "message": "update", "committedDate": "2020-11-10T04:40:00Z", "type": "commit"}, {"oid": "15ff2f515b904f4fe387f37c5ca0589e7f5899a4", "url": "https://github.com/futurewei-cloud/alcor/commit/15ff2f515b904f4fe387f37c5ca0589e7f5899a4", "message": "update", "committedDate": "2020-11-12T00:34:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjIxNzQ4OQ==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r522217489", "bodyText": "The api for creating subnet route table for Neutron should be like this:\n/project/{projectid}/subnets/{subnetid}/routetable\n\nPlease refer to https://github.com/futurewei-cloud/alcor/blob/master/docs/modules/ROOT/pages/mgmt_services/route_manager.adoc#subnet_add_neutron_routetable", "author": "cj-chung", "createdAt": "2020-11-12T15:59:02Z", "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/controller/RouterController.java", "diffHunk": "@@ -293,6 +293,43 @@ public RouteTableWebJson getOrCreateSubnetRouteTable(@PathVariable String projec\n         return new RouteTableWebJson(routeTable);\n     }\n \n+    /**\n+     * Create neutron subnet routeTable\n+     * @param projectid\n+     * @param subnetid\n+     * @param resource\n+     * @return\n+     * @throws Exception\n+     */\n+    @RequestMapping(\n+            method = POST,\n+            value = {\"/project/{projectid}/subnets/{subnetid}/neutron-routetable\"})", "originalCommit": "15ff2f515b904f4fe387f37c5ca0589e7f5899a4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUxNDkyNg==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r522514926", "bodyText": "Sure", "author": "kevin-zhonghao", "createdAt": "2020-11-12T23:53:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjIxNzQ4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjIyNDI4OQ==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r522224289", "bodyText": "Should we consider to make updateRoutingRule more general so that both Neutron and VPC scenarios can utilize this internal function?", "author": "cj-chung", "createdAt": "2020-11-12T16:07:47Z", "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/controller/NeutronRouterController.java", "diffHunk": "@@ -354,6 +359,11 @@ public RoutesToNeutronWebResponse removeRoutesToNeutronRouter(@PathVariable Stri\n \n         RoutesToNeutronWebResponse routesToNeutronWebResponse = this.neutronRouterService.removeRoutesToNeutronRouter(routerid, router);\n \n+        // sub-level routing rule update\n+        InternalRouterInfo internalRouterInfo = this.neutronRouterService.updateRoutingRule(routerid, null, router);\n+", "originalCommit": "15ff2f515b904f4fe387f37c5ca0589e7f5899a4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUxNTQwMA==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r522515400", "bodyText": "Already revise updateRoutingRule method and it will be more general now", "author": "kevin-zhonghao", "createdAt": "2020-11-12T23:54:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjIyNDI4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjIzNTIzNQ==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r522235235", "bodyText": "We need to call updateRoutingRule from here or from createNeutronSubnetRouteTable to send InternalRouterInfo to DPM or PM.", "author": "cj-chung", "createdAt": "2020-11-12T16:21:42Z", "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/controller/RouterController.java", "diffHunk": "@@ -293,6 +293,43 @@ public RouteTableWebJson getOrCreateSubnetRouteTable(@PathVariable String projec\n         return new RouteTableWebJson(routeTable);\n     }\n \n+    /**\n+     * Create neutron subnet routeTable\n+     * @param projectid\n+     * @param subnetid\n+     * @param resource\n+     * @return\n+     * @throws Exception\n+     */\n+    @RequestMapping(\n+            method = POST,\n+            value = {\"/project/{projectid}/subnets/{subnetid}/neutron-routetable\"})\n+    @DurationStatistics\n+    public RouteTableWebJson createNeutronSubnetRouteTable(@PathVariable String projectid, @PathVariable String subnetid, @RequestBody RouteTableWebJson resource) throws Exception {\n+\n+        RouteTable routeTable = null;\n+\n+        try {\n+            RestPreconditionsUtil.verifyParameterNotNullorEmpty(subnetid);\n+            RestPreconditionsUtil.verifyParameterNotNullorEmpty(projectid);\n+            RestPreconditionsUtil.verifyResourceFound(projectid);\n+\n+            // check resource\n+            if (!RouteManagerUtil.checkCreateNeutronSubnetRouteTableWebJsonResourceIsValid(resource)) {\n+                throw new ResourceNotValidException(\"request resource is invalid\");\n+            }\n+\n+            routeTable = this.routerService.createNeutronSubnetRouteTable(projectid, subnetid, resource);\n+", "originalCommit": "15ff2f515b904f4fe387f37c5ca0589e7f5899a4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUxNjA2OA==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r522516068", "bodyText": "Sure", "author": "kevin-zhonghao", "createdAt": "2020-11-12T23:56:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjIzNTIzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjIzODg5Mg==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r522238892", "bodyText": "After this, we should call updateRoutingRule", "author": "cj-chung", "createdAt": "2020-11-12T16:26:25Z", "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/service/Impl/RouterServiceImpl.java", "diffHunk": "@@ -314,5 +314,30 @@ public String deleteSubnetRouteTable(String projectId, String subnetId) throws E\n         return routeTableId;\n     }\n \n+    @Override\n+    public RouteTable createNeutronSubnetRouteTable(String projectId, String subnetId, RouteTableWebJson resource) throws DatabasePersistenceException {\n+\n+        // configure a new route table\n+        RouteTable routeTable = new RouteTable();\n+        String id = UUID.randomUUID().toString();\n+        routeTable.setId(id);\n+        routeTable.setDescription(\"\");\n+        routeTable.setName(\"subnet-\" + id + \"-routetable\");\n+        routeTable.setProjectId(projectId);\n+        routeTable.setRouteTableType(RouteTableType.NEUTRON_SUBNET.getRouteTableType());\n+        routeTable.setOwner(subnetId);\n+\n+        routeTable.setRouteEntities(new ArrayList<RouteEntry>());\n+\n+\n+        RouteTable inRoutetable = resource.getRoutetable();\n+\n+        RouteManagerUtil.copyPropertiesIgnoreNull(inRoutetable, routeTable);\n+        this.routeTableDatabaseService.addRouteTable(routeTable);\n+", "originalCommit": "15ff2f515b904f4fe387f37c5ca0589e7f5899a4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUyMjgyNA==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r522522824", "bodyText": "Already do this in the RouterController", "author": "kevin-zhonghao", "createdAt": "2020-11-13T00:17:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjIzODg5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjI0NjE2NA==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r522246164", "bodyText": "wrong URL. It should be /project/{projectid}/subnets/{subnetid}/routetable", "author": "cj-chung", "createdAt": "2020-11-12T16:35:49Z", "path": "services/subnet_manager/src/main/java/com/futurewei/alcor/subnet/service/implement/SubnetServiceImp.java", "diffHunk": "@@ -421,4 +426,175 @@ public boolean checkIfCidrOverlap(String cidr,String projectId, String vpcId) th\n \n         return false;\n     }\n+\n+    @Override\n+    public void updateSubnetHostRoutes(String subnetId, InternalRouterInfo resource) throws ResourceNotFoundException, ResourcePersistenceException, DatabasePersistenceException {\n+\n+        // get internal routing rule\n+        InternalRouterConfiguration configuration = resource.getRouterConfiguration();\n+        if (configuration == null) {\n+            return;\n+        }\n+\n+        List<InternalSubnetRoutingTable> subnetRoutingTables = configuration.getSubnetRoutingTables();\n+        if (subnetRoutingTables == null) {\n+            return;\n+        }\n+\n+        List<InternalRoutingRule> routingRules = null;\n+        for (InternalSubnetRoutingTable internalSubnetRoutingTable : subnetRoutingTables) {\n+            String internalSubnetId = internalSubnetRoutingTable.getSubnetId();\n+            List<InternalRoutingRule> internalRoutingRules = internalSubnetRoutingTable.getRoutingRules();\n+            if (subnetId.equals(internalSubnetId)) {\n+                routingRules = internalRoutingRules;\n+                break;\n+            }\n+        }\n+\n+        // get List<HostRoute> in subnet entity\n+        SubnetEntity subnetEntity = this.subnetDatabaseService.getBySubnetId(subnetId);\n+        if (subnetEntity == null) {\n+            return;\n+        }\n+        List<HostRoute> hostRoutes = subnetEntity.getHostRoutes();\n+\n+        if (hostRoutes == null || routingRules == null) {\n+            return;\n+        }\n+\n+        // update subnet routes\n+        for (InternalRoutingRule internalRoutingRule : routingRules) {\n+            String operationType = internalRoutingRule.getOperationType().getOperationType();\n+            String destination = internalRoutingRule.getDestination();\n+            String nextHopIp = internalRoutingRule.getNextHopIp();\n+            if (destination == null || operationType == null) {\n+                continue;\n+            }\n+\n+            if (operationType.equals(OperationType.CREATE.getOperationType())) {\n+\n+                HostRoute newHostRoute = new HostRoute(destination, nextHopIp);\n+                hostRoutes.add(newHostRoute);\n+\n+            } else if (operationType.equals(OperationType.UPDATE.getOperationType())) {\n+\n+                for (int i = 0 ; i < hostRoutes.size(); i ++) {\n+                    HostRoute hostRoute = hostRoutes.get(i);\n+                    String subnetDestination = hostRoute.getDestination();\n+                    if (subnetDestination == null) {\n+                        continue;\n+                    }\n+\n+                    if (subnetDestination.equals(destination)) {\n+                        hostRoute.setDestination(destination);\n+                        hostRoute.setNexthop(nextHopIp);\n+                    }\n+                }\n+\n+            } else if (operationType.equals(OperationType.DELETE.getOperationType())) {\n+\n+                Iterator<HostRoute> iterator = hostRoutes.iterator();\n+                while (iterator.hasNext()) {\n+                    HostRoute hostRoute = iterator.next();\n+                    String subnetDestination = hostRoute.getDestination();\n+                    if (subnetDestination == null) {\n+                        continue;\n+                    }\n+\n+                    if (subnetDestination.equals(destination)) {\n+                        iterator.remove();\n+                    }\n+                }\n+\n+            }\n+\n+        }\n+\n+        subnetEntity.setHostRoutes(hostRoutes);\n+        this.subnetDatabaseService.addSubnet(subnetEntity);\n+\n+    }\n+\n+\n+    @Override\n+    public void deleteSubnetRoutingRuleInRM(String projectId, String subnetId) throws SubnetIdIsNull {\n+\n+        if (subnetId == null) {\n+            throw new SubnetIdIsNull();\n+        }\n+\n+        String routeManagerServiceUrl = routeUrl + \"project/\" + projectId + \"/subnets/\" + subnetId + \"/routetable\";\n+        restTemplate.delete(routeManagerServiceUrl, ResponseId.class);\n+\n+    }\n+\n+    @Override\n+    public void updateSubnetRoutingRuleInRM(String projectId, String subnetId, SubnetEntity subnetEntity) throws SubnetIdIsNull {\n+\n+        if (subnetId == null) {\n+            throw new SubnetIdIsNull();\n+        }\n+\n+        if (subnetEntity == null) {\n+            return;\n+        }\n+        List<HostRoute> hostRoutes = subnetEntity.getHostRoutes();\n+        List<RouteEntry> routeEntities = new ArrayList<>();\n+        for (HostRoute hostRoute : hostRoutes) {\n+            String destination = hostRoute.getDestination();\n+            String nexthop = hostRoute.getNexthop();\n+            RouteEntry routeEntry = new RouteEntry(null, null, null, null,\n+                    destination, null, null, null, nexthop);\n+            routeEntities.add(routeEntry);\n+        }\n+\n+        RouteTable routetable = new RouteTable();\n+        routetable.setOwner(subnetId);\n+        routetable.setRouteTableType(RouteTableType.NEUTRON_SUBNET.getRouteTableType());\n+        routetable.setRouteEntities(routeEntities);\n+\n+\n+        String routeManagerServiceUrl = routeUrl + \"project/\" + projectId + \"/subnets/\" + subnetId + \"/routetable\";\n+        HttpEntity<RouteTableWebJson> routeRequest = new HttpEntity<>(new RouteTableWebJson(routetable));\n+        restTemplate.put(routeManagerServiceUrl, routeRequest, RouteTableWebJson.class);\n+\n+    }\n+\n+    @Override\n+    public void createSubnetRoutingRuleInRM(String projectId, String subnetId, SubnetEntity subnetEntity) throws SubnetIdIsNull {\n+\n+        if (subnetId == null) {\n+            throw new SubnetIdIsNull();\n+        }\n+\n+        if (subnetEntity == null) {\n+            return;\n+        }\n+        List<HostRoute> hostRoutes = subnetEntity.getHostRoutes();\n+        List<RouteEntry> routeEntities = new ArrayList<>();\n+        for (HostRoute hostRoute : hostRoutes) {\n+            String destination = hostRoute.getDestination();\n+            String nexthop = hostRoute.getNexthop();\n+            RouteEntry routeEntry = new RouteEntry(null, null, null, null,\n+                    destination, null, null, null, nexthop);\n+            routeEntities.add(routeEntry);\n+        }\n+\n+        RouteTable routetable = new RouteTable();\n+        routetable.setOwner(subnetId);\n+        routetable.setRouteTableType(RouteTableType.NEUTRON_SUBNET.getRouteTableType());\n+        routetable.setRouteEntities(routeEntities);\n+\n+        String routeManagerServiceUrl = routeUrl + \"project/\" + projectId + \"/subnets/\" + subnetId + \"/neutron-routetable\";", "originalCommit": "15ff2f515b904f4fe387f37c5ca0589e7f5899a4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUyMzIxMA==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r522523210", "bodyText": "Fixed it", "author": "kevin-zhonghao", "createdAt": "2020-11-13T00:19:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjI0NjE2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjI1MDY0MA==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r522250640", "bodyText": "deleteSubnetRoutingRuleInRM, updateSubnetRoutingRuleInRM, and createSubnetRoutingRuleInRM three functions are doing pretty similar task, should we consider to consolidate them into one function?", "author": "cj-chung", "createdAt": "2020-11-12T16:42:17Z", "path": "services/subnet_manager/src/main/java/com/futurewei/alcor/subnet/service/implement/SubnetServiceImp.java", "diffHunk": "@@ -421,4 +426,175 @@ public boolean checkIfCidrOverlap(String cidr,String projectId, String vpcId) th\n \n         return false;\n     }\n+\n+    @Override\n+    public void updateSubnetHostRoutes(String subnetId, InternalRouterInfo resource) throws ResourceNotFoundException, ResourcePersistenceException, DatabasePersistenceException {\n+\n+        // get internal routing rule\n+        InternalRouterConfiguration configuration = resource.getRouterConfiguration();\n+        if (configuration == null) {\n+            return;\n+        }\n+\n+        List<InternalSubnetRoutingTable> subnetRoutingTables = configuration.getSubnetRoutingTables();\n+        if (subnetRoutingTables == null) {\n+            return;\n+        }\n+\n+        List<InternalRoutingRule> routingRules = null;\n+        for (InternalSubnetRoutingTable internalSubnetRoutingTable : subnetRoutingTables) {\n+            String internalSubnetId = internalSubnetRoutingTable.getSubnetId();\n+            List<InternalRoutingRule> internalRoutingRules = internalSubnetRoutingTable.getRoutingRules();\n+            if (subnetId.equals(internalSubnetId)) {\n+                routingRules = internalRoutingRules;\n+                break;\n+            }\n+        }\n+\n+        // get List<HostRoute> in subnet entity\n+        SubnetEntity subnetEntity = this.subnetDatabaseService.getBySubnetId(subnetId);\n+        if (subnetEntity == null) {\n+            return;\n+        }\n+        List<HostRoute> hostRoutes = subnetEntity.getHostRoutes();\n+\n+        if (hostRoutes == null || routingRules == null) {\n+            return;\n+        }\n+\n+        // update subnet routes\n+        for (InternalRoutingRule internalRoutingRule : routingRules) {\n+            String operationType = internalRoutingRule.getOperationType().getOperationType();\n+            String destination = internalRoutingRule.getDestination();\n+            String nextHopIp = internalRoutingRule.getNextHopIp();\n+            if (destination == null || operationType == null) {\n+                continue;\n+            }\n+\n+            if (operationType.equals(OperationType.CREATE.getOperationType())) {\n+\n+                HostRoute newHostRoute = new HostRoute(destination, nextHopIp);\n+                hostRoutes.add(newHostRoute);\n+\n+            } else if (operationType.equals(OperationType.UPDATE.getOperationType())) {\n+\n+                for (int i = 0 ; i < hostRoutes.size(); i ++) {\n+                    HostRoute hostRoute = hostRoutes.get(i);\n+                    String subnetDestination = hostRoute.getDestination();\n+                    if (subnetDestination == null) {\n+                        continue;\n+                    }\n+\n+                    if (subnetDestination.equals(destination)) {\n+                        hostRoute.setDestination(destination);\n+                        hostRoute.setNexthop(nextHopIp);\n+                    }\n+                }\n+\n+            } else if (operationType.equals(OperationType.DELETE.getOperationType())) {\n+\n+                Iterator<HostRoute> iterator = hostRoutes.iterator();\n+                while (iterator.hasNext()) {\n+                    HostRoute hostRoute = iterator.next();\n+                    String subnetDestination = hostRoute.getDestination();\n+                    if (subnetDestination == null) {\n+                        continue;\n+                    }\n+\n+                    if (subnetDestination.equals(destination)) {\n+                        iterator.remove();\n+                    }\n+                }\n+\n+            }\n+\n+        }\n+\n+        subnetEntity.setHostRoutes(hostRoutes);\n+        this.subnetDatabaseService.addSubnet(subnetEntity);\n+\n+    }\n+\n+\n+    @Override\n+    public void deleteSubnetRoutingRuleInRM(String projectId, String subnetId) throws SubnetIdIsNull {\n+\n+        if (subnetId == null) {\n+            throw new SubnetIdIsNull();\n+        }\n+\n+        String routeManagerServiceUrl = routeUrl + \"project/\" + projectId + \"/subnets/\" + subnetId + \"/routetable\";\n+        restTemplate.delete(routeManagerServiceUrl, ResponseId.class);\n+\n+    }\n+\n+    @Override\n+    public void updateSubnetRoutingRuleInRM(String projectId, String subnetId, SubnetEntity subnetEntity) throws SubnetIdIsNull {", "originalCommit": "15ff2f515b904f4fe387f37c5ca0589e7f5899a4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUyNDQxNA==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r522524414", "bodyText": "Actually they should call different rest API and the same thing is to construct RouteTable in updateSubnetRoutingRuleInRM, createSubnetRoutingRuleInRM. We could put this process in one method, but I think sperate these three method is okay. What do you think?", "author": "kevin-zhonghao", "createdAt": "2020-11-13T00:22:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjI1MDY0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjI2OTczMQ==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r522269731", "bodyText": "Should we catch exception here instead of just return nothing when the subnet is not exist?", "author": "cj-chung", "createdAt": "2020-11-12T17:08:04Z", "path": "services/subnet_manager/src/main/java/com/futurewei/alcor/subnet/service/implement/SubnetServiceImp.java", "diffHunk": "@@ -421,4 +426,175 @@ public boolean checkIfCidrOverlap(String cidr,String projectId, String vpcId) th\n \n         return false;\n     }\n+\n+    @Override\n+    public void updateSubnetHostRoutes(String subnetId, InternalRouterInfo resource) throws ResourceNotFoundException, ResourcePersistenceException, DatabasePersistenceException {\n+\n+        // get internal routing rule\n+        InternalRouterConfiguration configuration = resource.getRouterConfiguration();\n+        if (configuration == null) {\n+            return;\n+        }\n+\n+        List<InternalSubnetRoutingTable> subnetRoutingTables = configuration.getSubnetRoutingTables();\n+        if (subnetRoutingTables == null) {\n+            return;\n+        }\n+\n+        List<InternalRoutingRule> routingRules = null;\n+        for (InternalSubnetRoutingTable internalSubnetRoutingTable : subnetRoutingTables) {\n+            String internalSubnetId = internalSubnetRoutingTable.getSubnetId();\n+            List<InternalRoutingRule> internalRoutingRules = internalSubnetRoutingTable.getRoutingRules();\n+            if (subnetId.equals(internalSubnetId)) {\n+                routingRules = internalRoutingRules;\n+                break;\n+            }\n+        }\n+\n+        // get List<HostRoute> in subnet entity\n+        SubnetEntity subnetEntity = this.subnetDatabaseService.getBySubnetId(subnetId);\n+        if (subnetEntity == null) {\n+            return;\n+        }", "originalCommit": "15ff2f515b904f4fe387f37c5ca0589e7f5899a4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU0Nzk1NA==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r522547954", "bodyText": "Added it", "author": "kevin-zhonghao", "createdAt": "2020-11-13T01:17:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjI2OTczMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjI3MTYyMA==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r522271620", "bodyText": "If hostRoutes == null, we should replace hostRoutes with routingRules, right?", "author": "cj-chung", "createdAt": "2020-11-12T17:10:44Z", "path": "services/subnet_manager/src/main/java/com/futurewei/alcor/subnet/service/implement/SubnetServiceImp.java", "diffHunk": "@@ -421,4 +426,175 @@ public boolean checkIfCidrOverlap(String cidr,String projectId, String vpcId) th\n \n         return false;\n     }\n+\n+    @Override\n+    public void updateSubnetHostRoutes(String subnetId, InternalRouterInfo resource) throws ResourceNotFoundException, ResourcePersistenceException, DatabasePersistenceException {\n+\n+        // get internal routing rule\n+        InternalRouterConfiguration configuration = resource.getRouterConfiguration();\n+        if (configuration == null) {\n+            return;\n+        }\n+\n+        List<InternalSubnetRoutingTable> subnetRoutingTables = configuration.getSubnetRoutingTables();\n+        if (subnetRoutingTables == null) {\n+            return;\n+        }\n+\n+        List<InternalRoutingRule> routingRules = null;\n+        for (InternalSubnetRoutingTable internalSubnetRoutingTable : subnetRoutingTables) {\n+            String internalSubnetId = internalSubnetRoutingTable.getSubnetId();\n+            List<InternalRoutingRule> internalRoutingRules = internalSubnetRoutingTable.getRoutingRules();\n+            if (subnetId.equals(internalSubnetId)) {\n+                routingRules = internalRoutingRules;\n+                break;\n+            }\n+        }\n+\n+        // get List<HostRoute> in subnet entity\n+        SubnetEntity subnetEntity = this.subnetDatabaseService.getBySubnetId(subnetId);\n+        if (subnetEntity == null) {\n+            return;\n+        }\n+        List<HostRoute> hostRoutes = subnetEntity.getHostRoutes();\n+\n+        if (hostRoutes == null || routingRules == null) {\n+            return;", "originalCommit": "15ff2f515b904f4fe387f37c5ca0589e7f5899a4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU0OTAwNQ==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r522549005", "bodyText": "Yeah you are right, I changed logic here", "author": "kevin-zhonghao", "createdAt": "2020-11-13T01:20:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjI3MTYyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjI3MzU0OQ==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r522273549", "bodyText": "It's not allow destination or operationType equal to null in the InternalRouterInfo. Should we catch this exception instead of just continue?", "author": "cj-chung", "createdAt": "2020-11-12T17:13:30Z", "path": "services/subnet_manager/src/main/java/com/futurewei/alcor/subnet/service/implement/SubnetServiceImp.java", "diffHunk": "@@ -421,4 +426,175 @@ public boolean checkIfCidrOverlap(String cidr,String projectId, String vpcId) th\n \n         return false;\n     }\n+\n+    @Override\n+    public void updateSubnetHostRoutes(String subnetId, InternalRouterInfo resource) throws ResourceNotFoundException, ResourcePersistenceException, DatabasePersistenceException {\n+\n+        // get internal routing rule\n+        InternalRouterConfiguration configuration = resource.getRouterConfiguration();\n+        if (configuration == null) {\n+            return;\n+        }\n+\n+        List<InternalSubnetRoutingTable> subnetRoutingTables = configuration.getSubnetRoutingTables();\n+        if (subnetRoutingTables == null) {\n+            return;\n+        }\n+\n+        List<InternalRoutingRule> routingRules = null;\n+        for (InternalSubnetRoutingTable internalSubnetRoutingTable : subnetRoutingTables) {\n+            String internalSubnetId = internalSubnetRoutingTable.getSubnetId();\n+            List<InternalRoutingRule> internalRoutingRules = internalSubnetRoutingTable.getRoutingRules();\n+            if (subnetId.equals(internalSubnetId)) {\n+                routingRules = internalRoutingRules;\n+                break;\n+            }\n+        }\n+\n+        // get List<HostRoute> in subnet entity\n+        SubnetEntity subnetEntity = this.subnetDatabaseService.getBySubnetId(subnetId);\n+        if (subnetEntity == null) {\n+            return;\n+        }\n+        List<HostRoute> hostRoutes = subnetEntity.getHostRoutes();\n+\n+        if (hostRoutes == null || routingRules == null) {\n+            return;\n+        }\n+\n+        // update subnet routes\n+        for (InternalRoutingRule internalRoutingRule : routingRules) {\n+            String operationType = internalRoutingRule.getOperationType().getOperationType();\n+            String destination = internalRoutingRule.getDestination();\n+            String nextHopIp = internalRoutingRule.getNextHopIp();\n+            if (destination == null || operationType == null) {\n+                continue;\n+            }", "originalCommit": "15ff2f515b904f4fe387f37c5ca0589e7f5899a4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU0OTE2Mw==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r522549163", "bodyText": "NP", "author": "kevin-zhonghao", "createdAt": "2020-11-13T01:21:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjI3MzU0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjI5MDQ2NQ==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r522290465", "bodyText": "Again, it not allow subnetDestination = null.", "author": "cj-chung", "createdAt": "2020-11-12T17:36:15Z", "path": "services/subnet_manager/src/main/java/com/futurewei/alcor/subnet/service/implement/SubnetServiceImp.java", "diffHunk": "@@ -421,4 +426,175 @@ public boolean checkIfCidrOverlap(String cidr,String projectId, String vpcId) th\n \n         return false;\n     }\n+\n+    @Override\n+    public void updateSubnetHostRoutes(String subnetId, InternalRouterInfo resource) throws ResourceNotFoundException, ResourcePersistenceException, DatabasePersistenceException {\n+\n+        // get internal routing rule\n+        InternalRouterConfiguration configuration = resource.getRouterConfiguration();\n+        if (configuration == null) {\n+            return;\n+        }\n+\n+        List<InternalSubnetRoutingTable> subnetRoutingTables = configuration.getSubnetRoutingTables();\n+        if (subnetRoutingTables == null) {\n+            return;\n+        }\n+\n+        List<InternalRoutingRule> routingRules = null;\n+        for (InternalSubnetRoutingTable internalSubnetRoutingTable : subnetRoutingTables) {\n+            String internalSubnetId = internalSubnetRoutingTable.getSubnetId();\n+            List<InternalRoutingRule> internalRoutingRules = internalSubnetRoutingTable.getRoutingRules();\n+            if (subnetId.equals(internalSubnetId)) {\n+                routingRules = internalRoutingRules;\n+                break;\n+            }\n+        }\n+\n+        // get List<HostRoute> in subnet entity\n+        SubnetEntity subnetEntity = this.subnetDatabaseService.getBySubnetId(subnetId);\n+        if (subnetEntity == null) {\n+            return;\n+        }\n+        List<HostRoute> hostRoutes = subnetEntity.getHostRoutes();\n+\n+        if (hostRoutes == null || routingRules == null) {\n+            return;\n+        }\n+\n+        // update subnet routes\n+        for (InternalRoutingRule internalRoutingRule : routingRules) {\n+            String operationType = internalRoutingRule.getOperationType().getOperationType();\n+            String destination = internalRoutingRule.getDestination();\n+            String nextHopIp = internalRoutingRule.getNextHopIp();\n+            if (destination == null || operationType == null) {\n+                continue;\n+            }\n+\n+            if (operationType.equals(OperationType.CREATE.getOperationType())) {\n+\n+                HostRoute newHostRoute = new HostRoute(destination, nextHopIp);\n+                hostRoutes.add(newHostRoute);\n+\n+            } else if (operationType.equals(OperationType.UPDATE.getOperationType())) {\n+\n+                for (int i = 0 ; i < hostRoutes.size(); i ++) {\n+                    HostRoute hostRoute = hostRoutes.get(i);\n+                    String subnetDestination = hostRoute.getDestination();\n+                    if (subnetDestination == null) {\n+                        continue;\n+                    }", "originalCommit": "15ff2f515b904f4fe387f37c5ca0589e7f5899a4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU1MDIxMw==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r522550213", "bodyText": "Sure", "author": "kevin-zhonghao", "createdAt": "2020-11-13T01:24:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjI5MDQ2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjI5MTEwMA==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r522291100", "bodyText": "Do you think it costs too much to iterate all routes for each UPDATE route?", "author": "cj-chung", "createdAt": "2020-11-12T17:37:06Z", "path": "services/subnet_manager/src/main/java/com/futurewei/alcor/subnet/service/implement/SubnetServiceImp.java", "diffHunk": "@@ -421,4 +426,175 @@ public boolean checkIfCidrOverlap(String cidr,String projectId, String vpcId) th\n \n         return false;\n     }\n+\n+    @Override\n+    public void updateSubnetHostRoutes(String subnetId, InternalRouterInfo resource) throws ResourceNotFoundException, ResourcePersistenceException, DatabasePersistenceException {\n+\n+        // get internal routing rule\n+        InternalRouterConfiguration configuration = resource.getRouterConfiguration();\n+        if (configuration == null) {\n+            return;\n+        }\n+\n+        List<InternalSubnetRoutingTable> subnetRoutingTables = configuration.getSubnetRoutingTables();\n+        if (subnetRoutingTables == null) {\n+            return;\n+        }\n+\n+        List<InternalRoutingRule> routingRules = null;\n+        for (InternalSubnetRoutingTable internalSubnetRoutingTable : subnetRoutingTables) {\n+            String internalSubnetId = internalSubnetRoutingTable.getSubnetId();\n+            List<InternalRoutingRule> internalRoutingRules = internalSubnetRoutingTable.getRoutingRules();\n+            if (subnetId.equals(internalSubnetId)) {\n+                routingRules = internalRoutingRules;\n+                break;\n+            }\n+        }\n+\n+        // get List<HostRoute> in subnet entity\n+        SubnetEntity subnetEntity = this.subnetDatabaseService.getBySubnetId(subnetId);\n+        if (subnetEntity == null) {\n+            return;\n+        }\n+        List<HostRoute> hostRoutes = subnetEntity.getHostRoutes();\n+\n+        if (hostRoutes == null || routingRules == null) {\n+            return;\n+        }\n+\n+        // update subnet routes\n+        for (InternalRoutingRule internalRoutingRule : routingRules) {\n+            String operationType = internalRoutingRule.getOperationType().getOperationType();\n+            String destination = internalRoutingRule.getDestination();\n+            String nextHopIp = internalRoutingRule.getNextHopIp();\n+            if (destination == null || operationType == null) {\n+                continue;\n+            }\n+\n+            if (operationType.equals(OperationType.CREATE.getOperationType())) {\n+\n+                HostRoute newHostRoute = new HostRoute(destination, nextHopIp);\n+                hostRoutes.add(newHostRoute);\n+\n+            } else if (operationType.equals(OperationType.UPDATE.getOperationType())) {\n+\n+                for (int i = 0 ; i < hostRoutes.size(); i ++) {\n+                    HostRoute hostRoute = hostRoutes.get(i);\n+                    String subnetDestination = hostRoute.getDestination();", "originalCommit": "15ff2f515b904f4fe387f37c5ca0589e7f5899a4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU1MDk1Mw==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r522550953", "bodyText": "HostRoute dont have its own repo, so I think we could do in this way, I think subnet dont have many hostRoutes, right?", "author": "kevin-zhonghao", "createdAt": "2020-11-13T01:27:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjI5MTEwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjI5MzA4NA==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r522293084", "bodyText": "same comment above, can we lookup hostRoute by destination?", "author": "cj-chung", "createdAt": "2020-11-12T17:39:40Z", "path": "services/subnet_manager/src/main/java/com/futurewei/alcor/subnet/service/implement/SubnetServiceImp.java", "diffHunk": "@@ -421,4 +426,175 @@ public boolean checkIfCidrOverlap(String cidr,String projectId, String vpcId) th\n \n         return false;\n     }\n+\n+    @Override\n+    public void updateSubnetHostRoutes(String subnetId, InternalRouterInfo resource) throws ResourceNotFoundException, ResourcePersistenceException, DatabasePersistenceException {\n+\n+        // get internal routing rule\n+        InternalRouterConfiguration configuration = resource.getRouterConfiguration();\n+        if (configuration == null) {\n+            return;\n+        }\n+\n+        List<InternalSubnetRoutingTable> subnetRoutingTables = configuration.getSubnetRoutingTables();\n+        if (subnetRoutingTables == null) {\n+            return;\n+        }\n+\n+        List<InternalRoutingRule> routingRules = null;\n+        for (InternalSubnetRoutingTable internalSubnetRoutingTable : subnetRoutingTables) {\n+            String internalSubnetId = internalSubnetRoutingTable.getSubnetId();\n+            List<InternalRoutingRule> internalRoutingRules = internalSubnetRoutingTable.getRoutingRules();\n+            if (subnetId.equals(internalSubnetId)) {\n+                routingRules = internalRoutingRules;\n+                break;\n+            }\n+        }\n+\n+        // get List<HostRoute> in subnet entity\n+        SubnetEntity subnetEntity = this.subnetDatabaseService.getBySubnetId(subnetId);\n+        if (subnetEntity == null) {\n+            return;\n+        }\n+        List<HostRoute> hostRoutes = subnetEntity.getHostRoutes();\n+\n+        if (hostRoutes == null || routingRules == null) {\n+            return;\n+        }\n+\n+        // update subnet routes\n+        for (InternalRoutingRule internalRoutingRule : routingRules) {\n+            String operationType = internalRoutingRule.getOperationType().getOperationType();\n+            String destination = internalRoutingRule.getDestination();\n+            String nextHopIp = internalRoutingRule.getNextHopIp();\n+            if (destination == null || operationType == null) {\n+                continue;\n+            }\n+\n+            if (operationType.equals(OperationType.CREATE.getOperationType())) {\n+\n+                HostRoute newHostRoute = new HostRoute(destination, nextHopIp);\n+                hostRoutes.add(newHostRoute);\n+\n+            } else if (operationType.equals(OperationType.UPDATE.getOperationType())) {\n+\n+                for (int i = 0 ; i < hostRoutes.size(); i ++) {\n+                    HostRoute hostRoute = hostRoutes.get(i);\n+                    String subnetDestination = hostRoute.getDestination();\n+                    if (subnetDestination == null) {\n+                        continue;\n+                    }\n+\n+                    if (subnetDestination.equals(destination)) {\n+                        hostRoute.setDestination(destination);\n+                        hostRoute.setNexthop(nextHopIp);\n+                    }\n+                }\n+\n+            } else if (operationType.equals(OperationType.DELETE.getOperationType())) {\n+\n+                Iterator<HostRoute> iterator = hostRoutes.iterator();\n+                while (iterator.hasNext()) {\n+                    HostRoute hostRoute = iterator.next();\n+                    String subnetDestination = hostRoute.getDestination();\n+                    if (subnetDestination == null) {\n+                        continue;\n+                    }", "originalCommit": "15ff2f515b904f4fe387f37c5ca0589e7f5899a4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU1MTEwMw==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r522551103", "bodyText": "the response above", "author": "kevin-zhonghao", "createdAt": "2020-11-13T01:27:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjI5MzA4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQwNTI5NA==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r522405294", "bodyText": "Chane RoutesToNeutronRouterRequestObject routerObject to a more generic routes object like we discuss before.", "author": "cj-chung", "createdAt": "2020-11-12T20:28:00Z", "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/service/Impl/NeutronRouterServiceImpl.java", "diffHunk": "@@ -469,6 +466,151 @@ public ConnectedSubnetsWebResponse getConnectedSubnets(String projectId, String\n         return connectedSubnetsWebResponse;\n     }\n \n+    @Override\n+    public InternalRouterInfo updateRoutingRule (String routerId, String subnetId, RoutesToNeutronRouterRequestObject routerObject) throws ResourceNotFoundException, ResourcePersistenceException, RouterUnavailable, RouterTableNotExist, DestinationOrNexthopCanNotBeNull, OwnerInNeutronRouteTableNotFound {\n+        List<InternalRoutingRule> updateRoutes = new ArrayList<>();\n+", "originalCommit": "15ff2f515b904f4fe387f37c5ca0589e7f5899a4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU1MTE1NA==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r522551154", "bodyText": "Sure", "author": "kevin-zhonghao", "createdAt": "2020-11-13T01:27:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQwNTI5NA=="}], "type": "inlineReview"}, {"oid": "170c425f6152484e8015dab461a450c6e7f5db6f", "url": "https://github.com/futurewei-cloud/alcor/commit/170c425f6152484e8015dab461a450c6e7f5db6f", "message": "update", "committedDate": "2020-11-13T01:27:28Z", "type": "commit"}, {"oid": "57bb5930b947375d72f7804a64e0a7408bfc6406", "url": "https://github.com/futurewei-cloud/alcor/commit/57bb5930b947375d72f7804a64e0a7408bfc6406", "message": "update", "committedDate": "2020-11-13T03:19:27Z", "type": "commit"}, {"oid": "17cfb3185e93d7dfce981f09e4fbc64bc7dce58b", "url": "https://github.com/futurewei-cloud/alcor/commit/17cfb3185e93d7dfce981f09e4fbc64bc7dce58b", "message": "update", "committedDate": "2020-11-18T22:45:23Z", "type": "commit"}, {"oid": "dbe2f9f98f08cee0a8c39135453dfeaf1ab64455", "url": "https://github.com/futurewei-cloud/alcor/commit/dbe2f9f98f08cee0a8c39135453dfeaf1ab64455", "message": "update", "committedDate": "2020-11-18T22:50:26Z", "type": "commit"}, {"oid": "ef0b4fe4b03ddcc00904f1d603d020648846c34f", "url": "https://github.com/futurewei-cloud/alcor/commit/ef0b4fe4b03ddcc00904f1d603d020648846c34f", "message": "Merge branch 'master' of https://github.com/futurewei-cloud/alcor into new_master", "committedDate": "2020-11-18T22:54:01Z", "type": "commit"}, {"oid": "7aa69738c481986153ba9819cf94adfac414e383", "url": "https://github.com/futurewei-cloud/alcor/commit/7aa69738c481986153ba9819cf94adfac414e383", "message": "Merge branch 'new_master' into feature/sub_level_programming\n\n# Conflicts:\n#\tservices/data_plane_manager/src/main/java/com/futurewei/alcor/dataplane/service/ovs/DataPlaneServiceImplNew.java", "committedDate": "2020-11-18T22:56:21Z", "type": "commit"}, {"oid": "6052d2e731930d4eb49cdf4734059abc878cf9b1", "url": "https://github.com/futurewei-cloud/alcor/commit/6052d2e731930d4eb49cdf4734059abc878cf9b1", "message": "update", "committedDate": "2020-11-18T23:03:23Z", "type": "commit"}, {"oid": "f5a703fb67a649151029feda61773b0f335f8ebc", "url": "https://github.com/futurewei-cloud/alcor/commit/f5a703fb67a649151029feda61773b0f335f8ebc", "message": "update", "committedDate": "2020-11-18T23:33:43Z", "type": "commit"}, {"oid": "e602e2914d54aeb8e388c39a082881428698bf20", "url": "https://github.com/futurewei-cloud/alcor/commit/e602e2914d54aeb8e388c39a082881428698bf20", "message": "update", "committedDate": "2020-11-19T21:46:18Z", "type": "commit"}, {"oid": "590eea3dbe93fe7da2c87f6056035a502a445a33", "url": "https://github.com/futurewei-cloud/alcor/commit/590eea3dbe93fe7da2c87f6056035a502a445a33", "message": "update", "committedDate": "2020-11-25T17:33:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQwOTMyNg==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r522409326", "bodyText": "I think we don't need this part if we use routetable id or owner id to search for the routetable.", "author": "cj-chung", "createdAt": "2020-11-12T20:34:11Z", "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/service/Impl/NeutronRouterServiceImpl.java", "diffHunk": "@@ -469,6 +466,151 @@ public ConnectedSubnetsWebResponse getConnectedSubnets(String projectId, String\n         return connectedSubnetsWebResponse;\n     }\n \n+    @Override\n+    public InternalRouterInfo updateRoutingRule (String routerId, String subnetId, RoutesToNeutronRouterRequestObject routerObject) throws ResourceNotFoundException, ResourcePersistenceException, RouterUnavailable, RouterTableNotExist, DestinationOrNexthopCanNotBeNull, OwnerInNeutronRouteTableNotFound {\n+        List<InternalRoutingRule> updateRoutes = new ArrayList<>();\n+\n+        List<RoutesToNeutronRouteObject> routes = routerObject.getRoutes();\n+        if (routes == null || routes.size() == 0) {\n+            return new InternalRouterInfo();\n+        }\n+\n+        Router router = this.routerDatabaseService.getByRouterId(routerId);\n+        if (router == null) {\n+            throw new RouterUnavailable(routerId);\n+        }\n+\n+        // find neutron routeTable\n+        RouteTable neutronRouteTable = null;\n+        if (subnetId == null) {\n+            // call from RM (RM path)\n+            neutronRouteTable = router.getNeutronRouteTable();\n+            if (neutronRouteTable == null) {\n+                throw new RouterTableNotExist();\n+            }\n+        } else {\n+            // call from SM (SM path)\n+            List<RouteTable> neutronSubnetRouteTables = router.getNeutronSubnetRouteTables();\n+            for (RouteTable neutronSubnetRouteTable : neutronSubnetRouteTables) {\n+                String owner = neutronSubnetRouteTable.getOwner();\n+                if (owner == null) {\n+                    throw new OwnerInNeutronRouteTableNotFound();\n+                }\n+                if (owner.equals(subnetId)) {\n+                    neutronRouteTable = neutronSubnetRouteTable;\n+                    break;\n+                }\n+            }\n+            if (neutronRouteTable == null) {\n+                throw new RouterTableNotExist();\n+            }\n+        }", "originalCommit": "15ff2f515b904f4fe387f37c5ca0589e7f5899a4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc2Nzg2Mw==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r532767863", "bodyText": "Yes, but the above class is outdated. I have a update in the last NeutronRouterServiceImpl", "author": "kevin-zhonghao", "createdAt": "2020-11-30T17:23:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQwOTMyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYwNDIzMA==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r530604230", "bodyText": "The variable router here is a bit of confusion, it means routes right?", "author": "cj-chung", "createdAt": "2020-11-25T19:39:08Z", "path": "web/src/main/java/com/futurewei/alcor/web/entity/route/RoutesToNeutronWebRequest.java", "diffHunk": "@@ -20,11 +20,11 @@\n @Data\n public class RoutesToNeutronWebRequest {\n \n-    private RoutesToNeutronRouterRequestObject router;\n+    private NewRoutesWebRequest router;", "originalCommit": "590eea3dbe93fe7da2c87f6056035a502a445a33", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc2ODI4Nw==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r532768287", "bodyText": "Yes, I could change it to routes", "author": "kevin-zhonghao", "createdAt": "2020-11-30T17:24:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYwNDIzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc3MDM4Nw==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r532770387", "bodyText": "newRoutesWebRequest", "author": "kevin-zhonghao", "createdAt": "2020-11-30T17:27:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYwNDIzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYwNzU3Mw==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r530607573", "bodyText": "Did we change ports field name in Router entity to gateway_ports?\nIf we did, router.getPorts() may be get trouble.", "author": "cj-chung", "createdAt": "2020-11-25T19:46:15Z", "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/controller/NeutronRouterController.java", "diffHunk": "@@ -324,12 +329,30 @@ public RoutesToNeutronWebResponse addRoutesToNeutronRouter(@PathVariable String\n         RestPreconditionsUtil.verifyParameterNotNullorEmpty(routerid);\n         RestPreconditionsUtil.verifyResourceFound(projectid);\n \n-        RoutesToNeutronRouterRequestObject router = resource.getRouter();\n-        if (router == null) {\n+        NewRoutesWebRequest newRoutes = resource.getRouter();\n+        if (newRoutes == null) {\n             return new RoutesToNeutronWebResponse();\n         }\n \n-        RoutesToNeutronWebResponse routesToNeutronWebResponse = this.neutronRouterService.addRoutesToNeutronRouter(routerid, router);\n+        // List<String> ports -> port entity -> subnet id\n+        Router router = this.routerDatabaseService.getByRouterId(routerid);\n+\n+        RoutesToNeutronWebResponse routesToNeutronWebResponse = this.neutronRouterService.addRoutesToNeutronRouter(routerid, newRoutes);\n+\n+        List<String> gatewayPorts = router.getPorts();", "originalCommit": "590eea3dbe93fe7da2c87f6056035a502a445a33", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc3Nzc4MA==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r532777780", "bodyText": "I just changed the Json name to gateway_ports, let me fix", "author": "kevin-zhonghao", "createdAt": "2020-11-30T17:38:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYwNzU3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYxNTkyMg==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r530615922", "bodyText": "It should have only one InternalSubnetRoutingTable, not a List.", "author": "cj-chung", "createdAt": "2020-11-25T20:04:11Z", "path": "web/src/main/java/com/futurewei/alcor/web/entity/route/UpdateRoutingRuleResponse.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+Copyright 2019 The Alcor Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+        you may not use this file except in compliance with the License.\n+        You may obtain a copy of the License at\n+\n+        http://www.apache.org/licenses/LICENSE-2.0\n+\n+        Unless required by applicable law or agreed to in writing, software\n+        distributed under the License is distributed on an \"AS IS\" BASIS,\n+        WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+        See the License for the specific language governing permissions and\n+        limitations under the License.\n+*/\n+package com.futurewei.alcor.web.entity.route;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.futurewei.alcor.web.entity.subnet.HostRoute;\n+import lombok.Data;\n+\n+import java.util.List;\n+\n+@Data\n+public class UpdateRoutingRuleResponse {\n+\n+    @JsonProperty(\"internalRouterInfo\")\n+    private List<InternalSubnetRoutingTable> internalSubnetRoutingTables;\n+", "originalCommit": "590eea3dbe93fe7da2c87f6056035a502a445a33", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc5MDg0MA==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r532790840", "bodyText": "Sure", "author": "kevin-zhonghao", "createdAt": "2020-11-30T17:57:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYxNTkyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYxNzE4Mw==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r530617183", "bodyText": "this.neutronRouterService.updateRoutingRule(subnetId, newRoutes, true) is only process one subnet, so it should only return a single InternalSubnetRoutingTable inside of UpdateRoutingRuleResponse.", "author": "cj-chung", "createdAt": "2020-11-25T20:06:51Z", "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/controller/NeutronRouterController.java", "diffHunk": "@@ -324,12 +329,30 @@ public RoutesToNeutronWebResponse addRoutesToNeutronRouter(@PathVariable String\n         RestPreconditionsUtil.verifyParameterNotNullorEmpty(routerid);\n         RestPreconditionsUtil.verifyResourceFound(projectid);\n \n-        RoutesToNeutronRouterRequestObject router = resource.getRouter();\n-        if (router == null) {\n+        NewRoutesWebRequest newRoutes = resource.getRouter();\n+        if (newRoutes == null) {\n             return new RoutesToNeutronWebResponse();\n         }\n \n-        RoutesToNeutronWebResponse routesToNeutronWebResponse = this.neutronRouterService.addRoutesToNeutronRouter(routerid, router);\n+        // List<String> ports -> port entity -> subnet id\n+        Router router = this.routerDatabaseService.getByRouterId(routerid);\n+\n+        RoutesToNeutronWebResponse routesToNeutronWebResponse = this.neutronRouterService.addRoutesToNeutronRouter(routerid, newRoutes);\n+\n+        List<String> gatewayPorts = router.getPorts();\n+        List<String> subnetIds = this.routerToPMService.getSubnetIdsFromPM(projectid, gatewayPorts);\n+        // sub-level routing rule update\n+        List<InternalSubnetRoutingTable> internalSubnetRoutingTableList = new ArrayList<>();\n+        for (String subnetId : subnetIds) {\n+            UpdateRoutingRuleResponse updateRoutingRuleResponse = this.neutronRouterService.updateRoutingRule(subnetId, newRoutes, true);\n+            List<InternalSubnetRoutingTable> internalSubnetRoutingTables = updateRoutingRuleResponse.getInternalSubnetRoutingTables();", "originalCommit": "590eea3dbe93fe7da2c87f6056035a502a445a33", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgwMzUwNQ==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r532803505", "bodyText": "But as talked about it before, we also needed to update HostRoute in SubnetEntity, so we put them together in UpdateRoutingRuleResponse", "author": "kevin-zhonghao", "createdAt": "2020-11-30T18:18:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYxNzE4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYyMzE0Nw==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r530623147", "bodyText": "We don't need todo for L3-neighbors here, you can remove it.", "author": "cj-chung", "createdAt": "2020-11-25T20:20:06Z", "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/controller/NeutronRouterController.java", "diffHunk": "@@ -324,12 +329,30 @@ public RoutesToNeutronWebResponse addRoutesToNeutronRouter(@PathVariable String\n         RestPreconditionsUtil.verifyParameterNotNullorEmpty(routerid);\n         RestPreconditionsUtil.verifyResourceFound(projectid);\n \n-        RoutesToNeutronRouterRequestObject router = resource.getRouter();\n-        if (router == null) {\n+        NewRoutesWebRequest newRoutes = resource.getRouter();\n+        if (newRoutes == null) {\n             return new RoutesToNeutronWebResponse();\n         }\n \n-        RoutesToNeutronWebResponse routesToNeutronWebResponse = this.neutronRouterService.addRoutesToNeutronRouter(routerid, router);\n+        // List<String> ports -> port entity -> subnet id\n+        Router router = this.routerDatabaseService.getByRouterId(routerid);\n+\n+        RoutesToNeutronWebResponse routesToNeutronWebResponse = this.neutronRouterService.addRoutesToNeutronRouter(routerid, newRoutes);\n+\n+        List<String> gatewayPorts = router.getPorts();\n+        List<String> subnetIds = this.routerToPMService.getSubnetIdsFromPM(projectid, gatewayPorts);\n+        // sub-level routing rule update\n+        List<InternalSubnetRoutingTable> internalSubnetRoutingTableList = new ArrayList<>();\n+        for (String subnetId : subnetIds) {\n+            UpdateRoutingRuleResponse updateRoutingRuleResponse = this.neutronRouterService.updateRoutingRule(subnetId, newRoutes, true);\n+            List<InternalSubnetRoutingTable> internalSubnetRoutingTables = updateRoutingRuleResponse.getInternalSubnetRoutingTables();\n+            internalSubnetRoutingTableList.addAll(internalSubnetRoutingTables);\n+        }\n+\n+        InternalRouterInfo internalRouterInfo = this.neutronRouterService.constructInternalRouterInfo(internalSubnetRoutingTableList);\n+\n+        // send InternalRouterInfo contract to DPM\n+        this.routerToDPMService.sendInternalRouterInfoToDPM(internalRouterInfo);\n \n         // TODO:  l3-neighbors-updating (waiting for PM)", "originalCommit": "590eea3dbe93fe7da2c87f6056035a502a445a33", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgwNDEyNg==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r532804126", "bodyText": "NP", "author": "kevin-zhonghao", "createdAt": "2020-11-30T18:19:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYyMzE0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYyMzYzMg==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r530623632", "bodyText": "same comment as in the addRoutesToNeutronRouter", "author": "cj-chung", "createdAt": "2020-11-25T20:21:11Z", "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/controller/NeutronRouterController.java", "diffHunk": "@@ -347,12 +370,29 @@ public RoutesToNeutronWebResponse removeRoutesToNeutronRouter(@PathVariable Stri\n         RestPreconditionsUtil.verifyParameterNotNullorEmpty(routerid);\n         RestPreconditionsUtil.verifyResourceFound(projectid);\n \n-        RoutesToNeutronRouterRequestObject router = resource.getRouter();\n-        if (router == null) {\n+        NewRoutesWebRequest newRoutes = resource.getRouter();\n+        if (newRoutes == null) {\n             return new RoutesToNeutronWebResponse();\n         }\n+        // List<String> ports -> port entity -> subnet id\n+        Router router = this.routerDatabaseService.getByRouterId(routerid);\n+\n+        RoutesToNeutronWebResponse routesToNeutronWebResponse = this.neutronRouterService.removeRoutesToNeutronRouter(routerid, newRoutes);\n+\n+        List<String> gatewayPorts = router.getPorts();\n+        List<String> subnetIds = this.routerToPMService.getSubnetIdsFromPM(projectid, gatewayPorts);\n+        // sub-level routing rule update\n+        List<InternalSubnetRoutingTable> internalSubnetRoutingTableList = new ArrayList<>();\n+        for (String subnetId : subnetIds) {\n+            UpdateRoutingRuleResponse updateRoutingRuleResponse = this.neutronRouterService.updateRoutingRule(subnetId, newRoutes, true);\n+            List<InternalSubnetRoutingTable> internalSubnetRoutingTables = updateRoutingRuleResponse.getInternalSubnetRoutingTables();\n+            internalSubnetRoutingTableList.addAll(internalSubnetRoutingTables);", "originalCommit": "590eea3dbe93fe7da2c87f6056035a502a445a33", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgwNDUyOQ==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r532804529", "bodyText": "fixed it", "author": "kevin-zhonghao", "createdAt": "2020-11-30T18:20:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYyMzYzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYyNTMyNw==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r530625327", "bodyText": "How do we convert these priority strings to integer?", "author": "cj-chung", "createdAt": "2020-11-25T20:24:26Z", "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/config/ConstantsConfig.java", "diffHunk": "@@ -20,4 +20,11 @@\n     public static String FORMAT_VERSION = \"1\";\n     public static String REVISION_NUMBER = \"1\";\n     public static String HOST_DVR_MAC = \"fe:16:11:00:00:00\";\n+    public static String DEFAULT_ROUTINGRULETYPE = \"default\";\n+    public static String STATIC_ROUTINGRULETYPE = \"static\";\n+    public static String DPMFailedHandleRequest = \"Failed Handle request !!\";\n+    public static String LOW_PRIORITY = \"low_priority\";\n+    public static String MEDIUM_PRIORITY = \"medium_priority\";\n+    public static String HIGH_PRIORITY = \"high_priority\";", "originalCommit": "590eea3dbe93fe7da2c87f6056035a502a445a33", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgxMzYzNQ==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r532813635", "bodyText": "our priority field is :\n@JsonProperty(\"priority\")\nprivate String priority;\nSo it is fine we set these values first, what do you think", "author": "kevin-zhonghao", "createdAt": "2020-11-30T18:35:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYyNTMyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY0NzE1OQ==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r530647159", "bodyText": "For VPC, it should be target instead of nexthop.", "author": "cj-chung", "createdAt": "2020-11-25T21:17:55Z", "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/controller/RouterController.java", "diffHunk": "@@ -189,6 +198,39 @@ public RouteTableWebJson updateVpcRouteTable(@PathVariable String projectid, @Pa\n \n             routetable = this.routerService.updateVpcRouteTable(projectid, vpcid, resource);\n \n+            RouteTable newRoutetable = resource.getRoutetable();\n+            List<RouteEntry> routeEntities = newRoutetable.getRouteEntities();\n+            if (routeEntities == null) {\n+                return new RouteTableWebJson(routetable);\n+            }\n+            NewRoutesWebRequest newRouteEntry = new NewRoutesWebRequest();\n+            List<NewRoutesRequest> routes = new ArrayList<>();\n+            for (RouteEntry routeEntry : routeEntities) {\n+                NewRoutesRequest newRoutesRequest = new NewRoutesRequest();\n+                newRoutesRequest.setDestination(routeEntry.getDestination());\n+                newRoutesRequest.setNexthop(routeEntry.getNexthop());\n+                routes.add(newRoutesRequest);", "originalCommit": "590eea3dbe93fe7da2c87f6056035a502a445a33", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgxNzQwMg==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r532817402", "bodyText": "newRoutesRequest.setNexthop(routeEntry.getTarget()) , right?", "author": "kevin-zhonghao", "createdAt": "2020-11-30T18:41:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY0NzE1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY1MzA2MQ==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r530653061", "bodyText": "Not quite understand why you need to iterate each input route and convert it into newRouteEntry?", "author": "cj-chung", "createdAt": "2020-11-25T21:33:10Z", "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/controller/RouterController.java", "diffHunk": "@@ -189,6 +198,39 @@ public RouteTableWebJson updateVpcRouteTable(@PathVariable String projectid, @Pa\n \n             routetable = this.routerService.updateVpcRouteTable(projectid, vpcid, resource);\n \n+            RouteTable newRoutetable = resource.getRoutetable();\n+            List<RouteEntry> routeEntities = newRoutetable.getRouteEntities();\n+            if (routeEntities == null) {\n+                return new RouteTableWebJson(routetable);\n+            }\n+            NewRoutesWebRequest newRouteEntry = new NewRoutesWebRequest();\n+            List<NewRoutesRequest> routes = new ArrayList<>();\n+            for (RouteEntry routeEntry : routeEntities) {\n+                NewRoutesRequest newRoutesRequest = new NewRoutesRequest();\n+                newRoutesRequest.setDestination(routeEntry.getDestination());\n+                newRoutesRequest.setNexthop(routeEntry.getNexthop());\n+                routes.add(newRoutesRequest);\n+            }\n+            newRouteEntry.setRoutes(routes);\n+", "originalCommit": "590eea3dbe93fe7da2c87f6056035a502a445a33", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgxNzk0MQ==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r532817941", "bodyText": "Because updateRoutingRule method need NewRoutesWebRequest param", "author": "kevin-zhonghao", "createdAt": "2020-11-30T18:42:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY1MzA2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY1NDQ4NQ==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r530654485", "bodyText": "So, we use this.neutronRouterService.updateRoutingRule for both Neutron and VPC scenarios?\nIt should only return one single InternalSubnetRoutingTable.", "author": "cj-chung", "createdAt": "2020-11-25T21:36:55Z", "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/controller/RouterController.java", "diffHunk": "@@ -189,6 +198,39 @@ public RouteTableWebJson updateVpcRouteTable(@PathVariable String projectid, @Pa\n \n             routetable = this.routerService.updateVpcRouteTable(projectid, vpcid, resource);\n \n+            RouteTable newRoutetable = resource.getRoutetable();\n+            List<RouteEntry> routeEntities = newRoutetable.getRouteEntities();\n+            if (routeEntities == null) {\n+                return new RouteTableWebJson(routetable);\n+            }\n+            NewRoutesWebRequest newRouteEntry = new NewRoutesWebRequest();\n+            List<NewRoutesRequest> routes = new ArrayList<>();\n+            for (RouteEntry routeEntry : routeEntities) {\n+                NewRoutesRequest newRoutesRequest = new NewRoutesRequest();\n+                newRoutesRequest.setDestination(routeEntry.getDestination());\n+                newRoutesRequest.setNexthop(routeEntry.getNexthop());\n+                routes.add(newRoutesRequest);\n+            }\n+            newRouteEntry.setRoutes(routes);\n+\n+            // find subnets related to this vpc (getVpcRouteTables)\n+            Router router = this.routerService.getOrCreateVpcRouter(projectid, vpcid);\n+            List<RouteTable> vpcRouteTables = router.getVpcRouteTables();\n+\n+            // sub-level routing rule update\n+            List<InternalSubnetRoutingTable> internalSubnetRoutingTableList = new ArrayList<>();\n+            for (RouteTable routeTable : vpcRouteTables) {\n+                String subnetId = routeTable.getOwner();\n+                UpdateRoutingRuleResponse updateRoutingRuleResponse = this.neutronRouterService.updateRoutingRule(subnetId, newRouteEntry, true);\n+                List<InternalSubnetRoutingTable> internalSubnetRoutingTables = updateRoutingRuleResponse.getInternalSubnetRoutingTables();", "originalCommit": "590eea3dbe93fe7da2c87f6056035a502a445a33", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgxODA4Mg==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r532818082", "bodyText": "Fixed", "author": "kevin-zhonghao", "createdAt": "2020-11-30T18:43:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY1NDQ4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY1NzM5OQ==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r530657399", "bodyText": "this.neutronRouterService.updateRoutingRule should only return one single InternalSubnetRoutingTable.", "author": "cj-chung", "createdAt": "2020-11-25T21:44:40Z", "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/controller/RouterController.java", "diffHunk": "@@ -293,6 +335,69 @@ public RouteTableWebJson getOrCreateSubnetRouteTable(@PathVariable String projec\n         return new RouteTableWebJson(routeTable);\n     }\n \n+    /**\n+     * Create neutron subnet routeTable\n+     * @param projectid\n+     * @param subnetid\n+     * @param resource\n+     * @return\n+     * @throws Exception\n+     */\n+    @RequestMapping(\n+            method = POST,\n+            value = {\"/project/{projectid}/subnets/{subnetid}/routetable\"})\n+    @DurationStatistics\n+    public RouteTableWebJson createNeutronSubnetRouteTable(@PathVariable String projectid, @PathVariable String subnetid, @RequestBody RouteTableWebJson resource) throws Exception {\n+\n+        RouteTable routeTable = null;\n+\n+        try {\n+            RestPreconditionsUtil.verifyParameterNotNullorEmpty(subnetid);\n+            RestPreconditionsUtil.verifyParameterNotNullorEmpty(projectid);\n+            RestPreconditionsUtil.verifyResourceFound(projectid);\n+\n+            // check resource\n+            if (!RouteManagerUtil.checkCreateNeutronSubnetRouteTableWebJsonResourceIsValid(resource)) {\n+                throw new ResourceNotValidException(\"request resource is invalid\");\n+            }\n+\n+            routeTable = this.routerService.createNeutronSubnetRouteTable(projectid, subnetid, resource);\n+\n+            // sub-level routing rule update\n+            List<RouteEntry> routeEntities = routeTable.getRouteEntities();\n+            NewRoutesWebRequest newRoutes = new NewRoutesWebRequest();\n+            List<NewRoutesRequest> routes = new ArrayList<>();\n+            for (RouteEntry routeEntry : routeEntities) {\n+                String destination = routeEntry.getDestination();\n+                String nexthop = routeEntry.getNexthop();\n+                NewRoutesRequest newRoutesRequest = new NewRoutesRequest(destination, nexthop);\n+                routes.add(newRoutesRequest);\n+            }\n+            newRoutes.setRoutes(routes);\n+\n+            UpdateRoutingRuleResponse updateRoutingRuleResponse = this.neutronRouterService.updateRoutingRule(subnetid, newRoutes, false);\n+            List<InternalSubnetRoutingTable> internalSubnetRoutingTables = updateRoutingRuleResponse.getInternalSubnetRoutingTables();", "originalCommit": "590eea3dbe93fe7da2c87f6056035a502a445a33", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgxODI2Ng==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r532818266", "bodyText": "Sure, fixed", "author": "kevin-zhonghao", "createdAt": "2020-11-30T18:43:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY1NzM5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY1ODQ5MQ==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r530658491", "bodyText": "For Neutron's case, I think we don't need to return new HostRoute back to SM, since SM is already update its HostRoute when the subnet is created in SM.", "author": "cj-chung", "createdAt": "2020-11-25T21:47:24Z", "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/controller/RouterController.java", "diffHunk": "@@ -293,6 +335,69 @@ public RouteTableWebJson getOrCreateSubnetRouteTable(@PathVariable String projec\n         return new RouteTableWebJson(routeTable);\n     }\n \n+    /**\n+     * Create neutron subnet routeTable\n+     * @param projectid\n+     * @param subnetid\n+     * @param resource\n+     * @return\n+     * @throws Exception\n+     */\n+    @RequestMapping(\n+            method = POST,\n+            value = {\"/project/{projectid}/subnets/{subnetid}/routetable\"})\n+    @DurationStatistics\n+    public RouteTableWebJson createNeutronSubnetRouteTable(@PathVariable String projectid, @PathVariable String subnetid, @RequestBody RouteTableWebJson resource) throws Exception {\n+\n+        RouteTable routeTable = null;\n+\n+        try {\n+            RestPreconditionsUtil.verifyParameterNotNullorEmpty(subnetid);\n+            RestPreconditionsUtil.verifyParameterNotNullorEmpty(projectid);\n+            RestPreconditionsUtil.verifyResourceFound(projectid);\n+\n+            // check resource\n+            if (!RouteManagerUtil.checkCreateNeutronSubnetRouteTableWebJsonResourceIsValid(resource)) {\n+                throw new ResourceNotValidException(\"request resource is invalid\");\n+            }\n+\n+            routeTable = this.routerService.createNeutronSubnetRouteTable(projectid, subnetid, resource);\n+\n+            // sub-level routing rule update\n+            List<RouteEntry> routeEntities = routeTable.getRouteEntities();\n+            NewRoutesWebRequest newRoutes = new NewRoutesWebRequest();\n+            List<NewRoutesRequest> routes = new ArrayList<>();\n+            for (RouteEntry routeEntry : routeEntities) {\n+                String destination = routeEntry.getDestination();\n+                String nexthop = routeEntry.getNexthop();\n+                NewRoutesRequest newRoutesRequest = new NewRoutesRequest(destination, nexthop);\n+                routes.add(newRoutesRequest);\n+            }\n+            newRoutes.setRoutes(routes);\n+\n+            UpdateRoutingRuleResponse updateRoutingRuleResponse = this.neutronRouterService.updateRoutingRule(subnetid, newRoutes, false);\n+            List<InternalSubnetRoutingTable> internalSubnetRoutingTables = updateRoutingRuleResponse.getInternalSubnetRoutingTables();\n+            InternalRouterInfo internalRouterInfo = this.neutronRouterService.constructInternalRouterInfo(internalSubnetRoutingTables);\n+            List<HostRoute> hostRouteToSubnet = updateRoutingRuleResponse.getHostRouteToSubnet();\n+\n+            // send InternalRouterInfo contract to DPM\n+            this.routerToDPMService.sendInternalRouterInfoToDPM(internalRouterInfo);\n+\n+            // update routes in subnet manager\n+            if (hostRouteToSubnet == null) {\n+                throw new HostRoutesToSubnetIsNull();\n+            }\n+            this.vpcRouterToSubnetService.updateRoutingRuleInSubnetManager(projectid, subnetid, hostRouteToSubnet);\n+", "originalCommit": "590eea3dbe93fe7da2c87f6056035a502a445a33", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgyMDkxMw==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r532820913", "bodyText": "Could you explain why we don't need to update SM for Neutron's case?", "author": "kevin-zhonghao", "createdAt": "2020-11-30T18:47:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY1ODQ5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY1OTE5NA==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r530659194", "bodyText": "This API is for VPC scenario, we should set it's Target too.", "author": "cj-chung", "createdAt": "2020-11-25T21:49:26Z", "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/controller/RouterController.java", "diffHunk": "@@ -321,7 +426,33 @@ public RouteTableWebJson updateSubnetRouteTable(@PathVariable String projectid,\n \n             routetable = this.routerService.updateSubnetRouteTable(projectid, subnetid, resource);\n \n-        } catch (ParameterNullOrEmptyException e) {\n+            // sub-level routing rule update\n+            List<RouteEntry> routeEntities = routetable.getRouteEntities();\n+            NewRoutesWebRequest newRoutes = new NewRoutesWebRequest();\n+            List<NewRoutesRequest> routes = new ArrayList<>();\n+            for (RouteEntry routeEntry : routeEntities) {\n+                String destination = routeEntry.getDestination();\n+                String nexthop = routeEntry.getNexthop();\n+                NewRoutesRequest newRoutesRequest = new NewRoutesRequest(destination, nexthop);", "originalCommit": "590eea3dbe93fe7da2c87f6056035a502a445a33", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgyMTI4MA==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r532821280", "bodyText": "Sure", "author": "kevin-zhonghao", "createdAt": "2020-11-30T18:48:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY1OTE5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY2MTkwNQ==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r530661905", "bodyText": "We may think about how user update subnet's host route in the VPC scenario.\nIf we let user update subnet's route table through RM's API, then we need to update subnet's hostroute in SM.\nOtherwise, if we let user update that through SM, SM already has the new host route information, then there is no need to send the new host route back to SM from here.", "author": "cj-chung", "createdAt": "2020-11-25T21:56:05Z", "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/controller/RouterController.java", "diffHunk": "@@ -355,7 +486,25 @@ public ResponseId deleteSubnetRouteTable(@PathVariable String projectid, @PathVa\n \n             routerId = this.routerService.deleteSubnetRouteTable(projectid, subnetid);\n \n-        } catch (ParameterNullOrEmptyException e) {\n+            // sub-level routing rule update\n+            NewRoutesWebRequest newRoutes = new NewRoutesWebRequest();\n+            List<NewRoutesRequest> routes = new ArrayList<>();\n+            newRoutes.setRoutes(routes);\n+            UpdateRoutingRuleResponse updateRoutingRuleResponse = this.neutronRouterService.updateRoutingRule(subnetid, newRoutes, false);\n+            List<InternalSubnetRoutingTable> internalSubnetRoutingTables = updateRoutingRuleResponse.getInternalSubnetRoutingTables();\n+            InternalRouterInfo internalRouterInfo = this.neutronRouterService.constructInternalRouterInfo(internalSubnetRoutingTables);\n+            List<HostRoute> hostRouteToSubnet = updateRoutingRuleResponse.getHostRouteToSubnet();\n+\n+            // send InternalRouterInfo contract to DPM\n+            this.routerToDPMService.sendInternalRouterInfoToDPM(internalRouterInfo);\n+\n+            // update routes in subnet manager\n+            if (hostRouteToSubnet == null) {\n+                throw new HostRoutesToSubnetIsNull();\n+            }\n+            this.vpcRouterToSubnetService.updateRoutingRuleInSubnetManager(projectid, subnetid, hostRouteToSubnet);\n+", "originalCommit": "590eea3dbe93fe7da2c87f6056035a502a445a33", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY2Njk2MQ==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r530666961", "bodyText": "boolean isNeutronOrVPCLevelRoutingRule is a boolean, so it's better rename the variable to isDefaultRoutingRules.", "author": "cj-chung", "createdAt": "2020-11-25T22:07:51Z", "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/service/Impl/NeutronRouterServiceImpl.java", "diffHunk": "@@ -469,6 +468,197 @@ public ConnectedSubnetsWebResponse getConnectedSubnets(String projectId, String\n         return connectedSubnetsWebResponse;\n     }\n \n+    @Override\n+    public UpdateRoutingRuleResponse updateRoutingRule (String owner, NewRoutesWebRequest newRouteEntry, boolean isNeutronOrVPCLevelRoutingRule) throws DestinationOrNexthopCanNotBeNull, CacheException, CanNotFindRouteTableByOwner, QueryParamTypeNotSupportException, RouteTableNotUnique, DestinationInvalid {", "originalCommit": "590eea3dbe93fe7da2c87f6056035a502a445a33", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgzOTI1Mg==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r532839252", "bodyText": "okay", "author": "kevin-zhonghao", "createdAt": "2020-11-30T19:18:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY2Njk2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY3MDU5Mg==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r530670592", "bodyText": "It's better name the function removeRoutesFromNeutronRouter.", "author": "cj-chung", "createdAt": "2020-11-25T22:18:01Z", "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/service/Impl/NeutronRouterServiceImpl.java", "diffHunk": "@@ -380,9 +379,9 @@ public RoutesToNeutronWebResponse addRoutesToNeutronRouter(String routerid, Rout\n     }\n \n     @Override\n-    public RoutesToNeutronWebResponse removeRoutesToNeutronRouter(String routerid, RoutesToNeutronRouterRequestObject requestRouter) throws RouterOrSubnetAndPortNotExistOrNotVisible, ResourceNotFoundException, ResourcePersistenceException, DestinationOrNexthopCanNotBeNull, DatabasePersistenceException {\n+    public RoutesToNeutronWebResponse removeRoutesToNeutronRouter(String routerid, NewRoutesWebRequest requestRouter) throws RouterOrSubnetAndPortNotExistOrNotVisible, ResourceNotFoundException, ResourcePersistenceException, DestinationOrNexthopCanNotBeNull, DatabasePersistenceException {", "originalCommit": "590eea3dbe93fe7da2c87f6056035a502a445a33", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgzODcyNw==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r532838727", "bodyText": "Sure", "author": "kevin-zhonghao", "createdAt": "2020-11-30T19:18:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY3MDU5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY4NTcyMQ==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r530685721", "bodyText": "Do we need put these operations here? or move them into else part below if the if part doesn't need them.", "author": "cj-chung", "createdAt": "2020-11-25T23:04:39Z", "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/service/Impl/NeutronRouterServiceImpl.java", "diffHunk": "@@ -469,6 +468,197 @@ public ConnectedSubnetsWebResponse getConnectedSubnets(String projectId, String\n         return connectedSubnetsWebResponse;\n     }\n \n+    @Override\n+    public UpdateRoutingRuleResponse updateRoutingRule (String owner, NewRoutesWebRequest newRouteEntry, boolean isNeutronOrVPCLevelRoutingRule) throws DestinationOrNexthopCanNotBeNull, CacheException, CanNotFindRouteTableByOwner, QueryParamTypeNotSupportException, RouteTableNotUnique, DestinationInvalid {\n+        List<InternalRoutingRule> updateRoutes = new ArrayList<>();\n+        List<HostRoute> hostRouteToSubnet = new ArrayList<>();\n+\n+        List<NewRoutesRequest> routes = newRouteEntry.getRoutes();\n+        if (routes == null) {\n+            return new UpdateRoutingRuleResponse(new ArrayList<>(), hostRouteToSubnet);\n+        }\n+\n+        // find routeTable\n+        Map<String, String[]> requestParams =  new HashMap<>();\n+        String[] value = new String[1];\n+        value[0] = owner;\n+        requestParams.put(\"owner\", value);\n+\n+        Map<String, Object[]> queryParams =\n+                ControllerUtil.transformUrlPathParams(requestParams, RouteTable.class);\n+        Map<String, RouteTable> routeTableMap = this.routeTableDatabaseService.getAllRouteTables(queryParams);\n+        List<RouteTable> routeTables = new ArrayList<>(routeTableMap.values());\n+        if (routeTables == null || routeTables.size() == 0) {\n+            logger.log(Level.WARNING, \"owner: \" + owner);\n+            throw new CanNotFindRouteTableByOwner();\n+        } else if (routeTables.size() >= 2) {\n+            logger.log(Level.WARNING, \"owner: \" + owner);\n+            throw new RouteTableNotUnique();\n+        }\n+\n+        RouteTable existRouteTable = routeTables.get(0);\n+\n+        List<RouteEntry> existRoutes = existRouteTable.getRouteEntities();\n+        // TODO: existRoutes -> MAP: key - des(/\u524d\u9762\u7684), value - nexthop, \"10.0.0.0/16\"\n+        Map<String, RouteEntry> existRoutesMap = new HashMap<>();\n+        for (RouteEntry existRoute : existRoutes) {\n+            String[] existDes = existRoute.getDestination().split(\"\\\\/\");\n+            String existNetworkIP = existDes[0];\n+            existRoutesMap.put(existNetworkIP, existRoute);\n+        }\n+        // TODO: existRoutes replaced with map\n+        // Tracking operation type for each routing rule\n+        for (NewRoutesRequest newRouteRequest : routes) {\n+            //RouteEntry route = null;\n+            // TODO: 1. check new-des if it is valid\n+            String newRouteDestination = newRouteRequest.getDestination();\n+            String newRouteNexthop = newRouteRequest.getNexthop();\n+            boolean isDestinationValid = verifyCidrBlock(newRouteDestination);\n+            if (!isDestinationValid) {\n+                throw new DestinationInvalid(\"destination is invalid : \" + newRouteDestination);\n+            }\n+            String[] newRouteDes = newRouteDestination.split(\"\\\\/\");\n+            String newNetworkIP = newRouteDes[0];\n+            String newBitmask = newRouteDes[1];\n+            int newBitmaskInt = Integer.parseInt(newBitmask);", "originalCommit": "590eea3dbe93fe7da2c87f6056035a502a445a33", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY4NjQyNQ==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r530686425", "bodyText": "default routing rules don't need update back to subnet's host route or routing table.", "author": "cj-chung", "createdAt": "2020-11-25T23:07:12Z", "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/service/Impl/NeutronRouterServiceImpl.java", "diffHunk": "@@ -469,6 +468,197 @@ public ConnectedSubnetsWebResponse getConnectedSubnets(String projectId, String\n         return connectedSubnetsWebResponse;\n     }\n \n+    @Override\n+    public UpdateRoutingRuleResponse updateRoutingRule (String owner, NewRoutesWebRequest newRouteEntry, boolean isNeutronOrVPCLevelRoutingRule) throws DestinationOrNexthopCanNotBeNull, CacheException, CanNotFindRouteTableByOwner, QueryParamTypeNotSupportException, RouteTableNotUnique, DestinationInvalid {\n+        List<InternalRoutingRule> updateRoutes = new ArrayList<>();\n+        List<HostRoute> hostRouteToSubnet = new ArrayList<>();\n+\n+        List<NewRoutesRequest> routes = newRouteEntry.getRoutes();\n+        if (routes == null) {\n+            return new UpdateRoutingRuleResponse(new ArrayList<>(), hostRouteToSubnet);\n+        }\n+\n+        // find routeTable\n+        Map<String, String[]> requestParams =  new HashMap<>();\n+        String[] value = new String[1];\n+        value[0] = owner;\n+        requestParams.put(\"owner\", value);\n+\n+        Map<String, Object[]> queryParams =\n+                ControllerUtil.transformUrlPathParams(requestParams, RouteTable.class);\n+        Map<String, RouteTable> routeTableMap = this.routeTableDatabaseService.getAllRouteTables(queryParams);\n+        List<RouteTable> routeTables = new ArrayList<>(routeTableMap.values());\n+        if (routeTables == null || routeTables.size() == 0) {\n+            logger.log(Level.WARNING, \"owner: \" + owner);\n+            throw new CanNotFindRouteTableByOwner();\n+        } else if (routeTables.size() >= 2) {\n+            logger.log(Level.WARNING, \"owner: \" + owner);\n+            throw new RouteTableNotUnique();\n+        }\n+\n+        RouteTable existRouteTable = routeTables.get(0);\n+\n+        List<RouteEntry> existRoutes = existRouteTable.getRouteEntities();\n+        // TODO: existRoutes -> MAP: key - des(/\u524d\u9762\u7684), value - nexthop, \"10.0.0.0/16\"\n+        Map<String, RouteEntry> existRoutesMap = new HashMap<>();\n+        for (RouteEntry existRoute : existRoutes) {\n+            String[] existDes = existRoute.getDestination().split(\"\\\\/\");\n+            String existNetworkIP = existDes[0];\n+            existRoutesMap.put(existNetworkIP, existRoute);\n+        }\n+        // TODO: existRoutes replaced with map\n+        // Tracking operation type for each routing rule\n+        for (NewRoutesRequest newRouteRequest : routes) {\n+            //RouteEntry route = null;\n+            // TODO: 1. check new-des if it is valid\n+            String newRouteDestination = newRouteRequest.getDestination();\n+            String newRouteNexthop = newRouteRequest.getNexthop();\n+            boolean isDestinationValid = verifyCidrBlock(newRouteDestination);\n+            if (!isDestinationValid) {\n+                throw new DestinationInvalid(\"destination is invalid : \" + newRouteDestination);\n+            }\n+            String[] newRouteDes = newRouteDestination.split(\"\\\\/\");\n+            String newNetworkIP = newRouteDes[0];\n+            String newBitmask = newRouteDes[1];\n+            int newBitmaskInt = Integer.parseInt(newBitmask);\n+            // TODO: 2. flag check if it is from vpc/Neutron(lower priority) or subnet.\n+            RouteEntry existRoute = existRoutesMap.get(newNetworkIP);\n+            // dont find: Create (both)\n+            if (existRoute == null) {\n+                InternalRoutingRule internalRoutingRule = null;\n+                if (isNeutronOrVPCLevelRoutingRule) {\n+                    internalRoutingRule = constructNewInternalRoutingRule(OperationType.CREATE, RoutingRuleType.DEFAULT, existRoute, newRouteRequest);\n+                } else {\n+                    internalRoutingRule = constructNewInternalRoutingRule(OperationType.CREATE, RoutingRuleType.STATIC, existRoute, newRouteRequest);\n+                }\n+                String Des = internalRoutingRule.getDestination();\n+                String Nexthop = internalRoutingRule.getNextHopIp();\n+\n+                updateRoutes.add(internalRoutingRule);\n+                hostRouteToSubnet.add(new HostRoute(){{setNexthop(Nexthop);setDestination(Des);}});\n+\n+            } else { // could find:\n+                // compare which one cover the other one\n+                if (isNeutronOrVPCLevelRoutingRule) { // VPC/Neutron\n+                    String[] existDes = existRoute.getDestination().split(\"\\\\/\");\n+                    String existBitmask = existDes[1];\n+                    int existBitmaskInt = Integer.parseInt(existBitmask);\n+                    if (newBitmaskInt <= existBitmaskInt) { // new routing rule bitmask is smaller or equal than old one, drop it\n+                        continue;\n+                    } else { // new routing rule bitmask is larger than old one, Create new rule with low priority\n+\n+                        InternalRoutingRule internalRoutingRule = constructNewInternalRoutingRule(OperationType.CREATE, RoutingRuleType.DEFAULT, existRoute, newRouteRequest);\n+\n+                        updateRoutes.add(internalRoutingRule);\n+                        hostRouteToSubnet.add(new HostRoute(){{setNexthop(internalRoutingRule.getNextHopIp());setDestination(internalRoutingRule.getDestination());}});\n+", "originalCommit": "590eea3dbe93fe7da2c87f6056035a502a445a33", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg0MDc5MQ==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r532840791", "bodyText": "okay", "author": "kevin-zhonghao", "createdAt": "2020-11-30T19:21:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY4NjQyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY4ODIyNg==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r530688226", "bodyText": "You need to move existRoutesMap.remove(newNetworkIP) out of this else part, the if (isNeutronOrVPCLevelRoutingRule) part also need to remove the existing routing rule from the map.", "author": "cj-chung", "createdAt": "2020-11-25T23:13:53Z", "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/service/Impl/NeutronRouterServiceImpl.java", "diffHunk": "@@ -469,6 +468,197 @@ public ConnectedSubnetsWebResponse getConnectedSubnets(String projectId, String\n         return connectedSubnetsWebResponse;\n     }\n \n+    @Override\n+    public UpdateRoutingRuleResponse updateRoutingRule (String owner, NewRoutesWebRequest newRouteEntry, boolean isNeutronOrVPCLevelRoutingRule) throws DestinationOrNexthopCanNotBeNull, CacheException, CanNotFindRouteTableByOwner, QueryParamTypeNotSupportException, RouteTableNotUnique, DestinationInvalid {\n+        List<InternalRoutingRule> updateRoutes = new ArrayList<>();\n+        List<HostRoute> hostRouteToSubnet = new ArrayList<>();\n+\n+        List<NewRoutesRequest> routes = newRouteEntry.getRoutes();\n+        if (routes == null) {\n+            return new UpdateRoutingRuleResponse(new ArrayList<>(), hostRouteToSubnet);\n+        }\n+\n+        // find routeTable\n+        Map<String, String[]> requestParams =  new HashMap<>();\n+        String[] value = new String[1];\n+        value[0] = owner;\n+        requestParams.put(\"owner\", value);\n+\n+        Map<String, Object[]> queryParams =\n+                ControllerUtil.transformUrlPathParams(requestParams, RouteTable.class);\n+        Map<String, RouteTable> routeTableMap = this.routeTableDatabaseService.getAllRouteTables(queryParams);\n+        List<RouteTable> routeTables = new ArrayList<>(routeTableMap.values());\n+        if (routeTables == null || routeTables.size() == 0) {\n+            logger.log(Level.WARNING, \"owner: \" + owner);\n+            throw new CanNotFindRouteTableByOwner();\n+        } else if (routeTables.size() >= 2) {\n+            logger.log(Level.WARNING, \"owner: \" + owner);\n+            throw new RouteTableNotUnique();\n+        }\n+\n+        RouteTable existRouteTable = routeTables.get(0);\n+\n+        List<RouteEntry> existRoutes = existRouteTable.getRouteEntities();\n+        // TODO: existRoutes -> MAP: key - des(/\u524d\u9762\u7684), value - nexthop, \"10.0.0.0/16\"\n+        Map<String, RouteEntry> existRoutesMap = new HashMap<>();\n+        for (RouteEntry existRoute : existRoutes) {\n+            String[] existDes = existRoute.getDestination().split(\"\\\\/\");\n+            String existNetworkIP = existDes[0];\n+            existRoutesMap.put(existNetworkIP, existRoute);\n+        }\n+        // TODO: existRoutes replaced with map\n+        // Tracking operation type for each routing rule\n+        for (NewRoutesRequest newRouteRequest : routes) {\n+            //RouteEntry route = null;\n+            // TODO: 1. check new-des if it is valid\n+            String newRouteDestination = newRouteRequest.getDestination();\n+            String newRouteNexthop = newRouteRequest.getNexthop();\n+            boolean isDestinationValid = verifyCidrBlock(newRouteDestination);\n+            if (!isDestinationValid) {\n+                throw new DestinationInvalid(\"destination is invalid : \" + newRouteDestination);\n+            }\n+            String[] newRouteDes = newRouteDestination.split(\"\\\\/\");\n+            String newNetworkIP = newRouteDes[0];\n+            String newBitmask = newRouteDes[1];\n+            int newBitmaskInt = Integer.parseInt(newBitmask);\n+            // TODO: 2. flag check if it is from vpc/Neutron(lower priority) or subnet.\n+            RouteEntry existRoute = existRoutesMap.get(newNetworkIP);\n+            // dont find: Create (both)\n+            if (existRoute == null) {\n+                InternalRoutingRule internalRoutingRule = null;\n+                if (isNeutronOrVPCLevelRoutingRule) {\n+                    internalRoutingRule = constructNewInternalRoutingRule(OperationType.CREATE, RoutingRuleType.DEFAULT, existRoute, newRouteRequest);\n+                } else {\n+                    internalRoutingRule = constructNewInternalRoutingRule(OperationType.CREATE, RoutingRuleType.STATIC, existRoute, newRouteRequest);\n+                }\n+                String Des = internalRoutingRule.getDestination();\n+                String Nexthop = internalRoutingRule.getNextHopIp();\n+\n+                updateRoutes.add(internalRoutingRule);\n+                hostRouteToSubnet.add(new HostRoute(){{setNexthop(Nexthop);setDestination(Des);}});\n+\n+            } else { // could find:\n+                // compare which one cover the other one\n+                if (isNeutronOrVPCLevelRoutingRule) { // VPC/Neutron\n+                    String[] existDes = existRoute.getDestination().split(\"\\\\/\");\n+                    String existBitmask = existDes[1];\n+                    int existBitmaskInt = Integer.parseInt(existBitmask);\n+                    if (newBitmaskInt <= existBitmaskInt) { // new routing rule bitmask is smaller or equal than old one, drop it\n+                        continue;\n+                    } else { // new routing rule bitmask is larger than old one, Create new rule with low priority\n+\n+                        InternalRoutingRule internalRoutingRule = constructNewInternalRoutingRule(OperationType.CREATE, RoutingRuleType.DEFAULT, existRoute, newRouteRequest);\n+\n+                        updateRoutes.add(internalRoutingRule);\n+                        hostRouteToSubnet.add(new HostRoute(){{setNexthop(internalRoutingRule.getNextHopIp());setDestination(internalRoutingRule.getDestination());}});\n+\n+                    }\n+                } else { // Subnet\n+                    // new routing rule update old one without checking bitmask\n+                    InternalRoutingRule internalRoutingRule = constructNewInternalRoutingRule(OperationType.UPDATE, RoutingRuleType.STATIC, existRoute, newRouteRequest);\n+\n+                    updateRoutes.add(internalRoutingRule);\n+                    hostRouteToSubnet.add(new HostRoute(){{setNexthop(internalRoutingRule.getNextHopIp());setDestination(internalRoutingRule.getDestination());}});\n+\n+                    existRoutesMap.remove(newNetworkIP);", "originalCommit": "590eea3dbe93fe7da2c87f6056035a502a445a33", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg0MzQyOA==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r532843428", "bodyText": "It is a Create operation, should we remove?", "author": "kevin-zhonghao", "createdAt": "2020-11-30T19:25:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY4ODIyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg1Nzc1Mg==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r532857752", "bodyText": "Fixed", "author": "kevin-zhonghao", "createdAt": "2020-11-30T19:48:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY4ODIyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY4OTc3Nw==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r530689777", "bodyText": "If owner == null that's mean we cannot find routetable right?\nthen why we still need to set owner to internalSubnetRoutingTable?", "author": "cj-chung", "createdAt": "2020-11-25T23:19:23Z", "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/service/Impl/NeutronRouterServiceImpl.java", "diffHunk": "@@ -469,6 +468,197 @@ public ConnectedSubnetsWebResponse getConnectedSubnets(String projectId, String\n         return connectedSubnetsWebResponse;\n     }\n \n+    @Override\n+    public UpdateRoutingRuleResponse updateRoutingRule (String owner, NewRoutesWebRequest newRouteEntry, boolean isNeutronOrVPCLevelRoutingRule) throws DestinationOrNexthopCanNotBeNull, CacheException, CanNotFindRouteTableByOwner, QueryParamTypeNotSupportException, RouteTableNotUnique, DestinationInvalid {\n+        List<InternalRoutingRule> updateRoutes = new ArrayList<>();\n+        List<HostRoute> hostRouteToSubnet = new ArrayList<>();\n+\n+        List<NewRoutesRequest> routes = newRouteEntry.getRoutes();\n+        if (routes == null) {\n+            return new UpdateRoutingRuleResponse(new ArrayList<>(), hostRouteToSubnet);\n+        }\n+\n+        // find routeTable\n+        Map<String, String[]> requestParams =  new HashMap<>();\n+        String[] value = new String[1];\n+        value[0] = owner;\n+        requestParams.put(\"owner\", value);\n+\n+        Map<String, Object[]> queryParams =\n+                ControllerUtil.transformUrlPathParams(requestParams, RouteTable.class);\n+        Map<String, RouteTable> routeTableMap = this.routeTableDatabaseService.getAllRouteTables(queryParams);\n+        List<RouteTable> routeTables = new ArrayList<>(routeTableMap.values());\n+        if (routeTables == null || routeTables.size() == 0) {\n+            logger.log(Level.WARNING, \"owner: \" + owner);\n+            throw new CanNotFindRouteTableByOwner();\n+        } else if (routeTables.size() >= 2) {\n+            logger.log(Level.WARNING, \"owner: \" + owner);\n+            throw new RouteTableNotUnique();\n+        }\n+\n+        RouteTable existRouteTable = routeTables.get(0);\n+\n+        List<RouteEntry> existRoutes = existRouteTable.getRouteEntities();\n+        // TODO: existRoutes -> MAP: key - des(/\u524d\u9762\u7684), value - nexthop, \"10.0.0.0/16\"\n+        Map<String, RouteEntry> existRoutesMap = new HashMap<>();\n+        for (RouteEntry existRoute : existRoutes) {\n+            String[] existDes = existRoute.getDestination().split(\"\\\\/\");\n+            String existNetworkIP = existDes[0];\n+            existRoutesMap.put(existNetworkIP, existRoute);\n+        }\n+        // TODO: existRoutes replaced with map\n+        // Tracking operation type for each routing rule\n+        for (NewRoutesRequest newRouteRequest : routes) {\n+            //RouteEntry route = null;\n+            // TODO: 1. check new-des if it is valid\n+            String newRouteDestination = newRouteRequest.getDestination();\n+            String newRouteNexthop = newRouteRequest.getNexthop();\n+            boolean isDestinationValid = verifyCidrBlock(newRouteDestination);\n+            if (!isDestinationValid) {\n+                throw new DestinationInvalid(\"destination is invalid : \" + newRouteDestination);\n+            }\n+            String[] newRouteDes = newRouteDestination.split(\"\\\\/\");\n+            String newNetworkIP = newRouteDes[0];\n+            String newBitmask = newRouteDes[1];\n+            int newBitmaskInt = Integer.parseInt(newBitmask);\n+            // TODO: 2. flag check if it is from vpc/Neutron(lower priority) or subnet.\n+            RouteEntry existRoute = existRoutesMap.get(newNetworkIP);\n+            // dont find: Create (both)\n+            if (existRoute == null) {\n+                InternalRoutingRule internalRoutingRule = null;\n+                if (isNeutronOrVPCLevelRoutingRule) {\n+                    internalRoutingRule = constructNewInternalRoutingRule(OperationType.CREATE, RoutingRuleType.DEFAULT, existRoute, newRouteRequest);\n+                } else {\n+                    internalRoutingRule = constructNewInternalRoutingRule(OperationType.CREATE, RoutingRuleType.STATIC, existRoute, newRouteRequest);\n+                }\n+                String Des = internalRoutingRule.getDestination();\n+                String Nexthop = internalRoutingRule.getNextHopIp();\n+\n+                updateRoutes.add(internalRoutingRule);\n+                hostRouteToSubnet.add(new HostRoute(){{setNexthop(Nexthop);setDestination(Des);}});\n+\n+            } else { // could find:\n+                // compare which one cover the other one\n+                if (isNeutronOrVPCLevelRoutingRule) { // VPC/Neutron\n+                    String[] existDes = existRoute.getDestination().split(\"\\\\/\");\n+                    String existBitmask = existDes[1];\n+                    int existBitmaskInt = Integer.parseInt(existBitmask);\n+                    if (newBitmaskInt <= existBitmaskInt) { // new routing rule bitmask is smaller or equal than old one, drop it\n+                        continue;\n+                    } else { // new routing rule bitmask is larger than old one, Create new rule with low priority\n+\n+                        InternalRoutingRule internalRoutingRule = constructNewInternalRoutingRule(OperationType.CREATE, RoutingRuleType.DEFAULT, existRoute, newRouteRequest);\n+\n+                        updateRoutes.add(internalRoutingRule);\n+                        hostRouteToSubnet.add(new HostRoute(){{setNexthop(internalRoutingRule.getNextHopIp());setDestination(internalRoutingRule.getDestination());}});\n+\n+                    }\n+                } else { // Subnet\n+                    // new routing rule update old one without checking bitmask\n+                    InternalRoutingRule internalRoutingRule = constructNewInternalRoutingRule(OperationType.UPDATE, RoutingRuleType.STATIC, existRoute, newRouteRequest);\n+\n+                    updateRoutes.add(internalRoutingRule);\n+                    hostRouteToSubnet.add(new HostRoute(){{setNexthop(internalRoutingRule.getNextHopIp());setDestination(internalRoutingRule.getDestination());}});\n+\n+                    existRoutesMap.remove(newNetworkIP);\n+                }\n+\n+            }\n+\n+        }\n+\n+        for (Map.Entry<String, RouteEntry> existRouteEntry : existRoutesMap.entrySet()) {\n+            RouteEntry existRoute = (RouteEntry)existRouteEntry.getValue();\n+            InternalRoutingRule internalRoutingRule = constructNewInternalRoutingRule(OperationType.DELETE, RoutingRuleType.DEFAULT, existRoute, null);\n+\n+            updateRoutes.add(internalRoutingRule);\n+\n+        }\n+\n+        // construct List<InternalSubnetRoutingTable>\n+        List<InternalSubnetRoutingTable> subnetRoutingTables = new ArrayList<>();\n+\n+        InternalSubnetRoutingTable internalSubnetRoutingTable = new InternalSubnetRoutingTable();\n+        if (owner != null) {\n+            internalSubnetRoutingTable.setSubnetId(owner);\n+        } else {\n+            internalSubnetRoutingTable.setSubnetId(existRouteTable.getOwner());\n+        }", "originalCommit": "590eea3dbe93fe7da2c87f6056035a502a445a33", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgzNzE1MQ==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r532837151", "bodyText": "Actually the owner here is not possible to be null, I will change the logic", "author": "kevin-zhonghao", "createdAt": "2020-11-30T19:15:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY4OTc3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY5MzU0OA==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r530693548", "bodyText": "Is that possible for route == null, that's mean existing route doesn't exist?\nIf it's null, how can you getId() from a null?", "author": "cj-chung", "createdAt": "2020-11-25T23:33:48Z", "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/service/Impl/NeutronRouterServiceImpl.java", "diffHunk": "@@ -469,6 +468,197 @@ public ConnectedSubnetsWebResponse getConnectedSubnets(String projectId, String\n         return connectedSubnetsWebResponse;\n     }\n \n+    @Override\n+    public UpdateRoutingRuleResponse updateRoutingRule (String owner, NewRoutesWebRequest newRouteEntry, boolean isNeutronOrVPCLevelRoutingRule) throws DestinationOrNexthopCanNotBeNull, CacheException, CanNotFindRouteTableByOwner, QueryParamTypeNotSupportException, RouteTableNotUnique, DestinationInvalid {\n+        List<InternalRoutingRule> updateRoutes = new ArrayList<>();\n+        List<HostRoute> hostRouteToSubnet = new ArrayList<>();\n+\n+        List<NewRoutesRequest> routes = newRouteEntry.getRoutes();\n+        if (routes == null) {\n+            return new UpdateRoutingRuleResponse(new ArrayList<>(), hostRouteToSubnet);\n+        }\n+\n+        // find routeTable\n+        Map<String, String[]> requestParams =  new HashMap<>();\n+        String[] value = new String[1];\n+        value[0] = owner;\n+        requestParams.put(\"owner\", value);\n+\n+        Map<String, Object[]> queryParams =\n+                ControllerUtil.transformUrlPathParams(requestParams, RouteTable.class);\n+        Map<String, RouteTable> routeTableMap = this.routeTableDatabaseService.getAllRouteTables(queryParams);\n+        List<RouteTable> routeTables = new ArrayList<>(routeTableMap.values());\n+        if (routeTables == null || routeTables.size() == 0) {\n+            logger.log(Level.WARNING, \"owner: \" + owner);\n+            throw new CanNotFindRouteTableByOwner();\n+        } else if (routeTables.size() >= 2) {\n+            logger.log(Level.WARNING, \"owner: \" + owner);\n+            throw new RouteTableNotUnique();\n+        }\n+\n+        RouteTable existRouteTable = routeTables.get(0);\n+\n+        List<RouteEntry> existRoutes = existRouteTable.getRouteEntities();\n+        // TODO: existRoutes -> MAP: key - des(/\u524d\u9762\u7684), value - nexthop, \"10.0.0.0/16\"\n+        Map<String, RouteEntry> existRoutesMap = new HashMap<>();\n+        for (RouteEntry existRoute : existRoutes) {\n+            String[] existDes = existRoute.getDestination().split(\"\\\\/\");\n+            String existNetworkIP = existDes[0];\n+            existRoutesMap.put(existNetworkIP, existRoute);\n+        }\n+        // TODO: existRoutes replaced with map\n+        // Tracking operation type for each routing rule\n+        for (NewRoutesRequest newRouteRequest : routes) {\n+            //RouteEntry route = null;\n+            // TODO: 1. check new-des if it is valid\n+            String newRouteDestination = newRouteRequest.getDestination();\n+            String newRouteNexthop = newRouteRequest.getNexthop();\n+            boolean isDestinationValid = verifyCidrBlock(newRouteDestination);\n+            if (!isDestinationValid) {\n+                throw new DestinationInvalid(\"destination is invalid : \" + newRouteDestination);\n+            }\n+            String[] newRouteDes = newRouteDestination.split(\"\\\\/\");\n+            String newNetworkIP = newRouteDes[0];\n+            String newBitmask = newRouteDes[1];\n+            int newBitmaskInt = Integer.parseInt(newBitmask);\n+            // TODO: 2. flag check if it is from vpc/Neutron(lower priority) or subnet.\n+            RouteEntry existRoute = existRoutesMap.get(newNetworkIP);\n+            // dont find: Create (both)\n+            if (existRoute == null) {\n+                InternalRoutingRule internalRoutingRule = null;\n+                if (isNeutronOrVPCLevelRoutingRule) {\n+                    internalRoutingRule = constructNewInternalRoutingRule(OperationType.CREATE, RoutingRuleType.DEFAULT, existRoute, newRouteRequest);\n+                } else {\n+                    internalRoutingRule = constructNewInternalRoutingRule(OperationType.CREATE, RoutingRuleType.STATIC, existRoute, newRouteRequest);\n+                }\n+                String Des = internalRoutingRule.getDestination();\n+                String Nexthop = internalRoutingRule.getNextHopIp();\n+\n+                updateRoutes.add(internalRoutingRule);\n+                hostRouteToSubnet.add(new HostRoute(){{setNexthop(Nexthop);setDestination(Des);}});\n+\n+            } else { // could find:\n+                // compare which one cover the other one\n+                if (isNeutronOrVPCLevelRoutingRule) { // VPC/Neutron\n+                    String[] existDes = existRoute.getDestination().split(\"\\\\/\");\n+                    String existBitmask = existDes[1];\n+                    int existBitmaskInt = Integer.parseInt(existBitmask);\n+                    if (newBitmaskInt <= existBitmaskInt) { // new routing rule bitmask is smaller or equal than old one, drop it\n+                        continue;\n+                    } else { // new routing rule bitmask is larger than old one, Create new rule with low priority\n+\n+                        InternalRoutingRule internalRoutingRule = constructNewInternalRoutingRule(OperationType.CREATE, RoutingRuleType.DEFAULT, existRoute, newRouteRequest);\n+\n+                        updateRoutes.add(internalRoutingRule);\n+                        hostRouteToSubnet.add(new HostRoute(){{setNexthop(internalRoutingRule.getNextHopIp());setDestination(internalRoutingRule.getDestination());}});\n+\n+                    }\n+                } else { // Subnet\n+                    // new routing rule update old one without checking bitmask\n+                    InternalRoutingRule internalRoutingRule = constructNewInternalRoutingRule(OperationType.UPDATE, RoutingRuleType.STATIC, existRoute, newRouteRequest);\n+\n+                    updateRoutes.add(internalRoutingRule);\n+                    hostRouteToSubnet.add(new HostRoute(){{setNexthop(internalRoutingRule.getNextHopIp());setDestination(internalRoutingRule.getDestination());}});\n+\n+                    existRoutesMap.remove(newNetworkIP);\n+                }\n+\n+            }\n+\n+        }\n+\n+        for (Map.Entry<String, RouteEntry> existRouteEntry : existRoutesMap.entrySet()) {\n+            RouteEntry existRoute = (RouteEntry)existRouteEntry.getValue();\n+            InternalRoutingRule internalRoutingRule = constructNewInternalRoutingRule(OperationType.DELETE, RoutingRuleType.DEFAULT, existRoute, null);\n+\n+            updateRoutes.add(internalRoutingRule);\n+\n+        }\n+\n+        // construct List<InternalSubnetRoutingTable>\n+        List<InternalSubnetRoutingTable> subnetRoutingTables = new ArrayList<>();\n+\n+        InternalSubnetRoutingTable internalSubnetRoutingTable = new InternalSubnetRoutingTable();\n+        if (owner != null) {\n+            internalSubnetRoutingTable.setSubnetId(owner);\n+        } else {\n+            internalSubnetRoutingTable.setSubnetId(existRouteTable.getOwner());\n+        }\n+        internalSubnetRoutingTable.setRoutingRules(updateRoutes);\n+        subnetRoutingTables.add(internalSubnetRoutingTable);\n+\n+        // construct UpdateRoutingRuleResponse\n+        UpdateRoutingRuleResponse updateRoutingRuleResponse = new UpdateRoutingRuleResponse(subnetRoutingTables, hostRouteToSubnet);\n+\n+        return updateRoutingRuleResponse;\n+    }\n+\n+    @Override\n+    public InternalRouterInfo constructInternalRouterInfo (List<InternalSubnetRoutingTable> internalSubnetRoutingTableList) {\n+\n+        String requestId = UUID.randomUUID().toString();\n+        InternalRouterInfo internalRouterInfo = new InternalRouterInfo();\n+\n+        InternalRouterConfiguration internalRouterConfiguration = new InternalRouterConfiguration();\n+\n+        internalRouterConfiguration.setSubnetRoutingTables(internalSubnetRoutingTableList);\n+\n+        internalRouterConfiguration.setRevisionNumber(ConstantsConfig.REVISION_NUMBER);\n+        internalRouterConfiguration.setFormatVersion(ConstantsConfig.FORMAT_VERSION);\n+        internalRouterConfiguration.setRequestId(requestId);\n+        internalRouterConfiguration.setHostDvrMac(\"\");\n+        internalRouterConfiguration.setMessageType(MessageType.FULL);\n+\n+        internalRouterInfo.setOperationType(OperationType.INFO);\n+        internalRouterInfo.setRouterConfiguration(internalRouterConfiguration);\n+\n+        return internalRouterInfo;\n+\n+    }\n+\n+    private InternalRoutingRule constructNewInternalRoutingRule(OperationType operationType, RoutingRuleType routingRuleType, RouteEntry route, NewRoutesRequest newRouteRequest) {\n+        if (route == null && newRouteRequest == null) {\n+            return new InternalRoutingRule();\n+        }\n+\n+        InternalRoutingRule internalRoutingRule = new InternalRoutingRule();\n+\n+        InternalRoutingRuleExtraInfo routingRuleExtraInfo = new InternalRoutingRuleExtraInfo();\n+        //routingRuleExtraInfo.setNextHopMac();\n+        // TODO: insert destination type - if it is vpc router, configure value according to target\n+        routingRuleExtraInfo.setDestinationType(VpcRouteTarget.LOCAL);\n+\n+        if (route == null) {\n+            internalRoutingRule.setId(route.getId());", "originalCommit": "590eea3dbe93fe7da2c87f6056035a502a445a33", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgzNDcwMQ==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r532834701", "bodyText": "Yes, route == null is possible I think. And the two lines of code here are indeed in reverse order", "author": "kevin-zhonghao", "createdAt": "2020-11-30T19:11:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY5MzU0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY5ODIwMw==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r530698203", "bodyText": "Why not just set these properties based on the operation type?\nif (operationType == CREATE), the routing rule's properties use new route's properties.\nif (operationType == UPDATE), only nexthop use new route's property, others use existing route's properties.\nif (operationType == DELETE), use existing route's properties.", "author": "cj-chung", "createdAt": "2020-11-25T23:52:17Z", "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/service/Impl/NeutronRouterServiceImpl.java", "diffHunk": "@@ -469,6 +468,197 @@ public ConnectedSubnetsWebResponse getConnectedSubnets(String projectId, String\n         return connectedSubnetsWebResponse;\n     }\n \n+    @Override\n+    public UpdateRoutingRuleResponse updateRoutingRule (String owner, NewRoutesWebRequest newRouteEntry, boolean isNeutronOrVPCLevelRoutingRule) throws DestinationOrNexthopCanNotBeNull, CacheException, CanNotFindRouteTableByOwner, QueryParamTypeNotSupportException, RouteTableNotUnique, DestinationInvalid {\n+        List<InternalRoutingRule> updateRoutes = new ArrayList<>();\n+        List<HostRoute> hostRouteToSubnet = new ArrayList<>();\n+\n+        List<NewRoutesRequest> routes = newRouteEntry.getRoutes();\n+        if (routes == null) {\n+            return new UpdateRoutingRuleResponse(new ArrayList<>(), hostRouteToSubnet);\n+        }\n+\n+        // find routeTable\n+        Map<String, String[]> requestParams =  new HashMap<>();\n+        String[] value = new String[1];\n+        value[0] = owner;\n+        requestParams.put(\"owner\", value);\n+\n+        Map<String, Object[]> queryParams =\n+                ControllerUtil.transformUrlPathParams(requestParams, RouteTable.class);\n+        Map<String, RouteTable> routeTableMap = this.routeTableDatabaseService.getAllRouteTables(queryParams);\n+        List<RouteTable> routeTables = new ArrayList<>(routeTableMap.values());\n+        if (routeTables == null || routeTables.size() == 0) {\n+            logger.log(Level.WARNING, \"owner: \" + owner);\n+            throw new CanNotFindRouteTableByOwner();\n+        } else if (routeTables.size() >= 2) {\n+            logger.log(Level.WARNING, \"owner: \" + owner);\n+            throw new RouteTableNotUnique();\n+        }\n+\n+        RouteTable existRouteTable = routeTables.get(0);\n+\n+        List<RouteEntry> existRoutes = existRouteTable.getRouteEntities();\n+        // TODO: existRoutes -> MAP: key - des(/\u524d\u9762\u7684), value - nexthop, \"10.0.0.0/16\"\n+        Map<String, RouteEntry> existRoutesMap = new HashMap<>();\n+        for (RouteEntry existRoute : existRoutes) {\n+            String[] existDes = existRoute.getDestination().split(\"\\\\/\");\n+            String existNetworkIP = existDes[0];\n+            existRoutesMap.put(existNetworkIP, existRoute);\n+        }\n+        // TODO: existRoutes replaced with map\n+        // Tracking operation type for each routing rule\n+        for (NewRoutesRequest newRouteRequest : routes) {\n+            //RouteEntry route = null;\n+            // TODO: 1. check new-des if it is valid\n+            String newRouteDestination = newRouteRequest.getDestination();\n+            String newRouteNexthop = newRouteRequest.getNexthop();\n+            boolean isDestinationValid = verifyCidrBlock(newRouteDestination);\n+            if (!isDestinationValid) {\n+                throw new DestinationInvalid(\"destination is invalid : \" + newRouteDestination);\n+            }\n+            String[] newRouteDes = newRouteDestination.split(\"\\\\/\");\n+            String newNetworkIP = newRouteDes[0];\n+            String newBitmask = newRouteDes[1];\n+            int newBitmaskInt = Integer.parseInt(newBitmask);\n+            // TODO: 2. flag check if it is from vpc/Neutron(lower priority) or subnet.\n+            RouteEntry existRoute = existRoutesMap.get(newNetworkIP);\n+            // dont find: Create (both)\n+            if (existRoute == null) {\n+                InternalRoutingRule internalRoutingRule = null;\n+                if (isNeutronOrVPCLevelRoutingRule) {\n+                    internalRoutingRule = constructNewInternalRoutingRule(OperationType.CREATE, RoutingRuleType.DEFAULT, existRoute, newRouteRequest);\n+                } else {\n+                    internalRoutingRule = constructNewInternalRoutingRule(OperationType.CREATE, RoutingRuleType.STATIC, existRoute, newRouteRequest);\n+                }\n+                String Des = internalRoutingRule.getDestination();\n+                String Nexthop = internalRoutingRule.getNextHopIp();\n+\n+                updateRoutes.add(internalRoutingRule);\n+                hostRouteToSubnet.add(new HostRoute(){{setNexthop(Nexthop);setDestination(Des);}});\n+\n+            } else { // could find:\n+                // compare which one cover the other one\n+                if (isNeutronOrVPCLevelRoutingRule) { // VPC/Neutron\n+                    String[] existDes = existRoute.getDestination().split(\"\\\\/\");\n+                    String existBitmask = existDes[1];\n+                    int existBitmaskInt = Integer.parseInt(existBitmask);\n+                    if (newBitmaskInt <= existBitmaskInt) { // new routing rule bitmask is smaller or equal than old one, drop it\n+                        continue;\n+                    } else { // new routing rule bitmask is larger than old one, Create new rule with low priority\n+\n+                        InternalRoutingRule internalRoutingRule = constructNewInternalRoutingRule(OperationType.CREATE, RoutingRuleType.DEFAULT, existRoute, newRouteRequest);\n+\n+                        updateRoutes.add(internalRoutingRule);\n+                        hostRouteToSubnet.add(new HostRoute(){{setNexthop(internalRoutingRule.getNextHopIp());setDestination(internalRoutingRule.getDestination());}});\n+\n+                    }\n+                } else { // Subnet\n+                    // new routing rule update old one without checking bitmask\n+                    InternalRoutingRule internalRoutingRule = constructNewInternalRoutingRule(OperationType.UPDATE, RoutingRuleType.STATIC, existRoute, newRouteRequest);\n+\n+                    updateRoutes.add(internalRoutingRule);\n+                    hostRouteToSubnet.add(new HostRoute(){{setNexthop(internalRoutingRule.getNextHopIp());setDestination(internalRoutingRule.getDestination());}});\n+\n+                    existRoutesMap.remove(newNetworkIP);\n+                }\n+\n+            }\n+\n+        }\n+\n+        for (Map.Entry<String, RouteEntry> existRouteEntry : existRoutesMap.entrySet()) {\n+            RouteEntry existRoute = (RouteEntry)existRouteEntry.getValue();\n+            InternalRoutingRule internalRoutingRule = constructNewInternalRoutingRule(OperationType.DELETE, RoutingRuleType.DEFAULT, existRoute, null);\n+\n+            updateRoutes.add(internalRoutingRule);\n+\n+        }\n+\n+        // construct List<InternalSubnetRoutingTable>\n+        List<InternalSubnetRoutingTable> subnetRoutingTables = new ArrayList<>();\n+\n+        InternalSubnetRoutingTable internalSubnetRoutingTable = new InternalSubnetRoutingTable();\n+        if (owner != null) {\n+            internalSubnetRoutingTable.setSubnetId(owner);\n+        } else {\n+            internalSubnetRoutingTable.setSubnetId(existRouteTable.getOwner());\n+        }\n+        internalSubnetRoutingTable.setRoutingRules(updateRoutes);\n+        subnetRoutingTables.add(internalSubnetRoutingTable);\n+\n+        // construct UpdateRoutingRuleResponse\n+        UpdateRoutingRuleResponse updateRoutingRuleResponse = new UpdateRoutingRuleResponse(subnetRoutingTables, hostRouteToSubnet);\n+\n+        return updateRoutingRuleResponse;\n+    }\n+\n+    @Override\n+    public InternalRouterInfo constructInternalRouterInfo (List<InternalSubnetRoutingTable> internalSubnetRoutingTableList) {\n+\n+        String requestId = UUID.randomUUID().toString();\n+        InternalRouterInfo internalRouterInfo = new InternalRouterInfo();\n+\n+        InternalRouterConfiguration internalRouterConfiguration = new InternalRouterConfiguration();\n+\n+        internalRouterConfiguration.setSubnetRoutingTables(internalSubnetRoutingTableList);\n+\n+        internalRouterConfiguration.setRevisionNumber(ConstantsConfig.REVISION_NUMBER);\n+        internalRouterConfiguration.setFormatVersion(ConstantsConfig.FORMAT_VERSION);\n+        internalRouterConfiguration.setRequestId(requestId);\n+        internalRouterConfiguration.setHostDvrMac(\"\");\n+        internalRouterConfiguration.setMessageType(MessageType.FULL);\n+\n+        internalRouterInfo.setOperationType(OperationType.INFO);\n+        internalRouterInfo.setRouterConfiguration(internalRouterConfiguration);\n+\n+        return internalRouterInfo;\n+\n+    }\n+\n+    private InternalRoutingRule constructNewInternalRoutingRule(OperationType operationType, RoutingRuleType routingRuleType, RouteEntry route, NewRoutesRequest newRouteRequest) {\n+        if (route == null && newRouteRequest == null) {\n+            return new InternalRoutingRule();\n+        }\n+\n+        InternalRoutingRule internalRoutingRule = new InternalRoutingRule();\n+\n+        InternalRoutingRuleExtraInfo routingRuleExtraInfo = new InternalRoutingRuleExtraInfo();\n+        //routingRuleExtraInfo.setNextHopMac();\n+        // TODO: insert destination type - if it is vpc router, configure value according to target\n+        routingRuleExtraInfo.setDestinationType(VpcRouteTarget.LOCAL);\n+\n+        if (route == null) {\n+            internalRoutingRule.setId(route.getId());\n+        } else {\n+            internalRoutingRule.setId(UUID.randomUUID().toString());\n+            internalRoutingRule.setName(route.getName());\n+        }\n+\n+        if (newRouteRequest != null) {\n+            internalRoutingRule.setDestination(newRouteRequest.getDestination());\n+        } else {\n+            internalRoutingRule.setDestination(route.getDestination());", "originalCommit": "590eea3dbe93fe7da2c87f6056035a502a445a33", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgzMjUwNg==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r532832506", "bodyText": "Actually it is same as the logic here, since we have to set RouteEntry route and NewRoutesRequest newRouteRequest in params", "author": "kevin-zhonghao", "createdAt": "2020-11-30T19:07:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY5ODIwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY5OTM4OQ==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r530699389", "bodyText": "if (newRouteRequest.getTarget() != null) we need to translate target label name to a real nexthop ip address and next_hop_mac in the 'routingRuleExtraInfo' entity by calling Gateway Manager.", "author": "cj-chung", "createdAt": "2020-11-25T23:57:12Z", "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/service/Impl/NeutronRouterServiceImpl.java", "diffHunk": "@@ -469,6 +468,197 @@ public ConnectedSubnetsWebResponse getConnectedSubnets(String projectId, String\n         return connectedSubnetsWebResponse;\n     }\n \n+    @Override\n+    public UpdateRoutingRuleResponse updateRoutingRule (String owner, NewRoutesWebRequest newRouteEntry, boolean isNeutronOrVPCLevelRoutingRule) throws DestinationOrNexthopCanNotBeNull, CacheException, CanNotFindRouteTableByOwner, QueryParamTypeNotSupportException, RouteTableNotUnique, DestinationInvalid {\n+        List<InternalRoutingRule> updateRoutes = new ArrayList<>();\n+        List<HostRoute> hostRouteToSubnet = new ArrayList<>();\n+\n+        List<NewRoutesRequest> routes = newRouteEntry.getRoutes();\n+        if (routes == null) {\n+            return new UpdateRoutingRuleResponse(new ArrayList<>(), hostRouteToSubnet);\n+        }\n+\n+        // find routeTable\n+        Map<String, String[]> requestParams =  new HashMap<>();\n+        String[] value = new String[1];\n+        value[0] = owner;\n+        requestParams.put(\"owner\", value);\n+\n+        Map<String, Object[]> queryParams =\n+                ControllerUtil.transformUrlPathParams(requestParams, RouteTable.class);\n+        Map<String, RouteTable> routeTableMap = this.routeTableDatabaseService.getAllRouteTables(queryParams);\n+        List<RouteTable> routeTables = new ArrayList<>(routeTableMap.values());\n+        if (routeTables == null || routeTables.size() == 0) {\n+            logger.log(Level.WARNING, \"owner: \" + owner);\n+            throw new CanNotFindRouteTableByOwner();\n+        } else if (routeTables.size() >= 2) {\n+            logger.log(Level.WARNING, \"owner: \" + owner);\n+            throw new RouteTableNotUnique();\n+        }\n+\n+        RouteTable existRouteTable = routeTables.get(0);\n+\n+        List<RouteEntry> existRoutes = existRouteTable.getRouteEntities();\n+        // TODO: existRoutes -> MAP: key - des(/\u524d\u9762\u7684), value - nexthop, \"10.0.0.0/16\"\n+        Map<String, RouteEntry> existRoutesMap = new HashMap<>();\n+        for (RouteEntry existRoute : existRoutes) {\n+            String[] existDes = existRoute.getDestination().split(\"\\\\/\");\n+            String existNetworkIP = existDes[0];\n+            existRoutesMap.put(existNetworkIP, existRoute);\n+        }\n+        // TODO: existRoutes replaced with map\n+        // Tracking operation type for each routing rule\n+        for (NewRoutesRequest newRouteRequest : routes) {\n+            //RouteEntry route = null;\n+            // TODO: 1. check new-des if it is valid\n+            String newRouteDestination = newRouteRequest.getDestination();\n+            String newRouteNexthop = newRouteRequest.getNexthop();\n+            boolean isDestinationValid = verifyCidrBlock(newRouteDestination);\n+            if (!isDestinationValid) {\n+                throw new DestinationInvalid(\"destination is invalid : \" + newRouteDestination);\n+            }\n+            String[] newRouteDes = newRouteDestination.split(\"\\\\/\");\n+            String newNetworkIP = newRouteDes[0];\n+            String newBitmask = newRouteDes[1];\n+            int newBitmaskInt = Integer.parseInt(newBitmask);\n+            // TODO: 2. flag check if it is from vpc/Neutron(lower priority) or subnet.\n+            RouteEntry existRoute = existRoutesMap.get(newNetworkIP);\n+            // dont find: Create (both)\n+            if (existRoute == null) {\n+                InternalRoutingRule internalRoutingRule = null;\n+                if (isNeutronOrVPCLevelRoutingRule) {\n+                    internalRoutingRule = constructNewInternalRoutingRule(OperationType.CREATE, RoutingRuleType.DEFAULT, existRoute, newRouteRequest);\n+                } else {\n+                    internalRoutingRule = constructNewInternalRoutingRule(OperationType.CREATE, RoutingRuleType.STATIC, existRoute, newRouteRequest);\n+                }\n+                String Des = internalRoutingRule.getDestination();\n+                String Nexthop = internalRoutingRule.getNextHopIp();\n+\n+                updateRoutes.add(internalRoutingRule);\n+                hostRouteToSubnet.add(new HostRoute(){{setNexthop(Nexthop);setDestination(Des);}});\n+\n+            } else { // could find:\n+                // compare which one cover the other one\n+                if (isNeutronOrVPCLevelRoutingRule) { // VPC/Neutron\n+                    String[] existDes = existRoute.getDestination().split(\"\\\\/\");\n+                    String existBitmask = existDes[1];\n+                    int existBitmaskInt = Integer.parseInt(existBitmask);\n+                    if (newBitmaskInt <= existBitmaskInt) { // new routing rule bitmask is smaller or equal than old one, drop it\n+                        continue;\n+                    } else { // new routing rule bitmask is larger than old one, Create new rule with low priority\n+\n+                        InternalRoutingRule internalRoutingRule = constructNewInternalRoutingRule(OperationType.CREATE, RoutingRuleType.DEFAULT, existRoute, newRouteRequest);\n+\n+                        updateRoutes.add(internalRoutingRule);\n+                        hostRouteToSubnet.add(new HostRoute(){{setNexthop(internalRoutingRule.getNextHopIp());setDestination(internalRoutingRule.getDestination());}});\n+\n+                    }\n+                } else { // Subnet\n+                    // new routing rule update old one without checking bitmask\n+                    InternalRoutingRule internalRoutingRule = constructNewInternalRoutingRule(OperationType.UPDATE, RoutingRuleType.STATIC, existRoute, newRouteRequest);\n+\n+                    updateRoutes.add(internalRoutingRule);\n+                    hostRouteToSubnet.add(new HostRoute(){{setNexthop(internalRoutingRule.getNextHopIp());setDestination(internalRoutingRule.getDestination());}});\n+\n+                    existRoutesMap.remove(newNetworkIP);\n+                }\n+\n+            }\n+\n+        }\n+\n+        for (Map.Entry<String, RouteEntry> existRouteEntry : existRoutesMap.entrySet()) {\n+            RouteEntry existRoute = (RouteEntry)existRouteEntry.getValue();\n+            InternalRoutingRule internalRoutingRule = constructNewInternalRoutingRule(OperationType.DELETE, RoutingRuleType.DEFAULT, existRoute, null);\n+\n+            updateRoutes.add(internalRoutingRule);\n+\n+        }\n+\n+        // construct List<InternalSubnetRoutingTable>\n+        List<InternalSubnetRoutingTable> subnetRoutingTables = new ArrayList<>();\n+\n+        InternalSubnetRoutingTable internalSubnetRoutingTable = new InternalSubnetRoutingTable();\n+        if (owner != null) {\n+            internalSubnetRoutingTable.setSubnetId(owner);\n+        } else {\n+            internalSubnetRoutingTable.setSubnetId(existRouteTable.getOwner());\n+        }\n+        internalSubnetRoutingTable.setRoutingRules(updateRoutes);\n+        subnetRoutingTables.add(internalSubnetRoutingTable);\n+\n+        // construct UpdateRoutingRuleResponse\n+        UpdateRoutingRuleResponse updateRoutingRuleResponse = new UpdateRoutingRuleResponse(subnetRoutingTables, hostRouteToSubnet);\n+\n+        return updateRoutingRuleResponse;\n+    }\n+\n+    @Override\n+    public InternalRouterInfo constructInternalRouterInfo (List<InternalSubnetRoutingTable> internalSubnetRoutingTableList) {\n+\n+        String requestId = UUID.randomUUID().toString();\n+        InternalRouterInfo internalRouterInfo = new InternalRouterInfo();\n+\n+        InternalRouterConfiguration internalRouterConfiguration = new InternalRouterConfiguration();\n+\n+        internalRouterConfiguration.setSubnetRoutingTables(internalSubnetRoutingTableList);\n+\n+        internalRouterConfiguration.setRevisionNumber(ConstantsConfig.REVISION_NUMBER);\n+        internalRouterConfiguration.setFormatVersion(ConstantsConfig.FORMAT_VERSION);\n+        internalRouterConfiguration.setRequestId(requestId);\n+        internalRouterConfiguration.setHostDvrMac(\"\");\n+        internalRouterConfiguration.setMessageType(MessageType.FULL);\n+\n+        internalRouterInfo.setOperationType(OperationType.INFO);\n+        internalRouterInfo.setRouterConfiguration(internalRouterConfiguration);\n+\n+        return internalRouterInfo;\n+\n+    }\n+\n+    private InternalRoutingRule constructNewInternalRoutingRule(OperationType operationType, RoutingRuleType routingRuleType, RouteEntry route, NewRoutesRequest newRouteRequest) {\n+        if (route == null && newRouteRequest == null) {\n+            return new InternalRoutingRule();\n+        }\n+\n+        InternalRoutingRule internalRoutingRule = new InternalRoutingRule();\n+\n+        InternalRoutingRuleExtraInfo routingRuleExtraInfo = new InternalRoutingRuleExtraInfo();\n+        //routingRuleExtraInfo.setNextHopMac();\n+        // TODO: insert destination type - if it is vpc router, configure value according to target\n+        routingRuleExtraInfo.setDestinationType(VpcRouteTarget.LOCAL);\n+\n+        if (route == null) {\n+            internalRoutingRule.setId(route.getId());\n+        } else {\n+            internalRoutingRule.setId(UUID.randomUUID().toString());\n+            internalRoutingRule.setName(route.getName());\n+        }\n+\n+        if (newRouteRequest != null) {\n+            internalRoutingRule.setDestination(newRouteRequest.getDestination());\n+        } else {\n+            internalRoutingRule.setDestination(route.getDestination());\n+        }\n+        // TODO: translate target to nextHop - it is vpc router operation\n+        if (newRouteRequest != null) {\n+            internalRoutingRule.setNextHopIp(newRouteRequest.getNexthop());", "originalCommit": "590eea3dbe93fe7da2c87f6056035a502a445a33", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY5OTU2Mw==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r530699563", "bodyText": "priority property is an integer, how do you plan to convert these string to integer?", "author": "cj-chung", "createdAt": "2020-11-25T23:57:54Z", "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/service/Impl/NeutronRouterServiceImpl.java", "diffHunk": "@@ -469,6 +468,197 @@ public ConnectedSubnetsWebResponse getConnectedSubnets(String projectId, String\n         return connectedSubnetsWebResponse;\n     }\n \n+    @Override\n+    public UpdateRoutingRuleResponse updateRoutingRule (String owner, NewRoutesWebRequest newRouteEntry, boolean isNeutronOrVPCLevelRoutingRule) throws DestinationOrNexthopCanNotBeNull, CacheException, CanNotFindRouteTableByOwner, QueryParamTypeNotSupportException, RouteTableNotUnique, DestinationInvalid {\n+        List<InternalRoutingRule> updateRoutes = new ArrayList<>();\n+        List<HostRoute> hostRouteToSubnet = new ArrayList<>();\n+\n+        List<NewRoutesRequest> routes = newRouteEntry.getRoutes();\n+        if (routes == null) {\n+            return new UpdateRoutingRuleResponse(new ArrayList<>(), hostRouteToSubnet);\n+        }\n+\n+        // find routeTable\n+        Map<String, String[]> requestParams =  new HashMap<>();\n+        String[] value = new String[1];\n+        value[0] = owner;\n+        requestParams.put(\"owner\", value);\n+\n+        Map<String, Object[]> queryParams =\n+                ControllerUtil.transformUrlPathParams(requestParams, RouteTable.class);\n+        Map<String, RouteTable> routeTableMap = this.routeTableDatabaseService.getAllRouteTables(queryParams);\n+        List<RouteTable> routeTables = new ArrayList<>(routeTableMap.values());\n+        if (routeTables == null || routeTables.size() == 0) {\n+            logger.log(Level.WARNING, \"owner: \" + owner);\n+            throw new CanNotFindRouteTableByOwner();\n+        } else if (routeTables.size() >= 2) {\n+            logger.log(Level.WARNING, \"owner: \" + owner);\n+            throw new RouteTableNotUnique();\n+        }\n+\n+        RouteTable existRouteTable = routeTables.get(0);\n+\n+        List<RouteEntry> existRoutes = existRouteTable.getRouteEntities();\n+        // TODO: existRoutes -> MAP: key - des(/\u524d\u9762\u7684), value - nexthop, \"10.0.0.0/16\"\n+        Map<String, RouteEntry> existRoutesMap = new HashMap<>();\n+        for (RouteEntry existRoute : existRoutes) {\n+            String[] existDes = existRoute.getDestination().split(\"\\\\/\");\n+            String existNetworkIP = existDes[0];\n+            existRoutesMap.put(existNetworkIP, existRoute);\n+        }\n+        // TODO: existRoutes replaced with map\n+        // Tracking operation type for each routing rule\n+        for (NewRoutesRequest newRouteRequest : routes) {\n+            //RouteEntry route = null;\n+            // TODO: 1. check new-des if it is valid\n+            String newRouteDestination = newRouteRequest.getDestination();\n+            String newRouteNexthop = newRouteRequest.getNexthop();\n+            boolean isDestinationValid = verifyCidrBlock(newRouteDestination);\n+            if (!isDestinationValid) {\n+                throw new DestinationInvalid(\"destination is invalid : \" + newRouteDestination);\n+            }\n+            String[] newRouteDes = newRouteDestination.split(\"\\\\/\");\n+            String newNetworkIP = newRouteDes[0];\n+            String newBitmask = newRouteDes[1];\n+            int newBitmaskInt = Integer.parseInt(newBitmask);\n+            // TODO: 2. flag check if it is from vpc/Neutron(lower priority) or subnet.\n+            RouteEntry existRoute = existRoutesMap.get(newNetworkIP);\n+            // dont find: Create (both)\n+            if (existRoute == null) {\n+                InternalRoutingRule internalRoutingRule = null;\n+                if (isNeutronOrVPCLevelRoutingRule) {\n+                    internalRoutingRule = constructNewInternalRoutingRule(OperationType.CREATE, RoutingRuleType.DEFAULT, existRoute, newRouteRequest);\n+                } else {\n+                    internalRoutingRule = constructNewInternalRoutingRule(OperationType.CREATE, RoutingRuleType.STATIC, existRoute, newRouteRequest);\n+                }\n+                String Des = internalRoutingRule.getDestination();\n+                String Nexthop = internalRoutingRule.getNextHopIp();\n+\n+                updateRoutes.add(internalRoutingRule);\n+                hostRouteToSubnet.add(new HostRoute(){{setNexthop(Nexthop);setDestination(Des);}});\n+\n+            } else { // could find:\n+                // compare which one cover the other one\n+                if (isNeutronOrVPCLevelRoutingRule) { // VPC/Neutron\n+                    String[] existDes = existRoute.getDestination().split(\"\\\\/\");\n+                    String existBitmask = existDes[1];\n+                    int existBitmaskInt = Integer.parseInt(existBitmask);\n+                    if (newBitmaskInt <= existBitmaskInt) { // new routing rule bitmask is smaller or equal than old one, drop it\n+                        continue;\n+                    } else { // new routing rule bitmask is larger than old one, Create new rule with low priority\n+\n+                        InternalRoutingRule internalRoutingRule = constructNewInternalRoutingRule(OperationType.CREATE, RoutingRuleType.DEFAULT, existRoute, newRouteRequest);\n+\n+                        updateRoutes.add(internalRoutingRule);\n+                        hostRouteToSubnet.add(new HostRoute(){{setNexthop(internalRoutingRule.getNextHopIp());setDestination(internalRoutingRule.getDestination());}});\n+\n+                    }\n+                } else { // Subnet\n+                    // new routing rule update old one without checking bitmask\n+                    InternalRoutingRule internalRoutingRule = constructNewInternalRoutingRule(OperationType.UPDATE, RoutingRuleType.STATIC, existRoute, newRouteRequest);\n+\n+                    updateRoutes.add(internalRoutingRule);\n+                    hostRouteToSubnet.add(new HostRoute(){{setNexthop(internalRoutingRule.getNextHopIp());setDestination(internalRoutingRule.getDestination());}});\n+\n+                    existRoutesMap.remove(newNetworkIP);\n+                }\n+\n+            }\n+\n+        }\n+\n+        for (Map.Entry<String, RouteEntry> existRouteEntry : existRoutesMap.entrySet()) {\n+            RouteEntry existRoute = (RouteEntry)existRouteEntry.getValue();\n+            InternalRoutingRule internalRoutingRule = constructNewInternalRoutingRule(OperationType.DELETE, RoutingRuleType.DEFAULT, existRoute, null);\n+\n+            updateRoutes.add(internalRoutingRule);\n+\n+        }\n+\n+        // construct List<InternalSubnetRoutingTable>\n+        List<InternalSubnetRoutingTable> subnetRoutingTables = new ArrayList<>();\n+\n+        InternalSubnetRoutingTable internalSubnetRoutingTable = new InternalSubnetRoutingTable();\n+        if (owner != null) {\n+            internalSubnetRoutingTable.setSubnetId(owner);\n+        } else {\n+            internalSubnetRoutingTable.setSubnetId(existRouteTable.getOwner());\n+        }\n+        internalSubnetRoutingTable.setRoutingRules(updateRoutes);\n+        subnetRoutingTables.add(internalSubnetRoutingTable);\n+\n+        // construct UpdateRoutingRuleResponse\n+        UpdateRoutingRuleResponse updateRoutingRuleResponse = new UpdateRoutingRuleResponse(subnetRoutingTables, hostRouteToSubnet);\n+\n+        return updateRoutingRuleResponse;\n+    }\n+\n+    @Override\n+    public InternalRouterInfo constructInternalRouterInfo (List<InternalSubnetRoutingTable> internalSubnetRoutingTableList) {\n+\n+        String requestId = UUID.randomUUID().toString();\n+        InternalRouterInfo internalRouterInfo = new InternalRouterInfo();\n+\n+        InternalRouterConfiguration internalRouterConfiguration = new InternalRouterConfiguration();\n+\n+        internalRouterConfiguration.setSubnetRoutingTables(internalSubnetRoutingTableList);\n+\n+        internalRouterConfiguration.setRevisionNumber(ConstantsConfig.REVISION_NUMBER);\n+        internalRouterConfiguration.setFormatVersion(ConstantsConfig.FORMAT_VERSION);\n+        internalRouterConfiguration.setRequestId(requestId);\n+        internalRouterConfiguration.setHostDvrMac(\"\");\n+        internalRouterConfiguration.setMessageType(MessageType.FULL);\n+\n+        internalRouterInfo.setOperationType(OperationType.INFO);\n+        internalRouterInfo.setRouterConfiguration(internalRouterConfiguration);\n+\n+        return internalRouterInfo;\n+\n+    }\n+\n+    private InternalRoutingRule constructNewInternalRoutingRule(OperationType operationType, RoutingRuleType routingRuleType, RouteEntry route, NewRoutesRequest newRouteRequest) {\n+        if (route == null && newRouteRequest == null) {\n+            return new InternalRoutingRule();\n+        }\n+\n+        InternalRoutingRule internalRoutingRule = new InternalRoutingRule();\n+\n+        InternalRoutingRuleExtraInfo routingRuleExtraInfo = new InternalRoutingRuleExtraInfo();\n+        //routingRuleExtraInfo.setNextHopMac();\n+        // TODO: insert destination type - if it is vpc router, configure value according to target\n+        routingRuleExtraInfo.setDestinationType(VpcRouteTarget.LOCAL);\n+\n+        if (route == null) {\n+            internalRoutingRule.setId(route.getId());\n+        } else {\n+            internalRoutingRule.setId(UUID.randomUUID().toString());\n+            internalRoutingRule.setName(route.getName());\n+        }\n+\n+        if (newRouteRequest != null) {\n+            internalRoutingRule.setDestination(newRouteRequest.getDestination());\n+        } else {\n+            internalRoutingRule.setDestination(route.getDestination());\n+        }\n+        // TODO: translate target to nextHop - it is vpc router operation\n+        if (newRouteRequest != null) {\n+            internalRoutingRule.setNextHopIp(newRouteRequest.getNexthop());\n+        } else {\n+            internalRoutingRule.setNextHopIp(route.getNexthop());\n+        }\n+        // TODO: set priority - configure priority according to RoutingRuleType\n+        if (routingRuleType.getRoutingRuleType().equals(ConstantsConfig.DEFAULT_ROUTINGRULETYPE)) {\n+            internalRoutingRule.setPriority(ConstantsConfig.LOW_PRIORITY);\n+        } else if (routingRuleType.getRoutingRuleType().equals(ConstantsConfig.STATIC_ROUTINGRULETYPE)) {\n+            internalRoutingRule.setPriority(ConstantsConfig.HIGH_PRIORITY);", "originalCommit": "590eea3dbe93fe7da2c87f6056035a502a445a33", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgzMDQ0NA==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r532830444", "bodyText": "It is a String actually ~", "author": "kevin-zhonghao", "createdAt": "2020-11-30T19:03:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY5OTU2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDcwMTUyNQ==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r530701525", "bodyText": "Does PM has bulk create/query by a list of IP addresses?\nIf there is, we can just make an API call and do a batch process.", "author": "cj-chung", "createdAt": "2020-11-26T00:05:46Z", "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/service/Impl/RouterToPMServiceImpl.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+Copyright 2019 The Alcor Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+        you may not use this file except in compliance with the License.\n+        You may obtain a copy of the License at\n+\n+        http://www.apache.org/licenses/LICENSE-2.0\n+\n+        Unless required by applicable law or agreed to in writing, software\n+        distributed under the License is distributed on an \"AS IS\" BASIS,\n+        WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+        See the License for the specific language governing permissions and\n+        limitations under the License.\n+*/\n+package com.futurewei.alcor.route.service.Impl;\n+\n+import com.futurewei.alcor.route.exception.PortWebJsonOrPortEntityIsNull;\n+import com.futurewei.alcor.route.service.RouterToPMService;\n+import com.futurewei.alcor.web.entity.port.PortEntity;\n+import com.futurewei.alcor.web.entity.port.PortWebJson;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Service;\n+import org.springframework.web.client.RestTemplate;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+@Service\n+public class RouterToPMServiceImpl implements RouterToPMService {\n+\n+    @Value(\"${microservices.port.service.url}\")\n+    private String portUrl;\n+\n+    private RestTemplate restTemplate = new RestTemplate();\n+\n+    @Override\n+    public List<String> getSubnetIdsFromPM(String projectid, List<String> gatewayPorts) throws PortWebJsonOrPortEntityIsNull {\n+        if (gatewayPorts == null) {\n+            return null;\n+        }\n+\n+        List<String> subnetIds = new ArrayList<>();\n+        for (String gatewayPortId : gatewayPorts) {\n+            String portManagerServiceUrl = portUrl + \"/project/\" + projectid + \"/ports/\" + gatewayPortId;\n+            PortWebJson portResponse = restTemplate.getForObject(portManagerServiceUrl, PortWebJson.class);", "originalCommit": "590eea3dbe93fe7da2c87f6056035a502a445a33", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgzMDI3MQ==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r532830271", "bodyText": "Yes, PM has bulk create/query API. But here we query PortEntity by port id, right?", "author": "kevin-zhonghao", "createdAt": "2020-11-30T19:03:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDcwMTUyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDcwNTE3Mw==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r530705173", "bodyText": "What if update failed?", "author": "cj-chung", "createdAt": "2020-11-26T00:21:01Z", "path": "services/subnet_manager/src/main/java/com/futurewei/alcor/subnet/service/implement/SubnetToPortManagerServiceImpl.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+Copyright 2019 The Alcor Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+        you may not use this file except in compliance with the License.\n+        You may obtain a copy of the License at\n+\n+        http://www.apache.org/licenses/LICENSE-2.0\n+\n+        Unless required by applicable law or agreed to in writing, software\n+        distributed under the License is distributed on an \"AS IS\" BASIS,\n+        WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+        See the License for the specific language governing permissions and\n+        limitations under the License.\n+*/\n+package com.futurewei.alcor.subnet.service.implement;\n+\n+import com.futurewei.alcor.subnet.exception.PortWebJsonOrPortEntityIsNull;\n+import com.futurewei.alcor.subnet.service.SubnetToPortManagerService;\n+import com.futurewei.alcor.web.entity.port.PortEntity;\n+import com.futurewei.alcor.web.entity.port.PortWebJson;\n+import com.futurewei.alcor.web.entity.subnet.GatewayPortDetail;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.http.HttpEntity;\n+import org.springframework.stereotype.Service;\n+import org.springframework.web.client.RestTemplate;\n+\n+@Service\n+public class SubnetToPortManagerServiceImpl implements SubnetToPortManagerService {\n+\n+    private Logger logger = LoggerFactory.getLogger(this.getClass());\n+\n+    @Value(\"${microservices.port.service.url}\")\n+    private String portUrl;\n+\n+    private RestTemplate restTemplate = new RestTemplate();\n+\n+    @Override\n+    public GatewayPortDetail createGatewayPort(String projectId, PortEntity portEntity) throws Exception {\n+        String portManagerServiceUrl = portUrl + \"project/\" + projectId + \"/ports\";\n+        HttpEntity<PortWebJson> portRequest = new HttpEntity<>(new PortWebJson(portEntity));\n+        PortWebJson portResponse = restTemplate.postForObject(portManagerServiceUrl, portRequest, PortWebJson.class);\n+        if (portResponse == null) {\n+            throw new PortWebJsonOrPortEntityIsNull();\n+        }\n+\n+        PortEntity portEntityResponse = portResponse.getPortEntity();\n+        if (portEntityResponse == null) {\n+            throw new PortWebJsonOrPortEntityIsNull();\n+        }\n+\n+        GatewayPortDetail gatewayPortDetail = new GatewayPortDetail(portEntityResponse.getMacAddress(), portEntityResponse.getId());\n+\n+        return gatewayPortDetail;\n+    }\n+\n+    @Override\n+    public void updateGatewayPort(String projectId, String portId, PortEntity portEntity) throws Exception {\n+        String portManagerServiceUrl = portUrl + \"project/\" + projectId + \"/ports/\" + portId;\n+        HttpEntity<PortWebJson> portRequest = new HttpEntity<>(new PortWebJson(portEntity));\n+        restTemplate.put(portManagerServiceUrl, portRequest, PortWebJson.class);\n+    }", "originalCommit": "590eea3dbe93fe7da2c87f6056035a502a445a33", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDcwNTI5OQ==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r530705299", "bodyText": "What if delete failed?", "author": "cj-chung", "createdAt": "2020-11-26T00:21:29Z", "path": "services/subnet_manager/src/main/java/com/futurewei/alcor/subnet/service/implement/SubnetToPortManagerServiceImpl.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+Copyright 2019 The Alcor Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+        you may not use this file except in compliance with the License.\n+        You may obtain a copy of the License at\n+\n+        http://www.apache.org/licenses/LICENSE-2.0\n+\n+        Unless required by applicable law or agreed to in writing, software\n+        distributed under the License is distributed on an \"AS IS\" BASIS,\n+        WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+        See the License for the specific language governing permissions and\n+        limitations under the License.\n+*/\n+package com.futurewei.alcor.subnet.service.implement;\n+\n+import com.futurewei.alcor.subnet.exception.PortWebJsonOrPortEntityIsNull;\n+import com.futurewei.alcor.subnet.service.SubnetToPortManagerService;\n+import com.futurewei.alcor.web.entity.port.PortEntity;\n+import com.futurewei.alcor.web.entity.port.PortWebJson;\n+import com.futurewei.alcor.web.entity.subnet.GatewayPortDetail;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.http.HttpEntity;\n+import org.springframework.stereotype.Service;\n+import org.springframework.web.client.RestTemplate;\n+\n+@Service\n+public class SubnetToPortManagerServiceImpl implements SubnetToPortManagerService {\n+\n+    private Logger logger = LoggerFactory.getLogger(this.getClass());\n+\n+    @Value(\"${microservices.port.service.url}\")\n+    private String portUrl;\n+\n+    private RestTemplate restTemplate = new RestTemplate();\n+\n+    @Override\n+    public GatewayPortDetail createGatewayPort(String projectId, PortEntity portEntity) throws Exception {\n+        String portManagerServiceUrl = portUrl + \"project/\" + projectId + \"/ports\";\n+        HttpEntity<PortWebJson> portRequest = new HttpEntity<>(new PortWebJson(portEntity));\n+        PortWebJson portResponse = restTemplate.postForObject(portManagerServiceUrl, portRequest, PortWebJson.class);\n+        if (portResponse == null) {\n+            throw new PortWebJsonOrPortEntityIsNull();\n+        }\n+\n+        PortEntity portEntityResponse = portResponse.getPortEntity();\n+        if (portEntityResponse == null) {\n+            throw new PortWebJsonOrPortEntityIsNull();\n+        }\n+\n+        GatewayPortDetail gatewayPortDetail = new GatewayPortDetail(portEntityResponse.getMacAddress(), portEntityResponse.getId());\n+\n+        return gatewayPortDetail;\n+    }\n+\n+    @Override\n+    public void updateGatewayPort(String projectId, String portId, PortEntity portEntity) throws Exception {\n+        String portManagerServiceUrl = portUrl + \"project/\" + projectId + \"/ports/\" + portId;\n+        HttpEntity<PortWebJson> portRequest = new HttpEntity<>(new PortWebJson(portEntity));\n+        restTemplate.put(portManagerServiceUrl, portRequest, PortWebJson.class);\n+    }\n+\n+    @Override\n+    public PortEntity getGatewayPortByPortID(String projectId, String portId) throws Exception {\n+        String portManagerServiceUrl = portUrl + \"project/\" + projectId + \"/ports/\" + portId;\n+        PortWebJson portResponse = restTemplate.getForObject(portManagerServiceUrl, PortWebJson.class);\n+        if (portResponse == null) {\n+            throw new PortWebJsonOrPortEntityIsNull();\n+        }\n+\n+        PortEntity portEntityResponse = portResponse.getPortEntity();\n+        if (portEntityResponse == null) {\n+            throw new PortWebJsonOrPortEntityIsNull();\n+        }\n+\n+        return portEntityResponse;\n+    }\n+\n+    @Override\n+    public void deleteGatewayPort(String projectId, String portId) throws Exception {\n+        String portManagerServiceUrl = portUrl + \"project/\" + projectId + \"/ports/\" + portId;\n+        restTemplate.delete(portManagerServiceUrl);\n+    }", "originalCommit": "590eea3dbe93fe7da2c87f6056035a502a445a33", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDcwNTU2Mw==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r530705563", "bodyText": "we don't use default_routing_table anymore.", "author": "cj-chung", "createdAt": "2020-11-26T00:22:33Z", "path": "web/src/main/java/com/futurewei/alcor/web/entity/route/InternalRouterConfiguration.java", "diffHunk": "@@ -38,6 +38,9 @@\n     @JsonProperty(\"host_dvr_mac\")\n     private String host_dvr_mac;\n \n+    @JsonProperty(\"default_routing_table\")\n+    private List<InternalRoutingRule> default_routing_table;\n+", "originalCommit": "590eea3dbe93fe7da2c87f6056035a502a445a33", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgyMTk4Ng==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r532821986", "bodyText": "Removed", "author": "kevin-zhonghao", "createdAt": "2020-11-30T18:49:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDcwNTU2Mw=="}], "type": "inlineReview"}, {"oid": "0b67d824f7789c8ee3825f4783837acab1708221", "url": "https://github.com/futurewei-cloud/alcor/commit/0b67d824f7789c8ee3825f4783837acab1708221", "message": "update", "committedDate": "2020-11-30T22:53:04Z", "type": "commit"}, {"oid": "ff129d1af28b84d11624f14947bc0bab6dbcebaa", "url": "https://github.com/futurewei-cloud/alcor/commit/ff129d1af28b84d11624f14947bc0bab6dbcebaa", "message": "update", "committedDate": "2020-12-01T23:55:17Z", "type": "commit"}, {"oid": "9736111871ce612d55022f165eb379413a4b2df5", "url": "https://github.com/futurewei-cloud/alcor/commit/9736111871ce612d55022f165eb379413a4b2df5", "message": "update", "committedDate": "2020-12-02T00:42:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzgzNjA5OA==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r533836098", "bodyText": "Add comments.", "author": "xieus", "createdAt": "2020-12-02T01:31:13Z", "path": "services/port_manager/src/main/java/com/futurewei/alcor/portmanager/processor/FixedIpsProcessor.java", "diffHunk": "@@ -297,6 +297,9 @@ private void allocateFixedIpsProcess(PortContext context, List<PortEntity> portE\n \n         for (PortEntity portEntity: portEntities){\n             List<PortEntity.FixedIp> fixedIps = portEntity.getFixedIps();\n+            if (portEntity.isGatewayPort()) {\n+                continue;\n+            }", "originalCommit": "9736111871ce612d55022f165eb379413a4b2df5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzgzNjU2NA==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r533836564", "bodyText": "@chenpiaoping Could you pls review this change? I raised a question on Slack channel regarding why we need to reevaluate subnet and route after allocating IP address.", "author": "xieus", "createdAt": "2020-12-02T01:32:33Z", "path": "services/port_manager/src/main/java/com/futurewei/alcor/portmanager/processor/FixedIpsProcessor.java", "diffHunk": "@@ -284,7 +284,7 @@ private void allocateRandomIpCallback(IRestRequest request) throws Exception {\n             subnetIds.add(fixedIp.getSubnetId());\n         }\n \n-        getSubnetAndRoute(context, new ArrayList<>(subnetIds));\n+        //getSubnetAndRoute(context, new ArrayList<>(subnetIds));", "originalCommit": "9736111871ce612d55022f165eb379413a4b2df5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c61733fc0a105856b551901531d7b44296f11a73", "url": "https://github.com/futurewei-cloud/alcor/commit/c61733fc0a105856b551901531d7b44296f11a73", "message": "update", "committedDate": "2020-12-02T01:35:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg2OTk4NQ==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r533869985", "bodyText": "Please remove and cleanup the commented codes. @kevin-zhonghao", "author": "xieus", "createdAt": "2020-12-02T03:20:58Z", "path": "services/subnet_manager/src/main/java/com/futurewei/alcor/subnet/controller/SubnetController.java", "diffHunk": "@@ -214,19 +221,19 @@ public SubnetWebJson createSubnetState(@PathVariable String projectId, @RequestB\n             this.subnetService.checkIfCidrOverlap(cidr, projectId, vpcId);\n \n             //Allocate Gateway Mac\n-            CompletableFuture<MacStateJson> macFuture = CompletableFuture.supplyAsync(() -> {\n-                try {\n-                    return this.subnetService.allocateMacAddressForGatewayPort(projectId, vpcId, portId);\n-                } catch (Exception e) {\n-                    throw new CompletionException(e);\n-                }\n-            }, ThreadPoolExecutorUtils.SELECT_POOL_EXECUTOR).handle((s, e) -> {\n-                macResponseAtomic.set(s);\n-                if (e != null) {\n-                    throw new CompletionException(e);\n-                }\n-                return s;\n-            });\n+//            CompletableFuture<MacStateJson> macFuture = CompletableFuture.supplyAsync(() -> {\n+//                try {\n+//                    return this.subnetService.allocateMacAddressForGatewayPort(projectId, vpcId, portId);\n+//                } catch (Exception e) {\n+//                    throw new CompletionException(e);\n+//                }\n+//            }, ThreadPoolExecutorUtils.SELECT_POOL_EXECUTOR).handle((s, e) -> {\n+//                macResponseAtomic.set(s);\n+//                if (e != null) {\n+//                    throw new CompletionException(e);\n+//                }\n+//                return s;\n+//            });", "originalCommit": "c61733fc0a105856b551901531d7b44296f11a73", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg3MDA2Mg==", "url": "https://github.com/futurewei-cloud/alcor/pull/468#discussion_r533870062", "bodyText": "Same here.", "author": "xieus", "createdAt": "2020-12-02T03:21:13Z", "path": "services/subnet_manager/src/main/java/com/futurewei/alcor/subnet/controller/SubnetController.java", "diffHunk": "@@ -284,18 +292,24 @@ public SubnetWebJson createSubnetState(@PathVariable String projectId, @RequestB\n             routeEntities.add(routeResponse.getRoute());\n             inSubnetEntity.setRouteEntities(routeEntities);\n \n-            MacState macState = macResponse.getMacState();\n-            if (macState != null) {\n-                inSubnetEntity.setGatewayMacAddress(macState.getMacAddress());\n-            }\n+//            MacState macState = macResponse.getMacState();\n+//            if (macState != null) {\n+//                inSubnetEntity.setGatewayMacAddress(macState.getMacAddress());\n+//            }", "originalCommit": "c61733fc0a105856b551901531d7b44296f11a73", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}