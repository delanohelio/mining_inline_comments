{"pr_number": 14623, "pr_title": "Bratseth/defer ip address allocation", "pr_createdAt": "2020-09-29T17:37:29Z", "pr_url": "https://github.com/vespa-engine/vespa/pull/14623", "timeline": [{"oid": "3d05f38f1f67b7be20346878ea0c8fa0547c18a4", "url": "https://github.com/vespa-engine/vespa/commit/3d05f38f1f67b7be20346878ea0c8fa0547c18a4", "message": "Add Nodelike interface", "committedDate": "2020-09-29T09:27:02Z", "type": "commit"}, {"oid": "8385e15c0bbca0ccc1030a949c6f2dd346b3a013", "url": "https://github.com/vespa-engine/vespa/commit/8385e15c0bbca0ccc1030a949c6f2dd346b3a013", "message": "Avoid candidate node field access", "committedDate": "2020-09-29T10:16:39Z", "type": "commit"}, {"oid": "7cd6975779e424422cee39ffccc2c37ea2acd9ff", "url": "https://github.com/vespa-engine/vespa/commit/7cd6975779e424422cee39ffccc2c37ea2acd9ff", "message": "Avoid candidate node field access", "committedDate": "2020-09-29T10:40:52Z", "type": "commit"}, {"oid": "4d89e203f2583a7e7e7025ff1b86a462d67ebb71", "url": "https://github.com/vespa-engine/vespa/commit/4d89e203f2583a7e7e7025ff1b86a462d67ebb71", "message": "Avoid candidate node field access", "committedDate": "2020-09-29T10:52:33Z", "type": "commit"}, {"oid": "d70e79bf0a1d5c9c985bcb8be2f64d94fa11da6f", "url": "https://github.com/vespa-engine/vespa/commit/d70e79bf0a1d5c9c985bcb8be2f64d94fa11da6f", "message": "Split candidate into concrete and virtual", "committedDate": "2020-09-29T11:17:55Z", "type": "commit"}, {"oid": "fff00d462d0bc17b11b5cf0cd7413eeb1d4cf8aa", "url": "https://github.com/vespa-engine/vespa/commit/fff00d462d0bc17b11b5cf0cd7413eeb1d4cf8aa", "message": "Enumerate possibilities instead of using builder", "committedDate": "2020-09-29T12:23:15Z", "type": "commit"}, {"oid": "3ddad1bb2634d88883212f5d8b3ae751ee2a6836", "url": "https://github.com/vespa-engine/vespa/commit/3ddad1bb2634d88883212f5d8b3ae751ee2a6836", "message": "Remove test only option", "committedDate": "2020-09-29T12:29:26Z", "type": "commit"}, {"oid": "152632c8aa7a850de899bc1feb18f5e35fde300d", "url": "https://github.com/vespa-engine/vespa/commit/152632c8aa7a850de899bc1feb18f5e35fde300d", "message": "Call creator directly", "committedDate": "2020-09-29T16:49:24Z", "type": "commit"}, {"oid": "4a42076a45a2ec318577b4d12a52bb030f1fa99b", "url": "https://github.com/vespa-engine/vespa/commit/4a42076a45a2ec318577b4d12a52bb030f1fa99b", "message": "Simplify", "committedDate": "2020-09-29T16:55:45Z", "type": "commit"}, {"oid": "b20ca12a28bcd5dcb022f445b3f5d67a8dbd0330", "url": "https://github.com/vespa-engine/vespa/commit/b20ca12a28bcd5dcb022f445b3f5d67a8dbd0330", "message": "Defer creation of new child nodes until they are selected", "committedDate": "2020-09-29T17:28:46Z", "type": "commit"}, {"oid": "d254d8378f398ea6e90e2dcf0e270516c4fd1654", "url": "https://github.com/vespa-engine/vespa/commit/d254d8378f398ea6e90e2dcf0e270516c4fd1654", "message": "Cleanup", "committedDate": "2020-09-29T17:31:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk1MTI0Nw==", "url": "https://github.com/vespa-engine/vespa/pull/14623#discussion_r496951247", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                /** Returns the hostname oif the parent if this is a child node */\n          \n          \n            \n                /** Returns the hostname of the parent if this is a child node */", "author": "freva", "createdAt": "2020-09-29T18:28:47Z", "path": "node-repository/src/main/java/com/yahoo/vespa/hosted/provision/Nodelike.java", "diffHunk": "@@ -0,0 +1,23 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+package com.yahoo.vespa.hosted.provision;\n+\n+import com.yahoo.config.provision.NodeResources;\n+import com.yahoo.config.provision.NodeType;\n+\n+import java.util.Optional;\n+\n+/**\n+ * The API of anything that can behave essentially like a node.\n+ *\n+ * @author bratseth\n+ */\n+public interface Nodelike {\n+\n+    NodeResources resources();\n+\n+    /** Returns the hostname oif the parent if this is a child node */", "originalCommit": "3d05f38f1f67b7be20346878ea0c8fa0547c18a4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA2NDUyNA==", "url": "https://github.com/vespa-engine/vespa/pull/14623#discussion_r497064524", "bodyText": "The old code would just advance to the next node if resolving failing. If we get a node with broken IP, the allocation will basically not succeed until manual intervention since it would keep trying the same node? We should catch this and try next node if this fails.\nAlso, lets drop the stack trace for this, see #14599", "author": "freva", "createdAt": "2020-09-29T21:16:12Z", "path": "node-repository/src/main/java/com/yahoo/vespa/hosted/provision/provisioning/NodeCandidate.java", "diffHunk": "@@ -159,76 +186,174 @@ private double skewWith(NodeResources resources) {\n     }\n \n     private boolean isInNodeRepoAndReserved() {\n-        if (isNewNode) return false;\n-        return node.state().equals(Node.State.reserved);\n+        if (isNew) return false;\n+        return state().equals(Node.State.reserved);\n     }\n \n-    @Override\n-    public String toString() {\n-        return node.id();\n+    public static NodeCandidate createChild(Node node,\n+                                            NodeResources freeParentCapacity,\n+                                            Node parent,\n+                                            boolean violatesSpares,\n+                                            boolean isSurplus,\n+                                            boolean isNew,\n+                                            boolean isResizeable) {\n+        return new ConcreteNodeCandidate(node, freeParentCapacity, Optional.of(parent), violatesSpares, isSurplus, isNew, isResizeable);\n     }\n \n-    @Override\n-    public int hashCode() {\n-        return node.hashCode();\n+    public static NodeCandidate createNewChild(NodeResources resources,\n+                                               NodeResources freeParentCapacity,\n+                                               Node parent,\n+                                               boolean violatesSpares,\n+                                               LockedNodeList allNodes,\n+                                               NodeRepository nodeRepository) {\n+        return new VirtualNodeCandidate(resources, freeParentCapacity, parent, violatesSpares, allNodes, nodeRepository);\n     }\n \n-    @Override\n-    public boolean equals(Object other) {\n-        if (other == this) return true;\n-        if ( ! (other instanceof NodeCandidate)) return false;\n-        return this.node.equals(((NodeCandidate)other).node);\n+    public static NodeCandidate createNewExclusiveChild(Node node, Node parent) {\n+        return new ConcreteNodeCandidate(node, node.resources(), Optional.of(parent), false, false, true, false);\n     }\n \n-    static class Builder {\n+    public static NodeCandidate createStandalone(Node node, boolean isSurplus, boolean isNew) {\n+        return new ConcreteNodeCandidate(node, node.resources(), Optional.empty(), false, isSurplus, isNew, false);\n+    }\n+\n+    /** A candidate backed by a node */\n+    static class ConcreteNodeCandidate extends NodeCandidate {\n+\n+        private final Node node;\n+\n+        ConcreteNodeCandidate(Node node, NodeResources freeParentCapacity, Optional<Node> parent,\n+                              boolean violatesSpares,\n+                              boolean isSurplus, boolean isNew, boolean isResizeable) {\n+            super(freeParentCapacity, parent, violatesSpares, isSurplus, isNew, isResizeable);\n+            this.node = Objects.requireNonNull(node, \"Node cannot be null\");\n+        }\n+\n+        @Override\n+        public NodeResources resources() { return node.resources(); }\n+\n+        @Override\n+        public Optional<String> parentHostname() { return node.parentHostname(); }\n+\n+        @Override\n+        public NodeType type() { return node.type(); }\n \n-        public final Node node;\n-        private NodeResources freeParentCapacity;\n-        private Optional<Node> parent = Optional.empty();\n-        private boolean violatesSpares;\n-        private boolean isSurplusNode;\n-        private boolean isNewNode;\n-        private boolean isResizable;\n+        public Optional<Allocation> allocation() { return node.allocation(); }\n \n-        Builder(Node node) {\n-            this.node = node;\n-            this.freeParentCapacity = node.flavor().resources();\n+        public Node.State state() { return node.state(); }\n+\n+        public boolean wantToRetire() { return node.status().wantToRetire(); }\n+\n+        public Flavor flavor() { return node.flavor(); }\n+\n+        public NodeCandidate allocate(ApplicationId owner, ClusterMembership membership, NodeResources requestedResources, Instant at) {\n+            return new ConcreteNodeCandidate(node.allocate(owner, membership, requestedResources, at),\n+                                             freeParentCapacity, parent, violatesSpares, isSurplus, isNew, isResizable);\n         }\n \n-        /** The free capacity of the parent, before adding this node to it */\n-        Builder freeParentCapacity(NodeResources freeParentCapacity) {\n-            this.freeParentCapacity = freeParentCapacity;\n-            return this;\n+        /** Called when the node described by this candidate must be created */\n+        public NodeCandidate withNode() { return this; }\n+\n+        public Node toNode() { return node; }\n+\n+        @Override\n+        public int compareTo(NodeCandidate other) {\n+            int comparison = super.compareTo(other);\n+            if (comparison != 0) return comparison;\n+\n+            // Unimportant tie-breaking:\n+            if ( ! (other instanceof ConcreteNodeCandidate)) return -1;\n+            return this.node.hostname().compareTo(((ConcreteNodeCandidate)other).node.hostname());\n         }\n \n-        Builder parent(Node parent) {\n-            this.parent = Optional.of(parent);\n-            return this;\n+        @Override\n+        public String toString() {\n+            return node.id();\n         }\n \n-        Builder violatesSpares(boolean violatesSpares) {\n-            this.violatesSpares = violatesSpares;\n-            return this;\n+    }\n+\n+    /** A candidate for which no actual node has been created yet */\n+    static class VirtualNodeCandidate extends NodeCandidate {\n+\n+        /** The resources this node must have if created */\n+        private final NodeResources resources;\n+\n+        /** Needed to construct the node */\n+        private final LockedNodeList allNodes;\n+        private final NodeRepository nodeRepository;\n+\n+        private VirtualNodeCandidate(NodeResources resources,\n+                                     NodeResources freeParentCapacity,\n+                                     Node parent,\n+                                     boolean violatesSpares,\n+                                     LockedNodeList allNodes,\n+                                     NodeRepository nodeRepository) {\n+            super(freeParentCapacity, Optional.of(parent), violatesSpares, false, true, false);\n+            this.resources = resources;\n+            this.allNodes = allNodes;\n+            this.nodeRepository = nodeRepository;\n         }\n \n-        Builder surplusNode(boolean surplusNode) {\n-            isSurplusNode = surplusNode;\n-            return this;\n+        @Override\n+        public NodeResources resources() { return resources; }\n+\n+        @Override\n+        public Optional<String> parentHostname() { return Optional.of(parent.get().hostname()); }\n+\n+        @Override\n+        public NodeType type() { return NodeType.tenant; }\n+\n+        public Optional<Allocation> allocation() { return Optional.empty(); }\n+\n+        public Node.State state() { return Node.State.reserved; }\n+\n+        public boolean wantToRetire() { return false; }\n+\n+        public Flavor flavor() { return new Flavor(resources); }\n+\n+        public NodeCandidate allocate(ApplicationId owner, ClusterMembership membership, NodeResources requestedResources, Instant at) {\n+            return withNode().allocate(owner, membership, requestedResources, at);\n         }\n \n-        Builder newNode(boolean newNode) {\n-            isNewNode = newNode;\n-            return this;\n+        /** Called when the node described by this candidate must be created */\n+        public NodeCandidate withNode() {\n+            Optional<IP.Allocation> allocation;\n+            try {\n+                allocation = parent.get().ipConfig().pool().findAllocation(allNodes, nodeRepository.nameResolver());\n+                if (allocation.isEmpty())\n+                    throw new IllegalStateException(\"No free ip addresses on \" + parent.get() + \": Cannot allocate node\");\n+            } catch (Exception e) {\n+                throw new IllegalStateException(\"Failed allocating IP address on \" + parent.get() +\": \", e);", "originalCommit": "d254d8378f398ea6e90e2dcf0e270516c4fd1654", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzI4MjY1NQ==", "url": "https://github.com/vespa-engine/vespa/pull/14623#discussion_r497282655", "bodyText": "Done, please ptal. I think it would be better if we could expect this not to fail though - perhaps we should have a maintainer looking for it.", "author": "bratseth", "createdAt": "2020-09-30T06:58:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA2NDUyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzMxNDY0NA==", "url": "https://github.com/vespa-engine/vespa/pull/14623#discussion_r497314644", "bodyText": "It's the product of countless cases of DNS/IP misconfiguration upstream from us. It will continue to happen. \ud83d\ude1e", "author": "mpolden", "createdAt": "2020-09-30T07:58:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA2NDUyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzMzOTgzMA==", "url": "https://github.com/vespa-engine/vespa/pull/14623#discussion_r497339830", "bodyText": "I would like to stop using DNS but not sure if that would avoid all of that?", "author": "bratseth", "createdAt": "2020-09-30T08:39:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA2NDUyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzM0NTkxOQ==", "url": "https://github.com/vespa-engine/vespa/pull/14623#discussion_r497345919", "bodyText": "IP assignment and DNS issues typically correlate, at least in our internal infrastructure: If foo.example.com resolves to 1.1.1.1, but 1.1.1.1 resolves to bar.example.com, there's likely an IP conflict where two distinct hosts have been assigned the same IP.\nVespa itself also has strict hostname validation on startup, where hostname and IP are resolved and compared. That's another reason we do this check during allocation as the node would refuse to start in case of misconfiguration anyway.", "author": "mpolden", "createdAt": "2020-09-30T08:48:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA2NDUyNA=="}], "type": "inlineReview"}, {"oid": "c2c8751e7877d65ee9116d87d6da5ca163469520", "url": "https://github.com/vespa-engine/vespa/commit/c2c8751e7877d65ee9116d87d6da5ca163469520", "message": "Try another candidate if ip allocation fails", "committedDate": "2020-09-30T06:57:20Z", "type": "commit"}, {"oid": "a88727c861a0e0ce1cc0a28f1d771ad83987c413", "url": "https://github.com/vespa-engine/vespa/commit/a88727c861a0e0ce1cc0a28f1d771ad83987c413", "message": "Update node-repository/src/main/java/com/yahoo/vespa/hosted/provision/Nodelike.java\n\nCo-authored-by: Valerij Fredriksen <freva@users.noreply.github.com>", "committedDate": "2020-09-30T06:57:43Z", "type": "commit"}]}