{"pr_number": 14554, "pr_title": "Jonmv/async doc v1 implementation", "pr_createdAt": "2020-09-25T09:25:26Z", "pr_url": "https://github.com/vespa-engine/vespa/pull/14554", "timeline": [{"oid": "cd5c5c71b24e6c66a0ed79f3566cb1aadfa96f51", "url": "https://github.com/vespa-engine/vespa/commit/cd5c5c71b24e6c66a0ed79f3566cb1aadfa96f51", "message": "Eliminate code duplication in generating metric context for requests", "committedDate": "2020-09-25T10:00:20Z", "type": "forcePushed"}, {"oid": "9d5b7c9573bd2187bd95afe821b0d066b97a34af", "url": "https://github.com/vespa-engine/vespa/commit/9d5b7c9573bd2187bd95afe821b0d066b97a34af", "message": "Add async /document/v1 and backing executor", "committedDate": "2020-09-25T12:19:41Z", "type": "commit"}, {"oid": "c12f4775a03f1d16420a689f0b9d50d35c32413b", "url": "https://github.com/vespa-engine/vespa/commit/c12f4775a03f1d16420a689f0b9d50d35c32413b", "message": "Copyright header, one more catch, unused parameter GC", "committedDate": "2020-09-25T12:19:41Z", "type": "commit"}, {"oid": "3fe333d33ea24af3f6ebed8e3986db2d82a98bb6", "url": "https://github.com/vespa-engine/vespa/commit/3fe333d33ea24af3f6ebed8e3986db2d82a98bb6", "message": "Eliminate code duplication in generating metric context for requests", "committedDate": "2020-09-25T12:19:41Z", "type": "commit"}, {"oid": "d0572215be00dd764281818c9f370b7f82adb8bf", "url": "https://github.com/vespa-engine/vespa/commit/d0572215be00dd764281818c9f370b7f82adb8bf", "message": "Make LocalAsyncSession async when asked to, and test this", "committedDate": "2020-09-25T12:19:41Z", "type": "commit"}, {"oid": "d0572215be00dd764281818c9f370b7f82adb8bf", "url": "https://github.com/vespa-engine/vespa/commit/d0572215be00dd764281818c9f370b7f82adb8bf", "message": "Make LocalAsyncSession async when asked to, and test this", "committedDate": "2020-09-25T12:19:41Z", "type": "forcePushed"}, {"oid": "b819f60b6bdc2d6e124c0dc54c718016009e603c", "url": "https://github.com/vespa-engine/vespa/commit/b819f60b6bdc2d6e124c0dc54c718016009e603c", "message": "Update abi spec and simplify synch i LocalAsyncSession", "committedDate": "2020-09-25T15:23:46Z", "type": "commit"}, {"oid": "6d1aa9aa09f3628b180541922d651b4ad7a036cb", "url": "https://github.com/vespa-engine/vespa/commit/6d1aa9aa09f3628b180541922d651b4ad7a036cb", "message": "Use wait over sleep, to allow waking up maintainers on demand", "committedDate": "2020-09-25T16:07:40Z", "type": "commit"}, {"oid": "620b983bbc9a8d2bb1252fbb30e5941f3927563b", "url": "https://github.com/vespa-engine/vespa/commit/620b983bbc9a8d2bb1252fbb30e5941f3927563b", "message": "Separate out delay queue, and add unit test for it", "committedDate": "2020-09-28T09:50:41Z", "type": "commit"}, {"oid": "7fac15f41005fd65e44a5699f67c1a576d8eb3e7", "url": "https://github.com/vespa-engine/vespa/commit/7fac15f41005fd65e44a5699f67c1a576d8eb3e7", "message": "Test throttling and handle responses arriving before their acks", "committedDate": "2020-09-28T11:52:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjAxNzAzMQ==", "url": "https://github.com/vespa-engine/vespa/pull/14554#discussion_r496017031", "bodyText": "Do not use a concurrent collection as an external monitor (unless ConcurrentLinkedQueue says it's okay).", "author": "bjorncs", "createdAt": "2020-09-28T15:06:15Z", "path": "vespaclient-container-plugin/src/main/java/com/yahoo/document/restapi/DocumentOperationExecutor.java", "diffHunk": "@@ -0,0 +1,598 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+package com.yahoo.document.restapi;\n+\n+import com.yahoo.cloud.config.ClusterListConfig;\n+import com.yahoo.document.Document;\n+import com.yahoo.document.DocumentId;\n+import com.yahoo.document.DocumentPut;\n+import com.yahoo.document.DocumentUpdate;\n+import com.yahoo.document.FixedBucketSpaces;\n+import com.yahoo.document.fieldset.AllFields;\n+import com.yahoo.document.select.parser.ParseException;\n+import com.yahoo.documentapi.AsyncParameters;\n+import com.yahoo.documentapi.AsyncSession;\n+import com.yahoo.documentapi.DocumentAccess;\n+import com.yahoo.documentapi.DocumentOperationParameters;\n+import com.yahoo.documentapi.DocumentResponse;\n+import com.yahoo.documentapi.DumpVisitorDataHandler;\n+import com.yahoo.documentapi.ProgressToken;\n+import com.yahoo.documentapi.Response;\n+import com.yahoo.documentapi.Result;\n+import com.yahoo.documentapi.VisitorControlHandler;\n+import com.yahoo.documentapi.VisitorParameters;\n+import com.yahoo.documentapi.VisitorSession;\n+import com.yahoo.documentapi.messagebus.protocol.DocumentProtocol;\n+import com.yahoo.messagebus.StaticThrottlePolicy;\n+import com.yahoo.text.Text;\n+import com.yahoo.vespa.config.content.AllClustersBucketSpacesConfig;\n+import com.yahoo.yolean.Exceptions;\n+\n+import java.time.Clock;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.StringJoiner;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.BiConsumer;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Stream;\n+\n+import static com.yahoo.document.restapi.DocumentOperationExecutor.ErrorType.BAD_REQUEST;\n+import static com.yahoo.document.restapi.DocumentOperationExecutor.ErrorType.ERROR;\n+import static com.yahoo.document.restapi.DocumentOperationExecutor.ErrorType.NOT_FOUND;\n+import static com.yahoo.document.restapi.DocumentOperationExecutor.ErrorType.OVERLOAD;\n+import static com.yahoo.document.restapi.DocumentOperationExecutor.ErrorType.PRECONDITION_FAILED;\n+import static com.yahoo.document.restapi.DocumentOperationExecutor.ErrorType.TIMEOUT;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.stream.Collectors.toMap;\n+import static java.util.stream.Collectors.toUnmodifiableMap;\n+\n+/**\n+ * Encapsulates a document access and supports running asynchronous document\n+ * operations and visits against this, with retries and optional timeouts.\n+ *\n+ * @author jonmv\n+ */\n+public class DocumentOperationExecutor {\n+\n+    private static final Logger log = Logger.getLogger(DocumentOperationExecutor.class.getName());\n+\n+    private final Duration resendDelay;\n+    private final Duration defaultTimeout;\n+    private final Duration visitTimeout;\n+    private final long maxThrottled;\n+    private final DocumentAccess access;\n+    private final AsyncSession asyncSession;\n+    private final Map<String, StorageCluster> clusters;\n+    private final Clock clock;\n+    private final ConcurrentLinkedQueue<Delayed> throttled = new ConcurrentLinkedQueue<>();\n+    private final ConcurrentLinkedQueue<Delayed> timeouts = new ConcurrentLinkedQueue<>();\n+    private final Map<Long, OperationContext> outstanding = new ConcurrentHashMap<>();\n+    private final Map<VisitorControlHandler, VisitorSession> visits = new ConcurrentHashMap<>();\n+    private final Thread retryWorker;\n+    private final Thread timeoutWorker;\n+\n+    public DocumentOperationExecutor(ClusterListConfig clustersConfig, AllClustersBucketSpacesConfig bucketsConfig,\n+                                     DocumentOperationExecutorConfig executorConfig, DocumentAccess access, Clock clock) {\n+        this(Duration.ofMillis(executorConfig.resendDelayMillis()),\n+             Duration.ofSeconds(executorConfig.defaultTimeoutSeconds()),\n+             Duration.ofSeconds(executorConfig.visitTimeoutSeconds()),\n+             executorConfig.maxThrottled(),\n+             access,\n+             parseClusters(clustersConfig, bucketsConfig),\n+             clock);\n+    }\n+\n+    DocumentOperationExecutor(Duration resendDelay, Duration defaultTimeout, Duration visitTimeout, long maxThrottled,\n+                              DocumentAccess access, Map<String, StorageCluster> clusters, Clock clock) {\n+        this.resendDelay = requireNonNull(resendDelay);\n+        this.defaultTimeout = requireNonNull(defaultTimeout);\n+        this.visitTimeout = requireNonNull(visitTimeout);\n+        this.maxThrottled = maxThrottled;\n+        this.access = requireNonNull(access);\n+        this.asyncSession = access.createAsyncSession(new AsyncParameters().setResponseHandler(this::handleResponse));\n+        this.clock = requireNonNull(clock);\n+        this.clusters = Map.copyOf(clusters);\n+        this.retryWorker = new Thread(this::retry, \"document-operation-executor-retry-thread\");\n+        this.retryWorker.start();\n+        this.timeoutWorker = new Thread(this::timeOut, \"document-operation-executor-timeout-thread\");\n+        this.timeoutWorker.start();\n+    }\n+\n+    public void shutdown() {\n+        retryWorker.interrupt();\n+        timeoutWorker.interrupt();\n+        visits.values().forEach(VisitorSession::destroy);\n+        try {\n+            long timeoutMillis = clock.millis() + 10_000;\n+            retryWorker.join(timeoutMillis - clock.millis());\n+            timeoutWorker.join(timeoutMillis - clock.millis());\n+        }\n+        catch (InterruptedException e) {\n+            log.log(Level.WARNING, \"Interrupted waiting for caretaker threads to complete\");\n+            Thread.currentThread().interrupt();\n+        }\n+    }\n+\n+    public void get(DocumentId id, DocumentOperationParameters parameters, OperationContext context) {\n+        accept(() -> asyncSession.get(id, parameters), context);\n+    }\n+\n+    public void put(DocumentPut put, DocumentOperationParameters parameters, OperationContext context) {\n+        accept(() -> asyncSession.put(put, parameters), context);\n+    }\n+\n+    public void update(DocumentUpdate update, DocumentOperationParameters parameters, OperationContext context) {\n+        accept(() -> asyncSession.update(update, parameters), context);\n+    }\n+\n+    public void remove(DocumentId id, DocumentOperationParameters parameters, OperationContext context) {\n+        accept(() -> asyncSession.remove(id, parameters), context);\n+    }\n+\n+    public void visit(VisitorOptions options, VisitOperationsContext context) {\n+        try {\n+            VisitorParameters parameters = options.asParameters(clusters, visitTimeout);\n+            parameters.setLocalDataHandler(new DumpVisitorDataHandler() {\n+                @Override public void onDocument(Document doc, long timeStamp) { context.document(doc); }\n+                @Override public void onRemove(DocumentId id) { } // We don't visit removes here.\n+            });\n+            parameters.setControlHandler(new VisitorControlHandler() {\n+                @Override public void onDone(CompletionCode code, String message) {\n+                    super.onDone(code, message);\n+                    switch (code) {\n+                        case TIMEOUT:\n+                            if ( ! hasVisitedAnyBuckets())\n+                                context.error(TIMEOUT, \"No buckets visited within timeout of \" + visitTimeout);\n+                        case SUCCESS: // intentional fallthrough\n+                        case ABORTED:\n+                            context.success(Optional.ofNullable(getProgress())\n+                                                    .filter(progress -> ! progress.isFinished())\n+                                                    .map(ProgressToken::serializeToString));\n+                            break;\n+                        default:\n+                            context.error(ERROR, message != null ? message : \"Visiting failed\");\n+                    }\n+                    visits.remove(this).destroy();\n+                }\n+            });\n+            visits.put(parameters.getControlHandler(), access.createVisitorSession(parameters));\n+        }\n+        catch (IllegalArgumentException | ParseException e) {\n+            context.error(BAD_REQUEST, Exceptions.toMessageString(e));\n+        }\n+        catch (RuntimeException e) {\n+            context.error(ERROR, Exceptions.toMessageString(e));\n+        }\n+    }\n+\n+    public String routeToCluster(String cluster) {\n+        return resolveCluster(Optional.of(cluster), clusters).route();\n+    }\n+\n+    /** Rejects operation if retry queue is full; otherwise starts a timer for the given task, and attempts to send it.  */\n+    private void accept(Supplier<Result> operation, OperationContext context) {\n+        timeouts.add(new Delayed(clock.instant().plus(defaultTimeout), operation, context));\n+        timeouts.notify();\n+        send(operation, context);\n+    }\n+\n+    /** Sends the given operation through the async session of this, enqueueing a retry if throttled, unless overloaded. */\n+    private void send(Supplier<Result> operation, OperationContext context) {\n+        Result result = operation.get();\n+        switch (result.type()) {\n+            case SUCCESS:\n+                outstanding.put(result.getRequestId(), context);\n+                break;\n+            case TRANSIENT_ERROR:\n+                if (throttled.size() > maxThrottled)\n+                    context.error(OVERLOAD, maxThrottled + \" requests already in retry queue\");\n+                else {\n+                    throttled.add(new Delayed(clock.instant().plus(resendDelay), operation, context));\n+                    throttled.notify();\n+                }\n+                break;\n+            default:\n+                log.log(Level.WARNING, \"Unknown result type '\" + result.type() + \"'\");\n+            case FATAL_ERROR: // intentional fallthrough\n+                context.error(ERROR, result.getError().getMessage());\n+        }\n+    }\n+\n+    private void handleResponse(Response response){\n+        OperationContext context = outstanding.remove(response.getRequestId());\n+        if (context != null)\n+            if (response.isSuccess())\n+                context.success(response instanceof DocumentResponse ? Optional.ofNullable(((DocumentResponse) response).getDocument())\n+                                                                     : Optional.empty());\n+            else\n+                context.error(toErrorType(response.outcome()), response.getTextMessage());\n+        else\n+            log.log(Level.FINE, () -> \"Received response for request which has timed out, with id \" + response.getRequestId());\n+    }\n+\n+    private static ErrorType toErrorType(Response.Outcome outcome) {\n+        switch (outcome) {\n+            case NOT_FOUND:\n+                return NOT_FOUND;\n+            case CONDITION_FAILED:\n+                return PRECONDITION_FAILED;\n+            default:\n+                log.log(Level.WARNING, \"Unexpected response outcome: \" + outcome);\n+            case ERROR: // intentional fallthrough\n+                return ERROR;\n+        }\n+    }\n+\n+    private void retry() {\n+        maintain(throttled, delayed -> send(delayed.operation(), delayed.context()));\n+    }\n+\n+    private void timeOut() {\n+        maintain(timeouts, delayed -> delayed.context().error(TIMEOUT, \"Timed out after \" + defaultTimeout));\n+    }\n+\n+    private void maintain(ConcurrentLinkedQueue<Delayed> queue, Consumer<Delayed> action) {\n+        while ( ! Thread.currentThread().isInterrupted()) {\n+            try {\n+                long waitUntilMillis = Instant.MAX.toEpochMilli();\n+                Iterator<Delayed> operations = queue.iterator();\n+                while (operations.hasNext()) {\n+                    Delayed operation = operations.next();\n+                    // Already handled: remove and continue.\n+                    if (operation.context().handled()) {\n+                        operations.remove();\n+                        continue;\n+                    }\n+                    // Ready for retry \u2014\u00a0remove from queue and send.\n+                    if (operation.readyAt().isBefore(clock.instant())) {\n+                        action.accept(operation);\n+                        operations.remove();\n+                        continue;\n+                    }\n+                    // Not yet ready for retry \u2014\u00a0track earliest time to wake up again.\n+                    waitUntilMillis = Math.min(waitUntilMillis, operation.readyAt.toEpochMilli());\n+                }\n+                synchronized (queue) {", "originalCommit": "6d1aa9aa09f3628b180541922d651b4ad7a036cb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEwODEwNg==", "url": "https://github.com/vespa-engine/vespa/pull/14554#discussion_r496108106", "bodyText": "Good point. Already changed to allow tests to notify maintainers, though :)", "author": "jonmv", "createdAt": "2020-09-28T17:12:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjAxNzAzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjAyMDQzNA==", "url": "https://github.com/vespa-engine/vespa/pull/14554#discussion_r496020434", "bodyText": "Consider moving the metric aggregation to HandlerMetricContextUtil and replace this with a e.g HandlerMetricContextUtil.onHandledRequest(...).", "author": "bjorncs", "createdAt": "2020-09-28T15:09:13Z", "path": "vespaclient-container-plugin/src/main/java/com/yahoo/document/restapi/resource/DocumentV1ApiHandler.java", "diffHunk": "@@ -0,0 +1,603 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+package com.yahoo.document.restapi.resource;\n+\n+import com.fasterxml.jackson.core.JsonFactory;\n+import com.google.inject.Inject;\n+import com.yahoo.cloud.config.ClusterListConfig;\n+import com.yahoo.container.core.documentapi.VespaDocumentAccess;\n+import com.yahoo.document.DocumentId;\n+import com.yahoo.document.DocumentOperation;\n+import com.yahoo.document.DocumentPut;\n+import com.yahoo.document.DocumentTypeManager;\n+import com.yahoo.document.DocumentUpdate;\n+import com.yahoo.document.TestAndSetCondition;\n+import com.yahoo.document.config.DocumentmanagerConfig;\n+import com.yahoo.document.json.JsonReader;\n+import com.yahoo.document.json.JsonWriter;\n+import com.yahoo.document.json.document.DocumentParser;\n+import com.yahoo.document.restapi.DocumentOperationExecutor;\n+import com.yahoo.document.restapi.DocumentOperationExecutor.ErrorType;\n+import com.yahoo.document.restapi.DocumentOperationExecutor.Group;\n+import com.yahoo.document.restapi.DocumentOperationExecutor.OperationContext;\n+import com.yahoo.document.restapi.DocumentOperationExecutor.VisitOperationsContext;\n+import com.yahoo.document.restapi.DocumentOperationExecutor.VisitorOptions;\n+import com.yahoo.document.restapi.DocumentOperationExecutorConfig;\n+import com.yahoo.documentapi.DocumentOperationParameters;\n+import com.yahoo.documentapi.metrics.DocumentApiMetrics;\n+import com.yahoo.documentapi.metrics.DocumentOperationStatus;\n+import com.yahoo.documentapi.metrics.DocumentOperationType;\n+import com.yahoo.jdisc.Metric;\n+import com.yahoo.jdisc.Request;\n+import com.yahoo.jdisc.Response;\n+import com.yahoo.jdisc.handler.AbstractRequestHandler;\n+import com.yahoo.jdisc.handler.CompletionHandler;\n+import com.yahoo.jdisc.handler.ContentChannel;\n+import com.yahoo.jdisc.handler.ReadableContentChannel;\n+import com.yahoo.jdisc.handler.ResponseHandler;\n+import com.yahoo.jdisc.handler.UnsafeContentInputStream;\n+import com.yahoo.container.core.HandlerMetricContextUtil;\n+import com.yahoo.jdisc.http.HttpRequest;\n+import com.yahoo.jdisc.http.HttpRequest.Method;\n+import com.yahoo.metrics.simple.MetricReceiver;\n+import com.yahoo.restapi.Path;\n+import com.yahoo.slime.Cursor;\n+import com.yahoo.slime.Inspector;\n+import com.yahoo.slime.Slime;\n+import com.yahoo.slime.SlimeUtils;\n+import com.yahoo.vespa.config.content.AllClustersBucketSpacesConfig;\n+import com.yahoo.yolean.Exceptions;\n+\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.time.Clock;\n+import java.time.Instant;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.logging.Logger;\n+\n+import static com.yahoo.documentapi.DocumentOperationParameters.parameters;\n+import static com.yahoo.jdisc.http.HttpRequest.Method.DELETE;\n+import static com.yahoo.jdisc.http.HttpRequest.Method.GET;\n+import static com.yahoo.jdisc.http.HttpRequest.Method.OPTIONS;\n+import static com.yahoo.jdisc.http.HttpRequest.Method.POST;\n+import static com.yahoo.jdisc.http.HttpRequest.Method.PUT;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.logging.Level.FINE;\n+import static java.util.logging.Level.WARNING;\n+import static java.util.stream.Collectors.joining;\n+\n+/**\n+ * Asynchronous HTTP handler for /document/v1/\n+ *\n+ * @author jonmv\n+ */\n+public class DocumentV1ApiHandler extends AbstractRequestHandler {\n+\n+    private static final Logger log = Logger.getLogger(DocumentV1ApiHandler.class.getName());\n+    private static final Parser<Integer> numberParser = Integer::parseInt;\n+    private static final Parser<Boolean> booleanParser = Boolean::parseBoolean;\n+\n+    private static final CompletionHandler logException = new CompletionHandler() {\n+        @Override public void completed() { }\n+        @Override public void failed(Throwable t) {\n+            log.log(WARNING, \"Exception writing response data\", t);\n+        }\n+    };\n+\n+    private static final ContentChannel ignoredContent = new ContentChannel() {\n+        @Override public void write(ByteBuffer buf, CompletionHandler handler) { handler.completed(); }\n+        @Override public void close(CompletionHandler handler) { handler.completed(); }\n+    };\n+\n+    private static final String CREATE = \"create\";\n+    private static final String CONDITION = \"condition\";\n+    private static final String ROUTE = \"route\"; // TODO jonmv: set for everything except Get\n+    private static final String FIELD_SET = \"fieldSet\";\n+    private static final String SELECTION = \"selection\";\n+    private static final String CLUSTER = \"cluster\"; // TODO jonmv: set for Get\n+    private static final String CONTINUATION = \"continuation\";\n+    private static final String WANTED_DOCUMENT_COUNT = \"wantedDocumentCount\";\n+    private static final String CONCURRENCY = \"concurrency\";\n+    private static final String BUCKET_SPACE = \"bucketSpace\";\n+\n+    private final Clock clock;\n+    private final Metric metric; // TODO jonmv: make response class which logs on completion/error\n+    private final DocumentApiMetrics metrics;\n+    private final DocumentOperationExecutor executor;\n+    private final DocumentOperationParser parser;\n+    private final Map<String, Map<Method, Handler>> handlers;\n+\n+    @Inject\n+    public DocumentV1ApiHandler(Clock clock,\n+                                Metric metric,\n+                                MetricReceiver metricReceiver,\n+                                VespaDocumentAccess documentAccess,\n+                                DocumentmanagerConfig documentManagerConfig,\n+                                ClusterListConfig clusterListConfig,\n+                                AllClustersBucketSpacesConfig bucketSpacesConfig,\n+                                DocumentOperationExecutorConfig executorConfig) {\n+        this(clock,\n+             new DocumentOperationExecutor(clusterListConfig, bucketSpacesConfig, executorConfig, documentAccess, clock),\n+             new DocumentOperationParser(documentManagerConfig),\n+             metric,\n+             metricReceiver);\n+    }\n+\n+    DocumentV1ApiHandler(Clock clock, DocumentOperationExecutor executor, DocumentOperationParser parser,\n+                         Metric metric, MetricReceiver metricReceiver) {\n+        this.clock = clock;\n+        this.executor = executor;\n+        this.parser = parser;\n+        this.metric = metric;\n+        this.metrics = new DocumentApiMetrics(metricReceiver, \"documentV1\");\n+        this.handlers = defineApi();\n+    }\n+\n+    @Override\n+    public ContentChannel handleRequest(Request rawRequest, ResponseHandler rawResponseHandler) {\n+        metric.add(\"handled.requests\", 1, HandlerMetricContextUtil.contextFor(rawRequest, metric, getClass()));", "originalCommit": "6d1aa9aa09f3628b180541922d651b4ad7a036cb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "29f45f8cfdb15e87d3b0dfe312fdcdc39e84cf41", "url": "https://github.com/vespa-engine/vespa/commit/29f45f8cfdb15e87d3b0dfe312fdcdc39e84cf41", "message": "Tests and the fixes they entailed", "committedDate": "2020-09-28T17:01:12Z", "type": "commit"}, {"oid": "6c2b2cb1cea66f7f9dbdb7ac366bdeda00194c60", "url": "https://github.com/vespa-engine/vespa/commit/6c2b2cb1cea66f7f9dbdb7ac366bdeda00194c60", "message": "Common metrics code and abi spec", "committedDate": "2020-09-28T18:28:29Z", "type": "commit"}]}