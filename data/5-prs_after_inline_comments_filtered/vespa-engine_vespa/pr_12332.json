{"pr_number": 12332, "pr_title": "Adding more threads does not work when the Q is unbound. Use a Synchr\u2026", "pr_createdAt": "2020-02-25T12:10:30Z", "pr_url": "https://github.com/vespa-engine/vespa/pull/12332", "timeline": [{"oid": "f17690d9533eef0f2471577184369548b0f3b380", "url": "https://github.com/vespa-engine/vespa/commit/f17690d9533eef0f2471577184369548b0f3b380", "message": "Adding more threads does not work when the Q is unbound. Use a SynchronousQ instead.", "committedDate": "2020-02-25T12:07:42Z", "type": "commit"}, {"oid": "d7d87a8e45e0dace606493dfed2f903a614b76f7", "url": "https://github.com/vespa-engine/vespa/commit/d7d87a8e45e0dace606493dfed2f903a614b76f7", "message": "Use a global bounded cached tread pool as primary, and a single threaded one for fallback.", "committedDate": "2020-02-25T14:23:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkyOTczMQ==", "url": "https://github.com/vespa-engine/vespa/pull/12332#discussion_r383929731", "bodyText": "I suggest having a method to wait for an executor completion and calling it for each executor", "author": "havardpe", "createdAt": "2020-02-25T14:55:43Z", "path": "jrt/src/com/yahoo/jrt/Connector.java", "diffHunk": "@@ -3,42 +3,119 @@\n \n import com.yahoo.concurrent.ThreadFactoryFactory;\n \n+import java.util.concurrent.Executor;\n import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.SynchronousQueue;\n import java.util.concurrent.ThreadPoolExecutor;\n import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n \n-class Connector {\n+class Connector implements AutoCloseable {\n \n-    private final ExecutorService executor = new ThreadPoolExecutor(1, 64, 1L, TimeUnit.SECONDS,\n-                                                                    new LinkedBlockingQueue<>(),\n-                                                                    ThreadFactoryFactory.getDaemonThreadFactory(\"jrt.connector\"));\n+    private static final Object globalLock = new Object();\n+    private static ExecutorService globalPrimaryExecutor = null;\n+    private static ExecutorService globalFallbackExecutor = null;\n+    private static long usages = 0;\n \n-    private void connect(Connection conn) {\n-        conn.transportThread().addConnection(conn.connect());\n+    private static class ExecutorWithFallback implements Executor {\n+        private final Executor primary;\n+        private final Executor secondary;\n+        ExecutorWithFallback(Executor primary, Executor secondary) {\n+            this.primary = primary;\n+            this.secondary = secondary;\n+        }\n+\n+        @Override\n+        public void execute(Runnable command) {\n+            try {\n+                primary.execute(command);\n+            } catch (RejectedExecutionException e1) {\n+                secondary.execute(() -> retryForEver(command));\n+            }\n+        }\n+        private void retryForEver(Runnable command) {\n+            while (true) {\n+                try {\n+                    primary.execute(command);\n+                    return;\n+                } catch (RejectedExecutionException rejected) {\n+                    try {\n+                        Thread.sleep(1);\n+                    } catch (InterruptedException silenced) { }\n+                }\n+            }\n+        }\n     }\n \n-    public void connectLater(Connection conn) {\n-        try {\n-            executor.execute(() -> connect(conn));\n-        } catch (RejectedExecutionException e) {\n-            conn.transportThread().addConnection(conn);\n+    private static ExecutorWithFallback acquire() {\n+        synchronized (globalLock) {\n+            if (globalPrimaryExecutor == null) {\n+                globalPrimaryExecutor = new ThreadPoolExecutor(1, 64, 1L, TimeUnit.SECONDS,\n+                        new SynchronousQueue<>(), ThreadFactoryFactory.getDaemonThreadFactory(\"jrt.connector.primary\"));\n+                globalFallbackExecutor = Executors.newSingleThreadExecutor(ThreadFactoryFactory.getDaemonThreadFactory(\"jrt.connector.fallback\"));\n+            }\n+            usages ++;\n+            return new ExecutorWithFallback(globalPrimaryExecutor, globalFallbackExecutor);\n         }\n     }\n \n-    public Connector shutdown() {\n-        executor.shutdown();\n-        return this;\n+    private static void release(ExecutorWithFallback executor) {\n+        synchronized (globalLock) {\n+            if (executor.primary != globalPrimaryExecutor) {\n+                throw new IllegalStateException(\"primary executor \" + executor.primary + \" != \" + globalPrimaryExecutor);\n+            }\n+            if (executor.secondary != globalFallbackExecutor) {\n+                throw new IllegalStateException(\"secondary executor \" + executor.secondary + \" != \" + globalFallbackExecutor);\n+            }\n+            usages--;\n+            if (usages == 0) {\n+                globalPrimaryExecutor.shutdown();\n+                globalFallbackExecutor.shutdown();\n+                while (true) {", "originalCommit": "d7d87a8e45e0dace606493dfed2f903a614b76f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzk0NTIwMA==", "url": "https://github.com/vespa-engine/vespa/pull/12332#discussion_r383945200", "bodyText": "Fixed", "author": "baldersheim", "createdAt": "2020-02-25T15:18:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkyOTczMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkzMDAzMg==", "url": "https://github.com/vespa-engine/vespa/pull/12332#discussion_r383930032", "bodyText": "extra space", "author": "havardpe", "createdAt": "2020-02-25T14:56:09Z", "path": "jrt/src/com/yahoo/jrt/Connector.java", "diffHunk": "@@ -3,42 +3,119 @@\n \n import com.yahoo.concurrent.ThreadFactoryFactory;\n \n+import java.util.concurrent.Executor;\n import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.SynchronousQueue;\n import java.util.concurrent.ThreadPoolExecutor;\n import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n \n-class Connector {\n+class Connector implements AutoCloseable {\n \n-    private final ExecutorService executor = new ThreadPoolExecutor(1, 64, 1L, TimeUnit.SECONDS,\n-                                                                    new LinkedBlockingQueue<>(),\n-                                                                    ThreadFactoryFactory.getDaemonThreadFactory(\"jrt.connector\"));\n+    private static final Object globalLock = new Object();\n+    private static ExecutorService globalPrimaryExecutor = null;\n+    private static ExecutorService globalFallbackExecutor = null;\n+    private static long usages = 0;\n \n-    private void connect(Connection conn) {\n-        conn.transportThread().addConnection(conn.connect());\n+    private static class ExecutorWithFallback implements Executor {\n+        private final Executor primary;\n+        private final Executor secondary;\n+        ExecutorWithFallback(Executor primary, Executor secondary) {\n+            this.primary = primary;\n+            this.secondary = secondary;\n+        }\n+\n+        @Override\n+        public void execute(Runnable command) {\n+            try {\n+                primary.execute(command);\n+            } catch (RejectedExecutionException e1) {\n+                secondary.execute(() -> retryForEver(command));\n+            }\n+        }\n+        private void retryForEver(Runnable command) {\n+            while (true) {\n+                try {\n+                    primary.execute(command);\n+                    return;\n+                } catch (RejectedExecutionException rejected) {\n+                    try {\n+                        Thread.sleep(1);\n+                    } catch (InterruptedException silenced) { }\n+                }\n+            }\n+        }\n     }\n \n-    public void connectLater(Connection conn) {\n-        try {\n-            executor.execute(() -> connect(conn));\n-        } catch (RejectedExecutionException e) {\n-            conn.transportThread().addConnection(conn);\n+    private static ExecutorWithFallback acquire() {\n+        synchronized (globalLock) {\n+            if (globalPrimaryExecutor == null) {\n+                globalPrimaryExecutor = new ThreadPoolExecutor(1, 64, 1L, TimeUnit.SECONDS,\n+                        new SynchronousQueue<>(), ThreadFactoryFactory.getDaemonThreadFactory(\"jrt.connector.primary\"));\n+                globalFallbackExecutor = Executors.newSingleThreadExecutor(ThreadFactoryFactory.getDaemonThreadFactory(\"jrt.connector.fallback\"));\n+            }\n+            usages ++;", "originalCommit": "d7d87a8e45e0dace606493dfed2f903a614b76f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzk0NTA0Nw==", "url": "https://github.com/vespa-engine/vespa/pull/12332#discussion_r383945047", "bodyText": "Fixed", "author": "baldersheim", "createdAt": "2020-02-25T15:18:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkzMDAzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkzMjAwOQ==", "url": "https://github.com/vespa-engine/vespa/pull/12332#discussion_r383932009", "bodyText": "consider checking usages and secondary pointer for consistency", "author": "havardpe", "createdAt": "2020-02-25T14:58:53Z", "path": "jrt/src/com/yahoo/jrt/Connector.java", "diffHunk": "@@ -3,42 +3,119 @@\n \n import com.yahoo.concurrent.ThreadFactoryFactory;\n \n+import java.util.concurrent.Executor;\n import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.SynchronousQueue;\n import java.util.concurrent.ThreadPoolExecutor;\n import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n \n-class Connector {\n+class Connector implements AutoCloseable {\n \n-    private final ExecutorService executor = new ThreadPoolExecutor(1, 64, 1L, TimeUnit.SECONDS,\n-                                                                    new LinkedBlockingQueue<>(),\n-                                                                    ThreadFactoryFactory.getDaemonThreadFactory(\"jrt.connector\"));\n+    private static final Object globalLock = new Object();\n+    private static ExecutorService globalPrimaryExecutor = null;\n+    private static ExecutorService globalFallbackExecutor = null;\n+    private static long usages = 0;\n \n-    private void connect(Connection conn) {\n-        conn.transportThread().addConnection(conn.connect());\n+    private static class ExecutorWithFallback implements Executor {\n+        private final Executor primary;\n+        private final Executor secondary;\n+        ExecutorWithFallback(Executor primary, Executor secondary) {\n+            this.primary = primary;\n+            this.secondary = secondary;\n+        }\n+\n+        @Override\n+        public void execute(Runnable command) {\n+            try {\n+                primary.execute(command);\n+            } catch (RejectedExecutionException e1) {\n+                secondary.execute(() -> retryForEver(command));\n+            }\n+        }\n+        private void retryForEver(Runnable command) {\n+            while (true) {\n+                try {\n+                    primary.execute(command);\n+                    return;\n+                } catch (RejectedExecutionException rejected) {\n+                    try {\n+                        Thread.sleep(1);\n+                    } catch (InterruptedException silenced) { }\n+                }\n+            }\n+        }\n     }\n \n-    public void connectLater(Connection conn) {\n-        try {\n-            executor.execute(() -> connect(conn));\n-        } catch (RejectedExecutionException e) {\n-            conn.transportThread().addConnection(conn);\n+    private static ExecutorWithFallback acquire() {\n+        synchronized (globalLock) {\n+            if (globalPrimaryExecutor == null) {\n+                globalPrimaryExecutor = new ThreadPoolExecutor(1, 64, 1L, TimeUnit.SECONDS,", "originalCommit": "d7d87a8e45e0dace606493dfed2f903a614b76f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzk0NTM5NQ==", "url": "https://github.com/vespa-engine/vespa/pull/12332#discussion_r383945395", "bodyText": "Fixed", "author": "baldersheim", "createdAt": "2020-02-25T15:19:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkzMjAwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkzMjY1MA==", "url": "https://github.com/vespa-engine/vespa/pull/12332#discussion_r383932650", "bodyText": "in the future, this could be moved to vespajlib since it is a general utility not directly tied to rpc", "author": "havardpe", "createdAt": "2020-02-25T14:59:48Z", "path": "jrt/src/com/yahoo/jrt/Connector.java", "diffHunk": "@@ -3,42 +3,119 @@\n \n import com.yahoo.concurrent.ThreadFactoryFactory;\n \n+import java.util.concurrent.Executor;\n import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.SynchronousQueue;\n import java.util.concurrent.ThreadPoolExecutor;\n import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n \n-class Connector {\n+class Connector implements AutoCloseable {\n \n-    private final ExecutorService executor = new ThreadPoolExecutor(1, 64, 1L, TimeUnit.SECONDS,\n-                                                                    new LinkedBlockingQueue<>(),\n-                                                                    ThreadFactoryFactory.getDaemonThreadFactory(\"jrt.connector\"));\n+    private static final Object globalLock = new Object();\n+    private static ExecutorService globalPrimaryExecutor = null;\n+    private static ExecutorService globalFallbackExecutor = null;\n+    private static long usages = 0;\n \n-    private void connect(Connection conn) {\n-        conn.transportThread().addConnection(conn.connect());\n+    private static class ExecutorWithFallback implements Executor {", "originalCommit": "d7d87a8e45e0dace606493dfed2f903a614b76f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzk0NTU2Mg==", "url": "https://github.com/vespa-engine/vespa/pull/12332#discussion_r383945562", "bodyText": "Added TODO", "author": "baldersheim", "createdAt": "2020-02-25T15:19:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkzMjY1MA=="}], "type": "inlineReview"}, {"oid": "62ea092d9fba83670a6b9923ec776d910c331d37", "url": "https://github.com/vespa-engine/vespa/commit/62ea092d9fba83670a6b9923ec776d910c331d37", "message": "Add sanity checks and avoid codeduplicationi after codereview.", "committedDate": "2020-02-25T15:18:21Z", "type": "commit"}]}