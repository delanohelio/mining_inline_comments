{"pr_number": 2168, "pr_title": "[HUDI-1331] Adding support for validating entire dataset and long running tests in test suite framework", "pr_createdAt": "2020-10-11T04:05:07Z", "pr_url": "https://github.com/apache/hudi/pull/2168", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjg2MjkxOQ==", "url": "https://github.com/apache/hudi/pull/2168#discussion_r502862919", "bodyText": "as of now, I have kept it simple with thread.sleep. but open to ideas on how to add delays. Initially I thought we could schedule testsuitejob every time, but haven't thought through completely on whether we need a single test suite job to run and manage delays on its own or can we initiate a test suite job everytime from cron job kind of thing.", "author": "nsivabalan", "createdAt": "2020-10-11T04:14:16Z", "path": "hudi-integ-test/src/main/java/org/apache/hudi/integ/testsuite/dag/nodes/DelayNode.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.integ.testsuite.dag.nodes;\n+\n+import org.apache.hudi.integ.testsuite.dag.ExecutionContext;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Delay Node to add delays between each group of test runs.\n+ */\n+public class DelayNode extends DagNode<Boolean> {\n+\n+  private static Logger log = LoggerFactory.getLogger(ValidateDatasetNode.class);\n+  private int delayMins;\n+\n+  public DelayNode(int delayMins) {\n+    this.delayMins = delayMins;\n+  }\n+\n+  @Override\n+  public void execute(ExecutionContext context) throws Exception {\n+    log.warn(\"Waiting for \"+ delayMins+\" mins before going for next test run\");", "originalCommit": "f7ba49cc8652da0c77da6af506af715740c127d5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9e50d66861aa789edc66507517386f63c011feaa", "url": "https://github.com/apache/hudi/commit/9e50d66861aa789edc66507517386f63c011feaa", "message": "Adding hive table validation to ValidateDatasetNode", "committedDate": "2020-10-28T13:01:31Z", "type": "forcePushed"}, {"oid": "33d41db7ded16a4af924127b656ce80722bd7bf4", "url": "https://github.com/apache/hudi/commit/33d41db7ded16a4af924127b656ce80722bd7bf4", "message": "Adding hive table validation to ValidateDatasetNode", "committedDate": "2020-10-28T13:02:07Z", "type": "forcePushed"}, {"oid": "58227327470dac31c48430997dcc2e9a2d0a0291", "url": "https://github.com/apache/hudi/commit/58227327470dac31c48430997dcc2e9a2d0a0291", "message": "trigger rebuild", "committedDate": "2020-11-03T23:54:46Z", "type": "commit"}, {"oid": "1ed56f5d3b64debbca7397b2d5037cf6787a6cb0", "url": "https://github.com/apache/hudi/commit/1ed56f5d3b64debbca7397b2d5037cf6787a6cb0", "message": "[HUDI-1156] Remove unused dependencies from HoodieDeltaStreamerWrapper Class (#1927)", "committedDate": "2020-11-03T23:54:46Z", "type": "commit"}, {"oid": "f8e4bba5b0a6bf35140463ba8271002083a04cee", "url": "https://github.com/apache/hudi/commit/f8e4bba5b0a6bf35140463ba8271002083a04cee", "message": "Adding support for validating records and long running tests in test sutie framework", "committedDate": "2020-11-04T00:26:09Z", "type": "commit"}, {"oid": "45fd1bf484a5f556b87797bb611c21b26dea21b2", "url": "https://github.com/apache/hudi/commit/45fd1bf484a5f556b87797bb611c21b26dea21b2", "message": "Adding partial validate node", "committedDate": "2020-11-04T00:26:13Z", "type": "commit"}, {"oid": "a4e765e48e99944dd495cea1e42f5a31ff7dd71e", "url": "https://github.com/apache/hudi/commit/a4e765e48e99944dd495cea1e42f5a31ff7dd71e", "message": "Fixing spark session initiation in Validate nodes", "committedDate": "2020-11-04T00:26:14Z", "type": "commit"}, {"oid": "8e3a63883c778b38b5f1cb16d042357118a3bb12", "url": "https://github.com/apache/hudi/commit/8e3a63883c778b38b5f1cb16d042357118a3bb12", "message": "Fixing validation", "committedDate": "2020-11-04T01:21:28Z", "type": "commit"}, {"oid": "e4cd457cae554d5b4e84b1a481a79085320905a0", "url": "https://github.com/apache/hudi/commit/e4cd457cae554d5b4e84b1a481a79085320905a0", "message": "Adding hive table validation to ValidateDatasetNode", "committedDate": "2020-11-04T01:21:32Z", "type": "commit"}, {"oid": "8feb5a0995ba602ca5042a0fb7ed0f68dc251f4b", "url": "https://github.com/apache/hudi/commit/8feb5a0995ba602ca5042a0fb7ed0f68dc251f4b", "message": "Rebasing with latest commits from master", "committedDate": "2020-11-04T05:17:31Z", "type": "commit"}, {"oid": "8feb5a0995ba602ca5042a0fb7ed0f68dc251f4b", "url": "https://github.com/apache/hudi/commit/8feb5a0995ba602ca5042a0fb7ed0f68dc251f4b", "message": "Rebasing with latest commits from master", "committedDate": "2020-11-04T05:17:31Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDEzMzQzNg==", "url": "https://github.com/apache/hudi/pull/2168#discussion_r520133436", "bodyText": "@nsivabalan\nCan we avoid introducing these high level arguments numRound and delayMins to the dagScheduler ? This messes with a simpler design and adds unnecessary overloading to the constructor.\nInstead, we could do something like this\nIntroduce a top level yaml change around this\ndag_name:\ndag_rounds:\ndag_intermittent_delay:\ndag_props:\ndag_content:\ninsert_node:\n...\nupsert_node:\n...\nYou can then introduce a concept called RuntimeComposableDagNode that basically wraps this concept.\nLet me know.", "author": "n3nash", "createdAt": "2020-11-09T21:32:04Z", "path": "hudi-integ-test/src/main/java/org/apache/hudi/integ/testsuite/HoodieTestSuiteJob.java", "diffHunk": "@@ -147,7 +147,7 @@ public void runTestSuite() {\n       long startTime = System.currentTimeMillis();\n       WriterContext writerContext = new WriterContext(jsc, props, cfg, keyGenerator, sparkSession);\n       writerContext.initContext(jsc);\n-      DagScheduler dagScheduler = new DagScheduler(workflowDag, writerContext);\n+      DagScheduler dagScheduler = new DagScheduler(workflowDag, writerContext, jsc, cfg.numRounds, cfg.delayMins);", "originalCommit": "8feb5a0995ba602ca5042a0fb7ed0f68dc251f4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDEzMzk3Nw==", "url": "https://github.com/apache/hudi/pull/2168#discussion_r520133977", "bodyText": "Can you explain why we need to introduce these 2 fields ? Also, please comment why the preCombineFieldValue is \"int\" ?", "author": "n3nash", "createdAt": "2020-11-09T21:33:07Z", "path": "hudi-integ-test/src/main/java/org/apache/hudi/integ/testsuite/converter/UpdateConverter.java", "diffHunk": "@@ -35,19 +37,23 @@\n   private final List<String> partitionPathFields;\n   private final List<String> recordKeyFields;\n   private final int minPayloadSize;\n+  private final String preCombineField;\n+  private final int preCombineFieldValue;\n \n-  public UpdateConverter(String schemaStr, int minPayloadSize, List<String> partitionPathFields,\n-      List<String> recordKeyFields) {\n+  public  UpdateConverter(String schemaStr, int minPayloadSize, List<String> partitionPathFields,\n+      List<String> recordKeyFields, String preCombineField, int preCombineFieldValue) {", "originalCommit": "8feb5a0995ba602ca5042a0fb7ed0f68dc251f4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDE2MDkwNA==", "url": "https://github.com/apache/hudi/pull/2168#discussion_r520160904", "bodyText": "This is problematic since we cannot test other types of partitioning. It's OK for now, can you add a TODO here ?", "author": "n3nash", "createdAt": "2020-11-09T22:27:02Z", "path": "hudi-integ-test/src/main/java/org/apache/hudi/integ/testsuite/dag/nodes/ValidateDatasetNode.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.integ.testsuite.dag.nodes;\n+\n+import org.apache.hudi.common.model.HoodieRecord;\n+import org.apache.hudi.integ.testsuite.configuration.DeltaConfig.Config;\n+import org.apache.hudi.integ.testsuite.dag.ExecutionContext;\n+\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.spark.api.java.function.MapFunction;\n+import org.apache.spark.api.java.function.ReduceFunction;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Encoders;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.SparkSession;\n+import org.apache.spark.sql.catalyst.analysis.SimpleAnalyzer$;\n+import org.apache.spark.sql.catalyst.encoders.ExpressionEncoder;\n+import org.apache.spark.sql.catalyst.encoders.RowEncoder;\n+import org.apache.spark.sql.catalyst.expressions.Attribute;\n+import org.apache.spark.sql.types.StructType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import scala.Tuple2;\n+import scala.collection.JavaConversions;\n+import scala.collection.JavaConverters;\n+\n+/**\n+ * This nodes validates contents from input path are in tact with Hudi. This nodes uses spark datasource for comparison purposes. By default no configs are required for this node. But there is an\n+ * optional config \"delete_input_data\" that you can set for this node. If set, once validation completes, contents from inputPath are deleted. This will come in handy for long running test suites.\n+ * README has more details under docker set up for usages of this node.\n+ */\n+public class ValidateDatasetNode extends DagNode<Boolean> {\n+\n+  private static Logger log = LoggerFactory.getLogger(ValidateDatasetNode.class);\n+\n+  public ValidateDatasetNode(Config config) {\n+    this.config = config;\n+  }\n+\n+  @Override\n+  public void execute(ExecutionContext context) throws Exception {\n+\n+    SparkSession session = SparkSession.builder().sparkContext(context.getJsc().sc()).getOrCreate();\n+\n+    String inputPath = context.getHoodieTestSuiteWriter().getCfg().inputBasePath + \"/*/*\";\n+    String hudiPath = context.getHoodieTestSuiteWriter().getCfg().targetBasePath + \"/*/*/*\";", "originalCommit": "8feb5a0995ba602ca5042a0fb7ed0f68dc251f4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDE2MTA5Mw==", "url": "https://github.com/apache/hudi/pull/2168#discussion_r520161093", "bodyText": "There should be a config for inputBasePath ?", "author": "n3nash", "createdAt": "2020-11-09T22:27:23Z", "path": "hudi-integ-test/src/main/java/org/apache/hudi/integ/testsuite/dag/nodes/ValidateDatasetNode.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.integ.testsuite.dag.nodes;\n+\n+import org.apache.hudi.common.model.HoodieRecord;\n+import org.apache.hudi.integ.testsuite.configuration.DeltaConfig.Config;\n+import org.apache.hudi.integ.testsuite.dag.ExecutionContext;\n+\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.spark.api.java.function.MapFunction;\n+import org.apache.spark.api.java.function.ReduceFunction;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Encoders;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.SparkSession;\n+import org.apache.spark.sql.catalyst.analysis.SimpleAnalyzer$;\n+import org.apache.spark.sql.catalyst.encoders.ExpressionEncoder;\n+import org.apache.spark.sql.catalyst.encoders.RowEncoder;\n+import org.apache.spark.sql.catalyst.expressions.Attribute;\n+import org.apache.spark.sql.types.StructType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import scala.Tuple2;\n+import scala.collection.JavaConversions;\n+import scala.collection.JavaConverters;\n+\n+/**\n+ * This nodes validates contents from input path are in tact with Hudi. This nodes uses spark datasource for comparison purposes. By default no configs are required for this node. But there is an\n+ * optional config \"delete_input_data\" that you can set for this node. If set, once validation completes, contents from inputPath are deleted. This will come in handy for long running test suites.\n+ * README has more details under docker set up for usages of this node.\n+ */\n+public class ValidateDatasetNode extends DagNode<Boolean> {\n+\n+  private static Logger log = LoggerFactory.getLogger(ValidateDatasetNode.class);\n+\n+  public ValidateDatasetNode(Config config) {\n+    this.config = config;\n+  }\n+\n+  @Override\n+  public void execute(ExecutionContext context) throws Exception {\n+\n+    SparkSession session = SparkSession.builder().sparkContext(context.getJsc().sc()).getOrCreate();\n+\n+    String inputPath = context.getHoodieTestSuiteWriter().getCfg().inputBasePath + \"/*/*\";\n+    String hudiPath = context.getHoodieTestSuiteWriter().getCfg().targetBasePath + \"/*/*/*\";\n+    log.warn(\"ValidateDataset Node: Input path \" + inputPath + \", hudi path \" + hudiPath);\n+    // listing batches to be validated\n+    String inputPathStr = context.getHoodieTestSuiteWriter().getCfg().targetBasePath + \"/../input/\";", "originalCommit": "8feb5a0995ba602ca5042a0fb7ed0f68dc251f4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDE2MTQyOQ==", "url": "https://github.com/apache/hudi/pull/2168#discussion_r520161429", "bodyText": "Can you make this \"TODO\" ?", "author": "n3nash", "createdAt": "2020-11-09T22:28:05Z", "path": "hudi-integ-test/src/main/java/org/apache/hudi/integ/testsuite/dag/nodes/ValidateDatasetNode.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.integ.testsuite.dag.nodes;\n+\n+import org.apache.hudi.common.model.HoodieRecord;\n+import org.apache.hudi.integ.testsuite.configuration.DeltaConfig.Config;\n+import org.apache.hudi.integ.testsuite.dag.ExecutionContext;\n+\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.spark.api.java.function.MapFunction;\n+import org.apache.spark.api.java.function.ReduceFunction;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Encoders;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.SparkSession;\n+import org.apache.spark.sql.catalyst.analysis.SimpleAnalyzer$;\n+import org.apache.spark.sql.catalyst.encoders.ExpressionEncoder;\n+import org.apache.spark.sql.catalyst.encoders.RowEncoder;\n+import org.apache.spark.sql.catalyst.expressions.Attribute;\n+import org.apache.spark.sql.types.StructType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import scala.Tuple2;\n+import scala.collection.JavaConversions;\n+import scala.collection.JavaConverters;\n+\n+/**\n+ * This nodes validates contents from input path are in tact with Hudi. This nodes uses spark datasource for comparison purposes. By default no configs are required for this node. But there is an\n+ * optional config \"delete_input_data\" that you can set for this node. If set, once validation completes, contents from inputPath are deleted. This will come in handy for long running test suites.\n+ * README has more details under docker set up for usages of this node.\n+ */\n+public class ValidateDatasetNode extends DagNode<Boolean> {\n+\n+  private static Logger log = LoggerFactory.getLogger(ValidateDatasetNode.class);\n+\n+  public ValidateDatasetNode(Config config) {\n+    this.config = config;\n+  }\n+\n+  @Override\n+  public void execute(ExecutionContext context) throws Exception {\n+\n+    SparkSession session = SparkSession.builder().sparkContext(context.getJsc().sc()).getOrCreate();\n+\n+    String inputPath = context.getHoodieTestSuiteWriter().getCfg().inputBasePath + \"/*/*\";\n+    String hudiPath = context.getHoodieTestSuiteWriter().getCfg().targetBasePath + \"/*/*/*\";\n+    log.warn(\"ValidateDataset Node: Input path \" + inputPath + \", hudi path \" + hudiPath);\n+    // listing batches to be validated\n+    String inputPathStr = context.getHoodieTestSuiteWriter().getCfg().targetBasePath + \"/../input/\";\n+    FileSystem fs = new Path(inputPathStr)\n+        .getFileSystem(context.getHoodieTestSuiteWriter().getConfiguration());\n+    FileStatus[] fileStatuses = fs.listStatus(new Path(inputPathStr));\n+    for (FileStatus fileStatus : fileStatuses) {\n+      log.debug(\"Listing all Micro batches to be validated :: \" + fileStatus.getPath().toString());\n+    }\n+\n+    // fix hard coded fields from configs.\n+    // read input and resolve insert, updates, etc.", "originalCommit": "8feb5a0995ba602ca5042a0fb7ed0f68dc251f4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDE2MjA1Nw==", "url": "https://github.com/apache/hudi/pull/2168#discussion_r520162057", "bodyText": "Can we take the database names and table names from config ?", "author": "n3nash", "createdAt": "2020-11-09T22:29:30Z", "path": "hudi-integ-test/src/main/java/org/apache/hudi/integ/testsuite/dag/nodes/ValidateDatasetNode.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.integ.testsuite.dag.nodes;\n+\n+import org.apache.hudi.common.model.HoodieRecord;\n+import org.apache.hudi.integ.testsuite.configuration.DeltaConfig.Config;\n+import org.apache.hudi.integ.testsuite.dag.ExecutionContext;\n+\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.spark.api.java.function.MapFunction;\n+import org.apache.spark.api.java.function.ReduceFunction;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Encoders;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.SparkSession;\n+import org.apache.spark.sql.catalyst.analysis.SimpleAnalyzer$;\n+import org.apache.spark.sql.catalyst.encoders.ExpressionEncoder;\n+import org.apache.spark.sql.catalyst.encoders.RowEncoder;\n+import org.apache.spark.sql.catalyst.expressions.Attribute;\n+import org.apache.spark.sql.types.StructType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import scala.Tuple2;\n+import scala.collection.JavaConversions;\n+import scala.collection.JavaConverters;\n+\n+/**\n+ * This nodes validates contents from input path are in tact with Hudi. This nodes uses spark datasource for comparison purposes. By default no configs are required for this node. But there is an\n+ * optional config \"delete_input_data\" that you can set for this node. If set, once validation completes, contents from inputPath are deleted. This will come in handy for long running test suites.\n+ * README has more details under docker set up for usages of this node.\n+ */\n+public class ValidateDatasetNode extends DagNode<Boolean> {\n+\n+  private static Logger log = LoggerFactory.getLogger(ValidateDatasetNode.class);\n+\n+  public ValidateDatasetNode(Config config) {\n+    this.config = config;\n+  }\n+\n+  @Override\n+  public void execute(ExecutionContext context) throws Exception {\n+\n+    SparkSession session = SparkSession.builder().sparkContext(context.getJsc().sc()).getOrCreate();\n+\n+    String inputPath = context.getHoodieTestSuiteWriter().getCfg().inputBasePath + \"/*/*\";\n+    String hudiPath = context.getHoodieTestSuiteWriter().getCfg().targetBasePath + \"/*/*/*\";\n+    log.warn(\"ValidateDataset Node: Input path \" + inputPath + \", hudi path \" + hudiPath);\n+    // listing batches to be validated\n+    String inputPathStr = context.getHoodieTestSuiteWriter().getCfg().targetBasePath + \"/../input/\";\n+    FileSystem fs = new Path(inputPathStr)\n+        .getFileSystem(context.getHoodieTestSuiteWriter().getConfiguration());\n+    FileStatus[] fileStatuses = fs.listStatus(new Path(inputPathStr));\n+    for (FileStatus fileStatus : fileStatuses) {\n+      log.debug(\"Listing all Micro batches to be validated :: \" + fileStatus.getPath().toString());\n+    }\n+\n+    // fix hard coded fields from configs.\n+    // read input and resolve insert, updates, etc.\n+    Dataset<Row> inputDf = session.read().format(\"avro\").load(inputPath);\n+    ExpressionEncoder encoder = getEncoder(inputDf.schema());\n+    Dataset<Row> inputSnapshotDf = inputDf.groupByKey(\n+        (MapFunction<Row, String>) value -> value.getAs(\"timestamp\") + \"+\" + value.getAs(\"_row_key\"), Encoders.STRING())\n+        .reduceGroups((ReduceFunction<Row>) (v1, v2) -> {\n+          long ts1 = v1.getAs(\"ts\");\n+          long ts2 = v2.getAs(\"ts\");\n+          if (ts1 > ts2) {\n+            return v1;\n+          } else {\n+            return v2;\n+          }\n+        })\n+        .map((MapFunction<Tuple2<String, Row>, Row>) value -> value._2, encoder);\n+\n+    // read from hudi and remove meta columns.\n+    Dataset<Row> hudiDf = session.read().format(\"hudi\").load(hudiPath);\n+    Dataset<Row> trimmedDf = hudiDf.drop(HoodieRecord.COMMIT_TIME_METADATA_FIELD).drop(HoodieRecord.COMMIT_SEQNO_METADATA_FIELD).drop(HoodieRecord.RECORD_KEY_METADATA_FIELD)\n+        .drop(HoodieRecord.PARTITION_PATH_METADATA_FIELD).drop(HoodieRecord.FILENAME_METADATA_FIELD);\n+\n+    Dataset<Row> intersectionDf = inputSnapshotDf.intersect(trimmedDf);\n+    // the intersected df should be same as inputDf. if not, there is some mismatch.\n+    if (inputSnapshotDf.except(intersectionDf).count() != 0) {\n+      log.error(\"Data set validation failed. Total count in hudi \" + trimmedDf.count() + \", input df count \" + inputSnapshotDf.count());\n+      throw new AssertionError(\"Hudi contents does not match contents input data. \");\n+    } \n+\n+    log.warn(\"Validating hive table \");\n+    Dataset<Row> cowDf = session.sql(\"SELECT * FROM testdb.table1\");", "originalCommit": "8feb5a0995ba602ca5042a0fb7ed0f68dc251f4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDE2MjEzMQ==", "url": "https://github.com/apache/hudi/pull/2168#discussion_r520162131", "bodyText": "Same comment here", "author": "n3nash", "createdAt": "2020-11-09T22:29:41Z", "path": "hudi-integ-test/src/main/java/org/apache/hudi/integ/testsuite/dag/nodes/ValidateDatasetNode.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.integ.testsuite.dag.nodes;\n+\n+import org.apache.hudi.common.model.HoodieRecord;\n+import org.apache.hudi.integ.testsuite.configuration.DeltaConfig.Config;\n+import org.apache.hudi.integ.testsuite.dag.ExecutionContext;\n+\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.spark.api.java.function.MapFunction;\n+import org.apache.spark.api.java.function.ReduceFunction;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Encoders;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.SparkSession;\n+import org.apache.spark.sql.catalyst.analysis.SimpleAnalyzer$;\n+import org.apache.spark.sql.catalyst.encoders.ExpressionEncoder;\n+import org.apache.spark.sql.catalyst.encoders.RowEncoder;\n+import org.apache.spark.sql.catalyst.expressions.Attribute;\n+import org.apache.spark.sql.types.StructType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import scala.Tuple2;\n+import scala.collection.JavaConversions;\n+import scala.collection.JavaConverters;\n+\n+/**\n+ * This nodes validates contents from input path are in tact with Hudi. This nodes uses spark datasource for comparison purposes. By default no configs are required for this node. But there is an\n+ * optional config \"delete_input_data\" that you can set for this node. If set, once validation completes, contents from inputPath are deleted. This will come in handy for long running test suites.\n+ * README has more details under docker set up for usages of this node.\n+ */\n+public class ValidateDatasetNode extends DagNode<Boolean> {\n+\n+  private static Logger log = LoggerFactory.getLogger(ValidateDatasetNode.class);\n+\n+  public ValidateDatasetNode(Config config) {\n+    this.config = config;\n+  }\n+\n+  @Override\n+  public void execute(ExecutionContext context) throws Exception {\n+\n+    SparkSession session = SparkSession.builder().sparkContext(context.getJsc().sc()).getOrCreate();\n+\n+    String inputPath = context.getHoodieTestSuiteWriter().getCfg().inputBasePath + \"/*/*\";\n+    String hudiPath = context.getHoodieTestSuiteWriter().getCfg().targetBasePath + \"/*/*/*\";\n+    log.warn(\"ValidateDataset Node: Input path \" + inputPath + \", hudi path \" + hudiPath);\n+    // listing batches to be validated\n+    String inputPathStr = context.getHoodieTestSuiteWriter().getCfg().targetBasePath + \"/../input/\";\n+    FileSystem fs = new Path(inputPathStr)\n+        .getFileSystem(context.getHoodieTestSuiteWriter().getConfiguration());\n+    FileStatus[] fileStatuses = fs.listStatus(new Path(inputPathStr));\n+    for (FileStatus fileStatus : fileStatuses) {\n+      log.debug(\"Listing all Micro batches to be validated :: \" + fileStatus.getPath().toString());\n+    }\n+\n+    // fix hard coded fields from configs.\n+    // read input and resolve insert, updates, etc.\n+    Dataset<Row> inputDf = session.read().format(\"avro\").load(inputPath);\n+    ExpressionEncoder encoder = getEncoder(inputDf.schema());\n+    Dataset<Row> inputSnapshotDf = inputDf.groupByKey(\n+        (MapFunction<Row, String>) value -> value.getAs(\"timestamp\") + \"+\" + value.getAs(\"_row_key\"), Encoders.STRING())\n+        .reduceGroups((ReduceFunction<Row>) (v1, v2) -> {\n+          long ts1 = v1.getAs(\"ts\");\n+          long ts2 = v2.getAs(\"ts\");\n+          if (ts1 > ts2) {\n+            return v1;\n+          } else {\n+            return v2;\n+          }\n+        })\n+        .map((MapFunction<Tuple2<String, Row>, Row>) value -> value._2, encoder);\n+\n+    // read from hudi and remove meta columns.\n+    Dataset<Row> hudiDf = session.read().format(\"hudi\").load(hudiPath);\n+    Dataset<Row> trimmedDf = hudiDf.drop(HoodieRecord.COMMIT_TIME_METADATA_FIELD).drop(HoodieRecord.COMMIT_SEQNO_METADATA_FIELD).drop(HoodieRecord.RECORD_KEY_METADATA_FIELD)\n+        .drop(HoodieRecord.PARTITION_PATH_METADATA_FIELD).drop(HoodieRecord.FILENAME_METADATA_FIELD);\n+\n+    Dataset<Row> intersectionDf = inputSnapshotDf.intersect(trimmedDf);\n+    // the intersected df should be same as inputDf. if not, there is some mismatch.\n+    if (inputSnapshotDf.except(intersectionDf).count() != 0) {\n+      log.error(\"Data set validation failed. Total count in hudi \" + trimmedDf.count() + \", input df count \" + inputSnapshotDf.count());\n+      throw new AssertionError(\"Hudi contents does not match contents input data. \");\n+    } \n+\n+    log.warn(\"Validating hive table \");\n+    Dataset<Row> cowDf = session.sql(\"SELECT * FROM testdb.table1\");\n+    Dataset<Row> trimmedCowDf = cowDf.drop(HoodieRecord.COMMIT_TIME_METADATA_FIELD).drop(HoodieRecord.COMMIT_SEQNO_METADATA_FIELD).drop(HoodieRecord.RECORD_KEY_METADATA_FIELD)\n+        .drop(HoodieRecord.PARTITION_PATH_METADATA_FIELD).drop(HoodieRecord.FILENAME_METADATA_FIELD);\n+    intersectionDf = inputSnapshotDf.intersect(trimmedDf);\n+    // the intersected df should be same as inputDf. if not, there is some mismatch.\n+    if (inputSnapshotDf.except(intersectionDf).count() != 0) {\n+      log.error(\"Data set validation failed for COW hive table. Total count in hudi \" + trimmedCowDf.count() + \", input df count \" + inputSnapshotDf.count());\n+      throw new AssertionError(\"Hudi hive table contents does not match contents input data. \");\n+    }\n+\n+    // if delete input data is enabled, erase input data.\n+    if (config.isDeleteInputData()) {\n+      // clean up input data for current group of writes.\n+      inputPathStr = context.getHoodieTestSuiteWriter().getCfg().targetBasePath + \"/../input/\";", "originalCommit": "8feb5a0995ba602ca5042a0fb7ed0f68dc251f4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f91cb6a43c1d6c98d50715fdfef5e9696614033d", "url": "https://github.com/apache/hudi/commit/f91cb6a43c1d6c98d50715fdfef5e9696614033d", "message": "Addressing feedback", "committedDate": "2020-11-21T19:34:34Z", "type": "forcePushed"}, {"oid": "bb66e344ded7f737da619f08f23efce9e3409fa0", "url": "https://github.com/apache/hudi/commit/bb66e344ded7f737da619f08f23efce9e3409fa0", "message": "Addressing feedback", "committedDate": "2020-11-21T19:58:55Z", "type": "commit"}, {"oid": "bb66e344ded7f737da619f08f23efce9e3409fa0", "url": "https://github.com/apache/hudi/commit/bb66e344ded7f737da619f08f23efce9e3409fa0", "message": "Addressing feedback", "committedDate": "2020-11-21T19:58:55Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODIzNDQxOA==", "url": "https://github.com/apache/hudi/pull/2168#discussion_r528234418", "bodyText": "high level config param parsing.", "author": "nsivabalan", "createdAt": "2020-11-21T19:38:19Z", "path": "hudi-integ-test/src/main/java/org/apache/hudi/integ/testsuite/dag/DagUtils.java", "diffHunk": "@@ -62,15 +71,38 @@ public static WorkflowDag convertYamlPathToDag(FileSystem fs, String path) throw\n    * Converts a YAML representation to {@link WorkflowDag}.\n    */\n   public static WorkflowDag convertYamlToDag(String yaml) throws IOException {\n+    int dagRounds = DEFAULT_DAG_ROUNDS;\n+    int intermittentDelayMins = DEFAULT_INTERMITTENT_DELAY_MINS;\n+    String dagName = DEFAULT_DAG_NAME;\n     Map<String, DagNode> allNodes = new HashMap<>();\n     final ObjectMapper yamlReader = new ObjectMapper(new YAMLFactory());\n     final JsonNode jsonNode = yamlReader.readTree(yaml);\n     Iterator<Entry<String, JsonNode>> itr = jsonNode.fields();\n     while (itr.hasNext()) {\n       Entry<String, JsonNode> dagNode = itr.next();\n-      allNodes.put(dagNode.getKey(), convertJsonToDagNode(allNodes, dagNode.getKey(), dagNode.getValue()));\n+      String key = dagNode.getKey();\n+      switch (key) {\n+        case DAG_NAME:", "originalCommit": "f91cb6a43c1d6c98d50715fdfef5e9696614033d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODIzNDQ1Ng==", "url": "https://github.com/apache/hudi/pull/2168#discussion_r528234456", "bodyText": "as agreed, all node contents go into \"dag_content\"", "author": "nsivabalan", "createdAt": "2020-11-21T19:38:45Z", "path": "hudi-integ-test/src/main/java/org/apache/hudi/integ/testsuite/dag/DagUtils.java", "diffHunk": "@@ -62,15 +71,38 @@ public static WorkflowDag convertYamlPathToDag(FileSystem fs, String path) throw\n    * Converts a YAML representation to {@link WorkflowDag}.\n    */\n   public static WorkflowDag convertYamlToDag(String yaml) throws IOException {\n+    int dagRounds = DEFAULT_DAG_ROUNDS;\n+    int intermittentDelayMins = DEFAULT_INTERMITTENT_DELAY_MINS;\n+    String dagName = DEFAULT_DAG_NAME;\n     Map<String, DagNode> allNodes = new HashMap<>();\n     final ObjectMapper yamlReader = new ObjectMapper(new YAMLFactory());\n     final JsonNode jsonNode = yamlReader.readTree(yaml);\n     Iterator<Entry<String, JsonNode>> itr = jsonNode.fields();\n     while (itr.hasNext()) {\n       Entry<String, JsonNode> dagNode = itr.next();\n-      allNodes.put(dagNode.getKey(), convertJsonToDagNode(allNodes, dagNode.getKey(), dagNode.getValue()));\n+      String key = dagNode.getKey();\n+      switch (key) {\n+        case DAG_NAME:\n+          dagName = dagNode.getValue().asText();\n+          break;\n+        case DAG_ROUNDS:\n+          dagRounds = dagNode.getValue().asInt();\n+          break;\n+        case DAG_INTERMITTENT_DELAY_MINS:\n+          intermittentDelayMins = dagNode.getValue().asInt();\n+          break;\n+        case DAG_CONTENT:", "originalCommit": "f91cb6a43c1d6c98d50715fdfef5e9696614033d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODIzNDYzMA==", "url": "https://github.com/apache/hudi/pull/2168#discussion_r528234630", "bodyText": "may I know where or how to fetch the record key and partition path field. I don't see any thing exposed in deltastreamer config. as of now, I am hardcoding it here.", "author": "nsivabalan", "createdAt": "2020-11-21T19:40:14Z", "path": "hudi-integ-test/src/main/java/org/apache/hudi/integ/testsuite/dag/nodes/ValidateDatasetNode.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.integ.testsuite.dag.nodes;\n+\n+import org.apache.hudi.common.model.HoodieRecord;\n+import org.apache.hudi.integ.testsuite.configuration.DeltaConfig.Config;\n+import org.apache.hudi.integ.testsuite.dag.ExecutionContext;\n+import org.apache.hudi.integ.testsuite.schema.SchemaUtils;\n+\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.spark.api.java.function.MapFunction;\n+import org.apache.spark.api.java.function.ReduceFunction;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Encoders;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.SparkSession;\n+import org.apache.spark.sql.catalyst.analysis.SimpleAnalyzer$;\n+import org.apache.spark.sql.catalyst.encoders.ExpressionEncoder;\n+import org.apache.spark.sql.catalyst.encoders.RowEncoder;\n+import org.apache.spark.sql.catalyst.expressions.Attribute;\n+import org.apache.spark.sql.types.StructType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import scala.Tuple2;\n+import scala.collection.JavaConversions;\n+import scala.collection.JavaConverters;\n+\n+/**\n+ * This nodes validates contents from input path are in tact with Hudi. This nodes uses spark datasource for comparison purposes. By default no configs are required for this node. But there is an\n+ * optional config \"delete_input_data\" that you can set for this node. If set, once validation completes, contents from inputPath are deleted. This will come in handy for long running test suites.\n+ * README has more details under docker set up for usages of this node.\n+ */\n+public class ValidateDatasetNode extends DagNode<Boolean> {\n+\n+  private static Logger log = LoggerFactory.getLogger(ValidateDatasetNode.class);\n+\n+  public ValidateDatasetNode(Config config) {\n+    this.config = config;\n+  }\n+\n+  @Override\n+  public void execute(ExecutionContext context) throws Exception {\n+\n+    SparkSession session = SparkSession.builder().sparkContext(context.getJsc().sc()).getOrCreate();\n+\n+    // todo: Fix partitioning schemes. For now, assumes data based partitioning.\n+    String inputPath = context.getHoodieTestSuiteWriter().getCfg().inputBasePath + \"/*/*\";\n+    String hudiPath = context.getHoodieTestSuiteWriter().getCfg().targetBasePath + \"/*/*/*\";\n+    log.warn(\"ValidateDataset Node: Input path \" + inputPath + \", hudi path \" + hudiPath);\n+    // listing batches to be validated\n+    String inputPathStr = context.getHoodieTestSuiteWriter().getCfg().inputBasePath;\n+    FileSystem fs = new Path(inputPathStr)\n+        .getFileSystem(context.getHoodieTestSuiteWriter().getConfiguration());\n+    FileStatus[] fileStatuses = fs.listStatus(new Path(inputPathStr));\n+    for (FileStatus fileStatus : fileStatuses) {\n+      log.debug(\"Listing all Micro batches to be validated :: \" + fileStatus.getPath().toString());\n+    }\n+\n+    // todo: fix hard coded fields from configs.\n+    // read input and resolve insert, updates, etc.\n+    Dataset<Row> inputDf = session.read().format(\"avro\").load(inputPath);\n+    ExpressionEncoder encoder = getEncoder(inputDf.schema());\n+    Dataset<Row> inputSnapshotDf = inputDf.groupByKey(\n+        (MapFunction<Row, String>) value -> value.getAs(\"timestamp\") + \"+\" + value.getAs(\"_row_key\"), Encoders.STRING())", "originalCommit": "f91cb6a43c1d6c98d50715fdfef5e9696614033d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODIzNDc2MQ==", "url": "https://github.com/apache/hudi/pull/2168#discussion_r528234761", "bodyText": "I didn't make a whole lot of change from last time. I exposed the global params in workflowDag and using it wherever required. like rounds, delay etc. Felt this is simple and achieves our goal.", "author": "nsivabalan", "createdAt": "2020-11-21T19:41:38Z", "path": "hudi-integ-test/src/main/java/org/apache/hudi/integ/testsuite/dag/scheduler/DagScheduler.java", "diffHunk": "@@ -77,33 +79,47 @@ public void schedule() throws Exception {\n    * Method to start executing the nodes in workflow DAGs.\n    *\n    * @param service ExecutorService\n-   * @param nodes Nodes to be executed\n+   * @param workflowDag instance of workflow dag that needs to be executed\n    * @throws Exception will be thrown if ant error occurred\n    */\n-  private void execute(ExecutorService service, List<DagNode> nodes) throws Exception {\n+  private void execute(ExecutorService service, WorkflowDag workflowDag) throws Exception {", "originalCommit": "f91cb6a43c1d6c98d50715fdfef5e9696614033d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODIzNDk2MA==", "url": "https://github.com/apache/hudi/pull/2168#discussion_r528234960", "bodyText": "Added this schemaProvider to append the source ordering field to source and target schema.", "author": "nsivabalan", "createdAt": "2020-11-21T19:44:20Z", "path": "hudi-integ-test/src/main/java/org/apache/hudi/integ/testsuite/schema/TestSuiteFileBasedSchemaProvider.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.integ.testsuite.schema;\n+\n+import org.apache.hudi.common.config.TypedProperties;\n+import org.apache.hudi.integ.testsuite.dag.WriterContext;\n+import org.apache.hudi.utilities.schema.FilebasedSchemaProvider;\n+\n+import org.apache.avro.Schema;\n+import org.apache.avro.Schema.Field;\n+import org.apache.avro.Schema.Type;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+import org.apache.spark.api.java.JavaSparkContext;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class TestSuiteFileBasedSchemaProvider extends FilebasedSchemaProvider {", "originalCommit": "f91cb6a43c1d6c98d50715fdfef5e9696614033d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODIzNTAyMA==", "url": "https://github.com/apache/hudi/pull/2168#discussion_r528235020", "bodyText": "this is where the source ordering field is set.", "author": "nsivabalan", "createdAt": "2020-11-21T19:44:44Z", "path": "hudi-integ-test/src/main/java/org/apache/hudi/integ/testsuite/writer/DFSDeltaWriterAdapter.java", "diffHunk": "@@ -30,22 +32,29 @@\n  */\n public class DFSDeltaWriterAdapter implements DeltaWriterAdapter<GenericRecord> {\n \n-  private DeltaInputWriter deltaInputGenerator;\n+  private DeltaInputWriter deltaInputWriter;\n   private List<DeltaWriteStats> metrics = new ArrayList<>();\n+  private int preCombineFieldVal = 0;\n+\n+  public DFSDeltaWriterAdapter(DeltaInputWriter<GenericRecord> deltaInputWriter, int preCombineFieldVal) {\n+    this.deltaInputWriter = deltaInputWriter;\n+    this.preCombineFieldVal = preCombineFieldVal;\n+  }\n \n-  public DFSDeltaWriterAdapter(DeltaInputWriter<GenericRecord> deltaInputGenerator) {\n-    this.deltaInputGenerator = deltaInputGenerator;\n+  public DFSDeltaWriterAdapter(DeltaInputWriter<GenericRecord> deltaInputWriter) {\n+    this.deltaInputWriter = deltaInputWriter;\n   }\n \n   @Override\n   public List<DeltaWriteStats> write(Iterator<GenericRecord> input) throws IOException {\n     while (input.hasNext()) {\n       GenericRecord next = input.next();\n-      if (this.deltaInputGenerator.canWrite()) {\n-        this.deltaInputGenerator.writeData(next);\n-      } else if (input.hasNext()) {\n+      next.put(SchemaUtils.SOURCE_ORDERING_FIELD, preCombineFieldVal);", "originalCommit": "f91cb6a43c1d6c98d50715fdfef5e9696614033d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODIzNTIwMA==", "url": "https://github.com/apache/hudi/pull/2168#discussion_r528235200", "bodyText": "since I am introducing a test schema provider to append source ordering field, I had to make this protected since the test schema provider extends from this.", "author": "nsivabalan", "createdAt": "2020-11-21T19:46:25Z", "path": "hudi-utilities/src/main/java/org/apache/hudi/utilities/schema/FilebasedSchemaProvider.java", "diffHunk": "@@ -46,9 +46,9 @@\n \n   private final FileSystem fs;\n \n-  private final Schema sourceSchema;\n+  protected Schema sourceSchema;", "originalCommit": "f91cb6a43c1d6c98d50715fdfef5e9696614033d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODIzNjYwNQ==", "url": "https://github.com/apache/hudi/pull/2168#discussion_r528236605", "bodyText": "is this the right way to fetch record key and partition path field ?", "author": "nsivabalan", "createdAt": "2020-11-21T20:00:30Z", "path": "hudi-integ-test/src/main/java/org/apache/hudi/integ/testsuite/dag/nodes/ValidateDatasetNode.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.integ.testsuite.dag.nodes;\n+\n+import org.apache.hudi.DataSourceWriteOptions;\n+import org.apache.hudi.common.model.HoodieRecord;\n+import org.apache.hudi.integ.testsuite.configuration.DeltaConfig.Config;\n+import org.apache.hudi.integ.testsuite.dag.ExecutionContext;\n+import org.apache.hudi.integ.testsuite.schema.SchemaUtils;\n+\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.spark.api.java.function.MapFunction;\n+import org.apache.spark.api.java.function.ReduceFunction;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Encoders;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.SparkSession;\n+import org.apache.spark.sql.catalyst.analysis.SimpleAnalyzer$;\n+import org.apache.spark.sql.catalyst.encoders.ExpressionEncoder;\n+import org.apache.spark.sql.catalyst.encoders.RowEncoder;\n+import org.apache.spark.sql.catalyst.expressions.Attribute;\n+import org.apache.spark.sql.types.StructType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import scala.Tuple2;\n+import scala.collection.JavaConversions;\n+import scala.collection.JavaConverters;\n+\n+/**\n+ * This nodes validates contents from input path are in tact with Hudi. This nodes uses spark datasource for comparison purposes. By default no configs are required for this node. But there is an\n+ * optional config \"delete_input_data\" that you can set for this node. If set, once validation completes, contents from inputPath are deleted. This will come in handy for long running test suites.\n+ * README has more details under docker set up for usages of this node.\n+ */\n+public class ValidateDatasetNode extends DagNode<Boolean> {\n+\n+  private static Logger log = LoggerFactory.getLogger(ValidateDatasetNode.class);\n+\n+  public ValidateDatasetNode(Config config) {\n+    this.config = config;\n+  }\n+\n+  @Override\n+  public void execute(ExecutionContext context) throws Exception {\n+\n+    SparkSession session = SparkSession.builder().sparkContext(context.getJsc().sc()).getOrCreate();\n+\n+    // todo: Fix partitioning schemes. For now, assumes data based partitioning.\n+    String inputPath = context.getHoodieTestSuiteWriter().getCfg().inputBasePath + \"/*/*\";\n+    String hudiPath = context.getHoodieTestSuiteWriter().getCfg().targetBasePath + \"/*/*/*\";\n+    log.warn(\"ValidateDataset Node: Input path \" + inputPath + \", hudi path \" + hudiPath);\n+    // listing batches to be validated\n+    String inputPathStr = context.getHoodieTestSuiteWriter().getCfg().inputBasePath;\n+    FileSystem fs = new Path(inputPathStr)\n+        .getFileSystem(context.getHoodieTestSuiteWriter().getConfiguration());\n+    FileStatus[] fileStatuses = fs.listStatus(new Path(inputPathStr));\n+    for (FileStatus fileStatus : fileStatuses) {\n+      log.debug(\"Listing all Micro batches to be validated :: \" + fileStatus.getPath().toString());\n+    }\n+\n+    String recordKeyField = context.getWriterContext().getProps().getString(DataSourceWriteOptions.RECORDKEY_FIELD_OPT_KEY());", "originalCommit": "bb66e344ded7f737da619f08f23efce9e3409fa0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODgzMjcyOA==", "url": "https://github.com/apache/hudi/pull/2168#discussion_r538832728", "bodyText": "@nsivabalan This will just fetch the KEY names, I'm guessing you need the values for these keys ?", "author": "n3nash", "createdAt": "2020-12-08T21:49:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODIzNjYwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ4MzQ4Nw==", "url": "https://github.com/apache/hudi/pull/2168#discussion_r540483487", "bodyText": "nope. just the record key and partition path field names. we need to group by Hoodiekey in df\ninputDf.groupByKey(\n        (MapFunction<Row, String>) value -> partitionPathField + \"+\" + recordKeyField, Encoders.STRING())", "author": "nsivabalan", "createdAt": "2020-12-10T20:43:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODIzNjYwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODIzNjY0Ng==", "url": "https://github.com/apache/hudi/pull/2168#discussion_r528236646", "bodyText": "again, couldn't find a better way to fetch db and table name. LMK if there are other better ways", "author": "nsivabalan", "createdAt": "2020-11-21T20:01:01Z", "path": "hudi-integ-test/src/main/java/org/apache/hudi/integ/testsuite/dag/nodes/ValidateDatasetNode.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.integ.testsuite.dag.nodes;\n+\n+import org.apache.hudi.DataSourceWriteOptions;\n+import org.apache.hudi.common.model.HoodieRecord;\n+import org.apache.hudi.integ.testsuite.configuration.DeltaConfig.Config;\n+import org.apache.hudi.integ.testsuite.dag.ExecutionContext;\n+import org.apache.hudi.integ.testsuite.schema.SchemaUtils;\n+\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.spark.api.java.function.MapFunction;\n+import org.apache.spark.api.java.function.ReduceFunction;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Encoders;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.SparkSession;\n+import org.apache.spark.sql.catalyst.analysis.SimpleAnalyzer$;\n+import org.apache.spark.sql.catalyst.encoders.ExpressionEncoder;\n+import org.apache.spark.sql.catalyst.encoders.RowEncoder;\n+import org.apache.spark.sql.catalyst.expressions.Attribute;\n+import org.apache.spark.sql.types.StructType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import scala.Tuple2;\n+import scala.collection.JavaConversions;\n+import scala.collection.JavaConverters;\n+\n+/**\n+ * This nodes validates contents from input path are in tact with Hudi. This nodes uses spark datasource for comparison purposes. By default no configs are required for this node. But there is an\n+ * optional config \"delete_input_data\" that you can set for this node. If set, once validation completes, contents from inputPath are deleted. This will come in handy for long running test suites.\n+ * README has more details under docker set up for usages of this node.\n+ */\n+public class ValidateDatasetNode extends DagNode<Boolean> {\n+\n+  private static Logger log = LoggerFactory.getLogger(ValidateDatasetNode.class);\n+\n+  public ValidateDatasetNode(Config config) {\n+    this.config = config;\n+  }\n+\n+  @Override\n+  public void execute(ExecutionContext context) throws Exception {\n+\n+    SparkSession session = SparkSession.builder().sparkContext(context.getJsc().sc()).getOrCreate();\n+\n+    // todo: Fix partitioning schemes. For now, assumes data based partitioning.\n+    String inputPath = context.getHoodieTestSuiteWriter().getCfg().inputBasePath + \"/*/*\";\n+    String hudiPath = context.getHoodieTestSuiteWriter().getCfg().targetBasePath + \"/*/*/*\";\n+    log.warn(\"ValidateDataset Node: Input path \" + inputPath + \", hudi path \" + hudiPath);\n+    // listing batches to be validated\n+    String inputPathStr = context.getHoodieTestSuiteWriter().getCfg().inputBasePath;\n+    FileSystem fs = new Path(inputPathStr)\n+        .getFileSystem(context.getHoodieTestSuiteWriter().getConfiguration());\n+    FileStatus[] fileStatuses = fs.listStatus(new Path(inputPathStr));\n+    for (FileStatus fileStatus : fileStatuses) {\n+      log.debug(\"Listing all Micro batches to be validated :: \" + fileStatus.getPath().toString());\n+    }\n+\n+    String recordKeyField = context.getWriterContext().getProps().getString(DataSourceWriteOptions.RECORDKEY_FIELD_OPT_KEY());\n+    String partitionPathField = context.getWriterContext().getProps().getString(DataSourceWriteOptions.PARTITIONPATH_FIELD_OPT_KEY());\n+    // todo: fix hard coded fields from configs.\n+    // read input and resolve insert, updates, etc.\n+    Dataset<Row> inputDf = session.read().format(\"avro\").load(inputPath);\n+    ExpressionEncoder encoder = getEncoder(inputDf.schema());\n+    Dataset<Row> inputSnapshotDf = inputDf.groupByKey(\n+        (MapFunction<Row, String>) value -> partitionPathField + \"+\" + recordKeyField, Encoders.STRING())\n+        .reduceGroups((ReduceFunction<Row>) (v1, v2) -> {\n+          int ts1 = v1.getAs(SchemaUtils.SOURCE_ORDERING_FIELD);\n+          int ts2 = v2.getAs(SchemaUtils.SOURCE_ORDERING_FIELD);\n+          if (ts1 > ts2) {\n+            return v1;\n+          } else {\n+            return v2;\n+          }\n+        })\n+        .map((MapFunction<Tuple2<String, Row>, Row>) value -> value._2, encoder);\n+\n+    // read from hudi and remove meta columns.\n+    Dataset<Row> hudiDf = session.read().format(\"hudi\").load(hudiPath);\n+    Dataset<Row> trimmedDf = hudiDf.drop(HoodieRecord.COMMIT_TIME_METADATA_FIELD).drop(HoodieRecord.COMMIT_SEQNO_METADATA_FIELD).drop(HoodieRecord.RECORD_KEY_METADATA_FIELD)\n+        .drop(HoodieRecord.PARTITION_PATH_METADATA_FIELD).drop(HoodieRecord.FILENAME_METADATA_FIELD);\n+\n+    Dataset<Row> intersectionDf = inputSnapshotDf.intersect(trimmedDf);\n+    // the intersected df should be same as inputDf. if not, there is some mismatch.\n+    if (inputSnapshotDf.except(intersectionDf).count() != 0) {\n+      log.error(\"Data set validation failed. Total count in hudi \" + trimmedDf.count() + \", input df count \" + inputSnapshotDf.count());\n+      throw new AssertionError(\"Hudi contents does not match contents input data. \");\n+    }\n+\n+    String database = context.getWriterContext().getProps().getString(\"hoodie.datasource.hive_sync.database\");\n+    String tableName = context.getWriterContext().getProps().getString(\"hoodie.datasource.hive_sync.table\");", "originalCommit": "bb66e344ded7f737da619f08f23efce9e3409fa0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODgzMzk2Mg==", "url": "https://github.com/apache/hudi/pull/2168#discussion_r538833962", "bodyText": "Can you use this config instead of the hard coding -> https://github.com/apache/hudi/blob/master/hudi-spark/src/main/scala/org/apache/hudi/DataSourceOptions.scala#L298 ? Same for the second one as well", "author": "n3nash", "createdAt": "2020-12-08T21:51:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODIzNjY0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODgzNjM2Nw==", "url": "https://github.com/apache/hudi/pull/2168#discussion_r538836367", "bodyText": "The name can be in caps (TestDagName), no need for camecasing..", "author": "n3nash", "createdAt": "2020-12-08T21:55:17Z", "path": "hudi-integ-test/src/main/java/org/apache/hudi/integ/testsuite/dag/DagUtils.java", "diffHunk": "@@ -48,6 +48,15 @@\n  */\n public class DagUtils {\n \n+  public static final String DAG_NAME = \"dag_name\";\n+  public static final String DAG_ROUNDS = \"dag_rounds\";\n+  public static final String DAG_INTERMITTENT_DELAY_MINS = \"dag_intermittent_delay_mins\";\n+  public static final String DAG_CONTENT = \"dag_content\";\n+\n+  public static int DEFAULT_DAG_ROUNDS = 1;\n+  public static int DEFAULT_INTERMITTENT_DELAY_MINS = 10;\n+  public static String DEFAULT_DAG_NAME = \"testDagName\";", "originalCommit": "bb66e344ded7f737da619f08f23efce9e3409fa0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "bc2ff513c06431641c1e14bf4263c2c118b4500e", "url": "https://github.com/apache/hudi/commit/bc2ff513c06431641c1e14bf4263c2c118b4500e", "message": "Addressing comments", "committedDate": "2020-12-18T07:01:47Z", "type": "commit"}, {"oid": "bc2ff513c06431641c1e14bf4263c2c118b4500e", "url": "https://github.com/apache/hudi/commit/bc2ff513c06431641c1e14bf4263c2c118b4500e", "message": "Addressing comments", "committedDate": "2020-12-18T07:01:47Z", "type": "forcePushed"}]}