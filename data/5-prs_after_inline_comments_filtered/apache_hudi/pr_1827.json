{"pr_number": 1827, "pr_title": "[HUDI-1089] Refactor hudi-client to support multi-engine", "pr_createdAt": "2020-07-14T11:56:30Z", "pr_url": "https://github.com/apache/hudi/pull/1827", "timeline": [{"oid": "9d7a51de66b0198df85c04d93d2e73ed5381714c", "url": "https://github.com/apache/hudi/commit/9d7a51de66b0198df85c04d93d2e73ed5381714c", "message": "Renaming some Abstract* classes as Hoodie* to improve readability", "committedDate": "2020-10-01T16:13:53Z", "type": "commit"}, {"oid": "9d7a51de66b0198df85c04d93d2e73ed5381714c", "url": "https://github.com/apache/hudi/commit/9d7a51de66b0198df85c04d93d2e73ed5381714c", "message": "Renaming some Abstract* classes as Hoodie* to improve readability", "committedDate": "2020-10-01T16:13:53Z", "type": "forcePushed"}, {"oid": "137da2b4ab862e16a48cfba84d56fc61ca762d69", "url": "https://github.com/apache/hudi/commit/137da2b4ab862e16a48cfba84d56fc61ca762d69", "message": "fix Unable to find driver bind address from spark config", "committedDate": "2020-10-01T18:21:52Z", "type": "commit"}, {"oid": "13795f5c1223424d44244e46acb0864b93ec403e", "url": "https://github.com/apache/hudi/commit/13795f5c1223424d44244e46acb0864b93ec403e", "message": "[HUDI-1089] Refactor hudi-client to support multi-engine", "committedDate": "2020-07-15T15:22:08Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTcwMjIwNg==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r455702206", "bodyText": "The new style or the old style, which one is right?", "author": "yanghua", "createdAt": "2020-07-16T10:58:14Z", "path": "hudi-cli/src/main/java/org/apache/hudi/cli/commands/CompactionCommand.java", "diffHunk": "@@ -593,8 +592,8 @@ public String repairCompaction(\n     return output;\n   }\n \n-  private String getRenamesToBePrinted(List<RenameOpResult> res, Integer limit, String sortByField, boolean descending,\n-      boolean headerOnly, String operation) {\n+  private String getRenamesToBePrinted(List<BaseCompactionAdminClient.RenameOpResult> res, Integer limit, String sortByField, boolean descending,\n+                                       boolean headerOnly, String operation) {", "originalCommit": "13795f5c1223424d44244e46acb0864b93ec403e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIzOTM4NQ==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r456239385", "bodyText": "Hi, @yanghua thanks for your review. I am not sure which one is right either, I will roll back these style issues just to keep as same as before.", "author": "wangxianghu", "createdAt": "2020-07-17T06:14:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTcwMjIwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTcwNTI1OA==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r455705258", "bodyText": "Why do we need to change this class?", "author": "yanghua", "createdAt": "2020-07-16T11:04:11Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/io/storage/HoodieParquetWriter.java", "diffHunk": "@@ -40,7 +39,7 @@\n  * HoodieParquetWriter extends the ParquetWriter to help limit the size of underlying file. Provides a way to check if\n  * the current file can take more records with the <code>canWrite()</code>\n  */\n-public class HoodieParquetWriter<T extends HoodieRecordPayload, R extends IndexedRecord>\n+public class HoodieParquetWriter<R extends IndexedRecord>", "originalCommit": "13795f5c1223424d44244e46acb0864b93ec403e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI0NzcyMQ==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r456247721", "bodyText": "Why do we need to change this class?\n\nThe Generic \"T\" is useless in this class, and it causes some generic problems in the abstraction, so I removed it.", "author": "wangxianghu", "createdAt": "2020-07-17T06:38:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTcwNTI1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk4MDc1MQ==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r456980751", "bodyText": "Just bump into this... Since this is a generic engine context, will it be better to use a generic name like engineConfig?", "author": "henrywu2019", "createdAt": "2020-07-20T01:04:42Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/common/HoodieEngineContext.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.common;\n+\n+import org.apache.hudi.client.TaskContextSupplier;\n+import org.apache.hudi.common.config.SerializableConfiguration;\n+\n+/**\n+ * Base class contains the context information needed by the engine at runtime. It will be extended by different\n+ * engine implementation if needed.\n+ */\n+public class HoodieEngineContext {\n+  /**\n+   * A wrapped hadoop configuration which can be serialized.\n+   */\n+  private SerializableConfiguration hadoopConf;", "originalCommit": "88c6661e865945059f782880c395547c16ef1a1c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzEyNzAwNA==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r457127004", "bodyText": "Just bump into this... Since this is a generic engine context, will it be better to use a generic name like engineConfig?\n\nHi, henry thanks for your review. This class holds more than config stuff(your can see its child class HoodieSparkEngineContext),  maybe context is better, WDYT\uff1f", "author": "wangxianghu", "createdAt": "2020-07-20T07:24:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk4MDc1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzEyODk4OA==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r457128988", "bodyText": "", "author": "wangxianghu", "createdAt": "2020-07-20T07:27:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk4MDc1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc5ODQyNg==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r457798426", "bodyText": "Oh...What I meant is at line 32 the name hadoopConf, not the class name, which implies hadoop. I bumped into this searching for Flink support from HUDI and this PR looks a big step moving in that direction. Thanks tons @Mathieu1124 and definitely @vinothchandar as well.", "author": "henrywu2019", "createdAt": "2020-07-21T02:26:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk4MDc1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA5Njk4Nw==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484096987", "bodyText": "I am okay leaving it as hadoopConf given that's what we wrap. leave it you both :)", "author": "vinothchandar", "createdAt": "2020-09-06T17:51:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk4MDc1MQ=="}], "type": "inlineReview"}, {"oid": "b30f9738a504ac28bdb30485b83a1313ee3ee248", "url": "https://github.com/apache/hudi/commit/b30f9738a504ac28bdb30485b83a1313ee3ee248", "message": "resolve conflicts", "committedDate": "2020-07-20T11:21:19Z", "type": "forcePushed"}, {"oid": "39db50b5e64666e7f688a83aa06e7096cdf8ce16", "url": "https://github.com/apache/hudi/commit/39db50b5e64666e7f688a83aa06e7096cdf8ce16", "message": "mv class to hudi-client-common", "committedDate": "2020-07-21T11:53:45Z", "type": "forcePushed"}, {"oid": "9fa51f49f38ef3b80fa391b27fc45d9d2d424ed2", "url": "https://github.com/apache/hudi/commit/9fa51f49f38ef3b80fa391b27fc45d9d2d424ed2", "message": "rebase master", "committedDate": "2020-07-22T15:34:37Z", "type": "forcePushed"}, {"oid": "c42bed02e73b74d730d489ebb0a8ce297d074517", "url": "https://github.com/apache/hudi/commit/c42bed02e73b74d730d489ebb0a8ce297d074517", "message": "rebase master", "committedDate": "2020-07-22T15:35:49Z", "type": "forcePushed"}, {"oid": "56dfec1d2da5b27397ee7821cd90aa3e81728f56", "url": "https://github.com/apache/hudi/commit/56dfec1d2da5b27397ee7821cd90aa3e81728f56", "message": "fix conflicts", "committedDate": "2020-07-30T15:31:03Z", "type": "forcePushed"}, {"oid": "b5c1ad3daaf17404d22e52efd54687687dc9d1a2", "url": "https://github.com/apache/hudi/commit/b5c1ad3daaf17404d22e52efd54687687dc9d1a2", "message": "fix conflicts", "committedDate": "2020-08-19T15:49:09Z", "type": "forcePushed"}, {"oid": "85a8457d29d315c4c7f1766e46ad4fca5ab211e9", "url": "https://github.com/apache/hudi/commit/85a8457d29d315c4c7f1766e46ad4fca5ab211e9", "message": "[HUDI-1089] [WIP]Refactor hudi-client to support multi-engine", "committedDate": "2020-08-20T12:39:10Z", "type": "forcePushed"}, {"oid": "2d9cc47260d6f35584db45b75261fbbd343c7b0c", "url": "https://github.com/apache/hudi/commit/2d9cc47260d6f35584db45b75261fbbd343c7b0c", "message": "finish index refactor", "committedDate": "2020-08-21T03:32:22Z", "type": "forcePushed"}, {"oid": "e7e8cb85fc7ee38bcbc56a6c2479931d4fde4fcb", "url": "https://github.com/apache/hudi/commit/e7e8cb85fc7ee38bcbc56a6c2479931d4fde4fcb", "message": "finish index refactor", "committedDate": "2020-08-21T07:21:35Z", "type": "forcePushed"}, {"oid": "b8d06e925943ee02d5e19ae89256b5aa404e197d", "url": "https://github.com/apache/hudi/commit/b8d06e925943ee02d5e19ae89256b5aa404e197d", "message": "rebase master WIP", "committedDate": "2020-08-21T10:13:31Z", "type": "forcePushed"}, {"oid": "958dac8b6c33b0ee46645c901f0ee0fafcd0f846", "url": "https://github.com/apache/hudi/commit/958dac8b6c33b0ee46645c901f0ee0fafcd0f846", "message": "rebase master WIP", "committedDate": "2020-08-23T03:58:42Z", "type": "forcePushed"}, {"oid": "009fae91da08a60624f054cebff04d5c59077251", "url": "https://github.com/apache/hudi/commit/009fae91da08a60624f054cebff04d5c59077251", "message": "abstract Helper class and write client", "committedDate": "2020-08-24T13:06:54Z", "type": "forcePushed"}, {"oid": "1c7d03a43097ffecf404dda29dd5aaa74fde95ca", "url": "https://github.com/apache/hudi/commit/1c7d03a43097ffecf404dda29dd5aaa74fde95ca", "message": "finish most source class", "committedDate": "2020-08-27T15:31:57Z", "type": "forcePushed"}, {"oid": "48cf8c614f745ec91612cf1ba04063838891d8e5", "url": "https://github.com/apache/hudi/commit/48cf8c614f745ec91612cf1ba04063838891d8e5", "message": "rebase master", "committedDate": "2020-08-30T04:33:48Z", "type": "forcePushed"}, {"oid": "e755bf5d58817c627aeda63c504902ef504b9de5", "url": "https://github.com/apache/hudi/commit/e755bf5d58817c627aeda63c504902ef504b9de5", "message": "Make it compilable", "committedDate": "2020-08-30T11:46:09Z", "type": "forcePushed"}, {"oid": "74a0af4ffab2de6032e90ac31e0aae3787823a86", "url": "https://github.com/apache/hudi/commit/74a0af4ffab2de6032e90ac31e0aae3787823a86", "message": "Make it compilable", "committedDate": "2020-08-30T11:48:13Z", "type": "forcePushed"}, {"oid": "cd697a95bafc5ae0566a8cacbe8c4a93c053a91f", "url": "https://github.com/apache/hudi/commit/cd697a95bafc5ae0566a8cacbe8c4a93c053a91f", "message": "Make it compilable", "committedDate": "2020-08-30T12:14:27Z", "type": "forcePushed"}, {"oid": "57660f91ea21db5d011af54511abbe9a2c75b5c7", "url": "https://github.com/apache/hudi/commit/57660f91ea21db5d011af54511abbe9a2c75b5c7", "message": "Make it compilable", "committedDate": "2020-08-30T16:18:15Z", "type": "forcePushed"}, {"oid": "0808014b1b90aadcef14ccb8907b4215ccafe586", "url": "https://github.com/apache/hudi/commit/0808014b1b90aadcef14ccb8907b4215ccafe586", "message": "Make it compilable", "committedDate": "2020-08-31T09:43:57Z", "type": "forcePushed"}, {"oid": "5d6f909a4006cfb8c54b6ed70baa2256077cab4e", "url": "https://github.com/apache/hudi/commit/5d6f909a4006cfb8c54b6ed70baa2256077cab4e", "message": "Make it compilable", "committedDate": "2020-08-31T15:04:30Z", "type": "forcePushed"}, {"oid": "4d71c51ba6a1dd2401473a668565b965b37505a3", "url": "https://github.com/apache/hudi/commit/4d71c51ba6a1dd2401473a668565b965b37505a3", "message": "rebase master", "committedDate": "2020-08-31T15:57:40Z", "type": "forcePushed"}, {"oid": "9d83635dd77d77d003946c6d39c5aaeb64c975a4", "url": "https://github.com/apache/hudi/commit/9d83635dd77d77d003946c6d39c5aaeb64c975a4", "message": "rebase master", "committedDate": "2020-08-31T16:50:36Z", "type": "forcePushed"}, {"oid": "a7b3a4e268842d87ebace4c03d7f12dd3be1f103", "url": "https://github.com/apache/hudi/commit/a7b3a4e268842d87ebace4c03d7f12dd3be1f103", "message": "rebase master", "committedDate": "2020-09-01T16:42:44Z", "type": "forcePushed"}, {"oid": "93fa69ebbc770c191c6834330e0bcb2898eba88b", "url": "https://github.com/apache/hudi/commit/93fa69ebbc770c191c6834330e0bcb2898eba88b", "message": "rebase master", "committedDate": "2020-09-01T16:51:21Z", "type": "forcePushed"}, {"oid": "c51ef79e9c7fb5ff47558d701b37c73b16499834", "url": "https://github.com/apache/hudi/commit/c51ef79e9c7fb5ff47558d701b37c73b16499834", "message": "rebase master", "committedDate": "2020-09-01T17:40:25Z", "type": "forcePushed"}, {"oid": "abf3c654665362be70a78392f638d0ae7ad7bc6d", "url": "https://github.com/apache/hudi/commit/abf3c654665362be70a78392f638d0ae7ad7bc6d", "message": "rebase master", "committedDate": "2020-09-02T15:06:58Z", "type": "forcePushed"}, {"oid": "3901bcbcc191319a8cd7394f0f058b6c5e28d566", "url": "https://github.com/apache/hudi/commit/3901bcbcc191319a8cd7394f0f058b6c5e28d566", "message": "rebase master", "committedDate": "2020-09-03T15:27:15Z", "type": "forcePushed"}, {"oid": "7902ca9485788a5eada5e8f2b0bd0b0389ad90a3", "url": "https://github.com/apache/hudi/commit/7902ca9485788a5eada5e8f2b0bd0b0389ad90a3", "message": "rebase master", "committedDate": "2020-09-05T09:48:06Z", "type": "forcePushed"}, {"oid": "3e637ea42d9228eacbb4d76bb9f551334a05f01d", "url": "https://github.com/apache/hudi/commit/3e637ea42d9228eacbb4d76bb9f551334a05f01d", "message": "rebase master", "committedDate": "2020-09-05T09:52:53Z", "type": "forcePushed"}, {"oid": "32d00412e619964df8ded5c8bd273d941f23acf8", "url": "https://github.com/apache/hudi/commit/32d00412e619964df8ded5c8bd273d941f23acf8", "message": "rebase master", "committedDate": "2020-09-05T10:18:42Z", "type": "forcePushed"}, {"oid": "e13408780ee7dfd29680551d397ecdc0b4d6505f", "url": "https://github.com/apache/hudi/commit/e13408780ee7dfd29680551d397ecdc0b4d6505f", "message": "rebase master", "committedDate": "2020-09-06T03:52:05Z", "type": "forcePushed"}, {"oid": "f16ded111e1cef45443da8df30c3d060a82758e8", "url": "https://github.com/apache/hudi/commit/f16ded111e1cef45443da8df30c3d060a82758e8", "message": "rebase master", "committedDate": "2020-09-06T05:02:44Z", "type": "forcePushed"}, {"oid": "71ad86f3a89e42fabbcb6d0ebb2734113c8c2323", "url": "https://github.com/apache/hudi/commit/71ad86f3a89e42fabbcb6d0ebb2734113c8c2323", "message": "rebase master", "committedDate": "2020-09-06T05:59:51Z", "type": "forcePushed"}, {"oid": "36573ef00199fc7648c2cbf543f811f1697306f2", "url": "https://github.com/apache/hudi/commit/36573ef00199fc7648c2cbf543f811f1697306f2", "message": "rebase master", "committedDate": "2020-09-06T13:19:56Z", "type": "forcePushed"}, {"oid": "28eecab55cb62bb602e6ed7fe1cb9d5b188a87df", "url": "https://github.com/apache/hudi/commit/28eecab55cb62bb602e6ed7fe1cb9d5b188a87df", "message": "rebase master", "committedDate": "2020-09-06T14:29:42Z", "type": "forcePushed"}, {"oid": "2348f73b4a270e4d04d2f67f9d7bd9691391b569", "url": "https://github.com/apache/hudi/commit/2348f73b4a270e4d04d2f67f9d7bd9691391b569", "message": "rebase master", "committedDate": "2020-09-06T15:41:07Z", "type": "forcePushed"}, {"oid": "ac3339704c703741f9ff50f2d96019cef2d2c72b", "url": "https://github.com/apache/hudi/commit/ac3339704c703741f9ff50f2d96019cef2d2c72b", "message": "rebase master", "committedDate": "2020-09-06T16:35:49Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzI5MTAwNw==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r483291007", "bodyText": "nit: extra line.", "author": "vinothchandar", "createdAt": "2020-09-03T22:41:18Z", "path": "hudi-cli/src/test/java/org/apache/hudi/cli/commands/TestArchivedCommitsCommand.java", "diffHunk": "@@ -92,8 +92,9 @@ public void init() throws IOException {\n     metaClient.getActiveTimeline().reload().getAllCommitsTimeline().filterCompletedInstants();\n \n     // archive\n-    HoodieTimelineArchiveLog archiveLog = new HoodieTimelineArchiveLog(cfg, hadoopConf);\n-    archiveLog.archiveIfRequired(jsc);\n+", "originalCommit": "3901bcbcc191319a8cd7394f0f058b6c5e28d566", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzI5MTcwNQ==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r483291705", "bodyText": "typo: async", "author": "vinothchandar", "createdAt": "2020-09-03T22:43:39Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/asyc/AbstractAsyncService.java", "diffHunk": "@@ -16,7 +16,7 @@\n  * limitations under the License.\n  */\n \n-package org.apache.hudi.async;\n+package org.apache.hudi.asyc;", "originalCommit": "3901bcbcc191319a8cd7394f0f058b6c5e28d566", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDgxNTEwNA==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484815104", "bodyText": "done", "author": "wangxianghu", "createdAt": "2020-09-08T10:28:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzI5MTcwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA4MjkzNg==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484082936", "bodyText": "not sure if this is right. index must be not be needed at the the write client level.", "author": "vinothchandar", "createdAt": "2020-09-06T15:25:44Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -18,120 +18,195 @@\n \n package org.apache.hudi.client;\n \n+import com.codahale.metrics.Timer;\n+import org.apache.hadoop.conf.Configuration;\n import org.apache.hudi.avro.model.HoodieCleanMetadata;\n import org.apache.hudi.avro.model.HoodieCompactionPlan;\n import org.apache.hudi.avro.model.HoodieRestoreMetadata;\n import org.apache.hudi.avro.model.HoodieRollbackMetadata;\n-import org.apache.hudi.client.embedded.EmbeddedTimelineService;\n+import org.apache.hudi.callback.HoodieWriteCommitCallback;\n+import org.apache.hudi.callback.common.HoodieWriteCommitCallbackMessage;\n+import org.apache.hudi.callback.util.HoodieCommitCallbackFactory;\n+import org.apache.hudi.client.embebbed.BaseEmbeddedTimelineService;\n+import org.apache.hudi.common.HoodieEngineContext;\n import org.apache.hudi.common.model.HoodieCommitMetadata;\n import org.apache.hudi.common.model.HoodieKey;\n-import org.apache.hudi.common.model.HoodieRecord;\n import org.apache.hudi.common.model.HoodieRecordPayload;\n import org.apache.hudi.common.model.HoodieWriteStat;\n import org.apache.hudi.common.model.WriteOperationType;\n import org.apache.hudi.common.table.HoodieTableMetaClient;\n import org.apache.hudi.common.table.timeline.HoodieActiveTimeline;\n import org.apache.hudi.common.table.timeline.HoodieInstant;\n-import org.apache.hudi.common.table.timeline.HoodieInstant.State;\n import org.apache.hudi.common.table.timeline.HoodieTimeline;\n import org.apache.hudi.common.util.Option;\n import org.apache.hudi.common.util.ValidationUtils;\n-import org.apache.hudi.config.HoodieCompactionConfig;\n import org.apache.hudi.config.HoodieWriteConfig;\n+\n import org.apache.hudi.exception.HoodieCommitException;\n import org.apache.hudi.exception.HoodieIOException;\n import org.apache.hudi.exception.HoodieRestoreException;\n import org.apache.hudi.exception.HoodieRollbackException;\n import org.apache.hudi.exception.HoodieSavepointException;\n import org.apache.hudi.index.HoodieIndex;\n import org.apache.hudi.metrics.HoodieMetrics;\n-import org.apache.hudi.table.HoodieTable;\n-import org.apache.hudi.table.HoodieTimelineArchiveLog;\n-import org.apache.hudi.table.MarkerFiles;\n import org.apache.hudi.table.BulkInsertPartitioner;\n+import org.apache.hudi.table.HoodieTable;\n import org.apache.hudi.table.action.HoodieWriteMetadata;\n-import org.apache.hudi.table.action.compact.CompactHelpers;\n import org.apache.hudi.table.action.savepoint.SavepointHelpers;\n-\n-import com.codahale.metrics.Timer;\n import org.apache.log4j.LogManager;\n import org.apache.log4j.Logger;\n-import org.apache.spark.SparkConf;\n-import org.apache.spark.api.java.JavaRDD;\n-import org.apache.spark.api.java.JavaSparkContext;\n \n import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n import java.text.ParseException;\n import java.util.Collection;\n import java.util.List;\n import java.util.Map;\n import java.util.stream.Collectors;\n \n /**\n- * Hoodie Write Client helps you build tables on HDFS [insert()] and then perform efficient mutations on an HDFS\n- * table [upsert()]\n- * <p>\n- * Note that, at any given time, there can only be one Spark job performing these operations on a Hoodie table.\n+ * Abstract Write Client providing functionality for performing commit, index updates and rollback\n+ * Reused for regular write operations like upsert/insert/bulk-insert.. as well as bootstrap\n+ *\n+ * @param <T> Sub type of HoodieRecordPayload\n+ * @param <I> Type of inputs\n+ * @param <K> Type of keys\n+ * @param <O> Type of outputs\n+ * @param <P> Type of record position [Key, Option[partitionPath, fileID]] in hoodie table\n  */\n-public class HoodieWriteClient<T extends HoodieRecordPayload> extends AbstractHoodieWriteClient<T> {\n-\n+public abstract class AbstractHoodieWriteClient<T extends HoodieRecordPayload, I, K, O, P> extends AbstractHoodieClient {\n   private static final long serialVersionUID = 1L;\n-  private static final Logger LOG = LogManager.getLogger(HoodieWriteClient.class);\n-  private static final String LOOKUP_STR = \"lookup\";\n-  private final boolean rollbackPending;\n-  private final transient HoodieMetrics metrics;\n-  private transient Timer.Context compactionTimer;\n+  private static final Logger LOG = LogManager.getLogger(AbstractHoodieWriteClient.class);\n+\n+  protected final transient HoodieMetrics metrics;\n+  private final transient HoodieIndex<T, I, K, O, P> index;", "originalCommit": "28eecab55cb62bb602e6ed7fe1cb9d5b188a87df", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA4MzA3MQ==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484083071", "bodyText": "can we move all the static members to the top, like how it was before.", "author": "vinothchandar", "createdAt": "2020-09-06T15:27:01Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -18,120 +18,195 @@\n \n package org.apache.hudi.client;\n \n+import com.codahale.metrics.Timer;\n+import org.apache.hadoop.conf.Configuration;\n import org.apache.hudi.avro.model.HoodieCleanMetadata;\n import org.apache.hudi.avro.model.HoodieCompactionPlan;\n import org.apache.hudi.avro.model.HoodieRestoreMetadata;\n import org.apache.hudi.avro.model.HoodieRollbackMetadata;\n-import org.apache.hudi.client.embedded.EmbeddedTimelineService;\n+import org.apache.hudi.callback.HoodieWriteCommitCallback;\n+import org.apache.hudi.callback.common.HoodieWriteCommitCallbackMessage;\n+import org.apache.hudi.callback.util.HoodieCommitCallbackFactory;\n+import org.apache.hudi.client.embebbed.BaseEmbeddedTimelineService;\n+import org.apache.hudi.common.HoodieEngineContext;\n import org.apache.hudi.common.model.HoodieCommitMetadata;\n import org.apache.hudi.common.model.HoodieKey;\n-import org.apache.hudi.common.model.HoodieRecord;\n import org.apache.hudi.common.model.HoodieRecordPayload;\n import org.apache.hudi.common.model.HoodieWriteStat;\n import org.apache.hudi.common.model.WriteOperationType;\n import org.apache.hudi.common.table.HoodieTableMetaClient;\n import org.apache.hudi.common.table.timeline.HoodieActiveTimeline;\n import org.apache.hudi.common.table.timeline.HoodieInstant;\n-import org.apache.hudi.common.table.timeline.HoodieInstant.State;\n import org.apache.hudi.common.table.timeline.HoodieTimeline;\n import org.apache.hudi.common.util.Option;\n import org.apache.hudi.common.util.ValidationUtils;\n-import org.apache.hudi.config.HoodieCompactionConfig;\n import org.apache.hudi.config.HoodieWriteConfig;\n+\n import org.apache.hudi.exception.HoodieCommitException;\n import org.apache.hudi.exception.HoodieIOException;\n import org.apache.hudi.exception.HoodieRestoreException;\n import org.apache.hudi.exception.HoodieRollbackException;\n import org.apache.hudi.exception.HoodieSavepointException;\n import org.apache.hudi.index.HoodieIndex;\n import org.apache.hudi.metrics.HoodieMetrics;\n-import org.apache.hudi.table.HoodieTable;\n-import org.apache.hudi.table.HoodieTimelineArchiveLog;\n-import org.apache.hudi.table.MarkerFiles;\n import org.apache.hudi.table.BulkInsertPartitioner;\n+import org.apache.hudi.table.HoodieTable;\n import org.apache.hudi.table.action.HoodieWriteMetadata;\n-import org.apache.hudi.table.action.compact.CompactHelpers;\n import org.apache.hudi.table.action.savepoint.SavepointHelpers;\n-\n-import com.codahale.metrics.Timer;\n import org.apache.log4j.LogManager;\n import org.apache.log4j.Logger;\n-import org.apache.spark.SparkConf;\n-import org.apache.spark.api.java.JavaRDD;\n-import org.apache.spark.api.java.JavaSparkContext;\n \n import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n import java.text.ParseException;\n import java.util.Collection;\n import java.util.List;\n import java.util.Map;\n import java.util.stream.Collectors;\n \n /**\n- * Hoodie Write Client helps you build tables on HDFS [insert()] and then perform efficient mutations on an HDFS\n- * table [upsert()]\n- * <p>\n- * Note that, at any given time, there can only be one Spark job performing these operations on a Hoodie table.\n+ * Abstract Write Client providing functionality for performing commit, index updates and rollback\n+ * Reused for regular write operations like upsert/insert/bulk-insert.. as well as bootstrap\n+ *\n+ * @param <T> Sub type of HoodieRecordPayload\n+ * @param <I> Type of inputs\n+ * @param <K> Type of keys\n+ * @param <O> Type of outputs\n+ * @param <P> Type of record position [Key, Option[partitionPath, fileID]] in hoodie table\n  */\n-public class HoodieWriteClient<T extends HoodieRecordPayload> extends AbstractHoodieWriteClient<T> {\n-\n+public abstract class AbstractHoodieWriteClient<T extends HoodieRecordPayload, I, K, O, P> extends AbstractHoodieClient {\n   private static final long serialVersionUID = 1L;\n-  private static final Logger LOG = LogManager.getLogger(HoodieWriteClient.class);\n-  private static final String LOOKUP_STR = \"lookup\";\n-  private final boolean rollbackPending;\n-  private final transient HoodieMetrics metrics;\n-  private transient Timer.Context compactionTimer;\n+  private static final Logger LOG = LogManager.getLogger(AbstractHoodieWriteClient.class);\n+\n+  protected final transient HoodieMetrics metrics;\n+  private final transient HoodieIndex<T, I, K, O, P> index;\n+\n+  protected transient Timer.Context writeContext = null;\n+  private transient WriteOperationType operationType;\n+  private transient HoodieWriteCommitCallback commitCallback;\n+\n+  protected static final String LOOKUP_STR = \"lookup\";", "originalCommit": "28eecab55cb62bb602e6ed7fe1cb9d5b188a87df", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA4MzIxNg==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484083216", "bodyText": "why did this constructor have to change", "author": "vinothchandar", "createdAt": "2020-09-06T15:28:40Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -18,120 +18,195 @@\n \n package org.apache.hudi.client;\n \n+import com.codahale.metrics.Timer;\n+import org.apache.hadoop.conf.Configuration;\n import org.apache.hudi.avro.model.HoodieCleanMetadata;\n import org.apache.hudi.avro.model.HoodieCompactionPlan;\n import org.apache.hudi.avro.model.HoodieRestoreMetadata;\n import org.apache.hudi.avro.model.HoodieRollbackMetadata;\n-import org.apache.hudi.client.embedded.EmbeddedTimelineService;\n+import org.apache.hudi.callback.HoodieWriteCommitCallback;\n+import org.apache.hudi.callback.common.HoodieWriteCommitCallbackMessage;\n+import org.apache.hudi.callback.util.HoodieCommitCallbackFactory;\n+import org.apache.hudi.client.embebbed.BaseEmbeddedTimelineService;\n+import org.apache.hudi.common.HoodieEngineContext;\n import org.apache.hudi.common.model.HoodieCommitMetadata;\n import org.apache.hudi.common.model.HoodieKey;\n-import org.apache.hudi.common.model.HoodieRecord;\n import org.apache.hudi.common.model.HoodieRecordPayload;\n import org.apache.hudi.common.model.HoodieWriteStat;\n import org.apache.hudi.common.model.WriteOperationType;\n import org.apache.hudi.common.table.HoodieTableMetaClient;\n import org.apache.hudi.common.table.timeline.HoodieActiveTimeline;\n import org.apache.hudi.common.table.timeline.HoodieInstant;\n-import org.apache.hudi.common.table.timeline.HoodieInstant.State;\n import org.apache.hudi.common.table.timeline.HoodieTimeline;\n import org.apache.hudi.common.util.Option;\n import org.apache.hudi.common.util.ValidationUtils;\n-import org.apache.hudi.config.HoodieCompactionConfig;\n import org.apache.hudi.config.HoodieWriteConfig;\n+\n import org.apache.hudi.exception.HoodieCommitException;\n import org.apache.hudi.exception.HoodieIOException;\n import org.apache.hudi.exception.HoodieRestoreException;\n import org.apache.hudi.exception.HoodieRollbackException;\n import org.apache.hudi.exception.HoodieSavepointException;\n import org.apache.hudi.index.HoodieIndex;\n import org.apache.hudi.metrics.HoodieMetrics;\n-import org.apache.hudi.table.HoodieTable;\n-import org.apache.hudi.table.HoodieTimelineArchiveLog;\n-import org.apache.hudi.table.MarkerFiles;\n import org.apache.hudi.table.BulkInsertPartitioner;\n+import org.apache.hudi.table.HoodieTable;\n import org.apache.hudi.table.action.HoodieWriteMetadata;\n-import org.apache.hudi.table.action.compact.CompactHelpers;\n import org.apache.hudi.table.action.savepoint.SavepointHelpers;\n-\n-import com.codahale.metrics.Timer;\n import org.apache.log4j.LogManager;\n import org.apache.log4j.Logger;\n-import org.apache.spark.SparkConf;\n-import org.apache.spark.api.java.JavaRDD;\n-import org.apache.spark.api.java.JavaSparkContext;\n \n import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n import java.text.ParseException;\n import java.util.Collection;\n import java.util.List;\n import java.util.Map;\n import java.util.stream.Collectors;\n \n /**\n- * Hoodie Write Client helps you build tables on HDFS [insert()] and then perform efficient mutations on an HDFS\n- * table [upsert()]\n- * <p>\n- * Note that, at any given time, there can only be one Spark job performing these operations on a Hoodie table.\n+ * Abstract Write Client providing functionality for performing commit, index updates and rollback\n+ * Reused for regular write operations like upsert/insert/bulk-insert.. as well as bootstrap\n+ *\n+ * @param <T> Sub type of HoodieRecordPayload\n+ * @param <I> Type of inputs\n+ * @param <K> Type of keys\n+ * @param <O> Type of outputs\n+ * @param <P> Type of record position [Key, Option[partitionPath, fileID]] in hoodie table\n  */\n-public class HoodieWriteClient<T extends HoodieRecordPayload> extends AbstractHoodieWriteClient<T> {\n-\n+public abstract class AbstractHoodieWriteClient<T extends HoodieRecordPayload, I, K, O, P> extends AbstractHoodieClient {\n   private static final long serialVersionUID = 1L;\n-  private static final Logger LOG = LogManager.getLogger(HoodieWriteClient.class);\n-  private static final String LOOKUP_STR = \"lookup\";\n-  private final boolean rollbackPending;\n-  private final transient HoodieMetrics metrics;\n-  private transient Timer.Context compactionTimer;\n+  private static final Logger LOG = LogManager.getLogger(AbstractHoodieWriteClient.class);\n+\n+  protected final transient HoodieMetrics metrics;\n+  private final transient HoodieIndex<T, I, K, O, P> index;\n+\n+  protected transient Timer.Context writeContext = null;\n+  private transient WriteOperationType operationType;\n+  private transient HoodieWriteCommitCallback commitCallback;\n+\n+  protected static final String LOOKUP_STR = \"lookup\";\n+  protected final boolean rollbackPending;\n+  protected transient Timer.Context compactionTimer;\n   private transient AsyncCleanerService asyncCleanerService;\n \n+  public void setOperationType(WriteOperationType operationType) {\n+    this.operationType = operationType;\n+  }\n+\n+  public WriteOperationType getOperationType() {\n+    return this.operationType;\n+  }\n+\n   /**\n    * Create a write client, without cleaning up failed/inflight commits.\n    *\n-   * @param jsc Java Spark Context\n+   * @param context      Java Spark Context\n    * @param clientConfig instance of HoodieWriteConfig\n    */\n-  public HoodieWriteClient(JavaSparkContext jsc, HoodieWriteConfig clientConfig) {\n-    this(jsc, clientConfig, false);\n+  public AbstractHoodieWriteClient(HoodieEngineContext context, HoodieWriteConfig clientConfig) {\n+    this(context, clientConfig, false);\n   }\n \n   /**\n    * Create a write client, with new hudi index.\n    *\n-   * @param jsc Java Spark Context\n-   * @param writeConfig instance of HoodieWriteConfig\n+   * @param context         HoodieEngineContext\n+   * @param writeConfig     instance of HoodieWriteConfig\n    * @param rollbackPending whether need to cleanup pending commits\n    */\n-  public HoodieWriteClient(JavaSparkContext jsc, HoodieWriteConfig writeConfig, boolean rollbackPending) {\n-    this(jsc, writeConfig, rollbackPending, HoodieIndex.createIndex(writeConfig));\n-  }\n-\n-  public HoodieWriteClient(JavaSparkContext jsc, HoodieWriteConfig writeConfig, boolean rollbackPending, HoodieIndex index) {\n-    this(jsc, writeConfig, rollbackPending, index, Option.empty());\n+  public AbstractHoodieWriteClient(HoodieEngineContext context, HoodieWriteConfig writeConfig, boolean rollbackPending) {\n+    this(context, writeConfig, rollbackPending, Option.empty());\n   }\n \n   /**\n-   *  Create a write client, allows to specify all parameters.\n+   * Create a write client, allows to specify all parameters.\n    *\n-   * @param jsc Java Spark Context\n-   * @param writeConfig instance of HoodieWriteConfig\n+   * @param context         HoodieEngineContext\n+   * @param writeConfig     instance of HoodieWriteConfig\n    * @param rollbackPending whether need to cleanup pending commits\n    * @param timelineService Timeline Service that runs as part of write client.\n    */\n-  public HoodieWriteClient(JavaSparkContext jsc, HoodieWriteConfig writeConfig, boolean rollbackPending,\n-      HoodieIndex index, Option<EmbeddedTimelineService> timelineService) {\n-    super(jsc, index, writeConfig, timelineService);\n+  public AbstractHoodieWriteClient(HoodieEngineContext context, HoodieWriteConfig writeConfig, boolean rollbackPending,\n+                                   Option<BaseEmbeddedTimelineService> timelineService) {\n+    super(context, writeConfig, timelineService);\n     this.metrics = new HoodieMetrics(config, config.getTableName());\n     this.rollbackPending = rollbackPending;\n+    this.index = createIndex(writeConfig);", "originalCommit": "28eecab55cb62bb602e6ed7fe1cb9d5b188a87df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc0NzY1MQ==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r494747651", "bodyText": "Understood", "author": "vinothchandar", "createdAt": "2020-09-25T04:59:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA4MzIxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA4MzI3NA==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484083274", "bodyText": "same point, not sure if this is correct.", "author": "vinothchandar", "createdAt": "2020-09-06T15:29:19Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -18,120 +18,195 @@\n \n package org.apache.hudi.client;\n \n+import com.codahale.metrics.Timer;\n+import org.apache.hadoop.conf.Configuration;\n import org.apache.hudi.avro.model.HoodieCleanMetadata;\n import org.apache.hudi.avro.model.HoodieCompactionPlan;\n import org.apache.hudi.avro.model.HoodieRestoreMetadata;\n import org.apache.hudi.avro.model.HoodieRollbackMetadata;\n-import org.apache.hudi.client.embedded.EmbeddedTimelineService;\n+import org.apache.hudi.callback.HoodieWriteCommitCallback;\n+import org.apache.hudi.callback.common.HoodieWriteCommitCallbackMessage;\n+import org.apache.hudi.callback.util.HoodieCommitCallbackFactory;\n+import org.apache.hudi.client.embebbed.BaseEmbeddedTimelineService;\n+import org.apache.hudi.common.HoodieEngineContext;\n import org.apache.hudi.common.model.HoodieCommitMetadata;\n import org.apache.hudi.common.model.HoodieKey;\n-import org.apache.hudi.common.model.HoodieRecord;\n import org.apache.hudi.common.model.HoodieRecordPayload;\n import org.apache.hudi.common.model.HoodieWriteStat;\n import org.apache.hudi.common.model.WriteOperationType;\n import org.apache.hudi.common.table.HoodieTableMetaClient;\n import org.apache.hudi.common.table.timeline.HoodieActiveTimeline;\n import org.apache.hudi.common.table.timeline.HoodieInstant;\n-import org.apache.hudi.common.table.timeline.HoodieInstant.State;\n import org.apache.hudi.common.table.timeline.HoodieTimeline;\n import org.apache.hudi.common.util.Option;\n import org.apache.hudi.common.util.ValidationUtils;\n-import org.apache.hudi.config.HoodieCompactionConfig;\n import org.apache.hudi.config.HoodieWriteConfig;\n+\n import org.apache.hudi.exception.HoodieCommitException;\n import org.apache.hudi.exception.HoodieIOException;\n import org.apache.hudi.exception.HoodieRestoreException;\n import org.apache.hudi.exception.HoodieRollbackException;\n import org.apache.hudi.exception.HoodieSavepointException;\n import org.apache.hudi.index.HoodieIndex;\n import org.apache.hudi.metrics.HoodieMetrics;\n-import org.apache.hudi.table.HoodieTable;\n-import org.apache.hudi.table.HoodieTimelineArchiveLog;\n-import org.apache.hudi.table.MarkerFiles;\n import org.apache.hudi.table.BulkInsertPartitioner;\n+import org.apache.hudi.table.HoodieTable;\n import org.apache.hudi.table.action.HoodieWriteMetadata;\n-import org.apache.hudi.table.action.compact.CompactHelpers;\n import org.apache.hudi.table.action.savepoint.SavepointHelpers;\n-\n-import com.codahale.metrics.Timer;\n import org.apache.log4j.LogManager;\n import org.apache.log4j.Logger;\n-import org.apache.spark.SparkConf;\n-import org.apache.spark.api.java.JavaRDD;\n-import org.apache.spark.api.java.JavaSparkContext;\n \n import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n import java.text.ParseException;\n import java.util.Collection;\n import java.util.List;\n import java.util.Map;\n import java.util.stream.Collectors;\n \n /**\n- * Hoodie Write Client helps you build tables on HDFS [insert()] and then perform efficient mutations on an HDFS\n- * table [upsert()]\n- * <p>\n- * Note that, at any given time, there can only be one Spark job performing these operations on a Hoodie table.\n+ * Abstract Write Client providing functionality for performing commit, index updates and rollback\n+ * Reused for regular write operations like upsert/insert/bulk-insert.. as well as bootstrap\n+ *\n+ * @param <T> Sub type of HoodieRecordPayload\n+ * @param <I> Type of inputs\n+ * @param <K> Type of keys\n+ * @param <O> Type of outputs\n+ * @param <P> Type of record position [Key, Option[partitionPath, fileID]] in hoodie table\n  */\n-public class HoodieWriteClient<T extends HoodieRecordPayload> extends AbstractHoodieWriteClient<T> {\n-\n+public abstract class AbstractHoodieWriteClient<T extends HoodieRecordPayload, I, K, O, P> extends AbstractHoodieClient {\n   private static final long serialVersionUID = 1L;\n-  private static final Logger LOG = LogManager.getLogger(HoodieWriteClient.class);\n-  private static final String LOOKUP_STR = \"lookup\";\n-  private final boolean rollbackPending;\n-  private final transient HoodieMetrics metrics;\n-  private transient Timer.Context compactionTimer;\n+  private static final Logger LOG = LogManager.getLogger(AbstractHoodieWriteClient.class);\n+\n+  protected final transient HoodieMetrics metrics;\n+  private final transient HoodieIndex<T, I, K, O, P> index;\n+\n+  protected transient Timer.Context writeContext = null;\n+  private transient WriteOperationType operationType;\n+  private transient HoodieWriteCommitCallback commitCallback;\n+\n+  protected static final String LOOKUP_STR = \"lookup\";\n+  protected final boolean rollbackPending;\n+  protected transient Timer.Context compactionTimer;\n   private transient AsyncCleanerService asyncCleanerService;\n \n+  public void setOperationType(WriteOperationType operationType) {\n+    this.operationType = operationType;\n+  }\n+\n+  public WriteOperationType getOperationType() {\n+    return this.operationType;\n+  }\n+\n   /**\n    * Create a write client, without cleaning up failed/inflight commits.\n    *\n-   * @param jsc Java Spark Context\n+   * @param context      Java Spark Context\n    * @param clientConfig instance of HoodieWriteConfig\n    */\n-  public HoodieWriteClient(JavaSparkContext jsc, HoodieWriteConfig clientConfig) {\n-    this(jsc, clientConfig, false);\n+  public AbstractHoodieWriteClient(HoodieEngineContext context, HoodieWriteConfig clientConfig) {\n+    this(context, clientConfig, false);\n   }\n \n   /**\n    * Create a write client, with new hudi index.\n    *\n-   * @param jsc Java Spark Context\n-   * @param writeConfig instance of HoodieWriteConfig\n+   * @param context         HoodieEngineContext\n+   * @param writeConfig     instance of HoodieWriteConfig\n    * @param rollbackPending whether need to cleanup pending commits\n    */\n-  public HoodieWriteClient(JavaSparkContext jsc, HoodieWriteConfig writeConfig, boolean rollbackPending) {\n-    this(jsc, writeConfig, rollbackPending, HoodieIndex.createIndex(writeConfig));\n-  }\n-\n-  public HoodieWriteClient(JavaSparkContext jsc, HoodieWriteConfig writeConfig, boolean rollbackPending, HoodieIndex index) {\n-    this(jsc, writeConfig, rollbackPending, index, Option.empty());\n+  public AbstractHoodieWriteClient(HoodieEngineContext context, HoodieWriteConfig writeConfig, boolean rollbackPending) {\n+    this(context, writeConfig, rollbackPending, Option.empty());\n   }\n \n   /**\n-   *  Create a write client, allows to specify all parameters.\n+   * Create a write client, allows to specify all parameters.\n    *\n-   * @param jsc Java Spark Context\n-   * @param writeConfig instance of HoodieWriteConfig\n+   * @param context         HoodieEngineContext\n+   * @param writeConfig     instance of HoodieWriteConfig\n    * @param rollbackPending whether need to cleanup pending commits\n    * @param timelineService Timeline Service that runs as part of write client.\n    */\n-  public HoodieWriteClient(JavaSparkContext jsc, HoodieWriteConfig writeConfig, boolean rollbackPending,\n-      HoodieIndex index, Option<EmbeddedTimelineService> timelineService) {\n-    super(jsc, index, writeConfig, timelineService);\n+  public AbstractHoodieWriteClient(HoodieEngineContext context, HoodieWriteConfig writeConfig, boolean rollbackPending,\n+                                   Option<BaseEmbeddedTimelineService> timelineService) {\n+    super(context, writeConfig, timelineService);\n     this.metrics = new HoodieMetrics(config, config.getTableName());\n     this.rollbackPending = rollbackPending;\n+    this.index = createIndex(writeConfig);\n   }\n \n+  protected abstract HoodieIndex<T, I, K, O, P> createIndex(HoodieWriteConfig writeConfig);", "originalCommit": "28eecab55cb62bb602e6ed7fe1cb9d5b188a87df", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA4MzQ0Mg==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484083442", "bodyText": "guessing this is all moved to spark client now?", "author": "vinothchandar", "createdAt": "2020-09-06T15:30:50Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -18,120 +18,195 @@\n \n package org.apache.hudi.client;\n \n+import com.codahale.metrics.Timer;\n+import org.apache.hadoop.conf.Configuration;\n import org.apache.hudi.avro.model.HoodieCleanMetadata;\n import org.apache.hudi.avro.model.HoodieCompactionPlan;\n import org.apache.hudi.avro.model.HoodieRestoreMetadata;\n import org.apache.hudi.avro.model.HoodieRollbackMetadata;\n-import org.apache.hudi.client.embedded.EmbeddedTimelineService;\n+import org.apache.hudi.callback.HoodieWriteCommitCallback;\n+import org.apache.hudi.callback.common.HoodieWriteCommitCallbackMessage;\n+import org.apache.hudi.callback.util.HoodieCommitCallbackFactory;\n+import org.apache.hudi.client.embebbed.BaseEmbeddedTimelineService;\n+import org.apache.hudi.common.HoodieEngineContext;\n import org.apache.hudi.common.model.HoodieCommitMetadata;\n import org.apache.hudi.common.model.HoodieKey;\n-import org.apache.hudi.common.model.HoodieRecord;\n import org.apache.hudi.common.model.HoodieRecordPayload;\n import org.apache.hudi.common.model.HoodieWriteStat;\n import org.apache.hudi.common.model.WriteOperationType;\n import org.apache.hudi.common.table.HoodieTableMetaClient;\n import org.apache.hudi.common.table.timeline.HoodieActiveTimeline;\n import org.apache.hudi.common.table.timeline.HoodieInstant;\n-import org.apache.hudi.common.table.timeline.HoodieInstant.State;\n import org.apache.hudi.common.table.timeline.HoodieTimeline;\n import org.apache.hudi.common.util.Option;\n import org.apache.hudi.common.util.ValidationUtils;\n-import org.apache.hudi.config.HoodieCompactionConfig;\n import org.apache.hudi.config.HoodieWriteConfig;\n+\n import org.apache.hudi.exception.HoodieCommitException;\n import org.apache.hudi.exception.HoodieIOException;\n import org.apache.hudi.exception.HoodieRestoreException;\n import org.apache.hudi.exception.HoodieRollbackException;\n import org.apache.hudi.exception.HoodieSavepointException;\n import org.apache.hudi.index.HoodieIndex;\n import org.apache.hudi.metrics.HoodieMetrics;\n-import org.apache.hudi.table.HoodieTable;\n-import org.apache.hudi.table.HoodieTimelineArchiveLog;\n-import org.apache.hudi.table.MarkerFiles;\n import org.apache.hudi.table.BulkInsertPartitioner;\n+import org.apache.hudi.table.HoodieTable;\n import org.apache.hudi.table.action.HoodieWriteMetadata;\n-import org.apache.hudi.table.action.compact.CompactHelpers;\n import org.apache.hudi.table.action.savepoint.SavepointHelpers;\n-\n-import com.codahale.metrics.Timer;\n import org.apache.log4j.LogManager;\n import org.apache.log4j.Logger;\n-import org.apache.spark.SparkConf;\n-import org.apache.spark.api.java.JavaRDD;\n-import org.apache.spark.api.java.JavaSparkContext;\n \n import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n import java.text.ParseException;\n import java.util.Collection;\n import java.util.List;\n import java.util.Map;\n import java.util.stream.Collectors;\n \n /**\n- * Hoodie Write Client helps you build tables on HDFS [insert()] and then perform efficient mutations on an HDFS\n- * table [upsert()]\n- * <p>\n- * Note that, at any given time, there can only be one Spark job performing these operations on a Hoodie table.\n+ * Abstract Write Client providing functionality for performing commit, index updates and rollback\n+ * Reused for regular write operations like upsert/insert/bulk-insert.. as well as bootstrap\n+ *\n+ * @param <T> Sub type of HoodieRecordPayload\n+ * @param <I> Type of inputs\n+ * @param <K> Type of keys\n+ * @param <O> Type of outputs\n+ * @param <P> Type of record position [Key, Option[partitionPath, fileID]] in hoodie table\n  */\n-public class HoodieWriteClient<T extends HoodieRecordPayload> extends AbstractHoodieWriteClient<T> {\n-\n+public abstract class AbstractHoodieWriteClient<T extends HoodieRecordPayload, I, K, O, P> extends AbstractHoodieClient {\n   private static final long serialVersionUID = 1L;\n-  private static final Logger LOG = LogManager.getLogger(HoodieWriteClient.class);\n-  private static final String LOOKUP_STR = \"lookup\";\n-  private final boolean rollbackPending;\n-  private final transient HoodieMetrics metrics;\n-  private transient Timer.Context compactionTimer;\n+  private static final Logger LOG = LogManager.getLogger(AbstractHoodieWriteClient.class);\n+\n+  protected final transient HoodieMetrics metrics;\n+  private final transient HoodieIndex<T, I, K, O, P> index;\n+\n+  protected transient Timer.Context writeContext = null;\n+  private transient WriteOperationType operationType;\n+  private transient HoodieWriteCommitCallback commitCallback;\n+\n+  protected static final String LOOKUP_STR = \"lookup\";\n+  protected final boolean rollbackPending;\n+  protected transient Timer.Context compactionTimer;\n   private transient AsyncCleanerService asyncCleanerService;\n \n+  public void setOperationType(WriteOperationType operationType) {\n+    this.operationType = operationType;\n+  }\n+\n+  public WriteOperationType getOperationType() {\n+    return this.operationType;\n+  }\n+\n   /**\n    * Create a write client, without cleaning up failed/inflight commits.\n    *\n-   * @param jsc Java Spark Context\n+   * @param context      Java Spark Context\n    * @param clientConfig instance of HoodieWriteConfig\n    */\n-  public HoodieWriteClient(JavaSparkContext jsc, HoodieWriteConfig clientConfig) {\n-    this(jsc, clientConfig, false);\n+  public AbstractHoodieWriteClient(HoodieEngineContext context, HoodieWriteConfig clientConfig) {\n+    this(context, clientConfig, false);\n   }\n \n   /**\n    * Create a write client, with new hudi index.\n    *\n-   * @param jsc Java Spark Context\n-   * @param writeConfig instance of HoodieWriteConfig\n+   * @param context         HoodieEngineContext\n+   * @param writeConfig     instance of HoodieWriteConfig\n    * @param rollbackPending whether need to cleanup pending commits\n    */\n-  public HoodieWriteClient(JavaSparkContext jsc, HoodieWriteConfig writeConfig, boolean rollbackPending) {\n-    this(jsc, writeConfig, rollbackPending, HoodieIndex.createIndex(writeConfig));\n-  }\n-\n-  public HoodieWriteClient(JavaSparkContext jsc, HoodieWriteConfig writeConfig, boolean rollbackPending, HoodieIndex index) {\n-    this(jsc, writeConfig, rollbackPending, index, Option.empty());\n+  public AbstractHoodieWriteClient(HoodieEngineContext context, HoodieWriteConfig writeConfig, boolean rollbackPending) {\n+    this(context, writeConfig, rollbackPending, Option.empty());\n   }\n \n   /**\n-   *  Create a write client, allows to specify all parameters.\n+   * Create a write client, allows to specify all parameters.\n    *\n-   * @param jsc Java Spark Context\n-   * @param writeConfig instance of HoodieWriteConfig\n+   * @param context         HoodieEngineContext\n+   * @param writeConfig     instance of HoodieWriteConfig\n    * @param rollbackPending whether need to cleanup pending commits\n    * @param timelineService Timeline Service that runs as part of write client.\n    */\n-  public HoodieWriteClient(JavaSparkContext jsc, HoodieWriteConfig writeConfig, boolean rollbackPending,\n-      HoodieIndex index, Option<EmbeddedTimelineService> timelineService) {\n-    super(jsc, index, writeConfig, timelineService);\n+  public AbstractHoodieWriteClient(HoodieEngineContext context, HoodieWriteConfig writeConfig, boolean rollbackPending,\n+                                   Option<BaseEmbeddedTimelineService> timelineService) {\n+    super(context, writeConfig, timelineService);\n     this.metrics = new HoodieMetrics(config, config.getTableName());\n     this.rollbackPending = rollbackPending;\n+    this.index = createIndex(writeConfig);\n   }\n \n+  protected abstract HoodieIndex<T, I, K, O, P> createIndex(HoodieWriteConfig writeConfig);\n+\n   /**\n-   * Register hudi classes for Kryo serialization.\n-   *\n-   * @param conf instance of SparkConf\n-   * @return SparkConf\n+   * Commit changes performed at the given instantTime marker.\n    */\n-  public static SparkConf registerClasses(SparkConf conf) {", "originalCommit": "28eecab55cb62bb602e6ed7fe1cb9d5b188a87df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU5MTYxOA==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r485591618", "bodyText": "guessing this is all moved to spark client now?\n\nyes, In SparkRDDWriteClient now", "author": "wangxianghu", "createdAt": "2020-09-09T13:00:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA4MzQ0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA4NDI5NQ==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484084295", "bodyText": "it would be great, if you can avoid the whitespace changes :) Have to fish for what the real changes are", "author": "vinothchandar", "createdAt": "2020-09-06T15:39:17Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -242,150 +286,93 @@ protected void rollBackInflightBootstrap() {\n    * de-duped if needed.\n    *\n    * @param preppedRecords HoodieRecords to insert\n-   * @param instantTime Instant time of the commit\n+   * @param instantTime    Instant time of the commit\n    * @return JavaRDD[WriteStatus] - RDD of WriteStatus to inspect errors and counts\n    */\n-  public JavaRDD<WriteStatus> insertPreppedRecords(JavaRDD<HoodieRecord<T>> preppedRecords, final String instantTime) {\n-    HoodieTable<T> table = getTableAndInitCtx(WriteOperationType.INSERT_PREPPED, instantTime);\n-    table.validateInsertSchema();\n-    setOperationType(WriteOperationType.INSERT_PREPPED);\n-    this.asyncCleanerService = AsyncCleanerService.startAsyncCleaningIfEnabled(this, instantTime);\n-    HoodieWriteMetadata result = table.insertPrepped(jsc,instantTime, preppedRecords);\n-    return postWrite(result, instantTime, table);\n-  }\n+  public abstract O insertPreppedRecords(I preppedRecords, final String instantTime);\n \n   /**\n    * Loads the given HoodieRecords, as inserts into the table. This is suitable for doing big bulk loads into a Hoodie\n    * table for the very first time (e.g: converting an existing table to Hoodie).\n    * <p>\n    * This implementation uses sortBy (which does range partitioning based on reservoir sampling) and attempts to control\n-   * the numbers of files with less memory compared to the {@link HoodieWriteClient#insert(JavaRDD, String)}\n+   * the numbers of files with less memory compared to the {@link AbstractHoodieWriteClient#insert(I, String)}\n    *\n-   * @param records HoodieRecords to insert\n+   * @param records     HoodieRecords to insert\n    * @param instantTime Instant time of the commit\n    * @return JavaRDD[WriteStatus] - RDD of WriteStatus to inspect errors and counts\n    */\n-  public JavaRDD<WriteStatus> bulkInsert(JavaRDD<HoodieRecord<T>> records, final String instantTime) {\n-    return bulkInsert(records, instantTime, Option.empty());\n-  }\n+  public abstract O bulkInsert(I records, final String instantTime);\n \n   /**\n    * Loads the given HoodieRecords, as inserts into the table. This is suitable for doing big bulk loads into a Hoodie\n    * table for the very first time (e.g: converting an existing table to Hoodie).\n    * <p>\n    * This implementation uses sortBy (which does range partitioning based on reservoir sampling) and attempts to control\n-   * the numbers of files with less memory compared to the {@link HoodieWriteClient#insert(JavaRDD, String)}. Optionally\n+   * the numbers of files with less memory compared to the {@link AbstractHoodieWriteClient#insert(I, String)}. Optionally\n    * it allows users to specify their own partitioner. If specified then it will be used for repartitioning records. See\n    * {@link BulkInsertPartitioner}.\n    *\n-   * @param records HoodieRecords to insert\n-   * @param instantTime Instant time of the commit\n+   * @param records                          HoodieRecords to insert\n+   * @param instantTime                      Instant time of the commit\n    * @param userDefinedBulkInsertPartitioner If specified then it will be used to partition input records before they are inserted\n-   * into hoodie.\n+   *                                         into hoodie.\n    * @return JavaRDD[WriteStatus] - RDD of WriteStatus to inspect errors and counts\n    */\n-  public JavaRDD<WriteStatus> bulkInsert(JavaRDD<HoodieRecord<T>> records, final String instantTime,\n-                                         Option<BulkInsertPartitioner> userDefinedBulkInsertPartitioner) {\n-    HoodieTable<T> table = getTableAndInitCtx(WriteOperationType.BULK_INSERT, instantTime);\n-    table.validateInsertSchema();\n-    setOperationType(WriteOperationType.BULK_INSERT);\n-    this.asyncCleanerService = AsyncCleanerService.startAsyncCleaningIfEnabled(this, instantTime);\n-    HoodieWriteMetadata result = table.bulkInsert(jsc,instantTime, records, userDefinedBulkInsertPartitioner);\n-    return postWrite(result, instantTime, table);\n-  }\n+  public abstract O bulkInsert(I records, final String instantTime,\n+                      Option<BulkInsertPartitioner<I>> userDefinedBulkInsertPartitioner);\n+\n \n   /**\n    * Loads the given HoodieRecords, as inserts into the table. This is suitable for doing big bulk loads into a Hoodie\n    * table for the very first time (e.g: converting an existing table to Hoodie). The input records should contain no\n    * duplicates if needed.\n    * <p>\n    * This implementation uses sortBy (which does range partitioning based on reservoir sampling) and attempts to control\n-   * the numbers of files with less memory compared to the {@link HoodieWriteClient#insert(JavaRDD, String)}. Optionally\n+   * the numbers of files with less memory compared to the {@link AbstractHoodieWriteClient#insert(I, String)}. Optionally\n    * it allows users to specify their own partitioner. If specified then it will be used for repartitioning records. See\n    * {@link BulkInsertPartitioner}.\n    *\n-   * @param preppedRecords HoodieRecords to insert\n-   * @param instantTime Instant time of the commit\n+   * @param preppedRecords        HoodieRecords to insert", "originalCommit": "28eecab55cb62bb602e6ed7fe1cb9d5b188a87df", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA4NDg3Mw==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484084873", "bodyText": "this method need not have moved?", "author": "vinothchandar", "createdAt": "2020-09-06T15:44:19Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AsyncCleanerService.java", "diffHunk": "@@ -52,19 +52,6 @@ protected AsyncCleanerService(HoodieWriteClient<?> writeClient, String cleanInst\n     }), executor);\n   }\n \n-  public static AsyncCleanerService startAsyncCleaningIfEnabled(HoodieWriteClient writeClient,", "originalCommit": "2348f73b4a270e4d04d2f67f9d7bd9691391b569", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk5OTYyOQ==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r493999629", "bodyText": "this method need not have moved?\n\nIt is back now.", "author": "wangxianghu", "createdAt": "2020-09-24T02:18:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA4NDg3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA5Njc3Ng==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484096776", "bodyText": "are these from reformatting via IDE .", "author": "vinothchandar", "createdAt": "2020-09-06T17:48:51Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/bootstrap/selector/BootstrapRegexModeSelector.java", "diffHunk": "@@ -18,17 +18,18 @@\n \n package org.apache.hudi.client.bootstrap.selector;\n \n-import java.util.List;\n-import java.util.Map;\n-import java.util.regex.Pattern;\n-import java.util.stream.Collectors;\n import org.apache.hudi.avro.model.HoodieFileStatus;\n import org.apache.hudi.client.bootstrap.BootstrapMode;\n import org.apache.hudi.common.util.collection.Pair;\n import org.apache.hudi.config.HoodieWriteConfig;\n import org.apache.log4j.LogManager;\n import org.apache.log4j.Logger;\n \n+import java.util.List;", "originalCommit": "ac3339704c703741f9ff50f2d96019cef2d2c72b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA5NzE2MA==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484097160", "bodyText": "In general, not sure if this class is applicable outside of Spark. but we do use it in all of the code paths. So understand that we needed to do this.", "author": "vinothchandar", "createdAt": "2020-09-06T17:52:53Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/execution/BaseLazyInsertIterable.java", "diffHunk": "@@ -18,64 +18,47 @@\n \n package org.apache.hudi.execution;\n \n-import org.apache.hudi.client.SparkTaskContextSupplier;\n+import org.apache.avro.Schema;\n+import org.apache.avro.generic.IndexedRecord;\n+import org.apache.hudi.client.TaskContextSupplier;\n import org.apache.hudi.client.WriteStatus;\n import org.apache.hudi.client.utils.LazyIterableIterator;\n import org.apache.hudi.common.model.HoodieRecord;\n import org.apache.hudi.common.model.HoodieRecordPayload;\n import org.apache.hudi.common.util.Option;\n-import org.apache.hudi.common.util.queue.BoundedInMemoryExecutor;\n import org.apache.hudi.config.HoodieWriteConfig;\n-import org.apache.hudi.exception.HoodieException;\n-import org.apache.hudi.io.CreateHandleFactory;\n import org.apache.hudi.io.WriteHandleFactory;\n import org.apache.hudi.table.HoodieTable;\n \n-import org.apache.avro.Schema;\n-import org.apache.avro.generic.IndexedRecord;\n-\n import java.util.Iterator;\n import java.util.List;\n import java.util.function.Function;\n \n /**\n  * Lazy Iterable, that writes a stream of HoodieRecords sorted by the partitionPath, into new files.\n  */\n-public class LazyInsertIterable<T extends HoodieRecordPayload>\n+public abstract class BaseLazyInsertIterable<T extends HoodieRecordPayload>", "originalCommit": "ac3339704c703741f9ff50f2d96019cef2d2c72b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA5NzM0Mw==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484097343", "bodyText": "some of these index types don't make sense without Spark Index now. actually almost all of them except may be HBaseIndex.\nSo these should all be renamed with the Spark prefix", "author": "vinothchandar", "createdAt": "2020-09-06T17:55:12Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/index/HoodieIndex.java", "diffHunk": "@@ -21,94 +21,52 @@\n import org.apache.hudi.ApiMaturityLevel;\n import org.apache.hudi.PublicAPIClass;\n import org.apache.hudi.PublicAPIMethod;\n-import org.apache.hudi.client.WriteStatus;\n+import org.apache.hudi.common.HoodieEngineContext;\n import org.apache.hudi.common.model.FileSlice;\n import org.apache.hudi.common.model.HoodieKey;\n-import org.apache.hudi.common.model.HoodieRecord;\n import org.apache.hudi.common.model.HoodieRecordPayload;\n-import org.apache.hudi.common.util.Option;\n-import org.apache.hudi.common.util.ReflectionUtils;\n-import org.apache.hudi.common.util.StringUtils;\n-import org.apache.hudi.common.util.collection.Pair;\n import org.apache.hudi.config.HoodieWriteConfig;\n import org.apache.hudi.exception.HoodieIndexException;\n-import org.apache.hudi.index.bloom.HoodieBloomIndex;\n-import org.apache.hudi.index.bloom.HoodieGlobalBloomIndex;\n-import org.apache.hudi.index.hbase.HBaseIndex;\n-import org.apache.hudi.index.simple.HoodieGlobalSimpleIndex;\n-import org.apache.hudi.index.simple.HoodieSimpleIndex;\n import org.apache.hudi.table.HoodieTable;\n \n-import org.apache.spark.api.java.JavaPairRDD;\n-import org.apache.spark.api.java.JavaRDD;\n-import org.apache.spark.api.java.JavaSparkContext;\n-\n import java.io.Serializable;\n \n /**\n  * Base class for different types of indexes to determine the mapping from uuid.\n  */\n @PublicAPIClass(maturity = ApiMaturityLevel.EVOLVING)\n-public abstract class HoodieIndex<T extends HoodieRecordPayload> implements Serializable {\n+public abstract class HoodieIndex<T extends HoodieRecordPayload, I, K, O, P> implements Serializable {\n \n   protected final HoodieWriteConfig config;\n \n   protected HoodieIndex(HoodieWriteConfig config) {\n     this.config = config;\n   }\n \n-  public static <T extends HoodieRecordPayload> HoodieIndex<T> createIndex(", "originalCommit": "ac3339704c703741f9ff50f2d96019cef2d2c72b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA5NzQxNg==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484097416", "bodyText": "now I understand P better.", "author": "vinothchandar", "createdAt": "2020-09-06T17:56:00Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/index/HoodieIndex.java", "diffHunk": "@@ -21,94 +21,52 @@\n import org.apache.hudi.ApiMaturityLevel;\n import org.apache.hudi.PublicAPIClass;\n import org.apache.hudi.PublicAPIMethod;\n-import org.apache.hudi.client.WriteStatus;\n+import org.apache.hudi.common.HoodieEngineContext;\n import org.apache.hudi.common.model.FileSlice;\n import org.apache.hudi.common.model.HoodieKey;\n-import org.apache.hudi.common.model.HoodieRecord;\n import org.apache.hudi.common.model.HoodieRecordPayload;\n-import org.apache.hudi.common.util.Option;\n-import org.apache.hudi.common.util.ReflectionUtils;\n-import org.apache.hudi.common.util.StringUtils;\n-import org.apache.hudi.common.util.collection.Pair;\n import org.apache.hudi.config.HoodieWriteConfig;\n import org.apache.hudi.exception.HoodieIndexException;\n-import org.apache.hudi.index.bloom.HoodieBloomIndex;\n-import org.apache.hudi.index.bloom.HoodieGlobalBloomIndex;\n-import org.apache.hudi.index.hbase.HBaseIndex;\n-import org.apache.hudi.index.simple.HoodieGlobalSimpleIndex;\n-import org.apache.hudi.index.simple.HoodieSimpleIndex;\n import org.apache.hudi.table.HoodieTable;\n \n-import org.apache.spark.api.java.JavaPairRDD;\n-import org.apache.spark.api.java.JavaRDD;\n-import org.apache.spark.api.java.JavaSparkContext;\n-\n import java.io.Serializable;\n \n /**\n  * Base class for different types of indexes to determine the mapping from uuid.\n  */\n @PublicAPIClass(maturity = ApiMaturityLevel.EVOLVING)\n-public abstract class HoodieIndex<T extends HoodieRecordPayload> implements Serializable {\n+public abstract class HoodieIndex<T extends HoodieRecordPayload, I, K, O, P> implements Serializable {\n \n   protected final HoodieWriteConfig config;\n \n   protected HoodieIndex(HoodieWriteConfig config) {\n     this.config = config;\n   }\n \n-  public static <T extends HoodieRecordPayload> HoodieIndex<T> createIndex(\n-      HoodieWriteConfig config) throws HoodieIndexException {\n-    // first use index class config to create index.\n-    if (!StringUtils.isNullOrEmpty(config.getIndexClass())) {\n-      Object instance = ReflectionUtils.loadClass(config.getIndexClass(), config);\n-      if (!(instance instanceof HoodieIndex)) {\n-        throw new HoodieIndexException(config.getIndexClass() + \" is not a subclass of HoodieIndex\");\n-      }\n-      return (HoodieIndex) instance;\n-    }\n-    switch (config.getIndexType()) {\n-      case HBASE:\n-        return new HBaseIndex<>(config);\n-      case INMEMORY:\n-        return new InMemoryHashIndex<>(config);\n-      case BLOOM:\n-        return new HoodieBloomIndex<>(config);\n-      case GLOBAL_BLOOM:\n-        return new HoodieGlobalBloomIndex<>(config);\n-      case SIMPLE:\n-        return new HoodieSimpleIndex<>(config);\n-      case GLOBAL_SIMPLE:\n-        return new HoodieGlobalSimpleIndex<>(config);\n-      default:\n-        throw new HoodieIndexException(\"Index type unspecified, set \" + config.getIndexType());\n-    }\n-  }\n-\n   /**\n    * Checks if the given [Keys] exists in the hoodie table and returns [Key, Option[partitionPath, fileID]] If the\n    * optional is empty, then the key is not found.\n    */\n   @PublicAPIMethod(maturity = ApiMaturityLevel.STABLE)\n-  public abstract JavaPairRDD<HoodieKey, Option<Pair<String, String>>> fetchRecordLocation(\n-      JavaRDD<HoodieKey> hoodieKeys, final JavaSparkContext jsc, HoodieTable<T> hoodieTable);\n+  public abstract P fetchRecordLocation(", "originalCommit": "ac3339704c703741f9ff50f2d96019cef2d2c72b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA5NzYxMw==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484097613", "bodyText": "these annotations needs to moved over to a SparkHoodieIndex class? it will be hard for end developers to program against HoodieIndex directly anymore. This is a general point actually. The current public APIs should all be annotated against the Spark child classes.  wdyt?", "author": "vinothchandar", "createdAt": "2020-09-06T17:58:04Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/index/HoodieIndex.java", "diffHunk": "@@ -21,94 +21,52 @@\n import org.apache.hudi.ApiMaturityLevel;\n import org.apache.hudi.PublicAPIClass;\n import org.apache.hudi.PublicAPIMethod;\n-import org.apache.hudi.client.WriteStatus;\n+import org.apache.hudi.common.HoodieEngineContext;\n import org.apache.hudi.common.model.FileSlice;\n import org.apache.hudi.common.model.HoodieKey;\n-import org.apache.hudi.common.model.HoodieRecord;\n import org.apache.hudi.common.model.HoodieRecordPayload;\n-import org.apache.hudi.common.util.Option;\n-import org.apache.hudi.common.util.ReflectionUtils;\n-import org.apache.hudi.common.util.StringUtils;\n-import org.apache.hudi.common.util.collection.Pair;\n import org.apache.hudi.config.HoodieWriteConfig;\n import org.apache.hudi.exception.HoodieIndexException;\n-import org.apache.hudi.index.bloom.HoodieBloomIndex;\n-import org.apache.hudi.index.bloom.HoodieGlobalBloomIndex;\n-import org.apache.hudi.index.hbase.HBaseIndex;\n-import org.apache.hudi.index.simple.HoodieGlobalSimpleIndex;\n-import org.apache.hudi.index.simple.HoodieSimpleIndex;\n import org.apache.hudi.table.HoodieTable;\n \n-import org.apache.spark.api.java.JavaPairRDD;\n-import org.apache.spark.api.java.JavaRDD;\n-import org.apache.spark.api.java.JavaSparkContext;\n-\n import java.io.Serializable;\n \n /**\n  * Base class for different types of indexes to determine the mapping from uuid.\n  */\n @PublicAPIClass(maturity = ApiMaturityLevel.EVOLVING)\n-public abstract class HoodieIndex<T extends HoodieRecordPayload> implements Serializable {\n+public abstract class HoodieIndex<T extends HoodieRecordPayload, I, K, O, P> implements Serializable {\n \n   protected final HoodieWriteConfig config;\n \n   protected HoodieIndex(HoodieWriteConfig config) {\n     this.config = config;\n   }\n \n-  public static <T extends HoodieRecordPayload> HoodieIndex<T> createIndex(\n-      HoodieWriteConfig config) throws HoodieIndexException {\n-    // first use index class config to create index.\n-    if (!StringUtils.isNullOrEmpty(config.getIndexClass())) {\n-      Object instance = ReflectionUtils.loadClass(config.getIndexClass(), config);\n-      if (!(instance instanceof HoodieIndex)) {\n-        throw new HoodieIndexException(config.getIndexClass() + \" is not a subclass of HoodieIndex\");\n-      }\n-      return (HoodieIndex) instance;\n-    }\n-    switch (config.getIndexType()) {\n-      case HBASE:\n-        return new HBaseIndex<>(config);\n-      case INMEMORY:\n-        return new InMemoryHashIndex<>(config);\n-      case BLOOM:\n-        return new HoodieBloomIndex<>(config);\n-      case GLOBAL_BLOOM:\n-        return new HoodieGlobalBloomIndex<>(config);\n-      case SIMPLE:\n-        return new HoodieSimpleIndex<>(config);\n-      case GLOBAL_SIMPLE:\n-        return new HoodieGlobalSimpleIndex<>(config);\n-      default:\n-        throw new HoodieIndexException(\"Index type unspecified, set \" + config.getIndexType());\n-    }\n-  }\n-\n   /**\n    * Checks if the given [Keys] exists in the hoodie table and returns [Key, Option[partitionPath, fileID]] If the\n    * optional is empty, then the key is not found.\n    */\n   @PublicAPIMethod(maturity = ApiMaturityLevel.STABLE)\n-  public abstract JavaPairRDD<HoodieKey, Option<Pair<String, String>>> fetchRecordLocation(\n-      JavaRDD<HoodieKey> hoodieKeys, final JavaSparkContext jsc, HoodieTable<T> hoodieTable);\n+  public abstract P fetchRecordLocation(\n+      K hoodieKeys, final HoodieEngineContext context, HoodieTable<T, I, K, O, P> hoodieTable);\n \n   /**\n    * Looks up the index and tags each incoming record with a location of a file that contains the row (if it is actually\n    * present).\n    */\n   @PublicAPIMethod(maturity = ApiMaturityLevel.STABLE)", "originalCommit": "ac3339704c703741f9ff50f2d96019cef2d2c72b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDgxNTQwMg==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484815402", "bodyText": "these annotations needs to moved over to a SparkHoodieIndex class? it will be hard for end developers to program against HoodieIndex directly anymore. This is a general point actually. The current public APIs should all be annotated against the Spark child classes. wdyt?\n\ngood idea, done", "author": "wangxianghu", "createdAt": "2020-09-08T10:29:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA5NzYxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA5NzY1NA==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484097654", "bodyText": "I suggest introducing a SparkHoodieIndex base class", "author": "vinothchandar", "createdAt": "2020-09-06T17:58:34Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/index/bloom/BaseHoodieBloomIndex.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.index.bloom;\n+\n+import org.apache.hudi.common.HoodieEngineContext;\n+import org.apache.hudi.common.model.HoodieRecordPayload;\n+import org.apache.hudi.config.HoodieWriteConfig;\n+import org.apache.hudi.exception.HoodieIndexException;\n+import org.apache.hudi.index.HoodieIndex;\n+import org.apache.hudi.table.HoodieTable;\n+\n+/**\n+ * Indexing mechanism based on bloom filter. Each parquet file includes its row_key bloom filter in its metadata.\n+ */\n+public abstract class BaseHoodieBloomIndex<T extends HoodieRecordPayload, I, K, O, P> extends HoodieIndex<T, I, K, O, P> {", "originalCommit": "ac3339704c703741f9ff50f2d96019cef2d2c72b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDkyMTYxMg==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484921612", "bodyText": "I suggest introducing a SparkHoodieIndex base class\n\ndone", "author": "wangxianghu", "createdAt": "2020-09-08T13:30:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA5NzY1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA5Nzk1MA==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484097950", "bodyText": "are there any code changes here, i.e logic changes?", "author": "vinothchandar", "createdAt": "2020-09-06T18:01:32Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/index/hbase/BaseHoodieHBaseIndex.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.index.hbase;\n+\n+import org.apache.hudi.common.HoodieEngineContext;\n+import org.apache.hudi.common.model.HoodieRecordPayload;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.table.timeline.HoodieTimeline;\n+import org.apache.hudi.common.util.ReflectionUtils;\n+import org.apache.hudi.config.HoodieHBaseIndexConfig;\n+import org.apache.hudi.config.HoodieWriteConfig;\n+import org.apache.hudi.exception.HoodieDependentSystemUnavailableException;\n+import org.apache.hudi.index.HoodieIndex;\n+import org.apache.hudi.table.HoodieTable;\n+\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.HBaseConfiguration;\n+import org.apache.hadoop.hbase.HRegionLocation;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.client.BufferedMutator;\n+import org.apache.hadoop.hbase.client.Connection;\n+import org.apache.hadoop.hbase.client.ConnectionFactory;\n+import org.apache.hadoop.hbase.client.Get;\n+import org.apache.hadoop.hbase.client.HTable;\n+import org.apache.hadoop.hbase.client.Mutation;\n+import org.apache.hadoop.hbase.client.RegionLocator;\n+import org.apache.hadoop.hbase.client.Result;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.List;\n+\n+/**\n+ * Hoodie Index implementation backed by HBase.\n+ */\n+public abstract class BaseHoodieHBaseIndex<T extends HoodieRecordPayload, I, K, O, P> extends HoodieIndex<T, I, K, O, P> {", "originalCommit": "ac3339704c703741f9ff50f2d96019cef2d2c72b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDkyMTk5NA==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484921994", "bodyText": "are there any code changes here, i.e logic changes?\n\nnothing changed", "author": "wangxianghu", "createdAt": "2020-09-08T13:31:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA5Nzk1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA5ODM1MA==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484098350", "bodyText": "we should make sure there are no backwards incompatible changes to the key generator interface", "author": "vinothchandar", "createdAt": "2020-09-06T18:05:46Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/keygen/KeyGeneratorInterface.java", "diffHunk": "@@ -34,8 +33,4 @@\n \n   List<String> getRecordKeyFieldNames();\n \n-  String getRecordKey(Row row);", "originalCommit": "ac3339704c703741f9ff50f2d96019cef2d2c72b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDgxNjY5MA==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484816690", "bodyText": "we should make sure there are no backwards incompatible changes to the key generator interface\n\nYes, I moved it to SparkKeyGeneratorInterface", "author": "wangxianghu", "createdAt": "2020-09-08T10:31:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA5ODM1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA5ODg5Mw==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484098893", "bodyText": "why is this no longer a mergeHandle?", "author": "vinothchandar", "createdAt": "2020-09-06T18:12:15Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/table/action/commit/BaseMergeHelper.java", "diffHunk": "@@ -161,11 +108,11 @@ private static GenericRecord transformRecordBasedOnNewSchema(GenericDatumReader<\n   /**\n    * Consumer that dequeues records from queue and sends to Merge Handle.\n    */\n-  private static class UpdateHandler extends BoundedInMemoryQueueConsumer<GenericRecord, Void> {\n+  static class UpdateHandler extends BoundedInMemoryQueueConsumer<GenericRecord, Void> {\n \n-    private final HoodieMergeHandle upsertHandle;\n+    private final HoodieWriteHandle upsertHandle;", "originalCommit": "ac3339704c703741f9ff50f2d96019cef2d2c72b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDkyNTY4OQ==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484925689", "bodyText": "why is this no longer a mergeHandle?\n\nHoodieWriteHandle is spark-free, while HoodieMergeHandle is not. To abstract MergeHelper, the variables it holds should be spark-free too", "author": "wangxianghu", "createdAt": "2020-09-08T13:36:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA5ODg5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk5OTExNA==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r493999114", "bodyText": "why is this no longer a mergeHandle?\n\nWith parallelDo method introduced in, this change is no longer needed.  rollback already", "author": "wangxianghu", "createdAt": "2020-09-24T02:16:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA5ODg5Mw=="}], "type": "inlineReview"}, {"oid": "57869f2f1ad83183779c98536ea3862eb30d0cc3", "url": "https://github.com/apache/hudi/commit/57869f2f1ad83183779c98536ea3862eb30d0cc3", "message": "rebase master", "committedDate": "2020-09-07T05:36:24Z", "type": "forcePushed"}, {"oid": "a9ddf89e5c79996b2a4720bb467b7dc696e4f3d8", "url": "https://github.com/apache/hudi/commit/a9ddf89e5c79996b2a4720bb467b7dc696e4f3d8", "message": "rebase master", "committedDate": "2020-09-07T05:47:04Z", "type": "forcePushed"}, {"oid": "ac3339704c703741f9ff50f2d96019cef2d2c72b", "url": "https://github.com/apache/hudi/commit/ac3339704c703741f9ff50f2d96019cef2d2c72b", "message": "rebase master", "committedDate": "2020-09-06T16:35:49Z", "type": "forcePushed"}, {"oid": "e24c968a27d9cdbb746e68ff09b86c25da758c82", "url": "https://github.com/apache/hudi/commit/e24c968a27d9cdbb746e68ff09b86c25da758c82", "message": "resolve conflicts", "committedDate": "2020-09-07T14:04:45Z", "type": "forcePushed"}, {"oid": "7aedc0bdc1565d47b044487aab04b659167bd086", "url": "https://github.com/apache/hudi/commit/7aedc0bdc1565d47b044487aab04b659167bd086", "message": "resolve conflicts", "committedDate": "2020-09-07T14:23:15Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDEzNDg1Mg==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484134852", "bodyText": "These sort of classes, we should have a way to implement with just a reference to engineContext ideally. Even though we cannot implement every method in sparkContext. This is a topic for later", "author": "vinothchandar", "createdAt": "2020-09-07T00:30:06Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/table/action/rollback/BaseMarkerBasedRollbackStrategy.java", "diffHunk": "@@ -18,63 +18,58 @@\n \n package org.apache.hudi.table.action.rollback;\n \n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.HoodieEngineContext;\n import org.apache.hudi.common.HoodieRollbackStat;\n import org.apache.hudi.common.fs.FSUtils;\n import org.apache.hudi.common.model.HoodieLogFile;\n-import org.apache.hudi.common.model.IOType;\n+import org.apache.hudi.common.model.HoodieRecordPayload;\n import org.apache.hudi.common.table.log.HoodieLogFormat;\n import org.apache.hudi.common.table.log.block.HoodieCommandBlock;\n import org.apache.hudi.common.table.log.block.HoodieLogBlock;\n import org.apache.hudi.common.table.timeline.HoodieInstant;\n import org.apache.hudi.config.HoodieWriteConfig;\n import org.apache.hudi.exception.HoodieIOException;\n-import org.apache.hudi.exception.HoodieRollbackException;\n import org.apache.hudi.table.HoodieTable;\n-import org.apache.hudi.table.MarkerFiles;\n \n-import org.apache.hadoop.fs.Path;\n import org.apache.log4j.LogManager;\n import org.apache.log4j.Logger;\n-import org.apache.spark.api.java.JavaSparkContext;\n \n import java.io.IOException;\n import java.util.Collections;\n-import java.util.List;\n import java.util.Map;\n \n-import scala.Tuple2;\n-\n /**\n  * Performs rollback using marker files generated during the write..\n  */\n-public class MarkerBasedRollbackStrategy implements BaseRollbackActionExecutor.RollbackStrategy {\n+public abstract class BaseMarkerBasedRollbackStrategy<T extends HoodieRecordPayload, I, K, O, P> implements BaseRollbackActionExecutor.RollbackStrategy {", "originalCommit": "ac3339704c703741f9ff50f2d96019cef2d2c72b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDEzNTEzNw==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484135137", "bodyText": "would a parallelDo(func, parallelism) method in HoodieEngineContext help us avoid a lot of base/child class duplication of logic like this?\nMost of clean, compact, rollback, restore etc can be implemented this way. Most of them just take a list, parallelize it, and execute some function, collect results and get the objects back", "author": "vinothchandar", "createdAt": "2020-09-07T00:32:18Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/table/action/rollback/BaseMarkerBasedRollbackStrategy.java", "diffHunk": "@@ -132,32 +127,4 @@ private HoodieRollbackStat undoAppend(String appendBaseFilePath, HoodieInstant i\n         .build();\n   }\n \n-  @Override\n-  public List<HoodieRollbackStat> execute(HoodieInstant instantToRollback) {\n-    try {\n-      MarkerFiles markerFiles = new MarkerFiles(table, instantToRollback.getTimestamp());\n-      List<String> markerFilePaths = markerFiles.allMarkerFilePaths();\n-      int parallelism = Math.max(Math.min(markerFilePaths.size(), config.getRollbackParallelism()), 1);\n-      return jsc.parallelize(markerFilePaths, parallelism)\n-          .map(markerFilePath -> {", "originalCommit": "ac3339704c703741f9ff50f2d96019cef2d2c72b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDUxNjMzOQ==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484516339", "bodyText": "the MOR equivalent method got moved I guess", "author": "vinothchandar", "createdAt": "2020-09-07T16:33:44Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/table/action/rollback/RollbackUtils.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.table.action.rollback;\n+\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import org.apache.hudi.common.HoodieRollbackStat;\n+import org.apache.hudi.common.fs.FSUtils;\n+import org.apache.hudi.common.model.FileSlice;\n+import org.apache.hudi.common.model.HoodieCommitMetadata;\n+import org.apache.hudi.common.model.HoodieWriteStat;\n+import org.apache.hudi.common.table.log.block.HoodieCommandBlock;\n+import org.apache.hudi.common.table.log.block.HoodieLogBlock;\n+import org.apache.hudi.common.table.timeline.HoodieInstant;\n+import org.apache.hudi.common.table.timeline.HoodieTimeline;\n+import org.apache.hudi.common.util.Option;\n+import org.apache.hudi.common.util.ValidationUtils;\n+import org.apache.hudi.exception.HoodieIOException;\n+import org.apache.hudi.table.HoodieTable;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+public class RollbackUtils {\n+\n+  private static final Logger LOG = LogManager.getLogger(RollbackUtils.class);\n+\n+  static Map<HoodieLogBlock.HeaderMetadataType, String> generateHeader(String instantToRollback, String rollbackInstantTime) {\n+    // generate metadata\n+    Map<HoodieLogBlock.HeaderMetadataType, String> header = new HashMap<>(3);\n+    header.put(HoodieLogBlock.HeaderMetadataType.INSTANT_TIME, rollbackInstantTime);\n+    header.put(HoodieLogBlock.HeaderMetadataType.TARGET_INSTANT_TIME, instantToRollback);\n+    header.put(HoodieLogBlock.HeaderMetadataType.COMMAND_BLOCK_TYPE,\n+        String.valueOf(HoodieCommandBlock.HoodieCommandBlockTypeEnum.ROLLBACK_PREVIOUS_BLOCK.ordinal()));\n+    return header;\n+  }\n+\n+  /**\n+   * Helper to merge 2 rollback-stats for a given partition.\n+   *\n+   * @param stat1 HoodieRollbackStat\n+   * @param stat2 HoodieRollbackStat\n+   * @return Merged HoodieRollbackStat\n+   */\n+  static HoodieRollbackStat mergeRollbackStat(HoodieRollbackStat stat1, HoodieRollbackStat stat2) {\n+    ValidationUtils.checkArgument(stat1.getPartitionPath().equals(stat2.getPartitionPath()));\n+    final List<String> successDeleteFiles = new ArrayList<>();\n+    final List<String> failedDeleteFiles = new ArrayList<>();\n+    final Map<FileStatus, Long> commandBlocksCount = new HashMap<>();\n+    final List<FileStatus> filesToRollback = new ArrayList<>();\n+    Option.ofNullable(stat1.getSuccessDeleteFiles()).ifPresent(successDeleteFiles::addAll);\n+    Option.ofNullable(stat2.getSuccessDeleteFiles()).ifPresent(successDeleteFiles::addAll);\n+    Option.ofNullable(stat1.getFailedDeleteFiles()).ifPresent(failedDeleteFiles::addAll);\n+    Option.ofNullable(stat2.getFailedDeleteFiles()).ifPresent(failedDeleteFiles::addAll);\n+    Option.ofNullable(stat1.getCommandBlocksCount()).ifPresent(commandBlocksCount::putAll);\n+    Option.ofNullable(stat2.getCommandBlocksCount()).ifPresent(commandBlocksCount::putAll);\n+    return new HoodieRollbackStat(stat1.getPartitionPath(), successDeleteFiles, failedDeleteFiles, commandBlocksCount);\n+  }\n+\n+  /**\n+   * Generate all rollback requests that needs rolling back this action without actually performing rollback for COW table type.\n+   * @param fs instance of {@link FileSystem} to use.\n+   * @param basePath base path of interest.\n+   * @param shouldAssumeDatePartitioning {@code true} if date partitioning should be assumed. {@code false} otherwise.\n+   * @return {@link List} of {@link ListingBasedRollbackRequest}s thus collected.\n+   */\n+  public static List<ListingBasedRollbackRequest> generateRollbackRequestsByListingCOW(FileSystem fs, String basePath, boolean shouldAssumeDatePartitioning) {", "originalCommit": "7aedc0bdc1565d47b044487aab04b659167bd086", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDgyMzQ2NQ==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484823465", "bodyText": "the MOR equivalent method got moved I guess\n\nYes,  MOR equivalent method moved to SparkRollbackUtils.", "author": "wangxianghu", "createdAt": "2020-09-08T10:44:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDUxNjMzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDUxNjk5Ng==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484516996", "bodyText": "might make sense to move the COMPACT_POOL_NAME also to the child class", "author": "vinothchandar", "createdAt": "2020-09-07T16:35:59Z", "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/async/HoodieSparkAsyncCompactService.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.async;\n+\n+import org.apache.hudi.asyc.BaseAsyncCompactService;\n+import org.apache.hudi.client.AbstractHoodieWriteClient;\n+import org.apache.hudi.client.BaseCompactor;\n+import org.apache.hudi.client.HoodieSparkCompactor;\n+import org.apache.hudi.common.HoodieEngineContext;\n+import org.apache.hudi.common.HoodieSparkEngineContext;\n+import org.apache.hudi.common.table.timeline.HoodieInstant;\n+import org.apache.hudi.common.util.collection.Pair;\n+import org.apache.hudi.exception.HoodieIOException;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+import org.apache.spark.api.java.JavaSparkContext;\n+\n+import java.io.IOException;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.stream.IntStream;\n+\n+public class HoodieSparkAsyncCompactService extends BaseAsyncCompactService {\n+\n+  private static final Logger LOG = LogManager.getLogger(HoodieSparkAsyncCompactService.class);\n+\n+  private transient JavaSparkContext jssc;\n+  public HoodieSparkAsyncCompactService(HoodieEngineContext context, AbstractHoodieWriteClient client) {\n+    super(context, client);\n+    this.jssc = HoodieSparkEngineContext.getSparkContext(context);\n+  }\n+\n+  public HoodieSparkAsyncCompactService(HoodieEngineContext context, AbstractHoodieWriteClient client, boolean runInDaemonMode) {\n+    super(context, client, runInDaemonMode);\n+    this.jssc = HoodieSparkEngineContext.getSparkContext(context);\n+  }\n+\n+  @Override\n+  protected BaseCompactor createCompactor(AbstractHoodieWriteClient client) {\n+    return new HoodieSparkCompactor(client);\n+  }\n+\n+  @Override\n+  protected Pair<CompletableFuture, ExecutorService> startService() {\n+    ExecutorService executor = Executors.newFixedThreadPool(maxConcurrentCompaction,\n+        r -> {\n+          Thread t = new Thread(r, \"async_compact_thread\");\n+          t.setDaemon(isRunInDaemonMode());\n+          return t;\n+        });\n+    return Pair.of(CompletableFuture.allOf(IntStream.range(0, maxConcurrentCompaction).mapToObj(i -> CompletableFuture.supplyAsync(() -> {\n+      try {\n+        // Set Compactor Pool Name for allowing users to prioritize compaction\n+        LOG.info(\"Setting Spark Pool name for compaction to \" + COMPACT_POOL_NAME);\n+        jssc.setLocalProperty(\"spark.scheduler.pool\", COMPACT_POOL_NAME);", "originalCommit": "7aedc0bdc1565d47b044487aab04b659167bd086", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDUyMDAxMw==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484520013", "bodyText": "wondering if this renaming will have any impact on deserializing older plans. cc @bvaradar to confirm", "author": "vinothchandar", "createdAt": "2020-09-07T16:46:49Z", "path": "hudi-utilities/src/main/java/org/apache/hudi/utilities/HoodieCompactionAdminTool.java", "diffHunk": "@@ -60,38 +60,38 @@ public static void main(String[] args) throws Exception {\n    */\n   public void run(JavaSparkContext jsc) throws Exception {\n     HoodieTableMetaClient metaClient = new HoodieTableMetaClient(jsc.hadoopConfiguration(), cfg.basePath);\n-    try (CompactionAdminClient admin = new CompactionAdminClient(jsc, cfg.basePath)) {\n+    try (HoodieSparkCompactionAdminClient admin = new HoodieSparkCompactionAdminClient(new HoodieSparkEngineContext(jsc), cfg.basePath)) {\n       final FileSystem fs = FSUtils.getFs(cfg.basePath, jsc.hadoopConfiguration());\n       if (cfg.outputPath != null && fs.exists(new Path(cfg.outputPath))) {\n         throw new IllegalStateException(\"Output File Path already exists\");\n       }\n       switch (cfg.operation) {\n         case VALIDATE:\n-          List<ValidationOpResult> res =\n+          List<BaseCompactionAdminClient.ValidationOpResult> res =\n               admin.validateCompactionPlan(metaClient, cfg.compactionInstantTime, cfg.parallelism);\n           if (cfg.printOutput) {\n             printOperationResult(\"Result of Validation Operation :\", res);\n           }\n           serializeOperationResult(fs, res);\n           break;\n         case UNSCHEDULE_FILE:\n-          List<RenameOpResult> r = admin.unscheduleCompactionFileId(\n+          List<BaseCompactionAdminClient.RenameOpResult> r = admin.unscheduleCompactionFileId(\n               new HoodieFileGroupId(cfg.partitionPath, cfg.fileId), cfg.skipValidation, cfg.dryRun);\n           if (cfg.printOutput) {\n             System.out.println(r);\n           }\n           serializeOperationResult(fs, r);\n           break;\n         case UNSCHEDULE_PLAN:\n-          List<RenameOpResult> r2 = admin.unscheduleCompactionPlan(cfg.compactionInstantTime, cfg.skipValidation,\n+          List<BaseCompactionAdminClient.RenameOpResult> r2 = admin.unscheduleCompactionPlan(cfg.compactionInstantTime, cfg.skipValidation,", "originalCommit": "7aedc0bdc1565d47b044487aab04b659167bd086", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDUyMDkyOQ==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484520929", "bodyText": "rename: generateInputRecords", "author": "vinothchandar", "createdAt": "2020-09-07T16:50:14Z", "path": "hudi-spark/src/main/java/org/apache/hudi/bootstrap/SparkParquetBootstrapDataProvider.java", "diffHunk": "@@ -43,18 +43,18 @@\n /**\n  * Spark Data frame based bootstrap input provider.\n  */\n-public class SparkParquetBootstrapDataProvider extends FullRecordBootstrapDataProvider {\n+public class SparkParquetBootstrapDataProvider extends FullRecordBootstrapDataProvider<JavaRDD<HoodieRecord>> {\n \n   private final transient SparkSession sparkSession;\n \n   public SparkParquetBootstrapDataProvider(TypedProperties props,\n-                                           JavaSparkContext jsc) {\n-    super(props, jsc);\n-    this.sparkSession = SparkSession.builder().config(jsc.getConf()).getOrCreate();\n+                                           HoodieSparkEngineContext context) {\n+    super(props, context);\n+    this.sparkSession = SparkSession.builder().config(context.getJavaSparkContext().getConf()).getOrCreate();\n   }\n \n   @Override\n-  public JavaRDD<HoodieRecord> generateInputRecordRDD(String tableName, String sourceBasePath,\n+  public JavaRDD<HoodieRecord> generateInputRecord(String tableName, String sourceBasePath,", "originalCommit": "7aedc0bdc1565d47b044487aab04b659167bd086", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDkyODExNw==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484928117", "bodyText": "rename: generateInputRecords\n\ndone", "author": "wangxianghu", "createdAt": "2020-09-08T13:39:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDUyMDkyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDUzODgxNQ==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484538815", "bodyText": "why was this change required?", "author": "vinothchandar", "createdAt": "2020-09-07T18:15:06Z", "path": "hudi-client/hudi-spark-client/src/test/java/org/apache/hudi/testutils/HoodieClientTestUtils.java", "diffHunk": "@@ -81,7 +82,9 @@\n    */\n   public static SparkConf getSparkConfForTest(String appName) {\n     SparkConf sparkConf = new SparkConf().setAppName(appName)\n-        .set(\"spark.serializer\", \"org.apache.spark.serializer.KryoSerializer\").setMaster(\"local[8]\");\n+        .set(\"spark.serializer\", \"org.apache.spark.serializer.KryoSerializer\")\n+        .set(\"spark.driver.host\",\"localhost\")", "originalCommit": "7aedc0bdc1565d47b044487aab04b659167bd086", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDkzMTE2MQ==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484931161", "bodyText": "why was this change required?\n\nI have rolled back this.\nThe unit test is not runnable in my local yesterday, but ok now... weird", "author": "wangxianghu", "createdAt": "2020-09-08T13:43:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDUzODgxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU5ODU1OQ==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484598559", "bodyText": "need to ensure the ordering of closing resources is the same as before/", "author": "vinothchandar", "createdAt": "2020-09-08T01:01:41Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -716,32 +674,97 @@ private void rollbackPendingCommits() {\n    * @param compactionInstantTime Compaction Instant Time\n    * @return RDD of Write Status\n    */\n-  private JavaRDD<WriteStatus> compact(String compactionInstantTime, boolean shouldComplete) {\n-    HoodieTable<T> table = HoodieTable.create(config, hadoopConf);\n-    HoodieTimeline pendingCompactionTimeline = table.getActiveTimeline().filterPendingCompactionTimeline();\n-    HoodieInstant inflightInstant = HoodieTimeline.getCompactionInflightInstant(compactionInstantTime);\n-    if (pendingCompactionTimeline.containsInstant(inflightInstant)) {\n-      rollbackInflightCompaction(inflightInstant, table);\n-      table.getMetaClient().reloadActiveTimeline();\n-    }\n-    compactionTimer = metrics.getCompactionCtx();\n-    HoodieWriteMetadata compactionMetadata = table.compact(jsc, compactionInstantTime);\n-    JavaRDD<WriteStatus> statuses = compactionMetadata.getWriteStatuses();\n-    if (shouldComplete && compactionMetadata.getCommitMetadata().isPresent()) {\n-      completeCompaction(compactionMetadata.getCommitMetadata().get(), statuses, table, compactionInstantTime);\n-    }\n-    return statuses;\n-  }\n+  protected abstract O compact(String compactionInstantTime, boolean shouldComplete);\n \n   /**\n    * Performs a compaction operation on a table, serially before or after an insert/upsert action.\n    */\n-  private Option<String> inlineCompact(Option<Map<String, String>> extraMetadata) {\n+  protected Option<String> inlineCompact(Option<Map<String, String>> extraMetadata) {\n     Option<String> compactionInstantTimeOpt = scheduleCompaction(extraMetadata);\n     compactionInstantTimeOpt.ifPresent(compactionInstantTime -> {\n       // inline compaction should auto commit as the user is never given control\n       compact(compactionInstantTime, true);\n     });\n     return compactionInstantTimeOpt;\n   }\n+\n+  /**\n+   * Finalize Write operation.\n+   *\n+   * @param table       HoodieTable\n+   * @param instantTime Instant Time\n+   * @param stats       Hoodie Write Stat\n+   */\n+  protected void finalizeWrite(HoodieTable<T, I, K, O, P> table, String instantTime, List<HoodieWriteStat> stats) {\n+    try {\n+      final Timer.Context finalizeCtx = metrics.getFinalizeCtx();\n+      table.finalizeWrite(context, instantTime, stats);\n+      if (finalizeCtx != null) {\n+        Option<Long> durationInMs = Option.of(metrics.getDurationInMs(finalizeCtx.stop()));\n+        durationInMs.ifPresent(duration -> {\n+          LOG.info(\"Finalize write elapsed time (milliseconds): \" + duration);\n+          metrics.updateFinalizeWriteMetrics(duration, stats.size());\n+        });\n+      }\n+    } catch (HoodieIOException ioe) {\n+      throw new HoodieCommitException(\"Failed to complete commit \" + instantTime + \" due to finalize errors.\", ioe);\n+    }\n+  }\n+\n+  public HoodieMetrics getMetrics() {\n+    return metrics;\n+  }\n+\n+  public HoodieIndex<T, I, K, O, P> getIndex() {\n+    return index;\n+  }\n+\n+  /**\n+   * Get HoodieTable and init {@link Timer.Context}.\n+   *\n+   * @param operationType write operation type\n+   * @param instantTime   current inflight instant time\n+   * @return HoodieTable\n+   */\n+  protected abstract HoodieTable<T, I, K, O, P> getTableAndInitCtx(WriteOperationType operationType, String instantTime);\n+\n+  /**\n+   * Sets write schema from last instant since deletes may not have schema set in the config.\n+   */\n+  protected void setWriteSchemaForDeletes(HoodieTableMetaClient metaClient) {\n+    try {\n+      HoodieActiveTimeline activeTimeline = metaClient.getActiveTimeline();\n+      Option<HoodieInstant> lastInstant =\n+          activeTimeline.filterCompletedInstants().filter(s -> s.getAction().equals(metaClient.getCommitActionType()))\n+              .lastInstant();\n+      if (lastInstant.isPresent()) {\n+        HoodieCommitMetadata commitMetadata = HoodieCommitMetadata.fromBytes(\n+            activeTimeline.getInstantDetails(lastInstant.get()).get(), HoodieCommitMetadata.class);\n+        if (commitMetadata.getExtraMetadata().containsKey(HoodieCommitMetadata.SCHEMA_KEY)) {\n+          config.setSchema(commitMetadata.getExtraMetadata().get(HoodieCommitMetadata.SCHEMA_KEY));\n+        } else {\n+          throw new HoodieIOException(\"Latest commit does not have any schema in commit metadata\");\n+        }\n+      } else {\n+        throw new HoodieIOException(\"Deletes issued without any prior commits\");\n+      }\n+    } catch (IOException e) {\n+      throw new HoodieIOException(\"IOException thrown while reading last commit metadata\", e);\n+    }\n+  }\n+\n+  public abstract AsyncCleanerService startAsyncCleaningIfEnabled(AbstractHoodieWriteClient<T, I, K, O, P> client, String instantTime);\n+\n+  @Override\n+  public void close() {", "originalCommit": "7aedc0bdc1565d47b044487aab04b659167bd086", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDkzMTcwNw==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484931707", "bodyText": "need to ensure the ordering of closing resources is the same as before/\n\nYes, they are the same.", "author": "wangxianghu", "createdAt": "2020-09-08T13:44:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU5ODU1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU5OTI3NQ==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484599275", "bodyText": "Let's name this SparkRDDWriteClient ?", "author": "vinothchandar", "createdAt": "2020-09-08T01:05:55Z", "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/client/HoodieSparkWriteClient.java", "diffHunk": "@@ -0,0 +1,360 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.client;\n+\n+import com.codahale.metrics.Timer;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hudi.client.embebbed.BaseEmbeddedTimelineService;\n+import org.apache.hudi.client.embedded.SparkEmbeddedTimelineService;\n+import org.apache.hudi.common.HoodieEngineContext;\n+import org.apache.hudi.common.HoodieSparkEngineContext;\n+import org.apache.hudi.common.model.HoodieCommitMetadata;\n+import org.apache.hudi.common.model.HoodieKey;\n+import org.apache.hudi.common.model.HoodieRecord;\n+import org.apache.hudi.common.model.HoodieRecordPayload;\n+import org.apache.hudi.common.model.HoodieWriteStat;\n+import org.apache.hudi.common.model.WriteOperationType;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.table.HoodieTableVersion;\n+import org.apache.hudi.common.table.timeline.HoodieActiveTimeline;\n+import org.apache.hudi.common.table.timeline.HoodieInstant;\n+import org.apache.hudi.common.table.timeline.HoodieTimeline;\n+import org.apache.hudi.common.util.Option;\n+import org.apache.hudi.common.util.collection.Pair;\n+import org.apache.hudi.config.HoodieCompactionConfig;\n+import org.apache.hudi.config.HoodieWriteConfig;\n+import org.apache.hudi.exception.HoodieCommitException;\n+import org.apache.hudi.exception.HoodieIOException;\n+import org.apache.hudi.index.HoodieIndex;\n+import org.apache.hudi.index.HoodieSparkIndexFactory;\n+import org.apache.hudi.table.BaseHoodieTimelineArchiveLog;\n+import org.apache.hudi.table.BulkInsertPartitioner;\n+import org.apache.hudi.table.HoodieSparkTable;\n+import org.apache.hudi.table.HoodieSparkTimelineArchiveLog;\n+import org.apache.hudi.table.HoodieTable;\n+import org.apache.hudi.table.SparkMarkerFiles;\n+import org.apache.hudi.table.action.HoodieWriteMetadata;\n+import org.apache.hudi.table.action.compact.SparkCompactHelpers;\n+import org.apache.hudi.table.upgrade.SparkUpgradeDowngrade;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+import org.apache.spark.SparkConf;\n+import org.apache.spark.api.java.JavaPairRDD;\n+import org.apache.spark.api.java.JavaRDD;\n+\n+import java.io.IOException;\n+import java.text.ParseException;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class HoodieSparkWriteClient<T extends HoodieRecordPayload> extends AbstractHoodieWriteClient<T,", "originalCommit": "7aedc0bdc1565d47b044487aab04b659167bd086", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDkzMTMxNw==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484931317", "bodyText": "Let's name this SparkRDDWriteClient ?\n\ndone", "author": "wangxianghu", "createdAt": "2020-09-08T13:43:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU5OTI3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDYwMDc0Mg==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484600742", "bodyText": "why are we not hanging onto the returned object?", "author": "vinothchandar", "createdAt": "2020-09-08T01:13:43Z", "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/client/HoodieSparkWriteClient.java", "diffHunk": "@@ -0,0 +1,360 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.client;\n+\n+import com.codahale.metrics.Timer;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hudi.client.embebbed.BaseEmbeddedTimelineService;\n+import org.apache.hudi.client.embedded.SparkEmbeddedTimelineService;\n+import org.apache.hudi.common.HoodieEngineContext;\n+import org.apache.hudi.common.HoodieSparkEngineContext;\n+import org.apache.hudi.common.model.HoodieCommitMetadata;\n+import org.apache.hudi.common.model.HoodieKey;\n+import org.apache.hudi.common.model.HoodieRecord;\n+import org.apache.hudi.common.model.HoodieRecordPayload;\n+import org.apache.hudi.common.model.HoodieWriteStat;\n+import org.apache.hudi.common.model.WriteOperationType;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.table.HoodieTableVersion;\n+import org.apache.hudi.common.table.timeline.HoodieActiveTimeline;\n+import org.apache.hudi.common.table.timeline.HoodieInstant;\n+import org.apache.hudi.common.table.timeline.HoodieTimeline;\n+import org.apache.hudi.common.util.Option;\n+import org.apache.hudi.common.util.collection.Pair;\n+import org.apache.hudi.config.HoodieCompactionConfig;\n+import org.apache.hudi.config.HoodieWriteConfig;\n+import org.apache.hudi.exception.HoodieCommitException;\n+import org.apache.hudi.exception.HoodieIOException;\n+import org.apache.hudi.index.HoodieIndex;\n+import org.apache.hudi.index.HoodieSparkIndexFactory;\n+import org.apache.hudi.table.BaseHoodieTimelineArchiveLog;\n+import org.apache.hudi.table.BulkInsertPartitioner;\n+import org.apache.hudi.table.HoodieSparkTable;\n+import org.apache.hudi.table.HoodieSparkTimelineArchiveLog;\n+import org.apache.hudi.table.HoodieTable;\n+import org.apache.hudi.table.SparkMarkerFiles;\n+import org.apache.hudi.table.action.HoodieWriteMetadata;\n+import org.apache.hudi.table.action.compact.SparkCompactHelpers;\n+import org.apache.hudi.table.upgrade.SparkUpgradeDowngrade;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+import org.apache.spark.SparkConf;\n+import org.apache.spark.api.java.JavaPairRDD;\n+import org.apache.spark.api.java.JavaRDD;\n+\n+import java.io.IOException;\n+import java.text.ParseException;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class HoodieSparkWriteClient<T extends HoodieRecordPayload> extends AbstractHoodieWriteClient<T,\n+    JavaRDD<HoodieRecord<T>>, JavaRDD<HoodieKey>, JavaRDD<WriteStatus>, JavaPairRDD<HoodieKey, Option<Pair<String, String>>>> {\n+\n+  private static final Logger LOG = LogManager.getLogger(HoodieSparkWriteClient.class);\n+\n+  public HoodieSparkWriteClient(HoodieEngineContext context, HoodieWriteConfig clientConfig) {\n+    super(context, clientConfig);\n+  }\n+\n+  public HoodieSparkWriteClient(HoodieEngineContext context, HoodieWriteConfig writeConfig, boolean rollbackPending) {\n+    super(context, writeConfig, rollbackPending);\n+  }\n+\n+  public HoodieSparkWriteClient(HoodieEngineContext context, HoodieWriteConfig writeConfig, boolean rollbackPending, Option<BaseEmbeddedTimelineService> timelineService) {\n+    super(context, writeConfig, rollbackPending, timelineService);\n+  }\n+\n+  /**\n+   * Register hudi classes for Kryo serialization.\n+   *\n+   * @param conf instance of SparkConf\n+   * @return SparkConf\n+   */\n+  public static SparkConf registerClasses(SparkConf conf) {\n+    conf.registerKryoClasses(new Class[]{HoodieWriteConfig.class, HoodieRecord.class, HoodieKey.class});\n+    return conf;\n+  }\n+\n+  @Override\n+  protected HoodieIndex<T, JavaRDD<HoodieRecord<T>>, JavaRDD<HoodieKey>, JavaRDD<WriteStatus>, JavaPairRDD<HoodieKey, Option<Pair<String, String>>>> createIndex(HoodieWriteConfig writeConfig) {\n+    return HoodieSparkIndexFactory.createIndex(config);\n+  }\n+\n+  @Override\n+  public boolean commit(String instantTime, JavaRDD<WriteStatus> writeStatuses, Option<Map<String, String>> extraMetadata) {\n+    List<HoodieWriteStat> stats = writeStatuses.map(WriteStatus::getStat).collect();\n+    return commitStats(instantTime, stats, extraMetadata);\n+  }\n+\n+  @Override\n+  protected HoodieTable<T, JavaRDD<HoodieRecord<T>>, JavaRDD<HoodieKey>, JavaRDD<WriteStatus>, JavaPairRDD<HoodieKey, Option<Pair<String, String>>>> createTable(HoodieWriteConfig config, Configuration hadoopConf) {\n+    return HoodieSparkTable.create(config, context);\n+  }\n+\n+  @Override\n+  public JavaRDD<HoodieRecord<T>> filterExists(JavaRDD<HoodieRecord<T>> hoodieRecords) {\n+    // Create a Hoodie table which encapsulated the commits and files visible\n+    HoodieTable table = HoodieSparkTable.create(config, context);\n+    Timer.Context indexTimer = metrics.getIndexCtx();\n+    JavaRDD<HoodieRecord<T>> recordsWithLocation = getIndex().tagLocation(hoodieRecords, context, table);\n+    metrics.updateIndexMetrics(LOOKUP_STR, metrics.getDurationInMs(indexTimer == null ? 0L : indexTimer.stop()));\n+    return recordsWithLocation.filter(v1 -> !v1.isCurrentLocationKnown());\n+  }\n+\n+  /**\n+   * Main API to run bootstrap to hudi.\n+   */\n+  @Override\n+  public void bootstrap(Option<Map<String, String>> extraMetadata) {\n+    if (rollbackPending) {\n+      rollBackInflightBootstrap();\n+    }\n+    HoodieSparkTable table = (HoodieSparkTable) getTableAndInitCtx(WriteOperationType.UPSERT, HoodieTimeline.METADATA_BOOTSTRAP_INSTANT_TS);\n+    table.bootstrap(context, extraMetadata);\n+  }\n+\n+  @Override\n+  public JavaRDD<WriteStatus> upsert(JavaRDD<HoodieRecord<T>> records, String instantTime) {\n+    HoodieSparkTable table = (HoodieSparkTable) getTableAndInitCtx(WriteOperationType.UPSERT, instantTime);\n+    table.validateUpsertSchema();\n+    setOperationType(WriteOperationType.UPSERT);\n+    startAsyncCleaningIfEnabled(this, instantTime);", "originalCommit": "7aedc0bdc1565d47b044487aab04b659167bd086", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDkzMzAxMw==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484933013", "bodyText": "why are we not hanging onto the returned object?\n\nmy bad. done", "author": "wangxianghu", "createdAt": "2020-09-08T13:46:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDYwMDc0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDYwMDgwNw==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484600807", "bodyText": "same here and everywhere else.", "author": "vinothchandar", "createdAt": "2020-09-08T01:14:01Z", "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/client/HoodieSparkWriteClient.java", "diffHunk": "@@ -0,0 +1,360 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.client;\n+\n+import com.codahale.metrics.Timer;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hudi.client.embebbed.BaseEmbeddedTimelineService;\n+import org.apache.hudi.client.embedded.SparkEmbeddedTimelineService;\n+import org.apache.hudi.common.HoodieEngineContext;\n+import org.apache.hudi.common.HoodieSparkEngineContext;\n+import org.apache.hudi.common.model.HoodieCommitMetadata;\n+import org.apache.hudi.common.model.HoodieKey;\n+import org.apache.hudi.common.model.HoodieRecord;\n+import org.apache.hudi.common.model.HoodieRecordPayload;\n+import org.apache.hudi.common.model.HoodieWriteStat;\n+import org.apache.hudi.common.model.WriteOperationType;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.table.HoodieTableVersion;\n+import org.apache.hudi.common.table.timeline.HoodieActiveTimeline;\n+import org.apache.hudi.common.table.timeline.HoodieInstant;\n+import org.apache.hudi.common.table.timeline.HoodieTimeline;\n+import org.apache.hudi.common.util.Option;\n+import org.apache.hudi.common.util.collection.Pair;\n+import org.apache.hudi.config.HoodieCompactionConfig;\n+import org.apache.hudi.config.HoodieWriteConfig;\n+import org.apache.hudi.exception.HoodieCommitException;\n+import org.apache.hudi.exception.HoodieIOException;\n+import org.apache.hudi.index.HoodieIndex;\n+import org.apache.hudi.index.HoodieSparkIndexFactory;\n+import org.apache.hudi.table.BaseHoodieTimelineArchiveLog;\n+import org.apache.hudi.table.BulkInsertPartitioner;\n+import org.apache.hudi.table.HoodieSparkTable;\n+import org.apache.hudi.table.HoodieSparkTimelineArchiveLog;\n+import org.apache.hudi.table.HoodieTable;\n+import org.apache.hudi.table.SparkMarkerFiles;\n+import org.apache.hudi.table.action.HoodieWriteMetadata;\n+import org.apache.hudi.table.action.compact.SparkCompactHelpers;\n+import org.apache.hudi.table.upgrade.SparkUpgradeDowngrade;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+import org.apache.spark.SparkConf;\n+import org.apache.spark.api.java.JavaPairRDD;\n+import org.apache.spark.api.java.JavaRDD;\n+\n+import java.io.IOException;\n+import java.text.ParseException;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class HoodieSparkWriteClient<T extends HoodieRecordPayload> extends AbstractHoodieWriteClient<T,\n+    JavaRDD<HoodieRecord<T>>, JavaRDD<HoodieKey>, JavaRDD<WriteStatus>, JavaPairRDD<HoodieKey, Option<Pair<String, String>>>> {\n+\n+  private static final Logger LOG = LogManager.getLogger(HoodieSparkWriteClient.class);\n+\n+  public HoodieSparkWriteClient(HoodieEngineContext context, HoodieWriteConfig clientConfig) {\n+    super(context, clientConfig);\n+  }\n+\n+  public HoodieSparkWriteClient(HoodieEngineContext context, HoodieWriteConfig writeConfig, boolean rollbackPending) {\n+    super(context, writeConfig, rollbackPending);\n+  }\n+\n+  public HoodieSparkWriteClient(HoodieEngineContext context, HoodieWriteConfig writeConfig, boolean rollbackPending, Option<BaseEmbeddedTimelineService> timelineService) {\n+    super(context, writeConfig, rollbackPending, timelineService);\n+  }\n+\n+  /**\n+   * Register hudi classes for Kryo serialization.\n+   *\n+   * @param conf instance of SparkConf\n+   * @return SparkConf\n+   */\n+  public static SparkConf registerClasses(SparkConf conf) {\n+    conf.registerKryoClasses(new Class[]{HoodieWriteConfig.class, HoodieRecord.class, HoodieKey.class});\n+    return conf;\n+  }\n+\n+  @Override\n+  protected HoodieIndex<T, JavaRDD<HoodieRecord<T>>, JavaRDD<HoodieKey>, JavaRDD<WriteStatus>, JavaPairRDD<HoodieKey, Option<Pair<String, String>>>> createIndex(HoodieWriteConfig writeConfig) {\n+    return HoodieSparkIndexFactory.createIndex(config);\n+  }\n+\n+  @Override\n+  public boolean commit(String instantTime, JavaRDD<WriteStatus> writeStatuses, Option<Map<String, String>> extraMetadata) {\n+    List<HoodieWriteStat> stats = writeStatuses.map(WriteStatus::getStat).collect();\n+    return commitStats(instantTime, stats, extraMetadata);\n+  }\n+\n+  @Override\n+  protected HoodieTable<T, JavaRDD<HoodieRecord<T>>, JavaRDD<HoodieKey>, JavaRDD<WriteStatus>, JavaPairRDD<HoodieKey, Option<Pair<String, String>>>> createTable(HoodieWriteConfig config, Configuration hadoopConf) {\n+    return HoodieSparkTable.create(config, context);\n+  }\n+\n+  @Override\n+  public JavaRDD<HoodieRecord<T>> filterExists(JavaRDD<HoodieRecord<T>> hoodieRecords) {\n+    // Create a Hoodie table which encapsulated the commits and files visible\n+    HoodieTable table = HoodieSparkTable.create(config, context);\n+    Timer.Context indexTimer = metrics.getIndexCtx();\n+    JavaRDD<HoodieRecord<T>> recordsWithLocation = getIndex().tagLocation(hoodieRecords, context, table);\n+    metrics.updateIndexMetrics(LOOKUP_STR, metrics.getDurationInMs(indexTimer == null ? 0L : indexTimer.stop()));\n+    return recordsWithLocation.filter(v1 -> !v1.isCurrentLocationKnown());\n+  }\n+\n+  /**\n+   * Main API to run bootstrap to hudi.\n+   */\n+  @Override\n+  public void bootstrap(Option<Map<String, String>> extraMetadata) {\n+    if (rollbackPending) {\n+      rollBackInflightBootstrap();\n+    }\n+    HoodieSparkTable table = (HoodieSparkTable) getTableAndInitCtx(WriteOperationType.UPSERT, HoodieTimeline.METADATA_BOOTSTRAP_INSTANT_TS);\n+    table.bootstrap(context, extraMetadata);\n+  }\n+\n+  @Override\n+  public JavaRDD<WriteStatus> upsert(JavaRDD<HoodieRecord<T>> records, String instantTime) {\n+    HoodieSparkTable table = (HoodieSparkTable) getTableAndInitCtx(WriteOperationType.UPSERT, instantTime);\n+    table.validateUpsertSchema();\n+    setOperationType(WriteOperationType.UPSERT);\n+    startAsyncCleaningIfEnabled(this, instantTime);\n+    HoodieWriteMetadata<JavaRDD<WriteStatus>> result = table.upsert(context, instantTime, records);\n+    if (result.getIndexLookupDuration().isPresent()) {\n+      metrics.updateIndexMetrics(LOOKUP_STR, result.getIndexLookupDuration().get().toMillis());\n+    }\n+    return postWrite(result, instantTime, table);\n+  }\n+\n+  @Override\n+  public JavaRDD<WriteStatus> upsertPreppedRecords(JavaRDD<HoodieRecord<T>> preppedRecords, String instantTime) {\n+    HoodieSparkTable table = (HoodieSparkTable) getTableAndInitCtx(WriteOperationType.UPSERT_PREPPED, instantTime);\n+    table.validateUpsertSchema();\n+    setOperationType(WriteOperationType.UPSERT_PREPPED);\n+    startAsyncCleaningIfEnabled(this, instantTime);", "originalCommit": "7aedc0bdc1565d47b044487aab04b659167bd086", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDYwMTYzMQ==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484601631", "bodyText": "I think we can eliminate the need for breaking this up into spark vs non-spark, by just passing in the host. This class does not make much sense being broken up.", "author": "vinothchandar", "createdAt": "2020-09-08T01:18:10Z", "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/client/embedded/SparkEmbeddedTimelineService.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.client.embedded;\n+\n+import org.apache.hudi.client.embebbed.BaseEmbeddedTimelineService;\n+import org.apache.hudi.common.HoodieEngineContext;\n+import org.apache.hudi.common.HoodieSparkEngineContext;\n+import org.apache.hudi.common.table.view.FileSystemViewStorageConfig;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+import org.apache.spark.SparkConf;\n+\n+/**\n+ * Spark implementation of Timeline Service.\n+ */\n+public class SparkEmbeddedTimelineService extends BaseEmbeddedTimelineService {\n+\n+  private static final Logger LOG = LogManager.getLogger(SparkEmbeddedTimelineService.class);\n+\n+  public SparkEmbeddedTimelineService(HoodieEngineContext context, FileSystemViewStorageConfig config) {\n+    super(context, config);\n+  }\n+\n+  @Override\n+  public void setHostAddrFromContext(HoodieEngineContext context) {\n+    SparkConf sparkConf = HoodieSparkEngineContext.getSparkContext(context).getConf();\n+    String hostAddr = sparkConf.get(\"spark.driver.host\", null);", "originalCommit": "7aedc0bdc1565d47b044487aab04b659167bd086", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAxNjI5NA==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r485016294", "bodyText": "I think we can eliminate the need for breaking this up into spark vs non-spark, by just passing in the host. This class does not make much sense being broken up.\n\ndone, add hoodie.embed.timeline.server.host to HoodieWriteConfig,  it can be obtained via method getEmbeddedServerHost()\nThis is not the same as before(acquired from sparkConf). users who enabled the embedded timeline service should config this hostaddr additionally.", "author": "wangxianghu", "createdAt": "2020-09-08T15:37:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDYwMTYzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDYwMjU2Mg==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484602562", "bodyText": "note to self: make sure these methods are now in the base class", "author": "vinothchandar", "createdAt": "2020-09-08T01:23:12Z", "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/index/hbase/HoodieSparkHBaseIndex.java", "diffHunk": "@@ -18,169 +18,60 @@\n \n package org.apache.hudi.index.hbase;\n \n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.client.BufferedMutator;\n+import org.apache.hadoop.hbase.client.Delete;\n+import org.apache.hadoop.hbase.client.Get;\n+import org.apache.hadoop.hbase.client.HTable;\n+import org.apache.hadoop.hbase.client.Mutation;\n+import org.apache.hadoop.hbase.client.Put;\n+import org.apache.hadoop.hbase.client.Result;\n+import org.apache.hadoop.hbase.util.Bytes;\n import org.apache.hudi.client.WriteStatus;\n import org.apache.hudi.client.utils.SparkConfigUtils;\n+import org.apache.hudi.common.HoodieEngineContext;\n+import org.apache.hudi.common.HoodieSparkEngineContext;\n import org.apache.hudi.common.model.HoodieKey;\n import org.apache.hudi.common.model.HoodieRecord;\n import org.apache.hudi.common.model.HoodieRecordLocation;\n import org.apache.hudi.common.model.HoodieRecordPayload;\n import org.apache.hudi.common.table.HoodieTableMetaClient;\n-import org.apache.hudi.common.table.timeline.HoodieTimeline;\n import org.apache.hudi.common.util.Option;\n-import org.apache.hudi.common.util.ReflectionUtils;\n import org.apache.hudi.common.util.collection.Pair;\n-import org.apache.hudi.config.HoodieHBaseIndexConfig;\n import org.apache.hudi.config.HoodieWriteConfig;\n-import org.apache.hudi.exception.HoodieDependentSystemUnavailableException;\n import org.apache.hudi.exception.HoodieIndexException;\n-import org.apache.hudi.index.HoodieIndex;\n import org.apache.hudi.table.HoodieTable;\n-\n-import org.apache.hadoop.conf.Configuration;\n-import org.apache.hadoop.hbase.HBaseConfiguration;\n-import org.apache.hadoop.hbase.HRegionLocation;\n-import org.apache.hadoop.hbase.TableName;\n-import org.apache.hadoop.hbase.client.BufferedMutator;\n-import org.apache.hadoop.hbase.client.Connection;\n-import org.apache.hadoop.hbase.client.ConnectionFactory;\n-import org.apache.hadoop.hbase.client.Delete;\n-import org.apache.hadoop.hbase.client.Get;\n-import org.apache.hadoop.hbase.client.HTable;\n-import org.apache.hadoop.hbase.client.Mutation;\n-import org.apache.hadoop.hbase.client.Put;\n-import org.apache.hadoop.hbase.client.RegionLocator;\n-import org.apache.hadoop.hbase.client.Result;\n-import org.apache.hadoop.hbase.util.Bytes;\n import org.apache.log4j.LogManager;\n import org.apache.log4j.Logger;\n import org.apache.spark.SparkConf;\n import org.apache.spark.api.java.JavaPairRDD;\n import org.apache.spark.api.java.JavaRDD;\n import org.apache.spark.api.java.JavaSparkContext;\n import org.apache.spark.api.java.function.Function2;\n+import scala.Tuple2;\n \n import java.io.IOException;\n-import java.io.Serializable;\n import java.util.ArrayList;\n import java.util.Iterator;\n import java.util.LinkedList;\n import java.util.List;\n \n-import scala.Tuple2;\n+public class HoodieSparkHBaseIndex<T extends HoodieRecordPayload> extends BaseHoodieHBaseIndex<T, JavaRDD<HoodieRecord<T>>, JavaRDD<HoodieKey>, JavaRDD<WriteStatus>, JavaPairRDD<HoodieKey, Option<Pair<String, String>>>> {\n \n-/**\n- * Hoodie Index implementation backed by HBase.\n- */\n-public class HBaseIndex<T extends HoodieRecordPayload> extends HoodieIndex<T> {\n+  private static final Logger LOG = LogManager.getLogger(HoodieSparkHBaseIndex.class);\n \n   public static final String DEFAULT_SPARK_EXECUTOR_INSTANCES_CONFIG_NAME = \"spark.executor.instances\";\n   public static final String DEFAULT_SPARK_DYNAMIC_ALLOCATION_ENABLED_CONFIG_NAME = \"spark.dynamicAllocation.enabled\";\n   public static final String DEFAULT_SPARK_DYNAMIC_ALLOCATION_MAX_EXECUTORS_CONFIG_NAME =\n       \"spark.dynamicAllocation.maxExecutors\";\n \n-  private static final byte[] SYSTEM_COLUMN_FAMILY = Bytes.toBytes(\"_s\");\n-  private static final byte[] COMMIT_TS_COLUMN = Bytes.toBytes(\"commit_ts\");\n-  private static final byte[] FILE_NAME_COLUMN = Bytes.toBytes(\"file_name\");\n-  private static final byte[] PARTITION_PATH_COLUMN = Bytes.toBytes(\"partition_path\");\n-  private static final int SLEEP_TIME_MILLISECONDS = 100;\n-\n-  private static final Logger LOG = LogManager.getLogger(HBaseIndex.class);\n-  private static Connection hbaseConnection = null;\n-  private HBaseIndexQPSResourceAllocator hBaseIndexQPSResourceAllocator = null;\n-  private float qpsFraction;\n-  private int maxQpsPerRegionServer;\n-  /**\n-   * multiPutBatchSize will be computed and re-set in updateLocation if\n-   * {@link HoodieHBaseIndexConfig#HBASE_PUT_BATCH_SIZE_AUTO_COMPUTE_PROP} is set to true.\n-   */\n-  private Integer multiPutBatchSize;\n-  private Integer numRegionServersForTable;\n-  private final String tableName;\n-  private HBasePutBatchSizeCalculator putBatchSizeCalculator;\n-\n-  public HBaseIndex(HoodieWriteConfig config) {\n+  public HoodieSparkHBaseIndex(HoodieWriteConfig config) {\n     super(config);\n-    this.tableName = config.getHbaseTableName();\n-    addShutDownHook();\n-    init(config);\n-  }\n-\n-  private void init(HoodieWriteConfig config) {\n-    this.multiPutBatchSize = config.getHbaseIndexGetBatchSize();\n-    this.qpsFraction = config.getHbaseIndexQPSFraction();\n-    this.maxQpsPerRegionServer = config.getHbaseIndexMaxQPSPerRegionServer();\n-    this.putBatchSizeCalculator = new HBasePutBatchSizeCalculator();\n-    this.hBaseIndexQPSResourceAllocator = createQPSResourceAllocator(this.config);\n-  }\n-\n-  public HBaseIndexQPSResourceAllocator createQPSResourceAllocator(HoodieWriteConfig config) {", "originalCommit": "7aedc0bdc1565d47b044487aab04b659167bd086", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDYwMzIzOA==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484603238", "bodyText": "note to self: make sure these methods are in the base class now", "author": "vinothchandar", "createdAt": "2020-09-08T01:26:16Z", "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/index/simple/HoodieSparkGlobalSimpleIndex.java", "diffHunk": "@@ -71,43 +75,14 @@ public HoodieGlobalSimpleIndex(HoodieWriteConfig config) {\n    * @return {@link JavaRDD} of records with record locations set\n    */\n   protected JavaRDD<HoodieRecord<T>> tagLocationInternal(JavaRDD<HoodieRecord<T>> inputRecordRDD, JavaSparkContext jsc,\n-                                                         HoodieTable<T> hoodieTable) {\n+                                                         HoodieTable hoodieTable) {\n \n     JavaPairRDD<String, HoodieRecord<T>> keyedInputRecordRDD = inputRecordRDD.mapToPair(entry -> new Tuple2<>(entry.getRecordKey(), entry));\n     JavaPairRDD<HoodieKey, HoodieRecordLocation> allRecordLocationsInTable = fetchAllRecordLocations(jsc, hoodieTable,\n         config.getGlobalSimpleIndexParallelism());\n     return getTaggedRecords(keyedInputRecordRDD, allRecordLocationsInTable);\n   }\n \n-  /**\n-   * Fetch record locations for passed in {@link HoodieKey}s.\n-   *\n-   * @param jsc         instance of {@link JavaSparkContext} to use\n-   * @param hoodieTable instance of {@link HoodieTable} of interest\n-   * @param parallelism parallelism to use\n-   * @return {@link JavaPairRDD} of {@link HoodieKey} and {@link HoodieRecordLocation}\n-   */\n-  protected JavaPairRDD<HoodieKey, HoodieRecordLocation> fetchAllRecordLocations(JavaSparkContext jsc,\n-                                                                                 HoodieTable hoodieTable,\n-                                                                                 int parallelism) {\n-    List<Pair<String, HoodieBaseFile>> latestBaseFiles = getAllBaseFilesInTable(jsc, hoodieTable);\n-    return fetchRecordLocations(jsc, hoodieTable, parallelism, latestBaseFiles);\n-  }\n-\n-  /**\n-   * Load all files for all partitions as <Partition, filename> pair RDD.\n-   */\n-  protected List<Pair<String, HoodieBaseFile>> getAllBaseFilesInTable(final JavaSparkContext jsc, final HoodieTable hoodieTable) {", "originalCommit": "7aedc0bdc1565d47b044487aab04b659167bd086", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDYwMzgwMA==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484603800", "bodyText": "at the MergeHandle level, we need not introduce any notion of RDDs. the io package should be free of spark already. All we need to do is to pass in the taskContextSupplier correctly? This is a large outstanding issue we need to resolve", "author": "vinothchandar", "createdAt": "2020-09-08T01:29:10Z", "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/io/HoodieSparkMergeHandle.java", "diffHunk": "@@ -54,9 +60,9 @@\n import java.util.Set;\n \n @SuppressWarnings(\"Duplicates\")\n-public class HoodieMergeHandle<T extends HoodieRecordPayload> extends HoodieWriteHandle<T> {\n+public class HoodieSparkMergeHandle<T extends HoodieRecordPayload> extends HoodieWriteHandle<T, JavaRDD<HoodieRecord<T>>, JavaRDD<HoodieKey>, JavaRDD<WriteStatus>, JavaPairRDD<HoodieKey, Option<Pair<String, String>>>> {", "originalCommit": "7aedc0bdc1565d47b044487aab04b659167bd086", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAyNjU4MQ==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r485026581", "bodyText": "at the MergeHandle level, we need not introduce any notion of RDDs. the io package should be free of spark already. All we need to do is to pass in the taskContextSupplier correctly? This is a large outstanding issue we need to resolve\n\nActually not yet. #1756 added support for rollbacks using marker files, and MarkerFiles is spark related.", "author": "wangxianghu", "createdAt": "2020-09-08T15:52:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDYwMzgwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDYwNDAxMQ==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484604011", "bodyText": "please refrain from moving methods around within the file. it makes life hard during review :(", "author": "vinothchandar", "createdAt": "2020-09-08T01:30:08Z", "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/io/HoodieSparkMergeHandle.java", "diffHunk": "@@ -71,34 +77,25 @@\n   protected boolean useWriterSchema;\n   private HoodieBaseFile baseFileToMerge;\n \n-  public HoodieMergeHandle(HoodieWriteConfig config, String instantTime, HoodieTable<T> hoodieTable,\n-       Iterator<HoodieRecord<T>> recordItr, String partitionPath, String fileId, SparkTaskContextSupplier sparkTaskContextSupplier) {\n-    super(config, instantTime, partitionPath, fileId, hoodieTable, sparkTaskContextSupplier);\n+  public HoodieSparkMergeHandle(HoodieWriteConfig config, String instantTime, HoodieTable hoodieTable,\n+                                Iterator<HoodieRecord<T>> recordItr, String partitionPath, String fileId, TaskContextSupplier taskContextSupplier) {\n+    super(config, instantTime, partitionPath, fileId, hoodieTable, taskContextSupplier);\n     init(fileId, recordItr);\n     init(fileId, partitionPath, hoodieTable.getBaseFileOnlyView().getLatestBaseFile(partitionPath, fileId).get());\n   }\n \n   /**\n    * Called by compactor code path.\n    */\n-  public HoodieMergeHandle(HoodieWriteConfig config, String instantTime, HoodieTable<T> hoodieTable,\n-      Map<String, HoodieRecord<T>> keyToNewRecords, String partitionPath, String fileId,\n-      HoodieBaseFile dataFileToBeMerged, SparkTaskContextSupplier sparkTaskContextSupplier) {\n-    super(config, instantTime, partitionPath, fileId, hoodieTable, sparkTaskContextSupplier);\n+  public HoodieSparkMergeHandle(HoodieWriteConfig config, String instantTime, HoodieTable hoodieTable,\n+                                Map<String, HoodieRecord<T>> keyToNewRecords, String partitionPath, String fileId,\n+                                HoodieBaseFile dataFileToBeMerged, TaskContextSupplier taskContextSupplier) {\n+    super(config, instantTime, partitionPath, fileId, hoodieTable, taskContextSupplier);\n     this.keyToNewRecords = keyToNewRecords;\n     this.useWriterSchema = true;\n     init(fileId, this.partitionPath, dataFileToBeMerged);\n   }\n \n-  @Override", "originalCommit": "7aedc0bdc1565d47b044487aab04b659167bd086", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAyNzU4Mw==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r485027583", "bodyText": "please refrain from moving methods around within the file. it makes life hard during review :(\n\nsorry for the inconvenient, let me see what I can do to avoid this :)", "author": "wangxianghu", "createdAt": "2020-09-08T15:54:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDYwNDAxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDYwNDI5Mg==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484604292", "bodyText": "same here. we need to make sure these factory methods don't have spark vs non-spark versions", "author": "vinothchandar", "createdAt": "2020-09-08T01:31:14Z", "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/io/SparkAppendHandleFactory.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.io;\n+\n+import org.apache.hudi.client.SparkTaskContextSupplier;\n+import org.apache.hudi.client.TaskContextSupplier;\n+import org.apache.hudi.client.WriteStatus;\n+import org.apache.hudi.common.model.HoodieKey;\n+import org.apache.hudi.common.model.HoodieRecord;\n+import org.apache.hudi.common.model.HoodieRecordPayload;\n+import org.apache.hudi.common.util.Option;\n+import org.apache.hudi.common.util.collection.Pair;\n+import org.apache.hudi.config.HoodieWriteConfig;\n+\n+import org.apache.hudi.table.HoodieTable;\n+import org.apache.spark.api.java.JavaPairRDD;\n+import org.apache.spark.api.java.JavaRDD;\n+\n+/**\n+ * Factory to create {@link HoodieSparkAppendHandle}.\n+ */\n+public class SparkAppendHandleFactory<T extends HoodieRecordPayload> extends WriteHandleFactory<T, JavaRDD<HoodieRecord<T>>, JavaRDD<HoodieKey>, JavaRDD<WriteStatus>, JavaPairRDD<HoodieKey, Option<Pair<String, String>>>> {", "originalCommit": "7aedc0bdc1565d47b044487aab04b659167bd086", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDAwMDY4Nw==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r494000687", "bodyText": "same here. we need to make sure these factory methods don't have spark vs non-spark versions\n\ndone", "author": "wangxianghu", "createdAt": "2020-09-24T02:22:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDYwNDI5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDYwNDM2OQ==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484604369", "bodyText": "same. is there a way to not make these spark specific", "author": "vinothchandar", "createdAt": "2020-09-08T01:31:41Z", "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/io/SparkCreateHandleFactory.java", "diffHunk": "@@ -0,0 +1,46 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.io;\n+\n+import org.apache.hudi.client.TaskContextSupplier;\n+import org.apache.hudi.client.WriteStatus;\n+import org.apache.hudi.common.model.HoodieKey;\n+import org.apache.hudi.common.model.HoodieRecord;\n+import org.apache.hudi.common.model.HoodieRecordPayload;\n+import org.apache.hudi.common.util.Option;\n+import org.apache.hudi.common.util.collection.Pair;\n+import org.apache.hudi.config.HoodieWriteConfig;\n+import org.apache.hudi.table.HoodieTable;\n+import org.apache.spark.api.java.JavaPairRDD;\n+import org.apache.spark.api.java.JavaRDD;\n+\n+public class SparkCreateHandleFactory<T extends HoodieRecordPayload> extends WriteHandleFactory<T, JavaRDD<HoodieRecord<T>>, JavaRDD<HoodieKey>, JavaRDD<WriteStatus>, JavaPairRDD<HoodieKey, Option<Pair<String, String>>>> {\n+\n+  @Override\n+  public HoodieSparkCreateHandle create(final HoodieWriteConfig hoodieConfig,", "originalCommit": "7aedc0bdc1565d47b044487aab04b659167bd086", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDkzMzc1NQ==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484933755", "bodyText": "same. is there a way to not make these spark specific\n\nI'll give a try", "author": "wangxianghu", "createdAt": "2020-09-08T13:47:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDYwNDM2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDYwNTI5MA==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484605290", "bodyText": "we can actually try and keep this generic and just pass in what we need from taggedRecords to constructor instead of the entire thing", "author": "vinothchandar", "createdAt": "2020-09-08T01:36:26Z", "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/table/SparkWorkloadProfile.java", "diffHunk": "@@ -22,49 +22,22 @@\n import org.apache.hudi.common.model.HoodieRecordLocation;\n import org.apache.hudi.common.model.HoodieRecordPayload;\n import org.apache.hudi.common.util.Option;\n-\n import org.apache.spark.api.java.JavaRDD;\n+import scala.Tuple2;\n \n-import java.io.Serializable;\n-import java.util.HashMap;\n import java.util.Map;\n-import java.util.Set;\n-\n-import scala.Tuple2;\n \n /**\n- * Information about incoming records for upsert/insert obtained either via sampling or introspecting the data fully.\n- * <p>\n- * TODO(vc): Think about obtaining this directly from index.tagLocation\n+ * Spark implementation of {@link BaseWorkloadProfile}.\n+ * @param <T>\n  */\n-public class WorkloadProfile<T extends HoodieRecordPayload> implements Serializable {\n-\n-  /**\n-   * Input workload.\n-   */\n-  private final JavaRDD<HoodieRecord<T>> taggedRecords;\n-\n-  /**\n-   * Computed workload profile.\n-   */\n-  private final HashMap<String, WorkloadStat> partitionPathStatMap;\n-\n-  /**\n-   * Global workloadStat.\n-   */\n-  private final WorkloadStat globalStat;\n-\n-  public WorkloadProfile(JavaRDD<HoodieRecord<T>> taggedRecords) {\n-    this.taggedRecords = taggedRecords;\n-    this.partitionPathStatMap = new HashMap<>();\n-    this.globalStat = new WorkloadStat();\n-    buildProfile();\n+public class SparkWorkloadProfile<T extends HoodieRecordPayload> extends BaseWorkloadProfile<JavaRDD<HoodieRecord<T>>> {", "originalCommit": "7aedc0bdc1565d47b044487aab04b659167bd086", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA1ODI2MQ==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r485058261", "bodyText": "we can actually try and keep this generic and just pass in what we need from taggedRecords to constructor instead of the entire thing\n\ndone", "author": "wangxianghu", "createdAt": "2020-09-08T16:43:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDYwNTI5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDYwNTUxNw==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484605517", "bodyText": "hmmm? why do we return null here", "author": "vinothchandar", "createdAt": "2020-09-08T01:37:30Z", "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/table/action/bootstrap/SparkBootstrapCommitActionExecutor.java", "diffHunk": "@@ -77,34 +81,44 @@\n import org.apache.parquet.hadoop.ParquetReader;\n import org.apache.parquet.hadoop.metadata.ParquetMetadata;\n import org.apache.parquet.schema.MessageType;\n-import org.apache.spark.Partitioner;\n+import org.apache.spark.api.java.JavaPairRDD;\n import org.apache.spark.api.java.JavaRDD;\n import org.apache.spark.api.java.JavaSparkContext;\n \n import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.time.Duration;\n+import java.time.Instant;\n import java.util.Collection;\n import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n import java.util.stream.Collectors;\n \n-public class BootstrapCommitActionExecutor<T extends HoodieRecordPayload<T>>\n-    extends BaseCommitActionExecutor<T, HoodieBootstrapWriteMetadata> {\n+public class SparkBootstrapCommitActionExecutor<T extends HoodieRecordPayload>\n+    extends BaseCommitActionExecutor<T, JavaRDD<HoodieRecord<T>>, JavaRDD<HoodieKey>, JavaRDD<WriteStatus>, JavaPairRDD<HoodieKey, Option<Pair<String, String>>>, HoodieBootstrapWriteMetadata> {\n \n-  private static final Logger LOG = LogManager.getLogger(BootstrapCommitActionExecutor.class);\n+  private static final Logger LOG = LogManager.getLogger(SparkBootstrapCommitActionExecutor.class);\n   protected String bootstrapSchema = null;\n   private transient FileSystem bootstrapSourceFileSystem;\n \n-  public BootstrapCommitActionExecutor(JavaSparkContext jsc, HoodieWriteConfig config, HoodieTable<?> table,\n-      Option<Map<String, String>> extraMetadata) {\n-    super(jsc, new HoodieWriteConfig.Builder().withProps(config.getProps())\n-        .withAutoCommit(true).withWriteStatusClass(BootstrapWriteStatus.class)\n-        .withBulkInsertParallelism(config.getBootstrapParallelism())\n-        .build(), table, HoodieTimeline.METADATA_BOOTSTRAP_INSTANT_TS, WriteOperationType.BOOTSTRAP,\n+  public SparkBootstrapCommitActionExecutor(HoodieSparkEngineContext context,\n+                                            HoodieWriteConfig config,\n+                                            HoodieTable<T, JavaRDD<HoodieRecord<T>>, JavaRDD<HoodieKey>, JavaRDD<WriteStatus>, JavaPairRDD<HoodieKey, Option<Pair<String, String>>>> table,\n+                                            Option<Map<String, String>> extraMetadata) {\n+    super(context, new HoodieWriteConfig.Builder().withProps(config.getProps())\n+            .withAutoCommit(true).withWriteStatusClass(BootstrapWriteStatus.class)\n+            .withBulkInsertParallelism(config.getBootstrapParallelism())\n+            .build(), table, HoodieTimeline.METADATA_BOOTSTRAP_INSTANT_TS, WriteOperationType.BOOTSTRAP,\n         extraMetadata);\n     bootstrapSourceFileSystem = FSUtils.getFs(config.getBootstrapSourceBasePath(), hadoopConf);\n   }\n \n+  @Override\n+  public HoodieWriteMetadata<JavaRDD<WriteStatus>> execute(JavaRDD<HoodieRecord<T>> inputRecordsRDD) {", "originalCommit": "7aedc0bdc1565d47b044487aab04b659167bd086", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk0MDIwMw==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r484940203", "bodyText": "hmmm? why do we return null here\n\nBootstrapCommitActionExecutor dose not need this method actually, inherited from its parent class.", "author": "wangxianghu", "createdAt": "2020-09-08T13:55:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDYwNTUxNw=="}], "type": "inlineReview"}, {"oid": "b002589fedc67299449c3356a4abd1cc6d363dae", "url": "https://github.com/apache/hudi/commit/b002589fedc67299449c3356a4abd1cc6d363dae", "message": "add SparkHoodieIndex", "committedDate": "2020-09-08T10:25:49Z", "type": "forcePushed"}, {"oid": "82f0cd83dfbed28aa693279943f89913025c6ccf", "url": "https://github.com/apache/hudi/commit/82f0cd83dfbed28aa693279943f89913025c6ccf", "message": "add SparkHoodieIndex", "committedDate": "2020-09-08T11:11:27Z", "type": "forcePushed"}, {"oid": "84656038e5ebafbb1585dc42cea14b76ef58a489", "url": "https://github.com/apache/hudi/commit/84656038e5ebafbb1585dc42cea14b76ef58a489", "message": "add SparkHoodieIndex", "committedDate": "2020-09-08T13:50:57Z", "type": "forcePushed"}, {"oid": "f39dfa997704f0dbd02fba8745699a92af668049", "url": "https://github.com/apache/hudi/commit/f39dfa997704f0dbd02fba8745699a92af668049", "message": "edit travis.yml", "committedDate": "2020-09-08T14:32:33Z", "type": "forcePushed"}, {"oid": "d59df457569584145896f08855cf5e53e765e9d1", "url": "https://github.com/apache/hudi/commit/d59df457569584145896f08855cf5e53e765e9d1", "message": "edit travis.yml", "committedDate": "2020-09-08T14:40:46Z", "type": "forcePushed"}, {"oid": "58746a68aaa2ffa8dd85a9a6cbc68db6af02d457", "url": "https://github.com/apache/hudi/commit/58746a68aaa2ffa8dd85a9a6cbc68db6af02d457", "message": "add SparkHoodieIndex", "committedDate": "2020-09-08T14:51:47Z", "type": "forcePushed"}, {"oid": "01b4f4a433c49a83df2d6370effaa1356df1343d", "url": "https://github.com/apache/hudi/commit/01b4f4a433c49a83df2d6370effaa1356df1343d", "message": "add SparkHoodieIndex", "committedDate": "2020-09-08T15:33:16Z", "type": "forcePushed"}, {"oid": "54d352ac06b57da3116aefa00aec80cdd45ada5a", "url": "https://github.com/apache/hudi/commit/54d352ac06b57da3116aefa00aec80cdd45ada5a", "message": "trigger ci", "committedDate": "2020-09-09T14:57:00Z", "type": "forcePushed"}, {"oid": "e94a33d304341fc61b9ddaf82b3e0868f223b92c", "url": "https://github.com/apache/hudi/commit/e94a33d304341fc61b9ddaf82b3e0868f223b92c", "message": "trigger ci", "committedDate": "2020-09-10T13:47:42Z", "type": "forcePushed"}, {"oid": "23b9e3649bb337c5815b3d1234354667e0a47859", "url": "https://github.com/apache/hudi/commit/23b9e3649bb337c5815b3d1234354667e0a47859", "message": "trigger ci", "committedDate": "2020-09-10T13:53:02Z", "type": "forcePushed"}, {"oid": "dc5e08a9eb3501c5a0bd86c12a5978d4070ea465", "url": "https://github.com/apache/hudi/commit/dc5e08a9eb3501c5a0bd86c12a5978d4070ea465", "message": "[HUDI-1089] Refactor hudi-client to support multi-engine", "committedDate": "2020-09-11T08:04:15Z", "type": "forcePushed"}, {"oid": "23b9e3649bb337c5815b3d1234354667e0a47859", "url": "https://github.com/apache/hudi/commit/23b9e3649bb337c5815b3d1234354667e0a47859", "message": "trigger ci", "committedDate": "2020-09-10T13:53:02Z", "type": "forcePushed"}, {"oid": "bb34e0d3c3d8be74472276f0899cb369600380bb", "url": "https://github.com/apache/hudi/commit/bb34e0d3c3d8be74472276f0899cb369600380bb", "message": "[HUDI-1089] Refactor hudi-client to support multi-engine", "committedDate": "2020-09-11T08:17:16Z", "type": "forcePushed"}, {"oid": "23b9e3649bb337c5815b3d1234354667e0a47859", "url": "https://github.com/apache/hudi/commit/23b9e3649bb337c5815b3d1234354667e0a47859", "message": "trigger ci", "committedDate": "2020-09-10T13:53:02Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI2MTgzNw==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r492261837", "bodyText": "I think we should leave this abstract and let the engines implement this?  even for Java. Its better to have a HoodieJavaEngineContext. From what I can see, this is not overridden in HoodieSparkEngineContext and thus we lose the parallel execution that we currently have with Spark with this change.", "author": "vinothchandar", "createdAt": "2020-09-21T18:26:34Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/common/HoodieEngineContext.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.common;\n+\n+import org.apache.hudi.client.TaskContextSupplier;\n+import org.apache.hudi.common.config.SerializableConfiguration;\n+\n+import java.util.List;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ * Base class contains the context information needed by the engine at runtime. It will be extended by different\n+ * engine implementation if needed.\n+ */\n+public class HoodieEngineContext {\n+  /**\n+   * A wrapped hadoop configuration which can be serialized.\n+   */\n+  private SerializableConfiguration hadoopConf;\n+\n+  private TaskContextSupplier taskContextSupplier;\n+\n+  public HoodieEngineContext(SerializableConfiguration hadoopConf, TaskContextSupplier taskContextSupplier) {\n+    this.hadoopConf = hadoopConf;\n+    this.taskContextSupplier = taskContextSupplier;\n+  }\n+\n+  public SerializableConfiguration getHadoopConf() {\n+    return hadoopConf;\n+  }\n+\n+  public TaskContextSupplier getTaskContextSupplier() {\n+    return taskContextSupplier;\n+  }\n+\n+  public <I, O> List<O> map(List<I> data, Function<I, O> func) {", "originalCommit": "2d1f2124db067f1379fd342b94b4fe1775ace663", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI2NDM1Mg==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r492264352", "bodyText": "Also these APIs should take in a parallelism parameter, no?", "author": "vinothchandar", "createdAt": "2020-09-21T18:31:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI2MTgzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQzNDQwNQ==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r492434405", "bodyText": "I think we should leave this abstract and let the engines implement this? even for Java. Its better to have a HoodieJavaEngineContext. From what I can see, this is not overridden in HoodieSparkEngineContext and thus we lose the parallel execution that we currently have with Spark with this change.\n\nas we discussed before, parallelDo model need a function as input parameter, Unfortunately, different engines need different type function, its hard to align them in an abstract parallelDo method. so we agreed to use  java.util.function.Function as the unified input function. in this way, there is no need to distinguish spark and flink, no need to make it abstract and the parallelism is not needed too. its just java, can be implemented directly.", "author": "wangxianghu", "createdAt": "2020-09-22T01:41:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI2MTgzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ0OTU0Mw==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r492449543", "bodyText": "@wangxianghu functionality wise, you are correct. it can be implemented just using Java. but, we do parallelization of different pieces of code e.g deletion of files in parallel using spark for a reason. It significantly speeds these up, for large tables.\nAll I am saying is to implement the HoodieSparkEngineContext#map like below\n public <I, O> List<O> map(List<I> data, Function<I, O> func, int parallelism) {\n    return javaSparkContext.parallelize(data, parallelism).map(func).collect();\n }\n\nsimilarly for the other two methods. I don't see any issues with this. do you?", "author": "vinothchandar", "createdAt": "2020-09-22T02:57:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI2MTgzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ1MzI5OA==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r492453298", "bodyText": "@wangxianghu functionality wise, you are correct. it can be implemented just using Java. but, we do parallelization of different pieces of code e.g deletion of files in parallel using spark for a reason. It significantly speeds these up, for large tables.\nAll I am saying is to implement the HoodieSparkEngineContext#map like below\n public <I, O> List<O> map(List<I> data, Function<I, O> func, int parallelism) {\n    return javaSparkContext.parallelize(data, parallelism).map(func).collect();\n }\n\nsimilarly for the other two methods. I don't see any issues with this. do you?\n\nI know what you mean.\nwhat I am saying is that the func in HoodieSparkEngineContext#map and HoodieEngineContext#map is not the same type.\nfor HoodieEngineContext#map it is java.util.function.Function,\nfor HoodieSparkEngineContext#map  it is org.apache.spark.api.java.function.Function.\nHoodieSparkEngineContext#map can not override from HoodieEngineContext#map", "author": "wangxianghu", "createdAt": "2020-09-22T03:14:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI2MTgzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ2MDcxOQ==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r492460719", "bodyText": "Is it possible to take a java.util.function.Function and then within HoodieSparkEngineContext#map wrap that into a org.apache.spark.api.java.function.Function ?", "author": "vinothchandar", "createdAt": "2020-09-22T03:52:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI2MTgzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ2ODU0MA==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r492468540", "bodyText": "Is it possible to take a java.util.function.Function and then within HoodieSparkEngineContext#map wrap that into a org.apache.spark.api.java.function.Function ?\n\nlet me try", "author": "wangxianghu", "createdAt": "2020-09-22T04:31:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI2MTgzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ3NDEwOA==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r492474108", "bodyText": "In Spark, there is a functional interface defined like this\npackage org.apache.spark.api.java.function;\n\nimport java.io.Serializable;\n\n/**\n * Base interface for functions whose return types do not create special RDDs. PairFunction and\n * DoubleFunction are handled separately, to allow PairRDDs and DoubleRDDs to be constructed\n * when mapping RDDs of other types.\n */\n@FunctionalInterface\npublic interface Function<T1, R> extends Serializable {\n  R call(T1 v1) throws Exception;\n}", "author": "vinothchandar", "createdAt": "2020-09-22T04:57:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI2MTgzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ3NDQ5NQ==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r492474495", "bodyText": "when the use passes in a regular lambda, into rdd.map(), this is what it gets converted into", "author": "vinothchandar", "createdAt": "2020-09-22T04:59:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI2MTgzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ5MzczOQ==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r492493739", "bodyText": "when the use passes in a regular lambda, into rdd.map(), this is what it gets converted into\n\nThe serializable issue can be solved by introducing a seriableFuncition to replace java.util.function.Function\npublic interface SerializableFunction<I, O> extends Serializable {\n  O call(I v1) throws Exception;\n}\n\nHoodieEngineContext can be\npublic abstract class HoodieEngineContext {\n  public abstract  <I, O> List<O> map(List<I> data, SerializableFunction<I, O> func, int parallelism) ;\n}\n\nHoodieSparkEngineContext can be\npublic class HoodieSparkEngineContext extends HoodieEngineContext {\n  private static JavaSparkContext jsc;\n\n  // tmp\n  static {\n    SparkConf conf = new SparkConf()\n        .setMaster(\"local[4]\")\n        .set(\"spark.driver.host\",\"localhost\")\n        .setAppName(\"HoodieSparkEngineContext\");\n\n    jsc = new JavaSparkContext(conf);\n  }\n  \n  @Override\n  public <I, O> List<O> map(List<I> data, SerializableFunction<I, O> func, int parallelism) {\n    return jsc.parallelize(data, parallelism).map(func::call).collect();\n  }\n}\n\nthis works :)", "author": "wangxianghu", "createdAt": "2020-09-22T06:14:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI2MTgzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg3MjUwNA==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r492872504", "bodyText": "@wangxianghu This is awesome. Hopefully this can reduce the amount of code you need to write for Flink significantly. TestMarkerFiles seems to pass, so guess the serialization etc is working as expected.\nWe can go ahead with doing more files in this approach and remerge the base/child classes back as much as possible. cc @leesf @yanghua  as well in case they have more things to add.\ncc @bvaradar as well as FYI", "author": "vinothchandar", "createdAt": "2020-09-22T16:26:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI2MTgzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzEyMDkyMg==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r493120922", "bodyText": "@wangxianghu This is awesome. Hopefully this can reduce the amount of code you need to write for Flink significantly. TestMarkerFiles seems to pass, so guess the serialization etc is working as expected.\nWe can go ahead with doing more files in this approach and remerge the base/child classes back as much as possible. cc @leesf @yanghua as well in case they have more things to add.\ncc @bvaradar as well as FYI\n\nYes, it also reduce tons of code in the refactoring. I'm working on it ,hope to finish it today or tomorrow", "author": "wangxianghu", "createdAt": "2020-09-23T01:22:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI2MTgzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI2Mjk2NA==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r492262964", "bodyText": "can we implement versiosn of map, flatMap, forEach here which use javaSparkContext.parallelize() ? It would be good to keep this PR free of any changes in terms of whether we are executing the deletes/lists in parallel or in serial.", "author": "vinothchandar", "createdAt": "2020-09-21T18:28:36Z", "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/common/HoodieSparkEngineContext.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.common;\n+\n+import org.apache.hudi.client.SparkTaskContextSupplier;\n+import org.apache.hudi.common.config.SerializableConfiguration;\n+import org.apache.spark.api.java.JavaSparkContext;\n+import org.apache.spark.sql.SQLContext;\n+\n+/**\n+ * A Spark engine implementation of HoodieEngineContext.\n+ */\n+public class HoodieSparkEngineContext extends HoodieEngineContext {", "originalCommit": "2d1f2124db067f1379fd342b94b4fe1775ace663", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk5ODQ0Mg==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r493998442", "bodyText": "can we implement versiosn of map, flatMap, forEach here which use javaSparkContext.parallelize() ? It would be good to keep this PR free of any changes in terms of whether we are executing the deletes/lists in parallel or in serial.\n\ndone", "author": "wangxianghu", "createdAt": "2020-09-24T02:13:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI2Mjk2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI2NDkxOQ==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r492264919", "bodyText": "we are not using parallelism here. This will lead to a perf regression w.r.t master.", "author": "vinothchandar", "createdAt": "2020-09-21T18:32:04Z", "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/table/SparkMarkerFiles.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.table;\n+\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.LocatedFileStatus;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.fs.RemoteIterator;\n+import org.apache.hudi.bifunction.wrapper.ThrowingFunction;\n+import org.apache.hudi.common.HoodieEngineContext;\n+import org.apache.hudi.common.config.SerializableConfiguration;\n+import org.apache.hudi.common.model.IOType;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.exception.HoodieIOException;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.apache.hudi.bifunction.wrapper.BiFunctionWrapper.throwingConsumerWrapper;\n+import static org.apache.hudi.bifunction.wrapper.BiFunctionWrapper.throwingFlatMapWrapper;\n+\n+public class SparkMarkerFiles extends BaseMarkerFiles {\n+\n+  private static final Logger LOG = LogManager.getLogger(SparkMarkerFiles.class);\n+\n+  public SparkMarkerFiles(HoodieTable table, String instantTime) {\n+    super(table, instantTime);\n+  }\n+\n+  public SparkMarkerFiles(FileSystem fs, String basePath, String markerFolderPath, String instantTime) {\n+    super(fs, basePath, markerFolderPath, instantTime);\n+  }\n+\n+  @Override\n+  public boolean deleteMarkerDir(HoodieEngineContext context, int parallelism) {\n+    try {\n+      if (fs.exists(markerDirPath)) {\n+        FileStatus[] fileStatuses = fs.listStatus(markerDirPath);\n+        List<String> markerDirSubPaths = Arrays.stream(fileStatuses)\n+            .map(fileStatus -> fileStatus.getPath().toString())\n+            .collect(Collectors.toList());\n+\n+        if (markerDirSubPaths.size() > 0) {\n+          SerializableConfiguration conf = new SerializableConfiguration(fs.getConf());\n+          context.foreach(markerDirSubPaths, throwingConsumerWrapper(subPathStr -> {\n+            Path subPath = new Path(subPathStr);\n+            FileSystem fileSystem = subPath.getFileSystem(conf.get());\n+            fileSystem.delete(subPath, true);\n+          }));\n+        }\n+\n+        boolean result = fs.delete(markerDirPath, true);\n+        LOG.info(\"Removing marker directory at \" + markerDirPath);\n+        return result;\n+      }\n+    } catch (IOException ioe) {\n+      throw new HoodieIOException(ioe.getMessage(), ioe);\n+    }\n+    return false;\n+  }\n+\n+  @Override\n+  public Set<String> createdAndMergedDataPaths(HoodieEngineContext context, int parallelism) throws IOException {", "originalCommit": "2d1f2124db067f1379fd342b94b4fe1775ace663", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI2NTE3Nw==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r492265177", "bodyText": "Given this file is now free of Spark, we dont have the need of breaking these into base and child classes right.", "author": "vinothchandar", "createdAt": "2020-09-21T18:32:33Z", "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/table/SparkMarkerFiles.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.table;\n+\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.LocatedFileStatus;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.fs.RemoteIterator;\n+import org.apache.hudi.bifunction.wrapper.ThrowingFunction;\n+import org.apache.hudi.common.HoodieEngineContext;\n+import org.apache.hudi.common.config.SerializableConfiguration;\n+import org.apache.hudi.common.model.IOType;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.exception.HoodieIOException;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.apache.hudi.bifunction.wrapper.BiFunctionWrapper.throwingConsumerWrapper;\n+import static org.apache.hudi.bifunction.wrapper.BiFunctionWrapper.throwingFlatMapWrapper;\n+\n+public class SparkMarkerFiles extends BaseMarkerFiles {", "originalCommit": "2d1f2124db067f1379fd342b94b4fe1775ace663", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQzNTUzMQ==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r492435531", "bodyText": "Given this file is now free of Spark, we dont have the need of breaking these into base and child classes right.\n\nYes, this is an example to show you the bi function, if you agree with this implementation, I'll rollback them in one class", "author": "wangxianghu", "createdAt": "2020-09-22T01:47:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI2NTE3Nw=="}], "type": "inlineReview"}, {"oid": "3a9b9a71a07c68dae940e5260ad1aab065652430", "url": "https://github.com/apache/hudi/commit/3a9b9a71a07c68dae940e5260ad1aab065652430", "message": "[HUDI-1089] Refactor hudi-client to support multi-engine", "committedDate": "2020-09-23T12:12:02Z", "type": "forcePushed"}, {"oid": "0609a9bafebb6fc4bb1b45bd26ab09bdfeb94e69", "url": "https://github.com/apache/hudi/commit/0609a9bafebb6fc4bb1b45bd26ab09bdfeb94e69", "message": "[HUDI-1089] Refactor hudi-client to support multi-engine", "committedDate": "2020-09-23T12:19:59Z", "type": "forcePushed"}, {"oid": "df2ffa1c2455538316551e9ecc71567d748ea3be", "url": "https://github.com/apache/hudi/commit/df2ffa1c2455538316551e9ecc71567d748ea3be", "message": "[HUDI-1089] Refactor hudi-client to support multi-engine", "committedDate": "2020-09-23T12:55:13Z", "type": "forcePushed"}, {"oid": "20f3a866ebb92c7db34d4c8d15fbebee4e78016c", "url": "https://github.com/apache/hudi/commit/20f3a866ebb92c7db34d4c8d15fbebee4e78016c", "message": "[HUDI-1089] Refactor hudi-client to support multi-engine", "committedDate": "2020-09-23T13:13:58Z", "type": "forcePushed"}, {"oid": "cab19a136418580dd69fc794787b63b07b372d08", "url": "https://github.com/apache/hudi/commit/cab19a136418580dd69fc794787b63b07b372d08", "message": "[HUDI-1089] Refactor hudi-client to support multi-engine", "committedDate": "2020-09-23T13:55:46Z", "type": "forcePushed"}, {"oid": "e675a4f9fc20fb9fc6aa017d66fab3da372580c5", "url": "https://github.com/apache/hudi/commit/e675a4f9fc20fb9fc6aa017d66fab3da372580c5", "message": "[HUDI-1089] Refactor hudi-client to support multi-engine", "committedDate": "2020-09-24T01:36:37Z", "type": "forcePushed"}, {"oid": "f05a20cf78dcc5c06558c8e8827e62acede4c4bf", "url": "https://github.com/apache/hudi/commit/f05a20cf78dcc5c06558c8e8827e62acede4c4bf", "message": "[HUDI-1089] Refactor hudi-client to support multi-engine", "committedDate": "2020-09-24T01:48:25Z", "type": "forcePushed"}, {"oid": "131aa883ec95f2cef0f9d4493ac4549770f59e8b", "url": "https://github.com/apache/hudi/commit/131aa883ec95f2cef0f9d4493ac4549770f59e8b", "message": "[HUDI-1089] Refactor hudi-client to support multi-engine", "committedDate": "2020-09-24T01:54:53Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk5NjY0Mg==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r493996642", "bodyText": "Here, I used org.apache.hudi.common.util.SizeEstimator#sizeEstimate to replace org.apache.spark.util.SizeEstimator#estimate is it ok?  @vinothchandar", "author": "wangxianghu", "createdAt": "2020-09-24T02:06:04Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/io/HoodieAppendHandle.java", "diffHunk": "@@ -134,7 +138,7 @@ private void init(HoodieRecord record) {\n       writeStatus.setPartitionPath(partitionPath);\n       writeStatus.getStat().setPartitionPath(partitionPath);\n       writeStatus.getStat().setFileId(fileId);\n-      averageRecordSize = SizeEstimator.estimate(record);\n+      averageRecordSize = sizeEstimator.sizeEstimate(record);\n       try {", "originalCommit": "131aa883ec95f2cef0f9d4493ac4549770f59e8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDA3Mzg3NQ==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r494073875", "bodyText": "Should be okay.", "author": "vinothchandar", "createdAt": "2020-09-24T06:44:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk5NjY0Mg=="}], "type": "inlineReview"}, {"oid": "6ebd0e664ee5a159db7b2fd60ccce3978f26c9ee", "url": "https://github.com/apache/hudi/commit/6ebd0e664ee5a159db7b2fd60ccce3978f26c9ee", "message": "[HUDI-1089] Refactor hudi-client to support multi-engine", "committedDate": "2020-09-24T02:09:34Z", "type": "forcePushed"}, {"oid": "4199bcce2b1568383b685b2c188732e2adbc22b5", "url": "https://github.com/apache/hudi/commit/4199bcce2b1568383b685b2c188732e2adbc22b5", "message": "[HUDI-1089] Refactor hudi-client to support multi-engine", "committedDate": "2020-09-24T05:34:54Z", "type": "forcePushed"}, {"oid": "c24a47c9eae815337d7b7ad42695958a3afa9e3c", "url": "https://github.com/apache/hudi/commit/c24a47c9eae815337d7b7ad42695958a3afa9e3c", "message": "[HUDI-1089] Refactor hudi-client to support multi-engine", "committedDate": "2020-09-24T06:20:31Z", "type": "forcePushed"}, {"oid": "9737063a0845f5c0525f054095dab463bcdc423f", "url": "https://github.com/apache/hudi/commit/9737063a0845f5c0525f054095dab463bcdc423f", "message": "Code Review Comments\n\n* Renaming HoodieSparkAsyncCompactService to SparkAsyncCompactService\n* Bug in SparkStreamingAsyncCompactService of not calling the super constructor with daemon mode.\n* Rename methods in HoodieEngineContext to setJobStatus() and setProperty()\n* Rename common packages to under client.common package\n* Bug in HoodieMergeHandle and compactor not getting the right merge memory", "committedDate": "2020-09-28T01:08:28Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY0ODM5Mg==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r494648392", "bodyText": "can we replace more of the code to direclty just use HoodieTable instead. Need to examine cases that need an explicit HoodieSparkTable", "author": "vinothchandar", "createdAt": "2020-09-24T22:37:33Z", "path": "hudi-cli/src/test/java/org/apache/hudi/cli/commands/TestArchivedCommitsCommand.java", "diffHunk": "@@ -92,8 +93,9 @@ public void init() throws IOException {\n     metaClient.getActiveTimeline().reload().getAllCommitsTimeline().filterCompletedInstants();\n \n     // archive\n-    HoodieTimelineArchiveLog archiveLog = new HoodieTimelineArchiveLog(cfg, hadoopConf);\n-    archiveLog.archiveIfRequired(jsc);\n+    HoodieSparkTable table = HoodieSparkTable.create(cfg, context, metaClient);", "originalCommit": "c24a47c9eae815337d7b7ad42695958a3afa9e3c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY1MDcwNQ==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r495650705", "bodyText": "can we replace more of the code to direclty just use HoodieTable instead. Need to examine cases that need an explicit HoodieSparkTable\n\nyes, make sense", "author": "wangxianghu", "createdAt": "2020-09-28T01:43:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY0ODM5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY0ODg1Nw==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r494648857", "bodyText": "just like this, we should try to  use the abstract class as much as we can", "author": "vinothchandar", "createdAt": "2020-09-24T22:38:54Z", "path": "hudi-cli/src/test/java/org/apache/hudi/cli/commands/TestRollbacksCommand.java", "diffHunk": "@@ -88,7 +88,7 @@ public void init() throws IOException {\n     HoodieWriteConfig config = HoodieWriteConfig.newBuilder().withPath(tablePath)\n         .withIndexConfig(HoodieIndexConfig.newBuilder().withIndexType(HoodieIndex.IndexType.INMEMORY).build()).build();\n \n-    try (HoodieWriteClient client = getHoodieWriteClient(config)) {\n+    try (AbstractHoodieWriteClient client = getHoodieWriteClient(config)) {", "originalCommit": "c24a47c9eae815337d7b7ad42695958a3afa9e3c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc0NjE5Ng==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r494746196", "bodyText": "this was actually same. fixing it", "author": "vinothchandar", "createdAt": "2020-09-25T04:52:38Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -716,32 +669,95 @@ private void rollbackPendingCommits() {\n    * @param compactionInstantTime Compaction Instant Time\n    * @return RDD of Write Status\n    */\n-  private JavaRDD<WriteStatus> compact(String compactionInstantTime, boolean shouldComplete) {\n-    HoodieTable<T> table = HoodieTable.create(config, hadoopConf);\n-    HoodieTimeline pendingCompactionTimeline = table.getActiveTimeline().filterPendingCompactionTimeline();\n-    HoodieInstant inflightInstant = HoodieTimeline.getCompactionInflightInstant(compactionInstantTime);\n-    if (pendingCompactionTimeline.containsInstant(inflightInstant)) {\n-      rollbackInflightCompaction(inflightInstant, table);\n-      table.getMetaClient().reloadActiveTimeline();\n-    }\n-    compactionTimer = metrics.getCompactionCtx();\n-    HoodieWriteMetadata compactionMetadata = table.compact(jsc, compactionInstantTime);\n-    JavaRDD<WriteStatus> statuses = compactionMetadata.getWriteStatuses();\n-    if (shouldComplete && compactionMetadata.getCommitMetadata().isPresent()) {\n-      completeCompaction(compactionMetadata.getCommitMetadata().get(), statuses, table, compactionInstantTime);\n-    }\n-    return statuses;\n-  }\n+  protected abstract O compact(String compactionInstantTime, boolean shouldComplete);\n \n   /**\n    * Performs a compaction operation on a table, serially before or after an insert/upsert action.\n    */\n-  private Option<String> inlineCompact(Option<Map<String, String>> extraMetadata) {\n+  protected Option<String> inlineCompact(Option<Map<String, String>> extraMetadata) {\n     Option<String> compactionInstantTimeOpt = scheduleCompaction(extraMetadata);\n     compactionInstantTimeOpt.ifPresent(compactionInstantTime -> {\n       // inline compaction should auto commit as the user is never given control\n       compact(compactionInstantTime, true);\n     });\n     return compactionInstantTimeOpt;\n   }\n+\n+  /**\n+   * Finalize Write operation.\n+   *\n+   * @param table HoodieTable\n+   * @param instantTime Instant Time\n+   * @param stats Hoodie Write Stat\n+   */\n+  protected void finalizeWrite(HoodieTable<T, I, K, O, P> table, String instantTime, List<HoodieWriteStat> stats) {\n+    try {\n+      final Timer.Context finalizeCtx = metrics.getFinalizeCtx();\n+      table.finalizeWrite(context, instantTime, stats);\n+      if (finalizeCtx != null) {\n+        Option<Long> durationInMs = Option.of(metrics.getDurationInMs(finalizeCtx.stop()));\n+        durationInMs.ifPresent(duration -> {\n+          LOG.info(\"Finalize write elapsed time (milliseconds): \" + duration);\n+          metrics.updateFinalizeWriteMetrics(duration, stats.size());\n+        });\n+      }\n+    } catch (HoodieIOException ioe) {\n+      throw new HoodieCommitException(\"Failed to complete commit \" + instantTime + \" due to finalize errors.\", ioe);\n+    }\n+  }\n+\n+  public HoodieMetrics getMetrics() {\n+    return metrics;\n+  }\n+\n+  public HoodieIndex<T, I, K, O, P> getIndex() {\n+    return index;\n+  }\n+\n+  /**\n+   * Get HoodieTable and init {@link Timer.Context}.\n+   *\n+   * @param operationType write operation type\n+   * @param instantTime current inflight instant time\n+   * @return HoodieTable\n+   */\n+  protected abstract HoodieTable<T, I, K, O, P> getTableAndInitCtx(WriteOperationType operationType, String instantTime);\n+\n+  /**\n+   * Sets write schema from last instant since deletes may not have schema set in the config.\n+   */\n+  protected void setWriteSchemaForDeletes(HoodieTableMetaClient metaClient) {\n+    try {\n+      HoodieActiveTimeline activeTimeline = metaClient.getActiveTimeline();\n+      Option<HoodieInstant> lastInstant =\n+          activeTimeline.filterCompletedInstants().filter(s -> s.getAction().equals(metaClient.getCommitActionType()))\n+              .lastInstant();\n+      if (lastInstant.isPresent()) {\n+        HoodieCommitMetadata commitMetadata = HoodieCommitMetadata.fromBytes(\n+            activeTimeline.getInstantDetails(lastInstant.get()).get(), HoodieCommitMetadata.class);\n+        if (commitMetadata.getExtraMetadata().containsKey(HoodieCommitMetadata.SCHEMA_KEY)) {\n+          config.setSchema(commitMetadata.getExtraMetadata().get(HoodieCommitMetadata.SCHEMA_KEY));\n+        } else {\n+          throw new HoodieIOException(\"Latest commit does not have any schema in commit metadata\");\n+        }\n+      } else {\n+        throw new HoodieIOException(\"Deletes issued without any prior commits\");\n+      }\n+    } catch (IOException e) {\n+      throw new HoodieIOException(\"IOException thrown while reading last commit metadata\", e);\n+    }\n+  }\n+\n+  @Override\n+  public void close() {\n+    // Stop timeline-server if running\n+    super.close();\n+    // Calling this here releases any resources used by your index, so make sure to finish any related operations\n+    // before this point\n+    this.index.close();\n+\n+    // release AsyncCleanerService\n+    AsyncCleanerService.forceShutdown(asyncCleanerService);\n+    asyncCleanerService = null;", "originalCommit": "c24a47c9eae815337d7b7ad42695958a3afa9e3c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc0NzUxOQ==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r494747519", "bodyText": "this needs to be removed. but not the issue for this PR to be bothered about may be", "author": "vinothchandar", "createdAt": "2020-09-25T04:58:30Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -716,32 +669,95 @@ private void rollbackPendingCommits() {\n    * @param compactionInstantTime Compaction Instant Time\n    * @return RDD of Write Status\n    */\n-  private JavaRDD<WriteStatus> compact(String compactionInstantTime, boolean shouldComplete) {\n-    HoodieTable<T> table = HoodieTable.create(config, hadoopConf);\n-    HoodieTimeline pendingCompactionTimeline = table.getActiveTimeline().filterPendingCompactionTimeline();\n-    HoodieInstant inflightInstant = HoodieTimeline.getCompactionInflightInstant(compactionInstantTime);\n-    if (pendingCompactionTimeline.containsInstant(inflightInstant)) {\n-      rollbackInflightCompaction(inflightInstant, table);\n-      table.getMetaClient().reloadActiveTimeline();\n-    }\n-    compactionTimer = metrics.getCompactionCtx();\n-    HoodieWriteMetadata compactionMetadata = table.compact(jsc, compactionInstantTime);\n-    JavaRDD<WriteStatus> statuses = compactionMetadata.getWriteStatuses();\n-    if (shouldComplete && compactionMetadata.getCommitMetadata().isPresent()) {\n-      completeCompaction(compactionMetadata.getCommitMetadata().get(), statuses, table, compactionInstantTime);\n-    }\n-    return statuses;\n-  }\n+  protected abstract O compact(String compactionInstantTime, boolean shouldComplete);\n \n   /**\n    * Performs a compaction operation on a table, serially before or after an insert/upsert action.\n    */\n-  private Option<String> inlineCompact(Option<Map<String, String>> extraMetadata) {\n+  protected Option<String> inlineCompact(Option<Map<String, String>> extraMetadata) {\n     Option<String> compactionInstantTimeOpt = scheduleCompaction(extraMetadata);\n     compactionInstantTimeOpt.ifPresent(compactionInstantTime -> {\n       // inline compaction should auto commit as the user is never given control\n       compact(compactionInstantTime, true);\n     });\n     return compactionInstantTimeOpt;\n   }\n+\n+  /**\n+   * Finalize Write operation.\n+   *\n+   * @param table HoodieTable\n+   * @param instantTime Instant Time\n+   * @param stats Hoodie Write Stat\n+   */\n+  protected void finalizeWrite(HoodieTable<T, I, K, O, P> table, String instantTime, List<HoodieWriteStat> stats) {\n+    try {\n+      final Timer.Context finalizeCtx = metrics.getFinalizeCtx();\n+      table.finalizeWrite(context, instantTime, stats);\n+      if (finalizeCtx != null) {\n+        Option<Long> durationInMs = Option.of(metrics.getDurationInMs(finalizeCtx.stop()));\n+        durationInMs.ifPresent(duration -> {\n+          LOG.info(\"Finalize write elapsed time (milliseconds): \" + duration);\n+          metrics.updateFinalizeWriteMetrics(duration, stats.size());\n+        });\n+      }\n+    } catch (HoodieIOException ioe) {\n+      throw new HoodieCommitException(\"Failed to complete commit \" + instantTime + \" due to finalize errors.\", ioe);\n+    }\n+  }\n+\n+  public HoodieMetrics getMetrics() {\n+    return metrics;\n+  }\n+\n+  public HoodieIndex<T, I, K, O, P> getIndex() {", "originalCommit": "c24a47c9eae815337d7b7ad42695958a3afa9e3c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTIzNTI3MQ==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r495235271", "bodyText": "this cannot be configurable. yarn/k8s will decide the actual driver host. changing it to how it was before", "author": "vinothchandar", "createdAt": "2020-09-25T21:14:01Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/config/HoodieWriteConfig.java", "diffHunk": "@@ -100,6 +99,7 @@\n \n   public static final String EMBEDDED_TIMELINE_SERVER_ENABLED = \"hoodie.embed.timeline.server\";\n   public static final String DEFAULT_EMBEDDED_TIMELINE_SERVER_ENABLED = \"true\";\n+  public static final String EMBEDDED_TIMELINE_SERVER_HOST = \"hoodie.embed.timeline.server.host\";", "originalCommit": "c24a47c9eae815337d7b7ad42695958a3afa9e3c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU5OTk0MA==", "url": "https://github.com/apache/hudi/pull/1827#discussion_r495599940", "bodyText": "this is a problem. it changes behavior and needs to be reworked.", "author": "vinothchandar", "createdAt": "2020-09-27T18:18:11Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/io/HoodieMergeHandle.java", "diffHunk": "@@ -149,7 +148,7 @@ private void init(String fileId, String partitionPath, HoodieBaseFile baseFileTo\n   private void init(String fileId, Iterator<HoodieRecord<T>> newRecordsItr) {\n     try {\n       // Load the new records in a map\n-      long memoryForMerge = SparkConfigUtils.getMaxMemoryPerPartitionMerge(config.getProps());\n+      long memoryForMerge = config.getMaxMemoryPerPartitionMerge();", "originalCommit": "c24a47c9eae815337d7b7ad42695958a3afa9e3c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c205bce39d13665e7393b743257d49a78d5f5f20", "url": "https://github.com/apache/hudi/commit/c205bce39d13665e7393b743257d49a78d5f5f20", "message": "Code Review Comments\n\n* Renaming HoodieSparkAsyncCompactService to SparkAsyncCompactService\n* Bug in SparkStreamingAsyncCompactService of not calling the super constructor with daemon mode.\n* Rename methods in HoodieEngineContext to setJobStatus() and setProperty()\n* Rename common packages to under client.common package\n* Bug in HoodieMergeHandle and compactor not getting the right merge memory", "committedDate": "2020-09-28T16:37:54Z", "type": "forcePushed"}, {"oid": "c158dee14355ec3cb24d1b16cb2fd7a84508fd44", "url": "https://github.com/apache/hudi/commit/c158dee14355ec3cb24d1b16cb2fd7a84508fd44", "message": "Code Review Comments\n\n* Renaming HoodieSparkAsyncCompactService to SparkAsyncCompactService\n* Bug in SparkStreamingAsyncCompactService of not calling the super constructor with daemon mode.\n* Rename methods in HoodieEngineContext to setJobStatus() and setProperty()\n* Rename common packages to under client.common package\n* Bug in HoodieMergeHandle and compactor not getting the right merge memory", "committedDate": "2020-09-28T20:56:04Z", "type": "forcePushed"}, {"oid": "bcf84a65661c9bdb517e4d982f10bc4ca14ad623", "url": "https://github.com/apache/hudi/commit/bcf84a65661c9bdb517e4d982f10bc4ca14ad623", "message": "More code review changes\n\n* Making HoodieSnapshotCopier/HoodieSnapshotExporter all use HoodieContext\n* More replacements of jsc.parallelize across hudi-spark-client\n* More replacements of jsc.setJobGroup across hudi-spark-client", "committedDate": "2020-09-30T00:50:45Z", "type": "forcePushed"}, {"oid": "b67ee14568ceb0bc0519594de42a20f6972ce2c0", "url": "https://github.com/apache/hudi/commit/b67ee14568ceb0bc0519594de42a20f6972ce2c0", "message": "[HUDI-1089] Refactor hudi-client to support multi-engine", "committedDate": "2020-09-30T23:53:10Z", "type": "commit"}, {"oid": "cd5d75ec4eb8594f37b37f5cb78cdb0d0d138713", "url": "https://github.com/apache/hudi/commit/cd5d75ec4eb8594f37b37f5cb78cdb0d0d138713", "message": "Code Review Comments\n\n* Renaming HoodieSparkAsyncCompactService to SparkAsyncCompactService\n* Bug in SparkStreamingAsyncCompactService of not calling the super constructor with daemon mode.\n* Rename methods in HoodieEngineContext to setJobStatus() and setProperty()\n* Rename common packages to under client.common package\n* Bug in HoodieMergeHandle and compactor not getting the right merge memory", "committedDate": "2020-10-01T04:48:20Z", "type": "commit"}, {"oid": "6c66d499ba941cbf0ed4e9f04a9256561fa55e9b", "url": "https://github.com/apache/hudi/commit/6c66d499ba941cbf0ed4e9f04a9256561fa55e9b", "message": "More code review changes\n\n* Making HoodieSnapshotCopier/HoodieSnapshotExporter all use HoodieContext\n* More replacements of jsc.parallelize across hudi-spark-client\n* More replacements of jsc.setJobGroup across hudi-spark-client", "committedDate": "2020-10-01T04:48:20Z", "type": "forcePushed"}, {"oid": "8b0670588e9d2d4454f5be0cf2dbbb28884e0cec", "url": "https://github.com/apache/hudi/commit/8b0670588e9d2d4454f5be0cf2dbbb28884e0cec", "message": "More code review changes\n\n* Making HoodieSnapshotCopier/HoodieSnapshotExporter all use HoodieContext\n* More replacements of jsc.parallelize across hudi-spark-client\n* More replacements of jsc.setJobGroup across hudi-spark-client", "committedDate": "2020-10-01T05:24:56Z", "type": "forcePushed"}, {"oid": "8512cac40d6990e6ce3276bee7c63907c6d5d96c", "url": "https://github.com/apache/hudi/commit/8512cac40d6990e6ce3276bee7c63907c6d5d96c", "message": "More code review changes\n\n* Making HoodieSnapshotCopier/HoodieSnapshotExporter all use HoodieContext\n* More replacements of jsc.parallelize across hudi-spark-client\n* More replacements of jsc.setJobGroup across hudi-spark-client", "committedDate": "2020-10-01T05:35:28Z", "type": "forcePushed"}, {"oid": "56690a5338b7cb0e10565544cbbd98daedd163c2", "url": "https://github.com/apache/hudi/commit/56690a5338b7cb0e10565544cbbd98daedd163c2", "message": "More code review changes\n\n* Making HoodieSnapshotCopier/HoodieSnapshotExporter all use HoodieContext\n* More replacements of jsc.parallelize across hudi-spark-client\n* More replacements of jsc.setJobGroup across hudi-spark-client", "committedDate": "2020-10-01T06:14:41Z", "type": "forcePushed"}, {"oid": "c7b1cb1860496efcf90b2855e6b40600cb454efb", "url": "https://github.com/apache/hudi/commit/c7b1cb1860496efcf90b2855e6b40600cb454efb", "message": "More code review changes\n\n* Making HoodieSnapshotCopier/HoodieSnapshotExporter all use HoodieContext\n* More replacements of jsc.parallelize across hudi-spark-client\n* More replacements of jsc.setJobGroup across hudi-spark-client\n* Removing usages of HoodieIndex#fetchRecordLocation everywhere", "committedDate": "2020-10-01T06:41:31Z", "type": "forcePushed"}, {"oid": "6a79819a84ffb129574b218e4dd4c435f4e94b58", "url": "https://github.com/apache/hudi/commit/6a79819a84ffb129574b218e4dd4c435f4e94b58", "message": "More code review changes\n\n* Making HoodieSnapshotCopier/HoodieSnapshotExporter all use HoodieContext\n* More replacements of jsc.parallelize across hudi-spark-client\n* More replacements of jsc.setJobGroup across hudi-spark-client\n* Removing usages of HoodieIndex#fetchRecordLocation everywhere", "committedDate": "2020-10-01T06:52:52Z", "type": "commit"}, {"oid": "6a79819a84ffb129574b218e4dd4c435f4e94b58", "url": "https://github.com/apache/hudi/commit/6a79819a84ffb129574b218e4dd4c435f4e94b58", "message": "More code review changes\n\n* Making HoodieSnapshotCopier/HoodieSnapshotExporter all use HoodieContext\n* More replacements of jsc.parallelize across hudi-spark-client\n* More replacements of jsc.setJobGroup across hudi-spark-client\n* Removing usages of HoodieIndex#fetchRecordLocation everywhere", "committedDate": "2020-10-01T06:52:52Z", "type": "forcePushed"}, {"oid": "7e33f73f70a65be635357e6fddc3053ac5a00694", "url": "https://github.com/apache/hudi/commit/7e33f73f70a65be635357e6fddc3053ac5a00694", "message": "Dropping HoodieIndex#fetchRecordLocation API\n\n* Not used by any other major API\n* Removing `P` from the templatized list of parameters", "committedDate": "2020-10-01T08:34:51Z", "type": "commit"}, {"oid": "d99096df897e64ca200df2cd9ca269c327faebf1", "url": "https://github.com/apache/hudi/commit/d99096df897e64ca200df2cd9ca269c327faebf1", "message": "Renaming some Abstract* classes as Hoodie* to improve readability", "committedDate": "2020-10-01T14:31:47Z", "type": "forcePushed"}]}