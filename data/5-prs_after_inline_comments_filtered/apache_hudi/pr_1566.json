{"pr_number": 1566, "pr_title": "[HUDI-603]: DeltaStreamer can now fetch schema before every run in continuous mode", "pr_createdAt": "2020-04-26T20:15:17Z", "pr_url": "https://github.com/apache/hudi/pull/1566", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjIyMDE4Mg==", "url": "https://github.com/apache/hudi/pull/1566#discussion_r416220182", "bodyText": "@pratyakshsharma : It looks like refreshSchemaProvider  not only refreshes schema-provider but also recreates Source and setup WriteClient\n@vinothchandar : Recreating DeltaSync each run would require to handle embedded timeline server reuse and async compaction triggering differently.  Another option is to have explicit refreshSchema() API in SchemaProvider (with default implementation (for compatibility) and implementing refresh in existing Schema Provider implementation) and have delta-streamer call this ? Let me know your thoughts on this ?", "author": "bvaradar", "createdAt": "2020-04-27T23:33:49Z", "path": "hudi-utilities/src/main/java/org/apache/hudi/utilities/deltastreamer/DeltaSync.java", "diffHunk": "@@ -162,18 +162,23 @@ public DeltaSync(HoodieDeltaStreamer.Config cfg, SparkSession sparkSession, Sche\n     this.fs = fs;\n     this.onInitializingHoodieWriteClient = onInitializingHoodieWriteClient;\n     this.props = props;\n-    this.schemaProvider = schemaProvider;\n \n     refreshTimeline();\n-\n     this.transformer = UtilHelpers.createTransformer(cfg.transformerClassNames);\n     this.keyGenerator = DataSourceUtils.createKeyGenerator(props);\n-\n-    this.formatAdapter = new SourceFormatAdapter(\n-        UtilHelpers.createSource(cfg.sourceClassName, props, jssc, sparkSession, schemaProvider));\n-\n     this.conf = conf;\n+    refreshSchemaProvider(schemaProvider);\n+  }\n \n+  /**\n+   * Very useful when DeltaStreamer is running in continuous mode.\n+   * @param schemaProvider\n+   * @throws IOException\n+   */\n+  public void refreshSchemaProvider(SchemaProvider schemaProvider) throws IOException {", "originalCommit": "dfaa70dc3bddebe875d1c194ac8916b260d0a3ba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjMxOTA2NQ==", "url": "https://github.com/apache/hudi/pull/1566#discussion_r416319065", "bodyText": "right.. embedded server re-use is important. let's scratch my idea.", "author": "vinothchandar", "createdAt": "2020-04-28T04:33:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjIyMDE4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjY5NDYwMg==", "url": "https://github.com/apache/hudi/pull/1566#discussion_r416694602", "bodyText": "It looks like refreshSchemaProvider not only refreshes schema-provider but also recreates Source and setup WriteClient\n\nDo you see any side effects of doing this? @bvaradar\n\nhave delta-streamer call this ?\n\nThis call will happen exactly at the same point where I am calling refreshSchemaProvider in delta-streamer, right?", "author": "pratyakshsharma", "createdAt": "2020-04-28T15:11:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjIyMDE4Mg=="}], "type": "inlineReview"}, {"oid": "741db83307e63e9ee6fe9df1911f1bfc6394cf78", "url": "https://github.com/apache/hudi/commit/741db83307e63e9ee6fe9df1911f1bfc6394cf78", "message": "[HUDI-603]: DeltaStreamer can now fetch schema before every run in continuous mode", "committedDate": "2020-05-15T19:47:46Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA3NDQxNg==", "url": "https://github.com/apache/hudi/pull/1566#discussion_r426074416", "bodyText": "should we add serialVersionUID? If it is not specified and anything in the class imports is shaded -> it will affect autogenerated one. Which causes issues if there is more than 1 version of the class in the classpath which was shaded differently.", "author": "afilipchik", "createdAt": "2020-05-15T22:32:15Z", "path": "hudi-utilities/src/main/java/org/apache/hudi/utilities/schema/SchemaSet.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.utilities.schema;\n+\n+import java.io.Serializable;\n+import java.util.HashSet;\n+import org.apache.avro.Schema;\n+import org.apache.avro.SchemaNormalization;\n+\n+import java.util.Set;\n+\n+/**\n+ * Tracks already processed schemas.\n+ */\n+public class SchemaSet implements Serializable {\n+", "originalCommit": "741db83307e63e9ee6fe9df1911f1bfc6394cf78", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE4NzEzOQ==", "url": "https://github.com/apache/hudi/pull/1566#discussion_r426187139", "bodyText": "@bvaradar to chime in here.", "author": "pratyakshsharma", "createdAt": "2020-05-16T20:14:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA3NDQxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODIxMDU0OQ==", "url": "https://github.com/apache/hudi/pull/1566#discussion_r428210549", "bodyText": "I will add serialVersionUUID. Usually, serialversion mismatch is a clue to an underlying problem which is package version mismatch", "author": "bvaradar", "createdAt": "2020-05-20T18:10:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA3NDQxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA3NjgwMw==", "url": "https://github.com/apache/hudi/pull/1566#discussion_r426076803", "bodyText": "is it called only once during a run? Will it be an issue if it is called more than once and slightly different schema is returned?", "author": "afilipchik", "createdAt": "2020-05-15T22:41:59Z", "path": "hudi-utilities/src/main/java/org/apache/hudi/utilities/schema/SchemaRegistryProvider.java", "diffHunk": "@@ -81,11 +66,22 @@ private static Schema getSchema(String registryUrl) throws IOException {\n \n   @Override\n   public Schema getSourceSchema() {\n-    return schema;\n+    String registryUrl = config.getString(Config.SRC_SCHEMA_REGISTRY_URL_PROP);", "originalCommit": "741db83307e63e9ee6fe9df1911f1bfc6394cf78", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE4NzA5Mw==", "url": "https://github.com/apache/hudi/pull/1566#discussion_r426187093", "bodyText": "It is already handled in the code, in case different schema is returned, writeClient is recreated and new avro schemas are registered with spark configuration.", "author": "pratyakshsharma", "createdAt": "2020-05-16T20:14:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA3NjgwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODIwODQwNg==", "url": "https://github.com/apache/hudi/pull/1566#discussion_r428208406", "bodyText": "this is called in every run and if we detect schema change, we register and recreate write client.", "author": "bvaradar", "createdAt": "2020-05-20T18:07:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA3NjgwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA3NzExNw==", "url": "https://github.com/apache/hudi/pull/1566#discussion_r426077117", "bodyText": "it might result in target schema != source schema when targetRegistryUrl is not specified as schema might change between getSourceSchema, getTargetSchema calls. Is it a problem?", "author": "afilipchik", "createdAt": "2020-05-15T22:43:15Z", "path": "hudi-utilities/src/main/java/org/apache/hudi/utilities/schema/SchemaRegistryProvider.java", "diffHunk": "@@ -81,11 +66,22 @@ private static Schema getSchema(String registryUrl) throws IOException {\n \n   @Override\n   public Schema getSourceSchema() {\n-    return schema;\n+    String registryUrl = config.getString(Config.SRC_SCHEMA_REGISTRY_URL_PROP);\n+    try {\n+      return getSchema(registryUrl);\n+    } catch (IOException ioe) {\n+      throw new HoodieIOException(\"Error reading source schema from registry :\" + registryUrl, ioe);\n+    }\n   }\n \n   @Override\n   public Schema getTargetSchema() {\n-    return targetSchema;\n+    String registryUrl = config.getString(Config.SRC_SCHEMA_REGISTRY_URL_PROP);\n+    String targetRegistryUrl = config.getString(Config.TARGET_SCHEMA_REGISTRY_URL_PROP, registryUrl);\n+    try {\n+      return getSchema(targetRegistryUrl);", "originalCommit": "741db83307e63e9ee6fe9df1911f1bfc6394cf78", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE4NTI1MQ==", "url": "https://github.com/apache/hudi/pull/1566#discussion_r426185251", "bodyText": "Should not be a problem I believe since sourceSchema is used for reading while targetSchema is used for writing. Any issues if at all should be handled in HoodieAvroUtils when we try to rewrite the record with targetSchema.", "author": "pratyakshsharma", "createdAt": "2020-05-16T19:51:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA3NzExNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODIwOTMxNw==", "url": "https://github.com/apache/hudi/pull/1566#discussion_r428209317", "bodyText": "yes, target schema is allowed to be different than source schema due to transformations and this is fine.", "author": "bvaradar", "createdAt": "2020-05-20T18:08:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA3NzExNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA3NzI0NQ==", "url": "https://github.com/apache/hudi/pull/1566#discussion_r426077245", "bodyText": "would be great to have some documentation on why it is done this way.", "author": "afilipchik", "createdAt": "2020-05-15T22:43:54Z", "path": "hudi-utilities/src/main/java/org/apache/hudi/utilities/deltastreamer/HoodieDeltaStreamer.java", "diffHunk": "@@ -464,21 +464,25 @@ private void shutdownCompactor(boolean error) {\n      */\n     protected Boolean onInitializingWriteClient(HoodieWriteClient writeClient) {\n       if (cfg.isAsyncCompactionEnabled()) {\n-        asyncCompactService = new AsyncCompactService(jssc, writeClient);\n-        // Enqueue existing pending compactions first\n-        HoodieTableMetaClient meta =\n-            new HoodieTableMetaClient(new Configuration(jssc.hadoopConfiguration()), cfg.targetBasePath, true);\n-        List<HoodieInstant> pending = CompactionUtils.getPendingCompactionInstantTimes(meta);\n-        pending.forEach(hoodieInstant -> asyncCompactService.enqueuePendingCompaction(hoodieInstant));\n-        asyncCompactService.start((error) -> {\n-          // Shutdown DeltaSync\n-          shutdown(false);\n-          return true;\n-        });\n-        try {\n-          asyncCompactService.waitTillPendingCompactionsReducesTo(cfg.maxPendingCompactions);\n-        } catch (InterruptedException ie) {\n-          throw new HoodieException(ie);\n+        if (null != asyncCompactService) {", "originalCommit": "741db83307e63e9ee6fe9df1911f1bfc6394cf78", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE4NDgyOA==", "url": "https://github.com/apache/hudi/pull/1566#discussion_r426184828", "bodyText": "+1", "author": "pratyakshsharma", "createdAt": "2020-05-16T19:46:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA3NzI0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTY0OTQxMw==", "url": "https://github.com/apache/hudi/pull/1566#discussion_r491649413", "bodyText": "Added", "author": "bvaradar", "createdAt": "2020-09-20T04:06:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA3NzI0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA3NzgwOQ==", "url": "https://github.com/apache/hudi/pull/1566#discussion_r426077809", "bodyText": "is it used anywhere?", "author": "afilipchik", "createdAt": "2020-05-15T22:46:02Z", "path": "hudi-utilities/src/main/java/org/apache/hudi/utilities/deltastreamer/Compactor.java", "diffHunk": "@@ -59,6 +60,10 @@ public void compact(HoodieInstant instant) throws IOException {\n           \"Compaction for instant (\" + instant + \") failed with write errors. Errors :\" + numWriteErrors);\n     }\n     // Commit compaction\n-    compactionClient.commitCompaction(instant.getTimestamp(), res, Option.empty());\n+    writeClient.commitCompaction(instant.getTimestamp(), res, Option.empty());\n+  }\n+\n+  public void updateWriteClient(HoodieWriteClient writeClient) {", "originalCommit": "741db83307e63e9ee6fe9df1911f1bfc6394cf78", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE4NDY1Mg==", "url": "https://github.com/apache/hudi/pull/1566#discussion_r426184652", "bodyText": "Yes, in HoodieDeltaStreamer.", "author": "pratyakshsharma", "createdAt": "2020-05-16T19:44:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA3NzgwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA3ODUwMQ==", "url": "https://github.com/apache/hudi/pull/1566#discussion_r426078501", "bodyText": "will this grow indefinitely? How would we remove old schema?", "author": "afilipchik", "createdAt": "2020-05-15T22:48:51Z", "path": "hudi-utilities/src/main/java/org/apache/hudi/utilities/schema/SchemaSet.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.utilities.schema;\n+\n+import java.io.Serializable;\n+import java.util.HashSet;\n+import org.apache.avro.Schema;\n+import org.apache.avro.SchemaNormalization;\n+\n+import java.util.Set;\n+\n+/**\n+ * Tracks already processed schemas.\n+ */\n+public class SchemaSet implements Serializable {\n+\n+  private final Set<Long> processedSchema = new HashSet<>();", "originalCommit": "741db83307e63e9ee6fe9df1911f1bfc6394cf78", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE4NDc5MA==", "url": "https://github.com/apache/hudi/pull/1566#discussion_r426184790", "bodyText": "Personally I feel you do not have many schema evolutions in production environment. So not removing old schemas should not create any issues. @bvaradar to take the final call.", "author": "pratyakshsharma", "createdAt": "2020-05-16T19:45:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA3ODUwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODIwNjQwMA==", "url": "https://github.com/apache/hudi/pull/1566#discussion_r428206400", "bodyText": "I think this is similar in scope to how sparkConf maintains avro schemas. In continuous mode, we reuse the same spark session. I think this is ok.", "author": "bvaradar", "createdAt": "2020-05-20T18:03:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA3ODUwMQ=="}], "type": "inlineReview"}, {"oid": "f547f6f4fe289cc44c8a426ed58bdee5f62a7f78", "url": "https://github.com/apache/hudi/commit/f547f6f4fe289cc44c8a426ed58bdee5f62a7f78", "message": "[HUDI-603]: DeltaStreamer can now fetch schema before every run in continuous mode", "committedDate": "2020-09-20T04:00:12Z", "type": "forcePushed"}, {"oid": "4f2450f521cb2dbc87867bcd4674c2042efe64a4", "url": "https://github.com/apache/hudi/commit/4f2450f521cb2dbc87867bcd4674c2042efe64a4", "message": "[HUDI-603]: DeltaStreamer can now fetch schema before every run in continuous mode", "committedDate": "2020-09-20T04:06:34Z", "type": "forcePushed"}, {"oid": "43fe6e6502e2c8283df70f208d3777d04fc8f900", "url": "https://github.com/apache/hudi/commit/43fe6e6502e2c8283df70f208d3777d04fc8f900", "message": "[HUDI-603]: DeltaStreamer can now fetch schema before every run in continuous mode", "committedDate": "2020-09-20T05:33:07Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQ5NjgzMw==", "url": "https://github.com/apache/hudi/pull/1566#discussion_r495496833", "bodyText": "Any specific reason for introducing a new variable here?", "author": "pratyakshsharma", "createdAt": "2020-09-26T21:21:28Z", "path": "hudi-client/src/main/java/org/apache/hudi/client/Compactor.java", "diffHunk": "@@ -45,7 +45,8 @@ public Compactor(HoodieWriteClient compactionClient) {\n \n   public void compact(HoodieInstant instant) throws IOException {\n     LOG.info(\"Compactor executing compaction \" + instant);\n-    JavaRDD<WriteStatus> res = compactionClient.compact(instant.getTimestamp());\n+    HoodieWriteClient writeClient = compactionClient;", "originalCommit": "43fe6e6502e2c8283df70f208d3777d04fc8f900", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE2MDQ4MQ==", "url": "https://github.com/apache/hudi/pull/1566#discussion_r496160481", "bodyText": "This is to keep the client instance consistent between writing and committing.", "author": "bvaradar", "createdAt": "2020-09-28T18:46:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQ5NjgzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQ5ODUyNQ==", "url": "https://github.com/apache/hudi/pull/1566#discussion_r495498525", "bodyText": "Just curious, can you please explain why do we need to call this function here? @bvaradar", "author": "pratyakshsharma", "createdAt": "2020-09-26T21:42:52Z", "path": "hudi-utilities/src/main/java/org/apache/hudi/utilities/deltastreamer/DeltaSync.java", "diffHunk": "@@ -536,14 +564,35 @@ public void syncHive(HiveConf conf) {\n    * SchemaProvider creation is a precursor to HoodieWriteClient and AsyncCompactor creation. This method takes care of\n    * this constraint.\n    */\n-  private void setupWriteClient() {\n-    LOG.info(\"Setting up Hoodie Write Client\");\n-    if ((null != schemaProvider) && (null == writeClient)) {\n-      registerAvroSchemas(schemaProvider);\n-      HoodieWriteConfig hoodieCfg = getHoodieClientConfig(schemaProvider);\n-      writeClient = new HoodieWriteClient<>(jssc, hoodieCfg, true);\n-      onInitializingHoodieWriteClient.apply(writeClient);\n+  public void setupWriteClient() throws IOException {\n+    if ((null != schemaProvider)) {\n+      Schema sourceSchema = schemaProvider.getSourceSchema();\n+      Schema targetSchema = schemaProvider.getTargetSchema();\n+      createNewWriteClient(sourceSchema, targetSchema);\n+    }\n+  }\n+\n+  private void createNewWriteClient(Schema sourceSchema, Schema targetSchema) throws IOException {\n+    LOG.info(\"Setting up new Hoodie Write Client\");\n+    registerAvroSchemas(sourceSchema, targetSchema);\n+    HoodieWriteConfig hoodieCfg = getHoodieClientConfig(targetSchema);\n+    if (hoodieCfg.isEmbeddedTimelineServerEnabled()) {\n+      if (!embeddedTimelineService.isPresent()) {\n+        embeddedTimelineService = EmbeddedTimelineServerHelper.createEmbeddedTimelineService(jssc.hadoopConfiguration(),\n+            jssc.getConf(), hoodieCfg);\n+      } else {\n+        EmbeddedTimelineServerHelper.updateWriteConfigWithTimelineServer(embeddedTimelineService.get(), hoodieCfg);", "originalCommit": "43fe6e6502e2c8283df70f208d3777d04fc8f900", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQ5OTExNg==", "url": "https://github.com/apache/hudi/pull/1566#discussion_r495499116", "bodyText": "As per my understanding, in every iteration of deltaStreamer, only the target schema can change, rest of the HoodieWriteConfig will remain same. Rather than creating a new hoodieCfg variable in this method every time schema changes, can we have a class level HoodieWriteConfig variable, where we only update the schema whenever it changes? This way we can do away with this call updateWriteConfigWithTimelineServer here. WDYT?", "author": "pratyakshsharma", "createdAt": "2020-09-26T21:51:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQ5ODUyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE2MDA1Ng==", "url": "https://github.com/apache/hudi/pull/1566#discussion_r496160056", "bodyText": "There can be new fields in the source schema and the target schema can just reflect that. The write config are designed to be immutable with builder pattern. Also, some of the functions run in executor side. It is lot simpler by recreating the aggregate class (WriteClient) here.", "author": "bvaradar", "createdAt": "2020-09-28T18:45:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQ5ODUyNQ=="}], "type": "inlineReview"}, {"oid": "75b10c1381fdb989f02803a25eb2614ad471f666", "url": "https://github.com/apache/hudi/commit/75b10c1381fdb989f02803a25eb2614ad471f666", "message": "[HUDI-603]: DeltaStreamer can now fetch schema before every run in continuous mode", "committedDate": "2020-10-04T16:49:50Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI5OTg1MA==", "url": "https://github.com/apache/hudi/pull/1566#discussion_r499299850", "bodyText": "I really dislike all the nested ifs-and null checks. :( there ought to be a better way of structuring this code overall. Side rant", "author": "vinothchandar", "createdAt": "2020-10-04T23:25:23Z", "path": "hudi-utilities/src/main/java/org/apache/hudi/utilities/deltastreamer/DeltaSync.java", "diffHunk": "@@ -244,6 +263,18 @@ private void refreshTimeline() throws IOException {\n         this.schemaProvider = srcRecordsWithCkpt.getKey();", "originalCommit": "a0b3b64eae966fb35e92de7dc99a01b3d871ef37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY1ODUxNA==", "url": "https://github.com/apache/hudi/pull/1566#discussion_r500658514", "bodyText": "Agree. the whole schema provider and write client handling needs to be refactored to be more readable.", "author": "bvaradar", "createdAt": "2020-10-06T23:50:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI5OTg1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI5OTk0NA==", "url": "https://github.com/apache/hudi/pull/1566#discussion_r499299944", "bodyText": "rename: reInitWriteClient()", "author": "vinothchandar", "createdAt": "2020-10-04T23:26:38Z", "path": "hudi-utilities/src/main/java/org/apache/hudi/utilities/deltastreamer/DeltaSync.java", "diffHunk": "@@ -534,19 +565,33 @@ public void syncHive(HiveConf conf) {\n     syncHive();\n   }\n \n-  /**\n-   * Note that depending on configs and source-type, schemaProvider could either be eagerly or lazily created.\n-   * SchemaProvider creation is a precursor to HoodieWriteClient and AsyncCompactor creation. This method takes care of\n-   * this constraint.\n-   */\n-  private void setupWriteClient() {\n-    LOG.info(\"Setting up Hoodie Write Client\");\n-    if ((null != schemaProvider) && (null == writeClient)) {\n-      registerAvroSchemas(schemaProvider);\n-      HoodieWriteConfig hoodieCfg = getHoodieClientConfig(schemaProvider);\n-      writeClient = new SparkRDDWriteClient<>(new HoodieSparkEngineContext(jssc), hoodieCfg, true);\n-      onInitializingHoodieWriteClient.apply(writeClient);\n+  public void setupWriteClient() throws IOException {\n+    if ((null != schemaProvider)) {\n+      Schema sourceSchema = schemaProvider.getSourceSchema();\n+      Schema targetSchema = schemaProvider.getTargetSchema();\n+      createNewWriteClient(sourceSchema, targetSchema);\n+    }\n+  }\n+\n+  private void createNewWriteClient(Schema sourceSchema, Schema targetSchema) throws IOException {", "originalCommit": "a0b3b64eae966fb35e92de7dc99a01b3d871ef37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY1NzkzNA==", "url": "https://github.com/apache/hudi/pull/1566#discussion_r500657934", "bodyText": "Done", "author": "bvaradar", "createdAt": "2020-10-06T23:48:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI5OTk0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTMwMDAyNQ==", "url": "https://github.com/apache/hudi/pull/1566#discussion_r499300025", "bodyText": "any need to make this synchronized across threads?", "author": "vinothchandar", "createdAt": "2020-10-04T23:27:40Z", "path": "hudi-utilities/src/main/java/org/apache/hudi/utilities/deltastreamer/HoodieDeltaStreamer.java", "diffHunk": "@@ -624,21 +624,26 @@ private void shutdownCompactor(boolean error) {\n      */\n     protected Boolean onInitializingWriteClient(SparkRDDWriteClient writeClient) {\n       if (cfg.isAsyncCompactionEnabled()) {\n-        asyncCompactService = new SparkAsyncCompactService(new HoodieSparkEngineContext(jssc), writeClient);\n-        // Enqueue existing pending compactions first\n-        HoodieTableMetaClient meta =\n-            new HoodieTableMetaClient(new Configuration(jssc.hadoopConfiguration()), cfg.targetBasePath, true);\n-        List<HoodieInstant> pending = CompactionUtils.getPendingCompactionInstantTimes(meta);\n-        pending.forEach(hoodieInstant -> asyncCompactService.enqueuePendingCompaction(hoodieInstant));\n-        asyncCompactService.start((error) -> {\n-          // Shutdown DeltaSync\n-          shutdown(false);\n-          return true;\n-        });\n-        try {\n-          asyncCompactService.waitTillPendingCompactionsReducesTo(cfg.maxPendingCompactions);\n-        } catch (InterruptedException ie) {\n-          throw new HoodieException(ie);\n+        if (null != asyncCompactService) {\n+          // Update the write client used by Async Compactor.\n+          asyncCompactService.updateWriteClient(writeClient);", "originalCommit": "a0b3b64eae966fb35e92de7dc99a01b3d871ef37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY1NzkxNQ==", "url": "https://github.com/apache/hudi/pull/1566#discussion_r500657915", "bodyText": "Should work as is but adding synchronized if we make future changes in a way where this would be not thread-safe.", "author": "bvaradar", "createdAt": "2020-10-06T23:48:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTMwMDAyNQ=="}], "type": "inlineReview"}, {"oid": "b61c87c0639ddb50fc038212ba7dd18cc92f73a7", "url": "https://github.com/apache/hudi/commit/b61c87c0639ddb50fc038212ba7dd18cc92f73a7", "message": "[HUDI-603]: DeltaStreamer can now fetch schema before every run in continuous mode", "committedDate": "2020-10-07T00:43:18Z", "type": "commit"}, {"oid": "b61c87c0639ddb50fc038212ba7dd18cc92f73a7", "url": "https://github.com/apache/hudi/commit/b61c87c0639ddb50fc038212ba7dd18cc92f73a7", "message": "[HUDI-603]: DeltaStreamer can now fetch schema before every run in continuous mode", "committedDate": "2020-10-07T00:43:18Z", "type": "forcePushed"}]}