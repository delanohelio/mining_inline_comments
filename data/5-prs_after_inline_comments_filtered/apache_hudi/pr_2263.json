{"pr_number": 2263, "pr_title": "[HUDI-1075] Implement simple clustering strategies to create and run ClusteringPlan", "pr_createdAt": "2020-11-19T21:30:39Z", "pr_url": "https://github.com/apache/hudi/pull/2263", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA0NDk3NQ==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r528044975", "bodyText": "Should this be a public method ? Rolling back inflight could probably remain private ? Or is this for the CLI ?", "author": "n3nash", "createdAt": "2020-11-21T01:07:16Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -726,6 +751,54 @@ private void rollbackPendingCommits() {\n     return compactionInstantTimeOpt;\n   }\n \n+  /**\n+   * Schedules a new clustering instant.\n+   *\n+   * @param extraMetadata Extra Metadata to be stored\n+   */\n+  public Option<String> scheduleClustering(Option<Map<String, String>> extraMetadata) throws HoodieIOException {\n+    String instantTime = HoodieActiveTimeline.createNewInstantTime();\n+    return scheduleClusteringAtInstant(instantTime, extraMetadata) ? Option.of(instantTime) : Option.empty();\n+  }\n+\n+  /**\n+   * Schedules a new clustering instant with passed-in instant time.\n+   *\n+   * @param instantTime clustering Instant Time\n+   * @param extraMetadata Extra Metadata to be stored\n+   */\n+  public boolean scheduleClusteringAtInstant(String instantTime, Option<Map<String, String>> extraMetadata) throws HoodieIOException {\n+    LOG.info(\"Scheduling clustering at instant time :\" + instantTime);\n+    Option<HoodieClusteringPlan> plan = createTable(config, hadoopConf)\n+        .scheduleClustering(context, instantTime, extraMetadata);\n+    return plan.isPresent();\n+  }\n+\n+  /**\n+   * Ensures clustering instant is in expected state and performs clustering for the plan stored in metadata.\n+   *\n+   * @param clusteringInstant Clustering Instant Time\n+   * @return Collection of Write Status\n+   */\n+  protected abstract HoodieWriteMetadata<O> cluster(String clusteringInstant, boolean shouldComplete);\n+\n+  /**\n+   * Executes a clustering plan on a table, serially before or after an insert/upsert action.\n+   */\n+  protected Option<String> inlineCluster(Option<Map<String, String>> extraMetadata) {\n+    Option<String> clusteringInstantOpt = scheduleClustering(extraMetadata);\n+    clusteringInstantOpt.ifPresent(clusteringInstant -> {\n+      // inline cluster should auto commit as the user is never given control\n+      cluster(clusteringInstant, true);\n+    });\n+    return clusteringInstantOpt;\n+  }\n+\n+  public void rollbackInflightClustering(HoodieInstant inflightInstant, HoodieTable<T, I, K, O> table) {", "originalCommit": "dc6d32154dacec181149e41d091a0854b662c362", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgxMjI2Ng==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r532812266", "bodyText": "Changed to protected. I dont think this is needed for CLI.  We can change it back to public, when needed.", "author": "satishkotha", "createdAt": "2020-11-30T18:32:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA0NDk3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA0Njg5OA==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r528046898", "bodyText": "Looks like the execution framework details are in the configs. Would be nice to have a wrapper around reflection utils that can pick the right execution engine based class but keep the strategy class name generic...not sure if it's too late for that..", "author": "n3nash", "createdAt": "2020-11-21T01:18:21Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/config/HoodieClusteringConfig.java", "diffHunk": "@@ -0,0 +1,155 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.config;\n+\n+import org.apache.hudi.common.config.DefaultHoodieConfig;\n+\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.util.Properties;\n+\n+/**\n+ * Clustering specific configs.\n+ */\n+public class HoodieClusteringConfig extends DefaultHoodieConfig {\n+\n+  public static final String SCHEDULE_CLUSTERING_STRATEGY_CLASS = \"hoodie.clustering.schedule.strategy.class\";\n+  public static final String DEFAULT_SCHEDULE_CLUSTERING_STRATEGY_CLASS =", "originalCommit": "dc6d32154dacec181149e41d091a0854b662c362", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgxMjk0MQ==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r532812941", "bodyText": "This is just the class name. It is possible to support both flink and spark clients with same class. Initial implementation is primarily targeted for Spark. So i explicitly called the class Spark.", "author": "satishkotha", "createdAt": "2020-11-30T18:34:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA0Njg5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA0Njk2MQ==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r528046961", "bodyText": "extreme nit : s/a/an :)", "author": "n3nash", "createdAt": "2020-11-21T01:18:47Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/config/HoodieClusteringConfig.java", "diffHunk": "@@ -0,0 +1,155 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.config;\n+\n+import org.apache.hudi.common.config.DefaultHoodieConfig;\n+\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.util.Properties;\n+\n+/**\n+ * Clustering specific configs.\n+ */\n+public class HoodieClusteringConfig extends DefaultHoodieConfig {\n+\n+  public static final String SCHEDULE_CLUSTERING_STRATEGY_CLASS = \"hoodie.clustering.schedule.strategy.class\";\n+  public static final String DEFAULT_SCHEDULE_CLUSTERING_STRATEGY_CLASS =\n+      \"org.apache.hudi.client.clustering.schedule.SparkBoundedDayBasedScheduleClusteringStrategy\";\n+\n+  public static final String RUN_CLUSTERING_STRATEGY_CLASS = \"hoodie.clustering.run.strategy.class\";\n+  public static final String DEFAULT_RUN_CLUSTERING_STRATEGY_CLASS =\n+      \"org.apache.hudi.client.clustering.run.SparkBulkInsertBasedRunClusteringStrategy\";\n+\n+  // Turn on inline clustering - after few commits a inline compaction will be run", "originalCommit": "dc6d32154dacec181149e41d091a0854b662c362", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA0NzI4Ng==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r528047286", "bodyText": "Is this in MB ? Can we rename this to withClusteringMaxGroupSizeInMB ?", "author": "n3nash", "createdAt": "2020-11-21T01:20:45Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/config/HoodieClusteringConfig.java", "diffHunk": "@@ -0,0 +1,155 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.config;\n+\n+import org.apache.hudi.common.config.DefaultHoodieConfig;\n+\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.util.Properties;\n+\n+/**\n+ * Clustering specific configs.\n+ */\n+public class HoodieClusteringConfig extends DefaultHoodieConfig {\n+\n+  public static final String SCHEDULE_CLUSTERING_STRATEGY_CLASS = \"hoodie.clustering.schedule.strategy.class\";\n+  public static final String DEFAULT_SCHEDULE_CLUSTERING_STRATEGY_CLASS =\n+      \"org.apache.hudi.client.clustering.schedule.SparkBoundedDayBasedScheduleClusteringStrategy\";\n+\n+  public static final String RUN_CLUSTERING_STRATEGY_CLASS = \"hoodie.clustering.run.strategy.class\";\n+  public static final String DEFAULT_RUN_CLUSTERING_STRATEGY_CLASS =\n+      \"org.apache.hudi.client.clustering.run.SparkBulkInsertBasedRunClusteringStrategy\";\n+\n+  // Turn on inline clustering - after few commits a inline compaction will be run\n+  public static final String INLINE_CLUSTERING_PROP = \"hoodie.clustering.inline\";\n+  private static final String DEFAULT_INLINE_CLUSTERING = \"false\";\n+\n+  public static final String INLINE_CLUSTERING_NUM_COMMIT_PROP = \"hoodie.clustering.inline.num.commits\";\n+  private static final String DEFAULT_INLINE_CLUSTERING_NUM_COMMITS = \"4\";\n+\n+  public static final String CLUSTERING_TARGET_PARTITIONS = \"hoodie.clustering.target.partitions\";\n+  public static final String DEFAULT_CLUSTERING_TARGET_PARTITIONS = String.valueOf(2);\n+\n+  // Each clustering operation can create multiple groups. Total amount of data processed by clustering operation\n+  // is defined by below two properties (CLUSTERING_MAX_GROUP_SIZE * CLUSTERING_MAX_NUM_GROUPS).\n+  // Max amount of data to be included in one group\n+  public static final String CLUSTERING_MAX_GROUP_SIZE = \"hoodie.clustering.max.group.size\";\n+  public static final String DEFAULT_CLUSTERING_MAX_GROUP_SIZE = String.valueOf(2 * 1024 * 1024 * 1024L);\n+\n+  public static final String CLUSTERING_MAX_NUM_GROUPS = \"hoodie.clustering.max.num.groups\";\n+  public static final String DEFAULT_CLUSTERING_MAX_NUM_GROUPS = \"1\";\n+\n+  // Each group can produce 'N' (CLUSTERING_MAX_GROUP_SIZE/CLUSTERING_TARGET_FILE_SIZE) output file groups.\n+  public static final String CLUSTERING_TARGET_FILE_SIZE = \"hoodie.clustering.target.file.size\";\n+  public static final String DEFAULT_CLUSTERING_TARGET_FILE_SIZE = String.valueOf(1 * 1024 * 1024 * 1024L);\n+\n+  // Any strategy specific params can be saved with this prefix\n+  public static final String CLUSTERING_STRATEGY_PARAM_PREFIX = \"hoodie.clustering.strategy.param.\";\n+\n+  // constants related to clustering that may be used by more than 1 strategy.\n+  public static final String SORT_COLUMNS_PROPERTY = HoodieClusteringConfig.CLUSTERING_STRATEGY_PARAM_PREFIX + \"sort.columns\";\n+\n+  public HoodieClusteringConfig(Properties props) {\n+    super(props);\n+  }\n+\n+  public static Builder newBuilder() {\n+    return new Builder();\n+  }\n+\n+  public static class Builder {\n+\n+    private final Properties props = new Properties();\n+\n+    public Builder fromFile(File propertiesFile) throws IOException {\n+      try (FileReader reader = new FileReader(propertiesFile)) {\n+        this.props.load(reader);\n+        return this;\n+      }\n+    }\n+\n+    public Builder withScheduleClusteringStrategyClass(String clusteringStrategyClass) {\n+      props.setProperty(SCHEDULE_CLUSTERING_STRATEGY_CLASS, clusteringStrategyClass);\n+      return this;\n+    }\n+\n+    public Builder withRunClusteringStrategyClass(String runClusteringStrategyClass) {\n+      props.setProperty(RUN_CLUSTERING_STRATEGY_CLASS, runClusteringStrategyClass);\n+      return this;\n+    }\n+\n+    public Builder withClusteringTargetPartitions(String clusteringTargetPartitions) {\n+      props.setProperty(CLUSTERING_TARGET_PARTITIONS, clusteringTargetPartitions);\n+      return this;\n+    }\n+\n+    public Builder withClusteringMaxGroupSize(long clusteringMaxGroupSize) {", "originalCommit": "dc6d32154dacec181149e41d091a0854b662c362", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgxMzExNA==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r532813114", "bodyText": "Fixed", "author": "satishkotha", "createdAt": "2020-11-30T18:34:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA0NzI4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA0NzM0NA==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r528047344", "bodyText": "Same this, if in MB, add it to the name or java docs ?", "author": "n3nash", "createdAt": "2020-11-21T01:21:06Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/config/HoodieClusteringConfig.java", "diffHunk": "@@ -0,0 +1,155 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.config;\n+\n+import org.apache.hudi.common.config.DefaultHoodieConfig;\n+\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.util.Properties;\n+\n+/**\n+ * Clustering specific configs.\n+ */\n+public class HoodieClusteringConfig extends DefaultHoodieConfig {\n+\n+  public static final String SCHEDULE_CLUSTERING_STRATEGY_CLASS = \"hoodie.clustering.schedule.strategy.class\";\n+  public static final String DEFAULT_SCHEDULE_CLUSTERING_STRATEGY_CLASS =\n+      \"org.apache.hudi.client.clustering.schedule.SparkBoundedDayBasedScheduleClusteringStrategy\";\n+\n+  public static final String RUN_CLUSTERING_STRATEGY_CLASS = \"hoodie.clustering.run.strategy.class\";\n+  public static final String DEFAULT_RUN_CLUSTERING_STRATEGY_CLASS =\n+      \"org.apache.hudi.client.clustering.run.SparkBulkInsertBasedRunClusteringStrategy\";\n+\n+  // Turn on inline clustering - after few commits a inline compaction will be run\n+  public static final String INLINE_CLUSTERING_PROP = \"hoodie.clustering.inline\";\n+  private static final String DEFAULT_INLINE_CLUSTERING = \"false\";\n+\n+  public static final String INLINE_CLUSTERING_NUM_COMMIT_PROP = \"hoodie.clustering.inline.num.commits\";\n+  private static final String DEFAULT_INLINE_CLUSTERING_NUM_COMMITS = \"4\";\n+\n+  public static final String CLUSTERING_TARGET_PARTITIONS = \"hoodie.clustering.target.partitions\";\n+  public static final String DEFAULT_CLUSTERING_TARGET_PARTITIONS = String.valueOf(2);\n+\n+  // Each clustering operation can create multiple groups. Total amount of data processed by clustering operation\n+  // is defined by below two properties (CLUSTERING_MAX_GROUP_SIZE * CLUSTERING_MAX_NUM_GROUPS).\n+  // Max amount of data to be included in one group\n+  public static final String CLUSTERING_MAX_GROUP_SIZE = \"hoodie.clustering.max.group.size\";\n+  public static final String DEFAULT_CLUSTERING_MAX_GROUP_SIZE = String.valueOf(2 * 1024 * 1024 * 1024L);\n+\n+  public static final String CLUSTERING_MAX_NUM_GROUPS = \"hoodie.clustering.max.num.groups\";\n+  public static final String DEFAULT_CLUSTERING_MAX_NUM_GROUPS = \"1\";\n+\n+  // Each group can produce 'N' (CLUSTERING_MAX_GROUP_SIZE/CLUSTERING_TARGET_FILE_SIZE) output file groups.\n+  public static final String CLUSTERING_TARGET_FILE_SIZE = \"hoodie.clustering.target.file.size\";\n+  public static final String DEFAULT_CLUSTERING_TARGET_FILE_SIZE = String.valueOf(1 * 1024 * 1024 * 1024L);\n+\n+  // Any strategy specific params can be saved with this prefix\n+  public static final String CLUSTERING_STRATEGY_PARAM_PREFIX = \"hoodie.clustering.strategy.param.\";\n+\n+  // constants related to clustering that may be used by more than 1 strategy.\n+  public static final String SORT_COLUMNS_PROPERTY = HoodieClusteringConfig.CLUSTERING_STRATEGY_PARAM_PREFIX + \"sort.columns\";\n+\n+  public HoodieClusteringConfig(Properties props) {\n+    super(props);\n+  }\n+\n+  public static Builder newBuilder() {\n+    return new Builder();\n+  }\n+\n+  public static class Builder {\n+\n+    private final Properties props = new Properties();\n+\n+    public Builder fromFile(File propertiesFile) throws IOException {\n+      try (FileReader reader = new FileReader(propertiesFile)) {\n+        this.props.load(reader);\n+        return this;\n+      }\n+    }\n+\n+    public Builder withScheduleClusteringStrategyClass(String clusteringStrategyClass) {\n+      props.setProperty(SCHEDULE_CLUSTERING_STRATEGY_CLASS, clusteringStrategyClass);\n+      return this;\n+    }\n+\n+    public Builder withRunClusteringStrategyClass(String runClusteringStrategyClass) {\n+      props.setProperty(RUN_CLUSTERING_STRATEGY_CLASS, runClusteringStrategyClass);\n+      return this;\n+    }\n+\n+    public Builder withClusteringTargetPartitions(String clusteringTargetPartitions) {\n+      props.setProperty(CLUSTERING_TARGET_PARTITIONS, clusteringTargetPartitions);\n+      return this;\n+    }\n+\n+    public Builder withClusteringMaxGroupSize(long clusteringMaxGroupSize) {\n+      props.setProperty(CLUSTERING_MAX_GROUP_SIZE, String.valueOf(clusteringMaxGroupSize));\n+      return this;\n+    }\n+\n+    public Builder withClusteringMaxNumGroups(int maxNumGroups) {\n+      props.setProperty(CLUSTERING_MAX_NUM_GROUPS, String.valueOf(maxNumGroups));\n+      return this;\n+    }\n+\n+    public Builder withClusteringTargetFileSize(long targetFileSize) {", "originalCommit": "dc6d32154dacec181149e41d091a0854b662c362", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgxMzE4NQ==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r532813185", "bodyText": "Fixed", "author": "satishkotha", "createdAt": "2020-11-30T18:34:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA0NzM0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA0ODI5Nw==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r528048297", "bodyText": "Should this be named \"cluster\" given the write client also has \"cluster\" ?", "author": "n3nash", "createdAt": "2020-11-21T01:27:24Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/table/HoodieTable.java", "diffHunk": "@@ -326,6 +327,28 @@ public HoodieActiveTimeline getActiveTimeline() {\n   public abstract HoodieWriteMetadata<O> compact(HoodieEngineContext context,\n                                               String compactionInstantTime);\n \n+\n+  /**\n+   * Schedule clustering for the instant time.\n+   *\n+   * @param context HoodieEngineContext\n+   * @param instantTime Instant Time for scheduling clustering\n+   * @param extraMetadata additional metadata to write into plan\n+   * @return HoodieClusteringPlan, if there is enough data for clustering.\n+   */\n+  public abstract Option<HoodieClusteringPlan> scheduleClustering(HoodieEngineContext context,\n+                                                                  String instantTime,\n+                                                                  Option<Map<String, String>> extraMetadata);\n+\n+  /**\n+   * Run Clustering on the table. Clustering re-arranges the data so that it is optimized for data access.\n+   *\n+   * @param context HoodieEngineContext\n+   * @param clusteringInstantTime Instant Time\n+   */\n+  public abstract HoodieWriteMetadata<O> clustering(HoodieEngineContext context,", "originalCommit": "dc6d32154dacec181149e41d091a0854b662c362", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgxMzM5NQ==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r532813395", "bodyText": "Fixed", "author": "satishkotha", "createdAt": "2020-11-30T18:34:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA0ODI5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA3OTU0OQ==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r528079549", "bodyText": "Better name for \"maxDataInGroup\" ?", "author": "n3nash", "createdAt": "2020-11-21T06:13:29Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/table/action/cluster/strategy/PartitionAwareScheduleClusteringStrategy.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.table.action.cluster.strategy;\n+\n+import org.apache.hudi.avro.model.HoodieClusteringGroup;\n+import org.apache.hudi.avro.model.HoodieClusteringPlan;\n+import org.apache.hudi.avro.model.HoodieClusteringStrategy;\n+import org.apache.hudi.client.common.HoodieEngineContext;\n+import org.apache.hudi.common.fs.FSUtils;\n+import org.apache.hudi.common.model.FileSlice;\n+import org.apache.hudi.common.model.HoodieRecordPayload;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.util.Option;\n+import org.apache.hudi.config.HoodieWriteConfig;\n+import org.apache.hudi.exception.HoodieIOException;\n+import org.apache.hudi.table.HoodieTable;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ * Scheduling strategy with restriction that clustering groups can only contain files from same partition.\n+ */\n+public abstract class PartitionAwareScheduleClusteringStrategy<T extends HoodieRecordPayload,I,K,O> extends ScheduleClusteringStrategy<T,I,K,O> {\n+  private static final Logger LOG = LogManager.getLogger(PartitionAwareScheduleClusteringStrategy.class);\n+\n+  public PartitionAwareScheduleClusteringStrategy(HoodieTable table, HoodieEngineContext engineContext, HoodieWriteConfig writeConfig) {\n+    super(table, engineContext, writeConfig);\n+  }\n+\n+  /**\n+   * Create Clustering group based on files eligible for clustering in the partition.\n+   */\n+  protected abstract Stream<HoodieClusteringGroup> buildClusteringGroupsForPartition(String partitionPath,\n+                                                                                     List<FileSlice> fileSlices,\n+                                                                                     long maxDataInGroup);", "originalCommit": "dc6d32154dacec181149e41d091a0854b662c362", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgxMzY0MA==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r532813640", "bodyText": "Removed this argument per Li Wei suggestion.", "author": "satishkotha", "createdAt": "2020-11-30T18:35:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA3OTU0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA4MDMyNA==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r528080324", "bodyText": "Can you expand on why we need the \"schema\" parameter ?", "author": "n3nash", "createdAt": "2020-11-21T06:21:23Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/table/action/cluster/strategy/RunClusteringStrategy.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.table.action.cluster.strategy;\n+\n+import org.apache.avro.Schema;\n+import org.apache.hudi.client.common.HoodieEngineContext;\n+import org.apache.hudi.common.model.HoodieRecordPayload;\n+import org.apache.hudi.config.HoodieWriteConfig;\n+import org.apache.hudi.table.HoodieTable;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import java.io.Serializable;\n+import java.util.Map;\n+\n+/**\n+ * Pluggable implementation for writing data into new file groups based on ClusteringPlan.\n+ */\n+public abstract class RunClusteringStrategy<T extends HoodieRecordPayload,I,K,O> implements Serializable {\n+  private static final Logger LOG = LogManager.getLogger(RunClusteringStrategy.class);\n+\n+  private final HoodieTable<T,I,K,O> hoodieTable;\n+  private final HoodieEngineContext engineContext;\n+  private final HoodieWriteConfig writeConfig;\n+\n+  public RunClusteringStrategy(HoodieTable table, HoodieEngineContext engineContext, HoodieWriteConfig writeConfig) {\n+    this.writeConfig = writeConfig;\n+    this.hoodieTable = table;\n+    this.engineContext = engineContext;\n+  }\n+\n+  /**\n+   * Run clustering to write inputRecords into new files as defined by rules in strategy parameters. The number of new\n+   * file groups created is bounded by numOutputGroups.\n+   * Note that commit is not done as part of strategy. commit is callers responsibility.\n+   */\n+  public abstract O performClustering(final I inputRecords, final int numOutputGroups, final String instantTime,", "originalCommit": "dc6d32154dacec181149e41d091a0854b662c362", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgxNTUwNg==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r532815506", "bodyText": "This is \"readerSchema\" for all inputRecords being clustered. This is useful to read values for specified sort columns  from inputRecords.  Let me know if theres a better way to do this.", "author": "satishkotha", "createdAt": "2020-11-30T18:38:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA4MDMyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTA1NTkxNQ==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r545055915", "bodyText": "lets rename the parameter to be more descriptive?", "author": "vinothchandar", "createdAt": "2020-12-17T12:34:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA4MDMyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA4MDU2OA==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r528080568", "bodyText": "Could we use StringUtils.EMPTY or create a constant ?", "author": "n3nash", "createdAt": "2020-11-21T06:24:38Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/table/action/cluster/strategy/ScheduleClusteringStrategy.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.table.action.cluster.strategy;\n+\n+import org.apache.hudi.avro.model.HoodieClusteringPlan;\n+import org.apache.hudi.avro.model.HoodieSliceInfo;\n+import org.apache.hudi.client.common.HoodieEngineContext;\n+import org.apache.hudi.common.fs.FSUtils;\n+import org.apache.hudi.common.model.BaseFile;\n+import org.apache.hudi.common.model.FileSlice;\n+import org.apache.hudi.common.model.HoodieBaseFile;\n+import org.apache.hudi.common.model.HoodieFileGroupId;\n+import org.apache.hudi.common.model.HoodieLogFile;\n+import org.apache.hudi.common.model.HoodieRecordPayload;\n+import org.apache.hudi.common.table.view.SyncableFileSystemView;\n+import org.apache.hudi.common.util.ClusteringUtils;\n+import org.apache.hudi.common.util.Option;\n+import org.apache.hudi.config.HoodieWriteConfig;\n+import org.apache.hudi.table.HoodieTable;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import java.io.Serializable;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Pluggable implementation for scheduling clustering and creating ClusteringPlan.\n+ */\n+public abstract class ScheduleClusteringStrategy<T extends HoodieRecordPayload,I,K,O> implements Serializable {\n+  private static final Logger LOG = LogManager.getLogger(ScheduleClusteringStrategy.class);\n+\n+  public static final String TOTAL_IO_READ_MB = \"TOTAL_IO_READ_MB\";\n+  public static final String TOTAL_IO_WRITE_MB = \"TOTAL_IO_WRITE_MB\";\n+  public static final String TOTAL_IO_MB = \"TOTAL_IO_MB\";\n+  public static final String TOTAL_LOG_FILE_SIZE = \"TOTAL_LOG_FILES_SIZE\";\n+  public static final String TOTAL_LOG_FILES = \"TOTAL_LOG_FILES\";\n+\n+  public static final int CLUSTERING_PLAN_VERSION_1 = 1;\n+\n+  private final HoodieTable<T,I,K,O> hoodieTable;\n+  private final HoodieEngineContext engineContext;\n+  private final HoodieWriteConfig writeConfig;\n+\n+  public ScheduleClusteringStrategy(HoodieTable table, HoodieEngineContext engineContext, HoodieWriteConfig writeConfig) {\n+    this.writeConfig = writeConfig;\n+    this.hoodieTable = table;\n+    this.engineContext = engineContext;\n+  }\n+\n+  /**\n+   * Generate metadata for grouping eligible files and create a plan. Note that data is not moved around\n+   * as part of this step.\n+   *\n+   * If there is no data available to cluster, return None.\n+   */\n+  public abstract Option<HoodieClusteringPlan> generateClusteringPlan();\n+\n+  /**\n+   * Return file slices eligible for clustering. FileIds in\n+   * 1) pending clustering/compaction\n+   * 2) Larger than clustering target file size\n+   *\n+   * are not eligible for clustering\n+   */\n+  protected List<FileSlice> getFileSlicesEligibleForClustering(String partition) {\n+    Set<HoodieFileGroupId> fgIdsInPendingCompactionAndClustering = ((SyncableFileSystemView) getHoodieTable().getSliceView()).getPendingCompactionOperations()\n+        .map(instantTimeOpPair -> instantTimeOpPair.getValue().getFileGroupId())\n+        .collect(Collectors.toSet());\n+    fgIdsInPendingCompactionAndClustering.addAll(ClusteringUtils.getAllFileGroupsInPendingClusteringPlans(getHoodieTable().getMetaClient()).keySet());\n+\n+    return hoodieTable.getSliceView().getLatestFileSlices(partition)\n+        // file ids already in clustering are not eligible\n+        .filter(slice -> !fgIdsInPendingCompactionAndClustering.contains(slice.getFileGroupId()))\n+        // files that have basefile size larger than clustering target file size are not eligible (Note that compaction can merge any updates)\n+        .filter(slice -> slice.getBaseFile().map(HoodieBaseFile::getFileSize).orElse(0L) < writeConfig.getClusteringTargetFileSize())\n+        .collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Get parameters specific to strategy. These parameters are passed from 'schedule clustering' step to\n+   * 'run clustering' step. 'run clustering' step is typically async. So these params help with passing any required\n+   * context from schedule to run step.\n+   */\n+  protected abstract Map<String, String> getStrategyParams();\n+\n+  /**\n+   * Returns any specific parameters to be stored as part of clustering metadata.\n+   */\n+  protected Map<String, String> getExtraMetadata() {\n+    return Collections.emptyMap();\n+  }\n+\n+  /**\n+   * Version to support future changes for plan.\n+   */\n+  protected int getPlanVersion() {\n+    return CLUSTERING_PLAN_VERSION_1;\n+  }\n+\n+  /**\n+   * Transform {@link FileSlice} to {@link HoodieSliceInfo}.\n+   */\n+  protected List<HoodieSliceInfo> getFileSliceInfo(List<FileSlice> slices) {\n+    return slices.stream().map(slice -> new HoodieSliceInfo().newBuilder()\n+        .setPartitionPath(slice.getPartitionPath())\n+        .setFileId(slice.getFileId())\n+        .setDataFilePath(slice.getBaseFile().map(BaseFile::getPath).orElse(\"\"))", "originalCommit": "dc6d32154dacec181149e41d091a0854b662c362", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTA1OTUzNg==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r545059536", "bodyText": "use the constant in L123 as well?", "author": "vinothchandar", "createdAt": "2020-12-17T12:40:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA4MDU2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA4ODAyNw==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r528088027", "bodyText": "Could we split this -> https://github.com/apache/hudi/blob/master/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/table/action/compact/strategy/CompactionStrategy.java into IStrategy that should have common methods expected from all strategies such as buildMetrics, getPlanVersion..and then ScheduleClusteringStrategy can extend it ?\nAfter that, let's move the buildMetrics into a utils class given it's the same across both compaction and clustering right now ?", "author": "n3nash", "createdAt": "2020-11-21T06:43:13Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/table/action/cluster/strategy/ScheduleClusteringStrategy.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.table.action.cluster.strategy;\n+\n+import org.apache.hudi.avro.model.HoodieClusteringPlan;\n+import org.apache.hudi.avro.model.HoodieSliceInfo;\n+import org.apache.hudi.client.common.HoodieEngineContext;\n+import org.apache.hudi.common.fs.FSUtils;\n+import org.apache.hudi.common.model.BaseFile;\n+import org.apache.hudi.common.model.FileSlice;\n+import org.apache.hudi.common.model.HoodieBaseFile;\n+import org.apache.hudi.common.model.HoodieFileGroupId;\n+import org.apache.hudi.common.model.HoodieLogFile;\n+import org.apache.hudi.common.model.HoodieRecordPayload;\n+import org.apache.hudi.common.table.view.SyncableFileSystemView;\n+import org.apache.hudi.common.util.ClusteringUtils;\n+import org.apache.hudi.common.util.Option;\n+import org.apache.hudi.config.HoodieWriteConfig;\n+import org.apache.hudi.table.HoodieTable;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import java.io.Serializable;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Pluggable implementation for scheduling clustering and creating ClusteringPlan.\n+ */\n+public abstract class ScheduleClusteringStrategy<T extends HoodieRecordPayload,I,K,O> implements Serializable {", "originalCommit": "dc6d32154dacec181149e41d091a0854b662c362", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgxNzU4Mw==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r532817583", "bodyText": "I feel like inheritance is wrong pattern here. These look similar now, but i think metrics will change differently over time. So having tight integration may make it difficult for these two evolve differently. Let me know if you have strong opinion. I can change it.", "author": "satishkotha", "createdAt": "2020-11-30T18:42:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA4ODAyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzYxNzYyNQ==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r533617625", "bodyText": "My general idea was to consolidate different kinds of strategies for operations such as compaction, clustering right now (tiering etc in the future). If you take a look, lots of code around TOTAL IO etc is coped over, any other way we can consolidate this without taking away some flexibility ?", "author": "n3nash", "createdAt": "2020-12-01T18:07:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA4ODAyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTY1MDM2Mg==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r535650362", "bodyText": "I moved buildMetrics to utils class. If you have strong opinion on common interface I can add it.", "author": "satishkotha", "createdAt": "2020-12-03T21:38:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA4ODAyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA5MTE5Mw==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r528091193", "bodyText": "nit : updateIndex -> update index, lets follow one pattern", "author": "n3nash", "createdAt": "2020-11-21T06:47:21Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/table/action/commit/AbstractBulkInsertHelper.java", "diffHunk": "@@ -27,8 +27,20 @@\n \n public abstract class AbstractBulkInsertHelper<T extends HoodieRecordPayload, I, K, O, R> {\n \n+  /**\n+   * Mark instant as inflight, write input records, updateIndex and return result.", "originalCommit": "dc6d32154dacec181149e41d091a0854b662c362", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgxNzY1OQ==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r532817659", "bodyText": "Fixed", "author": "satishkotha", "createdAt": "2020-11-30T18:42:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA5MTE5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA5NTk3Mg==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r528095972", "bodyText": "Should this be a REPLACE_ACTION instead of COMPACTION_ACTION ?", "author": "n3nash", "createdAt": "2020-11-21T06:53:55Z", "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/client/SparkRDDWriteClient.java", "diffHunk": "@@ -296,6 +298,57 @@ protected void completeCompaction(HoodieCommitMetadata metadata, JavaRDD<WriteSt\n     return statuses;\n   }\n \n+  @Override\n+  protected HoodieWriteMetadata<JavaRDD<WriteStatus>> cluster(String clusteringInstant, boolean shouldComplete) {\n+    HoodieSparkTable<T> table = HoodieSparkTable.create(config, context);\n+    HoodieTimeline pendingClusteringTimeline = table.getActiveTimeline().filterPendingReplaceTimeline();\n+    HoodieInstant inflightInstant = HoodieTimeline.getReplaceCommitInflightInstant(clusteringInstant);\n+    if (pendingClusteringTimeline.containsInstant(inflightInstant)) {\n+      rollbackInflightClustering(inflightInstant, table);\n+      table.getMetaClient().reloadActiveTimeline();\n+    }\n+    clusteringTimer = metrics.getClusteringCtx();\n+    LOG.info(\"Starting clustering at \" + clusteringInstant);\n+    HoodieWriteMetadata<JavaRDD<WriteStatus>> clusteringMetadata = table.clustering(context, clusteringInstant);\n+    JavaRDD<WriteStatus> statuses = clusteringMetadata.getWriteStatuses();\n+    if (shouldComplete && clusteringMetadata.getCommitMetadata().isPresent()) {\n+      completeClustering((HoodieReplaceCommitMetadata) clusteringMetadata.getCommitMetadata().get(), statuses, table, clusteringInstant);\n+    }\n+    return clusteringMetadata;\n+  }\n+\n+  protected void completeClustering(HoodieReplaceCommitMetadata metadata, JavaRDD<WriteStatus> writeStatuses,\n+                                    HoodieTable<T, JavaRDD<HoodieRecord<T>>, JavaRDD<HoodieKey>, JavaRDD<WriteStatus>> table,\n+                                    String clusteringCommitTime) {\n+\n+    List<HoodieWriteStat> writeStats = writeStatuses.map(WriteStatus::getStat).collect();\n+    if (!writeStatuses.filter(WriteStatus::hasErrors).isEmpty()) {\n+      throw new HoodieClusteringException(\"Clustering failed to write to files:\"\n+          + writeStatuses.filter(WriteStatus::hasErrors).map(WriteStatus::getFileId).collect());\n+    }\n+    finalizeWrite(table, clusteringCommitTime, writeStats);\n+    try {\n+      LOG.info(\"Committing Clustering \" + clusteringCommitTime + \". Finished with result \" + metadata);\n+      table.getActiveTimeline().transitionReplaceInflightToComplete(\n+          HoodieTimeline.getReplaceCommitInflightInstant(clusteringCommitTime),\n+          Option.of(metadata.toJsonString().getBytes(StandardCharsets.UTF_8)));\n+    } catch (IOException e) {\n+      throw new HoodieClusteringException(\"unable to transition clustering inflight to complete: \" + clusteringCommitTime,  e);\n+    }\n+\n+    if (clusteringTimer != null) {\n+      long durationInMs = metrics.getDurationInMs(clusteringTimer.stop());\n+      try {\n+        metrics.updateCommitMetrics(HoodieActiveTimeline.COMMIT_FORMATTER.parse(clusteringCommitTime).getTime(),\n+            durationInMs, metadata, HoodieActiveTimeline.COMPACTION_ACTION);", "originalCommit": "dc6d32154dacec181149e41d091a0854b662c362", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgxNzc2MQ==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r532817761", "bodyText": "Good catch, fixed.", "author": "satishkotha", "createdAt": "2020-11-30T18:42:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA5NTk3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA5NjI3NA==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r528096274", "bodyText": "Why is this not under the strategy package ?", "author": "n3nash", "createdAt": "2020-11-21T06:54:20Z", "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/client/clustering/run/SparkBulkInsertBasedRunClusteringStrategy.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.client.clustering.run;\n+\n+import org.apache.avro.Schema;\n+import org.apache.hudi.client.WriteStatus;\n+import org.apache.hudi.client.common.HoodieSparkEngineContext;\n+import org.apache.hudi.common.model.HoodieKey;\n+import org.apache.hudi.common.model.HoodieRecord;\n+import org.apache.hudi.common.model.HoodieRecordPayload;\n+import org.apache.hudi.common.util.Option;\n+import org.apache.hudi.config.HoodieWriteConfig;\n+import org.apache.hudi.execution.bulkinsert.RDDCustomColumnsSortPartitioner;\n+import org.apache.hudi.table.BulkInsertPartitioner;\n+import org.apache.hudi.table.HoodieSparkCopyOnWriteTable;\n+import org.apache.hudi.table.action.cluster.strategy.RunClusteringStrategy;\n+import org.apache.hudi.table.action.commit.SparkBulkInsertHelper;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+import org.apache.spark.api.java.JavaRDD;\n+\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import static org.apache.hudi.config.HoodieClusteringConfig.SORT_COLUMNS_PROPERTY;\n+\n+/**\n+ * Clustering Strategy based on following.\n+ * 1) Spark execution engine.\n+ * 2) Uses bulk_insert to write data into new files.\n+ */\n+public class SparkBulkInsertBasedRunClusteringStrategy<T extends HoodieRecordPayload<T>>", "originalCommit": "dc6d32154dacec181149e41d091a0854b662c362", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgxNzg0MA==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r532817840", "bodyText": "Moved.", "author": "satishkotha", "createdAt": "2020-11-30T18:42:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA5NjI3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA5Nzg0Ng==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r528097846", "bodyText": "same question, should this go under strategy package ?", "author": "n3nash", "createdAt": "2020-11-21T06:56:30Z", "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/client/clustering/schedule/SparkBoundedDayBasedScheduleClusteringStrategy.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.client.clustering.schedule;\n+\n+import org.apache.hudi.avro.model.HoodieClusteringGroup;\n+import org.apache.hudi.client.WriteStatus;\n+import org.apache.hudi.client.common.HoodieSparkEngineContext;\n+import org.apache.hudi.common.model.FileSlice;\n+import org.apache.hudi.common.model.HoodieKey;\n+import org.apache.hudi.common.model.HoodieRecord;\n+import org.apache.hudi.common.model.HoodieRecordPayload;\n+import org.apache.hudi.common.util.collection.Pair;\n+import org.apache.hudi.config.HoodieWriteConfig;\n+import org.apache.hudi.table.HoodieSparkCopyOnWriteTable;\n+import org.apache.hudi.table.action.cluster.strategy.PartitionAwareScheduleClusteringStrategy;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+import org.apache.spark.api.java.JavaRDD;\n+\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.apache.hudi.config.HoodieClusteringConfig.SORT_COLUMNS_PROPERTY;\n+\n+/**\n+ * Clustering Strategy based on following.\n+ * 1) Spark execution engine.\n+ * 2) Limits amount of data per clustering operation.\n+ */\n+public class SparkBoundedDayBasedScheduleClusteringStrategy<T extends HoodieRecordPayload<T>>", "originalCommit": "dc6d32154dacec181149e41d091a0854b662c362", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgxNzkwNQ==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r532817905", "bodyText": "Moved", "author": "satishkotha", "createdAt": "2020-11-30T18:42:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA5Nzg0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA5ODU2NA==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r528098564", "bodyText": "Could you explain this change please ?", "author": "n3nash", "createdAt": "2020-11-21T06:57:30Z", "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/execution/SparkLazyInsertIterable.java", "diffHunk": "@@ -34,14 +35,18 @@\n \n public class SparkLazyInsertIterable<T extends HoodieRecordPayload> extends HoodieLazyInsertIterable<T> {\n \n+  private boolean addMetadataFields;", "originalCommit": "dc6d32154dacec181149e41d091a0854b662c362", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgxODYzMQ==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r532818631", "bodyText": "With regular bulk insert, RDD only has user specified columns. With bulk insert based clustering, RDD also has hoodie internal columns. So, I am adding this flag to make it work for both cases. Let me know if you want me to reorganize this  differently.", "author": "satishkotha", "createdAt": "2020-11-30T18:44:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA5ODU2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA5ODY0MQ==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r528098641", "bodyText": "same", "author": "n3nash", "createdAt": "2020-11-21T06:57:39Z", "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/execution/bulkinsert/BulkInsertMapFunction.java", "diffHunk": "@@ -41,20 +41,22 @@\n   private HoodieWriteConfig config;\n   private HoodieTable hoodieTable;\n   private List<String> fileIDPrefixes;\n+  private boolean addMetadataFields;\n \n   public BulkInsertMapFunction(String instantTime, boolean areRecordsSorted,\n                                HoodieWriteConfig config, HoodieTable hoodieTable,\n-                               List<String> fileIDPrefixes) {\n+                               List<String> fileIDPrefixes, boolean addMetadataFields) {", "originalCommit": "dc6d32154dacec181149e41d091a0854b662c362", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgxODY3OQ==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r532818679", "bodyText": "With regular bulk insert, RDD only has user specified columns. With bulk insert based clustering, RDD also has hoodie internal columns. So, I am adding this flag to make it work for both cases. Let me know if you want me to reorganize this  differently.", "author": "satishkotha", "createdAt": "2020-11-30T18:44:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA5ODY0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY1ODgwNA==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r533658804", "bodyText": "This problem exists today with the MOR tables when inserts go into log files. For this reason, we have a different constructor for the create handle that is called from the compaction code path -> \n  \n    \n      hudi/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/io/HoodieCreateHandle.java\n    \n    \n         Line 93\n      in\n      36ce5bc\n    \n    \n    \n    \n\n        \n          \n           public HoodieCreateHandle(HoodieWriteConfig config, String instantTime, HoodieTable<T, I, K, O> hoodieTable, \n        \n    \n  \n\n. Can you try to do the same for clustering and avoid passing this flag here ?", "author": "n3nash", "createdAt": "2020-12-01T19:15:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA5ODY0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTU1NjIzMw==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r535556233", "bodyText": "We need this in transform function below (We dont use HoodieCreateHandle here). I changed the name to follow same pattern as HoodieCreateHandle to make it more clear. Let me know if this is clear.", "author": "satishkotha", "createdAt": "2020-12-03T20:14:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA5ODY0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODEwNzE5NA==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r528107194", "bodyText": "This runs the clustering groups in sequence, is that what is expected ?", "author": "n3nash", "createdAt": "2020-11-21T07:09:40Z", "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/table/action/cluster/SparkRunClusteringCommitActionExecutor.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.table.action.cluster;\n+\n+import org.apache.avro.Schema;\n+import org.apache.avro.generic.IndexedRecord;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.avro.HoodieAvroUtils;\n+import org.apache.hudi.avro.model.HoodieClusteringGroup;\n+import org.apache.hudi.avro.model.HoodieClusteringPlan;\n+import org.apache.hudi.client.SparkTaskContextSupplier;\n+import org.apache.hudi.client.WriteStatus;\n+import org.apache.hudi.client.common.HoodieEngineContext;\n+import org.apache.hudi.client.common.HoodieSparkEngineContext;\n+import org.apache.hudi.common.model.HoodieCommitMetadata;\n+import org.apache.hudi.common.model.HoodieKey;\n+import org.apache.hudi.common.model.HoodieRecord;\n+import org.apache.hudi.common.model.HoodieRecordPayload;\n+import org.apache.hudi.common.model.WriteOperationType;\n+import org.apache.hudi.common.table.log.HoodieFileSliceReader;\n+import org.apache.hudi.common.table.log.HoodieMergedLogRecordScanner;\n+import org.apache.hudi.common.table.timeline.HoodieInstant;\n+import org.apache.hudi.common.table.timeline.HoodieTimeline;\n+import org.apache.hudi.common.util.ClusteringUtils;\n+import org.apache.hudi.common.util.CommitUtils;\n+import org.apache.hudi.common.util.Option;\n+import org.apache.hudi.common.util.ReflectionUtils;\n+import org.apache.hudi.common.util.collection.Pair;\n+import org.apache.hudi.config.HoodieWriteConfig;\n+import org.apache.hudi.exception.HoodieClusteringException;\n+import org.apache.hudi.io.IOUtils;\n+import org.apache.hudi.io.storage.HoodieFileReader;\n+import org.apache.hudi.io.storage.HoodieFileReaderFactory;\n+import org.apache.hudi.table.HoodieTable;\n+import org.apache.hudi.table.action.HoodieWriteMetadata;\n+import org.apache.hudi.table.action.cluster.strategy.RunClusteringStrategy;\n+import org.apache.hudi.table.action.commit.BaseSparkCommitActionExecutor;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+import org.apache.spark.api.java.JavaRDD;\n+import org.apache.spark.api.java.JavaSparkContext;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+public class SparkRunClusteringCommitActionExecutor<T extends HoodieRecordPayload<T>>\n+    extends BaseSparkCommitActionExecutor<T> {\n+\n+  private static final Logger LOG = LogManager.getLogger(SparkRunClusteringCommitActionExecutor.class);\n+  private final HoodieClusteringPlan clusteringPlan;\n+\n+  public SparkRunClusteringCommitActionExecutor(HoodieEngineContext context,\n+                                                HoodieWriteConfig config, HoodieTable table,\n+                                                String instantTime) {\n+    super(context, config, table, instantTime, WriteOperationType.CLUSTER);\n+    this.clusteringPlan = ClusteringUtils.getClusteringPlan(table.getMetaClient(), HoodieTimeline.getReplaceCommitRequestedInstant(instantTime))\n+      .map(Pair::getRight).orElseThrow(() -> new HoodieClusteringException(\"Unable to read clustering plan for instant: \" + instantTime));\n+  }\n+\n+  @Override\n+  public HoodieWriteMetadata<JavaRDD<WriteStatus>> execute() {\n+    HoodieInstant instant = HoodieTimeline.getReplaceCommitRequestedInstant(instantTime);\n+    // Mark instant as clustering inflight\n+    table.getActiveTimeline().transitionReplaceRequestedToInflight(instant, Option.empty());\n+    table.getMetaClient().reloadActiveTimeline();\n+\n+    JavaSparkContext engineContext = HoodieSparkEngineContext.getSparkContext(context);\n+    // read rdd from input groups in plan\n+    JavaRDD<WriteStatus> writeStatuses = clusteringPlan.getInputGroups().stream()", "originalCommit": "dc6d32154dacec181149e41d091a0854b662c362", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgxOTAyOQ==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r532819029", "bodyText": "I changed it to parallelize using java thread pool. PTAL.", "author": "satishkotha", "createdAt": "2020-11-30T18:44:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODEwNzE5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODEwODcxMw==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r528108713", "bodyText": "Why do we need this reload ?", "author": "n3nash", "createdAt": "2020-11-21T07:11:48Z", "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/table/action/cluster/SparkRunClusteringCommitActionExecutor.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.table.action.cluster;\n+\n+import org.apache.avro.Schema;\n+import org.apache.avro.generic.IndexedRecord;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.avro.HoodieAvroUtils;\n+import org.apache.hudi.avro.model.HoodieClusteringGroup;\n+import org.apache.hudi.avro.model.HoodieClusteringPlan;\n+import org.apache.hudi.client.SparkTaskContextSupplier;\n+import org.apache.hudi.client.WriteStatus;\n+import org.apache.hudi.client.common.HoodieEngineContext;\n+import org.apache.hudi.client.common.HoodieSparkEngineContext;\n+import org.apache.hudi.common.model.HoodieCommitMetadata;\n+import org.apache.hudi.common.model.HoodieKey;\n+import org.apache.hudi.common.model.HoodieRecord;\n+import org.apache.hudi.common.model.HoodieRecordPayload;\n+import org.apache.hudi.common.model.WriteOperationType;\n+import org.apache.hudi.common.table.log.HoodieFileSliceReader;\n+import org.apache.hudi.common.table.log.HoodieMergedLogRecordScanner;\n+import org.apache.hudi.common.table.timeline.HoodieInstant;\n+import org.apache.hudi.common.table.timeline.HoodieTimeline;\n+import org.apache.hudi.common.util.ClusteringUtils;\n+import org.apache.hudi.common.util.CommitUtils;\n+import org.apache.hudi.common.util.Option;\n+import org.apache.hudi.common.util.ReflectionUtils;\n+import org.apache.hudi.common.util.collection.Pair;\n+import org.apache.hudi.config.HoodieWriteConfig;\n+import org.apache.hudi.exception.HoodieClusteringException;\n+import org.apache.hudi.io.IOUtils;\n+import org.apache.hudi.io.storage.HoodieFileReader;\n+import org.apache.hudi.io.storage.HoodieFileReaderFactory;\n+import org.apache.hudi.table.HoodieTable;\n+import org.apache.hudi.table.action.HoodieWriteMetadata;\n+import org.apache.hudi.table.action.cluster.strategy.RunClusteringStrategy;\n+import org.apache.hudi.table.action.commit.BaseSparkCommitActionExecutor;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+import org.apache.spark.api.java.JavaRDD;\n+import org.apache.spark.api.java.JavaSparkContext;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+public class SparkRunClusteringCommitActionExecutor<T extends HoodieRecordPayload<T>>\n+    extends BaseSparkCommitActionExecutor<T> {\n+\n+  private static final Logger LOG = LogManager.getLogger(SparkRunClusteringCommitActionExecutor.class);\n+  private final HoodieClusteringPlan clusteringPlan;\n+\n+  public SparkRunClusteringCommitActionExecutor(HoodieEngineContext context,\n+                                                HoodieWriteConfig config, HoodieTable table,\n+                                                String instantTime) {\n+    super(context, config, table, instantTime, WriteOperationType.CLUSTER);\n+    this.clusteringPlan = ClusteringUtils.getClusteringPlan(table.getMetaClient(), HoodieTimeline.getReplaceCommitRequestedInstant(instantTime))\n+      .map(Pair::getRight).orElseThrow(() -> new HoodieClusteringException(\"Unable to read clustering plan for instant: \" + instantTime));\n+  }\n+\n+  @Override\n+  public HoodieWriteMetadata<JavaRDD<WriteStatus>> execute() {\n+    HoodieInstant instant = HoodieTimeline.getReplaceCommitRequestedInstant(instantTime);\n+    // Mark instant as clustering inflight\n+    table.getActiveTimeline().transitionReplaceRequestedToInflight(instant, Option.empty());\n+    table.getMetaClient().reloadActiveTimeline();", "originalCommit": "dc6d32154dacec181149e41d091a0854b662c362", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgxOTg5Mw==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r532819893", "bodyText": "After this step, we convert inflight to commit. Without this reload, 'inflight' doesnt exist in table.getActiveTimeline(). So commit doesnt succeed. We seem to be doing similar step for compaction too.", "author": "satishkotha", "createdAt": "2020-11-30T18:46:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODEwODcxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzYxODk1NQ==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r533618955", "bodyText": "Okay", "author": "n3nash", "createdAt": "2020-12-01T18:09:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODEwODcxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODExMDAwMA==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r528110000", "bodyText": "Java doc please", "author": "n3nash", "createdAt": "2020-11-21T07:13:48Z", "path": "hudi-common/src/main/java/org/apache/hudi/common/table/log/HoodieFileSliceReader.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.common.table.log;\n+\n+import org.apache.avro.Schema;\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.avro.generic.IndexedRecord;\n+import org.apache.hudi.common.model.HoodieRecord;\n+import org.apache.hudi.common.model.HoodieRecordPayload;\n+import org.apache.hudi.common.util.SpillableMapUtils;\n+import org.apache.hudi.io.storage.HoodieFileReader;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Iterator;\n+\n+public class HoodieFileSliceReader implements Iterable<HoodieRecord<? extends HoodieRecordPayload>> {", "originalCommit": "dc6d32154dacec181149e41d091a0854b662c362", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgxOTk1MA==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r532819950", "bodyText": "Added", "author": "satishkotha", "createdAt": "2020-11-30T18:46:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODExMDAwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODExMjExMw==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r528112113", "bodyText": "At a high level, what is the use-case when we would need to cluster every N commits ? For compaction it makes sense..", "author": "n3nash", "createdAt": "2020-11-21T07:16:41Z", "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/table/action/cluster/SparkScheduleClusteringActionExecutor.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.table.action.cluster;\n+\n+import org.apache.hudi.avro.model.HoodieClusteringPlan;\n+import org.apache.hudi.client.WriteStatus;\n+import org.apache.hudi.client.common.HoodieEngineContext;\n+import org.apache.hudi.common.model.HoodieKey;\n+import org.apache.hudi.common.model.HoodieRecord;\n+import org.apache.hudi.common.model.HoodieRecordPayload;\n+import org.apache.hudi.common.table.timeline.HoodieInstant;\n+import org.apache.hudi.common.util.Option;\n+import org.apache.hudi.common.util.ReflectionUtils;\n+import org.apache.hudi.config.HoodieWriteConfig;\n+import org.apache.hudi.table.HoodieTable;\n+import org.apache.hudi.table.action.cluster.strategy.ScheduleClusteringStrategy;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+import org.apache.spark.api.java.JavaRDD;\n+\n+import java.util.Map;\n+\n+@SuppressWarnings(\"checkstyle:LineLength\")\n+public class SparkScheduleClusteringActionExecutor<T extends HoodieRecordPayload> extends\n+    BaseScheduleClusteringActionExecutor<T, JavaRDD<HoodieRecord<T>>, JavaRDD<HoodieKey>, JavaRDD<WriteStatus>> {\n+\n+  private static final Logger LOG = LogManager.getLogger(SparkScheduleClusteringActionExecutor.class);\n+\n+  public SparkScheduleClusteringActionExecutor(HoodieEngineContext context,\n+                                               HoodieWriteConfig config,\n+                                               HoodieTable<T, JavaRDD<HoodieRecord<T>>, JavaRDD<HoodieKey>, JavaRDD<WriteStatus>> table,\n+                                               String instantTime,\n+                                               Option<Map<String, String>> extraMetadata) {\n+    super(context, config, table, instantTime, extraMetadata);\n+  }\n+\n+  @Override\n+  protected Option<HoodieClusteringPlan> scheduleClustering() {\n+    LOG.info(\"Checking if clustering needs to be run on \" + config.getBasePath());\n+    Option<HoodieInstant> lastClusteringInstant = table.getActiveTimeline().getCompletedReplaceTimeline().lastInstant();\n+\n+    int commitsSinceLastClustering = table.getActiveTimeline().getCommitsTimeline().filterCompletedInstants()\n+        .findInstantsAfter(lastClusteringInstant.map(HoodieInstant::getTimestamp).orElse(\"0\"), Integer.MAX_VALUE)\n+        .countInstants();\n+    if (config.getInlineClusterMaxCommits() > commitsSinceLastClustering) {", "originalCommit": "dc6d32154dacec181149e41d091a0854b662c362", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgyMTM0OQ==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r532821349", "bodyText": "I think this still makes sense for clustering too. Imagine, we are writing new data every 5minutes. It doesnt make sense to do file listing and figure out if theres enough data for clustering.  User knows there is enough data after N minutes, so they can select N/5 commits here.\nWe can also potentially move this to strategy specific implementation. But I do think most strategies will use this. Let me know if you want me to move this into strategy.", "author": "satishkotha", "createdAt": "2020-11-30T18:48:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODExMjExMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzYyMzQwOQ==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r533623409", "bodyText": "I think this is one more config for people to manage. Clustering use-case spans across many different angles, compacting small files into larger being just one of them. For compaction, since there aren't other use-cases, every N commit makes total sense. But the other side is to keep the same behaviors consistent across compaction and clustering so keeping this would provide users the same knobs.\nI'll let @vinothchandar take a call on this.", "author": "n3nash", "createdAt": "2020-12-01T18:17:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODExMjExMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODExNTYwMA==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r528115600", "bodyText": "So if there are N clustering groups consisting of M file groups that are being converted into O file groups, we will have N different RDD's. There are some performance limitation of unioning multiple different RDDs from what I remember. Can you run a simple test a) take 10000 records, parallelize them with jsc to create 1 RDD and then write them out to a file b) take 10000 records, create 1 RDD for each record and then union them and write them out to a single file ?", "author": "n3nash", "createdAt": "2020-11-21T07:21:32Z", "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/table/action/cluster/SparkRunClusteringCommitActionExecutor.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.table.action.cluster;\n+\n+import org.apache.avro.Schema;\n+import org.apache.avro.generic.IndexedRecord;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.avro.HoodieAvroUtils;\n+import org.apache.hudi.avro.model.HoodieClusteringGroup;\n+import org.apache.hudi.avro.model.HoodieClusteringPlan;\n+import org.apache.hudi.client.SparkTaskContextSupplier;\n+import org.apache.hudi.client.WriteStatus;\n+import org.apache.hudi.client.common.HoodieEngineContext;\n+import org.apache.hudi.client.common.HoodieSparkEngineContext;\n+import org.apache.hudi.common.model.HoodieCommitMetadata;\n+import org.apache.hudi.common.model.HoodieKey;\n+import org.apache.hudi.common.model.HoodieRecord;\n+import org.apache.hudi.common.model.HoodieRecordPayload;\n+import org.apache.hudi.common.model.WriteOperationType;\n+import org.apache.hudi.common.table.log.HoodieFileSliceReader;\n+import org.apache.hudi.common.table.log.HoodieMergedLogRecordScanner;\n+import org.apache.hudi.common.table.timeline.HoodieInstant;\n+import org.apache.hudi.common.table.timeline.HoodieTimeline;\n+import org.apache.hudi.common.util.ClusteringUtils;\n+import org.apache.hudi.common.util.CommitUtils;\n+import org.apache.hudi.common.util.Option;\n+import org.apache.hudi.common.util.ReflectionUtils;\n+import org.apache.hudi.common.util.collection.Pair;\n+import org.apache.hudi.config.HoodieWriteConfig;\n+import org.apache.hudi.exception.HoodieClusteringException;\n+import org.apache.hudi.io.IOUtils;\n+import org.apache.hudi.io.storage.HoodieFileReader;\n+import org.apache.hudi.io.storage.HoodieFileReaderFactory;\n+import org.apache.hudi.table.HoodieTable;\n+import org.apache.hudi.table.action.HoodieWriteMetadata;\n+import org.apache.hudi.table.action.cluster.strategy.RunClusteringStrategy;\n+import org.apache.hudi.table.action.commit.BaseSparkCommitActionExecutor;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+import org.apache.spark.api.java.JavaRDD;\n+import org.apache.spark.api.java.JavaSparkContext;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+public class SparkRunClusteringCommitActionExecutor<T extends HoodieRecordPayload<T>>\n+    extends BaseSparkCommitActionExecutor<T> {\n+\n+  private static final Logger LOG = LogManager.getLogger(SparkRunClusteringCommitActionExecutor.class);\n+  private final HoodieClusteringPlan clusteringPlan;\n+\n+  public SparkRunClusteringCommitActionExecutor(HoodieEngineContext context,\n+                                                HoodieWriteConfig config, HoodieTable table,\n+                                                String instantTime) {\n+    super(context, config, table, instantTime, WriteOperationType.CLUSTER);\n+    this.clusteringPlan = ClusteringUtils.getClusteringPlan(table.getMetaClient(), HoodieTimeline.getReplaceCommitRequestedInstant(instantTime))\n+      .map(Pair::getRight).orElseThrow(() -> new HoodieClusteringException(\"Unable to read clustering plan for instant: \" + instantTime));\n+  }\n+\n+  @Override\n+  public HoodieWriteMetadata<JavaRDD<WriteStatus>> execute() {\n+    HoodieInstant instant = HoodieTimeline.getReplaceCommitRequestedInstant(instantTime);\n+    // Mark instant as clustering inflight\n+    table.getActiveTimeline().transitionReplaceRequestedToInflight(instant, Option.empty());\n+    table.getMetaClient().reloadActiveTimeline();\n+\n+    JavaSparkContext engineContext = HoodieSparkEngineContext.getSparkContext(context);\n+    // read rdd from input groups in plan\n+    JavaRDD<WriteStatus> writeStatuses = clusteringPlan.getInputGroups().stream()\n+        .map(inputGroup -> runClusteringForGroup(inputGroup, clusteringPlan.getStrategy().getStrategyParams()))\n+        .reduce((rdd1, rdd2) -> engineContext.union(rdd1, rdd2)).orElse(engineContext.emptyRDD());\n+    if (writeStatuses.isEmpty()) {\n+      throw new HoodieClusteringException(\"Clustering plan produced 0 WriteStatus for \" + instantTime + \" #groups: \" + clusteringPlan.getInputGroups().size());\n+    }\n+    // merge all write status\n+    HoodieWriteMetadata<JavaRDD<WriteStatus>> writeMetadata = buildWriteMetadata(writeStatuses);\n+    updateIndexAndCommitIfNeeded(writeStatuses, writeMetadata);\n+    if (!writeMetadata.getCommitMetadata().isPresent()) {\n+      HoodieCommitMetadata commitMetadata = CommitUtils.buildMetadata(writeStatuses.map(WriteStatus::getStat).collect(), writeMetadata.getPartitionToReplaceFileIds(),\n+          extraMetadata, operationType, getSchemaToStoreInCommit(), getCommitActionType());\n+      writeMetadata.setCommitMetadata(Option.of(commitMetadata));\n+    }\n+    return writeMetadata;\n+  }\n+\n+  private JavaRDD<WriteStatus> runClusteringForGroup(HoodieClusteringGroup clusteringGroup, Map<String, String> strategyParams) {", "originalCommit": "dc6d32154dacec181149e41d091a0854b662c362", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgyNDIzNQ==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r532824235", "bodyText": "Is there an alternative to union? Should we collect individual RDD and merge lists? I did testing only with 2 groups so far. So, I didn't see big performance degradation. I'll look into testing large number of groups as separate task. (We may also don't want number of groups to be really high as we want clustering to be atomic operation. Doing large amount of data/groups can increase chance of failures and slow down entire process.)", "author": "satishkotha", "createdAt": "2020-11-30T18:53:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODExNTYwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzYyNjQ3OQ==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r533626479", "bodyText": "Yes, like we discussed offline, we should have a config to limit the number of clustering groups to avoid someone setting wrong configs for things like maxDataPerGroup and then result in a large number of RDDs to be unioned. I think we should still do a quick test to see if there is any degradation due to union before we land this diff so we are aware. It should be as simple as writing a test case that loops over code\nTestUnionPerformance\ntest for 10000 records\nlong startTime = System.currentMillis();\nRDD rdd = jsc.parallelize(Arrays.asList(record))\nfor (record in records)\n{\nrdd.union(jsc.parallelize(Arrays.asList(record)))\n}\nrdd.collect();\nwriteClient.bulkInsert(rdd);\nsout(\"time taken with union\" + System.currentMillis - starttime)\nlong startTime = System.currentMillis();\nRDD rdd = jsc.parallelize(records)\nrdd.collect();\nwriteClient.bulkInsert(rdd);\nsout(\"time taken without union\" + System.currentMillis - starttime)", "author": "n3nash", "createdAt": "2020-12-01T18:22:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODExNTYwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTU1NzQ3Mg==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r535557472", "bodyText": "Ok, Changed to limit max groups to 50 (thats where we see significant degradation). I only applied for this strategy (because reduce is inside strategy code).", "author": "satishkotha", "createdAt": "2020-12-03T20:15:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODExNTYwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODExNjUxNg==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r528116516", "bodyText": "Do we need this level of file readers in this part of the code ? Can we just call compactor.compact(context, compactionPlan, table, config, instantTime) ?", "author": "n3nash", "createdAt": "2020-11-21T07:22:49Z", "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/table/action/cluster/SparkRunClusteringCommitActionExecutor.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.table.action.cluster;\n+\n+import org.apache.avro.Schema;\n+import org.apache.avro.generic.IndexedRecord;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.avro.HoodieAvroUtils;\n+import org.apache.hudi.avro.model.HoodieClusteringGroup;\n+import org.apache.hudi.avro.model.HoodieClusteringPlan;\n+import org.apache.hudi.client.SparkTaskContextSupplier;\n+import org.apache.hudi.client.WriteStatus;\n+import org.apache.hudi.client.common.HoodieEngineContext;\n+import org.apache.hudi.client.common.HoodieSparkEngineContext;\n+import org.apache.hudi.common.model.HoodieCommitMetadata;\n+import org.apache.hudi.common.model.HoodieKey;\n+import org.apache.hudi.common.model.HoodieRecord;\n+import org.apache.hudi.common.model.HoodieRecordPayload;\n+import org.apache.hudi.common.model.WriteOperationType;\n+import org.apache.hudi.common.table.log.HoodieFileSliceReader;\n+import org.apache.hudi.common.table.log.HoodieMergedLogRecordScanner;\n+import org.apache.hudi.common.table.timeline.HoodieInstant;\n+import org.apache.hudi.common.table.timeline.HoodieTimeline;\n+import org.apache.hudi.common.util.ClusteringUtils;\n+import org.apache.hudi.common.util.CommitUtils;\n+import org.apache.hudi.common.util.Option;\n+import org.apache.hudi.common.util.ReflectionUtils;\n+import org.apache.hudi.common.util.collection.Pair;\n+import org.apache.hudi.config.HoodieWriteConfig;\n+import org.apache.hudi.exception.HoodieClusteringException;\n+import org.apache.hudi.io.IOUtils;\n+import org.apache.hudi.io.storage.HoodieFileReader;\n+import org.apache.hudi.io.storage.HoodieFileReaderFactory;\n+import org.apache.hudi.table.HoodieTable;\n+import org.apache.hudi.table.action.HoodieWriteMetadata;\n+import org.apache.hudi.table.action.cluster.strategy.RunClusteringStrategy;\n+import org.apache.hudi.table.action.commit.BaseSparkCommitActionExecutor;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+import org.apache.spark.api.java.JavaRDD;\n+import org.apache.spark.api.java.JavaSparkContext;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+public class SparkRunClusteringCommitActionExecutor<T extends HoodieRecordPayload<T>>\n+    extends BaseSparkCommitActionExecutor<T> {\n+\n+  private static final Logger LOG = LogManager.getLogger(SparkRunClusteringCommitActionExecutor.class);\n+  private final HoodieClusteringPlan clusteringPlan;\n+\n+  public SparkRunClusteringCommitActionExecutor(HoodieEngineContext context,\n+                                                HoodieWriteConfig config, HoodieTable table,\n+                                                String instantTime) {\n+    super(context, config, table, instantTime, WriteOperationType.CLUSTER);\n+    this.clusteringPlan = ClusteringUtils.getClusteringPlan(table.getMetaClient(), HoodieTimeline.getReplaceCommitRequestedInstant(instantTime))\n+      .map(Pair::getRight).orElseThrow(() -> new HoodieClusteringException(\"Unable to read clustering plan for instant: \" + instantTime));\n+  }\n+\n+  @Override\n+  public HoodieWriteMetadata<JavaRDD<WriteStatus>> execute() {\n+    HoodieInstant instant = HoodieTimeline.getReplaceCommitRequestedInstant(instantTime);\n+    // Mark instant as clustering inflight\n+    table.getActiveTimeline().transitionReplaceRequestedToInflight(instant, Option.empty());\n+    table.getMetaClient().reloadActiveTimeline();\n+\n+    JavaSparkContext engineContext = HoodieSparkEngineContext.getSparkContext(context);\n+    // read rdd from input groups in plan\n+    JavaRDD<WriteStatus> writeStatuses = clusteringPlan.getInputGroups().stream()\n+        .map(inputGroup -> runClusteringForGroup(inputGroup, clusteringPlan.getStrategy().getStrategyParams()))\n+        .reduce((rdd1, rdd2) -> engineContext.union(rdd1, rdd2)).orElse(engineContext.emptyRDD());\n+    if (writeStatuses.isEmpty()) {\n+      throw new HoodieClusteringException(\"Clustering plan produced 0 WriteStatus for \" + instantTime + \" #groups: \" + clusteringPlan.getInputGroups().size());\n+    }\n+    // merge all write status\n+    HoodieWriteMetadata<JavaRDD<WriteStatus>> writeMetadata = buildWriteMetadata(writeStatuses);\n+    updateIndexAndCommitIfNeeded(writeStatuses, writeMetadata);\n+    if (!writeMetadata.getCommitMetadata().isPresent()) {\n+      HoodieCommitMetadata commitMetadata = CommitUtils.buildMetadata(writeStatuses.map(WriteStatus::getStat).collect(), writeMetadata.getPartitionToReplaceFileIds(),\n+          extraMetadata, operationType, getSchemaToStoreInCommit(), getCommitActionType());\n+      writeMetadata.setCommitMetadata(Option.of(commitMetadata));\n+    }\n+    return writeMetadata;\n+  }\n+\n+  private JavaRDD<WriteStatus> runClusteringForGroup(HoodieClusteringGroup clusteringGroup, Map<String, String> strategyParams) {\n+    JavaSparkContext jsc = HoodieSparkEngineContext.getSparkContext(context);\n+    JavaRDD<HoodieRecord<? extends HoodieRecordPayload>> inputRecords = jsc.parallelize(clusteringGroup.getSlices(), clusteringGroup.getSlices().size()).map(sliceInfo -> {\n+      long maxMemoryPerCompaction = IOUtils.getMaxMemoryPerCompaction(new SparkTaskContextSupplier(), config.getProps());\n+      LOG.info(\"MaxMemoryPerCompaction run as part of clustering => \" + maxMemoryPerCompaction);\n+      try {\n+        Schema readerSchema = HoodieAvroUtils.addMetadataFields(new Schema.Parser().parse(config.getSchema()));\n+        HoodieFileReader<? extends IndexedRecord> baseFileReader = HoodieFileReaderFactory.getFileReader(table.getHadoopConf(), new Path(sliceInfo.getDataFilePath()));", "originalCommit": "dc6d32154dacec181149e41d091a0854b662c362", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgyOTM0NQ==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r532829345", "bodyText": "compactor.compact seems to write data into new files and returns WriteStatus. We then have to read data and use it for clustering. I think this additional is unnecessary.  Also, creating compactionplan for clustering looks like tight coupling to me. This is only few lines of code and abstractions look reasonable to me. Please take a look and let me know if you have any suggestions.", "author": "satishkotha", "createdAt": "2020-11-30T19:01:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODExNjUxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODIwNzAzOA==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r528207038", "bodyText": "hello , i am interesting  about the scenario to limit the partition num of clustering. does cluster all partitions have some problem?", "author": "lw309637554", "createdAt": "2020-11-21T15:16:05Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/config/HoodieClusteringConfig.java", "diffHunk": "@@ -0,0 +1,155 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.config;\n+\n+import org.apache.hudi.common.config.DefaultHoodieConfig;\n+\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.util.Properties;\n+\n+/**\n+ * Clustering specific configs.\n+ */\n+public class HoodieClusteringConfig extends DefaultHoodieConfig {\n+\n+  public static final String SCHEDULE_CLUSTERING_STRATEGY_CLASS = \"hoodie.clustering.schedule.strategy.class\";\n+  public static final String DEFAULT_SCHEDULE_CLUSTERING_STRATEGY_CLASS =\n+      \"org.apache.hudi.client.clustering.schedule.SparkBoundedDayBasedScheduleClusteringStrategy\";\n+\n+  public static final String RUN_CLUSTERING_STRATEGY_CLASS = \"hoodie.clustering.run.strategy.class\";\n+  public static final String DEFAULT_RUN_CLUSTERING_STRATEGY_CLASS =\n+      \"org.apache.hudi.client.clustering.run.SparkBulkInsertBasedRunClusteringStrategy\";\n+\n+  // Turn on inline clustering - after few commits a inline compaction will be run\n+  public static final String INLINE_CLUSTERING_PROP = \"hoodie.clustering.inline\";\n+  private static final String DEFAULT_INLINE_CLUSTERING = \"false\";\n+\n+  public static final String INLINE_CLUSTERING_NUM_COMMIT_PROP = \"hoodie.clustering.inline.num.commits\";\n+  private static final String DEFAULT_INLINE_CLUSTERING_NUM_COMMITS = \"4\";\n+\n+  public static final String CLUSTERING_TARGET_PARTITIONS = \"hoodie.clustering.target.partitions\";\n+  public static final String DEFAULT_CLUSTERING_TARGET_PARTITIONS = String.valueOf(2);", "originalCommit": "dc6d32154dacec181149e41d091a0854b662c362", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgzOTUyMQ==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r532839521", "bodyText": "I think we do file listing per partition in the first strategy implementation. So if you have lot of partitions, that can cause some degradation. I reached out on slack to help with testing. I sent you commands to run inline clustering. Will you be able to test this PR by setting this config to a large value?", "author": "satishkotha", "createdAt": "2020-11-30T19:19:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODIwNzAzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM1NTEwMw==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r539355103", "bodyText": "\"So if you have lot of partitions, that can cause some degradation\" will resolved in file listing  https://issues.apache.org/jira/browse/HUDI-1292?\ni am happy to test this scenario", "author": "lw309637554", "createdAt": "2020-12-09T14:32:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODIwNzAzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTkwODg1OQ==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r539908859", "bodyText": "Yes, that ticket can resolve issues to some extent. But, in some cases, there are large day based tables with 1000s of partitions. we probably dont want to scan all partitions in those cases. So i think its useful to have this config.", "author": "satishkotha", "createdAt": "2020-12-10T06:52:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODIwNzAzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM2NzA5Ng==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r545367096", "bodyText": "@lw309637554 let me know if you got a chance to test this scenario (or clustering in general)", "author": "satishkotha", "createdAt": "2020-12-17T20:00:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODIwNzAzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODIwNzg1OA==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r528207858", "bodyText": "The implement of buildClusteringGroupsForPartition method in SparkBoundedDayBasedScheduleClusteringStrategy. Get params about clustering from maxDataInGroup\u3001getWriteConfig().getClusteringTargetFileSize()\u3001getWriteConfig().getClusteringTargetFileSize(). Maybe other implement will need more params . Can we just abstract buildClusteringGroupsForPartition with the HoodieWriteConfig for param ?  maybe like :\nprotected abstract Stream buildClusteringGroupsForPartition(String partitionPath,\nList fileSlices,\nHoodieWriteConfig writeConfig);", "author": "lw309637554", "createdAt": "2020-11-21T15:24:36Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/table/action/cluster/strategy/PartitionAwareScheduleClusteringStrategy.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.table.action.cluster.strategy;\n+\n+import org.apache.hudi.avro.model.HoodieClusteringGroup;\n+import org.apache.hudi.avro.model.HoodieClusteringPlan;\n+import org.apache.hudi.avro.model.HoodieClusteringStrategy;\n+import org.apache.hudi.client.common.HoodieEngineContext;\n+import org.apache.hudi.common.fs.FSUtils;\n+import org.apache.hudi.common.model.FileSlice;\n+import org.apache.hudi.common.model.HoodieRecordPayload;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.util.Option;\n+import org.apache.hudi.config.HoodieWriteConfig;\n+import org.apache.hudi.exception.HoodieIOException;\n+import org.apache.hudi.table.HoodieTable;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ * Scheduling strategy with restriction that clustering groups can only contain files from same partition.\n+ */\n+public abstract class PartitionAwareScheduleClusteringStrategy<T extends HoodieRecordPayload,I,K,O> extends ScheduleClusteringStrategy<T,I,K,O> {\n+  private static final Logger LOG = LogManager.getLogger(PartitionAwareScheduleClusteringStrategy.class);\n+\n+  public PartitionAwareScheduleClusteringStrategy(HoodieTable table, HoodieEngineContext engineContext, HoodieWriteConfig writeConfig) {\n+    super(table, engineContext, writeConfig);\n+  }\n+\n+  /**\n+   * Create Clustering group based on files eligible for clustering in the partition.\n+   */\n+  protected abstract Stream<HoodieClusteringGroup> buildClusteringGroupsForPartition(String partitionPath,\n+                                                                                     List<FileSlice> fileSlices,\n+                                                                                     long maxDataInGroup);", "originalCommit": "dc6d32154dacec181149e41d091a0854b662c362", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgzOTgwNA==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r532839804", "bodyText": "Sure. Changed it to keep it more flexible.", "author": "satishkotha", "createdAt": "2020-11-30T19:19:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODIwNzg1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODIwODUxNg==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r528208516", "bodyText": "if use HoodieClusteringConfig.SORT_COLUMNS_PROPERTY in code  instead of import static better?", "author": "lw309637554", "createdAt": "2020-11-21T15:30:48Z", "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/client/clustering/run/SparkBulkInsertBasedRunClusteringStrategy.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.client.clustering.run;\n+\n+import org.apache.avro.Schema;\n+import org.apache.hudi.client.WriteStatus;\n+import org.apache.hudi.client.common.HoodieSparkEngineContext;\n+import org.apache.hudi.common.model.HoodieKey;\n+import org.apache.hudi.common.model.HoodieRecord;\n+import org.apache.hudi.common.model.HoodieRecordPayload;\n+import org.apache.hudi.common.util.Option;\n+import org.apache.hudi.config.HoodieWriteConfig;\n+import org.apache.hudi.execution.bulkinsert.RDDCustomColumnsSortPartitioner;\n+import org.apache.hudi.table.BulkInsertPartitioner;\n+import org.apache.hudi.table.HoodieSparkCopyOnWriteTable;\n+import org.apache.hudi.table.action.cluster.strategy.RunClusteringStrategy;\n+import org.apache.hudi.table.action.commit.SparkBulkInsertHelper;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+import org.apache.spark.api.java.JavaRDD;\n+\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import static org.apache.hudi.config.HoodieClusteringConfig.SORT_COLUMNS_PROPERTY;", "originalCommit": "dc6d32154dacec181149e41d091a0854b662c362", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg0MDQxNA==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r532840414", "bodyText": "for constants, we seem to be using static imports in many places. So I keep as is. Let me know if you have strong reason to avoid static imports.", "author": "satishkotha", "createdAt": "2020-11-30T19:20:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODIwODUxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODI3ODkxNg==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r528278916", "bodyText": "if we should  constraint the columns start of partitionpath and row_key. Or just auto fill the two columns? Because the records of same partition and row_key need in one file slice.", "author": "lw309637554", "createdAt": "2020-11-22T04:07:22Z", "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/execution/bulkinsert/RDDCustomColumnsSortPartitioner.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.execution.bulkinsert;\n+\n+import org.apache.avro.Schema;\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.hudi.common.model.HoodieRecord;\n+import org.apache.hudi.common.model.HoodieRecordPayload;\n+import org.apache.hudi.table.BulkInsertPartitioner;\n+import org.apache.spark.api.java.JavaRDD;\n+\n+/**\n+ * A partitioner that does sorting based on specified column values for each RDD partition.\n+ *\n+ * @param <T> HoodieRecordPayload type\n+ */\n+public class RDDCustomColumnsSortPartitioner<T extends HoodieRecordPayload>\n+    implements BulkInsertPartitioner<JavaRDD<HoodieRecord<T>>> {\n+\n+  private final String[] sortColumnNames;\n+  private final String schemaString;\n+\n+  public RDDCustomColumnsSortPartitioner(String[] columnNames, Schema schema) {\n+    this.sortColumnNames = columnNames;\n+    //TODO Schema is not serializable. So convert to String here. Figure out how to improve this\n+    this.schemaString = schema.toString();\n+  }\n+\n+  @Override\n+  public JavaRDD<HoodieRecord<T>> repartitionRecords(JavaRDD<HoodieRecord<T>> records,\n+                                                     int outputSparkPartitions) {\n+    final String[] sortColumns = this.sortColumnNames;", "originalCommit": "dc6d32154dacec181149e41d091a0854b662c362", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg0MTI0MQ==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r532841241", "bodyText": "I dont think we want to add this constraint. There are use cases where we want to sort data by other columns.", "author": "satishkotha", "createdAt": "2020-11-30T19:22:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODI3ODkxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODMyNDk0NA==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r528324944", "bodyText": "can we get pendingClusterFileGroupid  from getHoodieTable().getSliceView() just like getPendingCompactionOperations?", "author": "lw309637554", "createdAt": "2020-11-22T11:59:03Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/table/action/cluster/strategy/ScheduleClusteringStrategy.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.table.action.cluster.strategy;\n+\n+import org.apache.hudi.avro.model.HoodieClusteringPlan;\n+import org.apache.hudi.avro.model.HoodieSliceInfo;\n+import org.apache.hudi.client.common.HoodieEngineContext;\n+import org.apache.hudi.common.fs.FSUtils;\n+import org.apache.hudi.common.model.BaseFile;\n+import org.apache.hudi.common.model.FileSlice;\n+import org.apache.hudi.common.model.HoodieBaseFile;\n+import org.apache.hudi.common.model.HoodieFileGroupId;\n+import org.apache.hudi.common.model.HoodieLogFile;\n+import org.apache.hudi.common.model.HoodieRecordPayload;\n+import org.apache.hudi.common.table.view.SyncableFileSystemView;\n+import org.apache.hudi.common.util.ClusteringUtils;\n+import org.apache.hudi.common.util.Option;\n+import org.apache.hudi.config.HoodieWriteConfig;\n+import org.apache.hudi.table.HoodieTable;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import java.io.Serializable;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Pluggable implementation for scheduling clustering and creating ClusteringPlan.\n+ */\n+public abstract class ScheduleClusteringStrategy<T extends HoodieRecordPayload,I,K,O> implements Serializable {\n+  private static final Logger LOG = LogManager.getLogger(ScheduleClusteringStrategy.class);\n+\n+  public static final String TOTAL_IO_READ_MB = \"TOTAL_IO_READ_MB\";\n+  public static final String TOTAL_IO_WRITE_MB = \"TOTAL_IO_WRITE_MB\";\n+  public static final String TOTAL_IO_MB = \"TOTAL_IO_MB\";\n+  public static final String TOTAL_LOG_FILE_SIZE = \"TOTAL_LOG_FILES_SIZE\";\n+  public static final String TOTAL_LOG_FILES = \"TOTAL_LOG_FILES\";\n+\n+  public static final int CLUSTERING_PLAN_VERSION_1 = 1;\n+\n+  private final HoodieTable<T,I,K,O> hoodieTable;\n+  private final HoodieEngineContext engineContext;\n+  private final HoodieWriteConfig writeConfig;\n+\n+  public ScheduleClusteringStrategy(HoodieTable table, HoodieEngineContext engineContext, HoodieWriteConfig writeConfig) {\n+    this.writeConfig = writeConfig;\n+    this.hoodieTable = table;\n+    this.engineContext = engineContext;\n+  }\n+\n+  /**\n+   * Generate metadata for grouping eligible files and create a plan. Note that data is not moved around\n+   * as part of this step.\n+   *\n+   * If there is no data available to cluster, return None.\n+   */\n+  public abstract Option<HoodieClusteringPlan> generateClusteringPlan();\n+\n+  /**\n+   * Return file slices eligible for clustering. FileIds in\n+   * 1) pending clustering/compaction\n+   * 2) Larger than clustering target file size\n+   *\n+   * are not eligible for clustering\n+   */\n+  protected List<FileSlice> getFileSlicesEligibleForClustering(String partition) {\n+    Set<HoodieFileGroupId> fgIdsInPendingCompactionAndClustering = ((SyncableFileSystemView) getHoodieTable().getSliceView()).getPendingCompactionOperations()\n+        .map(instantTimeOpPair -> instantTimeOpPair.getValue().getFileGroupId())\n+        .collect(Collectors.toSet());\n+    fgIdsInPendingCompactionAndClustering.addAll(ClusteringUtils.getAllFileGroupsInPendingClusteringPlans(getHoodieTable().getMetaClient()).keySet());", "originalCommit": "dc6d32154dacec181149e41d091a0854b662c362", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg0MTQwNA==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r532841404", "bodyText": "Good catch. I changed it to get this data from view.", "author": "satishkotha", "createdAt": "2020-11-30T19:22:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODMyNDk0NA=="}], "type": "inlineReview"}, {"oid": "6e8ea212666c06840129aabcf292dad60b5f3885", "url": "https://github.com/apache/hudi/commit/6e8ea212666c06840129aabcf292dad60b5f3885", "message": "[HUDI-1075] Implement simple clustering strategies to create ClusteringPlan and to run the plan", "committedDate": "2020-11-30T18:26:52Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY1MzkzMA==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r533653930", "bodyText": "I have a suggestion to change the way we are generating the sort cols. Instead of performing this operation during write where the following code will spend cycles to convert data to generic record again, can we do this during read time when the HoodieRecord is being constructed ? I think you are using HoodieFileSliceReader and HoodieMergedRecordScanner to do this, does it make sense to add a sortKey to HoodieRecord and when you are constructing the hoodie record where you anyways have a handle to the generic record, you can just set that value in the hoodie record ? This will also help avoid passing schemas around for partitioner..\nThe downside of this approach is that the RDD bloats up so the shuffle will be larger so the question is whether that's worse or converting to generic record is worse from a CPU perspective", "author": "n3nash", "createdAt": "2020-12-01T19:06:25Z", "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/execution/bulkinsert/RDDCustomColumnsSortPartitioner.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.execution.bulkinsert;\n+\n+import org.apache.avro.Schema;\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.hudi.common.model.HoodieRecord;\n+import org.apache.hudi.common.model.HoodieRecordPayload;\n+import org.apache.hudi.table.BulkInsertPartitioner;\n+import org.apache.spark.api.java.JavaRDD;\n+\n+/**\n+ * A partitioner that does sorting based on specified column values for each RDD partition.\n+ *\n+ * @param <T> HoodieRecordPayload type\n+ */\n+public class RDDCustomColumnsSortPartitioner<T extends HoodieRecordPayload>\n+    implements BulkInsertPartitioner<JavaRDD<HoodieRecord<T>>> {\n+\n+  private final String[] sortColumnNames;\n+  private final String schemaString;\n+\n+  public RDDCustomColumnsSortPartitioner(String[] columnNames, Schema schema) {\n+    this.sortColumnNames = columnNames;\n+    //TODO Schema is not serializable. So convert to String here. Figure out how to improve this\n+    this.schemaString = schema.toString();\n+  }\n+\n+  @Override\n+  public JavaRDD<HoodieRecord<T>> repartitionRecords(JavaRDD<HoodieRecord<T>> records,\n+                                                     int outputSparkPartitions) {\n+    final String[] sortColumns = this.sortColumnNames;\n+    final String schemaStr = this.schemaString;\n+    return records.sortBy(record -> {", "originalCommit": "6e8ea212666c06840129aabcf292dad60b5f3885", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTYwMjczMA==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r535602730", "bodyText": "I like this suggestion. This 'sortColumn' is probably needed only for this 'BulkInsert' based clustering strategy.  So, just want to make sure its ok to add new fields in HoodieRecord even though this is needed only for one usecase.  If you think thats acceptable, I'll make the change. Let me know.", "author": "satishkotha", "createdAt": "2020-12-03T20:55:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY1MzkzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTYzNDY0Mw==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r535634643", "bodyText": "@satishkotha Do we know the overhead of converting schemaString to schema and generic record ?", "author": "n3nash", "createdAt": "2020-12-03T21:22:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY1MzkzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTY0MDg0MQ==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r535640841", "bodyText": "@n3nash I dont have numbers for this. I'll add metrics and calculate this. If you have any details from past examples, let me know", "author": "satishkotha", "createdAt": "2020-12-03T21:28:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY1MzkzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY1NTkyNw==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r533655927", "bodyText": "The merged record scanner will try to keep an in-memory map, can we optimize for cases when there are no log files ? Or am I missing where this is done for COW / MOR where we are only reading parquet files ?", "author": "n3nash", "createdAt": "2020-12-01T19:10:01Z", "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/table/action/cluster/SparkRunClusteringCommitActionExecutor.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.table.action.cluster;\n+\n+import org.apache.avro.Schema;\n+import org.apache.avro.generic.IndexedRecord;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.avro.HoodieAvroUtils;\n+import org.apache.hudi.avro.model.HoodieClusteringGroup;\n+import org.apache.hudi.avro.model.HoodieClusteringPlan;\n+import org.apache.hudi.client.SparkTaskContextSupplier;\n+import org.apache.hudi.client.WriteStatus;\n+import org.apache.hudi.client.common.HoodieEngineContext;\n+import org.apache.hudi.client.common.HoodieSparkEngineContext;\n+import org.apache.hudi.common.model.HoodieCommitMetadata;\n+import org.apache.hudi.common.model.HoodieKey;\n+import org.apache.hudi.common.model.HoodieRecord;\n+import org.apache.hudi.common.model.HoodieRecordPayload;\n+import org.apache.hudi.common.model.WriteOperationType;\n+import org.apache.hudi.common.table.log.HoodieFileSliceReader;\n+import org.apache.hudi.common.table.log.HoodieMergedLogRecordScanner;\n+import org.apache.hudi.common.table.timeline.HoodieInstant;\n+import org.apache.hudi.common.table.timeline.HoodieTimeline;\n+import org.apache.hudi.common.util.ClusteringUtils;\n+import org.apache.hudi.common.util.CommitUtils;\n+import org.apache.hudi.common.util.Option;\n+import org.apache.hudi.common.util.ReflectionUtils;\n+import org.apache.hudi.common.util.collection.Pair;\n+import org.apache.hudi.config.HoodieWriteConfig;\n+import org.apache.hudi.exception.HoodieClusteringException;\n+import org.apache.hudi.io.IOUtils;\n+import org.apache.hudi.io.storage.HoodieFileReader;\n+import org.apache.hudi.io.storage.HoodieFileReaderFactory;\n+import org.apache.hudi.table.HoodieTable;\n+import org.apache.hudi.table.action.HoodieWriteMetadata;\n+import org.apache.hudi.table.action.cluster.strategy.RunClusteringStrategy;\n+import org.apache.hudi.table.action.commit.BaseSparkCommitActionExecutor;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+import org.apache.spark.api.java.JavaRDD;\n+import org.apache.spark.api.java.JavaSparkContext;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.stream.Collectors;\n+\n+public class SparkRunClusteringCommitActionExecutor<T extends HoodieRecordPayload<T>>\n+    extends BaseSparkCommitActionExecutor<T> {\n+\n+  private static final Logger LOG = LogManager.getLogger(SparkRunClusteringCommitActionExecutor.class);\n+  private final HoodieClusteringPlan clusteringPlan;\n+\n+  public SparkRunClusteringCommitActionExecutor(HoodieEngineContext context,\n+                                                HoodieWriteConfig config, HoodieTable table,\n+                                                String instantTime) {\n+    super(context, config, table, instantTime, WriteOperationType.CLUSTER);\n+    this.clusteringPlan = ClusteringUtils.getClusteringPlan(table.getMetaClient(), HoodieTimeline.getReplaceCommitRequestedInstant(instantTime))\n+      .map(Pair::getRight).orElseThrow(() -> new HoodieClusteringException(\"Unable to read clustering plan for instant: \" + instantTime));\n+  }\n+\n+  @Override\n+  public HoodieWriteMetadata<JavaRDD<WriteStatus>> execute() {\n+    HoodieInstant instant = HoodieTimeline.getReplaceCommitRequestedInstant(instantTime);\n+    // Mark instant as clustering inflight\n+    table.getActiveTimeline().transitionReplaceRequestedToInflight(instant, Option.empty());\n+    table.getMetaClient().reloadActiveTimeline();\n+\n+    JavaSparkContext engineContext = HoodieSparkEngineContext.getSparkContext(context);\n+    // run clustering for each group async and collect WriteStatus\n+    JavaRDD<WriteStatus> writeStatusRDD = clusteringPlan.getInputGroups().stream()\n+        .map(inputGroup -> runClusteringForGroupAsync(inputGroup, clusteringPlan.getStrategy().getStrategyParams()))\n+        .map(CompletableFuture::join)\n+        .reduce((rdd1, rdd2) -> rdd1.union(rdd2)).orElse(engineContext.emptyRDD());\n+    if (writeStatusRDD.isEmpty()) {\n+      throw new HoodieClusteringException(\"Clustering plan produced 0 WriteStatus for \" + instantTime + \" #groups: \" + clusteringPlan.getInputGroups().size());\n+    }\n+\n+    HoodieWriteMetadata<JavaRDD<WriteStatus>> writeMetadata = buildWriteMetadata(writeStatusRDD);\n+    updateIndexAndCommitIfNeeded(writeStatusRDD, writeMetadata);\n+    if (!writeMetadata.getCommitMetadata().isPresent()) {\n+      HoodieCommitMetadata commitMetadata = CommitUtils.buildMetadata(writeStatusRDD.map(WriteStatus::getStat).collect(), writeMetadata.getPartitionToReplaceFileIds(),\n+          extraMetadata, operationType, getSchemaToStoreInCommit(), getCommitActionType());\n+      writeMetadata.setCommitMetadata(Option.of(commitMetadata));\n+    }\n+    return writeMetadata;\n+  }\n+\n+  private CompletableFuture<JavaRDD<WriteStatus>> runClusteringForGroupAsync(HoodieClusteringGroup clusteringGroup, Map<String, String> strategyParams) {\n+    CompletableFuture<JavaRDD<WriteStatus>> writeStatusesFuture = CompletableFuture.supplyAsync(() -> {\n+      JavaSparkContext jsc = HoodieSparkEngineContext.getSparkContext(context);\n+      JavaRDD<HoodieRecord<? extends HoodieRecordPayload>> inputRecords = jsc.parallelize(clusteringGroup.getSlices(), clusteringGroup.getSlices().size()).map(sliceInfo -> {\n+        long maxMemoryPerCompaction = IOUtils.getMaxMemoryPerCompaction(new SparkTaskContextSupplier(), config.getProps());\n+        LOG.info(\"MaxMemoryPerCompaction run as part of clustering => \" + maxMemoryPerCompaction);\n+        try {\n+          Schema readerSchema = HoodieAvroUtils.addMetadataFields(new Schema.Parser().parse(config.getSchema()));\n+          HoodieFileReader<? extends IndexedRecord> baseFileReader = HoodieFileReaderFactory.getFileReader(table.getHadoopConf(), new Path(sliceInfo.getDataFilePath()));\n+          HoodieMergedLogRecordScanner scanner = new HoodieMergedLogRecordScanner(table.getMetaClient().getFs(),", "originalCommit": "6e8ea212666c06840129aabcf292dad60b5f3885", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTU2MTE5OA==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r535561198", "bodyText": "I initially had implemented separate for COW/MOR. But it did not result in significant difference in performance in terms of run time. Memory utilization is definitely more with log files. But since we have memory limit configuration, to keep it simple, I just added one path that works for both COW/MOR.\nI brought back earlier implementation. Take a look. If you think thats not complex, we can keep both.", "author": "satishkotha", "createdAt": "2020-12-03T20:18:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY1NTkyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTY1Mjg2Mg==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r535652862", "bodyText": "@satishkotha I see the new one looks messy, if the runtime/difference in performance is the same for MergedScanner and no memory overhead of FileSlices without any log files, let's keep your other implementation with MergedScanner for both. Added 1 comment on the FileSliceReader", "author": "n3nash", "createdAt": "2020-12-03T21:40:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY1NTkyNw=="}], "type": "inlineReview"}, {"oid": "2f632f1f049281d2e3e4ad18a1d2217b3c7bdd1c", "url": "https://github.com/apache/hudi/commit/2f632f1f049281d2e3e4ad18a1d2217b3c7bdd1c", "message": "[HUDI-1075] Implement simple clustering strategies to create ClusteringPlan and to run the plan", "committedDate": "2020-12-03T08:28:42Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTY1MTU0MQ==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r535651541", "bodyText": "Should we make this AbstractLogRecordScanner to allow for UnMergedScanner as well ? @satishkotha", "author": "n3nash", "createdAt": "2020-12-03T21:39:38Z", "path": "hudi-common/src/main/java/org/apache/hudi/common/table/log/HoodieFileSliceReader.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.common.table.log;\n+\n+import org.apache.avro.Schema;\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.avro.generic.IndexedRecord;\n+import org.apache.hudi.common.model.HoodieRecord;\n+import org.apache.hudi.common.model.HoodieRecordPayload;\n+import org.apache.hudi.common.util.SpillableMapUtils;\n+import org.apache.hudi.io.storage.HoodieFileReader;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Iterator;\n+\n+/**\n+ * Reads records from base file and merges any updates from log files and provides iterable over all records in the file slice.\n+ */\n+public class HoodieFileSliceReader implements Iterable<HoodieRecord<? extends HoodieRecordPayload>> {\n+  private HoodieMergedLogRecordScanner logRecordScanner;\n+\n+  public static <R extends IndexedRecord, T extends HoodieRecordPayload> HoodieFileSliceReader getFileSliceReader(\n+      HoodieFileReader<R> baseFileReader, HoodieMergedLogRecordScanner scanner, Schema schema, String payloadClass) throws IOException {", "originalCommit": "2f632f1f049281d2e3e4ad18a1d2217b3c7bdd1c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTY2ODU1NQ==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r535668555", "bodyText": "UnmergedScanner doesnt seem to have a way to get record iterator. This requires lot more refactoring if we want to make it work for both.", "author": "satishkotha", "createdAt": "2020-12-03T21:55:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTY1MTU0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTcyMzc0Mg==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r535723742", "bodyText": "Hmm, okay, in that case, can we keep the method signature of FileSliceReader as iterator rather than scanner so that way the FileSliceReader is generic and then we can figure out how to make those record scanner changes later ?\n@satishkotha", "author": "n3nash", "createdAt": "2020-12-03T23:32:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTY1MTU0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkzNDg2Mg==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r538934862", "bodyText": "We also need process method in LogRecordScanner. So I kept this 'factory' method as is. But changed HoodieFileSliceReader constructor to take records. We can implement another factory method for UnmergedScanner. PTAL.", "author": "satishkotha", "createdAt": "2020-12-09T01:28:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTY1MTU0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTAxNjI0Mw==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r539016243", "bodyText": "@satishkotha We cannot use the scanner.getRecords() API, that will bring all the records into memory and cause the job to OOM. Let's just continue to return the iterator and then lazily fetch records as you iterate.", "author": "n3nash", "createdAt": "2020-12-09T05:28:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTY1MTU0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA0MTM5Ng==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r539041396", "bodyText": "@n3nash getRecords just retruns 'ExternalSpillableMap'. So i dont think it can cause OOM. Anyway, changed it to iterator to keep it similar to reading records from base files.", "author": "satishkotha", "createdAt": "2020-12-09T06:25:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTY1MTU0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjEyNTg2Nw==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r546125867", "bodyText": "Nonetheless we should file a code cleanup JIRA to provide these iterators as core building blocks under a nice abstractions.", "author": "vinothchandar", "createdAt": "2020-12-18T22:45:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTY1MTU0MQ=="}], "type": "inlineReview"}, {"oid": "3f5a847f93e6af8733f5e53ee3ac26863ee2c3ea", "url": "https://github.com/apache/hudi/commit/3f5a847f93e6af8733f5e53ee3ac26863ee2c3ea", "message": "[HUDI-1075] Implement simple clustering strategies to create ClusteringPlan and to run the plan", "committedDate": "2020-12-03T21:39:35Z", "type": "forcePushed"}, {"oid": "3d52938150d46d25895d734b64dcc4b51c79a1e5", "url": "https://github.com/apache/hudi/commit/3d52938150d46d25895d734b64dcc4b51c79a1e5", "message": "[HUDI-1075] Implement simple clustering strategies to create ClusteringPlan and to run the plan", "committedDate": "2020-12-03T22:51:09Z", "type": "forcePushed"}, {"oid": "a4c469f17880f3b7fd7255b362ab0291db69bdf0", "url": "https://github.com/apache/hudi/commit/a4c469f17880f3b7fd7255b362ab0291db69bdf0", "message": "[HUDI-1075] Implement simple clustering strategies to create ClusteringPlan and to run the plan", "committedDate": "2020-12-03T22:59:12Z", "type": "forcePushed"}, {"oid": "dc13795bbdb7aa0a26bdb9e17f293a337e8efc09", "url": "https://github.com/apache/hudi/commit/dc13795bbdb7aa0a26bdb9e17f293a337e8efc09", "message": "[HUDI-1075] Implement simple clustering strategies to create ClusteringPlan and to run the plan", "committedDate": "2020-12-03T23:18:40Z", "type": "forcePushed"}, {"oid": "5a1e16233ea944237f55e522fae8cf70b4c041a7", "url": "https://github.com/apache/hudi/commit/5a1e16233ea944237f55e522fae8cf70b4c041a7", "message": "[HUDI-1075] Implement simple clustering strategies to create ClusteringPlan and to run the plan", "committedDate": "2020-12-09T01:28:08Z", "type": "forcePushed"}, {"oid": "f526c2c0eed8134aa513898ba48ef8ddf851272c", "url": "https://github.com/apache/hudi/commit/f526c2c0eed8134aa513898ba48ef8ddf851272c", "message": "[HUDI-1075] Implement simple clustering strategies to create ClusteringPlan and to run the plan", "committedDate": "2020-12-09T06:14:09Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg1OTMzNA==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r544859334", "bodyText": "lets please add java docs for all these configs?", "author": "vinothchandar", "createdAt": "2020-12-17T07:10:56Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/config/HoodieClusteringConfig.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.config;\n+\n+import org.apache.hudi.common.config.DefaultHoodieConfig;\n+\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.util.Properties;\n+\n+/**\n+ * Clustering specific configs.\n+ */\n+public class HoodieClusteringConfig extends DefaultHoodieConfig {\n+\n+  public static final String ASYNC_CLUSTERING_ENABLED = \"hoodie.clustering.enabled\";\n+  public static final String DEFAULT_ASYNC_CLUSTERING_ENABLED = \"false\";\n+\n+  public static final String SCHEDULE_CLUSTERING_STRATEGY_CLASS = \"hoodie.clustering.schedule.strategy.class\";\n+  public static final String DEFAULT_SCHEDULE_CLUSTERING_STRATEGY_CLASS =\n+      \"org.apache.hudi.client.clustering.schedule.strategy.SparkBoundedDayBasedScheduleClusteringStrategy\";\n+\n+  public static final String RUN_CLUSTERING_STRATEGY_CLASS = \"hoodie.clustering.run.strategy.class\";\n+  public static final String DEFAULT_RUN_CLUSTERING_STRATEGY_CLASS =\n+      \"org.apache.hudi.client.clustering.run.strategy.SparkBulkInsertBasedRunClusteringStrategy\";\n+\n+  // Turn on inline clustering - after few commits an inline clustering will be run\n+  public static final String INLINE_CLUSTERING_PROP = \"hoodie.clustering.inline\";\n+  private static final String DEFAULT_INLINE_CLUSTERING = \"false\";\n+\n+  public static final String INLINE_CLUSTERING_NUM_COMMIT_PROP = \"hoodie.clustering.inline.num.commits\";", "originalCommit": "f526c2c0eed8134aa513898ba48ef8ddf851272c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU1MzMwNQ==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r545553305", "bodyText": "Added", "author": "satishkotha", "createdAt": "2020-12-18T03:40:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg1OTMzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg2MjM2Nw==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r544862367", "bodyText": "make this more readable, by putting each param on a line like before?", "author": "vinothchandar", "createdAt": "2020-12-17T07:18:02Z", "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/table/action/commit/SparkBulkInsertHelper.java", "diffHunk": "@@ -59,25 +58,39 @@ public static SparkBulkInsertHelper newInstance() {\n   }\n \n   @Override\n-  public HoodieWriteMetadata<JavaRDD<WriteStatus>> bulkInsert(JavaRDD<HoodieRecord<T>> inputRecords,\n-                                                              String instantTime,\n-                                                              HoodieTable<T, JavaRDD<HoodieRecord<T>>, JavaRDD<HoodieKey>, JavaRDD<WriteStatus>> table,\n-                                                              HoodieWriteConfig config,\n-                                                              BaseCommitActionExecutor<T, JavaRDD<HoodieRecord<T>>, JavaRDD<HoodieKey>, JavaRDD<WriteStatus>, R> executor,\n-                                                              boolean performDedupe,\n-                                                              Option<BulkInsertPartitioner<T>> userDefinedBulkInsertPartitioner) {\n+  public HoodieWriteMetadata<JavaRDD<WriteStatus>> bulkInsert(final JavaRDD<HoodieRecord<T>> inputRecords, final String instantTime, final HoodieTable<T, JavaRDD<HoodieRecord<T>>, JavaRDD<HoodieKey>, JavaRDD<WriteStatus>> table, final HoodieWriteConfig config, final BaseCommitActionExecutor<T, JavaRDD<HoodieRecord<T>>, JavaRDD<HoodieKey>, JavaRDD<WriteStatus>, R> executor, final boolean performDedupe, final Option<BulkInsertPartitioner<T>> userDefinedBulkInsertPartitioner) {", "originalCommit": "f526c2c0eed8134aa513898ba48ef8ddf851272c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU1MzM2NA==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r545553364", "bodyText": "Done", "author": "satishkotha", "createdAt": "2020-12-18T03:40:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg2MjM2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTAzNzE0NQ==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r545037145", "bodyText": "should this be called replaceTimer as well?", "author": "vinothchandar", "createdAt": "2020-12-17T12:02:13Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/metrics/HoodieMetrics.java", "diffHunk": "@@ -48,6 +49,7 @@\n   private Timer deltaCommitTimer = null;\n   private Timer finalizeTimer = null;\n   private Timer compactionTimer = null;\n+  private Timer clusteringTimer = null;", "originalCommit": "f526c2c0eed8134aa513898ba48ef8ddf851272c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU1Mzc4Mg==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r545553782", "bodyText": "This is specific to clustering operation and only used in WriteClient#cluster.\nWe could have a different timer for insertOverwrite and replace commands if needed. I like this approach because replace can mean multiple things. Let me know if you think common timer makes more sense.", "author": "satishkotha", "createdAt": "2020-12-18T03:42:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTAzNzE0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTA0NDk5MA==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r545044990", "bodyText": "I think we should have 50 as the default value for this config and allow any value to passed in, as opposed to having this limit hard-coded.", "author": "vinothchandar", "createdAt": "2020-12-17T12:15:51Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/table/action/cluster/strategy/PartitionAwareScheduleClusteringStrategy.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.table.action.cluster.strategy;\n+\n+import org.apache.hudi.avro.model.HoodieClusteringGroup;\n+import org.apache.hudi.avro.model.HoodieClusteringPlan;\n+import org.apache.hudi.avro.model.HoodieClusteringStrategy;\n+import org.apache.hudi.client.common.HoodieEngineContext;\n+import org.apache.hudi.common.fs.FSUtils;\n+import org.apache.hudi.common.model.FileSlice;\n+import org.apache.hudi.common.model.HoodieRecordPayload;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.util.Option;\n+import org.apache.hudi.config.HoodieWriteConfig;\n+import org.apache.hudi.exception.HoodieIOException;\n+import org.apache.hudi.table.HoodieTable;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ * Scheduling strategy with restriction that clustering groups can only contain files from same partition.\n+ */\n+public abstract class PartitionAwareScheduleClusteringStrategy<T extends HoodieRecordPayload,I,K,O> extends ScheduleClusteringStrategy<T,I,K,O> {\n+  private static final Logger LOG = LogManager.getLogger(PartitionAwareScheduleClusteringStrategy.class);\n+  // With more than 50 groups, we see performance degradation with this Strategy implementation.\n+  private static final int MAX_CLUSTERING_GROUPS_STRATEGY = 50;\n+\n+  public PartitionAwareScheduleClusteringStrategy(HoodieTable table, HoodieEngineContext engineContext, HoodieWriteConfig writeConfig) {\n+    super(table, engineContext, writeConfig);\n+  }\n+\n+  /**\n+   * Create Clustering group based on files eligible for clustering in the partition.\n+   */\n+  protected abstract Stream<HoodieClusteringGroup> buildClusteringGroupsForPartition(String partitionPath,\n+                                                                                     List<FileSlice> fileSlices);\n+\n+  /**\n+   * Return list of partition paths to be considered for clustering.\n+   */\n+  protected List<String> filterPartitionPaths(List<String> partitionPaths) {\n+    return partitionPaths;\n+  }\n+\n+  @Override\n+  public Option<HoodieClusteringPlan> generateClusteringPlan() {\n+    try {\n+      HoodieTableMetaClient metaClient = getHoodieTable().getMetaClient();\n+      LOG.info(\"Scheduling clustering for \" + metaClient.getBasePath());\n+      List<String> partitionPaths = FSUtils.getAllPartitionPaths(metaClient.getFs(), metaClient.getBasePath(),\n+          getWriteConfig().shouldAssumeDatePartitioning());\n+\n+      // filter the partition paths if needed to reduce list status\n+      partitionPaths = filterPartitionPaths(partitionPaths);\n+\n+      if (partitionPaths.isEmpty()) {\n+        // In case no partitions could be picked, return no clustering plan\n+        return Option.empty();\n+      }\n+\n+      long maxClusteringGroups = getWriteConfig().getClusteringMaxNumGroups();", "originalCommit": "f526c2c0eed8134aa513898ba48ef8ddf851272c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU1MzgwNw==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r545553807", "bodyText": "Fixed.", "author": "satishkotha", "createdAt": "2020-12-18T03:42:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTA0NDk5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTA0NTk3Ng==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r545045976", "bodyText": "why not try to do this in parallel using context.map() etc? it should improve performance as well", "author": "vinothchandar", "createdAt": "2020-12-17T12:17:34Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/table/action/cluster/strategy/PartitionAwareScheduleClusteringStrategy.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.table.action.cluster.strategy;\n+\n+import org.apache.hudi.avro.model.HoodieClusteringGroup;\n+import org.apache.hudi.avro.model.HoodieClusteringPlan;\n+import org.apache.hudi.avro.model.HoodieClusteringStrategy;\n+import org.apache.hudi.client.common.HoodieEngineContext;\n+import org.apache.hudi.common.fs.FSUtils;\n+import org.apache.hudi.common.model.FileSlice;\n+import org.apache.hudi.common.model.HoodieRecordPayload;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.util.Option;\n+import org.apache.hudi.config.HoodieWriteConfig;\n+import org.apache.hudi.exception.HoodieIOException;\n+import org.apache.hudi.table.HoodieTable;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ * Scheduling strategy with restriction that clustering groups can only contain files from same partition.\n+ */\n+public abstract class PartitionAwareScheduleClusteringStrategy<T extends HoodieRecordPayload,I,K,O> extends ScheduleClusteringStrategy<T,I,K,O> {\n+  private static final Logger LOG = LogManager.getLogger(PartitionAwareScheduleClusteringStrategy.class);\n+  // With more than 50 groups, we see performance degradation with this Strategy implementation.\n+  private static final int MAX_CLUSTERING_GROUPS_STRATEGY = 50;\n+\n+  public PartitionAwareScheduleClusteringStrategy(HoodieTable table, HoodieEngineContext engineContext, HoodieWriteConfig writeConfig) {\n+    super(table, engineContext, writeConfig);\n+  }\n+\n+  /**\n+   * Create Clustering group based on files eligible for clustering in the partition.\n+   */\n+  protected abstract Stream<HoodieClusteringGroup> buildClusteringGroupsForPartition(String partitionPath,\n+                                                                                     List<FileSlice> fileSlices);\n+\n+  /**\n+   * Return list of partition paths to be considered for clustering.\n+   */\n+  protected List<String> filterPartitionPaths(List<String> partitionPaths) {\n+    return partitionPaths;\n+  }\n+\n+  @Override\n+  public Option<HoodieClusteringPlan> generateClusteringPlan() {\n+    try {\n+      HoodieTableMetaClient metaClient = getHoodieTable().getMetaClient();\n+      LOG.info(\"Scheduling clustering for \" + metaClient.getBasePath());\n+      List<String> partitionPaths = FSUtils.getAllPartitionPaths(metaClient.getFs(), metaClient.getBasePath(),\n+          getWriteConfig().shouldAssumeDatePartitioning());\n+\n+      // filter the partition paths if needed to reduce list status\n+      partitionPaths = filterPartitionPaths(partitionPaths);\n+\n+      if (partitionPaths.isEmpty()) {\n+        // In case no partitions could be picked, return no clustering plan\n+        return Option.empty();\n+      }\n+\n+      long maxClusteringGroups = getWriteConfig().getClusteringMaxNumGroups();\n+      if (maxClusteringGroups > MAX_CLUSTERING_GROUPS_STRATEGY) {\n+        LOG.warn(\"Reducing max clustering groups to \" + MAX_CLUSTERING_GROUPS_STRATEGY + \" for performance reasons\");\n+        maxClusteringGroups = MAX_CLUSTERING_GROUPS_STRATEGY;\n+      }\n+\n+      List<HoodieClusteringGroup> clusteringGroups = partitionPaths.stream()", "originalCommit": "f526c2c0eed8134aa513898ba48ef8ddf851272c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU1Mzg1OQ==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r545553859", "bodyText": "Updated.", "author": "satishkotha", "createdAt": "2020-12-18T03:42:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTA0NTk3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTA1NDc1OA==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r545054758", "bodyText": "is this like a group number? Seems more like the number of output files produced by that group", "author": "vinothchandar", "createdAt": "2020-12-17T12:32:26Z", "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/client/clustering/schedule/strategy/SparkBoundedDayBasedScheduleClusteringStrategy.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.client.clustering.schedule.strategy;\n+\n+import org.apache.hudi.avro.model.HoodieClusteringGroup;\n+import org.apache.hudi.client.WriteStatus;\n+import org.apache.hudi.client.common.HoodieSparkEngineContext;\n+import org.apache.hudi.common.model.FileSlice;\n+import org.apache.hudi.common.model.HoodieKey;\n+import org.apache.hudi.common.model.HoodieRecord;\n+import org.apache.hudi.common.model.HoodieRecordPayload;\n+import org.apache.hudi.common.util.collection.Pair;\n+import org.apache.hudi.config.HoodieWriteConfig;\n+import org.apache.hudi.table.HoodieSparkCopyOnWriteTable;\n+import org.apache.hudi.table.HoodieSparkMergeOnReadTable;\n+import org.apache.hudi.table.action.cluster.strategy.PartitionAwareScheduleClusteringStrategy;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+import org.apache.spark.api.java.JavaRDD;\n+\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.apache.hudi.config.HoodieClusteringConfig.SORT_COLUMNS_PROPERTY;\n+\n+/**\n+ * Clustering Strategy based on following.\n+ * 1) Spark execution engine.\n+ * 2) Limits amount of data per clustering operation.\n+ */\n+public class SparkBoundedDayBasedScheduleClusteringStrategy<T extends HoodieRecordPayload<T>>\n+    extends PartitionAwareScheduleClusteringStrategy<T, JavaRDD<HoodieRecord<T>>, JavaRDD<HoodieKey>, JavaRDD<WriteStatus>> {\n+  private static final Logger LOG = LogManager.getLogger(SparkBoundedDayBasedScheduleClusteringStrategy.class);\n+\n+  public SparkBoundedDayBasedScheduleClusteringStrategy(HoodieSparkCopyOnWriteTable<T> table,\n+                                                        HoodieSparkEngineContext engineContext,\n+                                                        HoodieWriteConfig writeConfig) {\n+    super(table, engineContext, writeConfig);\n+  }\n+\n+  public SparkBoundedDayBasedScheduleClusteringStrategy(HoodieSparkMergeOnReadTable<T> table,\n+                                                        HoodieSparkEngineContext engineContext,\n+                                                        HoodieWriteConfig writeConfig) {\n+    super(table, engineContext, writeConfig);\n+  }\n+\n+  @Override\n+  protected Stream<HoodieClusteringGroup> buildClusteringGroupsForPartition(String partitionPath, List<FileSlice> fileSlices) {\n+    List<Pair<List<FileSlice>, Integer>> fileSliceGroups = new ArrayList<>();\n+    List<FileSlice> currentGroup = new ArrayList<>();\n+    int totalSizeSoFar = 0;\n+    for (FileSlice currentSlice : fileSlices) {\n+      // assume each filegroup size is ~= parquet.max.file.size\n+      totalSizeSoFar += currentSlice.getBaseFile().isPresent() ? currentSlice.getBaseFile().get().getFileSize() : getWriteConfig().getParquetMaxFileSize();\n+      // check if max size is reached and create new group, if needed.\n+      if (totalSizeSoFar >= getWriteConfig().getClusteringMaxBytesInGroup() && !currentGroup.isEmpty()) {\n+        fileSliceGroups.add(Pair.of(currentGroup, getNumberOfGroups(totalSizeSoFar, getWriteConfig().getClusteringTargetFileMaxBytes())));\n+        currentGroup = new ArrayList<>();\n+        totalSizeSoFar = 0;\n+      }\n+      currentGroup.add(currentSlice);\n+    }\n+    if (!currentGroup.isEmpty()) {\n+      fileSliceGroups.add(Pair.of(currentGroup, getNumberOfGroups(totalSizeSoFar, getWriteConfig().getClusteringTargetFileMaxBytes())));\n+    }\n+\n+    return fileSliceGroups.stream().map(fileSliceGroup -> HoodieClusteringGroup.newBuilder()\n+        .setSlices(getFileSliceInfo(fileSliceGroup.getLeft()))\n+        .setNumOutputGroups(fileSliceGroup.getRight())\n+        .setMetrics(buildMetrics(fileSliceGroup.getLeft()))\n+        .build());\n+  }\n+\n+  @Override\n+  protected Map<String, String> getStrategyParams() {\n+    Map<String, String> params = new HashMap<>();\n+    if (getWriteConfig().getProps().containsKey(SORT_COLUMNS_PROPERTY)) {\n+      params.put(SORT_COLUMNS_PROPERTY, getWriteConfig().getProps().getProperty(SORT_COLUMNS_PROPERTY));\n+    }\n+    return params;\n+  }\n+\n+  @Override\n+  protected List<String> filterPartitionPaths(List<String> partitionPaths) {\n+    int targetPartitionsForClustering = getWriteConfig().getTargetPartitionsForClustering();\n+    return partitionPaths.stream().map(partition -> partition.replace(\"/\", \"-\"))\n+        .sorted(Comparator.reverseOrder()).map(partitionPath -> partitionPath.replace(\"-\", \"/\"))\n+        .limit(targetPartitionsForClustering > 0 ? targetPartitionsForClustering : partitionPaths.size())\n+        .collect(Collectors.toList());\n+  }\n+\n+  private int getNumberOfGroups(long groupSize, long targetFileSize) {", "originalCommit": "f526c2c0eed8134aa513898ba48ef8ddf851272c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU1NDA0Mw==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r545554043", "bodyText": "yes, this is calculating number of FileGroups. I updated the name to be explicit", "author": "satishkotha", "createdAt": "2020-12-18T03:43:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTA1NDc1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTA1NTA4OA==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r545055088", "bodyText": "why do we need the /,- replace logic. It should correctly even without that?", "author": "vinothchandar", "createdAt": "2020-12-17T12:33:03Z", "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/client/clustering/schedule/strategy/SparkBoundedDayBasedScheduleClusteringStrategy.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.client.clustering.schedule.strategy;\n+\n+import org.apache.hudi.avro.model.HoodieClusteringGroup;\n+import org.apache.hudi.client.WriteStatus;\n+import org.apache.hudi.client.common.HoodieSparkEngineContext;\n+import org.apache.hudi.common.model.FileSlice;\n+import org.apache.hudi.common.model.HoodieKey;\n+import org.apache.hudi.common.model.HoodieRecord;\n+import org.apache.hudi.common.model.HoodieRecordPayload;\n+import org.apache.hudi.common.util.collection.Pair;\n+import org.apache.hudi.config.HoodieWriteConfig;\n+import org.apache.hudi.table.HoodieSparkCopyOnWriteTable;\n+import org.apache.hudi.table.HoodieSparkMergeOnReadTable;\n+import org.apache.hudi.table.action.cluster.strategy.PartitionAwareScheduleClusteringStrategy;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+import org.apache.spark.api.java.JavaRDD;\n+\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.apache.hudi.config.HoodieClusteringConfig.SORT_COLUMNS_PROPERTY;\n+\n+/**\n+ * Clustering Strategy based on following.\n+ * 1) Spark execution engine.\n+ * 2) Limits amount of data per clustering operation.\n+ */\n+public class SparkBoundedDayBasedScheduleClusteringStrategy<T extends HoodieRecordPayload<T>>\n+    extends PartitionAwareScheduleClusteringStrategy<T, JavaRDD<HoodieRecord<T>>, JavaRDD<HoodieKey>, JavaRDD<WriteStatus>> {\n+  private static final Logger LOG = LogManager.getLogger(SparkBoundedDayBasedScheduleClusteringStrategy.class);\n+\n+  public SparkBoundedDayBasedScheduleClusteringStrategy(HoodieSparkCopyOnWriteTable<T> table,\n+                                                        HoodieSparkEngineContext engineContext,\n+                                                        HoodieWriteConfig writeConfig) {\n+    super(table, engineContext, writeConfig);\n+  }\n+\n+  public SparkBoundedDayBasedScheduleClusteringStrategy(HoodieSparkMergeOnReadTable<T> table,\n+                                                        HoodieSparkEngineContext engineContext,\n+                                                        HoodieWriteConfig writeConfig) {\n+    super(table, engineContext, writeConfig);\n+  }\n+\n+  @Override\n+  protected Stream<HoodieClusteringGroup> buildClusteringGroupsForPartition(String partitionPath, List<FileSlice> fileSlices) {\n+    List<Pair<List<FileSlice>, Integer>> fileSliceGroups = new ArrayList<>();\n+    List<FileSlice> currentGroup = new ArrayList<>();\n+    int totalSizeSoFar = 0;\n+    for (FileSlice currentSlice : fileSlices) {\n+      // assume each filegroup size is ~= parquet.max.file.size\n+      totalSizeSoFar += currentSlice.getBaseFile().isPresent() ? currentSlice.getBaseFile().get().getFileSize() : getWriteConfig().getParquetMaxFileSize();\n+      // check if max size is reached and create new group, if needed.\n+      if (totalSizeSoFar >= getWriteConfig().getClusteringMaxBytesInGroup() && !currentGroup.isEmpty()) {\n+        fileSliceGroups.add(Pair.of(currentGroup, getNumberOfGroups(totalSizeSoFar, getWriteConfig().getClusteringTargetFileMaxBytes())));\n+        currentGroup = new ArrayList<>();\n+        totalSizeSoFar = 0;\n+      }\n+      currentGroup.add(currentSlice);\n+    }\n+    if (!currentGroup.isEmpty()) {\n+      fileSliceGroups.add(Pair.of(currentGroup, getNumberOfGroups(totalSizeSoFar, getWriteConfig().getClusteringTargetFileMaxBytes())));\n+    }\n+\n+    return fileSliceGroups.stream().map(fileSliceGroup -> HoodieClusteringGroup.newBuilder()\n+        .setSlices(getFileSliceInfo(fileSliceGroup.getLeft()))\n+        .setNumOutputGroups(fileSliceGroup.getRight())\n+        .setMetrics(buildMetrics(fileSliceGroup.getLeft()))\n+        .build());\n+  }\n+\n+  @Override\n+  protected Map<String, String> getStrategyParams() {\n+    Map<String, String> params = new HashMap<>();\n+    if (getWriteConfig().getProps().containsKey(SORT_COLUMNS_PROPERTY)) {\n+      params.put(SORT_COLUMNS_PROPERTY, getWriteConfig().getProps().getProperty(SORT_COLUMNS_PROPERTY));\n+    }\n+    return params;\n+  }\n+\n+  @Override\n+  protected List<String> filterPartitionPaths(List<String> partitionPaths) {\n+    int targetPartitionsForClustering = getWriteConfig().getTargetPartitionsForClustering();\n+    return partitionPaths.stream().map(partition -> partition.replace(\"/\", \"-\"))", "originalCommit": "f526c2c0eed8134aa513898ba48ef8ddf851272c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU1NDM3OA==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r545554378", "bodyText": "Seems to work fine without replacing '/'.  So I removed it. Btw, compaction has this code, so I'm not sure if there are special cases where this replace is needed. It should be easy to add if we run into any issue. So I removed it.", "author": "satishkotha", "createdAt": "2020-12-18T03:44:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTA1NTA4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTA1OTExMg==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r545059112", "bodyText": "should the filtering for 2 happen at this level?  that seems like something a specific plan would do.\n1 makes sense to do at this level.", "author": "vinothchandar", "createdAt": "2020-12-17T12:39:58Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/table/action/cluster/strategy/ScheduleClusteringStrategy.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.table.action.cluster.strategy;\n+\n+import org.apache.hudi.avro.model.HoodieClusteringPlan;\n+import org.apache.hudi.avro.model.HoodieSliceInfo;\n+import org.apache.hudi.client.common.HoodieEngineContext;\n+import org.apache.hudi.common.model.BaseFile;\n+import org.apache.hudi.common.model.FileSlice;\n+import org.apache.hudi.common.model.HoodieBaseFile;\n+import org.apache.hudi.common.model.HoodieFileGroupId;\n+import org.apache.hudi.common.model.HoodieRecordPayload;\n+import org.apache.hudi.common.table.view.SyncableFileSystemView;\n+import org.apache.hudi.common.util.FileSliceUtils;\n+import org.apache.hudi.common.util.Option;\n+import org.apache.hudi.common.util.StringUtils;\n+import org.apache.hudi.common.util.collection.Pair;\n+import org.apache.hudi.config.HoodieWriteConfig;\n+import org.apache.hudi.table.HoodieTable;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import java.io.Serializable;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Pluggable implementation for scheduling clustering and creating ClusteringPlan.\n+ */\n+public abstract class ScheduleClusteringStrategy<T extends HoodieRecordPayload,I,K,O> implements Serializable {\n+  private static final Logger LOG = LogManager.getLogger(ScheduleClusteringStrategy.class);\n+\n+  public static final int CLUSTERING_PLAN_VERSION_1 = 1;\n+\n+  private final HoodieTable<T,I,K,O> hoodieTable;\n+  private final HoodieEngineContext engineContext;\n+  private final HoodieWriteConfig writeConfig;\n+\n+  public ScheduleClusteringStrategy(HoodieTable table, HoodieEngineContext engineContext, HoodieWriteConfig writeConfig) {\n+    this.writeConfig = writeConfig;\n+    this.hoodieTable = table;\n+    this.engineContext = engineContext;\n+  }\n+\n+  /**\n+   * Generate metadata for grouping eligible files and create a plan. Note that data is not moved around\n+   * as part of this step.\n+   *\n+   * If there is no data available to cluster, return None.\n+   */\n+  public abstract Option<HoodieClusteringPlan> generateClusteringPlan();\n+\n+  /**\n+   * Return file slices eligible for clustering. FileIds in\n+   * 1) pending clustering/compaction\n+   * 2) Larger than clustering target file size", "originalCommit": "f526c2c0eed8134aa513898ba48ef8ddf851272c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU1NDQ5NA==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r545554494", "bodyText": "Moved 2 to strategy specific implementation.", "author": "satishkotha", "createdAt": "2020-12-18T03:44:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTA1OTExMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTA2MDE0Ng==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r545060146", "bodyText": "this is actually just a ClusteringPlanStrategy right? i.e it generates clustering plans. It has less to do with scheduling of clustering itself?", "author": "vinothchandar", "createdAt": "2020-12-17T12:41:44Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/table/action/cluster/strategy/ScheduleClusteringStrategy.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.table.action.cluster.strategy;\n+\n+import org.apache.hudi.avro.model.HoodieClusteringPlan;\n+import org.apache.hudi.avro.model.HoodieSliceInfo;\n+import org.apache.hudi.client.common.HoodieEngineContext;\n+import org.apache.hudi.common.model.BaseFile;\n+import org.apache.hudi.common.model.FileSlice;\n+import org.apache.hudi.common.model.HoodieBaseFile;\n+import org.apache.hudi.common.model.HoodieFileGroupId;\n+import org.apache.hudi.common.model.HoodieRecordPayload;\n+import org.apache.hudi.common.table.view.SyncableFileSystemView;\n+import org.apache.hudi.common.util.FileSliceUtils;\n+import org.apache.hudi.common.util.Option;\n+import org.apache.hudi.common.util.StringUtils;\n+import org.apache.hudi.common.util.collection.Pair;\n+import org.apache.hudi.config.HoodieWriteConfig;\n+import org.apache.hudi.table.HoodieTable;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import java.io.Serializable;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Pluggable implementation for scheduling clustering and creating ClusteringPlan.\n+ */\n+public abstract class ScheduleClusteringStrategy<T extends HoodieRecordPayload,I,K,O> implements Serializable {\n+  private static final Logger LOG = LogManager.getLogger(ScheduleClusteringStrategy.class);\n+\n+  public static final int CLUSTERING_PLAN_VERSION_1 = 1;\n+\n+  private final HoodieTable<T,I,K,O> hoodieTable;\n+  private final HoodieEngineContext engineContext;\n+  private final HoodieWriteConfig writeConfig;\n+\n+  public ScheduleClusteringStrategy(HoodieTable table, HoodieEngineContext engineContext, HoodieWriteConfig writeConfig) {", "originalCommit": "f526c2c0eed8134aa513898ba48ef8ddf851272c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTA2MDM1Mg==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r545060352", "bodyText": "Should we rename this class and the configs?", "author": "vinothchandar", "createdAt": "2020-12-17T12:42:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTA2MDE0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU1NDg0MQ==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r545554841", "bodyText": "I followed compaction naming pattern. But agree schedule has different meaning. I changed it to ClusteringPlanStrategy. WriteClient methods are still scheduleClustering(String instant), let me know if you think this needs to change also.", "author": "satishkotha", "createdAt": "2020-12-18T03:46:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTA2MDE0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTA2MTMzMQ==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r545061331", "bodyText": "can we rename numOutputGroups to something that can be easily understood in the bulk insert context. If we leak some clustering terminology here, it becomes to harder to read this.", "author": "vinothchandar", "createdAt": "2020-12-17T12:43:40Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/table/action/commit/AbstractBulkInsertHelper.java", "diffHunk": "@@ -27,8 +27,21 @@\n \n public abstract class AbstractBulkInsertHelper<T extends HoodieRecordPayload, I, K, O, R> {\n \n+  /**\n+   * Mark instant as inflight, write input records, update index and return result.\n+   */\n   public abstract HoodieWriteMetadata<O> bulkInsert(I inputRecords, String instantTime,\n                                                     HoodieTable<T, I, K, O> table, HoodieWriteConfig config,\n                                                     BaseCommitActionExecutor<T, I, K, O, R> executor, boolean performDedupe,\n                                                     Option<BulkInsertPartitioner<T>> userDefinedBulkInsertPartitioner);\n+\n+  /**\n+   * Only write input records. Does not change timeline/index. Return information about new files created.\n+   */\n+  public abstract O bulkInsert(I inputRecords, String instantTime,\n+                               HoodieTable<T, I, K, O> table, HoodieWriteConfig config,\n+                               boolean performDedupe,\n+                               Option<BulkInsertPartitioner<T>> userDefinedBulkInsertPartitioner,\n+                               boolean addMetadataFields,\n+                               int numOutputGroups);", "originalCommit": "f526c2c0eed8134aa513898ba48ef8ddf851272c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU1NDk4OQ==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r545554989", "bodyText": "Looks like I already changed subclasses, but overlooked base class. Thanks for catching this.", "author": "satishkotha", "createdAt": "2020-12-18T03:46:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTA2MTMzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTA2MjM0NA==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r545062344", "bodyText": "are these cleanups strictly needed for this PR? if you have tested them already, its okay. but generally, separating these in a different refactor PR is preferrable.", "author": "vinothchandar", "createdAt": "2020-12-17T12:45:20Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/table/action/compact/strategy/LogFileSizeBasedCompactionStrategy.java", "diffHunk": "@@ -40,21 +36,6 @@\n public class LogFileSizeBasedCompactionStrategy extends BoundedIOCompactionStrategy\n     implements Comparator<HoodieCompactionOperation> {\n \n-  private static final String TOTAL_LOG_FILE_SIZE = \"TOTAL_LOG_FILE_SIZE\";", "originalCommit": "f526c2c0eed8134aa513898ba48ef8ddf851272c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU1NTM3MA==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r545555370", "bodyText": "I refactored it based on other review feedback. There are unit tests for this. So I am reasonably confident theres no errors. I'll keep such changes for another PR next time. Thanks", "author": "satishkotha", "createdAt": "2020-12-18T03:48:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTA2MjM0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTEzMTY3Ng==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r545131676", "bodyText": "place each parameter on its own line?", "author": "vinothchandar", "createdAt": "2020-12-17T14:28:33Z", "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/table/action/commit/SparkBulkInsertHelper.java", "diffHunk": "@@ -59,25 +58,39 @@ public static SparkBulkInsertHelper newInstance() {\n   }\n \n   @Override\n-  public HoodieWriteMetadata<JavaRDD<WriteStatus>> bulkInsert(JavaRDD<HoodieRecord<T>> inputRecords,\n-                                                              String instantTime,\n-                                                              HoodieTable<T, JavaRDD<HoodieRecord<T>>, JavaRDD<HoodieKey>, JavaRDD<WriteStatus>> table,\n-                                                              HoodieWriteConfig config,\n-                                                              BaseCommitActionExecutor<T, JavaRDD<HoodieRecord<T>>, JavaRDD<HoodieKey>, JavaRDD<WriteStatus>, R> executor,\n-                                                              boolean performDedupe,\n-                                                              Option<BulkInsertPartitioner<T>> userDefinedBulkInsertPartitioner) {\n+  public HoodieWriteMetadata<JavaRDD<WriteStatus>> bulkInsert(final JavaRDD<HoodieRecord<T>> inputRecords, final String instantTime, final HoodieTable<T, JavaRDD<HoodieRecord<T>>, JavaRDD<HoodieKey>, JavaRDD<WriteStatus>> table, final HoodieWriteConfig config, final BaseCommitActionExecutor<T, JavaRDD<HoodieRecord<T>>, JavaRDD<HoodieKey>, JavaRDD<WriteStatus>, R> executor, final boolean performDedupe, final Option<BulkInsertPartitioner<T>> userDefinedBulkInsertPartitioner) {", "originalCommit": "f526c2c0eed8134aa513898ba48ef8ddf851272c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU1NTM5Nw==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r545555397", "bodyText": "Done", "author": "satishkotha", "createdAt": "2020-12-18T03:48:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTEzMTY3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTEzOTA1MA==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r545139050", "bodyText": "this is very metric specific. could we stick it somewhere else closer to actual usage in hudi-client-common? may be rename the class to something like FileSliceMetricUtils ?", "author": "vinothchandar", "createdAt": "2020-12-17T14:38:32Z", "path": "hudi-common/src/main/java/org/apache/hudi/common/util/FileSliceUtils.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.common.util;\n+\n+import org.apache.hudi.common.fs.FSUtils;\n+import org.apache.hudi.common.model.FileSlice;\n+import org.apache.hudi.common.model.HoodieLogFile;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * A utility class for numeric.\n+ */\n+public class FileSliceUtils {\n+\n+  public static final String TOTAL_IO_READ_MB = \"TOTAL_IO_READ_MB\";\n+  public static final String TOTAL_IO_WRITE_MB = \"TOTAL_IO_WRITE_MB\";\n+  public static final String TOTAL_IO_MB = \"TOTAL_IO_MB\";\n+  public static final String TOTAL_LOG_FILE_SIZE = \"TOTAL_LOG_FILES_SIZE\";\n+  public static final String TOTAL_LOG_FILES = \"TOTAL_LOG_FILES\";\n+\n+  public static void addFileSliceCommonMetrics(List<FileSlice> fileSlices, Map<String, Double> metrics, long defaultBaseFileSize) {", "originalCommit": "f526c2c0eed8134aa513898ba48ef8ddf851272c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU1NTUxNw==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r545555517", "bodyText": "Moved it as suggested.", "author": "satishkotha", "createdAt": "2020-12-18T03:48:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTEzOTA1MA=="}], "type": "inlineReview"}, {"oid": "039e6a5931e0da738582b5e7c35691cdf76e803a", "url": "https://github.com/apache/hudi/commit/039e6a5931e0da738582b5e7c35691cdf76e803a", "message": "[HUDI-1075] Implement simple clustering strategies to create ClusteringPlan and to run the plan", "committedDate": "2020-12-18T03:38:49Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjExNDYwMw==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r546114603", "bodyText": "may be call it execution.  hoodie.clustering.execution.strategy.class ?", "author": "vinothchandar", "createdAt": "2020-12-18T22:10:19Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/config/HoodieClusteringConfig.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.config;\n+\n+import org.apache.hudi.common.config.DefaultHoodieConfig;\n+\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.util.Properties;\n+\n+/**\n+ * Clustering specific configs.\n+ */\n+public class HoodieClusteringConfig extends DefaultHoodieConfig {\n+\n+  // Config to provide a strategy class to create ClusteringPlan. Class has to be subclass of ClusteringPlanStrategy\n+  public static final String CLUSTERING_PLAN_STRATEGY_CLASS = \"hoodie.clustering.plan.strategy.class\";\n+  public static final String DEFAULT_CLUSTERING_PLAN_STRATEGY_CLASS =\n+      \"org.apache.hudi.client.clustering.plan.strategy.SparkBoundedDayBasedClusteringPlanStrategy\";\n+\n+  // Config to provide a strategy class to execute a ClusteringPlan. Class has to be subclass of RunClusteringStrategy\n+  public static final String RUN_CLUSTERING_STRATEGY_CLASS = \"hoodie.clustering.run.strategy.class\";", "originalCommit": "039e6a5931e0da738582b5e7c35691cdf76e803a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjExNDk0OA==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r546114948", "bodyText": "max.commits?", "author": "vinothchandar", "createdAt": "2020-12-18T22:11:25Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/config/HoodieClusteringConfig.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.config;\n+\n+import org.apache.hudi.common.config.DefaultHoodieConfig;\n+\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.util.Properties;\n+\n+/**\n+ * Clustering specific configs.\n+ */\n+public class HoodieClusteringConfig extends DefaultHoodieConfig {\n+\n+  // Config to provide a strategy class to create ClusteringPlan. Class has to be subclass of ClusteringPlanStrategy\n+  public static final String CLUSTERING_PLAN_STRATEGY_CLASS = \"hoodie.clustering.plan.strategy.class\";\n+  public static final String DEFAULT_CLUSTERING_PLAN_STRATEGY_CLASS =\n+      \"org.apache.hudi.client.clustering.plan.strategy.SparkBoundedDayBasedClusteringPlanStrategy\";\n+\n+  // Config to provide a strategy class to execute a ClusteringPlan. Class has to be subclass of RunClusteringStrategy\n+  public static final String RUN_CLUSTERING_STRATEGY_CLASS = \"hoodie.clustering.run.strategy.class\";\n+  public static final String DEFAULT_RUN_CLUSTERING_STRATEGY_CLASS =\n+      \"org.apache.hudi.client.clustering.run.strategy.SparkBulkInsertBasedRunClusteringStrategy\";\n+\n+  // Turn on inline clustering - clustering will be run after write operation is complete.\n+  public static final String INLINE_CLUSTERING_PROP = \"hoodie.clustering.inline\";\n+  private static final String DEFAULT_INLINE_CLUSTERING = \"false\";\n+\n+  // Config to control frequency of clustering\n+  public static final String INLINE_CLUSTERING_NUM_COMMIT_PROP = \"hoodie.clustering.inline.num.commits\";", "originalCommit": "039e6a5931e0da738582b5e7c35691cdf76e803a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjExNTQzMw==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r546115433", "bodyText": "replace scan with list?\nshould we also do it based on last N commits? It helps for tables that receive data across partitions? This is probably some follow on work we can do to add a new plan strategy for this. Lets add a JIRA?", "author": "vinothchandar", "createdAt": "2020-12-18T22:12:56Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/config/HoodieClusteringConfig.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.config;\n+\n+import org.apache.hudi.common.config.DefaultHoodieConfig;\n+\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.util.Properties;\n+\n+/**\n+ * Clustering specific configs.\n+ */\n+public class HoodieClusteringConfig extends DefaultHoodieConfig {\n+\n+  // Config to provide a strategy class to create ClusteringPlan. Class has to be subclass of ClusteringPlanStrategy\n+  public static final String CLUSTERING_PLAN_STRATEGY_CLASS = \"hoodie.clustering.plan.strategy.class\";\n+  public static final String DEFAULT_CLUSTERING_PLAN_STRATEGY_CLASS =\n+      \"org.apache.hudi.client.clustering.plan.strategy.SparkBoundedDayBasedClusteringPlanStrategy\";\n+\n+  // Config to provide a strategy class to execute a ClusteringPlan. Class has to be subclass of RunClusteringStrategy\n+  public static final String RUN_CLUSTERING_STRATEGY_CLASS = \"hoodie.clustering.run.strategy.class\";\n+  public static final String DEFAULT_RUN_CLUSTERING_STRATEGY_CLASS =\n+      \"org.apache.hudi.client.clustering.run.strategy.SparkBulkInsertBasedRunClusteringStrategy\";\n+\n+  // Turn on inline clustering - clustering will be run after write operation is complete.\n+  public static final String INLINE_CLUSTERING_PROP = \"hoodie.clustering.inline\";\n+  private static final String DEFAULT_INLINE_CLUSTERING = \"false\";\n+\n+  // Config to control frequency of clustering\n+  public static final String INLINE_CLUSTERING_NUM_COMMIT_PROP = \"hoodie.clustering.inline.num.commits\";\n+  private static final String DEFAULT_INLINE_CLUSTERING_NUM_COMMITS = \"4\";\n+\n+  // Number of partitions to scan to create ClusteringPlan.", "originalCommit": "039e6a5931e0da738582b5e7c35691cdf76e803a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjExNjExOQ==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r546116119", "bodyText": "hoodie.clustering.plan.strategy.daybased.lookback.partitions or something ties this to a specific strategy and also captures that this look at N partitions from now.", "author": "vinothchandar", "createdAt": "2020-12-18T22:14:46Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/config/HoodieClusteringConfig.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.config;\n+\n+import org.apache.hudi.common.config.DefaultHoodieConfig;\n+\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.util.Properties;\n+\n+/**\n+ * Clustering specific configs.\n+ */\n+public class HoodieClusteringConfig extends DefaultHoodieConfig {\n+\n+  // Config to provide a strategy class to create ClusteringPlan. Class has to be subclass of ClusteringPlanStrategy\n+  public static final String CLUSTERING_PLAN_STRATEGY_CLASS = \"hoodie.clustering.plan.strategy.class\";\n+  public static final String DEFAULT_CLUSTERING_PLAN_STRATEGY_CLASS =\n+      \"org.apache.hudi.client.clustering.plan.strategy.SparkBoundedDayBasedClusteringPlanStrategy\";\n+\n+  // Config to provide a strategy class to execute a ClusteringPlan. Class has to be subclass of RunClusteringStrategy\n+  public static final String RUN_CLUSTERING_STRATEGY_CLASS = \"hoodie.clustering.run.strategy.class\";\n+  public static final String DEFAULT_RUN_CLUSTERING_STRATEGY_CLASS =\n+      \"org.apache.hudi.client.clustering.run.strategy.SparkBulkInsertBasedRunClusteringStrategy\";\n+\n+  // Turn on inline clustering - clustering will be run after write operation is complete.\n+  public static final String INLINE_CLUSTERING_PROP = \"hoodie.clustering.inline\";\n+  private static final String DEFAULT_INLINE_CLUSTERING = \"false\";\n+\n+  // Config to control frequency of clustering\n+  public static final String INLINE_CLUSTERING_NUM_COMMIT_PROP = \"hoodie.clustering.inline.num.commits\";\n+  private static final String DEFAULT_INLINE_CLUSTERING_NUM_COMMITS = \"4\";\n+\n+  // Number of partitions to scan to create ClusteringPlan.\n+  public static final String CLUSTERING_TARGET_PARTITIONS = \"hoodie.clustering.target.partitions\";", "originalCommit": "039e6a5931e0da738582b5e7c35691cdf76e803a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjExNjk0MA==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r546116940", "bodyText": "something to think about. should this be strategy specific too?", "author": "vinothchandar", "createdAt": "2020-12-18T22:16:58Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/config/HoodieClusteringConfig.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.config;\n+\n+import org.apache.hudi.common.config.DefaultHoodieConfig;\n+\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.util.Properties;\n+\n+/**\n+ * Clustering specific configs.\n+ */\n+public class HoodieClusteringConfig extends DefaultHoodieConfig {\n+\n+  // Config to provide a strategy class to create ClusteringPlan. Class has to be subclass of ClusteringPlanStrategy\n+  public static final String CLUSTERING_PLAN_STRATEGY_CLASS = \"hoodie.clustering.plan.strategy.class\";\n+  public static final String DEFAULT_CLUSTERING_PLAN_STRATEGY_CLASS =\n+      \"org.apache.hudi.client.clustering.plan.strategy.SparkBoundedDayBasedClusteringPlanStrategy\";\n+\n+  // Config to provide a strategy class to execute a ClusteringPlan. Class has to be subclass of RunClusteringStrategy\n+  public static final String RUN_CLUSTERING_STRATEGY_CLASS = \"hoodie.clustering.run.strategy.class\";\n+  public static final String DEFAULT_RUN_CLUSTERING_STRATEGY_CLASS =\n+      \"org.apache.hudi.client.clustering.run.strategy.SparkBulkInsertBasedRunClusteringStrategy\";\n+\n+  // Turn on inline clustering - clustering will be run after write operation is complete.\n+  public static final String INLINE_CLUSTERING_PROP = \"hoodie.clustering.inline\";\n+  private static final String DEFAULT_INLINE_CLUSTERING = \"false\";\n+\n+  // Config to control frequency of clustering\n+  public static final String INLINE_CLUSTERING_NUM_COMMIT_PROP = \"hoodie.clustering.inline.num.commits\";\n+  private static final String DEFAULT_INLINE_CLUSTERING_NUM_COMMITS = \"4\";\n+\n+  // Number of partitions to scan to create ClusteringPlan.\n+  public static final String CLUSTERING_TARGET_PARTITIONS = \"hoodie.clustering.target.partitions\";\n+  public static final String DEFAULT_CLUSTERING_TARGET_PARTITIONS = String.valueOf(2);\n+\n+  // Each clustering operation can create multiple groups. Total amount of data processed by clustering operation", "originalCommit": "039e6a5931e0da738582b5e7c35691cdf76e803a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjExNzgwOA==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r546117808", "bodyText": "may be hoodie.clustering.max.bytes.per.group ?", "author": "vinothchandar", "createdAt": "2020-12-18T22:19:40Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/config/HoodieClusteringConfig.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.config;\n+\n+import org.apache.hudi.common.config.DefaultHoodieConfig;\n+\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.util.Properties;\n+\n+/**\n+ * Clustering specific configs.\n+ */\n+public class HoodieClusteringConfig extends DefaultHoodieConfig {\n+\n+  // Config to provide a strategy class to create ClusteringPlan. Class has to be subclass of ClusteringPlanStrategy\n+  public static final String CLUSTERING_PLAN_STRATEGY_CLASS = \"hoodie.clustering.plan.strategy.class\";\n+  public static final String DEFAULT_CLUSTERING_PLAN_STRATEGY_CLASS =\n+      \"org.apache.hudi.client.clustering.plan.strategy.SparkBoundedDayBasedClusteringPlanStrategy\";\n+\n+  // Config to provide a strategy class to execute a ClusteringPlan. Class has to be subclass of RunClusteringStrategy\n+  public static final String RUN_CLUSTERING_STRATEGY_CLASS = \"hoodie.clustering.run.strategy.class\";\n+  public static final String DEFAULT_RUN_CLUSTERING_STRATEGY_CLASS =\n+      \"org.apache.hudi.client.clustering.run.strategy.SparkBulkInsertBasedRunClusteringStrategy\";\n+\n+  // Turn on inline clustering - clustering will be run after write operation is complete.\n+  public static final String INLINE_CLUSTERING_PROP = \"hoodie.clustering.inline\";\n+  private static final String DEFAULT_INLINE_CLUSTERING = \"false\";\n+\n+  // Config to control frequency of clustering\n+  public static final String INLINE_CLUSTERING_NUM_COMMIT_PROP = \"hoodie.clustering.inline.num.commits\";\n+  private static final String DEFAULT_INLINE_CLUSTERING_NUM_COMMITS = \"4\";\n+\n+  // Number of partitions to scan to create ClusteringPlan.\n+  public static final String CLUSTERING_TARGET_PARTITIONS = \"hoodie.clustering.target.partitions\";\n+  public static final String DEFAULT_CLUSTERING_TARGET_PARTITIONS = String.valueOf(2);\n+\n+  // Each clustering operation can create multiple groups. Total amount of data processed by clustering operation\n+  // is defined by below two properties (CLUSTERING_MAX_BYTES_IN_GROUP * CLUSTERING_MAX_NUM_GROUPS).\n+  // Max amount of data to be included in one group\n+  public static final String CLUSTERING_MAX_BYTES_IN_GROUP = \"hoodie.clustering.max.bytes.group\";", "originalCommit": "039e6a5931e0da738582b5e7c35691cdf76e803a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjExNzkxNQ==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r546117915", "bodyText": "strategy specific?", "author": "vinothchandar", "createdAt": "2020-12-18T22:20:01Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/config/HoodieClusteringConfig.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.config;\n+\n+import org.apache.hudi.common.config.DefaultHoodieConfig;\n+\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.util.Properties;\n+\n+/**\n+ * Clustering specific configs.\n+ */\n+public class HoodieClusteringConfig extends DefaultHoodieConfig {\n+\n+  // Config to provide a strategy class to create ClusteringPlan. Class has to be subclass of ClusteringPlanStrategy\n+  public static final String CLUSTERING_PLAN_STRATEGY_CLASS = \"hoodie.clustering.plan.strategy.class\";\n+  public static final String DEFAULT_CLUSTERING_PLAN_STRATEGY_CLASS =\n+      \"org.apache.hudi.client.clustering.plan.strategy.SparkBoundedDayBasedClusteringPlanStrategy\";\n+\n+  // Config to provide a strategy class to execute a ClusteringPlan. Class has to be subclass of RunClusteringStrategy\n+  public static final String RUN_CLUSTERING_STRATEGY_CLASS = \"hoodie.clustering.run.strategy.class\";\n+  public static final String DEFAULT_RUN_CLUSTERING_STRATEGY_CLASS =\n+      \"org.apache.hudi.client.clustering.run.strategy.SparkBulkInsertBasedRunClusteringStrategy\";\n+\n+  // Turn on inline clustering - clustering will be run after write operation is complete.\n+  public static final String INLINE_CLUSTERING_PROP = \"hoodie.clustering.inline\";\n+  private static final String DEFAULT_INLINE_CLUSTERING = \"false\";\n+\n+  // Config to control frequency of clustering\n+  public static final String INLINE_CLUSTERING_NUM_COMMIT_PROP = \"hoodie.clustering.inline.num.commits\";\n+  private static final String DEFAULT_INLINE_CLUSTERING_NUM_COMMITS = \"4\";\n+\n+  // Number of partitions to scan to create ClusteringPlan.\n+  public static final String CLUSTERING_TARGET_PARTITIONS = \"hoodie.clustering.target.partitions\";\n+  public static final String DEFAULT_CLUSTERING_TARGET_PARTITIONS = String.valueOf(2);\n+\n+  // Each clustering operation can create multiple groups. Total amount of data processed by clustering operation\n+  // is defined by below two properties (CLUSTERING_MAX_BYTES_IN_GROUP * CLUSTERING_MAX_NUM_GROUPS).\n+  // Max amount of data to be included in one group\n+  public static final String CLUSTERING_MAX_BYTES_IN_GROUP = \"hoodie.clustering.max.bytes.group\";\n+  public static final String DEFAULT_CLUSTERING_MAX_GROUP_SIZE = String.valueOf(2 * 1024 * 1024 * 1024L);\n+\n+  // Maximum number of groups to create as part of ClusteringPlan. Increasing groups will increase parallelism.\n+  public static final String CLUSTERING_MAX_NUM_GROUPS = \"hoodie.clustering.max.num.groups\";\n+  public static final String DEFAULT_CLUSTERING_MAX_NUM_GROUPS = \"30\";\n+\n+  // Each group can produce 'N' (CLUSTERING_MAX_GROUP_SIZE/CLUSTERING_TARGET_FILE_SIZE) output file groups.", "originalCommit": "039e6a5931e0da738582b5e7c35691cdf76e803a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjExODExNA==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r546118114", "bodyText": "drop the Create?", "author": "vinothchandar", "createdAt": "2020-12-18T22:20:44Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/table/action/cluster/BaseCreateClusteringPlanActionExecutor.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.table.action.cluster;\n+\n+import org.apache.hudi.avro.model.HoodieClusteringPlan;\n+import org.apache.hudi.avro.model.HoodieRequestedReplaceMetadata;\n+import org.apache.hudi.client.common.HoodieEngineContext;\n+import org.apache.hudi.common.model.HoodieRecordPayload;\n+import org.apache.hudi.common.model.WriteOperationType;\n+import org.apache.hudi.common.table.timeline.HoodieInstant;\n+import org.apache.hudi.common.table.timeline.HoodieTimeline;\n+import org.apache.hudi.common.table.timeline.TimelineMetadataUtils;\n+import org.apache.hudi.common.util.Option;\n+import org.apache.hudi.config.HoodieWriteConfig;\n+import org.apache.hudi.exception.HoodieIOException;\n+import org.apache.hudi.table.HoodieTable;\n+import org.apache.hudi.table.action.BaseActionExecutor;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.Map;\n+\n+public abstract class BaseCreateClusteringPlanActionExecutor<T extends HoodieRecordPayload, I, K, O> extends BaseActionExecutor<T, I, K, O, Option<HoodieClusteringPlan>> {", "originalCommit": "039e6a5931e0da738582b5e7c35691cdf76e803a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjExODQ1NQ==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r546118455", "bodyText": "remove this?", "author": "vinothchandar", "createdAt": "2020-12-18T22:21:53Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/table/action/cluster/strategy/ClusteringPlanStrategy.java", "diffHunk": "@@ -0,0 +1,146 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.table.action.cluster.strategy;\n+\n+import org.apache.hudi.avro.model.HoodieClusteringPlan;\n+import org.apache.hudi.avro.model.HoodieSliceInfo;\n+import org.apache.hudi.client.common.HoodieEngineContext;\n+import org.apache.hudi.client.utils.FileSliceMetricUtils;\n+import org.apache.hudi.common.model.BaseFile;\n+import org.apache.hudi.common.model.FileSlice;\n+import org.apache.hudi.common.model.HoodieFileGroupId;\n+import org.apache.hudi.common.model.HoodieRecordPayload;\n+import org.apache.hudi.common.table.view.SyncableFileSystemView;\n+import org.apache.hudi.common.util.Option;\n+import org.apache.hudi.common.util.StringUtils;\n+import org.apache.hudi.common.util.collection.Pair;\n+import org.apache.hudi.config.HoodieWriteConfig;\n+import org.apache.hudi.table.HoodieTable;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import java.io.Serializable;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ * Pluggable implementation for scheduling clustering and creating ClusteringPlan.\n+ */\n+public abstract class ClusteringPlanStrategy<T extends HoodieRecordPayload,I,K,O> implements Serializable {\n+  private static final Logger LOG = LogManager.getLogger(ClusteringPlanStrategy.class);\n+\n+  public static final int CLUSTERING_PLAN_VERSION_1 = 1;\n+\n+  private final HoodieTable<T,I,K,O> hoodieTable;\n+  private final transient HoodieEngineContext engineContext;\n+  private final HoodieWriteConfig writeConfig;\n+\n+  public ClusteringPlanStrategy(HoodieTable table, HoodieEngineContext engineContext, HoodieWriteConfig writeConfig) {\n+    this.writeConfig = writeConfig;\n+    this.hoodieTable = table;\n+    this.engineContext = engineContext;\n+  }\n+\n+  /**\n+   * Generate metadata for grouping eligible files and create a plan. Note that data is not moved around\n+   * as part of this step.\n+   *\n+   * If there is no data available to cluster, return None.\n+   */\n+  public abstract Option<HoodieClusteringPlan> generateClusteringPlan();\n+\n+  /**\n+   * Return file slices eligible for clustering. FileIds in\n+   * 1) pending clustering/compaction\n+   * 2) Larger than clustering target file size", "originalCommit": "039e6a5931e0da738582b5e7c35691cdf76e803a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjExODgyMQ==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r546118821", "bodyText": "EMPTY_STRING?", "author": "vinothchandar", "createdAt": "2020-12-18T22:22:48Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/table/action/cluster/strategy/ClusteringPlanStrategy.java", "diffHunk": "@@ -0,0 +1,146 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.table.action.cluster.strategy;\n+\n+import org.apache.hudi.avro.model.HoodieClusteringPlan;\n+import org.apache.hudi.avro.model.HoodieSliceInfo;\n+import org.apache.hudi.client.common.HoodieEngineContext;\n+import org.apache.hudi.client.utils.FileSliceMetricUtils;\n+import org.apache.hudi.common.model.BaseFile;\n+import org.apache.hudi.common.model.FileSlice;\n+import org.apache.hudi.common.model.HoodieFileGroupId;\n+import org.apache.hudi.common.model.HoodieRecordPayload;\n+import org.apache.hudi.common.table.view.SyncableFileSystemView;\n+import org.apache.hudi.common.util.Option;\n+import org.apache.hudi.common.util.StringUtils;\n+import org.apache.hudi.common.util.collection.Pair;\n+import org.apache.hudi.config.HoodieWriteConfig;\n+import org.apache.hudi.table.HoodieTable;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import java.io.Serializable;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ * Pluggable implementation for scheduling clustering and creating ClusteringPlan.\n+ */\n+public abstract class ClusteringPlanStrategy<T extends HoodieRecordPayload,I,K,O> implements Serializable {\n+  private static final Logger LOG = LogManager.getLogger(ClusteringPlanStrategy.class);\n+\n+  public static final int CLUSTERING_PLAN_VERSION_1 = 1;\n+\n+  private final HoodieTable<T,I,K,O> hoodieTable;\n+  private final transient HoodieEngineContext engineContext;\n+  private final HoodieWriteConfig writeConfig;\n+\n+  public ClusteringPlanStrategy(HoodieTable table, HoodieEngineContext engineContext, HoodieWriteConfig writeConfig) {\n+    this.writeConfig = writeConfig;\n+    this.hoodieTable = table;\n+    this.engineContext = engineContext;\n+  }\n+\n+  /**\n+   * Generate metadata for grouping eligible files and create a plan. Note that data is not moved around\n+   * as part of this step.\n+   *\n+   * If there is no data available to cluster, return None.\n+   */\n+  public abstract Option<HoodieClusteringPlan> generateClusteringPlan();\n+\n+  /**\n+   * Return file slices eligible for clustering. FileIds in\n+   * 1) pending clustering/compaction\n+   * 2) Larger than clustering target file size\n+   *\n+   * are not eligible for clustering.\n+   */\n+  protected Stream<FileSlice> getFileSlicesEligibleForClustering(String partition) {\n+    SyncableFileSystemView fileSystemView = (SyncableFileSystemView) getHoodieTable().getSliceView();\n+    Set<HoodieFileGroupId> fgIdsInPendingCompactionAndClustering = fileSystemView.getPendingCompactionOperations()\n+        .map(instantTimeOpPair -> instantTimeOpPair.getValue().getFileGroupId())\n+        .collect(Collectors.toSet());\n+    fgIdsInPendingCompactionAndClustering.addAll(fileSystemView.getFileGroupsInPendingClustering().map(Pair::getKey).collect(Collectors.toSet()));\n+\n+    return hoodieTable.getSliceView().getLatestFileSlices(partition)\n+        // file ids already in clustering are not eligible\n+        .filter(slice -> !fgIdsInPendingCompactionAndClustering.contains(slice.getFileGroupId()));\n+  }\n+\n+  /**\n+   * Get parameters specific to strategy. These parameters are passed from 'schedule clustering' step to\n+   * 'run clustering' step. 'run clustering' step is typically async. So these params help with passing any required\n+   * context from schedule to run step.\n+   */\n+  protected abstract Map<String, String> getStrategyParams();\n+\n+  /**\n+   * Returns any specific parameters to be stored as part of clustering metadata.\n+   */\n+  protected Map<String, String> getExtraMetadata() {\n+    return Collections.emptyMap();\n+  }\n+\n+  /**\n+   * Version to support future changes for plan.\n+   */\n+  protected int getPlanVersion() {\n+    return CLUSTERING_PLAN_VERSION_1;\n+  }\n+\n+  /**\n+   * Transform {@link FileSlice} to {@link HoodieSliceInfo}.\n+   */\n+  protected List<HoodieSliceInfo> getFileSliceInfo(List<FileSlice> slices) {\n+    return slices.stream().map(slice -> new HoodieSliceInfo().newBuilder()\n+        .setPartitionPath(slice.getPartitionPath())\n+        .setFileId(slice.getFileId())\n+        .setDataFilePath(slice.getBaseFile().map(BaseFile::getPath).orElse(\"\"))", "originalCommit": "039e6a5931e0da738582b5e7c35691cdf76e803a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjExOTA1Mg==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r546119052", "bodyText": "worth thinking about making this a static helper?", "author": "vinothchandar", "createdAt": "2020-12-18T22:23:22Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/table/action/cluster/strategy/ClusteringPlanStrategy.java", "diffHunk": "@@ -0,0 +1,146 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.table.action.cluster.strategy;\n+\n+import org.apache.hudi.avro.model.HoodieClusteringPlan;\n+import org.apache.hudi.avro.model.HoodieSliceInfo;\n+import org.apache.hudi.client.common.HoodieEngineContext;\n+import org.apache.hudi.client.utils.FileSliceMetricUtils;\n+import org.apache.hudi.common.model.BaseFile;\n+import org.apache.hudi.common.model.FileSlice;\n+import org.apache.hudi.common.model.HoodieFileGroupId;\n+import org.apache.hudi.common.model.HoodieRecordPayload;\n+import org.apache.hudi.common.table.view.SyncableFileSystemView;\n+import org.apache.hudi.common.util.Option;\n+import org.apache.hudi.common.util.StringUtils;\n+import org.apache.hudi.common.util.collection.Pair;\n+import org.apache.hudi.config.HoodieWriteConfig;\n+import org.apache.hudi.table.HoodieTable;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import java.io.Serializable;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ * Pluggable implementation for scheduling clustering and creating ClusteringPlan.\n+ */\n+public abstract class ClusteringPlanStrategy<T extends HoodieRecordPayload,I,K,O> implements Serializable {\n+  private static final Logger LOG = LogManager.getLogger(ClusteringPlanStrategy.class);\n+\n+  public static final int CLUSTERING_PLAN_VERSION_1 = 1;\n+\n+  private final HoodieTable<T,I,K,O> hoodieTable;\n+  private final transient HoodieEngineContext engineContext;\n+  private final HoodieWriteConfig writeConfig;\n+\n+  public ClusteringPlanStrategy(HoodieTable table, HoodieEngineContext engineContext, HoodieWriteConfig writeConfig) {\n+    this.writeConfig = writeConfig;\n+    this.hoodieTable = table;\n+    this.engineContext = engineContext;\n+  }\n+\n+  /**\n+   * Generate metadata for grouping eligible files and create a plan. Note that data is not moved around\n+   * as part of this step.\n+   *\n+   * If there is no data available to cluster, return None.\n+   */\n+  public abstract Option<HoodieClusteringPlan> generateClusteringPlan();\n+\n+  /**\n+   * Return file slices eligible for clustering. FileIds in\n+   * 1) pending clustering/compaction\n+   * 2) Larger than clustering target file size\n+   *\n+   * are not eligible for clustering.\n+   */\n+  protected Stream<FileSlice> getFileSlicesEligibleForClustering(String partition) {\n+    SyncableFileSystemView fileSystemView = (SyncableFileSystemView) getHoodieTable().getSliceView();\n+    Set<HoodieFileGroupId> fgIdsInPendingCompactionAndClustering = fileSystemView.getPendingCompactionOperations()\n+        .map(instantTimeOpPair -> instantTimeOpPair.getValue().getFileGroupId())\n+        .collect(Collectors.toSet());\n+    fgIdsInPendingCompactionAndClustering.addAll(fileSystemView.getFileGroupsInPendingClustering().map(Pair::getKey).collect(Collectors.toSet()));\n+\n+    return hoodieTable.getSliceView().getLatestFileSlices(partition)\n+        // file ids already in clustering are not eligible\n+        .filter(slice -> !fgIdsInPendingCompactionAndClustering.contains(slice.getFileGroupId()));\n+  }\n+\n+  /**\n+   * Get parameters specific to strategy. These parameters are passed from 'schedule clustering' step to\n+   * 'run clustering' step. 'run clustering' step is typically async. So these params help with passing any required\n+   * context from schedule to run step.\n+   */\n+  protected abstract Map<String, String> getStrategyParams();\n+\n+  /**\n+   * Returns any specific parameters to be stored as part of clustering metadata.\n+   */\n+  protected Map<String, String> getExtraMetadata() {\n+    return Collections.emptyMap();\n+  }\n+\n+  /**\n+   * Version to support future changes for plan.\n+   */\n+  protected int getPlanVersion() {\n+    return CLUSTERING_PLAN_VERSION_1;\n+  }\n+\n+  /**\n+   * Transform {@link FileSlice} to {@link HoodieSliceInfo}.\n+   */\n+  protected List<HoodieSliceInfo> getFileSliceInfo(List<FileSlice> slices) {", "originalCommit": "039e6a5931e0da738582b5e7c35691cdf76e803a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjExOTY2OQ==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r546119669", "bodyText": "same something like DayBased? to indicate date partitioning?", "author": "vinothchandar", "createdAt": "2020-12-18T22:25:13Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/table/action/cluster/strategy/PartitionAwareClusteringPlanStrategy.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.table.action.cluster.strategy;\n+\n+import org.apache.hudi.avro.model.HoodieClusteringGroup;\n+import org.apache.hudi.avro.model.HoodieClusteringPlan;\n+import org.apache.hudi.avro.model.HoodieClusteringStrategy;\n+import org.apache.hudi.client.common.HoodieEngineContext;\n+import org.apache.hudi.common.fs.FSUtils;\n+import org.apache.hudi.common.model.FileSlice;\n+import org.apache.hudi.common.model.HoodieRecordPayload;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.util.Option;\n+import org.apache.hudi.config.HoodieWriteConfig;\n+import org.apache.hudi.exception.HoodieIOException;\n+import org.apache.hudi.table.HoodieTable;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ * Scheduling strategy with restriction that clustering groups can only contain files from same partition.\n+ */\n+public abstract class PartitionAwareClusteringPlanStrategy<T extends HoodieRecordPayload,I,K,O> extends ClusteringPlanStrategy<T,I,K,O> {", "originalCommit": "039e6a5931e0da738582b5e7c35691cdf76e803a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjEyMTM2OQ==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r546121369", "bodyText": "also rename the subclass to indicate that it prefers the recent partitions?", "author": "vinothchandar", "createdAt": "2020-12-18T22:30:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjExOTY2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjEyMjI2NA==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r546122264", "bodyText": "Something like hoodie.clustering.small.file.limit", "author": "vinothchandar", "createdAt": "2020-12-18T22:33:32Z", "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/client/clustering/plan/strategy/SparkBoundedDayBasedClusteringPlanStrategy.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.client.clustering.plan.strategy;\n+\n+import org.apache.hudi.avro.model.HoodieClusteringGroup;\n+import org.apache.hudi.client.WriteStatus;\n+import org.apache.hudi.client.common.HoodieSparkEngineContext;\n+import org.apache.hudi.common.model.FileSlice;\n+import org.apache.hudi.common.model.HoodieBaseFile;\n+import org.apache.hudi.common.model.HoodieKey;\n+import org.apache.hudi.common.model.HoodieRecord;\n+import org.apache.hudi.common.model.HoodieRecordPayload;\n+import org.apache.hudi.common.util.collection.Pair;\n+import org.apache.hudi.config.HoodieWriteConfig;\n+import org.apache.hudi.table.HoodieSparkCopyOnWriteTable;\n+import org.apache.hudi.table.HoodieSparkMergeOnReadTable;\n+import org.apache.hudi.table.action.cluster.strategy.PartitionAwareClusteringPlanStrategy;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+import org.apache.spark.api.java.JavaRDD;\n+\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.apache.hudi.config.HoodieClusteringConfig.SORT_COLUMNS_PROPERTY;\n+\n+/**\n+ * Clustering Strategy based on following.\n+ * 1) Spark execution engine.\n+ * 2) Limits amount of data per clustering operation.\n+ */\n+public class SparkBoundedDayBasedClusteringPlanStrategy<T extends HoodieRecordPayload<T>>\n+    extends PartitionAwareClusteringPlanStrategy<T, JavaRDD<HoodieRecord<T>>, JavaRDD<HoodieKey>, JavaRDD<WriteStatus>> {\n+  private static final Logger LOG = LogManager.getLogger(SparkBoundedDayBasedClusteringPlanStrategy.class);\n+\n+  public SparkBoundedDayBasedClusteringPlanStrategy(HoodieSparkCopyOnWriteTable<T> table,\n+                                                    HoodieSparkEngineContext engineContext,\n+                                                    HoodieWriteConfig writeConfig) {\n+    super(table, engineContext, writeConfig);\n+  }\n+\n+  public SparkBoundedDayBasedClusteringPlanStrategy(HoodieSparkMergeOnReadTable<T> table,\n+                                                    HoodieSparkEngineContext engineContext,\n+                                                    HoodieWriteConfig writeConfig) {\n+    super(table, engineContext, writeConfig);\n+  }\n+\n+  @Override\n+  protected Stream<HoodieClusteringGroup> buildClusteringGroupsForPartition(String partitionPath, List<FileSlice> fileSlices) {\n+    List<Pair<List<FileSlice>, Integer>> fileSliceGroups = new ArrayList<>();\n+    List<FileSlice> currentGroup = new ArrayList<>();\n+    int totalSizeSoFar = 0;\n+    for (FileSlice currentSlice : fileSlices) {\n+      // assume each filegroup size is ~= parquet.max.file.size\n+      totalSizeSoFar += currentSlice.getBaseFile().isPresent() ? currentSlice.getBaseFile().get().getFileSize() : getWriteConfig().getParquetMaxFileSize();\n+      // check if max size is reached and create new group, if needed.\n+      if (totalSizeSoFar >= getWriteConfig().getClusteringMaxBytesInGroup() && !currentGroup.isEmpty()) {\n+        fileSliceGroups.add(Pair.of(currentGroup, getNumberOfOutputFileGroups(totalSizeSoFar, getWriteConfig().getClusteringTargetFileMaxBytes())));\n+        currentGroup = new ArrayList<>();\n+        totalSizeSoFar = 0;\n+      }\n+      currentGroup.add(currentSlice);\n+    }\n+    if (!currentGroup.isEmpty()) {\n+      fileSliceGroups.add(Pair.of(currentGroup, getNumberOfOutputFileGroups(totalSizeSoFar, getWriteConfig().getClusteringTargetFileMaxBytes())));\n+    }\n+\n+    return fileSliceGroups.stream().map(fileSliceGroup -> HoodieClusteringGroup.newBuilder()\n+        .setSlices(getFileSliceInfo(fileSliceGroup.getLeft()))\n+        .setNumOutputFileGroups(fileSliceGroup.getRight())\n+        .setMetrics(buildMetrics(fileSliceGroup.getLeft()))\n+        .build());\n+  }\n+\n+  @Override\n+  protected Map<String, String> getStrategyParams() {\n+    Map<String, String> params = new HashMap<>();\n+    if (getWriteConfig().getProps().containsKey(SORT_COLUMNS_PROPERTY)) {\n+      params.put(SORT_COLUMNS_PROPERTY, getWriteConfig().getProps().getProperty(SORT_COLUMNS_PROPERTY));\n+    }\n+    return params;\n+  }\n+\n+  @Override\n+  protected List<String> filterPartitionPaths(List<String> partitionPaths) {\n+    int targetPartitionsForClustering = getWriteConfig().getTargetPartitionsForClustering();\n+    return partitionPaths.stream()\n+        .sorted(Comparator.reverseOrder())\n+        .limit(targetPartitionsForClustering > 0 ? targetPartitionsForClustering : partitionPaths.size())\n+        .collect(Collectors.toList());\n+  }\n+\n+  @Override\n+  protected Stream<FileSlice> getFileSlicesEligibleForClustering(final String partition) {\n+    return super.getFileSlicesEligibleForClustering(partition)\n+        // files that have basefile size larger than clustering target file size are not eligible (Note that compaction can merge any updates)\n+        .filter(slice -> slice.getBaseFile().map(HoodieBaseFile::getFileSize).orElse(0L) < getWriteConfig().getClusteringTargetFileMaxBytes());", "originalCommit": "039e6a5931e0da738582b5e7c35691cdf76e803a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjEyMzA3MQ==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r546123071", "bodyText": "we can add SerializableSchema (we do this for Hadoop Config object) ?", "author": "vinothchandar", "createdAt": "2020-12-18T22:36:11Z", "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/execution/bulkinsert/RDDCustomColumnsSortPartitioner.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.execution.bulkinsert;\n+\n+import org.apache.avro.Schema;\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.hudi.common.model.HoodieRecord;\n+import org.apache.hudi.common.model.HoodieRecordPayload;\n+import org.apache.hudi.table.BulkInsertPartitioner;\n+import org.apache.spark.api.java.JavaRDD;\n+\n+/**\n+ * A partitioner that does sorting based on specified column values for each RDD partition.\n+ *\n+ * @param <T> HoodieRecordPayload type\n+ */\n+public class RDDCustomColumnsSortPartitioner<T extends HoodieRecordPayload>\n+    implements BulkInsertPartitioner<JavaRDD<HoodieRecord<T>>> {\n+\n+  private final String[] sortColumnNames;\n+  private final String schemaString;\n+\n+  public RDDCustomColumnsSortPartitioner(String[] columnNames, Schema schema) {\n+    this.sortColumnNames = columnNames;\n+    //TODO Schema is not serializable. So convert to String here. Figure out how to improve this\n+    this.schemaString = schema.toString();\n+  }\n+\n+  @Override\n+  public JavaRDD<HoodieRecord<T>> repartitionRecords(JavaRDD<HoodieRecord<T>> records,\n+                                                     int outputSparkPartitions) {\n+    final String[] sortColumns = this.sortColumnNames;\n+    final String schemaStr = this.schemaString;\n+    return records.sortBy(record -> {\n+      Schema schema = new Schema.Parser().parse(schemaStr);", "originalCommit": "039e6a5931e0da738582b5e7c35691cdf76e803a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjEyMzYzNw==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r546123637", "bodyText": "See SerialiableConfiguration for reference", "author": "vinothchandar", "createdAt": "2020-12-18T22:38:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjEyMzA3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjEyNDE4Mg==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r546124182", "bodyText": "SparkClusteringCommitActionExecutor?", "author": "vinothchandar", "createdAt": "2020-12-18T22:39:48Z", "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/table/action/cluster/SparkRunClusteringCommitActionExecutor.java", "diffHunk": "@@ -0,0 +1,230 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.table.action.cluster;\n+\n+import org.apache.avro.Schema;\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.avro.generic.IndexedRecord;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.avro.HoodieAvroUtils;\n+import org.apache.hudi.avro.model.HoodieClusteringGroup;\n+import org.apache.hudi.avro.model.HoodieClusteringPlan;\n+import org.apache.hudi.client.SparkTaskContextSupplier;\n+import org.apache.hudi.client.WriteStatus;\n+import org.apache.hudi.client.common.HoodieEngineContext;\n+import org.apache.hudi.client.common.HoodieSparkEngineContext;\n+import org.apache.hudi.client.utils.ConcatenatingIterator;\n+import org.apache.hudi.common.model.ClusteringOperation;\n+import org.apache.hudi.common.model.HoodieCommitMetadata;\n+import org.apache.hudi.common.model.HoodieKey;\n+import org.apache.hudi.common.model.HoodieRecord;\n+import org.apache.hudi.common.model.HoodieRecordPayload;\n+import org.apache.hudi.common.model.WriteOperationType;\n+import org.apache.hudi.common.table.log.HoodieFileSliceReader;\n+import org.apache.hudi.common.table.log.HoodieMergedLogRecordScanner;\n+import org.apache.hudi.common.table.timeline.HoodieInstant;\n+import org.apache.hudi.common.table.timeline.HoodieTimeline;\n+import org.apache.hudi.common.util.ClusteringUtils;\n+import org.apache.hudi.common.util.CommitUtils;\n+import org.apache.hudi.common.util.Option;\n+import org.apache.hudi.common.util.ReflectionUtils;\n+import org.apache.hudi.common.util.collection.Pair;\n+import org.apache.hudi.config.HoodieWriteConfig;\n+import org.apache.hudi.exception.HoodieClusteringException;\n+import org.apache.hudi.io.IOUtils;\n+import org.apache.hudi.io.storage.HoodieFileReader;\n+import org.apache.hudi.io.storage.HoodieFileReaderFactory;\n+import org.apache.hudi.table.HoodieTable;\n+import org.apache.hudi.table.action.HoodieWriteMetadata;\n+import org.apache.hudi.table.action.cluster.strategy.RunClusteringStrategy;\n+import org.apache.hudi.table.action.commit.BaseSparkCommitActionExecutor;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+import org.apache.spark.api.java.JavaRDD;\n+import org.apache.spark.api.java.JavaSparkContext;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.stream.Collectors;\n+\n+public class SparkRunClusteringCommitActionExecutor<T extends HoodieRecordPayload<T>>", "originalCommit": "039e6a5931e0da738582b5e7c35691cdf76e803a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjEyNDgzNg==", "url": "https://github.com/apache/hudi/pull/2263#discussion_r546124836", "bodyText": "this is very cool!", "author": "vinothchandar", "createdAt": "2020-12-18T22:42:07Z", "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/table/action/cluster/SparkRunClusteringCommitActionExecutor.java", "diffHunk": "@@ -0,0 +1,230 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.table.action.cluster;\n+\n+import org.apache.avro.Schema;\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.avro.generic.IndexedRecord;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.avro.HoodieAvroUtils;\n+import org.apache.hudi.avro.model.HoodieClusteringGroup;\n+import org.apache.hudi.avro.model.HoodieClusteringPlan;\n+import org.apache.hudi.client.SparkTaskContextSupplier;\n+import org.apache.hudi.client.WriteStatus;\n+import org.apache.hudi.client.common.HoodieEngineContext;\n+import org.apache.hudi.client.common.HoodieSparkEngineContext;\n+import org.apache.hudi.client.utils.ConcatenatingIterator;\n+import org.apache.hudi.common.model.ClusteringOperation;\n+import org.apache.hudi.common.model.HoodieCommitMetadata;\n+import org.apache.hudi.common.model.HoodieKey;\n+import org.apache.hudi.common.model.HoodieRecord;\n+import org.apache.hudi.common.model.HoodieRecordPayload;\n+import org.apache.hudi.common.model.WriteOperationType;\n+import org.apache.hudi.common.table.log.HoodieFileSliceReader;\n+import org.apache.hudi.common.table.log.HoodieMergedLogRecordScanner;\n+import org.apache.hudi.common.table.timeline.HoodieInstant;\n+import org.apache.hudi.common.table.timeline.HoodieTimeline;\n+import org.apache.hudi.common.util.ClusteringUtils;\n+import org.apache.hudi.common.util.CommitUtils;\n+import org.apache.hudi.common.util.Option;\n+import org.apache.hudi.common.util.ReflectionUtils;\n+import org.apache.hudi.common.util.collection.Pair;\n+import org.apache.hudi.config.HoodieWriteConfig;\n+import org.apache.hudi.exception.HoodieClusteringException;\n+import org.apache.hudi.io.IOUtils;\n+import org.apache.hudi.io.storage.HoodieFileReader;\n+import org.apache.hudi.io.storage.HoodieFileReaderFactory;\n+import org.apache.hudi.table.HoodieTable;\n+import org.apache.hudi.table.action.HoodieWriteMetadata;\n+import org.apache.hudi.table.action.cluster.strategy.RunClusteringStrategy;\n+import org.apache.hudi.table.action.commit.BaseSparkCommitActionExecutor;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+import org.apache.spark.api.java.JavaRDD;\n+import org.apache.spark.api.java.JavaSparkContext;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.stream.Collectors;\n+\n+public class SparkRunClusteringCommitActionExecutor<T extends HoodieRecordPayload<T>>\n+    extends BaseSparkCommitActionExecutor<T> {\n+\n+  private static final Logger LOG = LogManager.getLogger(SparkRunClusteringCommitActionExecutor.class);\n+  private final HoodieClusteringPlan clusteringPlan;\n+\n+  public SparkRunClusteringCommitActionExecutor(HoodieEngineContext context,\n+                                                HoodieWriteConfig config, HoodieTable table,\n+                                                String instantTime) {\n+    super(context, config, table, instantTime, WriteOperationType.CLUSTER);\n+    this.clusteringPlan = ClusteringUtils.getClusteringPlan(table.getMetaClient(), HoodieTimeline.getReplaceCommitRequestedInstant(instantTime))\n+      .map(Pair::getRight).orElseThrow(() -> new HoodieClusteringException(\"Unable to read clustering plan for instant: \" + instantTime));\n+  }\n+\n+  @Override\n+  public HoodieWriteMetadata<JavaRDD<WriteStatus>> execute() {\n+    HoodieInstant instant = HoodieTimeline.getReplaceCommitRequestedInstant(instantTime);\n+    // Mark instant as clustering inflight\n+    table.getActiveTimeline().transitionReplaceRequestedToInflight(instant, Option.empty());\n+    table.getMetaClient().reloadActiveTimeline();\n+\n+    JavaSparkContext engineContext = HoodieSparkEngineContext.getSparkContext(context);\n+    // run clustering for each group async and collect WriteStatus\n+    JavaRDD<WriteStatus> writeStatusRDD = clusteringPlan.getInputGroups().stream()", "originalCommit": "039e6a5931e0da738582b5e7c35691cdf76e803a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6191f6c2b487c2c16947aff8b1ff75ea209b0f08", "url": "https://github.com/apache/hudi/commit/6191f6c2b487c2c16947aff8b1ff75ea209b0f08", "message": "[HUDI-1075] Implement simple clustering strategies to create ClusteringPlan and to run the plan", "committedDate": "2020-12-21T20:11:57Z", "type": "forcePushed"}, {"oid": "27935d447e7a32def984fe1c542893fc578cedb9", "url": "https://github.com/apache/hudi/commit/27935d447e7a32def984fe1c542893fc578cedb9", "message": "[HUDI-1075] Implement simple clustering strategies to create ClusteringPlan and to run the plan", "committedDate": "2020-12-21T23:06:24Z", "type": "forcePushed"}, {"oid": "6dc03b65bfd98d0a1fde2d48ebb31f36b1186cf9", "url": "https://github.com/apache/hudi/commit/6dc03b65bfd98d0a1fde2d48ebb31f36b1186cf9", "message": "[HUDI-1075] Implement simple clustering strategies to create ClusteringPlan and to run the plan", "committedDate": "2020-12-22T01:34:15Z", "type": "commit"}, {"oid": "6dc03b65bfd98d0a1fde2d48ebb31f36b1186cf9", "url": "https://github.com/apache/hudi/commit/6dc03b65bfd98d0a1fde2d48ebb31f36b1186cf9", "message": "[HUDI-1075] Implement simple clustering strategies to create ClusteringPlan and to run the plan", "committedDate": "2020-12-22T01:34:15Z", "type": "forcePushed"}]}