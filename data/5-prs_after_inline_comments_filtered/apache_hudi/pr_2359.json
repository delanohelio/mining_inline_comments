{"pr_number": 2359, "pr_title": "[HUDI-1486] Remove inflight rollback in hoodie writer", "pr_createdAt": "2020-12-22T04:42:11Z", "pr_url": "https://github.com/apache/hudi/pull/2359", "timeline": [{"oid": "b8c9cb6d64689ca00f551c982a2707e3e09e340a", "url": "https://github.com/apache/hudi/commit/b8c9cb6d64689ca00f551c982a2707e3e09e340a", "message": "[HUDI-1486] Remove inline inflight rollback in hoodie writer\n1. Refactor rollback and move cleaning failed commits logic into cleaner\n2. Introduce hoodie heartbeat to ascertain failed commits\n3. Fix test cases", "committedDate": "2020-12-22T04:43:24Z", "type": "forcePushed"}, {"oid": "f858d5d192b5da3b171671f38c4b1f414e329c61", "url": "https://github.com/apache/hudi/commit/f858d5d192b5da3b171671f38c4b1f414e329c61", "message": "Adding configs to make failed writes eager/lazy", "committedDate": "2020-12-26T06:58:47Z", "type": "forcePushed"}, {"oid": "e45bf61e837827cd737037c4e8fa80c73c272ba1", "url": "https://github.com/apache/hudi/commit/e45bf61e837827cd737037c4e8fa80c73c272ba1", "message": "Adding configs to make failed writes eager/lazy", "committedDate": "2020-12-26T07:14:34Z", "type": "forcePushed"}, {"oid": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb", "url": "https://github.com/apache/hudi/commit/35a82c7f68c8bf0b381e47dc3f12374bec7081eb", "message": "Adding configs to make failed writes eager/lazy", "committedDate": "2020-12-28T08:22:37Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQzMjE1MA==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549432150", "bodyText": "these seem like fixes we should make regardless? cc @satishkotha  ?", "author": "vinothchandar", "createdAt": "2020-12-28T17:53:33Z", "path": "hudi-cli/src/main/java/org/apache/hudi/cli/commands/FileSystemViewCommand.java", "diffHunk": "@@ -249,7 +249,7 @@ private HoodieTableFileSystemView buildFileSystemView(String globRegex, String m\n     } else if (excludeCompaction) {\n       timeline = metaClient.getActiveTimeline().getCommitsTimeline();\n     } else {\n-      timeline = metaClient.getActiveTimeline().getCommitsAndCompactionTimeline();\n+      timeline = metaClient.getActiveTimeline().getCommitsCompactionAndReplaceTimeline();", "originalCommit": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQzMjU5Mg==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549432592", "bodyText": "nit: just heartbeatClient ?", "author": "vinothchandar", "createdAt": "2020-12-28T17:54:47Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieClient.java", "diffHunk": "@@ -70,6 +72,7 @@ protected AbstractHoodieClient(HoodieEngineContext context, HoodieWriteConfig cl\n     this.config = clientConfig;\n     this.timelineServer = timelineServer;\n     shouldStopTimelineServer = !timelineServer.isPresent();\n+    this.hoodieHeartbeatClient = new HoodieHeartbeatClient(this.fs, this.basePath, clientConfig.getHoodieClientHeartbeatIntervalInSecs());", "originalCommit": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQzMjk5Nw==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549432997", "bodyText": "can we do this in postCommit(), so all these things are in one place.", "author": "vinothchandar", "createdAt": "2020-12-28T17:56:14Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -160,7 +180,9 @@ public boolean commit(String instantTime, O writeStatuses) {\n   public boolean commit(String instantTime, O writeStatuses, Option<Map<String, String>> extraMetadata) {\n     HoodieTableMetaClient metaClient = createMetaClient(false);\n     String actionType = metaClient.getCommitActionType();\n-    return commit(instantTime, writeStatuses, extraMetadata, actionType, Collections.emptyMap());\n+    boolean isCommitted = commit(instantTime, writeStatuses, extraMetadata, actionType, Collections.emptyMap());\n+    this.hoodieHeartbeatClient.stop(instantTime);", "originalCommit": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQzMzEzMQ==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549433131", "bodyText": "bootstrap reattempt will do this IIRC", "author": "vinothchandar", "createdAt": "2020-12-28T17:56:39Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -232,17 +254,18 @@ void emitCommitMetrics(String instantTime, HoodieCommitMetadata metadata, String\n    * Main API to run bootstrap to hudi.\n    */\n   public void bootstrap(Option<Map<String, String>> extraMetadata) {\n-    if (rollbackPending) {\n-      rollBackInflightBootstrap();\n-    }\n+    // TODO : MULTIWRITER -> check if failed bootstrap files can be cleaned later", "originalCommit": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTk5NzIwMA==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549997200", "bodyText": "Yes, but now I'm making cleaning/rolling back optional during that reattempt, so want to make sure it's OK to clean/delete later..", "author": "n3nash", "createdAt": "2020-12-30T07:44:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQzMzEzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQzMzU1Mg==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549433552", "bodyText": "may be pull HoodieFailedWritesCleaningPolicy into its own file? shorter read everywhere.", "author": "vinothchandar", "createdAt": "2020-12-28T17:58:07Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -232,17 +254,18 @@ void emitCommitMetrics(String instantTime, HoodieCommitMetadata metadata, String\n    * Main API to run bootstrap to hudi.\n    */\n   public void bootstrap(Option<Map<String, String>> extraMetadata) {\n-    if (rollbackPending) {\n-      rollBackInflightBootstrap();\n-    }\n+    // TODO : MULTIWRITER -> check if failed bootstrap files can be cleaned later\n     HoodieTable<T, I, K, O> table = getTableAndInitCtx(WriteOperationType.UPSERT, HoodieTimeline.METADATA_BOOTSTRAP_INSTANT_TS);\n+    if (config.getFailedWritesCleanPolicy() == HoodieCleaningPolicy.HoodieFailedWritesCleaningPolicy.EAGER) {", "originalCommit": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQzNDYyMQ==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549434621", "bodyText": "this sort of block is repeated in many places. lets see if we can invest in some helpers?", "author": "vinothchandar", "createdAt": "2020-12-28T18:02:05Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -615,6 +640,11 @@ public String startCommit() {\n    * @param instantTime Instant time to be generated\n    */\n   public void startCommitWithTime(String instantTime) {\n+    if (config.getFailedWritesCleanPolicy() == HoodieCleaningPolicy.HoodieFailedWritesCleaningPolicy.LAZY) {", "originalCommit": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDM2MDA1OQ==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r550360059", "bodyText": "Added a private method", "author": "n3nash", "createdAt": "2020-12-31T00:00:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQzNDYyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQzNDgwNw==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549434807", "bodyText": "why is this public now?", "author": "vinothchandar", "createdAt": "2020-12-28T18:02:50Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -712,24 +742,43 @@ public void rollbackInflightCompaction(HoodieInstant inflightInstant, HoodieTabl\n   }\n \n   /**\n-   * Cleanup all pending commits.\n+   * Rollback all failed commits.\n    */\n-  private void rollbackPendingCommits() {\n+  public void rollbackFailedCommits() {", "originalCommit": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTk4MjEzOA==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549982138", "bodyText": "Intention is to make rollback() private, since this is the first release, I've only marked it as @deprecated. Going forward people should use the following 2 API's : restore() to revert successful commits and rollbackFailedCommits() to delete failed writes.", "author": "n3nash", "createdAt": "2020-12-30T07:24:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQzNDgwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTYxOTY3OA==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r551619678", "bodyText": "okay makes sense.  left a comment above for renaming.", "author": "vinothchandar", "createdAt": "2021-01-04T23:02:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQzNDgwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQzNTA1NA==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549435054", "bodyText": "rename: .close() or shutDown() to differentiate from the other usage", "author": "vinothchandar", "createdAt": "2020-12-28T18:03:35Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -875,5 +924,6 @@ public void close() {\n     // Calling this here releases any resources used by your index, so make sure to finish any related operations\n     // before this point\n     this.index.close();\n+    this.hoodieHeartbeatClient.stop();", "originalCommit": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTk5NzYyNg==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549997626", "bodyText": "Did not follow, can you explain what you mean by \"differentiate from other usage\" ?", "author": "n3nash", "createdAt": "2020-12-30T07:45:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQzNTA1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUxMDgwMg==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549510802", "bodyText": "nit. Collections.EMPTY_LIST?", "author": "vinothchandar", "createdAt": "2020-12-28T22:52:59Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -712,24 +742,43 @@ public void rollbackInflightCompaction(HoodieInstant inflightInstant, HoodieTabl\n   }\n \n   /**\n-   * Cleanup all pending commits.\n+   * Rollback all failed commits.\n    */\n-  private void rollbackPendingCommits() {\n+  public void rollbackFailedCommits() {\n     HoodieTable<T, I, K, O> table = createTable(config, hadoopConf);\n-    HoodieTimeline inflightTimeline = table.getMetaClient().getCommitsTimeline().filterPendingExcludingCompaction();\n-    List<String> commits = inflightTimeline.getReverseOrderedInstants().map(HoodieInstant::getTimestamp)\n-        .collect(Collectors.toList());\n-    for (String commit : commits) {\n-      if (HoodieTimeline.compareTimestamps(commit, HoodieTimeline.LESSER_THAN_OR_EQUALS,\n+    List<String> instantsToRollback = getInstantsToRollback(table);\n+    for (String instant : instantsToRollback) {\n+      if (HoodieTimeline.compareTimestamps(instant, HoodieTimeline.LESSER_THAN_OR_EQUALS,\n           HoodieTimeline.FULL_BOOTSTRAP_INSTANT_TS)) {\n-        rollBackInflightBootstrap();\n+        rollbackFailedBootstrap();\n         break;\n       } else {\n-        rollback(commit);\n+        rollback(instant);\n       }\n     }\n   }\n \n+  private List<String> getInstantsToRollback(HoodieTable<T, I, K, O> table) {\n+    if (config.getFailedWritesCleanPolicy() == HoodieCleaningPolicy.HoodieFailedWritesCleaningPolicy.EAGER) {\n+      HoodieTimeline inflightTimeline = table.getMetaClient().getCommitsTimeline().filterPendingExcludingCompaction();\n+      return inflightTimeline.getReverseOrderedInstants().map(HoodieInstant::getTimestamp)\n+          .collect(Collectors.toList());\n+    } else if (config.getFailedWritesCleanPolicy() == HoodieCleaningPolicy.HoodieFailedWritesCleaningPolicy.LAZY) {\n+      return table.getMetaClient().getActiveTimeline()\n+          .getCommitsTimeline().filterInflights().getReverseOrderedInstants().filter(instant -> {\n+            try {\n+              return !hoodieHeartbeatClient.checkIfConcurrentWriterRunning(instant.getTimestamp());\n+            } catch (IOException io) {\n+              throw new HoodieException(\"Failed to check heartbeat for instant \" + instant, io);\n+            }\n+          }).map(HoodieInstant::getTimestamp).collect(Collectors.toList());\n+    } else if (config.getFailedWritesCleanPolicy() == HoodieCleaningPolicy.HoodieFailedWritesCleaningPolicy.NEVER) {\n+      return new ArrayList<>();", "originalCommit": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUxMDk2MA==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549510960", "bodyText": "please move the property closer to the default values", "author": "vinothchandar", "createdAt": "2020-12-28T22:53:50Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/config/HoodieCompactionConfig.java", "diffHunk": "@@ -39,6 +39,7 @@\n public class HoodieCompactionConfig extends DefaultHoodieConfig {\n \n   public static final String CLEANER_POLICY_PROP = \"hoodie.cleaner.policy\";\n+  public static final String FAILED_WRITES_CLEANER_POLICY_PROP = \"hoodie.failed.writes.cleaner.policy\";", "originalCommit": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUxMTQ0NA==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549511444", "bodyText": "rename :  WRITER_CONCURRENCY_MODE, instead of model. its more understandable for users. MULTI seems redundant", "author": "vinothchandar", "createdAt": "2020-12-28T22:56:12Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/config/HoodieWriteConfig.java", "diffHunk": "@@ -140,6 +144,10 @@\n   public static final String EXTERNAL_RECORD_AND_SCHEMA_TRANSFORMATION = AVRO_SCHEMA + \".externalTransformation\";\n   public static final String DEFAULT_EXTERNAL_RECORD_AND_SCHEMA_TRANSFORMATION = \"false\";\n \n+  public static final String MULTI_WRITER_CONCURRENCY_MODEL_PROP =", "originalCommit": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUxMjc3Mw==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549512773", "bodyText": "why not just keep the config at ms level. I think thats better to do .", "author": "vinothchandar", "createdAt": "2020-12-28T23:03:26Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/heartbeat/HoodieHeartbeatClient.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.client.heartbeat;\n+\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.util.ValidationUtils;\n+import org.apache.hudi.exception.HoodieException;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InterruptedIOException;\n+import java.io.OutputStream;\n+import java.io.Serializable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+\n+/**\n+ * This class creates heartbeat for hudi client. This heartbeat is used to ascertain whether the running job is or not.\n+ * NOTE: Due to CPU contention on the driver/client node, the heartbeats could be delayed, hence it's important to set\n+ *       the value high enough to avoid that possibility.\n+ */\n+@NotThreadSafe\n+public class HoodieHeartbeatClient implements AutoCloseable, Serializable {\n+\n+  // TODO : Throw new exception from thread\n+  private static final Logger LOG = LogManager.getLogger(HoodieHeartbeatClient.class);\n+\n+  // path to the hearbeat folder where all writers are updating their heartbeats\n+  private final transient FileSystem fs;\n+  private final String basePath;\n+  private String heartBeatFolderPath;\n+  private String currentInstantTime;\n+  private int numHeartBeatsForCurrentInstantTime;\n+  // heartbeat interval in millis\n+  private final long heartbeatIntervalInMillis;\n+  private final transient ExecutorService executorService = Executors.newSingleThreadExecutor();\n+  private volatile boolean shutdownRequested;\n+  private boolean isHearbeatStarted = false;\n+  private boolean isHeatBeatStopped = false;\n+  private transient Future<?> heartBeatFuture;\n+  private Long lastHeartBeatTime;\n+  // This is required for testing. Problem : if we set heartbeatIntervalInSeconds really large, test takes longer, if\n+  // we set it small and you are debugging with breakpoint, causes issues. Need to implement a Mock in tests\n+  private final Boolean skipHeartBeatCheck;\n+\n+  public HoodieHeartbeatClient(FileSystem fs, String basePath, long heartbeatIntervalInSeconds) {\n+    ValidationUtils.checkArgument(heartbeatIntervalInSeconds >= 1, \"Cannot set heartbeat lower than 1 second\");\n+    this.fs = fs;\n+    this.basePath = basePath;\n+    this.heartBeatFolderPath = HoodieTableMetaClient.getHeartbeatFolderPath(basePath);\n+    this.heartbeatIntervalInMillis = heartbeatIntervalInSeconds * 1000L;", "originalCommit": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUxMzE2NQ==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549513165", "bodyText": "so this is assuming the single write client won't have multiple writers. i.e will issue start(instantTime) for only one instant at any time. Can we use a Map per instantTime and maintain state such that the heartbeatClient can handle multiple instant times at once", "author": "vinothchandar", "createdAt": "2020-12-28T23:05:21Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/heartbeat/HoodieHeartbeatClient.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.client.heartbeat;\n+\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.util.ValidationUtils;\n+import org.apache.hudi.exception.HoodieException;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InterruptedIOException;\n+import java.io.OutputStream;\n+import java.io.Serializable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+\n+/**\n+ * This class creates heartbeat for hudi client. This heartbeat is used to ascertain whether the running job is or not.\n+ * NOTE: Due to CPU contention on the driver/client node, the heartbeats could be delayed, hence it's important to set\n+ *       the value high enough to avoid that possibility.\n+ */\n+@NotThreadSafe\n+public class HoodieHeartbeatClient implements AutoCloseable, Serializable {\n+\n+  // TODO : Throw new exception from thread\n+  private static final Logger LOG = LogManager.getLogger(HoodieHeartbeatClient.class);\n+\n+  // path to the hearbeat folder where all writers are updating their heartbeats\n+  private final transient FileSystem fs;\n+  private final String basePath;\n+  private String heartBeatFolderPath;\n+  private String currentInstantTime;\n+  private int numHeartBeatsForCurrentInstantTime;\n+  // heartbeat interval in millis\n+  private final long heartbeatIntervalInMillis;\n+  private final transient ExecutorService executorService = Executors.newSingleThreadExecutor();\n+  private volatile boolean shutdownRequested;\n+  private boolean isHearbeatStarted = false;\n+  private boolean isHeatBeatStopped = false;\n+  private transient Future<?> heartBeatFuture;\n+  private Long lastHeartBeatTime;\n+  // This is required for testing. Problem : if we set heartbeatIntervalInSeconds really large, test takes longer, if\n+  // we set it small and you are debugging with breakpoint, causes issues. Need to implement a Mock in tests\n+  private final Boolean skipHeartBeatCheck;\n+\n+  public HoodieHeartbeatClient(FileSystem fs, String basePath, long heartbeatIntervalInSeconds) {\n+    ValidationUtils.checkArgument(heartbeatIntervalInSeconds >= 1, \"Cannot set heartbeat lower than 1 second\");\n+    this.fs = fs;\n+    this.basePath = basePath;\n+    this.heartBeatFolderPath = HoodieTableMetaClient.getHeartbeatFolderPath(basePath);\n+    this.heartbeatIntervalInMillis = heartbeatIntervalInSeconds * 1000L;\n+    this.skipHeartBeatCheck = true;\n+  }\n+\n+  public void start(String instantTime) {\n+    LOG.info(\"Received request to start heartbeat for instant time \" + instantTime);\n+    if (isHearbeatStarted && instantTime == currentInstantTime) {\n+      // heartbeat already started, NO_OP\n+      return;\n+    } else if (instantTime != currentInstantTime) {\n+      if (this.currentInstantTime != null) {\n+        LOG.warn(\"Stopping heartbeat for previous instant time \" + this.currentInstantTime);\n+        this.stop(this.currentInstantTime);\n+      }\n+      this.currentInstantTime = instantTime;", "originalCommit": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQwNTYxMQ==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r550405611", "bodyText": "Refactored.", "author": "n3nash", "createdAt": "2020-12-31T06:09:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUxMzE2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUxMzM4OQ==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549513389", "bodyText": "can we use a TimerTask or TimerService. it can also support multiple of these schedules", "author": "vinothchandar", "createdAt": "2020-12-28T23:06:32Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/heartbeat/HoodieHeartbeatClient.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.client.heartbeat;\n+\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.util.ValidationUtils;\n+import org.apache.hudi.exception.HoodieException;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InterruptedIOException;\n+import java.io.OutputStream;\n+import java.io.Serializable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+\n+/**\n+ * This class creates heartbeat for hudi client. This heartbeat is used to ascertain whether the running job is or not.\n+ * NOTE: Due to CPU contention on the driver/client node, the heartbeats could be delayed, hence it's important to set\n+ *       the value high enough to avoid that possibility.\n+ */\n+@NotThreadSafe\n+public class HoodieHeartbeatClient implements AutoCloseable, Serializable {\n+\n+  // TODO : Throw new exception from thread\n+  private static final Logger LOG = LogManager.getLogger(HoodieHeartbeatClient.class);\n+\n+  // path to the hearbeat folder where all writers are updating their heartbeats\n+  private final transient FileSystem fs;\n+  private final String basePath;\n+  private String heartBeatFolderPath;\n+  private String currentInstantTime;\n+  private int numHeartBeatsForCurrentInstantTime;\n+  // heartbeat interval in millis\n+  private final long heartbeatIntervalInMillis;\n+  private final transient ExecutorService executorService = Executors.newSingleThreadExecutor();\n+  private volatile boolean shutdownRequested;\n+  private boolean isHearbeatStarted = false;\n+  private boolean isHeatBeatStopped = false;\n+  private transient Future<?> heartBeatFuture;\n+  private Long lastHeartBeatTime;\n+  // This is required for testing. Problem : if we set heartbeatIntervalInSeconds really large, test takes longer, if\n+  // we set it small and you are debugging with breakpoint, causes issues. Need to implement a Mock in tests\n+  private final Boolean skipHeartBeatCheck;\n+\n+  public HoodieHeartbeatClient(FileSystem fs, String basePath, long heartbeatIntervalInSeconds) {\n+    ValidationUtils.checkArgument(heartbeatIntervalInSeconds >= 1, \"Cannot set heartbeat lower than 1 second\");\n+    this.fs = fs;\n+    this.basePath = basePath;\n+    this.heartBeatFolderPath = HoodieTableMetaClient.getHeartbeatFolderPath(basePath);\n+    this.heartbeatIntervalInMillis = heartbeatIntervalInSeconds * 1000L;\n+    this.skipHeartBeatCheck = true;\n+  }\n+\n+  public void start(String instantTime) {\n+    LOG.info(\"Received request to start heartbeat for instant time \" + instantTime);\n+    if (isHearbeatStarted && instantTime == currentInstantTime) {\n+      // heartbeat already started, NO_OP\n+      return;\n+    } else if (instantTime != currentInstantTime) {\n+      if (this.currentInstantTime != null) {\n+        LOG.warn(\"Stopping heartbeat for previous instant time \" + this.currentInstantTime);\n+        this.stop(this.currentInstantTime);\n+      }\n+      this.currentInstantTime = instantTime;\n+      this.numHeartBeatsForCurrentInstantTime = 0;\n+      this.shutdownRequested = false;\n+    }\n+    try {\n+      updateHeartbeat(instantTime);\n+    } catch (Exception e) {\n+      throw new RuntimeException(\"Unable to generate heartbeat\");\n+    }\n+    this.heartBeatFuture = executorService.submit(() -> {", "originalCommit": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQwNTUzMA==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r550405530", "bodyText": "Added.", "author": "n3nash", "createdAt": "2020-12-31T06:08:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUxMzM4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUxMzU2Mw==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549513563", "bodyText": "this is always true?", "author": "vinothchandar", "createdAt": "2020-12-28T23:07:19Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/heartbeat/HoodieHeartbeatClient.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.client.heartbeat;\n+\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.util.ValidationUtils;\n+import org.apache.hudi.exception.HoodieException;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InterruptedIOException;\n+import java.io.OutputStream;\n+import java.io.Serializable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+\n+/**\n+ * This class creates heartbeat for hudi client. This heartbeat is used to ascertain whether the running job is or not.\n+ * NOTE: Due to CPU contention on the driver/client node, the heartbeats could be delayed, hence it's important to set\n+ *       the value high enough to avoid that possibility.\n+ */\n+@NotThreadSafe\n+public class HoodieHeartbeatClient implements AutoCloseable, Serializable {\n+\n+  // TODO : Throw new exception from thread\n+  private static final Logger LOG = LogManager.getLogger(HoodieHeartbeatClient.class);\n+\n+  // path to the hearbeat folder where all writers are updating their heartbeats\n+  private final transient FileSystem fs;\n+  private final String basePath;\n+  private String heartBeatFolderPath;\n+  private String currentInstantTime;\n+  private int numHeartBeatsForCurrentInstantTime;\n+  // heartbeat interval in millis\n+  private final long heartbeatIntervalInMillis;\n+  private final transient ExecutorService executorService = Executors.newSingleThreadExecutor();\n+  private volatile boolean shutdownRequested;\n+  private boolean isHearbeatStarted = false;\n+  private boolean isHeatBeatStopped = false;\n+  private transient Future<?> heartBeatFuture;\n+  private Long lastHeartBeatTime;\n+  // This is required for testing. Problem : if we set heartbeatIntervalInSeconds really large, test takes longer, if\n+  // we set it small and you are debugging with breakpoint, causes issues. Need to implement a Mock in tests\n+  private final Boolean skipHeartBeatCheck;", "originalCommit": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQwNTUwOA==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r550405508", "bodyText": "Remnant of testing, remove it", "author": "n3nash", "createdAt": "2020-12-31T06:08:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUxMzU2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUxMzkwNQ==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549513905", "bodyText": "then all we need to is to cancel the timers", "author": "vinothchandar", "createdAt": "2020-12-28T23:09:07Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/heartbeat/HoodieHeartbeatClient.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.client.heartbeat;\n+\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.util.ValidationUtils;\n+import org.apache.hudi.exception.HoodieException;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InterruptedIOException;\n+import java.io.OutputStream;\n+import java.io.Serializable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+\n+/**\n+ * This class creates heartbeat for hudi client. This heartbeat is used to ascertain whether the running job is or not.\n+ * NOTE: Due to CPU contention on the driver/client node, the heartbeats could be delayed, hence it's important to set\n+ *       the value high enough to avoid that possibility.\n+ */\n+@NotThreadSafe\n+public class HoodieHeartbeatClient implements AutoCloseable, Serializable {\n+\n+  // TODO : Throw new exception from thread\n+  private static final Logger LOG = LogManager.getLogger(HoodieHeartbeatClient.class);\n+\n+  // path to the hearbeat folder where all writers are updating their heartbeats\n+  private final transient FileSystem fs;\n+  private final String basePath;\n+  private String heartBeatFolderPath;\n+  private String currentInstantTime;\n+  private int numHeartBeatsForCurrentInstantTime;\n+  // heartbeat interval in millis\n+  private final long heartbeatIntervalInMillis;\n+  private final transient ExecutorService executorService = Executors.newSingleThreadExecutor();\n+  private volatile boolean shutdownRequested;\n+  private boolean isHearbeatStarted = false;\n+  private boolean isHeatBeatStopped = false;\n+  private transient Future<?> heartBeatFuture;\n+  private Long lastHeartBeatTime;\n+  // This is required for testing. Problem : if we set heartbeatIntervalInSeconds really large, test takes longer, if\n+  // we set it small and you are debugging with breakpoint, causes issues. Need to implement a Mock in tests\n+  private final Boolean skipHeartBeatCheck;\n+\n+  public HoodieHeartbeatClient(FileSystem fs, String basePath, long heartbeatIntervalInSeconds) {\n+    ValidationUtils.checkArgument(heartbeatIntervalInSeconds >= 1, \"Cannot set heartbeat lower than 1 second\");\n+    this.fs = fs;\n+    this.basePath = basePath;\n+    this.heartBeatFolderPath = HoodieTableMetaClient.getHeartbeatFolderPath(basePath);\n+    this.heartbeatIntervalInMillis = heartbeatIntervalInSeconds * 1000L;\n+    this.skipHeartBeatCheck = true;\n+  }\n+\n+  public void start(String instantTime) {\n+    LOG.info(\"Received request to start heartbeat for instant time \" + instantTime);\n+    if (isHearbeatStarted && instantTime == currentInstantTime) {\n+      // heartbeat already started, NO_OP\n+      return;\n+    } else if (instantTime != currentInstantTime) {\n+      if (this.currentInstantTime != null) {\n+        LOG.warn(\"Stopping heartbeat for previous instant time \" + this.currentInstantTime);\n+        this.stop(this.currentInstantTime);\n+      }\n+      this.currentInstantTime = instantTime;\n+      this.numHeartBeatsForCurrentInstantTime = 0;\n+      this.shutdownRequested = false;\n+    }\n+    try {\n+      updateHeartbeat(instantTime);\n+    } catch (Exception e) {\n+      throw new RuntimeException(\"Unable to generate heartbeat\");\n+    }\n+    this.heartBeatFuture = executorService.submit(() -> {\n+      while (!shutdownRequested) {\n+        try {\n+          Thread.sleep(this.heartbeatIntervalInMillis);\n+          updateHeartbeat(instantTime);\n+        } catch (InterruptedIOException | InterruptedException ioe) {\n+          LOG.warn(\"Thread controlling heartbeat was interrupted\");\n+        } catch (IOException ioe) {\n+          LOG.error(\"Unable to create heartbeat file\", ioe);\n+          throw new RuntimeException(ioe);\n+        }\n+      }\n+    });\n+    this.isHearbeatStarted = true;", "originalCommit": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUxNDQ0Mw==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549514443", "bodyText": "this is leaking upper level context (multi writing) to a lower level class. We should just name this something around heartbeats. say isHeartbeatExpired()", "author": "vinothchandar", "createdAt": "2020-12-28T23:12:07Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/heartbeat/HoodieHeartbeatClient.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.client.heartbeat;\n+\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.util.ValidationUtils;\n+import org.apache.hudi.exception.HoodieException;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InterruptedIOException;\n+import java.io.OutputStream;\n+import java.io.Serializable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+\n+/**\n+ * This class creates heartbeat for hudi client. This heartbeat is used to ascertain whether the running job is or not.\n+ * NOTE: Due to CPU contention on the driver/client node, the heartbeats could be delayed, hence it's important to set\n+ *       the value high enough to avoid that possibility.\n+ */\n+@NotThreadSafe\n+public class HoodieHeartbeatClient implements AutoCloseable, Serializable {\n+\n+  // TODO : Throw new exception from thread\n+  private static final Logger LOG = LogManager.getLogger(HoodieHeartbeatClient.class);\n+\n+  // path to the hearbeat folder where all writers are updating their heartbeats\n+  private final transient FileSystem fs;\n+  private final String basePath;\n+  private String heartBeatFolderPath;\n+  private String currentInstantTime;\n+  private int numHeartBeatsForCurrentInstantTime;\n+  // heartbeat interval in millis\n+  private final long heartbeatIntervalInMillis;\n+  private final transient ExecutorService executorService = Executors.newSingleThreadExecutor();\n+  private volatile boolean shutdownRequested;\n+  private boolean isHearbeatStarted = false;\n+  private boolean isHeatBeatStopped = false;\n+  private transient Future<?> heartBeatFuture;\n+  private Long lastHeartBeatTime;\n+  // This is required for testing. Problem : if we set heartbeatIntervalInSeconds really large, test takes longer, if\n+  // we set it small and you are debugging with breakpoint, causes issues. Need to implement a Mock in tests\n+  private final Boolean skipHeartBeatCheck;\n+\n+  public HoodieHeartbeatClient(FileSystem fs, String basePath, long heartbeatIntervalInSeconds) {\n+    ValidationUtils.checkArgument(heartbeatIntervalInSeconds >= 1, \"Cannot set heartbeat lower than 1 second\");\n+    this.fs = fs;\n+    this.basePath = basePath;\n+    this.heartBeatFolderPath = HoodieTableMetaClient.getHeartbeatFolderPath(basePath);\n+    this.heartbeatIntervalInMillis = heartbeatIntervalInSeconds * 1000L;\n+    this.skipHeartBeatCheck = true;\n+  }\n+\n+  public void start(String instantTime) {\n+    LOG.info(\"Received request to start heartbeat for instant time \" + instantTime);\n+    if (isHearbeatStarted && instantTime == currentInstantTime) {\n+      // heartbeat already started, NO_OP\n+      return;\n+    } else if (instantTime != currentInstantTime) {\n+      if (this.currentInstantTime != null) {\n+        LOG.warn(\"Stopping heartbeat for previous instant time \" + this.currentInstantTime);\n+        this.stop(this.currentInstantTime);\n+      }\n+      this.currentInstantTime = instantTime;\n+      this.numHeartBeatsForCurrentInstantTime = 0;\n+      this.shutdownRequested = false;\n+    }\n+    try {\n+      updateHeartbeat(instantTime);\n+    } catch (Exception e) {\n+      throw new RuntimeException(\"Unable to generate heartbeat\");\n+    }\n+    this.heartBeatFuture = executorService.submit(() -> {\n+      while (!shutdownRequested) {\n+        try {\n+          Thread.sleep(this.heartbeatIntervalInMillis);\n+          updateHeartbeat(instantTime);\n+        } catch (InterruptedIOException | InterruptedException ioe) {\n+          LOG.warn(\"Thread controlling heartbeat was interrupted\");\n+        } catch (IOException ioe) {\n+          LOG.error(\"Unable to create heartbeat file\", ioe);\n+          throw new RuntimeException(ioe);\n+        }\n+      }\n+    });\n+    this.isHearbeatStarted = true;\n+    this.isHeatBeatStopped = false;\n+  }\n+\n+  public void stop(String instantTime) throws HoodieException {\n+    this.shutdownRequested = true;\n+    if (isHearbeatStarted && !isHeatBeatStopped && this.heartBeatFuture != null) {\n+      // TODO : Substract the amount of time it takes to execute updateHeartbeat from the sleep time to avoid race conditions\n+      boolean isCancelled = this.heartBeatFuture.cancel(true);\n+      if (!isCancelled) {\n+        throw new HoodieException(\"Could not stop heartbeat client\");\n+      }\n+      this.isHeatBeatStopped = true;\n+      LOG.info(\"Stopping heartbeat for instant \" + instantTime);\n+    }\n+  }\n+\n+  public void stop() throws HoodieException {\n+    if (this.currentInstantTime != null) {\n+      stop(this.currentInstantTime);\n+    }\n+  }\n+\n+  public boolean delete(String instantTime) throws IOException {\n+    // TODO ensure that we are not deleting the current instant heartbeat, this might need storing the instant time\n+    // and implementing another heartbeat utils class for everything else\n+    if (this.currentInstantTime == instantTime && !this.isHeatBeatStopped) {\n+      LOG.error(\"Cannot delete a currently running heartbeat, stop it first\");\n+      return false;\n+    } else {\n+      boolean deleted = this.fs.delete(new Path(heartBeatFolderPath + File.separator + instantTime), false);\n+      if (!deleted) {\n+        LOG.error(\"Failed to delete heartbeat for instant \" + instantTime);\n+      }\n+      return deleted;\n+    }\n+  }\n+\n+  public static Long getLastHeartbeat(FileSystem fs, String basePath, String instantTime) throws IOException {\n+    Path heartBeatFilePath = new Path(HoodieTableMetaClient.getHeartbeatFolderPath(basePath) + File.separator + instantTime);\n+    if (fs.exists(heartBeatFilePath)) {\n+      return fs.getFileStatus(heartBeatFilePath).getModificationTime();\n+    } else {\n+      // NOTE : This can happen when a writer is upgraded to use lazy cleaning and the last write had failed\n+      return 0L;\n+    }\n+  }\n+\n+  public boolean checkIfConcurrentWriterRunning(String instantTime) throws IOException {", "originalCommit": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUxNDY5Nw==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549514697", "bodyText": "return this.heartbeatIntervalInMillis <= currentTime - lastHeartBeatForWriter ? single line", "author": "vinothchandar", "createdAt": "2020-12-28T23:13:42Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/heartbeat/HoodieHeartbeatClient.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.client.heartbeat;\n+\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.util.ValidationUtils;\n+import org.apache.hudi.exception.HoodieException;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InterruptedIOException;\n+import java.io.OutputStream;\n+import java.io.Serializable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+\n+/**\n+ * This class creates heartbeat for hudi client. This heartbeat is used to ascertain whether the running job is or not.\n+ * NOTE: Due to CPU contention on the driver/client node, the heartbeats could be delayed, hence it's important to set\n+ *       the value high enough to avoid that possibility.\n+ */\n+@NotThreadSafe\n+public class HoodieHeartbeatClient implements AutoCloseable, Serializable {\n+\n+  // TODO : Throw new exception from thread\n+  private static final Logger LOG = LogManager.getLogger(HoodieHeartbeatClient.class);\n+\n+  // path to the hearbeat folder where all writers are updating their heartbeats\n+  private final transient FileSystem fs;\n+  private final String basePath;\n+  private String heartBeatFolderPath;\n+  private String currentInstantTime;\n+  private int numHeartBeatsForCurrentInstantTime;\n+  // heartbeat interval in millis\n+  private final long heartbeatIntervalInMillis;\n+  private final transient ExecutorService executorService = Executors.newSingleThreadExecutor();\n+  private volatile boolean shutdownRequested;\n+  private boolean isHearbeatStarted = false;\n+  private boolean isHeatBeatStopped = false;\n+  private transient Future<?> heartBeatFuture;\n+  private Long lastHeartBeatTime;\n+  // This is required for testing. Problem : if we set heartbeatIntervalInSeconds really large, test takes longer, if\n+  // we set it small and you are debugging with breakpoint, causes issues. Need to implement a Mock in tests\n+  private final Boolean skipHeartBeatCheck;\n+\n+  public HoodieHeartbeatClient(FileSystem fs, String basePath, long heartbeatIntervalInSeconds) {\n+    ValidationUtils.checkArgument(heartbeatIntervalInSeconds >= 1, \"Cannot set heartbeat lower than 1 second\");\n+    this.fs = fs;\n+    this.basePath = basePath;\n+    this.heartBeatFolderPath = HoodieTableMetaClient.getHeartbeatFolderPath(basePath);\n+    this.heartbeatIntervalInMillis = heartbeatIntervalInSeconds * 1000L;\n+    this.skipHeartBeatCheck = true;\n+  }\n+\n+  public void start(String instantTime) {\n+    LOG.info(\"Received request to start heartbeat for instant time \" + instantTime);\n+    if (isHearbeatStarted && instantTime == currentInstantTime) {\n+      // heartbeat already started, NO_OP\n+      return;\n+    } else if (instantTime != currentInstantTime) {\n+      if (this.currentInstantTime != null) {\n+        LOG.warn(\"Stopping heartbeat for previous instant time \" + this.currentInstantTime);\n+        this.stop(this.currentInstantTime);\n+      }\n+      this.currentInstantTime = instantTime;\n+      this.numHeartBeatsForCurrentInstantTime = 0;\n+      this.shutdownRequested = false;\n+    }\n+    try {\n+      updateHeartbeat(instantTime);\n+    } catch (Exception e) {\n+      throw new RuntimeException(\"Unable to generate heartbeat\");\n+    }\n+    this.heartBeatFuture = executorService.submit(() -> {\n+      while (!shutdownRequested) {\n+        try {\n+          Thread.sleep(this.heartbeatIntervalInMillis);\n+          updateHeartbeat(instantTime);\n+        } catch (InterruptedIOException | InterruptedException ioe) {\n+          LOG.warn(\"Thread controlling heartbeat was interrupted\");\n+        } catch (IOException ioe) {\n+          LOG.error(\"Unable to create heartbeat file\", ioe);\n+          throw new RuntimeException(ioe);\n+        }\n+      }\n+    });\n+    this.isHearbeatStarted = true;\n+    this.isHeatBeatStopped = false;\n+  }\n+\n+  public void stop(String instantTime) throws HoodieException {\n+    this.shutdownRequested = true;\n+    if (isHearbeatStarted && !isHeatBeatStopped && this.heartBeatFuture != null) {\n+      // TODO : Substract the amount of time it takes to execute updateHeartbeat from the sleep time to avoid race conditions\n+      boolean isCancelled = this.heartBeatFuture.cancel(true);\n+      if (!isCancelled) {\n+        throw new HoodieException(\"Could not stop heartbeat client\");\n+      }\n+      this.isHeatBeatStopped = true;\n+      LOG.info(\"Stopping heartbeat for instant \" + instantTime);\n+    }\n+  }\n+\n+  public void stop() throws HoodieException {\n+    if (this.currentInstantTime != null) {\n+      stop(this.currentInstantTime);\n+    }\n+  }\n+\n+  public boolean delete(String instantTime) throws IOException {\n+    // TODO ensure that we are not deleting the current instant heartbeat, this might need storing the instant time\n+    // and implementing another heartbeat utils class for everything else\n+    if (this.currentInstantTime == instantTime && !this.isHeatBeatStopped) {\n+      LOG.error(\"Cannot delete a currently running heartbeat, stop it first\");\n+      return false;\n+    } else {\n+      boolean deleted = this.fs.delete(new Path(heartBeatFolderPath + File.separator + instantTime), false);\n+      if (!deleted) {\n+        LOG.error(\"Failed to delete heartbeat for instant \" + instantTime);\n+      }\n+      return deleted;\n+    }\n+  }\n+\n+  public static Long getLastHeartbeat(FileSystem fs, String basePath, String instantTime) throws IOException {\n+    Path heartBeatFilePath = new Path(HoodieTableMetaClient.getHeartbeatFolderPath(basePath) + File.separator + instantTime);\n+    if (fs.exists(heartBeatFilePath)) {\n+      return fs.getFileStatus(heartBeatFilePath).getModificationTime();\n+    } else {\n+      // NOTE : This can happen when a writer is upgraded to use lazy cleaning and the last write had failed\n+      return 0L;\n+    }\n+  }\n+\n+  public boolean checkIfConcurrentWriterRunning(String instantTime) throws IOException {\n+    long lastHeartBeatForWriter = getLastHeartbeat(fs, basePath, instantTime);\n+    long currentTime = System.currentTimeMillis();\n+    if (currentTime - lastHeartBeatForWriter > this.heartbeatIntervalInMillis) {", "originalCommit": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUxNTMyNw==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549515327", "bodyText": "So the heartbeats won't align correctly with the interval. Typically we add another config that multiplies with this.heartbeatIntervalInMillis , which should at least be 2. I am saying we should compared for currentTime - lastHeartBeatForWriter > this.numTolerableHeartbeatMisses * this.heartbeatIntervalInMillis.\nnumTolerableHeartbeatMisses should have another config, with default value 2", "author": "vinothchandar", "createdAt": "2020-12-28T23:17:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUxNDY5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDM2Nzk5Ng==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r550367996", "bodyText": "I want to add logs if the heartbeat has expired, hence not in a single line. Added the other property for tolereable misses", "author": "n3nash", "createdAt": "2020-12-31T00:57:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUxNDY5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUxNTQ2MQ==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549515461", "bodyText": "AFAIK, a new file creation should be atomic in both HDFS and cloud stores. but unsure how the overwrite part works.\nCan you clarify?", "author": "vinothchandar", "createdAt": "2020-12-28T23:18:00Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/heartbeat/HoodieHeartbeatClient.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.client.heartbeat;\n+\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.util.ValidationUtils;\n+import org.apache.hudi.exception.HoodieException;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InterruptedIOException;\n+import java.io.OutputStream;\n+import java.io.Serializable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+\n+/**\n+ * This class creates heartbeat for hudi client. This heartbeat is used to ascertain whether the running job is or not.\n+ * NOTE: Due to CPU contention on the driver/client node, the heartbeats could be delayed, hence it's important to set\n+ *       the value high enough to avoid that possibility.\n+ */\n+@NotThreadSafe\n+public class HoodieHeartbeatClient implements AutoCloseable, Serializable {\n+\n+  // TODO : Throw new exception from thread\n+  private static final Logger LOG = LogManager.getLogger(HoodieHeartbeatClient.class);\n+\n+  // path to the hearbeat folder where all writers are updating their heartbeats\n+  private final transient FileSystem fs;\n+  private final String basePath;\n+  private String heartBeatFolderPath;\n+  private String currentInstantTime;\n+  private int numHeartBeatsForCurrentInstantTime;\n+  // heartbeat interval in millis\n+  private final long heartbeatIntervalInMillis;\n+  private final transient ExecutorService executorService = Executors.newSingleThreadExecutor();\n+  private volatile boolean shutdownRequested;\n+  private boolean isHearbeatStarted = false;\n+  private boolean isHeatBeatStopped = false;\n+  private transient Future<?> heartBeatFuture;\n+  private Long lastHeartBeatTime;\n+  // This is required for testing. Problem : if we set heartbeatIntervalInSeconds really large, test takes longer, if\n+  // we set it small and you are debugging with breakpoint, causes issues. Need to implement a Mock in tests\n+  private final Boolean skipHeartBeatCheck;\n+\n+  public HoodieHeartbeatClient(FileSystem fs, String basePath, long heartbeatIntervalInSeconds) {\n+    ValidationUtils.checkArgument(heartbeatIntervalInSeconds >= 1, \"Cannot set heartbeat lower than 1 second\");\n+    this.fs = fs;\n+    this.basePath = basePath;\n+    this.heartBeatFolderPath = HoodieTableMetaClient.getHeartbeatFolderPath(basePath);\n+    this.heartbeatIntervalInMillis = heartbeatIntervalInSeconds * 1000L;\n+    this.skipHeartBeatCheck = true;\n+  }\n+\n+  public void start(String instantTime) {\n+    LOG.info(\"Received request to start heartbeat for instant time \" + instantTime);\n+    if (isHearbeatStarted && instantTime == currentInstantTime) {\n+      // heartbeat already started, NO_OP\n+      return;\n+    } else if (instantTime != currentInstantTime) {\n+      if (this.currentInstantTime != null) {\n+        LOG.warn(\"Stopping heartbeat for previous instant time \" + this.currentInstantTime);\n+        this.stop(this.currentInstantTime);\n+      }\n+      this.currentInstantTime = instantTime;\n+      this.numHeartBeatsForCurrentInstantTime = 0;\n+      this.shutdownRequested = false;\n+    }\n+    try {\n+      updateHeartbeat(instantTime);\n+    } catch (Exception e) {\n+      throw new RuntimeException(\"Unable to generate heartbeat\");\n+    }\n+    this.heartBeatFuture = executorService.submit(() -> {\n+      while (!shutdownRequested) {\n+        try {\n+          Thread.sleep(this.heartbeatIntervalInMillis);\n+          updateHeartbeat(instantTime);\n+        } catch (InterruptedIOException | InterruptedException ioe) {\n+          LOG.warn(\"Thread controlling heartbeat was interrupted\");\n+        } catch (IOException ioe) {\n+          LOG.error(\"Unable to create heartbeat file\", ioe);\n+          throw new RuntimeException(ioe);\n+        }\n+      }\n+    });\n+    this.isHearbeatStarted = true;\n+    this.isHeatBeatStopped = false;\n+  }\n+\n+  public void stop(String instantTime) throws HoodieException {\n+    this.shutdownRequested = true;\n+    if (isHearbeatStarted && !isHeatBeatStopped && this.heartBeatFuture != null) {\n+      // TODO : Substract the amount of time it takes to execute updateHeartbeat from the sleep time to avoid race conditions\n+      boolean isCancelled = this.heartBeatFuture.cancel(true);\n+      if (!isCancelled) {\n+        throw new HoodieException(\"Could not stop heartbeat client\");\n+      }\n+      this.isHeatBeatStopped = true;\n+      LOG.info(\"Stopping heartbeat for instant \" + instantTime);\n+    }\n+  }\n+\n+  public void stop() throws HoodieException {\n+    if (this.currentInstantTime != null) {\n+      stop(this.currentInstantTime);\n+    }\n+  }\n+\n+  public boolean delete(String instantTime) throws IOException {\n+    // TODO ensure that we are not deleting the current instant heartbeat, this might need storing the instant time\n+    // and implementing another heartbeat utils class for everything else\n+    if (this.currentInstantTime == instantTime && !this.isHeatBeatStopped) {\n+      LOG.error(\"Cannot delete a currently running heartbeat, stop it first\");\n+      return false;\n+    } else {\n+      boolean deleted = this.fs.delete(new Path(heartBeatFolderPath + File.separator + instantTime), false);\n+      if (!deleted) {\n+        LOG.error(\"Failed to delete heartbeat for instant \" + instantTime);\n+      }\n+      return deleted;\n+    }\n+  }\n+\n+  public static Long getLastHeartbeat(FileSystem fs, String basePath, String instantTime) throws IOException {\n+    Path heartBeatFilePath = new Path(HoodieTableMetaClient.getHeartbeatFolderPath(basePath) + File.separator + instantTime);\n+    if (fs.exists(heartBeatFilePath)) {\n+      return fs.getFileStatus(heartBeatFilePath).getModificationTime();\n+    } else {\n+      // NOTE : This can happen when a writer is upgraded to use lazy cleaning and the last write had failed\n+      return 0L;\n+    }\n+  }\n+\n+  public boolean checkIfConcurrentWriterRunning(String instantTime) throws IOException {\n+    long lastHeartBeatForWriter = getLastHeartbeat(fs, basePath, instantTime);\n+    long currentTime = System.currentTimeMillis();\n+    if (currentTime - lastHeartBeatForWriter > this.heartbeatIntervalInMillis) {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  private void updateHeartbeat(String instantTime) throws IOException {\n+    Long newHeartBeatTime = System.currentTimeMillis();\n+    OutputStream outputStream =", "originalCommit": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTkzNzc0Mg==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549937742", "bodyText": "Yes, a new file creation is atomic, overwrite is NOT. That is why I don't read the contents of the file since that causes race-conditions and the attempt to read fail, the modification time is an indicator of when was the last attempt to update heartbeat which is all we need. Also from the documentation here -> https://hadoop.apache.org/docs/r3.1.2/hadoop-project-dist/hadoop-common/filesystem/introduction.html\nWhen OutputStream.close() is called, all remaining data is written, the file closed and the NameNode updated with the final size of the file. The modification time is set to the time the file was closed.", "author": "n3nash", "createdAt": "2020-12-30T05:13:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUxNTQ2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUxODQyMg==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549518422", "bodyText": "No Thread.sleep in tests please. these make tests flaky. lets structure them, to wait till a condition X is reached with a timeout. essence is explained here. http://www.awaitility.org/", "author": "vinothchandar", "createdAt": "2020-12-28T23:35:22Z", "path": "hudi-client/hudi-client-common/src/test/java/org/apache/hudi/client/heartbeat/TestHoodieHeartbeatClient.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.client.heartbeat;\n+\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.testutils.HoodieCommonTestHarness;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class TestHoodieHeartbeatClient extends HoodieCommonTestHarness {\n+\n+  private static String instantTime1 = \"100\";\n+  private static String instantTime2 = \"101\";\n+\n+  @BeforeEach\n+  public void init() throws IOException {\n+    initMetaClient();\n+  }\n+\n+  @Test\n+  public void testStartHeartbeat() throws IOException {\n+    int heartBeatInterval = 1;\n+    HoodieHeartbeatClient hoodieHeartbeatClient =\n+        new HoodieHeartbeatClient(metaClient.getFs(), metaClient.getBasePath(), heartBeatInterval);\n+    hoodieHeartbeatClient.start(instantTime1);\n+    FileStatus [] fs = metaClient.getFs().listStatus(new Path(hoodieHeartbeatClient.getHeartBeatFolderPath()));\n+    assertTrue(fs.length == 1);\n+    assertTrue(fs[0].getPath().toString().contains(instantTime1));\n+  }\n+\n+  @Test\n+  public void testStopHeartbeat() throws IOException, InterruptedException {\n+    int heartBeatInterval = 1;\n+    HoodieHeartbeatClient hoodieHeartbeatClient =\n+        new HoodieHeartbeatClient(metaClient.getFs(), metaClient.getBasePath(), heartBeatInterval);\n+    hoodieHeartbeatClient.start(instantTime1);\n+    hoodieHeartbeatClient.stop(instantTime1);\n+    Long waitTimeInMs = 2000L;\n+    Thread.sleep(waitTimeInMs);\n+    assertTrue(hoodieHeartbeatClient.getNumHeartBeatsForCurrentInstantTime() > 0);\n+    Long lastHeartBeat = HoodieHeartbeatClient.getLastHeartbeat(metaClient.getFs(), basePath, instantTime1);\n+    assertTrue(System.currentTimeMillis() - lastHeartBeat >= waitTimeInMs);\n+  }\n+\n+  @Test\n+  public void testNumHeartbeatsGenerated() throws InterruptedException {\n+    int heartBeatInterval = 1;\n+    HoodieHeartbeatClient hoodieHeartbeatClient =\n+        new HoodieHeartbeatClient(metaClient.getFs(), metaClient.getBasePath(), heartBeatInterval);\n+    hoodieHeartbeatClient.start(\"100\");\n+    // wait 10 heartbeats\n+    Thread.sleep(10 * heartBeatInterval * 1000);", "originalCommit": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUxODQ2MQ==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549518461", "bodyText": "log?", "author": "vinothchandar", "createdAt": "2020-12-28T23:35:32Z", "path": "hudi-client/hudi-client-common/src/test/java/org/apache/hudi/client/heartbeat/TestHoodieHeartbeatClient.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.client.heartbeat;\n+\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.testutils.HoodieCommonTestHarness;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class TestHoodieHeartbeatClient extends HoodieCommonTestHarness {\n+\n+  private static String instantTime1 = \"100\";\n+  private static String instantTime2 = \"101\";\n+\n+  @BeforeEach\n+  public void init() throws IOException {\n+    initMetaClient();\n+  }\n+\n+  @Test\n+  public void testStartHeartbeat() throws IOException {\n+    int heartBeatInterval = 1;\n+    HoodieHeartbeatClient hoodieHeartbeatClient =\n+        new HoodieHeartbeatClient(metaClient.getFs(), metaClient.getBasePath(), heartBeatInterval);\n+    hoodieHeartbeatClient.start(instantTime1);\n+    FileStatus [] fs = metaClient.getFs().listStatus(new Path(hoodieHeartbeatClient.getHeartBeatFolderPath()));\n+    assertTrue(fs.length == 1);\n+    assertTrue(fs[0].getPath().toString().contains(instantTime1));\n+  }\n+\n+  @Test\n+  public void testStopHeartbeat() throws IOException, InterruptedException {\n+    int heartBeatInterval = 1;\n+    HoodieHeartbeatClient hoodieHeartbeatClient =\n+        new HoodieHeartbeatClient(metaClient.getFs(), metaClient.getBasePath(), heartBeatInterval);\n+    hoodieHeartbeatClient.start(instantTime1);\n+    hoodieHeartbeatClient.stop(instantTime1);\n+    Long waitTimeInMs = 2000L;\n+    Thread.sleep(waitTimeInMs);\n+    assertTrue(hoodieHeartbeatClient.getNumHeartBeatsForCurrentInstantTime() > 0);\n+    Long lastHeartBeat = HoodieHeartbeatClient.getLastHeartbeat(metaClient.getFs(), basePath, instantTime1);\n+    assertTrue(System.currentTimeMillis() - lastHeartBeat >= waitTimeInMs);\n+  }\n+\n+  @Test\n+  public void testNumHeartbeatsGenerated() throws InterruptedException {\n+    int heartBeatInterval = 1;\n+    HoodieHeartbeatClient hoodieHeartbeatClient =\n+        new HoodieHeartbeatClient(metaClient.getFs(), metaClient.getBasePath(), heartBeatInterval);\n+    hoodieHeartbeatClient.start(\"100\");\n+    // wait 10 heartbeats\n+    Thread.sleep(10 * heartBeatInterval * 1000);\n+    assertTrue(hoodieHeartbeatClient.getNumHeartBeatsForCurrentInstantTime() >= 10);\n+  }\n+\n+  @Test\n+  public void testLastHeartBeatTime() throws IOException, InterruptedException {\n+    int heartBeatInterval = 1;\n+    HoodieHeartbeatClient hoodieHeartbeatClient =\n+        new HoodieHeartbeatClient(metaClient.getFs(), metaClient.getBasePath(), heartBeatInterval);\n+    hoodieHeartbeatClient.start(\"100\");\n+    // wait 10 heartbeats\n+    Thread.sleep(1 * heartBeatInterval * 1000);\n+    Long startHeartbeat = hoodieHeartbeatClient.getLastHeartbeat(metaClient.getFs(), basePath, \"100\");\n+    Thread.sleep(9 * heartBeatInterval * 1000);\n+    hoodieHeartbeatClient.stop(\"100\");\n+    Long endHeartbeat = HoodieHeartbeatClient.getLastHeartbeat(metaClient.getFs(), basePath, \"100\");\n+    // check if the heartbeat time is greater than start time + 10 heartbeat intervals\n+    assertTrue((endHeartbeat - startHeartbeat) >= (9 * heartBeatInterval * 1000));\n+  }\n+\n+  @Test\n+  public void testDeleteWrongHeartbeat() throws IOException {\n+    int heartBeatInterval = 1;\n+    HoodieHeartbeatClient hoodieHeartbeatClient =\n+        new HoodieHeartbeatClient(metaClient.getFs(), metaClient.getBasePath(), heartBeatInterval);\n+    hoodieHeartbeatClient.start(instantTime1);\n+    hoodieHeartbeatClient.stop(instantTime1);\n+    assertFalse(hoodieHeartbeatClient.delete(instantTime2));\n+  }\n+\n+  @Test\n+  public void testDeleteRunningHeartbeat() throws IOException {\n+    int heartBeatInterval = 1;\n+    HoodieHeartbeatClient hoodieHeartbeatClient =\n+        new HoodieHeartbeatClient(metaClient.getFs(), metaClient.getBasePath(), heartBeatInterval);\n+    hoodieHeartbeatClient.start(instantTime1);\n+    assertFalse(hoodieHeartbeatClient.delete(instantTime1));\n+  }\n+\n+  @Test\n+  public void testConcurrentReadsAndWritesToSameFile() throws InterruptedException {\n+    Thread th1 = new Thread(() -> {\n+      try {\n+        while (true) {\n+          OutputStream outputStream = metaClient.getFs().create(new Path(metaClient.getBasePath() + \"/test\"), true);\n+          outputStream.write(\"testing\".getBytes());\n+          outputStream.close();\n+        }\n+      } catch (Exception e) {\n+        System.out.println(\"Caught Exception th1\");\n+        e.printStackTrace();\n+      }\n+    });\n+\n+    Thread th2 = new Thread(() -> {\n+      try {\n+        while (true) {\n+          FileStatus fs = metaClient.getFs().getFileStatus(new Path(metaClient.getBasePath() + \"/test\"));\n+          System.out.println(\"Modification Time => \" + fs.getModificationTime());\n+        }\n+      } catch (Exception e) {\n+        System.out.println(\"Caught Exception th2\");", "originalCommit": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUxODY2OQ==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549518669", "bodyText": "hmmm. we should probably do this only once at the super class level.", "author": "vinothchandar", "createdAt": "2020-12-28T23:36:35Z", "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/client/SparkRDDWriteClient.java", "diffHunk": "@@ -100,7 +107,9 @@ public static SparkConf registerClasses(SparkConf conf) {\n   public boolean commit(String instantTime, JavaRDD<WriteStatus> writeStatuses, Option<Map<String, String>> extraMetadata,\n                         String commitActionType, Map<String, List<String>> partitionToReplacedFileIds) {\n     List<HoodieWriteStat> writeStats = writeStatuses.map(WriteStatus::getStat).collect();\n-    return commitStats(instantTime, writeStats, extraMetadata, commitActionType, partitionToReplacedFileIds);\n+    boolean isCommitted = commitStats(instantTime, writeStats, extraMetadata, commitActionType, partitionToReplacedFileIds);\n+    this.hoodieHeartbeatClient.stop(instantTime);", "originalCommit": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTkzODA0Ng==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549938046", "bodyText": "Moved to postCommit", "author": "n3nash", "createdAt": "2020-12-30T05:15:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUxODY2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUxOTMzNA==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549519334", "bodyText": "why can't we override this once for all tests. if we run everything with LAZY then we can have better confidence that no uncommitted data will ever be exposed", "author": "vinothchandar", "createdAt": "2020-12-28T23:40:36Z", "path": "hudi-client/hudi-spark-client/src/test/java/org/apache/hudi/client/TestHoodieClientOnCopyOnWriteStorage.java", "diffHunk": "@@ -437,7 +456,10 @@ private void testUpsertsInternal(HoodieWriteConfig config,\n    */\n   @Test\n   public void testDeletes() throws Exception {\n-    SparkRDDWriteClient client = getHoodieWriteClient(getConfig(), false);\n+    // Set cleaner to LAZY so no inflights are cleaned", "originalCommit": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUxOTYwNQ==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549519605", "bodyText": "We need to do something about the repeated line\ngetConfig().getProps().put(HoodieCompactionConfig.FAILED_WRITES_CLEANER_POLICY_PROP, HoodieCleaningPolicy.HoodieFailedWritesCleaningPolicy.LAZY.name());\neven if you want to override only selectively. Can we add an override for getConfig(boolean) which decides whether or not we do lazy cleaning of failed writes.", "author": "vinothchandar", "createdAt": "2020-12-28T23:42:21Z", "path": "hudi-client/hudi-spark-client/src/test/java/org/apache/hudi/client/TestHoodieClientOnCopyOnWriteStorage.java", "diffHunk": "@@ -546,7 +571,10 @@ private void testUpsertsUpdatePartitionPath(IndexType indexType, HoodieWriteConf\n     HoodieTableMetaClient.initTableType(metaClient.getHadoopConf(), metaClient.getBasePath(),\n         metaClient.getTableType(), metaClient.getTableConfig().getTableName(), metaClient.getArchivePath(),\n         metaClient.getTableConfig().getPayloadClass(), VERSION_0);\n-    SparkRDDWriteClient client = getHoodieWriteClient(hoodieWriteConfig, false);\n+    // Set rollback to LAZY so no inflights are deleted\n+    hoodieWriteConfig.getProps().put(HoodieCompactionConfig.FAILED_WRITES_CLEANER_POLICY_PROP,", "originalCommit": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUxOTc4MA==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549519780", "bodyText": "lets inline these variables . they can all be just constants, right", "author": "vinothchandar", "createdAt": "2020-12-28T23:43:31Z", "path": "hudi-client/hudi-spark-client/src/test/java/org/apache/hudi/client/TestHoodieClientOnCopyOnWriteStorage.java", "diffHunk": "@@ -1367,6 +1410,77 @@ public void testRollbackAfterConsistencyCheckFailureUsingMarkers(boolean enableO\n     testRollbackAfterConsistencyCheckFailureUsingFileList(true, enableOptimisticConsistencyGuard);\n   }\n \n+  @Test\n+  public void testParallelWriting() throws Exception {\n+    ExecutorService service = Executors.newFixedThreadPool(3);\n+    String instantTime1 = \"100\";", "originalCommit": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUxOTk0Nw==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549519947", "bodyText": "should we upsert of the writes. so we get a better mix.", "author": "vinothchandar", "createdAt": "2020-12-28T23:44:30Z", "path": "hudi-client/hudi-spark-client/src/test/java/org/apache/hudi/client/TestHoodieClientOnCopyOnWriteStorage.java", "diffHunk": "@@ -1367,6 +1410,77 @@ public void testRollbackAfterConsistencyCheckFailureUsingMarkers(boolean enableO\n     testRollbackAfterConsistencyCheckFailureUsingFileList(true, enableOptimisticConsistencyGuard);\n   }\n \n+  @Test\n+  public void testParallelWriting() throws Exception {\n+    ExecutorService service = Executors.newFixedThreadPool(3);\n+    String instantTime1 = \"100\";\n+    String instantTime2 = \"200\";\n+    String instantTime3 = \"300\";\n+    Boolean doCommit = true;\n+    Boolean doClean = false;\n+    HoodieTestUtils.init(hadoopConf, basePath);\n+    Future<Boolean> commit1 = service.submit(() -> doWritesToTable(instantTime1, doCommit, doClean));\n+    Future<Boolean> commit2 = service.submit(() -> doWritesToTable(instantTime2, doCommit, doClean));\n+    Future<Boolean> commit3 = service.submit(() -> doWritesToTable(instantTime3, doCommit, doClean));\n+    assertTrue(commit1.get() && commit2.get() && commit3.get());\n+    HoodieTableMetaClient metaClient = new HoodieTableMetaClient(hadoopConf, basePath);\n+    assertTrue(metaClient.getActiveTimeline().getCommitsTimeline().filterCompletedInstants().countInstants() == 3);\n+  }\n+\n+  @Test\n+  public void testParallelWritingWhileCleaningPreviousFailedCommits() throws Exception {\n+    ExecutorService service = Executors.newFixedThreadPool(2);\n+    String instantTime1 = \"100\";\n+    String instantTime2 = \"200\";\n+    String instantTime3 = \"300\";\n+    String instantTime4 = \"400\";\n+    Boolean doCommit = false;\n+    Boolean doClean = false;\n+    HoodieTestUtils.init(hadoopConf, basePath);\n+    // Perform 2 failed writes to table\n+    doWritesToTable(instantTime1, doCommit, doClean);\n+    doWritesToTable(instantTime2, doCommit, doClean);\n+    Future<Boolean> commit3 = service.submit(() -> doWritesToTable(instantTime3, true, false));\n+    assertTrue(commit3.get());\n+    HoodieTableMetaClient metaClient = new HoodieTableMetaClient(hadoopConf, basePath);\n+    assertTrue(metaClient.getActiveTimeline().getTimelineOfActions(\n+        CollectionUtils.createSet(HoodieTimeline.ROLLBACK_ACTION)).countInstants() == 0);\n+    assertTrue(metaClient.getActiveTimeline().filterInflights().countInstants() == 2);\n+    // Sleep for 5 secs to allow for heart beat interval to pass\n+    Thread.sleep(5000);\n+    SparkRDDWriteClient client = new SparkRDDWriteClient(context, getParallelWritingWriteConfig());\n+    Future<Boolean> commit4 = service.submit(() -> doWritesToTable(instantTime4, true, false));\n+    Future<HoodieCleanMetadata> clean1 = service.submit(() -> client.clean());\n+    assertTrue(commit4.get());\n+    clean1.get();\n+    assertTrue(metaClient.getActiveTimeline().reload().getTimelineOfActions(\n+        CollectionUtils.createSet(HoodieTimeline.ROLLBACK_ACTION)).countInstants() == 2);\n+  }\n+\n+  private boolean doWritesToTable(String instantTime, Boolean doCommit, Boolean doClean) {\n+    HoodieWriteConfig cfg = getParallelWritingWriteConfig();\n+    // Create a new write client local to thread\n+    SparkRDDWriteClient client = new SparkRDDWriteClient(context, cfg);\n+\n+    client.startCommitWithTime(instantTime);\n+\n+    List<HoodieRecord> records0 = dataGen.generateInserts(instantTime, 200);\n+    JavaRDD<HoodieRecord> writeRecords0 = jsc.parallelize(records0, 1);\n+    JavaRDD<WriteStatus> result0 = client.bulkInsert(writeRecords0, instantTime);", "originalCommit": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUyMDU0MQ==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549520541", "bodyText": "let's have as a top level enum/ unnested", "author": "vinothchandar", "createdAt": "2020-12-28T23:47:31Z", "path": "hudi-common/src/main/java/org/apache/hudi/common/model/HoodieCleaningPolicy.java", "diffHunk": "@@ -22,5 +22,8 @@\n  * Hoodie cleaning policies.\n  */\n public enum HoodieCleaningPolicy {\n-  KEEP_LATEST_FILE_VERSIONS, KEEP_LATEST_COMMITS\n+  KEEP_LATEST_FILE_VERSIONS, KEEP_LATEST_COMMITS;\n+  public enum HoodieFailedWritesCleaningPolicy {", "originalCommit": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUyMDU2Ng==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549520566", "bodyText": "rename:WriteConcurrencyMode", "author": "vinothchandar", "createdAt": "2020-12-28T23:47:49Z", "path": "hudi-common/src/main/java/org/apache/hudi/common/model/MultiWriterConcurrencyModel.java", "diffHunk": "@@ -0,0 +1,25 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.common.model;\n+\n+public enum MultiWriterConcurrencyModel {", "originalCommit": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUyMDY0Ng==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549520646", "bodyText": "rename: SINGLE_WRITER, dropping the LEGACY. The model has its merits", "author": "vinothchandar", "createdAt": "2020-12-28T23:48:12Z", "path": "hudi-common/src/main/java/org/apache/hudi/common/model/MultiWriterConcurrencyModel.java", "diffHunk": "@@ -0,0 +1,25 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.common.model;\n+\n+public enum MultiWriterConcurrencyModel {\n+  LEGACY_SINGLE_WRITER,", "originalCommit": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUyMDc3OA==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549520778", "bodyText": "rename: just PARALLEL_NO_CONTENTION", "author": "vinothchandar", "createdAt": "2020-12-28T23:48:55Z", "path": "hudi-common/src/main/java/org/apache/hudi/common/model/MultiWriterConcurrencyModel.java", "diffHunk": "@@ -0,0 +1,25 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.common.model;\n+\n+public enum MultiWriterConcurrencyModel {\n+  LEGACY_SINGLE_WRITER,\n+  EMBARRASSINGLY_PARALLEL,", "originalCommit": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUyMDg4MA==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549520880", "bodyText": "should nt this be under the metaPath?", "author": "vinothchandar", "createdAt": "2020-12-28T23:49:43Z", "path": "hudi-common/src/main/java/org/apache/hudi/common/table/HoodieTableMetaClient.java", "diffHunk": "@@ -217,6 +218,13 @@ public String getMetaAuxiliaryPath() {\n     return basePath + File.separator + AUXILIARYFOLDER_NAME;\n   }\n \n+  /**\n+   * @return Heartbeat folder path.\n+   */\n+  public static String getHeartbeatFolderPath(String basePath) {", "originalCommit": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDM2Njg2OA==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r550366868", "bodyText": "It should be and is, follows the same semantic of .aux -> https://github.com/apache/hudi/blob/master/hudi-common/src/main/java/org/apache/hudi/common/table/HoodieTableMetaClient.java#L76", "author": "n3nash", "createdAt": "2020-12-31T00:48:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUyMDg4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUyMDk5Ng==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549520996", "bodyText": "this is not an invalid block right. this skipping an uncommitted block?", "author": "vinothchandar", "createdAt": "2020-12-28T23:50:32Z", "path": "hudi-common/src/main/java/org/apache/hudi/common/table/log/AbstractHoodieLogRecordScanner.java", "diffHunk": "@@ -145,6 +146,11 @@ public void scan() {\n           // hit a block with instant time greater than should be processed, stop processing further\n           break;\n         }\n+        if (r.getBlockType() != CORRUPT_BLOCK && r.getBlockType() != COMMAND_BLOCK\n+            && !timeline.containsOrBeforeTimelineStarts(r.getLogBlockHeader().get(INSTANT_TIME))) {\n+          // hit an invalid block possibly from a failed write, move to the next one and skip processing this one", "originalCommit": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTk1MjgwMA==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549952800", "bodyText": "Yes, that's why in the comments added \"possibly from a failed write\". Changed the invalid -> uncommitted", "author": "n3nash", "createdAt": "2020-12-30T06:43:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUyMDk5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUyMTA4MA==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549521080", "bodyText": "got it. so this is a rename. discard my earlier comment.", "author": "vinothchandar", "createdAt": "2020-12-28T23:51:06Z", "path": "hudi-common/src/main/java/org/apache/hudi/common/table/timeline/HoodieDefaultTimeline.java", "diffHunk": "@@ -107,7 +107,7 @@ public HoodieTimeline filterCompletedAndCompactionInstants() {\n   }\n \n   @Override\n-  public HoodieDefaultTimeline getCommitsAndCompactionTimeline() {\n+  public HoodieDefaultTimeline getCommitsCompactionAndReplaceTimeline() {", "originalCommit": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUyMTEyOA==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549521128", "bodyText": "how about getWriteTimeline simply", "author": "vinothchandar", "createdAt": "2020-12-28T23:51:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUyMTA4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDM2NTk2Mw==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r550365963", "bodyText": "sg", "author": "n3nash", "createdAt": "2020-12-31T00:42:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUyMTA4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUyMTM0Nw==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549521347", "bodyText": "dont we already have helpers that do these. cc @xushiyan", "author": "vinothchandar", "createdAt": "2020-12-28T23:53:11Z", "path": "hudi-common/src/test/java/org/apache/hudi/common/testutils/FileCreateUtils.java", "diffHunk": "@@ -83,6 +83,17 @@ private static void createMetaFile(String basePath, String instantTime, String s\n     }\n   }\n \n+  private static void createMetaFile(FileSystem fs, String basePath, String instantTime, String suffix) throws IOException {", "originalCommit": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUyODAxMg==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549528012", "bodyText": "HoodieTestTable makes use of this FileCreateUtils to perform the actual file manipulations.", "author": "xushiyan", "createdAt": "2020-12-29T00:34:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUyMTM0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUyODQ5OA==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549528498", "bodyText": "Looks like this new set of helpers is a version that uses hadoop fs instead of java nio. Would it align better if we put FileSystem fs as the last argument? so that other args match with the java nio version. This applies to the few new helper methods below.", "author": "xushiyan", "createdAt": "2020-12-29T00:36:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUyMTM0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU0OTYwMw==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549549603", "bodyText": "+1", "author": "vinothchandar", "createdAt": "2020-12-29T02:54:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUyMTM0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUyMTM5MQ==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549521391", "bodyText": "why removing the test?", "author": "vinothchandar", "createdAt": "2020-12-28T23:53:36Z", "path": "hudi-hadoop-mr/src/test/java/org/apache/hudi/hadoop/TestHoodieROTablePathFilter.java", "diffHunk": "@@ -84,7 +84,6 @@ public void testNonHoodiePaths() throws IOException {\n     assertTrue(pathFilter.accept(new Path(path2.toUri())));\n   }\n \n-  @Test\n   public void testPartitionPathsAsNonHoodiePaths() throws Exception {", "originalCommit": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTk3MDcwOQ==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549970709", "bodyText": "Added it back, was failing so had commented it out", "author": "n3nash", "createdAt": "2020-12-30T07:08:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUyMTM5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU0Nzk1Ng==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549547956", "bodyText": "is n't there an existing method to get this? Also should we include replacecommit here as well?  I understand the issue with compactions, since the retry will attempt to reuse the same instantTime. is that why you only have commit/deltacommit here?", "author": "vinothchandar", "createdAt": "2020-12-29T02:43:31Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/table/HoodieTimelineArchiveLog.java", "diffHunk": "@@ -165,13 +167,17 @@ public boolean archiveIfRequired(HoodieEngineContext context) throws IOException\n     HoodieTimeline commitTimeline = table.getCompletedCommitsTimeline();\n     Option<HoodieInstant> oldestPendingCompactionInstant =\n         table.getActiveTimeline().filterPendingCompactionTimeline().firstInstant();\n+    Option<HoodieInstant> oldestInflightInstant =\n+        table.getActiveTimeline()\n+            .getTimelineOfActions(CollectionUtils.createSet(HoodieTimeline.COMMIT_ACTION, HoodieTimeline.DELTA_COMMIT_ACTION))", "originalCommit": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTk4MTgxNQ==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549981815", "bodyText": "Yes, the retry of both will use the same instant right now. All of the lazy cleaning is only done for commits/deltacommits since there is contention when multiple writers start running. Both compaction and clustering will continue to do inline rollbacks since both these operations are bound to happen once scheduled. If the compaction or clustering DON'T run, the failed writes will keep lying around. Basically, once a compaction/clustering is scheduled, we ensure no other writer can modify the same set of files, there is no contention for the failed writes and hence the cleanup happens inline. If they don't happen inline and depend on the LAZY cleaning, then since we re-use the same instant, we cannot guarantee correctness.", "author": "n3nash", "createdAt": "2020-12-30T07:24:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU0Nzk1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA4NDg0MQ==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r552084841", "bodyText": "makes sense to have the lazy cleaning for just the true write actiosn.", "author": "vinothchandar", "createdAt": "2021-01-05T17:35:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU0Nzk1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU0OTMwNA==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549549304", "bodyText": "do we need to guard this by config.getMultiWriterConcurrencyModel() != MultiWriterConcurrencyModel.LEGACY_SINGLE_WRITER ? it should technically work right? if so, best to keep just the one flag to fence", "author": "vinothchandar", "createdAt": "2020-12-29T02:52:08Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/table/HoodieTimelineArchiveLog.java", "diffHunk": "@@ -180,7 +186,14 @@ public boolean archiveIfRequired(HoodieEngineContext context) throws IOException\n             return oldestPendingCompactionInstant\n                 .map(instant -> HoodieTimeline.compareTimestamps(instant.getTimestamp(), GREATER_THAN, s.getTimestamp()))\n                 .orElse(true);\n-          }).limit(commitTimeline.countInstants() - minInstantsToKeep);\n+          });\n+      if (config.getFailedWritesCleanPolicy() == HoodieCleaningPolicy.HoodieFailedWritesCleaningPolicy.LAZY\n+          && config.getMultiWriterConcurrencyModel() != MultiWriterConcurrencyModel.LEGACY_SINGLE_WRITER) {", "originalCommit": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU0OTQ1OA==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549549458", "bodyText": "just return if the policy is not EAGER?  easier to read that, than nested if blocks .", "author": "vinothchandar", "createdAt": "2020-12-29T02:53:16Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/table/action/rollback/BaseRollbackActionExecutor.java", "diffHunk": "@@ -130,23 +131,29 @@ private void validateSavepointRollbacks() {\n   }\n \n   private void validateRollbackCommitSequence() {\n-    final String instantTimeToRollback = instantToRollback.getTimestamp();\n-    HoodieTimeline commitTimeline = table.getCompletedCommitsTimeline();\n-    HoodieTimeline inflightAndRequestedCommitTimeline = table.getPendingCommitTimeline();\n-    // Make sure only the last n commits are being rolled back\n-    // If there is a commit in-between or after that is not rolled back, then abort\n-    if ((instantTimeToRollback != null) && !commitTimeline.empty()\n-        && !commitTimeline.findInstantsAfter(instantTimeToRollback, Integer.MAX_VALUE).empty()) {\n-      throw new HoodieRollbackException(\n-          \"Found commits after time :\" + instantTimeToRollback + \", please rollback greater commits first\");\n-    }\n+    // Continue to provide the same behavior if policy is EAGER (similar to pendingRollback logic). This is required\n+    // since with LAZY rollback we support parallel writing which can allow a new inflight while rollback is ongoing\n+    // Remove this once we support LAZY rollback of failed writes by default as parallel writing becomes the default\n+    // writer mode.\n+    if (config.getFailedWritesCleanPolicy() == HoodieCleaningPolicy.HoodieFailedWritesCleaningPolicy.EAGER) {", "originalCommit": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU1MDAwMw==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549550003", "bodyText": "I was expecting some changes in this file, to clean the failed writers for LAZY? Can you point me to the files that do this.", "author": "vinothchandar", "createdAt": "2020-12-29T02:56:26Z", "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/table/action/clean/SparkCleanActionExecutor.java", "diffHunk": "@@ -23,9 +23,9 @@\n import org.apache.hudi.avro.model.HoodieActionInstant;\n import org.apache.hudi.avro.model.HoodieCleanerPlan;\n import org.apache.hudi.client.WriteStatus;\n-import org.apache.hudi.common.HoodieCleanStat;\n import org.apache.hudi.client.common.HoodieEngineContext;\n import org.apache.hudi.client.common.HoodieSparkEngineContext;\n+import org.apache.hudi.common.HoodieCleanStat;\n import org.apache.hudi.common.model.CleanFileInfo;\n import org.apache.hudi.common.model.HoodieKey;\n import org.apache.hudi.common.model.HoodieRecord;", "originalCommit": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTk3NzY2MQ==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549977661", "bodyText": "@vinothchandar No change in the action executor, to keep this change simple, just added that here -> \n  \n    \n      hudi/hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java\n    \n    \n         Line 609\n      in\n      35a82c7\n    \n    \n    \n    \n\n        \n          \n           if (config.getFailedWritesCleanPolicy() == HoodieCleaningPolicy.HoodieFailedWritesCleaningPolicy.LAZY) {", "author": "n3nash", "createdAt": "2020-12-30T07:18:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU1MDAwMw=="}], "type": "inlineReview"}, {"oid": "19d7cbc0c0685119742f116dc8c5d2dc5067727d", "url": "https://github.com/apache/hudi/commit/19d7cbc0c0685119742f116dc8c5d2dc5067727d", "message": "Adding configs to make failed writes eager/lazy", "committedDate": "2020-12-31T08:41:31Z", "type": "forcePushed"}, {"oid": "b21cb42fe0f6ce29e77ac1412defb54191b06d54", "url": "https://github.com/apache/hudi/commit/b21cb42fe0f6ce29e77ac1412defb54191b06d54", "message": "Adding configs to make failed writes eager/lazy", "committedDate": "2021-01-03T03:11:25Z", "type": "forcePushed"}, {"oid": "2ec3746823cd8955318469fe81ae531b2100b299", "url": "https://github.com/apache/hudi/commit/2ec3746823cd8955318469fe81ae531b2100b299", "message": "Adding configs to make failed writes eager/lazy", "committedDate": "2021-01-03T03:17:40Z", "type": "forcePushed"}, {"oid": "4718c03b3aeac528d6192fcd8cb5c3916bd08555", "url": "https://github.com/apache/hudi/commit/4718c03b3aeac528d6192fcd8cb5c3916bd08555", "message": "Adding configs to make failed writes eager/lazy", "committedDate": "2021-01-03T07:52:17Z", "type": "forcePushed"}, {"oid": "557bbd3d71e53f8306d0f1cae6ced16314204aee", "url": "https://github.com/apache/hudi/commit/557bbd3d71e53f8306d0f1cae6ced16314204aee", "message": "Adding configs to make failed writes eager/lazy", "committedDate": "2021-01-05T08:21:21Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTYxNzkwMg==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r551617902", "bodyText": "rename to be shorter? drop the HoodieClient or Hoodie part in the names?", "author": "vinothchandar", "createdAt": "2021-01-04T22:57:37Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieClient.java", "diffHunk": "@@ -70,6 +72,8 @@ protected AbstractHoodieClient(HoodieEngineContext context, HoodieWriteConfig cl\n     this.config = clientConfig;\n     this.timelineServer = timelineServer;\n     shouldStopTimelineServer = !timelineServer.isPresent();\n+    this.heartbeatClient = new HoodieHeartbeatClient(this.fs, this.basePath,\n+        clientConfig.getHoodieClientHeartbeatIntervalInMs(), clientConfig.getHoodieClientHeartbeatTolerableMisses());", "originalCommit": "4718c03b3aeac528d6192fcd8cb5c3916bd08555", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzYzNTIzMg==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r577635232", "bodyText": "+1", "author": "nsivabalan", "createdAt": "2021-02-17T14:03:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTYxNzkwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTYxODcyOQ==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r551618729", "bodyText": "config is a member variable right? why do we pass it in to the checks? Can we just do eagerCleanFailedWrites(), which does he if block and the call to rollbackFailedBootstrap()?", "author": "vinothchandar", "createdAt": "2021-01-04T22:59:57Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -232,17 +250,18 @@ void emitCommitMetrics(String instantTime, HoodieCommitMetadata metadata, String\n    * Main API to run bootstrap to hudi.\n    */\n   public void bootstrap(Option<Map<String, String>> extraMetadata) {\n-    if (rollbackPending) {\n-      rollBackInflightBootstrap();\n-    }\n+    // TODO : MULTIWRITER -> check if failed bootstrap files can be cleaned later\n     HoodieTable<T, I, K, O> table = getTableAndInitCtx(WriteOperationType.UPSERT, HoodieTimeline.METADATA_BOOTSTRAP_INSTANT_TS);\n+    if (isEager(config.getFailedWritesCleanPolicy())) {", "originalCommit": "4718c03b3aeac528d6192fcd8cb5c3916bd08555", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzE2NDM3MA==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r553164370", "bodyText": "Refactored this, PTAL", "author": "n3nash", "createdAt": "2021-01-07T08:01:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTYxODcyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTYxOTAxMA==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r551619010", "bodyText": "should we just call getCommitsCompactionAndReplaceTimeline() -> getCompletedWriteTimeline() ? we use writes already for other things", "author": "vinothchandar", "createdAt": "2021-01-04T23:00:51Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -408,13 +426,14 @@ protected void postCommit(HoodieTable<T, I, K, O> table, HoodieCommitMetadata me\n       HoodieTimelineArchiveLog archiveLog = new HoodieTimelineArchiveLog(config, table);\n       archiveLog.archiveIfRequired(context);\n       autoCleanOnCommit(instantTime);\n+      this.heartbeatClient.stop(instantTime);\n     } catch (IOException ioe) {\n       throw new HoodieIOException(ioe.getMessage(), ioe);\n     }\n   }\n \n   protected void runAnyPendingCompactions(HoodieTable<T, I, K, O> table) {\n-    table.getActiveTimeline().getCommitsAndCompactionTimeline().filterPendingCompactionTimeline().getInstants()\n+    table.getActiveTimeline().getCommitsCompactionAndReplaceTimeline().filterPendingCompactionTimeline().getInstants()", "originalCommit": "4718c03b3aeac528d6192fcd8cb5c3916bd08555", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzE3Nzk5Mg==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r553177992", "bodyText": "yes, I think I renamed it in the other PR, since this is landing first, renamed it here", "author": "n3nash", "createdAt": "2021-01-07T08:33:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTYxOTAxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTYxOTI0OA==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r551619248", "bodyText": "pull both lines into a method that takes 0 args?", "author": "vinothchandar", "createdAt": "2021-01-04T23:01:30Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -580,6 +602,11 @@ public HoodieRestoreMetadata restoreToInstant(final String instantTime) throws H\n   public HoodieCleanMetadata clean(String cleanInstantTime) throws HoodieIOException {\n     LOG.info(\"Cleaner started\");\n     final Timer.Context timerContext = metrics.getCleanCtx();\n+    LOG.info(\"Cleaning failed attempts if any\");\n+    if (!isEager(config.getFailedWritesCleanPolicy())) {", "originalCommit": "4718c03b3aeac528d6192fcd8cb5c3916bd08555", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzE2NTE4MA==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r553165180", "bodyText": "Refactored this", "author": "n3nash", "createdAt": "2021-01-07T08:03:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTYxOTI0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTYxOTM3NQ==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r551619375", "bodyText": "rename to rollbackFailedWrites()", "author": "vinothchandar", "createdAt": "2021-01-04T23:01:47Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -580,6 +602,11 @@ public HoodieRestoreMetadata restoreToInstant(final String instantTime) throws H\n   public HoodieCleanMetadata clean(String cleanInstantTime) throws HoodieIOException {\n     LOG.info(\"Cleaner started\");\n     final Timer.Context timerContext = metrics.getCleanCtx();\n+    LOG.info(\"Cleaning failed attempts if any\");\n+    if (!isEager(config.getFailedWritesCleanPolicy())) {\n+      rollbackFailedCommits();", "originalCommit": "4718c03b3aeac528d6192fcd8cb5c3916bd08555", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTYyMDg0OA==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r551620848", "bodyText": "drop the second argument to isHeartbeatExpired() and have it get the current time epoch inside?", "author": "vinothchandar", "createdAt": "2021-01-04T23:05:58Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -707,24 +739,51 @@ public void rollbackInflightCompaction(HoodieInstant inflightInstant, HoodieTabl\n   }\n \n   /**\n-   * Cleanup all pending commits.\n+   * Rollback all failed commits.\n    */\n-  private void rollbackPendingCommits() {\n+  public void rollbackFailedCommits() {\n     HoodieTable<T, I, K, O> table = createTable(config, hadoopConf);\n-    HoodieTimeline inflightTimeline = table.getMetaClient().getCommitsTimeline().filterPendingExcludingCompaction();\n-    List<String> commits = inflightTimeline.getReverseOrderedInstants().map(HoodieInstant::getTimestamp)\n-        .collect(Collectors.toList());\n-    for (String commit : commits) {\n-      if (HoodieTimeline.compareTimestamps(commit, HoodieTimeline.LESSER_THAN_OR_EQUALS,\n+    List<String> instantsToRollback = getInstantsToRollback(table);\n+    for (String instant : instantsToRollback) {\n+      if (HoodieTimeline.compareTimestamps(instant, HoodieTimeline.LESSER_THAN_OR_EQUALS,\n           HoodieTimeline.FULL_BOOTSTRAP_INSTANT_TS)) {\n-        rollBackInflightBootstrap();\n+        rollbackFailedBootstrap();\n         break;\n       } else {\n-        rollback(commit);\n+        rollback(instant);\n+      }\n+      // Delete the heartbeats from DFS\n+      if (!isEager(config.getFailedWritesCleanPolicy())) {\n+        try {\n+          this.heartbeatClient.delete(instant);\n+        } catch (IOException io) {\n+          LOG.error(io);\n+        }\n       }\n     }\n   }\n \n+  private List<String> getInstantsToRollback(HoodieTable<T, I, K, O> table) {\n+    if (isEager(config.getFailedWritesCleanPolicy())) {\n+      HoodieTimeline inflightTimeline = table.getMetaClient().getCommitsTimeline().filterPendingExcludingCompaction();\n+      return inflightTimeline.getReverseOrderedInstants().map(HoodieInstant::getTimestamp)\n+          .collect(Collectors.toList());\n+    } else if (!isEager(config.getFailedWritesCleanPolicy())) {\n+      return table.getMetaClient().getActiveTimeline()\n+          .getCommitsTimeline().filterInflights().getReverseOrderedInstants().filter(instant -> {\n+            try {\n+              return heartbeatClient.isHeartbeatExpired(instant.getTimestamp(), System.currentTimeMillis());", "originalCommit": "4718c03b3aeac528d6192fcd8cb5c3916bd08555", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTYyOTg4OA==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r551629888", "bodyText": "To confirm my understanding, this will log rollback blocks for a much older data block and as long as that instant is on the active timeline, the merging/reading part will continue to ignore the blocks/files corresponding to the failed write.\nIn terms of multiple writing, one of the writers has to be responsible for doing all \"table services\" (cleaning, compaction, clustering, failedwrite cleaning, archiving) and another writer could be writing a new data block into the file group, while this failed cleanup is happening? and we can handle this, right?", "author": "vinothchandar", "createdAt": "2021-01-04T23:31:38Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -707,24 +739,51 @@ public void rollbackInflightCompaction(HoodieInstant inflightInstant, HoodieTabl\n   }\n \n   /**\n-   * Cleanup all pending commits.\n+   * Rollback all failed commits.\n    */\n-  private void rollbackPendingCommits() {\n+  public void rollbackFailedCommits() {\n     HoodieTable<T, I, K, O> table = createTable(config, hadoopConf);\n-    HoodieTimeline inflightTimeline = table.getMetaClient().getCommitsTimeline().filterPendingExcludingCompaction();\n-    List<String> commits = inflightTimeline.getReverseOrderedInstants().map(HoodieInstant::getTimestamp)\n-        .collect(Collectors.toList());\n-    for (String commit : commits) {\n-      if (HoodieTimeline.compareTimestamps(commit, HoodieTimeline.LESSER_THAN_OR_EQUALS,\n+    List<String> instantsToRollback = getInstantsToRollback(table);", "originalCommit": "4718c03b3aeac528d6192fcd8cb5c3916bd08555", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzE5ODE4NQ==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r553198185", "bodyText": "For part 1 of the question, what you mentioned is true, in addition, I have also added a check in the merging of log blocks where if the instant is not on the active timeline, that block will be ignored (so for this specific case, rollback blocks are not needed). For the case where the instant has been archived, that cannot happen until that failed commit has been rolled back by the cleaner (changes to the archival ensure that)\nFor part 2, it's slightly complicated.\nFor parallel writing, the assumption is the following :\n\nWriter 1 starts writing to file groups f1_c1, f2_c1\nWriter 2 starts writing to file groups f3_c2, f4_c2\nAny scheduling operations (schedule compaction, schedule clustering, clean) cannot happen for f1, f2, f3, f4 because updates may have started for f1.log_c1 and scheduleCompaction may create a new phantom file slice f1_c3, in which case f1.log_c1 updates are lost.\nSo, for all operations to run concurrently, they truly have to not overlap in file slices\n\nFor concurrent writing, we may need some more changes :\n\nWriter 1 starts writing to file groups f1_c1, f2_c1\nWriter 2 starts writing to file groups f2_c2, f3_c2\nscheduleCompaction for f2_c1 & f1_c1 -> f2_c3, f1_c3\n\nNow the other PR needs some more enhancements to not only check how many writers have happened since the time it started, but also if there are any other \"schedule\" operations that are also on the timeline. This will I think we will have to implement a ConcurrentRequestStrategyWithPriority where we can allow for schedule to fail if it sees a writer running etc..", "author": "n3nash", "createdAt": "2021-01-07T09:12:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTYyOTg4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc1ODc4NA==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r553758784", "bodyText": "As per discussion offline, we are just considering this PR to disable inline rollbacks, parallel writing will NOT be supported", "author": "n3nash", "createdAt": "2021-01-08T06:05:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTYyOTg4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODgyMDg0Mg==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r568820842", "bodyText": "can you comment again on whether this changes the answer to my question above?\n\nI have also added a check in the merging of log blocks where if the instant is not on the active timeline, that block will be ignored\n\nThe concern I had was the part 2 where, a committed write could have been archived and we may end up skipping it. Can you please clarify again how we guard that? By ensuring the archival will wait for the cleaner to log this block?", "author": "vinothchandar", "createdAt": "2021-02-02T18:09:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTYyOTg4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTYzMDUyNQ==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r551630525", "bodyText": "some context on the error?", "author": "vinothchandar", "createdAt": "2021-01-04T23:33:45Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -707,24 +739,51 @@ public void rollbackInflightCompaction(HoodieInstant inflightInstant, HoodieTabl\n   }\n \n   /**\n-   * Cleanup all pending commits.\n+   * Rollback all failed commits.\n    */\n-  private void rollbackPendingCommits() {\n+  public void rollbackFailedCommits() {\n     HoodieTable<T, I, K, O> table = createTable(config, hadoopConf);\n-    HoodieTimeline inflightTimeline = table.getMetaClient().getCommitsTimeline().filterPendingExcludingCompaction();\n-    List<String> commits = inflightTimeline.getReverseOrderedInstants().map(HoodieInstant::getTimestamp)\n-        .collect(Collectors.toList());\n-    for (String commit : commits) {\n-      if (HoodieTimeline.compareTimestamps(commit, HoodieTimeline.LESSER_THAN_OR_EQUALS,\n+    List<String> instantsToRollback = getInstantsToRollback(table);\n+    for (String instant : instantsToRollback) {\n+      if (HoodieTimeline.compareTimestamps(instant, HoodieTimeline.LESSER_THAN_OR_EQUALS,\n           HoodieTimeline.FULL_BOOTSTRAP_INSTANT_TS)) {\n-        rollBackInflightBootstrap();\n+        rollbackFailedBootstrap();\n         break;\n       } else {\n-        rollback(commit);\n+        rollback(instant);\n+      }\n+      // Delete the heartbeats from DFS\n+      if (!isEager(config.getFailedWritesCleanPolicy())) {\n+        try {\n+          this.heartbeatClient.delete(instant);\n+        } catch (IOException io) {\n+          LOG.error(io);", "originalCommit": "4718c03b3aeac528d6192fcd8cb5c3916bd08555", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA3ODEwNg==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r552078106", "bodyText": "how do we cleanup if we fail after rolling back, but before deleting the heartbeat?", "author": "vinothchandar", "createdAt": "2021-01-05T17:24:02Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -707,24 +739,51 @@ public void rollbackInflightCompaction(HoodieInstant inflightInstant, HoodieTabl\n   }\n \n   /**\n-   * Cleanup all pending commits.\n+   * Rollback all failed commits.\n    */\n-  private void rollbackPendingCommits() {\n+  public void rollbackFailedCommits() {\n     HoodieTable<T, I, K, O> table = createTable(config, hadoopConf);\n-    HoodieTimeline inflightTimeline = table.getMetaClient().getCommitsTimeline().filterPendingExcludingCompaction();\n-    List<String> commits = inflightTimeline.getReverseOrderedInstants().map(HoodieInstant::getTimestamp)\n-        .collect(Collectors.toList());\n-    for (String commit : commits) {\n-      if (HoodieTimeline.compareTimestamps(commit, HoodieTimeline.LESSER_THAN_OR_EQUALS,\n+    List<String> instantsToRollback = getInstantsToRollback(table);\n+    for (String instant : instantsToRollback) {\n+      if (HoodieTimeline.compareTimestamps(instant, HoodieTimeline.LESSER_THAN_OR_EQUALS,\n           HoodieTimeline.FULL_BOOTSTRAP_INSTANT_TS)) {\n-        rollBackInflightBootstrap();\n+        rollbackFailedBootstrap();\n         break;\n       } else {\n-        rollback(commit);\n+        rollback(instant);\n+      }\n+      // Delete the heartbeats from DFS\n+      if (!isEager(config.getFailedWritesCleanPolicy())) {\n+        try {\n+          this.heartbeatClient.delete(instant);", "originalCommit": "557bbd3d71e53f8306d0f1cae6ced16314204aee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc1ODM0MQ==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r553758341", "bodyText": "Added a Utils class to clean up orphaned heartbeat files", "author": "n3nash", "createdAt": "2021-01-08T06:03:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA3ODEwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA3OTUwMw==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r552079503", "bodyText": "Like I mentioned above, we can make turn this into eagerCleanFailedWrites() returning boolean, working off the member variable config ? In its current form, this should probably reside in HoodieFailedWritesCleaningPolicy itself", "author": "vinothchandar", "createdAt": "2021-01-05T17:26:15Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -859,6 +931,10 @@ protected void setWriteSchemaForDeletes(HoodieTableMetaClient metaClient) {\n     }\n   }\n \n+  private boolean isEager(HoodieFailedWritesCleaningPolicy cleaningPolicy) {", "originalCommit": "557bbd3d71e53f8306d0f1cae6ced16314204aee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzE2ODM1Ng==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r553168356", "bodyText": "Responded above", "author": "n3nash", "createdAt": "2021-01-07T08:11:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA3OTUwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA3OTk4Ng==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r552079986", "bodyText": "typo: interval", "author": "vinothchandar", "createdAt": "2021-01-05T17:26:59Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/heartbeat/HoodieHeartbeatClient.java", "diffHunk": "@@ -0,0 +1,265 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.client.heartbeat;\n+\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.util.ValidationUtils;\n+import org.apache.hudi.exception.HoodieException;\n+import org.apache.hudi.exception.HoodieHeartbeatException;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+\n+/**\n+ * This class creates heartbeat for hudi client. This heartbeat is used to ascertain whether the running job is or not.\n+ * NOTE: Due to CPU contention on the driver/client node, the heartbeats could be delayed, hence it's important to set\n+ *       the value high enough to avoid that possibility.\n+ */\n+@NotThreadSafe\n+public class HoodieHeartbeatClient implements AutoCloseable, Serializable {\n+\n+  private static final Logger LOG = LogManager.getLogger(HoodieHeartbeatClient.class);\n+\n+  // path to the heartbeat folder where all writers are updating their heartbeats\n+  private final transient FileSystem fs;\n+  private final String basePath;\n+  private String heartBeatFolderPath;\n+  // heartbeat interval in millis\n+  private final Long heartbeatIntervalInMs;\n+  private Integer numTolerableHeartbeatMisses;\n+  private final Long maxAllowableHeartbeatInternalInMs;", "originalCommit": "557bbd3d71e53f8306d0f1cae6ced16314204aee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA4MTE2Nw==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r552081167", "bodyText": "just numHeartBeats?", "author": "vinothchandar", "createdAt": "2021-01-05T17:28:45Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/heartbeat/HoodieHeartbeatClient.java", "diffHunk": "@@ -0,0 +1,265 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.client.heartbeat;\n+\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.util.ValidationUtils;\n+import org.apache.hudi.exception.HoodieException;\n+import org.apache.hudi.exception.HoodieHeartbeatException;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+\n+/**\n+ * This class creates heartbeat for hudi client. This heartbeat is used to ascertain whether the running job is or not.\n+ * NOTE: Due to CPU contention on the driver/client node, the heartbeats could be delayed, hence it's important to set\n+ *       the value high enough to avoid that possibility.\n+ */\n+@NotThreadSafe\n+public class HoodieHeartbeatClient implements AutoCloseable, Serializable {\n+\n+  private static final Logger LOG = LogManager.getLogger(HoodieHeartbeatClient.class);\n+\n+  // path to the heartbeat folder where all writers are updating their heartbeats\n+  private final transient FileSystem fs;\n+  private final String basePath;\n+  private String heartBeatFolderPath;\n+  // heartbeat interval in millis\n+  private final Long heartbeatIntervalInMs;\n+  private Integer numTolerableHeartbeatMisses;\n+  private final Long maxAllowableHeartbeatInternalInMs;\n+  private Map<String, Heartbeat> instantToHeartbeatMap;\n+\n+  public HoodieHeartbeatClient(FileSystem fs, String basePath, Long heartbeatIntervalInMs,\n+                               Integer numTolerableHeartbeatMisses) {\n+    ValidationUtils.checkArgument(heartbeatIntervalInMs >= 1000, \"Cannot set heartbeat lower than 1 second\");\n+    this.fs = fs;\n+    this.basePath = basePath;\n+    this.heartBeatFolderPath = HoodieTableMetaClient.getHeartbeatFolderPath(basePath);\n+    this.heartbeatIntervalInMs = heartbeatIntervalInMs;\n+    this.numTolerableHeartbeatMisses = numTolerableHeartbeatMisses;\n+    this.maxAllowableHeartbeatInternalInMs = this.heartbeatIntervalInMs * this.numTolerableHeartbeatMisses;\n+    this.instantToHeartbeatMap = new HashMap<>();\n+  }\n+\n+  class Heartbeat {\n+\n+    private String instantTime;\n+    private Boolean isHeartbeatStarted = false;\n+    private Boolean isHeartbeatStopped = false;\n+    private Long lastHeartBeatTime;\n+    private Integer numHeartBeatsForCurrentInstantTime = 0;", "originalCommit": "557bbd3d71e53f8306d0f1cae6ced16314204aee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA4MTcxNA==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r552081714", "bodyText": "is there a reason to make this map synchronzied/concurrent ?", "author": "vinothchandar", "createdAt": "2021-01-05T17:29:39Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/heartbeat/HoodieHeartbeatClient.java", "diffHunk": "@@ -0,0 +1,265 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.client.heartbeat;\n+\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.util.ValidationUtils;\n+import org.apache.hudi.exception.HoodieException;\n+import org.apache.hudi.exception.HoodieHeartbeatException;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+\n+/**\n+ * This class creates heartbeat for hudi client. This heartbeat is used to ascertain whether the running job is or not.\n+ * NOTE: Due to CPU contention on the driver/client node, the heartbeats could be delayed, hence it's important to set\n+ *       the value high enough to avoid that possibility.\n+ */\n+@NotThreadSafe\n+public class HoodieHeartbeatClient implements AutoCloseable, Serializable {\n+\n+  private static final Logger LOG = LogManager.getLogger(HoodieHeartbeatClient.class);\n+\n+  // path to the heartbeat folder where all writers are updating their heartbeats\n+  private final transient FileSystem fs;\n+  private final String basePath;\n+  private String heartBeatFolderPath;\n+  // heartbeat interval in millis\n+  private final Long heartbeatIntervalInMs;\n+  private Integer numTolerableHeartbeatMisses;\n+  private final Long maxAllowableHeartbeatInternalInMs;\n+  private Map<String, Heartbeat> instantToHeartbeatMap;\n+\n+  public HoodieHeartbeatClient(FileSystem fs, String basePath, Long heartbeatIntervalInMs,\n+                               Integer numTolerableHeartbeatMisses) {\n+    ValidationUtils.checkArgument(heartbeatIntervalInMs >= 1000, \"Cannot set heartbeat lower than 1 second\");\n+    this.fs = fs;\n+    this.basePath = basePath;\n+    this.heartBeatFolderPath = HoodieTableMetaClient.getHeartbeatFolderPath(basePath);\n+    this.heartbeatIntervalInMs = heartbeatIntervalInMs;\n+    this.numTolerableHeartbeatMisses = numTolerableHeartbeatMisses;\n+    this.maxAllowableHeartbeatInternalInMs = this.heartbeatIntervalInMs * this.numTolerableHeartbeatMisses;\n+    this.instantToHeartbeatMap = new HashMap<>();\n+  }\n+\n+  class Heartbeat {\n+\n+    private String instantTime;\n+    private Boolean isHeartbeatStarted = false;\n+    private Boolean isHeartbeatStopped = false;\n+    private Long lastHeartBeatTime;\n+    private Integer numHeartBeatsForCurrentInstantTime = 0;\n+    private Timer timer = new Timer();\n+\n+    public String getInstantTime() {\n+      return instantTime;\n+    }\n+\n+    public void setInstantTime(String instantTime) {\n+      this.instantTime = instantTime;\n+    }\n+\n+    public Boolean isHeartbeatStarted() {\n+      return isHeartbeatStarted;\n+    }\n+\n+    public void setHeartbeatStarted(Boolean heartbeatStarted) {\n+      isHeartbeatStarted = heartbeatStarted;\n+    }\n+\n+    public Boolean isHeartbeatStopped() {\n+      return isHeartbeatStopped;\n+    }\n+\n+    public void setHeartbeatStopped(Boolean heartbeatStopped) {\n+      isHeartbeatStopped = heartbeatStopped;\n+    }\n+\n+    public Long getLastHeartBeatTime() {\n+      return lastHeartBeatTime;\n+    }\n+\n+    public void setLastHeartBeatTime(Long lastHeartBeatTime) {\n+      this.lastHeartBeatTime = lastHeartBeatTime;\n+    }\n+\n+    public Integer getNumHeartBeatsForCurrentInstantTime() {\n+      return numHeartBeatsForCurrentInstantTime;\n+    }\n+\n+    public void setNumHeartBeatsForCurrentInstantTime(Integer numHeartBeatsForCurrentInstantTime) {\n+      this.numHeartBeatsForCurrentInstantTime = numHeartBeatsForCurrentInstantTime;\n+    }\n+\n+    public Timer getTimer() {\n+      return timer;\n+    }\n+\n+    public void setTimer(Timer timer) {\n+      this.timer = timer;\n+    }\n+  }\n+\n+  class HeartbeatTask extends TimerTask {\n+\n+    private final String instantTime;\n+\n+    HeartbeatTask(String instantTime) {\n+      this.instantTime = instantTime;\n+    }\n+\n+    @Override\n+    public void run() {\n+      updateHeartbeat(instantTime);\n+    }\n+  }\n+\n+  /**\n+   * Start a new heartbeat for the specified instant. If there is already one running, this will be a NO_OP\n+   * @param instantTime\n+   */\n+  public void start(String instantTime) {\n+    LOG.info(\"Received request to start heartbeat for instant time \" + instantTime);\n+    Heartbeat heartbeat = instantToHeartbeatMap.get(instantTime);", "originalCommit": "557bbd3d71e53f8306d0f1cae6ced16314204aee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzE2OTkwNQ==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r553169905", "bodyText": "It's not synchronized, if you see above, it's just a HashMap()", "author": "n3nash", "createdAt": "2021-01-07T08:15:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA4MTcxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA4MjQzOA==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r552082438", "bodyText": "I find this a bit odd, for heartBeat to have a delete() method? can this clean up be done as part of stop() ? esp given delete() requires a stop first", "author": "vinothchandar", "createdAt": "2021-01-05T17:31:04Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/heartbeat/HoodieHeartbeatClient.java", "diffHunk": "@@ -0,0 +1,265 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.client.heartbeat;\n+\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.util.ValidationUtils;\n+import org.apache.hudi.exception.HoodieException;\n+import org.apache.hudi.exception.HoodieHeartbeatException;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+\n+/**\n+ * This class creates heartbeat for hudi client. This heartbeat is used to ascertain whether the running job is or not.\n+ * NOTE: Due to CPU contention on the driver/client node, the heartbeats could be delayed, hence it's important to set\n+ *       the value high enough to avoid that possibility.\n+ */\n+@NotThreadSafe\n+public class HoodieHeartbeatClient implements AutoCloseable, Serializable {\n+\n+  private static final Logger LOG = LogManager.getLogger(HoodieHeartbeatClient.class);\n+\n+  // path to the heartbeat folder where all writers are updating their heartbeats\n+  private final transient FileSystem fs;\n+  private final String basePath;\n+  private String heartBeatFolderPath;\n+  // heartbeat interval in millis\n+  private final Long heartbeatIntervalInMs;\n+  private Integer numTolerableHeartbeatMisses;\n+  private final Long maxAllowableHeartbeatInternalInMs;\n+  private Map<String, Heartbeat> instantToHeartbeatMap;\n+\n+  public HoodieHeartbeatClient(FileSystem fs, String basePath, Long heartbeatIntervalInMs,\n+                               Integer numTolerableHeartbeatMisses) {\n+    ValidationUtils.checkArgument(heartbeatIntervalInMs >= 1000, \"Cannot set heartbeat lower than 1 second\");\n+    this.fs = fs;\n+    this.basePath = basePath;\n+    this.heartBeatFolderPath = HoodieTableMetaClient.getHeartbeatFolderPath(basePath);\n+    this.heartbeatIntervalInMs = heartbeatIntervalInMs;\n+    this.numTolerableHeartbeatMisses = numTolerableHeartbeatMisses;\n+    this.maxAllowableHeartbeatInternalInMs = this.heartbeatIntervalInMs * this.numTolerableHeartbeatMisses;\n+    this.instantToHeartbeatMap = new HashMap<>();\n+  }\n+\n+  class Heartbeat {\n+\n+    private String instantTime;\n+    private Boolean isHeartbeatStarted = false;\n+    private Boolean isHeartbeatStopped = false;\n+    private Long lastHeartBeatTime;\n+    private Integer numHeartBeatsForCurrentInstantTime = 0;\n+    private Timer timer = new Timer();\n+\n+    public String getInstantTime() {\n+      return instantTime;\n+    }\n+\n+    public void setInstantTime(String instantTime) {\n+      this.instantTime = instantTime;\n+    }\n+\n+    public Boolean isHeartbeatStarted() {\n+      return isHeartbeatStarted;\n+    }\n+\n+    public void setHeartbeatStarted(Boolean heartbeatStarted) {\n+      isHeartbeatStarted = heartbeatStarted;\n+    }\n+\n+    public Boolean isHeartbeatStopped() {\n+      return isHeartbeatStopped;\n+    }\n+\n+    public void setHeartbeatStopped(Boolean heartbeatStopped) {\n+      isHeartbeatStopped = heartbeatStopped;\n+    }\n+\n+    public Long getLastHeartBeatTime() {\n+      return lastHeartBeatTime;\n+    }\n+\n+    public void setLastHeartBeatTime(Long lastHeartBeatTime) {\n+      this.lastHeartBeatTime = lastHeartBeatTime;\n+    }\n+\n+    public Integer getNumHeartBeatsForCurrentInstantTime() {\n+      return numHeartBeatsForCurrentInstantTime;\n+    }\n+\n+    public void setNumHeartBeatsForCurrentInstantTime(Integer numHeartBeatsForCurrentInstantTime) {\n+      this.numHeartBeatsForCurrentInstantTime = numHeartBeatsForCurrentInstantTime;\n+    }\n+\n+    public Timer getTimer() {\n+      return timer;\n+    }\n+\n+    public void setTimer(Timer timer) {\n+      this.timer = timer;\n+    }\n+  }\n+\n+  class HeartbeatTask extends TimerTask {\n+\n+    private final String instantTime;\n+\n+    HeartbeatTask(String instantTime) {\n+      this.instantTime = instantTime;\n+    }\n+\n+    @Override\n+    public void run() {\n+      updateHeartbeat(instantTime);\n+    }\n+  }\n+\n+  /**\n+   * Start a new heartbeat for the specified instant. If there is already one running, this will be a NO_OP\n+   * @param instantTime\n+   */\n+  public void start(String instantTime) {\n+    LOG.info(\"Received request to start heartbeat for instant time \" + instantTime);\n+    Heartbeat heartbeat = instantToHeartbeatMap.get(instantTime);\n+    ValidationUtils.checkArgument(heartbeat == null || !heartbeat.isHeartbeatStopped(), \"Cannot restart a stopped heartbeat for \" + instantTime);\n+    if (heartbeat != null && heartbeat.isHeartbeatStarted()) {\n+      // heartbeat already started, NO_OP\n+      return;\n+    } else {\n+      Heartbeat newHeartBeat = new Heartbeat();\n+      newHeartBeat.setHeartbeatStarted(true);\n+      instantToHeartbeatMap.putIfAbsent(instantTime, newHeartBeat);\n+      // Ensure heartbeat is generated for the first time with this blocking call.\n+      // Since timer submits the task to a thread, no guarantee when that thread will get CPU\n+      // cycles to generate the first heartbeat.\n+      updateHeartbeat(instantTime);\n+      newHeartBeat.getTimer().scheduleAtFixedRate(new HeartbeatTask(instantTime), this.heartbeatIntervalInMs,\n+          this.heartbeatIntervalInMs);\n+    }\n+  }\n+\n+  /**\n+   * Stops the heartbeat for the specified instant.\n+   * @param instantTime\n+   * @throws HoodieException\n+   */\n+  public void stop(String instantTime) throws HoodieException {\n+    Heartbeat heartbeat = instantToHeartbeatMap.get(instantTime);\n+    if (heartbeat != null && heartbeat.isHeartbeatStarted() && !heartbeat.isHeartbeatStopped()) {\n+      heartbeat.getTimer().cancel();\n+      heartbeat.setHeartbeatStopped(true);\n+      LOG.info(\"Stopping heartbeat for instant \" + instantTime);\n+    }\n+  }\n+\n+  /**\n+   * Stops all heartbeats started via this instance of the client.\n+   * @throws HoodieException\n+   */\n+  public void stop() throws HoodieException {\n+    instantToHeartbeatMap.values().stream().forEach(heartbeat -> stop(heartbeat.getInstantTime()));\n+  }\n+\n+  public boolean delete(String instantTime) throws IOException {", "originalCommit": "557bbd3d71e53f8306d0f1cae6ced16314204aee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzE4MjA4OQ==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r553182089", "bodyText": "yeah, I agree, refactored and moved to utils class", "author": "n3nash", "createdAt": "2021-01-07T08:42:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA4MjQzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA4Mzg5NQ==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r552083895", "bodyText": "withFailedWritesCleaningPolicy(). can we make this consistent everywhere.", "author": "vinothchandar", "createdAt": "2021-01-05T17:33:34Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/config/HoodieCompactionConfig.java", "diffHunk": "@@ -260,6 +264,11 @@ public Builder withCleanBootstrapBaseFileEnabled(Boolean cleanBootstrapSourceFil\n       return this;\n     }\n \n+    public Builder withCleanFailedWritesPolicy(HoodieFailedWritesCleaningPolicy failedWritesPolicy) {", "originalCommit": "557bbd3d71e53f8306d0f1cae6ced16314204aee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzE3MDU1Mw==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r553170553", "bodyText": "Done, is there an easy way to generate a with... for these variables ? I'm manually typing them hence end up introducing errors.", "author": "n3nash", "createdAt": "2021-01-07T08:16:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA4Mzg5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA4NjA5OA==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r552086098", "bodyText": "the 2 second limit is a bit tight. the test jvm can gc etc. can we make this longer.  same check for other time based tests here.", "author": "vinothchandar", "createdAt": "2021-01-05T17:37:18Z", "path": "hudi-client/hudi-client-common/src/test/java/org/apache/hudi/client/heartbeat/TestHoodieHeartbeatClient.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.client.heartbeat;\n+\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.testutils.HoodieCommonTestHarness;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static org.awaitility.Awaitility.await;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class TestHoodieHeartbeatClient extends HoodieCommonTestHarness {\n+\n+  private static final Logger LOG = LogManager.getLogger(TestHoodieHeartbeatClient.class);\n+\n+  private static String instantTime1 = \"100\";\n+  private static String instantTime2 = \"101\";\n+  private static Long heartBeatInterval = 1000L;\n+  private static int numTolerableMisses = 1;\n+\n+  @BeforeEach\n+  public void init() throws IOException {\n+    initMetaClient();\n+  }\n+\n+  @Test\n+  public void testStartHeartbeat() throws IOException {\n+    HoodieHeartbeatClient hoodieHeartbeatClient =\n+        new HoodieHeartbeatClient(metaClient.getFs(), metaClient.getBasePath(), heartBeatInterval, numTolerableMisses);\n+    hoodieHeartbeatClient.start(instantTime1);\n+    FileStatus [] fs = metaClient.getFs().listStatus(new Path(hoodieHeartbeatClient.getHeartBeatFolderPath()));\n+    assertTrue(fs.length == 1);\n+    assertTrue(fs[0].getPath().toString().contains(instantTime1));\n+  }\n+\n+  @Test\n+  public void testStopHeartbeat() {\n+    HoodieHeartbeatClient hoodieHeartbeatClient =\n+        new HoodieHeartbeatClient(metaClient.getFs(), metaClient.getBasePath(), heartBeatInterval, numTolerableMisses);\n+    hoodieHeartbeatClient.start(instantTime1);\n+    hoodieHeartbeatClient.stop(instantTime1);\n+    await().atMost(2, SECONDS).until(() -> hoodieHeartbeatClient.getHeartbeat(instantTime1).getNumHeartBeatsForCurrentInstantTime() > 0);", "originalCommit": "557bbd3d71e53f8306d0f1cae6ced16314204aee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzE3MTQ5Nw==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r553171497", "bodyText": "I thought await() doesn't necessary wait for 2 SECONDS, it just simulates that internally ?", "author": "n3nash", "createdAt": "2021-01-07T08:18:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA4NjA5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA4NzQ1NA==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r552087454", "bodyText": "docs for all these three modes please.", "author": "vinothchandar", "createdAt": "2021-01-05T17:39:44Z", "path": "hudi-common/src/main/java/org/apache/hudi/common/model/HoodieFailedWritesCleaningPolicy.java", "diffHunk": "@@ -0,0 +1,23 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.common.model;\n+\n+public enum HoodieFailedWritesCleaningPolicy {\n+  EAGER, LAZY, NEVER", "originalCommit": "557bbd3d71e53f8306d0f1cae6ced16314204aee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "868fbaba7f5a778dc6248b6a4c2b25362b8a8d6b", "url": "https://github.com/apache/hudi/commit/868fbaba7f5a778dc6248b6a4c2b25362b8a8d6b", "message": "Refactored code, removed parallel writing capability", "committedDate": "2021-01-19T00:46:14Z", "type": "forcePushed"}, {"oid": "b702eb16f9bfcba66e69036514b5b96c898074e8", "url": "https://github.com/apache/hudi/commit/b702eb16f9bfcba66e69036514b5b96c898074e8", "message": "Refactored code, removed parallel writing capability", "committedDate": "2021-01-20T09:08:04Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODE1NzAyMQ==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r568157021", "bodyText": "@n3nash spent sometime thinking about this. the tradeoffs are pretty clear in the sense, this helps us reclaim the storage used by failed writes much sooner than say deleting the files, during archival process (which by itself is not a guarantee actually).\nIf we want to implement some schema to pre-emptively take away compute resources used by a pending job or storage space, then I don't see a way to do this without heartbeats of some kind.\nWe could just keep this simpler in this PR, if you like and just clean up once during archival. (again, the case of a long deletion job running for say 12 hrs, comes to mind. and That needs some kind of heartbeat mechanism, so that even archival does not clean up).\nOrthogonal question : for such long running concurrent writes, should n't they just abort early if they detect more commits have happened since it began?  i.e if it figures out after 1 hr of runtime, that some writes have changed the same filegroups, then why should it even run? its going to fail anyway", "author": "vinothchandar", "createdAt": "2021-02-01T21:37:23Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/heartbeat/HoodieHeartbeatClient.java", "diffHunk": "@@ -0,0 +1,265 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.client.heartbeat;\n+\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.util.HeartbeatUtils;\n+import org.apache.hudi.common.util.ValidationUtils;\n+import org.apache.hudi.exception.HoodieException;\n+import org.apache.hudi.exception.HoodieHeartbeatException;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.Serializable;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class creates heartbeat for hudi client. This heartbeat is used to ascertain whether the running job is or not.", "originalCommit": "b702eb16f9bfcba66e69036514b5b96c898074e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODgyNTcxMg==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r568825712", "bodyText": "will review this class again, pending this discussion here.", "author": "vinothchandar", "createdAt": "2021-02-02T18:16:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODE1NzAyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTE1Njc4Ng==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r569156786", "bodyText": "High level, no other way to guard against these cases. Even if we check for long running concurrent writes and resolve every N heartbeats, backfill jobs may not have anything overlapping and may even OOM at the end since folks don't know how to tune large spark jobs.", "author": "n3nash", "createdAt": "2021-02-03T06:17:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODE1NzAyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODgxNDYzNA==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r568814634", "bodyText": "is rollbackPending being used anymore? remove?", "author": "vinothchandar", "createdAt": "2021-02-02T17:59:56Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -128,11 +133,26 @@ public AbstractHoodieWriteClient(HoodieEngineContext context, HoodieWriteConfig\n    * @param rollbackPending whether need to cleanup pending commits\n    * @param timelineService Timeline Service that runs as part of write client.\n    */\n+  @Deprecated\n   public AbstractHoodieWriteClient(HoodieEngineContext context, HoodieWriteConfig writeConfig, boolean rollbackPending,", "originalCommit": "b702eb16f9bfcba66e69036514b5b96c898074e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTE0OTI1NA==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r569149254", "bodyText": "That would be a backwards incompatible change. I'm OK to remove it if it's just for Uber.", "author": "n3nash", "createdAt": "2021-02-03T05:55:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODgxNDYzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTE2NjQxNQ==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r569166415", "bodyText": "yeah nobody uses the RDD api other than Uber. so please remove.", "author": "vinothchandar", "createdAt": "2021-02-03T06:44:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODgxNDYzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODgxNTA3OQ==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r568815079", "bodyText": "remote isCommitted and return directly?", "author": "vinothchandar", "createdAt": "2021-02-02T18:00:33Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -160,7 +180,8 @@ public boolean commit(String instantTime, O writeStatuses) {\n   public boolean commit(String instantTime, O writeStatuses, Option<Map<String, String>> extraMetadata) {\n     HoodieTableMetaClient metaClient = createMetaClient(false);\n     String actionType = metaClient.getCommitActionType();\n-    return commit(instantTime, writeStatuses, extraMetadata, actionType, Collections.emptyMap());\n+    boolean isCommitted = commit(instantTime, writeStatuses, extraMetadata, actionType, Collections.emptyMap());", "originalCommit": "b702eb16f9bfcba66e69036514b5b96c898074e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODgxODIxOA==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r568818218", "bodyText": "this seems like remnant of merge conficts? can you please make a full pass and ensure no temp debugging changes/ or remnants like this are removed?", "author": "vinothchandar", "createdAt": "2021-02-02T18:05:09Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -732,6 +746,9 @@ public void rollbackInflightCompaction(HoodieInstant inflightInstant, HoodieTabl\n   }\n \n   /**\n+<<<<<<< 1e1a9a5ba5907efb5dd8cb1e0ae830aa78725dd1", "originalCommit": "b702eb16f9bfcba66e69036514b5b96c898074e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODgxODMwMQ==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r568818301", "bodyText": "same here", "author": "vinothchandar", "createdAt": "2021-02-02T18:05:18Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -750,24 +767,49 @@ private HoodieTimeline getInflightTimelineExcludeCompactionAndClustering(HoodieT\n   }\n \n   /**\n-   * Cleanup all pending commits.\n+   * Clean up all failed commits.\n+=======", "originalCommit": "b702eb16f9bfcba66e69036514b5b96c898074e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODgyMTg3Mg==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r568821872", "bodyText": "would nt HoodieFailedWritesCleaningPolicy.NEVER also pass the check for !eager ?", "author": "vinothchandar", "createdAt": "2021-02-02T18:10:26Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -750,24 +767,49 @@ private HoodieTimeline getInflightTimelineExcludeCompactionAndClustering(HoodieT\n   }\n \n   /**\n-   * Cleanup all pending commits.\n+   * Clean up all failed commits.\n+=======\n+   * Rollback all failed commits.\n+>>>>>>> Adding configs to make failed writes eager/lazy\n+=======\n+   * Rollback all failed writes.\n+>>>>>>> Refactored code, removed parallel writing capability\n    */\n-  private void rollbackPendingCommits() {\n+  public void rollbackFailedWrites() {\n     HoodieTable<T, I, K, O> table = createTable(config, hadoopConf);\n-    HoodieTimeline inflightTimeline = getInflightTimelineExcludeCompactionAndClustering(table);\n-    List<String> commits = inflightTimeline.getReverseOrderedInstants().map(HoodieInstant::getTimestamp)\n-        .collect(Collectors.toList());\n-    for (String commit : commits) {\n-      if (HoodieTimeline.compareTimestamps(commit, HoodieTimeline.LESSER_THAN_OR_EQUALS,\n+    List<String> instantsToRollback = getInstantsToRollback(table);\n+    for (String instant : instantsToRollback) {\n+      if (HoodieTimeline.compareTimestamps(instant, HoodieTimeline.LESSER_THAN_OR_EQUALS,\n           HoodieTimeline.FULL_BOOTSTRAP_INSTANT_TS)) {\n-        rollBackInflightBootstrap();\n+        rollbackFailedBootstrap();\n         break;\n       } else {\n-        rollback(commit);\n+        rollback(instant);\n       }\n     }\n   }\n \n+  private List<String> getInstantsToRollback(HoodieTable<T, I, K, O> table) {\n+    if (config.getFailedWritesCleanPolicy().isEager()) {\n+      HoodieTimeline inflightTimeline = table.getMetaClient().getCommitsTimeline().filterPendingExcludingCompaction();\n+      return inflightTimeline.getReverseOrderedInstants().map(HoodieInstant::getTimestamp)\n+          .collect(Collectors.toList());\n+    } else if (!config.getFailedWritesCleanPolicy().isEager()) {", "originalCommit": "b702eb16f9bfcba66e69036514b5b96c898074e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTE1MDMwNw==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r569150307", "bodyText": "moved the else if conditions", "author": "n3nash", "createdAt": "2021-02-03T05:58:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODgyMTg3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODgyMzA3Mg==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r568823072", "bodyText": "lets move this to HeartbeatUtils", "author": "vinothchandar", "createdAt": "2021-02-02T18:12:18Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -859,6 +901,19 @@ protected void finalizeWrite(HoodieTable<T, I, K, O> table, String instantTime,\n     }\n   }\n \n+  protected void checkHeartbeatExpired(String instantTime, HoodieTable table) {", "originalCommit": "b702eb16f9bfcba66e69036514b5b96c898074e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODgyNjUwMg==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r568826502", "bodyText": "nit: tolerable.misses", "author": "vinothchandar", "createdAt": "2021-02-02T18:17:12Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/config/HoodieWriteConfig.java", "diffHunk": "@@ -133,6 +134,12 @@\n   private static final String MERGE_DATA_VALIDATION_CHECK_ENABLED = \"hoodie.merge.data.validation.enabled\";\n   private static final String DEFAULT_MERGE_DATA_VALIDATION_CHECK_ENABLED = \"false\";\n \n+  public static final String CLIENT_HEARTBEAT_INTERVAL_IN_MS_PROP = \"hoodie.client.heartbeat.interval_in_ms\";\n+  public static final Integer DEFAULT_CLIENT_HEARTBEAT_INTERVAL_IN_MS = 60 * 1000;\n+\n+  public static final String CLIENT_HEARTBEAT_NUM_TOLERABLE_MISSES_PROP = \"hoodie.client.heartbeat.tolerable_misses\";", "originalCommit": "b702eb16f9bfcba66e69036514b5b96c898074e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODgyNzUwMw==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r568827503", "bodyText": "was wondering how these threads actually stop?", "author": "vinothchandar", "createdAt": "2021-02-02T18:18:36Z", "path": "hudi-client/hudi-client-common/src/test/java/org/apache/hudi/client/heartbeat/TestHoodieHeartbeatClient.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.client.heartbeat;\n+\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.testutils.HoodieCommonTestHarness;\n+import org.apache.hudi.common.util.HeartbeatUtils;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static org.awaitility.Awaitility.await;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class TestHoodieHeartbeatClient extends HoodieCommonTestHarness {\n+\n+  private static final Logger LOG = LogManager.getLogger(TestHoodieHeartbeatClient.class);\n+\n+  private static String instantTime1 = \"100\";\n+  private static String instantTime2 = \"101\";\n+  private static Long heartBeatInterval = 1000L;\n+  private static int numTolerableMisses = 1;\n+\n+  @BeforeEach\n+  public void init() throws IOException {\n+    initMetaClient();\n+  }\n+\n+  @Test\n+  public void testStartHeartbeat() throws IOException {\n+    HoodieHeartbeatClient hoodieHeartbeatClient =\n+        new HoodieHeartbeatClient(metaClient.getFs(), metaClient.getBasePath(), heartBeatInterval, numTolerableMisses);\n+    hoodieHeartbeatClient.start(instantTime1);\n+    FileStatus [] fs = metaClient.getFs().listStatus(new Path(hoodieHeartbeatClient.getHeartbeatFolderPath()));\n+    assertTrue(fs.length == 1);\n+    assertTrue(fs[0].getPath().toString().contains(instantTime1));\n+  }\n+\n+  @Test\n+  public void testStopHeartbeat() {\n+    HoodieHeartbeatClient hoodieHeartbeatClient =\n+        new HoodieHeartbeatClient(metaClient.getFs(), metaClient.getBasePath(), heartBeatInterval, numTolerableMisses);\n+    hoodieHeartbeatClient.start(instantTime1);\n+    hoodieHeartbeatClient.stop(instantTime1);\n+    await().atMost(5, SECONDS).until(() -> hoodieHeartbeatClient.getHeartbeat(instantTime1).getNumHeartbeats() > 0);\n+    Integer numHeartBeats = hoodieHeartbeatClient.getHeartbeat(instantTime1).getNumHeartbeats();\n+    assertTrue(numHeartBeats == 1);\n+  }\n+\n+  @Test\n+  public void testIsHeartbeatExpired() throws IOException {\n+    HoodieHeartbeatClient hoodieHeartbeatClient =\n+        new HoodieHeartbeatClient(metaClient.getFs(), metaClient.getBasePath(), heartBeatInterval, numTolerableMisses);\n+    hoodieHeartbeatClient.start(instantTime1);\n+    hoodieHeartbeatClient.stop(instantTime1);\n+    assertFalse(hoodieHeartbeatClient.isHeartbeatExpired(instantTime1));\n+  }\n+\n+  @Test\n+  public void testNumHeartbeatsGenerated() {\n+    Long heartBeatInterval = 5000L;\n+    HoodieHeartbeatClient hoodieHeartbeatClient =\n+        new HoodieHeartbeatClient(metaClient.getFs(), metaClient.getBasePath(), heartBeatInterval, numTolerableMisses);\n+    hoodieHeartbeatClient.start(\"100\");\n+    await().atMost(5, SECONDS).until(() -> hoodieHeartbeatClient.getHeartbeat(instantTime1).getNumHeartbeats() >= 1);\n+  }\n+\n+  @Test\n+  public void testDeleteWrongHeartbeat() throws IOException {\n+    HoodieHeartbeatClient hoodieHeartbeatClient =\n+        new HoodieHeartbeatClient(metaClient.getFs(), metaClient.getBasePath(), heartBeatInterval, numTolerableMisses);\n+    hoodieHeartbeatClient.start(instantTime1);\n+    hoodieHeartbeatClient.stop(instantTime1);\n+    assertFalse(HeartbeatUtils.deleteHeartbeatFile(metaClient.getFs(), basePath, instantTime2));\n+  }\n+\n+  @Disabled\n+  public void testConcurrentReadsAndWritesToSameFile() throws InterruptedException {\n+    Thread th1 = new Thread(() -> {\n+      try {\n+        while (true) {\n+          OutputStream outputStream = metaClient.getFs().create(new Path(metaClient.getBasePath() + \"/test\"), true);\n+          outputStream.write(\"testing\".getBytes());\n+          outputStream.close();\n+        }\n+      } catch (Exception e) {\n+        LOG.info(\"Caught Exception th1\");\n+        e.printStackTrace();\n+      }\n+    });\n+\n+    Thread th2 = new Thread(() -> {\n+      try {\n+        while (true) {\n+          FileStatus fs = metaClient.getFs().getFileStatus(new Path(metaClient.getBasePath() + \"/test\"));\n+        }\n+      } catch (Exception e) {\n+        LOG.info(\"Caught Exception th2\");\n+        e.printStackTrace();\n+      }\n+    });\n+\n+    Thread th3 = new Thread(() -> {\n+      try {\n+        while (true) {\n+          String heartbeat = org.apache.commons.io.IOUtils.toString(metaClient.getFs().open(new Path(metaClient.getBasePath() + \"/test\")));\n+        }\n+      } catch (Exception e) {\n+        LOG.info(\"Caught Exception th3\");\n+        e.printStackTrace();\n+      }\n+    });\n+\n+    th1.start();\n+    Thread.sleep(100);\n+    th2.start();\n+    th3.start();\n+\n+    // To simulate the issues of race conditions when creating & reading file, simply do th1.join; th2.join; th3.join;", "originalCommit": "b702eb16f9bfcba66e69036514b5b96c898074e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTE1NDUzMA==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r569154530", "bodyText": "I left the test disabled since I was just using this for testing. Have enabled the test now and added the join back.", "author": "n3nash", "createdAt": "2021-02-03T06:10:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODgyNzUwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODgyNzczMA==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r568827730", "bodyText": "LOG.error() and get rid of printing stack trace?", "author": "vinothchandar", "createdAt": "2021-02-02T18:18:55Z", "path": "hudi-client/hudi-client-common/src/test/java/org/apache/hudi/client/heartbeat/TestHoodieHeartbeatClient.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.client.heartbeat;\n+\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.testutils.HoodieCommonTestHarness;\n+import org.apache.hudi.common.util.HeartbeatUtils;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static org.awaitility.Awaitility.await;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class TestHoodieHeartbeatClient extends HoodieCommonTestHarness {\n+\n+  private static final Logger LOG = LogManager.getLogger(TestHoodieHeartbeatClient.class);\n+\n+  private static String instantTime1 = \"100\";\n+  private static String instantTime2 = \"101\";\n+  private static Long heartBeatInterval = 1000L;\n+  private static int numTolerableMisses = 1;\n+\n+  @BeforeEach\n+  public void init() throws IOException {\n+    initMetaClient();\n+  }\n+\n+  @Test\n+  public void testStartHeartbeat() throws IOException {\n+    HoodieHeartbeatClient hoodieHeartbeatClient =\n+        new HoodieHeartbeatClient(metaClient.getFs(), metaClient.getBasePath(), heartBeatInterval, numTolerableMisses);\n+    hoodieHeartbeatClient.start(instantTime1);\n+    FileStatus [] fs = metaClient.getFs().listStatus(new Path(hoodieHeartbeatClient.getHeartbeatFolderPath()));\n+    assertTrue(fs.length == 1);\n+    assertTrue(fs[0].getPath().toString().contains(instantTime1));\n+  }\n+\n+  @Test\n+  public void testStopHeartbeat() {\n+    HoodieHeartbeatClient hoodieHeartbeatClient =\n+        new HoodieHeartbeatClient(metaClient.getFs(), metaClient.getBasePath(), heartBeatInterval, numTolerableMisses);\n+    hoodieHeartbeatClient.start(instantTime1);\n+    hoodieHeartbeatClient.stop(instantTime1);\n+    await().atMost(5, SECONDS).until(() -> hoodieHeartbeatClient.getHeartbeat(instantTime1).getNumHeartbeats() > 0);\n+    Integer numHeartBeats = hoodieHeartbeatClient.getHeartbeat(instantTime1).getNumHeartbeats();\n+    assertTrue(numHeartBeats == 1);\n+  }\n+\n+  @Test\n+  public void testIsHeartbeatExpired() throws IOException {\n+    HoodieHeartbeatClient hoodieHeartbeatClient =\n+        new HoodieHeartbeatClient(metaClient.getFs(), metaClient.getBasePath(), heartBeatInterval, numTolerableMisses);\n+    hoodieHeartbeatClient.start(instantTime1);\n+    hoodieHeartbeatClient.stop(instantTime1);\n+    assertFalse(hoodieHeartbeatClient.isHeartbeatExpired(instantTime1));\n+  }\n+\n+  @Test\n+  public void testNumHeartbeatsGenerated() {\n+    Long heartBeatInterval = 5000L;\n+    HoodieHeartbeatClient hoodieHeartbeatClient =\n+        new HoodieHeartbeatClient(metaClient.getFs(), metaClient.getBasePath(), heartBeatInterval, numTolerableMisses);\n+    hoodieHeartbeatClient.start(\"100\");\n+    await().atMost(5, SECONDS).until(() -> hoodieHeartbeatClient.getHeartbeat(instantTime1).getNumHeartbeats() >= 1);\n+  }\n+\n+  @Test\n+  public void testDeleteWrongHeartbeat() throws IOException {\n+    HoodieHeartbeatClient hoodieHeartbeatClient =\n+        new HoodieHeartbeatClient(metaClient.getFs(), metaClient.getBasePath(), heartBeatInterval, numTolerableMisses);\n+    hoodieHeartbeatClient.start(instantTime1);\n+    hoodieHeartbeatClient.stop(instantTime1);\n+    assertFalse(HeartbeatUtils.deleteHeartbeatFile(metaClient.getFs(), basePath, instantTime2));\n+  }\n+\n+  @Disabled\n+  public void testConcurrentReadsAndWritesToSameFile() throws InterruptedException {\n+    Thread th1 = new Thread(() -> {\n+      try {\n+        while (true) {\n+          OutputStream outputStream = metaClient.getFs().create(new Path(metaClient.getBasePath() + \"/test\"), true);\n+          outputStream.write(\"testing\".getBytes());\n+          outputStream.close();\n+        }\n+      } catch (Exception e) {\n+        LOG.info(\"Caught Exception th1\");\n+        e.printStackTrace();\n+      }\n+    });\n+\n+    Thread th2 = new Thread(() -> {\n+      try {\n+        while (true) {\n+          FileStatus fs = metaClient.getFs().getFileStatus(new Path(metaClient.getBasePath() + \"/test\"));\n+        }\n+      } catch (Exception e) {\n+        LOG.info(\"Caught Exception th2\");\n+        e.printStackTrace();\n+      }\n+    });\n+\n+    Thread th3 = new Thread(() -> {\n+      try {\n+        while (true) {\n+          String heartbeat = org.apache.commons.io.IOUtils.toString(metaClient.getFs().open(new Path(metaClient.getBasePath() + \"/test\")));\n+        }\n+      } catch (Exception e) {\n+        LOG.info(\"Caught Exception th3\");\n+        e.printStackTrace();", "originalCommit": "b702eb16f9bfcba66e69036514b5b96c898074e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODgyODA4OQ==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r568828089", "bodyText": "same. lets remove the temp variable", "author": "vinothchandar", "createdAt": "2021-02-02T18:19:33Z", "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/client/SparkRDDWriteClient.java", "diffHunk": "@@ -105,7 +112,8 @@ public static SparkConf registerClasses(SparkConf conf) {\n   public boolean commit(String instantTime, JavaRDD<WriteStatus> writeStatuses, Option<Map<String, String>> extraMetadata,\n                         String commitActionType, Map<String, List<String>> partitionToReplacedFileIds) {\n     List<HoodieWriteStat> writeStats = writeStatuses.map(WriteStatus::getStat).collect();\n-    return commitStats(instantTime, writeStats, extraMetadata, commitActionType, partitionToReplacedFileIds);\n+    boolean isCommitted = commitStats(instantTime, writeStats, extraMetadata, commitActionType, partitionToReplacedFileIds);", "originalCommit": "b702eb16f9bfcba66e69036514b5b96c898074e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODgyODY1Mg==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r568828652", "bodyText": "is there a reason why this should be in hudi-common?", "author": "vinothchandar", "createdAt": "2021-02-02T18:20:20Z", "path": "hudi-common/src/main/java/org/apache/hudi/common/util/HeartbeatUtils.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.common.util;\n+\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.table.timeline.HoodieInstant;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper class to delete heartbeat for completed or failed instants with expired heartbeats.\n+ */\n+public class HeartbeatUtils {", "originalCommit": "b702eb16f9bfcba66e69036514b5b96c898074e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTE1NDc3Ng==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r569154776", "bodyText": "No, I thought I created it in hudi-client-common, moved it.", "author": "n3nash", "createdAt": "2021-02-03T06:11:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODgyODY1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODgyOTM3NQ==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r568829375", "bodyText": "rename by dropping  the Files suffix? is there any special handling for expired vs orphaned? why not just call it cleanExpiredHearbeats", "author": "vinothchandar", "createdAt": "2021-02-02T18:21:23Z", "path": "hudi-common/src/main/java/org/apache/hudi/common/util/HeartbeatUtils.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.common.util;\n+\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.table.timeline.HoodieInstant;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper class to delete heartbeat for completed or failed instants with expired heartbeats.\n+ */\n+public class HeartbeatUtils {\n+\n+  private static final Logger LOG = LogManager.getLogger(HeartbeatUtils.class);\n+\n+  /**\n+   * Deletes the heartbeat file for the specified instant.\n+   * @param fs\n+   * @param basePath\n+   * @param instantTime\n+   * @return\n+   */\n+  public static boolean deleteHeartbeatFile(FileSystem fs, String basePath, String instantTime) {\n+    boolean deleted = false;\n+    try {\n+      String heartbeatFolderPath = HoodieTableMetaClient.getHeartbeatFolderPath(basePath);\n+      deleted = fs.delete(new Path(heartbeatFolderPath + File.separator + instantTime), false);\n+      if (!deleted) {\n+        LOG.error(\"Failed to delete heartbeat for instant \" + instantTime);\n+      }\n+    } catch (IOException io) {\n+      LOG.error(\"Unable to delete heartbeat for instant \" + instantTime, io);\n+    }\n+    return deleted;\n+  }\n+\n+  /**\n+   * Deletes the heartbeat files for instants with expired heartbeats or orphaned heartbeats without any active instant.\n+   * @param existingHeartbeatInstants\n+   * @param metaClient\n+   * @param basePath\n+   */\n+  public static void cleanUpExpiredOrOrphanHeartbeatFiles(List<String> existingHeartbeatInstants,", "originalCommit": "b702eb16f9bfcba66e69036514b5b96c898074e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTE1NTEyNw==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r569155127", "bodyText": "There isn't any special handling, renamed it.", "author": "n3nash", "createdAt": "2021-02-03T06:12:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODgyOTM3NQ=="}], "type": "inlineReview"}, {"oid": "fddf048834bf3b40b70c2d128cdcc18a49cfb91f", "url": "https://github.com/apache/hudi/commit/fddf048834bf3b40b70c2d128cdcc18a49cfb91f", "message": "[HUDI-1486] Remove inline inflight rollback in hoodie writer\n1. Refactor rollback and move cleaning failed commits logic into cleaner\n2. Introduce hoodie heartbeat to ascertain failed commits\n3. Fix test cases", "committedDate": "2021-02-03T07:33:28Z", "type": "forcePushed"}, {"oid": "0764dd5a5931f798d37914dfafef0e2aaae7c873", "url": "https://github.com/apache/hudi/commit/0764dd5a5931f798d37914dfafef0e2aaae7c873", "message": "[HUDI-1486] Remove inline inflight rollback in hoodie writer\n1. Refactor rollback and move cleaning failed commits logic into cleaner\n2. Introduce hoodie heartbeat to ascertain failed commits\n3. Fix test cases", "committedDate": "2021-02-06T07:50:11Z", "type": "forcePushed"}, {"oid": "87b002a1569b225b90e63f720b9c2f8277c5971c", "url": "https://github.com/apache/hudi/commit/87b002a1569b225b90e63f720b9c2f8277c5971c", "message": "[HUDI-1486] Remove inline inflight rollback in hoodie writer\n1. Refactor rollback and move cleaning failed commits logic into cleaner\n2. Introduce hoodie heartbeat to ascertain failed commits\n3. Fix test cases", "committedDate": "2021-02-06T08:20:07Z", "type": "forcePushed"}, {"oid": "6d2391d4aad1025fc31090384e473d0685f31c82", "url": "https://github.com/apache/hudi/commit/6d2391d4aad1025fc31090384e473d0685f31c82", "message": "[HUDI-1486] Remove inline inflight rollback in hoodie writer\n1. Refactor rollback and move cleaning failed commits logic into cleaner\n2. Introduce hoodie heartbeat to ascertain failed commits\n3. Fix test cases", "committedDate": "2021-02-08T03:36:59Z", "type": "forcePushed"}, {"oid": "4a0cc16e25ca645396daf482088a6c36925d260b", "url": "https://github.com/apache/hudi/commit/4a0cc16e25ca645396daf482088a6c36925d260b", "message": "[HUDI-1486] Remove inline inflight rollback in hoodie writer\n1. Refactor rollback and move cleaning failed commits logic into cleaner\n2. Introduce hoodie heartbeat to ascertain failed commits\n3. Fix test cases", "committedDate": "2021-02-08T05:04:05Z", "type": "forcePushed"}, {"oid": "a100eaf17763ac7ddf50a53f9890922c54c7312f", "url": "https://github.com/apache/hudi/commit/a100eaf17763ac7ddf50a53f9890922c54c7312f", "message": "[HUDI-1486] Remove inline inflight rollback in hoodie writer\n1. Refactor rollback and move cleaning failed commits logic into cleaner\n2. Introduce hoodie heartbeat to ascertain failed commits\n3. Fix test cases", "committedDate": "2021-02-12T02:12:16Z", "type": "forcePushed"}, {"oid": "37ad1ec4cf340095dbc5585a842842a3df54e328", "url": "https://github.com/apache/hudi/commit/37ad1ec4cf340095dbc5585a842842a3df54e328", "message": "[HUDI-1486] Remove inline inflight rollback in hoodie writer\n1. Refactor rollback and move cleaning failed commits logic into cleaner\n2. Introduce hoodie heartbeat to ascertain failed commits\n3. Fix test cases", "committedDate": "2021-02-15T03:17:19Z", "type": "forcePushed"}, {"oid": "fd7e2e55e94491109046f9eb14386ccb180d27c3", "url": "https://github.com/apache/hudi/commit/fd7e2e55e94491109046f9eb14386ccb180d27c3", "message": "[HUDI-1486] Remove inline inflight rollback in hoodie writer\n1. Refactor rollback and move cleaning failed commits logic into cleaner\n2. Introduce hoodie heartbeat to ascertain failed commits\n3. Fix test cases", "committedDate": "2021-02-17T07:50:16Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzYzMzU5NA==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r577633594", "bodyText": "why not final ?", "author": "nsivabalan", "createdAt": "2021-02-17T14:01:33Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieClient.java", "diffHunk": "@@ -48,6 +49,7 @@\n   protected final transient Configuration hadoopConf;\n   protected final HoodieWriteConfig config;\n   protected final String basePath;\n+  protected HoodieHeartbeatClient heartbeatClient;", "originalCommit": "fd7e2e55e94491109046f9eb14386ccb180d27c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzYzNjA4MA==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r577636080", "bodyText": "I see you have a public getter. so, wondering why have it as protected here? bcoz, inherited classes could re-initialize?", "author": "nsivabalan", "createdAt": "2021-02-17T14:04:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzYzMzU5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzY0Mjg0Ng==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r577642846", "bodyText": "@vinothchandar @n3nash : what's a good programming practice here or is it more of developers choice.\nHere I see two approaches\nApproach1: // what's in this patch.\nHeartbeatUtils.abortIfHeartbea.... // this will throw exception if need to be aborted.\nactiveTimeline.saveAsComplete.... // so the assumption is that if no exception is thrown, heart beat is successful sort of \nproceed further...\n\nApproach 2: // make HeartbeatUtils.abortIfHeart.... return a boolean whether abort or not.\nif(HeartbeatUtils.hasHeartBeatExpired ....)\n    // abort steps\n    // may be throw an exception here\nelse \n   activeTimeline.saveAsComplete\n   proceed further \n\n2nd approach is more explicit. do you have any good suggestions on this.", "author": "nsivabalan", "createdAt": "2021-02-17T14:13:25Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -181,7 +171,7 @@ public boolean commitStats(String instantTime, List<HoodieWriteStat> stats, Opti\n     HoodieCommitMetadata metadata = CommitUtils.buildMetadata(stats, partitionToReplaceFileIds, extraMetadata, operationType, config.getSchema(), commitActionType);\n     // Finalize write\n     finalizeWrite(table, instantTime, stats);\n-\n+    HeartbeatUtils.abortIfHeartbeatExpired(instantTime, table, heartbeatClient, config);", "originalCommit": "fd7e2e55e94491109046f9eb14386ccb180d27c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3ODA4MTU1NA==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r578081554", "bodyText": "I want to avoid business logic like approach 2 in the AbstractHoodieWriteClient, this logic is pushed to the method abortIfHeartbeatExpired. Alternatively, the method abortIfHeartbeatExpired build on other public API's to be able to do custom business logic if needed.", "author": "n3nash", "createdAt": "2021-02-18T02:24:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzY0Mjg0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTU4ODE2Mw==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r579588163", "bodyText": "as long as the exception is clear, throwing runtime exceptions is actually better. (source: clean code book)", "author": "vinothchandar", "createdAt": "2021-02-20T03:41:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzY0Mjg0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzY1NDk4NA==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r577654984", "bodyText": "if someone has set rollbackPending = false, prior to this patch, we will not rollback and now we are rolling back right. So is that intentional ? or its a TODO to be fixed in a later patch?", "author": "nsivabalan", "createdAt": "2021-02-17T14:28:22Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -236,17 +226,16 @@ protected void syncTableMetadata() {\n    * Main API to run bootstrap to hudi.\n    */\n   public void bootstrap(Option<Map<String, String>> extraMetadata) {\n-    if (rollbackPending) {\n-      rollBackInflightBootstrap();\n-    }\n+    // TODO : MULTIWRITER -> check if failed bootstrap files can be cleaned later\n     HoodieTable<T, I, K, O> table = getTableAndInitCtx(WriteOperationType.UPSERT, HoodieTimeline.METADATA_BOOTSTRAP_INSTANT_TS);\n+    rollbackFailedBootstrap();", "originalCommit": "fd7e2e55e94491109046f9eb14386ccb180d27c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3ODA4MTE3MQ==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r578081171", "bodyText": "This API is only supported via JavaRDD which is used only at Uber. No side-effect for others.", "author": "n3nash", "createdAt": "2021-02-18T02:23:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzY1NDk4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzY3NjA5OA==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r577676098", "bodyText": "why required to be public?", "author": "nsivabalan", "createdAt": "2021-02-17T14:53:23Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -236,17 +226,16 @@ protected void syncTableMetadata() {\n    * Main API to run bootstrap to hudi.\n    */\n   public void bootstrap(Option<Map<String, String>> extraMetadata) {\n-    if (rollbackPending) {\n-      rollBackInflightBootstrap();\n-    }\n+    // TODO : MULTIWRITER -> check if failed bootstrap files can be cleaned later\n     HoodieTable<T, I, K, O> table = getTableAndInitCtx(WriteOperationType.UPSERT, HoodieTimeline.METADATA_BOOTSTRAP_INSTANT_TS);\n+    rollbackFailedBootstrap();\n     table.bootstrap(context, extraMetadata);\n   }\n \n   /**\n-   * Main API to rollback pending bootstrap.\n+   * Main API to rollback failed bootstrap.\n    */\n-  protected void rollBackInflightBootstrap() {\n+  public void rollbackFailedBootstrap() {", "originalCommit": "fd7e2e55e94491109046f9eb14386ccb180d27c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3ODA3MTI3MQ==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r578071271", "bodyText": "We are deprecating the use pf rollback API since that api currently supports rolling back failed and valid commits. Rollback of valid commits is only supported through restore.", "author": "n3nash", "createdAt": "2021-02-18T01:55:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzY3NjA5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzY3ODkyMg==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r577678922", "bodyText": "should we do this within finally? or is it intentional to do it here.", "author": "nsivabalan", "createdAt": "2021-02-17T14:56:38Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -424,15 +411,15 @@ protected void postCommit(HoodieTable<T, I, K, O> table, HoodieCommitMetadata me\n       HoodieTimelineArchiveLog archiveLog = new HoodieTimelineArchiveLog(config, table);\n       archiveLog.archiveIfRequired(context);\n       autoCleanOnCommit();\n-\n       syncTableMetadata();\n+      this.heartbeatClient.stop(instantTime);", "originalCommit": "fd7e2e55e94491109046f9eb14386ccb180d27c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3ODA3MTM0MA==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r578071340", "bodyText": "Good point, moved it.", "author": "n3nash", "createdAt": "2021-02-18T01:55:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzY3ODkyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzY4NjQ1Mw==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r577686453", "bodyText": "Can you confirm that when some customer moves from eager to lazy in successive launches, this should handle it. ie. lazy code path will clean any leftovers (if any), if in previous launch partial files were cleaned up eagerly, but before cleaning up fully, the process crashed.", "author": "nsivabalan", "createdAt": "2021-02-17T15:05:12Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -598,6 +588,9 @@ public HoodieRestoreMetadata restoreToInstant(final String instantTime) throws H\n   public HoodieCleanMetadata clean(String cleanInstantTime) throws HoodieIOException {\n     LOG.info(\"Cleaner started\");\n     final Timer.Context timerContext = metrics.getCleanCtx();\n+    LOG.info(\"Cleaned failed attempts if any\");\n+    CleanerUtils.rollbackFailedWrites(config.getFailedWritesCleanPolicy(),", "originalCommit": "fd7e2e55e94491109046f9eb14386ccb180d27c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3ODA4MDUyMQ==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r578080521", "bodyText": "Yes, both are handled (going from EAGER to LAZY and back). Also check BaseRollbackActionExecution for more context.", "author": "n3nash", "createdAt": "2021-02-18T02:21:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzY4NjQ1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzY4ODM0OQ==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r577688349", "bodyText": "not part of this patch. but just curious. Why this method(startCommit) in turn does not call into startCommitWithTime() ?", "author": "nsivabalan", "createdAt": "2021-02-17T15:07:25Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -617,11 +610,8 @@ public HoodieCleanMetadata clean() {\n    * Provides a new commit time for a write operation (insert/update/delete).\n    */\n   public String startCommit() {\n-    // NOTE : Need to ensure that rollback is done before a new commit is started\n-    if (rollbackPending) {\n-      // Only rollback pending commit/delta-commits. Do not touch compaction commits\n-      rollbackPendingCommits();\n-    }\n+    CleanerUtils.rollbackFailedWrites(config.getFailedWritesCleanPolicy(),\n+        HoodieTimeline.COMMIT_ACTION, () -> rollbackFailedWrites());", "originalCommit": "fd7e2e55e94491109046f9eb14386ccb180d27c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzY5MDE3NA==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r577690174", "bodyText": "if we do that, we don't need to call CleanerUtils.rollbackFailedWrites at two diff places(613, 643). Guess you might have ran into some issues. Interested to understand the reasoning.", "author": "nsivabalan", "createdAt": "2021-02-17T15:09:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzY4ODM0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3ODA3OTg1Nw==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r578079857", "bodyText": "Let's take this offline. We can probably refactor but not in this PR.", "author": "n3nash", "createdAt": "2021-02-18T02:19:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzY4ODM0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzY5Mjg5OQ==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r577692899", "bodyText": "can we do switch case instead of multiple if else.", "author": "nsivabalan", "createdAt": "2021-02-17T15:12:48Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -749,22 +739,49 @@ private HoodieTimeline getInflightTimelineExcludeCompactionAndClustering(HoodieT\n   }\n \n   /**\n-   * Cleanup all pending commits.\n+   * Rollback all failed writes.\n    */\n-  private void rollbackPendingCommits() {\n+  public Boolean rollbackFailedWrites() {\n     HoodieTable<T, I, K, O> table = createTable(config, hadoopConf);\n-    HoodieTimeline inflightTimeline = getInflightTimelineExcludeCompactionAndClustering(table);\n-    List<String> commits = inflightTimeline.getReverseOrderedInstants().map(HoodieInstant::getTimestamp)\n-        .collect(Collectors.toList());\n-    for (String commit : commits) {\n-      if (HoodieTimeline.compareTimestamps(commit, HoodieTimeline.LESSER_THAN_OR_EQUALS,\n+    List<String> instantsToRollback = getInstantsToRollback(table);\n+    for (String instant : instantsToRollback) {\n+      if (HoodieTimeline.compareTimestamps(instant, HoodieTimeline.LESSER_THAN_OR_EQUALS,\n           HoodieTimeline.FULL_BOOTSTRAP_INSTANT_TS)) {\n-        rollBackInflightBootstrap();\n+        rollbackFailedBootstrap();\n         break;\n       } else {\n-        rollback(commit);\n+        rollback(instant);\n       }\n     }\n+    // Delete any heartbeat files for already rolled back commits\n+    try {\n+      HeartbeatUtils.cleanExpiredHeartbeats(this.heartbeatClient.getExistingHeartbeatInstantFileNames(),\n+          createMetaClient(true), basePath);\n+    } catch (IOException io) {\n+      LOG.error(\"Unable to delete heartbeat files\", io);\n+    }\n+    return true;\n+  }\n+\n+  private List<String> getInstantsToRollback(HoodieTable<T, I, K, O> table) {\n+    if (config.getFailedWritesCleanPolicy().isEager()) {", "originalCommit": "fd7e2e55e94491109046f9eb14386ccb180d27c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3ODIxNjE2OA==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r578216168", "bodyText": "Would like to keep if-else since I don't see the types of policies growing at this point.", "author": "n3nash", "createdAt": "2021-02-18T08:22:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzY5Mjg5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzY5NzQxOQ==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r577697419", "bodyText": "minor: activeHeartbeatInstants", "author": "nsivabalan", "createdAt": "2021-02-17T15:18:00Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/heartbeat/HeartbeatUtils.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.client.heartbeat;\n+\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.table.timeline.HoodieInstant;\n+import org.apache.hudi.common.util.ValidationUtils;\n+import org.apache.hudi.config.HoodieWriteConfig;\n+import org.apache.hudi.exception.HoodieException;\n+import org.apache.hudi.table.HoodieTable;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper class to delete heartbeat for completed or failed instants with expired heartbeats.\n+ */\n+public class HeartbeatUtils {\n+\n+  private static final Logger LOG = LogManager.getLogger(HeartbeatUtils.class);\n+\n+  /**\n+   * Deletes the heartbeat file for the specified instant.\n+   * @param fs\n+   * @param basePath\n+   * @param instantTime\n+   * @return\n+   */\n+  public static boolean deleteHeartbeatFile(FileSystem fs, String basePath, String instantTime) {\n+    boolean deleted = false;\n+    try {\n+      String heartbeatFolderPath = HoodieTableMetaClient.getHeartbeatFolderPath(basePath);\n+      deleted = fs.delete(new Path(heartbeatFolderPath + File.separator + instantTime), false);\n+      if (!deleted) {\n+        LOG.error(\"Failed to delete heartbeat for instant \" + instantTime);\n+      }\n+    } catch (IOException io) {\n+      LOG.error(\"Unable to delete heartbeat for instant \" + instantTime, io);\n+    }\n+    return deleted;\n+  }\n+\n+  /**\n+   * Deletes the heartbeat files for instants with expired heartbeats without any active instant.\n+   * @param existingHeartbeatInstants\n+   * @param metaClient\n+   * @param basePath\n+   */\n+  public static void cleanExpiredHeartbeats(List<String> existingHeartbeatInstants,\n+                                            HoodieTableMetaClient metaClient, String basePath) {\n+    Set<String> heartbeatInstants = metaClient.getActiveTimeline()", "originalCommit": "fd7e2e55e94491109046f9eb14386ccb180d27c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3ODA3OTkyOA==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r578079928", "bodyText": "renamed to nonExpiredHeartbeatInstants since \"active\" can mean differnet", "author": "n3nash", "createdAt": "2021-02-18T02:19:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzY5NzQxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzczNDc4Mg==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r577734782", "bodyText": "do we make use of the return value somewhere? also, I don't see we return false anywhere. exceptions will be thrown anyways. so not sure if the return value is of much value.", "author": "nsivabalan", "createdAt": "2021-02-17T16:01:15Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -749,22 +739,49 @@ private HoodieTimeline getInflightTimelineExcludeCompactionAndClustering(HoodieT\n   }\n \n   /**\n-   * Cleanup all pending commits.\n+   * Rollback all failed writes.\n    */\n-  private void rollbackPendingCommits() {\n+  public Boolean rollbackFailedWrites() {", "originalCommit": "fd7e2e55e94491109046f9eb14386ccb180d27c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3ODA3OTk1MA==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r578079950", "bodyText": "This function is used as a Lambda in a different place and implemented as a Function0. Hence returning boolean here.", "author": "n3nash", "createdAt": "2021-02-18T02:19:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzczNDc4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTU4ODg4MA==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r579588880", "bodyText": "to @nsivabalan 's point. can't the return type be void and use Void for the function.", "author": "vinothchandar", "createdAt": "2021-02-20T03:47:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzczNDc4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzczNTE4Nw==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r577735187", "bodyText": "do we need to move this to finally block ?", "author": "nsivabalan", "createdAt": "2021-02-17T16:01:47Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -912,5 +929,6 @@ public void close() {\n     // Calling this here releases any resources used by your index, so make sure to finish any related operations\n     // before this point\n     this.index.close();\n+    this.heartbeatClient.stop();", "originalCommit": "fd7e2e55e94491109046f9eb14386ccb180d27c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3ODA4MDExMQ==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r578080111", "bodyText": "This is to stop all heartbeats if multiple were started when the client goes out of scope.", "author": "n3nash", "createdAt": "2021-02-18T02:20:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzczNTE4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzczNjUxOQ==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r577736519", "bodyText": "sorry, shouldn't we throw here?", "author": "nsivabalan", "createdAt": "2021-02-17T16:03:31Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/heartbeat/HeartbeatUtils.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.client.heartbeat;\n+\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.table.timeline.HoodieInstant;\n+import org.apache.hudi.common.util.ValidationUtils;\n+import org.apache.hudi.config.HoodieWriteConfig;\n+import org.apache.hudi.exception.HoodieException;\n+import org.apache.hudi.table.HoodieTable;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper class to delete heartbeat for completed or failed instants with expired heartbeats.\n+ */\n+public class HeartbeatUtils {\n+\n+  private static final Logger LOG = LogManager.getLogger(HeartbeatUtils.class);\n+\n+  /**\n+   * Deletes the heartbeat file for the specified instant.\n+   * @param fs\n+   * @param basePath\n+   * @param instantTime\n+   * @return\n+   */\n+  public static boolean deleteHeartbeatFile(FileSystem fs, String basePath, String instantTime) {\n+    boolean deleted = false;\n+    try {\n+      String heartbeatFolderPath = HoodieTableMetaClient.getHeartbeatFolderPath(basePath);\n+      deleted = fs.delete(new Path(heartbeatFolderPath + File.separator + instantTime), false);\n+      if (!deleted) {\n+        LOG.error(\"Failed to delete heartbeat for instant \" + instantTime);\n+      }\n+    } catch (IOException io) {\n+      LOG.error(\"Unable to delete heartbeat for instant \" + instantTime, io);", "originalCommit": "fd7e2e55e94491109046f9eb14386ccb180d27c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3ODA4MDI2MA==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r578080260", "bodyText": "No, not being able to delete heartbeat is benign, should not be a drastic failure for job.", "author": "n3nash", "createdAt": "2021-02-18T02:20:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzczNjUxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzczNzI3Nw==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r577737277", "bodyText": "is this referring to this case.\ndeleting an already deleted or non existent heartbeatFile?", "author": "nsivabalan", "createdAt": "2021-02-17T16:04:27Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/heartbeat/HeartbeatUtils.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.client.heartbeat;\n+\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.table.timeline.HoodieInstant;\n+import org.apache.hudi.common.util.ValidationUtils;\n+import org.apache.hudi.config.HoodieWriteConfig;\n+import org.apache.hudi.exception.HoodieException;\n+import org.apache.hudi.table.HoodieTable;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper class to delete heartbeat for completed or failed instants with expired heartbeats.\n+ */\n+public class HeartbeatUtils {\n+\n+  private static final Logger LOG = LogManager.getLogger(HeartbeatUtils.class);\n+\n+  /**\n+   * Deletes the heartbeat file for the specified instant.\n+   * @param fs\n+   * @param basePath\n+   * @param instantTime\n+   * @return\n+   */\n+  public static boolean deleteHeartbeatFile(FileSystem fs, String basePath, String instantTime) {\n+    boolean deleted = false;\n+    try {\n+      String heartbeatFolderPath = HoodieTableMetaClient.getHeartbeatFolderPath(basePath);\n+      deleted = fs.delete(new Path(heartbeatFolderPath + File.separator + instantTime), false);\n+      if (!deleted) {\n+        LOG.error(\"Failed to delete heartbeat for instant \" + instantTime);", "originalCommit": "fd7e2e55e94491109046f9eb14386ccb180d27c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3ODA4MDI5MA==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r578080290", "bodyText": "No, sometimes the underlying DFS may not delete the file due to an exception. Unfortunately, the delete API does not return an exception. We are logging the error here as opposed to throwing an exception since not being able to delete a heartbeat is benign and repeatable.", "author": "n3nash", "createdAt": "2021-02-18T02:20:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzczNzI3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzczODA1OQ==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r577738059", "bodyText": "java docs", "author": "nsivabalan", "createdAt": "2021-02-17T16:05:29Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/heartbeat/HeartbeatUtils.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.client.heartbeat;\n+\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.table.timeline.HoodieInstant;\n+import org.apache.hudi.common.util.ValidationUtils;\n+import org.apache.hudi.config.HoodieWriteConfig;\n+import org.apache.hudi.exception.HoodieException;\n+import org.apache.hudi.table.HoodieTable;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper class to delete heartbeat for completed or failed instants with expired heartbeats.\n+ */\n+public class HeartbeatUtils {\n+\n+  private static final Logger LOG = LogManager.getLogger(HeartbeatUtils.class);\n+\n+  /**\n+   * Deletes the heartbeat file for the specified instant.\n+   * @param fs\n+   * @param basePath\n+   * @param instantTime\n+   * @return\n+   */\n+  public static boolean deleteHeartbeatFile(FileSystem fs, String basePath, String instantTime) {\n+    boolean deleted = false;\n+    try {\n+      String heartbeatFolderPath = HoodieTableMetaClient.getHeartbeatFolderPath(basePath);\n+      deleted = fs.delete(new Path(heartbeatFolderPath + File.separator + instantTime), false);\n+      if (!deleted) {\n+        LOG.error(\"Failed to delete heartbeat for instant \" + instantTime);\n+      }\n+    } catch (IOException io) {\n+      LOG.error(\"Unable to delete heartbeat for instant \" + instantTime, io);\n+    }\n+    return deleted;\n+  }\n+\n+  /**\n+   * Deletes the heartbeat files for instants with expired heartbeats without any active instant.\n+   * @param existingHeartbeatInstants\n+   * @param metaClient\n+   * @param basePath\n+   */\n+  public static void cleanExpiredHeartbeats(List<String> existingHeartbeatInstants,\n+                                            HoodieTableMetaClient metaClient, String basePath) {\n+    Set<String> heartbeatInstants = metaClient.getActiveTimeline()\n+        .filterCompletedInstants().getInstants().map(HoodieInstant::getTimestamp).collect(Collectors.toSet());\n+    existingHeartbeatInstants.stream().forEach(instant -> {\n+      if (!heartbeatInstants.contains(instant)) {\n+        deleteHeartbeatFile(metaClient.getFs(), basePath, instant);\n+      }\n+    });\n+  }\n+\n+  public static void abortIfHeartbeatExpired(String instantTime, HoodieTable table,", "originalCommit": "fd7e2e55e94491109046f9eb14386ccb180d27c3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Nzc0MDE4Ng==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r577740186", "bodyText": "guess you need to move this comment to 2 lines below", "author": "nsivabalan", "createdAt": "2021-02-17T16:07:57Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/heartbeat/HoodieHeartbeatClient.java", "diffHunk": "@@ -0,0 +1,284 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.client.heartbeat;\n+\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.util.ValidationUtils;\n+import org.apache.hudi.exception.HoodieException;\n+import org.apache.hudi.exception.HoodieHeartbeatException;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.Serializable;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class creates heartbeat for hudi client. This heartbeat is used to ascertain whether the running job is or not.\n+ * NOTE: Due to CPU contention on the driver/client node, the heartbeats could be delayed, hence it's important to set\n+ *       the value high enough to avoid that possibility.\n+ */\n+@NotThreadSafe\n+public class HoodieHeartbeatClient implements AutoCloseable, Serializable {\n+\n+  private static final Logger LOG = LogManager.getLogger(HoodieHeartbeatClient.class);\n+\n+  // path to the heartbeat folder where all writers are updating their heartbeats", "originalCommit": "fd7e2e55e94491109046f9eb14386ccb180d27c3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Nzc0MTg2Ng==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r577741866", "bodyText": "minor. may be we could name \"heartBeatTimeoutInMs\". feel free to take a call.", "author": "nsivabalan", "createdAt": "2021-02-17T16:09:51Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/heartbeat/HoodieHeartbeatClient.java", "diffHunk": "@@ -0,0 +1,284 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.client.heartbeat;\n+\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.util.ValidationUtils;\n+import org.apache.hudi.exception.HoodieException;\n+import org.apache.hudi.exception.HoodieHeartbeatException;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.Serializable;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class creates heartbeat for hudi client. This heartbeat is used to ascertain whether the running job is or not.\n+ * NOTE: Due to CPU contention on the driver/client node, the heartbeats could be delayed, hence it's important to set\n+ *       the value high enough to avoid that possibility.\n+ */\n+@NotThreadSafe\n+public class HoodieHeartbeatClient implements AutoCloseable, Serializable {\n+\n+  private static final Logger LOG = LogManager.getLogger(HoodieHeartbeatClient.class);\n+\n+  // path to the heartbeat folder where all writers are updating their heartbeats\n+  private final transient FileSystem fs;\n+  private final String basePath;\n+  private String heartbeatFolderPath;\n+  // heartbeat interval in millis\n+  private final Long heartbeatIntervalInMs;\n+  private Integer numTolerableHeartbeatMisses;\n+  private final Long maxAllowableHeartbeatIntervalInMs;", "originalCommit": "fd7e2e55e94491109046f9eb14386ccb180d27c3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Nzc3MTk5Nw==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r577771997", "bodyText": "can we revert this.", "author": "nsivabalan", "createdAt": "2021-02-17T16:47:00Z", "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/table/action/clean/SparkCleanActionExecutor.java", "diffHunk": "@@ -131,4 +131,5 @@ public SparkCleanActionExecutor(HoodieSparkEngineContext context,\n           .build();\n     }).collect(Collectors.toList());\n   }\n+", "originalCommit": "fd7e2e55e94491109046f9eb14386ccb180d27c3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Nzc3NjYwNQ==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r577776605", "bodyText": "java docs", "author": "nsivabalan", "createdAt": "2021-02-17T16:52:56Z", "path": "hudi-common/src/main/java/org/apache/hudi/common/util/CleanerUtils.java", "diffHunk": "@@ -112,4 +114,25 @@ public static HoodieCleanerPlan getCleanerPlan(HoodieTableMetaClient metaClient,\n   public static List<HoodieCleanFileInfo> convertToHoodieCleanFileInfoList(List<CleanFileInfo> cleanFileInfoList) {\n     return cleanFileInfoList.stream().map(CleanFileInfo::toHoodieFileCleanInfo).collect(Collectors.toList());\n   }\n+\n+  public static void rollbackFailedWrites(HoodieFailedWritesCleaningPolicy cleaningPolicy, String actionType,", "originalCommit": "fd7e2e55e94491109046f9eb14386ccb180d27c3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Nzc3ODU3Ng==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r577778576", "bodyText": "why keeping this loose. why not just do it only for COMMIT_ACTION only. I see callers only for these 2 action types. For any other action types, shouldn't we throw or leave it a no-op ?", "author": "nsivabalan", "createdAt": "2021-02-17T16:55:16Z", "path": "hudi-common/src/main/java/org/apache/hudi/common/util/CleanerUtils.java", "diffHunk": "@@ -112,4 +114,25 @@ public static HoodieCleanerPlan getCleanerPlan(HoodieTableMetaClient metaClient,\n   public static List<HoodieCleanFileInfo> convertToHoodieCleanFileInfoList(List<CleanFileInfo> cleanFileInfoList) {\n     return cleanFileInfoList.stream().map(CleanFileInfo::toHoodieFileCleanInfo).collect(Collectors.toList());\n   }\n+\n+  public static void rollbackFailedWrites(HoodieFailedWritesCleaningPolicy cleaningPolicy, String actionType,\n+                                          Functions.Function0<Boolean> rollbackFailedWritesFunc) {\n+    switch (actionType) {\n+      case HoodieTimeline.CLEAN_ACTION:\n+        if (cleaningPolicy.isEager()) {\n+          // No need to do any special cleanup for failed operations during clean, compact etc\n+          return;\n+        }\n+        else if (cleaningPolicy.isLazy()) {\n+          rollbackFailedWritesFunc.apply();\n+        }\n+        break;\n+      default:", "originalCommit": "fd7e2e55e94491109046f9eb14386ccb180d27c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Nzc3OTA5Mw==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r577779093", "bodyText": "basically, why we execute lines 131 to 135 for all action types except CLEAN_ACTION", "author": "nsivabalan", "createdAt": "2021-02-17T16:55:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Nzc3ODU3Ng=="}], "type": "inlineReview"}, {"oid": "ce950df02ff5c73937236be1bb04f493727ab3f7", "url": "https://github.com/apache/hudi/commit/ce950df02ff5c73937236be1bb04f493727ab3f7", "message": "[HUDI-1486] Remove inline inflight rollback in hoodie writer\n1. Refactor rollback and move cleaning failed commits logic into cleaner\n2. Introduce hoodie heartbeat to ascertain failed commits\n3. Fix test cases", "committedDate": "2021-02-18T01:56:43Z", "type": "forcePushed"}, {"oid": "ab25ff9deee0ea13df0f24a5e98f2b1c3f7271d1", "url": "https://github.com/apache/hudi/commit/ab25ff9deee0ea13df0f24a5e98f2b1c3f7271d1", "message": "[HUDI-1486] Remove inline inflight rollback in hoodie writer\n1. Refactor rollback and move cleaning failed commits logic into cleaner\n2. Introduce hoodie heartbeat to ascertain failed commits\n3. Fix test cases", "committedDate": "2021-02-18T02:33:22Z", "type": "forcePushed"}, {"oid": "ff7149d58bd0f1a2f4aadf1a3c88ef44f9d48b37", "url": "https://github.com/apache/hudi/commit/ff7149d58bd0f1a2f4aadf1a3c88ef44f9d48b37", "message": "[HUDI-1486] Remove inline inflight rollback in hoodie writer\n1. Refactor rollback and move cleaning failed commits logic into cleaner\n2. Introduce hoodie heartbeat to ascertain failed commits\n3. Fix test cases", "committedDate": "2021-02-18T08:21:11Z", "type": "forcePushed"}, {"oid": "93572f23e81bb9b79284c6e84164101e0a5b942c", "url": "https://github.com/apache/hudi/commit/93572f23e81bb9b79284c6e84164101e0a5b942c", "message": "[HUDI-1486] Remove inline inflight rollback in hoodie writer\n1. Refactor rollback and move cleaning failed commits logic into cleaner\n2. Introduce hoodie heartbeat to ascertain failed commits\n3. Fix test cases", "committedDate": "2021-02-20T03:25:22Z", "type": "commit"}, {"oid": "93572f23e81bb9b79284c6e84164101e0a5b942c", "url": "https://github.com/apache/hudi/commit/93572f23e81bb9b79284c6e84164101e0a5b942c", "message": "[HUDI-1486] Remove inline inflight rollback in hoodie writer\n1. Refactor rollback and move cleaning failed commits logic into cleaner\n2. Introduce hoodie heartbeat to ascertain failed commits\n3. Fix test cases", "committedDate": "2021-02-20T03:25:22Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTU4OTI2Nw==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r579589267", "bodyText": "to our discussion today, can you add a TestHeartbeatUtils in a subsequent PR?", "author": "vinothchandar", "createdAt": "2021-02-20T03:51:13Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/heartbeat/HeartbeatUtils.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.client.heartbeat;\n+\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.table.timeline.HoodieInstant;\n+import org.apache.hudi.common.util.ValidationUtils;\n+import org.apache.hudi.config.HoodieWriteConfig;\n+import org.apache.hudi.exception.HoodieException;\n+import org.apache.hudi.table.HoodieTable;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper class to delete heartbeat for completed or failed instants with expired heartbeats.\n+ */\n+public class HeartbeatUtils {", "originalCommit": "93572f23e81bb9b79284c6e84164101e0a5b942c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTU4OTM5Nw==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r579589397", "bodyText": "this deserves its own Exception class.", "author": "vinothchandar", "createdAt": "2021-02-20T03:52:37Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/heartbeat/HeartbeatUtils.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.client.heartbeat;\n+\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.table.timeline.HoodieInstant;\n+import org.apache.hudi.common.util.ValidationUtils;\n+import org.apache.hudi.config.HoodieWriteConfig;\n+import org.apache.hudi.exception.HoodieException;\n+import org.apache.hudi.table.HoodieTable;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper class to delete heartbeat for completed or failed instants with expired heartbeats.\n+ */\n+public class HeartbeatUtils {\n+\n+  private static final Logger LOG = LogManager.getLogger(HeartbeatUtils.class);\n+\n+  /**\n+   * Deletes the heartbeat file for the specified instant.\n+   * @param fs\n+   * @param basePath\n+   * @param instantTime\n+   * @return\n+   */\n+  public static boolean deleteHeartbeatFile(FileSystem fs, String basePath, String instantTime) {\n+    boolean deleted = false;\n+    try {\n+      String heartbeatFolderPath = HoodieTableMetaClient.getHeartbeatFolderPath(basePath);\n+      deleted = fs.delete(new Path(heartbeatFolderPath + File.separator + instantTime), false);\n+      if (!deleted) {\n+        LOG.error(\"Failed to delete heartbeat for instant \" + instantTime);\n+      }\n+    } catch (IOException io) {\n+      LOG.error(\"Unable to delete heartbeat for instant \" + instantTime, io);\n+    }\n+    return deleted;\n+  }\n+\n+  /**\n+   * Deletes the heartbeat files for instants with expired heartbeats without any active instant.\n+   * @param allExistingHeartbeatInstants\n+   * @param metaClient\n+   * @param basePath\n+   */\n+  public static void cleanExpiredHeartbeats(List<String> allExistingHeartbeatInstants,\n+                                            HoodieTableMetaClient metaClient, String basePath) {\n+    Set<String> nonExpiredHeartbeatInstants = metaClient.getActiveTimeline()\n+        .filterCompletedInstants().getInstants().map(HoodieInstant::getTimestamp).collect(Collectors.toSet());\n+    allExistingHeartbeatInstants.stream().forEach(instant -> {\n+      if (!nonExpiredHeartbeatInstants.contains(instant)) {\n+        deleteHeartbeatFile(metaClient.getFs(), basePath, instant);\n+      }\n+    });\n+  }\n+\n+  /**\n+   * Check if the heartbeat corresponding to instantTime has expired. If yes, abort by throwing an exception.\n+   * @param instantTime\n+   * @param table\n+   * @param heartbeatClient\n+   * @param config\n+   */\n+  public static void abortIfHeartbeatExpired(String instantTime, HoodieTable table,\n+                                             HoodieHeartbeatClient heartbeatClient, HoodieWriteConfig config) {\n+    ValidationUtils.checkArgument(heartbeatClient != null);\n+    try {\n+      if (config.getFailedWritesCleanPolicy().isLazy() && heartbeatClient.isHeartbeatExpired(instantTime)) {\n+        throw new HoodieException(\"Heartbeat for instant \" + instantTime + \" has expired, last heartbeat \"", "originalCommit": "93572f23e81bb9b79284c6e84164101e0a5b942c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTU4OTQyOQ==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r579589429", "bodyText": "Pleas throw HoodieIOException whenever there is an IOException being rethrown", "author": "vinothchandar", "createdAt": "2021-02-20T03:53:02Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/heartbeat/HeartbeatUtils.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.client.heartbeat;\n+\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.table.timeline.HoodieInstant;\n+import org.apache.hudi.common.util.ValidationUtils;\n+import org.apache.hudi.config.HoodieWriteConfig;\n+import org.apache.hudi.exception.HoodieException;\n+import org.apache.hudi.table.HoodieTable;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper class to delete heartbeat for completed or failed instants with expired heartbeats.\n+ */\n+public class HeartbeatUtils {\n+\n+  private static final Logger LOG = LogManager.getLogger(HeartbeatUtils.class);\n+\n+  /**\n+   * Deletes the heartbeat file for the specified instant.\n+   * @param fs\n+   * @param basePath\n+   * @param instantTime\n+   * @return\n+   */\n+  public static boolean deleteHeartbeatFile(FileSystem fs, String basePath, String instantTime) {\n+    boolean deleted = false;\n+    try {\n+      String heartbeatFolderPath = HoodieTableMetaClient.getHeartbeatFolderPath(basePath);\n+      deleted = fs.delete(new Path(heartbeatFolderPath + File.separator + instantTime), false);\n+      if (!deleted) {\n+        LOG.error(\"Failed to delete heartbeat for instant \" + instantTime);\n+      }\n+    } catch (IOException io) {\n+      LOG.error(\"Unable to delete heartbeat for instant \" + instantTime, io);\n+    }\n+    return deleted;\n+  }\n+\n+  /**\n+   * Deletes the heartbeat files for instants with expired heartbeats without any active instant.\n+   * @param allExistingHeartbeatInstants\n+   * @param metaClient\n+   * @param basePath\n+   */\n+  public static void cleanExpiredHeartbeats(List<String> allExistingHeartbeatInstants,\n+                                            HoodieTableMetaClient metaClient, String basePath) {\n+    Set<String> nonExpiredHeartbeatInstants = metaClient.getActiveTimeline()\n+        .filterCompletedInstants().getInstants().map(HoodieInstant::getTimestamp).collect(Collectors.toSet());\n+    allExistingHeartbeatInstants.stream().forEach(instant -> {\n+      if (!nonExpiredHeartbeatInstants.contains(instant)) {\n+        deleteHeartbeatFile(metaClient.getFs(), basePath, instant);\n+      }\n+    });\n+  }\n+\n+  /**\n+   * Check if the heartbeat corresponding to instantTime has expired. If yes, abort by throwing an exception.\n+   * @param instantTime\n+   * @param table\n+   * @param heartbeatClient\n+   * @param config\n+   */\n+  public static void abortIfHeartbeatExpired(String instantTime, HoodieTable table,\n+                                             HoodieHeartbeatClient heartbeatClient, HoodieWriteConfig config) {\n+    ValidationUtils.checkArgument(heartbeatClient != null);\n+    try {\n+      if (config.getFailedWritesCleanPolicy().isLazy() && heartbeatClient.isHeartbeatExpired(instantTime)) {\n+        throw new HoodieException(\"Heartbeat for instant \" + instantTime + \" has expired, last heartbeat \"\n+            + heartbeatClient.getLastHeartbeatTime(table.getMetaClient().getFs(), config.getBasePath(), instantTime));\n+      }\n+    } catch (IOException io) {\n+      throw new HoodieException(\"Unable to read heartbeat\", io);", "originalCommit": "93572f23e81bb9b79284c6e84164101e0a5b942c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTU4OTU2MQ==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r579589561", "bodyText": "invert the condition?  and avoid the return ;", "author": "vinothchandar", "createdAt": "2021-02-20T03:54:36Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/heartbeat/HoodieHeartbeatClient.java", "diffHunk": "@@ -0,0 +1,289 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.client.heartbeat;\n+\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.util.ValidationUtils;\n+import org.apache.hudi.exception.HoodieException;\n+import org.apache.hudi.exception.HoodieHeartbeatException;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.Serializable;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+\n+/**\n+ * This class creates heartbeat for hudi client. This heartbeat is used to ascertain whether the running job is or not.\n+ * NOTE: Due to CPU contention on the driver/client node, the heartbeats could be delayed, hence it's important to set\n+ *       the value high enough to avoid that possibility.\n+ */\n+@NotThreadSafe\n+public class HoodieHeartbeatClient implements AutoCloseable, Serializable {\n+\n+  private static final Logger LOG = LogManager.getLogger(HoodieHeartbeatClient.class);\n+\n+  private final transient FileSystem fs;\n+  private final String basePath;\n+  // path to the heartbeat folder where all writers are updating their heartbeats\n+  private String heartbeatFolderPath;\n+  // heartbeat interval in millis\n+  private final Long heartbeatIntervalInMs;\n+  private Integer numTolerableHeartbeatMisses;\n+  private final Long maxAllowableHeartbeatIntervalInMs;\n+  private Map<String, Heartbeat> instantToHeartbeatMap;\n+\n+  public HoodieHeartbeatClient(FileSystem fs, String basePath, Long heartbeatIntervalInMs,\n+                               Integer numTolerableHeartbeatMisses) {\n+    ValidationUtils.checkArgument(heartbeatIntervalInMs >= 1000, \"Cannot set heartbeat lower than 1 second\");\n+    this.fs = fs;\n+    this.basePath = basePath;\n+    this.heartbeatFolderPath = HoodieTableMetaClient.getHeartbeatFolderPath(basePath);\n+    this.heartbeatIntervalInMs = heartbeatIntervalInMs;\n+    this.numTolerableHeartbeatMisses = numTolerableHeartbeatMisses;\n+    this.maxAllowableHeartbeatIntervalInMs = this.heartbeatIntervalInMs * this.numTolerableHeartbeatMisses;\n+    this.instantToHeartbeatMap = new HashMap<>();\n+  }\n+\n+  class Heartbeat {\n+\n+    private String instantTime;\n+    private Boolean isHeartbeatStarted = false;\n+    private Boolean isHeartbeatStopped = false;\n+    private Long lastHeartbeatTime;\n+    private Integer numHeartbeats = 0;\n+    private Timer timer = new Timer();\n+\n+    public String getInstantTime() {\n+      return instantTime;\n+    }\n+\n+    public void setInstantTime(String instantTime) {\n+      this.instantTime = instantTime;\n+    }\n+\n+    public Boolean isHeartbeatStarted() {\n+      return isHeartbeatStarted;\n+    }\n+\n+    public void setHeartbeatStarted(Boolean heartbeatStarted) {\n+      isHeartbeatStarted = heartbeatStarted;\n+    }\n+\n+    public Boolean isHeartbeatStopped() {\n+      return isHeartbeatStopped;\n+    }\n+\n+    public void setHeartbeatStopped(Boolean heartbeatStopped) {\n+      isHeartbeatStopped = heartbeatStopped;\n+    }\n+\n+    public Long getLastHeartbeatTime() {\n+      return lastHeartbeatTime;\n+    }\n+\n+    public void setLastHeartbeatTime(Long lastHeartbeatTime) {\n+      this.lastHeartbeatTime = lastHeartbeatTime;\n+    }\n+\n+    public Integer getNumHeartbeats() {\n+      return numHeartbeats;\n+    }\n+\n+    public void setNumHeartbeats(Integer numHeartbeats) {\n+      this.numHeartbeats = numHeartbeats;\n+    }\n+\n+    public Timer getTimer() {\n+      return timer;\n+    }\n+\n+    public void setTimer(Timer timer) {\n+      this.timer = timer;\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"Heartbeat{\"\n+              + \"instantTime='\" + instantTime + '\\''\n+              + \", isHeartbeatStarted=\" + isHeartbeatStarted\n+              + \", isHeartbeatStopped=\" + isHeartbeatStopped\n+              + \", lastHeartbeatTime=\" + lastHeartbeatTime\n+              + \", numHeartbeats=\" + numHeartbeats\n+              + \", timer=\" + timer\n+              + '}';\n+    }\n+  }\n+\n+  class HeartbeatTask extends TimerTask {\n+\n+    private final String instantTime;\n+\n+    HeartbeatTask(String instantTime) {\n+      this.instantTime = instantTime;\n+    }\n+\n+    @Override\n+    public void run() {\n+      updateHeartbeat(instantTime);\n+    }\n+  }\n+\n+  /**\n+   * Start a new heartbeat for the specified instant. If there is already one running, this will be a NO_OP\n+   * @param instantTime\n+   */\n+  public void start(String instantTime) {\n+    LOG.info(\"Received request to start heartbeat for instant time \" + instantTime);\n+    Heartbeat heartbeat = instantToHeartbeatMap.get(instantTime);\n+    ValidationUtils.checkArgument(heartbeat == null || !heartbeat.isHeartbeatStopped(), \"Cannot restart a stopped heartbeat for \" + instantTime);\n+    if (heartbeat != null && heartbeat.isHeartbeatStarted()) {", "originalCommit": "93572f23e81bb9b79284c6e84164101e0a5b942c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTU4OTYzMg==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r579589632", "bodyText": "shuld the Heartbeat() constructor do this?", "author": "vinothchandar", "createdAt": "2021-02-20T03:55:12Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/heartbeat/HoodieHeartbeatClient.java", "diffHunk": "@@ -0,0 +1,289 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.client.heartbeat;\n+\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.util.ValidationUtils;\n+import org.apache.hudi.exception.HoodieException;\n+import org.apache.hudi.exception.HoodieHeartbeatException;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.Serializable;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+\n+/**\n+ * This class creates heartbeat for hudi client. This heartbeat is used to ascertain whether the running job is or not.\n+ * NOTE: Due to CPU contention on the driver/client node, the heartbeats could be delayed, hence it's important to set\n+ *       the value high enough to avoid that possibility.\n+ */\n+@NotThreadSafe\n+public class HoodieHeartbeatClient implements AutoCloseable, Serializable {\n+\n+  private static final Logger LOG = LogManager.getLogger(HoodieHeartbeatClient.class);\n+\n+  private final transient FileSystem fs;\n+  private final String basePath;\n+  // path to the heartbeat folder where all writers are updating their heartbeats\n+  private String heartbeatFolderPath;\n+  // heartbeat interval in millis\n+  private final Long heartbeatIntervalInMs;\n+  private Integer numTolerableHeartbeatMisses;\n+  private final Long maxAllowableHeartbeatIntervalInMs;\n+  private Map<String, Heartbeat> instantToHeartbeatMap;\n+\n+  public HoodieHeartbeatClient(FileSystem fs, String basePath, Long heartbeatIntervalInMs,\n+                               Integer numTolerableHeartbeatMisses) {\n+    ValidationUtils.checkArgument(heartbeatIntervalInMs >= 1000, \"Cannot set heartbeat lower than 1 second\");\n+    this.fs = fs;\n+    this.basePath = basePath;\n+    this.heartbeatFolderPath = HoodieTableMetaClient.getHeartbeatFolderPath(basePath);\n+    this.heartbeatIntervalInMs = heartbeatIntervalInMs;\n+    this.numTolerableHeartbeatMisses = numTolerableHeartbeatMisses;\n+    this.maxAllowableHeartbeatIntervalInMs = this.heartbeatIntervalInMs * this.numTolerableHeartbeatMisses;\n+    this.instantToHeartbeatMap = new HashMap<>();\n+  }\n+\n+  class Heartbeat {\n+\n+    private String instantTime;\n+    private Boolean isHeartbeatStarted = false;\n+    private Boolean isHeartbeatStopped = false;\n+    private Long lastHeartbeatTime;\n+    private Integer numHeartbeats = 0;\n+    private Timer timer = new Timer();\n+\n+    public String getInstantTime() {\n+      return instantTime;\n+    }\n+\n+    public void setInstantTime(String instantTime) {\n+      this.instantTime = instantTime;\n+    }\n+\n+    public Boolean isHeartbeatStarted() {\n+      return isHeartbeatStarted;\n+    }\n+\n+    public void setHeartbeatStarted(Boolean heartbeatStarted) {\n+      isHeartbeatStarted = heartbeatStarted;\n+    }\n+\n+    public Boolean isHeartbeatStopped() {\n+      return isHeartbeatStopped;\n+    }\n+\n+    public void setHeartbeatStopped(Boolean heartbeatStopped) {\n+      isHeartbeatStopped = heartbeatStopped;\n+    }\n+\n+    public Long getLastHeartbeatTime() {\n+      return lastHeartbeatTime;\n+    }\n+\n+    public void setLastHeartbeatTime(Long lastHeartbeatTime) {\n+      this.lastHeartbeatTime = lastHeartbeatTime;\n+    }\n+\n+    public Integer getNumHeartbeats() {\n+      return numHeartbeats;\n+    }\n+\n+    public void setNumHeartbeats(Integer numHeartbeats) {\n+      this.numHeartbeats = numHeartbeats;\n+    }\n+\n+    public Timer getTimer() {\n+      return timer;\n+    }\n+\n+    public void setTimer(Timer timer) {\n+      this.timer = timer;\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"Heartbeat{\"\n+              + \"instantTime='\" + instantTime + '\\''\n+              + \", isHeartbeatStarted=\" + isHeartbeatStarted\n+              + \", isHeartbeatStopped=\" + isHeartbeatStopped\n+              + \", lastHeartbeatTime=\" + lastHeartbeatTime\n+              + \", numHeartbeats=\" + numHeartbeats\n+              + \", timer=\" + timer\n+              + '}';\n+    }\n+  }\n+\n+  class HeartbeatTask extends TimerTask {\n+\n+    private final String instantTime;\n+\n+    HeartbeatTask(String instantTime) {\n+      this.instantTime = instantTime;\n+    }\n+\n+    @Override\n+    public void run() {\n+      updateHeartbeat(instantTime);\n+    }\n+  }\n+\n+  /**\n+   * Start a new heartbeat for the specified instant. If there is already one running, this will be a NO_OP\n+   * @param instantTime\n+   */\n+  public void start(String instantTime) {\n+    LOG.info(\"Received request to start heartbeat for instant time \" + instantTime);\n+    Heartbeat heartbeat = instantToHeartbeatMap.get(instantTime);\n+    ValidationUtils.checkArgument(heartbeat == null || !heartbeat.isHeartbeatStopped(), \"Cannot restart a stopped heartbeat for \" + instantTime);\n+    if (heartbeat != null && heartbeat.isHeartbeatStarted()) {\n+      // heartbeat already started, NO_OP\n+      return;\n+    } else {\n+      Heartbeat newHeartbeat = new Heartbeat();\n+      newHeartbeat.setHeartbeatStarted(true);", "originalCommit": "93572f23e81bb9b79284c6e84164101e0a5b942c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTU5MDI5MQ==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r579590291", "bodyText": "can we add a test case for archiving with inflight instants and lazy cleaning?", "author": "vinothchandar", "createdAt": "2021-02-20T04:00:17Z", "path": "hudi-client/hudi-spark-client/src/test/java/org/apache/hudi/io/TestHoodieTimelineArchiveLog.java", "diffHunk": "@@ -408,11 +408,11 @@ public void testArchiveCommitCompactionNoHole() throws IOException {\n     HoodieTable table = HoodieSparkTable.create(cfg, context, metaClient);\n     HoodieTimelineArchiveLog archiveLog = new HoodieTimelineArchiveLog(cfg, table);\n \n-    HoodieTimeline timeline = metaClient.getActiveTimeline().getCommitsAndCompactionTimeline();\n+    HoodieTimeline timeline = metaClient.getActiveTimeline().getWriteTimeline();", "originalCommit": "93572f23e81bb9b79284c6e84164101e0a5b942c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTU5MDM3Nw==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r579590377", "bodyText": "why this change?", "author": "vinothchandar", "createdAt": "2021-02-20T04:01:15Z", "path": "hudi-common/src/main/java/org/apache/hudi/common/table/HoodieTableMetaClient.java", "diffHunk": "@@ -71,10 +72,10 @@\n   private static final long serialVersionUID = 1L;\n   private static final Logger LOG = LogManager.getLogger(HoodieTableMetaClient.class);\n   public static final String METAFOLDER_NAME = \".hoodie\";\n-  public static final String TEMPFOLDER_NAME = METAFOLDER_NAME + Path.SEPARATOR + \".temp\";\n-  public static final String AUXILIARYFOLDER_NAME = METAFOLDER_NAME + Path.SEPARATOR + \".aux\";\n-  public static final String BOOTSTRAP_INDEX_ROOT_FOLDER_PATH = AUXILIARYFOLDER_NAME + Path.SEPARATOR + \".bootstrap\";\n-\n+  public static final String TEMPFOLDER_NAME = METAFOLDER_NAME + File.separator + \".temp\";", "originalCommit": "93572f23e81bb9b79284c6e84164101e0a5b942c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTU5MDUwMA==", "url": "https://github.com/apache/hudi/pull/2359#discussion_r579590500", "bodyText": "test case for this?", "author": "vinothchandar", "createdAt": "2021-02-20T04:02:35Z", "path": "hudi-common/src/main/java/org/apache/hudi/common/table/log/AbstractHoodieLogRecordScanner.java", "diffHunk": "@@ -145,6 +148,14 @@ public void scan() {\n           // hit a block with instant time greater than should be processed, stop processing further\n           break;\n         }\n+        if (r.getBlockType() != CORRUPT_BLOCK && r.getBlockType() != COMMAND_BLOCK) {", "originalCommit": "93572f23e81bb9b79284c6e84164101e0a5b942c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}