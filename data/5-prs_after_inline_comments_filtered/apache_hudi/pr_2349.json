{"pr_number": 2349, "pr_title": "[HUDI-1474] Add additional unit tests to TestHBaseIndex", "pr_createdAt": "2020-12-18T20:03:42Z", "pr_url": "https://github.com/apache/hudi/pull/2349", "timeline": [{"oid": "71df84f851413e1bba166f76f5c1fd621fa8754a", "url": "https://github.com/apache/hudi/commit/71df84f851413e1bba166f76f5c1fd621fa8754a", "message": "[HUDI-1474] Add additional unit tests to TestHBaseIndex", "committedDate": "2020-12-18T19:48:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTAxNzAzMw==", "url": "https://github.com/apache/hudi/pull/2349#discussion_r549017033", "bodyText": "sorry, shouldn't this return 0 since the commit is rolled back? I see a test in this class testSimpleTagLocationAndUpdateWithRollback which tests that rolledback records don't have current location set. am I missing something?", "author": "nsivabalan", "createdAt": "2020-12-26T18:14:50Z", "path": "hudi-client/hudi-spark-client/src/test/java/org/apache/hudi/index/hbase/TestHBaseIndex.java", "diffHunk": "@@ -307,6 +308,125 @@ public void testSimpleTagLocationAndUpdateWithRollback() throws Exception {\n     assertEquals(0, records3.stream().filter(record -> record.getCurrentLocation() != null).count());\n   }\n \n+  /*\n+   * Test case to verify that for taglocation entries present in HBase, if the corresponding commit instant is missing\n+   * in timeline and the commit is not archived, taglocation would reset the current record location to null.\n+   */\n+  @Test\n+  public void testSimpleTagLocationWithInvalidCommit() throws Exception {\n+    // Load to memory\n+    HoodieWriteConfig config = getConfig();\n+    SparkHoodieHBaseIndex index = new SparkHoodieHBaseIndex(config);\n+    SparkRDDWriteClient writeClient = getHoodieWriteClient(config);\n+\n+    String newCommitTime = writeClient.startCommit();\n+    // make a commit with 199 records\n+    JavaRDD<HoodieRecord> writeRecords = generateAndCommitRecords(writeClient, 199);\n+\n+    // make a second commit with a single record\n+    String invalidCommit = writeClient.startCommit();\n+    JavaRDD<HoodieRecord> invalidWriteRecords = generateAndCommitRecords(writeClient, 1, invalidCommit);\n+\n+    // verify location is tagged.\n+    HoodieTable hoodieTable = HoodieSparkTable.create(config, context, metaClient);\n+    JavaRDD<HoodieRecord> javaRDD0 = index.tagLocation(invalidWriteRecords, context(), hoodieTable);\n+    assert (javaRDD0.collect().size() == 1);   // one record present\n+    assert (javaRDD0.filter(HoodieRecord::isCurrentLocationKnown).collect().size() == 1); // it is tagged\n+    assert (javaRDD0.collect().get(0).getCurrentLocation().getInstantTime().equals(invalidCommit));\n+\n+    // rollback the invalid commit, so that hbase will be left with a stale entry.\n+    writeClient.rollback(invalidCommit);\n+\n+    // Now tagLocation for the valid records, hbaseIndex should tag them\n+    metaClient = HoodieTableMetaClient.reload(metaClient);\n+    hoodieTable = HoodieSparkTable.create(config, context, metaClient);\n+    JavaRDD<HoodieRecord> javaRDD1 = index.tagLocation(writeRecords, context(), hoodieTable);\n+    assert (javaRDD1.filter(HoodieRecord::isCurrentLocationKnown).collect().size() == 199);\n+\n+    // tagLocation for the invalid record - commit is not present in timeline due to rollback.\n+    JavaRDD<HoodieRecord> javaRDD2 = index.tagLocation(invalidWriteRecords, context(), hoodieTable);\n+    assert (javaRDD2.collect().size() == 1);   // one record present\n+    assert (javaRDD2.filter(HoodieRecord::isCurrentLocationKnown).collect().size() == 0); // it is not tagged\n+  }\n+\n+  /*\n+   * Test case to verify that taglocation() uses the commit timeline to validate the commitTS stored in hbase.\n+   * When CheckIfValidCommit() in HbaseIndex uses the incorrect timeline filtering, this test would fail.\n+   */\n+  @Test\n+  public void testEnsureTagLocationUsesCommitTimeline() throws Exception {\n+    // Load to memory\n+    HoodieWriteConfig config = getConfig();\n+    SparkHoodieHBaseIndex index = new SparkHoodieHBaseIndex(config);\n+    SparkRDDWriteClient writeClient = getHoodieWriteClient(config);\n+\n+    String commitTime1 = writeClient.startCommit();\n+    JavaRDD<HoodieRecord> writeRecords1 = generateAndCommitRecords(writeClient, 20, commitTime1);\n+\n+    // rollback the commit - leaves a clean file in timeline.\n+    writeClient.rollback(commitTime1);\n+\n+    // create a second commit with 20 records\n+    metaClient = HoodieTableMetaClient.reload(metaClient);\n+    generateAndCommitRecords(writeClient, 20);\n+\n+    // Now tagLocation for the first set of rolledback records, hbaseIndex should tag them\n+    metaClient = HoodieTableMetaClient.reload(metaClient);\n+    HoodieTable hoodieTable = HoodieSparkTable.create(config, context, metaClient);\n+    JavaRDD<HoodieRecord> javaRDD1 = index.tagLocation(writeRecords1, context(), hoodieTable);\n+    assert (javaRDD1.filter(HoodieRecord::isCurrentLocationKnown).collect().size() == 20);", "originalCommit": "71df84f851413e1bba166f76f5c1fd621fa8754a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ1ODk3Ng==", "url": "https://github.com/apache/hudi/pull/2349#discussion_r549458976", "bodyText": "These tests are added mainly to validate checkIfValidCommit() is using the completed commit timeline (older version of this function was not using the timeline with all instants, causing dupes).\nWhen the rolled back commit is older than the earliest available commit, then it is treated as an archived commit.", "author": "nbalajee", "createdAt": "2020-12-28T19:19:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTAxNzAzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUyNTAxNA==", "url": "https://github.com/apache/hudi/pull/2349#discussion_r549525014", "bodyText": "@nsivabalan ^", "author": "n3nash", "createdAt": "2020-12-29T00:15:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTAxNzAzMw=="}], "type": "inlineReview"}]}