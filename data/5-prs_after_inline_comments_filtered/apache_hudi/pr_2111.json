{"pr_number": 2111, "pr_title": "[HUDI-1234] Insert new records to data files without merging for \"Insert\" operation. ", "pr_createdAt": "2020-09-24T13:00:50Z", "pr_url": "https://github.com/apache/hudi/pull/2111", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDkzMDUzMg==", "url": "https://github.com/apache/hudi/pull/2111#discussion_r494930532", "bodyText": "WriteOperationType should be Serializable?", "author": "leesf", "createdAt": "2020-09-25T11:41:06Z", "path": "hudi-client/src/main/java/org/apache/hudi/table/WorkloadProfile.java", "diffHunk": "@@ -54,13 +55,23 @@\n    */\n   private final WorkloadStat globalStat;\n \n+  /**\n+   * Write operation type.\n+   */\n+  private WriteOperationType operationType;", "originalCommit": "7313074623a295060fdba16d3b33f4701cce71b8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDkzODM5Ng==", "url": "https://github.com/apache/hudi/pull/2111#discussion_r494938396", "bodyText": "@leesf Yes, WriteOperationType should be Serializable, forget to check this. I would like to add implements Serializable.", "author": "SteNicholas", "createdAt": "2020-09-25T11:58:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDkzMDUzMg=="}], "type": "inlineReview"}, {"oid": "0a9518660ebed9d38c5bba0cfbf8db38760974d4", "url": "https://github.com/apache/hudi/commit/0a9518660ebed9d38c5bba0cfbf8db38760974d4", "message": "[HUDI-1234] Insert new records regardless of small file when using insert operation", "committedDate": "2020-10-02T05:28:01Z", "type": "forcePushed"}, {"oid": "2703684438f9aeeeaf28c68d0241cc00b98339e6", "url": "https://github.com/apache/hudi/commit/2703684438f9aeeeaf28c68d0241cc00b98339e6", "message": "[HUDI-1234] Insert new records regardless of small file when using insert operation", "committedDate": "2020-10-02T06:20:45Z", "type": "forcePushed"}, {"oid": "ce8a23b2c7402158c3a35ec978465edaefa15cb6", "url": "https://github.com/apache/hudi/commit/ce8a23b2c7402158c3a35ec978465edaefa15cb6", "message": "[HUDI-1234] Insert new records regardless of small file when using insert operation", "committedDate": "2020-10-02T10:42:32Z", "type": "forcePushed"}, {"oid": "7c770ec23c11fccd7298a3e8c9e187297b74f749", "url": "https://github.com/apache/hudi/commit/7c770ec23c11fccd7298a3e8c9e187297b74f749", "message": "[HUDI-1234] Insert new records regardless of small file when using insert operation", "committedDate": "2020-10-02T11:41:04Z", "type": "forcePushed"}, {"oid": "b60451d881e17b64cd5a7db084377b79c4a47d84", "url": "https://github.com/apache/hudi/commit/b60451d881e17b64cd5a7db084377b79c4a47d84", "message": "[HUDI-1234] Insert new records regardless of small file when using insert operation", "committedDate": "2020-10-02T12:44:11Z", "type": "forcePushed"}, {"oid": "3872213002b615be0cacaa2c6221b60e066f4934", "url": "https://github.com/apache/hudi/commit/3872213002b615be0cacaa2c6221b60e066f4934", "message": "[HUDI-1234] Insert new records regardless of small file when using insert operation", "committedDate": "2020-10-02T14:08:17Z", "type": "forcePushed"}, {"oid": "3ce6e021080921c9e01e819b577ab307e7cfee85", "url": "https://github.com/apache/hudi/commit/3ce6e021080921c9e01e819b577ab307e7cfee85", "message": "[HUDI-1234] Insert new records regardless of small file when using insert operation", "committedDate": "2020-10-02T14:51:33Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTY1OTc1MQ==", "url": "https://github.com/apache/hudi/pull/2111#discussion_r501659751", "bodyText": "The method called addUpdateBucket, but the BucketType would be INSERT, it is not very suitable, would we move the logic outside of the method?", "author": "leesf", "createdAt": "2020-10-08T11:53:10Z", "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/table/action/commit/UpsertPartitioner.java", "diffHunk": "@@ -112,16 +115,17 @@ private void assignUpdates(WorkloadProfile profile) {\n     for (Map.Entry<String, WorkloadStat> partitionStat : partitionStatEntries) {\n       for (Map.Entry<String, Pair<String, Long>> updateLocEntry :\n           partitionStat.getValue().getUpdateLocationToCount().entrySet()) {\n-        addUpdateBucket(partitionStat.getKey(), updateLocEntry.getKey());\n+        addUpdateBucket(partitionStat.getKey(), updateLocEntry.getKey(), profile.getOperationType());\n       }\n     }\n   }\n \n-  private int addUpdateBucket(String partitionPath, String fileIdHint) {\n+  private int addUpdateBucket(String partitionPath, String fileIdHint, WriteOperationType operationType) {\n     int bucket = totalBuckets;\n     updateLocationToBucket.put(fileIdHint, bucket);\n     BucketInfo bucketInfo = new BucketInfo();\n-    bucketInfo.bucketType = BucketType.UPDATE;\n+    bucketInfo.bucketType = operationType == null || isChangingRecords(operationType)", "originalCommit": "3ce6e021080921c9e01e819b577ab307e7cfee85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTczNTk3Ng==", "url": "https://github.com/apache/hudi/pull/2111#discussion_r501735976", "bodyText": "@leesf OK, I would move the logic outside of method addUpdateBucket.", "author": "SteNicholas", "createdAt": "2020-10-08T13:49:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTY1OTc1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTY2MTI3NQ==", "url": "https://github.com/apache/hudi/pull/2111#discussion_r501661275", "bodyText": "must remove these asserts?", "author": "leesf", "createdAt": "2020-10-08T11:55:50Z", "path": "hudi-client/hudi-spark-client/src/test/java/org/apache/hudi/client/TestHoodieClientOnCopyOnWriteStorage.java", "diffHunk": "@@ -743,47 +743,37 @@ public void testSmallInsertHandlingForUpserts() throws Exception {\n    */\n   @Test\n   public void testSmallInsertHandlingForInserts() throws Exception {\n-\n     final String testPartitionPath = \"2016/09/26\";\n     final int insertSplitLimit = 100;\n     // setup the small file handling params\n     HoodieWriteConfig config = getSmallInsertWriteConfig(insertSplitLimit); // hold upto 200 records max\n     dataGen = new HoodieTestDataGenerator(new String[] {testPartitionPath});\n     SparkRDDWriteClient client = getHoodieWriteClient(config, false);\n \n-    // Inserts => will write file1\n     String commitTime1 = \"001\";\n     client.startCommitWithTime(commitTime1);\n     List<HoodieRecord> inserts1 = dataGen.generateInserts(commitTime1, insertSplitLimit); // this writes ~500kb\n     Set<String> keys1 = recordsToRecordKeySet(inserts1);\n     JavaRDD<HoodieRecord> insertRecordsRDD1 = jsc.parallelize(inserts1, 1);\n     List<WriteStatus> statuses = client.insert(insertRecordsRDD1, commitTime1).collect();\n-\n     assertNoWriteErrors(statuses);\n-    assertPartitionMetadata(new String[] {testPartitionPath}, fs);\n-\n+    assertPartitionMetadata(new String[]{testPartitionPath}, fs);\n     assertEquals(1, statuses.size(), \"Just 1 file needs to be added.\");\n-    String file1 = statuses.get(0).getFileId();\n     assertEquals(100,\n         readRowKeysFromParquet(hadoopConf, new Path(basePath, statuses.get(0).getStat().getPath()))\n             .size(), \"file should contain 100 records\");\n \n-    // Second, set of Inserts should just expand file1\n     String commitTime2 = \"002\";\n     client.startCommitWithTime(commitTime2);\n     List<HoodieRecord> inserts2 = dataGen.generateInserts(commitTime2, 40);\n     Set<String> keys2 = recordsToRecordKeySet(inserts2);\n     JavaRDD<HoodieRecord> insertRecordsRDD2 = jsc.parallelize(inserts2, 1);\n     statuses = client.insert(insertRecordsRDD2, commitTime2).collect();\n     assertNoWriteErrors(statuses);\n-\n-    assertEquals(1, statuses.size(), \"Just 1 file needs to be updated.\");\n-    assertEquals(file1, statuses.get(0).getFileId(), \"Existing file should be expanded\");\n-    assertEquals(commitTime1, statuses.get(0).getStat().getPrevCommit(), \"Existing file should be expanded\");", "originalCommit": "3ce6e021080921c9e01e819b577ab307e7cfee85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTcyODk0NQ==", "url": "https://github.com/apache/hudi/pull/2111#discussion_r501728945", "bodyText": "@leesf These asserts makes no sense, because statuses.get(0).getFileId() could be file1+\"-0\" and statuses.get(0).getStat().getPrevCommit() could be null.", "author": "SteNicholas", "createdAt": "2020-10-08T13:40:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTY2MTI3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTY3NDUxNg==", "url": "https://github.com/apache/hudi/pull/2111#discussion_r501674516", "bodyText": "100 should be passed via method parameter.", "author": "leesf", "createdAt": "2020-10-08T12:18:30Z", "path": "hudi-client/hudi-spark-client/src/test/java/org/apache/hudi/table/action/commit/TestUpsertPartitioner.java", "diffHunk": "@@ -90,14 +88,33 @@ private UpsertPartitioner getUpsertPartitioner(int smallFileSize, int numInserts\n     List<HoodieRecord> records = new ArrayList<>();\n     records.addAll(insertRecords);\n     records.addAll(updateRecords);\n-    WorkloadProfile profile = new WorkloadProfile(buildProfile(jsc.parallelize(records)));\n+    WorkloadProfile profile = new WorkloadProfile(buildProfile(jsc.parallelize(records)), WriteOperationType.UPSERT);\n     UpsertPartitioner partitioner = new UpsertPartitioner(profile, context, table, config);\n     assertEquals(0, partitioner.getPartition(\n         new Tuple2<>(updateRecords.get(0).getKey(), Option.ofNullable(updateRecords.get(0).getCurrentLocation()))),\n         \"Update record should have gone to the 1 update partition\");\n     return partitioner;\n   }\n \n+  private UpsertPartitioner getInsertPartitioner(int smallFileSize, int numInserts, int fileSize, String testPartitionPath,\n+      boolean autoSplitInserts) throws Exception {\n+    HoodieWriteConfig config = makeHoodieClientConfigBuilder()\n+            .withCompactionConfig(HoodieCompactionConfig.newBuilder().compactionSmallFileSize(smallFileSize)\n+                    .insertSplitSize(100).autoTuneInsertSplits(autoSplitInserts).build())", "originalCommit": "3ce6e021080921c9e01e819b577ab307e7cfee85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTczOTIxMA==", "url": "https://github.com/apache/hudi/pull/2111#discussion_r501739210", "bodyText": "@leesf  I don't think 100 should be passed via method parameter. You could refer to the method getUpsertPartitioner.", "author": "SteNicholas", "createdAt": "2020-10-08T13:53:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTY3NDUxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTY3NTE2NQ==", "url": "https://github.com/apache/hudi/pull/2111#discussion_r501675165", "bodyText": "it would be better if you would describe how to get 3 expected partitions.", "author": "leesf", "createdAt": "2020-10-08T12:19:45Z", "path": "hudi-client/hudi-spark-client/src/test/java/org/apache/hudi/table/action/commit/TestUpsertPartitioner.java", "diffHunk": "@@ -286,8 +303,48 @@ public void testUpsertPartitionerWithSmallInsertHandling() throws Exception {\n         \"Bucket 3 is INSERT\");\n     assertEquals(4, insertBuckets.size(), \"Total of 4 insert buckets\");\n \n-    weights = new Double[] { 0.08, 0.31, 0.31, 0.31};\n-    cumulativeWeights = new Double[] { 0.08, 0.39, 0.69, 1.0};\n+    weights = new Double[] {0.08, 0.31, 0.31, 0.31};\n+    cumulativeWeights = new Double[] {0.08, 0.39, 0.69, 1.0};\n+    assertInsertBuckets(weights, cumulativeWeights, insertBuckets);\n+  }\n+\n+  @Test\n+  public void testInsertPartitionerWithSmallInsertHandling() throws Exception {\n+    final String testPartitionPath = \"2016/09/26\";\n+    // Inserts  .. Check updates go together & inserts subsplit, after expanding smallest file\n+    UpsertPartitioner partitioner = getInsertPartitioner(1000 * 1024, 400, 800 * 1024, testPartitionPath, false);\n+    List<InsertBucketCumulativeWeightPair> insertBuckets = partitioner.getInsertBuckets(testPartitionPath);\n+\n+    assertEquals(3, partitioner.numPartitions(), \"Should have 3 partitions\");", "originalCommit": "3ce6e021080921c9e01e819b577ab307e7cfee85", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTY3NTUwMA==", "url": "https://github.com/apache/hudi/pull/2111#discussion_r501675500", "bodyText": "ditto", "author": "leesf", "createdAt": "2020-10-08T12:20:16Z", "path": "hudi-client/hudi-spark-client/src/test/java/org/apache/hudi/table/action/commit/TestUpsertPartitioner.java", "diffHunk": "@@ -286,8 +303,48 @@ public void testUpsertPartitionerWithSmallInsertHandling() throws Exception {\n         \"Bucket 3 is INSERT\");\n     assertEquals(4, insertBuckets.size(), \"Total of 4 insert buckets\");\n \n-    weights = new Double[] { 0.08, 0.31, 0.31, 0.31};\n-    cumulativeWeights = new Double[] { 0.08, 0.39, 0.69, 1.0};\n+    weights = new Double[] {0.08, 0.31, 0.31, 0.31};\n+    cumulativeWeights = new Double[] {0.08, 0.39, 0.69, 1.0};\n+    assertInsertBuckets(weights, cumulativeWeights, insertBuckets);\n+  }\n+\n+  @Test\n+  public void testInsertPartitionerWithSmallInsertHandling() throws Exception {\n+    final String testPartitionPath = \"2016/09/26\";\n+    // Inserts  .. Check updates go together & inserts subsplit, after expanding smallest file\n+    UpsertPartitioner partitioner = getInsertPartitioner(1000 * 1024, 400, 800 * 1024, testPartitionPath, false);\n+    List<InsertBucketCumulativeWeightPair> insertBuckets = partitioner.getInsertBuckets(testPartitionPath);\n+\n+    assertEquals(3, partitioner.numPartitions(), \"Should have 3 partitions\");\n+    assertEquals(BucketType.INSERT, partitioner.getBucketInfo(0).bucketType,\n+        \"Bucket 0 is INSERT\");\n+    assertEquals(BucketType.INSERT, partitioner.getBucketInfo(1).bucketType,\n+        \"Bucket 1 is INSERT\");\n+    assertEquals(BucketType.INSERT, partitioner.getBucketInfo(2).bucketType,\n+        \"Bucket 2 is INSERT\");\n+    assertEquals(3, insertBuckets.size(), \"Total of 3 insert buckets\");\n+\n+    Double[] weights = {0.5, 0.25, 0.25};\n+    Double[] cumulativeWeights = {0.5, 0.75, 1.0};\n+    assertInsertBuckets(weights, cumulativeWeights, insertBuckets);\n+\n+    // Now with insert split size auto tuned\n+    partitioner = getInsertPartitioner(1000 * 1024, 2400, 800 * 1024, testPartitionPath, true);\n+    insertBuckets = partitioner.getInsertBuckets(testPartitionPath);\n+\n+    assertEquals(4, partitioner.numPartitions(), \"Should have 4 partitions\");", "originalCommit": "3ce6e021080921c9e01e819b577ab307e7cfee85", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTY3NjQ2OA==", "url": "https://github.com/apache/hudi/pull/2111#discussion_r501676468", "bodyText": "would you please use foreach assertion instead of listing all buckets?", "author": "leesf", "createdAt": "2020-10-08T12:21:52Z", "path": "hudi-client/hudi-spark-client/src/test/java/org/apache/hudi/table/action/commit/TestUpsertPartitioner.java", "diffHunk": "@@ -286,8 +303,48 @@ public void testUpsertPartitionerWithSmallInsertHandling() throws Exception {\n         \"Bucket 3 is INSERT\");\n     assertEquals(4, insertBuckets.size(), \"Total of 4 insert buckets\");\n \n-    weights = new Double[] { 0.08, 0.31, 0.31, 0.31};\n-    cumulativeWeights = new Double[] { 0.08, 0.39, 0.69, 1.0};\n+    weights = new Double[] {0.08, 0.31, 0.31, 0.31};\n+    cumulativeWeights = new Double[] {0.08, 0.39, 0.69, 1.0};\n+    assertInsertBuckets(weights, cumulativeWeights, insertBuckets);\n+  }\n+\n+  @Test\n+  public void testInsertPartitionerWithSmallInsertHandling() throws Exception {\n+    final String testPartitionPath = \"2016/09/26\";\n+    // Inserts  .. Check updates go together & inserts subsplit, after expanding smallest file\n+    UpsertPartitioner partitioner = getInsertPartitioner(1000 * 1024, 400, 800 * 1024, testPartitionPath, false);\n+    List<InsertBucketCumulativeWeightPair> insertBuckets = partitioner.getInsertBuckets(testPartitionPath);\n+\n+    assertEquals(3, partitioner.numPartitions(), \"Should have 3 partitions\");\n+    assertEquals(BucketType.INSERT, partitioner.getBucketInfo(0).bucketType,\n+        \"Bucket 0 is INSERT\");\n+    assertEquals(BucketType.INSERT, partitioner.getBucketInfo(1).bucketType,\n+        \"Bucket 1 is INSERT\");\n+    assertEquals(BucketType.INSERT, partitioner.getBucketInfo(2).bucketType,\n+        \"Bucket 2 is INSERT\");", "originalCommit": "3ce6e021080921c9e01e819b577ab307e7cfee85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTcyNjc0NA==", "url": "https://github.com/apache/hudi/pull/2111#discussion_r501726744", "bodyText": "@leesf Yes, I would like to use foreach assertion instead.", "author": "SteNicholas", "createdAt": "2020-10-08T13:37:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTY3NjQ2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTY3NjU3OA==", "url": "https://github.com/apache/hudi/pull/2111#discussion_r501676578", "bodyText": "ditto", "author": "leesf", "createdAt": "2020-10-08T12:22:04Z", "path": "hudi-client/hudi-spark-client/src/test/java/org/apache/hudi/table/action/commit/TestUpsertPartitioner.java", "diffHunk": "@@ -286,8 +303,48 @@ public void testUpsertPartitionerWithSmallInsertHandling() throws Exception {\n         \"Bucket 3 is INSERT\");\n     assertEquals(4, insertBuckets.size(), \"Total of 4 insert buckets\");\n \n-    weights = new Double[] { 0.08, 0.31, 0.31, 0.31};\n-    cumulativeWeights = new Double[] { 0.08, 0.39, 0.69, 1.0};\n+    weights = new Double[] {0.08, 0.31, 0.31, 0.31};\n+    cumulativeWeights = new Double[] {0.08, 0.39, 0.69, 1.0};\n+    assertInsertBuckets(weights, cumulativeWeights, insertBuckets);\n+  }\n+\n+  @Test\n+  public void testInsertPartitionerWithSmallInsertHandling() throws Exception {\n+    final String testPartitionPath = \"2016/09/26\";\n+    // Inserts  .. Check updates go together & inserts subsplit, after expanding smallest file\n+    UpsertPartitioner partitioner = getInsertPartitioner(1000 * 1024, 400, 800 * 1024, testPartitionPath, false);\n+    List<InsertBucketCumulativeWeightPair> insertBuckets = partitioner.getInsertBuckets(testPartitionPath);\n+\n+    assertEquals(3, partitioner.numPartitions(), \"Should have 3 partitions\");\n+    assertEquals(BucketType.INSERT, partitioner.getBucketInfo(0).bucketType,\n+        \"Bucket 0 is INSERT\");\n+    assertEquals(BucketType.INSERT, partitioner.getBucketInfo(1).bucketType,\n+        \"Bucket 1 is INSERT\");\n+    assertEquals(BucketType.INSERT, partitioner.getBucketInfo(2).bucketType,\n+        \"Bucket 2 is INSERT\");\n+    assertEquals(3, insertBuckets.size(), \"Total of 3 insert buckets\");\n+\n+    Double[] weights = {0.5, 0.25, 0.25};\n+    Double[] cumulativeWeights = {0.5, 0.75, 1.0};\n+    assertInsertBuckets(weights, cumulativeWeights, insertBuckets);\n+\n+    // Now with insert split size auto tuned\n+    partitioner = getInsertPartitioner(1000 * 1024, 2400, 800 * 1024, testPartitionPath, true);\n+    insertBuckets = partitioner.getInsertBuckets(testPartitionPath);\n+\n+    assertEquals(4, partitioner.numPartitions(), \"Should have 4 partitions\");\n+    assertEquals(BucketType.INSERT, partitioner.getBucketInfo(0).bucketType,\n+        \"Bucket 0 is INSERT\");\n+    assertEquals(BucketType.INSERT, partitioner.getBucketInfo(1).bucketType,\n+        \"Bucket 1 is INSERT\");\n+    assertEquals(BucketType.INSERT, partitioner.getBucketInfo(2).bucketType,\n+        \"Bucket 2 is INSERT\");\n+    assertEquals(BucketType.INSERT, partitioner.getBucketInfo(3).bucketType,\n+        \"Bucket 3 is INSERT\");", "originalCommit": "3ce6e021080921c9e01e819b577ab307e7cfee85", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTY3NzAyNg==", "url": "https://github.com/apache/hudi/pull/2111#discussion_r501677026", "bodyText": "would you please explain why change from 200 to 100 ?", "author": "leesf", "createdAt": "2020-10-08T12:22:49Z", "path": "hudi-integ-test/src/test/java/org/apache/hudi/integ/command/ITTestHoodieSyncCommand.java", "diffHunk": "@@ -52,7 +52,7 @@ public void testValidateSync() throws Exception {\n         executeCommandStringInDocker(ADHOC_1_CONTAINER, HUDI_CLI_TOOL + \" --cmdfile \" + SYNC_VALIDATE_COMMANDS, true);\n \n     String expected = String.format(\"Count difference now is (count(%s) - count(%s) == %d. Catch up count is %d\",\n-        hiveTableName, hiveTableName2, 100, 200);\n+        hiveTableName, hiveTableName2, 100, 100);", "originalCommit": "3ce6e021080921c9e01e819b577ab307e7cfee85", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "cd244bb28bb6826f09a612f4d75ab081d8cb749a", "url": "https://github.com/apache/hudi/commit/cd244bb28bb6826f09a612f4d75ab081d8cb749a", "message": "[HUDI-1234] Insert new records regardless of small file when using insert operation", "committedDate": "2020-10-15T07:39:50Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU0MTQ0Ng==", "url": "https://github.com/apache/hudi/pull/2111#discussion_r505541446", "bodyText": "would also merge\nfor (int b = 0; b < insertBuckets; b++) {\n            bucketNumbers.add(totalBuckets);\n            recordsPerBucket.add(totalUnassignedInserts / insertBuckets);\n            BucketInfo bucketInfo = new BucketInfo();\n            bucketInfo.bucketType = BucketType.INSERT;\n            bucketInfo.partitionPath = partitionPath;\n            bucketInfo.fileIdPrefix = FSUtils.createNewFileIdPfx();\n            bucketInfoMap.put(totalBuckets, bucketInfo);\n            totalBuckets++;\n          }\n\nthe logic to the method?", "author": "leesf", "createdAt": "2020-10-15T13:28:17Z", "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/table/action/commit/UpsertPartitioner.java", "diffHunk": "@@ -129,6 +131,18 @@ private int addUpdateBucket(String partitionPath, String fileIdHint) {\n     return bucket;\n   }\n \n+  private int addInsertBucket(String partitionPath, String fileIdHint) {\n+    int bucket = totalBuckets;\n+    updateLocationToBucket.put(fileIdHint, bucket);\n+    BucketInfo bucketInfo = new BucketInfo();\n+    bucketInfo.bucketType = BucketType.INSERT;\n+    bucketInfo.fileIdPrefix = fileIdHint;\n+    bucketInfo.partitionPath = partitionPath;\n+    bucketInfoMap.put(totalBuckets, bucketInfo);\n+    totalBuckets++;\n+    return bucket;", "originalCommit": "cd244bb28bb6826f09a612f4d75ab081d8cb749a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU0MjgzMg==", "url": "https://github.com/apache/hudi/pull/2111#discussion_r505542832", "bodyText": "maybe we would create a new FileID instead of using exist small file id @bvaradar WDYT?", "author": "leesf", "createdAt": "2020-10-15T13:30:09Z", "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/table/action/commit/UpsertPartitioner.java", "diffHunk": "@@ -160,11 +174,15 @@ private void assignInserts(WorkloadProfile profile, HoodieEngineContext context)\n           if (recordsToAppend > 0 && totalUnassignedInserts > 0) {\n             // create a new bucket or re-use an existing bucket\n             int bucket;\n-            if (updateLocationToBucket.containsKey(smallFile.location.getFileId())) {\n+            // insert new records regardless of small file when using insert operation\n+            if (isChangingRecords(profile.getOperationType())\n+                    && updateLocationToBucket.containsKey(smallFile.location.getFileId())) {\n               bucket = updateLocationToBucket.get(smallFile.location.getFileId());\n               LOG.info(\"Assigning \" + recordsToAppend + \" inserts to existing update bucket \" + bucket);\n             } else {\n-              bucket = addUpdateBucket(partitionPath, smallFile.location.getFileId());\n+              bucket = profile.getOperationType() == null || isChangingRecords(profile.getOperationType())\n+                      ? addUpdateBucket(partitionPath, smallFile.location.getFileId())\n+                      : addInsertBucket(partitionPath, smallFile.location.getFileId());", "originalCommit": "cd244bb28bb6826f09a612f4d75ab081d8cb749a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY4MjI1OQ==", "url": "https://github.com/apache/hudi/pull/2111#discussion_r505682259", "bodyText": "@bvaradar @vinothchandar  WDYT? I thought using existing small file id would be better.", "author": "SteNicholas", "createdAt": "2020-10-15T16:33:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU0MjgzMg=="}], "type": "inlineReview"}, {"oid": "f0a56e1337899a4f0ceeec8dc6998f88eb5adcfd", "url": "https://github.com/apache/hudi/commit/f0a56e1337899a4f0ceeec8dc6998f88eb5adcfd", "message": "[HUDI-1234] Insert new records regardless of small file when using insert operation", "committedDate": "2020-10-16T06:31:49Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTAwMjUxOA==", "url": "https://github.com/apache/hudi/pull/2111#discussion_r509002518", "bodyText": "would really prefer a non -static import here. makes it easier on the eyes.", "author": "vinothchandar", "createdAt": "2020-10-21T05:41:35Z", "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/table/action/commit/UpsertPartitioner.java", "diffHunk": "@@ -54,6 +54,8 @@\n \n import scala.Tuple2;\n \n+import static org.apache.hudi.common.model.WriteOperationType.isChangingRecords;", "originalCommit": "f0a56e1337899a4f0ceeec8dc6998f88eb5adcfd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0081537f85abb1654119bcaef6cb782441e9c600", "url": "https://github.com/apache/hudi/commit/0081537f85abb1654119bcaef6cb782441e9c600", "message": "Adding a config flag to route inserts to new files ignoring small file handling", "committedDate": "2021-01-07T04:35:03Z", "type": "forcePushed"}, {"oid": "3ee7854700476cf5185be5c765ec582e4f14955f", "url": "https://github.com/apache/hudi/commit/3ee7854700476cf5185be5c765ec582e4f14955f", "message": "Adding a config flag to route inserts to new files ignoring small file handling", "committedDate": "2021-01-07T04:38:31Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzEwNDcxMg==", "url": "https://github.com/apache/hudi/pull/2111#discussion_r553104712", "bodyText": "I don't want to add config.isRouteInsertsToNewFiles() to all 3 if else conditions and hence, have added a bigger if else for older and new code path.", "author": "nsivabalan", "createdAt": "2021-01-07T04:37:59Z", "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/table/action/commit/UpsertPartitioner.java", "diffHunk": "@@ -191,14 +201,29 @@ private void assignInserts(WorkloadProfile profile, HoodieEngineContext context)\n           long recordsToAppend = Math.min((config.getParquetMaxFileSize() - smallFile.sizeBytes) / averageRecordSize,\n               totalUnassignedInserts);\n           if (recordsToAppend > 0 && totalUnassignedInserts > 0) {\n-            // create a new bucket or re-use an existing bucket\n             int bucket;\n-            if (updateLocationToBucket.containsKey(smallFile.location.getFileId())) {\n-              bucket = updateLocationToBucket.get(smallFile.location.getFileId());\n-              LOG.info(\"Assigning \" + recordsToAppend + \" inserts to existing update bucket \" + bucket);\n-            } else {\n-              bucket = addUpdateBucket(partitionPath, smallFile.location.getFileId());\n-              LOG.info(\"Assigning \" + recordsToAppend + \" inserts to new update bucket \" + bucket);\n+            if (config.isRouteInsertsToNewFiles()) {\n+              // if insert operation, route inserts to new files regardless of small file handling.", "originalCommit": "0081537f85abb1654119bcaef6cb782441e9c600", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "dbb835a799e16212c9051571c1a9ee1ef080bcf4", "url": "https://github.com/apache/hudi/commit/dbb835a799e16212c9051571c1a9ee1ef080bcf4", "message": "Adding a config flag to route inserts to new files ignoring small file handling", "committedDate": "2021-01-07T13:47:47Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzcxMzE5Mg==", "url": "https://github.com/apache/hudi/pull/2111#discussion_r553713192", "bodyText": "rename hoodie.merge.allow.duplicate.inserts", "author": "vinothchandar", "createdAt": "2021-01-08T02:55:37Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/config/HoodieWriteConfig.java", "diffHunk": "@@ -133,6 +133,10 @@\n   private static final String MERGE_DATA_VALIDATION_CHECK_ENABLED = \"hoodie.merge.data.validation.enabled\";\n   private static final String DEFAULT_MERGE_DATA_VALIDATION_CHECK_ENABLED = \"false\";\n \n+  // Routes inserts to new files ignoring small file handling\n+  private static final String ROUTE_INSERTS_TO_NEW_FILES = \"hoodie.route.inserts.to.new.files\";", "originalCommit": "dbb835a799e16212c9051571c1a9ee1ef080bcf4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODQ4NjQ3Mg==", "url": "https://github.com/apache/hudi/pull/2111#discussion_r558486472", "bodyText": "@vinothchandar : Have added this new handle and tested that it works as expected. But would like to call out that any new records would just get appended. For instance, if records to be deleted (with \"_hoodie_is_deleted\" set to true) are sent via \"Insert\" operation, this handle will just append and may not recognize the deleted records as we don't do any combineAndUpdate.", "author": "nsivabalan", "createdAt": "2021-01-15T18:17:06Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/io/storage/HoodieConcatHandle.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.io.storage;\n+\n+import org.apache.hudi.client.common.TaskContextSupplier;\n+import org.apache.hudi.common.model.HoodieBaseFile;\n+import org.apache.hudi.common.model.HoodieRecord;\n+import org.apache.hudi.common.model.HoodieRecordPayload;\n+import org.apache.hudi.config.HoodieWriteConfig;\n+import org.apache.hudi.exception.HoodieUpsertException;\n+import org.apache.hudi.io.HoodieMergeHandle;\n+import org.apache.hudi.table.HoodieTable;\n+\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+/**\n+ * Handle to concatenate new records to old records w/o any merging. If Operation is set to Inserts, and if {{@link HoodieWriteConfig#isRouteInsertsToNewFiles()}}\n+ * is set, this handle will be used instead of {@link HoodieMergeHandle}\n+ */\n+public class HoodieConcatHandle<T extends HoodieRecordPayload, I, K, O> extends HoodieMergeHandle<T, I, K, O> {\n+\n+  private static final Logger LOG = LogManager.getLogger(HoodieConcatHandle.class);\n+\n+  public HoodieConcatHandle(HoodieWriteConfig config, String instantTime, HoodieTable hoodieTable, Iterator recordItr,\n+      String partitionPath, String fileId, TaskContextSupplier taskContextSupplier) {\n+    super(config, instantTime, hoodieTable, recordItr, partitionPath, fileId, taskContextSupplier);\n+  }\n+\n+  public HoodieConcatHandle(HoodieWriteConfig config, String instantTime, HoodieTable hoodieTable, Map keyToNewRecords, String partitionPath, String fileId,\n+      HoodieBaseFile dataFileToBeMerged, TaskContextSupplier taskContextSupplier) {\n+    super(config, instantTime, hoodieTable, keyToNewRecords, partitionPath, fileId, dataFileToBeMerged, taskContextSupplier);\n+  }\n+\n+  /**\n+   * Write old record as is w/o merging with incoming record.\n+   */\n+  @Override\n+  public void write(GenericRecord oldRecord) {", "originalCommit": "36d316b4406ce344d92d75b856f2d936160f3393", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0b016c69f860f8cdf2bafca24ce5e3f70b84032e", "url": "https://github.com/apache/hudi/commit/0b016c69f860f8cdf2bafca24ce5e3f70b84032e", "message": "Minor fixes", "committedDate": "2021-01-19T05:47:52Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDEwNTE5Nw==", "url": "https://github.com/apache/hudi/pull/2111#discussion_r560105197", "bodyText": "IMO, this could be defined as boolean type.", "author": "SteNicholas", "createdAt": "2021-01-19T11:22:08Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/config/HoodieWriteConfig.java", "diffHunk": "@@ -133,6 +133,10 @@\n   private static final String MERGE_DATA_VALIDATION_CHECK_ENABLED = \"hoodie.merge.data.validation.enabled\";\n   private static final String DEFAULT_MERGE_DATA_VALIDATION_CHECK_ENABLED = \"false\";\n \n+  // Concats inserts to data files without merging\n+  private static final String MERGE_ALLOW_DUPLICATE_INSERTS = \"hoodie.merge.allow.duplicate.inserts\";\n+  private static final String DEFAULT_MERGE_ALLOW_DUPLICATE_INSERTS = \"false\";", "originalCommit": "0b016c69f860f8cdf2bafca24ce5e3f70b84032e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDY4MTUwNg==", "url": "https://github.com/apache/hudi/pull/2111#discussion_r560681506", "bodyText": "just following the convention we have been using in hoodie so far.", "author": "nsivabalan", "createdAt": "2021-01-20T05:05:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDEwNTE5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDU3ODM2Nw==", "url": "https://github.com/apache/hudi/pull/2111#discussion_r560578367", "bodyText": "allowDuplicateInserts()", "author": "vinothchandar", "createdAt": "2021-01-19T23:50:10Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/config/HoodieWriteConfig.java", "diffHunk": "@@ -330,6 +334,10 @@ public boolean isMergeDataValidationCheckEnabled() {\n     return Boolean.parseBoolean(props.getProperty(MERGE_DATA_VALIDATION_CHECK_ENABLED));\n   }\n \n+  public boolean isMergeAllowDuplicateInserts() {", "originalCommit": "0b016c69f860f8cdf2bafca24ce5e3f70b84032e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDY4MTAxNg==", "url": "https://github.com/apache/hudi/pull/2111#discussion_r560681016", "bodyText": "@vinothchandar : does the config name looks ok? somehow I feel it does not exactly convey the actual intent, but talks about the effect. For instance,\nsomething like \"hoodie.concat.inserts.without.merge.on.insert\" or \"hoodie.concat.records.on.insert\" etc.", "author": "nsivabalan", "createdAt": "2021-01-20T05:03:25Z", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/config/HoodieWriteConfig.java", "diffHunk": "@@ -133,6 +133,10 @@\n   private static final String MERGE_DATA_VALIDATION_CHECK_ENABLED = \"hoodie.merge.data.validation.enabled\";\n   private static final String DEFAULT_MERGE_DATA_VALIDATION_CHECK_ENABLED = \"false\";\n \n+  // Concats inserts to data files without merging\n+  private static final String MERGE_ALLOW_DUPLICATE_INSERTS = \"hoodie.merge.allow.duplicate.inserts\";", "originalCommit": "0b016c69f860f8cdf2bafca24ce5e3f70b84032e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDY4NjYyOQ==", "url": "https://github.com/apache/hudi/pull/2111#discussion_r560686629", "bodyText": "first one is too long IMO. I think hoodie.merge.allow.duplicates.on.insert is a better name (I added the .on) given it explains to the user what the impact is. Whether we concat or prepend in implementation, thats not very useful for the end user", "author": "vinothchandar", "createdAt": "2021-01-20T05:22:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDY4MTAxNg=="}], "type": "inlineReview"}, {"oid": "f7d52e77c6cd6972db9e85dabbc2143591b774a1", "url": "https://github.com/apache/hudi/commit/f7d52e77c6cd6972db9e85dabbc2143591b774a1", "message": "[HUDI-1234] Insert new records regardless of small file when using insert operation", "committedDate": "2021-01-20T15:00:45Z", "type": "commit"}, {"oid": "7f742ee0bfdbbbd6bfb6a5e1bb52bfec11f6a753", "url": "https://github.com/apache/hudi/commit/7f742ee0bfdbbbd6bfb6a5e1bb52bfec11f6a753", "message": "[HUDI-1234] Insert new records regardless of small file when using insert operation", "committedDate": "2021-01-20T15:01:33Z", "type": "commit"}, {"oid": "dde11ef3cbd27bda17c2ce1f680a110bfcf6e5c1", "url": "https://github.com/apache/hudi/commit/dde11ef3cbd27bda17c2ce1f680a110bfcf6e5c1", "message": "[HUDI-1234] Insert new records regardless of small file when using insert operation", "committedDate": "2021-01-20T15:01:37Z", "type": "commit"}, {"oid": "c466a22d69088104c17e30e68a4b8f824d5dfbf5", "url": "https://github.com/apache/hudi/commit/c466a22d69088104c17e30e68a4b8f824d5dfbf5", "message": "Adding a config flag to route inserts to new files ignoring small file handling", "committedDate": "2021-01-20T15:02:42Z", "type": "commit"}, {"oid": "591e97e2837e0a15709edce85df31b09fa2b1586", "url": "https://github.com/apache/hudi/commit/591e97e2837e0a15709edce85df31b09fa2b1586", "message": "Adding HoodieConcatHandle to insert records w/o merging with \"Insert\" operation", "committedDate": "2021-01-20T15:02:46Z", "type": "commit"}, {"oid": "39123ef582ab8c8d388d7f3b714188310de68fc1", "url": "https://github.com/apache/hudi/commit/39123ef582ab8c8d388d7f3b714188310de68fc1", "message": "Reverting some of previous changes", "committedDate": "2021-01-20T15:03:12Z", "type": "commit"}, {"oid": "09fcaa1fd9f21c1573e8450b7e28e21acfd05273", "url": "https://github.com/apache/hudi/commit/09fcaa1fd9f21c1573e8450b7e28e21acfd05273", "message": "Fixing tests in TestHoodieClientOnCopyOnWriteStorage.java", "committedDate": "2021-01-20T15:03:16Z", "type": "commit"}, {"oid": "4c5d84cc5c0472c6d9001502d768ed1f16372296", "url": "https://github.com/apache/hudi/commit/4c5d84cc5c0472c6d9001502d768ed1f16372296", "message": "Minor fixes", "committedDate": "2021-01-20T15:03:17Z", "type": "commit"}, {"oid": "1eec9b1cdb71e451fef5f19dc4f2d0692e773443", "url": "https://github.com/apache/hudi/commit/1eec9b1cdb71e451fef5f19dc4f2d0692e773443", "message": "Addressing comments", "committedDate": "2021-01-20T15:03:18Z", "type": "commit"}, {"oid": "23c6ce3f35da17c65465b786845a800856cd1c9f", "url": "https://github.com/apache/hudi/commit/23c6ce3f35da17c65465b786845a800856cd1c9f", "message": "Fetching and rebasing with master", "committedDate": "2021-01-20T15:17:11Z", "type": "forcePushed"}, {"oid": "287a016ff22b8d555b8a6ea39135003417b93d7c", "url": "https://github.com/apache/hudi/commit/287a016ff22b8d555b8a6ea39135003417b93d7c", "message": "Fetching and rebasing with master", "committedDate": "2021-01-20T15:21:24Z", "type": "commit"}, {"oid": "287a016ff22b8d555b8a6ea39135003417b93d7c", "url": "https://github.com/apache/hudi/commit/287a016ff22b8d555b8a6ea39135003417b93d7c", "message": "Fetching and rebasing with master", "committedDate": "2021-01-20T15:21:24Z", "type": "forcePushed"}]}