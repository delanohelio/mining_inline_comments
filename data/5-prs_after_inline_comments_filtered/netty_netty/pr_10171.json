{"pr_number": 10171, "pr_title": "Stop sending DNS queries if promise is cancelled", "pr_createdAt": "2020-04-07T09:09:04Z", "pr_url": "https://github.com/netty/netty/pull/10171", "timeline": [{"oid": "61de103075758e9ca4b03feb346948bdc724448f", "url": "https://github.com/netty/netty/commit/61de103075758e9ca4b03feb346948bdc724448f", "message": "Stop sending DNS queries if promise is cancelled\nMotivation:\nA user might want to cancel DNS resolution when it takes too long.\nCurrently, there's no way to cancel the internal DNS queries especially when there's a lot of search domains.\n\nModification:\n- Stop sending a DNS query if the original `Promise`, which was passed calling `resolve()`, is canceled.\n\nResult:\n- You can now stop sending DNS queries by cancelling the `Promise`.", "committedDate": "2020-04-07T08:44:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY4NzA3Ng==", "url": "https://github.com/netty/netty/pull/10171#discussion_r404687076", "bodyText": "@minwoox I wonder if a better approach would be to ensure we propagate cancellation by attaching a FutureListener to original promise and call promise.cancel(...) if needed. WDYT ?", "author": "normanmaurer", "createdAt": "2020-04-07T09:59:38Z", "path": "resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "diffHunk": "@@ -352,7 +354,7 @@ private void query(final DnsServerAddressStream nameServerAddrStream,\n                        final Promise<List<T>> promise,\n                        final Throwable cause) {\n         if (completeEarly || nameServerAddrStreamIndex >= nameServerAddrStream.size() ||\n-                allowedQueries == 0 || promise.isCancelled()) {\n+                allowedQueries == 0 || originalPromise.isCancelled() || promise.isCancelled()) {", "originalCommit": "61de103075758e9ca4b03feb346948bdc724448f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY5NTUyOQ==", "url": "https://github.com/netty/netty/pull/10171#discussion_r404695529", "bodyText": "Ah, that was actually my first thought but it makes a little complicated in some cases. For example:\n1. Call resolve(String inetHost, Promise<T> promise); // The promise here is the original promise\n2. Call doResolveUncached() in DnsNameResolver. // A new allPromise is newly created and passed.\n3. Call DnsAddressResolveContext.resolve(promise). // The promise here is the allPromise which created in #2.\n4. In resolve() searchDomainPromise is created and used.\n\nIn this flow, there are three Promises involved (originalPromise, allPromise and searchDomainPromise), so we have to add two listerers.\nSo that's the reason that I have chosen this way, but if you think adding listerner is better, then I can change it. \ud83d\ude04", "author": "minwoox", "createdAt": "2020-04-07T10:13:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY4NzA3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY5ODg5MQ==", "url": "https://github.com/netty/netty/pull/10171#discussion_r404698891", "bodyText": "@minwoox makes sense.. was just an idea but I guess what you did here is good enough and is less complex.", "author": "normanmaurer", "createdAt": "2020-04-07T10:19:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY4NzA3Ng=="}], "type": "inlineReview"}]}