{"pr_number": 10542, "pr_title": "Further reduce io_uring syscalls", "pr_createdAt": "2020-09-07T19:39:41Z", "pr_url": "https://github.com/netty/netty/pull/10542", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE0MjU1MA==", "url": "https://github.com/netty/netty/pull/10542#discussion_r485142550", "bodyText": "It looks correct that we are getting the completion queue tail with volatile, but previously the volatile load was on the head. Can we have a double-check and justify to ourselves that this is right?", "author": "chrisvest", "createdAt": "2020-09-08T19:19:13Z", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringCompletionQueue.java", "diffHunk": "@@ -51,37 +54,44 @@\n     this.ringSize = ringSize;\n     this.ringAddress = ringAddress;\n     this.ringFd = ringFd;\n+\n+    this.ringMask = PlatformDependent.getInt(kringMaskAddress);\n+    this.ringHead = PlatformDependent.getInt(kHeadAddress);\n+  }\n+\n+  public boolean hasCompletions() {\n+      return ringHead != PlatformDependent.getIntVolatile(kTailAddress);\n   }\n \n   public int process(IOUringCompletionQueueCallback callback) {\n+      int tail = PlatformDependent.getIntVolatile(kTailAddress);", "originalCommit": "8f2cf9e78e4bc6c2c1354e63ac46bb3f7f27c9ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3OTg2OA==", "url": "https://github.com/netty/netty/pull/10542#discussion_r485179868", "bodyText": "I think this is right... agree it would be good for others to confirm :)", "author": "njhill", "createdAt": "2020-09-08T20:32:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE0MjU1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTMyNzY5Nw==", "url": "https://github.com/netty/netty/pull/10542#discussion_r485327697", "bodyText": "I dont think you that we need  head double check, as io_uring wouldn't never change the cqe head", "author": "1Jo1", "createdAt": "2020-09-09T04:18:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE0MjU1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM3NjQ0OA==", "url": "https://github.com/netty/netty/pull/10542#discussion_r485376448", "bodyText": "@nitsanw can you have a look as well to ensure that we are ok in terms with memory barriers etc ?", "author": "normanmaurer", "createdAt": "2020-09-09T06:48:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE0MjU1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE0NDQ3MA==", "url": "https://github.com/netty/netty/pull/10542#discussion_r485144470", "bodyText": "This can also be modelled as a do-while.", "author": "chrisvest", "createdAt": "2020-09-08T19:22:40Z", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringEventLoop.java", "diffHunk": "@@ -110,9 +110,29 @@ protected void run() {\n \n         // Lets add the eventfd related events before starting to do any real work.\n         submissionQueue.addPollIn(eventfd.intValue());\n-        submissionQueue.submit();\n \n         for (;;) {\n+            for (;;) {\n+                // avoid blocking for as long as possible\n+                completionQueue.process(this);\n+                boolean ranTasks = runAllTasks();\n+                if (!ranTasks) {\n+                    break;\n+                }\n+            }", "originalCommit": "8f2cf9e78e4bc6c2c1354e63ac46bb3f7f27c9ad", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "08cfa017a767924500c700bf16c120155673d054", "url": "https://github.com/netty/netty/commit/08cfa017a767924500c700bf16c120155673d054", "message": "Change to do/while per @chrisvest's suggestion", "committedDate": "2020-09-08T20:32:59Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM3OTUzMg==", "url": "https://github.com/netty/netty/pull/10542#discussion_r485379532", "bodyText": "I would make this volatile for clarity", "author": "nitsanw", "createdAt": "2020-09-09T06:54:45Z", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringCompletionQueue.java", "diffHunk": "@@ -51,37 +54,36 @@\n     this.ringSize = ringSize;\n     this.ringAddress = ringAddress;\n     this.ringFd = ringFd;\n+\n+    this.ringMask = PlatformDependent.getInt(kringMaskAddress);\n+    this.ringHead = PlatformDependent.getInt(kHeadAddress);", "originalCommit": "08cfa017a767924500c700bf16c120155673d054", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQxODAyOA==", "url": "https://github.com/netty/netty/pull/10542#discussion_r485418028", "bodyText": "do you mean both variables should be volatile or getIntVolatile, however I would prefer getIntVolatile :)", "author": "1Jo1", "createdAt": "2020-09-09T08:06:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM3OTUzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4MDEyOA==", "url": "https://github.com/netty/netty/pull/10542#discussion_r485380128", "bodyText": "I assume cqe is entryAddress?", "author": "nitsanw", "createdAt": "2020-09-09T06:55:59Z", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringCompletionQueue.java", "diffHunk": "@@ -51,37 +54,36 @@\n     this.ringSize = ringSize;\n     this.ringAddress = ringAddress;\n     this.ringFd = ringFd;\n+\n+    this.ringMask = PlatformDependent.getInt(kringMaskAddress);\n+    this.ringHead = PlatformDependent.getInt(kHeadAddress);\n+  }\n+\n+  public boolean hasCompletions() {\n+      return ringHead != PlatformDependent.getIntVolatile(kTailAddress);\n   }\n \n   public int process(IOUringCompletionQueueCallback callback) {\n+      int tail = PlatformDependent.getIntVolatile(kTailAddress);\n       int i = 0;\n-      for (;;) {\n-          long head = toUnsignedLong(PlatformDependent.getIntVolatile(kHeadAddress));\n-          if (head != toUnsignedLong(PlatformDependent.getInt(kTailAddress))) {\n-              long index = head & toUnsignedLong(PlatformDependent.getInt(kringMaskAddress));\n-              long cqe = index * CQE_SIZE + completionQueueArrayAddress;\n-\n-              long udata = PlatformDependent.getLong(cqe + CQE_USER_DATA_FIELD);\n-              int res = PlatformDependent.getInt(cqe + CQE_RES_FIELD);\n-              long flags = toUnsignedLong(PlatformDependent.getInt(cqe + CQE_FLAGS_FIELD));\n-\n-              //Ensure that the kernel only sees the new value of the head index after the CQEs have been read.\n-              PlatformDependent.putIntOrdered(kHeadAddress, (int) (head + 1));\n-\n-              int fd = (int) (udata >> 32);\n-              int opMask = (int) udata;\n-              short op = (short) (opMask >> 16);\n-              short mask = (short) opMask;\n-\n-              i++;\n-              if (!callback.handle(fd, res, flags, op, mask)) {\n-                  break;\n-              }\n-          } else {\n-              if (i == 0) {\n-                  return -1;\n-              }\n-              return i;\n+      while (ringHead != tail) {\n+          long cqe = (ringHead & ringMask) * CQE_SIZE + completionQueueArrayAddress;", "originalCommit": "08cfa017a767924500c700bf16c120155673d054", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQxOTEyMw==", "url": "https://github.com/netty/netty/pull/10542#discussion_r485419123", "bodyText": "exactly", "author": "1Jo1", "createdAt": "2020-09-09T08:07:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4MDEyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4MTU4Ng==", "url": "https://github.com/netty/netty/pull/10542#discussion_r485381586", "bodyText": "The completion queue is single consumer I assume, so this is fine. I would still split this into 2 lines.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      PlatformDependent.putIntOrdered(kHeadAddress, ++ringHead);\n          \n          \n            \n                      ringHead++;\n          \n          \n            \n                      PlatformDependent.putIntOrdered(kHeadAddress, ringHead);", "author": "nitsanw", "createdAt": "2020-09-09T06:59:09Z", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringCompletionQueue.java", "diffHunk": "@@ -51,37 +54,36 @@\n     this.ringSize = ringSize;\n     this.ringAddress = ringAddress;\n     this.ringFd = ringFd;\n+\n+    this.ringMask = PlatformDependent.getInt(kringMaskAddress);\n+    this.ringHead = PlatformDependent.getInt(kHeadAddress);\n+  }\n+\n+  public boolean hasCompletions() {\n+      return ringHead != PlatformDependent.getIntVolatile(kTailAddress);\n   }\n \n   public int process(IOUringCompletionQueueCallback callback) {\n+      int tail = PlatformDependent.getIntVolatile(kTailAddress);\n       int i = 0;\n-      for (;;) {\n-          long head = toUnsignedLong(PlatformDependent.getIntVolatile(kHeadAddress));\n-          if (head != toUnsignedLong(PlatformDependent.getInt(kTailAddress))) {\n-              long index = head & toUnsignedLong(PlatformDependent.getInt(kringMaskAddress));\n-              long cqe = index * CQE_SIZE + completionQueueArrayAddress;\n-\n-              long udata = PlatformDependent.getLong(cqe + CQE_USER_DATA_FIELD);\n-              int res = PlatformDependent.getInt(cqe + CQE_RES_FIELD);\n-              long flags = toUnsignedLong(PlatformDependent.getInt(cqe + CQE_FLAGS_FIELD));\n-\n-              //Ensure that the kernel only sees the new value of the head index after the CQEs have been read.\n-              PlatformDependent.putIntOrdered(kHeadAddress, (int) (head + 1));\n-\n-              int fd = (int) (udata >> 32);\n-              int opMask = (int) udata;\n-              short op = (short) (opMask >> 16);\n-              short mask = (short) opMask;\n-\n-              i++;\n-              if (!callback.handle(fd, res, flags, op, mask)) {\n-                  break;\n-              }\n-          } else {\n-              if (i == 0) {\n-                  return -1;\n-              }\n-              return i;\n+      while (ringHead != tail) {\n+          long cqe = (ringHead & ringMask) * CQE_SIZE + completionQueueArrayAddress;\n+\n+          long udata = PlatformDependent.getLong(cqe + CQE_USER_DATA_FIELD);\n+          int res = PlatformDependent.getInt(cqe + CQE_RES_FIELD);\n+          int flags = PlatformDependent.getInt(cqe + CQE_FLAGS_FIELD);\n+\n+          //Ensure that the kernel only sees the new value of the head index after the CQEs have been read.\n+          PlatformDependent.putIntOrdered(kHeadAddress, ++ringHead);", "originalCommit": "08cfa017a767924500c700bf16c120155673d054", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4MjU2NA==", "url": "https://github.com/netty/netty/pull/10542#discussion_r485382564", "bodyText": "This is not present in the new code?", "author": "nitsanw", "createdAt": "2020-09-09T07:01:10Z", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringCompletionQueue.java", "diffHunk": "@@ -51,37 +54,36 @@\n     this.ringSize = ringSize;\n     this.ringAddress = ringAddress;\n     this.ringFd = ringFd;\n+\n+    this.ringMask = PlatformDependent.getInt(kringMaskAddress);\n+    this.ringHead = PlatformDependent.getInt(kHeadAddress);\n+  }\n+\n+  public boolean hasCompletions() {\n+      return ringHead != PlatformDependent.getIntVolatile(kTailAddress);\n   }\n \n   public int process(IOUringCompletionQueueCallback callback) {\n+      int tail = PlatformDependent.getIntVolatile(kTailAddress);\n       int i = 0;\n-      for (;;) {\n-          long head = toUnsignedLong(PlatformDependent.getIntVolatile(kHeadAddress));\n-          if (head != toUnsignedLong(PlatformDependent.getInt(kTailAddress))) {\n-              long index = head & toUnsignedLong(PlatformDependent.getInt(kringMaskAddress));\n-              long cqe = index * CQE_SIZE + completionQueueArrayAddress;\n-\n-              long udata = PlatformDependent.getLong(cqe + CQE_USER_DATA_FIELD);\n-              int res = PlatformDependent.getInt(cqe + CQE_RES_FIELD);\n-              long flags = toUnsignedLong(PlatformDependent.getInt(cqe + CQE_FLAGS_FIELD));\n-\n-              //Ensure that the kernel only sees the new value of the head index after the CQEs have been read.\n-              PlatformDependent.putIntOrdered(kHeadAddress, (int) (head + 1));\n-\n-              int fd = (int) (udata >> 32);\n-              int opMask = (int) udata;\n-              short op = (short) (opMask >> 16);\n-              short mask = (short) opMask;\n-\n-              i++;\n-              if (!callback.handle(fd, res, flags, op, mask)) {\n-                  break;\n-              }\n-          } else {\n-              if (i == 0) {\n-                  return -1;", "originalCommit": "08cfa017a767924500c700bf16c120155673d054", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTcxMjQ5OA==", "url": "https://github.com/netty/netty/pull/10542#discussion_r485712498", "bodyText": "I think it was redundant. The method returns count of completions processed, so didn't see a reason for converting 0 to -1, maybe @1Jo1 can confirm?", "author": "njhill", "createdAt": "2020-09-09T15:41:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4MjU2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA2MDkwMA==", "url": "https://github.com/netty/netty/pull/10542#discussion_r486060900", "bodyText": "@njhill yeah it is redundant, it looks fine to me, just replace -1 to 0 :)", "author": "1Jo1", "createdAt": "2020-09-10T04:48:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4MjU2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4MzczMw==", "url": "https://github.com/netty/netty/pull/10542#discussion_r485383733", "bodyText": "should be &&?", "author": "nitsanw", "createdAt": "2020-09-09T07:03:46Z", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringEventLoop.java", "diffHunk": "@@ -120,10 +120,31 @@ protected void run() {\n \n         // Lets add the eventfd related events before starting to do any real work.\n         submissionQueue.addPollIn(eventfd.intValue());\n-        submissionQueue.submit();\n \n         for (;;) {\n             logger.trace(\"Run IOUringEventLoop {}\", this.toString());\n+            // avoid blocking for as long as possible - loop until two consecutive \"empty\" results\n+            boolean maybeMoreTasks = true;\n+            boolean maybeMoreIo;\n+            do {\n+                maybeMoreIo = completionQueue.process(this) != 0;\n+                if (!maybeMoreIo & !maybeMoreTasks) {", "originalCommit": "08cfa017a767924500c700bf16c120155673d054", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTcyMTU5MA==", "url": "https://github.com/netty/netty/pull/10542#discussion_r485721590", "bodyText": "@nitsanw this is probably more in your wheelhouse but my understanding was that non-short-circuit variants of boolean ops are preferable when the operands are trivial (eliminates a branch I think)? I've seen it used in other places but agree it looks odd.", "author": "njhill", "createdAt": "2020-09-09T15:54:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4MzczMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4NTM5Mw==", "url": "https://github.com/netty/netty/pull/10542#discussion_r485385393", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        boolean maybeMoreIo;\n          \n          \n            \n                        do {\n          \n          \n            \n                            maybeMoreIo = completionQueue.process(this) != 0;\n          \n          \n            \n                            if (!maybeMoreIo & !maybeMoreTasks) {\n          \n          \n            \n                                break; // no need to check tasks again here\n          \n          \n            \n                            }\n          \n          \n            \n                            maybeMoreTasks = runAllTasks();\n          \n          \n            \n                            try {\n          \n          \n            \n                                if (isShuttingDown()) {\n          \n          \n            \n                                    closeAll();\n          \n          \n            \n                                    if (confirmShutdown()) {\n          \n          \n            \n                                        return;\n          \n          \n            \n                                    }\n          \n          \n            \n                                }\n          \n          \n            \n                            } catch (Throwable t) {\n          \n          \n            \n                                logger.info(\"Exception error: {}\", t);\n          \n          \n            \n                            }\n          \n          \n            \n                        } while (maybeMoreIo | maybeMoreTasks);\n          \n          \n            \n                        boolean maybeMoreIo = completionQueue.process(this) != 0;\n          \n          \n            \n                        while (maybeMoreIo || maybeMoreTasks) {\n          \n          \n            \n                            maybeMoreTasks = runAllTasks();\n          \n          \n            \n                            try {\n          \n          \n            \n                                if (isShuttingDown()) {\n          \n          \n            \n                                    closeAll();\n          \n          \n            \n                                    if (confirmShutdown()) {\n          \n          \n            \n                                        return;\n          \n          \n            \n                                    }\n          \n          \n            \n                                }\n          \n          \n            \n                            } catch (Throwable t) {\n          \n          \n            \n                                logger.info(\"Exception error: {}\", t);\n          \n          \n            \n                            }\n          \n          \n            \n                            maybeMoreIo = completionQueue.process(this) != 0;\n          \n          \n            \n                        }", "author": "nitsanw", "createdAt": "2020-09-09T07:07:25Z", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringEventLoop.java", "diffHunk": "@@ -120,10 +120,31 @@ protected void run() {\n \n         // Lets add the eventfd related events before starting to do any real work.\n         submissionQueue.addPollIn(eventfd.intValue());\n-        submissionQueue.submit();\n \n         for (;;) {\n             logger.trace(\"Run IOUringEventLoop {}\", this.toString());\n+            // avoid blocking for as long as possible - loop until two consecutive \"empty\" results\n+            boolean maybeMoreTasks = true;\n+            boolean maybeMoreIo;\n+            do {\n+                maybeMoreIo = completionQueue.process(this) != 0;\n+                if (!maybeMoreIo & !maybeMoreTasks) {\n+                    break; // no need to check tasks again here\n+                }\n+                maybeMoreTasks = runAllTasks();\n+                try {\n+                    if (isShuttingDown()) {\n+                        closeAll();\n+                        if (confirmShutdown()) {\n+                            return;\n+                        }\n+                    }\n+                } catch (Throwable t) {\n+                    logger.info(\"Exception error: {}\", t);\n+                }\n+            } while (maybeMoreIo | maybeMoreTasks);", "originalCommit": "08cfa017a767924500c700bf16c120155673d054", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQyNDY2Nw==", "url": "https://github.com/netty/netty/pull/10542#discussion_r485424667", "bodyText": "@nitsanw I like your suggested change \ud83d\udc4d I think it's cleaner to avoid break's", "author": "1Jo1", "createdAt": "2020-09-09T08:17:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4NTM5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU2NDgwOA==", "url": "https://github.com/netty/netty/pull/10542#discussion_r485564808", "bodyText": "Yeah, the do-while only made sense when we had the simple loop previously.", "author": "chrisvest", "createdAt": "2020-09-09T12:17:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4NTM5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTgwNDczOA==", "url": "https://github.com/netty/netty/pull/10542#discussion_r485804738", "bodyText": "I was aiming to allow breaking out after either the tasks run or the io run, since there could be a redundant attempt otherwise (for example some tasks run, then CQ is empty, then no tasks are run - the proposed version will attempt to process the CQ again unnecessarily). In practice I guess it wouldn't make noticeable difference, so maybe fine to stick with slightly simpler logic?", "author": "njhill", "createdAt": "2020-09-09T17:46:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4NTM5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTgyMDA5NA==", "url": "https://github.com/netty/netty/pull/10542#discussion_r485820094", "bodyText": "let's follow \"KISS\" rule here and keep it simple", "author": "normanmaurer", "createdAt": "2020-09-09T18:14:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4NTM5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4MTUxNA==", "url": "https://github.com/netty/netty/pull/10542#discussion_r485381514", "bodyText": "we should submit here, at least at the end of the loop", "author": "1Jo1", "createdAt": "2020-09-09T06:59:01Z", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringEventLoop.java", "diffHunk": "@@ -153,29 +173,7 @@ protected void run() {\n                         pendingWakeup = true;\n                     }\n                 }\n-            }\n-\n-            completionQueue.process(this);\n-\n-            // Always call runAllTasks() as it will also fetch the scheduled tasks that are ready.\n-            runAllTasks();\n-\n-            // Once we submitted its safe to clear the iovArray and so be able to re-use it.\n-            submissionQueue.submit();\n-            clearUsedIovArrays();\n-            try {\n-                if (isShuttingDown()) {\n-                    closeAll();\n-                    // Once we submitted its safe to clear the iovArray and so be able to re-use it.\n-                    submissionQueue.submit();\n-                    clearUsedIovArrays();\n-\n-                    if (confirmShutdown()) {\n-                        break;\n-                    }\n-                }\n-            } catch (Throwable t) {\n-                logger.info(\"Exception error: {}\", t);\n+                clearUsedIovArrays();", "originalCommit": "08cfa017a767924500c700bf16c120155673d054", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQwMDM4Mw==", "url": "https://github.com/netty/netty/pull/10542#discussion_r485400383", "bodyText": "WDYT?", "author": "1Jo1", "createdAt": "2020-09-09T07:36:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4MTUxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg4NjYzNQ==", "url": "https://github.com/netty/netty/pull/10542#discussion_r485886635", "bodyText": "@1Jo1 but this is right after submitting (the submitAndWait() above)? Unless we skipped it because more work was found, but that's just an edge case (we would have remained in the inner loop anyhow).\nLooking again I just realized that there is a (pre-existing) bug here though... the hasTasks() check should be inside the try/finally, will fix that.", "author": "njhill", "createdAt": "2020-09-09T19:59:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4MTUxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA2MjcyOQ==", "url": "https://github.com/netty/netty/pull/10542#discussion_r486062729", "bodyText": "@1Jo1 but this is right after submitting (the submitAndWait() above)? Unless we skipped it because more work was found, but that's just an edge case (we would have remained in the inner loop anyhow).\n\nexactly that's what I thought :)", "author": "1Jo1", "createdAt": "2020-09-10T04:54:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4MTUxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU2MzIxNA==", "url": "https://github.com/netty/netty/pull/10542#discussion_r485563214", "bodyText": "Checkstyle seems to complain about trailing whitespace on this line.", "author": "chrisvest", "createdAt": "2020-09-09T12:14:26Z", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringCompletionQueue.java", "diffHunk": "@@ -39,6 +39,9 @@\n   private final int ringSize;\n   private final long ringAddress;\n   private final int ringFd;\n+  ", "originalCommit": "08cfa017a767924500c700bf16c120155673d054", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTcyMzE3OQ==", "url": "https://github.com/netty/netty/pull/10542#discussion_r485723179", "bodyText": "\ud83d\udc4d I hadn't been running these through checkstyle up to now but will do and make sure it passes", "author": "njhill", "createdAt": "2020-09-09T15:56:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU2MzIxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU2ODc2OA==", "url": "https://github.com/netty/netty/pull/10542#discussion_r485568768", "bodyText": "I think the exception should say something about \"Caught exception when shutting down event loop\" or something. This part, including the error handling, could also be extracted to a separate method, so it looks like \"if (blabla()) { return; }`", "author": "chrisvest", "createdAt": "2020-09-09T12:24:26Z", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringEventLoop.java", "diffHunk": "@@ -120,10 +120,31 @@ protected void run() {\n \n         // Lets add the eventfd related events before starting to do any real work.\n         submissionQueue.addPollIn(eventfd.intValue());\n-        submissionQueue.submit();\n \n         for (;;) {\n             logger.trace(\"Run IOUringEventLoop {}\", this.toString());\n+            // avoid blocking for as long as possible - loop until two consecutive \"empty\" results\n+            boolean maybeMoreTasks = true;\n+            boolean maybeMoreIo;\n+            do {\n+                maybeMoreIo = completionQueue.process(this) != 0;\n+                if (!maybeMoreIo & !maybeMoreTasks) {\n+                    break; // no need to check tasks again here\n+                }\n+                maybeMoreTasks = runAllTasks();\n+                try {\n+                    if (isShuttingDown()) {\n+                        closeAll();\n+                        if (confirmShutdown()) {\n+                            return;\n+                        }\n+                    }\n+                } catch (Throwable t) {\n+                    logger.info(\"Exception error: {}\", t);", "originalCommit": "08cfa017a767924500c700bf16c120155673d054", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTczNzUyNQ==", "url": "https://github.com/netty/netty/pull/10542#discussion_r485737525", "bodyText": "@chrisvest agree this needs more changes but I had just moved this part from lower down. I think there's a fair amount still to be done for error handling in general so maybe best for another PR(s)?", "author": "njhill", "createdAt": "2020-09-09T16:12:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU2ODc2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTczOTgwNg==", "url": "https://github.com/netty/netty/pull/10542#discussion_r485739806", "bodyText": "Sounds good.", "author": "chrisvest", "createdAt": "2020-09-09T16:15:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU2ODc2OA=="}], "type": "inlineReview"}, {"oid": "ac7a03ccc35dc2ddccb3dae289829424c83fcf08", "url": "https://github.com/netty/netty/commit/ac7a03ccc35dc2ddccb3dae289829424c83fcf08", "message": "Make sure there is a try/catch around each event loop iteration\n\nand refine inner loop", "committedDate": "2020-09-10T20:43:04Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk0OTMxNQ==", "url": "https://github.com/netty/netty/pull/10542#discussion_r486949315", "bodyText": "I'm not sure if a Or bitwise operator would make sense here, what about ||?", "author": "1Jo1", "createdAt": "2020-09-11T10:13:43Z", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringEventLoop.java", "diffHunk": "@@ -125,62 +125,83 @@ protected void run() {\n \n         // Lets add the eventfd related events before starting to do any real work.\n         addEventFdRead(submissionQueue);\n-        submissionQueue.submit();\n \n         for (;;) {\n-            logger.trace(\"Run IOUringEventLoop {}\", this.toString());\n-            long curDeadlineNanos = nextScheduledTaskDeadlineNanos();\n-            if (curDeadlineNanos == -1L) {\n-                curDeadlineNanos = NONE; // nothing on the calendar\n-            }\n-            nextWakeupNanos.set(curDeadlineNanos);\n+            try {\n+                logger.trace(\"Run IOUringEventLoop {}\", this);\n \n-            // Only submit a timeout if there are no tasks to process and do a blocking operation\n-            // on the completionQueue.\n-            if (!hasTasks()) {\n-                try {\n-                    if (curDeadlineNanos != prevDeadlineNanos) {\n-                        prevDeadlineNanos = curDeadlineNanos;\n-                        submissionQueue.addTimeout(deadlineToDelayNanos(curDeadlineNanos));\n-                        submissionQueue.submit();\n-                    }\n+                // Prepare to block wait\n+                long curDeadlineNanos = nextScheduledTaskDeadlineNanos();\n+                if (curDeadlineNanos == -1L) {\n+                    curDeadlineNanos = NONE; // nothing on the calendar\n+                }\n+                nextWakeupNanos.set(curDeadlineNanos);\n \n-                    // Check there were any completion events to process\n-                    if (completionQueue.process(this) == -1) {\n-                        // Block if there is nothing to process after this try again to call process(....)\n-                        logger.trace(\"ioUringWaitCqe {}\", this.toString());\n-                        completionQueue.ioUringWaitCqe();\n+                // Only submit a timeout if there are no tasks to process and do a blocking operation\n+                // on the completionQueue.\n+                try {\n+                    if (!hasTasks()) {\n+                        if (curDeadlineNanos != prevDeadlineNanos) {\n+                            prevDeadlineNanos = curDeadlineNanos;\n+                            submissionQueue.addTimeout(deadlineToDelayNanos(curDeadlineNanos));\n+                        }\n+\n+                        // Check there were any completion events to process\n+                        if (!completionQueue.hasCompletions()) {\n+                            // Block if there is nothing to process after this try again to call process(....)\n+                            logger.trace(\"submitAndWait {}\", this);\n+                            submissionQueue.submitAndWait();\n+                        }\n                     }\n-                } catch (Throwable t) {\n-                    //Todo handle exception\n                 } finally {\n                     if (nextWakeupNanos.get() == AWAKE || nextWakeupNanos.getAndSet(AWAKE) == AWAKE) {\n                         pendingWakeup = true;\n                     }\n                 }\n-            }\n-\n-            completionQueue.process(this);\n-\n-            // Always call runAllTasks() as it will also fetch the scheduled tasks that are ready.\n-            runAllTasks();\n \n-            submissionQueue.submit();\n-            try {\n-                if (isShuttingDown()) {\n-                    closeAll();\n-                    submissionQueue.submit();\n-\n-                    if (confirmShutdown()) {\n-                        break;\n+                // avoid blocking for as long as possible - loop until available work exhausted\n+                boolean maybeMoreWork = true;\n+                do {\n+                    try {\n+                        maybeMoreWork = completionQueue.process(this) != 0 | runAllTasks();", "originalCommit": "ac7a03ccc35dc2ddccb3dae289829424c83fcf08", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk2ODQ0MA==", "url": "https://github.com/netty/netty/pull/10542#discussion_r486968440", "bodyText": "the difference here is (IMHO) that with | it will run both commands while with || it will run only the first. If | is really what we want we should at least clarify this in a comment as at the first look it seems suspicious.", "author": "normanmaurer", "createdAt": "2020-09-11T10:54:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk0OTMxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk3MTc4OA==", "url": "https://github.com/netty/netty/pull/10542#discussion_r486971788", "bodyText": "okay that makes sense :)", "author": "1Jo1", "createdAt": "2020-09-11T11:01:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk0OTMxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAyNTM1OQ==", "url": "https://github.com/netty/netty/pull/10542#discussion_r487025359", "bodyText": "Yeah, either a comment, or a change the code to make it obvious that we wish to run both.", "author": "chrisvest", "createdAt": "2020-09-11T12:55:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk0OTMxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA3NTQ4NA==", "url": "https://github.com/netty/netty/pull/10542#discussion_r487075484", "bodyText": "Yep agreed a comment would be good!", "author": "njhill", "createdAt": "2020-09-11T14:16:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk0OTMxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAyMTYyNw==", "url": "https://github.com/netty/netty/pull/10542#discussion_r487021627", "bodyText": "Not specifically related to this PR, but I just noticed that this considers the CQE processed and consumed when handle returns false. Further turns out that this doesn't matter in practice because handle always returns true, except in one test. \ud83e\udd37", "author": "chrisvest", "createdAt": "2020-09-11T12:48:35Z", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringCompletionQueue.java", "diffHunk": "@@ -51,37 +54,37 @@\n     this.ringSize = ringSize;\n     this.ringAddress = ringAddress;\n     this.ringFd = ringFd;\n+\n+    this.ringMask = PlatformDependent.getIntVolatile(kringMaskAddress);\n+    this.ringHead = PlatformDependent.getIntVolatile(kHeadAddress);\n+  }\n+\n+  public boolean hasCompletions() {\n+      return ringHead != PlatformDependent.getIntVolatile(kTailAddress);\n   }\n \n   public int process(IOUringCompletionQueueCallback callback) {\n+      int tail = PlatformDependent.getIntVolatile(kTailAddress);\n       int i = 0;\n-      for (;;) {\n-          long head = toUnsignedLong(PlatformDependent.getIntVolatile(kHeadAddress));\n-          if (head != toUnsignedLong(PlatformDependent.getInt(kTailAddress))) {\n-              long index = head & toUnsignedLong(PlatformDependent.getInt(kringMaskAddress));\n-              long cqe = index * CQE_SIZE + completionQueueArrayAddress;\n-\n-              long udata = PlatformDependent.getLong(cqe + CQE_USER_DATA_FIELD);\n-              int res = PlatformDependent.getInt(cqe + CQE_RES_FIELD);\n-              long flags = toUnsignedLong(PlatformDependent.getInt(cqe + CQE_FLAGS_FIELD));\n-\n-              //Ensure that the kernel only sees the new value of the head index after the CQEs have been read.\n-              PlatformDependent.putIntOrdered(kHeadAddress, (int) (head + 1));\n-\n-              int fd = (int) (udata >> 32);\n-              int opMask = (int) udata;\n-              short op = (short) (opMask >> 16);\n-              short mask = (short) opMask;\n-\n-              i++;\n-              if (!callback.handle(fd, res, flags, op, mask)) {\n-                  break;\n-              }\n-          } else {\n-              if (i == 0) {\n-                  return -1;\n-              }\n-              return i;\n+      while (ringHead != tail) {\n+          long cqeAddress = completionQueueArrayAddress + (ringHead & ringMask) * CQE_SIZE;\n+\n+          long udata = PlatformDependent.getLong(cqeAddress + CQE_USER_DATA_FIELD);\n+          int res = PlatformDependent.getInt(cqeAddress + CQE_RES_FIELD);\n+          int flags = PlatformDependent.getInt(cqeAddress + CQE_FLAGS_FIELD);\n+\n+          //Ensure that the kernel only sees the new value of the head index after the CQEs have been read.\n+          ringHead++;\n+          PlatformDependent.putIntOrdered(kHeadAddress, ringHead);\n+\n+          int fd = (int) (udata >>> 32);\n+          int opMask = (int) (udata & 0xFFFFFFFFL);\n+          int op = opMask >>> 16;\n+          int mask = opMask & 0xffff;\n+\n+          i++;\n+          if (!callback.handle(fd, res, flags, op, mask)) {", "originalCommit": "ac7a03ccc35dc2ddccb3dae289829424c83fcf08", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA3NzcxOQ==", "url": "https://github.com/netty/netty/pull/10542#discussion_r487077719", "bodyText": "Will let @normanmaurer comment since I think he did this originally. It does look like it might be redundant now though... @normanmaurer wdyt about changing to void?", "author": "njhill", "createdAt": "2020-09-11T14:20:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAyMTYyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA5MjE1MQ==", "url": "https://github.com/netty/netty/pull/10542#discussion_r487092151", "bodyText": "@chrisvest  good point, void would make more sense I guess", "author": "1Jo1", "createdAt": "2020-09-11T14:41:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAyMTYyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzEzMDkzMA==", "url": "https://github.com/netty/netty/pull/10542#discussion_r487130930", "bodyText": "I added it original to limit the number of processed events per loop but i guess void is fine for now", "author": "normanmaurer", "createdAt": "2020-09-11T15:43:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAyMTYyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAyNjg1Mw==", "url": "https://github.com/netty/netty/pull/10542#discussion_r487026853", "bodyText": "Oof! Can we add a trip-counter or something (with reset on successful trips) so we only do this when there are many consecutive errors? This could be moved to some rate-limited error reporter component.", "author": "chrisvest", "createdAt": "2020-09-11T12:57:43Z", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringEventLoop.java", "diffHunk": "@@ -125,62 +125,83 @@ protected void run() {\n \n         // Lets add the eventfd related events before starting to do any real work.\n         addEventFdRead(submissionQueue);\n-        submissionQueue.submit();\n \n         for (;;) {\n-            logger.trace(\"Run IOUringEventLoop {}\", this.toString());\n-            long curDeadlineNanos = nextScheduledTaskDeadlineNanos();\n-            if (curDeadlineNanos == -1L) {\n-                curDeadlineNanos = NONE; // nothing on the calendar\n-            }\n-            nextWakeupNanos.set(curDeadlineNanos);\n+            try {\n+                logger.trace(\"Run IOUringEventLoop {}\", this);\n \n-            // Only submit a timeout if there are no tasks to process and do a blocking operation\n-            // on the completionQueue.\n-            if (!hasTasks()) {\n-                try {\n-                    if (curDeadlineNanos != prevDeadlineNanos) {\n-                        prevDeadlineNanos = curDeadlineNanos;\n-                        submissionQueue.addTimeout(deadlineToDelayNanos(curDeadlineNanos));\n-                        submissionQueue.submit();\n-                    }\n+                // Prepare to block wait\n+                long curDeadlineNanos = nextScheduledTaskDeadlineNanos();\n+                if (curDeadlineNanos == -1L) {\n+                    curDeadlineNanos = NONE; // nothing on the calendar\n+                }\n+                nextWakeupNanos.set(curDeadlineNanos);\n \n-                    // Check there were any completion events to process\n-                    if (completionQueue.process(this) == -1) {\n-                        // Block if there is nothing to process after this try again to call process(....)\n-                        logger.trace(\"ioUringWaitCqe {}\", this.toString());\n-                        completionQueue.ioUringWaitCqe();\n+                // Only submit a timeout if there are no tasks to process and do a blocking operation\n+                // on the completionQueue.\n+                try {\n+                    if (!hasTasks()) {\n+                        if (curDeadlineNanos != prevDeadlineNanos) {\n+                            prevDeadlineNanos = curDeadlineNanos;\n+                            submissionQueue.addTimeout(deadlineToDelayNanos(curDeadlineNanos));\n+                        }\n+\n+                        // Check there were any completion events to process\n+                        if (!completionQueue.hasCompletions()) {\n+                            // Block if there is nothing to process after this try again to call process(....)\n+                            logger.trace(\"submitAndWait {}\", this);\n+                            submissionQueue.submitAndWait();\n+                        }\n                     }\n-                } catch (Throwable t) {\n-                    //Todo handle exception\n                 } finally {\n                     if (nextWakeupNanos.get() == AWAKE || nextWakeupNanos.getAndSet(AWAKE) == AWAKE) {\n                         pendingWakeup = true;\n                     }\n                 }\n-            }\n-\n-            completionQueue.process(this);\n-\n-            // Always call runAllTasks() as it will also fetch the scheduled tasks that are ready.\n-            runAllTasks();\n \n-            submissionQueue.submit();\n-            try {\n-                if (isShuttingDown()) {\n-                    closeAll();\n-                    submissionQueue.submit();\n-\n-                    if (confirmShutdown()) {\n-                        break;\n+                // avoid blocking for as long as possible - loop until available work exhausted\n+                boolean maybeMoreWork = true;\n+                do {\n+                    try {\n+                        maybeMoreWork = completionQueue.process(this) != 0 | runAllTasks();\n+                    } finally {\n+                        // Always handle shutdown even if the loop processing threw an exception\n+                        try {\n+                            if (isShuttingDown()) {\n+                                closeAll();\n+                                if (confirmShutdown()) {\n+                                    return;\n+                                }\n+                                if (!maybeMoreWork) {\n+                                    maybeMoreWork = hasTasks() || completionQueue.hasCompletions();\n+                                }\n+                            }\n+                        } catch (Throwable t) {\n+                            handleLoopException(t);\n+                        }\n                     }\n-                }\n+                } while (maybeMoreWork);\n             } catch (Throwable t) {\n-                logger.info(\"Exception error: {}\", t);\n+                handleLoopException(t);\n             }\n         }\n     }\n \n+    /**\n+     * Visible only for testing!\n+     */\n+    void handleLoopException(Throwable t) {\n+        logger.warn(\"Unexpected exception in the io_uring event loop\", t);\n+\n+        // Prevent possible consecutive immediate failures that lead to\n+        // excessive CPU consumption.\n+        try {\n+            Thread.sleep(1000);", "originalCommit": "ac7a03ccc35dc2ddccb3dae289829424c83fcf08", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA4MDgxOA==", "url": "https://github.com/netty/netty/pull/10542#discussion_r487080818", "bodyText": "This was lifted straight from EpollEventLoop https://github.com/netty/netty/blob/4.1/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoop.java#L410-L423 where it's lived for a long time.\nI think that any exceptions are expected to be caught before reaching this point, so it indicates something is very wrong. I don't recall ever seeing this hit myself so extra complexity might not be worth it. Will defer to @normanmaurer again... :)", "author": "njhill", "createdAt": "2020-09-11T14:25:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAyNjg1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzExMTgzOQ==", "url": "https://github.com/netty/netty/pull/10542#discussion_r487111839", "bodyText": "Ok, in that case I won't hold it against this PR.", "author": "chrisvest", "createdAt": "2020-09-11T15:12:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAyNjg1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAyOTA4Mg==", "url": "https://github.com/netty/netty/pull/10542#discussion_r487029082", "bodyText": "Guarding for negative submit counts? When would that happen?", "author": "chrisvest", "createdAt": "2020-09-11T13:01:46Z", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringSubmissionQueue.java", "diffHunk": "@@ -188,17 +188,33 @@ public boolean addClose(int fd) {\n     public void submit() {\n         int submit = tail - head;\n         if (submit > 0) {\n-            PlatformDependent.putIntOrdered(kTailAddress, tail); // release memory barrier\n-            int ret = Native.ioUringEnter(ringFd, submit, 0, 0);\n-            head = PlatformDependent.getIntVolatile(kHeadAddress); // acquire memory barrier\n-            if (ret != submit) {\n-                if (ret < 0) {\n-                    throw new RuntimeException(\"ioUringEnter syscall\");\n-                }\n-                logger.warn(\"Not all submissions succeeded\");\n+            submit(submit, 0, 0);\n+        }\n+    }\n+\n+    public void submitAndWait() {\n+        int submit = tail - head;\n+        if (submit > 0) {\n+            submit(submit, 1, Native.IORING_ENTER_GETEVENTS);\n+        } else {\n+            int ret = Native.ioUringEnter(ringFd, 0, 1, Native.IORING_ENTER_GETEVENTS);", "originalCommit": "ac7a03ccc35dc2ddccb3dae289829424c83fcf08", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA4NjU4Mg==", "url": "https://github.com/netty/netty/pull/10542#discussion_r487086582", "bodyText": "I think that would entail a nasty bug but I guess it wouldn't harm to check.", "author": "njhill", "createdAt": "2020-09-11T14:34:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAyOTA4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzEwMjUwMQ==", "url": "https://github.com/netty/netty/pull/10542#discussion_r487102501", "bodyText": "On second thoughts I don't think there's really a need to \"guard\" for this here, since we still take the \"correct\" action i.e. don't submit and wait for completions. But I will add a check to where we trigger submit when the SQ ring is full, since if for some reason that returns 0 we should not move to the next SQE slot.", "author": "njhill", "createdAt": "2020-09-11T14:57:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAyOTA4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzExMDE2MQ==", "url": "https://github.com/netty/netty/pull/10542#discussion_r487110161", "bodyText": "Yeah, that's my thinking. The dance seems unnecessary, but I'm not entirely certain. Things like overflow is hard to reason about.", "author": "chrisvest", "createdAt": "2020-09-11T15:09:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAyOTA4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE1OTkwNA==", "url": "https://github.com/netty/netty/pull/10542#discussion_r487159904", "bodyText": "Good candidate for assert?", "author": "johnou", "createdAt": "2020-09-11T16:35:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAyOTA4Mg=="}], "type": "inlineReview"}, {"oid": "e14343d415d3e51db6e2bc162376c10413c10c38", "url": "https://github.com/netty/netty/commit/e14343d415d3e51db6e2bc162376c10413c10c38", "message": "Further reduce io_uring syscalls\n\nMotivation\n\nIOUringEventLoop can be streamlined to further reduce io_uring_enter\ncalls\n\nModification\n\n- Don't prepare to block-wait until all available work is exhausted\n- Combine submission with GETEVENTS\n\nResult\n\nHopefully faster", "committedDate": "2020-09-11T16:33:41Z", "type": "commit"}, {"oid": "5d7c9776294b8ddc98c13ccd991aa651e1c15d79", "url": "https://github.com/netty/netty/commit/5d7c9776294b8ddc98c13ccd991aa651e1c15d79", "message": "minor simplification to IOUringCompletionQueue#process method", "committedDate": "2020-09-11T16:33:41Z", "type": "commit"}, {"oid": "7eff2ea6b8c5cd380c4152d93968711569f7abf5", "url": "https://github.com/netty/netty/commit/7eff2ea6b8c5cd380c4152d93968711569f7abf5", "message": "Move shutdown check into inner loop", "committedDate": "2020-09-11T16:33:41Z", "type": "commit"}, {"oid": "4180c38ab7f1f348c665b958a8e83182ef1968c8", "url": "https://github.com/netty/netty/commit/4180c38ab7f1f348c665b958a8e83182ef1968c8", "message": "Fix eventloop shutdown logic", "committedDate": "2020-09-11T16:33:41Z", "type": "commit"}, {"oid": "28907dbc9fa7624dd865fdd4a35b9f119ad0b304", "url": "https://github.com/netty/netty/commit/28907dbc9fa7624dd865fdd4a35b9f119ad0b304", "message": "Adjust inner event loop to better interleave task/completion processing", "committedDate": "2020-09-11T16:33:42Z", "type": "commit"}, {"oid": "d0cf1c985491b232b5b324d98581f2a1af933663", "url": "https://github.com/netty/netty/commit/d0cf1c985491b232b5b324d98581f2a1af933663", "message": "Change to do/while per @chrisvest's suggestion", "committedDate": "2020-09-11T16:33:42Z", "type": "commit"}, {"oid": "87ba9ce4db9bf717dfbdc9fdf9107bd77a49eb56", "url": "https://github.com/netty/netty/commit/87ba9ce4db9bf717dfbdc9fdf9107bd77a49eb56", "message": "Incorporate suggestions, move inner loop to bottom, move hasTasks check", "committedDate": "2020-09-11T16:33:42Z", "type": "commit"}, {"oid": "5ab9871dd3b2e52c473afa7c8aa9faecfba41d5a", "url": "https://github.com/netty/netty/commit/5ab9871dd3b2e52c473afa7c8aa9faecfba41d5a", "message": "Make sure there is a try/catch around each event loop iteration\n\nand refine inner loop", "committedDate": "2020-09-11T16:33:42Z", "type": "commit"}, {"oid": "6df3f3718c212f7d6e573a2250ef87ef948ab35f", "url": "https://github.com/netty/netty/commit/6df3f3718c212f7d6e573a2250ef87ef948ab35f", "message": "Address some comments, other small refinements\n\nAdjust try/catch blocks some more to ensure that exceptions are logged\nin order", "committedDate": "2020-09-11T16:33:42Z", "type": "commit"}, {"oid": "425b95ed92ef6bdd44c05db395fca50a5337fd00", "url": "https://github.com/netty/netty/commit/425b95ed92ef6bdd44c05db395fca50a5337fd00", "message": "Simplify completion queue handle() and related methods", "committedDate": "2020-09-11T16:50:58Z", "type": "commit"}, {"oid": "425b95ed92ef6bdd44c05db395fca50a5337fd00", "url": "https://github.com/netty/netty/commit/425b95ed92ef6bdd44c05db395fca50a5337fd00", "message": "Simplify completion queue handle() and related methods", "committedDate": "2020-09-11T16:50:58Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzIxNTMwNw==", "url": "https://github.com/netty/netty/pull/10542#discussion_r487215307", "bodyText": "Hmm it\u2019s kind of odd to expose a package-private class in a public method imho", "author": "normanmaurer", "createdAt": "2020-09-11T18:24:03Z", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/AbstractIOUringChannel.java", "diffHunk": "@@ -163,6 +163,11 @@ public FileDescriptor fd() {\n     @Override\n     protected abstract AbstractUringUnsafe newUnsafe();\n \n+    @Override\n+    public AbstractUringUnsafe unsafe() {", "originalCommit": "425b95ed92ef6bdd44c05db395fca50a5337fd00", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzIyMjA0OA==", "url": "https://github.com/netty/netty/pull/10542#discussion_r487222048", "bodyText": "@normanmaurer sure I can revert this if you prefer. I don't think it's really exposed though since the AbstractIOUringChannel class itself is also package-private. So anyone calling from outside would be operating on the superclass version of it anyhow which returns Unsafe and so would not see or be aware of this... wdyt?", "author": "njhill", "createdAt": "2020-09-11T18:38:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzIxNTMwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzIyODI3Nw==", "url": "https://github.com/netty/netty/pull/10542#discussion_r487228277", "bodyText": "... or could add a separate package-private ioUringUnsafe() method if you think that's better? Just seems preferable to casting everywhere", "author": "njhill", "createdAt": "2020-09-11T18:51:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzIxNTMwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzIyOTgxMw==", "url": "https://github.com/netty/netty/pull/10542#discussion_r487229813", "bodyText": "Yeah let\u2019s do that", "author": "normanmaurer", "createdAt": "2020-09-11T18:54:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzIxNTMwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzI0MDE5Ng==", "url": "https://github.com/netty/netty/pull/10542#discussion_r487240196", "bodyText": "done", "author": "njhill", "createdAt": "2020-09-11T19:16:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzIxNTMwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzIxNjkzOQ==", "url": "https://github.com/netty/netty/pull/10542#discussion_r487216939", "bodyText": "Just as a followup we should better access the fields directly from JNI as calling methods is expensive", "author": "normanmaurer", "createdAt": "2020-09-11T18:27:04Z", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringSubmissionQueue.java", "diffHunk": "@@ -231,6 +250,8 @@ public void release() {\n         PlatformDependent.freeMemory(timeoutMemoryAddress);\n     }\n \n+    // The getters below are called from JNI code\n+", "originalCommit": "425b95ed92ef6bdd44c05db395fca50a5337fd00", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5NDcyMg==", "url": "https://github.com/netty/netty/pull/10542#discussion_r487394722", "bodyText": "@normanmaurer I think it shouldn't be big issue as the methods are called when we close the RingBuffer, however it would be cleaner to access the fields directly, I'll create followup PR today", "author": "1Jo1", "createdAt": "2020-09-12T10:22:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzIxNjkzOQ=="}], "type": "inlineReview"}, {"oid": "68217514ca8c6aa8be523bfc36476dec8316650b", "url": "https://github.com/netty/netty/commit/68217514ca8c6aa8be523bfc36476dec8316650b", "message": "Use dedicated pkg-private AbstractIOUringChannel#ioUringUnsafe() method", "committedDate": "2020-09-11T19:15:10Z", "type": "commit"}]}