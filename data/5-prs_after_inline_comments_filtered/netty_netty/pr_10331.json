{"pr_number": 10331, "pr_title": "Support session cache for client and server when using native SSLEngi\u2026", "pr_createdAt": "2020-05-29T15:48:03Z", "pr_url": "https://github.com/netty/netty/pull/10331", "timeline": [{"oid": "7e8856a98a46997fd310f15916b78eb6d77abf8f", "url": "https://github.com/netty/netty/commit/7e8856a98a46997fd310f15916b78eb6d77abf8f", "message": "Support session cache for client and server when using native SSLEngine implementation\n\nMotivation:\n\nAt the moment we don't support session caching for client side when using native SSLEngine implementation and our implementation of SSLSessionContext is incomplete.\n\nModification:\n\n- Consume netty-tcnative changes to be able to cache session in an external cache\n- Add and adjust unit tests to test session caching\n- Add an in memory session cache that is hooked into native SSLEngine\n\nResult:\n\nSupport session caching on the client and server side", "committedDate": "2020-05-29T15:54:30Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDExMTMyNw==", "url": "https://github.com/netty/netty/pull/10331#discussion_r434111327", "bodyText": "getLocalPrincipal() should not be null when getLocalCertificates() is not null.", "author": "idelpivnitskiy", "createdAt": "2020-06-02T19:03:04Z", "path": "handler/src/main/java/io/netty/handler/ssl/NullOpenSslSession.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.ssl;\n+\n+import io.netty.util.internal.EmptyArrays;\n+\n+import javax.net.ssl.SSLPeerUnverifiedException;\n+import javax.security.cert.X509Certificate;\n+import java.security.Principal;\n+import java.security.cert.Certificate;\n+\n+final class NullOpenSslSession extends AbstractOpenSslSession {\n+\n+    private final Certificate[] localCertificate;\n+\n+    NullOpenSslSession(OpenSslSessionContext sessionContext, Certificate[] localCertificate) {\n+        super(sessionContext, null, -1, EmptyArrays.EMPTY_BYTES);\n+        this.localCertificate = localCertificate;\n+    }\n+\n+    @Override\n+    public boolean isNullSession() {\n+        return true;\n+    }\n+\n+    @Override\n+    public long nativeAddr() {\n+        return -1;\n+    }\n+\n+    @Override\n+    public void setLocalCertificate(Certificate[] localCertificate) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public void tryExpandApplicationBufferSize(int packetLengthDataOnly) {\n+        // NOOP\n+    }\n+\n+    @Override\n+    public void setPacketBufferSize(int packetBufferSize) {\n+        // NOOP\n+    }\n+\n+    @Override\n+    public void updateLastAccessedTime() {\n+        // NOOP\n+    }\n+\n+    @Override\n+    public long free() {\n+        return -1;\n+    }\n+\n+    @Override\n+    public long getCreationTime() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public long getLastAccessedTime() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public void invalidate() {\n+        // NOOP\n+    }\n+\n+    @Override\n+    public boolean isValid() {\n+        return false;\n+    }\n+\n+    @Override\n+    public Certificate[] getPeerCertificates() throws SSLPeerUnverifiedException {\n+        throw new SSLPeerUnverifiedException(\"NULL session\");\n+    }\n+\n+    @Override\n+    public Certificate[] getLocalCertificates() {\n+        if (localCertificate != null) {\n+            return localCertificate.clone();\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public X509Certificate[] getPeerCertificateChain() throws SSLPeerUnverifiedException {\n+        throw new SSLPeerUnverifiedException(\"NULL session\");\n+    }\n+\n+    @Override\n+    public Principal getPeerPrincipal() throws SSLPeerUnverifiedException {\n+        throw new SSLPeerUnverifiedException(\"NULL session\");\n+    }\n+\n+    @Override\n+    public Principal getLocalPrincipal() {\n+        return null;", "originalCommit": "7e8856a98a46997fd310f15916b78eb6d77abf8f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE3MTg5Mw==", "url": "https://github.com/netty/netty/pull/10331#discussion_r434171893", "bodyText": "Consider returning a constant", "author": "idelpivnitskiy", "createdAt": "2020-06-02T20:58:47Z", "path": "handler/src/main/java/io/netty/handler/ssl/ExtendedOpenSslSession.java", "diffHunk": "@@ -61,8 +61,43 @@\n     }\n \n     @Override\n-    public final void handshakeFinished() throws SSLException {\n-        wrapped.handshakeFinished();\n+    public OpenSslSessionId sessionId() {\n+        return wrapped.sessionId();\n+    }\n+\n+    @Override\n+    public final boolean isNullSession() {\n+        return wrapped.isNullSession();\n+    }\n+\n+    @Override\n+    public final void setLocalCertificate(Certificate[] localCertificate) {\n+        wrapped.setLocalCertificate(localCertificate);\n+    }\n+\n+    @Override\n+    public final void setPacketBufferSize(int packetBufferSize) {\n+        wrapped.setPacketBufferSize(packetBufferSize);\n+    }\n+\n+    @Override\n+    public final long nativeAddr() {\n+        return wrapped.nativeAddr();\n+    }\n+\n+    @Override\n+    public final void updateLastAccessedTime() {\n+        wrapped.updateLastAccessedTime();\n+    }\n+\n+    @Override\n+    public final long free() {\n+        return wrapped.free();\n+    }\n+\n+    @Override\n+    public String[] getPeerSupportedSignatureAlgorithms() {\n+        return new String[0];", "originalCommit": "7e8856a98a46997fd310f15916b78eb6d77abf8f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE3NDM3OA==", "url": "https://github.com/netty/netty/pull/10331#discussion_r434174378", "bodyText": "Consider defining serialVersionUID", "author": "idelpivnitskiy", "createdAt": "2020-06-02T21:03:54Z", "path": "handler/src/main/java/io/netty/handler/ssl/OpenSslSessionCache.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.ssl;\n+\n+import io.netty.internal.tcnative.SSLSessionCache;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+import javax.net.ssl.SSLSession;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+// TODO: Handle timeout\n+class OpenSslSessionCache implements SSLSessionCache {\n+    private static final int DEFAULT_CACHE_SIZE;\n+    static {\n+        int cacheSize = SystemPropertyUtil.getInt(\"javax.net.ssl.sessionCacheSize\", 20480);\n+        if (cacheSize >= 0) {\n+            DEFAULT_CACHE_SIZE = cacheSize;\n+        } else {\n+            DEFAULT_CACHE_SIZE = 20480;\n+        }\n+    }\n+\n+    private final OpenSslEngineMap engineMap;\n+\n+    private final Map<OpenSslSessionId, OpenSslSession> sessions =\n+            new LinkedHashMap<OpenSslSessionId, OpenSslSession>() {", "originalCommit": "7e8856a98a46997fd310f15916b78eb6d77abf8f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE4NTk1Mg==", "url": "https://github.com/netty/netty/pull/10331#discussion_r434185952", "bodyText": "If the arguments is false, should we also clear existing sessionCache?", "author": "idelpivnitskiy", "createdAt": "2020-06-02T21:28:35Z", "path": "handler/src/main/java/io/netty/handler/ssl/OpenSslSessionContext.java", "diffHunk": "@@ -124,12 +178,30 @@ public void setTicketKeys(OpenSslSessionTicketKey... keys) {\n     /**\n      * Enable or disable caching of SSL sessions.\n      */\n-    public abstract void setSessionCacheEnabled(boolean enabled);\n+    public void setSessionCacheEnabled(boolean enabled) {\n+        long mode = enabled ? mask | SSL.SSL_SESS_CACHE_NO_INTERNAL_LOOKUP |", "originalCommit": "7e8856a98a46997fd310f15916b78eb6d77abf8f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE4NzIwOA==", "url": "https://github.com/netty/netty/pull/10331#discussion_r434187208", "bodyText": "isProtocolEnabled and isCipherSuiteEnabled may be static", "author": "idelpivnitskiy", "createdAt": "2020-06-02T21:31:12Z", "path": "handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslClientContext.java", "diffHunk": "@@ -184,44 +189,113 @@ private static void setVerifyCallback(long ctx, OpenSslEngineMap engineMap, X509\n         }\n     }\n \n-    // No cache is currently supported for client side mode.\n-    static final class OpenSslClientSessionContext extends OpenSslSessionContext {\n-        OpenSslClientSessionContext(ReferenceCountedOpenSslContext context, OpenSslKeyMaterialProvider provider) {\n-            super(context, provider);\n+    private static final class OpenSslClientSessionCache extends OpenSslSessionCache {\n+        // TODO: Should we support to have a List of OpenSslSessions for a Host/Port key and so be able to\n+        // support sessions for different protocols / ciphers to the same remote peer ?\n+        private final Map<HostPort, OpenSslSession> sessions = new HashMap<HostPort, OpenSslSession>();\n+\n+        OpenSslClientSessionCache(OpenSslEngineMap engineMap) {\n+            super(engineMap);\n         }\n \n         @Override\n-        public void setSessionTimeout(int seconds) {\n-            if (seconds < 0) {\n-                throw new IllegalArgumentException();\n+        protected boolean sessionCreated(OpenSslSession session) {\n+            assert Thread.holdsLock(this);\n+            String host = session.getPeerHost();\n+            int port = session.getPeerPort();\n+            if (host == null || port == -1) {\n+                return false;\n             }\n+            HostPort hostPort = new HostPort(host, port);\n+            if (sessions.containsKey(hostPort)) {\n+                return false;\n+            }\n+            sessions.put(hostPort, session);\n+            return true;\n         }\n \n         @Override\n-        public int getSessionTimeout() {\n-            return 0;\n+        protected void sessionRemoved(OpenSslSession session) {\n+            assert Thread.holdsLock(this);\n+            String host = session.getPeerHost();\n+            int port = session.getPeerPort();\n+            if (host == null || port == -1) {\n+                return;\n+            }\n+            sessions.remove(new HostPort(host, port));\n         }\n \n-        @Override\n-        public void setSessionCacheSize(int size)  {\n-            if (size < 0) {\n-                throw new IllegalArgumentException();\n+        private boolean isProtocolEnabled(OpenSslSession session, String[] enabledProtocols) {\n+            return arrayContains(session.getProtocol(), enabledProtocols);\n+        }\n+\n+        private boolean isCipherSuiteEnabled(OpenSslSession session, String[] enabledCipherSuites) {", "originalCommit": "7e8856a98a46997fd310f15916b78eb6d77abf8f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE5MDYzNA==", "url": "https://github.com/netty/netty/pull/10331#discussion_r434190634", "bodyText": "Consider also verifying that the session was reused.", "author": "idelpivnitskiy", "createdAt": "2020-06-02T21:39:10Z", "path": "handler/src/test/java/io/netty/handler/ssl/SSLEngineTest.java", "diffHunk": "@@ -2869,6 +2871,70 @@ public void testGetCiphersuite() throws Exception {\n         }\n     }\n \n+    @Test\n+    public void testSessionCacheForTLS12() throws Exception {", "originalCommit": "7e8856a98a46997fd310f15916b78eb6d77abf8f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE4NDg1MA==", "url": "https://github.com/netty/netty/pull/10331#discussion_r437184850", "bodyText": "Looks like it should be opposite: drain only if new size < oldSize.", "author": "idelpivnitskiy", "createdAt": "2020-06-09T07:12:22Z", "path": "handler/src/main/java/io/netty/handler/ssl/OpenSslSessionCache.java", "diffHunk": "@@ -0,0 +1,256 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.ssl;\n+\n+import io.netty.internal.tcnative.SSLSessionCache;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+import javax.net.ssl.SSLException;\n+import javax.net.ssl.SSLSession;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+\n+/**\n+ * {@link SSLSessionCache} implementation for our native SSL implementation.\n+ */\n+class OpenSslSessionCache implements SSLSessionCache {\n+    private static final int DEFAULT_CACHE_SIZE;\n+    static {\n+        // Respect the same system property as the JDK implementation to make it easy to switch between implementations.\n+        int cacheSize = SystemPropertyUtil.getInt(\"javax.net.ssl.sessionCacheSize\", 20480);\n+        if (cacheSize >= 0) {\n+            DEFAULT_CACHE_SIZE = cacheSize;\n+        } else {\n+            DEFAULT_CACHE_SIZE = 20480;\n+        }\n+    }\n+\n+    private final OpenSslEngineMap engineMap;\n+\n+    private final Map<OpenSslSessionId, OpenSslSession> sessions =\n+            new LinkedHashMap<OpenSslSessionId, OpenSslSession>() {\n+\n+                private static final long serialVersionUID = -7773696788135734448L;\n+\n+                @Override\n+        protected boolean removeEldestEntry(Map.Entry<OpenSslSessionId, OpenSslSession> eldest) {\n+            int maxSize = maximumCacheSize.get();\n+            if (maxSize >= 0 && this.size() > maxSize) {\n+                OpenSslSession session = eldest.getValue();\n+                sessionRemoved(session);\n+                session.release();\n+                return true;\n+            }\n+            return false;\n+        }\n+    };\n+\n+    private final AtomicInteger maximumCacheSize = new AtomicInteger(DEFAULT_CACHE_SIZE);\n+\n+    // Let's use the same default value as OpenSSL does.\n+    // See https://www.openssl.org/docs/man1.1.1/man3/SSL_get_default_timeout.html\n+    private volatile int sessionTimeout = 300;\n+    private int sessionCounter;\n+\n+    OpenSslSessionCache(OpenSslEngineMap engineMap) {\n+        this.engineMap = engineMap;\n+    }\n+\n+    void setSessionTimeout(int seconds) {\n+        if (seconds < 0) {\n+            throw new IllegalArgumentException();\n+        }\n+        sessionTimeout = seconds;\n+    }\n+\n+    int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    /**\n+     * Called once a new {@link OpenSslSession} was created.\n+     *\n+     * @param session the new session.\n+     * @return {@code true} if the session should be cached, {@code false} otherwise.\n+     */\n+    protected boolean sessionCreated(OpenSslSession session) {\n+        return true;\n+    }\n+\n+    /**\n+     * Called once an {@link OpenSslSession} was removed from the cache.\n+     *\n+     * @param session the session to remove.\n+     */\n+    protected void sessionRemoved(OpenSslSession session) { }\n+\n+    final void setSessionCacheSize(int size) {\n+        if (size < 0) {\n+            throw new IllegalArgumentException();\n+        }\n+        long oldSize = maximumCacheSize.getAndSet(size);\n+        if (oldSize < size) {", "originalCommit": "c534860ad4f6c78c359dacc339704e9998bc2f24", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE4Nzc1Ng==", "url": "https://github.com/netty/netty/pull/10331#discussion_r437187756", "bodyText": "When timeout is changed some sessions may become invalidated and should be removed from the cache.\nWe can do this as a follow-up, let's just keep a reminder somewhere.", "author": "idelpivnitskiy", "createdAt": "2020-06-09T07:18:15Z", "path": "handler/src/main/java/io/netty/handler/ssl/OpenSslSessionCache.java", "diffHunk": "@@ -0,0 +1,256 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.ssl;\n+\n+import io.netty.internal.tcnative.SSLSessionCache;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+import javax.net.ssl.SSLException;\n+import javax.net.ssl.SSLSession;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+\n+/**\n+ * {@link SSLSessionCache} implementation for our native SSL implementation.\n+ */\n+class OpenSslSessionCache implements SSLSessionCache {\n+    private static final int DEFAULT_CACHE_SIZE;\n+    static {\n+        // Respect the same system property as the JDK implementation to make it easy to switch between implementations.\n+        int cacheSize = SystemPropertyUtil.getInt(\"javax.net.ssl.sessionCacheSize\", 20480);\n+        if (cacheSize >= 0) {\n+            DEFAULT_CACHE_SIZE = cacheSize;\n+        } else {\n+            DEFAULT_CACHE_SIZE = 20480;\n+        }\n+    }\n+\n+    private final OpenSslEngineMap engineMap;\n+\n+    private final Map<OpenSslSessionId, OpenSslSession> sessions =\n+            new LinkedHashMap<OpenSslSessionId, OpenSslSession>() {\n+\n+                private static final long serialVersionUID = -7773696788135734448L;\n+\n+                @Override\n+        protected boolean removeEldestEntry(Map.Entry<OpenSslSessionId, OpenSslSession> eldest) {\n+            int maxSize = maximumCacheSize.get();\n+            if (maxSize >= 0 && this.size() > maxSize) {\n+                OpenSslSession session = eldest.getValue();\n+                sessionRemoved(session);\n+                session.release();\n+                return true;\n+            }\n+            return false;\n+        }\n+    };\n+\n+    private final AtomicInteger maximumCacheSize = new AtomicInteger(DEFAULT_CACHE_SIZE);\n+\n+    // Let's use the same default value as OpenSSL does.\n+    // See https://www.openssl.org/docs/man1.1.1/man3/SSL_get_default_timeout.html\n+    private volatile int sessionTimeout = 300;\n+    private int sessionCounter;\n+\n+    OpenSslSessionCache(OpenSslEngineMap engineMap) {\n+        this.engineMap = engineMap;\n+    }\n+\n+    void setSessionTimeout(int seconds) {\n+        if (seconds < 0) {\n+            throw new IllegalArgumentException();\n+        }\n+        sessionTimeout = seconds;", "originalCommit": "c534860ad4f6c78c359dacc339704e9998bc2f24", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI2ODY4NQ==", "url": "https://github.com/netty/netty/pull/10331#discussion_r437268685", "bodyText": "the timeout should only affect new sessions as stated in the javadocs of SSLSessionContext", "author": "normanmaurer", "createdAt": "2020-06-09T09:24:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE4Nzc1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ4MjAwMg==", "url": "https://github.com/netty/netty/pull/10331#discussion_r437482002", "bodyText": "https://docs.oracle.com/javase/7/docs/api/javax/net/ssl/SSLSessionContext.html#setSessionTimeout(int)", "author": "normanmaurer", "createdAt": "2020-06-09T14:47:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE4Nzc1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE5MDg1NQ==", "url": "https://github.com/netty/netty/pull/10331#discussion_r437190855", "bodyText": "The freeSeessions() method does the same thing as expungeInvalidSessions() (except synchronized). Consider reusing the logic that clears sessions.", "author": "idelpivnitskiy", "createdAt": "2020-06-09T07:24:13Z", "path": "handler/src/main/java/io/netty/handler/ssl/OpenSslSessionCache.java", "diffHunk": "@@ -0,0 +1,256 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.ssl;\n+\n+import io.netty.internal.tcnative.SSLSessionCache;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+import javax.net.ssl.SSLException;\n+import javax.net.ssl.SSLSession;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+\n+/**\n+ * {@link SSLSessionCache} implementation for our native SSL implementation.\n+ */\n+class OpenSslSessionCache implements SSLSessionCache {\n+    private static final int DEFAULT_CACHE_SIZE;\n+    static {\n+        // Respect the same system property as the JDK implementation to make it easy to switch between implementations.\n+        int cacheSize = SystemPropertyUtil.getInt(\"javax.net.ssl.sessionCacheSize\", 20480);\n+        if (cacheSize >= 0) {\n+            DEFAULT_CACHE_SIZE = cacheSize;\n+        } else {\n+            DEFAULT_CACHE_SIZE = 20480;\n+        }\n+    }\n+\n+    private final OpenSslEngineMap engineMap;\n+\n+    private final Map<OpenSslSessionId, OpenSslSession> sessions =\n+            new LinkedHashMap<OpenSslSessionId, OpenSslSession>() {\n+\n+                private static final long serialVersionUID = -7773696788135734448L;\n+\n+                @Override\n+        protected boolean removeEldestEntry(Map.Entry<OpenSslSessionId, OpenSslSession> eldest) {\n+            int maxSize = maximumCacheSize.get();\n+            if (maxSize >= 0 && this.size() > maxSize) {\n+                OpenSslSession session = eldest.getValue();\n+                sessionRemoved(session);\n+                session.release();\n+                return true;\n+            }\n+            return false;\n+        }\n+    };\n+\n+    private final AtomicInteger maximumCacheSize = new AtomicInteger(DEFAULT_CACHE_SIZE);\n+\n+    // Let's use the same default value as OpenSSL does.\n+    // See https://www.openssl.org/docs/man1.1.1/man3/SSL_get_default_timeout.html\n+    private volatile int sessionTimeout = 300;\n+    private int sessionCounter;\n+\n+    OpenSslSessionCache(OpenSslEngineMap engineMap) {\n+        this.engineMap = engineMap;\n+    }\n+\n+    void setSessionTimeout(int seconds) {\n+        if (seconds < 0) {\n+            throw new IllegalArgumentException();\n+        }\n+        sessionTimeout = seconds;\n+    }\n+\n+    int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    /**\n+     * Called once a new {@link OpenSslSession} was created.\n+     *\n+     * @param session the new session.\n+     * @return {@code true} if the session should be cached, {@code false} otherwise.\n+     */\n+    protected boolean sessionCreated(OpenSslSession session) {\n+        return true;\n+    }\n+\n+    /**\n+     * Called once an {@link OpenSslSession} was removed from the cache.\n+     *\n+     * @param session the session to remove.\n+     */\n+    protected void sessionRemoved(OpenSslSession session) { }\n+\n+    final void setSessionCacheSize(int size) {\n+        if (size < 0) {\n+            throw new IllegalArgumentException();\n+        }\n+        long oldSize = maximumCacheSize.getAndSet(size);\n+        if (oldSize < size) {\n+            // Just keep it simple for now and drain the whole cache.\n+            freeSessions();\n+        }\n+    }\n+\n+    final int getSessionCacheSize() {\n+        return maximumCacheSize.get();\n+    }\n+\n+    DefaultOpenSslSession newOpenSslSession(long sslSession, OpenSslSessionContext context, String peerHost,\n+                                            int peerPort, String protocol, String cipher,\n+                                            OpenSslJavaxX509Certificate[] peerCertificateChain,\n+                                            long creationTime) {\n+        synchronized (this) {\n+            if (sslSession != -1) {\n+                if (!io.netty.internal.tcnative.SSLSession.upRef(sslSession)) {\n+                    throw new IllegalStateException(\"Unable to update reference count of SSL_SESSION*\");\n+                }\n+            }\n+        }\n+        return new DefaultOpenSslSession(context, peerHost, peerPort, sslSession, protocol, cipher,\n+                peerCertificateChain, creationTime, context.getSessionTimeout() * 1000L);\n+    }\n+\n+    private void expungeInvalidSessions() {\n+        Iterator<Map.Entry<OpenSslSessionId, OpenSslSession>> iterator = sessions.entrySet().iterator();\n+        while (iterator.hasNext()) {\n+            OpenSslSession session = iterator.next().getValue();\n+            if (!session.isValid()) {\n+                iterator.remove();\n+\n+                sessionRemoved(session);\n+                session.release();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public final boolean sessionCreated(long ssl, long sslSession) {\n+        ReferenceCountedOpenSslEngine engine = engineMap.get(ssl);\n+        if (engine == null) {\n+            return false;\n+        }\n+\n+        synchronized (this) {\n+            // Mimic what OpenSSL is duing and expunge every 255 new sessions\n+            // See https://www.openssl.org/docs/man1.0.2/man3/SSL_CTX_flush_sessions.html\n+            if (++sessionCounter == 255) {\n+                sessionCounter = 0;\n+                expungeInvalidSessions();\n+            }\n+\n+            final OpenSslSession session;\n+            try {\n+                session = engine.sessionCreated(sslSession);\n+            } catch (SSLException e) {\n+                // TODO: Should we log this ?\n+                return false;\n+            }\n+            if (!sessionCreated(session)) {\n+                return false;\n+            }\n+\n+            final OpenSslSession old = sessions.put(session.sessionId(), session.retain());\n+            if (old != null) {\n+                sessionRemoved(old);\n+                old.release();\n+            }\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public final long getSession(long ssl, byte[] sessionId) {\n+        OpenSslSessionId id = new OpenSslSessionId(sessionId);\n+        synchronized (this) {\n+            OpenSslSession session = sessions.get(id);\n+            if (session == null) {\n+                return -1;\n+            }\n+            long nativeAddr = session.nativeAddr();\n+            if (nativeAddr == -1 || !session.isValid()) {\n+                removeSession(session);\n+                return -1;\n+            }\n+\n+            // This needs to happen in the synchronized block so we ensure we never destroy it before we incremented\n+            // the reference count.\n+            if (!io.netty.internal.tcnative.SSLSession.upRef(nativeAddr)) {\n+                // we could not increment the reference count, something is wrong. Let's just drop the session.\n+                removeSession(session);\n+                return -1;\n+            }\n+\n+            session.retain();\n+\n+            if (io.netty.internal.tcnative.SSLSession.shouldBeSingleUse(nativeAddr)) {\n+                // Should only be used once\n+                removeSession(session);\n+            }\n+            session.updateLastAccessedTime();\n+            return nativeAddr;\n+        }\n+    }\n+\n+    protected void removeSession(OpenSslSession session) {\n+        sessions.remove(session.sessionId());\n+        sessionRemoved(session);\n+        session.release();\n+    }\n+\n+    final SSLSession getSession(byte[] bytes) {\n+        OpenSslSessionId id = new OpenSslSessionId(bytes);\n+        synchronized (this) {\n+            OpenSslSession session = sessions.get(id);\n+            if (session == null) {\n+                return null;\n+            }\n+            if (!session.isValid()) {\n+                removeSession(session);\n+                return null;\n+            }\n+            return session;\n+        }\n+    }\n+\n+    final synchronized List<byte[]> getIds() {\n+        List<byte[]> ids = new ArrayList<byte[]>(sessions.size());\n+        for (OpenSslSession session: sessions.values()) {\n+            if (session.isValid()) {\n+                ids.add(session.getId());\n+            }\n+        }\n+        return ids;\n+    }\n+\n+    final synchronized void freeSessions() {\n+        final OpenSslSession[] sessionsArray = sessions.values().toArray(new OpenSslSession[0]);\n+        sessions.clear();\n+\n+        for (OpenSslSession session: sessionsArray) {\n+            sessionRemoved(session);\n+            session.release();", "originalCommit": "c534860ad4f6c78c359dacc339704e9998bc2f24", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ4MDYwOA==", "url": "https://github.com/netty/netty/pull/10331#discussion_r437480608", "bodyText": "it does not the same as exponugeInvalidSessions also takes isValid into account", "author": "normanmaurer", "createdAt": "2020-06-09T14:45:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE5MDg1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE5NzIwNQ==", "url": "https://github.com/netty/netty/pull/10331#discussion_r437197205", "bodyText": "Why only positive numbers? Zero is also a legit value.\nNegative values should throw an IllegalArgumetException, consider verifying input parameters from public API of SslContextBuilder or OpenSslClientContext ctors.", "author": "idelpivnitskiy", "createdAt": "2020-06-09T07:35:53Z", "path": "handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslClientContext.java", "diffHunk": "@@ -164,6 +166,15 @@ static OpenSslSessionContext newSessionContext(ReferenceCountedOpenSslContext th\n                 throw new SSLException(\"unable to setup trustmanager\", e);\n             }\n             OpenSslClientSessionContext context = new OpenSslClientSessionContext(thiz, keyMaterialProvider);\n+            // Enable session caching by default\n+            context.setSessionCacheEnabled(true);\n+            if (sessionCacheSize > 0) {\n+                context.setSessionCacheSize((int) Math.min(sessionCacheSize, Integer.MAX_VALUE));\n+            }\n+            if (sessionTimeout > 0) {", "originalCommit": "c534860ad4f6c78c359dacc339704e9998bc2f24", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE5NzcwNA==", "url": "https://github.com/netty/netty/pull/10331#discussion_r437197704", "bodyText": "Consider clarifying the current and expected values in the exception message.", "author": "idelpivnitskiy", "createdAt": "2020-06-09T07:36:45Z", "path": "handler/src/main/java/io/netty/handler/ssl/OpenSslSessionCache.java", "diffHunk": "@@ -0,0 +1,256 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.ssl;\n+\n+import io.netty.internal.tcnative.SSLSessionCache;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+import javax.net.ssl.SSLException;\n+import javax.net.ssl.SSLSession;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+\n+/**\n+ * {@link SSLSessionCache} implementation for our native SSL implementation.\n+ */\n+class OpenSslSessionCache implements SSLSessionCache {\n+    private static final int DEFAULT_CACHE_SIZE;\n+    static {\n+        // Respect the same system property as the JDK implementation to make it easy to switch between implementations.\n+        int cacheSize = SystemPropertyUtil.getInt(\"javax.net.ssl.sessionCacheSize\", 20480);\n+        if (cacheSize >= 0) {\n+            DEFAULT_CACHE_SIZE = cacheSize;\n+        } else {\n+            DEFAULT_CACHE_SIZE = 20480;\n+        }\n+    }\n+\n+    private final OpenSslEngineMap engineMap;\n+\n+    private final Map<OpenSslSessionId, OpenSslSession> sessions =\n+            new LinkedHashMap<OpenSslSessionId, OpenSslSession>() {\n+\n+                private static final long serialVersionUID = -7773696788135734448L;\n+\n+                @Override\n+        protected boolean removeEldestEntry(Map.Entry<OpenSslSessionId, OpenSslSession> eldest) {\n+            int maxSize = maximumCacheSize.get();\n+            if (maxSize >= 0 && this.size() > maxSize) {\n+                OpenSslSession session = eldest.getValue();\n+                sessionRemoved(session);\n+                session.release();\n+                return true;\n+            }\n+            return false;\n+        }\n+    };\n+\n+    private final AtomicInteger maximumCacheSize = new AtomicInteger(DEFAULT_CACHE_SIZE);\n+\n+    // Let's use the same default value as OpenSSL does.\n+    // See https://www.openssl.org/docs/man1.1.1/man3/SSL_get_default_timeout.html\n+    private volatile int sessionTimeout = 300;\n+    private int sessionCounter;\n+\n+    OpenSslSessionCache(OpenSslEngineMap engineMap) {\n+        this.engineMap = engineMap;\n+    }\n+\n+    void setSessionTimeout(int seconds) {\n+        if (seconds < 0) {\n+            throw new IllegalArgumentException();", "originalCommit": "c534860ad4f6c78c359dacc339704e9998bc2f24", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE5Nzc2Nw==", "url": "https://github.com/netty/netty/pull/10331#discussion_r437197767", "bodyText": "Consider clarifying the current and expected values in the exception message.", "author": "idelpivnitskiy", "createdAt": "2020-06-09T07:36:52Z", "path": "handler/src/main/java/io/netty/handler/ssl/OpenSslSessionCache.java", "diffHunk": "@@ -0,0 +1,256 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.ssl;\n+\n+import io.netty.internal.tcnative.SSLSessionCache;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+import javax.net.ssl.SSLException;\n+import javax.net.ssl.SSLSession;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+\n+/**\n+ * {@link SSLSessionCache} implementation for our native SSL implementation.\n+ */\n+class OpenSslSessionCache implements SSLSessionCache {\n+    private static final int DEFAULT_CACHE_SIZE;\n+    static {\n+        // Respect the same system property as the JDK implementation to make it easy to switch between implementations.\n+        int cacheSize = SystemPropertyUtil.getInt(\"javax.net.ssl.sessionCacheSize\", 20480);\n+        if (cacheSize >= 0) {\n+            DEFAULT_CACHE_SIZE = cacheSize;\n+        } else {\n+            DEFAULT_CACHE_SIZE = 20480;\n+        }\n+    }\n+\n+    private final OpenSslEngineMap engineMap;\n+\n+    private final Map<OpenSslSessionId, OpenSslSession> sessions =\n+            new LinkedHashMap<OpenSslSessionId, OpenSslSession>() {\n+\n+                private static final long serialVersionUID = -7773696788135734448L;\n+\n+                @Override\n+        protected boolean removeEldestEntry(Map.Entry<OpenSslSessionId, OpenSslSession> eldest) {\n+            int maxSize = maximumCacheSize.get();\n+            if (maxSize >= 0 && this.size() > maxSize) {\n+                OpenSslSession session = eldest.getValue();\n+                sessionRemoved(session);\n+                session.release();\n+                return true;\n+            }\n+            return false;\n+        }\n+    };\n+\n+    private final AtomicInteger maximumCacheSize = new AtomicInteger(DEFAULT_CACHE_SIZE);\n+\n+    // Let's use the same default value as OpenSSL does.\n+    // See https://www.openssl.org/docs/man1.1.1/man3/SSL_get_default_timeout.html\n+    private volatile int sessionTimeout = 300;\n+    private int sessionCounter;\n+\n+    OpenSslSessionCache(OpenSslEngineMap engineMap) {\n+        this.engineMap = engineMap;\n+    }\n+\n+    void setSessionTimeout(int seconds) {\n+        if (seconds < 0) {\n+            throw new IllegalArgumentException();\n+        }\n+        sessionTimeout = seconds;\n+    }\n+\n+    int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    /**\n+     * Called once a new {@link OpenSslSession} was created.\n+     *\n+     * @param session the new session.\n+     * @return {@code true} if the session should be cached, {@code false} otherwise.\n+     */\n+    protected boolean sessionCreated(OpenSslSession session) {\n+        return true;\n+    }\n+\n+    /**\n+     * Called once an {@link OpenSslSession} was removed from the cache.\n+     *\n+     * @param session the session to remove.\n+     */\n+    protected void sessionRemoved(OpenSslSession session) { }\n+\n+    final void setSessionCacheSize(int size) {\n+        if (size < 0) {\n+            throw new IllegalArgumentException();", "originalCommit": "c534860ad4f6c78c359dacc339704e9998bc2f24", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE5OTM4Mg==", "url": "https://github.com/netty/netty/pull/10331#discussion_r437199382", "bodyText": "Same comment as for the client:\n\n\nWhy only positive numbers? Zero is also a legit value.\nNegative values should throw an IllegalArgumetException, consider verifying input parameters from public API of SslContextBuilder or OpenSslClientContext ctors.\n\n\nDoes that mean that we have an external cache for the server side as well?", "author": "idelpivnitskiy", "createdAt": "2020-06-09T07:39:56Z", "path": "handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslServerContext.java", "diffHunk": "@@ -178,6 +179,14 @@ static OpenSslServerSessionContext newSessionContext(ReferenceCountedOpenSslCont\n \n             OpenSslServerSessionContext sessionContext = new OpenSslServerSessionContext(thiz, keyMaterialProvider);\n             sessionContext.setSessionIdContext(ID);\n+            // Enable session caching by default\n+            sessionContext.setSessionCacheEnabled(true);\n+            if (sessionCacheSize > 0) {\n+                sessionContext.setSessionCacheSize((int) Math.min(sessionCacheSize, Integer.MAX_VALUE));\n+            }\n+            if (sessionTimeout > 0) {", "originalCommit": "c534860ad4f6c78c359dacc339704e9998bc2f24", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ4NTIyNA==", "url": "https://github.com/netty/netty/pull/10331#discussion_r437485224", "bodyText": "yes... we use the same \"mechanism\" for client and server.", "author": "normanmaurer", "createdAt": "2020-06-09T14:51:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE5OTM4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzIwMjUyOA==", "url": "https://github.com/netty/netty/pull/10331#discussion_r437202528", "bodyText": "IIRC the session reuse for TLSv1.3 should work in the same was as session id from the OpenSSL API point of view, only time of receiving PSK is different. Are you going to work on session resumption for TLSv1.3 in a follow-up?", "author": "idelpivnitskiy", "createdAt": "2020-06-09T07:45:36Z", "path": "handler/src/test/java/io/netty/handler/ssl/SslHandlerTest.java", "diffHunk": "@@ -1214,11 +1245,18 @@ public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n                                 }\n                             });\n                         }\n-                    }).connect(sc.localAddress());\n+                    }).connect(serverAddress);\n             cc = future.syncUninterruptibly().channel();\n \n-            assertTrue(clientSslHandler.handshakeFuture().await().isSuccess());\n-            assertTrue(serverSslHandler.handshakeFuture().await().isSuccess());\n+            assertTrue(clientSslHandler.handshakeFuture().sync().isSuccess());\n+\n+            ReferenceCountedOpenSslEngine engine = (ReferenceCountedOpenSslEngine) clientSslHandler.engine();\n+            // This test only works for non TLSv1.3 as TLSv1.3 will establish sessions after\n+            // the handshake is done.\n+            // See https://www.openssl.org/docs/man1.1.1/man3/SSL_CTX_sess_set_get_cb.html\n+            if (!SslUtils.PROTOCOL_TLS_V1_3.equals(engine.getSession().getProtocol())) {", "originalCommit": "c534860ad4f6c78c359dacc339704e9998bc2f24", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ4NTc5Nw==", "url": "https://github.com/netty/netty/pull/10331#discussion_r437485797", "bodyText": "it already works... I just need to come up with a unit test as you can not assume the session is sent when the handshake completes.", "author": "normanmaurer", "createdAt": "2020-06-09T14:52:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzIwMjUyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzIwMzI3MA==", "url": "https://github.com/netty/netty/pull/10331#discussion_r437203270", "bodyText": "If this a ref-counted object, should retain() also perform io.netty.internal.tcnative.SSLSession.upRef?", "author": "idelpivnitskiy", "createdAt": "2020-06-09T07:46:55Z", "path": "handler/src/main/java/io/netty/handler/ssl/DefaultOpenSslSession.java", "diffHunk": "@@ -0,0 +1,349 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.ssl;\n+\n+import io.netty.internal.tcnative.SSLSession;\n+import io.netty.util.AbstractReferenceCounted;\n+import io.netty.util.ReferenceCounted;\n+import io.netty.util.internal.EmptyArrays;\n+import io.netty.util.internal.ObjectUtil;\n+import io.netty.util.internal.StringUtil;\n+\n+import javax.net.ssl.SSLPeerUnverifiedException;\n+import javax.net.ssl.SSLSessionBindingEvent;\n+import javax.net.ssl.SSLSessionBindingListener;\n+import javax.security.cert.X509Certificate;\n+import java.security.Principal;\n+import java.security.cert.Certificate;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+final class DefaultOpenSslSession extends AbstractReferenceCounted implements ReferenceCounted, OpenSslSession {\n+\n+    private final OpenSslSessionContext sessionContext;\n+    private final String peerHost;\n+    private final int peerPort;\n+    private final OpenSslSessionId id;\n+    private final X509Certificate[] x509PeerCerts;\n+    private final Certificate[] peerCerts;\n+    private final String protocol;\n+    private final String cipher;\n+    private final long sslSession;\n+    private final long creationTime;\n+    private final long timeout;\n+\n+    private volatile int applicationBufferSize = ReferenceCountedOpenSslEngine.MAX_PLAINTEXT_LENGTH;\n+    private volatile int packetBufferSize = ReferenceCountedOpenSslEngine.MAX_RECORD_SIZE;\n+    private volatile long lastAccessed;\n+    private volatile Certificate[] localCertificateChain;\n+    private volatile boolean invalid;\n+\n+    // Guarded by synchronized(this)\n+    // lazy init for memory reasons\n+    private Map<String, Object> values;\n+\n+    DefaultOpenSslSession(OpenSslSessionContext sessionContext, String peerHost, int peerPort, long sslSession,\n+                          String version,\n+                          String cipher,\n+                          OpenSslJavaxX509Certificate[] x509PeerCerts,\n+                          long creationTime, long timeout) {\n+        this.sessionContext = sessionContext;\n+        this.peerHost = peerHost;\n+        this.peerPort = peerPort;\n+        this.id = new OpenSslSessionId(id(sslSession));\n+        this.sslSession = sslSession;\n+        this.cipher = cipher == null ? SslUtils.INVALID_CIPHER : cipher;\n+        this.x509PeerCerts = x509PeerCerts;\n+        if (x509PeerCerts != null) {\n+            peerCerts = new Certificate[x509PeerCerts.length];\n+            for (int i = 0; i < peerCerts.length; i++) {\n+                peerCerts[i] = new OpenSslX509Certificate(x509PeerCerts[i].getBytes());\n+            }\n+        } else {\n+            peerCerts = null;\n+        }\n+        this.protocol = version == null ? StringUtil.EMPTY_STRING : version;\n+        this.creationTime = creationTime;\n+        this.lastAccessed = creationTime;\n+        this.timeout = timeout;\n+    }\n+\n+    private static byte[] id(long sslSession) {\n+        if (sslSession == -1) {\n+            return EmptyArrays.EMPTY_BYTES;\n+        }\n+        byte[] id = io.netty.internal.tcnative.SSLSession.getSessionId(sslSession);\n+        return id == null ? EmptyArrays.EMPTY_BYTES : id;\n+    }\n+\n+    @Override\n+    public OpenSslSessionContext getSessionContext() {\n+        return sessionContext;\n+    }\n+\n+    @Override\n+    public void putValue(String name, Object value) {\n+        ObjectUtil.checkNotNull(name, \"name\");\n+        ObjectUtil.checkNotNull(value, \"value\");\n+\n+        final Object old;\n+        synchronized (this) {\n+            Map<String, Object> values = this.values;\n+            if (values == null) {\n+                // Use size of 2 to keep the memory overhead small\n+                values = this.values = new HashMap<String, Object>(2);\n+            }\n+            old = values.put(name, value);\n+        }\n+\n+        if (value instanceof SSLSessionBindingListener) {\n+            ((SSLSessionBindingListener) value).valueBound(new SSLSessionBindingEvent(this, name));\n+        }\n+        notifyUnbound(old, name);\n+    }\n+\n+    @Override\n+    public Object getValue(String name) {\n+        ObjectUtil.checkNotNull(name, \"name\");\n+        synchronized (this) {\n+            if (values == null) {\n+                return null;\n+            }\n+            return values.get(name);\n+        }\n+    }\n+\n+    @Override\n+    public void removeValue(String name) {\n+        ObjectUtil.checkNotNull(name, \"name\");\n+\n+        final Object old;\n+        synchronized (this) {\n+            Map<String, Object> values = this.values;\n+            if (values == null) {\n+                return;\n+            }\n+            old = values.remove(name);\n+        }\n+\n+        notifyUnbound(old, name);\n+    }\n+\n+    @Override\n+    public String[] getValueNames() {\n+        synchronized (this) {\n+            Map<String, Object> values = this.values;\n+            if (values == null || values.isEmpty()) {\n+                return EmptyArrays.EMPTY_STRINGS;\n+            }\n+            return values.keySet().toArray(new String[0]);\n+        }\n+    }\n+\n+    private void notifyUnbound(Object value, String name) {\n+        if (value instanceof SSLSessionBindingListener) {\n+            ((SSLSessionBindingListener) value).valueUnbound(new SSLSessionBindingEvent(this, name));\n+        }\n+    }\n+\n+    @Override\n+    public String getPeerHost() {\n+        return peerHost;\n+    }\n+\n+    @Override\n+    public int getPeerPort() {\n+        return peerPort;\n+    }\n+\n+    @Override\n+    public OpenSslSessionId sessionId() {\n+        return id;\n+    }\n+\n+    @Override\n+    public byte[] getId() {\n+        return sessionId().cloneBytes();\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return sessionId().hashCode();\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (!(obj instanceof OpenSslSession)) {\n+            return false;\n+        }\n+        return sessionId().equals(((OpenSslSession) obj).sessionId());\n+    }\n+\n+    @Override\n+    public boolean isNullSession() {\n+        return false;\n+    }\n+\n+    @Override\n+    public long getCreationTime() {\n+        return creationTime;\n+    }\n+\n+    @Override\n+    public long getLastAccessedTime() {\n+        return lastAccessed;\n+    }\n+\n+    @Override\n+    public void invalidate() {\n+        invalid = true;\n+    }\n+\n+    @Override\n+    public boolean isValid() {\n+        if (sslSession == -1 || invalid) {\n+            return false;\n+        }\n+\n+        // Never timeout\n+        if (timeout == 0) {\n+            return true;\n+        }\n+\n+        long current = System.currentTimeMillis();\n+        return current - timeout < creationTime;\n+    }\n+\n+    @Override\n+    public long nativeAddr() {\n+        return sslSession;\n+    }\n+\n+    @Override\n+    public void setLocalCertificate(Certificate[] localCertificate) {\n+        this.localCertificateChain = localCertificate;\n+    }\n+\n+    @Override\n+    public void setPacketBufferSize(int packetBufferSize) {\n+        this.packetBufferSize = packetBufferSize;\n+    }\n+\n+    @Override\n+    public void updateLastAccessedTime() {\n+        lastAccessed = System.currentTimeMillis();\n+    }\n+\n+    @Override\n+    public Certificate[] getPeerCertificates() throws SSLPeerUnverifiedException {\n+        if (SslUtils.isEmpty(peerCerts)) {\n+            throw new SSLPeerUnverifiedException(\"peer not verified\");\n+        }\n+        return peerCerts.clone();\n+    }\n+\n+    @Override\n+    public Certificate[] getLocalCertificates() {\n+        Certificate[] localCerts = localCertificateChain;\n+        if (localCerts == null) {\n+            return null;\n+        }\n+        return localCerts.clone();\n+    }\n+\n+    @Override\n+    public X509Certificate[] getPeerCertificateChain() throws SSLPeerUnverifiedException {\n+        if (SslUtils.isEmpty(x509PeerCerts)) {\n+            throw new SSLPeerUnverifiedException(\"peer not verified\");\n+        }\n+        return x509PeerCerts.clone();\n+    }\n+\n+    @Override\n+    public Principal getPeerPrincipal() throws SSLPeerUnverifiedException {\n+        Certificate[] peer = getPeerCertificates();\n+        // No need for null or length > 0 is needed as this is done in getPeerCertificates()\n+        // already.\n+        return ((java.security.cert.X509Certificate) peer[0]).getSubjectX500Principal();\n+    }\n+\n+    @Override\n+    public Principal getLocalPrincipal() {\n+        Certificate[] local = localCertificateChain;\n+        if (SslUtils.isEmpty(local)) {\n+            return null;\n+        }\n+        return ((java.security.cert.X509Certificate) local[0]).getIssuerX500Principal();\n+    }\n+\n+    @Override\n+    public String getCipherSuite() {\n+        return cipher;\n+    }\n+\n+    @Override\n+    public String getProtocol() {\n+        return protocol;\n+    }\n+\n+    @Override\n+    public int getPacketBufferSize() {\n+        return packetBufferSize;\n+    }\n+\n+    @Override\n+    public int getApplicationBufferSize() {\n+        return applicationBufferSize;\n+    }\n+\n+    @Override\n+    public void tryExpandApplicationBufferSize(int packetLengthDataOnly) {\n+        if (packetLengthDataOnly > ReferenceCountedOpenSslEngine.MAX_PLAINTEXT_LENGTH &&\n+                applicationBufferSize != ReferenceCountedOpenSslEngine.MAX_RECORD_SIZE) {\n+            applicationBufferSize = ReferenceCountedOpenSslEngine.MAX_RECORD_SIZE;\n+        }\n+    }\n+\n+    @Override\n+    protected void deallocate() {\n+        if (sslSession != -1) {\n+            SSLSession.free(sslSession);\n+        }\n+    }\n+\n+    @Override\n+    public DefaultOpenSslSession touch() {\n+        super.touch();\n+        return this;\n+    }\n+\n+    @Override\n+    public DefaultOpenSslSession touch(Object hint) {\n+        return this;\n+    }\n+\n+    @Override\n+    public DefaultOpenSslSession retain() {\n+        super.retain();", "originalCommit": "c534860ad4f6c78c359dacc339704e9998bc2f24", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ4NjEyNw==", "url": "https://github.com/netty/netty/pull/10331#discussion_r437486127", "bodyText": "nope... We only reference count the java object itself to simplify things here.", "author": "normanmaurer", "createdAt": "2020-06-09T14:52:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzIwMzI3MA=="}], "type": "inlineReview"}, {"oid": "d92883c7c13d5b8abe8f5b5216dcc2efa9e82c25", "url": "https://github.com/netty/netty/commit/d92883c7c13d5b8abe8f5b5216dcc2efa9e82c25", "message": "Test fixes", "committedDate": "2020-06-25T13:29:12Z", "type": "forcePushed"}, {"oid": "c57927a2f4a28e36ba95e0d81f0b5c53b7cfbcb2", "url": "https://github.com/netty/netty/commit/c57927a2f4a28e36ba95e0d81f0b5c53b7cfbcb2", "message": "Test fixes", "committedDate": "2020-06-25T20:21:27Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQzOTA5Ng==", "url": "https://github.com/netty/netty/pull/10331#discussion_r446439096", "bodyText": "Accidental move :)", "author": "idelpivnitskiy", "createdAt": "2020-06-26T22:36:06Z", "path": "handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslContext.java", "diffHunk": "@@ -272,7 +272,7 @@ protected void deallocate() {\n                           // This also let SSLSession.getId() work the same way for the JDK implementation and the\n                           // OpenSSLEngine. If tickets are supported SSLSession.getId() will only return an ID on the\n                           // server-side if it could make use of tickets.\n-                         SSL.SSL_OP_NO_TICKET;\n+                           SSL.SSL_OP_NO_TICKET;", "originalCommit": "6c6b4ae89be050f621accd23d3a2eca5cb6846c0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQzOTU5MQ==", "url": "https://github.com/netty/netty/pull/10331#discussion_r446439591", "bodyText": "Btw, should we enable tickets by default when users specify TLSv1.3 version in the list of protocols? That will be more inline with JDK.", "author": "idelpivnitskiy", "createdAt": "2020-06-26T22:38:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQzOTA5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjgxOTA1NA==", "url": "https://github.com/netty/netty/pull/10331#discussion_r446819054", "bodyText": "good question... is this the case for TLSv1.3 in JDK ?", "author": "normanmaurer", "createdAt": "2020-06-29T07:16:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQzOTA5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk4MTM3NA==", "url": "https://github.com/netty/netty/pull/10331#discussion_r446981374", "bodyText": "With JDK provider tickets just work when users specify TLSv1.3 protocol. No additional configuration is necessary.", "author": "idelpivnitskiy", "createdAt": "2020-06-29T13:43:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQzOTA5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk5MzUwNQ==", "url": "https://github.com/netty/netty/pull/10331#discussion_r448993505", "bodyText": "ok ... done", "author": "normanmaurer", "createdAt": "2020-07-02T13:16:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQzOTA5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ0MTg4MQ==", "url": "https://github.com/netty/netty/pull/10331#discussion_r446441881", "bodyText": "If you use equalsIgnoreCase here, the host.hashCode() should also ignore case.", "author": "idelpivnitskiy", "createdAt": "2020-06-26T22:47:34Z", "path": "handler/src/main/java/io/netty/handler/ssl/OpenSslClientSessionCache.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.ssl;\n+\n+import javax.net.ssl.SSLException;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * {@link OpenSslSessionCache} that is used by the client-side.\n+ */\n+final class OpenSslClientSessionCache extends OpenSslSessionCache {\n+    // TODO: Should we support to have a List of OpenSslSessions for a Host/Port key and so be able to\n+    // support sessions for different protocols / ciphers to the same remote peer ?\n+    private final Map<HostPort, OpenSslSession> sessions = new HashMap<HostPort, OpenSslSession>();\n+\n+    OpenSslClientSessionCache(OpenSslEngineMap engineMap) {\n+        super(engineMap);\n+    }\n+\n+    @Override\n+    protected boolean sessionCreated(OpenSslSession session) {\n+        assert Thread.holdsLock(this);\n+        String host = session.getPeerHost();\n+        int port = session.getPeerPort();\n+        if (host == null || port == -1) {\n+            return false;\n+        }\n+        HostPort hostPort = new HostPort(host, port);\n+        if (sessions.containsKey(hostPort)) {\n+            return false;\n+        }\n+        sessions.put(hostPort, session);\n+        return true;\n+    }\n+\n+    @Override\n+    protected void sessionRemoved(OpenSslSession session) {\n+        assert Thread.holdsLock(this);\n+        String host = session.getPeerHost();\n+        int port = session.getPeerPort();\n+        if (host == null || port == -1) {\n+            return;\n+        }\n+        sessions.remove(new HostPort(host, port));\n+    }\n+\n+    private static boolean isProtocolEnabled(OpenSslSession session, String[] enabledProtocols) {\n+        return arrayContains(session.getProtocol(), enabledProtocols);\n+    }\n+\n+    private static boolean isCipherSuiteEnabled(OpenSslSession session, String[] enabledCipherSuites) {\n+        return arrayContains(session.getCipherSuite(), enabledCipherSuites);\n+    }\n+\n+    private static boolean arrayContains(String expected, String[] array) {\n+        for (int i = 0; i < array.length; ++i) {\n+            String value = array[i];\n+            if (value.equals(expected)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    void setSession(ReferenceCountedOpenSslEngine engine) throws SSLException {\n+        String host = engine.getPeerHost();\n+        int port = engine.getPeerPort();\n+        if (host == null || port == -1) {\n+            return;\n+        }\n+        HostPort hostPort = new HostPort(host, port);\n+        synchronized (this) {\n+            OpenSslSession session = sessions.get(hostPort);\n+\n+            if (session == null) {\n+                return;\n+            }\n+            if (!session.isValid()) {\n+                removeSession(session);\n+                return;\n+            }\n+\n+            // Ensure the protocol and ciphersuite can be used.\n+            if (!isProtocolEnabled(session, engine.getEnabledProtocols()) ||\n+                    !isCipherSuiteEnabled(session, engine.getEnabledCipherSuites())) {\n+                return;\n+            }\n+\n+            // Try to set the session, if true is returned we retained the session and incremented the reference count\n+            // of the underlying SSL_SESSION*.\n+            if (engine.setSession(session)) {\n+                session.updateLastAccessedTime();\n+\n+                if (io.netty.internal.tcnative.SSLSession.shouldBeSingleUse(session.nativeAddr())) {\n+                    // Should only be re-used once so remove it from the cache\n+                    removeSession(session);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Host / Port tuple used to find a {@link OpenSslSession} in the cache.\n+     */\n+    private static final class HostPort {\n+        private final String host;\n+        private final int port;\n+\n+        HostPort(String host, int port) {\n+            this.host = host;\n+            this.port = port;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            int result = host.hashCode();\n+            result = 31 * result + port;\n+            return result;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (!(obj instanceof HostPort)) {\n+                return false;\n+            }\n+            HostPort other = (HostPort) obj;\n+            return port == other.port && host.equalsIgnoreCase(other.host);", "originalCommit": "6c6b4ae89be050f621accd23d3a2eca5cb6846c0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjgxODc4Mg==", "url": "https://github.com/netty/netty/pull/10331#discussion_r446818782", "bodyText": "Good catch...", "author": "normanmaurer", "createdAt": "2020-06-29T07:16:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ0MTg4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ0NzY2OQ==", "url": "https://github.com/netty/netty/pull/10331#discussion_r446447669", "bodyText": "This methods may invoke freeSessions() internally. In all other cases you protect the freeSessions with write lock. Do we need a lock here as well?", "author": "idelpivnitskiy", "createdAt": "2020-06-26T23:12:56Z", "path": "handler/src/main/java/io/netty/handler/ssl/OpenSslSessionContext.java", "diffHunk": "@@ -41,30 +40,73 @@\n     private final OpenSslKeyMaterialProvider provider;\n \n     final ReferenceCountedOpenSslContext context;\n+    final OpenSslNullSession nullSession;\n+\n+    final OpenSslSessionCache sessionCache;\n+    private final long mask;\n \n     // IMPORTANT: We take the OpenSslContext and not just the long (which points the native instance) to prevent\n     //            the GC to collect OpenSslContext as this would also free the pointer and so could result in a\n     //            segfault when the user calls any of the methods here that try to pass the pointer down to the native\n     //            level.\n-    OpenSslSessionContext(ReferenceCountedOpenSslContext context, OpenSslKeyMaterialProvider provider) {\n+    OpenSslSessionContext(ReferenceCountedOpenSslContext context, OpenSslKeyMaterialProvider provider, long mask,\n+                          OpenSslSessionCache cache) {\n         this.context = context;\n         this.provider = provider;\n+        this.mask = mask;\n         stats = new OpenSslSessionStats(context);\n+        sessionCache = cache;\n+        // If we do not use the KeyManagerFactory we need to set localCertificateChain now.\n+        // When we use a KeyManagerFactory it will be set during setKeyMaterial(...).\n+        nullSession = new OpenSslNullSession(this, provider == null ? context.keyCertChain : null);\n+        SSLContext.setSSLSessionCache(context.ctx, cache);\n+    }\n+\n+    final DefaultOpenSslSession newOpenSslSession(long sslSession, String peerHost,\n+                                            int peerPort, String protocol, String cipher,\n+                                            OpenSslJavaxX509Certificate[] peerCertificateChain, long creationTime) {\n+        return sessionCache.newOpenSslSession(sslSession, this, peerHost, peerPort, protocol, cipher,\n+                peerCertificateChain, creationTime);\n+    }\n+\n+    @Override\n+    public void setSessionCacheSize(int size) {\n+        ObjectUtil.checkPositiveOrZero(size, \"size\");\n+        sessionCache.setSessionCacheSize(size);", "originalCommit": "6c6b4ae89be050f621accd23d3a2eca5cb6846c0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjgyMDExOQ==", "url": "https://github.com/netty/netty/pull/10331#discussion_r446820119", "bodyText": "freeSessions() is defined as synchronized is this not good enough ?", "author": "normanmaurer", "createdAt": "2020-06-29T07:19:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ0NzY2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk4MjA4Nw==", "url": "https://github.com/netty/netty/pull/10331#discussion_r446982087", "bodyText": "missed that, \ud83d\udc4d", "author": "idelpivnitskiy", "createdAt": "2020-06-29T13:44:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ0NzY2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ1MjI4MA==", "url": "https://github.com/netty/netty/pull/10331#discussion_r446452280", "bodyText": "Should we throw if the requested sessionCacheSize/sessionTimeout  is higher than Integer.MAX_VALUE? Or at least log it? Silent override may be confusing.", "author": "idelpivnitskiy", "createdAt": "2020-06-26T23:37:32Z", "path": "handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslClientContext.java", "diffHunk": "@@ -170,6 +172,15 @@ static OpenSslSessionContext newSessionContext(ReferenceCountedOpenSslContext th\n                 throw new SSLException(\"unable to setup trustmanager\", e);\n             }\n             OpenSslClientSessionContext context = new OpenSslClientSessionContext(thiz, keyMaterialProvider);\n+            // Enable session caching by default\n+            context.setSessionCacheEnabled(true);\n+            if (sessionCacheSize > 0) {\n+                context.setSessionCacheSize((int) Math.min(sessionCacheSize, Integer.MAX_VALUE));\n+            }\n+            if (sessionTimeout > 0) {\n+                context.setSessionTimeout((int) Math.min(sessionTimeout, Integer.MAX_VALUE));", "originalCommit": "6c6b4ae89be050f621accd23d3a2eca5cb6846c0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjgxOTMxMQ==", "url": "https://github.com/netty/netty/pull/10331#discussion_r446819311", "bodyText": "this is the same code we use for the JDK implementation. Let me think about it and make a follow up if needed to keep it consistent.", "author": "normanmaurer", "createdAt": "2020-06-29T07:17:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ1MjI4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ1MzI1Mg==", "url": "https://github.com/netty/netty/pull/10331#discussion_r446453252", "bodyText": "Can we verify that a single session available in cache is reused for a.netty.io?", "author": "idelpivnitskiy", "createdAt": "2020-06-26T23:43:12Z", "path": "handler/src/test/java/io/netty/handler/ssl/SSLEngineTest.java", "diffHunk": "@@ -2900,6 +2900,259 @@ public void testGetCiphersuite() throws Exception {\n         }\n     }\n \n+    @Test\n+    public void testSessionCacheForTLS12() throws Exception {\n+        // This test only works for TLSv1.2 as TLSv1.3 will establish sessions after the handshake is done.\n+        // See https://www.openssl.org/docs/man1.1.1/man3/SSL_CTX_sess_set_get_cb.html\n+        if (protocolCipherCombo != ProtocolCipherCombo.TLSV12) {\n+            return;\n+        }\n+        clientSslCtx = wrapContext(SslContextBuilder.forClient()\n+                .trustManager(InsecureTrustManagerFactory.INSTANCE)\n+                .sslProvider(sslClientProvider())\n+                .sslContextProvider(clientSslContextProvider())\n+                .protocols(protocols())\n+                .ciphers(ciphers())\n+                .build());\n+        SelfSignedCertificate ssc = new SelfSignedCertificate();\n+        serverSslCtx = wrapContext(SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey())\n+                .sslProvider(sslServerProvider())\n+                .sslContextProvider(serverSslContextProvider())\n+                .protocols(protocols())\n+                .ciphers(ciphers())\n+                .build());\n+\n+        try {\n+            doHandshakeVerifyReusedAndClose(\"a.netty.io\", 9999, false);\n+            doHandshakeVerifyReusedAndClose(\"a.netty.io\", 9999, true);\n+            doHandshakeVerifyReusedAndClose(\"b.netty.io\", 9999, false);\n+            invalidateSessionsAndAssert(serverSslCtx.sessionContext());\n+            invalidateSessionsAndAssert(clientSslCtx.sessionContext());\n+        } finally {\n+            ssc.delete();\n+        }\n+    }\n+\n+    protected void invalidateSessionsAndAssert(SSLSessionContext context) {\n+        Enumeration<byte[]> ids = context.getIds();\n+        while (ids.hasMoreElements()) {\n+            byte[] id = ids.nextElement();\n+            SSLSession session = context.getSession(id);\n+            session.invalidate();\n+            assertFalse(session.isValid());\n+            assertNull(context.getSession(id));\n+        }\n+    }\n+\n+    private static void assertSessionCache(SSLSessionContext sessionContext, int numSessions) {\n+        Enumeration<byte[]> ids = sessionContext.getIds();\n+        int numIds = 0;\n+        while (ids.hasMoreElements()) {\n+            numIds++;\n+            byte[] id = ids.nextElement();\n+            assertNotEquals(0, id.length);\n+            SSLSession session = sessionContext.getSession(id);\n+            assertArrayEquals(id, session.getId());\n+        }\n+        assertEquals(numSessions, numIds);\n+    }\n+\n+    private void doHandshakeVerifyReusedAndClose(String host, int port, boolean reuse)\n+            throws Exception {\n+        SSLEngine clientEngine = null;\n+        SSLEngine serverEngine = null;\n+        try {\n+            clientEngine = wrapEngine(clientSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT, host, port));\n+            serverEngine = wrapEngine(serverSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));\n+            handshake(clientEngine, serverEngine);\n+            int clientSessions = currentSessionCacheSize(clientSslCtx.sessionContext());\n+            int serverSessions = currentSessionCacheSize(serverSslCtx.sessionContext());\n+            int nCSessions = clientSessions;\n+            int nSSessions = serverSessions;\n+            if (protocolCipherCombo == ProtocolCipherCombo.TLSV13) {\n+                ByteBuffer packetBuffer = allocateBuffer(32 * 1024);\n+                ByteBuffer appBuffer = allocateBuffer(32 * 1024);\n+\n+                appBuffer.clear().position(4).flip();\n+                packetBuffer.clear();\n+\n+                do {\n+                    SSLEngineResult result;\n+\n+                    do {\n+                        result = serverEngine.wrap(appBuffer, packetBuffer);\n+                    } while (appBuffer.hasRemaining() || result.bytesProduced() > 0);\n+\n+                    appBuffer.clear();\n+                    packetBuffer.flip();\n+                    do {\n+                        result = clientEngine.unwrap(packetBuffer, appBuffer);\n+                    } while (packetBuffer.hasRemaining() || result.bytesProduced() > 0);\n+\n+                    packetBuffer.clear();\n+                    appBuffer.clear().position(4).flip();\n+\n+                    do {\n+                        result = clientEngine.wrap(appBuffer, packetBuffer);\n+                    } while (appBuffer.hasRemaining() || result.bytesProduced() > 0);\n+\n+                    appBuffer.clear();\n+                    packetBuffer.flip();\n+\n+                    do {\n+                        result = serverEngine.unwrap(packetBuffer, appBuffer);\n+                    } while (packetBuffer.hasRemaining() || result.bytesProduced() > 0);\n+\n+                    packetBuffer.clear();\n+                    appBuffer.clear().position(4).flip();\n+                    nCSessions = currentSessionCacheSize(clientSslCtx.sessionContext());\n+                    nSSessions = currentSessionCacheSize(serverSslCtx.sessionContext());\n+                } while (!reuse && (nCSessions < clientSessions ||\n+                        // server may use multiple sessions\n+                        nSSessions < serverSessions));\n+            }\n+\n+            assertSessionReusedForEngine(clientEngine, serverEngine, reuse);\n+\n+            closeOutboundAndInbound(clientEngine, serverEngine);\n+        } finally {\n+            cleanupClientSslEngine(clientEngine);\n+            cleanupServerSslEngine(serverEngine);\n+        }\n+    }\n+\n+    private static int currentSessionCacheSize(SSLSessionContext ctx) {\n+        Enumeration<byte[]> ids = ctx.getIds();\n+        int i = 0;\n+        while (ids.hasMoreElements()) {\n+            i++;\n+            ids.nextElement();\n+        }\n+        return i;\n+    }\n+\n+    private void closeOutboundAndInbound(SSLEngine clientEngine, SSLEngine serverEngine) throws SSLException {\n+        assertFalse(clientEngine.isInboundDone());\n+        assertFalse(clientEngine.isOutboundDone());\n+        assertFalse(serverEngine.isInboundDone());\n+        assertFalse(serverEngine.isOutboundDone());\n+\n+        ByteBuffer empty = allocateBuffer(0);\n+        ByteBuffer cTOs = allocateBuffer(clientEngine.getSession().getPacketBufferSize());\n+        ByteBuffer sTOs = allocateBuffer(serverEngine.getSession().getPacketBufferSize());\n+\n+        ByteBuffer cApps = allocateBuffer(clientEngine.getSession().getApplicationBufferSize());\n+        ByteBuffer sApps = allocateBuffer(serverEngine.getSession().getApplicationBufferSize());\n+\n+        clientEngine.closeOutbound();\n+        for (;;) {\n+            // call wrap till we produced all data\n+            SSLEngineResult result = clientEngine.wrap(empty, cTOs);\n+            if (result.getStatus() == Status.CLOSED && result.bytesProduced() == 0) {\n+                break;\n+            }\n+            assertTrue(cTOs.hasRemaining());\n+        }\n+        cTOs.flip();\n+\n+        for (;;) {\n+            // call unwrap till we consumed all data\n+            SSLEngineResult result = serverEngine.unwrap(cTOs, sApps);\n+            if (result.getStatus() == Status.CLOSED && result.bytesProduced() == 0) {\n+                break;\n+            }\n+            assertTrue(sApps.hasRemaining());\n+        }\n+\n+        serverEngine.closeOutbound();\n+        for (;;) {\n+            // call wrap till we produced all data\n+            SSLEngineResult result = serverEngine.wrap(empty, sTOs);\n+            if (result.getStatus() == Status.CLOSED && result.bytesProduced() == 0) {\n+                break;\n+            }\n+            assertTrue(sTOs.hasRemaining());\n+        }\n+        sTOs.flip();\n+\n+        for (;;) {\n+            // call unwrap till we consumed all data\n+            SSLEngineResult result = clientEngine.unwrap(sTOs, cApps);\n+            if (result.getStatus() == Status.CLOSED && result.bytesProduced() == 0) {\n+                break;\n+            }\n+            assertTrue(cApps.hasRemaining());\n+        }\n+\n+        // Now close the inbound as well\n+        clientEngine.closeInbound();\n+        serverEngine.closeInbound();\n+    }\n+\n+    protected void assertSessionReusedForEngine(SSLEngine clientEngine, SSLEngine serverEngine, boolean reuse) {\n+        // NOOP\n+    }\n+\n+    @Test\n+    public void testSessionCacheTimeout() throws Exception {\n+        clientSslCtx = wrapContext(SslContextBuilder.forClient()\n+                .trustManager(InsecureTrustManagerFactory.INSTANCE)\n+                .sslProvider(sslClientProvider())\n+                .sslContextProvider(clientSslContextProvider())\n+                .protocols(protocols())\n+                .ciphers(ciphers())\n+                .sessionTimeout(1)\n+                .build());\n+        SelfSignedCertificate ssc = new SelfSignedCertificate();\n+        serverSslCtx = wrapContext(SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey())\n+                .sslProvider(sslServerProvider())\n+                .sslContextProvider(serverSslContextProvider())\n+                .protocols(protocols())\n+                .ciphers(ciphers())\n+                .sessionTimeout(1)\n+                .build());\n+\n+        try {\n+            doHandshakeVerifyReusedAndClose(\"a.netty.io\", 9999, false);\n+\n+            // Let's sleep for a bit more then 1 second so the cache should timeout the sessions.\n+            Thread.sleep(1500);\n+\n+            assertSessionCache(serverSslCtx.sessionContext(), 0);\n+            assertSessionCache(clientSslCtx.sessionContext(), 0);\n+        } finally {\n+            ssc.delete();\n+        }\n+    }\n+\n+    @Test\n+    public void testSessionCacheSize() throws Exception {\n+        clientSslCtx = wrapContext(SslContextBuilder.forClient()\n+                .trustManager(InsecureTrustManagerFactory.INSTANCE)\n+                .sslProvider(sslClientProvider())\n+                .sslContextProvider(clientSslContextProvider())\n+                .protocols(protocols())\n+                .ciphers(ciphers())\n+                .sessionCacheSize(1)\n+                .build());\n+        SelfSignedCertificate ssc = new SelfSignedCertificate();\n+        serverSslCtx = wrapContext(SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey())\n+                .sslProvider(sslServerProvider())\n+                .sslContextProvider(serverSslContextProvider())\n+                .protocols(protocols())\n+                .ciphers(ciphers())\n+                .sessionCacheSize(1)\n+                .build());\n+\n+        try {\n+            doHandshakeVerifyReusedAndClose(\"a.netty.io\", 9999, false);\n+            // As we have a cache size of 1 we should never have more then one session in the cache\n+            doHandshakeVerifyReusedAndClose(\"b.netty.io\", 9999, false);", "originalCommit": "6c6b4ae89be050f621accd23d3a2eca5cb6846c0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ1NDA5NA==", "url": "https://github.com/netty/netty/pull/10331#discussion_r446454094", "bodyText": "IIRC, assertions work only from the main thread in junit. You need to store the result in something like integer holder / atomic-integer and then assert from the main thread.", "author": "idelpivnitskiy", "createdAt": "2020-06-26T23:48:01Z", "path": "handler/src/test/java/io/netty/handler/ssl/SslHandlerTest.java", "diffHunk": "@@ -1176,11 +1171,26 @@ private static void testSessionTickets(String protocol, boolean withKey) throws\n                     .childHandler(new ChannelInitializer<Channel>() {\n                         @Override\n                         protected void initChannel(Channel ch) {\n-                            ch.pipeline().addLast(serverSslHandler);\n+                            final SslHandler sslHandler = sslServerCtx.newHandler(ch.alloc());\n+                            ch.pipeline().addLast(sslServerCtx.newHandler(UnpooledByteBufAllocator.DEFAULT));\n                             ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n+\n+                                private int handshakeCount;\n+\n                                 @Override\n                                 public void userEventTriggered(ChannelHandlerContext ctx, Object evt)  {\n                                     if (evt instanceof SslHandshakeCompletionEvent) {\n+                                        handshakeCount++;\n+                                        ReferenceCountedOpenSslEngine engine =\n+                                                (ReferenceCountedOpenSslEngine) sslHandler.engine();\n+                                        // This test only works for non TLSv1.3 as TLSv1.3 will establish sessions after\n+                                        // the handshake is done.\n+                                        // See https://www.openssl.org/docs/man1.1.1/man3/SSL_CTX_sess_set_get_cb.html\n+                                        if (!SslUtils.PROTOCOL_TLS_V1_3.equals(engine.getSession().getProtocol())) {\n+                                            // First should not re-use the session\n+                                            assertEquals(handshakeCount > 1, engine.isSessionReused());", "originalCommit": "6c6b4ae89be050f621accd23d3a2eca5cb6846c0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjgyNDU5MQ==", "url": "https://github.com/netty/netty/pull/10331#discussion_r446824591", "bodyText": "if this fails it would fail the test as we would never write back to the client. That said let me store it in an AtomicReference so it would produce more detail if it failed.", "author": "normanmaurer", "createdAt": "2020-06-29T07:28:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ1NDA5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ1NDQ0Nw==", "url": "https://github.com/netty/netty/pull/10331#discussion_r446454447", "bodyText": "I probably miss it somewhere, but how do you know if the session was reused via session ticket, not session id for TLSv1.2?", "author": "idelpivnitskiy", "createdAt": "2020-06-26T23:49:53Z", "path": "handler/src/test/java/io/netty/handler/ssl/SslHandlerTest.java", "diffHunk": "@@ -1211,11 +1242,18 @@ public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n                                 }\n                             });\n                         }\n-                    }).connect(sc.localAddress());\n+                    }).connect(serverAddress);\n             cc = future.syncUninterruptibly().channel();\n \n-            assertTrue(clientSslHandler.handshakeFuture().await().isSuccess());\n-            assertTrue(serverSslHandler.handshakeFuture().await().isSuccess());\n+            assertTrue(clientSslHandler.handshakeFuture().sync().isSuccess());\n+\n+            ReferenceCountedOpenSslEngine engine = (ReferenceCountedOpenSslEngine) clientSslHandler.engine();\n+            // This test only works for non TLSv1.3 as TLSv1.3 will establish sessions after\n+            // the handshake is done.\n+            // See https://www.openssl.org/docs/man1.1.1/man3/SSL_CTX_sess_set_get_cb.html\n+            if (!SslUtils.PROTOCOL_TLS_V1_3.equals(engine.getSession().getProtocol())) {\n+                assertEquals(isReused, engine.isSessionReused());", "originalCommit": "6c6b4ae89be050f621accd23d3a2eca5cb6846c0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc5OTE5Mg==", "url": "https://github.com/netty/netty/pull/10331#discussion_r447799192", "bodyText": "should this be a defensive copy?", "author": "carl-mastrangelo", "createdAt": "2020-06-30T16:02:27Z", "path": "handler/src/main/java/io/netty/handler/ssl/DefaultOpenSslSession.java", "diffHunk": "@@ -0,0 +1,349 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.ssl;\n+\n+import io.netty.internal.tcnative.SSLSession;\n+import io.netty.util.AbstractReferenceCounted;\n+import io.netty.util.ReferenceCounted;\n+import io.netty.util.internal.EmptyArrays;\n+import io.netty.util.internal.ObjectUtil;\n+import io.netty.util.internal.StringUtil;\n+\n+import javax.net.ssl.SSLPeerUnverifiedException;\n+import javax.net.ssl.SSLSessionBindingEvent;\n+import javax.net.ssl.SSLSessionBindingListener;\n+import javax.security.cert.X509Certificate;\n+import java.security.Principal;\n+import java.security.cert.Certificate;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+final class DefaultOpenSslSession extends AbstractReferenceCounted implements ReferenceCounted, OpenSslSession {\n+\n+    private final OpenSslSessionContext sessionContext;\n+    private final String peerHost;\n+    private final int peerPort;\n+    private final OpenSslSessionId id;\n+    private final X509Certificate[] x509PeerCerts;\n+    private final Certificate[] peerCerts;\n+    private final String protocol;\n+    private final String cipher;\n+    private final long sslSession;\n+    private final long creationTime;\n+    private final long timeout;\n+\n+    private volatile int applicationBufferSize = ReferenceCountedOpenSslEngine.MAX_PLAINTEXT_LENGTH;\n+    private volatile int packetBufferSize = ReferenceCountedOpenSslEngine.MAX_RECORD_SIZE;\n+    private volatile long lastAccessed;\n+    private volatile Certificate[] localCertificateChain;\n+    private volatile boolean invalid;\n+\n+    // Guarded by synchronized(this)\n+    // lazy init for memory reasons\n+    private Map<String, Object> values;\n+\n+    DefaultOpenSslSession(OpenSslSessionContext sessionContext, String peerHost, int peerPort, long sslSession,\n+                          String version,\n+                          String cipher,\n+                          OpenSslJavaxX509Certificate[] x509PeerCerts,\n+                          long creationTime, long timeout) {\n+        this.sessionContext = sessionContext;\n+        this.peerHost = peerHost;\n+        this.peerPort = peerPort;\n+        this.id = new OpenSslSessionId(id(sslSession));\n+        this.sslSession = sslSession;\n+        this.cipher = cipher == null ? SslUtils.INVALID_CIPHER : cipher;\n+        this.x509PeerCerts = x509PeerCerts;\n+        if (x509PeerCerts != null) {\n+            peerCerts = new Certificate[x509PeerCerts.length];\n+            for (int i = 0; i < peerCerts.length; i++) {\n+                peerCerts[i] = new OpenSslX509Certificate(x509PeerCerts[i].getBytes());\n+            }\n+        } else {\n+            peerCerts = null;\n+        }\n+        this.protocol = version == null ? StringUtil.EMPTY_STRING : version;\n+        this.creationTime = creationTime;\n+        this.lastAccessed = creationTime;\n+        this.timeout = timeout;\n+    }\n+\n+    private static byte[] id(long sslSession) {\n+        if (sslSession == -1) {\n+            return EmptyArrays.EMPTY_BYTES;\n+        }\n+        byte[] id = io.netty.internal.tcnative.SSLSession.getSessionId(sslSession);\n+        return id == null ? EmptyArrays.EMPTY_BYTES : id;\n+    }\n+\n+    @Override\n+    public OpenSslSessionContext getSessionContext() {\n+        return sessionContext;\n+    }\n+\n+    @Override\n+    public void putValue(String name, Object value) {\n+        ObjectUtil.checkNotNull(name, \"name\");\n+        ObjectUtil.checkNotNull(value, \"value\");\n+\n+        final Object old;\n+        synchronized (this) {\n+            Map<String, Object> values = this.values;\n+            if (values == null) {\n+                // Use size of 2 to keep the memory overhead small\n+                values = this.values = new HashMap<String, Object>(2);\n+            }\n+            old = values.put(name, value);\n+        }\n+\n+        if (value instanceof SSLSessionBindingListener) {\n+            ((SSLSessionBindingListener) value).valueBound(new SSLSessionBindingEvent(this, name));\n+        }\n+        notifyUnbound(old, name);\n+    }\n+\n+    @Override\n+    public Object getValue(String name) {\n+        ObjectUtil.checkNotNull(name, \"name\");\n+        synchronized (this) {\n+            if (values == null) {\n+                return null;\n+            }\n+            return values.get(name);\n+        }\n+    }\n+\n+    @Override\n+    public void removeValue(String name) {\n+        ObjectUtil.checkNotNull(name, \"name\");\n+\n+        final Object old;\n+        synchronized (this) {\n+            Map<String, Object> values = this.values;\n+            if (values == null) {\n+                return;\n+            }\n+            old = values.remove(name);\n+        }\n+\n+        notifyUnbound(old, name);\n+    }\n+\n+    @Override\n+    public String[] getValueNames() {\n+        synchronized (this) {\n+            Map<String, Object> values = this.values;\n+            if (values == null || values.isEmpty()) {\n+                return EmptyArrays.EMPTY_STRINGS;\n+            }\n+            return values.keySet().toArray(new String[0]);\n+        }\n+    }\n+\n+    private void notifyUnbound(Object value, String name) {\n+        if (value instanceof SSLSessionBindingListener) {\n+            ((SSLSessionBindingListener) value).valueUnbound(new SSLSessionBindingEvent(this, name));\n+        }\n+    }\n+\n+    @Override\n+    public String getPeerHost() {\n+        return peerHost;\n+    }\n+\n+    @Override\n+    public int getPeerPort() {\n+        return peerPort;\n+    }\n+\n+    @Override\n+    public OpenSslSessionId sessionId() {\n+        return id;\n+    }\n+\n+    @Override\n+    public byte[] getId() {\n+        return sessionId().cloneBytes();\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return sessionId().hashCode();\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (!(obj instanceof OpenSslSession)) {\n+            return false;\n+        }\n+        return sessionId().equals(((OpenSslSession) obj).sessionId());\n+    }\n+\n+    @Override\n+    public boolean isNullSession() {\n+        return false;\n+    }\n+\n+    @Override\n+    public long getCreationTime() {\n+        return creationTime;\n+    }\n+\n+    @Override\n+    public long getLastAccessedTime() {\n+        return lastAccessed;\n+    }\n+\n+    @Override\n+    public void invalidate() {\n+        invalid = true;\n+    }\n+\n+    @Override\n+    public boolean isValid() {\n+        if (sslSession == -1 || invalid) {\n+            return false;\n+        }\n+\n+        // Never timeout\n+        if (timeout == 0) {\n+            return true;\n+        }\n+\n+        long current = System.currentTimeMillis();\n+        return current - timeout < creationTime;\n+    }\n+\n+    @Override\n+    public long nativeAddr() {\n+        return sslSession;\n+    }\n+\n+    @Override\n+    public void setLocalCertificate(Certificate[] localCertificate) {\n+        this.localCertificateChain = localCertificate;", "originalCommit": "6c6b4ae89be050f621accd23d3a2eca5cb6846c0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODIzMDk0OA==", "url": "https://github.com/netty/netty/pull/10331#discussion_r448230948", "bodyText": "nope as we not re-use it later on. Let me add a comment.", "author": "normanmaurer", "createdAt": "2020-07-01T09:17:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc5OTE5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgxNjE0MQ==", "url": "https://github.com/netty/netty/pull/10331#discussion_r447816141", "bodyText": "defensive copy?", "author": "carl-mastrangelo", "createdAt": "2020-06-30T16:26:01Z", "path": "handler/src/main/java/io/netty/handler/ssl/OpenSslNullSession.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.ssl;\n+\n+import io.netty.util.internal.EmptyArrays;\n+\n+import javax.net.ssl.SSLPeerUnverifiedException;\n+import javax.security.cert.X509Certificate;\n+import java.security.Principal;\n+import java.security.cert.Certificate;\n+\n+/**\n+ * Special {@link OpenSslSession} which represent a {@code NULL} session. This will be used prior the handshake is\n+ * started.\n+ */\n+final class OpenSslNullSession implements OpenSslSession {\n+\n+    private final OpenSslSessionContext sessionContext;\n+    private final Certificate[] localCertificate;\n+    private final OpenSslSessionId sessionId = new OpenSslSessionId(EmptyArrays.EMPTY_BYTES);\n+\n+    OpenSslNullSession(OpenSslSessionContext sessionContext, Certificate[] localCertificate) {\n+        this.sessionContext = sessionContext;\n+        this.localCertificate = localCertificate;", "originalCommit": "6c6b4ae89be050f621accd23d3a2eca5cb6846c0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODIzMjI4Mw==", "url": "https://github.com/netty/netty/pull/10331#discussion_r448232283", "bodyText": "same comment as above... this will never be mutated.", "author": "normanmaurer", "createdAt": "2020-07-01T09:19:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgxNjE0MQ=="}], "type": "inlineReview"}, {"oid": "c9438824e4925f4046fb178331287b1151cd9df9", "url": "https://github.com/netty/netty/commit/c9438824e4925f4046fb178331287b1151cd9df9", "message": "Support session cache for client and server when using native SSLEngine implementation\n\nMotivation:\n\nAt the moment we don't support session caching for client side when using native SSLEngine implementation and our implementation of SSLSessionContext is incomplete.\n\nModification:\n\n- Consume netty-tcnative changes to be able to cache session in an external cache\n- Add and adjust unit tests to test session caching\n- Add an in memory session cache that is hooked into native SSLEngine\n\nResult:\n\nSupport session caching on the client and server side", "committedDate": "2020-07-06T11:21:45Z", "type": "forcePushed"}, {"oid": "e1bcbd5b54c5e77f439454aae6e0d3fc37fc5073", "url": "https://github.com/netty/netty/commit/e1bcbd5b54c5e77f439454aae6e0d3fc37fc5073", "message": "Support session cache for client and server when using native SSLEngine implementation\n\nMotivation:\n\nAt the moment we don't support session caching for client side when using native SSLEngine implementation and our implementation of SSLSessionContext is incomplete.\n\nModification:\n\n- Consume netty-tcnative changes to be able to cache session in an external cache\n- Add and adjust unit tests to test session caching\n- Add an in memory session cache that is hooked into native SSLEngine\n\nResult:\n\nSupport session caching on the client and server side", "committedDate": "2020-07-07T08:59:12Z", "type": "forcePushed"}, {"oid": "220ec3f6c41ce3d3938dbbe5ad1cc5a3883132ab", "url": "https://github.com/netty/netty/commit/220ec3f6c41ce3d3938dbbe5ad1cc5a3883132ab", "message": "Support session cache for client and server when using native SSLEngine implementation\n\nMotivation:\n\nAt the moment we don't support session caching for client side when using native SSLEngine implementation and our implementation of SSLSessionContext is incomplete.\n\nModification:\n\n- Consume netty-tcnative changes to be able to cache session in an external cache\n- Add and adjust unit tests to test session caching\n- Add an in memory session cache that is hooked into native SSLEngine\n\nResult:\n\nSupport session caching on the client and server side", "committedDate": "2020-07-08T12:15:26Z", "type": "forcePushed"}, {"oid": "730f02340b2f1dcdf73230cc03b8b81b1fe4a7b0", "url": "https://github.com/netty/netty/commit/730f02340b2f1dcdf73230cc03b8b81b1fe4a7b0", "message": "Support session cache for client and server when using native SSLEngine implementation\n\nMotivation:\n\nAt the moment we don't support session caching for client side when using native SSLEngine implementation and our implementation of SSLSessionContext is incomplete.\n\nModification:\n\n- Consume netty-tcnative changes to be able to cache session in an external cache\n- Add and adjust unit tests to test session caching\n- Add an in memory session cache that is hooked into native SSLEngine\n\nResult:\n\nSupport session caching on the client and server side", "committedDate": "2020-07-09T06:52:53Z", "type": "forcePushed"}, {"oid": "f8be4b2caf0553337e68858016870d57c782e103", "url": "https://github.com/netty/netty/commit/f8be4b2caf0553337e68858016870d57c782e103", "message": "Support session cache for client and server when using native SSLEngine implementation\n\nMotivation:\n\nAt the moment we don't support session caching for client side when using native SSLEngine implementation and our implementation of SSLSessionContext is incomplete.\n\nModification:\n\n- Consume netty-tcnative changes to be able to cache session in an external cache\n- Add and adjust unit tests to test session caching\n- Add an in memory session cache that is hooked into native SSLEngine\n\nResult:\n\nSupport session caching on the client and server side", "committedDate": "2020-07-10T09:28:02Z", "type": "forcePushed"}, {"oid": "de9c85b815681720ac1a0674d8260047f26f1648", "url": "https://github.com/netty/netty/commit/de9c85b815681720ac1a0674d8260047f26f1648", "message": "Support session cache for client and server when using native SSLEngine implementation\n\nMotivation:\n\nAt the moment we don't support session caching for client side when using native SSLEngine implementation and our implementation of SSLSessionContext is incomplete.\n\nModification:\n\n- Consume netty-tcnative changes to be able to cache session in an external cache\n- Add and adjust unit tests to test session caching\n- Add an in memory session cache that is hooked into native SSLEngine\n\nResult:\n\nSupport session caching on the client and server side", "committedDate": "2020-07-14T10:07:40Z", "type": "commit"}, {"oid": "de9c85b815681720ac1a0674d8260047f26f1648", "url": "https://github.com/netty/netty/commit/de9c85b815681720ac1a0674d8260047f26f1648", "message": "Support session cache for client and server when using native SSLEngine implementation\n\nMotivation:\n\nAt the moment we don't support session caching for client side when using native SSLEngine implementation and our implementation of SSLSessionContext is incomplete.\n\nModification:\n\n- Consume netty-tcnative changes to be able to cache session in an external cache\n- Add and adjust unit tests to test session caching\n- Add an in memory session cache that is hooked into native SSLEngine\n\nResult:\n\nSupport session caching on the client and server side", "committedDate": "2020-07-14T10:07:40Z", "type": "forcePushed"}]}