{"pr_number": 10544, "pr_title": "Simplify SQE handling", "pr_createdAt": "2020-09-07T19:44:12Z", "pr_url": "https://github.com/netty/netty/pull/10544", "timeline": [{"oid": "b86f254f48063cf1863fe622e5803cd55a5a1f78", "url": "https://github.com/netty/netty/commit/b86f254f48063cf1863fe622e5803cd55a5a1f78", "message": "Simplify SQE handling\n\nMotivation\n\nSQE handling can be simplified in terms of code and operations\nperformed\n\nModifications\n\n- Zero SQE array up front - no need to set never-used fields each time\n- Fill SQ array up front with corresponding indicies - no need to set\neach time since they are 1-1 with SQE array entries\n- Keep local head and tail vars and don't track separate sqe array\nhead/tail\n- Allocate memory for timespec directly (no need for ByteBuffer)\n- Avoid some unnecessary casts / type conversions (no need to convert\nuints to longs)\n\nResult\n\nFewer operations, less code", "committedDate": "2020-09-07T19:51:03Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDY5NTc1Nw==", "url": "https://github.com/netty/netty/pull/10544#discussion_r484695757", "bodyText": "nit: remove", "author": "normanmaurer", "createdAt": "2020-09-08T07:06:21Z", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringSubmissionQueue.java", "diffHunk": "@@ -51,124 +48,101 @@\n     //these unsigned integer pointers(shared with the kernel) will be changed by the kernel\n     private final long kHeadAddress;\n     private final long kTailAddress;\n-    private final long kRingMaskAddress;\n-    private final long kRingEntriesAddress;\n-    private final long fFlagsAdress;\n+    //private final long fFlagsAdress;", "originalCommit": "b86f254f48063cf1863fe622e5803cd55a5a1f78", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDY5NTk2Mg==", "url": "https://github.com/netty/netty/pull/10544#discussion_r484695962", "bodyText": "nit: remove", "author": "normanmaurer", "createdAt": "2020-09-08T07:06:44Z", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringSubmissionQueue.java", "diffHunk": "@@ -51,124 +48,101 @@\n     //these unsigned integer pointers(shared with the kernel) will be changed by the kernel\n     private final long kHeadAddress;\n     private final long kTailAddress;\n-    private final long kRingMaskAddress;\n-    private final long kRingEntriesAddress;\n-    private final long fFlagsAdress;\n+    //private final long fFlagsAdress;\n     private final long kDroppedAddress;\n     private final long arrayAddress;\n \n     private final long submissionQueueArrayAddress;\n \n-    private long sqeHead;\n-    private long sqeTail;\n+    private final int ringEntries;\n+    private final int ringMask; // = ringEntries - 1\n \n     private final int ringSize;\n     private final long ringAddress;\n     private final int ringFd;\n \n-    private final ByteBuffer timeoutMemory;\n     private final long timeoutMemoryAddress;\n \n-    //private int sqeSubmitCounter;\n+    private int head;\n+    private int tail;\n \n     IOUringSubmissionQueue(long kHeadAddress, long kTailAddress, long kRingMaskAddress, long kRingEntriesAddress,\n                            long fFlagsAdress, long kDroppedAddress, long arrayAddress,\n                            long submissionQueueArrayAddress, int ringSize,\n                            long ringAddress, int ringFd) {\n         this.kHeadAddress = kHeadAddress;\n         this.kTailAddress = kTailAddress;\n-        this.kRingMaskAddress = kRingMaskAddress;\n-        this.kRingEntriesAddress = kRingEntriesAddress;\n-        this.fFlagsAdress = fFlagsAdress;\n+        //this.fFlagsAdress = fFlagsAdress;", "originalCommit": "b86f254f48063cf1863fe622e5803cd55a5a1f78", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDY5NjI0MA==", "url": "https://github.com/netty/netty/pull/10544#discussion_r484696240", "bodyText": "seems like a few fields can be removed ?", "author": "normanmaurer", "createdAt": "2020-09-08T07:07:20Z", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringSubmissionQueue.java", "diffHunk": "@@ -51,124 +48,101 @@\n     //these unsigned integer pointers(shared with the kernel) will be changed by the kernel\n     private final long kHeadAddress;\n     private final long kTailAddress;\n-    private final long kRingMaskAddress;\n-    private final long kRingEntriesAddress;\n-    private final long fFlagsAdress;\n+    //private final long fFlagsAdress;\n     private final long kDroppedAddress;\n     private final long arrayAddress;\n \n     private final long submissionQueueArrayAddress;\n \n-    private long sqeHead;\n-    private long sqeTail;\n+    private final int ringEntries;\n+    private final int ringMask; // = ringEntries - 1\n \n     private final int ringSize;\n     private final long ringAddress;\n     private final int ringFd;\n \n-    private final ByteBuffer timeoutMemory;\n     private final long timeoutMemoryAddress;\n \n-    //private int sqeSubmitCounter;\n+    private int head;\n+    private int tail;\n \n     IOUringSubmissionQueue(long kHeadAddress, long kTailAddress, long kRingMaskAddress, long kRingEntriesAddress,\n                            long fFlagsAdress, long kDroppedAddress, long arrayAddress,", "originalCommit": "b86f254f48063cf1863fe622e5803cd55a5a1f78", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk4MDY1OA==", "url": "https://github.com/netty/netty/pull/10544#discussion_r484980658", "bodyText": "Some of these are used only from JNI during shutdown, and others I left because I wasn't sure whether we may have a use for them at some point (e.g. dropped SQE count). Probably we could trim down how many are actually needed for the shutdown though, since some are derived from others (like ringSize).\n@1Jo1 wdyt?", "author": "njhill", "createdAt": "2020-09-08T14:49:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDY5NjI0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA0NzcxNQ==", "url": "https://github.com/netty/netty/pull/10544#discussion_r485047715", "bodyText": "yeah dropped SQE count, it's probably useful for debugging or for logging, however it is very unlikely that the cqe(size=2 * sqe) is full, btw we could change cqe entry size as well at the beginning :)", "author": "1Jo1", "createdAt": "2020-09-08T16:25:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDY5NjI0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA0ODQxMg==", "url": "https://github.com/netty/netty/pull/10544#discussion_r485048412", "bodyText": "I already mentioned that, kFlag is required for SQPOLL", "author": "1Jo1", "createdAt": "2020-09-08T16:26:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDY5NjI0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ5NjA5MQ==", "url": "https://github.com/netty/netty/pull/10544#discussion_r485496091", "bodyText": "ok fair enough...", "author": "normanmaurer", "createdAt": "2020-09-09T10:07:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDY5NjI0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDY5NjUwOQ==", "url": "https://github.com/netty/netty/pull/10544#discussion_r484696509", "bodyText": "remove", "author": "normanmaurer", "createdAt": "2020-09-08T07:08:00Z", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringSubmissionQueue.java", "diffHunk": "@@ -51,124 +48,101 @@\n     //these unsigned integer pointers(shared with the kernel) will be changed by the kernel\n     private final long kHeadAddress;\n     private final long kTailAddress;\n-    private final long kRingMaskAddress;\n-    private final long kRingEntriesAddress;\n-    private final long fFlagsAdress;\n+    //private final long fFlagsAdress;\n     private final long kDroppedAddress;\n     private final long arrayAddress;\n \n     private final long submissionQueueArrayAddress;\n \n-    private long sqeHead;\n-    private long sqeTail;\n+    private final int ringEntries;\n+    private final int ringMask; // = ringEntries - 1\n \n     private final int ringSize;\n     private final long ringAddress;\n     private final int ringFd;\n \n-    private final ByteBuffer timeoutMemory;\n     private final long timeoutMemoryAddress;\n \n-    //private int sqeSubmitCounter;\n+    private int head;\n+    private int tail;\n \n     IOUringSubmissionQueue(long kHeadAddress, long kTailAddress, long kRingMaskAddress, long kRingEntriesAddress,\n                            long fFlagsAdress, long kDroppedAddress, long arrayAddress,\n                            long submissionQueueArrayAddress, int ringSize,\n                            long ringAddress, int ringFd) {\n         this.kHeadAddress = kHeadAddress;\n         this.kTailAddress = kTailAddress;\n-        this.kRingMaskAddress = kRingMaskAddress;\n-        this.kRingEntriesAddress = kRingEntriesAddress;\n-        this.fFlagsAdress = fFlagsAdress;\n+        //this.fFlagsAdress = fFlagsAdress;\n         this.kDroppedAddress = kDroppedAddress;\n         this.arrayAddress = arrayAddress;\n         this.submissionQueueArrayAddress = submissionQueueArrayAddress;\n         this.ringSize = ringSize;\n         this.ringAddress = ringAddress;\n         this.ringFd = ringFd;\n \n-        timeoutMemory = Buffer.allocateDirectWithNativeOrder(KERNEL_TIMESPEC_SIZE);\n-        timeoutMemoryAddress = Buffer.memoryAddress(timeoutMemory);\n-    }\n+        this.ringEntries = PlatformDependent.getInt(kRingEntriesAddress);\n+        this.ringMask = PlatformDependent.getInt(kRingMaskAddress);\n+        this.head = PlatformDependent.getInt(kHeadAddress);\n+        this.tail = PlatformDependent.getInt(kTailAddress);\n \n-    public long getSqe() {\n-        long next = sqeTail + 1;\n-        long kRingEntries = toUnsignedLong(PlatformDependent.getInt(kRingEntriesAddress));\n+        this.timeoutMemoryAddress = PlatformDependent.allocateMemory(KERNEL_TIMESPEC_SIZE);\n \n-        //acquire memory barrier\n-        long kHead = toUnsignedLong(PlatformDependent.getIntVolatile(kHeadAddress));\n+        // Zero the whole SQE array first\n+        PlatformDependent.setMemory(submissionQueueArrayAddress, ringEntries * SQE_SIZE, (byte) 0);\n \n-        long sqe = 0;\n-        if ((next - kHead) <= kRingEntries) {\n-            long index = sqeTail & toUnsignedLong(PlatformDependent.getInt(kRingMaskAddress));\n-            sqe = SQE_SIZE * index + submissionQueueArrayAddress;\n-            sqeTail = next;\n+        // Fill SQ array (lines up with SQE array)\n+        long address = arrayAddress;\n+        for (int i = 0; i < ringEntries; i++, address += INT_SIZE) {\n+            PlatformDependent.putInt(address, i);\n         }\n-        return sqe;\n     }\n \n-    private void setData(long sqe, byte op, int pollMask, int fd, long bufferAddress, int length, long offset) {\n-        //Todo cleaner\n-        //set sqe(submission queue) properties\n-        PlatformDependent.putByte(sqe + SQE_OP_CODE_FIELD, op);\n-        PlatformDependent.putShort(sqe + SQE_IOPRIO_FIELD, (short) 0);\n-        PlatformDependent.putInt(sqe + SQE_FD_FIELD, fd);\n-        PlatformDependent.putLong(sqe + SQE_OFFSET_FIELD, offset);\n-        PlatformDependent.putLong(sqe + SQE_ADDRESS_FIELD, bufferAddress);\n-        PlatformDependent.putInt(sqe + SQE_LEN_FIELD, length);\n-\n-        //user_data should be same as POLL_LINK fd\n-        if (op == Native.IORING_OP_POLL_REMOVE) {\n-            PlatformDependent.putInt(sqe + SQE_FD_FIELD, -1);\n-            long uData = convertToUserData((byte) Native.IORING_OP_POLL_ADD, fd, pollMask);\n-            PlatformDependent.putLong(sqe + SQE_ADDRESS_FIELD, uData);\n-            PlatformDependent.putLong(sqe + SQE_USER_DATA_FIELD, convertToUserData(op, fd, 0));\n-            PlatformDependent.putInt(sqe + SQE_RW_FLAGS_FIELD, 0);\n-        } else {\n-            long uData = convertToUserData(op, fd, pollMask);\n-            PlatformDependent.putLong(sqe + SQE_USER_DATA_FIELD, uData);\n-            //c union set Rw-Flags or accept_flags\n-            if (op != Native.IORING_OP_ACCEPT) {\n-                PlatformDependent.putInt(sqe + SQE_RW_FLAGS_FIELD, pollMask);\n-            } else {\n-                //accept_flags set NON_BLOCKING\n-                PlatformDependent.putInt(sqe + SQE_RW_FLAGS_FIELD, Native.SOCK_NONBLOCK | Native.SOCK_CLOEXEC);\n-            }\n+    private boolean enqueueSqe(int op, int rwFlags, int fd, long bufferAddress, int length, long offset) {\n+        boolean submitted = false;\n+        int pending = tail - head;\n+        if (pending == ringEntries) {\n+            submit();\n+            submitted = true;\n         }\n+        long sqe = submissionQueueArrayAddress + (tail++ & ringMask) * SQE_SIZE;\n+        setData(sqe, op, rwFlags, fd, bufferAddress, length, offset);\n+        return submitted;\n+    }\n \n+    private void setData(long sqe, int op, int rwFlags, int fd, long bufferAddress, int length, long offset) {\n+        //set sqe(submission queue) properties\n+        // never-used fields are omitted since we zero the entire array up-front\n+\n+        PlatformDependent.putByte(sqe + SQE_OP_CODE_FIELD, (byte) op);\n         // TODO: Make it configurable if we should use this flag or not.\n         PlatformDependent.putByte(sqe + SQE_FLAGS_FIELD,\n                 // Workaround for a kernel bug:\n                 // See https://lore.kernel.org/io-uring/6428c1ee0234105d18c5e3e88aa00c57@nickhill.org/T/#t\n                 (byte) (op != Native.IORING_OP_WRITEV ? Native.IOSQE_ASYNC : 0));\n-\n+        //PlatformDependent.putShort(sqe + SQE_IOPRIO_FIELD, (short) 0);\n+        PlatformDependent.putInt(sqe + SQE_FD_FIELD, fd);\n+        PlatformDependent.putLong(sqe + SQE_OFFSET_FIELD, offset);\n+        PlatformDependent.putLong(sqe + SQE_ADDRESS_FIELD, bufferAddress);\n+        PlatformDependent.putInt(sqe + SQE_LEN_FIELD, length);\n+        PlatformDependent.putInt(sqe + SQE_RW_FLAGS_FIELD, rwFlags);\n+        long userData = convertToUserData(op, fd, rwFlags);\n+        PlatformDependent.putLong(sqe + SQE_USER_DATA_FIELD, userData);\n         // pad field array -> all fields should be zero\n-        long offsetIndex = 0;\n-        for (int i = 0; i < 3; i++) {\n-            PlatformDependent.putLong(sqe + SQE_PAD_FIELD + offsetIndex, 0);\n-            offsetIndex += 8;\n-        }\n+//        long offsetIndex = 0;\n+//        for (int i = 0; i < 3; i++) {\n+//            PlatformDependent.putLong(sqe + SQE_PAD_FIELD + offsetIndex, 0);\n+//            offsetIndex += 8;\n+//        }", "originalCommit": "b86f254f48063cf1863fe622e5803cd55a5a1f78", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e62184cc5b4fa1496df15b3e55a05a12fab6ac65", "url": "https://github.com/netty/netty/commit/e62184cc5b4fa1496df15b3e55a05a12fab6ac65", "message": "Clean up some commented lines per @normanmaurer's comments", "committedDate": "2020-09-08T14:59:36Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAzMDA4NQ==", "url": "https://github.com/netty/netty/pull/10544#discussion_r485030085", "bodyText": "should as remove argument in JNI as well otherweise it wouldn't compile it", "author": "1Jo1", "createdAt": "2020-09-08T15:58:09Z", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringSubmissionQueue.java", "diffHunk": "@@ -51,121 +48,89 @@\n     //these unsigned integer pointers(shared with the kernel) will be changed by the kernel\n     private final long kHeadAddress;\n     private final long kTailAddress;\n-    private final long kRingMaskAddress;\n-    private final long kRingEntriesAddress;\n-    private final long fFlagsAdress;\n     private final long kDroppedAddress;\n     private final long arrayAddress;\n \n     private final long submissionQueueArrayAddress;\n \n-    private long sqeHead;\n-    private long sqeTail;\n+    private final int ringEntries;\n+    private final int ringMask; // = ringEntries - 1\n \n     private final int ringSize;\n     private final long ringAddress;\n     private final int ringFd;\n \n-    private final ByteBuffer timeoutMemory;\n     private final long timeoutMemoryAddress;\n \n-    //private int sqeSubmitCounter;\n+    private int head;\n+    private int tail;\n \n     IOUringSubmissionQueue(long kHeadAddress, long kTailAddress, long kRingMaskAddress, long kRingEntriesAddress,\n-                           long fFlagsAdress, long kDroppedAddress, long arrayAddress,\n-                           long submissionQueueArrayAddress, int ringSize,\n+                           long kDroppedAddress, long arrayAddress, long submissionQueueArrayAddress, int ringSize,", "originalCommit": "de666589c974738093af9cf2fc08736e9b4faac5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAzNDY2NA==", "url": "https://github.com/netty/netty/pull/10544#discussion_r485034664", "bodyText": "I think we should add comment as it's not really clear that putIntOrdered is a release memory barrier", "author": "1Jo1", "createdAt": "2020-09-08T16:04:57Z", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringSubmissionQueue.java", "diffHunk": "@@ -181,157 +146,51 @@ public boolean addPollOut(int fd) {\n     }\n \n     private boolean addPoll(int fd, int pollMask) {\n-        long sqe = 0;\n-        boolean submitted = false;\n-        while (sqe == 0) {\n-            sqe = getSqe();\n-\n-            if (sqe == 0) {\n-                submit();\n-                submitted = true;\n-            }\n-        }\n-\n-        setData(sqe, (byte) Native.IORING_OP_POLL_ADD, pollMask, fd, 0, 0, 0);\n-        return submitted;\n+        return enqueueSqe(Native.IORING_OP_POLL_ADD, pollMask, fd, 0, 0, 0);\n     }\n \n     //return true -> submit() was called\n     public boolean addRead(int fd, long bufferAddress, int pos, int limit) {\n-        long sqe = 0;\n-        boolean submitted = false;\n-        while (sqe == 0) {\n-            sqe = getSqe();\n-\n-            if (sqe == 0) {\n-                submit();\n-                submitted = true;\n-            }\n-        }\n-        setData(sqe, (byte) Native.IORING_OP_READ, 0, fd, bufferAddress + pos, limit - pos, 0);\n-        return submitted;\n+        return enqueueSqe(Native.IORING_OP_READ, 0, fd, bufferAddress + pos, limit - pos, 0);\n     }\n \n     public boolean addWrite(int fd, long bufferAddress, int pos, int limit) {\n-        long sqe = 0;\n-        boolean submitted = false;\n-        while (sqe == 0) {\n-            sqe = getSqe();\n-\n-            if (sqe == 0) {\n-                submit();\n-                submitted = true;\n-            }\n-        }\n-        setData(sqe, (byte) Native.IORING_OP_WRITE, 0, fd, bufferAddress + pos, limit - pos, 0);\n-        return submitted;\n+        return enqueueSqe(Native.IORING_OP_WRITE, 0, fd, bufferAddress + pos, limit - pos, 0);\n     }\n \n     public boolean addAccept(int fd) {\n-        long sqe = 0;\n-        boolean submitted = false;\n-        while (sqe == 0) {\n-            sqe = getSqe();\n-\n-            if (sqe == 0) {\n-                submit();\n-                submitted = true;\n-            }\n-        }\n-        setData(sqe, (byte) Native.IORING_OP_ACCEPT, 0, fd, 0, 0, 0);\n-        return submitted;\n+        return enqueueSqe(Native.IORING_OP_ACCEPT, Native.SOCK_NONBLOCK | Native.SOCK_CLOEXEC, fd, 0, 0, 0);\n     }\n \n     //fill the address which is associated with server poll link user_data\n     public boolean addPollRemove(int fd, int pollMask) {\n-        long sqe = 0;\n-        boolean submitted = false;\n-        while (sqe == 0) {\n-            sqe = getSqe();\n-\n-            if (sqe == 0) {\n-                submit();\n-                submitted = true;\n-            }\n-        }\n-        setData(sqe, (byte) Native.IORING_OP_POLL_REMOVE, pollMask, fd, 0, 0, 0);\n-\n-        return submitted;\n+        return enqueueSqe(Native.IORING_OP_POLL_REMOVE, 0, fd,\n+                convertToUserData(Native.IORING_OP_POLL_ADD, fd, pollMask), 0, 0);\n     }\n \n     public boolean addConnect(int fd, long socketAddress, long socketAddressLength) {\n-        long sqe = 0;\n-        boolean submitted = false;\n-        while (sqe == 0) {\n-            sqe = getSqe();\n-\n-            if (sqe == 0) {\n-                submit();\n-                submitted = true;\n-            }\n-        }\n-        setData(sqe, (byte) Native.IORING_OP_CONNECT, 0, fd, socketAddress, 0, socketAddressLength);\n-\n-        return submitted;\n+        return enqueueSqe(Native.IORING_OP_CONNECT, 0, fd, socketAddress, 0, socketAddressLength);\n     }\n \n     public boolean addWritev(int fd, long iovecArrayAddress, int length) {\n-        long sqe = 0;\n-        boolean submitted = false;\n-        while (sqe == 0) {\n-            sqe = getSqe();\n-\n-            if (sqe == 0) {\n-                submit();\n-                submitted = true;\n-            }\n-        }\n-        setData(sqe, (byte) Native.IORING_OP_WRITEV, 0, fd, iovecArrayAddress, length, 0);\n-\n-        return submitted;\n-    }\n-\n-    private int flushSqe() {\n-        long kTail = toUnsignedLong(PlatformDependent.getInt(kTailAddress));\n-        long kHead = toUnsignedLong(PlatformDependent.getIntVolatile(kHeadAddress));\n-        long kRingMask = toUnsignedLong(PlatformDependent.getInt(kRingMaskAddress));\n-\n-        logger.trace(\"Ktail: {}\", kTail);\n-        logger.trace(\"Ktail: {}\", kHead);\n-        logger.trace(\"SqeHead: {}\", sqeHead);\n-        logger.trace(\"SqeTail: {}\", sqeTail);\n-\n-        if (sqeHead == sqeTail) {\n-            return (int) (kTail - kHead);\n-        }\n-\n-        long toSubmit = sqeTail - sqeHead;\n-        while (toSubmit > 0) {\n-            long index = kTail & kRingMask;\n-\n-            PlatformDependent.putInt(arrayAddress + index * INT_SIZE, (int) (sqeHead & kRingMask));\n-\n-            sqeHead++;\n-            kTail++;\n-            toSubmit--;\n-        }\n-\n-        //release\n-        PlatformDependent.putIntOrdered(kTailAddress, (int) kTail);\n-\n-        return (int) (kTail - kHead);\n+        return enqueueSqe(Native.IORING_OP_WRITEV, 0, fd, iovecArrayAddress, length, 0);\n     }\n \n     public void submit() {\n-        int submitted = flushSqe();\n-        logger.trace(\"Submitted: {}\", submitted);\n-        if (submitted > 0) {\n-            int ret = Native.ioUringEnter(ringFd, submitted, 0, 0);\n-            if (ret < 0) {\n-                throw new RuntimeException(\"ioUringEnter syscall\");\n+        int submit = tail - head;\n+        if (submit > 0) {\n+            PlatformDependent.putIntOrdered(kTailAddress, tail);", "originalCommit": "de666589c974738093af9cf2fc08736e9b4faac5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAzNjQ1Nw==", "url": "https://github.com/netty/netty/pull/10544#discussion_r485036457", "bodyText": "here the same putIntOrdered ->  acquire memory barrier", "author": "1Jo1", "createdAt": "2020-09-08T16:07:47Z", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringSubmissionQueue.java", "diffHunk": "@@ -181,157 +146,51 @@ public boolean addPollOut(int fd) {\n     }\n \n     private boolean addPoll(int fd, int pollMask) {\n-        long sqe = 0;\n-        boolean submitted = false;\n-        while (sqe == 0) {\n-            sqe = getSqe();\n-\n-            if (sqe == 0) {\n-                submit();\n-                submitted = true;\n-            }\n-        }\n-\n-        setData(sqe, (byte) Native.IORING_OP_POLL_ADD, pollMask, fd, 0, 0, 0);\n-        return submitted;\n+        return enqueueSqe(Native.IORING_OP_POLL_ADD, pollMask, fd, 0, 0, 0);\n     }\n \n     //return true -> submit() was called\n     public boolean addRead(int fd, long bufferAddress, int pos, int limit) {\n-        long sqe = 0;\n-        boolean submitted = false;\n-        while (sqe == 0) {\n-            sqe = getSqe();\n-\n-            if (sqe == 0) {\n-                submit();\n-                submitted = true;\n-            }\n-        }\n-        setData(sqe, (byte) Native.IORING_OP_READ, 0, fd, bufferAddress + pos, limit - pos, 0);\n-        return submitted;\n+        return enqueueSqe(Native.IORING_OP_READ, 0, fd, bufferAddress + pos, limit - pos, 0);\n     }\n \n     public boolean addWrite(int fd, long bufferAddress, int pos, int limit) {\n-        long sqe = 0;\n-        boolean submitted = false;\n-        while (sqe == 0) {\n-            sqe = getSqe();\n-\n-            if (sqe == 0) {\n-                submit();\n-                submitted = true;\n-            }\n-        }\n-        setData(sqe, (byte) Native.IORING_OP_WRITE, 0, fd, bufferAddress + pos, limit - pos, 0);\n-        return submitted;\n+        return enqueueSqe(Native.IORING_OP_WRITE, 0, fd, bufferAddress + pos, limit - pos, 0);\n     }\n \n     public boolean addAccept(int fd) {\n-        long sqe = 0;\n-        boolean submitted = false;\n-        while (sqe == 0) {\n-            sqe = getSqe();\n-\n-            if (sqe == 0) {\n-                submit();\n-                submitted = true;\n-            }\n-        }\n-        setData(sqe, (byte) Native.IORING_OP_ACCEPT, 0, fd, 0, 0, 0);\n-        return submitted;\n+        return enqueueSqe(Native.IORING_OP_ACCEPT, Native.SOCK_NONBLOCK | Native.SOCK_CLOEXEC, fd, 0, 0, 0);\n     }\n \n     //fill the address which is associated with server poll link user_data\n     public boolean addPollRemove(int fd, int pollMask) {\n-        long sqe = 0;\n-        boolean submitted = false;\n-        while (sqe == 0) {\n-            sqe = getSqe();\n-\n-            if (sqe == 0) {\n-                submit();\n-                submitted = true;\n-            }\n-        }\n-        setData(sqe, (byte) Native.IORING_OP_POLL_REMOVE, pollMask, fd, 0, 0, 0);\n-\n-        return submitted;\n+        return enqueueSqe(Native.IORING_OP_POLL_REMOVE, 0, fd,\n+                convertToUserData(Native.IORING_OP_POLL_ADD, fd, pollMask), 0, 0);\n     }\n \n     public boolean addConnect(int fd, long socketAddress, long socketAddressLength) {\n-        long sqe = 0;\n-        boolean submitted = false;\n-        while (sqe == 0) {\n-            sqe = getSqe();\n-\n-            if (sqe == 0) {\n-                submit();\n-                submitted = true;\n-            }\n-        }\n-        setData(sqe, (byte) Native.IORING_OP_CONNECT, 0, fd, socketAddress, 0, socketAddressLength);\n-\n-        return submitted;\n+        return enqueueSqe(Native.IORING_OP_CONNECT, 0, fd, socketAddress, 0, socketAddressLength);\n     }\n \n     public boolean addWritev(int fd, long iovecArrayAddress, int length) {\n-        long sqe = 0;\n-        boolean submitted = false;\n-        while (sqe == 0) {\n-            sqe = getSqe();\n-\n-            if (sqe == 0) {\n-                submit();\n-                submitted = true;\n-            }\n-        }\n-        setData(sqe, (byte) Native.IORING_OP_WRITEV, 0, fd, iovecArrayAddress, length, 0);\n-\n-        return submitted;\n-    }\n-\n-    private int flushSqe() {\n-        long kTail = toUnsignedLong(PlatformDependent.getInt(kTailAddress));\n-        long kHead = toUnsignedLong(PlatformDependent.getIntVolatile(kHeadAddress));\n-        long kRingMask = toUnsignedLong(PlatformDependent.getInt(kRingMaskAddress));\n-\n-        logger.trace(\"Ktail: {}\", kTail);\n-        logger.trace(\"Ktail: {}\", kHead);\n-        logger.trace(\"SqeHead: {}\", sqeHead);\n-        logger.trace(\"SqeTail: {}\", sqeTail);\n-\n-        if (sqeHead == sqeTail) {\n-            return (int) (kTail - kHead);\n-        }\n-\n-        long toSubmit = sqeTail - sqeHead;\n-        while (toSubmit > 0) {\n-            long index = kTail & kRingMask;\n-\n-            PlatformDependent.putInt(arrayAddress + index * INT_SIZE, (int) (sqeHead & kRingMask));\n-\n-            sqeHead++;\n-            kTail++;\n-            toSubmit--;\n-        }\n-\n-        //release\n-        PlatformDependent.putIntOrdered(kTailAddress, (int) kTail);\n-\n-        return (int) (kTail - kHead);\n+        return enqueueSqe(Native.IORING_OP_WRITEV, 0, fd, iovecArrayAddress, length, 0);\n     }\n \n     public void submit() {\n-        int submitted = flushSqe();\n-        logger.trace(\"Submitted: {}\", submitted);\n-        if (submitted > 0) {\n-            int ret = Native.ioUringEnter(ringFd, submitted, 0, 0);\n-            if (ret < 0) {\n-                throw new RuntimeException(\"ioUringEnter syscall\");\n+        int submit = tail - head;\n+        if (submit > 0) {\n+            PlatformDependent.putIntOrdered(kTailAddress, tail);\n+            int ret = Native.ioUringEnter(ringFd, submit, 0, 0);\n+            head = PlatformDependent.getIntVolatile(kHeadAddress);", "originalCommit": "de666589c974738093af9cf2fc08736e9b4faac5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "bd6f9315503d32eec9ea19c9ce8debf3ebbaa4a8", "url": "https://github.com/netty/netty/commit/bd6f9315503d32eec9ea19c9ce8debf3ebbaa4a8", "message": "Simplify SQE handling\n\nMotivation\n\nSQE handling can be simplified in terms of code and operations\nperformed\n\nModifications\n\n- Zero SQE array up front - no need to set never-used fields each time\n- Fill SQ array up front with corresponding indicies - no need to set\neach time since they are 1-1 with SQE array entries\n- Keep local head and tail vars and don't track separate sqe array\nhead/tail\n- Allocate memory for timespec directly (no need for ByteBuffer)\n- Avoid some unnecessary casts / type conversions (no need to convert\nuints to longs)\n\nResult\n\nFewer operations, less code", "committedDate": "2020-09-09T18:11:05Z", "type": "commit"}, {"oid": "f8548dff8f9a2d15ea9574b02933311fe18834a8", "url": "https://github.com/netty/netty/commit/f8548dff8f9a2d15ea9574b02933311fe18834a8", "message": "Clean up some commented lines per @normanmaurer's comments", "committedDate": "2020-09-09T18:14:49Z", "type": "commit"}, {"oid": "1ae20e670cdfe39ed61ca8378a9c3cf0006b9b0e", "url": "https://github.com/netty/netty/commit/1ae20e670cdfe39ed61ca8378a9c3cf0006b9b0e", "message": "JNI change missed from prior commit", "committedDate": "2020-09-09T18:14:49Z", "type": "commit"}, {"oid": "d67c9b1aaaa6af0ae62658728b9be0c47d0c8dac", "url": "https://github.com/netty/netty/commit/d67c9b1aaaa6af0ae62658728b9be0c47d0c8dac", "message": "Also remove parameter from JNI constructor method signature", "committedDate": "2020-09-09T18:15:45Z", "type": "commit"}, {"oid": "8060002ab4e791f38a11a59210d5ebce1bc3029a", "url": "https://github.com/netty/netty/commit/8060002ab4e791f38a11a59210d5ebce1bc3029a", "message": "Address @1Jo1's comments, other minor cleanup\n\nIn particular reinstate fFlagsAdress field", "committedDate": "2020-09-09T18:22:27Z", "type": "commit"}, {"oid": "7a60e4a1adb7b169fb59077ce9b8963e3d285681", "url": "https://github.com/netty/netty/commit/7a60e4a1adb7b169fb59077ce9b8963e3d285681", "message": "Change initial reads from kernel-written mem to be volatile", "committedDate": "2020-09-09T18:28:36Z", "type": "commit"}, {"oid": "7a60e4a1adb7b169fb59077ce9b8963e3d285681", "url": "https://github.com/netty/netty/commit/7a60e4a1adb7b169fb59077ce9b8963e3d285681", "message": "Change initial reads from kernel-written mem to be volatile", "committedDate": "2020-09-09T18:28:36Z", "type": "forcePushed"}]}