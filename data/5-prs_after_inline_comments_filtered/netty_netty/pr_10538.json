{"pr_number": 10538, "pr_title": "Only execute the close once the already added write operations completes", "pr_createdAt": "2020-09-07T08:01:37Z", "pr_url": "https://github.com/netty/netty/pull/10538", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDI2MTc5NQ==", "url": "https://github.com/netty/netty/pull/10538#discussion_r484261795", "bodyText": "Wildcard not allowed.", "author": "hyperxpro", "createdAt": "2020-09-07T08:06:58Z", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/AbstractIOUringChannel.java", "diffHunk": "@@ -19,18 +19,7 @@\n import io.netty.buffer.ByteBufAllocator;\n import io.netty.buffer.ByteBufUtil;\n import io.netty.buffer.Unpooled;\n-import io.netty.channel.AbstractChannel;\n-import io.netty.channel.Channel;\n-import io.netty.channel.ChannelConfig;\n-import io.netty.channel.ChannelFuture;\n-import io.netty.channel.ChannelFutureListener;\n-import io.netty.channel.ChannelMetadata;\n-import io.netty.channel.ChannelOutboundBuffer;\n-import io.netty.channel.ChannelPromise;\n-import io.netty.channel.ConnectTimeoutException;\n-import io.netty.channel.DefaultChannelConfig;\n-import io.netty.channel.EventLoop;\n-import io.netty.channel.RecvByteBufAllocator;\n+import io.netty.channel.*;", "originalCommit": "56a998c03ceeb36caa6d825b6828f91cda91750a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDI2MjE0NQ==", "url": "https://github.com/netty/netty/pull/10538#discussion_r484262145", "bodyText": "Can we use a Logger instead of System.out.println(Object)?", "author": "hyperxpro", "createdAt": "2020-09-07T08:07:43Z", "path": "transport-native-io_uring/src/test/java/io/netty/channel/uring/PollRemoveTest.java", "diffHunk": "@@ -81,7 +81,7 @@ public void initChannel(SocketChannel ch) throws Exception {\n     public void test() throws Exception {\n \n         io_uring_test();\n-\n+        Thread.sleep(1000);\n         System.out.println(\"io_uring --------------------------------\");", "originalCommit": "56a998c03ceeb36caa6d825b6828f91cda91750a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDI2NDAwOQ==", "url": "https://github.com/netty/netty/pull/10538#discussion_r484264009", "bodyText": "yes... I will do a full cleanup now so check style will pass etc.", "author": "normanmaurer", "createdAt": "2020-09-07T08:11:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDI2MjE0NQ=="}], "type": "inlineReview"}, {"oid": "0b164de4f3d8dc166103af2b82f07b216ceaf49a", "url": "https://github.com/netty/netty/commit/0b164de4f3d8dc166103af2b82f07b216ceaf49a", "message": "Address nicks comments", "committedDate": "2020-09-07T08:34:04Z", "type": "forcePushed"}, {"oid": "ae5a8d795a2be7ec9e2f1fa7aefc2189fee4d8b6", "url": "https://github.com/netty/netty/commit/ae5a8d795a2be7ec9e2f1fa7aefc2189fee4d8b6", "message": "Address nicks comments", "committedDate": "2020-09-07T08:42:59Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDI5NDQ1OA==", "url": "https://github.com/netty/netty/pull/10538#discussion_r484294458", "bodyText": "A sleep in a test is always suspicious.", "author": "chrisvest", "createdAt": "2020-09-07T09:02:53Z", "path": "transport-native-io_uring/src/test/java/io/netty/channel/uring/PollRemoveTest.java", "diffHunk": "@@ -64,6 +64,9 @@ public void initChannel(SocketChannel ch) { }\n     @Test\n     public void test() throws Exception {\n         io_uring_test();\n+\n+        Thread.sleep(1000);", "originalCommit": "ae5a8d795a2be7ec9e2f1fa7aefc2189fee4d8b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDMwODUyOA==", "url": "https://github.com/netty/netty/pull/10538#discussion_r484308528", "bodyText": "I agree... that said this sleep has nothing to do with the PR itself ... I just added it as the test failed sometimes for me as the fd was not completely closed when we did rerun the test (was the case before as well)", "author": "normanmaurer", "createdAt": "2020-09-07T09:25:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDI5NDQ1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDM2NDk0MA==", "url": "https://github.com/netty/netty/pull/10538#discussion_r484364940", "bodyText": "this test also failed for me as well..", "author": "1Jo1", "createdAt": "2020-09-07T11:12:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDI5NDQ1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDI5ODI5Nw==", "url": "https://github.com/netty/netty/pull/10538#discussion_r484298297", "bodyText": "An alternative to delay enqueueing the close operation, could be to enqueue it with the IOSQE_IO_DRAIN flag. Then the close operation will not be started until prior operations have completed, though following operations will also not be started until the close operation has completion, thus creating a slight queue hiccup. The hiccup might not be a big deal, though, compared to the state tracking we otherwise have to do.", "author": "chrisvest", "createdAt": "2020-09-07T09:09:04Z", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/AbstractIOUringChannel.java", "diffHunk": "@@ -327,23 +346,54 @@ private void doWriteMultiple(ChannelOutboundBuffer in) {\n      }\n \n     protected final void doWriteSingle(ByteBuf buf) {\n+        assert (ioState & WRITE_SCHEDULED) == 0;\n         IOUringSubmissionQueue submissionQueue = submissionQueue();\n         submissionQueue.addWrite(socket.intValue(), buf.memoryAddress(), buf.readerIndex(),\n                 buf.writerIndex());\n         ioState |= WRITE_SCHEDULED;\n     }\n \n     //POLLOUT\n-    private void addPollOut() {\n+    private void schedulePollOut() {\n         assert (ioState & POLL_OUT_SCHEDULED) == 0;\n-        ioState |= POLL_OUT_SCHEDULED;\n         IOUringSubmissionQueue submissionQueue = submissionQueue();\n         submissionQueue.addPollOut(socket.intValue());\n+        ioState |= POLL_OUT_SCHEDULED;\n+    }\n+\n+    void schedulePollRdHup() {\n+        assert (ioState & POLL_RDHUP_SCHEDULED) == 0;\n+        IOUringSubmissionQueue submissionQueue = submissionQueue();\n+        submissionQueue.addPollRdHup(fd().intValue());\n+        ioState |= POLL_RDHUP_SCHEDULED;\n     }\n \n     abstract class AbstractUringUnsafe extends AbstractUnsafe {\n         private IOUringRecvByteAllocatorHandle allocHandle;\n \n+        @Override\n+        public void close(ChannelPromise promise) {\n+            if ((ioState & (WRITE_SCHEDULED | READ_SCHEDULED | CONNECT_SCHEDULED)) == 0) {\n+                forceClose(promise);", "originalCommit": "ae5a8d795a2be7ec9e2f1fa7aefc2189fee4d8b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDMwNzg0Nw==", "url": "https://github.com/netty/netty/pull/10538#discussion_r484307847", "bodyText": "The problem with this is that this is not only about the \"close sys call\" but also about other state that is set in netty itself. So this will not help at all :)", "author": "normanmaurer", "createdAt": "2020-09-07T09:24:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDI5ODI5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDM1OTMxOQ==", "url": "https://github.com/netty/netty/pull/10538#discussion_r484359319", "bodyText": "it might cause an issue if we set IOSQE_IO_DRAIN, when some fd submit another fd polling event before, sqe wouldn't be executed as it waits until the socket is readable", "author": "1Jo1", "createdAt": "2020-09-07T11:00:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDI5ODI5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDMyNTE2NA==", "url": "https://github.com/netty/netty/pull/10538#discussion_r484325164", "bodyText": "This is not needed anymore as even with SO_LINGER we are fine as the close will not block this method ;)", "author": "normanmaurer", "createdAt": "2020-09-07T09:54:20Z", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/AbstractIOUringChannel.java", "diffHunk": "@@ -247,29 +243,16 @@ protected void doClose() throws Exception {\n \n             cancelConnectTimeoutFuture();\n \n-            if (isRegistered()) {\n-                // Need to check if we are on the EventLoop as doClose() may be triggered by the GlobalEventExecutor\n-                // if SO_LINGER is used.\n-                //\n-                // See https://github.com/netty/netty/issues/7159", "originalCommit": "657864aaae906e1195d7ec3546d2db0984be8dac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDMyNTU0OA==", "url": "https://github.com/netty/netty/pull/10538#discussion_r484325548", "bodyText": "I need this one for now... We will refactor this later on.", "author": "normanmaurer", "createdAt": "2020-09-07T09:55:02Z", "path": "transport-native-unix-common/src/main/java/io/netty/channel/unix/FileDescriptor.java", "diffHunk": "@@ -62,23 +62,28 @@ public final int intValue() {\n         return fd;\n     }\n \n-    /**\n-     * Close the file descriptor.\n-     */\n-    public void close() throws IOException {\n+    protected boolean markClosed() {", "originalCommit": "657864aaae906e1195d7ec3546d2db0984be8dac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDUyMzk1MQ==", "url": "https://github.com/netty/netty/pull/10538#discussion_r484523951", "bodyText": "nit: combine these?", "author": "njhill", "createdAt": "2020-09-07T17:01:57Z", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/AbstractIOUringChannel.java", "diffHunk": "@@ -288,6 +271,16 @@ protected void doWrite(ChannelOutboundBuffer in) {\n         if ((ioState & WRITE_SCHEDULED) != 0) {\n             return;\n         }\n+        scheduleWrite(in);\n+    }\n+\n+    private void scheduleWrite(ChannelOutboundBuffer in) {\n+        if (delayedClose != null) {\n+            return;\n+        }\n+        if (in == null) {\n+            return;\n+        }", "originalCommit": "657864aaae906e1195d7ec3546d2db0984be8dac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU0NjUyMQ==", "url": "https://github.com/netty/netty/pull/10538#discussion_r484546521", "bodyText": "nit: write -> io", "author": "njhill", "createdAt": "2020-09-07T19:00:31Z", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/AbstractIOUringChannel.java", "diffHunk": "@@ -327,23 +320,54 @@ private void doWriteMultiple(ChannelOutboundBuffer in) {\n      }\n \n     protected final void doWriteSingle(ByteBuf buf) {\n+        assert (ioState & WRITE_SCHEDULED) == 0;\n         IOUringSubmissionQueue submissionQueue = submissionQueue();\n         submissionQueue.addWrite(socket.intValue(), buf.memoryAddress(), buf.readerIndex(),\n                 buf.writerIndex());\n         ioState |= WRITE_SCHEDULED;\n     }\n \n     //POLLOUT\n-    private void addPollOut() {\n+    private void schedulePollOut() {\n         assert (ioState & POLL_OUT_SCHEDULED) == 0;\n-        ioState |= POLL_OUT_SCHEDULED;\n         IOUringSubmissionQueue submissionQueue = submissionQueue();\n         submissionQueue.addPollOut(socket.intValue());\n+        ioState |= POLL_OUT_SCHEDULED;\n+    }\n+\n+    void schedulePollRdHup() {\n+        assert (ioState & POLL_RDHUP_SCHEDULED) == 0;\n+        IOUringSubmissionQueue submissionQueue = submissionQueue();\n+        submissionQueue.addPollRdHup(fd().intValue());\n+        ioState |= POLL_RDHUP_SCHEDULED;\n     }\n \n     abstract class AbstractUringUnsafe extends AbstractUnsafe {\n         private IOUringRecvByteAllocatorHandle allocHandle;\n \n+        @Override\n+        public void close(ChannelPromise promise) {\n+            if ((ioState & (WRITE_SCHEDULED | READ_SCHEDULED | CONNECT_SCHEDULED)) == 0) {\n+                forceClose(promise);\n+            } else {\n+                if (delayedClose == null || delayedClose.isVoid()) {\n+                    // We have a write operation pending that should be completed asap.\n+                    // We will do the actual close operation one this write result is returned as otherwise\n+                    // we may get into trouble as we may close the fd while we did not process the write yet.", "originalCommit": "657864aaae906e1195d7ec3546d2db0984be8dac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU0NzU5Ng==", "url": "https://github.com/netty/netty/pull/10538#discussion_r484547596", "bodyText": "nit: else if?", "author": "njhill", "createdAt": "2020-09-07T19:06:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU0NjUyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU0NzcwMg==", "url": "https://github.com/netty/netty/pull/10538#discussion_r484547702", "bodyText": "nit: could simplify to:\n} else if (!promise.isVoid()) {\n    delayedClose.addListener(new ChannelPromiseNotifier(promise));\n}", "author": "njhill", "createdAt": "2020-09-07T19:07:34Z", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/AbstractIOUringChannel.java", "diffHunk": "@@ -327,23 +320,54 @@ private void doWriteMultiple(ChannelOutboundBuffer in) {\n      }\n \n     protected final void doWriteSingle(ByteBuf buf) {\n+        assert (ioState & WRITE_SCHEDULED) == 0;\n         IOUringSubmissionQueue submissionQueue = submissionQueue();\n         submissionQueue.addWrite(socket.intValue(), buf.memoryAddress(), buf.readerIndex(),\n                 buf.writerIndex());\n         ioState |= WRITE_SCHEDULED;\n     }\n \n     //POLLOUT\n-    private void addPollOut() {\n+    private void schedulePollOut() {\n         assert (ioState & POLL_OUT_SCHEDULED) == 0;\n-        ioState |= POLL_OUT_SCHEDULED;\n         IOUringSubmissionQueue submissionQueue = submissionQueue();\n         submissionQueue.addPollOut(socket.intValue());\n+        ioState |= POLL_OUT_SCHEDULED;\n+    }\n+\n+    void schedulePollRdHup() {\n+        assert (ioState & POLL_RDHUP_SCHEDULED) == 0;\n+        IOUringSubmissionQueue submissionQueue = submissionQueue();\n+        submissionQueue.addPollRdHup(fd().intValue());\n+        ioState |= POLL_RDHUP_SCHEDULED;\n     }\n \n     abstract class AbstractUringUnsafe extends AbstractUnsafe {\n         private IOUringRecvByteAllocatorHandle allocHandle;\n \n+        @Override\n+        public void close(ChannelPromise promise) {\n+            if ((ioState & (WRITE_SCHEDULED | READ_SCHEDULED | CONNECT_SCHEDULED)) == 0) {\n+                forceClose(promise);\n+            } else {\n+                if (delayedClose == null || delayedClose.isVoid()) {\n+                    // We have a write operation pending that should be completed asap.\n+                    // We will do the actual close operation one this write result is returned as otherwise\n+                    // we may get into trouble as we may close the fd while we did not process the write yet.\n+                    delayedClose = promise;\n+                } else {\n+                    if (promise.isVoid()) {\n+                        return;\n+                    }\n+                    delayedClose.addListener(new ChannelPromiseNotifier(promise));\n+                }", "originalCommit": "657864aaae906e1195d7ec3546d2db0984be8dac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU0ODUwMg==", "url": "https://github.com/netty/netty/pull/10538#discussion_r484548502", "bodyText": "clear RDHUP_SCHEDULED here?", "author": "njhill", "createdAt": "2020-09-07T19:12:18Z", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/AbstractIOUringChannel.java", "diffHunk": "@@ -464,6 +495,9 @@ final void readComplete(int res) {\n          * Called once POLLRDHUP event is ready to be processed\n          */\n         final void pollRdHup(int res) {", "originalCommit": "657864aaae906e1195d7ec3546d2db0984be8dac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU0OTQxMQ==", "url": "https://github.com/netty/netty/pull/10538#discussion_r484549411", "bodyText": "Could do as a follow-on but this would probably be cleaner to cover non-channel-specific cases first, then lookup the channel once and pass it to appropriate handler if non-null (rather than looking up separately in each of the handlers)", "author": "njhill", "createdAt": "2020-09-07T19:17:53Z", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringEventLoop.java", "diffHunk": "@@ -168,53 +168,69 @@ protected void run() {\n     @Override\n     public boolean handle(int fd, int res, long flags, int op, int pollMask) {\n         IOUringSubmissionQueue submissionQueue = ringBuffer.getIoUringSubmissionQueue();\n+        final AbstractIOUringChannel channel;", "originalCommit": "657864aaae906e1195d7ec3546d2db0984be8dac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDY4NDM4OQ==", "url": "https://github.com/netty/netty/pull/10538#discussion_r484684389", "bodyText": "let me do a followup", "author": "normanmaurer", "createdAt": "2020-09-08T06:41:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU0OTQxMQ=="}], "type": "inlineReview"}, {"oid": "354d0cbbcd95142604172f59d5f6e0a17d2af392", "url": "https://github.com/netty/netty/commit/354d0cbbcd95142604172f59d5f6e0a17d2af392", "message": "Fixes", "committedDate": "2020-09-08T19:46:15Z", "type": "forcePushed"}, {"oid": "1cc47c439952596fb5b55db4d4a85c5672f4d99d", "url": "https://github.com/netty/netty/commit/1cc47c439952596fb5b55db4d4a85c5672f4d99d", "message": "Only execute the close once the already added write operations completes\n\nMotivation:\n\nWe need to be careful that we only execute the close(...) once the write\noperation completes as otherwise we may close the underlying socket too\nfast and also the writes\n\nModifications:\n\nKeep track of if we need to delay the close or not and if so execute it\nonce the write completes\n\nResult:\n\nNo more test failures", "committedDate": "2020-09-09T07:59:27Z", "type": "commit"}, {"oid": "1cc47c439952596fb5b55db4d4a85c5672f4d99d", "url": "https://github.com/netty/netty/commit/1cc47c439952596fb5b55db4d4a85c5672f4d99d", "message": "Only execute the close once the already added write operations completes\n\nMotivation:\n\nWe need to be careful that we only execute the close(...) once the write\noperation completes as otherwise we may close the underlying socket too\nfast and also the writes\n\nModifications:\n\nKeep track of if we need to delay the close or not and if so execute it\nonce the write completes\n\nResult:\n\nNo more test failures", "committedDate": "2020-09-09T07:59:27Z", "type": "forcePushed"}]}