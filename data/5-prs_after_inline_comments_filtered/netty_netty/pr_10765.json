{"pr_number": 10765, "pr_title": "Add PushPromise and Priority Frame support in Http2FrameCodec", "pr_createdAt": "2020-11-02T18:58:17Z", "pr_url": "https://github.com/netty/netty/pull/10765", "timeline": [{"oid": "d296fd1892f3a0110fed5148089371f6b908f015", "url": "https://github.com/netty/netty/commit/d296fd1892f3a0110fed5148089371f6b908f015", "message": "Add PushPromiseRead support", "committedDate": "2020-11-02T18:55:07Z", "type": "commit"}, {"oid": "46dd775b7dc6dba8aff7e19e4937557276b2df52", "url": "https://github.com/netty/netty/commit/46dd775b7dc6dba8aff7e19e4937557276b2df52", "message": "change http2StreamFrame to stream", "committedDate": "2020-11-02T19:03:12Z", "type": "commit"}, {"oid": "24483ce917cc83b18d2ecc7ffafa3188b20b70cd", "url": "https://github.com/netty/netty/commit/24483ce917cc83b18d2ecc7ffafa3188b20b70cd", "message": "Add Priority Read and unit tests", "committedDate": "2020-11-07T08:40:36Z", "type": "commit"}, {"oid": "596a18eee1299fdbe61fd07cb4b196c06276e4e5", "url": "https://github.com/netty/netty/commit/596a18eee1299fdbe61fd07cb4b196c06276e4e5", "message": "Shutdown eventloopgroup in test once done", "committedDate": "2020-11-07T08:46:08Z", "type": "commit"}, {"oid": "d62b4793676b4bfb208a097b7f9d5d078d9a7b44", "url": "https://github.com/netty/netty/commit/d62b4793676b4bfb208a097b7f9d5d078d9a7b44", "message": "Release bytebuf", "committedDate": "2020-11-07T08:47:34Z", "type": "commit"}, {"oid": "e0694494c9bd9ba78c4635d47e29c00a59297289", "url": "https://github.com/netty/netty/commit/e0694494c9bd9ba78c4635d47e29c00a59297289", "message": "make #initializeNewStream public", "committedDate": "2020-11-08T12:45:01Z", "type": "commit"}, {"oid": "c362f6a2b2ad67a81b39f2ddf65f215565fc6703", "url": "https://github.com/netty/netty/commit/c362f6a2b2ad67a81b39f2ddf65f215565fc6703", "message": "Fix NPE", "committedDate": "2020-11-10T03:56:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDY2MDM1NQ==", "url": "https://github.com/netty/netty/pull/10765#discussion_r520660355", "bodyText": "Why 2?", "author": "bryce-anderson", "createdAt": "2020-11-10T15:39:48Z", "path": "codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2PushPromiseFrameTest.java", "diffHunk": "@@ -0,0 +1,223 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.http2;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelPipeline;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.util.CharsetUtil;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+public class DefaultHttp2PushPromiseFrameTest {\n+\n+    private final EventLoopGroup eventLoopGroup = new NioEventLoopGroup(2);", "originalCommit": "c362f6a2b2ad67a81b39f2ddf65f215565fc6703", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM5NzEzNQ==", "url": "https://github.com/netty/netty/pull/10765#discussion_r521397135", "bodyText": "Just wanted to give Server and Client dedicated threads.", "author": "hyperxpro", "createdAt": "2020-11-11T14:30:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDY2MDM1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDY4MTg2OQ==", "url": "https://github.com/netty/netty/pull/10765#discussion_r520681869", "bodyText": "It looks like we return the newly created stream id in two places: as the return value and as the newly populated http2FrameStream.id field. What do you think about making the return value of this method void and using the latter when it's necessary? To me, that avoids the ambiguity up higher as to whether we should use streamId returned by this method or pushPromiseFrame.pushStream().id() (or the parallel in the writeHeaders method).", "author": "bryce-anderson", "createdAt": "2020-11-10T16:07:18Z", "path": "codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java", "diffHunk": "@@ -436,6 +422,66 @@ public void operationComplete(ChannelFuture channelFuture) {\n         }\n     }\n \n+    private void writePushPromise(final ChannelHandlerContext ctx, Http2PushPromiseFrame pushPromiseFrame,\n+                                  final ChannelPromise promise) {\n+        if (isStreamIdValid(pushPromiseFrame.pushStream().id())) {\n+            encoder().writePushPromise(ctx, pushPromiseFrame.stream().id(), pushPromiseFrame.pushStream().id(),\n+                    pushPromiseFrame.http2Headers(), pushPromiseFrame.padding(), promise);\n+        } else {\n+            final int streamId = initializeNewStream(ctx, (DefaultHttp2FrameStream) pushPromiseFrame.pushStream(),\n+                    promise);\n+\n+            encoder().writePushPromise(ctx, pushPromiseFrame.stream().id(), streamId,\n+                    pushPromiseFrame.http2Headers(), pushPromiseFrame.padding(), promise);\n+\n+            if (!promise.isDone()) {\n+                numBufferedStreams++;\n+                // Clean up the stream being initialized if writing the headers fails and also\n+                // decrement the number of buffered streams.\n+                promise.addListener(new ChannelFutureListener() {\n+                    @Override\n+                    public void operationComplete(ChannelFuture channelFuture) {\n+                        numBufferedStreams--;\n+\n+                        handleHeaderFuture(channelFuture, streamId);\n+                    }\n+                });\n+            } else {\n+                handleHeaderFuture(promise, streamId);\n+            }\n+        }\n+    }\n+\n+    public int initializeNewStream(ChannelHandlerContext ctx, DefaultHttp2FrameStream http2FrameStream,", "originalCommit": "c362f6a2b2ad67a81b39f2ddf65f215565fc6703", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDY4NDY0MA==", "url": "https://github.com/netty/netty/pull/10765#discussion_r520684640", "bodyText": "ffti: it's easier to read these branches if you put the simple case first and you get an added bonus of being able to drop the boolean not operator from the predicate.", "author": "bryce-anderson", "createdAt": "2020-11-10T16:10:44Z", "path": "codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java", "diffHunk": "@@ -436,6 +422,66 @@ public void operationComplete(ChannelFuture channelFuture) {\n         }\n     }\n \n+    private void writePushPromise(final ChannelHandlerContext ctx, Http2PushPromiseFrame pushPromiseFrame,\n+                                  final ChannelPromise promise) {\n+        if (isStreamIdValid(pushPromiseFrame.pushStream().id())) {\n+            encoder().writePushPromise(ctx, pushPromiseFrame.stream().id(), pushPromiseFrame.pushStream().id(),\n+                    pushPromiseFrame.http2Headers(), pushPromiseFrame.padding(), promise);\n+        } else {\n+            final int streamId = initializeNewStream(ctx, (DefaultHttp2FrameStream) pushPromiseFrame.pushStream(),\n+                    promise);\n+\n+            encoder().writePushPromise(ctx, pushPromiseFrame.stream().id(), streamId,\n+                    pushPromiseFrame.http2Headers(), pushPromiseFrame.padding(), promise);\n+\n+            if (!promise.isDone()) {\n+                numBufferedStreams++;\n+                // Clean up the stream being initialized if writing the headers fails and also\n+                // decrement the number of buffered streams.\n+                promise.addListener(new ChannelFutureListener() {\n+                    @Override\n+                    public void operationComplete(ChannelFuture channelFuture) {\n+                        numBufferedStreams--;\n+\n+                        handleHeaderFuture(channelFuture, streamId);\n+                    }\n+                });\n+            } else {\n+                handleHeaderFuture(promise, streamId);\n+            }", "originalCommit": "c362f6a2b2ad67a81b39f2ddf65f215565fc6703", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM5ODgwOA==", "url": "https://github.com/netty/netty/pull/10765#discussion_r521398808", "bodyText": "Will fix this.", "author": "hyperxpro", "createdAt": "2020-11-11T14:32:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDY4NDY0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDY4OTE4Nw==", "url": "https://github.com/netty/netty/pull/10765#discussion_r520689187", "bodyText": "Would it be easier to just add the tests to Http2FrameCodecTest.java? It already has a well developed testing scaffold.", "author": "bryce-anderson", "createdAt": "2020-11-10T16:16:46Z", "path": "codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2PushPromiseFrameTest.java", "diffHunk": "@@ -0,0 +1,223 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.http2;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelPipeline;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.util.CharsetUtil;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+public class DefaultHttp2PushPromiseFrameTest {", "originalCommit": "c362f6a2b2ad67a81b39f2ddf65f215565fc6703", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM5ODU4Mw==", "url": "https://github.com/netty/netty/pull/10765#discussion_r521398583", "bodyText": "I tried but Http2FrameCodecTest.java was already big and complex and adding this made it 2x complex. So decided to move it into a separate test class.", "author": "hyperxpro", "createdAt": "2020-11-11T14:32:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDY4OTE4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDY4OTk5NQ==", "url": "https://github.com/netty/netty/pull/10765#discussion_r520689995", "bodyText": "In general, it's not a great idea to hard code ports for tests since you can't be sure they're available to you in all environments.", "author": "bryce-anderson", "createdAt": "2020-11-10T16:17:55Z", "path": "codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2PushPromiseFrameTest.java", "diffHunk": "@@ -0,0 +1,223 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.http2;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelPipeline;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.util.CharsetUtil;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+public class DefaultHttp2PushPromiseFrameTest {\n+\n+    private final EventLoopGroup eventLoopGroup = new NioEventLoopGroup(2);\n+    private final ClientHandler clientHandler = new ClientHandler();\n+    private final Map<Integer, String> contentMap = new ConcurrentHashMap<Integer, String>();\n+\n+    @Before\n+    public void setup() throws InterruptedException {\n+        ServerBootstrap serverBootstrap = new ServerBootstrap()\n+                .group(eventLoopGroup)\n+                .channel(NioServerSocketChannel.class)\n+                .childHandler(new ChannelInitializer<SocketChannel>() {\n+                    @Override\n+                    protected void initChannel(SocketChannel ch) {\n+                        ChannelPipeline pipeline = ch.pipeline();\n+\n+                        Http2FrameCodec frameCodec = Http2FrameCodecBuilder.forServer()\n+                                .autoAckSettingsFrame(true)\n+                                .autoAckPingFrame(true)\n+                                .build();\n+\n+                        pipeline.addLast(frameCodec);\n+                        pipeline.addLast(new ServerHandler());\n+                    }\n+                });\n+\n+        serverBootstrap.bind(\"127.0.0.1\", 5555);", "originalCommit": "c362f6a2b2ad67a81b39f2ddf65f215565fc6703", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM5ODcyNw==", "url": "https://github.com/netty/netty/pull/10765#discussion_r521398727", "bodyText": "Alright, will fix this.", "author": "hyperxpro", "createdAt": "2020-11-11T14:32:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDY4OTk5NQ=="}], "type": "inlineReview"}, {"oid": "d5b239bf7c284963a8b5ca225f6b4c0ecb61b643", "url": "https://github.com/netty/netty/commit/d5b239bf7c284963a8b5ca225f6b4c0ecb61b643", "message": "Swap handleHeaderFuture", "committedDate": "2020-11-11T17:58:14Z", "type": "commit"}, {"oid": "ddc57e0e04c87c9d98dc31e76ba87a02185aa9be", "url": "https://github.com/netty/netty/commit/ddc57e0e04c87c9d98dc31e76ba87a02185aa9be", "message": "Use automatic address binding", "committedDate": "2020-11-11T18:00:31Z", "type": "commit"}, {"oid": "313b2f84f83a914b94b050bb0d98fe0e7be75c1c", "url": "https://github.com/netty/netty/commit/313b2f84f83a914b94b050bb0d98fe0e7be75c1c", "message": "Simplify Stream Initialization", "committedDate": "2020-11-11T18:04:24Z", "type": "commit"}, {"oid": "317c54fdcf0daecec24ea60a4ef4ff319ab7e764", "url": "https://github.com/netty/netty/commit/317c54fdcf0daecec24ea60a4ef4ff319ab7e764", "message": "Use https instead of http", "committedDate": "2020-11-26T11:06:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzg0NTM2MA==", "url": "https://github.com/netty/netty/pull/10765#discussion_r547845360", "bodyText": "@hyperxpro why is this public ?", "author": "normanmaurer", "createdAt": "2020-12-23T09:19:07Z", "path": "codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java", "diffHunk": "@@ -436,6 +423,62 @@ public void operationComplete(ChannelFuture channelFuture) {\n         }\n     }\n \n+    private void writePushPromise(final ChannelHandlerContext ctx, Http2PushPromiseFrame pushPromiseFrame,\n+                                  final ChannelPromise promise) {\n+        if (isStreamIdValid(pushPromiseFrame.pushStream().id())) {\n+            encoder().writePushPromise(ctx, pushPromiseFrame.stream().id(), pushPromiseFrame.pushStream().id(),\n+                    pushPromiseFrame.http2Headers(), pushPromiseFrame.padding(), promise);\n+        } else {\n+            initializeNewStream(ctx, (DefaultHttp2FrameStream) pushPromiseFrame.pushStream(), promise);\n+            final int streamId = pushPromiseFrame.stream().id();\n+\n+            encoder().writePushPromise(ctx, streamId, pushPromiseFrame.pushStream().id(),\n+                    pushPromiseFrame.http2Headers(), pushPromiseFrame.padding(), promise);\n+\n+            if (promise.isDone()) {\n+                handleHeaderFuture(promise, streamId);\n+            } else {\n+                numBufferedStreams++;\n+                // Clean up the stream being initialized if writing the headers fails and also\n+                // decrement the number of buffered streams.\n+                promise.addListener(new ChannelFutureListener() {\n+                    @Override\n+                    public void operationComplete(ChannelFuture channelFuture) {\n+                        numBufferedStreams--;\n+\n+                        handleHeaderFuture(channelFuture, streamId);\n+                    }\n+                });\n+            }\n+        }\n+    }\n+\n+    public void initializeNewStream(ChannelHandlerContext ctx, DefaultHttp2FrameStream http2FrameStream,", "originalCommit": "317c54fdcf0daecec24ea60a4ef4ff319ab7e764", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzg0NzAxMg==", "url": "https://github.com/netty/netty/pull/10765#discussion_r547847012", "bodyText": "Also this should return boolean so when using this you can detect when it failed and when not to early return.", "author": "normanmaurer", "createdAt": "2020-12-23T09:21:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzg0NTM2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzkyMzA2Mw==", "url": "https://github.com/netty/netty/pull/10765#discussion_r547923063", "bodyText": "Some use case needs Stream ID to be generated early before sending HeadersFrame. That's why I made it public. If this approach is not good then I will change it back to package-private.\nMy use case:\nHttp2FrameCodec.DefaultHttp2FrameStream http2FrameStream = (Http2FrameCodec.DefaultHttp2FrameStream) newStream();\nframeCodec.initializeNewStream(ctx, http2FrameStream, promise);\nlong id = httpFrame.id();\n\n// Put the stream ID and Outbound Property into the map.\naddStream(new OutboundProperty(id, http2FrameStream, httpFrame.protocol()));", "author": "hyperxpro", "createdAt": "2020-12-23T11:56:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzg0NTM2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzk0MDIwOQ==", "url": "https://github.com/netty/netty/pull/10765#discussion_r547940209", "bodyText": "I think we need to solve this in a better way...  Maybe we should at least expose this via the Http2ChannelDuplexHandler", "author": "normanmaurer", "createdAt": "2020-12-23T12:41:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzg0NTM2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzg0NTkwNQ==", "url": "https://github.com/netty/netty/pull/10765#discussion_r547845905", "bodyText": "missing return.", "author": "normanmaurer", "createdAt": "2020-12-23T09:19:38Z", "path": "codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java", "diffHunk": "@@ -436,6 +423,62 @@ public void operationComplete(ChannelFuture channelFuture) {\n         }\n     }\n \n+    private void writePushPromise(final ChannelHandlerContext ctx, Http2PushPromiseFrame pushPromiseFrame,\n+                                  final ChannelPromise promise) {\n+        if (isStreamIdValid(pushPromiseFrame.pushStream().id())) {\n+            encoder().writePushPromise(ctx, pushPromiseFrame.stream().id(), pushPromiseFrame.pushStream().id(),\n+                    pushPromiseFrame.http2Headers(), pushPromiseFrame.padding(), promise);\n+        } else {\n+            initializeNewStream(ctx, (DefaultHttp2FrameStream) pushPromiseFrame.pushStream(), promise);\n+            final int streamId = pushPromiseFrame.stream().id();\n+\n+            encoder().writePushPromise(ctx, streamId, pushPromiseFrame.pushStream().id(),\n+                    pushPromiseFrame.http2Headers(), pushPromiseFrame.padding(), promise);\n+\n+            if (promise.isDone()) {\n+                handleHeaderFuture(promise, streamId);\n+            } else {\n+                numBufferedStreams++;\n+                // Clean up the stream being initialized if writing the headers fails and also\n+                // decrement the number of buffered streams.\n+                promise.addListener(new ChannelFutureListener() {\n+                    @Override\n+                    public void operationComplete(ChannelFuture channelFuture) {\n+                        numBufferedStreams--;\n+\n+                        handleHeaderFuture(channelFuture, streamId);\n+                    }\n+                });\n+            }\n+        }\n+    }\n+\n+    public void initializeNewStream(ChannelHandlerContext ctx, DefaultHttp2FrameStream http2FrameStream,\n+                                    ChannelPromise promise) {\n+        final Http2Connection connection = connection();\n+        final int streamId = connection.local().incrementAndGetNextStreamId();\n+        if (streamId < 0) {\n+            promise.setFailure(new Http2NoMoreStreamIdsException());\n+\n+            // Simulate a GOAWAY being received due to stream exhaustion on this connection. We use the maximum\n+            // valid stream ID for the current peer.\n+            onHttp2Frame(ctx, new DefaultHttp2GoAwayFrame(connection.isServer() ? Integer.MAX_VALUE :\n+                    Integer.MAX_VALUE - 1, NO_ERROR.code(),\n+                    writeAscii(ctx.alloc(), \"Stream IDs exhausted on local stream creation\")));", "originalCommit": "317c54fdcf0daecec24ea60a4ef4ff319ab7e764", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzg0NzUyMw==", "url": "https://github.com/netty/netty/pull/10765#discussion_r547847523", "bodyText": "like said below this should return a boolean and you should return early when the method failed.", "author": "normanmaurer", "createdAt": "2020-12-23T09:21:41Z", "path": "codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java", "diffHunk": "@@ -436,6 +423,62 @@ public void operationComplete(ChannelFuture channelFuture) {\n         }\n     }\n \n+    private void writePushPromise(final ChannelHandlerContext ctx, Http2PushPromiseFrame pushPromiseFrame,\n+                                  final ChannelPromise promise) {\n+        if (isStreamIdValid(pushPromiseFrame.pushStream().id())) {\n+            encoder().writePushPromise(ctx, pushPromiseFrame.stream().id(), pushPromiseFrame.pushStream().id(),\n+                    pushPromiseFrame.http2Headers(), pushPromiseFrame.padding(), promise);\n+        } else {\n+            initializeNewStream(ctx, (DefaultHttp2FrameStream) pushPromiseFrame.pushStream(), promise);", "originalCommit": "317c54fdcf0daecec24ea60a4ef4ff319ab7e764", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzkyNjIxMQ==", "url": "https://github.com/netty/netty/pull/10765#discussion_r547926211", "bodyText": "Sorry, I didn't get it completely. PTAL at latest commit and suggest.", "author": "hyperxpro", "createdAt": "2020-12-23T12:05:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzg0NzUyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzg0NzU3NQ==", "url": "https://github.com/netty/netty/pull/10765#discussion_r547847575", "bodyText": "like said below this should return a boolean and you should return early when the method failed.", "author": "normanmaurer", "createdAt": "2020-12-23T09:21:49Z", "path": "codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java", "diffHunk": "@@ -383,37 +392,15 @@ private void writeGoAwayFrame(ChannelHandlerContext ctx, Http2GoAwayFrame frame,\n         goAway(ctx, (int) lastStreamId, frame.errorCode(), frame.content(), promise);\n     }\n \n-    private void writeHeadersFrame(\n-            final ChannelHandlerContext ctx, Http2HeadersFrame headersFrame, final ChannelPromise promise) {\n+    private void writeHeadersFrame(final ChannelHandlerContext ctx, Http2HeadersFrame headersFrame,\n+                                   final ChannelPromise promise) {\n \n         if (isStreamIdValid(headersFrame.stream().id())) {\n             encoder().writeHeaders(ctx, headersFrame.stream().id(), headersFrame.headers(), headersFrame.padding(),\n                     headersFrame.isEndStream(), promise);\n         } else {\n-            final DefaultHttp2FrameStream stream = (DefaultHttp2FrameStream) headersFrame.stream();\n-            final Http2Connection connection = connection();\n-            final int streamId = connection.local().incrementAndGetNextStreamId();\n-            if (streamId < 0) {\n-                promise.setFailure(new Http2NoMoreStreamIdsException());\n-\n-                // Simulate a GOAWAY being received due to stream exhaustion on this connection. We use the maximum\n-                // valid stream ID for the current peer.\n-                onHttp2Frame(ctx, new DefaultHttp2GoAwayFrame(connection.isServer() ? Integer.MAX_VALUE :\n-                        Integer.MAX_VALUE - 1, NO_ERROR.code(),\n-                        writeAscii(ctx.alloc(), \"Stream IDs exhausted on local stream creation\")));\n-                return;\n-            }\n-            stream.id = streamId;\n-\n-            // Use a Map to store all pending streams as we may have multiple. This is needed as if we would store the\n-            // stream in a field directly we may override the stored field before onStreamAdded(...) was called\n-            // and so not correctly set the property for the buffered stream.\n-            //\n-            // See https://github.com/netty/netty/issues/8692\n-            Object old = frameStreamToInitializeMap.put(streamId, stream);\n-\n-            // We should not re-use ids.\n-            assert old == null;\n+            initializeNewStream(ctx, (DefaultHttp2FrameStream) headersFrame.stream(), promise);", "originalCommit": "317c54fdcf0daecec24ea60a4ef4ff319ab7e764", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "99820408095e4b1a8b72079955a58cf3e2d096ee", "url": "https://github.com/netty/netty/commit/99820408095e4b1a8b72079955a58cf3e2d096ee", "message": "address review", "committedDate": "2020-12-23T12:03:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzkyNjk2NA==", "url": "https://github.com/netty/netty/pull/10765#discussion_r547926964", "bodyText": "just merge these two lines", "author": "normanmaurer", "createdAt": "2020-12-23T12:06:55Z", "path": "codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java", "diffHunk": "@@ -383,59 +392,100 @@ private void writeGoAwayFrame(ChannelHandlerContext ctx, Http2GoAwayFrame frame,\n         goAway(ctx, (int) lastStreamId, frame.errorCode(), frame.content(), promise);\n     }\n \n-    private void writeHeadersFrame(\n-            final ChannelHandlerContext ctx, Http2HeadersFrame headersFrame, final ChannelPromise promise) {\n+    private void writeHeadersFrame(final ChannelHandlerContext ctx, Http2HeadersFrame headersFrame,\n+                                   final ChannelPromise promise) {\n \n         if (isStreamIdValid(headersFrame.stream().id())) {\n             encoder().writeHeaders(ctx, headersFrame.stream().id(), headersFrame.headers(), headersFrame.padding(),\n                     headersFrame.isEndStream(), promise);\n         } else {\n-            final DefaultHttp2FrameStream stream = (DefaultHttp2FrameStream) headersFrame.stream();\n-            final Http2Connection connection = connection();\n-            final int streamId = connection.local().incrementAndGetNextStreamId();\n-            if (streamId < 0) {\n-                promise.setFailure(new Http2NoMoreStreamIdsException());\n-\n-                // Simulate a GOAWAY being received due to stream exhaustion on this connection. We use the maximum\n-                // valid stream ID for the current peer.\n-                onHttp2Frame(ctx, new DefaultHttp2GoAwayFrame(connection.isServer() ? Integer.MAX_VALUE :\n-                        Integer.MAX_VALUE - 1, NO_ERROR.code(),\n-                        writeAscii(ctx.alloc(), \"Stream IDs exhausted on local stream creation\")));\n-                return;\n+            boolean init = initializeNewStream(ctx, (DefaultHttp2FrameStream) headersFrame.stream(), promise);\n+            if (init) {", "originalCommit": "99820408095e4b1a8b72079955a58cf3e2d096ee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzkyNzA0Nw==", "url": "https://github.com/netty/netty/pull/10765#discussion_r547927047", "bodyText": "just merge the two lines", "author": "normanmaurer", "createdAt": "2020-12-23T12:07:12Z", "path": "codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java", "diffHunk": "@@ -383,59 +392,100 @@ private void writeGoAwayFrame(ChannelHandlerContext ctx, Http2GoAwayFrame frame,\n         goAway(ctx, (int) lastStreamId, frame.errorCode(), frame.content(), promise);\n     }\n \n-    private void writeHeadersFrame(\n-            final ChannelHandlerContext ctx, Http2HeadersFrame headersFrame, final ChannelPromise promise) {\n+    private void writeHeadersFrame(final ChannelHandlerContext ctx, Http2HeadersFrame headersFrame,\n+                                   final ChannelPromise promise) {\n \n         if (isStreamIdValid(headersFrame.stream().id())) {\n             encoder().writeHeaders(ctx, headersFrame.stream().id(), headersFrame.headers(), headersFrame.padding(),\n                     headersFrame.isEndStream(), promise);\n         } else {\n-            final DefaultHttp2FrameStream stream = (DefaultHttp2FrameStream) headersFrame.stream();\n-            final Http2Connection connection = connection();\n-            final int streamId = connection.local().incrementAndGetNextStreamId();\n-            if (streamId < 0) {\n-                promise.setFailure(new Http2NoMoreStreamIdsException());\n-\n-                // Simulate a GOAWAY being received due to stream exhaustion on this connection. We use the maximum\n-                // valid stream ID for the current peer.\n-                onHttp2Frame(ctx, new DefaultHttp2GoAwayFrame(connection.isServer() ? Integer.MAX_VALUE :\n-                        Integer.MAX_VALUE - 1, NO_ERROR.code(),\n-                        writeAscii(ctx.alloc(), \"Stream IDs exhausted on local stream creation\")));\n-                return;\n+            boolean init = initializeNewStream(ctx, (DefaultHttp2FrameStream) headersFrame.stream(), promise);\n+            if (init) {\n+                final int streamId = headersFrame.stream().id();\n+\n+                encoder().writeHeaders(ctx, streamId, headersFrame.headers(), headersFrame.padding(),\n+                        headersFrame.isEndStream(), promise);\n+\n+                if (!promise.isDone()) {\n+                    numBufferedStreams++;\n+                    // Clean up the stream being initialized if writing the headers fails and also\n+                    // decrement the number of buffered streams.\n+                    promise.addListener(new ChannelFutureListener() {\n+                        @Override\n+                        public void operationComplete(ChannelFuture channelFuture) {\n+                            numBufferedStreams--;\n+\n+                            handleHeaderFuture(channelFuture, streamId);\n+                        }\n+                    });\n+                } else {\n+                    handleHeaderFuture(promise, streamId);\n+                }\n             }\n-            stream.id = streamId;\n-\n-            // Use a Map to store all pending streams as we may have multiple. This is needed as if we would store the\n-            // stream in a field directly we may override the stored field before onStreamAdded(...) was called\n-            // and so not correctly set the property for the buffered stream.\n-            //\n-            // See https://github.com/netty/netty/issues/8692\n-            Object old = frameStreamToInitializeMap.put(streamId, stream);\n-\n-            // We should not re-use ids.\n-            assert old == null;\n+        }\n+    }\n \n-            encoder().writeHeaders(ctx, streamId, headersFrame.headers(), headersFrame.padding(),\n-                    headersFrame.isEndStream(), promise);\n+    private void writePushPromise(final ChannelHandlerContext ctx, Http2PushPromiseFrame pushPromiseFrame,\n+                                  final ChannelPromise promise) {\n+        if (isStreamIdValid(pushPromiseFrame.pushStream().id())) {\n+            encoder().writePushPromise(ctx, pushPromiseFrame.stream().id(), pushPromiseFrame.pushStream().id(),\n+                    pushPromiseFrame.http2Headers(), pushPromiseFrame.padding(), promise);\n+        } else {\n+            boolean init = initializeNewStream(ctx, (DefaultHttp2FrameStream) pushPromiseFrame.pushStream(), promise);\n+            if (init) {", "originalCommit": "99820408095e4b1a8b72079955a58cf3e2d096ee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzkyNzI4MA==", "url": "https://github.com/netty/netty/pull/10765#discussion_r547927280", "bodyText": "So I strongly believe this should not be public... If the user needs this method we need to find a better way of exposing this", "author": "normanmaurer", "createdAt": "2020-12-23T12:07:55Z", "path": "codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java", "diffHunk": "@@ -383,59 +392,100 @@ private void writeGoAwayFrame(ChannelHandlerContext ctx, Http2GoAwayFrame frame,\n         goAway(ctx, (int) lastStreamId, frame.errorCode(), frame.content(), promise);\n     }\n \n-    private void writeHeadersFrame(\n-            final ChannelHandlerContext ctx, Http2HeadersFrame headersFrame, final ChannelPromise promise) {\n+    private void writeHeadersFrame(final ChannelHandlerContext ctx, Http2HeadersFrame headersFrame,\n+                                   final ChannelPromise promise) {\n \n         if (isStreamIdValid(headersFrame.stream().id())) {\n             encoder().writeHeaders(ctx, headersFrame.stream().id(), headersFrame.headers(), headersFrame.padding(),\n                     headersFrame.isEndStream(), promise);\n         } else {\n-            final DefaultHttp2FrameStream stream = (DefaultHttp2FrameStream) headersFrame.stream();\n-            final Http2Connection connection = connection();\n-            final int streamId = connection.local().incrementAndGetNextStreamId();\n-            if (streamId < 0) {\n-                promise.setFailure(new Http2NoMoreStreamIdsException());\n-\n-                // Simulate a GOAWAY being received due to stream exhaustion on this connection. We use the maximum\n-                // valid stream ID for the current peer.\n-                onHttp2Frame(ctx, new DefaultHttp2GoAwayFrame(connection.isServer() ? Integer.MAX_VALUE :\n-                        Integer.MAX_VALUE - 1, NO_ERROR.code(),\n-                        writeAscii(ctx.alloc(), \"Stream IDs exhausted on local stream creation\")));\n-                return;\n+            boolean init = initializeNewStream(ctx, (DefaultHttp2FrameStream) headersFrame.stream(), promise);\n+            if (init) {\n+                final int streamId = headersFrame.stream().id();\n+\n+                encoder().writeHeaders(ctx, streamId, headersFrame.headers(), headersFrame.padding(),\n+                        headersFrame.isEndStream(), promise);\n+\n+                if (!promise.isDone()) {\n+                    numBufferedStreams++;\n+                    // Clean up the stream being initialized if writing the headers fails and also\n+                    // decrement the number of buffered streams.\n+                    promise.addListener(new ChannelFutureListener() {\n+                        @Override\n+                        public void operationComplete(ChannelFuture channelFuture) {\n+                            numBufferedStreams--;\n+\n+                            handleHeaderFuture(channelFuture, streamId);\n+                        }\n+                    });\n+                } else {\n+                    handleHeaderFuture(promise, streamId);\n+                }\n             }\n-            stream.id = streamId;\n-\n-            // Use a Map to store all pending streams as we may have multiple. This is needed as if we would store the\n-            // stream in a field directly we may override the stored field before onStreamAdded(...) was called\n-            // and so not correctly set the property for the buffered stream.\n-            //\n-            // See https://github.com/netty/netty/issues/8692\n-            Object old = frameStreamToInitializeMap.put(streamId, stream);\n-\n-            // We should not re-use ids.\n-            assert old == null;\n+        }\n+    }\n \n-            encoder().writeHeaders(ctx, streamId, headersFrame.headers(), headersFrame.padding(),\n-                    headersFrame.isEndStream(), promise);\n+    private void writePushPromise(final ChannelHandlerContext ctx, Http2PushPromiseFrame pushPromiseFrame,\n+                                  final ChannelPromise promise) {\n+        if (isStreamIdValid(pushPromiseFrame.pushStream().id())) {\n+            encoder().writePushPromise(ctx, pushPromiseFrame.stream().id(), pushPromiseFrame.pushStream().id(),\n+                    pushPromiseFrame.http2Headers(), pushPromiseFrame.padding(), promise);\n+        } else {\n+            boolean init = initializeNewStream(ctx, (DefaultHttp2FrameStream) pushPromiseFrame.pushStream(), promise);\n+            if (init) {\n+                final int streamId = pushPromiseFrame.stream().id();\n \n-            if (!promise.isDone()) {\n-                numBufferedStreams++;\n-                // Clean up the stream being initialized if writing the headers fails and also\n-                // decrement the number of buffered streams.\n-                promise.addListener(new ChannelFutureListener() {\n-                    @Override\n-                    public void operationComplete(ChannelFuture channelFuture) {\n-                        numBufferedStreams--;\n+                encoder().writePushPromise(ctx, streamId, pushPromiseFrame.pushStream().id(),\n+                        pushPromiseFrame.http2Headers(), pushPromiseFrame.padding(), promise);\n \n-                        handleHeaderFuture(channelFuture, streamId);\n-                    }\n-                });\n-            } else {\n-                handleHeaderFuture(promise, streamId);\n+                if (promise.isDone()) {\n+                    handleHeaderFuture(promise, streamId);\n+                } else {\n+                    numBufferedStreams++;\n+                    // Clean up the stream being initialized if writing the headers fails and also\n+                    // decrement the number of buffered streams.\n+                    promise.addListener(new ChannelFutureListener() {\n+                        @Override\n+                        public void operationComplete(ChannelFuture channelFuture) {\n+                            numBufferedStreams--;\n+\n+                            handleHeaderFuture(channelFuture, streamId);\n+                        }\n+                    });\n+                }\n             }\n         }\n     }\n \n+    public boolean initializeNewStream(ChannelHandlerContext ctx, DefaultHttp2FrameStream http2FrameStream,", "originalCommit": "99820408095e4b1a8b72079955a58cf3e2d096ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA0NTUwNA==", "url": "https://github.com/netty/netty/pull/10765#discussion_r548045504", "bodyText": "@hyperxpro ^^", "author": "normanmaurer", "createdAt": "2020-12-23T16:39:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzkyNzI4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzkyNzY0MA==", "url": "https://github.com/netty/netty/pull/10765#discussion_r547927640", "bodyText": "Seeing a sleep here seems like there needs to be something else that needs to be fixed", "author": "normanmaurer", "createdAt": "2020-12-23T12:08:47Z", "path": "codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2PushPromiseFrameTest.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.http2;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelPipeline;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.util.CharsetUtil;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+public class DefaultHttp2PushPromiseFrameTest {\n+\n+    private final EventLoopGroup eventLoopGroup = new NioEventLoopGroup(2);\n+    private final ClientHandler clientHandler = new ClientHandler();\n+    private final Map<Integer, String> contentMap = new ConcurrentHashMap<Integer, String>();\n+\n+    @Before\n+    public void setup() throws InterruptedException {\n+        ServerBootstrap serverBootstrap = new ServerBootstrap()\n+                .group(eventLoopGroup)\n+                .channel(NioServerSocketChannel.class)\n+                .childHandler(new ChannelInitializer<SocketChannel>() {\n+                    @Override\n+                    protected void initChannel(SocketChannel ch) {\n+                        ChannelPipeline pipeline = ch.pipeline();\n+\n+                        Http2FrameCodec frameCodec = Http2FrameCodecBuilder.forServer()\n+                                .autoAckSettingsFrame(true)\n+                                .autoAckPingFrame(true)\n+                                .build();\n+\n+                        pipeline.addLast(frameCodec);\n+                        pipeline.addLast(new ServerHandler());\n+                    }\n+                });\n+\n+        ChannelFuture channelFuture = serverBootstrap.bind(0).sync();\n+\n+        final Bootstrap bootstrap = new Bootstrap()\n+                .group(eventLoopGroup)\n+                .channel(NioSocketChannel.class)\n+                .handler(new ChannelInitializer<SocketChannel>() {\n+                    @Override\n+                    protected void initChannel(SocketChannel ch) {\n+                        ChannelPipeline pipeline = ch.pipeline();\n+\n+                        Http2FrameCodec frameCodec = Http2FrameCodecBuilder.forClient()\n+                                .autoAckSettingsFrame(true)\n+                                .autoAckPingFrame(true)\n+                                .initialSettings(Http2Settings.defaultSettings().pushEnabled(true))\n+                                .build();\n+\n+                        pipeline.addLast(frameCodec);\n+                        pipeline.addLast(clientHandler);\n+                    }\n+                });\n+\n+        bootstrap.connect(channelFuture.channel().localAddress()).sync();\n+    }\n+\n+    @Test\n+    public void send() throws InterruptedException {\n+        Thread.sleep(100);", "originalCommit": "99820408095e4b1a8b72079955a58cf3e2d096ee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ee7ff80e555ecf30beac89b424904e859de4ae94", "url": "https://github.com/netty/netty/commit/ee7ff80e555ecf30beac89b424904e859de4ae94", "message": "fix more issues", "committedDate": "2020-12-23T12:22:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzkzNTM1OQ==", "url": "https://github.com/netty/netty/pull/10765#discussion_r547935359", "bodyText": "This should have no get prefix... Also it missed javadocs. Beside this I wonder why this is not part of the interface ?", "author": "normanmaurer", "createdAt": "2020-12-23T12:28:55Z", "path": "codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2PushPromiseFrame.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.http2;\n+\n+/**\n+ * Default implementation of {@link Http2PushPromiseFrame}\n+ */\n+public class DefaultHttp2PushPromiseFrame implements Http2PushPromiseFrame {\n+\n+    private Http2FrameStream pushStreamFrame;\n+    private final Http2Headers http2Headers;\n+    private Http2FrameStream streamFrame;\n+    private final int padding;\n+    private final int promisedStreamId;\n+\n+    public DefaultHttp2PushPromiseFrame(Http2Headers http2Headers) {\n+        this(http2Headers, 0);\n+    }\n+\n+    public DefaultHttp2PushPromiseFrame(Http2Headers http2Headers, int padding) {\n+        this(http2Headers, padding, -1);\n+    }\n+\n+    DefaultHttp2PushPromiseFrame(Http2Headers http2Headers, int padding, int promisedStreamId) {\n+        this.http2Headers = http2Headers;\n+        this.padding = padding;\n+        this.promisedStreamId = promisedStreamId;\n+    }\n+\n+    @Override\n+    public Http2StreamFrame pushStream(Http2FrameStream stream) {\n+        pushStreamFrame = stream;\n+        return this;\n+    }\n+\n+    @Override\n+    public Http2FrameStream pushStream() {\n+        return pushStreamFrame;\n+    }\n+\n+    @Override\n+    public Http2Headers http2Headers() {\n+        return http2Headers;\n+    }\n+\n+    @Override\n+    public int padding() {\n+        return padding;\n+    }\n+\n+    @Override\n+    public Http2StreamFrame stream(Http2FrameStream stream) {\n+        streamFrame = stream;\n+        return this;\n+    }\n+\n+    @Override\n+    public Http2FrameStream stream() {\n+        return streamFrame;\n+    }\n+\n+    public int getPromisedStreamId() {", "originalCommit": "ee7ff80e555ecf30beac89b424904e859de4ae94", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzkzNTcyMg==", "url": "https://github.com/netty/netty/pull/10765#discussion_r547935722", "bodyText": "never call sync() in the eventloop. Remove this call and also remove the throws...", "author": "normanmaurer", "createdAt": "2020-12-23T12:29:49Z", "path": "codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2PushPromiseFrameTest.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.http2;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelPipeline;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.util.CharsetUtil;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+public class DefaultHttp2PushPromiseFrameTest {\n+\n+    private final EventLoopGroup eventLoopGroup = new NioEventLoopGroup(2);\n+    private final ClientHandler clientHandler = new ClientHandler();\n+    private final Map<Integer, String> contentMap = new ConcurrentHashMap<Integer, String>();\n+\n+    private ChannelFuture connectionFuture;\n+\n+    @Before\n+    public void setup() throws InterruptedException {\n+        ServerBootstrap serverBootstrap = new ServerBootstrap()\n+                .group(eventLoopGroup)\n+                .channel(NioServerSocketChannel.class)\n+                .childHandler(new ChannelInitializer<SocketChannel>() {\n+                    @Override\n+                    protected void initChannel(SocketChannel ch) {\n+                        ChannelPipeline pipeline = ch.pipeline();\n+\n+                        Http2FrameCodec frameCodec = Http2FrameCodecBuilder.forServer()\n+                                .autoAckSettingsFrame(true)\n+                                .autoAckPingFrame(true)\n+                                .build();\n+\n+                        pipeline.addLast(frameCodec);\n+                        pipeline.addLast(new ServerHandler());\n+                    }\n+                });\n+\n+        ChannelFuture channelFuture = serverBootstrap.bind(0).sync();\n+\n+        final Bootstrap bootstrap = new Bootstrap()\n+                .group(eventLoopGroup)\n+                .channel(NioSocketChannel.class)\n+                .handler(new ChannelInitializer<SocketChannel>() {\n+                    @Override\n+                    protected void initChannel(SocketChannel ch) {\n+                        ChannelPipeline pipeline = ch.pipeline();\n+\n+                        Http2FrameCodec frameCodec = Http2FrameCodecBuilder.forClient()\n+                                .autoAckSettingsFrame(true)\n+                                .autoAckPingFrame(true)\n+                                .initialSettings(Http2Settings.defaultSettings().pushEnabled(true))\n+                                .build();\n+\n+                        pipeline.addLast(frameCodec);\n+                        pipeline.addLast(clientHandler);\n+                    }\n+                });\n+\n+        connectionFuture = bootstrap.connect(channelFuture.channel().localAddress());\n+    }\n+\n+    @Test\n+    public void send() throws InterruptedException {\n+        connectionFuture.sync();\n+    }\n+\n+    @After\n+    public void shutdown() {\n+        eventLoopGroup.shutdownGracefully();\n+    }\n+\n+    private final class ServerHandler extends Http2ChannelDuplexHandler {\n+\n+        @Override\n+        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n+\n+            if (msg instanceof Http2HeadersFrame) {\n+                Http2HeadersFrame receivedFrame = (Http2HeadersFrame) msg;\n+\n+                Http2Headers pushRequestHeaders = new DefaultHttp2Headers();\n+                pushRequestHeaders.path(\"/meow\")\n+                        .method(\"GET\")\n+                        .scheme(\"https\")\n+                        .authority(\"localhost:5555\");\n+\n+                // Write PUSH_PROMISE request headers\n+                Http2FrameStream newPushFrameStream = newStream();\n+                Http2PushPromiseFrame pushPromiseFrame = new DefaultHttp2PushPromiseFrame(pushRequestHeaders);\n+                pushPromiseFrame.stream(receivedFrame.stream());\n+                pushPromiseFrame.pushStream(newPushFrameStream);\n+                ctx.writeAndFlush(pushPromiseFrame).sync();\n+\n+                contentMap.put(newPushFrameStream.id(), \"Meow, I am Pushed via HTTP/2\");\n+\n+                // Write headers for actual request\n+                Http2Headers http2Headers = new DefaultHttp2Headers();\n+                http2Headers.status(\"200\");\n+                http2Headers.add(\"push\", \"false\");\n+                Http2HeadersFrame headersFrame = new DefaultHttp2HeadersFrame(http2Headers, false);\n+                headersFrame.stream(receivedFrame.stream());\n+                ctx.writeAndFlush(headersFrame).sync();\n+\n+                // Write Data of actual request\n+                Http2DataFrame dataFrame = new DefaultHttp2DataFrame(Unpooled.wrappedBuffer(\"Meow\".getBytes()), true);\n+                dataFrame.stream(receivedFrame.stream());\n+                ctx.writeAndFlush(dataFrame).sync();\n+            } else if (msg instanceof Http2PriorityFrame) {\n+                Http2PriorityFrame priorityFrame = (Http2PriorityFrame) msg;\n+                String content = contentMap.get(priorityFrame.stream().id());\n+                if (content == null) {\n+                    ctx.writeAndFlush(new DefaultHttp2GoAwayFrame(Http2Error.REFUSED_STREAM));\n+                    return;\n+                }\n+\n+                // Write headers for Priority request\n+                Http2Headers http2Headers = new DefaultHttp2Headers();\n+                http2Headers.status(\"200\");\n+                http2Headers.add(\"push\", \"true\");\n+                Http2HeadersFrame headersFrame = new DefaultHttp2HeadersFrame(http2Headers, false);\n+                headersFrame.stream(priorityFrame.stream());\n+                ctx.writeAndFlush(headersFrame).sync();\n+\n+                // Write Data of Priority request\n+                Http2DataFrame dataFrame = new DefaultHttp2DataFrame(Unpooled.wrappedBuffer(content.getBytes()), true);\n+                dataFrame.stream(priorityFrame.stream());\n+                ctx.writeAndFlush(dataFrame).sync();\n+            }\n+        }\n+    }\n+\n+    private static final class ClientHandler extends Http2ChannelDuplexHandler {\n+\n+        @Override\n+        public void channelActive(ChannelHandlerContext ctx) throws InterruptedException {\n+            Http2Headers http2Headers = new DefaultHttp2Headers();\n+            http2Headers.path(\"/\")\n+                    .authority(\"localhost\")\n+                    .method(\"GET\")\n+                    .scheme(\"https\");\n+\n+            Http2HeadersFrame headersFrame = new DefaultHttp2HeadersFrame(http2Headers, true);\n+            headersFrame.stream(newStream());\n+            ctx.writeAndFlush(headersFrame).sync();", "originalCommit": "ee7ff80e555ecf30beac89b424904e859de4ae94", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzkzODk2Ng==", "url": "https://github.com/netty/netty/pull/10765#discussion_r547938966", "bodyText": "Then I get NPE if I don't block it with something. That's why I had Thread#sleep.", "author": "hyperxpro", "createdAt": "2020-12-23T12:38:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzkzNTcyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzk0MDMyOA==", "url": "https://github.com/netty/netty/pull/10765#discussion_r547940328", "bodyText": "show me the stack trace", "author": "normanmaurer", "createdAt": "2020-12-23T12:41:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzkzNTcyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzk0NDk4Ng==", "url": "https://github.com/netty/netty/pull/10765#discussion_r547944986", "bodyText": "Tried adding a listener. PTAL.", "author": "hyperxpro", "createdAt": "2020-12-23T12:54:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzkzNTcyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzkzNTkwMw==", "url": "https://github.com/netty/netty/pull/10765#discussion_r547935903", "bodyText": "nit: you could even merge this with the else and make it if else", "author": "normanmaurer", "createdAt": "2020-12-23T12:30:20Z", "path": "codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java", "diffHunk": "@@ -383,59 +392,98 @@ private void writeGoAwayFrame(ChannelHandlerContext ctx, Http2GoAwayFrame frame,\n         goAway(ctx, (int) lastStreamId, frame.errorCode(), frame.content(), promise);\n     }\n \n-    private void writeHeadersFrame(\n-            final ChannelHandlerContext ctx, Http2HeadersFrame headersFrame, final ChannelPromise promise) {\n+    private void writeHeadersFrame(final ChannelHandlerContext ctx, Http2HeadersFrame headersFrame,\n+                                   final ChannelPromise promise) {\n \n         if (isStreamIdValid(headersFrame.stream().id())) {\n             encoder().writeHeaders(ctx, headersFrame.stream().id(), headersFrame.headers(), headersFrame.padding(),\n                     headersFrame.isEndStream(), promise);\n         } else {\n-            final DefaultHttp2FrameStream stream = (DefaultHttp2FrameStream) headersFrame.stream();\n-            final Http2Connection connection = connection();\n-            final int streamId = connection.local().incrementAndGetNextStreamId();\n-            if (streamId < 0) {\n-                promise.setFailure(new Http2NoMoreStreamIdsException());\n-\n-                // Simulate a GOAWAY being received due to stream exhaustion on this connection. We use the maximum\n-                // valid stream ID for the current peer.\n-                onHttp2Frame(ctx, new DefaultHttp2GoAwayFrame(connection.isServer() ? Integer.MAX_VALUE :\n-                        Integer.MAX_VALUE - 1, NO_ERROR.code(),\n-                        writeAscii(ctx.alloc(), \"Stream IDs exhausted on local stream creation\")));\n-                return;\n+            if (initializeNewStream(ctx, (DefaultHttp2FrameStream) headersFrame.stream(), promise)) {", "originalCommit": "ee7ff80e555ecf30beac89b424904e859de4ae94", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzkzNTk4MQ==", "url": "https://github.com/netty/netty/pull/10765#discussion_r547935981", "bodyText": "nit: you could even merge this with the else and make it if else", "author": "normanmaurer", "createdAt": "2020-12-23T12:30:31Z", "path": "codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java", "diffHunk": "@@ -383,59 +392,98 @@ private void writeGoAwayFrame(ChannelHandlerContext ctx, Http2GoAwayFrame frame,\n         goAway(ctx, (int) lastStreamId, frame.errorCode(), frame.content(), promise);\n     }\n \n-    private void writeHeadersFrame(\n-            final ChannelHandlerContext ctx, Http2HeadersFrame headersFrame, final ChannelPromise promise) {\n+    private void writeHeadersFrame(final ChannelHandlerContext ctx, Http2HeadersFrame headersFrame,\n+                                   final ChannelPromise promise) {\n \n         if (isStreamIdValid(headersFrame.stream().id())) {\n             encoder().writeHeaders(ctx, headersFrame.stream().id(), headersFrame.headers(), headersFrame.padding(),\n                     headersFrame.isEndStream(), promise);\n         } else {\n-            final DefaultHttp2FrameStream stream = (DefaultHttp2FrameStream) headersFrame.stream();\n-            final Http2Connection connection = connection();\n-            final int streamId = connection.local().incrementAndGetNextStreamId();\n-            if (streamId < 0) {\n-                promise.setFailure(new Http2NoMoreStreamIdsException());\n-\n-                // Simulate a GOAWAY being received due to stream exhaustion on this connection. We use the maximum\n-                // valid stream ID for the current peer.\n-                onHttp2Frame(ctx, new DefaultHttp2GoAwayFrame(connection.isServer() ? Integer.MAX_VALUE :\n-                        Integer.MAX_VALUE - 1, NO_ERROR.code(),\n-                        writeAscii(ctx.alloc(), \"Stream IDs exhausted on local stream creation\")));\n-                return;\n+            if (initializeNewStream(ctx, (DefaultHttp2FrameStream) headersFrame.stream(), promise)) {\n+                final int streamId = headersFrame.stream().id();\n+\n+                encoder().writeHeaders(ctx, streamId, headersFrame.headers(), headersFrame.padding(),\n+                        headersFrame.isEndStream(), promise);\n+\n+                if (!promise.isDone()) {\n+                    numBufferedStreams++;\n+                    // Clean up the stream being initialized if writing the headers fails and also\n+                    // decrement the number of buffered streams.\n+                    promise.addListener(new ChannelFutureListener() {\n+                        @Override\n+                        public void operationComplete(ChannelFuture channelFuture) {\n+                            numBufferedStreams--;\n+\n+                            handleHeaderFuture(channelFuture, streamId);\n+                        }\n+                    });\n+                } else {\n+                    handleHeaderFuture(promise, streamId);\n+                }\n             }\n-            stream.id = streamId;\n-\n-            // Use a Map to store all pending streams as we may have multiple. This is needed as if we would store the\n-            // stream in a field directly we may override the stored field before onStreamAdded(...) was called\n-            // and so not correctly set the property for the buffered stream.\n-            //\n-            // See https://github.com/netty/netty/issues/8692\n-            Object old = frameStreamToInitializeMap.put(streamId, stream);\n-\n-            // We should not re-use ids.\n-            assert old == null;\n+        }\n+    }\n \n-            encoder().writeHeaders(ctx, streamId, headersFrame.headers(), headersFrame.padding(),\n-                    headersFrame.isEndStream(), promise);\n+    private void writePushPromise(final ChannelHandlerContext ctx, Http2PushPromiseFrame pushPromiseFrame,\n+                                  final ChannelPromise promise) {\n+        if (isStreamIdValid(pushPromiseFrame.pushStream().id())) {\n+            encoder().writePushPromise(ctx, pushPromiseFrame.stream().id(), pushPromiseFrame.pushStream().id(),\n+                    pushPromiseFrame.http2Headers(), pushPromiseFrame.padding(), promise);\n+        } else {\n+            if (initializeNewStream(ctx, (DefaultHttp2FrameStream) pushPromiseFrame.pushStream(), promise)) {", "originalCommit": "ee7ff80e555ecf30beac89b424904e859de4ae94", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4cbf31a0e3a7015c3ca4921551ed1606f50b2513", "url": "https://github.com/netty/netty/commit/4cbf31a0e3a7015c3ca4921551ed1606f50b2513", "message": "use if-else", "committedDate": "2020-12-23T12:46:41Z", "type": "commit"}, {"oid": "2787177868efd17479d6b4b06c2fb6b2cd2c0edd", "url": "https://github.com/netty/netty/commit/2787177868efd17479d6b4b06c2fb6b2cd2c0edd", "message": "use listener", "committedDate": "2020-12-23T12:53:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzk1MDkyMg==", "url": "https://github.com/netty/netty/pull/10765#discussion_r547950922", "bodyText": "This method should not block... You need to not call sync() in it when you call it in a handler", "author": "normanmaurer", "createdAt": "2020-12-23T13:09:23Z", "path": "codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2PushPromiseFrameTest.java", "diffHunk": "@@ -90,8 +91,17 @@ protected void initChannel(SocketChannel ch) {\n     }\n \n     @Test\n-    public void send() throws InterruptedException {\n-        connectionFuture.sync();\n+    public void send() {\n+        connectionFuture.addListener(new ChannelFutureListener() {\n+            @Override\n+            public void operationComplete(ChannelFuture future) {\n+                try {\n+                    clientHandler.write();", "originalCommit": "2787177868efd17479d6b4b06c2fb6b2cd2c0edd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzk1Mjc3Ng==", "url": "https://github.com/netty/netty/pull/10765#discussion_r547952776", "bodyText": "Done", "author": "hyperxpro", "createdAt": "2020-12-23T13:14:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzk1MDkyMg=="}], "type": "inlineReview"}, {"oid": "d673e90e71fba557ca91701afaea419d788c3e8c", "url": "https://github.com/netty/netty/commit/d673e90e71fba557ca91701afaea419d788c3e8c", "message": "dont block", "committedDate": "2020-12-23T13:13:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA0NTAxNg==", "url": "https://github.com/netty/netty/pull/10765#discussion_r548045016", "bodyText": "final...", "author": "normanmaurer", "createdAt": "2020-12-23T16:38:19Z", "path": "codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2PriorityFrame.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.http2;\n+\n+/**\n+ * Default implementation of {@linkplain Http2PriorityFrame}\n+ */\n+public class DefaultHttp2PriorityFrame implements Http2PriorityFrame {", "originalCommit": "d673e90e71fba557ca91701afaea419d788c3e8c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA0NTA5MQ==", "url": "https://github.com/netty/netty/pull/10765#discussion_r548045091", "bodyText": "Add @UnstableApi", "author": "normanmaurer", "createdAt": "2020-12-23T16:38:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA0NTAxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA0NTE2Ng==", "url": "https://github.com/netty/netty/pull/10765#discussion_r548045166", "bodyText": "final\nAdd @UnstableApi", "author": "normanmaurer", "createdAt": "2020-12-23T16:38:37Z", "path": "codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2PushPromiseFrame.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.http2;\n+\n+/**\n+ * Default implementation of {@link Http2PushPromiseFrame}\n+ */\n+public class DefaultHttp2PushPromiseFrame implements Http2PushPromiseFrame {", "originalCommit": "d673e90e71fba557ca91701afaea419d788c3e8c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA0NTU4Mw==", "url": "https://github.com/netty/netty/pull/10765#discussion_r548045583", "bodyText": "Add @UnstableApi", "author": "normanmaurer", "createdAt": "2020-12-23T16:39:37Z", "path": "codec-http2/src/main/java/io/netty/handler/codec/http2/Http2PriorityFrame.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.http2;\n+\n+/**\n+ * HTTP/2 Priority Frame\n+ */\n+public interface Http2PriorityFrame extends Http2StreamFrame {", "originalCommit": "d673e90e71fba557ca91701afaea419d788c3e8c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA0NTYxNg==", "url": "https://github.com/netty/netty/pull/10765#discussion_r548045616", "bodyText": "Add @UnstableApi", "author": "normanmaurer", "createdAt": "2020-12-23T16:39:42Z", "path": "codec-http2/src/main/java/io/netty/handler/codec/http2/Http2PushPromiseFrame.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.http2;\n+\n+/**\n+ * HTTP/2 Push Promise Frame\n+ */\n+public interface Http2PushPromiseFrame extends Http2StreamFrame {", "originalCommit": "d673e90e71fba557ca91701afaea419d788c3e8c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA0NTkwNw==", "url": "https://github.com/netty/netty/pull/10765#discussion_r548045907", "bodyText": "Remove throws InterruptedException and also remove the catch for it above", "author": "normanmaurer", "createdAt": "2020-12-23T16:40:21Z", "path": "codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2PushPromiseFrameTest.java", "diffHunk": "@@ -0,0 +1,235 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.http2;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelPipeline;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.util.CharsetUtil;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+public class DefaultHttp2PushPromiseFrameTest {\n+\n+    private final EventLoopGroup eventLoopGroup = new NioEventLoopGroup(2);\n+    private final ClientHandler clientHandler = new ClientHandler();\n+    private final Map<Integer, String> contentMap = new ConcurrentHashMap<Integer, String>();\n+\n+    private ChannelFuture connectionFuture;\n+\n+    @Before\n+    public void setup() throws InterruptedException {\n+        ServerBootstrap serverBootstrap = new ServerBootstrap()\n+                .group(eventLoopGroup)\n+                .channel(NioServerSocketChannel.class)\n+                .childHandler(new ChannelInitializer<SocketChannel>() {\n+                    @Override\n+                    protected void initChannel(SocketChannel ch) {\n+                        ChannelPipeline pipeline = ch.pipeline();\n+\n+                        Http2FrameCodec frameCodec = Http2FrameCodecBuilder.forServer()\n+                                .autoAckSettingsFrame(true)\n+                                .autoAckPingFrame(true)\n+                                .build();\n+\n+                        pipeline.addLast(frameCodec);\n+                        pipeline.addLast(new ServerHandler());\n+                    }\n+                });\n+\n+        ChannelFuture channelFuture = serverBootstrap.bind(0).sync();\n+\n+        final Bootstrap bootstrap = new Bootstrap()\n+                .group(eventLoopGroup)\n+                .channel(NioSocketChannel.class)\n+                .handler(new ChannelInitializer<SocketChannel>() {\n+                    @Override\n+                    protected void initChannel(SocketChannel ch) {\n+                        ChannelPipeline pipeline = ch.pipeline();\n+\n+                        Http2FrameCodec frameCodec = Http2FrameCodecBuilder.forClient()\n+                                .autoAckSettingsFrame(true)\n+                                .autoAckPingFrame(true)\n+                                .initialSettings(Http2Settings.defaultSettings().pushEnabled(true))\n+                                .build();\n+\n+                        pipeline.addLast(frameCodec);\n+                        pipeline.addLast(clientHandler);\n+                    }\n+                });\n+\n+        connectionFuture = bootstrap.connect(channelFuture.channel().localAddress());\n+    }\n+\n+    @Test\n+    public void send() {\n+        connectionFuture.addListener(new ChannelFutureListener() {\n+            @Override\n+            public void operationComplete(ChannelFuture future) {\n+                try {\n+                    clientHandler.write();\n+                } catch (InterruptedException e) {\n+                    // Ignore\n+                }\n+            }\n+        });\n+    }\n+\n+    @After\n+    public void shutdown() {\n+        eventLoopGroup.shutdownGracefully();\n+    }\n+\n+    private final class ServerHandler extends Http2ChannelDuplexHandler {\n+\n+        @Override\n+        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n+\n+            if (msg instanceof Http2HeadersFrame) {\n+                Http2HeadersFrame receivedFrame = (Http2HeadersFrame) msg;\n+\n+                Http2Headers pushRequestHeaders = new DefaultHttp2Headers();\n+                pushRequestHeaders.path(\"/meow\")\n+                        .method(\"GET\")\n+                        .scheme(\"https\")\n+                        .authority(\"localhost:5555\");\n+\n+                // Write PUSH_PROMISE request headers\n+                Http2FrameStream newPushFrameStream = newStream();\n+                Http2PushPromiseFrame pushPromiseFrame = new DefaultHttp2PushPromiseFrame(pushRequestHeaders);\n+                pushPromiseFrame.stream(receivedFrame.stream());\n+                pushPromiseFrame.pushStream(newPushFrameStream);\n+                ctx.writeAndFlush(pushPromiseFrame).sync();\n+\n+                contentMap.put(newPushFrameStream.id(), \"Meow, I am Pushed via HTTP/2\");\n+\n+                // Write headers for actual request\n+                Http2Headers http2Headers = new DefaultHttp2Headers();\n+                http2Headers.status(\"200\");\n+                http2Headers.add(\"push\", \"false\");\n+                Http2HeadersFrame headersFrame = new DefaultHttp2HeadersFrame(http2Headers, false);\n+                headersFrame.stream(receivedFrame.stream());\n+                ctx.writeAndFlush(headersFrame);\n+\n+                // Write Data of actual request\n+                Http2DataFrame dataFrame = new DefaultHttp2DataFrame(Unpooled.wrappedBuffer(\"Meow\".getBytes()), true);\n+                dataFrame.stream(receivedFrame.stream());\n+                ctx.writeAndFlush(dataFrame);\n+            } else if (msg instanceof Http2PriorityFrame) {\n+                Http2PriorityFrame priorityFrame = (Http2PriorityFrame) msg;\n+                String content = contentMap.get(priorityFrame.stream().id());\n+                if (content == null) {\n+                    ctx.writeAndFlush(new DefaultHttp2GoAwayFrame(Http2Error.REFUSED_STREAM));\n+                    return;\n+                }\n+\n+                // Write headers for Priority request\n+                Http2Headers http2Headers = new DefaultHttp2Headers();\n+                http2Headers.status(\"200\");\n+                http2Headers.add(\"push\", \"true\");\n+                Http2HeadersFrame headersFrame = new DefaultHttp2HeadersFrame(http2Headers, false);\n+                headersFrame.stream(priorityFrame.stream());\n+                ctx.writeAndFlush(headersFrame);\n+\n+                // Write Data of Priority request\n+                Http2DataFrame dataFrame = new DefaultHttp2DataFrame(Unpooled.wrappedBuffer(content.getBytes()), true);\n+                dataFrame.stream(priorityFrame.stream());\n+                ctx.writeAndFlush(dataFrame);\n+            }\n+        }\n+    }\n+\n+    private static final class ClientHandler extends Http2ChannelDuplexHandler {\n+\n+        private ChannelHandlerContext ctx;\n+\n+        @Override\n+        public void channelActive(ChannelHandlerContext ctx) throws InterruptedException {\n+            this.ctx = ctx;\n+        }\n+\n+        void write() throws InterruptedException {", "originalCommit": "d673e90e71fba557ca91701afaea419d788c3e8c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA0NjYyMQ==", "url": "https://github.com/netty/netty/pull/10765#discussion_r548046621", "bodyText": "consider removing all these release and just add a big try {... } finally { ReferenceCountUtil.release(msg); }", "author": "normanmaurer", "createdAt": "2020-12-23T16:42:01Z", "path": "codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2PushPromiseFrameTest.java", "diffHunk": "@@ -0,0 +1,235 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.http2;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelPipeline;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.util.CharsetUtil;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+public class DefaultHttp2PushPromiseFrameTest {\n+\n+    private final EventLoopGroup eventLoopGroup = new NioEventLoopGroup(2);\n+    private final ClientHandler clientHandler = new ClientHandler();\n+    private final Map<Integer, String> contentMap = new ConcurrentHashMap<Integer, String>();\n+\n+    private ChannelFuture connectionFuture;\n+\n+    @Before\n+    public void setup() throws InterruptedException {\n+        ServerBootstrap serverBootstrap = new ServerBootstrap()\n+                .group(eventLoopGroup)\n+                .channel(NioServerSocketChannel.class)\n+                .childHandler(new ChannelInitializer<SocketChannel>() {\n+                    @Override\n+                    protected void initChannel(SocketChannel ch) {\n+                        ChannelPipeline pipeline = ch.pipeline();\n+\n+                        Http2FrameCodec frameCodec = Http2FrameCodecBuilder.forServer()\n+                                .autoAckSettingsFrame(true)\n+                                .autoAckPingFrame(true)\n+                                .build();\n+\n+                        pipeline.addLast(frameCodec);\n+                        pipeline.addLast(new ServerHandler());\n+                    }\n+                });\n+\n+        ChannelFuture channelFuture = serverBootstrap.bind(0).sync();\n+\n+        final Bootstrap bootstrap = new Bootstrap()\n+                .group(eventLoopGroup)\n+                .channel(NioSocketChannel.class)\n+                .handler(new ChannelInitializer<SocketChannel>() {\n+                    @Override\n+                    protected void initChannel(SocketChannel ch) {\n+                        ChannelPipeline pipeline = ch.pipeline();\n+\n+                        Http2FrameCodec frameCodec = Http2FrameCodecBuilder.forClient()\n+                                .autoAckSettingsFrame(true)\n+                                .autoAckPingFrame(true)\n+                                .initialSettings(Http2Settings.defaultSettings().pushEnabled(true))\n+                                .build();\n+\n+                        pipeline.addLast(frameCodec);\n+                        pipeline.addLast(clientHandler);\n+                    }\n+                });\n+\n+        connectionFuture = bootstrap.connect(channelFuture.channel().localAddress());\n+    }\n+\n+    @Test\n+    public void send() {\n+        connectionFuture.addListener(new ChannelFutureListener() {\n+            @Override\n+            public void operationComplete(ChannelFuture future) {\n+                try {\n+                    clientHandler.write();\n+                } catch (InterruptedException e) {\n+                    // Ignore\n+                }\n+            }\n+        });\n+    }\n+\n+    @After\n+    public void shutdown() {\n+        eventLoopGroup.shutdownGracefully();\n+    }\n+\n+    private final class ServerHandler extends Http2ChannelDuplexHandler {\n+\n+        @Override\n+        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n+\n+            if (msg instanceof Http2HeadersFrame) {\n+                Http2HeadersFrame receivedFrame = (Http2HeadersFrame) msg;\n+\n+                Http2Headers pushRequestHeaders = new DefaultHttp2Headers();\n+                pushRequestHeaders.path(\"/meow\")\n+                        .method(\"GET\")\n+                        .scheme(\"https\")\n+                        .authority(\"localhost:5555\");\n+\n+                // Write PUSH_PROMISE request headers\n+                Http2FrameStream newPushFrameStream = newStream();\n+                Http2PushPromiseFrame pushPromiseFrame = new DefaultHttp2PushPromiseFrame(pushRequestHeaders);\n+                pushPromiseFrame.stream(receivedFrame.stream());\n+                pushPromiseFrame.pushStream(newPushFrameStream);\n+                ctx.writeAndFlush(pushPromiseFrame).sync();\n+\n+                contentMap.put(newPushFrameStream.id(), \"Meow, I am Pushed via HTTP/2\");\n+\n+                // Write headers for actual request\n+                Http2Headers http2Headers = new DefaultHttp2Headers();\n+                http2Headers.status(\"200\");\n+                http2Headers.add(\"push\", \"false\");\n+                Http2HeadersFrame headersFrame = new DefaultHttp2HeadersFrame(http2Headers, false);\n+                headersFrame.stream(receivedFrame.stream());\n+                ctx.writeAndFlush(headersFrame);\n+\n+                // Write Data of actual request\n+                Http2DataFrame dataFrame = new DefaultHttp2DataFrame(Unpooled.wrappedBuffer(\"Meow\".getBytes()), true);\n+                dataFrame.stream(receivedFrame.stream());\n+                ctx.writeAndFlush(dataFrame);\n+            } else if (msg instanceof Http2PriorityFrame) {\n+                Http2PriorityFrame priorityFrame = (Http2PriorityFrame) msg;\n+                String content = contentMap.get(priorityFrame.stream().id());\n+                if (content == null) {\n+                    ctx.writeAndFlush(new DefaultHttp2GoAwayFrame(Http2Error.REFUSED_STREAM));\n+                    return;\n+                }\n+\n+                // Write headers for Priority request\n+                Http2Headers http2Headers = new DefaultHttp2Headers();\n+                http2Headers.status(\"200\");\n+                http2Headers.add(\"push\", \"true\");\n+                Http2HeadersFrame headersFrame = new DefaultHttp2HeadersFrame(http2Headers, false);\n+                headersFrame.stream(priorityFrame.stream());\n+                ctx.writeAndFlush(headersFrame);\n+\n+                // Write Data of Priority request\n+                Http2DataFrame dataFrame = new DefaultHttp2DataFrame(Unpooled.wrappedBuffer(content.getBytes()), true);\n+                dataFrame.stream(priorityFrame.stream());\n+                ctx.writeAndFlush(dataFrame);\n+            }\n+        }\n+    }\n+\n+    private static final class ClientHandler extends Http2ChannelDuplexHandler {\n+\n+        private ChannelHandlerContext ctx;\n+\n+        @Override\n+        public void channelActive(ChannelHandlerContext ctx) throws InterruptedException {\n+            this.ctx = ctx;\n+        }\n+\n+        void write() throws InterruptedException {\n+            Http2Headers http2Headers = new DefaultHttp2Headers();\n+            http2Headers.path(\"/\")\n+                    .authority(\"localhost\")\n+                    .method(\"GET\")\n+                    .scheme(\"https\");\n+\n+            Http2HeadersFrame headersFrame = new DefaultHttp2HeadersFrame(http2Headers, true);\n+            headersFrame.stream(newStream());\n+            ctx.writeAndFlush(headersFrame);\n+        }\n+\n+        @Override\n+        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n+\n+            if (msg instanceof Http2PushPromiseFrame) {\n+                Http2PushPromiseFrame pushPromiseFrame = (Http2PushPromiseFrame) msg;\n+\n+                assertEquals(\"/meow\", pushPromiseFrame.http2Headers().path().toString());\n+                assertEquals(\"GET\", pushPromiseFrame.http2Headers().method().toString());\n+                assertEquals(\"https\", pushPromiseFrame.http2Headers().scheme().toString());\n+                assertEquals(\"localhost:5555\", pushPromiseFrame.http2Headers().authority().toString());\n+\n+                Http2PriorityFrame priorityFrame = new DefaultHttp2PriorityFrame(pushPromiseFrame.stream().id(),\n+                        Http2CodecUtil.DEFAULT_PRIORITY_WEIGHT, true);\n+                priorityFrame.stream(pushPromiseFrame.pushStream());\n+                ctx.writeAndFlush(priorityFrame);\n+            } else if (msg instanceof Http2HeadersFrame) {\n+                Http2HeadersFrame headersFrame = (Http2HeadersFrame) msg;\n+\n+                if (headersFrame.stream().id() == 3) {\n+                    assertEquals(\"200\", headersFrame.headers().status().toString());\n+                    assertEquals(\"false\", headersFrame.headers().get(\"push\").toString());\n+                } else if (headersFrame.stream().id() == 2) {\n+                    assertEquals(\"200\", headersFrame.headers().status().toString());\n+                    assertEquals(\"true\", headersFrame.headers().get(\"push\").toString());\n+                } else {\n+                    ctx.writeAndFlush(new DefaultHttp2GoAwayFrame(Http2Error.REFUSED_STREAM));\n+                }\n+            } else if (msg instanceof Http2DataFrame) {\n+                Http2DataFrame dataFrame = (Http2DataFrame) msg;\n+\n+                if (dataFrame.stream().id() == 3) {\n+                    assertEquals(\"Meow\", dataFrame.content().toString(CharsetUtil.UTF_8));\n+                    dataFrame.content().release();\n+                } else if (dataFrame.stream().id() == 2) {\n+                    assertEquals(\"Meow, I am Pushed via HTTP/2\", dataFrame.content().toString(CharsetUtil.UTF_8));\n+                    dataFrame.content().release();\n+                } else {\n+                    dataFrame.content().release();", "originalCommit": "d673e90e71fba557ca91701afaea419d788c3e8c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "fdaabd5434923b5ae64e68b33c99b8e594e6cd78", "url": "https://github.com/netty/netty/commit/fdaabd5434923b5ae64e68b33c99b8e594e6cd78", "message": "Address review", "committedDate": "2020-12-23T16:49:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA2Mjk3NQ==", "url": "https://github.com/netty/netty/pull/10765#discussion_r548062975", "bodyText": "This interface should add an override like:\n@Override\nHttp2PriorityFrame stream(Http2FrameStream stream) {", "author": "normanmaurer", "createdAt": "2020-12-23T17:19:22Z", "path": "codec-http2/src/main/java/io/netty/handler/codec/http2/Http2PriorityFrame.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.http2;\n+\n+import io.netty.util.internal.UnstableApi;\n+\n+/**\n+ * HTTP/2 Priority Frame\n+ */\n+@UnstableApi\n+public interface Http2PriorityFrame extends Http2StreamFrame {\n+\n+    /**\n+     * Parent Stream Id of this Priority request\n+     */\n+    int streamDependency();\n+\n+    /**\n+     * Stream weight\n+     */\n+    short weight();\n+\n+    /**\n+     * Set to {@code true} if this stream is exclusive else set to {@code false}\n+     */\n+    boolean exclusive();", "originalCommit": "fdaabd5434923b5ae64e68b33c99b8e594e6cd78", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM2Nzk4OA==", "url": "https://github.com/netty/netty/pull/10765#discussion_r548367988", "bodyText": "Done, PTAL.", "author": "hyperxpro", "createdAt": "2020-12-24T03:38:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA2Mjk3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA2MzE2Nw==", "url": "https://github.com/netty/netty/pull/10765#discussion_r548063167", "bodyText": "This interface should add an override like:\n@Override\nHttp2PushPromiseFrame stream(Http2FrameStream stream) {", "author": "normanmaurer", "createdAt": "2020-12-23T17:19:33Z", "path": "codec-http2/src/main/java/io/netty/handler/codec/http2/Http2PushPromiseFrame.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.http2;\n+\n+import io.netty.util.internal.UnstableApi;\n+\n+/**\n+ * HTTP/2 Push Promise Frame\n+ */\n+@UnstableApi\n+public interface Http2PushPromiseFrame extends Http2StreamFrame {\n+\n+    /**\n+     * Set the Promise {@link Http2FrameStream} object for this frame.\n+     */\n+    Http2StreamFrame pushStream(Http2FrameStream stream);\n+\n+    /**\n+     * Returns the Promise {@link Http2FrameStream} object for this frame, or {@code null} if the\n+     * frame has yet to be associated with a stream.\n+     */\n+    Http2FrameStream pushStream();\n+\n+    /**\n+     * {@link Http2Headers} sent in Push Promise\n+     */\n+    Http2Headers http2Headers();\n+\n+    /**\n+     * Frame padding to use. Will be non-negative and less than 256.\n+     */\n+    int padding();\n+\n+    /**\n+     * Promised Stream ID\n+     */\n+    int promisedStreamId();", "originalCommit": "fdaabd5434923b5ae64e68b33c99b8e594e6cd78", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d99cfc570523d740770c3b6b50fc25501a7c94f8", "url": "https://github.com/netty/netty/commit/d99cfc570523d740770c3b6b50fc25501a7c94f8", "message": "override methods", "committedDate": "2020-12-24T03:36:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQwMDkzMQ==", "url": "https://github.com/netty/netty/pull/10765#discussion_r548400931", "bodyText": "Is this override needed ? Seems like it returns the same type as the parent method", "author": "normanmaurer", "createdAt": "2020-12-24T06:03:19Z", "path": "codec-http2/src/main/java/io/netty/handler/codec/http2/Http2PushPromiseFrame.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.http2;\n+\n+import io.netty.util.internal.UnstableApi;\n+\n+/**\n+ * HTTP/2 Push Promise Frame\n+ */\n+@UnstableApi\n+public interface Http2PushPromiseFrame extends Http2StreamFrame {\n+\n+    /**\n+     * Set the Promise {@link Http2FrameStream} object for this frame.\n+     */\n+    Http2StreamFrame pushStream(Http2FrameStream stream);\n+\n+    /**\n+     * Returns the Promise {@link Http2FrameStream} object for this frame, or {@code null} if the\n+     * frame has yet to be associated with a stream.\n+     */\n+    Http2FrameStream pushStream();\n+\n+    /**\n+     * {@link Http2Headers} sent in Push Promise\n+     */\n+    Http2Headers http2Headers();\n+\n+    /**\n+     * Frame padding to use. Will be non-negative and less than 256.\n+     */\n+    int padding();\n+\n+    /**\n+     * Promised Stream ID\n+     */\n+    int promisedStreamId();\n+\n+    @Override\n+    Http2StreamFrame stream(Http2FrameStream stream);\n+\n+    @Override\n+    Http2FrameStream stream();", "originalCommit": "d99cfc570523d740770c3b6b50fc25501a7c94f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQwMDk5Mg==", "url": "https://github.com/netty/netty/pull/10765#discussion_r548400992", "bodyText": "Is this override needed ? Seems like it returns the same type as the parent method", "author": "normanmaurer", "createdAt": "2020-12-24T06:03:37Z", "path": "codec-http2/src/main/java/io/netty/handler/codec/http2/Http2PriorityFrame.java", "diffHunk": "@@ -0,0 +1,46 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.http2;\n+\n+import io.netty.util.internal.UnstableApi;\n+\n+/**\n+ * HTTP/2 Priority Frame\n+ */\n+@UnstableApi\n+public interface Http2PriorityFrame extends Http2StreamFrame {\n+\n+    /**\n+     * Parent Stream Id of this Priority request\n+     */\n+    int streamDependency();\n+\n+    /**\n+     * Stream weight\n+     */\n+    short weight();\n+\n+    /**\n+     * Set to {@code true} if this stream is exclusive else set to {@code false}\n+     */\n+    boolean exclusive();\n+\n+    @Override\n+    Http2StreamFrame stream(Http2FrameStream stream);\n+\n+    @Override\n+    Http2FrameStream stream();\n+}", "originalCommit": "d99cfc570523d740770c3b6b50fc25501a7c94f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQwMTQ1Mg==", "url": "https://github.com/netty/netty/pull/10765#discussion_r548401452", "bodyText": "Never call sync in the eventloop", "author": "normanmaurer", "createdAt": "2020-12-24T06:05:41Z", "path": "codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2PushPromiseFrameTest.java", "diffHunk": "@@ -0,0 +1,233 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.http2;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelPipeline;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.ReferenceCountUtil;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+public class DefaultHttp2PushPromiseFrameTest {\n+\n+    private final EventLoopGroup eventLoopGroup = new NioEventLoopGroup(2);\n+    private final ClientHandler clientHandler = new ClientHandler();\n+    private final Map<Integer, String> contentMap = new ConcurrentHashMap<Integer, String>();\n+\n+    private ChannelFuture connectionFuture;\n+\n+    @Before\n+    public void setup() throws InterruptedException {\n+        ServerBootstrap serverBootstrap = new ServerBootstrap()\n+                .group(eventLoopGroup)\n+                .channel(NioServerSocketChannel.class)\n+                .childHandler(new ChannelInitializer<SocketChannel>() {\n+                    @Override\n+                    protected void initChannel(SocketChannel ch) {\n+                        ChannelPipeline pipeline = ch.pipeline();\n+\n+                        Http2FrameCodec frameCodec = Http2FrameCodecBuilder.forServer()\n+                                .autoAckSettingsFrame(true)\n+                                .autoAckPingFrame(true)\n+                                .build();\n+\n+                        pipeline.addLast(frameCodec);\n+                        pipeline.addLast(new ServerHandler());\n+                    }\n+                });\n+\n+        ChannelFuture channelFuture = serverBootstrap.bind(0).sync();\n+\n+        final Bootstrap bootstrap = new Bootstrap()\n+                .group(eventLoopGroup)\n+                .channel(NioSocketChannel.class)\n+                .handler(new ChannelInitializer<SocketChannel>() {\n+                    @Override\n+                    protected void initChannel(SocketChannel ch) {\n+                        ChannelPipeline pipeline = ch.pipeline();\n+\n+                        Http2FrameCodec frameCodec = Http2FrameCodecBuilder.forClient()\n+                                .autoAckSettingsFrame(true)\n+                                .autoAckPingFrame(true)\n+                                .initialSettings(Http2Settings.defaultSettings().pushEnabled(true))\n+                                .build();\n+\n+                        pipeline.addLast(frameCodec);\n+                        pipeline.addLast(clientHandler);\n+                    }\n+                });\n+\n+        connectionFuture = bootstrap.connect(channelFuture.channel().localAddress());\n+    }\n+\n+    @Test\n+    public void send() {\n+        connectionFuture.addListener(new ChannelFutureListener() {\n+            @Override\n+            public void operationComplete(ChannelFuture future) {\n+                clientHandler.write();\n+            }\n+        });\n+    }\n+\n+    @After\n+    public void shutdown() {\n+        eventLoopGroup.shutdownGracefully();\n+    }\n+\n+    private final class ServerHandler extends Http2ChannelDuplexHandler {\n+\n+        @Override\n+        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n+\n+            if (msg instanceof Http2HeadersFrame) {\n+                Http2HeadersFrame receivedFrame = (Http2HeadersFrame) msg;\n+\n+                Http2Headers pushRequestHeaders = new DefaultHttp2Headers();\n+                pushRequestHeaders.path(\"/meow\")\n+                        .method(\"GET\")\n+                        .scheme(\"https\")\n+                        .authority(\"localhost:5555\");\n+\n+                // Write PUSH_PROMISE request headers\n+                Http2FrameStream newPushFrameStream = newStream();\n+                Http2PushPromiseFrame pushPromiseFrame = new DefaultHttp2PushPromiseFrame(pushRequestHeaders);\n+                pushPromiseFrame.stream(receivedFrame.stream());\n+                pushPromiseFrame.pushStream(newPushFrameStream);\n+                ctx.writeAndFlush(pushPromiseFrame).sync();", "originalCommit": "d99cfc570523d740770c3b6b50fc25501a7c94f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ab51220fb495dfd9928957c6cc96c81af4141f3d", "url": "https://github.com/netty/netty/commit/ab51220fb495dfd9928957c6cc96c81af4141f3d", "message": "address more review", "committedDate": "2020-12-24T06:18:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODc0NDAyMg==", "url": "https://github.com/netty/netty/pull/10765#discussion_r548744022", "bodyText": "s/Http2StreamFrame/Http2PushPromiseFrame/", "author": "normanmaurer", "createdAt": "2020-12-24T20:24:12Z", "path": "codec-http2/src/main/java/io/netty/handler/codec/http2/Http2PushPromiseFrame.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.http2;\n+\n+import io.netty.util.internal.UnstableApi;\n+\n+/**\n+ * HTTP/2 Push Promise Frame\n+ */\n+@UnstableApi\n+public interface Http2PushPromiseFrame extends Http2StreamFrame {\n+\n+    /**\n+     * Set the Promise {@link Http2FrameStream} object for this frame.\n+     */\n+    Http2StreamFrame pushStream(Http2FrameStream stream);\n+\n+    /**\n+     * Returns the Promise {@link Http2FrameStream} object for this frame, or {@code null} if the\n+     * frame has yet to be associated with a stream.\n+     */\n+    Http2FrameStream pushStream();\n+\n+    /**\n+     * {@link Http2Headers} sent in Push Promise\n+     */\n+    Http2Headers http2Headers();\n+\n+    /**\n+     * Frame padding to use. Will be non-negative and less than 256.\n+     */\n+    int padding();\n+\n+    /**\n+     * Promised Stream ID\n+     */\n+    int promisedStreamId();\n+\n+    @Override\n+    Http2StreamFrame stream(Http2FrameStream stream);", "originalCommit": "ab51220fb495dfd9928957c6cc96c81af4141f3d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODc4Mjg1MQ==", "url": "https://github.com/netty/netty/pull/10765#discussion_r548782851", "bodyText": "Sorry, I didn't get it. Do you want me to rename Http2StreamFrame stream(Http2FrameStream stream); to     Http2PriorityFrame stream(Http2PriorityFrame stream);?", "author": "hyperxpro", "createdAt": "2020-12-25T02:36:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODc0NDAyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODg1MTgzNw==", "url": "https://github.com/netty/netty/pull/10765#discussion_r548851837", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Http2StreamFrame stream(Http2FrameStream stream);\n          \n          \n            \n                Http2PushPromiseFrame stream(Http2FrameStream stream);", "author": "normanmaurer", "createdAt": "2020-12-25T10:28:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODc0NDAyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODc0NDA0Nw==", "url": "https://github.com/netty/netty/pull/10765#discussion_r548744047", "bodyText": "s/Http2StreamFrame/Http2PriorityFrame/", "author": "normanmaurer", "createdAt": "2020-12-24T20:24:27Z", "path": "codec-http2/src/main/java/io/netty/handler/codec/http2/Http2PriorityFrame.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.http2;\n+\n+import io.netty.util.internal.UnstableApi;\n+\n+/**\n+ * HTTP/2 Priority Frame\n+ */\n+@UnstableApi\n+public interface Http2PriorityFrame extends Http2StreamFrame {\n+\n+    /**\n+     * Parent Stream Id of this Priority request\n+     */\n+    int streamDependency();\n+\n+    /**\n+     * Stream weight\n+     */\n+    short weight();\n+\n+    /**\n+     * Set to {@code true} if this stream is exclusive else set to {@code false}\n+     */\n+    boolean exclusive();\n+\n+    @Override\n+    Http2StreamFrame stream(Http2FrameStream stream);", "originalCommit": "ab51220fb495dfd9928957c6cc96c81af4141f3d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODg1MTkzMA==", "url": "https://github.com/netty/netty/pull/10765#discussion_r548851930", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Http2StreamFrame stream(Http2FrameStream stream);\n          \n          \n            \n                Http2PriorityFrame stream(Http2FrameStream stream);", "author": "normanmaurer", "createdAt": "2020-12-25T10:28:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODc0NDA0Nw=="}], "type": "inlineReview"}, {"oid": "c1059f3a216ba18568f28934deb38e037dfe35b6", "url": "https://github.com/netty/netty/commit/c1059f3a216ba18568f28934deb38e037dfe35b6", "message": "Update codec-http2/src/main/java/io/netty/handler/codec/http2/Http2PushPromiseFrame.java\n\nCo-authored-by: Norman Maurer <norman_maurer@apple.com>", "committedDate": "2020-12-26T03:03:06Z", "type": "commit"}, {"oid": "f3e1a6c71f1e2dded5e81dbb336451448f2b59be", "url": "https://github.com/netty/netty/commit/f3e1a6c71f1e2dded5e81dbb336451448f2b59be", "message": "Update codec-http2/src/main/java/io/netty/handler/codec/http2/Http2PriorityFrame.java\n\nCo-authored-by: Norman Maurer <norman_maurer@apple.com>", "committedDate": "2020-12-26T03:03:21Z", "type": "commit"}, {"oid": "1e5c29a2dd026e428dc51db903e97943c563515b", "url": "https://github.com/netty/netty/commit/1e5c29a2dd026e428dc51db903e97943c563515b", "message": "refactor", "committedDate": "2020-12-26T03:13:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTA4OTMwNg==", "url": "https://github.com/netty/netty/pull/10765#discussion_r549089306", "bodyText": "remove 4 spaces in all lines in the if block... you use 8 spaces while we use 4 everywhere", "author": "normanmaurer", "createdAt": "2020-12-27T09:33:16Z", "path": "codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java", "diffHunk": "@@ -383,59 +392,94 @@ private void writeGoAwayFrame(ChannelHandlerContext ctx, Http2GoAwayFrame frame,\n         goAway(ctx, (int) lastStreamId, frame.errorCode(), frame.content(), promise);\n     }\n \n-    private void writeHeadersFrame(\n-            final ChannelHandlerContext ctx, Http2HeadersFrame headersFrame, final ChannelPromise promise) {\n+    private void writeHeadersFrame(final ChannelHandlerContext ctx, Http2HeadersFrame headersFrame,\n+                                   final ChannelPromise promise) {\n \n         if (isStreamIdValid(headersFrame.stream().id())) {\n             encoder().writeHeaders(ctx, headersFrame.stream().id(), headersFrame.headers(), headersFrame.padding(),\n                     headersFrame.isEndStream(), promise);\n-        } else {\n-            final DefaultHttp2FrameStream stream = (DefaultHttp2FrameStream) headersFrame.stream();\n-            final Http2Connection connection = connection();\n-            final int streamId = connection.local().incrementAndGetNextStreamId();\n-            if (streamId < 0) {\n-                promise.setFailure(new Http2NoMoreStreamIdsException());\n-\n-                // Simulate a GOAWAY being received due to stream exhaustion on this connection. We use the maximum\n-                // valid stream ID for the current peer.\n-                onHttp2Frame(ctx, new DefaultHttp2GoAwayFrame(connection.isServer() ? Integer.MAX_VALUE :\n-                        Integer.MAX_VALUE - 1, NO_ERROR.code(),\n-                        writeAscii(ctx.alloc(), \"Stream IDs exhausted on local stream creation\")));\n-                return;\n-            }\n-            stream.id = streamId;\n-\n-            // Use a Map to store all pending streams as we may have multiple. This is needed as if we would store the\n-            // stream in a field directly we may override the stored field before onStreamAdded(...) was called\n-            // and so not correctly set the property for the buffered stream.\n-            //\n-            // See https://github.com/netty/netty/issues/8692\n-            Object old = frameStreamToInitializeMap.put(streamId, stream);\n-\n-            // We should not re-use ids.\n-            assert old == null;\n+        } else if (initializeNewStream(ctx, (DefaultHttp2FrameStream) headersFrame.stream(), promise)) {\n+                final int streamId = headersFrame.stream().id();", "originalCommit": "1e5c29a2dd026e428dc51db903e97943c563515b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTA4OTMzNg==", "url": "https://github.com/netty/netty/pull/10765#discussion_r549089336", "bodyText": "remove 4 spaces in all lines in the if block... you use 8 spaces while we use 4 everywhere", "author": "normanmaurer", "createdAt": "2020-12-27T09:33:26Z", "path": "codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java", "diffHunk": "@@ -383,59 +392,94 @@ private void writeGoAwayFrame(ChannelHandlerContext ctx, Http2GoAwayFrame frame,\n         goAway(ctx, (int) lastStreamId, frame.errorCode(), frame.content(), promise);\n     }\n \n-    private void writeHeadersFrame(\n-            final ChannelHandlerContext ctx, Http2HeadersFrame headersFrame, final ChannelPromise promise) {\n+    private void writeHeadersFrame(final ChannelHandlerContext ctx, Http2HeadersFrame headersFrame,\n+                                   final ChannelPromise promise) {\n \n         if (isStreamIdValid(headersFrame.stream().id())) {\n             encoder().writeHeaders(ctx, headersFrame.stream().id(), headersFrame.headers(), headersFrame.padding(),\n                     headersFrame.isEndStream(), promise);\n-        } else {\n-            final DefaultHttp2FrameStream stream = (DefaultHttp2FrameStream) headersFrame.stream();\n-            final Http2Connection connection = connection();\n-            final int streamId = connection.local().incrementAndGetNextStreamId();\n-            if (streamId < 0) {\n-                promise.setFailure(new Http2NoMoreStreamIdsException());\n-\n-                // Simulate a GOAWAY being received due to stream exhaustion on this connection. We use the maximum\n-                // valid stream ID for the current peer.\n-                onHttp2Frame(ctx, new DefaultHttp2GoAwayFrame(connection.isServer() ? Integer.MAX_VALUE :\n-                        Integer.MAX_VALUE - 1, NO_ERROR.code(),\n-                        writeAscii(ctx.alloc(), \"Stream IDs exhausted on local stream creation\")));\n-                return;\n-            }\n-            stream.id = streamId;\n-\n-            // Use a Map to store all pending streams as we may have multiple. This is needed as if we would store the\n-            // stream in a field directly we may override the stored field before onStreamAdded(...) was called\n-            // and so not correctly set the property for the buffered stream.\n-            //\n-            // See https://github.com/netty/netty/issues/8692\n-            Object old = frameStreamToInitializeMap.put(streamId, stream);\n-\n-            // We should not re-use ids.\n-            assert old == null;\n+        } else if (initializeNewStream(ctx, (DefaultHttp2FrameStream) headersFrame.stream(), promise)) {\n+                final int streamId = headersFrame.stream().id();\n+\n+                encoder().writeHeaders(ctx, streamId, headersFrame.headers(), headersFrame.padding(),\n+                        headersFrame.isEndStream(), promise);\n+\n+                if (!promise.isDone()) {\n+                    numBufferedStreams++;\n+                    // Clean up the stream being initialized if writing the headers fails and also\n+                    // decrement the number of buffered streams.\n+                    promise.addListener(new ChannelFutureListener() {\n+                        @Override\n+                        public void operationComplete(ChannelFuture channelFuture) {\n+                            numBufferedStreams--;\n+\n+                            handleHeaderFuture(channelFuture, streamId);\n+                        }\n+                    });\n+                } else {\n+                    handleHeaderFuture(promise, streamId);\n+                }\n+        }\n+    }\n \n-            encoder().writeHeaders(ctx, streamId, headersFrame.headers(), headersFrame.padding(),\n-                    headersFrame.isEndStream(), promise);\n+    private void writePushPromise(final ChannelHandlerContext ctx, Http2PushPromiseFrame pushPromiseFrame,\n+                                  final ChannelPromise promise) {\n+        if (isStreamIdValid(pushPromiseFrame.pushStream().id())) {\n+            encoder().writePushPromise(ctx, pushPromiseFrame.stream().id(), pushPromiseFrame.pushStream().id(),\n+                    pushPromiseFrame.http2Headers(), pushPromiseFrame.padding(), promise);\n+        } else if (initializeNewStream(ctx, (DefaultHttp2FrameStream) pushPromiseFrame.pushStream(), promise)) {\n+                final int streamId = pushPromiseFrame.stream().id();", "originalCommit": "1e5c29a2dd026e428dc51db903e97943c563515b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTA4OTQ5NA==", "url": "https://github.com/netty/netty/pull/10765#discussion_r549089494", "bodyText": "Honestly I think this should be done in a ChannelFutureListener so you are sure the write was actually done and so the id was set... Basically move this line and everything below in a a ChannelFutureListener that is added to the headers write.", "author": "normanmaurer", "createdAt": "2020-12-27T09:34:58Z", "path": "codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2PushPromiseFrameTest.java", "diffHunk": "@@ -0,0 +1,233 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.http2;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelPipeline;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.ReferenceCountUtil;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+public class DefaultHttp2PushPromiseFrameTest {\n+\n+    private final EventLoopGroup eventLoopGroup = new NioEventLoopGroup(2);\n+    private final ClientHandler clientHandler = new ClientHandler();\n+    private final Map<Integer, String> contentMap = new ConcurrentHashMap<Integer, String>();\n+\n+    private ChannelFuture connectionFuture;\n+\n+    @Before\n+    public void setup() throws InterruptedException {\n+        ServerBootstrap serverBootstrap = new ServerBootstrap()\n+                .group(eventLoopGroup)\n+                .channel(NioServerSocketChannel.class)\n+                .childHandler(new ChannelInitializer<SocketChannel>() {\n+                    @Override\n+                    protected void initChannel(SocketChannel ch) {\n+                        ChannelPipeline pipeline = ch.pipeline();\n+\n+                        Http2FrameCodec frameCodec = Http2FrameCodecBuilder.forServer()\n+                                .autoAckSettingsFrame(true)\n+                                .autoAckPingFrame(true)\n+                                .build();\n+\n+                        pipeline.addLast(frameCodec);\n+                        pipeline.addLast(new ServerHandler());\n+                    }\n+                });\n+\n+        ChannelFuture channelFuture = serverBootstrap.bind(0).sync();\n+\n+        final Bootstrap bootstrap = new Bootstrap()\n+                .group(eventLoopGroup)\n+                .channel(NioSocketChannel.class)\n+                .handler(new ChannelInitializer<SocketChannel>() {\n+                    @Override\n+                    protected void initChannel(SocketChannel ch) {\n+                        ChannelPipeline pipeline = ch.pipeline();\n+\n+                        Http2FrameCodec frameCodec = Http2FrameCodecBuilder.forClient()\n+                                .autoAckSettingsFrame(true)\n+                                .autoAckPingFrame(true)\n+                                .initialSettings(Http2Settings.defaultSettings().pushEnabled(true))\n+                                .build();\n+\n+                        pipeline.addLast(frameCodec);\n+                        pipeline.addLast(clientHandler);\n+                    }\n+                });\n+\n+        connectionFuture = bootstrap.connect(channelFuture.channel().localAddress());\n+    }\n+\n+    @Test\n+    public void send() {\n+        connectionFuture.addListener(new ChannelFutureListener() {\n+            @Override\n+            public void operationComplete(ChannelFuture future) {\n+                clientHandler.write();\n+            }\n+        });\n+    }\n+\n+    @After\n+    public void shutdown() {\n+        eventLoopGroup.shutdownGracefully();\n+    }\n+\n+    private final class ServerHandler extends Http2ChannelDuplexHandler {\n+\n+        @Override\n+        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n+\n+            if (msg instanceof Http2HeadersFrame) {\n+                Http2HeadersFrame receivedFrame = (Http2HeadersFrame) msg;\n+\n+                Http2Headers pushRequestHeaders = new DefaultHttp2Headers();\n+                pushRequestHeaders.path(\"/meow\")\n+                        .method(\"GET\")\n+                        .scheme(\"https\")\n+                        .authority(\"localhost:5555\");\n+\n+                // Write PUSH_PROMISE request headers\n+                Http2FrameStream newPushFrameStream = newStream();\n+                Http2PushPromiseFrame pushPromiseFrame = new DefaultHttp2PushPromiseFrame(pushRequestHeaders);\n+                pushPromiseFrame.stream(receivedFrame.stream());\n+                pushPromiseFrame.pushStream(newPushFrameStream);\n+                ctx.writeAndFlush(pushPromiseFrame);\n+\n+                contentMap.put(newPushFrameStream.id(), \"Meow, I am Pushed via HTTP/2\");", "originalCommit": "1e5c29a2dd026e428dc51db903e97943c563515b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "53eeaf1d33270dc24db0077b6528e36c6f63b2d7", "url": "https://github.com/netty/netty/commit/53eeaf1d33270dc24db0077b6528e36c6f63b2d7", "message": "address more issues", "committedDate": "2020-12-27T09:46:54Z", "type": "commit"}, {"oid": "c861f2351c13fc203a61a7d18873ba518f119a94", "url": "https://github.com/netty/netty/commit/c861f2351c13fc203a61a7d18873ba518f119a94", "message": "refactor code with IDE", "committedDate": "2020-12-27T09:49:48Z", "type": "commit"}, {"oid": "d3fecf72d6337ce005b310046d78ec4518ec1a91", "url": "https://github.com/netty/netty/commit/d3fecf72d6337ce005b310046d78ec4518ec1a91", "message": "remove extra empty line", "committedDate": "2020-12-27T09:51:56Z", "type": "commit"}]}