{"pr_number": 10737, "pr_title": "Implement SWAR indexOf byte search", "pr_createdAt": "2020-10-28T08:09:27Z", "pr_url": "https://github.com/netty/netty/pull/10737", "timeline": [{"oid": "808c7c594d99a9dab15280957407f5ba4a9a32e2", "url": "https://github.com/netty/netty/commit/808c7c594d99a9dab15280957407f5ba4a9a32e2", "message": "Implement SWAR indexOf byte search\n\nMotivation:\n\nFaster indexOf\n\nModification:\n\nCreate generic SWAR indexOf that any ByteBuf implementation can use\n\nResult:\n\nFixes #10731", "committedDate": "2020-10-28T08:20:36Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI1NTE3MA==", "url": "https://github.com/netty/netty/pull/10737#discussion_r513255170", "bodyText": "you can do this as long pattern = (byteToFind & 0xFFL) * 0x101010101010101L", "author": "richardstartin", "createdAt": "2020-10-28T08:23:33Z", "path": "buffer/src/main/java/io/netty/buffer/ByteBufUtil.java", "diffHunk": "@@ -389,6 +389,89 @@ private static long compareUintBigEndianB(\n         return 0;\n     }\n \n+    private static final class SWARByteSearch {\n+\n+        private static final long[] SEARCH_PATTERNS;\n+\n+        static {\n+            SEARCH_PATTERNS = new long[256];\n+            for (int i = 0; i < SEARCH_PATTERNS.length; ++i) {\n+                final byte b = (byte) (i - 128);\n+                SEARCH_PATTERNS[i] = compilePattern(b);\n+            }\n+        }\n+\n+        private static long compilePattern(byte byteToFind) {\n+            long pattern = byteToFind & 0xFFL;\n+            return pattern\n+                   | (pattern << 8)", "originalCommit": "808c7c594d99a9dab15280957407f5ba4a9a32e2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI1NjQxOQ==", "url": "https://github.com/netty/netty/pull/10737#discussion_r513256419", "bodyText": "Since you're doing a little endian check elsewhere, I would consider making little and big endian variants of this method, just because it makes it harder to mix and match", "author": "richardstartin", "createdAt": "2020-10-28T08:25:41Z", "path": "buffer/src/main/java/io/netty/buffer/ByteBufUtil.java", "diffHunk": "@@ -389,6 +389,89 @@ private static long compareUintBigEndianB(\n         return 0;\n     }\n \n+    private static final class SWARByteSearch {\n+\n+        private static final long[] SEARCH_PATTERNS;\n+\n+        static {\n+            SEARCH_PATTERNS = new long[256];\n+            for (int i = 0; i < SEARCH_PATTERNS.length; ++i) {\n+                final byte b = (byte) (i - 128);\n+                SEARCH_PATTERNS[i] = compilePattern(b);\n+            }\n+        }\n+\n+        private static long compilePattern(byte byteToFind) {\n+            long pattern = byteToFind & 0xFFL;\n+            return pattern\n+                   | (pattern << 8)\n+                   | (pattern << 16)\n+                   | (pattern << 24)\n+                   | (pattern << 32)\n+                   | (pattern << 40)\n+                   | (pattern << 48)\n+                   | (pattern << 56);\n+        }\n+\n+        private static long patternOf(byte b) {\n+            return SEARCH_PATTERNS[b + 128];\n+        }\n+\n+        private static int firstAnyPattern(long word, long pattern, boolean leading) {\n+            long input = word ^ pattern;\n+            long tmp = (input & 0x7F7F7F7F7F7F7F7FL) + 0x7F7F7F7F7F7F7F7FL;\n+            tmp = ~(tmp | input | 0x7F7F7F7F7F7F7F7FL);\n+            final int binaryPosition = leading? Long.numberOfLeadingZeros(tmp) : Long.numberOfTrailingZeros(tmp);\n+            return binaryPosition >>> 3;\n+        }\n+\n+        // TODO: save using any pattern for the 0 search case, if we care\n+        private static int firstZeroByte(long word, long pattern, boolean leading) {\n+            long tmp = (word & 0x7F7F7F7F7F7F7F7FL) + 0x7F7F7F7F7F7F7F7FL;\n+            tmp = ~(tmp | word | 0x7F7F7F7F7F7F7F7FL);\n+            final int binaryPosition = leading? Long.numberOfLeadingZeros(tmp) : Long.numberOfTrailingZeros(tmp);", "originalCommit": "808c7c594d99a9dab15280957407f5ba4a9a32e2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI1NzU3Mg==", "url": "https://github.com/netty/netty/pull/10737#discussion_r513257572", "bodyText": "Currently this one isn't used yet, but firstAnyPattern instead, but I got the good idea, I will do it for both, \ud83d\udc4d", "author": "franz1981", "createdAt": "2020-10-28T08:27:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI1NjQxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI1ODkyOQ==", "url": "https://github.com/netty/netty/pull/10737#discussion_r513258929", "bodyText": "Will do it right after breakfast :P", "author": "franz1981", "createdAt": "2020-10-28T08:30:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI1NjQxOQ=="}], "type": "inlineReview"}, {"oid": "35c1e254f9daf5d516ba40d4341788e8405ddf87", "url": "https://github.com/netty/netty/commit/35c1e254f9daf5d516ba40d4341788e8405ddf87", "message": "Implement SWAR indexOf byte search\n\nMotivation:\n\nFaster indexOf\n\nModification:\n\nCreate generic SWAR indexOf that any ByteBuf implementation can use\n\nResult:\n\nFixes #10731", "committedDate": "2020-10-28T08:25:34Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI1NzExMQ==", "url": "https://github.com/netty/netty/pull/10737#discussion_r513257111", "bodyText": "This is 2KB, but if you change this to the multiplication mentioned earlier, I don't see benefit from caching", "author": "richardstartin", "createdAt": "2020-10-28T08:26:55Z", "path": "buffer/src/main/java/io/netty/buffer/ByteBufUtil.java", "diffHunk": "@@ -389,6 +389,81 @@ private static long compareUintBigEndianB(\n         return 0;\n     }\n \n+    private static final class SWARByteSearch {\n+\n+        private static final long[] SEARCH_PATTERNS;\n+\n+        static {\n+            SEARCH_PATTERNS = new long[256];\n+            for (int i = 0; i < SEARCH_PATTERNS.length; ++i) {\n+                final byte b = (byte) (i - 128);\n+                SEARCH_PATTERNS[i] = compilePattern(b);", "originalCommit": "35c1e254f9daf5d516ba40d4341788e8405ddf87", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI1Nzg4Nw==", "url": "https://github.com/netty/netty/pull/10737#discussion_r513257887", "bodyText": "That's better, it's now very cheap, great", "author": "franz1981", "createdAt": "2020-10-28T08:28:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI1NzExMQ=="}], "type": "inlineReview"}, {"oid": "f09f5d56a5734fe7a9e941e8e28fb2487ff6403a", "url": "https://github.com/netty/netty/commit/f09f5d56a5734fe7a9e941e8e28fb2487ff6403a", "message": "Implement SWAR indexOf byte search\n\nMotivation:\n\nFaster indexOf\n\nModification:\n\nCreate generic SWAR indexOf that any ByteBuf implementation can use\n\nResult:\n\nFixes #10731", "committedDate": "2020-10-28T08:29:17Z", "type": "forcePushed"}, {"oid": "cd47c9035f7bfbc60801dc061e8e6c728a696fab", "url": "https://github.com/netty/netty/commit/cd47c9035f7bfbc60801dc061e8e6c728a696fab", "message": "Implement SWAR indexOf byte search\n\nMotivation:\n\nFaster indexOf\n\nModification:\n\nCreate generic SWAR indexOf that any ByteBuf implementation can use\n\nResult:\n\nFixes #10731", "committedDate": "2020-10-28T11:30:29Z", "type": "forcePushed"}, {"oid": "2ee1c68fa3da5a2252915d7f3b33e204d7555b6a", "url": "https://github.com/netty/netty/commit/2ee1c68fa3da5a2252915d7f3b33e204d7555b6a", "message": "Move capacity() call to be a nearly monomorphic", "committedDate": "2020-10-31T13:37:16Z", "type": "forcePushed"}, {"oid": "4582ff1209ef5f5091ec1af1116fddaacbabf06a", "url": "https://github.com/netty/netty/commit/4582ff1209ef5f5091ec1af1116fddaacbabf06a", "message": "Implement SWAR indexOf byte search\n\nMotivation:\n\nFaster indexOf\n\nModification:\n\nCreate generic SWAR indexOf that any ByteBuf implementation can use\n\nResult:\n\nFixes #10731", "committedDate": "2020-11-02T13:46:56Z", "type": "forcePushed"}, {"oid": "6c949b582988cbf12a87f27bcadc64a101bd6c32", "url": "https://github.com/netty/netty/commit/6c949b582988cbf12a87f27bcadc64a101bd6c32", "message": "Implement SWAR indexOf byte search\n\nMotivation:\n\nFaster indexOf\n\nModification:\n\nCreate generic SWAR indexOf that any ByteBuf implementation can use\n\nResult:\n\nFixes #10731", "committedDate": "2020-11-02T13:50:44Z", "type": "forcePushed"}, {"oid": "8f0e271210b9dfccef9435e81c60a89ced5cd94d", "url": "https://github.com/netty/netty/commit/8f0e271210b9dfccef9435e81c60a89ced5cd94d", "message": "Implement SWAR indexOf byte search\n\nMotivation:\n\nFaster indexOf\n\nModification:\n\nCreate generic SWAR indexOf that any ByteBuf implementation can use\n\nResult:\n\nFixes #10731", "committedDate": "2020-11-02T20:44:08Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjgxOTA2Ng==", "url": "https://github.com/netty/netty/pull/10737#discussion_r526819066", "bodyText": "This method isn't used.", "author": "chrisvest", "createdAt": "2020-11-19T12:08:14Z", "path": "buffer/src/main/java/io/netty/buffer/ByteBufUtil.java", "diffHunk": "@@ -389,16 +389,132 @@ private static long compareUintBigEndianB(\n         return 0;\n     }\n \n+    private static final class SWARByteSearch {\n+\n+        private static long compilePattern(byte byteToFind) {\n+            return (byteToFind & 0xFFL) * 0x101010101010101L;\n+        }\n+\n+        private static int firstAnyPattern(long word, long pattern, boolean leading) {\n+            long input = word ^ pattern;\n+            long tmp = (input & 0x7F7F7F7F7F7F7F7FL) + 0x7F7F7F7F7F7F7F7FL;\n+            tmp = ~(tmp | input | 0x7F7F7F7F7F7F7F7FL);\n+            final int binaryPosition = leading? Long.numberOfLeadingZeros(tmp) : Long.numberOfTrailingZeros(tmp);\n+            return binaryPosition >>> 3;\n+        }\n+\n+        // TODO: save using any pattern for the 0 search case, if we care\n+        private static int firstZeroByte(long word, boolean leading) {", "originalCommit": "8f0e271210b9dfccef9435e81c60a89ced5cd94d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjk1NTgyMw==", "url": "https://github.com/netty/netty/pull/10737#discussion_r526955823", "bodyText": "Yep can be removed given that it won't improve things as expected", "author": "franz1981", "createdAt": "2020-11-19T15:02:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjgxOTA2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjgyMTcxMA==", "url": "https://github.com/netty/netty/pull/10737#discussion_r526821710", "bodyText": "Did you also try a small counted loop?", "author": "chrisvest", "createdAt": "2020-11-19T12:10:12Z", "path": "buffer/src/main/java/io/netty/buffer/ByteBufUtil.java", "diffHunk": "@@ -389,16 +389,132 @@ private static long compareUintBigEndianB(\n         return 0;\n     }\n \n+    private static final class SWARByteSearch {\n+\n+        private static long compilePattern(byte byteToFind) {\n+            return (byteToFind & 0xFFL) * 0x101010101010101L;\n+        }\n+\n+        private static int firstAnyPattern(long word, long pattern, boolean leading) {\n+            long input = word ^ pattern;\n+            long tmp = (input & 0x7F7F7F7F7F7F7F7FL) + 0x7F7F7F7F7F7F7F7FL;\n+            tmp = ~(tmp | input | 0x7F7F7F7F7F7F7F7FL);\n+            final int binaryPosition = leading? Long.numberOfLeadingZeros(tmp) : Long.numberOfTrailingZeros(tmp);\n+            return binaryPosition >>> 3;\n+        }\n+\n+        // TODO: save using any pattern for the 0 search case, if we care\n+        private static int firstZeroByte(long word, boolean leading) {\n+            long tmp = (word & 0x7F7F7F7F7F7F7F7FL) + 0x7F7F7F7F7F7F7F7FL;\n+            tmp = ~(tmp | word | 0x7F7F7F7F7F7F7F7FL);\n+            final int binaryPosition = leading? Long.numberOfLeadingZeros(tmp) : Long.numberOfTrailingZeros(tmp);\n+            return binaryPosition >>> 3;\n+        }\n+    }\n+\n+    private static int unrolledFirstIndexOf(AbstractByteBuf buffer, int fromIndex, int byteCount, byte value) {\n+        assert byteCount > 0 && byteCount < 8;\n+        if (buffer._getByte(fromIndex) == value) {\n+            return fromIndex;\n+        }\n+        if (byteCount == 1) {\n+            return -1;\n+        }", "originalCommit": "8f0e271210b9dfccef9435e81c60a89ced5cd94d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjk1NTQzMw==", "url": "https://github.com/netty/netty/pull/10737#discussion_r526955433", "bodyText": "Yess with byte indexes too", "author": "franz1981", "createdAt": "2020-11-19T15:01:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjgyMTcxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjgyNTYzOA==", "url": "https://github.com/netty/netty/pull/10737#discussion_r526825638", "bodyText": "I wonder if this class would make sense as a top-level ByteSearch class, and adopt more methods.", "author": "chrisvest", "createdAt": "2020-11-19T12:13:17Z", "path": "buffer/src/main/java/io/netty/buffer/ByteBufUtil.java", "diffHunk": "@@ -389,16 +389,132 @@ private static long compareUintBigEndianB(\n         return 0;\n     }\n \n+    private static final class SWARByteSearch {", "originalCommit": "8f0e271210b9dfccef9435e81c60a89ced5cd94d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjk1NDY0MA==", "url": "https://github.com/netty/netty/pull/10737#discussion_r526954640", "bodyText": "Yes yes and yes :)", "author": "franz1981", "createdAt": "2020-11-19T15:00:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjgyNTYzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjgyNzgyMA==", "url": "https://github.com/netty/netty/pull/10737#discussion_r526827820", "bodyText": "Why would fromIndex ever be negative?", "author": "chrisvest", "createdAt": "2020-11-19T12:15:00Z", "path": "buffer/src/main/java/io/netty/buffer/ByteBufUtil.java", "diffHunk": "@@ -389,16 +389,132 @@ private static long compareUintBigEndianB(\n         return 0;\n     }\n \n+    private static final class SWARByteSearch {\n+\n+        private static long compilePattern(byte byteToFind) {\n+            return (byteToFind & 0xFFL) * 0x101010101010101L;\n+        }\n+\n+        private static int firstAnyPattern(long word, long pattern, boolean leading) {\n+            long input = word ^ pattern;\n+            long tmp = (input & 0x7F7F7F7F7F7F7F7FL) + 0x7F7F7F7F7F7F7F7FL;\n+            tmp = ~(tmp | input | 0x7F7F7F7F7F7F7F7FL);\n+            final int binaryPosition = leading? Long.numberOfLeadingZeros(tmp) : Long.numberOfTrailingZeros(tmp);\n+            return binaryPosition >>> 3;\n+        }\n+\n+        // TODO: save using any pattern for the 0 search case, if we care\n+        private static int firstZeroByte(long word, boolean leading) {\n+            long tmp = (word & 0x7F7F7F7F7F7F7F7FL) + 0x7F7F7F7F7F7F7F7FL;\n+            tmp = ~(tmp | word | 0x7F7F7F7F7F7F7F7FL);\n+            final int binaryPosition = leading? Long.numberOfLeadingZeros(tmp) : Long.numberOfTrailingZeros(tmp);\n+            return binaryPosition >>> 3;\n+        }\n+    }\n+\n+    private static int unrolledFirstIndexOf(AbstractByteBuf buffer, int fromIndex, int byteCount, byte value) {\n+        assert byteCount > 0 && byteCount < 8;\n+        if (buffer._getByte(fromIndex) == value) {\n+            return fromIndex;\n+        }\n+        if (byteCount == 1) {\n+            return -1;\n+        }\n+        if (buffer._getByte(fromIndex + 1) == value) {\n+            return fromIndex + 1;\n+        }\n+        if (byteCount == 2) {\n+            return -1;\n+        }\n+        if (buffer._getByte(fromIndex + 2) == value) {\n+            return fromIndex + 2;\n+        }\n+        if (byteCount == 3) {\n+            return -1;\n+        }\n+        if (buffer._getByte(fromIndex + 3) == value) {\n+            return fromIndex + 3;\n+        }\n+        if (byteCount == 4) {\n+            return -1;\n+        }\n+        if (buffer._getByte(fromIndex + 4) == value) {\n+            return fromIndex + 4;\n+        }\n+        if (byteCount == 5) {\n+            return -1;\n+        }\n+        if (buffer._getByte(fromIndex + 5) == value) {\n+            return fromIndex + 5;\n+        }\n+        if (byteCount == 6) {\n+            return -1;\n+        }\n+        if (buffer._getByte(fromIndex + 6) == value) {\n+            return fromIndex + 6;\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * This is using a SWAR (SIMD Within A Register) batch read technique to minimize bound-checks and improve memory\n+     * usage while searching for {@code value}.\n+     */\n+    static int firstIndexOf(AbstractByteBuf buffer, int fromIndex, int toIndex, byte value) {\n+        fromIndex = Math.max(fromIndex, 0);", "originalCommit": "8f0e271210b9dfccef9435e81c60a89ced5cd94d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjk1Mzk5NQ==", "url": "https://github.com/netty/netty/pull/10737#discussion_r526953995", "bodyText": "Copied from the original implementation, suppose can be removed now", "author": "franz1981", "createdAt": "2020-11-19T15:00:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjgyNzgyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjgzMjI5Nw==", "url": "https://github.com/netty/netty/pull/10737#discussion_r526832297", "bodyText": "I suppose the first linearFirstIndexOf call for platforms that don't support unaligned access is because we have no idea what the underlying alignment of the buffer is. But do we need this unrolled call on platforms that do support unaligned access?", "author": "chrisvest", "createdAt": "2020-11-19T12:22:06Z", "path": "buffer/src/main/java/io/netty/buffer/ByteBufUtil.java", "diffHunk": "@@ -389,16 +389,132 @@ private static long compareUintBigEndianB(\n         return 0;\n     }\n \n+    private static final class SWARByteSearch {\n+\n+        private static long compilePattern(byte byteToFind) {\n+            return (byteToFind & 0xFFL) * 0x101010101010101L;\n+        }\n+\n+        private static int firstAnyPattern(long word, long pattern, boolean leading) {\n+            long input = word ^ pattern;\n+            long tmp = (input & 0x7F7F7F7F7F7F7F7FL) + 0x7F7F7F7F7F7F7F7FL;\n+            tmp = ~(tmp | input | 0x7F7F7F7F7F7F7F7FL);\n+            final int binaryPosition = leading? Long.numberOfLeadingZeros(tmp) : Long.numberOfTrailingZeros(tmp);\n+            return binaryPosition >>> 3;\n+        }\n+\n+        // TODO: save using any pattern for the 0 search case, if we care\n+        private static int firstZeroByte(long word, boolean leading) {\n+            long tmp = (word & 0x7F7F7F7F7F7F7F7FL) + 0x7F7F7F7F7F7F7F7FL;\n+            tmp = ~(tmp | word | 0x7F7F7F7F7F7F7F7FL);\n+            final int binaryPosition = leading? Long.numberOfLeadingZeros(tmp) : Long.numberOfTrailingZeros(tmp);\n+            return binaryPosition >>> 3;\n+        }\n+    }\n+\n+    private static int unrolledFirstIndexOf(AbstractByteBuf buffer, int fromIndex, int byteCount, byte value) {\n+        assert byteCount > 0 && byteCount < 8;\n+        if (buffer._getByte(fromIndex) == value) {\n+            return fromIndex;\n+        }\n+        if (byteCount == 1) {\n+            return -1;\n+        }\n+        if (buffer._getByte(fromIndex + 1) == value) {\n+            return fromIndex + 1;\n+        }\n+        if (byteCount == 2) {\n+            return -1;\n+        }\n+        if (buffer._getByte(fromIndex + 2) == value) {\n+            return fromIndex + 2;\n+        }\n+        if (byteCount == 3) {\n+            return -1;\n+        }\n+        if (buffer._getByte(fromIndex + 3) == value) {\n+            return fromIndex + 3;\n+        }\n+        if (byteCount == 4) {\n+            return -1;\n+        }\n+        if (buffer._getByte(fromIndex + 4) == value) {\n+            return fromIndex + 4;\n+        }\n+        if (byteCount == 5) {\n+            return -1;\n+        }\n+        if (buffer._getByte(fromIndex + 5) == value) {\n+            return fromIndex + 5;\n+        }\n+        if (byteCount == 6) {\n+            return -1;\n+        }\n+        if (buffer._getByte(fromIndex + 6) == value) {\n+            return fromIndex + 6;\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * This is using a SWAR (SIMD Within A Register) batch read technique to minimize bound-checks and improve memory\n+     * usage while searching for {@code value}.\n+     */\n+    static int firstIndexOf(AbstractByteBuf buffer, int fromIndex, int toIndex, byte value) {\n+        fromIndex = Math.max(fromIndex, 0);\n+        if (fromIndex >= toIndex || buffer.capacity() == 0) {\n+            return -1;\n+        }\n+        final int length = toIndex - fromIndex;\n+        buffer.checkIndex(fromIndex, length);\n+        if (!PlatformDependent.isUnaligned()) {\n+            return linearFirstIndexOf(buffer, fromIndex, toIndex, value);\n+        }\n+        assert PlatformDependent.isUnaligned();\n+        int offset = fromIndex;\n+        final int byteCount = length & 7;\n+        if (byteCount > 0) {\n+            final int index = unrolledFirstIndexOf(buffer, fromIndex, byteCount, value);", "originalCommit": "8f0e271210b9dfccef9435e81c60a89ced5cd94d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjk1MzQ0NQ==", "url": "https://github.com/netty/netty/pull/10737#discussion_r526953445", "bodyText": "Yep, it won't improve things for unpredictable inputs (that makes sense) but seems to help a lot the other cases", "author": "franz1981", "createdAt": "2020-11-19T14:59:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjgzMjI5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjgzMzI3Mw==", "url": "https://github.com/netty/netty/pull/10737#discussion_r526833273", "bodyText": "Don't we need to handle a tail? Or is that what the initial unrolled call is for?", "author": "chrisvest", "createdAt": "2020-11-19T12:23:46Z", "path": "buffer/src/main/java/io/netty/buffer/ByteBufUtil.java", "diffHunk": "@@ -389,16 +389,132 @@ private static long compareUintBigEndianB(\n         return 0;\n     }\n \n+    private static final class SWARByteSearch {\n+\n+        private static long compilePattern(byte byteToFind) {\n+            return (byteToFind & 0xFFL) * 0x101010101010101L;\n+        }\n+\n+        private static int firstAnyPattern(long word, long pattern, boolean leading) {\n+            long input = word ^ pattern;\n+            long tmp = (input & 0x7F7F7F7F7F7F7F7FL) + 0x7F7F7F7F7F7F7F7FL;\n+            tmp = ~(tmp | input | 0x7F7F7F7F7F7F7F7FL);\n+            final int binaryPosition = leading? Long.numberOfLeadingZeros(tmp) : Long.numberOfTrailingZeros(tmp);\n+            return binaryPosition >>> 3;\n+        }\n+\n+        // TODO: save using any pattern for the 0 search case, if we care\n+        private static int firstZeroByte(long word, boolean leading) {\n+            long tmp = (word & 0x7F7F7F7F7F7F7F7FL) + 0x7F7F7F7F7F7F7F7FL;\n+            tmp = ~(tmp | word | 0x7F7F7F7F7F7F7F7FL);\n+            final int binaryPosition = leading? Long.numberOfLeadingZeros(tmp) : Long.numberOfTrailingZeros(tmp);\n+            return binaryPosition >>> 3;\n+        }\n+    }\n+\n+    private static int unrolledFirstIndexOf(AbstractByteBuf buffer, int fromIndex, int byteCount, byte value) {\n+        assert byteCount > 0 && byteCount < 8;\n+        if (buffer._getByte(fromIndex) == value) {\n+            return fromIndex;\n+        }\n+        if (byteCount == 1) {\n+            return -1;\n+        }\n+        if (buffer._getByte(fromIndex + 1) == value) {\n+            return fromIndex + 1;\n+        }\n+        if (byteCount == 2) {\n+            return -1;\n+        }\n+        if (buffer._getByte(fromIndex + 2) == value) {\n+            return fromIndex + 2;\n+        }\n+        if (byteCount == 3) {\n+            return -1;\n+        }\n+        if (buffer._getByte(fromIndex + 3) == value) {\n+            return fromIndex + 3;\n+        }\n+        if (byteCount == 4) {\n+            return -1;\n+        }\n+        if (buffer._getByte(fromIndex + 4) == value) {\n+            return fromIndex + 4;\n+        }\n+        if (byteCount == 5) {\n+            return -1;\n+        }\n+        if (buffer._getByte(fromIndex + 5) == value) {\n+            return fromIndex + 5;\n+        }\n+        if (byteCount == 6) {\n+            return -1;\n+        }\n+        if (buffer._getByte(fromIndex + 6) == value) {\n+            return fromIndex + 6;\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * This is using a SWAR (SIMD Within A Register) batch read technique to minimize bound-checks and improve memory\n+     * usage while searching for {@code value}.\n+     */\n+    static int firstIndexOf(AbstractByteBuf buffer, int fromIndex, int toIndex, byte value) {\n+        fromIndex = Math.max(fromIndex, 0);\n+        if (fromIndex >= toIndex || buffer.capacity() == 0) {\n+            return -1;\n+        }\n+        final int length = toIndex - fromIndex;\n+        buffer.checkIndex(fromIndex, length);\n+        if (!PlatformDependent.isUnaligned()) {\n+            return linearFirstIndexOf(buffer, fromIndex, toIndex, value);\n+        }\n+        assert PlatformDependent.isUnaligned();\n+        int offset = fromIndex;\n+        final int byteCount = length & 7;\n+        if (byteCount > 0) {\n+            final int index = unrolledFirstIndexOf(buffer, fromIndex, byteCount, value);\n+            if (index != -1) {\n+                return index;\n+            }\n+            offset += byteCount;\n+            if (offset == toIndex) {\n+                return -1;\n+            }\n+        }\n+        final int longCount = length >>> 3;\n+        final ByteOrder nativeOrder = ByteOrder.nativeOrder();\n+        final boolean isNative = nativeOrder == buffer.order();\n+        final boolean useLE = nativeOrder == ByteOrder.LITTLE_ENDIAN;\n+        final long pattern = SWARByteSearch.compilePattern(value);\n+        for (int i = 0; i < longCount; i++) {\n+            // use the faster available getLong\n+            final long word = useLE? buffer._getLongLE(offset) : buffer._getLong(offset);\n+            int index = SWARByteSearch.firstAnyPattern(word, pattern, isNative);\n+            if (index < Long.BYTES) {\n+                return offset + index;\n+            }\n+            offset += Long.BYTES;\n+        }\n+        return -1;", "originalCommit": "8f0e271210b9dfccef9435e81c60a89ced5cd94d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjk1MjQ1Mw==", "url": "https://github.com/netty/netty/pull/10737#discussion_r526952453", "bodyText": "Exactly!", "author": "franz1981", "createdAt": "2020-11-19T14:58:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjgzMzI3Mw=="}], "type": "inlineReview"}, {"oid": "330347cb56874daf6be077d588bf6d2d3e70868e", "url": "https://github.com/netty/netty/commit/330347cb56874daf6be077d588bf6d2d3e70868e", "message": "Implement SWAR indexOf byte search\n\nMotivation:\n\nFaster indexOf\n\nModification:\n\nCreate generic SWAR indexOf that any ByteBuf implementation can use\n\nResult:\n\nFixes #10731", "committedDate": "2020-12-09T09:26:07Z", "type": "commit"}, {"oid": "330347cb56874daf6be077d588bf6d2d3e70868e", "url": "https://github.com/netty/netty/commit/330347cb56874daf6be077d588bf6d2d3e70868e", "message": "Implement SWAR indexOf byte search\n\nMotivation:\n\nFaster indexOf\n\nModification:\n\nCreate generic SWAR indexOf that any ByteBuf implementation can use\n\nResult:\n\nFixes #10731", "committedDate": "2020-12-09T09:26:07Z", "type": "forcePushed"}]}