{"pr_number": 10860, "pr_title": "Workaround possible JDK bug in SSLEngineImpl when using TLSv1.3 that \u2026", "pr_createdAt": "2020-12-11T15:34:50Z", "pr_url": "https://github.com/netty/netty/pull/10860", "timeline": [{"oid": "e21ba63d8ffa5009d5836713804484faeb8112c2", "url": "https://github.com/netty/netty/commit/e21ba63d8ffa5009d5836713804484faeb8112c2", "message": "Workaround possible JDK bug in SSLEngineImpl when using TLSv1.3 that lead to multiple notifications\n\nMotivation:\n\nWhen using the JDKs SSLEngineImpl with TLSv1.3 it sometimes returns HandshakeResult.FINISHED multiple times. This can lead to have SslHandshakeCompletionEvents to be fired multiple times.\n\nModifications:\n\n- Keep track of if we notified before and if so not do so again if we use TLSv1.3\n- Add unit test\n\nResult:\n\nConsistent usage of events", "committedDate": "2020-12-11T15:32:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTE1NjE2Nw==", "url": "https://github.com/netty/netty/pull/10860#discussion_r541156167", "bodyText": "Consider having 2 independent queues for client and server to make sure both of them see the same number if events.", "author": "idelpivnitskiy", "createdAt": "2020-12-11T18:50:26Z", "path": "handler/src/test/java/io/netty/handler/ssl/SslHandlerTest.java", "diffHunk": "@@ -1482,4 +1482,102 @@ protected void initChannel(Channel ch) {\n         }\n     }\n \n+    @Test\n+    public void testHandshakeEventsTls12JDK() throws Exception {\n+        testHandshakeEvents(SslProvider.JDK, SslUtils.PROTOCOL_TLS_V1_2);\n+    }\n+\n+    @Test\n+    public void testHandshakeEventsTls12Openssl() throws Exception {\n+        assumeTrue(OpenSsl.isAvailable());\n+        testHandshakeEvents(SslProvider.OPENSSL, SslUtils.PROTOCOL_TLS_V1_2);\n+    }\n+\n+    @Test\n+    public void testHandshakeEventsTls13JDK() throws Exception {\n+        assumeTrue(SslProvider.isTlsv13Supported(SslProvider.JDK));\n+        testHandshakeEvents(SslProvider.JDK, SslUtils.PROTOCOL_TLS_V1_3);\n+    }\n+\n+    @Test\n+    public void testHandshakeEventsTls13Openssl() throws Exception {\n+        assumeTrue(OpenSsl.isAvailable());\n+        assumeTrue(SslProvider.isTlsv13Supported(SslProvider.OPENSSL));\n+        testHandshakeEvents(SslProvider.OPENSSL, SslUtils.PROTOCOL_TLS_V1_3);\n+    }\n+\n+    private void testHandshakeEvents(SslProvider provider, String protocol) throws Exception {\n+        final SslContext sslClientCtx = SslContextBuilder.forClient()\n+                .trustManager(InsecureTrustManagerFactory.INSTANCE)\n+                .protocols(protocol)\n+                .sslProvider(provider).build();\n+\n+        final SelfSignedCertificate cert = new SelfSignedCertificate();\n+        final SslContext sslServerCtx = SslContextBuilder.forServer(cert.key(), cert.cert())\n+                .protocols(protocol)\n+                .sslProvider(provider).build();\n+\n+        EventLoopGroup group = new NioEventLoopGroup();\n+\n+        final LinkedBlockingQueue<SslHandshakeCompletionEvent> completionEvents =\n+                new LinkedBlockingQueue<SslHandshakeCompletionEvent>();\n+        final ChannelHandler completionEventHandler = new ChannelInboundHandlerAdapter() {\n+            @Override\n+            public void userEventTriggered(ChannelHandlerContext ctx, Object evt) {\n+                if (evt instanceof SslHandshakeCompletionEvent) {\n+                    completionEvents.add((SslHandshakeCompletionEvent) evt);\n+                }\n+            }\n+\n+            @Override\n+            public boolean isSharable() {\n+                return true;\n+            }\n+        };\n+        try {\n+            Channel sc = new ServerBootstrap()\n+                    .group(group)\n+                    .channel(NioServerSocketChannel.class)\n+                    .childHandler(new ChannelInitializer<Channel>() {\n+                        @Override\n+                        protected void initChannel(Channel ch) throws Exception {\n+                            ch.pipeline().addLast(sslServerCtx.newHandler(UnpooledByteBufAllocator.DEFAULT));\n+                            ch.pipeline().addLast(completionEventHandler);\n+                        }\n+                    })\n+                    .bind(new InetSocketAddress(0)).syncUninterruptibly().channel();\n+\n+            Bootstrap bs = new Bootstrap()\n+                    .group(group)\n+                    .channel(NioSocketChannel.class)\n+                    .handler(new ChannelInitializer<Channel>() {\n+                        @Override\n+                        protected void initChannel(Channel ch) {\n+                            ch.pipeline().addLast(sslClientCtx.newHandler(\n+                                    UnpooledByteBufAllocator.DEFAULT, \"netty.io\", 9999));\n+                            ch.pipeline().addLast(completionEventHandler);\n+                        }\n+                    })\n+                    .remoteAddress(sc.localAddress());\n+\n+            Channel cc1 = bs.connect().sync().channel();\n+            Channel cc2 = bs.connect().sync().channel();\n+\n+            // We expect 4 events as we have 2 connections and for each connection there should be one event\n+            // on the server-side and one on the client-side.\n+            for (int i = 0; i < 4; i++) {\n+                SslHandshakeCompletionEvent event = completionEvents.take();", "originalCommit": "e21ba63d8ffa5009d5836713804484faeb8112c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTE2MzQ4OA==", "url": "https://github.com/netty/netty/pull/10860#discussion_r541163488", "bodyText": "Is engineType == SslEngineType.JDK is necessary here? I think we can have only notified || !SslUtils.PROTOCOL_TLS_V1_3.equals(session.getProtocol()).\nAlso, IIUC in case of renegotiation netty initializes a new handshakePromise. So, the notified will also be true for renegotiation.", "author": "idelpivnitskiy", "createdAt": "2020-12-11T19:00:03Z", "path": "handler/src/main/java/io/netty/handler/ssl/SslHandler.java", "diffHunk": "@@ -1800,17 +1800,24 @@ private boolean setHandshakeSuccessIfStillHandshaking() {\n      * Notify all the handshake futures about the successfully handshake\n      */\n     private void setHandshakeSuccess() {\n-        handshakePromise.trySuccess(ctx.channel());\n-\n-        if (logger.isDebugEnabled()) {\n-            SSLSession session = engine.getSession();\n-            logger.debug(\n-              \"{} HANDSHAKEN: protocol:{} cipher suite:{}\",\n-              ctx.channel(),\n-              session.getProtocol(),\n-              session.getCipherSuite());\n+        boolean notified = handshakePromise.trySuccess(ctx.channel());\n+        SSLSession session = engine.getSession();\n+\n+        // There seems to be a bug in the SSLEngineImpl that is part of the OpenJDK that results in returning\n+        // HandshakeStatus.FINISHED multiple times which is not expected. This only happens in TLSv1.3 so lets\n+        // ensure we only notify once in this case.\n+        //\n+        // This is safe as TLSv1.3 does not support renegotiation and so we should never see two handshake events.\n+        if (notified || engineType == SslEngineType.JDK && !SslUtils.PROTOCOL_TLS_V1_3.equals(session.getProtocol())) {", "originalCommit": "e21ba63d8ffa5009d5836713804484faeb8112c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjczODAyNg==", "url": "https://github.com/netty/netty/pull/10860#discussion_r542738026", "bodyText": "I guess yeah we can simplify. This won't harm", "author": "normanmaurer", "createdAt": "2020-12-14T20:20:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTE2MzQ4OA=="}], "type": "inlineReview"}, {"oid": "75ec3eedb876ced05238ec2d38e2a5cb220d1a48", "url": "https://github.com/netty/netty/commit/75ec3eedb876ced05238ec2d38e2a5cb220d1a48", "message": "Address comment", "committedDate": "2020-12-14T20:33:10Z", "type": "commit"}]}