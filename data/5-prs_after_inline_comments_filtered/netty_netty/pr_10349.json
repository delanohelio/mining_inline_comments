{"pr_number": 10349, "pr_title": "Add option to HttpObjectDecoder to allow duplicate Content-Lengths", "pr_createdAt": "2020-06-12T21:44:57Z", "pr_url": "https://github.com/netty/netty/pull/10349", "timeline": [{"oid": "9b2954c8d105cd38c9ccaa101af26b884aaf34b8", "url": "https://github.com/netty/netty/commit/9b2954c8d105cd38c9ccaa101af26b884aaf34b8", "message": "Add option to HttpObjectDecoder to allow duplicate Content-Lengths\n\nMotivation\n\nSince https://github.com/netty/netty/pull/9865 (Netty 4.1.44) the\ndefault behavior of the HttpObjectDecoder has been to reject any HTTP\nmessage that is found to have multiple Content-Length headers when\ndecoding. This behavior is well-justified as per the risks outlined in\nhttps://github.com/netty/netty/issues/9861, however, we can see from the\ncited RFC section that there are multiple possible options offered for\nresponding to this scenario:\n\n> If a message is received that has multiple Content-Length header\n> fields with field-values consisting of the same decimal value, or a\n> single Content-Length header field with a field value containing a\n> list of identical decimal values (e.g., \"Content-Length: 42, 42\"),\n> indicating that duplicate Content-Length header fields have been\n> generated or combined by an upstream message processor, then the\n> recipient MUST either reject the message as invalid or replace the\n> duplicated field-values with a single valid Content-Length field\n> containing that decimal value prior to determining the message body\n> length or forwarding the message.\n\nhttps://tools.ietf.org/html/rfc7230#section-3.3.2\n\nNetty opted for the first option (rejecting as invalid), which seems\nlike the safest, but the second option (replacing duplicate values with\na single value) is also valid behavior.\n\nModifications\n\n* Introduce \"allowDuplicateContentLengths\" parameter to\nHttpObjectDecoder (defaulting to false).\n* When set to true, will allow multiple Content-Length headers only if\nthey are all the same value. The duplicated field-values will be\nreplaced with a single valid Content-Length field.\n* Add new parameterized test class for testing different variations of\nmultiple Content-Length headers.\n\nResult\n\nThis is a backwards-compatible change with no functional change to the\nexisting behavior.\n\nNote that the existing logic would result in NumberFormatExceptions\nfor header values like \"Content-Length: 42, 42\". The new logic correctly\nreports these as IllegalArgumentException with the proper error message.\n\nAdditionally note that this behavior is only applied to HTTP/1.1, but I\nsuspect that we may want to expand that to include HTTP/1.0 as well...\nThat behavior is not modified here to minimize the scope of this change.", "committedDate": "2020-06-12T21:41:33Z", "type": "commit"}, {"oid": "52a944faaf9da82c0d038b2717585c6fa5302f93", "url": "https://github.com/netty/netty/commit/52a944faaf9da82c0d038b2717585c6fa5302f93", "message": "Add option to HttpObjectDecoder to allow duplicate Content-Lengths\n\nMotivation\n\nSince https://github.com/netty/netty/pull/9865 (Netty 4.1.44) the\ndefault behavior of the HttpObjectDecoder has been to reject any HTTP\nmessage that is found to have multiple Content-Length headers when\ndecoding. This behavior is well-justified as per the risks outlined in\nhttps://github.com/netty/netty/issues/9861, however, we can see from the\ncited RFC section that there are multiple possible options offered for\nresponding to this scenario:\n\n> If a message is received that has multiple Content-Length header\n> fields with field-values consisting of the same decimal value, or a\n> single Content-Length header field with a field value containing a\n> list of identical decimal values (e.g., \"Content-Length: 42, 42\"),\n> indicating that duplicate Content-Length header fields have been\n> generated or combined by an upstream message processor, then the\n> recipient MUST either reject the message as invalid or replace the\n> duplicated field-values with a single valid Content-Length field\n> containing that decimal value prior to determining the message body\n> length or forwarding the message.\n\nhttps://tools.ietf.org/html/rfc7230#section-3.3.2\n\nNetty opted for the first option (rejecting as invalid), which seems\nlike the safest, but the second option (replacing duplicate values with\na single value) is also valid behavior.\n\nModifications\n\n* Introduce \"allowDuplicateContentLengths\" parameter to\nHttpObjectDecoder (defaulting to false).\n* When set to true, will allow multiple Content-Length headers only if\nthey are all the same value. The duplicated field-values will be\nreplaced with a single valid Content-Length field.\n* Add new parameterized test class for testing different variations of\nmultiple Content-Length headers.\n\nResult\n\nThis is a backwards-compatible change with no functional change to the\nexisting behavior.\n\nNote that the existing logic would result in NumberFormatExceptions\nfor header values like \"Content-Length: 42, 42\". The new logic correctly\nreports these as IllegalArgumentException with the proper error message.\n\nAdditionally note that this behavior is only applied to HTTP/1.1, but I\nsuspect that we may want to expand that to include HTTP/1.0 as well...\nThat behavior is not modified here to minimize the scope of this change.", "committedDate": "2020-06-15T20:03:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk4NzE0Ng==", "url": "https://github.com/netty/netty/pull/10349#discussion_r444987146", "bodyText": "IIUC the content should be just a, not ab. Same for testDanglingComma", "author": "idelpivnitskiy", "createdAt": "2020-06-24T15:37:03Z", "path": "codec-http/src/test/java/io/netty/handler/codec/http/MultipleContentLengthHeadersTest.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.http;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.embedded.EmbeddedChannel;\n+import io.netty.util.CharsetUtil;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import static io.netty.handler.codec.http.HttpObjectDecoder.DEFAULT_INITIAL_BUFFER_SIZE;\n+import static io.netty.handler.codec.http.HttpObjectDecoder.DEFAULT_MAX_CHUNK_SIZE;\n+import static io.netty.handler.codec.http.HttpObjectDecoder.DEFAULT_MAX_HEADER_SIZE;\n+import static io.netty.handler.codec.http.HttpObjectDecoder.DEFAULT_MAX_INITIAL_LINE_LENGTH;\n+import static io.netty.handler.codec.http.HttpObjectDecoder.DEFAULT_VALIDATE_HEADERS;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.contains;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.core.IsInstanceOf.instanceOf;\n+\n+@RunWith(Parameterized.class)\n+public class MultipleContentLengthHeadersTest {\n+\n+    private final boolean allowDuplicateContentLengths;\n+    private final boolean sameValue;\n+    private final boolean singleField;\n+\n+    private EmbeddedChannel channel;\n+\n+    @Parameters\n+    public static Collection<Object[]> parameters() {\n+        return Arrays.asList(new Object[][] {\n+                { false, false, false },\n+                { false, false, true },\n+                { false, true, false },\n+                { false, true, true },\n+                { true, false, false },\n+                { true, false, true },\n+                { true, true, false },\n+                { true, true, true }\n+        });\n+    }\n+\n+    public MultipleContentLengthHeadersTest(\n+            boolean allowDuplicateContentLengths, boolean sameValue, boolean singleField) {\n+        this.allowDuplicateContentLengths = allowDuplicateContentLengths;\n+        this.sameValue = sameValue;\n+        this.singleField = singleField;\n+    }\n+\n+    @Before\n+    public void setUp() {\n+        HttpRequestDecoder decoder = new HttpRequestDecoder(\n+                DEFAULT_MAX_INITIAL_LINE_LENGTH,\n+                DEFAULT_MAX_HEADER_SIZE,\n+                DEFAULT_MAX_CHUNK_SIZE,\n+                DEFAULT_VALIDATE_HEADERS,\n+                DEFAULT_INITIAL_BUFFER_SIZE,\n+                allowDuplicateContentLengths);\n+        channel = new EmbeddedChannel(decoder);\n+    }\n+\n+    @Test\n+    public void testMultipleContentLengthHeadersBehavior() {\n+        String requestStr = setupRequestString();\n+        assertThat(channel.writeInbound(Unpooled.copiedBuffer(requestStr, CharsetUtil.US_ASCII)), is(true));\n+        HttpRequest request = channel.readInbound();\n+\n+        if (allowDuplicateContentLengths) {\n+            if (sameValue) {\n+                assertValid(request);\n+                List<String> contentLengths = request.headers().getAll(HttpHeaderNames.CONTENT_LENGTH);\n+                assertThat(contentLengths, contains(\"1\"));\n+                LastHttpContent body = channel.readInbound();\n+                assertThat(body.content().readableBytes(), is(1));\n+                assertThat(body.content().readCharSequence(1, CharsetUtil.US_ASCII).toString(), is(\"a\"));\n+            } else {\n+                assertInvalid(request);\n+            }\n+        } else {\n+            assertInvalid(request);\n+        }\n+        assertThat(channel.finish(), is(false));\n+    }\n+\n+    private String setupRequestString() {\n+        String firstValue = \"1\";\n+        String secondValue = sameValue ? firstValue : \"2\";\n+        String contentLength;\n+        if (singleField) {\n+            contentLength = \"Content-Length: \" + firstValue + \", \" + secondValue + \"\\r\\n\\r\\n\";\n+        } else {\n+            contentLength = \"Content-Length: \" + firstValue + \"\\r\\n\" +\n+                            \"Content-Length: \" + secondValue + \"\\r\\n\\r\\n\";\n+        }\n+        return \"PUT /some/path HTTP/1.1\\r\\n\" +\n+               contentLength +\n+               \"ab\";", "originalCommit": "52a944faaf9da82c0d038b2717585c6fa5302f93", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA4NzM1MA==", "url": "https://github.com/netty/netty/pull/10349#discussion_r445087350", "bodyText": "The reason I chose ab is that we provide two content-lengths: 1 and 2. I wanted the potential body size to be the max of the possible content-lengths (2) so that we can assert the interpreted body is 1 and we gain more confidence in knowing that the decoder explicitly stopped parsing after 1.\nFrom an assertion perspective, perhaps it's somewhat redundant to assert on the body content being a after asserting the body size is 1, but I think it makes it more intuitive and could maybe catch some more egregious regressions.", "author": "Bennett-Lynch", "createdAt": "2020-06-24T18:24:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk4NzE0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk4OTE2NQ==", "url": "https://github.com/netty/netty/pull/10349#discussion_r444989165", "bodyText": "Should we verify that there is no more bytes in the channel after we read the content? Or that a new requests starts after the first one.", "author": "idelpivnitskiy", "createdAt": "2020-06-24T15:40:08Z", "path": "codec-http/src/test/java/io/netty/handler/codec/http/MultipleContentLengthHeadersTest.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.http;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.embedded.EmbeddedChannel;\n+import io.netty.util.CharsetUtil;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import static io.netty.handler.codec.http.HttpObjectDecoder.DEFAULT_INITIAL_BUFFER_SIZE;\n+import static io.netty.handler.codec.http.HttpObjectDecoder.DEFAULT_MAX_CHUNK_SIZE;\n+import static io.netty.handler.codec.http.HttpObjectDecoder.DEFAULT_MAX_HEADER_SIZE;\n+import static io.netty.handler.codec.http.HttpObjectDecoder.DEFAULT_MAX_INITIAL_LINE_LENGTH;\n+import static io.netty.handler.codec.http.HttpObjectDecoder.DEFAULT_VALIDATE_HEADERS;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.contains;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.core.IsInstanceOf.instanceOf;\n+\n+@RunWith(Parameterized.class)\n+public class MultipleContentLengthHeadersTest {\n+\n+    private final boolean allowDuplicateContentLengths;\n+    private final boolean sameValue;\n+    private final boolean singleField;\n+\n+    private EmbeddedChannel channel;\n+\n+    @Parameters\n+    public static Collection<Object[]> parameters() {\n+        return Arrays.asList(new Object[][] {\n+                { false, false, false },\n+                { false, false, true },\n+                { false, true, false },\n+                { false, true, true },\n+                { true, false, false },\n+                { true, false, true },\n+                { true, true, false },\n+                { true, true, true }\n+        });\n+    }\n+\n+    public MultipleContentLengthHeadersTest(\n+            boolean allowDuplicateContentLengths, boolean sameValue, boolean singleField) {\n+        this.allowDuplicateContentLengths = allowDuplicateContentLengths;\n+        this.sameValue = sameValue;\n+        this.singleField = singleField;\n+    }\n+\n+    @Before\n+    public void setUp() {\n+        HttpRequestDecoder decoder = new HttpRequestDecoder(\n+                DEFAULT_MAX_INITIAL_LINE_LENGTH,\n+                DEFAULT_MAX_HEADER_SIZE,\n+                DEFAULT_MAX_CHUNK_SIZE,\n+                DEFAULT_VALIDATE_HEADERS,\n+                DEFAULT_INITIAL_BUFFER_SIZE,\n+                allowDuplicateContentLengths);\n+        channel = new EmbeddedChannel(decoder);\n+    }\n+\n+    @Test\n+    public void testMultipleContentLengthHeadersBehavior() {\n+        String requestStr = setupRequestString();\n+        assertThat(channel.writeInbound(Unpooled.copiedBuffer(requestStr, CharsetUtil.US_ASCII)), is(true));\n+        HttpRequest request = channel.readInbound();\n+\n+        if (allowDuplicateContentLengths) {\n+            if (sameValue) {\n+                assertValid(request);\n+                List<String> contentLengths = request.headers().getAll(HttpHeaderNames.CONTENT_LENGTH);\n+                assertThat(contentLengths, contains(\"1\"));\n+                LastHttpContent body = channel.readInbound();\n+                assertThat(body.content().readableBytes(), is(1));\n+                assertThat(body.content().readCharSequence(1, CharsetUtil.US_ASCII).toString(), is(\"a\"));", "originalCommit": "52a944faaf9da82c0d038b2717585c6fa5302f93", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA4NzM2OQ==", "url": "https://github.com/netty/netty/pull/10349#discussion_r445087369", "bodyText": "We do expect there to be 1 \"leftover\" byte in the ByteToMessageDecoder#cumulation buffer. I'm not sure if it offers any value in explicitly asserting that if we are already asserting on the interpreted body size. If you think it adds value I can add more tests.", "author": "Bennett-Lynch", "createdAt": "2020-06-24T18:24:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk4OTE2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk5Mjc5Mg==", "url": "https://github.com/netty/netty/pull/10349#discussion_r444992792", "bodyText": "Would be nice to add this param to the class javadoc, after description of maxInitialLineLength, maxHeaderSize, and maxChunkSize.\nOther missing params (chunkedSupported, validateHeaders, and initialBufferSize) can be documented in a follow-up PR.", "author": "idelpivnitskiy", "createdAt": "2020-06-24T15:45:25Z", "path": "codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java", "diffHunk": "@@ -176,9 +181,20 @@ protected HttpObjectDecoder(\n              DEFAULT_INITIAL_BUFFER_SIZE);\n     }\n \n+    /**\n+     * Creates a new instance with the specified parameters.\n+     */\n     protected HttpObjectDecoder(\n             int maxInitialLineLength, int maxHeaderSize, int maxChunkSize,\n             boolean chunkedSupported, boolean validateHeaders, int initialBufferSize) {\n+        this(maxInitialLineLength, maxHeaderSize, maxChunkSize, chunkedSupported, validateHeaders, initialBufferSize,\n+             DEFAULT_ALLOW_DUPLICATE_CONTENT_LENGTHS);\n+    }\n+\n+    protected HttpObjectDecoder(\n+            int maxInitialLineLength, int maxHeaderSize, int maxChunkSize,\n+            boolean chunkedSupported, boolean validateHeaders, int initialBufferSize,\n+            boolean allowDuplicateContentLengths) {", "originalCommit": "52a944faaf9da82c0d038b2717585c6fa5302f93", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA4NzM4Mg==", "url": "https://github.com/netty/netty/pull/10349#discussion_r445087382", "bodyText": "I agree that it should be documented, I just couldn't find a great place to include it (since nothing is currently documented). I will take the liberty to add it to the class Javadoc.\nEdit: Just noticed the documentation you're referring to, thanks for pointing that out.", "author": "Bennett-Lynch", "createdAt": "2020-06-24T18:24:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk5Mjc5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA1NjQ5Ng==", "url": "https://github.com/netty/netty/pull/10349#discussion_r445056496", "bodyText": "It may be useful to add the mismatched values to the error message;\n\"Multiple Content-Length values found: \" + trimmed  + \" and \" + firstValue", "author": "NiteshKant", "createdAt": "2020-06-24T17:29:25Z", "path": "codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java", "diffHunk": "@@ -611,17 +627,40 @@ private State readHeaders(ByteBuf buffer) {\n             //   duplicated field-values with a single valid Content-Length field\n             //   containing that decimal value prior to determining the message body\n             //   length or forwarding the message.\n-            if (contentLengthValuesCount > 1 && message.protocolVersion() == HttpVersion.HTTP_1_1) {\n-                throw new IllegalArgumentException(\"Multiple Content-Length headers found\");\n+            boolean multipleContentLengths =\n+                    contentLengthFields.size() > 1 || contentLengthFields.get(0).indexOf(COMMA) >= 0;\n+            if (multipleContentLengths && message.protocolVersion() == HttpVersion.HTTP_1_1) {\n+                if (allowDuplicateContentLengths) {\n+                    // Find and enforce that all Content-Length values are the same\n+                    String firstValue = null;\n+                    for (String field : contentLengthFields) {\n+                        String[] tokens = COMMA_PATTERN.split(field, -1);\n+                        for (String token : tokens) {\n+                            String trimmed = token.trim();\n+                            if (firstValue == null) {\n+                                firstValue = trimmed;\n+                            } else if (!trimmed.equals(firstValue)) {\n+                                throw new IllegalArgumentException(\"Multiple Content-Length headers found\");", "originalCommit": "52a944faaf9da82c0d038b2717585c6fa5302f93", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA4OTU4Mw==", "url": "https://github.com/netty/netty/pull/10349#discussion_r445089583", "bodyText": "I like this idea but I'm not sure if there's a precedent for reporting request data in exceptions. This may cause some applications to inadvertently log data that users may consider to be sensitive.", "author": "Bennett-Lynch", "createdAt": "2020-06-24T18:28:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA1NjQ5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA5MzM2NQ==", "url": "https://github.com/netty/netty/pull/10349#discussion_r445093365", "bodyText": "Since the data here is content-length, I think the sensitive data risk is pretty low if not impossible, but I would defer to @normanmaurer for it.", "author": "NiteshKant", "createdAt": "2020-06-24T18:35:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA1NjQ5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA5Mzg0Ng==", "url": "https://github.com/netty/netty/pull/10349#discussion_r445093846", "bodyText": "Yeah I think it should be fine", "author": "normanmaurer", "createdAt": "2020-06-24T18:36:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA1NjQ5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTExNTIyMg==", "url": "https://github.com/netty/netty/pull/10349#discussion_r445115222", "bodyText": "Mostly agree on content-length hopefully being less sensitive. I will bias towards including it for now.", "author": "Bennett-Lynch", "createdAt": "2020-06-24T19:16:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA1NjQ5Ng=="}], "type": "inlineReview"}, {"oid": "cbe7e8bac25f06681aa08293a952069ac17f13bf", "url": "https://github.com/netty/netty/commit/cbe7e8bac25f06681aa08293a952069ac17f13bf", "message": "Add option to HttpObjectDecoder to allow duplicate Content-Lengths\n\nMotivation\n\nSince https://github.com/netty/netty/pull/9865 (Netty 4.1.44) the\ndefault behavior of the HttpObjectDecoder has been to reject any HTTP\nmessage that is found to have multiple Content-Length headers when\ndecoding. This behavior is well-justified as per the risks outlined in\nhttps://github.com/netty/netty/issues/9861, however, we can see from the\ncited RFC section that there are multiple possible options offered for\nresponding to this scenario:\n\n> If a message is received that has multiple Content-Length header\n> fields with field-values consisting of the same decimal value, or a\n> single Content-Length header field with a field value containing a\n> list of identical decimal values (e.g., \"Content-Length: 42, 42\"),\n> indicating that duplicate Content-Length header fields have been\n> generated or combined by an upstream message processor, then the\n> recipient MUST either reject the message as invalid or replace the\n> duplicated field-values with a single valid Content-Length field\n> containing that decimal value prior to determining the message body\n> length or forwarding the message.\n\nhttps://tools.ietf.org/html/rfc7230#section-3.3.2\n\nNetty opted for the first option (rejecting as invalid), which seems\nlike the safest, but the second option (replacing duplicate values with\na single value) is also valid behavior.\n\nModifications\n\n* Introduce \"allowDuplicateContentLengths\" parameter to\nHttpObjectDecoder (defaulting to false).\n* When set to true, will allow multiple Content-Length headers only if\nthey are all the same value. The duplicated field-values will be\nreplaced with a single valid Content-Length field.\n* Add new parameterized test class for testing different variations of\nmultiple Content-Length headers.\n\nResult\n\nThis is a backwards-compatible change with no functional change to the\nexisting behavior.\n\nNote that the existing logic would result in NumberFormatExceptions\nfor header values like \"Content-Length: 42, 42\". The new logic correctly\nreports these as IllegalArgumentException with the proper error message.\n\nAdditionally note that this behavior is only applied to HTTP/1.1, but I\nsuspect that we may want to expand that to include HTTP/1.0 as well...\nThat behavior is not modified here to minimize the scope of this change.", "committedDate": "2020-06-24T19:15:34Z", "type": "commit"}, {"oid": "33c96e15bf4fbb6a0bf2266d0e5b87197872f824", "url": "https://github.com/netty/netty/commit/33c96e15bf4fbb6a0bf2266d0e5b87197872f824", "message": "Add option to HttpObjectDecoder to allow duplicate Content-Lengths\n\nMotivation\n\nSince https://github.com/netty/netty/pull/9865 (Netty 4.1.44) the\ndefault behavior of the HttpObjectDecoder has been to reject any HTTP\nmessage that is found to have multiple Content-Length headers when\ndecoding. This behavior is well-justified as per the risks outlined in\nhttps://github.com/netty/netty/issues/9861, however, we can see from the\ncited RFC section that there are multiple possible options offered for\nresponding to this scenario:\n\n> If a message is received that has multiple Content-Length header\n> fields with field-values consisting of the same decimal value, or a\n> single Content-Length header field with a field value containing a\n> list of identical decimal values (e.g., \"Content-Length: 42, 42\"),\n> indicating that duplicate Content-Length header fields have been\n> generated or combined by an upstream message processor, then the\n> recipient MUST either reject the message as invalid or replace the\n> duplicated field-values with a single valid Content-Length field\n> containing that decimal value prior to determining the message body\n> length or forwarding the message.\n\nhttps://tools.ietf.org/html/rfc7230#section-3.3.2\n\nNetty opted for the first option (rejecting as invalid), which seems\nlike the safest, but the second option (replacing duplicate values with\na single value) is also valid behavior.\n\nModifications\n\n* Introduce \"allowDuplicateContentLengths\" parameter to\nHttpObjectDecoder (defaulting to false).\n* When set to true, will allow multiple Content-Length headers only if\nthey are all the same value. The duplicated field-values will be\nreplaced with a single valid Content-Length field.\n* Add new parameterized test class for testing different variations of\nmultiple Content-Length headers.\n\nResult\n\nThis is a backwards-compatible change with no functional change to the\nexisting behavior.\n\nNote that the existing logic would result in NumberFormatExceptions\nfor header values like \"Content-Length: 42, 42\". The new logic correctly\nreports these as IllegalArgumentException with the proper error message.\n\nAdditionally note that this behavior is only applied to HTTP/1.1, but I\nsuspect that we may want to expand that to include HTTP/1.0 as well...\nThat behavior is not modified here to minimize the scope of this change.", "committedDate": "2020-06-24T19:36:23Z", "type": "commit"}, {"oid": "afd72539ea42de31168a56665c6905ec9efc96f1", "url": "https://github.com/netty/netty/commit/afd72539ea42de31168a56665c6905ec9efc96f1", "message": "Add option to HttpObjectDecoder to allow duplicate Content-Lengths\n\nMotivation\n\nSince https://github.com/netty/netty/pull/9865 (Netty 4.1.44) the\ndefault behavior of the HttpObjectDecoder has been to reject any HTTP\nmessage that is found to have multiple Content-Length headers when\ndecoding. This behavior is well-justified as per the risks outlined in\nhttps://github.com/netty/netty/issues/9861, however, we can see from the\ncited RFC section that there are multiple possible options offered for\nresponding to this scenario:\n\n> If a message is received that has multiple Content-Length header\n> fields with field-values consisting of the same decimal value, or a\n> single Content-Length header field with a field value containing a\n> list of identical decimal values (e.g., \"Content-Length: 42, 42\"),\n> indicating that duplicate Content-Length header fields have been\n> generated or combined by an upstream message processor, then the\n> recipient MUST either reject the message as invalid or replace the\n> duplicated field-values with a single valid Content-Length field\n> containing that decimal value prior to determining the message body\n> length or forwarding the message.\n\nhttps://tools.ietf.org/html/rfc7230#section-3.3.2\n\nNetty opted for the first option (rejecting as invalid), which seems\nlike the safest, but the second option (replacing duplicate values with\na single value) is also valid behavior.\n\nModifications\n\n* Introduce \"allowDuplicateContentLengths\" parameter to\nHttpObjectDecoder (defaulting to false).\n* When set to true, will allow multiple Content-Length headers only if\nthey are all the same value. The duplicated field-values will be\nreplaced with a single valid Content-Length field.\n* Add new parameterized test class for testing different variations of\nmultiple Content-Length headers.\n\nResult\n\nThis is a backwards-compatible change with no functional change to the\nexisting behavior.\n\nNote that the existing logic would result in NumberFormatExceptions\nfor header values like \"Content-Length: 42, 42\". The new logic correctly\nreports these as IllegalArgumentException with the proper error message.\n\nAdditionally note that this behavior is only applied to HTTP/1.1, but I\nsuspect that we may want to expand that to include HTTP/1.0 as well...\nThat behavior is not modified here to minimize the scope of this change.", "committedDate": "2020-06-25T22:58:30Z", "type": "commit"}]}