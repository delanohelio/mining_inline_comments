{"pr_number": 10826, "pr_title": "Create bespoke long/long hashmap and long-valued priority queue for PoolChunk", "pr_createdAt": "2020-11-25T15:15:27Z", "pr_url": "https://github.com/netty/netty/pull/10826", "timeline": [{"oid": "718f29c4d43a962c79faaef7f3a443ff5a90bb2b", "url": "https://github.com/netty/netty/commit/718f29c4d43a962c79faaef7f3a443ff5a90bb2b", "message": "Create bespoke long/long hashmap and long-valued priority queue for PoolChunk\n\nMotivation:\nThe uncached access to PoolChunk can be made faster, and avoid allocating boxed Longs, if we have a primitive hash map and priority queue implementation for it.\n\nModification:\nAdd bespoke primitive implementations of a hash map and a priority queue for PoolChunk.\nRemove all the long-boxing caused by the previous implementation.\nThe hashmap is a linear probing map with a fairly short probe that keeps the search within a couple of cache lines.\nThe priority queue is the same binary heap algorithm that's described in Algorithms by Sedgewick and Wayne.\nThe implementation avoids the Long boxing by relying on a long[] array.\nThis makes the internal-remove method faster, which is an important operation in PoolChunk.\n\nResult:\nI see a roughly 25% performance uplift in buffer allocations that miss cache.", "committedDate": "2020-11-25T15:41:46Z", "type": "commit"}, {"oid": "718f29c4d43a962c79faaef7f3a443ff5a90bb2b", "url": "https://github.com/netty/netty/commit/718f29c4d43a962c79faaef7f3a443ff5a90bb2b", "message": "Create bespoke long/long hashmap and long-valued priority queue for PoolChunk\n\nMotivation:\nThe uncached access to PoolChunk can be made faster, and avoid allocating boxed Longs, if we have a primitive hash map and priority queue implementation for it.\n\nModification:\nAdd bespoke primitive implementations of a hash map and a priority queue for PoolChunk.\nRemove all the long-boxing caused by the previous implementation.\nThe hashmap is a linear probing map with a fairly short probe that keeps the search within a couple of cache lines.\nThe priority queue is the same binary heap algorithm that's described in Algorithms by Sedgewick and Wayne.\nThe implementation avoids the Long boxing by relying on a long[] array.\nThis makes the internal-remove method faster, which is an important operation in PoolChunk.\n\nResult:\nI see a roughly 25% performance uplift in buffer allocations that miss cache.", "committedDate": "2020-11-25T15:41:46Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ3NDgzNA==", "url": "https://github.com/netty/netty/pull/10826#discussion_r530474834", "bodyText": "Do we need to also shrink the internal storage at some point ?", "author": "normanmaurer", "createdAt": "2020-11-25T15:51:50Z", "path": "buffer/src/main/java/io/netty/buffer/PoolChunk.java", "diffHunk": "@@ -643,4 +638,161 @@ static boolean isSubpage(long handle) {\n     static int bitmapIdx(long handle) {\n         return (int) handle;\n     }\n+\n+    private static final class LongLongHashMap {\n+        private static final int MAX_PROBE = 4;\n+        private int mask = 31;\n+        private long[] array = new long[mask + 1];\n+        private long zeroVal;\n+\n+        public long put(long key, long value) {\n+            if (key == 0) {\n+                long prev = zeroVal;\n+                zeroVal = value;\n+                return prev;\n+            }\n+\n+            for (;;) {\n+                int index = index(key);\n+                for (int i = 0; i < MAX_PROBE; i++) {\n+                    long existing = array[index];\n+                    if (existing == key || existing == 0) {\n+                        long prev = array[index + 1];\n+                        array[index] = key;\n+                        array[index + 1] = value;\n+                        return prev;\n+                    }\n+                    index = index + 2 & mask;\n+                }\n+                expand(); // Grow array and re-hash.\n+            }\n+        }\n+\n+        public void remove(long key) {", "originalCommit": "718f29c4d43a962c79faaef7f3a443ff5a90bb2b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ3NTE3Ng==", "url": "https://github.com/netty/netty/pull/10826#discussion_r530475176", "bodyText": "Do we also need to shrink the internal storage at some point ?", "author": "normanmaurer", "createdAt": "2020-11-25T15:52:16Z", "path": "buffer/src/main/java/io/netty/buffer/PoolChunk.java", "diffHunk": "@@ -643,4 +638,161 @@ static boolean isSubpage(long handle) {\n     static int bitmapIdx(long handle) {\n         return (int) handle;\n     }\n+\n+    private static final class LongLongHashMap {\n+        private static final int MAX_PROBE = 4;\n+        private int mask = 31;\n+        private long[] array = new long[mask + 1];\n+        private long zeroVal;\n+\n+        public long put(long key, long value) {\n+            if (key == 0) {\n+                long prev = zeroVal;\n+                zeroVal = value;\n+                return prev;\n+            }\n+\n+            for (;;) {\n+                int index = index(key);\n+                for (int i = 0; i < MAX_PROBE; i++) {\n+                    long existing = array[index];\n+                    if (existing == key || existing == 0) {\n+                        long prev = array[index + 1];\n+                        array[index] = key;\n+                        array[index + 1] = value;\n+                        return prev;\n+                    }\n+                    index = index + 2 & mask;\n+                }\n+                expand(); // Grow array and re-hash.\n+            }\n+        }\n+\n+        public void remove(long key) {\n+            if (key == 0) {\n+                zeroVal = 0;\n+                return;\n+            }\n+            int index = index(key);\n+            for (int i = 0; i < MAX_PROBE; i++) {\n+                long existing = array[index];\n+                if (existing == key) {\n+                    array[index] = 0;\n+                    array[index + 1] = 0;\n+                    break;\n+                }\n+                index = index + 2 & mask;\n+            }\n+        }\n+\n+        public long get(long key) {\n+            if (key == 0) {\n+                return zeroVal;\n+            }\n+            int index = index(key);\n+            for (int i = 0; i < MAX_PROBE; i++) {\n+                long existing = array[index];\n+                if (existing == key) {\n+                    return array[index + 1];\n+                }\n+                index = index + 2 & mask;\n+            }\n+            return -1;\n+        }\n+\n+        private int index(long key) {\n+            return (int) (key << 1 & mask);\n+        }\n+\n+        private void expand() {\n+            long[] prev = array;\n+            int newSize = prev.length * 2;\n+            mask = newSize - 1;\n+            array = new long[newSize];\n+            for (int i = 0; i < prev.length >> 1; i += 2) {\n+                long key = prev[i];\n+                long val = prev[i + 1];\n+                put(key, val);\n+            }\n+        }\n+    }\n+\n+    private static final class LongPriorityQueue {\n+        private long[] array = new long[9];\n+        private int size;\n+\n+        public void offer(long handle) {\n+            size++;\n+            if (size == array.length) {\n+                // Grow queue capacity.\n+                array = Arrays.copyOf(array, 1 + (array.length - 1) * 2);\n+            }\n+            array[size] = handle;\n+            lift();\n+        }\n+\n+        public void remove(long value) {", "originalCommit": "718f29c4d43a962c79faaef7f3a443ff5a90bb2b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ5ODAzMA==", "url": "https://github.com/netty/netty/pull/10826#discussion_r530498030", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if (nextRun == 0) {\n          \n          \n            \n                        if (nextRun == -1) {\n          \n      \n    \n    \n  \n\n== 0 seems like a bug", "author": "normanmaurer", "createdAt": "2020-11-25T16:24:25Z", "path": "buffer/src/main/java/io/netty/buffer/PoolChunk.java", "diffHunk": "@@ -531,8 +526,8 @@ private long collapseNext(long handle) {\n             int runOffset = runOffset(handle);\n             int runPages = runPages(handle);\n \n-            Long nextRun = getAvailRunByOffset(runOffset + runPages);\n-            if (nextRun == null) {\n+            long nextRun = getAvailRunByOffset(runOffset + runPages);\n+            if (nextRun == 0) {", "originalCommit": "718f29c4d43a962c79faaef7f3a443ff5a90bb2b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ5ODQ3OQ==", "url": "https://github.com/netty/netty/pull/10826#discussion_r530498479", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if (pastRun == 0) {\n          \n          \n            \n                        if (pastRun == -1) {\n          \n      \n    \n    \n  \n\n== 0 seems incorrect", "author": "normanmaurer", "createdAt": "2020-11-25T16:25:04Z", "path": "buffer/src/main/java/io/netty/buffer/PoolChunk.java", "diffHunk": "@@ -507,8 +502,8 @@ private long collapsePast(long handle) {\n             int runOffset = runOffset(handle);\n             int runPages = runPages(handle);\n \n-            Long pastRun = getAvailRunByOffset(runOffset - 1);\n-            if (pastRun == null) {\n+            long pastRun = getAvailRunByOffset(runOffset - 1);\n+            if (pastRun == 0) {", "originalCommit": "718f29c4d43a962c79faaef7f3a443ff5a90bb2b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ5OTQ1Mg==", "url": "https://github.com/netty/netty/pull/10826#discussion_r530499452", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            return 0;\n          \n          \n            \n                            return -1;\n          \n      \n    \n    \n  \n\nI think -1 is better as 0 is a valid value for offer", "author": "normanmaurer", "createdAt": "2020-11-25T16:26:22Z", "path": "buffer/src/main/java/io/netty/buffer/PoolChunk.java", "diffHunk": "@@ -643,4 +638,161 @@ static boolean isSubpage(long handle) {\n     static int bitmapIdx(long handle) {\n         return (int) handle;\n     }\n+\n+    private static final class LongLongHashMap {\n+        private static final int MAX_PROBE = 4;\n+        private int mask = 31;\n+        private long[] array = new long[mask + 1];\n+        private long zeroVal;\n+\n+        public long put(long key, long value) {\n+            if (key == 0) {\n+                long prev = zeroVal;\n+                zeroVal = value;\n+                return prev;\n+            }\n+\n+            for (;;) {\n+                int index = index(key);\n+                for (int i = 0; i < MAX_PROBE; i++) {\n+                    long existing = array[index];\n+                    if (existing == key || existing == 0) {\n+                        long prev = array[index + 1];\n+                        array[index] = key;\n+                        array[index + 1] = value;\n+                        return prev;\n+                    }\n+                    index = index + 2 & mask;\n+                }\n+                expand(); // Grow array and re-hash.\n+            }\n+        }\n+\n+        public void remove(long key) {\n+            if (key == 0) {\n+                zeroVal = 0;\n+                return;\n+            }\n+            int index = index(key);\n+            for (int i = 0; i < MAX_PROBE; i++) {\n+                long existing = array[index];\n+                if (existing == key) {\n+                    array[index] = 0;\n+                    array[index + 1] = 0;\n+                    break;\n+                }\n+                index = index + 2 & mask;\n+            }\n+        }\n+\n+        public long get(long key) {\n+            if (key == 0) {\n+                return zeroVal;\n+            }\n+            int index = index(key);\n+            for (int i = 0; i < MAX_PROBE; i++) {\n+                long existing = array[index];\n+                if (existing == key) {\n+                    return array[index + 1];\n+                }\n+                index = index + 2 & mask;\n+            }\n+            return -1;\n+        }\n+\n+        private int index(long key) {\n+            return (int) (key << 1 & mask);\n+        }\n+\n+        private void expand() {\n+            long[] prev = array;\n+            int newSize = prev.length * 2;\n+            mask = newSize - 1;\n+            array = new long[newSize];\n+            for (int i = 0; i < prev.length >> 1; i += 2) {\n+                long key = prev[i];\n+                long val = prev[i + 1];\n+                put(key, val);\n+            }\n+        }\n+    }\n+\n+    private static final class LongPriorityQueue {\n+        private long[] array = new long[9];\n+        private int size;\n+\n+        public void offer(long handle) {\n+            size++;\n+            if (size == array.length) {\n+                // Grow queue capacity.\n+                array = Arrays.copyOf(array, 1 + (array.length - 1) * 2);\n+            }\n+            array[size] = handle;\n+            lift();\n+        }\n+\n+        public void remove(long value) {\n+            for (int i = 1; i <= size; i++) {\n+                if (array[i] == value) {\n+                    if (i == size) {\n+                        array[i] = 0;\n+                    } else {\n+                        array[i] = array[size];\n+                        sink(i);\n+                    }\n+                    size--;\n+                    return;\n+                }\n+            }\n+        }\n+\n+        public long poll() {\n+            if (size == 0) {\n+                return 0;", "originalCommit": "718f29c4d43a962c79faaef7f3a443ff5a90bb2b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUwMDMxNw==", "url": "https://github.com/netty/netty/pull/10826#discussion_r530500317", "bodyText": "If we do this change we also need to adjust a few other places that check for == 0", "author": "normanmaurer", "createdAt": "2020-11-25T16:27:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ5OTQ1Mg=="}], "type": "inlineReview"}, {"oid": "d1f392e416b275e954c57737ef52eba25344cc6a", "url": "https://github.com/netty/netty/commit/d1f392e416b275e954c57737ef52eba25344cc6a", "message": "Move internal data structures from PoolChunk to top-level classes\n\nMotivation:\nWe wish to test these independently.\n\nModification:\nMake inner classes top-level, moving LongLongHashMap and LongPriorityQueue out of PoolChunk.\n\nResult:\nThese classes can now be accessed from tests.", "committedDate": "2020-11-26T13:48:16Z", "type": "commit"}, {"oid": "ee73dfc355359fae184a9e5a6d9afdeca6933640", "url": "https://github.com/netty/netty/commit/ee73dfc355359fae184a9e5a6d9afdeca6933640", "message": "Make the LongPriorityQueue use -1, instead of 0, to signal the absence of a value.\n\nMotivation:\nUsing -1 as a token value for the absence of a value makes more sense, since 0 could be a legal value in the use case in PoolChunk.\n\nModification:\nThe LongPriorityQueue now uses -1 (and has a NO_VALUE constant for it) to signal the absence of a value, or that the queue is empty.\nUsage sites in PoolChunk have been adjusted accordingly.\n\nResult:\nCleaner code.", "committedDate": "2020-11-26T17:09:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTE1OTI1Mw==", "url": "https://github.com/netty/netty/pull/10826#discussion_r531159253", "bodyText": "let's put a proper assert with monitor check", "author": "franz1981", "createdAt": "2020-11-26T17:21:58Z", "path": "buffer/src/main/java/io/netty/buffer/PoolArena.java", "diffHunk": "@@ -190,7 +190,7 @@ private void tcacheAllocateNormal(PoolThreadCache cache, PooledByteBuf<T> buf, f\n         }\n     }\n \n-    // Method must be called inside synchronized(this) { ... }\u00a0block\n+    // Method must be called inside synchronized(this) { ... } block", "originalCommit": "ee73dfc355359fae184a9e5a6d9afdeca6933640", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTE3MzMwOA==", "url": "https://github.com/netty/netty/pull/10826#discussion_r531173308", "bodyText": "Lets do this as a follow up as its not related to the PR", "author": "normanmaurer", "createdAt": "2020-11-26T18:00:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTE1OTI1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTE3NDQ4Ng==", "url": "https://github.com/netty/netty/pull/10826#discussion_r531174486", "bodyText": "what is the reason for returning 0 and not -1 here ? IMHO -1 would be what I expect for a non existing key as handles will always be positive.", "author": "normanmaurer", "createdAt": "2020-11-26T18:03:31Z", "path": "buffer/src/main/java/io/netty/buffer/PoolChunk.java", "diffHunk": "@@ -245,18 +239,18 @@ private void insertAvailRun(int runOffset, int pages, Long handle) {\n         }\n     }\n \n-    private void insertAvailRun0(int runOffset, Long handle) {\n-        Long pre = runsAvailMap.put(runOffset, handle);\n-        assert pre == null;\n+    private void insertAvailRun0(int runOffset, long handle) {\n+        long pre = runsAvailMap.put(runOffset, handle);\n+        assert pre == 0;", "originalCommit": "ee73dfc355359fae184a9e5a6d9afdeca6933640", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "31e2fe5deb8c5a726b4651423db96d87e6fcd101", "url": "https://github.com/netty/netty/commit/31e2fe5deb8c5a726b4651423db96d87e6fcd101", "message": "Add tests for LongPriorityQueue\n\nMotivation:\nAlthough the algorithm is simple, it's important that it works correctly.\n\nModification:\nAdd tests for the LongPriorityQueue.\n\nResult:\nThe LongPriorityQueue is now thoroughly tested direct, instead of indirectly through the various buffer and pool tests.", "committedDate": "2020-11-27T10:30:49Z", "type": "commit"}, {"oid": "90f6bae3defe59f8edbfe2c9d8ff994643d8c484", "url": "https://github.com/netty/netty/commit/90f6bae3defe59f8edbfe2c9d8ff994643d8c484", "message": "Add tests for LongLongHashMap and fix bugs\n\nMotivation:\nSomething as complicated as a hash map obviously needs to have its own set of tests.\n\nModification:\nAdd tests for the LongLongHashMap, and fix the bugs found.\n\nResult:\nThe LongLongHashMap is now well tested, and seems to work correctly.", "committedDate": "2020-11-27T16:34:11Z", "type": "commit"}, {"oid": "b64b8e5a7fbe3dbff2df7944925503a476e9e57e", "url": "https://github.com/netty/netty/commit/b64b8e5a7fbe3dbff2df7944925503a476e9e57e", "message": "Use -1 as the empty value for LongLongHashMap in PoolChunk\n\nMotivation:\n-1 is a more obvious signal for the absence of a value, and it shouldn't be overlapping with the data domain used in PoolChunk.\n\nModification:\nMake PoolChunk instantiate its LongLongHashMap to use -1 as the empty value.\n\nResult:\nCleaner and more obvious code in PoolChunk.", "committedDate": "2020-11-27T16:45:47Z", "type": "commit"}, {"oid": "584552c2b33f952131abc9702c65c6651d98adad", "url": "https://github.com/netty/netty/commit/584552c2b33f952131abc9702c65c6651d98adad", "message": "Remove diamond operators to make things compile on all supported Java versions", "committedDate": "2020-11-27T16:50:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjEyNjIwMA==", "url": "https://github.com/netty/netty/pull/10826#discussion_r532126200", "bodyText": "Curious why the special handling of key 0?", "author": "njhill", "createdAt": "2020-11-29T01:05:42Z", "path": "buffer/src/main/java/io/netty/buffer/LongLongHashMap.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.buffer;\n+\n+/**\n+ * Internal primitive map implementation that is specifically optimised for the runs availability map use case in {@link\n+ * PoolChunk}.\n+ */\n+final class LongLongHashMap {\n+    private static final int MASK_TEMPLATE = ~1;\n+    private int mask;\n+    private long[] array;\n+    private int maxProbe;\n+    private long zeroVal;", "originalCommit": "584552c2b33f952131abc9702c65c6651d98adad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQ4NzMyNQ==", "url": "https://github.com/netty/netty/pull/10826#discussion_r532487325", "bodyText": "Zero is used as a marker in the array, that an entry is unused. So we need to handle them specially because those keys cannot be stored in the array.", "author": "chrisvest", "createdAt": "2020-11-30T10:21:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjEyNjIwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjEyNjQwOA==", "url": "https://github.com/netty/netty/pull/10826#discussion_r532126408", "bodyText": "Since this is special purpose how about just hard-coding this to -1? Might allow bit more compiler optimization (non-static final is untrusted)", "author": "njhill", "createdAt": "2020-11-29T01:08:38Z", "path": "buffer/src/main/java/io/netty/buffer/LongLongHashMap.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.buffer;\n+\n+/**\n+ * Internal primitive map implementation that is specifically optimised for the runs availability map use case in {@link\n+ * PoolChunk}.\n+ */\n+final class LongLongHashMap {\n+    private static final int MASK_TEMPLATE = ~1;\n+    private int mask;\n+    private long[] array;\n+    private int maxProbe;\n+    private long zeroVal;\n+    private final long emptyVal;", "originalCommit": "584552c2b33f952131abc9702c65c6651d98adad", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjEyNzM4Nw==", "url": "https://github.com/netty/netty/pull/10826#discussion_r532127387", "bodyText": "nit: no need for var", "author": "njhill", "createdAt": "2020-11-29T01:21:20Z", "path": "buffer/src/main/java/io/netty/buffer/LongLongHashMap.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.buffer;\n+\n+/**\n+ * Internal primitive map implementation that is specifically optimised for the runs availability map use case in {@link\n+ * PoolChunk}.\n+ */\n+final class LongLongHashMap {\n+    private static final int MASK_TEMPLATE = ~1;\n+    private int mask;\n+    private long[] array;\n+    private int maxProbe;\n+    private long zeroVal;\n+    private final long emptyVal;\n+\n+    LongLongHashMap(long emptyVal) {\n+        this.emptyVal = emptyVal;\n+        zeroVal = emptyVal;\n+        int initialSize = 32;\n+        array = new long[initialSize];\n+        mask = initialSize - 1;\n+        computeMaskAndProbe();\n+    }\n+\n+    public long put(long key, long value) {\n+        if (key == 0) {\n+            long prev = zeroVal;\n+            zeroVal = value;\n+            return prev;\n+        }\n+\n+        for (;;) {\n+            int index = index(key);\n+            for (int i = 0; i < maxProbe; i++) {\n+                long existing = array[index];\n+                if (existing == key || existing == 0) {\n+                    long prev = existing == 0? emptyVal : array[index + 1];\n+                    array[index] = key;\n+                    array[index + 1] = value;\n+                    for (; i < maxProbe; i++) { // Nerf any existing misplaced entries.\n+                        index = index + 2 & mask;\n+                        if (array[index] == key) {\n+                            array[index] = 0;\n+                            prev = array[index + 1];\n+                            break;\n+                        }\n+                    }\n+                    return prev;\n+                }\n+                index = index + 2 & mask;\n+            }\n+            expand(); // Grow array and re-hash.\n+        }\n+    }\n+\n+    public void remove(long key) {\n+        if (key == 0) {\n+            zeroVal = emptyVal;\n+            return;\n+        }\n+        int index = index(key);\n+        for (int i = 0; i < maxProbe; i++) {\n+            long existing = array[index];\n+            if (existing == key) {\n+                array[index] = 0;\n+                break;\n+            }\n+            index = index + 2 & mask;\n+        }\n+    }\n+\n+    public long get(long key) {\n+        if (key == 0) {\n+            return zeroVal;\n+        }\n+        int index = index(key);\n+        for (int i = 0; i < maxProbe; i++) {\n+            long existing = array[index];", "originalCommit": "584552c2b33f952131abc9702c65c6651d98adad", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjEyNzU4Nw==", "url": "https://github.com/netty/netty/pull/10826#discussion_r532127587", "bodyText": "How about filling the array with -1 here ... could eliminate some branches in the other methods", "author": "njhill", "createdAt": "2020-11-29T01:23:41Z", "path": "buffer/src/main/java/io/netty/buffer/LongLongHashMap.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.buffer;\n+\n+/**\n+ * Internal primitive map implementation that is specifically optimised for the runs availability map use case in {@link\n+ * PoolChunk}.\n+ */\n+final class LongLongHashMap {\n+    private static final int MASK_TEMPLATE = ~1;\n+    private int mask;\n+    private long[] array;\n+    private int maxProbe;\n+    private long zeroVal;\n+    private final long emptyVal;\n+\n+    LongLongHashMap(long emptyVal) {\n+        this.emptyVal = emptyVal;\n+        zeroVal = emptyVal;\n+        int initialSize = 32;\n+        array = new long[initialSize];", "originalCommit": "584552c2b33f952131abc9702c65c6651d98adad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQ4Nzk3OA==", "url": "https://github.com/netty/netty/pull/10826#discussion_r532487978", "bodyText": "Branch predictors are really good these days. Meanwhile, initialising an array is not free, and would happen at resize events where we already have a spike in service time. So I think this is a better trade off.", "author": "chrisvest", "createdAt": "2020-11-30T10:22:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjEyNzU4Nw=="}], "type": "inlineReview"}]}