{"pr_number": 10237, "pr_title": "Add a DNS client example.", "pr_createdAt": "2020-05-01T04:02:01Z", "pr_url": "https://github.com/netty/netty/pull/10237", "timeline": [{"oid": "a244af9a379336d176051584fad589ad56eca370", "url": "https://github.com/netty/netty/commit/a244af9a379336d176051584fad589ad56eca370", "message": "Add a DNS client example.", "committedDate": "2020-05-01T03:54:06Z", "type": "commit"}, {"oid": "394b3e0f93d8c883e7a7698b13e81c661ea19948", "url": "https://github.com/netty/netty/commit/394b3e0f93d8c883e7a7698b13e81c661ea19948", "message": "Move package from io.netty.example.dns to io.netty.example.dns.udp", "committedDate": "2020-05-03T16:24:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg5NjEwNw==", "url": "https://github.com/netty/netty/pull/10237#discussion_r419896107", "bodyText": "call sync()", "author": "normanmaurer", "createdAt": "2020-05-05T06:47:06Z", "path": "example/src/main/java/io/netty/example/dns/udp/DnsClient.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.example.dns.udp;\n+\n+import java.net.InetSocketAddress;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.ByteBufUtil;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelPipeline;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.DatagramChannel;\n+import io.netty.channel.socket.nio.NioDatagramChannel;\n+import io.netty.handler.codec.dns.DatagramDnsQuery;\n+import io.netty.handler.codec.dns.DatagramDnsQueryEncoder;\n+import io.netty.handler.codec.dns.DatagramDnsResponse;\n+import io.netty.handler.codec.dns.DatagramDnsResponseDecoder;\n+import io.netty.handler.codec.dns.DefaultDnsQuestion;\n+import io.netty.handler.codec.dns.DnsQuery;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsRawRecord;\n+import io.netty.handler.codec.dns.DnsRecord;\n+import io.netty.handler.codec.dns.DnsRecordType;\n+import io.netty.handler.codec.dns.DnsSection;\n+import io.netty.util.NetUtil;\n+import io.netty.util.internal.SocketUtils;\n+\n+public class DnsClient {\n+\n+    private static final String QUERY_DOMAIN = \"www.example.com\";\n+    private static final int DNS_SERVER_PORT = 53;\n+    private static final String DNS_SERVER_HOST = \"8.8.8.8\";\n+\n+    private static void handleQueryResp(DatagramDnsResponse msg) {\n+        if (msg.count(DnsSection.QUESTION) > 0) {\n+            DnsQuestion question = msg.recordAt(DnsSection.QUESTION, 0);\n+            System.out.printf(\"name: %s%n\", question.name());\n+        }\n+        for (int i = 0, count = msg.count(DnsSection.ANSWER); i < count; i++) {\n+            DnsRecord record = msg.recordAt(DnsSection.ANSWER, i);\n+            if (record.type() == DnsRecordType.A) {\n+                //just print the IP after query\n+                DnsRawRecord raw = (DnsRawRecord) record;\n+                System.out.println(NetUtil.bytesToIpAddress(ByteBufUtil.getBytes(raw.content())));\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        InetSocketAddress addr = SocketUtils.socketAddress(DNS_SERVER_HOST, DNS_SERVER_PORT);\n+        final CountDownLatch latch = new CountDownLatch(1);\n+        EventLoopGroup group = new NioEventLoopGroup();\n+        try {\n+            Bootstrap b = new Bootstrap();\n+            b.group(group)\n+             .channel(NioDatagramChannel.class)\n+             .handler(new ChannelInitializer<DatagramChannel>() {\n+                 @Override\n+                 protected void initChannel(DatagramChannel ch) throws Exception {\n+                     ChannelPipeline p = ch.pipeline();\n+                     p.addLast(new DatagramDnsQueryEncoder())\n+                     .addLast(new DatagramDnsResponseDecoder())\n+                     .addLast(new SimpleChannelInboundHandler<DatagramDnsResponse>() {\n+                        @Override\n+                        protected void channelRead0(ChannelHandlerContext ctx, DatagramDnsResponse msg)\n+                                throws Exception {\n+                            try {\n+                                handleQueryResp(msg);\n+                            } finally {\n+                                latch.countDown();\n+                            }\n+                        }\n+                    });\n+                 }\n+             });\n+            Channel ch = b.bind(0).sync().channel();\n+            DnsQuery query = new DatagramDnsQuery(null, addr, 1).setRecord(\n+                    DnsSection.QUESTION,\n+                    new DefaultDnsQuestion(QUERY_DOMAIN, DnsRecordType.A));\n+            ch.writeAndFlush(query);", "originalCommit": "394b3e0f93d8c883e7a7698b13e81c661ea19948", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg5NjM4Mg==", "url": "https://github.com/netty/netty/pull/10237#discussion_r419896382", "bodyText": "remove throws Exception", "author": "normanmaurer", "createdAt": "2020-05-05T06:47:51Z", "path": "example/src/main/java/io/netty/example/dns/udp/DnsClient.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.example.dns.udp;\n+\n+import java.net.InetSocketAddress;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.ByteBufUtil;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelPipeline;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.DatagramChannel;\n+import io.netty.channel.socket.nio.NioDatagramChannel;\n+import io.netty.handler.codec.dns.DatagramDnsQuery;\n+import io.netty.handler.codec.dns.DatagramDnsQueryEncoder;\n+import io.netty.handler.codec.dns.DatagramDnsResponse;\n+import io.netty.handler.codec.dns.DatagramDnsResponseDecoder;\n+import io.netty.handler.codec.dns.DefaultDnsQuestion;\n+import io.netty.handler.codec.dns.DnsQuery;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsRawRecord;\n+import io.netty.handler.codec.dns.DnsRecord;\n+import io.netty.handler.codec.dns.DnsRecordType;\n+import io.netty.handler.codec.dns.DnsSection;\n+import io.netty.util.NetUtil;\n+import io.netty.util.internal.SocketUtils;\n+\n+public class DnsClient {\n+\n+    private static final String QUERY_DOMAIN = \"www.example.com\";\n+    private static final int DNS_SERVER_PORT = 53;\n+    private static final String DNS_SERVER_HOST = \"8.8.8.8\";\n+\n+    private static void handleQueryResp(DatagramDnsResponse msg) {\n+        if (msg.count(DnsSection.QUESTION) > 0) {\n+            DnsQuestion question = msg.recordAt(DnsSection.QUESTION, 0);\n+            System.out.printf(\"name: %s%n\", question.name());\n+        }\n+        for (int i = 0, count = msg.count(DnsSection.ANSWER); i < count; i++) {\n+            DnsRecord record = msg.recordAt(DnsSection.ANSWER, i);\n+            if (record.type() == DnsRecordType.A) {\n+                //just print the IP after query\n+                DnsRawRecord raw = (DnsRawRecord) record;\n+                System.out.println(NetUtil.bytesToIpAddress(ByteBufUtil.getBytes(raw.content())));\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        InetSocketAddress addr = SocketUtils.socketAddress(DNS_SERVER_HOST, DNS_SERVER_PORT);\n+        final CountDownLatch latch = new CountDownLatch(1);\n+        EventLoopGroup group = new NioEventLoopGroup();\n+        try {\n+            Bootstrap b = new Bootstrap();\n+            b.group(group)\n+             .channel(NioDatagramChannel.class)\n+             .handler(new ChannelInitializer<DatagramChannel>() {\n+                 @Override\n+                 protected void initChannel(DatagramChannel ch) throws Exception {\n+                     ChannelPipeline p = ch.pipeline();\n+                     p.addLast(new DatagramDnsQueryEncoder())\n+                     .addLast(new DatagramDnsResponseDecoder())\n+                     .addLast(new SimpleChannelInboundHandler<DatagramDnsResponse>() {\n+                        @Override\n+                        protected void channelRead0(ChannelHandlerContext ctx, DatagramDnsResponse msg)\n+                                throws Exception {", "originalCommit": "394b3e0f93d8c883e7a7698b13e81c661ea19948", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg5NjgzOQ==", "url": "https://github.com/netty/netty/pull/10237#discussion_r419896839", "bodyText": "make final and add private constructor", "author": "normanmaurer", "createdAt": "2020-05-05T06:49:00Z", "path": "example/src/main/java/io/netty/example/dns/udp/DnsClient.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.example.dns.udp;\n+\n+import java.net.InetSocketAddress;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.ByteBufUtil;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelPipeline;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.DatagramChannel;\n+import io.netty.channel.socket.nio.NioDatagramChannel;\n+import io.netty.handler.codec.dns.DatagramDnsQuery;\n+import io.netty.handler.codec.dns.DatagramDnsQueryEncoder;\n+import io.netty.handler.codec.dns.DatagramDnsResponse;\n+import io.netty.handler.codec.dns.DatagramDnsResponseDecoder;\n+import io.netty.handler.codec.dns.DefaultDnsQuestion;\n+import io.netty.handler.codec.dns.DnsQuery;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsRawRecord;\n+import io.netty.handler.codec.dns.DnsRecord;\n+import io.netty.handler.codec.dns.DnsRecordType;\n+import io.netty.handler.codec.dns.DnsSection;\n+import io.netty.util.NetUtil;\n+import io.netty.util.internal.SocketUtils;\n+\n+public class DnsClient {", "originalCommit": "394b3e0f93d8c883e7a7698b13e81c661ea19948", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTkwMzM3Mw==", "url": "https://github.com/netty/netty/pull/10237#discussion_r419903373", "bodyText": "don't use SocketUtils in an example as its a internal class.", "author": "normanmaurer", "createdAt": "2020-05-05T07:05:42Z", "path": "example/src/main/java/io/netty/example/dns/udp/DnsClient.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.example.dns.udp;\n+\n+import java.net.InetSocketAddress;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.ByteBufUtil;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelPipeline;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.DatagramChannel;\n+import io.netty.channel.socket.nio.NioDatagramChannel;\n+import io.netty.handler.codec.dns.DatagramDnsQuery;\n+import io.netty.handler.codec.dns.DatagramDnsQueryEncoder;\n+import io.netty.handler.codec.dns.DatagramDnsResponse;\n+import io.netty.handler.codec.dns.DatagramDnsResponseDecoder;\n+import io.netty.handler.codec.dns.DefaultDnsQuestion;\n+import io.netty.handler.codec.dns.DnsQuery;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsRawRecord;\n+import io.netty.handler.codec.dns.DnsRecord;\n+import io.netty.handler.codec.dns.DnsRecordType;\n+import io.netty.handler.codec.dns.DnsSection;\n+import io.netty.util.NetUtil;\n+import io.netty.util.internal.SocketUtils;\n+\n+public class DnsClient {\n+\n+    private static final String QUERY_DOMAIN = \"www.example.com\";\n+    private static final int DNS_SERVER_PORT = 53;\n+    private static final String DNS_SERVER_HOST = \"8.8.8.8\";\n+\n+    private static void handleQueryResp(DatagramDnsResponse msg) {\n+        if (msg.count(DnsSection.QUESTION) > 0) {\n+            DnsQuestion question = msg.recordAt(DnsSection.QUESTION, 0);\n+            System.out.printf(\"name: %s%n\", question.name());\n+        }\n+        for (int i = 0, count = msg.count(DnsSection.ANSWER); i < count; i++) {\n+            DnsRecord record = msg.recordAt(DnsSection.ANSWER, i);\n+            if (record.type() == DnsRecordType.A) {\n+                //just print the IP after query\n+                DnsRawRecord raw = (DnsRawRecord) record;\n+                System.out.println(NetUtil.bytesToIpAddress(ByteBufUtil.getBytes(raw.content())));\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        InetSocketAddress addr = SocketUtils.socketAddress(DNS_SERVER_HOST, DNS_SERVER_PORT);", "originalCommit": "394b3e0f93d8c883e7a7698b13e81c661ea19948", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTkwMzk2Mw==", "url": "https://github.com/netty/netty/pull/10237#discussion_r419903963", "bodyText": "you could also just call ch.closeFuture().sync() and call ch.close() in your channelRead0 method", "author": "normanmaurer", "createdAt": "2020-05-05T07:07:09Z", "path": "example/src/main/java/io/netty/example/dns/udp/DnsClient.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.example.dns.udp;\n+\n+import java.net.InetSocketAddress;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.ByteBufUtil;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelPipeline;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.DatagramChannel;\n+import io.netty.channel.socket.nio.NioDatagramChannel;\n+import io.netty.handler.codec.dns.DatagramDnsQuery;\n+import io.netty.handler.codec.dns.DatagramDnsQueryEncoder;\n+import io.netty.handler.codec.dns.DatagramDnsResponse;\n+import io.netty.handler.codec.dns.DatagramDnsResponseDecoder;\n+import io.netty.handler.codec.dns.DefaultDnsQuestion;\n+import io.netty.handler.codec.dns.DnsQuery;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsRawRecord;\n+import io.netty.handler.codec.dns.DnsRecord;\n+import io.netty.handler.codec.dns.DnsRecordType;\n+import io.netty.handler.codec.dns.DnsSection;\n+import io.netty.util.NetUtil;\n+import io.netty.util.internal.SocketUtils;\n+\n+public class DnsClient {\n+\n+    private static final String QUERY_DOMAIN = \"www.example.com\";\n+    private static final int DNS_SERVER_PORT = 53;\n+    private static final String DNS_SERVER_HOST = \"8.8.8.8\";\n+\n+    private static void handleQueryResp(DatagramDnsResponse msg) {\n+        if (msg.count(DnsSection.QUESTION) > 0) {\n+            DnsQuestion question = msg.recordAt(DnsSection.QUESTION, 0);\n+            System.out.printf(\"name: %s%n\", question.name());\n+        }\n+        for (int i = 0, count = msg.count(DnsSection.ANSWER); i < count; i++) {\n+            DnsRecord record = msg.recordAt(DnsSection.ANSWER, i);\n+            if (record.type() == DnsRecordType.A) {\n+                //just print the IP after query\n+                DnsRawRecord raw = (DnsRawRecord) record;\n+                System.out.println(NetUtil.bytesToIpAddress(ByteBufUtil.getBytes(raw.content())));\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        InetSocketAddress addr = SocketUtils.socketAddress(DNS_SERVER_HOST, DNS_SERVER_PORT);\n+        final CountDownLatch latch = new CountDownLatch(1);\n+        EventLoopGroup group = new NioEventLoopGroup();\n+        try {\n+            Bootstrap b = new Bootstrap();\n+            b.group(group)\n+             .channel(NioDatagramChannel.class)\n+             .handler(new ChannelInitializer<DatagramChannel>() {\n+                 @Override\n+                 protected void initChannel(DatagramChannel ch) throws Exception {\n+                     ChannelPipeline p = ch.pipeline();\n+                     p.addLast(new DatagramDnsQueryEncoder())\n+                     .addLast(new DatagramDnsResponseDecoder())\n+                     .addLast(new SimpleChannelInboundHandler<DatagramDnsResponse>() {\n+                        @Override\n+                        protected void channelRead0(ChannelHandlerContext ctx, DatagramDnsResponse msg)\n+                                throws Exception {\n+                            try {\n+                                handleQueryResp(msg);\n+                            } finally {\n+                                latch.countDown();\n+                            }\n+                        }\n+                    });\n+                 }\n+             });\n+            Channel ch = b.bind(0).sync().channel();\n+            DnsQuery query = new DatagramDnsQuery(null, addr, 1).setRecord(\n+                    DnsSection.QUESTION,\n+                    new DefaultDnsQuestion(QUERY_DOMAIN, DnsRecordType.A));\n+            ch.writeAndFlush(query);\n+            latch.await(10L, TimeUnit.SECONDS);", "originalCommit": "394b3e0f93d8c883e7a7698b13e81c661ea19948", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4942db069c3710f7a347c3a8607b97b267d2a3aa", "url": "https://github.com/netty/netty/commit/4942db069c3710f7a347c3a8607b97b267d2a3aa", "message": "Fix some problems.", "committedDate": "2020-05-05T12:51:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA4NDUyNA==", "url": "https://github.com/netty/netty/pull/10237#discussion_r420084524", "bodyText": "nit: ctx.close();", "author": "normanmaurer", "createdAt": "2020-05-05T12:53:05Z", "path": "example/src/main/java/io/netty/example/dns/udp/DnsClient.java", "diffHunk": "@@ -81,24 +81,32 @@ protected void initChannel(DatagramChannel ch) throws Exception {\n                      .addLast(new DatagramDnsResponseDecoder())\n                      .addLast(new SimpleChannelInboundHandler<DatagramDnsResponse>() {\n                         @Override\n-                        protected void channelRead0(ChannelHandlerContext ctx, DatagramDnsResponse msg)\n-                                throws Exception {\n+                        protected void channelRead0(ChannelHandlerContext ctx, DatagramDnsResponse msg) {\n                             try {\n                                 handleQueryResp(msg);\n                             } finally {\n-                                latch.countDown();\n+                                ctx.channel().close();", "originalCommit": "4942db069c3710f7a347c3a8607b97b267d2a3aa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA4NTY4Mw==", "url": "https://github.com/netty/netty/pull/10237#discussion_r420085683", "bodyText": "just remove the schedule and call ch.closeFuture().await(....)", "author": "normanmaurer", "createdAt": "2020-05-05T12:54:54Z", "path": "example/src/main/java/io/netty/example/dns/udp/DnsClient.java", "diffHunk": "@@ -81,24 +81,32 @@ protected void initChannel(DatagramChannel ch) throws Exception {\n                      .addLast(new DatagramDnsResponseDecoder())\n                      .addLast(new SimpleChannelInboundHandler<DatagramDnsResponse>() {\n                         @Override\n-                        protected void channelRead0(ChannelHandlerContext ctx, DatagramDnsResponse msg)\n-                                throws Exception {\n+                        protected void channelRead0(ChannelHandlerContext ctx, DatagramDnsResponse msg) {\n                             try {\n                                 handleQueryResp(msg);\n                             } finally {\n-                                latch.countDown();\n+                                ctx.channel().close();\n                             }\n                         }\n                     });\n                  }\n              });\n-            Channel ch = b.bind(0).sync().channel();\n+            final Channel ch = b.bind(0).sync().channel();\n             DnsQuery query = new DatagramDnsQuery(null, addr, 1).setRecord(\n                     DnsSection.QUESTION,\n                     new DefaultDnsQuestion(QUERY_DOMAIN, DnsRecordType.A));\n-            ch.writeAndFlush(query);\n-            latch.await(10L, TimeUnit.SECONDS);\n-            ch.close().sync();\n+            ch.writeAndFlush(query).sync();\n+            ScheduledFuture<?> f = ch.eventLoop().schedule(new Runnable() {\n+                @Override\n+                public void run() {\n+                    if (ch.isActive()) {\n+                        System.err.println(\"dns query timeout.\");\n+                        ch.close();\n+                    }\n+                }\n+            }, 10L, TimeUnit.SECONDS);\n+            ch.closeFuture().sync();", "originalCommit": "4942db069c3710f7a347c3a8607b97b267d2a3aa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f611ada2626778cc375239ba2adb203034a06a66", "url": "https://github.com/netty/netty/commit/f611ada2626778cc375239ba2adb203034a06a66", "message": "Fix example problems.", "committedDate": "2020-05-05T13:10:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI0NDg3OA==", "url": "https://github.com/netty/netty/pull/10237#discussion_r420244878", "bodyText": "you can remove this if. It doesn't harm to close if it was not active", "author": "normanmaurer", "createdAt": "2020-05-05T16:32:19Z", "path": "example/src/main/java/io/netty/example/dns/udp/DnsClient.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.example.dns.udp;\n+\n+import java.net.InetSocketAddress;\n+import java.util.concurrent.TimeUnit;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.ByteBufUtil;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelPipeline;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.DatagramChannel;\n+import io.netty.channel.socket.nio.NioDatagramChannel;\n+import io.netty.handler.codec.dns.DatagramDnsQuery;\n+import io.netty.handler.codec.dns.DatagramDnsQueryEncoder;\n+import io.netty.handler.codec.dns.DatagramDnsResponse;\n+import io.netty.handler.codec.dns.DatagramDnsResponseDecoder;\n+import io.netty.handler.codec.dns.DefaultDnsQuestion;\n+import io.netty.handler.codec.dns.DnsQuery;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsRawRecord;\n+import io.netty.handler.codec.dns.DnsRecord;\n+import io.netty.handler.codec.dns.DnsRecordType;\n+import io.netty.handler.codec.dns.DnsSection;\n+import io.netty.util.NetUtil;\n+\n+public final class DnsClient {\n+\n+    private static final String QUERY_DOMAIN = \"www.example.com\";\n+    private static final int DNS_SERVER_PORT = 53;\n+    private static final String DNS_SERVER_HOST = \"8.8.8.8\";\n+\n+    private DnsClient() { }\n+\n+    private static void handleQueryResp(DatagramDnsResponse msg) {\n+        if (msg.count(DnsSection.QUESTION) > 0) {\n+            DnsQuestion question = msg.recordAt(DnsSection.QUESTION, 0);\n+            System.out.printf(\"name: %s%n\", question.name());\n+        }\n+        for (int i = 0, count = msg.count(DnsSection.ANSWER); i < count; i++) {\n+            DnsRecord record = msg.recordAt(DnsSection.ANSWER, i);\n+            if (record.type() == DnsRecordType.A) {\n+                //just print the IP after query\n+                DnsRawRecord raw = (DnsRawRecord) record;\n+                System.out.println(NetUtil.bytesToIpAddress(ByteBufUtil.getBytes(raw.content())));\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        InetSocketAddress addr = new InetSocketAddress(DNS_SERVER_HOST, DNS_SERVER_PORT);\n+        EventLoopGroup group = new NioEventLoopGroup();\n+        try {\n+            Bootstrap b = new Bootstrap();\n+            b.group(group)\n+             .channel(NioDatagramChannel.class)\n+             .handler(new ChannelInitializer<DatagramChannel>() {\n+                 @Override\n+                 protected void initChannel(DatagramChannel ch) throws Exception {\n+                     ChannelPipeline p = ch.pipeline();\n+                     p.addLast(new DatagramDnsQueryEncoder())\n+                     .addLast(new DatagramDnsResponseDecoder())\n+                     .addLast(new SimpleChannelInboundHandler<DatagramDnsResponse>() {\n+                        @Override\n+                        protected void channelRead0(ChannelHandlerContext ctx, DatagramDnsResponse msg) {\n+                            try {\n+                                handleQueryResp(msg);\n+                            } finally {\n+                                ctx.close();\n+                            }\n+                        }\n+                    });\n+                 }\n+             });\n+            final Channel ch = b.bind(0).sync().channel();\n+            DnsQuery query = new DatagramDnsQuery(null, addr, 1).setRecord(\n+                    DnsSection.QUESTION,\n+                    new DefaultDnsQuestion(QUERY_DOMAIN, DnsRecordType.A));\n+            ch.writeAndFlush(query).sync();\n+            boolean succ = ch.closeFuture().await(10, TimeUnit.SECONDS);\n+            if (!succ) {\n+                System.err.println(\"dns query timeout!\");\n+                if (ch.isActive()) {", "originalCommit": "f611ada2626778cc375239ba2adb203034a06a66", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "dd448819e8c6a8a8f9725f57f22ff925cad5e75b", "url": "https://github.com/netty/netty/commit/dd448819e8c6a8a8f9725f57f22ff925cad5e75b", "message": "Close the channel even if it's not active.", "committedDate": "2020-05-05T23:57:59Z", "type": "commit"}]}