{"pr_number": 10152, "pr_title": "Stomp over WebSocket Chat example", "pr_createdAt": "2020-03-31T12:23:57Z", "pr_url": "https://github.com/netty/netty/pull/10152", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDkzMzUwMA==", "url": "https://github.com/netty/netty/pull/10152#discussion_r400933500", "bodyText": "wouldn't it be better to make this non static and create one instance of the handler that is shared at the end ? This way we ensure at least stuff can be GC'ed.", "author": "normanmaurer", "createdAt": "2020-03-31T13:55:57Z", "path": "example/src/main/java/io/netty/example/stomp/websocket/StompChatHandler.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.example.stomp.websocket;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.handler.codec.DecoderResult;\n+import io.netty.handler.codec.stomp.DefaultStompFrame;\n+import io.netty.handler.codec.stomp.StompCommand;\n+import io.netty.handler.codec.stomp.StompFrame;\n+\n+import java.nio.CharBuffer;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import static io.netty.buffer.ByteBufUtil.*;\n+import static io.netty.handler.codec.stomp.StompHeaders.*;\n+import static io.netty.util.CharsetUtil.*;\n+\n+@Sharable\n+public class StompChatHandler extends SimpleChannelInboundHandler<StompFrame> {\n+\n+    static final StompChatHandler INSTANCE = new StompChatHandler();\n+\n+    private final ConcurrentHashMap<String, Set<StompSubscription>> CHAT_DESTINATIONS =", "originalCommit": "636aedd5eb323a3f40f4069593b56aae52886cf9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDk0NjY0NA==", "url": "https://github.com/netty/netty/pull/10152#discussion_r400946644", "bodyText": "Do you mean something like this:\n@Sharable\npublic class StompWebSocketProtocolCodec extends MessageToMessageCodec<WebSocketFrame, ByteBuf> {\n\n    private final StompChatHandler stompChatHandler = new StompChatHandler();\n\n    @Override\n    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n        if (evt instanceof WebSocketServerProtocolHandler.HandshakeComplete) {\n            StompVersion stompVersion = StompVersion.findBySubProtocol(((HandshakeComplete) evt).selectedSubprotocol());\n            ctx.channel().attr(StompVersion.CHANNEL_ATTRIBUTE_KEY).set(stompVersion);\n            String ctxName = ctx.name();\n            ctx.pipeline()\n               .addAfter(ctxName, \"stompChatHandler\", stompChatHandler)\n               .addAfter(ctxName, \"stompAggregator\", new StompSubframeAggregator(65536))\n               .addAfter(ctxName, \"stompEncoder\", new StompSubframeEncoder())\n               .addAfter(ctxName, \"stompDecoder\", new StompSubframeDecoder())\n               .remove(StompWebSocketClientPageHandler.INSTANCE);\n        } else {\n            super.userEventTriggered(ctx, evt);\n        }\n        super.userEventTriggered(ctx, evt);\n    }", "author": "amizurov", "createdAt": "2020-03-31T14:13:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDkzMzUwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQxNDA0Mg==", "url": "https://github.com/netty/netty/pull/10152#discussion_r401414042", "bodyText": "yep... that said in your example you call userEventTriggered two times ;)", "author": "normanmaurer", "createdAt": "2020-04-01T07:39:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDkzMzUwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ0NzcwMQ==", "url": "https://github.com/netty/netty/pull/10152#discussion_r401447701", "bodyText": "Good caught \ud83d\udc4d", "author": "amizurov", "createdAt": "2020-04-01T08:38:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDkzMzUwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDkzMzY0NA==", "url": "https://github.com/netty/netty/pull/10152#discussion_r400933644", "bodyText": "ConcurrentMap...", "author": "normanmaurer", "createdAt": "2020-03-31T13:56:09Z", "path": "example/src/main/java/io/netty/example/stomp/websocket/StompChatHandler.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.example.stomp.websocket;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.handler.codec.DecoderResult;\n+import io.netty.handler.codec.stomp.DefaultStompFrame;\n+import io.netty.handler.codec.stomp.StompCommand;\n+import io.netty.handler.codec.stomp.StompFrame;\n+\n+import java.nio.CharBuffer;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import static io.netty.buffer.ByteBufUtil.*;\n+import static io.netty.handler.codec.stomp.StompHeaders.*;\n+import static io.netty.util.CharsetUtil.*;\n+\n+@Sharable\n+public class StompChatHandler extends SimpleChannelInboundHandler<StompFrame> {\n+\n+    static final StompChatHandler INSTANCE = new StompChatHandler();\n+\n+    private final ConcurrentHashMap<String, Set<StompSubscription>> CHAT_DESTINATIONS =", "originalCommit": "636aedd5eb323a3f40f4069593b56aae52886cf9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDk0NzgyNw==", "url": "https://github.com/netty/netty/pull/10152#discussion_r400947827", "bodyText": "Thx again", "author": "amizurov", "createdAt": "2020-03-31T14:14:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDkzMzY0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDkzNDMzNQ==", "url": "https://github.com/netty/netty/pull/10152#discussion_r400934335", "bodyText": "List", "author": "normanmaurer", "createdAt": "2020-03-31T13:57:01Z", "path": "example/src/main/java/io/netty/example/stomp/websocket/StompVersion.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.example.stomp.websocket;\n+\n+import io.netty.util.AttributeKey;\n+import io.netty.util.internal.StringUtil;\n+\n+import java.util.ArrayList;\n+\n+public enum StompVersion {\n+\n+    STOMP_V11(\"1.1\", \"v11.stomp\"),\n+\n+    STOMP_V12(\"1.2\", \"v12.stomp\");\n+\n+    public static final AttributeKey<StompVersion> CHANNEL_ATTRIBUTE_KEY = AttributeKey.valueOf(\"stomp_version\");\n+    public static final String SUB_PROTOCOLS;\n+\n+    static {\n+        ArrayList<String> subProtocols = new ArrayList<String>(values().length);", "originalCommit": "636aedd5eb323a3f40f4069593b56aae52886cf9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDk0NzQ1Mg==", "url": "https://github.com/netty/netty/pull/10152#discussion_r400947452", "bodyText": "Ooops !!", "author": "amizurov", "createdAt": "2020-03-31T14:14:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDkzNDMzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQxNDU4Mw==", "url": "https://github.com/netty/netty/pull/10152#discussion_r401414583", "bodyText": "nit: I would make ChannelHandlerContext the first argument for all methods to be consistent with the rest of netty.", "author": "normanmaurer", "createdAt": "2020-04-01T07:40:39Z", "path": "example/src/main/java/io/netty/example/stomp/websocket/StompChatHandler.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.example.stomp.websocket;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.handler.codec.DecoderResult;\n+import io.netty.handler.codec.stomp.DefaultStompFrame;\n+import io.netty.handler.codec.stomp.StompCommand;\n+import io.netty.handler.codec.stomp.StompFrame;\n+\n+import java.nio.CharBuffer;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import static io.netty.buffer.ByteBufUtil.*;\n+import static io.netty.handler.codec.stomp.StompHeaders.*;\n+import static io.netty.util.CharsetUtil.*;\n+\n+@Sharable\n+public class StompChatHandler extends SimpleChannelInboundHandler<StompFrame> {\n+\n+    static final StompChatHandler INSTANCE = new StompChatHandler();\n+\n+    private final ConcurrentHashMap<String, Set<StompSubscription>> CHAT_DESTINATIONS =\n+            new ConcurrentHashMap<String, Set<StompSubscription>>();\n+\n+    @Override\n+    protected void channelRead0(ChannelHandlerContext ctx, StompFrame inboundFrame) throws Exception {\n+        DecoderResult decoderResult = inboundFrame.decoderResult();\n+        if (decoderResult.isFailure()) {\n+            sendErrorFrame(\"rejected frame\", decoderResult.toString(), ctx);\n+            return;\n+        }\n+\n+        switch (inboundFrame.command()) {\n+        case STOMP:\n+        case CONNECT:\n+            onConnect(inboundFrame, ctx);\n+            break;\n+        case SUBSCRIBE:\n+            onSubscribe(inboundFrame, ctx);\n+            break;\n+        case SEND:\n+            onSend(inboundFrame, ctx);\n+            break;\n+        case UNSUBSCRIBE:\n+            onUnsubscribe(inboundFrame, ctx);\n+            break;\n+        case DISCONNECT:\n+            onDisconnect(inboundFrame, ctx);\n+            break;\n+        default:\n+            sendErrorFrame(\"unsupported command\",\n+                           \"Received unsupported command \" + inboundFrame.command(), ctx);\n+        }\n+    }\n+\n+    private void onConnect(StompFrame inboundFrame, ChannelHandlerContext ctx) {", "originalCommit": "636aedd5eb323a3f40f4069593b56aae52886cf9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQzODY2OQ==", "url": "https://github.com/netty/netty/pull/10152#discussion_r401438669", "bodyText": "ok", "author": "amizurov", "createdAt": "2020-04-01T08:23:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQxNDU4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQxNTE0Mw==", "url": "https://github.com/netty/netty/pull/10152#discussion_r401415143", "bodyText": "can this ever be null ? I mean you use \u00b4.putIfAbsent\u00b4 just before.", "author": "normanmaurer", "createdAt": "2020-04-01T07:41:45Z", "path": "example/src/main/java/io/netty/example/stomp/websocket/StompChatHandler.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.example.stomp.websocket;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.handler.codec.DecoderResult;\n+import io.netty.handler.codec.stomp.DefaultStompFrame;\n+import io.netty.handler.codec.stomp.StompCommand;\n+import io.netty.handler.codec.stomp.StompFrame;\n+\n+import java.nio.CharBuffer;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import static io.netty.buffer.ByteBufUtil.*;\n+import static io.netty.handler.codec.stomp.StompHeaders.*;\n+import static io.netty.util.CharsetUtil.*;\n+\n+@Sharable\n+public class StompChatHandler extends SimpleChannelInboundHandler<StompFrame> {\n+\n+    static final StompChatHandler INSTANCE = new StompChatHandler();\n+\n+    private final ConcurrentHashMap<String, Set<StompSubscription>> CHAT_DESTINATIONS =\n+            new ConcurrentHashMap<String, Set<StompSubscription>>();\n+\n+    @Override\n+    protected void channelRead0(ChannelHandlerContext ctx, StompFrame inboundFrame) throws Exception {\n+        DecoderResult decoderResult = inboundFrame.decoderResult();\n+        if (decoderResult.isFailure()) {\n+            sendErrorFrame(\"rejected frame\", decoderResult.toString(), ctx);\n+            return;\n+        }\n+\n+        switch (inboundFrame.command()) {\n+        case STOMP:\n+        case CONNECT:\n+            onConnect(inboundFrame, ctx);\n+            break;\n+        case SUBSCRIBE:\n+            onSubscribe(inboundFrame, ctx);\n+            break;\n+        case SEND:\n+            onSend(inboundFrame, ctx);\n+            break;\n+        case UNSUBSCRIBE:\n+            onUnsubscribe(inboundFrame, ctx);\n+            break;\n+        case DISCONNECT:\n+            onDisconnect(inboundFrame, ctx);\n+            break;\n+        default:\n+            sendErrorFrame(\"unsupported command\",\n+                           \"Received unsupported command \" + inboundFrame.command(), ctx);\n+        }\n+    }\n+\n+    private void onConnect(StompFrame inboundFrame, ChannelHandlerContext ctx) {\n+        String acceptVersions = inboundFrame.headers().getAsString(ACCEPT_VERSION);\n+        StompVersion handshakeAcceptVersion = ctx.channel().attr(StompVersion.CHANNEL_ATTRIBUTE_KEY).get();\n+        if (acceptVersions == null || !acceptVersions.contains(handshakeAcceptVersion.version())) {\n+            sendErrorFrame(\"invalid version\",\n+                           \"Received invalid version, expected \" + handshakeAcceptVersion.version(), ctx);\n+            return;\n+        }\n+\n+        StompFrame connectedFrame = new DefaultStompFrame(StompCommand.CONNECTED);\n+        connectedFrame.headers()\n+                      .set(VERSION, handshakeAcceptVersion.version())\n+                      .set(SERVER, \"Netty-Server\")\n+                      .set(HEART_BEAT, \"0,0\");\n+        ctx.writeAndFlush(connectedFrame);\n+    }\n+\n+    private void onSubscribe(StompFrame inboundFrame, ChannelHandlerContext ctx) {\n+        String destination = inboundFrame.headers().getAsString(DESTINATION);\n+        String subscriptionId = inboundFrame.headers().getAsString(ID);\n+\n+        if (destination == null || subscriptionId == null) {\n+            sendErrorFrame(\"missed header\", \"Required 'destination' or 'id' header missed\", ctx);\n+            return;\n+        }\n+\n+        Set<StompSubscription> subscriptions =\n+                CHAT_DESTINATIONS.putIfAbsent(destination, new HashSet<StompSubscription>());\n+        if (subscriptions == null) {", "originalCommit": "636aedd5eb323a3f40f4069593b56aae52886cf9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ0MDI0NA==", "url": "https://github.com/netty/netty/pull/10152#discussion_r401440244", "bodyText": "If this first attempt it's return null (map.put(k,v))", "author": "amizurov", "createdAt": "2020-04-01T08:26:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQxNTE0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQxNTg2MQ==", "url": "https://github.com/netty/netty/pull/10152#discussion_r401415861", "bodyText": "imho you can just call write(...) and only flush at the end once you iterated over all of these.", "author": "normanmaurer", "createdAt": "2020-04-01T07:42:57Z", "path": "example/src/main/java/io/netty/example/stomp/websocket/StompChatHandler.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.example.stomp.websocket;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.handler.codec.DecoderResult;\n+import io.netty.handler.codec.stomp.DefaultStompFrame;\n+import io.netty.handler.codec.stomp.StompCommand;\n+import io.netty.handler.codec.stomp.StompFrame;\n+\n+import java.nio.CharBuffer;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import static io.netty.buffer.ByteBufUtil.*;\n+import static io.netty.handler.codec.stomp.StompHeaders.*;\n+import static io.netty.util.CharsetUtil.*;\n+\n+@Sharable\n+public class StompChatHandler extends SimpleChannelInboundHandler<StompFrame> {\n+\n+    static final StompChatHandler INSTANCE = new StompChatHandler();\n+\n+    private final ConcurrentHashMap<String, Set<StompSubscription>> CHAT_DESTINATIONS =\n+            new ConcurrentHashMap<String, Set<StompSubscription>>();\n+\n+    @Override\n+    protected void channelRead0(ChannelHandlerContext ctx, StompFrame inboundFrame) throws Exception {\n+        DecoderResult decoderResult = inboundFrame.decoderResult();\n+        if (decoderResult.isFailure()) {\n+            sendErrorFrame(\"rejected frame\", decoderResult.toString(), ctx);\n+            return;\n+        }\n+\n+        switch (inboundFrame.command()) {\n+        case STOMP:\n+        case CONNECT:\n+            onConnect(inboundFrame, ctx);\n+            break;\n+        case SUBSCRIBE:\n+            onSubscribe(inboundFrame, ctx);\n+            break;\n+        case SEND:\n+            onSend(inboundFrame, ctx);\n+            break;\n+        case UNSUBSCRIBE:\n+            onUnsubscribe(inboundFrame, ctx);\n+            break;\n+        case DISCONNECT:\n+            onDisconnect(inboundFrame, ctx);\n+            break;\n+        default:\n+            sendErrorFrame(\"unsupported command\",\n+                           \"Received unsupported command \" + inboundFrame.command(), ctx);\n+        }\n+    }\n+\n+    private void onConnect(StompFrame inboundFrame, ChannelHandlerContext ctx) {\n+        String acceptVersions = inboundFrame.headers().getAsString(ACCEPT_VERSION);\n+        StompVersion handshakeAcceptVersion = ctx.channel().attr(StompVersion.CHANNEL_ATTRIBUTE_KEY).get();\n+        if (acceptVersions == null || !acceptVersions.contains(handshakeAcceptVersion.version())) {\n+            sendErrorFrame(\"invalid version\",\n+                           \"Received invalid version, expected \" + handshakeAcceptVersion.version(), ctx);\n+            return;\n+        }\n+\n+        StompFrame connectedFrame = new DefaultStompFrame(StompCommand.CONNECTED);\n+        connectedFrame.headers()\n+                      .set(VERSION, handshakeAcceptVersion.version())\n+                      .set(SERVER, \"Netty-Server\")\n+                      .set(HEART_BEAT, \"0,0\");\n+        ctx.writeAndFlush(connectedFrame);\n+    }\n+\n+    private void onSubscribe(StompFrame inboundFrame, ChannelHandlerContext ctx) {\n+        String destination = inboundFrame.headers().getAsString(DESTINATION);\n+        String subscriptionId = inboundFrame.headers().getAsString(ID);\n+\n+        if (destination == null || subscriptionId == null) {\n+            sendErrorFrame(\"missed header\", \"Required 'destination' or 'id' header missed\", ctx);\n+            return;\n+        }\n+\n+        Set<StompSubscription> subscriptions =\n+                CHAT_DESTINATIONS.putIfAbsent(destination, new HashSet<StompSubscription>());\n+        if (subscriptions == null) {\n+            subscriptions = CHAT_DESTINATIONS.get(destination);\n+        }\n+\n+        final StompSubscription subscription = new StompSubscription(subscriptionId, destination, ctx.channel());\n+        if (subscriptions.contains(subscription)) {\n+            sendErrorFrame(\"duplicate subscription\",\n+                           \"Received duplicate subscription id=\" + subscriptionId, ctx);\n+            return;\n+        }\n+\n+        subscriptions.add(subscription);\n+        ctx.channel().closeFuture().addListener(new ChannelFutureListener() {\n+            @Override\n+            public void operationComplete(ChannelFuture future) {\n+                CHAT_DESTINATIONS.get(subscription.destination()).remove(subscription);\n+            }\n+        });\n+\n+        String receiptId = inboundFrame.headers().getAsString(RECEIPT);\n+        if (receiptId != null) {\n+            StompFrame receiptFrame = new DefaultStompFrame(StompCommand.RECEIPT);\n+            receiptFrame.headers().set(RECEIPT_ID, receiptId);\n+            ctx.writeAndFlush(receiptFrame);\n+        }\n+    }\n+\n+    private void onSend(StompFrame inboundFrame, ChannelHandlerContext ctx) {\n+        String destination = inboundFrame.headers().getAsString(DESTINATION);\n+        if (destination == null) {\n+            sendErrorFrame(\"missed header\", \"required 'destination' header missed\", ctx);\n+            return;\n+        }\n+\n+        Set<StompSubscription> subscriptions = CHAT_DESTINATIONS.get(destination);\n+        for (StompSubscription subscription : subscriptions) {\n+            subscription.channel().writeAndFlush(transformToMessage(inboundFrame, subscription));", "originalCommit": "636aedd5eb323a3f40f4069593b56aae52886cf9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQzNTIxMA==", "url": "https://github.com/netty/netty/pull/10152#discussion_r401435210", "bodyText": "ctx.flush(), Does it mean flush for all channels ? I need broadcast to each channel and after it do flush for each or I'm wrong ?", "author": "amizurov", "createdAt": "2020-04-01T08:17:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQxNTg2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTU4NDU3MA==", "url": "https://github.com/netty/netty/pull/10152#discussion_r401584570", "bodyText": "You are right... sorry I missed that there a different Channels.", "author": "normanmaurer", "createdAt": "2020-04-01T12:42:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQxNTg2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQxNjA4Mg==", "url": "https://github.com/netty/netty/pull/10152#discussion_r401416082", "bodyText": "static ?", "author": "normanmaurer", "createdAt": "2020-04-01T07:43:20Z", "path": "example/src/main/java/io/netty/example/stomp/websocket/StompChatHandler.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.example.stomp.websocket;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.handler.codec.DecoderResult;\n+import io.netty.handler.codec.stomp.DefaultStompFrame;\n+import io.netty.handler.codec.stomp.StompCommand;\n+import io.netty.handler.codec.stomp.StompFrame;\n+\n+import java.nio.CharBuffer;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import static io.netty.buffer.ByteBufUtil.*;\n+import static io.netty.handler.codec.stomp.StompHeaders.*;\n+import static io.netty.util.CharsetUtil.*;\n+\n+@Sharable\n+public class StompChatHandler extends SimpleChannelInboundHandler<StompFrame> {\n+\n+    static final StompChatHandler INSTANCE = new StompChatHandler();\n+\n+    private final ConcurrentHashMap<String, Set<StompSubscription>> CHAT_DESTINATIONS =\n+            new ConcurrentHashMap<String, Set<StompSubscription>>();\n+\n+    @Override\n+    protected void channelRead0(ChannelHandlerContext ctx, StompFrame inboundFrame) throws Exception {\n+        DecoderResult decoderResult = inboundFrame.decoderResult();\n+        if (decoderResult.isFailure()) {\n+            sendErrorFrame(\"rejected frame\", decoderResult.toString(), ctx);\n+            return;\n+        }\n+\n+        switch (inboundFrame.command()) {\n+        case STOMP:\n+        case CONNECT:\n+            onConnect(inboundFrame, ctx);\n+            break;\n+        case SUBSCRIBE:\n+            onSubscribe(inboundFrame, ctx);\n+            break;\n+        case SEND:\n+            onSend(inboundFrame, ctx);\n+            break;\n+        case UNSUBSCRIBE:\n+            onUnsubscribe(inboundFrame, ctx);\n+            break;\n+        case DISCONNECT:\n+            onDisconnect(inboundFrame, ctx);\n+            break;\n+        default:\n+            sendErrorFrame(\"unsupported command\",\n+                           \"Received unsupported command \" + inboundFrame.command(), ctx);\n+        }\n+    }\n+\n+    private void onConnect(StompFrame inboundFrame, ChannelHandlerContext ctx) {\n+        String acceptVersions = inboundFrame.headers().getAsString(ACCEPT_VERSION);\n+        StompVersion handshakeAcceptVersion = ctx.channel().attr(StompVersion.CHANNEL_ATTRIBUTE_KEY).get();\n+        if (acceptVersions == null || !acceptVersions.contains(handshakeAcceptVersion.version())) {\n+            sendErrorFrame(\"invalid version\",\n+                           \"Received invalid version, expected \" + handshakeAcceptVersion.version(), ctx);\n+            return;\n+        }\n+\n+        StompFrame connectedFrame = new DefaultStompFrame(StompCommand.CONNECTED);\n+        connectedFrame.headers()\n+                      .set(VERSION, handshakeAcceptVersion.version())\n+                      .set(SERVER, \"Netty-Server\")\n+                      .set(HEART_BEAT, \"0,0\");\n+        ctx.writeAndFlush(connectedFrame);\n+    }\n+\n+    private void onSubscribe(StompFrame inboundFrame, ChannelHandlerContext ctx) {\n+        String destination = inboundFrame.headers().getAsString(DESTINATION);\n+        String subscriptionId = inboundFrame.headers().getAsString(ID);\n+\n+        if (destination == null || subscriptionId == null) {\n+            sendErrorFrame(\"missed header\", \"Required 'destination' or 'id' header missed\", ctx);\n+            return;\n+        }\n+\n+        Set<StompSubscription> subscriptions =\n+                CHAT_DESTINATIONS.putIfAbsent(destination, new HashSet<StompSubscription>());\n+        if (subscriptions == null) {\n+            subscriptions = CHAT_DESTINATIONS.get(destination);\n+        }\n+\n+        final StompSubscription subscription = new StompSubscription(subscriptionId, destination, ctx.channel());\n+        if (subscriptions.contains(subscription)) {\n+            sendErrorFrame(\"duplicate subscription\",\n+                           \"Received duplicate subscription id=\" + subscriptionId, ctx);\n+            return;\n+        }\n+\n+        subscriptions.add(subscription);\n+        ctx.channel().closeFuture().addListener(new ChannelFutureListener() {\n+            @Override\n+            public void operationComplete(ChannelFuture future) {\n+                CHAT_DESTINATIONS.get(subscription.destination()).remove(subscription);\n+            }\n+        });\n+\n+        String receiptId = inboundFrame.headers().getAsString(RECEIPT);\n+        if (receiptId != null) {\n+            StompFrame receiptFrame = new DefaultStompFrame(StompCommand.RECEIPT);\n+            receiptFrame.headers().set(RECEIPT_ID, receiptId);\n+            ctx.writeAndFlush(receiptFrame);\n+        }\n+    }\n+\n+    private void onSend(StompFrame inboundFrame, ChannelHandlerContext ctx) {\n+        String destination = inboundFrame.headers().getAsString(DESTINATION);\n+        if (destination == null) {\n+            sendErrorFrame(\"missed header\", \"required 'destination' header missed\", ctx);\n+            return;\n+        }\n+\n+        Set<StompSubscription> subscriptions = CHAT_DESTINATIONS.get(destination);\n+        for (StompSubscription subscription : subscriptions) {\n+            subscription.channel().writeAndFlush(transformToMessage(inboundFrame, subscription));\n+        }\n+    }\n+\n+    private void onUnsubscribe(StompFrame inboundFrame, ChannelHandlerContext ctx) {\n+        String subscriptionId = inboundFrame.headers().getAsString(SUBSCRIPTION);\n+        for (Entry<String, Set<StompSubscription>> entry : CHAT_DESTINATIONS.entrySet()) {\n+            Iterator<StompSubscription> iterator = entry.getValue().iterator();\n+            while (iterator.hasNext()) {\n+                StompSubscription subscription = iterator.next();\n+                if (subscription.id().equals(subscriptionId) && subscription.channel().equals(ctx.channel())) {\n+                    iterator.remove();\n+                }\n+            }\n+        }\n+    }\n+\n+    private void onDisconnect(StompFrame inboundFrame, ChannelHandlerContext ctx) {\n+        String receiptId = inboundFrame.headers().getAsString(RECEIPT);\n+        if (receiptId == null) {\n+            ctx.close();\n+            return;\n+        }\n+\n+        StompFrame receiptFrame = new DefaultStompFrame(StompCommand.RECEIPT);\n+        receiptFrame.headers().set(RECEIPT_ID, receiptId);\n+        ctx.writeAndFlush(receiptFrame).addListener(ChannelFutureListener.CLOSE);\n+    }\n+\n+    private StompFrame transformToMessage(StompFrame sendFrame, StompSubscription subscription) {", "originalCommit": "636aedd5eb323a3f40f4069593b56aae52886cf9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ0ODEyMg==", "url": "https://github.com/netty/netty/pull/10152#discussion_r401448122", "bodyText": "Done", "author": "amizurov", "createdAt": "2020-04-01T08:39:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQxNjA4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQxNjE5NQ==", "url": "https://github.com/netty/netty/pull/10152#discussion_r401416195", "bodyText": "static ?", "author": "normanmaurer", "createdAt": "2020-04-01T07:43:31Z", "path": "example/src/main/java/io/netty/example/stomp/websocket/StompChatHandler.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.example.stomp.websocket;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.handler.codec.DecoderResult;\n+import io.netty.handler.codec.stomp.DefaultStompFrame;\n+import io.netty.handler.codec.stomp.StompCommand;\n+import io.netty.handler.codec.stomp.StompFrame;\n+\n+import java.nio.CharBuffer;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import static io.netty.buffer.ByteBufUtil.*;\n+import static io.netty.handler.codec.stomp.StompHeaders.*;\n+import static io.netty.util.CharsetUtil.*;\n+\n+@Sharable\n+public class StompChatHandler extends SimpleChannelInboundHandler<StompFrame> {\n+\n+    static final StompChatHandler INSTANCE = new StompChatHandler();\n+\n+    private final ConcurrentHashMap<String, Set<StompSubscription>> CHAT_DESTINATIONS =\n+            new ConcurrentHashMap<String, Set<StompSubscription>>();\n+\n+    @Override\n+    protected void channelRead0(ChannelHandlerContext ctx, StompFrame inboundFrame) throws Exception {\n+        DecoderResult decoderResult = inboundFrame.decoderResult();\n+        if (decoderResult.isFailure()) {\n+            sendErrorFrame(\"rejected frame\", decoderResult.toString(), ctx);\n+            return;\n+        }\n+\n+        switch (inboundFrame.command()) {\n+        case STOMP:\n+        case CONNECT:\n+            onConnect(inboundFrame, ctx);\n+            break;\n+        case SUBSCRIBE:\n+            onSubscribe(inboundFrame, ctx);\n+            break;\n+        case SEND:\n+            onSend(inboundFrame, ctx);\n+            break;\n+        case UNSUBSCRIBE:\n+            onUnsubscribe(inboundFrame, ctx);\n+            break;\n+        case DISCONNECT:\n+            onDisconnect(inboundFrame, ctx);\n+            break;\n+        default:\n+            sendErrorFrame(\"unsupported command\",\n+                           \"Received unsupported command \" + inboundFrame.command(), ctx);\n+        }\n+    }\n+\n+    private void onConnect(StompFrame inboundFrame, ChannelHandlerContext ctx) {\n+        String acceptVersions = inboundFrame.headers().getAsString(ACCEPT_VERSION);\n+        StompVersion handshakeAcceptVersion = ctx.channel().attr(StompVersion.CHANNEL_ATTRIBUTE_KEY).get();\n+        if (acceptVersions == null || !acceptVersions.contains(handshakeAcceptVersion.version())) {\n+            sendErrorFrame(\"invalid version\",\n+                           \"Received invalid version, expected \" + handshakeAcceptVersion.version(), ctx);\n+            return;\n+        }\n+\n+        StompFrame connectedFrame = new DefaultStompFrame(StompCommand.CONNECTED);\n+        connectedFrame.headers()\n+                      .set(VERSION, handshakeAcceptVersion.version())\n+                      .set(SERVER, \"Netty-Server\")\n+                      .set(HEART_BEAT, \"0,0\");\n+        ctx.writeAndFlush(connectedFrame);\n+    }\n+\n+    private void onSubscribe(StompFrame inboundFrame, ChannelHandlerContext ctx) {\n+        String destination = inboundFrame.headers().getAsString(DESTINATION);\n+        String subscriptionId = inboundFrame.headers().getAsString(ID);\n+\n+        if (destination == null || subscriptionId == null) {\n+            sendErrorFrame(\"missed header\", \"Required 'destination' or 'id' header missed\", ctx);\n+            return;\n+        }\n+\n+        Set<StompSubscription> subscriptions =\n+                CHAT_DESTINATIONS.putIfAbsent(destination, new HashSet<StompSubscription>());\n+        if (subscriptions == null) {\n+            subscriptions = CHAT_DESTINATIONS.get(destination);\n+        }\n+\n+        final StompSubscription subscription = new StompSubscription(subscriptionId, destination, ctx.channel());\n+        if (subscriptions.contains(subscription)) {\n+            sendErrorFrame(\"duplicate subscription\",\n+                           \"Received duplicate subscription id=\" + subscriptionId, ctx);\n+            return;\n+        }\n+\n+        subscriptions.add(subscription);\n+        ctx.channel().closeFuture().addListener(new ChannelFutureListener() {\n+            @Override\n+            public void operationComplete(ChannelFuture future) {\n+                CHAT_DESTINATIONS.get(subscription.destination()).remove(subscription);\n+            }\n+        });\n+\n+        String receiptId = inboundFrame.headers().getAsString(RECEIPT);\n+        if (receiptId != null) {\n+            StompFrame receiptFrame = new DefaultStompFrame(StompCommand.RECEIPT);\n+            receiptFrame.headers().set(RECEIPT_ID, receiptId);\n+            ctx.writeAndFlush(receiptFrame);\n+        }\n+    }\n+\n+    private void onSend(StompFrame inboundFrame, ChannelHandlerContext ctx) {\n+        String destination = inboundFrame.headers().getAsString(DESTINATION);\n+        if (destination == null) {\n+            sendErrorFrame(\"missed header\", \"required 'destination' header missed\", ctx);\n+            return;\n+        }\n+\n+        Set<StompSubscription> subscriptions = CHAT_DESTINATIONS.get(destination);\n+        for (StompSubscription subscription : subscriptions) {\n+            subscription.channel().writeAndFlush(transformToMessage(inboundFrame, subscription));\n+        }\n+    }\n+\n+    private void onUnsubscribe(StompFrame inboundFrame, ChannelHandlerContext ctx) {\n+        String subscriptionId = inboundFrame.headers().getAsString(SUBSCRIPTION);\n+        for (Entry<String, Set<StompSubscription>> entry : CHAT_DESTINATIONS.entrySet()) {\n+            Iterator<StompSubscription> iterator = entry.getValue().iterator();\n+            while (iterator.hasNext()) {\n+                StompSubscription subscription = iterator.next();\n+                if (subscription.id().equals(subscriptionId) && subscription.channel().equals(ctx.channel())) {\n+                    iterator.remove();\n+                }\n+            }\n+        }\n+    }\n+\n+    private void onDisconnect(StompFrame inboundFrame, ChannelHandlerContext ctx) {\n+        String receiptId = inboundFrame.headers().getAsString(RECEIPT);\n+        if (receiptId == null) {\n+            ctx.close();\n+            return;\n+        }\n+\n+        StompFrame receiptFrame = new DefaultStompFrame(StompCommand.RECEIPT);\n+        receiptFrame.headers().set(RECEIPT_ID, receiptId);\n+        ctx.writeAndFlush(receiptFrame).addListener(ChannelFutureListener.CLOSE);\n+    }\n+\n+    private StompFrame transformToMessage(StompFrame sendFrame, StompSubscription subscription) {\n+        StompFrame messageFrame = new DefaultStompFrame(StompCommand.MESSAGE, sendFrame.content().retainedDuplicate());\n+        String id = UUID.randomUUID().toString();\n+        messageFrame.headers()\n+                    .set(MESSAGE_ID, id)\n+                    .set(SUBSCRIPTION, subscription.id());\n+        return messageFrame;\n+    }\n+\n+    private void sendErrorFrame(String message, String description, ChannelHandlerContext ctx) {", "originalCommit": "636aedd5eb323a3f40f4069593b56aae52886cf9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQxNjMzNw==", "url": "https://github.com/netty/netty/pull/10152#discussion_r401416337", "bodyText": "you need to release the content.", "author": "normanmaurer", "createdAt": "2020-04-01T07:43:48Z", "path": "example/src/main/java/io/netty/example/stomp/websocket/StompChatHandler.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.example.stomp.websocket;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.handler.codec.DecoderResult;\n+import io.netty.handler.codec.stomp.DefaultStompFrame;\n+import io.netty.handler.codec.stomp.StompCommand;\n+import io.netty.handler.codec.stomp.StompFrame;\n+\n+import java.nio.CharBuffer;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import static io.netty.buffer.ByteBufUtil.*;\n+import static io.netty.handler.codec.stomp.StompHeaders.*;\n+import static io.netty.util.CharsetUtil.*;\n+\n+@Sharable\n+public class StompChatHandler extends SimpleChannelInboundHandler<StompFrame> {\n+\n+    static final StompChatHandler INSTANCE = new StompChatHandler();\n+\n+    private final ConcurrentHashMap<String, Set<StompSubscription>> CHAT_DESTINATIONS =\n+            new ConcurrentHashMap<String, Set<StompSubscription>>();\n+\n+    @Override\n+    protected void channelRead0(ChannelHandlerContext ctx, StompFrame inboundFrame) throws Exception {\n+        DecoderResult decoderResult = inboundFrame.decoderResult();\n+        if (decoderResult.isFailure()) {\n+            sendErrorFrame(\"rejected frame\", decoderResult.toString(), ctx);\n+            return;\n+        }\n+\n+        switch (inboundFrame.command()) {\n+        case STOMP:\n+        case CONNECT:\n+            onConnect(inboundFrame, ctx);\n+            break;\n+        case SUBSCRIBE:\n+            onSubscribe(inboundFrame, ctx);\n+            break;\n+        case SEND:\n+            onSend(inboundFrame, ctx);\n+            break;\n+        case UNSUBSCRIBE:\n+            onUnsubscribe(inboundFrame, ctx);\n+            break;\n+        case DISCONNECT:\n+            onDisconnect(inboundFrame, ctx);\n+            break;\n+        default:\n+            sendErrorFrame(\"unsupported command\",\n+                           \"Received unsupported command \" + inboundFrame.command(), ctx);\n+        }\n+    }\n+\n+    private void onConnect(StompFrame inboundFrame, ChannelHandlerContext ctx) {\n+        String acceptVersions = inboundFrame.headers().getAsString(ACCEPT_VERSION);\n+        StompVersion handshakeAcceptVersion = ctx.channel().attr(StompVersion.CHANNEL_ATTRIBUTE_KEY).get();\n+        if (acceptVersions == null || !acceptVersions.contains(handshakeAcceptVersion.version())) {\n+            sendErrorFrame(\"invalid version\",\n+                           \"Received invalid version, expected \" + handshakeAcceptVersion.version(), ctx);\n+            return;\n+        }\n+\n+        StompFrame connectedFrame = new DefaultStompFrame(StompCommand.CONNECTED);\n+        connectedFrame.headers()\n+                      .set(VERSION, handshakeAcceptVersion.version())\n+                      .set(SERVER, \"Netty-Server\")\n+                      .set(HEART_BEAT, \"0,0\");\n+        ctx.writeAndFlush(connectedFrame);\n+    }\n+\n+    private void onSubscribe(StompFrame inboundFrame, ChannelHandlerContext ctx) {\n+        String destination = inboundFrame.headers().getAsString(DESTINATION);\n+        String subscriptionId = inboundFrame.headers().getAsString(ID);\n+\n+        if (destination == null || subscriptionId == null) {\n+            sendErrorFrame(\"missed header\", \"Required 'destination' or 'id' header missed\", ctx);\n+            return;\n+        }\n+\n+        Set<StompSubscription> subscriptions =\n+                CHAT_DESTINATIONS.putIfAbsent(destination, new HashSet<StompSubscription>());\n+        if (subscriptions == null) {\n+            subscriptions = CHAT_DESTINATIONS.get(destination);\n+        }\n+\n+        final StompSubscription subscription = new StompSubscription(subscriptionId, destination, ctx.channel());\n+        if (subscriptions.contains(subscription)) {\n+            sendErrorFrame(\"duplicate subscription\",\n+                           \"Received duplicate subscription id=\" + subscriptionId, ctx);\n+            return;\n+        }\n+\n+        subscriptions.add(subscription);\n+        ctx.channel().closeFuture().addListener(new ChannelFutureListener() {\n+            @Override\n+            public void operationComplete(ChannelFuture future) {\n+                CHAT_DESTINATIONS.get(subscription.destination()).remove(subscription);\n+            }\n+        });\n+\n+        String receiptId = inboundFrame.headers().getAsString(RECEIPT);\n+        if (receiptId != null) {\n+            StompFrame receiptFrame = new DefaultStompFrame(StompCommand.RECEIPT);\n+            receiptFrame.headers().set(RECEIPT_ID, receiptId);\n+            ctx.writeAndFlush(receiptFrame);\n+        }\n+    }\n+\n+    private void onSend(StompFrame inboundFrame, ChannelHandlerContext ctx) {\n+        String destination = inboundFrame.headers().getAsString(DESTINATION);\n+        if (destination == null) {\n+            sendErrorFrame(\"missed header\", \"required 'destination' header missed\", ctx);\n+            return;\n+        }\n+\n+        Set<StompSubscription> subscriptions = CHAT_DESTINATIONS.get(destination);\n+        for (StompSubscription subscription : subscriptions) {\n+            subscription.channel().writeAndFlush(transformToMessage(inboundFrame, subscription));\n+        }\n+    }\n+\n+    private void onUnsubscribe(StompFrame inboundFrame, ChannelHandlerContext ctx) {\n+        String subscriptionId = inboundFrame.headers().getAsString(SUBSCRIPTION);\n+        for (Entry<String, Set<StompSubscription>> entry : CHAT_DESTINATIONS.entrySet()) {\n+            Iterator<StompSubscription> iterator = entry.getValue().iterator();\n+            while (iterator.hasNext()) {\n+                StompSubscription subscription = iterator.next();\n+                if (subscription.id().equals(subscriptionId) && subscription.channel().equals(ctx.channel())) {\n+                    iterator.remove();\n+                }\n+            }\n+        }\n+    }\n+\n+    private void onDisconnect(StompFrame inboundFrame, ChannelHandlerContext ctx) {\n+        String receiptId = inboundFrame.headers().getAsString(RECEIPT);\n+        if (receiptId == null) {\n+            ctx.close();\n+            return;\n+        }\n+\n+        StompFrame receiptFrame = new DefaultStompFrame(StompCommand.RECEIPT);\n+        receiptFrame.headers().set(RECEIPT_ID, receiptId);\n+        ctx.writeAndFlush(receiptFrame).addListener(ChannelFutureListener.CLOSE);\n+    }\n+\n+    private StompFrame transformToMessage(StompFrame sendFrame, StompSubscription subscription) {\n+        StompFrame messageFrame = new DefaultStompFrame(StompCommand.MESSAGE, sendFrame.content().retainedDuplicate());\n+        String id = UUID.randomUUID().toString();\n+        messageFrame.headers()\n+                    .set(MESSAGE_ID, id)\n+                    .set(SUBSCRIPTION, subscription.id());\n+        return messageFrame;\n+    }\n+\n+    private void sendErrorFrame(String message, String description, ChannelHandlerContext ctx) {\n+        StompFrame errorFrame = new DefaultStompFrame(StompCommand.ERROR);\n+        errorFrame.headers().set(MESSAGE, message);\n+\n+        if (description != null) {\n+            ByteBuf content = encodeString(ctx.alloc(), CharBuffer.wrap(description), UTF_8);\n+            errorFrame.content().writeBytes(content);", "originalCommit": "636aedd5eb323a3f40f4069593b56aae52886cf9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQxNjQ0MA==", "url": "https://github.com/netty/netty/pull/10152#discussion_r401416440", "bodyText": "static", "author": "normanmaurer", "createdAt": "2020-04-01T07:43:59Z", "path": "example/src/main/java/io/netty/example/stomp/websocket/StompChatHandler.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.example.stomp.websocket;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.handler.codec.DecoderResult;\n+import io.netty.handler.codec.stomp.DefaultStompFrame;\n+import io.netty.handler.codec.stomp.StompCommand;\n+import io.netty.handler.codec.stomp.StompFrame;\n+\n+import java.nio.CharBuffer;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import static io.netty.buffer.ByteBufUtil.*;\n+import static io.netty.handler.codec.stomp.StompHeaders.*;\n+import static io.netty.util.CharsetUtil.*;\n+\n+@Sharable\n+public class StompChatHandler extends SimpleChannelInboundHandler<StompFrame> {\n+\n+    static final StompChatHandler INSTANCE = new StompChatHandler();\n+\n+    private final ConcurrentHashMap<String, Set<StompSubscription>> CHAT_DESTINATIONS =\n+            new ConcurrentHashMap<String, Set<StompSubscription>>();\n+\n+    @Override\n+    protected void channelRead0(ChannelHandlerContext ctx, StompFrame inboundFrame) throws Exception {\n+        DecoderResult decoderResult = inboundFrame.decoderResult();\n+        if (decoderResult.isFailure()) {\n+            sendErrorFrame(\"rejected frame\", decoderResult.toString(), ctx);\n+            return;\n+        }\n+\n+        switch (inboundFrame.command()) {\n+        case STOMP:\n+        case CONNECT:\n+            onConnect(inboundFrame, ctx);\n+            break;\n+        case SUBSCRIBE:\n+            onSubscribe(inboundFrame, ctx);\n+            break;\n+        case SEND:\n+            onSend(inboundFrame, ctx);\n+            break;\n+        case UNSUBSCRIBE:\n+            onUnsubscribe(inboundFrame, ctx);\n+            break;\n+        case DISCONNECT:\n+            onDisconnect(inboundFrame, ctx);\n+            break;\n+        default:\n+            sendErrorFrame(\"unsupported command\",\n+                           \"Received unsupported command \" + inboundFrame.command(), ctx);\n+        }\n+    }\n+\n+    private void onConnect(StompFrame inboundFrame, ChannelHandlerContext ctx) {\n+        String acceptVersions = inboundFrame.headers().getAsString(ACCEPT_VERSION);\n+        StompVersion handshakeAcceptVersion = ctx.channel().attr(StompVersion.CHANNEL_ATTRIBUTE_KEY).get();\n+        if (acceptVersions == null || !acceptVersions.contains(handshakeAcceptVersion.version())) {\n+            sendErrorFrame(\"invalid version\",\n+                           \"Received invalid version, expected \" + handshakeAcceptVersion.version(), ctx);\n+            return;\n+        }\n+\n+        StompFrame connectedFrame = new DefaultStompFrame(StompCommand.CONNECTED);\n+        connectedFrame.headers()\n+                      .set(VERSION, handshakeAcceptVersion.version())\n+                      .set(SERVER, \"Netty-Server\")\n+                      .set(HEART_BEAT, \"0,0\");\n+        ctx.writeAndFlush(connectedFrame);\n+    }\n+\n+    private void onSubscribe(StompFrame inboundFrame, ChannelHandlerContext ctx) {\n+        String destination = inboundFrame.headers().getAsString(DESTINATION);\n+        String subscriptionId = inboundFrame.headers().getAsString(ID);\n+\n+        if (destination == null || subscriptionId == null) {\n+            sendErrorFrame(\"missed header\", \"Required 'destination' or 'id' header missed\", ctx);\n+            return;\n+        }\n+\n+        Set<StompSubscription> subscriptions =\n+                CHAT_DESTINATIONS.putIfAbsent(destination, new HashSet<StompSubscription>());\n+        if (subscriptions == null) {\n+            subscriptions = CHAT_DESTINATIONS.get(destination);\n+        }\n+\n+        final StompSubscription subscription = new StompSubscription(subscriptionId, destination, ctx.channel());\n+        if (subscriptions.contains(subscription)) {\n+            sendErrorFrame(\"duplicate subscription\",\n+                           \"Received duplicate subscription id=\" + subscriptionId, ctx);\n+            return;\n+        }\n+\n+        subscriptions.add(subscription);\n+        ctx.channel().closeFuture().addListener(new ChannelFutureListener() {\n+            @Override\n+            public void operationComplete(ChannelFuture future) {\n+                CHAT_DESTINATIONS.get(subscription.destination()).remove(subscription);\n+            }\n+        });\n+\n+        String receiptId = inboundFrame.headers().getAsString(RECEIPT);\n+        if (receiptId != null) {\n+            StompFrame receiptFrame = new DefaultStompFrame(StompCommand.RECEIPT);\n+            receiptFrame.headers().set(RECEIPT_ID, receiptId);\n+            ctx.writeAndFlush(receiptFrame);\n+        }\n+    }\n+\n+    private void onSend(StompFrame inboundFrame, ChannelHandlerContext ctx) {\n+        String destination = inboundFrame.headers().getAsString(DESTINATION);\n+        if (destination == null) {\n+            sendErrorFrame(\"missed header\", \"required 'destination' header missed\", ctx);\n+            return;\n+        }\n+\n+        Set<StompSubscription> subscriptions = CHAT_DESTINATIONS.get(destination);\n+        for (StompSubscription subscription : subscriptions) {\n+            subscription.channel().writeAndFlush(transformToMessage(inboundFrame, subscription));\n+        }\n+    }\n+\n+    private void onUnsubscribe(StompFrame inboundFrame, ChannelHandlerContext ctx) {\n+        String subscriptionId = inboundFrame.headers().getAsString(SUBSCRIPTION);\n+        for (Entry<String, Set<StompSubscription>> entry : CHAT_DESTINATIONS.entrySet()) {\n+            Iterator<StompSubscription> iterator = entry.getValue().iterator();\n+            while (iterator.hasNext()) {\n+                StompSubscription subscription = iterator.next();\n+                if (subscription.id().equals(subscriptionId) && subscription.channel().equals(ctx.channel())) {\n+                    iterator.remove();\n+                }\n+            }\n+        }\n+    }\n+\n+    private void onDisconnect(StompFrame inboundFrame, ChannelHandlerContext ctx) {", "originalCommit": "636aedd5eb323a3f40f4069593b56aae52886cf9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQxNjQ3MQ==", "url": "https://github.com/netty/netty/pull/10152#discussion_r401416471", "bodyText": "static", "author": "normanmaurer", "createdAt": "2020-04-01T07:44:02Z", "path": "example/src/main/java/io/netty/example/stomp/websocket/StompChatHandler.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.example.stomp.websocket;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.handler.codec.DecoderResult;\n+import io.netty.handler.codec.stomp.DefaultStompFrame;\n+import io.netty.handler.codec.stomp.StompCommand;\n+import io.netty.handler.codec.stomp.StompFrame;\n+\n+import java.nio.CharBuffer;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import static io.netty.buffer.ByteBufUtil.*;\n+import static io.netty.handler.codec.stomp.StompHeaders.*;\n+import static io.netty.util.CharsetUtil.*;\n+\n+@Sharable\n+public class StompChatHandler extends SimpleChannelInboundHandler<StompFrame> {\n+\n+    static final StompChatHandler INSTANCE = new StompChatHandler();\n+\n+    private final ConcurrentHashMap<String, Set<StompSubscription>> CHAT_DESTINATIONS =\n+            new ConcurrentHashMap<String, Set<StompSubscription>>();\n+\n+    @Override\n+    protected void channelRead0(ChannelHandlerContext ctx, StompFrame inboundFrame) throws Exception {\n+        DecoderResult decoderResult = inboundFrame.decoderResult();\n+        if (decoderResult.isFailure()) {\n+            sendErrorFrame(\"rejected frame\", decoderResult.toString(), ctx);\n+            return;\n+        }\n+\n+        switch (inboundFrame.command()) {\n+        case STOMP:\n+        case CONNECT:\n+            onConnect(inboundFrame, ctx);\n+            break;\n+        case SUBSCRIBE:\n+            onSubscribe(inboundFrame, ctx);\n+            break;\n+        case SEND:\n+            onSend(inboundFrame, ctx);\n+            break;\n+        case UNSUBSCRIBE:\n+            onUnsubscribe(inboundFrame, ctx);\n+            break;\n+        case DISCONNECT:\n+            onDisconnect(inboundFrame, ctx);\n+            break;\n+        default:\n+            sendErrorFrame(\"unsupported command\",\n+                           \"Received unsupported command \" + inboundFrame.command(), ctx);\n+        }\n+    }\n+\n+    private void onConnect(StompFrame inboundFrame, ChannelHandlerContext ctx) {\n+        String acceptVersions = inboundFrame.headers().getAsString(ACCEPT_VERSION);\n+        StompVersion handshakeAcceptVersion = ctx.channel().attr(StompVersion.CHANNEL_ATTRIBUTE_KEY).get();\n+        if (acceptVersions == null || !acceptVersions.contains(handshakeAcceptVersion.version())) {\n+            sendErrorFrame(\"invalid version\",\n+                           \"Received invalid version, expected \" + handshakeAcceptVersion.version(), ctx);\n+            return;\n+        }\n+\n+        StompFrame connectedFrame = new DefaultStompFrame(StompCommand.CONNECTED);\n+        connectedFrame.headers()\n+                      .set(VERSION, handshakeAcceptVersion.version())\n+                      .set(SERVER, \"Netty-Server\")\n+                      .set(HEART_BEAT, \"0,0\");\n+        ctx.writeAndFlush(connectedFrame);\n+    }\n+\n+    private void onSubscribe(StompFrame inboundFrame, ChannelHandlerContext ctx) {\n+        String destination = inboundFrame.headers().getAsString(DESTINATION);\n+        String subscriptionId = inboundFrame.headers().getAsString(ID);\n+\n+        if (destination == null || subscriptionId == null) {\n+            sendErrorFrame(\"missed header\", \"Required 'destination' or 'id' header missed\", ctx);\n+            return;\n+        }\n+\n+        Set<StompSubscription> subscriptions =\n+                CHAT_DESTINATIONS.putIfAbsent(destination, new HashSet<StompSubscription>());\n+        if (subscriptions == null) {\n+            subscriptions = CHAT_DESTINATIONS.get(destination);\n+        }\n+\n+        final StompSubscription subscription = new StompSubscription(subscriptionId, destination, ctx.channel());\n+        if (subscriptions.contains(subscription)) {\n+            sendErrorFrame(\"duplicate subscription\",\n+                           \"Received duplicate subscription id=\" + subscriptionId, ctx);\n+            return;\n+        }\n+\n+        subscriptions.add(subscription);\n+        ctx.channel().closeFuture().addListener(new ChannelFutureListener() {\n+            @Override\n+            public void operationComplete(ChannelFuture future) {\n+                CHAT_DESTINATIONS.get(subscription.destination()).remove(subscription);\n+            }\n+        });\n+\n+        String receiptId = inboundFrame.headers().getAsString(RECEIPT);\n+        if (receiptId != null) {\n+            StompFrame receiptFrame = new DefaultStompFrame(StompCommand.RECEIPT);\n+            receiptFrame.headers().set(RECEIPT_ID, receiptId);\n+            ctx.writeAndFlush(receiptFrame);\n+        }\n+    }\n+\n+    private void onSend(StompFrame inboundFrame, ChannelHandlerContext ctx) {\n+        String destination = inboundFrame.headers().getAsString(DESTINATION);\n+        if (destination == null) {\n+            sendErrorFrame(\"missed header\", \"required 'destination' header missed\", ctx);\n+            return;\n+        }\n+\n+        Set<StompSubscription> subscriptions = CHAT_DESTINATIONS.get(destination);\n+        for (StompSubscription subscription : subscriptions) {\n+            subscription.channel().writeAndFlush(transformToMessage(inboundFrame, subscription));\n+        }\n+    }\n+\n+    private void onUnsubscribe(StompFrame inboundFrame, ChannelHandlerContext ctx) {", "originalCommit": "636aedd5eb323a3f40f4069593b56aae52886cf9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQxNjUzNQ==", "url": "https://github.com/netty/netty/pull/10152#discussion_r401416535", "bodyText": "static", "author": "normanmaurer", "createdAt": "2020-04-01T07:44:07Z", "path": "example/src/main/java/io/netty/example/stomp/websocket/StompChatHandler.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.example.stomp.websocket;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.handler.codec.DecoderResult;\n+import io.netty.handler.codec.stomp.DefaultStompFrame;\n+import io.netty.handler.codec.stomp.StompCommand;\n+import io.netty.handler.codec.stomp.StompFrame;\n+\n+import java.nio.CharBuffer;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import static io.netty.buffer.ByteBufUtil.*;\n+import static io.netty.handler.codec.stomp.StompHeaders.*;\n+import static io.netty.util.CharsetUtil.*;\n+\n+@Sharable\n+public class StompChatHandler extends SimpleChannelInboundHandler<StompFrame> {\n+\n+    static final StompChatHandler INSTANCE = new StompChatHandler();\n+\n+    private final ConcurrentHashMap<String, Set<StompSubscription>> CHAT_DESTINATIONS =\n+            new ConcurrentHashMap<String, Set<StompSubscription>>();\n+\n+    @Override\n+    protected void channelRead0(ChannelHandlerContext ctx, StompFrame inboundFrame) throws Exception {\n+        DecoderResult decoderResult = inboundFrame.decoderResult();\n+        if (decoderResult.isFailure()) {\n+            sendErrorFrame(\"rejected frame\", decoderResult.toString(), ctx);\n+            return;\n+        }\n+\n+        switch (inboundFrame.command()) {\n+        case STOMP:\n+        case CONNECT:\n+            onConnect(inboundFrame, ctx);\n+            break;\n+        case SUBSCRIBE:\n+            onSubscribe(inboundFrame, ctx);\n+            break;\n+        case SEND:\n+            onSend(inboundFrame, ctx);\n+            break;\n+        case UNSUBSCRIBE:\n+            onUnsubscribe(inboundFrame, ctx);\n+            break;\n+        case DISCONNECT:\n+            onDisconnect(inboundFrame, ctx);\n+            break;\n+        default:\n+            sendErrorFrame(\"unsupported command\",\n+                           \"Received unsupported command \" + inboundFrame.command(), ctx);\n+        }\n+    }\n+\n+    private void onConnect(StompFrame inboundFrame, ChannelHandlerContext ctx) {\n+        String acceptVersions = inboundFrame.headers().getAsString(ACCEPT_VERSION);\n+        StompVersion handshakeAcceptVersion = ctx.channel().attr(StompVersion.CHANNEL_ATTRIBUTE_KEY).get();\n+        if (acceptVersions == null || !acceptVersions.contains(handshakeAcceptVersion.version())) {\n+            sendErrorFrame(\"invalid version\",\n+                           \"Received invalid version, expected \" + handshakeAcceptVersion.version(), ctx);\n+            return;\n+        }\n+\n+        StompFrame connectedFrame = new DefaultStompFrame(StompCommand.CONNECTED);\n+        connectedFrame.headers()\n+                      .set(VERSION, handshakeAcceptVersion.version())\n+                      .set(SERVER, \"Netty-Server\")\n+                      .set(HEART_BEAT, \"0,0\");\n+        ctx.writeAndFlush(connectedFrame);\n+    }\n+\n+    private void onSubscribe(StompFrame inboundFrame, ChannelHandlerContext ctx) {\n+        String destination = inboundFrame.headers().getAsString(DESTINATION);\n+        String subscriptionId = inboundFrame.headers().getAsString(ID);\n+\n+        if (destination == null || subscriptionId == null) {\n+            sendErrorFrame(\"missed header\", \"Required 'destination' or 'id' header missed\", ctx);\n+            return;\n+        }\n+\n+        Set<StompSubscription> subscriptions =\n+                CHAT_DESTINATIONS.putIfAbsent(destination, new HashSet<StompSubscription>());\n+        if (subscriptions == null) {\n+            subscriptions = CHAT_DESTINATIONS.get(destination);\n+        }\n+\n+        final StompSubscription subscription = new StompSubscription(subscriptionId, destination, ctx.channel());\n+        if (subscriptions.contains(subscription)) {\n+            sendErrorFrame(\"duplicate subscription\",\n+                           \"Received duplicate subscription id=\" + subscriptionId, ctx);\n+            return;\n+        }\n+\n+        subscriptions.add(subscription);\n+        ctx.channel().closeFuture().addListener(new ChannelFutureListener() {\n+            @Override\n+            public void operationComplete(ChannelFuture future) {\n+                CHAT_DESTINATIONS.get(subscription.destination()).remove(subscription);\n+            }\n+        });\n+\n+        String receiptId = inboundFrame.headers().getAsString(RECEIPT);\n+        if (receiptId != null) {\n+            StompFrame receiptFrame = new DefaultStompFrame(StompCommand.RECEIPT);\n+            receiptFrame.headers().set(RECEIPT_ID, receiptId);\n+            ctx.writeAndFlush(receiptFrame);\n+        }\n+    }\n+\n+    private void onSend(StompFrame inboundFrame, ChannelHandlerContext ctx) {", "originalCommit": "636aedd5eb323a3f40f4069593b56aae52886cf9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQxNjU5Mg==", "url": "https://github.com/netty/netty/pull/10152#discussion_r401416592", "bodyText": "static", "author": "normanmaurer", "createdAt": "2020-04-01T07:44:14Z", "path": "example/src/main/java/io/netty/example/stomp/websocket/StompChatHandler.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.example.stomp.websocket;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.handler.codec.DecoderResult;\n+import io.netty.handler.codec.stomp.DefaultStompFrame;\n+import io.netty.handler.codec.stomp.StompCommand;\n+import io.netty.handler.codec.stomp.StompFrame;\n+\n+import java.nio.CharBuffer;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import static io.netty.buffer.ByteBufUtil.*;\n+import static io.netty.handler.codec.stomp.StompHeaders.*;\n+import static io.netty.util.CharsetUtil.*;\n+\n+@Sharable\n+public class StompChatHandler extends SimpleChannelInboundHandler<StompFrame> {\n+\n+    static final StompChatHandler INSTANCE = new StompChatHandler();\n+\n+    private final ConcurrentHashMap<String, Set<StompSubscription>> CHAT_DESTINATIONS =\n+            new ConcurrentHashMap<String, Set<StompSubscription>>();\n+\n+    @Override\n+    protected void channelRead0(ChannelHandlerContext ctx, StompFrame inboundFrame) throws Exception {\n+        DecoderResult decoderResult = inboundFrame.decoderResult();\n+        if (decoderResult.isFailure()) {\n+            sendErrorFrame(\"rejected frame\", decoderResult.toString(), ctx);\n+            return;\n+        }\n+\n+        switch (inboundFrame.command()) {\n+        case STOMP:\n+        case CONNECT:\n+            onConnect(inboundFrame, ctx);\n+            break;\n+        case SUBSCRIBE:\n+            onSubscribe(inboundFrame, ctx);\n+            break;\n+        case SEND:\n+            onSend(inboundFrame, ctx);\n+            break;\n+        case UNSUBSCRIBE:\n+            onUnsubscribe(inboundFrame, ctx);\n+            break;\n+        case DISCONNECT:\n+            onDisconnect(inboundFrame, ctx);\n+            break;\n+        default:\n+            sendErrorFrame(\"unsupported command\",\n+                           \"Received unsupported command \" + inboundFrame.command(), ctx);\n+        }\n+    }\n+\n+    private void onConnect(StompFrame inboundFrame, ChannelHandlerContext ctx) {\n+        String acceptVersions = inboundFrame.headers().getAsString(ACCEPT_VERSION);\n+        StompVersion handshakeAcceptVersion = ctx.channel().attr(StompVersion.CHANNEL_ATTRIBUTE_KEY).get();\n+        if (acceptVersions == null || !acceptVersions.contains(handshakeAcceptVersion.version())) {\n+            sendErrorFrame(\"invalid version\",\n+                           \"Received invalid version, expected \" + handshakeAcceptVersion.version(), ctx);\n+            return;\n+        }\n+\n+        StompFrame connectedFrame = new DefaultStompFrame(StompCommand.CONNECTED);\n+        connectedFrame.headers()\n+                      .set(VERSION, handshakeAcceptVersion.version())\n+                      .set(SERVER, \"Netty-Server\")\n+                      .set(HEART_BEAT, \"0,0\");\n+        ctx.writeAndFlush(connectedFrame);\n+    }\n+\n+    private void onSubscribe(StompFrame inboundFrame, ChannelHandlerContext ctx) {", "originalCommit": "636aedd5eb323a3f40f4069593b56aae52886cf9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQxNjYyOA==", "url": "https://github.com/netty/netty/pull/10152#discussion_r401416628", "bodyText": "static", "author": "normanmaurer", "createdAt": "2020-04-01T07:44:19Z", "path": "example/src/main/java/io/netty/example/stomp/websocket/StompChatHandler.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.example.stomp.websocket;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.handler.codec.DecoderResult;\n+import io.netty.handler.codec.stomp.DefaultStompFrame;\n+import io.netty.handler.codec.stomp.StompCommand;\n+import io.netty.handler.codec.stomp.StompFrame;\n+\n+import java.nio.CharBuffer;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import static io.netty.buffer.ByteBufUtil.*;\n+import static io.netty.handler.codec.stomp.StompHeaders.*;\n+import static io.netty.util.CharsetUtil.*;\n+\n+@Sharable\n+public class StompChatHandler extends SimpleChannelInboundHandler<StompFrame> {\n+\n+    static final StompChatHandler INSTANCE = new StompChatHandler();\n+\n+    private final ConcurrentHashMap<String, Set<StompSubscription>> CHAT_DESTINATIONS =\n+            new ConcurrentHashMap<String, Set<StompSubscription>>();\n+\n+    @Override\n+    protected void channelRead0(ChannelHandlerContext ctx, StompFrame inboundFrame) throws Exception {\n+        DecoderResult decoderResult = inboundFrame.decoderResult();\n+        if (decoderResult.isFailure()) {\n+            sendErrorFrame(\"rejected frame\", decoderResult.toString(), ctx);\n+            return;\n+        }\n+\n+        switch (inboundFrame.command()) {\n+        case STOMP:\n+        case CONNECT:\n+            onConnect(inboundFrame, ctx);\n+            break;\n+        case SUBSCRIBE:\n+            onSubscribe(inboundFrame, ctx);\n+            break;\n+        case SEND:\n+            onSend(inboundFrame, ctx);\n+            break;\n+        case UNSUBSCRIBE:\n+            onUnsubscribe(inboundFrame, ctx);\n+            break;\n+        case DISCONNECT:\n+            onDisconnect(inboundFrame, ctx);\n+            break;\n+        default:\n+            sendErrorFrame(\"unsupported command\",\n+                           \"Received unsupported command \" + inboundFrame.command(), ctx);\n+        }\n+    }\n+\n+    private void onConnect(StompFrame inboundFrame, ChannelHandlerContext ctx) {", "originalCommit": "636aedd5eb323a3f40f4069593b56aae52886cf9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTUzNDUyOA==", "url": "https://github.com/netty/netty/pull/10152#discussion_r401534528", "bodyText": "Done", "author": "amizurov", "createdAt": "2020-04-01T11:08:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQxNjYyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTUzNjMxMg==", "url": "https://github.com/netty/netty/pull/10152#discussion_r401536312", "bodyText": "seems like you didn't push this yet", "author": "normanmaurer", "createdAt": "2020-04-01T11:11:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQxNjYyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTU0MjE3NA==", "url": "https://github.com/netty/netty/pull/10152#discussion_r401542174", "bodyText": "Yes just pushed, also some fixes added in StompWebSocketClientPageHandler.java", "author": "amizurov", "createdAt": "2020-04-01T11:23:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQxNjYyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQxNjczNA==", "url": "https://github.com/netty/netty/pull/10152#discussion_r401416734", "bodyText": "final", "author": "normanmaurer", "createdAt": "2020-04-01T07:44:32Z", "path": "example/src/main/java/io/netty/example/stomp/websocket/StompSubscription.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.example.stomp.websocket;\n+\n+import io.netty.channel.Channel;\n+import io.netty.util.internal.ObjectUtil;\n+\n+public class StompSubscription {", "originalCommit": "636aedd5eb323a3f40f4069593b56aae52886cf9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ1MzczMA==", "url": "https://github.com/netty/netty/pull/10152#discussion_r401453730", "bodyText": "Done", "author": "amizurov", "createdAt": "2020-04-01T08:48:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQxNjczNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQxNzU3MA==", "url": "https://github.com/netty/netty/pull/10152#discussion_r401417570", "bodyText": "add private constructor and make it final", "author": "normanmaurer", "createdAt": "2020-04-01T07:46:02Z", "path": "example/src/main/java/io/netty/example/stomp/websocket/StompWebSocketClientPageHandler.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.example.stomp.websocket;\n+\n+import io.netty.buffer.ByteBufUtil;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.DefaultFileRegion;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.handler.codec.http.DefaultFullHttpResponse;\n+import io.netty.handler.codec.http.DefaultHttpResponse;\n+import io.netty.handler.codec.http.FullHttpRequest;\n+import io.netty.handler.codec.http.FullHttpResponse;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import io.netty.handler.codec.http.HttpHeaderValues;\n+import io.netty.handler.codec.http.HttpResponse;\n+import io.netty.handler.codec.http.HttpUtil;\n+import io.netty.util.CharsetUtil;\n+\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.net.URL;\n+import java.nio.CharBuffer;\n+\n+import static io.netty.handler.codec.http.HttpHeaderNames.*;\n+import static io.netty.handler.codec.http.HttpHeaderValues.KEEP_ALIVE;\n+import static io.netty.handler.codec.http.HttpHeaderValues.*;\n+import static io.netty.handler.codec.http.HttpResponseStatus.*;\n+import static io.netty.handler.codec.http.HttpVersion.*;\n+\n+@Sharable\n+public class StompWebSocketClientPageHandler extends SimpleChannelInboundHandler<FullHttpRequest> {\n+", "originalCommit": "636aedd5eb323a3f40f4069593b56aae52886cf9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ1MzY4Mg==", "url": "https://github.com/netty/netty/pull/10152#discussion_r401453682", "bodyText": "Done", "author": "amizurov", "createdAt": "2020-04-01T08:48:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQxNzU3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQxNzk0OA==", "url": "https://github.com/netty/netty/pull/10152#discussion_r401417948", "bodyText": "Why can't you use writeCharSequence(...) ?", "author": "normanmaurer", "createdAt": "2020-04-01T07:46:51Z", "path": "example/src/main/java/io/netty/example/stomp/websocket/StompWebSocketClientPageHandler.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.example.stomp.websocket;\n+\n+import io.netty.buffer.ByteBufUtil;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.DefaultFileRegion;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.handler.codec.http.DefaultFullHttpResponse;\n+import io.netty.handler.codec.http.DefaultHttpResponse;\n+import io.netty.handler.codec.http.FullHttpRequest;\n+import io.netty.handler.codec.http.FullHttpResponse;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import io.netty.handler.codec.http.HttpHeaderValues;\n+import io.netty.handler.codec.http.HttpResponse;\n+import io.netty.handler.codec.http.HttpUtil;\n+import io.netty.util.CharsetUtil;\n+\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.net.URL;\n+import java.nio.CharBuffer;\n+\n+import static io.netty.handler.codec.http.HttpHeaderNames.*;\n+import static io.netty.handler.codec.http.HttpHeaderValues.KEEP_ALIVE;\n+import static io.netty.handler.codec.http.HttpHeaderValues.*;\n+import static io.netty.handler.codec.http.HttpResponseStatus.*;\n+import static io.netty.handler.codec.http.HttpVersion.*;\n+\n+@Sharable\n+public class StompWebSocketClientPageHandler extends SimpleChannelInboundHandler<FullHttpRequest> {\n+\n+    static final StompWebSocketClientPageHandler INSTANCE = new StompWebSocketClientPageHandler();\n+\n+    @Override\n+    protected void channelRead0(ChannelHandlerContext ctx, FullHttpRequest request) throws Exception {\n+        if (request.headers().contains(HttpHeaderNames.UPGRADE, HttpHeaderValues.WEBSOCKET, true)) {\n+            ctx.fireChannelRead(request.retain());\n+            return;\n+        }\n+\n+        if (!sendResource(request, ctx)) {\n+            FullHttpResponse notFound = new DefaultFullHttpResponse(request.protocolVersion(), NOT_FOUND);\n+            notFound.headers().set(CONTENT_TYPE, TEXT_PLAIN);\n+            String payload = \"Requested resource \" + request.uri() + \" not found\";\n+            notFound.content()\n+                    .writeBytes(ByteBufUtil.encodeString(ctx.alloc(), CharBuffer.wrap(payload), CharsetUtil.UTF_8));", "originalCommit": "636aedd5eb323a3f40f4069593b56aae52886cf9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTUzNDY2MA==", "url": "https://github.com/netty/netty/pull/10152#discussion_r401534660", "bodyText": "Fixed", "author": "amizurov", "createdAt": "2020-04-01T11:08:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQxNzk0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQxNzk5OA==", "url": "https://github.com/netty/netty/pull/10152#discussion_r401417998", "bodyText": "static", "author": "normanmaurer", "createdAt": "2020-04-01T07:46:58Z", "path": "example/src/main/java/io/netty/example/stomp/websocket/StompWebSocketClientPageHandler.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.example.stomp.websocket;\n+\n+import io.netty.buffer.ByteBufUtil;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.DefaultFileRegion;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.handler.codec.http.DefaultFullHttpResponse;\n+import io.netty.handler.codec.http.DefaultHttpResponse;\n+import io.netty.handler.codec.http.FullHttpRequest;\n+import io.netty.handler.codec.http.FullHttpResponse;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import io.netty.handler.codec.http.HttpHeaderValues;\n+import io.netty.handler.codec.http.HttpResponse;\n+import io.netty.handler.codec.http.HttpUtil;\n+import io.netty.util.CharsetUtil;\n+\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.net.URL;\n+import java.nio.CharBuffer;\n+\n+import static io.netty.handler.codec.http.HttpHeaderNames.*;\n+import static io.netty.handler.codec.http.HttpHeaderValues.KEEP_ALIVE;\n+import static io.netty.handler.codec.http.HttpHeaderValues.*;\n+import static io.netty.handler.codec.http.HttpResponseStatus.*;\n+import static io.netty.handler.codec.http.HttpVersion.*;\n+\n+@Sharable\n+public class StompWebSocketClientPageHandler extends SimpleChannelInboundHandler<FullHttpRequest> {\n+\n+    static final StompWebSocketClientPageHandler INSTANCE = new StompWebSocketClientPageHandler();\n+\n+    @Override\n+    protected void channelRead0(ChannelHandlerContext ctx, FullHttpRequest request) throws Exception {\n+        if (request.headers().contains(HttpHeaderNames.UPGRADE, HttpHeaderValues.WEBSOCKET, true)) {\n+            ctx.fireChannelRead(request.retain());\n+            return;\n+        }\n+\n+        if (!sendResource(request, ctx)) {\n+            FullHttpResponse notFound = new DefaultFullHttpResponse(request.protocolVersion(), NOT_FOUND);\n+            notFound.headers().set(CONTENT_TYPE, TEXT_PLAIN);\n+            String payload = \"Requested resource \" + request.uri() + \" not found\";\n+            notFound.content()\n+                    .writeBytes(ByteBufUtil.encodeString(ctx.alloc(), CharBuffer.wrap(payload), CharsetUtil.UTF_8));\n+            HttpUtil.setContentLength(notFound, notFound.content().readableBytes());\n+            sendResponse(notFound, ctx, true);\n+        }\n+    }\n+\n+    private boolean sendResource(FullHttpRequest request, ChannelHandlerContext ctx) {", "originalCommit": "636aedd5eb323a3f40f4069593b56aae52886cf9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ1Mzg1MA==", "url": "https://github.com/netty/netty/pull/10152#discussion_r401453850", "bodyText": "Done", "author": "amizurov", "createdAt": "2020-04-01T08:49:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQxNzk5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTU4NDE2OA==", "url": "https://github.com/netty/netty/pull/10152#discussion_r401584168", "bodyText": "I see.. that said I think we should check with get first and then call putIfAbstent to ensure we not allocate a new HashSet all the time", "author": "normanmaurer", "createdAt": "2020-04-01T12:42:08Z", "path": "example/src/main/java/io/netty/example/stomp/websocket/StompChatHandler.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.example.stomp.websocket;\n+\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.handler.codec.DecoderResult;\n+import io.netty.handler.codec.stomp.DefaultStompFrame;\n+import io.netty.handler.codec.stomp.StompCommand;\n+import io.netty.handler.codec.stomp.StompFrame;\n+import io.netty.util.CharsetUtil;\n+\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import static io.netty.handler.codec.stomp.StompHeaders.*;\n+\n+@Sharable\n+public class StompChatHandler extends SimpleChannelInboundHandler<StompFrame> {\n+\n+    private final ConcurrentMap<String, Set<StompSubscription>> chatDestinations =\n+            new ConcurrentHashMap<String, Set<StompSubscription>>();\n+\n+    @Override\n+    protected void channelRead0(ChannelHandlerContext ctx, StompFrame inboundFrame) throws Exception {\n+        DecoderResult decoderResult = inboundFrame.decoderResult();\n+        if (decoderResult.isFailure()) {\n+            sendErrorFrame(\"rejected frame\", decoderResult.toString(), ctx);\n+            return;\n+        }\n+\n+        switch (inboundFrame.command()) {\n+        case STOMP:\n+        case CONNECT:\n+            onConnect(ctx, inboundFrame);\n+            break;\n+        case SUBSCRIBE:\n+            onSubscribe(ctx, inboundFrame);\n+            break;\n+        case SEND:\n+            onSend(ctx, inboundFrame);\n+            break;\n+        case UNSUBSCRIBE:\n+            onUnsubscribe(ctx, inboundFrame);\n+            break;\n+        case DISCONNECT:\n+            onDisconnect(ctx, inboundFrame);\n+            break;\n+        default:\n+            sendErrorFrame(\"unsupported command\",\n+                           \"Received unsupported command \" + inboundFrame.command(), ctx);\n+        }\n+    }\n+\n+    private void onSubscribe(ChannelHandlerContext ctx, StompFrame inboundFrame) {\n+        String destination = inboundFrame.headers().getAsString(DESTINATION);\n+        String subscriptionId = inboundFrame.headers().getAsString(ID);\n+\n+        if (destination == null || subscriptionId == null) {\n+            sendErrorFrame(\"missed header\", \"Required 'destination' or 'id' header missed\", ctx);\n+            return;\n+        }\n+\n+        Set<StompSubscription> subscriptions =\n+                chatDestinations.putIfAbsent(destination, new HashSet<StompSubscription>());\n+        if (subscriptions == null) {", "originalCommit": "798e4731a7608943f12609e8cb1feddd7f992e7d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTYwNTEyOQ==", "url": "https://github.com/netty/netty/pull/10152#discussion_r401605129", "bodyText": "Got it", "author": "amizurov", "createdAt": "2020-04-01T13:15:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTU4NDE2OA=="}], "type": "inlineReview"}, {"oid": "bbd8bbce1f28e0f0cf542ec207e25503d6ca6ef9", "url": "https://github.com/netty/netty/commit/bbd8bbce1f28e0f0cf542ec207e25503d6ca6ef9", "message": "Stomp over WebSocket Chat example", "committedDate": "2020-04-01T17:40:48Z", "type": "commit"}, {"oid": "bbd8bbce1f28e0f0cf542ec207e25503d6ca6ef9", "url": "https://github.com/netty/netty/commit/bbd8bbce1f28e0f0cf542ec207e25503d6ca6ef9", "message": "Stomp over WebSocket Chat example", "committedDate": "2020-04-01T17:40:48Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEwNjc0NA==", "url": "https://github.com/netty/netty/pull/10152#discussion_r402106744", "bodyText": "ni: there is no need to call get again... putIfAbsent will return the subscription already so just store it in another var and re-assign", "author": "normanmaurer", "createdAt": "2020-04-02T07:31:35Z", "path": "example/src/main/java/io/netty/example/stomp/websocket/StompChatHandler.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.example.stomp.websocket;\n+\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.handler.codec.DecoderResult;\n+import io.netty.handler.codec.stomp.DefaultStompFrame;\n+import io.netty.handler.codec.stomp.StompCommand;\n+import io.netty.handler.codec.stomp.StompFrame;\n+import io.netty.util.CharsetUtil;\n+\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import static io.netty.handler.codec.stomp.StompHeaders.*;\n+\n+@Sharable\n+public class StompChatHandler extends SimpleChannelInboundHandler<StompFrame> {\n+\n+    private final ConcurrentMap<String, Set<StompSubscription>> chatDestinations =\n+            new ConcurrentHashMap<String, Set<StompSubscription>>();\n+\n+    @Override\n+    protected void channelRead0(ChannelHandlerContext ctx, StompFrame inboundFrame) throws Exception {\n+        DecoderResult decoderResult = inboundFrame.decoderResult();\n+        if (decoderResult.isFailure()) {\n+            sendErrorFrame(\"rejected frame\", decoderResult.toString(), ctx);\n+            return;\n+        }\n+\n+        switch (inboundFrame.command()) {\n+        case STOMP:\n+        case CONNECT:\n+            onConnect(ctx, inboundFrame);\n+            break;\n+        case SUBSCRIBE:\n+            onSubscribe(ctx, inboundFrame);\n+            break;\n+        case SEND:\n+            onSend(ctx, inboundFrame);\n+            break;\n+        case UNSUBSCRIBE:\n+            onUnsubscribe(ctx, inboundFrame);\n+            break;\n+        case DISCONNECT:\n+            onDisconnect(ctx, inboundFrame);\n+            break;\n+        default:\n+            sendErrorFrame(\"unsupported command\",\n+                           \"Received unsupported command \" + inboundFrame.command(), ctx);\n+        }\n+    }\n+\n+    private void onSubscribe(ChannelHandlerContext ctx, StompFrame inboundFrame) {\n+        String destination = inboundFrame.headers().getAsString(DESTINATION);\n+        String subscriptionId = inboundFrame.headers().getAsString(ID);\n+\n+        if (destination == null || subscriptionId == null) {\n+            sendErrorFrame(\"missed header\", \"Required 'destination' or 'id' header missed\", ctx);\n+            return;\n+        }\n+\n+        Set<StompSubscription> subscriptions = chatDestinations.get(destination);\n+        if (subscriptions == null) {\n+            subscriptions = new HashSet<StompSubscription>();\n+            if (chatDestinations.putIfAbsent(destination, subscriptions) != null) {\n+                subscriptions = chatDestinations.get(destination);", "originalCommit": "bbd8bbce1f28e0f0cf542ec207e25503d6ca6ef9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjM0NDk0Mw==", "url": "https://github.com/netty/netty/pull/10152#discussion_r402344943", "bodyText": "Done", "author": "amizurov", "createdAt": "2020-04-02T14:12:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEwNjc0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEwODY5Nw==", "url": "https://github.com/netty/netty/pull/10152#discussion_r402108697", "bodyText": "nit: why specify an explicit name here ? We dont do this for the other handlers as well.", "author": "normanmaurer", "createdAt": "2020-04-02T07:35:26Z", "path": "example/src/main/java/io/netty/example/stomp/websocket/StompWebSocketChatServerInitializer.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.example.stomp.websocket;\n+\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.handler.codec.http.HttpObjectAggregator;\n+import io.netty.handler.codec.http.HttpServerCodec;\n+import io.netty.handler.codec.http.websocketx.WebSocketServerProtocolHandler;\n+import io.netty.util.internal.ObjectUtil;\n+\n+public class StompWebSocketChatServerInitializer extends ChannelInitializer<SocketChannel> {\n+\n+    private final String chatPath;\n+    private final StompWebSocketProtocolCodec stompWebSocketProtocolCodec;\n+\n+    public StompWebSocketChatServerInitializer(String chatPath) {\n+        this.chatPath = ObjectUtil.checkNotNull(chatPath, \"chatPath\");\n+        stompWebSocketProtocolCodec = new StompWebSocketProtocolCodec();\n+    }\n+\n+    @Override\n+    protected void initChannel(SocketChannel channel) throws Exception {\n+        channel.pipeline()\n+               .addLast(new HttpServerCodec())\n+               .addLast(new HttpObjectAggregator(65536))\n+               .addLast(StompWebSocketClientPageHandler.INSTANCE)\n+               .addLast(new WebSocketServerProtocolHandler(chatPath, StompVersion.SUB_PROTOCOLS))\n+               .addLast(\"stompWebSocketProtocolCodec\", stompWebSocketProtocolCodec);", "originalCommit": "bbd8bbce1f28e0f0cf542ec207e25503d6ca6ef9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjM0NDg0MA==", "url": "https://github.com/netty/netty/pull/10152#discussion_r402344840", "bodyText": "Removed all codec names", "author": "amizurov", "createdAt": "2020-04-02T14:12:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEwODY5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEwOTI1Ng==", "url": "https://github.com/netty/netty/pull/10152#discussion_r402109256", "bodyText": "why explicit use voidPromise here ?", "author": "normanmaurer", "createdAt": "2020-04-02T07:36:34Z", "path": "example/src/main/java/io/netty/example/stomp/websocket/StompWebSocketClientPageHandler.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.example.stomp.websocket;\n+\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.DefaultFileRegion;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.handler.codec.http.DefaultFullHttpResponse;\n+import io.netty.handler.codec.http.DefaultHttpResponse;\n+import io.netty.handler.codec.http.FullHttpRequest;\n+import io.netty.handler.codec.http.FullHttpResponse;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import io.netty.handler.codec.http.HttpHeaderValues;\n+import io.netty.handler.codec.http.HttpResponse;\n+import io.netty.handler.codec.http.HttpUtil;\n+import io.netty.handler.codec.http.LastHttpContent;\n+import io.netty.util.CharsetUtil;\n+\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.net.URL;\n+\n+import static io.netty.handler.codec.http.HttpHeaderNames.*;\n+import static io.netty.handler.codec.http.HttpHeaderValues.KEEP_ALIVE;\n+import static io.netty.handler.codec.http.HttpHeaderValues.*;\n+import static io.netty.handler.codec.http.HttpResponseStatus.*;\n+import static io.netty.handler.codec.http.HttpVersion.*;\n+\n+@Sharable\n+public final class StompWebSocketClientPageHandler extends SimpleChannelInboundHandler<FullHttpRequest> {\n+\n+    static final StompWebSocketClientPageHandler INSTANCE = new StompWebSocketClientPageHandler();\n+\n+    private StompWebSocketClientPageHandler() {\n+    }\n+\n+    @Override\n+    protected void channelRead0(ChannelHandlerContext ctx, FullHttpRequest request) {\n+        if (request.headers().contains(HttpHeaderNames.UPGRADE, HttpHeaderValues.WEBSOCKET, true)) {\n+            ctx.fireChannelRead(request.retain());\n+            return;\n+        }\n+\n+        if (!sendResource(request, ctx)) {\n+            FullHttpResponse notFound = new DefaultFullHttpResponse(request.protocolVersion(), NOT_FOUND);\n+            notFound.headers().set(CONTENT_TYPE, TEXT_PLAIN);\n+            String payload = \"Requested resource \" + request.uri() + \" not found\";\n+            notFound.content().writeCharSequence(payload, CharsetUtil.UTF_8);\n+            HttpUtil.setContentLength(notFound, notFound.content().readableBytes());\n+            sendResponse(notFound, ctx, true);\n+        }\n+    }\n+\n+    private static boolean sendResource(FullHttpRequest request, ChannelHandlerContext ctx) {\n+        String requestResource = request.uri().substring(1);\n+        if (requestResource.isEmpty()) {\n+            requestResource = \"index.html\";\n+        }\n+\n+        URL resourceUrl = INSTANCE.getClass().getResource(requestResource);\n+        if (resourceUrl == null) {\n+            return false;\n+        }\n+\n+        RandomAccessFile raf = null;\n+        long fileLength = -1L;\n+        try {\n+            raf = new RandomAccessFile(resourceUrl.getFile(), \"r\");\n+            fileLength = raf.length();\n+        } catch (IOException io) {\n+            System.out.println(\"File not found \" + io.getMessage());\n+            return false;\n+        } finally {\n+            if (fileLength < 0 && raf != null) {\n+                try {\n+                    raf.close();\n+                } catch (Exception io) {\n+                    // Nothing to do\n+                }\n+            }\n+        }\n+\n+        HttpResponse response = new DefaultHttpResponse(request.protocolVersion(), OK);\n+        HttpUtil.setContentLength(response, fileLength);\n+\n+        String contentType = \"application/octet-stream\";\n+        if (requestResource.endsWith(\"html\")) {\n+            contentType = \"text/html; charset=UTF-8\";\n+        } else if (requestResource.endsWith(\"css\")) {\n+            contentType = \"text/css; charset=UTF-8\";\n+        } else if (requestResource.endsWith(\"js\")) {\n+            contentType = \"application/javascript\";\n+        }\n+\n+        response.headers().set(CONTENT_TYPE, contentType);\n+        sendResponse(response, ctx, false);\n+        ctx.write(new DefaultFileRegion(raf.getChannel(), 0, fileLength), ctx.voidPromise());", "originalCommit": "bbd8bbce1f28e0f0cf542ec207e25503d6ca6ef9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjM0Mzk3Mg==", "url": "https://github.com/netty/netty/pull/10152#discussion_r402343972", "bodyText": "Removed", "author": "amizurov", "createdAt": "2020-04-02T14:11:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEwOTI1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEwOTYzNA==", "url": "https://github.com/netty/netty/pull/10152#discussion_r402109634", "bodyText": "why specify a name when adding to the pipeline ? Consider just not doing this", "author": "normanmaurer", "createdAt": "2020-04-02T07:37:24Z", "path": "example/src/main/java/io/netty/example/stomp/websocket/StompWebSocketProtocolCodec.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.example.stomp.websocket;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.handler.codec.MessageToMessageCodec;\n+import io.netty.handler.codec.http.websocketx.TextWebSocketFrame;\n+import io.netty.handler.codec.http.websocketx.WebSocketFrame;\n+import io.netty.handler.codec.http.websocketx.WebSocketServerProtocolHandler;\n+import io.netty.handler.codec.http.websocketx.WebSocketServerProtocolHandler.HandshakeComplete;\n+import io.netty.handler.codec.stomp.StompSubframeAggregator;\n+import io.netty.handler.codec.stomp.StompSubframeDecoder;\n+import io.netty.handler.codec.stomp.StompSubframeEncoder;\n+\n+import java.util.List;\n+\n+@Sharable\n+public class StompWebSocketProtocolCodec extends MessageToMessageCodec<WebSocketFrame, ByteBuf> {\n+\n+    private final StompChatHandler stompChatHandler = new StompChatHandler();\n+\n+    @Override\n+    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n+        if (evt instanceof WebSocketServerProtocolHandler.HandshakeComplete) {\n+            StompVersion stompVersion = StompVersion.findBySubProtocol(((HandshakeComplete) evt).selectedSubprotocol());\n+            ctx.channel().attr(StompVersion.CHANNEL_ATTRIBUTE_KEY).set(stompVersion);\n+            String ctxName = ctx.name();\n+            ctx.pipeline()\n+               .addAfter(ctxName, \"stompChatHandler\", stompChatHandler)\n+               .addAfter(ctxName, \"stompAggregator\", new StompSubframeAggregator(65536))\n+               .addAfter(ctxName, \"stompEncoder\", new StompSubframeEncoder())\n+               .addAfter(ctxName, \"stompDecoder\", new StompSubframeDecoder())", "originalCommit": "bbd8bbce1f28e0f0cf542ec207e25503d6ca6ef9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjM0Mzg1MA==", "url": "https://github.com/netty/netty/pull/10152#discussion_r402343850", "bodyText": "Changed over addLast()", "author": "amizurov", "createdAt": "2020-04-02T14:11:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEwOTYzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjExMTU1Mg==", "url": "https://github.com/netty/netty/pull/10152#discussion_r402111552", "bodyText": "IOException", "author": "normanmaurer", "createdAt": "2020-04-02T07:41:08Z", "path": "example/src/main/java/io/netty/example/stomp/websocket/StompWebSocketClientPageHandler.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.example.stomp.websocket;\n+\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.DefaultFileRegion;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.handler.codec.http.DefaultFullHttpResponse;\n+import io.netty.handler.codec.http.DefaultHttpResponse;\n+import io.netty.handler.codec.http.FullHttpRequest;\n+import io.netty.handler.codec.http.FullHttpResponse;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import io.netty.handler.codec.http.HttpHeaderValues;\n+import io.netty.handler.codec.http.HttpResponse;\n+import io.netty.handler.codec.http.HttpUtil;\n+import io.netty.handler.codec.http.LastHttpContent;\n+import io.netty.util.CharsetUtil;\n+\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.net.URL;\n+\n+import static io.netty.handler.codec.http.HttpHeaderNames.*;\n+import static io.netty.handler.codec.http.HttpHeaderValues.KEEP_ALIVE;\n+import static io.netty.handler.codec.http.HttpHeaderValues.*;\n+import static io.netty.handler.codec.http.HttpResponseStatus.*;\n+import static io.netty.handler.codec.http.HttpVersion.*;\n+\n+@Sharable\n+public final class StompWebSocketClientPageHandler extends SimpleChannelInboundHandler<FullHttpRequest> {\n+\n+    static final StompWebSocketClientPageHandler INSTANCE = new StompWebSocketClientPageHandler();\n+\n+    private StompWebSocketClientPageHandler() {\n+    }\n+\n+    @Override\n+    protected void channelRead0(ChannelHandlerContext ctx, FullHttpRequest request) {\n+        if (request.headers().contains(HttpHeaderNames.UPGRADE, HttpHeaderValues.WEBSOCKET, true)) {\n+            ctx.fireChannelRead(request.retain());\n+            return;\n+        }\n+\n+        if (!sendResource(request, ctx)) {\n+            FullHttpResponse notFound = new DefaultFullHttpResponse(request.protocolVersion(), NOT_FOUND);\n+            notFound.headers().set(CONTENT_TYPE, TEXT_PLAIN);\n+            String payload = \"Requested resource \" + request.uri() + \" not found\";\n+            notFound.content().writeCharSequence(payload, CharsetUtil.UTF_8);\n+            HttpUtil.setContentLength(notFound, notFound.content().readableBytes());\n+            sendResponse(notFound, ctx, true);\n+        }\n+    }\n+\n+    private static boolean sendResource(FullHttpRequest request, ChannelHandlerContext ctx) {\n+        String requestResource = request.uri().substring(1);\n+        if (requestResource.isEmpty()) {\n+            requestResource = \"index.html\";\n+        }\n+\n+        URL resourceUrl = INSTANCE.getClass().getResource(requestResource);\n+        if (resourceUrl == null) {\n+            return false;\n+        }\n+\n+        RandomAccessFile raf = null;\n+        long fileLength = -1L;\n+        try {\n+            raf = new RandomAccessFile(resourceUrl.getFile(), \"r\");\n+            fileLength = raf.length();\n+        } catch (IOException io) {\n+            System.out.println(\"File not found \" + io.getMessage());\n+            return false;\n+        } finally {\n+            if (fileLength < 0 && raf != null) {\n+                try {\n+                    raf.close();\n+                } catch (Exception io) {", "originalCommit": "bbd8bbce1f28e0f0cf542ec207e25503d6ca6ef9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjM0MzUxMg==", "url": "https://github.com/netty/netty/pull/10152#discussion_r402343512", "bodyText": "Fixed", "author": "amizurov", "createdAt": "2020-04-02T14:10:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjExMTU1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjExMTc2Nw==", "url": "https://github.com/netty/netty/pull/10152#discussion_r402111767", "bodyText": "Should this be FileNotFoundException ?", "author": "normanmaurer", "createdAt": "2020-04-02T07:41:36Z", "path": "example/src/main/java/io/netty/example/stomp/websocket/StompWebSocketClientPageHandler.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.example.stomp.websocket;\n+\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.DefaultFileRegion;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.handler.codec.http.DefaultFullHttpResponse;\n+import io.netty.handler.codec.http.DefaultHttpResponse;\n+import io.netty.handler.codec.http.FullHttpRequest;\n+import io.netty.handler.codec.http.FullHttpResponse;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import io.netty.handler.codec.http.HttpHeaderValues;\n+import io.netty.handler.codec.http.HttpResponse;\n+import io.netty.handler.codec.http.HttpUtil;\n+import io.netty.handler.codec.http.LastHttpContent;\n+import io.netty.util.CharsetUtil;\n+\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.net.URL;\n+\n+import static io.netty.handler.codec.http.HttpHeaderNames.*;\n+import static io.netty.handler.codec.http.HttpHeaderValues.KEEP_ALIVE;\n+import static io.netty.handler.codec.http.HttpHeaderValues.*;\n+import static io.netty.handler.codec.http.HttpResponseStatus.*;\n+import static io.netty.handler.codec.http.HttpVersion.*;\n+\n+@Sharable\n+public final class StompWebSocketClientPageHandler extends SimpleChannelInboundHandler<FullHttpRequest> {\n+\n+    static final StompWebSocketClientPageHandler INSTANCE = new StompWebSocketClientPageHandler();\n+\n+    private StompWebSocketClientPageHandler() {\n+    }\n+\n+    @Override\n+    protected void channelRead0(ChannelHandlerContext ctx, FullHttpRequest request) {\n+        if (request.headers().contains(HttpHeaderNames.UPGRADE, HttpHeaderValues.WEBSOCKET, true)) {\n+            ctx.fireChannelRead(request.retain());\n+            return;\n+        }\n+\n+        if (!sendResource(request, ctx)) {\n+            FullHttpResponse notFound = new DefaultFullHttpResponse(request.protocolVersion(), NOT_FOUND);\n+            notFound.headers().set(CONTENT_TYPE, TEXT_PLAIN);\n+            String payload = \"Requested resource \" + request.uri() + \" not found\";\n+            notFound.content().writeCharSequence(payload, CharsetUtil.UTF_8);\n+            HttpUtil.setContentLength(notFound, notFound.content().readableBytes());\n+            sendResponse(notFound, ctx, true);\n+        }\n+    }\n+\n+    private static boolean sendResource(FullHttpRequest request, ChannelHandlerContext ctx) {\n+        String requestResource = request.uri().substring(1);\n+        if (requestResource.isEmpty()) {\n+            requestResource = \"index.html\";\n+        }\n+\n+        URL resourceUrl = INSTANCE.getClass().getResource(requestResource);\n+        if (resourceUrl == null) {\n+            return false;\n+        }\n+\n+        RandomAccessFile raf = null;\n+        long fileLength = -1L;\n+        try {\n+            raf = new RandomAccessFile(resourceUrl.getFile(), \"r\");\n+            fileLength = raf.length();\n+        } catch (IOException io) {", "originalCommit": "bbd8bbce1f28e0f0cf542ec207e25503d6ca6ef9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjM0MzQxOQ==", "url": "https://github.com/netty/netty/pull/10152#discussion_r402343419", "bodyText": "Handled a both possible exception", "author": "amizurov", "createdAt": "2020-04-02T14:10:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjExMTc2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjExMjMyMA==", "url": "https://github.com/netty/netty/pull/10152#discussion_r402112320", "bodyText": "I think we need to check that !....uri().isEmpty() as otherwise it may produce an IndexOutOfBoundsException above.", "author": "normanmaurer", "createdAt": "2020-04-02T07:42:37Z", "path": "example/src/main/java/io/netty/example/stomp/websocket/StompWebSocketClientPageHandler.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.example.stomp.websocket;\n+\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.DefaultFileRegion;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.handler.codec.http.DefaultFullHttpResponse;\n+import io.netty.handler.codec.http.DefaultHttpResponse;\n+import io.netty.handler.codec.http.FullHttpRequest;\n+import io.netty.handler.codec.http.FullHttpResponse;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import io.netty.handler.codec.http.HttpHeaderValues;\n+import io.netty.handler.codec.http.HttpResponse;\n+import io.netty.handler.codec.http.HttpUtil;\n+import io.netty.handler.codec.http.LastHttpContent;\n+import io.netty.util.CharsetUtil;\n+\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.net.URL;\n+\n+import static io.netty.handler.codec.http.HttpHeaderNames.*;\n+import static io.netty.handler.codec.http.HttpHeaderValues.KEEP_ALIVE;\n+import static io.netty.handler.codec.http.HttpHeaderValues.*;\n+import static io.netty.handler.codec.http.HttpResponseStatus.*;\n+import static io.netty.handler.codec.http.HttpVersion.*;\n+\n+@Sharable\n+public final class StompWebSocketClientPageHandler extends SimpleChannelInboundHandler<FullHttpRequest> {\n+\n+    static final StompWebSocketClientPageHandler INSTANCE = new StompWebSocketClientPageHandler();\n+\n+    private StompWebSocketClientPageHandler() {\n+    }\n+\n+    @Override\n+    protected void channelRead0(ChannelHandlerContext ctx, FullHttpRequest request) {\n+        if (request.headers().contains(HttpHeaderNames.UPGRADE, HttpHeaderValues.WEBSOCKET, true)) {\n+            ctx.fireChannelRead(request.retain());\n+            return;\n+        }\n+\n+        if (!sendResource(request, ctx)) {\n+            FullHttpResponse notFound = new DefaultFullHttpResponse(request.protocolVersion(), NOT_FOUND);\n+            notFound.headers().set(CONTENT_TYPE, TEXT_PLAIN);\n+            String payload = \"Requested resource \" + request.uri() + \" not found\";\n+            notFound.content().writeCharSequence(payload, CharsetUtil.UTF_8);\n+            HttpUtil.setContentLength(notFound, notFound.content().readableBytes());\n+            sendResponse(notFound, ctx, true);\n+        }\n+    }\n+\n+    private static boolean sendResource(FullHttpRequest request, ChannelHandlerContext ctx) {\n+        String requestResource = request.uri().substring(1);", "originalCommit": "bbd8bbce1f28e0f0cf542ec207e25503d6ca6ef9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjM0MTgwOQ==", "url": "https://github.com/netty/netty/pull/10152#discussion_r402341809", "bodyText": "Done", "author": "amizurov", "createdAt": "2020-04-02T14:08:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjExMjMyMA=="}], "type": "inlineReview"}, {"oid": "ef5934ba9b6037941159f0c72605e5e0fb17886b", "url": "https://github.com/netty/netty/commit/ef5934ba9b6037941159f0c72605e5e0fb17886b", "message": "Fix PR comments", "committedDate": "2020-04-02T14:09:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjM0ODAwMA==", "url": "https://github.com/netty/netty/pull/10152#discussion_r402348000", "bodyText": "hmm... shouldn't this also take the destination somehow into account to match StompSubscription.equals(...) ?", "author": "normanmaurer", "createdAt": "2020-04-02T14:16:45Z", "path": "example/src/main/java/io/netty/example/stomp/websocket/StompChatHandler.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.example.stomp.websocket;\n+\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.handler.codec.DecoderResult;\n+import io.netty.handler.codec.stomp.DefaultStompFrame;\n+import io.netty.handler.codec.stomp.StompCommand;\n+import io.netty.handler.codec.stomp.StompFrame;\n+import io.netty.util.CharsetUtil;\n+\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import static io.netty.handler.codec.stomp.StompHeaders.*;\n+\n+@Sharable\n+public class StompChatHandler extends SimpleChannelInboundHandler<StompFrame> {\n+\n+    private final ConcurrentMap<String, Set<StompSubscription>> chatDestinations =\n+            new ConcurrentHashMap<String, Set<StompSubscription>>();\n+\n+    @Override\n+    protected void channelRead0(ChannelHandlerContext ctx, StompFrame inboundFrame) throws Exception {\n+        DecoderResult decoderResult = inboundFrame.decoderResult();\n+        if (decoderResult.isFailure()) {\n+            sendErrorFrame(\"rejected frame\", decoderResult.toString(), ctx);\n+            return;\n+        }\n+\n+        switch (inboundFrame.command()) {\n+        case STOMP:\n+        case CONNECT:\n+            onConnect(ctx, inboundFrame);\n+            break;\n+        case SUBSCRIBE:\n+            onSubscribe(ctx, inboundFrame);\n+            break;\n+        case SEND:\n+            onSend(ctx, inboundFrame);\n+            break;\n+        case UNSUBSCRIBE:\n+            onUnsubscribe(ctx, inboundFrame);\n+            break;\n+        case DISCONNECT:\n+            onDisconnect(ctx, inboundFrame);\n+            break;\n+        default:\n+            sendErrorFrame(\"unsupported command\",\n+                           \"Received unsupported command \" + inboundFrame.command(), ctx);\n+        }\n+    }\n+\n+    private void onSubscribe(ChannelHandlerContext ctx, StompFrame inboundFrame) {\n+        String destination = inboundFrame.headers().getAsString(DESTINATION);\n+        String subscriptionId = inboundFrame.headers().getAsString(ID);\n+\n+        if (destination == null || subscriptionId == null) {\n+            sendErrorFrame(\"missed header\", \"Required 'destination' or 'id' header missed\", ctx);\n+            return;\n+        }\n+\n+        Set<StompSubscription> subscriptions = chatDestinations.get(destination);\n+        if (subscriptions == null) {\n+            subscriptions = new HashSet<StompSubscription>();\n+            Set<StompSubscription> previousSubscriptions = chatDestinations.putIfAbsent(destination, subscriptions);\n+            if (previousSubscriptions != null) {\n+                subscriptions = previousSubscriptions;\n+            }\n+        }\n+\n+        final StompSubscription subscription = new StompSubscription(subscriptionId, destination, ctx.channel());\n+        if (subscriptions.contains(subscription)) {\n+            sendErrorFrame(\"duplicate subscription\",\n+                           \"Received duplicate subscription id=\" + subscriptionId, ctx);\n+            return;\n+        }\n+\n+        subscriptions.add(subscription);\n+        ctx.channel().closeFuture().addListener(new ChannelFutureListener() {\n+            @Override\n+            public void operationComplete(ChannelFuture future) {\n+                chatDestinations.get(subscription.destination()).remove(subscription);\n+            }\n+        });\n+\n+        String receiptId = inboundFrame.headers().getAsString(RECEIPT);\n+        if (receiptId != null) {\n+            StompFrame receiptFrame = new DefaultStompFrame(StompCommand.RECEIPT);\n+            receiptFrame.headers().set(RECEIPT_ID, receiptId);\n+            ctx.writeAndFlush(receiptFrame);\n+        }\n+    }\n+\n+    private void onSend(ChannelHandlerContext ctx, StompFrame inboundFrame) {\n+        String destination = inboundFrame.headers().getAsString(DESTINATION);\n+        if (destination == null) {\n+            sendErrorFrame(\"missed header\", \"required 'destination' header missed\", ctx);\n+            return;\n+        }\n+\n+        Set<StompSubscription> subscriptions = chatDestinations.get(destination);\n+        for (StompSubscription subscription : subscriptions) {\n+            subscription.channel().writeAndFlush(transformToMessage(inboundFrame, subscription));\n+        }\n+    }\n+\n+    private void onUnsubscribe(ChannelHandlerContext ctx, StompFrame inboundFrame) {\n+        String subscriptionId = inboundFrame.headers().getAsString(SUBSCRIPTION);\n+        for (Entry<String, Set<StompSubscription>> entry : chatDestinations.entrySet()) {\n+            Iterator<StompSubscription> iterator = entry.getValue().iterator();\n+            while (iterator.hasNext()) {\n+                StompSubscription subscription = iterator.next();\n+                if (subscription.id().equals(subscriptionId) && subscription.channel().equals(ctx.channel())) {", "originalCommit": "ef5934ba9b6037941159f0c72605e5e0fb17886b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjM3MTk2MQ==", "url": "https://github.com/netty/netty/pull/10152#discussion_r402371961", "bodyText": "By spec only id required for UNSUBSCRIBE command. So assumption here that subscriptions id should be uniq within connection (channel).", "author": "amizurov", "createdAt": "2020-04-02T14:47:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjM0ODAwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ2ODgxMg==", "url": "https://github.com/netty/netty/pull/10152#discussion_r403468812", "bodyText": "chat destination There is a fuzzy match;\nExample:\nchat client destination: /topic/test/*\nWhether the server can adapt better\n@amizurov @normanmaurer", "author": "llm163520", "createdAt": "2020-04-04T13:13:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjM0ODAwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ2OTAxMw==", "url": "https://github.com/netty/netty/pull/10152#discussion_r403469013", "bodyText": "@amizurov @normanmaurer\nAfter the test found that the client port is not detected by the server", "author": "llm163520", "createdAt": "2020-04-04T13:15:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjM0ODAwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzk3MjYyMw==", "url": "https://github.com/netty/netty/pull/10152#discussion_r403972623", "bodyText": "chat destination There is a fuzzy match;\nExample:\nchat client destination: /topic/test/*\nWhether the server can adapt better\n@amizurov @normanmaurer\n\nJust for clarify, this is only example how you can integrate (WS and subProtocol(STOMP)). So fuzzy match is business feature if you think that is really needed you can provide a PR. IMHO.", "author": "amizurov", "createdAt": "2020-04-06T10:03:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjM0ODAwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzk3NDI3OA==", "url": "https://github.com/netty/netty/pull/10152#discussion_r403974278", "bodyText": "@amizurov @normanmaurer\nAfter the test found that the client port is not detected by the server\n\nI think we can handle index.html differently from resources (js, cs) with some simple templating. WDYT @normanmaurer", "author": "amizurov", "createdAt": "2020-04-06T10:06:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjM0ODAwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDA0NDM3NA==", "url": "https://github.com/netty/netty/pull/10152#discussion_r404044374", "bodyText": "At the end I think this is just an example and we should not over-complicate things.", "author": "normanmaurer", "createdAt": "2020-04-06T12:15:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjM0ODAwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDA3NDMzNQ==", "url": "https://github.com/netty/netty/pull/10152#discussion_r404074335", "bodyText": "@normanmaurer\nIf the example can be close to the actual application scenario, the integration cost can be reduced;\nI added some supplements to the above example to see if integration is needed;", "author": "llm163520", "createdAt": "2020-04-06T13:05:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjM0ODAwMA=="}], "type": "inlineReview"}, {"oid": "3a0c78bab4a356d879e4f63fad73d5ffffc537ae", "url": "https://github.com/netty/netty/commit/3a0c78bab4a356d879e4f63fad73d5ffffc537ae", "message": "Fix checkstyle violation", "committedDate": "2020-04-02T14:58:59Z", "type": "commit"}]}