{"pr_number": 17844, "pr_title": "Prevent client ending up with two addresses to same node when node is behind a private network", "pr_createdAt": "2020-11-10T13:37:56Z", "pr_url": "https://github.com/hazelcast/hazelcast/pull/17844", "timeline": [{"oid": "5de2677e53427dba2cbde5055b1de0a2cd786279", "url": "https://github.com/hazelcast/hazelcast/commit/5de2677e53427dba2cbde5055b1de0a2cd786279", "message": "Resolving a bug when remote node is behind a private network\n\nBackground :\n\ngetOrConnect method tries to open a connection to an\naddress only once. It should never open a second connection\nto a member. To achieve that we are using the remote address\nof a connection as the source of truth. The remote address is the\none in the member list for members.\n\nIf the member is using private-addresses on a closed network,\nthe client can not use that address on its config to connect that member.\nSo we have two addresses to define single member on the client side.\n\nHow bug happens:\n\nWhen client is already connected to members, it could be the case that\nall connections are dropped temporarily. In that case, we trigger\n`doConnectToCandidateCluster` logic. It connects to a random address\nprovided in the config. This one can use `public address` of the member.\n\nIn the meantime, we have a periodic task `ConnectToAllClusterMembersTask`\nthat tries to connect to all members in the latest known memberlist.\nThis one uses the remote address which is the  `private address`\n\nBoth of them uses `getOrConnect` and `doConnectToCandidateCluster`\ncan open a second connection while a first one is already there.\nNote that some of our other services rely on single connection per member\nlogic.\n\nHow to fix:\n1. `uuid` will be used  as the source of truth.\nThis means what we can not know the uuid of a connection before opening\na connection first. We will allow opening connections paralelly from\n`doConnectToCandidateCluster` path. As soon as a response returned from the\nserver(with uuid), we check if a connection is already there and close\nthe new connection before putting it in `activeConnection`.\n\nPeriodic `ConnectToAllClusterMembersTask` will not try to connect\nan already connected member.And it will use `uuid` to decide that.\n\n2. This two paths will not use same method `getOrConnect` to simplify\nthe logic. One will based on address and the other only uuid to\nmake the intent clear.\n\nTest:\nI could not write a unit test because this requires an inaccessible\nprivate network behind a public address.", "committedDate": "2020-11-11T11:50:47Z", "type": "forcePushed"}, {"oid": "a5af78e6a6f259c540f7d22bd3d7687066826617", "url": "https://github.com/hazelcast/hazelcast/commit/a5af78e6a6f259c540f7d22bd3d7687066826617", "message": "refactored connectToAllClusterMembers", "committedDate": "2020-11-17T09:59:12Z", "type": "forcePushed"}, {"oid": "c9b951d36dedd834e4bb254dd1c305019a7106f8", "url": "https://github.com/hazelcast/hazelcast/commit/c9b951d36dedd834e4bb254dd1c305019a7106f8", "message": "refactored connectToAllClusterMembers", "committedDate": "2020-11-17T13:58:46Z", "type": "forcePushed"}, {"oid": "1afc840af3bcf2d9c143ba18f0f1f540c504064e", "url": "https://github.com/hazelcast/hazelcast/commit/1afc840af3bcf2d9c143ba18f0f1f540c504064e", "message": "refactored connectToAllClusterMembers", "committedDate": "2020-11-17T17:21:21Z", "type": "forcePushed"}, {"oid": "d9b4e7da0316854ad1fe25e572c0fec53af38e7f", "url": "https://github.com/hazelcast/hazelcast/commit/d9b4e7da0316854ad1fe25e572c0fec53af38e7f", "message": "refactored connectToAllClusterMembers", "committedDate": "2020-11-18T14:30:13Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODY5MjQxOQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17844#discussion_r528692419", "bodyText": "can tryConnectToAllClusterMembers  be called multiple times? if so, multiple scheduled tasks?", "author": "ihsandemir", "createdAt": "2020-11-23T13:11:52Z", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/connection/tcp/TcpClientConnectionManager.java", "diffHunk": "@@ -299,23 +300,24 @@ public synchronized void start() {\n \n         heartbeat.start();\n         connectToCluster();\n-        if (isSmartRoutingEnabled) {\n-            executor.scheduleWithFixedDelay(connectToAllClusterMembersTask, 1, 1, TimeUnit.SECONDS);\n-        }\n     }\n \n-    public void connectToAllClusterMembers() {\n+    public void tryConnectToAllClusterMembers(boolean sync) {\n         if (!isSmartRoutingEnabled) {\n             return;\n         }\n \n-        for (Member member : client.getClientClusterService().getMemberList()) {\n-            try {\n-                getOrConnect(member.getAddress());\n-            } catch (Exception e) {\n-                EmptyStatement.ignore(e);\n+        if (sync) {\n+            for (Member member : client.getClientClusterService().getMemberList()) {\n+                try {\n+                    getOrConnectToMember(member);\n+                } catch (Exception e) {\n+                    EmptyStatement.ignore(e);\n+                }\n             }\n         }\n+\n+        executor.scheduleWithFixedDelay(connectToAllClusterMembersTask, 1, 1, TimeUnit.SECONDS);", "originalCommit": "d9b4e7da0316854ad1fe25e572c0fec53af38e7f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODc1NTY4Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/17844#discussion_r528755687", "bodyText": "No, it can not. We are calling it only once at the beginning of an instance.", "author": "sancar", "createdAt": "2020-11-23T14:48:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODY5MjQxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODY5OTMxOQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17844#discussion_r528699319", "bodyText": "you gave extra responsibility to the method authenticateOnCluster, rather than simply just authentication. Hence, you needed to put this explanation for the implicit returned connection. I would prefer this method to just do authentication and do existing connection check at getOrConnectToAddress. you also can close the connection at the same method rather than at handleSuccessfulAuth . This is more understandable to me, separation of concerns.", "author": "ihsandemir", "createdAt": "2020-11-23T13:23:23Z", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/connection/tcp/TcpClientConnectionManager.java", "diffHunk": "@@ -808,10 +807,17 @@ private ClientConnection getConnectionFromLoadBalancer(boolean dataMember) {\n             return null;\n         }\n \n-        return getConnection(member.getUuid());\n+        return activeConnections.get(member.getUuid());\n     }\n \n-    private void authenticateOnCluster(TcpClientConnection connection) {\n+    /**", "originalCommit": "d9b4e7da0316854ad1fe25e572c0fec53af38e7f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODc2NTQ3OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17844#discussion_r528765479", "bodyText": "We are getting a lock at handleSuccessfulAuth. The check if the connection already exists should happen under that lock together with adding to activeConnections map if the connection did not exist. Not sure if I can refactor any further.", "author": "sancar", "createdAt": "2020-11-23T15:00:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODY5OTMxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODc5OTg5Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17844#discussion_r528799896", "bodyText": "you can still do the check there at line https://github.com/hazelcast/hazelcast/pull/17844/files#diff-27e248511ddd6e03d414477f847d9c1b05ab33c329e40d318345cb2ed0d0ead2L874  where you can do putIfAbsent and if put fails, it can throw exception meaning that the connection auth failed due to an already existing connection and you do not even need a second check again.", "author": "ihsandemir", "createdAt": "2020-11-23T15:45:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODY5OTMxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODcwMjE4MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17844#discussion_r528702181", "bodyText": "I hate to keep an extra state connectingAddresses  when i already have activeConnections . How important an optimization is it to prevent multiple connection opening attempts when we can not avoid it 100% of the time. For code simplicity, I would chose not to add this extra state.", "author": "ihsandemir", "createdAt": "2020-11-23T13:27:59Z", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/connection/tcp/TcpClientConnectionManager.java", "diffHunk": "@@ -1018,36 +1031,40 @@ public void onError(Channel channel, Throwable cause) {\n \n     private class ConnectToAllClusterMembersTask implements Runnable {\n \n-        private Set<Address> connectingAddresses = Collections.newSetFromMap(new ConcurrentHashMap<>());\n+        private Set<UUID> connectingAddresses = Collections.newSetFromMap(new ConcurrentHashMap<>());\n \n         @Override\n         public void run() {\n+\n             if (!client.getLifecycleService().isRunning()) {\n                 return;\n             }\n \n             for (Member member : client.getClientClusterService().getMemberList()) {\n-                Address address = member.getAddress();\n-\n-                if (client.getLifecycleService().isRunning() && getConnection(address) == null\n-                        && connectingAddresses.add(address)) {\n-                    // submit a task for this address only if there is no\n-                    // another connection attempt for it\n-                    executor.submit(() -> {\n-                        try {\n-                            if (!client.getLifecycleService().isRunning()) {\n-                                return;\n-                            }\n-                            if (getConnection(member.getUuid()) == null) {\n-                                getOrConnect(address);\n-                            }\n-                        } catch (Exception e) {\n-                            EmptyStatement.ignore(e);\n-                        } finally {\n-                            connectingAddresses.remove(address);\n-                        }\n-                    });\n+                UUID uuid = member.getUuid();\n+\n+                if (activeConnections.get(uuid) != null) {\n+                    continue;\n                 }\n+\n+                if (!connectingAddresses.add(uuid)) {", "originalCommit": "d9b4e7da0316854ad1fe25e572c0fec53af38e7f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODc2MTI4OA==", "url": "https://github.com/hazelcast/hazelcast/pull/17844#discussion_r528761288", "bodyText": "The place that we can not avoid happens rarely.\nThis code happens periodically and more likely to occur.", "author": "sancar", "createdAt": "2020-11-23T14:55:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODcwMjE4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODczMzY1NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17844#discussion_r528733655", "bodyText": "There is a slight behavior change here but I think this is not big a problem. If some of the member addresses are the same as the addresses configured, then we were not trying to connect the same address twice, but we are doing it right now.\nTo get the same behavior, maybe we could store the member addresses on the triedTargets, and while iterating over the configured addresses, check the contents of it to see whether we tried to connect or not.", "author": "mdumandag", "createdAt": "2020-11-23T14:17:25Z", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/connection/tcp/TcpClientConnectionManager.java", "diffHunk": "@@ -444,16 +446,30 @@ private void fireLifecycleEvent(LifecycleState state) {\n     }\n \n     private boolean doConnectToCandidateCluster(CandidateClusterContext context) {\n-        Set<Address> triedAddresses = new HashSet<>();\n+        Set<Object> triedTargets = new HashSet<>();\n         try {\n             waitStrategy.reset();\n             do {\n-                Collection<Address> addresses = getPossibleMemberAddresses(context.getAddressProvider());\n-                for (Address address : addresses) {\n+                List<Member> memberList = new ArrayList<>(client.getClientClusterService().getMemberList());\n+                if (shuffleMemberList) {\n+                    Collections.shuffle(memberList);\n+                }\n+                //try to connect to a member in the member list first\n+                for (Member member : memberList) {\n                     checkClientActive();\n-                    triedAddresses.add(address);\n+                    triedTargets.add(member);", "originalCommit": "d9b4e7da0316854ad1fe25e572c0fec53af38e7f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI2MDEyMA==", "url": "https://github.com/hazelcast/hazelcast/pull/17844#discussion_r529260120", "bodyText": "I missed that there is a loop here, the proposed change causes the configured addresses to not tried more than once in case of a failure, that is probably the cause of the test failures", "author": "mdumandag", "createdAt": "2020-11-24T07:40:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODczMzY1NQ=="}], "type": "inlineReview"}, {"oid": "0fb989dc16df65a23d76aa27228647ada87dda56", "url": "https://github.com/hazelcast/hazelcast/commit/0fb989dc16df65a23d76aa27228647ada87dda56", "message": "seperate authenticate and onAuthenticate functions.", "committedDate": "2020-11-24T11:49:08Z", "type": "forcePushed"}, {"oid": "858d40ecfe1ab85d8d749c6713c1b9ab199067d1", "url": "https://github.com/hazelcast/hazelcast/commit/858d40ecfe1ab85d8d749c6713c1b9ab199067d1", "message": "Resolving a bug when remote node is behind a private network\n\nBackground :\n\ngetOrConnect method tries to open a connection to an\naddress only once. It should never open a second connection\nto a member. To achieve that we are using the remote address\nof a connection as the source of truth. The remote address is the\none in the member list for members.\n\nIf the member is using private-addresses on a closed network,\nthe client can not use that address on its config to connect that member.\nSo we have two addresses to define single member on the client side.\n\nHow bug happens:\n\nWhen client is already connected to members, it could be the case that\nall connections are dropped temporarily. In that case, we trigger\n`doConnectToCandidateCluster` logic. It connects to a random address\nprovided in the config. This one can use `public address` of the member.\n\nIn the meantime, we have a periodic task `ConnectToAllClusterMembersTask`\nthat tries to connect to all members in the latest known memberlist.\nThis one uses the remote address which is the  `private address`\n\nBoth of them uses `getOrConnect` and `doConnectToCandidateCluster`\ncan open a second connection while a first one is already there.\nNote that some of our other services rely on single connection per member\nlogic.\n\nHow to fix:\n1. `uuid` will be used  as the source of truth.\nThis means what we can not know the uuid of a connection before opening\na connection first. We will allow opening connections paralelly from\n`doConnectToCandidateCluster` path. As soon as a response returned from the\nserver(with uuid), we check if a connection is already there and close\nthe new connection before putting it in `activeConnection`.\n\nPeriodic `ConnectToAllClusterMembersTask` will not try to connect\nan already connected member.And it will use `uuid` to decide that.\n\n2. This two paths will not use same method `getOrConnect` to simplify\nthe logic. One will based on address and the other only uuid to\nmake the intent clear.\n\nTest:\nI could not write a unit test because this requires an inaccessible\nprivate network behind a public address.", "committedDate": "2020-11-24T13:16:43Z", "type": "commit"}, {"oid": "858d40ecfe1ab85d8d749c6713c1b9ab199067d1", "url": "https://github.com/hazelcast/hazelcast/commit/858d40ecfe1ab85d8d749c6713c1b9ab199067d1", "message": "Resolving a bug when remote node is behind a private network\n\nBackground :\n\ngetOrConnect method tries to open a connection to an\naddress only once. It should never open a second connection\nto a member. To achieve that we are using the remote address\nof a connection as the source of truth. The remote address is the\none in the member list for members.\n\nIf the member is using private-addresses on a closed network,\nthe client can not use that address on its config to connect that member.\nSo we have two addresses to define single member on the client side.\n\nHow bug happens:\n\nWhen client is already connected to members, it could be the case that\nall connections are dropped temporarily. In that case, we trigger\n`doConnectToCandidateCluster` logic. It connects to a random address\nprovided in the config. This one can use `public address` of the member.\n\nIn the meantime, we have a periodic task `ConnectToAllClusterMembersTask`\nthat tries to connect to all members in the latest known memberlist.\nThis one uses the remote address which is the  `private address`\n\nBoth of them uses `getOrConnect` and `doConnectToCandidateCluster`\ncan open a second connection while a first one is already there.\nNote that some of our other services rely on single connection per member\nlogic.\n\nHow to fix:\n1. `uuid` will be used  as the source of truth.\nThis means what we can not know the uuid of a connection before opening\na connection first. We will allow opening connections paralelly from\n`doConnectToCandidateCluster` path. As soon as a response returned from the\nserver(with uuid), we check if a connection is already there and close\nthe new connection before putting it in `activeConnection`.\n\nPeriodic `ConnectToAllClusterMembersTask` will not try to connect\nan already connected member.And it will use `uuid` to decide that.\n\n2. This two paths will not use same method `getOrConnect` to simplify\nthe logic. One will based on address and the other only uuid to\nmake the intent clear.\n\nTest:\nI could not write a unit test because this requires an inaccessible\nprivate network behind a public address.", "committedDate": "2020-11-24T13:16:43Z", "type": "forcePushed"}]}