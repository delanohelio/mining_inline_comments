{"pr_number": 17183, "pr_title": "Add basic SQL expressions support", "pr_createdAt": "2020-07-06T15:49:00Z", "pr_url": "https://github.com/hazelcast/hazelcast/pull/17183", "timeline": [{"oid": "0ba198ab0e0150adbca98ed24210b1ed145cc636", "url": "https://github.com/hazelcast/hazelcast/commit/0ba198ab0e0150adbca98ed24210b1ed145cc636", "message": "simplify asserts\n\nCo-authored-by: Viliam Durina <viliam-durina@users.noreply.github.com>", "committedDate": "2020-08-11T12:43:37Z", "type": "commit"}, {"oid": "826a52c3a017e21254e8a59bda5228fb5063f278", "url": "https://github.com/hazelcast/hazelcast/commit/826a52c3a017e21254e8a59bda5228fb5063f278", "message": "simplify CASE rewriting", "committedDate": "2020-08-11T12:43:37Z", "type": "commit"}, {"oid": "2cdd96adf606b599e3e19611b2ca02e81598f754", "url": "https://github.com/hazelcast/hazelcast/commit/2cdd96adf606b599e3e19611b2ca02e81598f754", "message": "use IdentityHashMap instead of HashMap for node type tracking", "committedDate": "2020-08-11T12:43:37Z", "type": "commit"}, {"oid": "ae86c3122d8e1b55b7a0055fc6aa1f2f66b3c1d5", "url": "https://github.com/hazelcast/hazelcast/commit/ae86c3122d8e1b55b7a0055fc6aa1f2f66b3c1d5", "message": "simplify javadoc wording\n\nCo-authored-by: Viliam Durina <viliam-durina@users.noreply.github.com>", "committedDate": "2020-08-11T12:43:37Z", "type": "commit"}, {"oid": "f5765c88ab53240721dbfa3cbc5d48234c1d218f", "url": "https://github.com/hazelcast/hazelcast/commit/f5765c88ab53240721dbfa3cbc5d48234c1d218f", "message": "check for edge case values in ConvertersTest for double and float", "committedDate": "2020-08-11T12:43:37Z", "type": "commit"}, {"oid": "2ad02e79ebe38a2c94e0b9fdd4f299a0e0ca476e", "url": "https://github.com/hazelcast/hazelcast/commit/2ad02e79ebe38a2c94e0b9fdd4f299a0e0ca476e", "message": "add more details to parameter conversion exception", "committedDate": "2020-08-11T12:43:37Z", "type": "commit"}, {"oid": "f4ffb4baa6712a6995f66e2b405d60a225d698bc", "url": "https://github.com/hazelcast/hazelcast/commit/f4ffb4baa6712a6995f66e2b405d60a225d698bc", "message": "make toDecimal conversion faster", "committedDate": "2020-08-11T12:43:37Z", "type": "commit"}, {"oid": "9622df65a60ef773dfda9d8556e43f942615b574", "url": "https://github.com/hazelcast/hazelcast/commit/9622df65a60ef773dfda9d8556e43f942615b574", "message": "change rounding mode to HALF_UP", "committedDate": "2020-08-11T12:43:38Z", "type": "commit"}, {"oid": "e29fd56f6cf0201e27c780874bd3962872c8d837", "url": "https://github.com/hazelcast/hazelcast/commit/e29fd56f6cf0201e27c780874bd3962872c8d837", "message": "expand javadoc on DECIMAL_MATH_CONTEXT", "committedDate": "2020-08-11T12:43:38Z", "type": "commit"}, {"oid": "74852892d3a65d18aa6eeb9cb29971ff44b0e990", "url": "https://github.com/hazelcast/hazelcast/commit/74852892d3a65d18aa6eeb9cb29971ff44b0e990", "message": "mention \"numeric\" in overflow error messages", "committedDate": "2020-08-11T12:43:38Z", "type": "commit"}, {"oid": "46f1731041351c1741dac8b5d1657e8f10bcb17b", "url": "https://github.com/hazelcast/hazelcast/commit/46f1731041351c1741dac8b5d1657e8f10bcb17b", "message": "add UDT for OBJECT as an alias for ANY and disallow direct use of ANY", "committedDate": "2020-08-11T12:43:38Z", "type": "commit"}, {"oid": "350d6d8688893778ee7439463a694eb05107455b", "url": "https://github.com/hazelcast/hazelcast/commit/350d6d8688893778ee7439463a694eb05107455b", "message": "add comments on overflow detection in float and double converters", "committedDate": "2020-08-11T12:43:38Z", "type": "commit"}, {"oid": "032c6f70bc6397cee1bd22fc42059f10ef34a05c", "url": "https://github.com/hazelcast/hazelcast/commit/032c6f70bc6397cee1bd22fc42059f10ef34a05c", "message": "document possible values of NULL type", "committedDate": "2020-08-11T12:43:38Z", "type": "commit"}, {"oid": "f65c6c1252574806022ec6d6a093dbf63e4c6c7c", "url": "https://github.com/hazelcast/hazelcast/commit/f65c6c1252574806022ec6d6a093dbf63e4c6c7c", "message": "fix hashCode", "committedDate": "2020-08-11T12:43:38Z", "type": "commit"}, {"oid": "d90a606693da537cad5699bc120862a6c7717322", "url": "https://github.com/hazelcast/hazelcast/commit/d90a606693da537cad5699bc120862a6c7717322", "message": "verify return types after conversion", "committedDate": "2020-08-11T12:43:38Z", "type": "commit"}, {"oid": "0dd24552cf8438aa8aa0a474d0fd0ef0881e71be", "url": "https://github.com/hazelcast/hazelcast/commit/0dd24552cf8438aa8aa0a474d0fd0ef0881e71be", "message": "literal end-to-end tests", "committedDate": "2020-08-11T12:43:38Z", "type": "commit"}, {"oid": "01bfa3e4d92413747dde9eed7bebffb209eaef11", "url": "https://github.com/hazelcast/hazelcast/commit/01bfa3e4d92413747dde9eed7bebffb209eaef11", "message": "parameter end-to-end test", "committedDate": "2020-08-11T12:43:39Z", "type": "commit"}, {"oid": "3617986802b14265dd71d48db72d4f959d0bfad8", "url": "https://github.com/hazelcast/hazelcast/commit/3617986802b14265dd71d48db72d4f959d0bfad8", "message": "column expression end-to-end tests", "committedDate": "2020-08-11T12:43:39Z", "type": "commit"}, {"oid": "aac21d4f61c4b81bb264ce358bf1b9bb7753cd2b", "url": "https://github.com/hazelcast/hazelcast/commit/aac21d4f61c4b81bb264ce358bf1b9bb7753cd2b", "message": "cast expression end-to-end test", "committedDate": "2020-08-11T12:43:39Z", "type": "commit"}, {"oid": "452e431632d85dcf275b836692303c1ae97e6170", "url": "https://github.com/hazelcast/hazelcast/commit/452e431632d85dcf275b836692303c1ae97e6170", "message": "proper name for cast end-to-end test", "committedDate": "2020-08-11T12:43:39Z", "type": "commit"}, {"oid": "ae76893b76c855f16a76d2d413a370dbe427230a", "url": "https://github.com/hazelcast/hazelcast/commit/ae76893b76c855f16a76d2d413a370dbe427230a", "message": "plus end-to-end test", "committedDate": "2020-08-11T12:43:39Z", "type": "commit"}, {"oid": "23a3fbd49d39a52b53e174a6444ee811e44b6934", "url": "https://github.com/hazelcast/hazelcast/commit/23a3fbd49d39a52b53e174a6444ee811e44b6934", "message": "port 83996e1313ddc8d80991e1bb3068d86cee30e599", "committedDate": "2020-08-11T12:43:39Z", "type": "commit"}, {"oid": "4654afd0ef5d35138d273cbe2caadac527b30bbe", "url": "https://github.com/hazelcast/hazelcast/commit/4654afd0ef5d35138d273cbe2caadac527b30bbe", "message": "test non-canonical parameters", "committedDate": "2020-08-11T12:43:40Z", "type": "commit"}, {"oid": "f68c2d5d4f0783440b6aefeb10d1f9f9ceab2d21", "url": "https://github.com/hazelcast/hazelcast/commit/f68c2d5d4f0783440b6aefeb10d1f9f9ceab2d21", "message": "minsu end-to-end test", "committedDate": "2020-08-11T12:43:40Z", "type": "commit"}, {"oid": "63b9451b714a1f139452bded8a80121a796631dc", "url": "https://github.com/hazelcast/hazelcast/commit/63b9451b714a1f139452bded8a80121a796631dc", "message": "add HZ OBJECT type + remove unneeded tests", "committedDate": "2020-08-11T12:43:40Z", "type": "commit"}, {"oid": "3d642bd1c926b3e545526f5a27d2da2ea0de085d", "url": "https://github.com/hazelcast/hazelcast/commit/3d642bd1c926b3e545526f5a27d2da2ea0de085d", "message": "assign OBJECT type to parameters of IS [NOT] NULL", "committedDate": "2020-08-11T12:43:40Z", "type": "commit"}, {"oid": "a7d6f93f63c498bf64e6cee961681c21d5e40722", "url": "https://github.com/hazelcast/hazelcast/commit/a7d6f93f63c498bf64e6cee961681c21d5e40722", "message": "simplify if-assert logic in ConstantExpression", "committedDate": "2020-08-11T12:43:40Z", "type": "commit"}, {"oid": "40bb767eed1a76052d4d2a8c9e77a1c5abdcc36d", "url": "https://github.com/hazelcast/hazelcast/commit/40bb767eed1a76052d4d2a8c9e77a1c5abdcc36d", "message": "move InvalidExpressionTest tests to ParserOperationsTest", "committedDate": "2020-08-11T12:43:40Z", "type": "commit"}, {"oid": "31c85affa8c760fdd22d86aa1fb4d1a67c3e4351", "url": "https://github.com/hazelcast/hazelcast/commit/31c85affa8c760fdd22d86aa1fb4d1a67c3e4351", "message": "remove temporal types support from RexToExpression", "committedDate": "2020-08-11T12:43:40Z", "type": "commit"}, {"oid": "190a854f4eb7a7fd868124c00be29962b830df4b", "url": "https://github.com/hazelcast/hazelcast/commit/190a854f4eb7a7fd868124c00be29962b830df4b", "message": "remove temporal types support from UnsupportedOperationVisitor", "committedDate": "2020-08-11T12:43:40Z", "type": "commit"}, {"oid": "b54b2a93ee3be5422253836d86365b0357990363", "url": "https://github.com/hazelcast/hazelcast/commit/b54b2a93ee3be5422253836d86365b0357990363", "message": "document how exactly our behavior differs from Calcite", "committedDate": "2020-08-11T12:43:40Z", "type": "commit"}, {"oid": "683795c7ffc19b4842d7357434ee1f727b01c08e", "url": "https://github.com/hazelcast/hazelcast/commit/683795c7ffc19b4842d7357434ee1f727b01c08e", "message": "clarify the purpose of HazelcastOperatorTableVisitor", "committedDate": "2020-08-11T12:43:41Z", "type": "commit"}, {"oid": "196a087a4f51d9042a5080457d8cb150f2dbb4d1", "url": "https://github.com/hazelcast/hazelcast/commit/196a087a4f51d9042a5080457d8cb150f2dbb4d1", "message": "fix monotonicity for HazelcastSqlBinaryOperator", "committedDate": "2020-08-11T12:43:41Z", "type": "commit"}, {"oid": "8690fb9d606d4a9d2d85cacf9aa9a2cd4150d7f7", "url": "https://github.com/hazelcast/hazelcast/commit/8690fb9d606d4a9d2d85cacf9aa9a2cd4150d7f7", "message": "remove useless null logic for 'else' result of CaseExpression", "committedDate": "2020-08-11T12:43:41Z", "type": "commit"}, {"oid": "e5f70630bf872e146dfcc27ce28cf4890e28e7f9", "url": "https://github.com/hazelcast/hazelcast/commit/e5f70630bf872e146dfcc27ce28cf4890e28e7f9", "message": "opimize away synthetic CASTs", "committedDate": "2020-08-11T12:43:41Z", "type": "commit"}, {"oid": "7e81d393bcd4d28d1decbec8d1b2414d0e322c2d", "url": "https://github.com/hazelcast/hazelcast/commit/7e81d393bcd4d28d1decbec8d1b2414d0e322c2d", "message": "clarify the purpose of HazelcastSqlValidator.knownNodeTypes", "committedDate": "2020-08-11T12:43:41Z", "type": "commit"}, {"oid": "1a01f204b9b715c2a8656d3450b168c96889d75e", "url": "https://github.com/hazelcast/hazelcast/commit/1a01f204b9b715c2a8656d3450b168c96889d75e", "message": "remove type ineference for offset-limit", "committedDate": "2020-08-11T12:43:41Z", "type": "commit"}, {"oid": "05faf0864dafae68156bda42723eced832e0510e", "url": "https://github.com/hazelcast/hazelcast/commit/05faf0864dafae68156bda42723eced832e0510e", "message": "remove DDL", "committedDate": "2020-08-11T12:43:41Z", "type": "commit"}, {"oid": "84feba0499fcd9cdf6efc0e1727ceac0a23d99d4", "url": "https://github.com/hazelcast/hazelcast/commit/84feba0499fcd9cdf6efc0e1727ceac0a23d99d4", "message": "clarify rewtiting", "committedDate": "2020-08-11T12:43:41Z", "type": "commit"}, {"oid": "ea483ee33ee089b8770168f87d5824fe5441a6f6", "url": "https://github.com/hazelcast/hazelcast/commit/ea483ee33ee089b8770168f87d5824fe5441a6f6", "message": "support exact and approximate floating point literals", "committedDate": "2020-08-11T12:43:41Z", "type": "commit"}, {"oid": "9571edf300ea1a97fac9a5f62942a5202ff1ddb9", "url": "https://github.com/hazelcast/hazelcast/commit/9571edf300ea1a97fac9a5f62942a5202ff1ddb9", "message": "remove unused import", "committedDate": "2020-08-11T12:43:42Z", "type": "commit"}, {"oid": "00ad4708074fb1ae51ef69f26d0bea6e8c82bff1", "url": "https://github.com/hazelcast/hazelcast/commit/00ad4708074fb1ae51ef69f26d0bea6e8c82bff1", "message": "remove dead code", "committedDate": "2020-08-11T12:43:42Z", "type": "commit"}, {"oid": "8c7129166ef03edcdb3c9c75b4a038f4b78869a4", "url": "https://github.com/hazelcast/hazelcast/commit/8c7129166ef03edcdb3c9c75b4a038f4b78869a4", "message": "remove dead code", "committedDate": "2020-08-11T12:43:42Z", "type": "commit"}, {"oid": "5737897a8557649b70d6ae799ded85c4d88ae6a1", "url": "https://github.com/hazelcast/hazelcast/commit/5737897a8557649b70d6ae799ded85c4d88ae6a1", "message": "rename INT to INTEGER", "committedDate": "2020-08-11T12:43:42Z", "type": "commit"}, {"oid": "c6372dff050bb2f3f1f2725cf656a165b1881b6c", "url": "https://github.com/hazelcast/hazelcast/commit/c6372dff050bb2f3f1f2725cf656a165b1881b6c", "message": "fix a typo", "committedDate": "2020-08-11T12:43:42Z", "type": "commit"}, {"oid": "98edf085ecaf6ce27216d4113de555f11d84335a", "url": "https://github.com/hazelcast/hazelcast/commit/98edf085ecaf6ce27216d4113de555f11d84335a", "message": "rebase and fix compilation errors", "committedDate": "2020-08-11T12:43:42Z", "type": "commit"}, {"oid": "7ac530fe4ea3fdd1ad8a5610171441284ef32506", "url": "https://github.com/hazelcast/hazelcast/commit/7ac530fe4ea3fdd1ad8a5610171441284ef32506", "message": "simplify BiExpressionWithType.equals", "committedDate": "2020-08-11T12:43:42Z", "type": "commit"}, {"oid": "f09814a0ecadbe3820b781ac44783f0dcfcd28fd", "url": "https://github.com/hazelcast/hazelcast/commit/f09814a0ecadbe3820b781ac44783f0dcfcd28fd", "message": "avoid hardcoded operator precedence", "committedDate": "2020-08-11T12:43:42Z", "type": "commit"}, {"oid": "a8ee75a995e29dd2ff7f7b1024e3578dff5981d1", "url": "https://github.com/hazelcast/hazelcast/commit/a8ee75a995e29dd2ff7f7b1024e3578dff5981d1", "message": "document NULL type", "committedDate": "2020-08-11T12:43:42Z", "type": "commit"}, {"oid": "1fecec42622a3a5ad8a5ba4b41fcf6f9b41503af", "url": "https://github.com/hazelcast/hazelcast/commit/1fecec42622a3a5ad8a5ba4b41fcf6f9b41503af", "message": "catch more exceptions during parameter conversion", "committedDate": "2020-08-11T12:43:42Z", "type": "commit"}, {"oid": "00e59bbefd1cdb74950fd1a141c0b0930f1b86aa", "url": "https://github.com/hazelcast/hazelcast/commit/00e59bbefd1cdb74950fd1a141c0b0930f1b86aa", "message": "more precise error messages", "committedDate": "2020-08-11T12:43:43Z", "type": "commit"}, {"oid": "413526ab68c0a677105d0869c47d9ddf24c3276f", "url": "https://github.com/hazelcast/hazelcast/commit/413526ab68c0a677105d0869c47d9ddf24c3276f", "message": "more detailed error messages for arithmetic operators", "committedDate": "2020-08-11T12:43:43Z", "type": "commit"}, {"oid": "5409eca7502ece5e69ea92279e885431955e810e", "url": "https://github.com/hazelcast/hazelcast/commit/5409eca7502ece5e69ea92279e885431955e810e", "message": "more detailed error messages", "committedDate": "2020-08-11T12:43:43Z", "type": "commit"}, {"oid": "7b6159d344703bdda317fd2f675320b96a677969", "url": "https://github.com/hazelcast/hazelcast/commit/7b6159d344703bdda317fd2f675320b96a677969", "message": "more precise bit width calculation", "committedDate": "2020-08-11T12:43:43Z", "type": "commit"}, {"oid": "53fd6bbbc74702110eb61ad4cff9a80d6be9b631", "url": "https://github.com/hazelcast/hazelcast/commit/53fd6bbbc74702110eb61ad4cff9a80d6be9b631", "message": "test standalone parameter", "committedDate": "2020-08-11T12:43:43Z", "type": "commit"}, {"oid": "8d10d2bb0c27cce8675022c5e52a3e514d1021d6", "url": "https://github.com/hazelcast/hazelcast/commit/8d10d2bb0c27cce8675022c5e52a3e514d1021d6", "message": "more detailed parameter conversion error message", "committedDate": "2020-08-11T12:43:43Z", "type": "commit"}, {"oid": "3af9fc7778ead880e2834bfaf036e0376846a1a5", "url": "https://github.com/hazelcast/hazelcast/commit/3af9fc7778ead880e2834bfaf036e0376846a1a5", "message": "add multiply end-to-end test", "committedDate": "2020-08-11T12:43:43Z", "type": "commit"}, {"oid": "8d39f010a5cced023ed897ecab46da32b64aedbb", "url": "https://github.com/hazelcast/hazelcast/commit/8d39f010a5cced023ed897ecab46da32b64aedbb", "message": "add divide end-to-end test", "committedDate": "2020-08-11T12:43:43Z", "type": "commit"}, {"oid": "6dcda63a3b6d4fabb0500435bb52f3bb8ecfe587", "url": "https://github.com/hazelcast/hazelcast/commit/6dcda63a3b6d4fabb0500435bb52f3bb8ecfe587", "message": "add unary plus end-to-end test", "committedDate": "2020-08-11T12:43:44Z", "type": "commit"}, {"oid": "d88efcd37f3ca342174d1f080be460b288a76f4d", "url": "https://github.com/hazelcast/hazelcast/commit/d88efcd37f3ca342174d1f080be460b288a76f4d", "message": "add unary minus end-to-end test", "committedDate": "2020-08-11T12:43:44Z", "type": "commit"}, {"oid": "02fdd8fd63a7ffa3c867e7c4f0480aeb32bea11c", "url": "https://github.com/hazelcast/hazelcast/commit/02fdd8fd63a7ffa3c867e7c4f0480aeb32bea11c", "message": "test for BigInteger in unary plus and minus tests", "committedDate": "2020-08-11T12:43:44Z", "type": "commit"}, {"oid": "0e2d056d9213c5e9f22774338c92a9b03072d58c", "url": "https://github.com/hazelcast/hazelcast/commit/0e2d056d9213c5e9f22774338c92a9b03072d58c", "message": "improve type system docs", "committedDate": "2020-08-11T12:43:44Z", "type": "commit"}, {"oid": "6445dd5ec40fb914cf170f8aaa7b6b5f04f3681e", "url": "https://github.com/hazelcast/hazelcast/commit/6445dd5ec40fb914cf170f8aaa7b6b5f04f3681e", "message": "document edge case values for HazelcastIntegerType", "committedDate": "2020-08-11T12:43:44Z", "type": "commit"}, {"oid": "0f4a3a8ddd8d0f8718ef68ae6a05c25a5f509409", "url": "https://github.com/hazelcast/hazelcast/commit/0f4a3a8ddd8d0f8718ef68ae6a05c25a5f509409", "message": "remove values from error messages + test for more values in case test", "committedDate": "2020-08-11T12:43:44Z", "type": "commit"}, {"oid": "a1f6135b32558453e010cda651b7cae4f319b479", "url": "https://github.com/hazelcast/hazelcast/commit/a1f6135b32558453e010cda651b7cae4f319b479", "message": "remove case", "committedDate": "2020-08-11T12:43:44Z", "type": "commit"}, {"oid": "386eb743f6550a106bfb9babdf82fc3779ff6fa6", "url": "https://github.com/hazelcast/hazelcast/commit/386eb743f6550a106bfb9babdf82fc3779ff6fa6", "message": "remove case part #2", "committedDate": "2020-08-11T12:43:44Z", "type": "commit"}, {"oid": "d6f3eae722fc375debc4700be52ee78deb5b6572", "url": "https://github.com/hazelcast/hazelcast/commit/d6f3eae722fc375debc4700be52ee78deb5b6572", "message": "better division by zero for floats and doubles", "committedDate": "2020-08-11T12:43:44Z", "type": "commit"}, {"oid": "d6f3eae722fc375debc4700be52ee78deb5b6572", "url": "https://github.com/hazelcast/hazelcast/commit/d6f3eae722fc375debc4700be52ee78deb5b6572", "message": "better division by zero for floats and doubles", "committedDate": "2020-08-11T12:43:44Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDkxNTE5NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r450915195", "bodyText": "XXX?", "author": "viliam-durina", "createdAt": "2020-07-07T14:37:55Z", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/HazelcastRexBuilder.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite;\n+\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastIntegerType;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeFactory;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rel.type.RelDataTypeFactory;\n+import org.apache.calcite.rex.RexBuilder;\n+import org.apache.calcite.rex.RexNode;\n+\n+import static org.apache.calcite.sql.type.SqlTypeName.ANY;\n+import static org.apache.calcite.sql.type.SqlTypeName.REAL;\n+\n+/**\n+ * Custom Hazelcast expression builder.\n+ * <p>\n+ * Currently, this custom expression builder is used just to workaround quirks\n+ * of the default Calcite expression builder.\n+ */\n+public final class HazelcastRexBuilder extends RexBuilder {\n+\n+    public HazelcastRexBuilder(RelDataTypeFactory typeFactory) {\n+        super(typeFactory);\n+        assert typeFactory instanceof HazelcastTypeFactory;\n+    }\n+\n+    @Override\n+    public RexNode makeLiteral(Object value, RelDataType type, boolean allowCast) {\n+        // XXX: Calcite evaluates casts like CAST(0 AS ANY) statically and", "originalCommit": "8fb741905b091cfa877a05823a92b6d7175df389", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM4MDg5MA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r451380890", "bodyText": "Probably it's not that common, but usually it's used to mark some hackish code, Wikipedia describes it as: \"warn other programmers of problematic or misguiding code\".", "author": "taburet", "createdAt": "2020-07-08T08:42:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDkxNTE5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDkzMTI1Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r450931253", "bodyText": "We can have the case CHAR: just before the default:, this comment is easier to miss.", "author": "viliam-durina", "createdAt": "2020-07-07T14:58:54Z", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/parse/UnsupportedOperationVisitor.java", "diffHunk": "@@ -106,16 +125,46 @@ public Void visit(SqlIdentifier id) {\n         return null;\n     }\n \n+    @SuppressWarnings(\"checkstyle:CyclomaticComplexity\")\n     @Override\n     public Void visit(SqlDataTypeSpec type) {\n-        throw error(type, RESOURCE.custom(\"Type specification is not supported\"));\n+        if (!(type.getTypeNameSpec() instanceof SqlBasicTypeNameSpec)) {\n+            throw error(type, RESOURCE.custom(\"Complex type specifications are not supported\"));\n+        }\n+\n+        SqlTypeName typeName = SqlTypeName.get(type.getTypeName().getSimple());\n+        switch (typeName) {\n+            case BOOLEAN:\n+            case TINYINT:\n+            case SMALLINT:\n+            case INTEGER:\n+            case BIGINT:\n+            case DECIMAL:\n+            case REAL:\n+            case DOUBLE:\n+            case VARCHAR:\n+            // CHAR is missing here intentionally, to avoid constructs like\n+            // CAST(foo as CHAR).", "originalCommit": "8fb741905b091cfa877a05823a92b6d7175df389", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM5MDQwOQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r451390409", "bodyText": "fixed", "author": "taburet", "createdAt": "2020-07-08T08:57:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDkzMTI1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk0NjEzNQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r450946135", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        assert resolvedOperators.isEmpty() || resolvedOperators.size() == 1;\n          \n          \n            \n            \n          \n          \n            \n                        if (!resolvedOperators.isEmpty()) {\n          \n          \n            \n                            basicCall.setOperator(resolvedOperators.get(0));\n          \n          \n            \n                        }\n          \n          \n            \n            \n          \n          \n            \n                        if (!resolvedOperators.isEmpty()) {\n          \n          \n            \n                            assert resolvedOperators.size() == 1;\n          \n          \n            \n                            basicCall.setOperator(resolvedOperators.get(0));\n          \n          \n            \n                        }", "author": "viliam-durina", "createdAt": "2020-07-07T15:19:04Z", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/HazelcastOperatorTableVisitor.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.validate;\n+\n+import com.hazelcast.sql.impl.calcite.validate.operators.HazelcastSqlCase;\n+import org.apache.calcite.sql.SqlBasicCall;\n+import org.apache.calcite.sql.SqlCall;\n+import org.apache.calcite.sql.SqlNode;\n+import org.apache.calcite.sql.SqlNodeList;\n+import org.apache.calcite.sql.SqlOperator;\n+import org.apache.calcite.sql.fun.SqlCase;\n+import org.apache.calcite.sql.fun.SqlStdOperatorTable;\n+import org.apache.calcite.sql.util.SqlBasicVisitor;\n+import org.apache.calcite.sql.validate.SqlNameMatcher;\n+import org.apache.calcite.sql.validate.SqlNameMatchers;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Rewrites operators in SqlNode tree from Calcite ones to Hazelcast ones.\n+ *\n+ * @see SqlStdOperatorTable\n+ * @see HazelcastSqlOperatorTable\n+ */\n+public final class HazelcastOperatorTableVisitor extends SqlBasicVisitor<Void> {\n+\n+    /**\n+     * Shared Hazelcast operator visitor instance.\n+     */\n+    public static final SqlBasicVisitor<Void> INSTANCE = new HazelcastOperatorTableVisitor();\n+\n+    private static final SqlNameMatcher NAME_MATCHER = SqlNameMatchers.withCaseSensitive(false);\n+\n+    private HazelcastOperatorTableVisitor() {\n+    }\n+\n+    @Override\n+    public Void visit(SqlCall call) {\n+        rewriteCall(call);\n+        return super.visit(call);\n+    }\n+\n+    @Override\n+    public Void visit(SqlNodeList nodeList) {\n+        rewriteNodeList(nodeList);\n+        return super.visit(nodeList);\n+    }\n+\n+    private static void rewriteCall(SqlCall call) {\n+        List<SqlNode> operands = call.getOperandList();\n+        for (int i = 0; i < operands.size(); ++i) {\n+            SqlNode operand = operands.get(i);\n+            if (!(operand instanceof SqlCase) || operand instanceof HazelcastSqlCase) {\n+                continue;\n+            }\n+\n+            SqlCase sqlCase = (SqlCase) operand;\n+            HazelcastSqlCase hazelcastSqlCase =\n+                    new HazelcastSqlCase(sqlCase.getParserPosition(), sqlCase.getValueOperand(), sqlCase.getWhenOperands(),\n+                            sqlCase.getThenOperands(), sqlCase.getElseOperand());\n+            call.setOperand(i, hazelcastSqlCase);\n+        }\n+\n+        if (call instanceof SqlBasicCall) {\n+            SqlBasicCall basicCall = (SqlBasicCall) call;\n+            SqlOperator operator = basicCall.getOperator();\n+\n+            List<SqlOperator> resolvedOperators = new ArrayList<>();\n+            HazelcastSqlOperatorTable.instance().lookupOperatorOverloads(operator.getNameAsId(), null, operator.getSyntax(),\n+                    resolvedOperators, NAME_MATCHER);\n+            assert resolvedOperators.isEmpty() || resolvedOperators.size() == 1;\n+\n+            if (!resolvedOperators.isEmpty()) {\n+                basicCall.setOperator(resolvedOperators.get(0));\n+            }", "originalCommit": "8fb741905b091cfa877a05823a92b6d7175df389", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk1MTEyNw==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r450951127", "bodyText": "The method tryRewriteSqlCase can be reused in rewriteCall:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static void rewriteNodeList(SqlNodeList nodeList) {\n          \n          \n            \n                    for (int i = 0; i < nodeList.size(); ++i) {\n          \n          \n            \n                        SqlNode node = nodeList.get(i);\n          \n          \n            \n                        if (!(node instanceof SqlCase) || node instanceof HazelcastSqlCase) {\n          \n          \n            \n                            continue;\n          \n          \n            \n                        }\n          \n          \n            \n            \n          \n          \n            \n                        SqlCase sqlCase = (SqlCase) node;\n          \n          \n            \n                        HazelcastSqlCase hazelcastSqlCase =\n          \n          \n            \n                                new HazelcastSqlCase(sqlCase.getParserPosition(), sqlCase.getValueOperand(), sqlCase.getWhenOperands(),\n          \n          \n            \n                                        sqlCase.getThenOperands(), sqlCase.getElseOperand());\n          \n          \n            \n                        nodeList.set(i, hazelcastSqlCase);\n          \n          \n            \n                    }\n          \n          \n            \n                }\n          \n          \n            \n                private static void rewriteNodeList(SqlNodeList nodeList) {\n          \n          \n            \n                    for (int i = 0; i < nodeList.size(); ++i) {\n          \n          \n            \n                        nodeList.set(i,\n          \n          \n            \n                                tryRewriteSqlCase(nodeList.get(i)));\n          \n          \n            \n                    }\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                private static SqlNode tryRewriteSqlCase(SqlNode node) {\n          \n          \n            \n                    if (node instanceof SqlCase && !(node instanceof HazelcastSqlCase)) {\n          \n          \n            \n                        SqlCase sqlCase = (SqlCase) node;\n          \n          \n            \n                        HazelcastSqlCase hazelcastSqlCase =\n          \n          \n            \n                                new HazelcastSqlCase(sqlCase.getParserPosition(), sqlCase.getValueOperand(), sqlCase.getWhenOperands(),\n          \n          \n            \n                                        sqlCase.getThenOperands(), sqlCase.getElseOperand());\n          \n          \n            \n            \n          \n          \n            \n                        return hazelcastSqlCase;\n          \n          \n            \n                    }\n          \n          \n            \n            \n          \n          \n            \n                    return node;\n          \n          \n            \n                }", "author": "viliam-durina", "createdAt": "2020-07-07T15:26:06Z", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/HazelcastOperatorTableVisitor.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.validate;\n+\n+import com.hazelcast.sql.impl.calcite.validate.operators.HazelcastSqlCase;\n+import org.apache.calcite.sql.SqlBasicCall;\n+import org.apache.calcite.sql.SqlCall;\n+import org.apache.calcite.sql.SqlNode;\n+import org.apache.calcite.sql.SqlNodeList;\n+import org.apache.calcite.sql.SqlOperator;\n+import org.apache.calcite.sql.fun.SqlCase;\n+import org.apache.calcite.sql.fun.SqlStdOperatorTable;\n+import org.apache.calcite.sql.util.SqlBasicVisitor;\n+import org.apache.calcite.sql.validate.SqlNameMatcher;\n+import org.apache.calcite.sql.validate.SqlNameMatchers;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Rewrites operators in SqlNode tree from Calcite ones to Hazelcast ones.\n+ *\n+ * @see SqlStdOperatorTable\n+ * @see HazelcastSqlOperatorTable\n+ */\n+public final class HazelcastOperatorTableVisitor extends SqlBasicVisitor<Void> {\n+\n+    /**\n+     * Shared Hazelcast operator visitor instance.\n+     */\n+    public static final SqlBasicVisitor<Void> INSTANCE = new HazelcastOperatorTableVisitor();\n+\n+    private static final SqlNameMatcher NAME_MATCHER = SqlNameMatchers.withCaseSensitive(false);\n+\n+    private HazelcastOperatorTableVisitor() {\n+    }\n+\n+    @Override\n+    public Void visit(SqlCall call) {\n+        rewriteCall(call);\n+        return super.visit(call);\n+    }\n+\n+    @Override\n+    public Void visit(SqlNodeList nodeList) {\n+        rewriteNodeList(nodeList);\n+        return super.visit(nodeList);\n+    }\n+\n+    private static void rewriteCall(SqlCall call) {\n+        List<SqlNode> operands = call.getOperandList();\n+        for (int i = 0; i < operands.size(); ++i) {\n+            SqlNode operand = operands.get(i);\n+            if (!(operand instanceof SqlCase) || operand instanceof HazelcastSqlCase) {\n+                continue;\n+            }\n+\n+            SqlCase sqlCase = (SqlCase) operand;\n+            HazelcastSqlCase hazelcastSqlCase =\n+                    new HazelcastSqlCase(sqlCase.getParserPosition(), sqlCase.getValueOperand(), sqlCase.getWhenOperands(),\n+                            sqlCase.getThenOperands(), sqlCase.getElseOperand());\n+            call.setOperand(i, hazelcastSqlCase);\n+        }\n+\n+        if (call instanceof SqlBasicCall) {\n+            SqlBasicCall basicCall = (SqlBasicCall) call;\n+            SqlOperator operator = basicCall.getOperator();\n+\n+            List<SqlOperator> resolvedOperators = new ArrayList<>();\n+            HazelcastSqlOperatorTable.instance().lookupOperatorOverloads(operator.getNameAsId(), null, operator.getSyntax(),\n+                    resolvedOperators, NAME_MATCHER);\n+            assert resolvedOperators.isEmpty() || resolvedOperators.size() == 1;\n+\n+            if (!resolvedOperators.isEmpty()) {\n+                basicCall.setOperator(resolvedOperators.get(0));\n+            }\n+        }\n+    }\n+\n+    private static void rewriteNodeList(SqlNodeList nodeList) {\n+        for (int i = 0; i < nodeList.size(); ++i) {\n+            SqlNode node = nodeList.get(i);\n+            if (!(node instanceof SqlCase) || node instanceof HazelcastSqlCase) {\n+                continue;\n+            }\n+\n+            SqlCase sqlCase = (SqlCase) node;\n+            HazelcastSqlCase hazelcastSqlCase =\n+                    new HazelcastSqlCase(sqlCase.getParserPosition(), sqlCase.getValueOperand(), sqlCase.getWhenOperands(),\n+                            sqlCase.getThenOperands(), sqlCase.getElseOperand());\n+            nodeList.set(i, hazelcastSqlCase);\n+        }\n+    }", "originalCommit": "8fb741905b091cfa877a05823a92b6d7175df389", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM5ODY2OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r451398669", "bodyText": "fixed", "author": "taburet", "createdAt": "2020-07-08T09:11:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk1MTEyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk1NTA3MA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r450955070", "bodyText": "SqlNode doesn't implement hashCode, it might be better to use IdentityHashMap to show the intent.", "author": "viliam-durina", "createdAt": "2020-07-07T15:31:35Z", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/HazelcastSqlValidator.java", "diffHunk": "@@ -17,53 +17,284 @@\n package com.hazelcast.sql.impl.calcite.validate;\n \n import com.hazelcast.sql.impl.calcite.schema.HazelcastTable;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastIntegerType;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeCoercion;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeFactory;\n import org.apache.calcite.rel.type.RelDataType;\n-import org.apache.calcite.rel.type.RelDataTypeFactory;\n import org.apache.calcite.sql.SqlCall;\n import org.apache.calcite.sql.SqlIdentifier;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.SqlLiteral;\n import org.apache.calcite.sql.SqlNode;\n import org.apache.calcite.sql.SqlOperatorTable;\n+import org.apache.calcite.sql.SqlSelect;\n+import org.apache.calcite.sql.SqlUtil;\n+import org.apache.calcite.sql.type.SqlTypeName;\n import org.apache.calcite.sql.validate.SelectScope;\n import org.apache.calcite.sql.validate.SqlConformance;\n import org.apache.calcite.sql.validate.SqlQualified;\n import org.apache.calcite.sql.validate.SqlValidatorCatalogReader;\n import org.apache.calcite.sql.validate.SqlValidatorImpl;\n+import org.apache.calcite.sql.validate.SqlValidatorScope;\n import org.apache.calcite.sql.validate.SqlValidatorTable;\n import org.apache.calcite.util.Util;\n \n+import java.math.BigDecimal;\n+import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n+import static com.hazelcast.sql.impl.calcite.validate.SqlNodeUtil.isLiteral;\n+import static com.hazelcast.sql.impl.calcite.validate.SqlNodeUtil.isParameter;\n+import static com.hazelcast.sql.impl.calcite.validate.SqlNodeUtil.numericValue;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.canRepresent;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.isInteger;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.isNumeric;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.narrowestTypeFor;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.typeName;\n+import static org.apache.calcite.sql.type.SqlTypeName.CHAR;\n+import static org.apache.calcite.sql.type.SqlTypeName.DECIMAL;\n+import static org.apache.calcite.sql.type.SqlTypeName.DOUBLE;\n+import static org.apache.calcite.sql.type.SqlTypeName.NULL;\n+import static org.apache.calcite.sql.type.SqlTypeName.NUMERIC_TYPES;\n+import static org.apache.calcite.sql.type.SqlTypeName.VARCHAR;\n+import static org.apache.calcite.util.Static.RESOURCE;\n+\n /**\n  * Hazelcast-specific SQL validator.\n  */\n public class HazelcastSqlValidator extends SqlValidatorImpl {\n-    public HazelcastSqlValidator(\n-        SqlOperatorTable opTab,\n-        SqlValidatorCatalogReader catalogReader,\n-        RelDataTypeFactory typeFactory,\n-        SqlConformance conformance\n-    ) {\n-        super(opTab, catalogReader, typeFactory, Config.DEFAULT.withSqlConformance(conformance));\n+\n+    private static final Config CONFIG = Config.DEFAULT.withIdentifierExpansion(true);\n+\n+    private final Map<SqlNode, RelDataType> knownNodeTypes = new HashMap<>();", "originalCommit": "8fb741905b091cfa877a05823a92b6d7175df389", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQwMTQzOQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r451401439", "bodyText": "fixed", "author": "taburet", "createdAt": "2020-07-08T09:16:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk1NTA3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk1NjQ1Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r450956453", "bodyText": "Took me a while to get this comment, this might be better:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Sets a known type of the given node to the given type in this validator.\n          \n          \n            \n                 * Sets {@code type} as the known type for {@code node}.", "author": "viliam-durina", "createdAt": "2020-07-07T15:33:34Z", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/HazelcastSqlValidator.java", "diffHunk": "@@ -17,53 +17,284 @@\n package com.hazelcast.sql.impl.calcite.validate;\n \n import com.hazelcast.sql.impl.calcite.schema.HazelcastTable;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastIntegerType;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeCoercion;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeFactory;\n import org.apache.calcite.rel.type.RelDataType;\n-import org.apache.calcite.rel.type.RelDataTypeFactory;\n import org.apache.calcite.sql.SqlCall;\n import org.apache.calcite.sql.SqlIdentifier;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.SqlLiteral;\n import org.apache.calcite.sql.SqlNode;\n import org.apache.calcite.sql.SqlOperatorTable;\n+import org.apache.calcite.sql.SqlSelect;\n+import org.apache.calcite.sql.SqlUtil;\n+import org.apache.calcite.sql.type.SqlTypeName;\n import org.apache.calcite.sql.validate.SelectScope;\n import org.apache.calcite.sql.validate.SqlConformance;\n import org.apache.calcite.sql.validate.SqlQualified;\n import org.apache.calcite.sql.validate.SqlValidatorCatalogReader;\n import org.apache.calcite.sql.validate.SqlValidatorImpl;\n+import org.apache.calcite.sql.validate.SqlValidatorScope;\n import org.apache.calcite.sql.validate.SqlValidatorTable;\n import org.apache.calcite.util.Util;\n \n+import java.math.BigDecimal;\n+import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n+import static com.hazelcast.sql.impl.calcite.validate.SqlNodeUtil.isLiteral;\n+import static com.hazelcast.sql.impl.calcite.validate.SqlNodeUtil.isParameter;\n+import static com.hazelcast.sql.impl.calcite.validate.SqlNodeUtil.numericValue;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.canRepresent;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.isInteger;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.isNumeric;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.narrowestTypeFor;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.typeName;\n+import static org.apache.calcite.sql.type.SqlTypeName.CHAR;\n+import static org.apache.calcite.sql.type.SqlTypeName.DECIMAL;\n+import static org.apache.calcite.sql.type.SqlTypeName.DOUBLE;\n+import static org.apache.calcite.sql.type.SqlTypeName.NULL;\n+import static org.apache.calcite.sql.type.SqlTypeName.NUMERIC_TYPES;\n+import static org.apache.calcite.sql.type.SqlTypeName.VARCHAR;\n+import static org.apache.calcite.util.Static.RESOURCE;\n+\n /**\n  * Hazelcast-specific SQL validator.\n  */\n public class HazelcastSqlValidator extends SqlValidatorImpl {\n-    public HazelcastSqlValidator(\n-        SqlOperatorTable opTab,\n-        SqlValidatorCatalogReader catalogReader,\n-        RelDataTypeFactory typeFactory,\n-        SqlConformance conformance\n-    ) {\n-        super(opTab, catalogReader, typeFactory, Config.DEFAULT.withSqlConformance(conformance));\n+\n+    private static final Config CONFIG = Config.DEFAULT.withIdentifierExpansion(true);\n+\n+    private final Map<SqlNode, RelDataType> knownNodeTypes = new HashMap<>();\n+\n+    public HazelcastSqlValidator(SqlOperatorTable opTab, SqlValidatorCatalogReader catalogReader,\n+                                 HazelcastTypeFactory typeFactory, SqlConformance conformance) {\n+        super(opTab, catalogReader, typeFactory, CONFIG.withSqlConformance(conformance));\n+        setTypeCoercion(new HazelcastTypeCoercion(this));\n+    }\n+\n+    /**\n+     * Sets a known type of the given node to the given type in this validator.", "originalCommit": "8fb741905b091cfa877a05823a92b6d7175df389", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAxNzM3OA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r451017378", "bodyText": "What's this?", "author": "viliam-durina", "createdAt": "2020-07-07T17:09:56Z", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/HazelcastSqlOperatorTable.java", "diffHunk": "@@ -16,13 +16,257 @@\n \n package com.hazelcast.sql.impl.calcite.validate;\n \n+import com.hazelcast.sql.impl.calcite.validate.operators.HazelcastSqlBinaryOperator;\n+import com.hazelcast.sql.impl.calcite.validate.operators.HazelcastSqlCaseOperator;\n+import com.hazelcast.sql.impl.calcite.validate.operators.HazelcastSqlCastFunction;\n+import com.hazelcast.sql.impl.calcite.validate.operators.HazelcastSqlMonotonicBinaryOperator;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastInferTypes;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastOperandTypes;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastReturnTypes;\n+import org.apache.calcite.sql.SqlBinaryOperator;\n+import org.apache.calcite.sql.SqlFunction;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.SqlOperator;\n+import org.apache.calcite.sql.SqlPostfixOperator;\n+import org.apache.calcite.sql.SqlPrefixOperator;\n+import org.apache.calcite.sql.type.InferTypes;\n+import org.apache.calcite.sql.type.OperandTypes;\n+import org.apache.calcite.sql.type.ReturnTypes;\n import org.apache.calcite.sql.util.ReflectiveSqlOperatorTable;\n \n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastOperandTypes.notAllNull;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastOperandTypes.notAny;\n+\n /**\n- * An additional functions that are resolved during query parsing/validation.\n+ * Custom functions and operators.\n  */\n public final class HazelcastSqlOperatorTable extends ReflectiveSqlOperatorTable {\n \n+    //@formatter:off", "originalCommit": "8fb741905b091cfa877a05823a92b6d7175df389", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQwNTE2NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r451405164", "bodyText": "It disables auto formatting for some region of the code. Usually I just auto reformat all the code after refactorings to make sure the formatting is still good. So disabling the auto formatting preserves the manually formatted code fragments.", "author": "taburet", "createdAt": "2020-07-08T09:22:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAxNzM3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTEzODM2OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r451138369", "bodyText": "We test a value that's too big for BIGINT. We should test a value that's too big for TINYINT, that is Byte.MAX_VALUE + 1", "author": "viliam-durina", "createdAt": "2020-07-07T20:56:50Z", "path": "hazelcast/src/test/java/com/hazelcast/sql/impl/type/converter/ConvertersTest.java", "diffHunk": "@@ -313,13 +337,18 @@ public void testDoubleConverter() {\n         checkConverterConversions(converter, VARCHAR, TINYINT, SMALLINT, INT, BIGINT, DECIMAL, REAL, OBJECT);\n \n         double val = 1.1d;\n+        double bigValue = Long.MAX_VALUE * 2.5d;\n \n         assertEquals(\"1.1\", converter.asVarchar(val));\n \n         assertEquals(1, converter.asTinyint(val));\n+        checkDataException(() -> converter.asTinyint(bigValue));", "originalCommit": "8fb741905b091cfa877a05823a92b6d7175df389", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQxMTk5NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r451411995", "bodyText": "fixed", "author": "taburet", "createdAt": "2020-07-08T09:33:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTEzODM2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM0NDU4Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r451344583", "bodyText": "What does CAST X as ANY mean from the user perspective? We do not have ANY type that is exposed to a user, do we?", "author": "devozerov", "createdAt": "2020-07-08T07:40:14Z", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/HazelcastRexBuilder.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite;\n+\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastIntegerType;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeFactory;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rel.type.RelDataTypeFactory;\n+import org.apache.calcite.rex.RexBuilder;\n+import org.apache.calcite.rex.RexNode;\n+\n+import static org.apache.calcite.sql.type.SqlTypeName.ANY;\n+import static org.apache.calcite.sql.type.SqlTypeName.REAL;\n+\n+/**\n+ * Custom Hazelcast expression builder.\n+ * <p>\n+ * Currently, this custom expression builder is used just to workaround quirks\n+ * of the default Calcite expression builder.\n+ */\n+public final class HazelcastRexBuilder extends RexBuilder {\n+\n+    public HazelcastRexBuilder(RelDataTypeFactory typeFactory) {\n+        super(typeFactory);\n+        assert typeFactory instanceof HazelcastTypeFactory;\n+    }\n+\n+    @Override\n+    public RexNode makeLiteral(Object value, RelDataType type, boolean allowCast) {\n+        // XXX: Calcite evaluates casts like CAST(0 AS ANY) statically and", "originalCommit": "a48cce0b0f2034cb9555df84780a00cccdc1c15d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQ0MTA4NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r451441085", "bodyText": "Currently ANY is exposed to users. Honestly, I'm not sure how to implement OBJECT support properly. ANY is the only standard type (SqlTypeName) having the semantics similar to OBJECT, it's actually mapped to java.sql.Types.JAVA_OBJECT by Calcite itself. Yes, it does have a special \"skip-all-checks\" meaning during validation. Probably SQL user defined types may help (not sure how well they are supported by Calcite), but AFAIU user defined types can express a new type only in terms of well-known ones, so internally we need to map it to some existing type having OBJECT semantics. Probably adding a custom RelDataType may resolve that, not sure. This requires research. What exactly you don't like about using ANY, the fact that we refer to it in queries as \"ANY\" and not as \"OBJECT\" or something else?", "author": "taburet", "createdAt": "2020-07-08T10:26:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM0NDU4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQ0NjQ3NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r451446475", "bodyText": "Probably I'm not getting right what the expected semantics of OBJECT actually is. Does it represent an object with nested fields accessible from queries or just a raw Java object?", "author": "taburet", "createdAt": "2020-07-08T10:37:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM0NDU4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjAyMzc4NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452023784", "bodyText": "This is up to us to decide in the scope of this PR because it was not a concern before.\nIn the prototype branch, the original semantics was \"this is an object of some type, I do not know which exactly\". So perhaps ANY is a good candidate. In this case, SqlColumnType should be renamed accordingly.\nOn the other hand, ANY maybe not an ideal fit for DDL, because in other databases ANY counterparts mean it could store anything, while in our case this is definitely not the case - one cannot store arbitrary objects inside the field.\nAdd to this ANSI SQL custom types and the necessity to deal with nested fields in the future, and the problem renders really complex. I doubt we will have the proper solution at the moment because we do no know how to deal with nested fields yet. So maybe ANY is a good starting point for beta. We may change it in future if needed.", "author": "devozerov", "createdAt": "2020-07-09T07:39:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM0NDU4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjA4Njg1Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452086857", "bodyText": "Added a user defined type for OBJECT as an alias to ANY, it's now possible to use OBJECT in queries, ANY is not allowed in queries anymore, but it's still used internally.", "author": "taburet", "createdAt": "2020-07-09T09:28:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM0NDU4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM1NjY3Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r453356673", "bodyText": "Thanks. Will Calcite exceptions SqlCallBinding#newValidationSignatureError show OBJECT now instead of ANY?", "author": "devozerov", "createdAt": "2020-07-12T19:55:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM0NDU4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQzMTI0NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r461431245", "bodyText": "Added a custom Hazelcast OBJECT type in 7fea458, all references to ANY type now should be displayed as OBJECT.", "author": "taburet", "createdAt": "2020-07-28T09:05:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM0NDU4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM2MzAyNg==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r451363026", "bodyText": "This code produces a generic data exception. We will not be able to map it properly to SQLSTATE codes for JDBC in the future. ANSI SQL declares a family of error codes for data exceptions, with numeric value out of range being a special separate code.\nI am not sure that we should introduce many sub-codes for data exception at the moment, because we do not have JDBC. But at the very least the error message should reflect that overflow happened. This is not the case now since we throw an abstract Cannot convert ..., without explaining why the conversion is not possible.\nThis applicable to all numeric converters, not only ShortConverter.", "author": "devozerov", "createdAt": "2020-07-08T08:12:37Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/type/converter/ShortConverter.java", "diffHunk": "@@ -38,7 +40,14 @@ private ShortConverter() {\n \n     @Override\n     public byte asTinyint(Object val) {\n-        return (byte) cast(val);\n+        short casted = cast(val);\n+        byte converted = (byte) casted;\n+\n+        if (converted != casted) {\n+            throw cannotConvert(QueryDataTypeFamily.TINYINT, val);", "originalCommit": "a48cce0b0f2034cb9555df84780a00cccdc1c15d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjAxOTQ5MA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452019490", "bodyText": "fixed", "author": "taburet", "createdAt": "2020-07-09T07:31:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM2MzAyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjAyNTAxNQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452025015", "bodyText": "In other databases, it is often referred to as \"numeric overflow\", to emphasize that we are talking about numbers. SQLSTATE also has the word \"numeric\" AFAIU.\nSo I would propose to add the word \"numeric\" to the exception message as well.", "author": "devozerov", "createdAt": "2020-07-09T07:41:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM2MzAyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjA2MTQ4Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452061483", "bodyText": "fixed", "author": "taburet", "createdAt": "2020-07-09T08:46:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM2MzAyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM2NTQyOA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r451365428", "bodyText": "Is there a specific reason why we picked HALF_DOWN here, and not HALF_UP or HALF_EVEN? Can we have JavaDoc explaining this decision?", "author": "devozerov", "createdAt": "2020-07-08T08:16:53Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/math/ExpressionMath.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.math;\n+\n+import com.hazelcast.sql.SqlErrorCode;\n+import com.hazelcast.sql.impl.QueryException;\n+\n+import java.math.MathContext;\n+import java.math.RoundingMode;\n+\n+import static com.hazelcast.sql.impl.type.QueryDataType.MAX_DECIMAL_PRECISION;\n+\n+/**\n+ * Utility methods for math functions.\n+ */\n+public final class ExpressionMath {\n+\n+    /**\n+     * Math context used by expressions while doing math on BigDecimal values.\n+     */\n+    public static final MathContext DECIMAL_MATH_CONTEXT = new MathContext(MAX_DECIMAL_PRECISION, RoundingMode.HALF_DOWN);", "originalCommit": "a48cce0b0f2034cb9555df84780a00cccdc1c15d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQ2NzU1Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r451467552", "bodyText": "I believe I just copied it blindly from the pre-existing prototype implementation assuming it's correct. Looks like the standard doesn't specify any defaults for rounding/truncation modes, so it's implementation defined. I think HALF_UP might be a better candidate since that's the mode most users known from school. WDYT?", "author": "taburet", "createdAt": "2020-07-08T11:20:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM2NTQyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjAyNTIzNw==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452025237", "bodyText": "Agree, HALF_UP appears to be a good fit.", "author": "devozerov", "createdAt": "2020-07-09T07:42:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM2NTQyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjA1ODA3Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452058073", "bodyText": "fixed", "author": "taburet", "createdAt": "2020-07-09T08:40:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM2NTQyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM2OTE4MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r451369181", "bodyText": "Why do we cast to int here to check for overflow, but cast to long in the asInt method?\nIs it possible that due to overflow castedInt != castedLong but castedInt == castedShort?", "author": "devozerov", "createdAt": "2020-07-08T08:23:10Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/type/converter/FloatConverter.java", "diffHunk": "@@ -38,27 +40,58 @@ private FloatConverter() {\n \n     @Override\n     public byte asTinyint(Object val) {\n-        return (byte) cast(val);\n+        float casted = cast(val);\n+        byte converted = (byte) casted;\n+\n+        if (converted != (int) casted || !Float.isFinite(casted)) {\n+            throw cannotConvert(QueryDataTypeFamily.TINYINT, val);\n+        }\n+\n+        return converted;\n     }\n \n     @Override\n     public short asSmallint(Object val) {\n-        return (short) cast(val);\n+        float casted = cast(val);\n+        short converted = (short) casted;\n+\n+        if (converted != (int) casted || !Float.isFinite(casted)) {", "originalCommit": "a48cce0b0f2034cb9555df84780a00cccdc1c15d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTUxNDE4OA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r451514188", "bodyText": "When float is casted to int, the so called saturating arithmetic cast is performed: any float value outside of the int representable range is converted to either Integer.MIN_VALUE or Integer.MAX_VALUE. It's obvious that any short representable value is within that range and can be represented without magnitude loss.\nWhen float is casted to short, it is first casted to int, because short is not a first class citizen in Java bytecode, then the produced int is implicitly casted to short, that's the time when the overflow may happen. If the short value implicitly casted back to int doesn't match the int value, that means the overflow happened.\nSimilar logic applies to long and int combo. See Narrowing Primitive Conversion section of JLS for more details.", "author": "taburet", "createdAt": "2020-07-08T12:42:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM2OTE4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjAyNjA1MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452026051", "bodyText": "Thanks for the explanation. I would add it to JavaDoc, because otherwise, it is hard to judge about the code correctness.", "author": "devozerov", "createdAt": "2020-07-09T07:43:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM2OTE4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjE3MjExMA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452172110", "bodyText": "fixed", "author": "taburet", "createdAt": "2020-07-09T12:14:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM2OTE4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM3MDkxMQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r451370911", "bodyText": "The (String val, MathContext mc) constructor is really heavy. Is there a reason why we cannot use (Double val, MathContext mc) here?\nI look at asDouble implementation, and there are no additional checks there.", "author": "devozerov", "createdAt": "2020-07-08T08:26:01Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/type/converter/FloatConverter.java", "diffHunk": "@@ -38,27 +40,58 @@ private FloatConverter() {\n \n     @Override\n     public byte asTinyint(Object val) {\n-        return (byte) cast(val);\n+        float casted = cast(val);\n+        byte converted = (byte) casted;\n+\n+        if (converted != (int) casted || !Float.isFinite(casted)) {\n+            throw cannotConvert(QueryDataTypeFamily.TINYINT, val);\n+        }\n+\n+        return converted;\n     }\n \n     @Override\n     public short asSmallint(Object val) {\n-        return (short) cast(val);\n+        float casted = cast(val);\n+        short converted = (short) casted;\n+\n+        if (converted != (int) casted || !Float.isFinite(casted)) {\n+            throw cannotConvert(QueryDataTypeFamily.SMALLINT, val);\n+        }\n+\n+        return converted;\n     }\n \n     @Override\n     public int asInt(Object val) {\n-        return (int) cast(val);\n+        float casted = cast(val);\n+        int converted = (int) casted;\n+\n+        if (converted != (long) casted || !Float.isFinite(casted)) {\n+            throw cannotConvert(QueryDataTypeFamily.INT, val);\n+        }\n+\n+        return converted;\n     }\n \n     @Override\n     public long asBigint(Object val) {\n-        return (long) cast(val);\n+        float casted = cast(val);\n+        float truncated = (float) (casted > 0.0 ? Math.floor(casted) : Math.ceil(casted));\n+        long converted = (long) truncated;\n+\n+        // No checks for NaNs and infinities are needed: NaNs are zeros and\n+        // infinities are Long.MAX/MIN_VALUE when converted to long.\n+        if ((float) converted != truncated) {\n+            throw cannotConvert(QueryDataTypeFamily.BIGINT, val);\n+        }\n+\n+        return converted;\n     }\n \n     @Override\n     public BigDecimal asDecimal(Object val) {\n-        return BigDecimal.valueOf(cast(val));\n+        return new BigDecimal(Float.toString(cast(val)), DECIMAL_MATH_CONTEXT);", "originalCommit": "a48cce0b0f2034cb9555df84780a00cccdc1c15d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTUzNTc5Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r451535792", "bodyText": "To my understanding, what users usually want when they cast, for instance, 0.3d to decimal is a decimal value that is literally equal to 0.3 and not 0.299999999999999988897769753748434595763683319091796875 which is the actual decimal fraction encoded by 0.3d. Probably we should introduce two different conversion methods, one to convert literals to human-readable decimals and one to convert some intermediate results to unhuman decimals, or just always use the latter ones.\nNot quite sure about which asDouble and checks you are talking about.", "author": "taburet", "createdAt": "2020-07-08T13:16:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM3MDkxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjAyNzQxNQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452027415", "bodyText": "Converters are not concerned with literals AFAIK. Literal conversions are parsing-time decisions, while the converters are used during query execution. So I am not sure that we should resort to intermediate string conversions here - it will negatively affect the performance.", "author": "devozerov", "createdAt": "2020-07-09T07:46:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM3MDkxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjAzNjExMA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452036110", "bodyText": "fixed", "author": "taburet", "createdAt": "2020-07-09T08:02:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM3MDkxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM3MjgzNQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r451372835", "bodyText": "Same concern as in the FloatConverter", "author": "devozerov", "createdAt": "2020-07-08T08:29:09Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/type/converter/DoubleConverter.java", "diffHunk": "@@ -38,27 +40,58 @@ private DoubleConverter() {\n \n     @Override\n     public byte asTinyint(Object val) {\n-        return (byte) cast(val);\n+        double casted = cast(val);\n+        byte converted = (byte) casted;\n+\n+        if (converted != (int) casted || !Double.isFinite(casted)) {", "originalCommit": "a48cce0b0f2034cb9555df84780a00cccdc1c15d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM3MjkyNA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r451372924", "bodyText": "Same concern as in the FloatConverter", "author": "devozerov", "createdAt": "2020-07-08T08:29:18Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/type/converter/DoubleConverter.java", "diffHunk": "@@ -38,27 +40,58 @@ private DoubleConverter() {\n \n     @Override\n     public byte asTinyint(Object val) {\n-        return (byte) cast(val);\n+        double casted = cast(val);\n+        byte converted = (byte) casted;\n+\n+        if (converted != (int) casted || !Double.isFinite(casted)) {\n+            throw cannotConvert(QueryDataTypeFamily.TINYINT, val);\n+        }\n+\n+        return converted;\n     }\n \n     @Override\n     public short asSmallint(Object val) {\n-        return (short) cast(val);\n+        double casted = cast(val);\n+        short converted = (short) casted;\n+\n+        if (converted != (int) casted || !Double.isFinite(casted)) {\n+            throw cannotConvert(QueryDataTypeFamily.SMALLINT, val);\n+        }\n+\n+        return converted;\n     }\n \n     @Override\n     public int asInt(Object val) {\n-        return (int) cast(val);\n+        double casted = cast(val);\n+        int converted = (int) casted;\n+\n+        if (converted != (long) casted || !Double.isFinite(casted)) {\n+            throw cannotConvert(QueryDataTypeFamily.INT, val);\n+        }\n+\n+        return converted;\n     }\n \n     @Override\n     public long asBigint(Object val) {\n-        return (long) cast(val);\n+        double casted = cast(val);\n+        double truncated = casted > 0.0 ? Math.floor(casted) : Math.ceil(casted);\n+        long converted = (long) truncated;\n+\n+        // No checks for NaNs and infinities are needed: NaNs are zeros and\n+        // infinities are Long.MAX/MIN_VALUE when converted to long.\n+        if ((double) converted != truncated) {\n+            throw cannotConvert(QueryDataTypeFamily.BIGINT, val);\n+        }\n+\n+        return converted;\n     }\n \n     @Override\n     public BigDecimal asDecimal(Object val) {\n-        return BigDecimal.valueOf(cast(val));\n+        return new BigDecimal(Double.toString(cast(val)), DECIMAL_MATH_CONTEXT);", "originalCommit": "a48cce0b0f2034cb9555df84780a00cccdc1c15d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg3MTAxOA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r462871018", "bodyText": "fixed in here #17183 (comment)", "author": "taburet", "createdAt": "2020-07-30T09:29:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM3MjkyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM4MjYzOA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r451382638", "bodyText": "What if conversion fails here? Users should receive a proper exception that a parameter on the position N of type T1 cannot be converted to a type T2. Looks like this is not the case.", "author": "devozerov", "createdAt": "2020-07-08T08:45:04Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/SqlInternalService.java", "diffHunk": "@@ -195,4 +195,27 @@ public QueryStateRegistry getStateRegistry() {\n     public QueryOperationHandlerImpl getOperationHandler() {\n         return operationHandler;\n     }\n+\n+    private void prepareParameters(Plan plan, List<Object> params) {\n+        assert params != null;\n+        QueryParameterMetadata parameterMetadata = plan.getParameterMetadata();\n+\n+        int parameterCount = parameterMetadata.getParameterCount();\n+        if (parameterCount != params.size()) {\n+            throw QueryException.error(\"Unexpected parameter count: expected \" + parameterCount + \", got \" + params.size());\n+        }\n+\n+        for (int i = 0; i < params.size(); ++i) {\n+            Object value = params.get(i);\n+            if (value == null) {\n+                continue;\n+            }\n+\n+            Converter valueConverter = Converters.getConverter(value.getClass());\n+            Converter typeConverter = parameterMetadata.getParameterType(i).getConverter();\n+            value = typeConverter.convertToSelf(valueConverter, value);", "originalCommit": "a48cce0b0f2034cb9555df84780a00cccdc1c15d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjAyOTg4Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452029882", "bodyText": "fixed", "author": "taburet", "createdAt": "2020-07-09T07:50:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM4MjYzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM4Mzk3Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r451383972", "bodyText": "Can we add a note to JavaDoc that returned value is always null?", "author": "devozerov", "createdAt": "2020-07-08T08:47:10Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/SqlColumnType.java", "diffHunk": "@@ -67,7 +67,12 @@\n     TIMESTAMP_WITH_TIME_ZONE(OffsetDateTime.class),\n \n     /** OBJECT type, could be represented by any Java class. */\n-    OBJECT(Object.class);\n+    OBJECT(Object.class),\n+\n+    /**\n+     * The type of the generic SQL {@code NULL} literal.", "originalCommit": "a48cce0b0f2034cb9555df84780a00cccdc1c15d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjE3NDg3OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452174879", "bodyText": "fixed", "author": "taburet", "createdAt": "2020-07-09T12:19:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM4Mzk3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM5NDAwMA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r451394000", "bodyText": "The chosen approach with generated cases is extremely difficult to follow. I cannot reason on whether the coverage is sufficient or not, because looking at thousands of invocations requires too much time. Neither I can understand how to deal with it in the future - what should I do as a developer when a new expression is introduced, or when a failure is observed? And how do I ensure that the test framework itself is correct when it is filled with complicated logic?\nI would propose two things:\n\nWe need detailed documentation about the testing framework, so that other developers know how to deal with it\nGiven that the complexity of the framework is high, we'd better rely on a set of simple manually written end-to-end tests to get quick understanding of the behavior in common cases, and use this framework to cover the edge cases", "author": "devozerov", "createdAt": "2020-07-08T09:03:16Z", "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/ExpressionTestBase.java", "diffHunk": "@@ -0,0 +1,1190 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression;\n+\n+import com.hazelcast.core.HazelcastInstance;\n+import com.hazelcast.internal.util.BiTuple;\n+import com.hazelcast.internal.util.RuntimeAvailableProcessors;\n+import com.hazelcast.map.IMap;\n+import com.hazelcast.sql.SqlErrorCode;\n+import com.hazelcast.sql.SqlException;\n+import com.hazelcast.sql.SqlResult;\n+import com.hazelcast.sql.SqlRow;\n+import com.hazelcast.sql.SqlService;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.QueryParameterMetadata;\n+import com.hazelcast.sql.impl.SqlTestSupport;\n+import com.hazelcast.sql.impl.calcite.OptimizerContext;\n+import com.hazelcast.sql.impl.calcite.SqlToQueryType;\n+import com.hazelcast.sql.impl.calcite.opt.physical.visitor.RexToExpressionVisitor;\n+import com.hazelcast.sql.impl.calcite.parse.QueryParseResult;\n+import com.hazelcast.sql.impl.calcite.schema.HazelcastSchema;\n+import com.hazelcast.sql.impl.calcite.schema.HazelcastSchemaUtils;\n+import com.hazelcast.sql.impl.calcite.schema.HazelcastTable;\n+import com.hazelcast.sql.impl.calcite.schema.MapTableStatistic;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeFactory;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem;\n+import com.hazelcast.sql.impl.plan.node.PlanNodeSchema;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.schema.ConstantTableStatistics;\n+import com.hazelcast.sql.impl.schema.TableField;\n+import com.hazelcast.sql.impl.schema.map.PartitionedMapTable;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import com.hazelcast.sql.impl.type.converter.Converter;\n+import com.hazelcast.sql.impl.type.converter.Converters;\n+import com.hazelcast.sql.impl.type.converter.StringConverter;\n+import com.hazelcast.test.TestHazelcastInstanceFactory;\n+import com.hazelcast.test.TestStringUtils;\n+import org.apache.calcite.avatica.util.TimeUnit;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.core.Project;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.sql.SqlCall;\n+import org.apache.calcite.sql.SqlCallBinding;\n+import org.apache.calcite.sql.SqlIdentifier;\n+import org.apache.calcite.sql.SqlIntervalQualifier;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.SqlLiteral;\n+import org.apache.calcite.sql.SqlNode;\n+import org.apache.calcite.sql.SqlNodeList;\n+import org.apache.calcite.sql.SqlOperandCountRange;\n+import org.apache.calcite.sql.SqlOperator;\n+import org.apache.calcite.sql.SqlSelect;\n+import org.apache.calcite.sql.SqlSyntax;\n+import org.apache.calcite.sql.parser.SqlParserPos;\n+import org.apache.calcite.sql.type.SqlOperandCountRanges;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+import org.apache.calcite.sql.validate.SqlValidator;\n+import org.apache.calcite.sql.validate.SqlValidatorScope;\n+import org.junit.After;\n+\n+import java.io.PrintWriter;\n+import java.io.Serializable;\n+import java.io.StringWriter;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.function.Function;\n+\n+import static com.hazelcast.sql.impl.calcite.SqlToQueryType.mapRowType;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.narrowestTypeFor;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.withHigherPrecedence;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.withHigherPrecedenceForLiterals;\n+import static java.util.Collections.singletonMap;\n+import static org.apache.calcite.sql.type.SqlTypeName.ANY;\n+import static org.apache.calcite.sql.type.SqlTypeName.BIGINT;\n+import static org.apache.calcite.sql.type.SqlTypeName.BOOLEAN;\n+import static org.apache.calcite.sql.type.SqlTypeName.CHAR_TYPES;\n+import static org.apache.calcite.sql.type.SqlTypeName.DECIMAL;\n+import static org.apache.calcite.sql.type.SqlTypeName.DOUBLE;\n+import static org.apache.calcite.sql.type.SqlTypeName.FRACTIONAL_TYPES;\n+import static org.apache.calcite.sql.type.SqlTypeName.INTEGER;\n+import static org.apache.calcite.sql.type.SqlTypeName.INT_TYPES;\n+import static org.apache.calcite.sql.type.SqlTypeName.NULL;\n+import static org.apache.calcite.sql.type.SqlTypeName.NUMERIC_TYPES;\n+import static org.apache.calcite.sql.type.SqlTypeName.REAL;\n+import static org.apache.calcite.sql.type.SqlTypeName.SMALLINT;\n+import static org.apache.calcite.sql.type.SqlTypeName.TIMESTAMP_WITH_LOCAL_TIME_ZONE;\n+import static org.apache.calcite.sql.type.SqlTypeName.TINYINT;\n+import static org.apache.calcite.sql.type.SqlTypeName.VARCHAR;\n+import static org.junit.Assert.assertArrayEquals;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+public abstract class ExpressionTestBase extends SqlTestSupport {", "originalCommit": "a48cce0b0f2034cb9555df84780a00cccdc1c15d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTU2OTcwOA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r451569708", "bodyText": "Yes, I'm also not that happy about it. But the \"framework\" allowed to catch numerous bugs and edge cases while working on the expressions. Initially, I started adding manually written tests for every expression, but then it became clear no matter how many tests I'm adding where is always one more to add covering some yet undiscovered case, so I switched to exhaustive enumeration. Think of it as a tool to verify the integration with Calcite, not as a fully fledged SQL test suite replacing end-to-end tests. Unfortunately, we (well, basically me) don't have enough capacity to work on good quality test suite and Calcite integration in parallel.", "author": "taburet", "createdAt": "2020-07-08T14:03:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM5NDAwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTU3NjM2Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r451576367", "bodyText": "Regarding the documentation, I will add it. Usually when a new expression is added, an empty test case is created with expected types/values lambdas always returning \"invalid\" value, then the missing logic is created on all three sides: expression implementation itself, Calcite integration and in the test case, until the test passes.", "author": "taburet", "createdAt": "2020-07-08T14:11:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM5NDAwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjAzMDM0NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452030345", "bodyText": "Ok, I see - there are no easy answers here. We should have a clear view on the purpose of these tests then - what they test, and what they do not test. AFAIU from your comment, we do use them mainly to test Calcite integration. But we cannot use them to test public behavior, such as returned values, column metadata, exception messages.\nTherefore, we need to cover basic tests manually anyway, and for the most expressions, the manual coverage is not that sufficient at the moment, especially around exceptions and metadata.\nThough, I think this framework could be a good way to understand what to test manually. E.g by looking at generated tests we can see some erroneous cases with specific errors and add manual tests for them.", "author": "devozerov", "createdAt": "2020-07-09T07:51:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM5NDAwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM5ODk1NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r451398955", "bodyText": "Can we propagate ID here to facilitate debugging?", "author": "devozerov", "createdAt": "2020-07-08T09:12:06Z", "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/ExpressionTestBase.java", "diffHunk": "@@ -0,0 +1,1190 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression;\n+\n+import com.hazelcast.core.HazelcastInstance;\n+import com.hazelcast.internal.util.BiTuple;\n+import com.hazelcast.internal.util.RuntimeAvailableProcessors;\n+import com.hazelcast.map.IMap;\n+import com.hazelcast.sql.SqlErrorCode;\n+import com.hazelcast.sql.SqlException;\n+import com.hazelcast.sql.SqlResult;\n+import com.hazelcast.sql.SqlRow;\n+import com.hazelcast.sql.SqlService;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.QueryParameterMetadata;\n+import com.hazelcast.sql.impl.SqlTestSupport;\n+import com.hazelcast.sql.impl.calcite.OptimizerContext;\n+import com.hazelcast.sql.impl.calcite.SqlToQueryType;\n+import com.hazelcast.sql.impl.calcite.opt.physical.visitor.RexToExpressionVisitor;\n+import com.hazelcast.sql.impl.calcite.parse.QueryParseResult;\n+import com.hazelcast.sql.impl.calcite.schema.HazelcastSchema;\n+import com.hazelcast.sql.impl.calcite.schema.HazelcastSchemaUtils;\n+import com.hazelcast.sql.impl.calcite.schema.HazelcastTable;\n+import com.hazelcast.sql.impl.calcite.schema.MapTableStatistic;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeFactory;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem;\n+import com.hazelcast.sql.impl.plan.node.PlanNodeSchema;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.schema.ConstantTableStatistics;\n+import com.hazelcast.sql.impl.schema.TableField;\n+import com.hazelcast.sql.impl.schema.map.PartitionedMapTable;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import com.hazelcast.sql.impl.type.converter.Converter;\n+import com.hazelcast.sql.impl.type.converter.Converters;\n+import com.hazelcast.sql.impl.type.converter.StringConverter;\n+import com.hazelcast.test.TestHazelcastInstanceFactory;\n+import com.hazelcast.test.TestStringUtils;\n+import org.apache.calcite.avatica.util.TimeUnit;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.core.Project;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.sql.SqlCall;\n+import org.apache.calcite.sql.SqlCallBinding;\n+import org.apache.calcite.sql.SqlIdentifier;\n+import org.apache.calcite.sql.SqlIntervalQualifier;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.SqlLiteral;\n+import org.apache.calcite.sql.SqlNode;\n+import org.apache.calcite.sql.SqlNodeList;\n+import org.apache.calcite.sql.SqlOperandCountRange;\n+import org.apache.calcite.sql.SqlOperator;\n+import org.apache.calcite.sql.SqlSelect;\n+import org.apache.calcite.sql.SqlSyntax;\n+import org.apache.calcite.sql.parser.SqlParserPos;\n+import org.apache.calcite.sql.type.SqlOperandCountRanges;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+import org.apache.calcite.sql.validate.SqlValidator;\n+import org.apache.calcite.sql.validate.SqlValidatorScope;\n+import org.junit.After;\n+\n+import java.io.PrintWriter;\n+import java.io.Serializable;\n+import java.io.StringWriter;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.function.Function;\n+\n+import static com.hazelcast.sql.impl.calcite.SqlToQueryType.mapRowType;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.narrowestTypeFor;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.withHigherPrecedence;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.withHigherPrecedenceForLiterals;\n+import static java.util.Collections.singletonMap;\n+import static org.apache.calcite.sql.type.SqlTypeName.ANY;\n+import static org.apache.calcite.sql.type.SqlTypeName.BIGINT;\n+import static org.apache.calcite.sql.type.SqlTypeName.BOOLEAN;\n+import static org.apache.calcite.sql.type.SqlTypeName.CHAR_TYPES;\n+import static org.apache.calcite.sql.type.SqlTypeName.DECIMAL;\n+import static org.apache.calcite.sql.type.SqlTypeName.DOUBLE;\n+import static org.apache.calcite.sql.type.SqlTypeName.FRACTIONAL_TYPES;\n+import static org.apache.calcite.sql.type.SqlTypeName.INTEGER;\n+import static org.apache.calcite.sql.type.SqlTypeName.INT_TYPES;\n+import static org.apache.calcite.sql.type.SqlTypeName.NULL;\n+import static org.apache.calcite.sql.type.SqlTypeName.NUMERIC_TYPES;\n+import static org.apache.calcite.sql.type.SqlTypeName.REAL;\n+import static org.apache.calcite.sql.type.SqlTypeName.SMALLINT;\n+import static org.apache.calcite.sql.type.SqlTypeName.TIMESTAMP_WITH_LOCAL_TIME_ZONE;\n+import static org.apache.calcite.sql.type.SqlTypeName.TINYINT;\n+import static org.apache.calcite.sql.type.SqlTypeName.VARCHAR;\n+import static org.junit.Assert.assertArrayEquals;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+public abstract class ExpressionTestBase extends SqlTestSupport {\n+\n+    private static final boolean VERIFY_EVALUATION = true;\n+\n+    private static final boolean TRACE = true;\n+    private static final boolean LOG_ON_SUCCESS = false;\n+\n+    protected static final RelDataType UNKNOWN_TYPE = null;\n+    protected static final SqlTypeName UNKNOWN_TYPE_NAME = null;\n+\n+    protected static final Object UNKNOWN_VALUE = new Object() {\n+        @Override\n+        public String toString() {\n+            return \"UNKNOWN\";\n+        }\n+    };\n+\n+    protected static final Object INVALID_VALUE = new Object() {\n+        @Override\n+        public String toString() {\n+            return \"INVALID\";\n+        }\n+    };\n+    protected static final BigDecimal INVALID_NUMERIC_VALUE = new BigDecimal(0);\n+    @SuppressWarnings({\"checkstyle:IllegalInstantiation\", \"UnnecessaryBoxing\", \"BooleanConstructorCall\"})\n+    protected static final Boolean INVALID_BOOLEAN_VALUE = new Boolean(true);\n+\n+    public static final HazelcastTypeFactory TYPE_FACTORY = HazelcastTypeFactory.INSTANCE;\n+\n+    protected static final List<Operand> COLUMNS = new ArrayList<>();\n+    protected static final List<Operand> LITERALS = new ArrayList<>();\n+    protected static final List<Operand> PARAMETERS = new ArrayList<>();\n+    protected static final List<Operand> TYPES = new ArrayList<>();\n+\n+    protected static final List<Operand> BOOLEAN_COLUMN = new ArrayList<>();\n+\n+    protected static final SqlOperator IDENTITY = new SqlOperator(\"\", SqlKind.OTHER, 0, 0, null, null, null) {\n+        @Override\n+        public SqlSyntax getSyntax() {\n+            return SqlSyntax.PREFIX;\n+        }\n+\n+        @Override\n+        public SqlOperandCountRange getOperandCountRange() {\n+            return SqlOperandCountRanges.of(1);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"IDENTITY\";\n+        }\n+    };\n+\n+    private static final SqlTypeName[] TYPE_NAMES;\n+\n+    static {\n+        TYPE_NAMES = new SqlTypeName[]{VARCHAR, BOOLEAN, TINYINT, SMALLINT, INTEGER, BIGINT, DECIMAL, REAL, DOUBLE, ANY, NULL};\n+    }\n+\n+    private static final Map<String, QueryDataType> FIELDS;\n+    private static final Map<String, Integer> FIELD_TO_INDEX;\n+    private static final PlanNodeSchema SCHEMA;\n+\n+    static {\n+        Map<String, QueryDataType> fields = new LinkedHashMap<>();\n+        for (SqlTypeName type : TYPE_NAMES) {\n+            if (type == NULL) {\n+                // null is synthetic internal type\n+                continue;\n+            }\n+\n+            fields.put(type.getName().toLowerCase() + \"1\", SqlToQueryType.map(type));\n+            fields.put(type.getName().toLowerCase() + \"2\", SqlToQueryType.map(type));\n+        }\n+\n+        FIELDS = Collections.unmodifiableMap(fields);\n+        SCHEMA = new PlanNodeSchema(new ArrayList<>(FIELDS.values()));\n+\n+        FIELD_TO_INDEX = new HashMap<>();\n+        int i = 0;\n+        for (String field : FIELDS.keySet()) {\n+            FIELD_TO_INDEX.put(field, i++);\n+        }\n+    }\n+\n+    static {\n+        // Literals.\n+\n+        LITERALS.add(numericLiteral(0));\n+        LITERALS.add(numericLiteral(1));\n+        LITERALS.add(numericLiteral(-1));\n+        LITERALS.add(numericLiteral(10));\n+        LITERALS.add(numericLiteral(-10));\n+\n+        long byteMax = Byte.MAX_VALUE;\n+        long byteMin = Byte.MIN_VALUE;\n+        LITERALS.add(numericLiteral(byteMax));\n+        LITERALS.add(numericLiteral(byteMax - 1));\n+        LITERALS.add(numericLiteral(byteMax + 1));\n+        LITERALS.add(numericLiteral(byteMax - 2));\n+        LITERALS.add(numericLiteral(byteMax + 2));\n+        LITERALS.add(numericLiteral(byteMin));\n+        LITERALS.add(numericLiteral(byteMin - 1));\n+        LITERALS.add(numericLiteral(byteMin + 1));\n+        LITERALS.add(numericLiteral(byteMin - 2));\n+        LITERALS.add(numericLiteral(byteMin + 2));\n+\n+        long shortMax = Short.MAX_VALUE;\n+        long shortMin = Short.MIN_VALUE;\n+        LITERALS.add(numericLiteral(shortMax));\n+        LITERALS.add(numericLiteral(shortMax - 1));\n+        LITERALS.add(numericLiteral(shortMax + 1));\n+        LITERALS.add(numericLiteral(shortMax - 2));\n+        LITERALS.add(numericLiteral(shortMax + 2));\n+        LITERALS.add(numericLiteral(shortMin));\n+        LITERALS.add(numericLiteral(shortMin - 1));\n+        LITERALS.add(numericLiteral(shortMin + 1));\n+        LITERALS.add(numericLiteral(shortMin - 2));\n+        LITERALS.add(numericLiteral(shortMin + 2));\n+\n+        long intMax = Integer.MAX_VALUE;\n+        long intMin = Integer.MIN_VALUE;\n+        LITERALS.add(numericLiteral(intMax));\n+        LITERALS.add(numericLiteral(intMax - 1));\n+        LITERALS.add(numericLiteral(intMax + 1));\n+        LITERALS.add(numericLiteral(intMax - 2));\n+        LITERALS.add(numericLiteral(intMax + 2));\n+        LITERALS.add(numericLiteral(intMin));\n+        LITERALS.add(numericLiteral(intMin - 1));\n+        LITERALS.add(numericLiteral(intMin + 1));\n+        LITERALS.add(numericLiteral(intMin - 2));\n+        LITERALS.add(numericLiteral(intMin + 2));\n+\n+        BigInteger longMax = BigInteger.valueOf(Long.MAX_VALUE);\n+        BigInteger longMin = BigInteger.valueOf(Long.MIN_VALUE);\n+        LITERALS.add(numericLiteral(longMax));\n+        LITERALS.add(numericLiteral(longMax.subtract(BigInteger.valueOf(1))));\n+        LITERALS.add(numericLiteral(longMax.add(BigInteger.valueOf(1))));\n+        LITERALS.add(numericLiteral(longMax.subtract(BigInteger.valueOf(2))));\n+        LITERALS.add(numericLiteral(longMax.add(BigInteger.valueOf(2))));\n+        LITERALS.add(numericLiteral(longMin));\n+        LITERALS.add(numericLiteral(longMin.subtract(BigInteger.valueOf(1))));\n+        LITERALS.add(numericLiteral(longMin.add(BigInteger.valueOf(1))));\n+        LITERALS.add(numericLiteral(longMin.subtract(BigInteger.valueOf(2))));\n+        LITERALS.add(numericLiteral(longMin.add(BigInteger.valueOf(2))));\n+\n+        LITERALS.add(numericLiteral(\"0.0\"));\n+        LITERALS.add(numericLiteral(\"1.0\"));\n+        LITERALS.add(numericLiteral(\"10.01\"));\n+        LITERALS.add(numericLiteral(\"-10.01\"));\n+        LITERALS.add(numericLiteral(\"9223372036854775808.01\"));\n+\n+        LITERALS.add(numericLiteral(\"1\" + TestStringUtils.repeat(\"0\", HazelcastTypeSystem.MAX_DECIMAL_PRECISION)));\n+        LITERALS.add(numericLiteral(\"1\" + TestStringUtils.repeat(\"0\", HazelcastTypeSystem.MAX_DECIMAL_PRECISION) + \".01\"));\n+\n+        LITERALS.add(new Operand(TYPE_FACTORY.createSqlType(BOOLEAN), false, \"FALSE\"));\n+        LITERALS.add(new Operand(TYPE_FACTORY.createSqlType(BOOLEAN), true, \"TRUE\"));\n+\n+        // produce string representations of the literals added above\n+        int size = LITERALS.size();\n+        for (int i = 0; i < size; ++i) {\n+            LITERALS.add(stringLiteral(LITERALS.get(i).text));\n+        }\n+\n+        LITERALS.add(new Operand(TYPE_FACTORY.createSqlType(NULL), null, \"NULL\"));\n+        LITERALS.add(stringLiteral(\"abc\"));\n+\n+        // Columns and types as seen in CASTs.\n+\n+        for (SqlTypeName typeName : TYPE_NAMES) {\n+            if (typeName == NULL) {\n+                // null is synthetic internal type\n+                continue;\n+            }\n+\n+            RelDataType type;\n+            switch (typeName) {\n+                case INTERVAL_YEAR_MONTH:\n+                    type = TYPE_FACTORY.createSqlIntervalType(\n+                            new SqlIntervalQualifier(TimeUnit.YEAR, TimeUnit.MONTH, SqlParserPos.ZERO));\n+                    break;\n+                case INTERVAL_DAY_SECOND:\n+                    type = TYPE_FACTORY.createSqlIntervalType(\n+                            new SqlIntervalQualifier(TimeUnit.DAY, TimeUnit.SECOND, SqlParserPos.ZERO));\n+                    break;\n+                default:\n+                    type = TYPE_FACTORY.createSqlType(typeName);\n+                    break;\n+            }\n+\n+            TYPES.add(new Operand(UNKNOWN_TYPE, type, unparse(type)));\n+\n+            type = TYPE_FACTORY.createTypeWithNullability(type, true);\n+            COLUMNS.add(new Operand(type, UNKNOWN_VALUE, typeName.getName().toLowerCase() + \"1\"));\n+            COLUMNS.add(new Operand(type, UNKNOWN_VALUE, typeName.getName().toLowerCase() + \"2\"));\n+\n+            if (typeName == BOOLEAN) {\n+                BOOLEAN_COLUMN.add(new Operand(type, UNKNOWN_VALUE, typeName.getName().toLowerCase() + \"1\"));\n+            }\n+        }\n+\n+        // Parameters: one is enough, every occurrence produces a new parameter.\n+\n+        PARAMETERS.add(new Operand(UNKNOWN_TYPE, UNKNOWN_VALUE, \"?\"));\n+    }\n+\n+    protected static final List<Operand> ALL = combine(COLUMNS, LITERALS, PARAMETERS);\n+\n+    private final ExecutorService executor = Executors.newWorkStealingPool(RuntimeAvailableProcessors.get());\n+\n+    @FunctionalInterface\n+    protected interface ExpectedTypes {\n+\n+        RelDataType[] compute(Operand[] operands);\n+\n+    }\n+\n+    @FunctionalInterface\n+    protected interface ExpectedValues {\n+\n+        Object compute(Operand[] operands, RelDataType[] types, Object[] args);\n+\n+    }\n+\n+    @After\n+    public void after() {\n+        // ease the pains of thread deallocation\n+        executor.shutdown();\n+    }\n+\n+    @SafeVarargs\n+    protected final void verify(SqlOperator operator, ExpectedTypes expectedTypes, ExpectedValues expectedValues,\n+                                List<Operand>... operands) {\n+        verify(operator, -1, -1, expectedTypes, expectedValues, operands);\n+    }\n+\n+    @SafeVarargs\n+    protected final void verify(SqlOperator operator, ExpectedTypes expectedTypes, ExpectedValues expectedValues, String format,\n+                                List<Operand>... operands) {\n+        verify(operator, -1, -1, expectedTypes, expectedValues, format, operands);\n+    }\n+\n+    @SafeVarargs\n+    @SuppressWarnings(\"SameParameterValue\")\n+    protected final void verify(SqlOperator operator, int invocationId, int evaluationId, ExpectedTypes expectedTypes,\n+                                ExpectedValues expectedValues, List<Operand>... operands) {\n+        String format;\n+        switch (operator.getSyntax()) {\n+            case PREFIX:\n+                assert operands.length == 1;\n+                format = operator.getName() + \"(%s)\";\n+                break;\n+\n+            case BINARY:\n+                assert operands.length == 2;\n+                format = \"%s \" + operator.getName() + \" %s\";\n+                break;\n+\n+            default:\n+                throw new IllegalArgumentException(\"unexpected syntax: \" + operator.getSyntax());\n+        }\n+\n+        verify(operator, invocationId, evaluationId, expectedTypes, expectedValues, format, operands);\n+    }\n+\n+    @SafeVarargs\n+    protected final void verify(SqlOperator operator, int invocationId, int evaluationId, ExpectedTypes expectedTypes,", "originalCommit": "a48cce0b0f2034cb9555df84780a00cccdc1c15d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjE4MjI1Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452182256", "bodyText": "It should be propagated already and included in the error messages, if any.", "author": "taburet", "createdAt": "2020-07-09T12:32:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM5ODk1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM1NjA3Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r453356077", "bodyText": "Yes, but for the debugging purposes it is harder - you need to add contains into the breakpoint expression, instead of just setting id == 42.", "author": "devozerov", "createdAt": "2020-07-12T19:49:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM5ODk1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ0MzIxNA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r461443214", "bodyText": "The method already receives and propagates invocationId and evaluationId, so you can use them in breakpoint expressions. If you need to test some specific combination of invocationId and evaluationId, you may just pass it directly to verify and avoid setting any breakpoints. If -1 is passed as an ID, that means all possible invocations/evaluations would be verified, the generated IDs are propagated and can be used for breakpoints, if you need to.", "author": "taburet", "createdAt": "2020-07-28T09:23:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM5ODk1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQwNDI3OA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r451404278", "bodyText": "I am really worried with the chosen testing approach. We rely on system behavior instead of our explicit claims.\nConsider that we have a bug in the HazelcastTypeSystem.canCast that returns false for a pair of types that indeed should be castable. The query will fail in the ExpressionTestBase.verify (bug fires the for the first time). Then the control is passed here, the bug is fired for the second time, and the test pass.\nI propose to rethink the whole testing approach. The \"expected\" part of expression tests cannot rely on the logic being tested, because it defeats the whole purpose of unit testing.\nThe alternative approach I saw in other systems (Calcite, CockroachDB), is to write test cases in text files. In this case, it is very easy to reason on what is actually tested, and we do not depend on the system behavior for the \"expected\" part. We may use the framework to generate those files, to avoid writing thousands of tests manually.", "author": "devozerov", "createdAt": "2020-07-08T09:20:56Z", "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/CastTest.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression;\n+\n+import com.hazelcast.sql.SqlErrorCode;\n+import com.hazelcast.sql.SqlService;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.calcite.SqlToQueryType;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastIntegerType;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem;\n+import com.hazelcast.sql.impl.type.converter.Converter;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import java.math.BigDecimal;\n+\n+import static com.hazelcast.sql.impl.calcite.validate.HazelcastSqlOperatorTable.CAST;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.narrowestTypeFor;\n+import static com.hazelcast.sql.impl.type.QueryDataType.BIGINT;\n+import static com.hazelcast.sql.impl.type.QueryDataType.DOUBLE;\n+import static com.hazelcast.sql.impl.type.QueryDataType.INT;\n+import static org.junit.Assert.assertEquals;\n+\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class CastTest extends ExpressionTestBase {\n+\n+    @Test\n+    public void testEndToEnd() {\n+        SqlService sql = createEndToEndRecords();\n+        assertRows(query(sql, \"select __key from records where cast(int1 as double) < 1500\"), keyRange(0, 500, 5000, 6000));\n+        assertRows(query(sql, \"select __key, cast(__key as decimal) + 1.5 from records\"), keyRange(0, 1000, 5000, 6000),\n+                k -> BigDecimal.valueOf(k).add(BigDecimal.valueOf(1.5)));\n+        assertQueryThrows(sql, \"select * from records where cast(string1 as integer) = 0\", \"cannot convert varchar to int\");\n+        assertQueryThrows(sql, \"select __key, cast(int1 as null) from records\", \"was expecting one of\");\n+        assertQueryThrows(sql, \"select __key, cast('foo' as char) from records\", \"char is not supported\");\n+    }\n+\n+    @Test\n+    public void verify() {\n+        verify(CAST, CastTest::expectedTypes, CastTest::expectedValues, \"CAST(%s AS %s)\", ALL, TYPES);\n+    }\n+\n+    @Test\n+    public void testCreationAndEval() {\n+        CastExpression<?> expression = CastExpression.create(ConstantExpression.create(1, INT), BIGINT);\n+        assertEquals(BIGINT, expression.getType());\n+        assertEquals(1L, expression.eval(row(\"foo\"), SimpleExpressionEvalContext.create()));\n+    }\n+\n+    @Test\n+    public void testEquality() {\n+        checkEquals(CastExpression.create(ConstantExpression.create(1, INT), BIGINT),\n+                CastExpression.create(ConstantExpression.create(1, INT), BIGINT), true);\n+\n+        checkEquals(CastExpression.create(ConstantExpression.create(1, INT), BIGINT),\n+                CastExpression.create(ConstantExpression.create(1, INT), DOUBLE), false);\n+\n+        checkEquals(CastExpression.create(ConstantExpression.create(1, INT), BIGINT),\n+                CastExpression.create(ConstantExpression.create(2, INT), BIGINT), false);\n+    }\n+\n+    @Test\n+    public void testSerialization() {\n+        CastExpression<?> original = CastExpression.create(ConstantExpression.create(1, INT), BIGINT);\n+        CastExpression<?> restored = serializeAndCheck(original, SqlDataSerializerHook.EXPRESSION_CAST);\n+\n+        checkEquals(original, restored, true);\n+    }\n+\n+    private static RelDataType[] expectedTypes(Operand[] operands) {\n+        Operand operand = operands[0];\n+        RelDataType from = operand.type;\n+\n+        assert operands[1].isType();\n+        RelDataType to = (RelDataType) operands[1].value;\n+        // Calcite treats target types as NOT NULL\n+        assert !to.isNullable();\n+\n+        // Handle NULL.\n+\n+        if (isNull(from)) {\n+            return new RelDataType[]{from, to, TYPE_FACTORY.createTypeWithNullability(to, true)};\n+        }\n+\n+        RelDataType returnType = to;\n+\n+        // Assign type for parameters.\n+\n+        if (operand.isParameter()) {\n+            from = TYPE_FACTORY.createTypeWithNullability(to, true);\n+        }\n+\n+        // Assign type to numeric literals.\n+\n+        BigDecimal numeric = operand.numericValue();\n+\n+        if (isNumeric(to) || isNumeric(from)) {\n+            //noinspection NumberEquality\n+            if (numeric == INVALID_NUMERIC_VALUE) {\n+                return null;\n+            }\n+\n+            if (numeric != null) {\n+                from = narrowestTypeFor(numeric, typeName(to));\n+            }\n+        }\n+\n+        // Validate the cast.\n+\n+        if (!HazelcastTypeSystem.canCast(from, to)) {\n+            return null;", "originalCommit": "a48cce0b0f2034cb9555df84780a00cccdc1c15d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTYwNTYyNA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r451605624", "bodyText": "Yes, it smells :) The alternative was to reimplement canCast on the test side, but it depends on the converters, so the next step is to reimplement the converters which in turn depend on something else, in the end basically everything needs to be reimplemented on the test side. So the idea was to cover all the parts shared between tests and implementation with separate unit tests. Probably some unit tests are missing or too relaxed/lazy, for instance, there is HazelcastTypeSystemTest.canCastTest, it's not that extensive because canCast internally relies on the converters which have separate unit tests. Again, the tests are mostly related to verifying the expectations about integration with Calcite, typing and evaluation of each individual expression, that's not an extensive collection of end-to-end SQL tests.", "author": "taburet", "createdAt": "2020-07-08T14:50:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQwNDI3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjAzMTU4OA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452031588", "bodyText": "I see, in this case we again return to the main question - what is the definition of a well-tested expression?", "author": "devozerov", "createdAt": "2020-07-09T07:54:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQwNDI3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQ3NDAxNQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r451474015", "bodyText": "One of the produced test cases:\nquery:  SELECT ? IS NULL FROM t\nAt line 1, column 8: Illegal use of dynamic parameter\n\nWhat is the reason of this query to fail? It looks valid to me", "author": "devozerov", "createdAt": "2020-07-08T11:33:33Z", "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/predicate/IsNullTest.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.predicate;\n+\n+import com.hazelcast.sql.SqlService;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.ColumnExpression;\n+import com.hazelcast.sql.impl.expression.ExpressionTestBase;\n+import com.hazelcast.sql.impl.expression.SimpleExpressionEvalContext;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import java.math.BigDecimal;\n+\n+import static com.hazelcast.sql.impl.calcite.validate.HazelcastSqlOperatorTable.IS_NULL;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.narrowestTypeFor;\n+import static org.apache.calcite.sql.type.SqlTypeName.BOOLEAN;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class IsNullTest extends ExpressionTestBase {", "originalCommit": "ed19ac4d54b7a1d746722c4ff8c89453ddb22e0a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjE5MTA2OA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452191068", "bodyText": "It's mostly for consistency with other expressions. Generally, if there is no enough type information to assign some meaningful types to operands, validation fails. Your idea is to assign ANY aka OBJECT type to ? in this particular case of ? IS [NOT] NULL, right?", "author": "taburet", "createdAt": "2020-07-09T12:47:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQ3NDAxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM1NjAyNQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r453356025", "bodyText": "Yes, formally this is a valid expression.", "author": "devozerov", "createdAt": "2020-07-12T19:48:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQ3NDAxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ2NDQzMg==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r461464432", "bodyText": "fixed in 310766b", "author": "taburet", "createdAt": "2020-07-28T09:58:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQ3NDAxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQ3NjcyMg==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r451476722", "bodyText": "Incorrect error messages is produced for some tests:\nid: 69\nquery:  SELECT NOT 9223372036854775808.01 FROM t\nFrom line 1, column 8 to line 1, column 33: Cannot apply 'NOT' to arguments of type 'NOT<DOUBLE>'. Supported form(s): 'NOT<BOOLEAN>'", "author": "devozerov", "createdAt": "2020-07-08T11:39:03Z", "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/predicate/NotTest.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.predicate;\n+\n+import com.hazelcast.sql.SqlService;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.ConstantExpression;\n+import com.hazelcast.sql.impl.expression.ExpressionTestBase;\n+import com.hazelcast.sql.impl.expression.SimpleExpressionEvalContext;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import static com.hazelcast.sql.impl.calcite.validate.HazelcastSqlOperatorTable.NOT;\n+import static org.apache.calcite.sql.type.SqlTypeName.BOOLEAN;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class NotTest extends ExpressionTestBase {", "originalCommit": "ed19ac4d54b7a1d746722c4ff8c89453ddb22e0a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTYwOTc3Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r451609776", "bodyText": "What's wrong with it?", "author": "taburet", "createdAt": "2020-07-08T14:56:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQ3NjcyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTYxMjUxOQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r451612519", "bodyText": "If you are talking about type 'NOT<DOUBLE>' part, looks like that is some bug in Calcite. I get used to it to the point it looks pretty normal to me now :)", "author": "taburet", "createdAt": "2020-07-08T14:59:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQ3NjcyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjAzMjIwOA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452032208", "bodyText": "Yes, I mean this NOT before the type. It is part of the Calcite, but maybe we can hook there and fix that. Otherwise, we confuse our users.", "author": "devozerov", "createdAt": "2020-07-09T07:55:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQ3NjcyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjIxMzM4Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452213387", "bodyText": "Looks like there is no way to customize the message without altering the Calcite code, see SqlCallBinding.newValidationSignatureError.", "author": "taburet", "createdAt": "2020-07-09T13:23:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQ3NjcyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjIxNTE2Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452215163", "bodyText": "It kind of look OKish for expression with more than one operand: Cannot apply 'AND' to arguments of type '<BIGINT> AND <DOUBLE>'. Supported form(s): '<BOOLEAN> AND <BOOLEAN>', but I agree for one-operand expressions it looks especially confusing.", "author": "taburet", "createdAt": "2020-07-09T13:25:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQ3NjcyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM1NTk1MA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r453355950", "bodyText": "AFAIU SqlCallBinding.newValidationSignatureError delegates to a specific operator to get this information. Can we override NOT operator to fix the error message?", "author": "devozerov", "createdAt": "2020-07-12T19:47:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQ3NjcyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ3MTM2MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r461471361", "bodyText": "I don't think that fixing it for a single operator makes any sense, it's the general format used by Calcite for all operators. It substitutes a type name surrounded by angle brackets for every formal operand of an operator.", "author": "taburet", "createdAt": "2020-07-28T10:11:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQ3NjcyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTcwMTcwNA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r461701704", "bodyText": "What is your proposal wrt this issue?", "author": "devozerov", "createdAt": "2020-07-28T16:10:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQ3NjcyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjA3Nzg1Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r462077853", "bodyText": "Is it an issue after all? If it is, how critical is it? What is your idea about a better message?\nThe only potentially universal solution I have in mind for now is overriding SqlValidatorImpl.newValidationError and trying to intercept incoming Resources.ExInst. Looks like that would require some significant amount of hackery, like classes declared on Calcite packages to gain access to protected fields.", "author": "taburet", "createdAt": "2020-07-29T06:54:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQ3NjcyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI0MTIzNQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r462241235", "bodyText": "From the user perspective, it is confusing - the system reports types that do not exist. At first glance, it doesn't seem difficult to fix. I was able to intercept the signature error by adding the following wrapper to the HazelcastOperandTypes.NotAny#checkOperandTypes:\nSqlCallBinding binding1 = new SqlCallBinding(binding.getValidator(), binding.getScope(),binding.getCall()) {\n    @Override\n    public CalciteException newValidationSignatureError() {\n        return super.newValidationSignatureError();\n    }\n};\n\nOnce the call is intercepted, we may produce any error message we like.", "author": "devozerov", "createdAt": "2020-07-29T11:53:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQ3NjcyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDgzNjE5Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r464836193", "bodyText": "created an issue #17301 for 4.2", "author": "taburet", "createdAt": "2020-08-04T06:50:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQ3NjcyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQ3ODIyOA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r451478228", "bodyText": "These and many others testEndToEnd tests in other classes validate only values, but do not validate the metadata. Also, they mostly do not check expressions in the SELECT list.", "author": "devozerov", "createdAt": "2020-07-08T11:42:02Z", "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/predicate/NotTest.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.predicate;\n+\n+import com.hazelcast.sql.SqlService;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.ConstantExpression;\n+import com.hazelcast.sql.impl.expression.ExpressionTestBase;\n+import com.hazelcast.sql.impl.expression.SimpleExpressionEvalContext;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import static com.hazelcast.sql.impl.calcite.validate.HazelcastSqlOperatorTable.NOT;\n+import static org.apache.calcite.sql.type.SqlTypeName.BOOLEAN;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class NotTest extends ExpressionTestBase {\n+\n+    @Test\n+    public void testEndToEnd() {\n+        SqlService sql = createEndToEndRecords();\n+        assertRows(query(sql, \"select __key from records where not boolean1\"), keyRange(0, 500));", "originalCommit": "ed19ac4d54b7a1d746722c4ff8c89453ddb22e0a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ4MTcyNg==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r461481726", "bodyText": "Such tests will be removed. No tests, no problems :)", "author": "taburet", "createdAt": "2020-07-28T10:31:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQ3ODIyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQ4NDMxMw==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r451484313", "bodyText": "It seems that certain types are not tested: character, big integer", "author": "devozerov", "createdAt": "2020-07-08T11:54:11Z", "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/ExpressionTestBase.java", "diffHunk": "@@ -0,0 +1,1190 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression;\n+\n+import com.hazelcast.core.HazelcastInstance;\n+import com.hazelcast.internal.util.BiTuple;\n+import com.hazelcast.internal.util.RuntimeAvailableProcessors;\n+import com.hazelcast.map.IMap;\n+import com.hazelcast.sql.SqlErrorCode;\n+import com.hazelcast.sql.SqlException;\n+import com.hazelcast.sql.SqlResult;\n+import com.hazelcast.sql.SqlRow;\n+import com.hazelcast.sql.SqlService;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.QueryParameterMetadata;\n+import com.hazelcast.sql.impl.SqlTestSupport;\n+import com.hazelcast.sql.impl.calcite.OptimizerContext;\n+import com.hazelcast.sql.impl.calcite.SqlToQueryType;\n+import com.hazelcast.sql.impl.calcite.opt.physical.visitor.RexToExpressionVisitor;\n+import com.hazelcast.sql.impl.calcite.parse.QueryParseResult;\n+import com.hazelcast.sql.impl.calcite.schema.HazelcastSchema;\n+import com.hazelcast.sql.impl.calcite.schema.HazelcastSchemaUtils;\n+import com.hazelcast.sql.impl.calcite.schema.HazelcastTable;\n+import com.hazelcast.sql.impl.calcite.schema.MapTableStatistic;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeFactory;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem;\n+import com.hazelcast.sql.impl.plan.node.PlanNodeSchema;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.schema.ConstantTableStatistics;\n+import com.hazelcast.sql.impl.schema.TableField;\n+import com.hazelcast.sql.impl.schema.map.PartitionedMapTable;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import com.hazelcast.sql.impl.type.converter.Converter;\n+import com.hazelcast.sql.impl.type.converter.Converters;\n+import com.hazelcast.sql.impl.type.converter.StringConverter;\n+import com.hazelcast.test.TestHazelcastInstanceFactory;\n+import com.hazelcast.test.TestStringUtils;\n+import org.apache.calcite.avatica.util.TimeUnit;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.core.Project;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.sql.SqlCall;\n+import org.apache.calcite.sql.SqlCallBinding;\n+import org.apache.calcite.sql.SqlIdentifier;\n+import org.apache.calcite.sql.SqlIntervalQualifier;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.SqlLiteral;\n+import org.apache.calcite.sql.SqlNode;\n+import org.apache.calcite.sql.SqlNodeList;\n+import org.apache.calcite.sql.SqlOperandCountRange;\n+import org.apache.calcite.sql.SqlOperator;\n+import org.apache.calcite.sql.SqlSelect;\n+import org.apache.calcite.sql.SqlSyntax;\n+import org.apache.calcite.sql.parser.SqlParserPos;\n+import org.apache.calcite.sql.type.SqlOperandCountRanges;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+import org.apache.calcite.sql.validate.SqlValidator;\n+import org.apache.calcite.sql.validate.SqlValidatorScope;\n+import org.junit.After;\n+\n+import java.io.PrintWriter;\n+import java.io.Serializable;\n+import java.io.StringWriter;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.function.Function;\n+\n+import static com.hazelcast.sql.impl.calcite.SqlToQueryType.mapRowType;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.narrowestTypeFor;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.withHigherPrecedence;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.withHigherPrecedenceForLiterals;\n+import static java.util.Collections.singletonMap;\n+import static org.apache.calcite.sql.type.SqlTypeName.ANY;\n+import static org.apache.calcite.sql.type.SqlTypeName.BIGINT;\n+import static org.apache.calcite.sql.type.SqlTypeName.BOOLEAN;\n+import static org.apache.calcite.sql.type.SqlTypeName.CHAR_TYPES;\n+import static org.apache.calcite.sql.type.SqlTypeName.DECIMAL;\n+import static org.apache.calcite.sql.type.SqlTypeName.DOUBLE;\n+import static org.apache.calcite.sql.type.SqlTypeName.FRACTIONAL_TYPES;\n+import static org.apache.calcite.sql.type.SqlTypeName.INTEGER;\n+import static org.apache.calcite.sql.type.SqlTypeName.INT_TYPES;\n+import static org.apache.calcite.sql.type.SqlTypeName.NULL;\n+import static org.apache.calcite.sql.type.SqlTypeName.NUMERIC_TYPES;\n+import static org.apache.calcite.sql.type.SqlTypeName.REAL;\n+import static org.apache.calcite.sql.type.SqlTypeName.SMALLINT;\n+import static org.apache.calcite.sql.type.SqlTypeName.TIMESTAMP_WITH_LOCAL_TIME_ZONE;\n+import static org.apache.calcite.sql.type.SqlTypeName.TINYINT;\n+import static org.apache.calcite.sql.type.SqlTypeName.VARCHAR;\n+import static org.junit.Assert.assertArrayEquals;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+public abstract class ExpressionTestBase extends SqlTestSupport {\n+\n+    private static final boolean VERIFY_EVALUATION = true;\n+\n+    private static final boolean TRACE = true;\n+    private static final boolean LOG_ON_SUCCESS = false;\n+\n+    protected static final RelDataType UNKNOWN_TYPE = null;\n+    protected static final SqlTypeName UNKNOWN_TYPE_NAME = null;\n+\n+    protected static final Object UNKNOWN_VALUE = new Object() {\n+        @Override\n+        public String toString() {\n+            return \"UNKNOWN\";\n+        }\n+    };\n+\n+    protected static final Object INVALID_VALUE = new Object() {\n+        @Override\n+        public String toString() {\n+            return \"INVALID\";\n+        }\n+    };\n+    protected static final BigDecimal INVALID_NUMERIC_VALUE = new BigDecimal(0);\n+    @SuppressWarnings({\"checkstyle:IllegalInstantiation\", \"UnnecessaryBoxing\", \"BooleanConstructorCall\"})\n+    protected static final Boolean INVALID_BOOLEAN_VALUE = new Boolean(true);\n+\n+    public static final HazelcastTypeFactory TYPE_FACTORY = HazelcastTypeFactory.INSTANCE;\n+\n+    protected static final List<Operand> COLUMNS = new ArrayList<>();\n+    protected static final List<Operand> LITERALS = new ArrayList<>();\n+    protected static final List<Operand> PARAMETERS = new ArrayList<>();\n+    protected static final List<Operand> TYPES = new ArrayList<>();\n+\n+    protected static final List<Operand> BOOLEAN_COLUMN = new ArrayList<>();\n+\n+    protected static final SqlOperator IDENTITY = new SqlOperator(\"\", SqlKind.OTHER, 0, 0, null, null, null) {\n+        @Override\n+        public SqlSyntax getSyntax() {\n+            return SqlSyntax.PREFIX;\n+        }\n+\n+        @Override\n+        public SqlOperandCountRange getOperandCountRange() {\n+            return SqlOperandCountRanges.of(1);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"IDENTITY\";\n+        }\n+    };\n+\n+    private static final SqlTypeName[] TYPE_NAMES;\n+\n+    static {\n+        TYPE_NAMES = new SqlTypeName[]{VARCHAR, BOOLEAN, TINYINT, SMALLINT, INTEGER, BIGINT, DECIMAL, REAL, DOUBLE, ANY, NULL};\n+    }\n+\n+    private static final Map<String, QueryDataType> FIELDS;\n+    private static final Map<String, Integer> FIELD_TO_INDEX;\n+    private static final PlanNodeSchema SCHEMA;\n+\n+    static {\n+        Map<String, QueryDataType> fields = new LinkedHashMap<>();\n+        for (SqlTypeName type : TYPE_NAMES) {\n+            if (type == NULL) {\n+                // null is synthetic internal type\n+                continue;\n+            }\n+\n+            fields.put(type.getName().toLowerCase() + \"1\", SqlToQueryType.map(type));\n+            fields.put(type.getName().toLowerCase() + \"2\", SqlToQueryType.map(type));\n+        }\n+\n+        FIELDS = Collections.unmodifiableMap(fields);", "originalCommit": "ed19ac4d54b7a1d746722c4ff8c89453ddb22e0a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ4ODg3MA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r461488870", "bodyText": "Calcite doesn't know anything about non-canonical types and there are no non-canonical types on expressions level.", "author": "taburet", "createdAt": "2020-07-28T10:46:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQ4NDMxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTcwNzk4OA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r461707988", "bodyText": "I am not sure why the Calcite is the only concern hew. Consider the ColumnTest. It generates queries like this:\nquery:  SELECT varchar1 FROM t\nparsed: SELECT `t`.`varchar1`\nFROM `t` AS `t`\nactual:   VARCHAR CHARACTER SET \"UTF-16LE\" -> VARCHAR CHARACTER SET \"UTF-16LE\"\nexpected: VARCHAR CHARACTER SET \"UTF-16LE\" -> VARCHAR CHARACTER SET \"UTF-16LE\"\n\nWhat is the reason that we test BigDecimal and String, but not BigInteger and Character?\nIn the future, when temporal types are added, we will have 5 types mapped to the TIMESTAMP_WITH_TIME_ZONE family. Will they also be excluded from these tests?", "author": "devozerov", "createdAt": "2020-07-28T16:19:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQ4NDMxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjA1Mjg1NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r462052854", "bodyText": "The tests internally create a mock environment for expression parsing, type inference, validation, conversion and evaluation. Non-canonical types for a certain type family are not making any difference for parsing, type inference, validation and conversion because for Calcite they are represented by a single canonical type. During evaluation, column values are directly passed to expressions by the tests, expressions can't accept values of non-canonical types, to accept values of non-canonical types they must be converted to values of canonical types. So the only thing the addition of non-canonical types would bring is the conversion of values of non-canonical types to canonical ones on the test side before passing them to expressions.", "author": "taburet", "createdAt": "2020-07-29T05:48:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQ4NDMxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQ5NTEyNQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r451495125", "bodyText": "This line is a good example of why such test automation is dangerous. I can break binaryIntegerPlus function, e.g. by adding one additional increment to the width, and all tests in this class will pass still, even though the produced behavior is wrong.", "author": "devozerov", "createdAt": "2020-07-08T12:12:48Z", "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/math/PlusTest.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.math;\n+\n+import com.hazelcast.sql.SqlService;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastReturnTypes;\n+import com.hazelcast.sql.impl.expression.ConstantExpression;\n+import com.hazelcast.sql.impl.expression.ExpressionTestBase;\n+import com.hazelcast.sql.impl.expression.SimpleExpressionEvalContext;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import java.math.BigDecimal;\n+\n+import static com.hazelcast.sql.impl.calcite.validate.HazelcastSqlOperatorTable.PLUS;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastIntegerType.canOverflow;\n+import static com.hazelcast.sql.impl.expression.math.ExpressionMath.DECIMAL_MATH_CONTEXT;\n+import static com.hazelcast.sql.impl.type.QueryDataType.BIGINT;\n+import static com.hazelcast.sql.impl.type.QueryDataType.INT;\n+import static org.apache.calcite.sql.type.SqlTypeName.NULL;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class PlusTest extends ExpressionTestBase {\n+\n+    @Test\n+    public void testEndToEnd() {\n+        SqlService sql = createEndToEndRecords();\n+        assertRows(query(sql, \"select __key from records where int1 + 100 > 0\"), keyRange(0, 1000));\n+        assertRows(query(sql, \"select __key, double1 + ? from records where __key < 1000\", \"2.1\"), keyRange(0, 1000),\n+                k -> (k + 2000.1) + 2.1);\n+        assertRows(query(sql, \"select __key, double1 + null from records\"), keyRange(0, 1000, 5000, 6000), k -> null);\n+        assertQueryThrows(sql, \"select ? + int1 from records\", \"bigint overflow\", Long.MAX_VALUE);\n+    }\n+\n+    @Test\n+    public void verify() {\n+        verify(PLUS, PlusTest::expectedTypes, PlusTest::expectedValues, ALL, ALL);\n+    }\n+\n+    @Test\n+    public void testCreationAndEval() {\n+        PlusFunction<?> expression =\n+                PlusFunction.create(ConstantExpression.create(3, INT), ConstantExpression.create(2, INT), INT);\n+        assertEquals(INT, expression.getType());\n+        assertEquals(5, expression.eval(row(\"foo\"), SimpleExpressionEvalContext.create()));\n+    }\n+\n+    @Test\n+    public void testEquality() {\n+        checkEquals(PlusFunction.create(ConstantExpression.create(3, INT), ConstantExpression.create(2, INT), INT),\n+                PlusFunction.create(ConstantExpression.create(3, INT), ConstantExpression.create(2, INT), INT), true);\n+\n+        checkEquals(PlusFunction.create(ConstantExpression.create(3, INT), ConstantExpression.create(2, INT), INT),\n+                PlusFunction.create(ConstantExpression.create(3, INT), ConstantExpression.create(2, INT), BIGINT), false);\n+\n+        checkEquals(PlusFunction.create(ConstantExpression.create(3, INT), ConstantExpression.create(2, INT), INT),\n+                PlusFunction.create(ConstantExpression.create(3, INT), ConstantExpression.create(100, INT), INT), false);\n+    }\n+\n+    @Test\n+    public void testSerialization() {\n+        PlusFunction<?> original = PlusFunction.create(ConstantExpression.create(3, INT), ConstantExpression.create(2, INT), INT);\n+        PlusFunction<?> restored = serializeAndCheck(original, SqlDataSerializerHook.EXPRESSION_PLUS);\n+\n+        checkEquals(original, restored, true);\n+    }\n+\n+    private static RelDataType[] expectedTypes(Operand[] operands) {\n+        // Infer types.\n+\n+        RelDataType[] types = inferTypes(operands, true);\n+        if (types == null) {\n+            return null;\n+        }\n+        RelDataType commonType = types[2];\n+\n+        // Validate, coerce and infer return type.\n+\n+        if (!isNumeric(commonType)) {\n+            return null;\n+        }\n+\n+        for (int i = 0; i < types.length - 1; ++i) {\n+            Operand operand = operands[i];\n+            RelDataType type = types[i];\n+\n+            if (!isNumeric(type) && !isNull(type)) {\n+                return null;\n+            }\n+\n+            if (operand.isLiteral() && !canRepresentLiteral(operand, type)) {\n+                return null;\n+            }\n+        }\n+\n+        if (isInteger(commonType)) {\n+            types[2] = HazelcastReturnTypes.binaryIntegerPlus(types[0], types[1]);", "originalCommit": "ed19ac4d54b7a1d746722c4ff8c89453ddb22e0a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjAzMjU5MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452032591", "bodyText": "Resolving, because it duplicates the previous discussions on how to test the expressions in general.", "author": "devozerov", "createdAt": "2020-07-09T07:55:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQ5NTEyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjA3ODQ2MA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452078460", "bodyText": "verify doesn't add much value here, because it generates only several invocations. Given that this is a foundational expression, we need to cover it with classical tests extensively, to ensure that the behavior is as expected. This includes, but not limited to:\n\nChecking all types and their metadata, including BigInteger, Character, custom objects - we need to ensure that they are converted properly\nChecking unexpected types - this may happen in case the plan was created for one model, but then the user loaded another model. In this case, the proper exception should be thrown from the target of field extractor\nChecking __key and this of different types - primitives, composite objects\nChecking different targets - Serializable, DS, IDS, Portable", "author": "devozerov", "createdAt": "2020-07-09T09:14:31Z", "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/ColumnTest.java", "diffHunk": "@@ -16,47 +16,76 @@\n \n package com.hazelcast.sql.impl.expression;\n \n+import com.hazelcast.sql.SqlService;\n import com.hazelcast.sql.impl.SqlDataSerializerHook;\n-import com.hazelcast.sql.impl.SqlTestSupport;\n import com.hazelcast.sql.impl.row.HeapRow;\n-import com.hazelcast.sql.impl.type.QueryDataType;\n import com.hazelcast.test.HazelcastParallelClassRunner;\n import com.hazelcast.test.annotation.ParallelJVMTest;\n import com.hazelcast.test.annotation.QuickTest;\n+import org.apache.calcite.rel.type.RelDataType;\n import org.junit.Test;\n import org.junit.experimental.categories.Category;\n import org.junit.runner.RunWith;\n \n-import static groovy.util.GroovyTestCase.assertEquals;\n+import static com.hazelcast.sql.impl.type.QueryDataType.BIGINT;\n+import static com.hazelcast.sql.impl.type.QueryDataType.INT;\n+import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertSame;\n \n @RunWith(HazelcastParallelClassRunner.class)\n @Category({QuickTest.class, ParallelJVMTest.class})\n-public class ColumnExpressionTest extends SqlTestSupport {\n+public class ColumnTest extends ExpressionTestBase {", "originalCommit": "d9a7be2618464e26ab4f2a08f66a7ac167b45e0e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ4OTcwMQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r461489701", "bodyText": "Added ColumnEndToEndTest", "author": "taburet", "createdAt": "2020-07-28T10:48:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjA3ODQ2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjA4MTA1NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452081055", "bodyText": "Minor: this if-statement could be replaced with the following snippet placed after the if (value == null) block:\n assert type.getTypeFamily() != QueryDataTypeFamily.NULL", "author": "devozerov", "createdAt": "2020-07-09T09:18:55Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/ConstantExpression.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression;\n+\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import com.hazelcast.sql.impl.type.QueryDataTypeFamily;\n+import com.hazelcast.sql.impl.type.converter.Converter;\n+import com.hazelcast.sql.impl.type.converter.Converters;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+\n+/**\n+ * Constant expression.\n+ *\n+ * @param <T> Return type.\n+ */\n+public final class ConstantExpression<T> implements Expression<T>, IdentifiedDataSerializable {\n+\n+    private QueryDataType type;\n+    private T value;\n+\n+    public ConstantExpression() {\n+        // No-op.\n+    }\n+\n+    private ConstantExpression(T value, QueryDataType type) {\n+        this.type = type;\n+        this.value = value;\n+    }\n+\n+    public static ConstantExpression<?> create(Object value, QueryDataType type) {\n+        if (type.getTypeFamily() == QueryDataTypeFamily.NULL) {", "originalCommit": "d9a7be2618464e26ab4f2a08f66a7ac167b45e0e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ5NjE3Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r461496177", "bodyText": "fixed in 07ba390", "author": "taburet", "createdAt": "2020-07-28T11:01:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjA4MTA1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjA4NDUwMg==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452084502", "bodyText": "Do we have tests that simulate an exception that happened during this conversion? What would the user receive in this case?", "author": "devozerov", "createdAt": "2020-07-09T09:24:28Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/ConstantExpression.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression;\n+\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import com.hazelcast.sql.impl.type.QueryDataTypeFamily;\n+import com.hazelcast.sql.impl.type.converter.Converter;\n+import com.hazelcast.sql.impl.type.converter.Converters;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+\n+/**\n+ * Constant expression.\n+ *\n+ * @param <T> Return type.\n+ */\n+public final class ConstantExpression<T> implements Expression<T>, IdentifiedDataSerializable {\n+\n+    private QueryDataType type;\n+    private T value;\n+\n+    public ConstantExpression() {\n+        // No-op.\n+    }\n+\n+    private ConstantExpression(T value, QueryDataType type) {\n+        this.type = type;\n+        this.value = value;\n+    }\n+\n+    public static ConstantExpression<?> create(Object value, QueryDataType type) {\n+        if (type.getTypeFamily() == QueryDataTypeFamily.NULL) {\n+            assert value == null;\n+            return new ConstantExpression<>(null, QueryDataType.NULL);\n+        }\n+\n+        if (value == null) {\n+            return new ConstantExpression<>(null, type);\n+        }\n+\n+        Converter valueConverter = Converters.getConverter(value.getClass());\n+        Converter typeConverter = type.getConverter();\n+        value = typeConverter.convertToSelf(valueConverter, value);", "originalCommit": "d9a7be2618464e26ab4f2a08f66a7ac167b45e0e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY5MDM2MA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452690360", "bodyText": "This conversion logic should never throw under normal conditions. The type of a literal and possibility of the conversion is already verified during query validation, see HazelcastSqlValidator.validateLiteral and HazelcastTypeSystem#canRepresent. In other words, we already attempted to perform the conversion during validation and if we have entered this method that means the conversion is valid, otherwise the query validation fails and we are obviously not creating any expressions for the query. If this conversion logic throws, that means the validation is broken, but that's kind of a system error, not the error user should deal with normally.", "author": "taburet", "createdAt": "2020-07-10T08:08:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjA4NDUwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjA4NjUyMA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452086520", "bodyText": "Constant is another foundational expression for us (the other two are column and parameter). We need exhaustive coverage with precise checks for returned values and types.\nAlso, AFAIK, we may face a constant not only in literals but also due to expression simplification (e.g. '1 + 1.1', or a predicate simplified to TRUE/FALSE). Such tests should be added as well.", "author": "devozerov", "createdAt": "2020-07-09T09:28:00Z", "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/LiteralTest.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression;\n+\n+import com.hazelcast.sql.SqlService;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import java.math.BigDecimal;\n+\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.narrowestTypeFor;\n+import static com.hazelcast.sql.impl.type.QueryDataType.BIGINT;\n+import static com.hazelcast.sql.impl.type.QueryDataType.INT;\n+import static org.junit.Assert.assertEquals;\n+\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class LiteralTest extends ExpressionTestBase {\n+\n+    @Test\n+    public void testEndToEnd() {", "originalCommit": "d9a7be2618464e26ab4f2a08f66a7ac167b45e0e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTUyMTgxNA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r461521814", "bodyText": "added LiteralEndToEndTest", "author": "taburet", "createdAt": "2020-07-28T11:53:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjA4NjUyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjA4NzUwMw==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452087503", "bodyText": "Type is not used for hash code calculation but is used in equals.", "author": "devozerov", "createdAt": "2020-07-09T09:29:40Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/ParameterExpression.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression;\n+\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+\n+/**\n+ * Dynamic parameter expression.\n+ */\n+public final class ParameterExpression<T> implements Expression<T>, IdentifiedDataSerializable {\n+\n+    private int index;\n+    private QueryDataType type;\n+\n+    public ParameterExpression() {\n+        // No-op.\n+    }\n+\n+    private ParameterExpression(int index, QueryDataType type) {\n+        this.index = index;\n+        this.type = type;\n+    }\n+\n+    public static ParameterExpression<?> create(int index, QueryDataType type) {\n+        return new ParameterExpression<>(index, type);\n+    }\n+\n+    @Override\n+    public int getFactoryId() {\n+        return SqlDataSerializerHook.F_ID;\n+    }\n+\n+    @Override\n+    public int getClassId() {\n+        return SqlDataSerializerHook.EXPRESSION_PARAMETER;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public T eval(Row row, ExpressionEvalContext context) {\n+        return (T) context.getArgument(index);\n+    }\n+\n+    @Override\n+    public QueryDataType getType() {\n+        return type;\n+    }\n+\n+    @Override\n+    public void writeData(ObjectDataOutput out) throws IOException {\n+        out.writeInt(index);\n+        out.writeObject(type);\n+    }\n+\n+    @Override\n+    public void readData(ObjectDataInput in) throws IOException {\n+        index = in.readInt();\n+        type = in.readObject();\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(index);", "originalCommit": "d9a7be2618464e26ab4f2a08f66a7ac167b45e0e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY5MzkyOA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452693928", "bodyText": "fixed", "author": "taburet", "createdAt": "2020-07-10T08:15:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjA4NzUwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjA5MDI2MA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452090260", "bodyText": "Similarly to columns and constants - we need exhaustive coverage here. Note that verify doesn't test anything at all here - only one invocation is generated.\n\nTests for every combination of input object type vs expected type: proper exceptions and return values/types should be checked.\nTest for cases, where type inference is non-trivial. For example, SELECT ? FROM t. Currently, it throws an exception, but why? I doubt other databases do the same.", "author": "devozerov", "createdAt": "2020-07-09T09:34:19Z", "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/ParameterTest.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression;\n+\n+import com.hazelcast.sql.SqlService;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import static com.hazelcast.sql.impl.type.QueryDataType.BIGINT;\n+import static com.hazelcast.sql.impl.type.QueryDataType.INT;\n+import static org.junit.Assert.assertEquals;\n+\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class ParameterTest extends ExpressionTestBase {", "originalCommit": "d9a7be2618464e26ab4f2a08f66a7ac167b45e0e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc1MzI1NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452753254", "bodyText": "This verify tests parameter expression in isolation, every other single expression verify utilizes parameters during verification. For instance, PlusTest verifies: ? + whatever and whatever + ? for every possible combination of types, and for every valid substitution of types it also verifies pretty large number of possible value substitutions.\nRegarding SELECT ? FROM t, that how Calcite works, if there is no type information to assign a type to a parameter it receives UNKNOWN type which is not considered valid by the validator. I think it would be hard to workaround this in that specific standalone parameter case.", "author": "taburet", "createdAt": "2020-07-10T10:10:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjA5MDI2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM1NTM3OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r453355379", "bodyText": "Can we cast ? to ANY/OBJECT during inference?", "author": "devozerov", "createdAt": "2020-07-12T19:41:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjA5MDI2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTUxOTEyNw==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r461519127", "bodyText": "Yes, we can, but the consequence of that would be ? + ? reporting Cannot apply '+' to arguments of type '<OBJECT> + <OBJECT>' error instead of Illegal use of dynamic parameter. Usually, type inference is done in the context of some operator, because only the operator knowns which types it expects, but there is no operator in this case of a standalone parameter. We can assign OBJECT type for every parameter of unknown type, but seeing only a parameter we can't tell does it participate as an operand of some operator or not, so we can't skip that OBJECT type assignment. Probably there is some way to workaround that, but I haven't found it yet.", "author": "taburet", "createdAt": "2020-07-28T11:48:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjA5MDI2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjA5MTU2NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452091565", "bodyText": "Supported and unsupported exceptions are currently tested in ParserOperationsTest.", "author": "devozerov", "createdAt": "2020-07-09T09:36:33Z", "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/InvalidExpressionTest.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression;\n+\n+import com.hazelcast.sql.SqlService;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class InvalidExpressionTest extends ExpressionTestBase {", "originalCommit": "d9a7be2618464e26ab4f2a08f66a7ac167b45e0e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTUyNjIzNQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r461526235", "bodyText": "fixed in e95608e", "author": "taburet", "createdAt": "2020-07-28T12:02:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjA5MTU2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjA5NTAxMQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452095011", "bodyText": "This part of the class is not tested at all, therefore we do not know whether it works or not. Given that this PR is not concerned with temporal types, we'd better not to merge this code at all.", "author": "devozerov", "createdAt": "2020-07-09T09:42:15Z", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/opt/physical/visitor/RexToExpression.java", "diffHunk": "@@ -17,39 +17,272 @@\n package com.hazelcast.sql.impl.calcite.opt.physical.visitor;\n \n import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.calcite.SqlToQueryType;\n+import com.hazelcast.sql.impl.expression.CastExpression;\n+import com.hazelcast.sql.impl.expression.ConstantExpression;\n import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.math.DivideFunction;\n+import com.hazelcast.sql.impl.expression.math.MinusFunction;\n+import com.hazelcast.sql.impl.expression.math.MultiplyFunction;\n+import com.hazelcast.sql.impl.expression.math.PlusFunction;\n+import com.hazelcast.sql.impl.expression.math.UnaryMinusFunction;\n+import com.hazelcast.sql.impl.expression.predicate.AndPredicate;\n+import com.hazelcast.sql.impl.expression.predicate.CaseExpression;\n+import com.hazelcast.sql.impl.expression.predicate.ComparisonMode;\n+import com.hazelcast.sql.impl.expression.predicate.ComparisonPredicate;\n+import com.hazelcast.sql.impl.expression.predicate.IsFalsePredicate;\n+import com.hazelcast.sql.impl.expression.predicate.IsNotFalsePredicate;\n+import com.hazelcast.sql.impl.expression.predicate.IsNotNullPredicate;\n+import com.hazelcast.sql.impl.expression.predicate.IsNotTruePredicate;\n import com.hazelcast.sql.impl.expression.predicate.IsNullPredicate;\n+import com.hazelcast.sql.impl.expression.predicate.IsTruePredicate;\n+import com.hazelcast.sql.impl.expression.predicate.NotPredicate;\n+import com.hazelcast.sql.impl.expression.predicate.OrPredicate;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import com.hazelcast.sql.impl.type.converter.CalendarConverter;\n import org.apache.calcite.rex.RexCall;\n+import org.apache.calcite.rex.RexLiteral;\n import org.apache.calcite.sql.SqlOperator;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+\n+import java.math.BigDecimal;\n+import java.util.Calendar;\n \n /**\n  * Utility methods for REX to Hazelcast expression conversion.\n  */\n public final class RexToExpression {\n+\n     private RexToExpression() {\n         // No-op.\n     }\n \n+    /**\n+     * Converts the given REX literal to runtime {@link ConstantExpression\n+     * constant expression}.\n+     *\n+     * @param literal the literal to convert.\n+     * @return the resulting constant expression.\n+     */\n+    @SuppressWarnings(\"checkstyle:CyclomaticComplexity\")\n+    public static Expression<?> convertLiteral(RexLiteral literal) {\n+        SqlTypeName type = literal.getType().getSqlTypeName();\n+\n+        switch (type) {\n+            case BOOLEAN:\n+                return convertBooleanLiteral(literal, type);\n+\n+            case TINYINT:\n+            case SMALLINT:\n+            case INTEGER:\n+            case BIGINT:\n+            case DECIMAL:\n+            case REAL:\n+            case FLOAT:\n+            case DOUBLE:\n+                return convertNumericLiteral(literal, type);\n+\n+            case CHAR:\n+            case VARCHAR:\n+                return convertStringLiteral(literal, type);\n+\n+            case DATE:\n+            case TIME:\n+            case TIME_WITH_LOCAL_TIME_ZONE:\n+            case TIMESTAMP:\n+            case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n+                return convertTemporalLiteral(literal, type);\n+\n+            case NULL:\n+                return ConstantExpression.create(null, QueryDataType.NULL);\n+\n+            case ANY:\n+                // currently, the only possible literal of ANY type is NULL\n+                assert literal.getValueAs(Object.class) == null;\n+                return ConstantExpression.create(null, QueryDataType.OBJECT);\n+\n+            default:\n+                throw QueryException.error(\"Unsupported literal: \" + literal);\n+        }\n+    }\n+\n     /**\n      * Converts a {@link RexCall} to {@link Expression}.\n      *\n      * @param call the call to convert.\n      * @return the resulting expression.\n      * @throws QueryException if the given {@link RexCall} can't be\n-     *                               converted.\n+     *                        converted.\n      */\n-    @SuppressWarnings(\"SwitchStatementWithTooFewBranches\")\n+    @SuppressWarnings({\"checkstyle:ReturnCount\", \"checkstyle:CyclomaticComplexity\"})\n     public static Expression<?> convertCall(RexCall call, Expression<?>[] operands) {\n         SqlOperator operator = call.getOperator();\n+        QueryDataType resultType = SqlToQueryType.map(call.getType().getSqlTypeName());\n \n         switch (operator.getKind()) {\n+            case CAST:\n+                return CastExpression.create(operands[0], resultType);\n+\n+            case CASE:\n+                return CaseExpression.create(operands, resultType);\n+\n+            case AND:\n+                return AndPredicate.create(operands);\n+\n+            case OR:\n+                return OrPredicate.create(operands);\n+\n+            case NOT:\n+                return NotPredicate.create(operands[0]);\n+\n+            case PLUS:\n+                return PlusFunction.create(operands[0], operands[1], resultType);\n+\n+            case MINUS:\n+                return MinusFunction.create(operands[0], operands[1], resultType);\n+\n+            case TIMES:\n+                return MultiplyFunction.create(operands[0], operands[1], resultType);\n+\n+            case DIVIDE:\n+                return DivideFunction.create(operands[0], operands[1], resultType);\n+\n+            case MINUS_PREFIX:\n+                return UnaryMinusFunction.create(operands[0], resultType);\n+\n+            case PLUS_PREFIX:\n+                return operands[0];\n+\n+            case EQUALS:\n+                return ComparisonPredicate.create(operands[0], operands[1], ComparisonMode.EQUALS);\n+\n+            case NOT_EQUALS:\n+                return ComparisonPredicate.create(operands[0], operands[1], ComparisonMode.NOT_EQUALS);\n+\n+            case GREATER_THAN:\n+                return ComparisonPredicate.create(operands[0], operands[1], ComparisonMode.GREATER_THAN);\n+\n+            case GREATER_THAN_OR_EQUAL:\n+                return ComparisonPredicate.create(operands[0], operands[1], ComparisonMode.GREATER_THAN_OR_EQUAL);\n+\n+            case LESS_THAN:\n+                return ComparisonPredicate.create(operands[0], operands[1], ComparisonMode.LESS_THAN);\n+\n+            case LESS_THAN_OR_EQUAL:\n+                return ComparisonPredicate.create(operands[0], operands[1], ComparisonMode.LESS_THAN_OR_EQUAL);\n+\n+            case IS_TRUE:\n+                return IsTruePredicate.create(operands[0]);\n+\n+            case IS_NOT_TRUE:\n+                return IsNotTruePredicate.create(operands[0]);\n+\n+            case IS_FALSE:\n+                return IsFalsePredicate.create(operands[0]);\n+\n+            case IS_NOT_FALSE:\n+                return IsNotFalsePredicate.create(operands[0]);\n+\n             case IS_NULL:\n                 return IsNullPredicate.create(operands[0]);\n \n+            case IS_NOT_NULL:\n+                return IsNotNullPredicate.create(operands[0]);\n+\n             default:\n                 break;\n         }\n \n         throw QueryException.error(\"Unsupported operator: \" + operator);\n     }\n+\n+    private static Expression<?> convertBooleanLiteral(RexLiteral literal, SqlTypeName type) {\n+        assert type == SqlTypeName.BOOLEAN;\n+        Boolean value = literal.getValueAs(Boolean.class);\n+        return ConstantExpression.create(value, SqlToQueryType.map(type));\n+    }\n+\n+    private static Expression<?> convertNumericLiteral(RexLiteral literal, SqlTypeName type) {\n+        Object value;\n+        switch (type) {\n+            case TINYINT:\n+                value = literal.getValueAs(Byte.class);\n+                break;\n+\n+            case SMALLINT:\n+                value = literal.getValueAs(Short.class);\n+                break;\n+\n+            case INTEGER:\n+                value = literal.getValueAs(Integer.class);\n+                break;\n+\n+            case BIGINT:\n+                value = literal.getValueAs(Long.class);\n+                break;\n+\n+            case DECIMAL:\n+                value = literal.getValueAs(BigDecimal.class);\n+                break;\n+\n+            case REAL:\n+                value = literal.getValueAs(Float.class);\n+                break;\n+\n+            case DOUBLE:\n+                value = literal.getValueAs(Double.class);\n+                break;\n+\n+            default:\n+                throw new IllegalArgumentException(\"Unsupported literal type: \" + type);\n+        }\n+\n+        return ConstantExpression.create(value, SqlToQueryType.map(type));\n+    }\n+\n+    private static Expression<?> convertStringLiteral(RexLiteral literal, SqlTypeName type) {\n+        Object value;\n+        switch (type) {\n+            case CHAR:\n+            case VARCHAR:\n+                value = literal.getValueAs(String.class);\n+                break;\n+\n+            default:\n+                throw new IllegalArgumentException(\"Unsupported literal type: \" + type);\n+        }\n+\n+        return ConstantExpression.create(value, SqlToQueryType.map(type));\n+    }\n+\n+    private static Expression<?> convertTemporalLiteral(RexLiteral literal, SqlTypeName type) {", "originalCommit": "d9a7be2618464e26ab4f2a08f66a7ac167b45e0e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTUyOTAyMw==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r461529023", "bodyText": "fixed in 1a8e2fa", "author": "taburet", "createdAt": "2020-07-28T12:07:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjA5NTAxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjA5NTQ0NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452095444", "bodyText": "This branch is not tested.", "author": "devozerov", "createdAt": "2020-07-09T09:43:04Z", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/opt/physical/visitor/RexToExpression.java", "diffHunk": "@@ -17,39 +17,272 @@\n package com.hazelcast.sql.impl.calcite.opt.physical.visitor;\n \n import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.calcite.SqlToQueryType;\n+import com.hazelcast.sql.impl.expression.CastExpression;\n+import com.hazelcast.sql.impl.expression.ConstantExpression;\n import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.math.DivideFunction;\n+import com.hazelcast.sql.impl.expression.math.MinusFunction;\n+import com.hazelcast.sql.impl.expression.math.MultiplyFunction;\n+import com.hazelcast.sql.impl.expression.math.PlusFunction;\n+import com.hazelcast.sql.impl.expression.math.UnaryMinusFunction;\n+import com.hazelcast.sql.impl.expression.predicate.AndPredicate;\n+import com.hazelcast.sql.impl.expression.predicate.CaseExpression;\n+import com.hazelcast.sql.impl.expression.predicate.ComparisonMode;\n+import com.hazelcast.sql.impl.expression.predicate.ComparisonPredicate;\n+import com.hazelcast.sql.impl.expression.predicate.IsFalsePredicate;\n+import com.hazelcast.sql.impl.expression.predicate.IsNotFalsePredicate;\n+import com.hazelcast.sql.impl.expression.predicate.IsNotNullPredicate;\n+import com.hazelcast.sql.impl.expression.predicate.IsNotTruePredicate;\n import com.hazelcast.sql.impl.expression.predicate.IsNullPredicate;\n+import com.hazelcast.sql.impl.expression.predicate.IsTruePredicate;\n+import com.hazelcast.sql.impl.expression.predicate.NotPredicate;\n+import com.hazelcast.sql.impl.expression.predicate.OrPredicate;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import com.hazelcast.sql.impl.type.converter.CalendarConverter;\n import org.apache.calcite.rex.RexCall;\n+import org.apache.calcite.rex.RexLiteral;\n import org.apache.calcite.sql.SqlOperator;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+\n+import java.math.BigDecimal;\n+import java.util.Calendar;\n \n /**\n  * Utility methods for REX to Hazelcast expression conversion.\n  */\n public final class RexToExpression {\n+\n     private RexToExpression() {\n         // No-op.\n     }\n \n+    /**\n+     * Converts the given REX literal to runtime {@link ConstantExpression\n+     * constant expression}.\n+     *\n+     * @param literal the literal to convert.\n+     * @return the resulting constant expression.\n+     */\n+    @SuppressWarnings(\"checkstyle:CyclomaticComplexity\")\n+    public static Expression<?> convertLiteral(RexLiteral literal) {\n+        SqlTypeName type = literal.getType().getSqlTypeName();\n+\n+        switch (type) {\n+            case BOOLEAN:\n+                return convertBooleanLiteral(literal, type);\n+\n+            case TINYINT:\n+            case SMALLINT:\n+            case INTEGER:\n+            case BIGINT:\n+            case DECIMAL:\n+            case REAL:\n+            case FLOAT:\n+            case DOUBLE:\n+                return convertNumericLiteral(literal, type);\n+\n+            case CHAR:\n+            case VARCHAR:\n+                return convertStringLiteral(literal, type);\n+\n+            case DATE:\n+            case TIME:\n+            case TIME_WITH_LOCAL_TIME_ZONE:\n+            case TIMESTAMP:\n+            case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n+                return convertTemporalLiteral(literal, type);\n+\n+            case NULL:\n+                return ConstantExpression.create(null, QueryDataType.NULL);\n+\n+            case ANY:\n+                // currently, the only possible literal of ANY type is NULL\n+                assert literal.getValueAs(Object.class) == null;\n+                return ConstantExpression.create(null, QueryDataType.OBJECT);\n+\n+            default:\n+                throw QueryException.error(\"Unsupported literal: \" + literal);\n+        }\n+    }\n+\n     /**\n      * Converts a {@link RexCall} to {@link Expression}.\n      *\n      * @param call the call to convert.\n      * @return the resulting expression.\n      * @throws QueryException if the given {@link RexCall} can't be\n-     *                               converted.\n+     *                        converted.\n      */\n-    @SuppressWarnings(\"SwitchStatementWithTooFewBranches\")\n+    @SuppressWarnings({\"checkstyle:ReturnCount\", \"checkstyle:CyclomaticComplexity\"})\n     public static Expression<?> convertCall(RexCall call, Expression<?>[] operands) {\n         SqlOperator operator = call.getOperator();\n+        QueryDataType resultType = SqlToQueryType.map(call.getType().getSqlTypeName());\n \n         switch (operator.getKind()) {\n+            case CAST:\n+                return CastExpression.create(operands[0], resultType);\n+\n+            case CASE:\n+                return CaseExpression.create(operands, resultType);\n+\n+            case AND:\n+                return AndPredicate.create(operands);\n+\n+            case OR:\n+                return OrPredicate.create(operands);\n+\n+            case NOT:\n+                return NotPredicate.create(operands[0]);\n+\n+            case PLUS:\n+                return PlusFunction.create(operands[0], operands[1], resultType);\n+\n+            case MINUS:\n+                return MinusFunction.create(operands[0], operands[1], resultType);\n+\n+            case TIMES:\n+                return MultiplyFunction.create(operands[0], operands[1], resultType);\n+\n+            case DIVIDE:\n+                return DivideFunction.create(operands[0], operands[1], resultType);\n+\n+            case MINUS_PREFIX:\n+                return UnaryMinusFunction.create(operands[0], resultType);\n+\n+            case PLUS_PREFIX:\n+                return operands[0];", "originalCommit": "d9a7be2618464e26ab4f2a08f66a7ac167b45e0e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTUzNzE0Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r461537142", "bodyText": "It's here mostly for consistency and it's a dead code: unary + is a no-operation in Calcite, during optimization it just strips the + and returns its operand. Here we do the same, just in case :)", "author": "taburet", "createdAt": "2020-07-28T12:22:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjA5NTQ0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjE4ODk2NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452188964", "bodyText": "Do we really need to handle temporal types in this PR, provided that they are not supported?", "author": "devozerov", "createdAt": "2020-07-09T12:43:44Z", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/parse/UnsupportedOperationVisitor.java", "diffHunk": "@@ -106,16 +125,46 @@ public Void visit(SqlIdentifier id) {\n         return null;\n     }\n \n+    @SuppressWarnings(\"checkstyle:CyclomaticComplexity\")\n     @Override\n     public Void visit(SqlDataTypeSpec type) {\n-        throw error(type, RESOURCE.custom(\"Type specification is not supported\"));\n+        if (!(type.getTypeNameSpec() instanceof SqlBasicTypeNameSpec)) {\n+            throw error(type, RESOURCE.custom(\"Complex type specifications are not supported\"));\n+        }\n+\n+        SqlTypeName typeName = SqlTypeName.get(type.getTypeName().getSimple());\n+        switch (typeName) {\n+            case BOOLEAN:\n+            case TINYINT:\n+            case SMALLINT:\n+            case INTEGER:\n+            case BIGINT:\n+            case DECIMAL:\n+            case REAL:\n+            case DOUBLE:\n+            case VARCHAR:\n+            case ANY:\n+            case NULL:\n+            case TIME:", "originalCommit": "d9a7be2618464e26ab4f2a08f66a7ac167b45e0e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTU0MjUzMg==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r461542532", "bodyText": "fixed in 145a6e2", "author": "taburet", "createdAt": "2020-07-28T12:32:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjE4ODk2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjE5MjgwMA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452192800", "bodyText": "This case might be slightly misleading to users:\n\nSELECT too_wide_value produces \"Numeric overflow\" exception\nBut\n\nSELECT `too_wide_value`\n\n... produces \"cannot convert to BIGDECIMAL\" exception.\nIt would be great to confine both cases to a similar overflow exception.", "author": "devozerov", "createdAt": "2020-07-09T12:50:31Z", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/SqlNodeUtil.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.validate;\n+\n+import com.hazelcast.sql.SqlErrorCode;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.type.converter.StringConverter;\n+import org.apache.calcite.runtime.CalciteContextException;\n+import org.apache.calcite.sql.SqlDynamicParam;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.SqlLiteral;\n+import org.apache.calcite.sql.SqlNode;\n+import org.apache.calcite.sql.SqlUtil;\n+\n+import java.math.BigDecimal;\n+\n+import static org.apache.calcite.sql.type.SqlTypeName.CHAR_TYPES;\n+import static org.apache.calcite.sql.type.SqlTypeName.DECIMAL;\n+import static org.apache.calcite.sql.type.SqlTypeName.NUMERIC_TYPES;\n+import static org.apache.calcite.util.Static.RESOURCE;\n+\n+/**\n+ * Utility methods to work with {@link SqlNode}s.\n+ */\n+public final class SqlNodeUtil {\n+\n+    private SqlNodeUtil() {\n+    }\n+\n+    /**\n+     * @return {@code true} if the given node is a {@linkplain SqlDynamicParam\n+     * dynamic parameter}, {@code false} otherwise.\n+     */\n+    public static boolean isParameter(SqlNode node) {\n+        return node.getKind() == SqlKind.DYNAMIC_PARAM;\n+    }\n+\n+    /**\n+     * @return {@code true} if the given node is a {@linkplain SqlLiteral literal},\n+     * {@code false} otherwise.\n+     */\n+    public static boolean isLiteral(SqlNode node) {\n+        return node.getKind() == SqlKind.LITERAL;\n+    }\n+\n+    /**\n+     * Obtains a numeric value of the given node if it's a numeric or string\n+     * {@linkplain SqlLiteral literal}.\n+     *\n+     * @param node the node to obtain the numeric value of.\n+     * @return the obtained numeric value or {@code null} if the given node is\n+     * not a numeric or string literal.\n+     * @throws CalciteContextException if the given node is a string literal\n+     *                                 that doesn't have a valid numeric\n+     *                                 representation.\n+     */\n+    public static BigDecimal numericValue(SqlNode node) {\n+        if (node.getKind() != SqlKind.LITERAL) {\n+            return null;\n+        }\n+\n+        SqlLiteral literal = (SqlLiteral) node;\n+\n+        if (CHAR_TYPES.contains(literal.getTypeName())) {\n+            try {\n+                return StringConverter.INSTANCE.asDecimal(literal.getValueAs(String.class));\n+            } catch (QueryException e) {\n+                assert e.getCode() == SqlErrorCode.DATA_EXCEPTION;\n+                throw SqlUtil.newContextException(literal.getParserPosition(),", "originalCommit": "d9a7be2618464e26ab4f2a08f66a7ac167b45e0e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjEwNTkyMg==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r462105922", "bodyText": "Could you please provide some more specific example. Assuming\nSELECT `too_wide_value`\n\nselects a string, it couldn't produce any exceptions related to numerics.", "author": "taburet", "createdAt": "2020-07-29T07:49:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjE5MjgwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI1MDA2OA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r462250068", "bodyText": "From the PlusTest:\nid: 15253\nquery:  SELECT '-9223372036854775807' + 9223372036854775808 FROM t\nFrom line 1, column 33 to line 1, column 51: Numeric literal '9223372036854775808' out of range\n\nid: 15307\nquery:  SELECT '-9223372036854775807' + '9223372036854775808' FROM t\nFrom line 1, column 33 to line 1, column 53: Literal ''9223372036854775808'' can not be parsed to type 'BIGINT'", "author": "devozerov", "createdAt": "2020-07-29T12:10:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjE5MjgwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDgyNzg1OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r464827859", "bodyText": "created an issue #17300 for 4.2", "author": "taburet", "createdAt": "2020-08-04T06:30:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjE5MjgwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjE5NDEyNA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452194124", "bodyText": "Can we document how exactly our behavior differs from Calcite?", "author": "devozerov", "createdAt": "2020-07-09T12:52:41Z", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/operators/HazelcastSqlCastFunction.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.validate.operators;\n+\n+import com.hazelcast.sql.impl.type.converter.Converter;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.sql.SqlCallBinding;\n+import org.apache.calcite.sql.fun.SqlCastFunction;\n+\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.canCast;\n+import static org.apache.calcite.util.Static.RESOURCE;\n+\n+/**\n+ * Custom Hazelcast {@link SqlCastFunction} to override the default operand type\n+ * checking strategy to make sure the casting behaviour is exactly the same as\n+ * defined by {@link Converter}s.\n+ */\n+public final class HazelcastSqlCastFunction extends SqlCastFunction {", "originalCommit": "d9a7be2618464e26ab4f2a08f66a7ac167b45e0e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjExOTI2OA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r462119268", "bodyText": "fixed in 2297197", "author": "taburet", "createdAt": "2020-07-29T08:13:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjE5NDEyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjE5NDg0MA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452194840", "bodyText": "I think we should document literal processing in the 01-type-system.md.", "author": "devozerov", "createdAt": "2020-07-09T12:54:01Z", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/SqlNodeUtil.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.validate;\n+\n+import com.hazelcast.sql.SqlErrorCode;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.type.converter.StringConverter;\n+import org.apache.calcite.runtime.CalciteContextException;\n+import org.apache.calcite.sql.SqlDynamicParam;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.SqlLiteral;\n+import org.apache.calcite.sql.SqlNode;\n+import org.apache.calcite.sql.SqlUtil;\n+\n+import java.math.BigDecimal;\n+\n+import static org.apache.calcite.sql.type.SqlTypeName.CHAR_TYPES;\n+import static org.apache.calcite.sql.type.SqlTypeName.DECIMAL;\n+import static org.apache.calcite.sql.type.SqlTypeName.NUMERIC_TYPES;\n+import static org.apache.calcite.util.Static.RESOURCE;\n+\n+/**\n+ * Utility methods to work with {@link SqlNode}s.\n+ */\n+public final class SqlNodeUtil {", "originalCommit": "d9a7be2618464e26ab4f2a08f66a7ac167b45e0e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYzMzAxOA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r466633018", "bodyText": "Resolving, this could be done separately.", "author": "devozerov", "createdAt": "2020-08-06T19:19:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjE5NDg0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjE5NTc3NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452195775", "bodyText": "If we agree to expose objects as ANY, then this should be reflected in the 01-type-system.md", "author": "devozerov", "createdAt": "2020-07-09T12:55:33Z", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/SqlToQueryType.java", "diffHunk": "@@ -69,6 +72,9 @@\n \n         HZ_TO_CALCITE.put(QueryDataTypeFamily.OBJECT, SqlTypeName.ANY);", "originalCommit": "d9a7be2618464e26ab4f2a08f66a7ac167b45e0e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjExOTgzNA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r462119834", "bodyText": "After all the fixes applied in this PR there should be no mentions of ANY visible to users.", "author": "taburet", "createdAt": "2020-07-29T08:14:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjE5NTc3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjE5ODQxNg==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452198416", "bodyText": "Can we document why we rewrite CASE and do the overload lookup? What would happen if we do not have this class?", "author": "devozerov", "createdAt": "2020-07-09T12:59:42Z", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/HazelcastOperatorTableVisitor.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.validate;\n+\n+import com.hazelcast.sql.impl.calcite.validate.operators.HazelcastSqlCase;\n+import org.apache.calcite.sql.SqlBasicCall;\n+import org.apache.calcite.sql.SqlCall;\n+import org.apache.calcite.sql.SqlNode;\n+import org.apache.calcite.sql.SqlNodeList;\n+import org.apache.calcite.sql.SqlOperator;\n+import org.apache.calcite.sql.fun.SqlCase;\n+import org.apache.calcite.sql.fun.SqlStdOperatorTable;\n+import org.apache.calcite.sql.util.SqlBasicVisitor;\n+import org.apache.calcite.sql.validate.SqlNameMatcher;\n+import org.apache.calcite.sql.validate.SqlNameMatchers;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Rewrites operators in SqlNode tree from Calcite ones to Hazelcast ones.\n+ *\n+ * @see SqlStdOperatorTable\n+ * @see HazelcastSqlOperatorTable\n+ */\n+public final class HazelcastOperatorTableVisitor extends SqlBasicVisitor<Void> {", "originalCommit": "d9a7be2618464e26ab4f2a08f66a7ac167b45e0e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjEyNzEwNg==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r462127106", "bodyText": "fixed in 7f2b7d1", "author": "taburet", "createdAt": "2020-07-29T08:25:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjE5ODQxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjIwMjc3MA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452202770", "bodyText": "Could you please clarify the purpose of this method? I understand why it is constant for DIVIDE. But as far as AND and OR - does NULL on the one side guarantee monotonicity anyhow? They may return FALSE/NULL and TRUE/NULL respectively, which doesn't seem monotonic to me.", "author": "devozerov", "createdAt": "2020-07-09T13:06:59Z", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/operators/HazelcastSqlBinaryOperator.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.validate.operators;\n+\n+import com.hazelcast.sql.impl.calcite.validate.HazelcastSqlOperatorTable;\n+import org.apache.calcite.sql.SqlBinaryOperator;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.SqlOperatorBinding;\n+import org.apache.calcite.sql.type.SqlOperandTypeChecker;\n+import org.apache.calcite.sql.type.SqlOperandTypeInference;\n+import org.apache.calcite.sql.type.SqlReturnTypeInference;\n+import org.apache.calcite.sql.validate.SqlMonotonicity;\n+import org.apache.calcite.util.Litmus;\n+\n+/**\n+ * The same as {@link SqlBinaryOperator}, but supports monotonicity for NULL\n+ * literals and operators from our custom {@link HazelcastSqlOperatorTable}.\n+ */\n+public class HazelcastSqlBinaryOperator extends SqlBinaryOperator {\n+\n+    public HazelcastSqlBinaryOperator(String name, SqlKind kind, int prec, boolean leftAssoc,\n+                                      SqlReturnTypeInference returnTypeInference, SqlOperandTypeInference operandTypeInference,\n+                                      SqlOperandTypeChecker operandTypeChecker) {\n+        super(name, kind, prec, leftAssoc, returnTypeInference, operandTypeInference, operandTypeChecker);\n+    }\n+\n+    @Override\n+    public SqlMonotonicity getMonotonicity(SqlOperatorBinding call) {\n+        if (call.isOperandNull(0, true) || call.isOperandNull(1, true)) {", "originalCommit": "d9a7be2618464e26ab4f2a08f66a7ac167b45e0e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE1MDE0OA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r462150148", "bodyText": "Good catch, fixed in 6300cb6", "author": "taburet", "createdAt": "2020-07-29T09:03:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjIwMjc3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjIwMzE3Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452203172", "bodyText": "Is it correct that DIVIDE uses this class and not HazelcastSqlMonotonicBinaryOperator?", "author": "devozerov", "createdAt": "2020-07-09T13:07:36Z", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/operators/HazelcastSqlBinaryOperator.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.validate.operators;\n+\n+import com.hazelcast.sql.impl.calcite.validate.HazelcastSqlOperatorTable;\n+import org.apache.calcite.sql.SqlBinaryOperator;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.SqlOperatorBinding;\n+import org.apache.calcite.sql.type.SqlOperandTypeChecker;\n+import org.apache.calcite.sql.type.SqlOperandTypeInference;\n+import org.apache.calcite.sql.type.SqlReturnTypeInference;\n+import org.apache.calcite.sql.validate.SqlMonotonicity;\n+import org.apache.calcite.util.Litmus;\n+\n+/**\n+ * The same as {@link SqlBinaryOperator}, but supports monotonicity for NULL\n+ * literals and operators from our custom {@link HazelcastSqlOperatorTable}.\n+ */\n+public class HazelcastSqlBinaryOperator extends SqlBinaryOperator {\n+\n+    public HazelcastSqlBinaryOperator(String name, SqlKind kind, int prec, boolean leftAssoc,", "originalCommit": "d9a7be2618464e26ab4f2a08f66a7ac167b45e0e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgyMDExNw==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452820117", "bodyText": "Calcite does the same, not sure what the reason is, probably division doesn't have all the properties to classify it as monotonic.", "author": "taburet", "createdAt": "2020-07-10T12:45:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjIwMzE3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjIwNjE1NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452206154", "bodyText": "This edge case is not covered with tests. Can we really have lastResult == null?", "author": "devozerov", "createdAt": "2020-07-09T13:12:24Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/predicate/CaseExpression.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.predicate;\n+\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+/**\n+ * Implements evaluation of SQL CASE operator.\n+ */\n+public final class CaseExpression<T> implements Expression<T>, IdentifiedDataSerializable {\n+\n+    private Expression<Boolean>[] conditions;\n+    private Expression<?>[] results;\n+    private QueryDataType resultType;\n+\n+    public CaseExpression() {\n+        // No-op.\n+    }\n+\n+    private CaseExpression(Expression<Boolean>[] conditions, Expression<?>[] results, QueryDataType resultType) {\n+        this.conditions = conditions;\n+        this.results = results;\n+        this.resultType = resultType;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public static CaseExpression<?> create(Expression<?>[] expressions, QueryDataType resultType) {\n+        // Split conditions and expressions.\n+        assert expressions != null;\n+        assert expressions.length % 2 == 1;\n+\n+        int conditionCount = expressions.length / 2;\n+\n+        Expression<Boolean>[] conditions = new Expression[conditionCount];\n+        Expression<?>[] results = new Expression[conditionCount + 1];\n+\n+        int idx = 0;\n+\n+        for (int i = 0; i < conditionCount; i++) {\n+            conditions[i] = (Expression<Boolean>) expressions[idx++];\n+            results[i] = expressions[idx++];\n+        }\n+\n+        // Last expression might be null.\n+        results[results.length - 1] = expressions.length == idx + 1 ? expressions[idx] : null;\n+\n+        // Done.\n+        return new CaseExpression<>(conditions, results, resultType);\n+    }\n+\n+    @Override\n+    public int getFactoryId() {\n+        return SqlDataSerializerHook.F_ID;\n+    }\n+\n+    @Override\n+    public int getClassId() {\n+        return SqlDataSerializerHook.EXPRESSION_CASE;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public T eval(Row row, ExpressionEvalContext context) {\n+        for (int i = 0; i < conditions.length; i++) {\n+            Expression<Boolean> condition = conditions[i];\n+\n+            Boolean conditionHolds = condition.eval(row, context);\n+            if (TernaryLogic.isTrue(conditionHolds)) {\n+                return (T) results[i].eval(row, context);\n+            }\n+        }\n+\n+        // Return the last result if none conditions were met.\n+        Expression<?> lastResult = results[results.length - 1];\n+\n+        if (lastResult != null) {\n+            return (T) lastResult.eval(row, context);\n+        } else {\n+            return null;", "originalCommit": "d9a7be2618464e26ab4f2a08f66a7ac167b45e0e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgyMDg1NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452820855", "bodyText": "Honestly, no idea, I just copied it from the pre-existing implementation. I will check it.", "author": "taburet", "createdAt": "2020-07-10T12:47:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjIwNjE1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE2Nzk1OA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r462167958", "bodyText": "It can't be null, fixed in 6201d4d", "author": "taburet", "createdAt": "2020-07-29T09:33:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjIwNjE1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjIxMTQ5Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452211493", "bodyText": "A common comment to all math functions: how do we handle overflow? We are very careful with an overflow for Converter-s, but it seems that we may easily overflow here as well, and this is not handled properly. Or maybe the trick is that the overflow never happens here thanks type widening that happens during planning? If yes - is this the case for all math operators?\nCan we add explicit tests to handle overflow for math operations to prove the correctness?", "author": "devozerov", "createdAt": "2020-07-09T13:20:21Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/math/PlusFunction.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.math;\n+\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.SqlErrorCode;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.BiExpressionWithType;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import com.hazelcast.sql.impl.type.QueryDataTypeFamily;\n+\n+import java.math.BigDecimal;\n+\n+/**\n+ * Implements evaluation of SQL plus operator.\n+ */\n+public final class PlusFunction<T> extends BiExpressionWithType<T> implements IdentifiedDataSerializable {\n+\n+    public PlusFunction() {\n+        // No-op.\n+    }\n+\n+    private PlusFunction(Expression<?> operand1, Expression<?> operand2, QueryDataType resultType) {\n+        super(operand1, operand2, resultType);\n+    }\n+\n+    public static PlusFunction<?> create(Expression<?> operand1, Expression<?> operand2, QueryDataType resultType) {\n+        return new PlusFunction<>(operand1, operand2, resultType);\n+    }\n+\n+    @Override\n+    public int getFactoryId() {\n+        return SqlDataSerializerHook.F_ID;\n+    }\n+\n+    @Override\n+    public int getClassId() {\n+        return SqlDataSerializerHook.EXPRESSION_PLUS;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public T eval(Row row, ExpressionEvalContext context) {\n+        Object left = operand1.eval(row, context);\n+        if (left == null) {\n+            return null;\n+        }\n+\n+        Object right = operand2.eval(row, context);\n+        if (right == null) {\n+            return null;\n+        }\n+\n+        QueryDataTypeFamily family = resultType.getTypeFamily();\n+        if (family.isTemporal()) {\n+            throw new UnsupportedOperationException(\"temporal types are unsupported currently\");\n+        }\n+\n+        return (T) evalNumeric((Number) left, (Number) right, family);\n+    }\n+\n+    private static Object evalNumeric(Number left, Number right, QueryDataTypeFamily family) {\n+        switch (family) {\n+            case TINYINT:\n+                return (byte) (left.byteValue() + right.byteValue());", "originalCommit": "d9a7be2618464e26ab4f2a08f66a7ac167b45e0e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgyNDQxNQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452824415", "bodyText": "Yes, the overflow should never happen if we didn't detect its possibility during validation and type inference. If its possibility is detected, the widening is performed until we hit long. Currently, all operations with long are checked for overflow, but that's not really necessary in all cases. It's just about equally expensive to check for an overflow as to check for the necessity of this check. But for compiled expressions that still might be a huge win to omit the overflow checks. See HazelcastIntegerType.canOverflow.", "author": "taburet", "createdAt": "2020-07-10T12:54:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjIxMTQ5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjIxNDgyMA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452214820", "bodyText": "It seems that we do not support comparison for ANY type. What is the reason for this? If two objects have the same type and are comparable, then we can compare them, aren't we?", "author": "devozerov", "createdAt": "2020-07-09T13:25:17Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/predicate/ComparisonPredicate.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.predicate;\n+\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.BiExpression;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+\n+/**\n+ * Implements evaluation of SQL comparison predicates.\n+ *\n+ * @see ComparisonMode\n+ */\n+public final class ComparisonPredicate extends BiExpression<Boolean> implements IdentifiedDataSerializable {\n+\n+    private ComparisonMode mode;\n+\n+    public ComparisonPredicate() {\n+        // No-op.\n+    }\n+\n+    private ComparisonPredicate(Expression<?> left, Expression<?> right, ComparisonMode mode) {\n+        super(left, right);\n+        this.mode = mode;\n+    }\n+\n+    public static ComparisonPredicate create(Expression<?> left, Expression<?> right, ComparisonMode comparisonMode) {\n+        assert left.getType().equals(right.getType());\n+        return new ComparisonPredicate(left, right, comparisonMode);\n+    }\n+\n+    @Override\n+    public int getFactoryId() {\n+        return SqlDataSerializerHook.F_ID;\n+    }\n+\n+    @Override\n+    public int getClassId() {\n+        return SqlDataSerializerHook.EXPRESSION_COMPARISON;\n+    }\n+\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    @SuppressFBWarnings(value = \"NP_BOOLEAN_RETURN_NULL\", justification = \"Any SQL expression may return null\")\n+    @Override\n+    public Boolean eval(Row row, ExpressionEvalContext context) {\n+        Object left = operand1.eval(row, context);\n+        if (left == null) {\n+            return null;\n+        }\n+\n+        Object right = operand2.eval(row, context);\n+        if (right == null) {\n+            return null;\n+        }\n+\n+        Comparable leftComparable = (Comparable) left;", "originalCommit": "d9a7be2618464e26ab4f2a08f66a7ac167b45e0e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE5MTk5OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r462191999", "bodyText": "Initially I started working on it, but there were too many open questions. For instance, OBJECT = OBJECT basically means we are comparing one object of unknown type to another object of unknown type, we can't be 100% sure they are comparable during query validation. Next, if we would allow comparisons for objects of unknown types, it's also logical to allow comparisons of a known type to an unknown one, like 'VARCHAR = OBJECT'. It's not clear should we use equals instead of compareTo, if one or both of the operands are not implementing Comparable and how that all would interact with indexes. So I decided to postpone it, if you think it's critical to have it in 4.1, I may continue the work.", "author": "taburet", "createdAt": "2020-07-29T10:14:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjIxNDgyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ4OTI5MA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r462489290", "bodyText": "I think we should create an issue, and try squeezing it into 4.1 once other more important expressions are ready. If not, we can do that in 4.2. But we need a ticket not to forget about this limitation.\nI am not fully sure about non-equality comparisons, but not allowing comparing objects for equality doesn't seem good for the engine.", "author": "devozerov", "createdAt": "2020-07-29T18:06:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjIxNDgyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDg0NDM2Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r464844363", "bodyText": "created an issue #17302 for 4.2", "author": "taburet", "createdAt": "2020-08-04T07:08:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjIxNDgyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjIxNTIyMA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452215220", "bodyText": "Is it guaranteed that two operands are coerced to the same type by this point?", "author": "devozerov", "createdAt": "2020-07-09T13:25:50Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/predicate/ComparisonPredicate.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.predicate;\n+\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.BiExpression;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+\n+/**\n+ * Implements evaluation of SQL comparison predicates.\n+ *\n+ * @see ComparisonMode\n+ */\n+public final class ComparisonPredicate extends BiExpression<Boolean> implements IdentifiedDataSerializable {\n+\n+    private ComparisonMode mode;\n+\n+    public ComparisonPredicate() {\n+        // No-op.\n+    }\n+\n+    private ComparisonPredicate(Expression<?> left, Expression<?> right, ComparisonMode mode) {\n+        super(left, right);\n+        this.mode = mode;\n+    }\n+\n+    public static ComparisonPredicate create(Expression<?> left, Expression<?> right, ComparisonMode comparisonMode) {\n+        assert left.getType().equals(right.getType());\n+        return new ComparisonPredicate(left, right, comparisonMode);\n+    }\n+\n+    @Override\n+    public int getFactoryId() {\n+        return SqlDataSerializerHook.F_ID;\n+    }\n+\n+    @Override\n+    public int getClassId() {\n+        return SqlDataSerializerHook.EXPRESSION_COMPARISON;\n+    }\n+\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    @SuppressFBWarnings(value = \"NP_BOOLEAN_RETURN_NULL\", justification = \"Any SQL expression may return null\")\n+    @Override\n+    public Boolean eval(Row row, ExpressionEvalContext context) {\n+        Object left = operand1.eval(row, context);\n+        if (left == null) {\n+            return null;\n+        }\n+\n+        Object right = operand2.eval(row, context);\n+        if (right == null) {\n+            return null;\n+        }\n+\n+        Comparable leftComparable = (Comparable) left;\n+        Comparable rightComparable = (Comparable) right;\n+\n+        int order = leftComparable.compareTo(rightComparable);", "originalCommit": "d9a7be2618464e26ab4f2a08f66a7ac167b45e0e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE5NTExNA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r462195114", "bodyText": "Yes, it is.", "author": "taburet", "createdAt": "2020-07-29T10:21:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjIxNTIyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjIxNzczNQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452217735", "bodyText": "I am not sure whether this is worth, but - we rely on casts heavily now, therefore the performance is important. In principle, we may avoid calling converter at all if the object is already of expected type:\nif (resultType.getConverter().getNormalizedValueClass() == value.getClass()) {\n    return value;\n}", "author": "devozerov", "createdAt": "2020-07-09T13:29:35Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/CastExpression.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression;\n+\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import com.hazelcast.sql.impl.type.converter.Converter;\n+\n+/**\n+ * Implements evaluation of SQL CAST operator.\n+ */\n+public final class CastExpression<T> extends UniExpressionWithType<T> implements IdentifiedDataSerializable {\n+\n+    public CastExpression() {\n+        // No-op.\n+    }\n+\n+    private CastExpression(Expression<?> operand, QueryDataType resultType) {\n+        super(operand, resultType);\n+    }\n+\n+    public static CastExpression<?> create(Expression<?> operand, QueryDataType resultType) {\n+        return new CastExpression<>(operand, resultType);\n+    }\n+\n+    @Override\n+    public int getFactoryId() {\n+        return SqlDataSerializerHook.F_ID;\n+    }\n+\n+    @Override\n+    public int getClassId() {\n+        return SqlDataSerializerHook.EXPRESSION_CAST;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public T eval(Row row, ExpressionEvalContext context) {\n+        Object value = operand.eval(row, context);\n+\n+        if (value == null) {\n+            return null;\n+        }\n+\n+        Converter fromConverter = operand.getType().getConverter();", "originalCommit": "d9a7be2618464e26ab4f2a08f66a7ac167b45e0e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIyNjk1MA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r462226950", "bodyText": "Casts should be inserted only if they are really needed, so there is no point in performing additional checks.", "author": "taburet", "createdAt": "2020-07-29T11:24:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjIxNzczNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ5MDQyMw==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r462490423", "bodyText": "How about a parameter placeholder, that is coerced to BIGINT, while the parameter itself is already Long?", "author": "devozerov", "createdAt": "2020-07-29T18:08:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjIxNzczNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjc0MTkwNQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r462741905", "bodyText": "Parameters should never be coerced through cast insertion, they just get some type assigned during validation, there should be no casts produced. If a parameter is casted explicitly by user, the parameter receives a type derived from the cast: cast(? as int), the parameter receives int type, the cast itself is optimized away. While preparing parameter arguments for a query, all the passed arguments are converted to their expected types once.", "author": "taburet", "createdAt": "2020-07-30T05:22:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjIxNzczNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjI1NTcxOA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452255718", "bodyText": "It seems that knowNodeTypes solves some specific problem with the CASE operator. Could you please add JavaDocs explaining the problem?", "author": "devozerov", "createdAt": "2020-07-09T14:22:53Z", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/HazelcastSqlValidator.java", "diffHunk": "@@ -17,53 +17,284 @@\n package com.hazelcast.sql.impl.calcite.validate;\n \n import com.hazelcast.sql.impl.calcite.schema.HazelcastTable;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastIntegerType;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeCoercion;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeFactory;\n import org.apache.calcite.rel.type.RelDataType;\n-import org.apache.calcite.rel.type.RelDataTypeFactory;\n import org.apache.calcite.sql.SqlCall;\n import org.apache.calcite.sql.SqlIdentifier;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.SqlLiteral;\n import org.apache.calcite.sql.SqlNode;\n import org.apache.calcite.sql.SqlOperatorTable;\n+import org.apache.calcite.sql.SqlSelect;\n+import org.apache.calcite.sql.SqlUtil;\n+import org.apache.calcite.sql.type.SqlTypeName;\n import org.apache.calcite.sql.validate.SelectScope;\n import org.apache.calcite.sql.validate.SqlConformance;\n import org.apache.calcite.sql.validate.SqlQualified;\n import org.apache.calcite.sql.validate.SqlValidatorCatalogReader;\n import org.apache.calcite.sql.validate.SqlValidatorImpl;\n+import org.apache.calcite.sql.validate.SqlValidatorScope;\n import org.apache.calcite.sql.validate.SqlValidatorTable;\n import org.apache.calcite.util.Util;\n \n+import java.math.BigDecimal;\n+import java.util.IdentityHashMap;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n+import static com.hazelcast.sql.impl.calcite.validate.SqlNodeUtil.isLiteral;\n+import static com.hazelcast.sql.impl.calcite.validate.SqlNodeUtil.isParameter;\n+import static com.hazelcast.sql.impl.calcite.validate.SqlNodeUtil.numericValue;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.canRepresent;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.isInteger;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.isNumeric;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.narrowestTypeFor;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.typeName;\n+import static org.apache.calcite.sql.type.SqlTypeName.CHAR;\n+import static org.apache.calcite.sql.type.SqlTypeName.DECIMAL;\n+import static org.apache.calcite.sql.type.SqlTypeName.DOUBLE;\n+import static org.apache.calcite.sql.type.SqlTypeName.NULL;\n+import static org.apache.calcite.sql.type.SqlTypeName.NUMERIC_TYPES;\n+import static org.apache.calcite.sql.type.SqlTypeName.VARCHAR;\n+import static org.apache.calcite.util.Static.RESOURCE;\n+\n /**\n  * Hazelcast-specific SQL validator.\n  */\n public class HazelcastSqlValidator extends SqlValidatorImpl {\n-    public HazelcastSqlValidator(\n-        SqlOperatorTable opTab,\n-        SqlValidatorCatalogReader catalogReader,\n-        RelDataTypeFactory typeFactory,\n-        SqlConformance conformance\n-    ) {\n-        super(opTab, catalogReader, typeFactory, Config.DEFAULT.withSqlConformance(conformance));\n+\n+    private static final Config CONFIG = Config.DEFAULT.withIdentifierExpansion(true);\n+\n+    private final Map<SqlNode, RelDataType> knownNodeTypes = new IdentityHashMap<>();\n+\n+    public HazelcastSqlValidator(SqlOperatorTable opTab, SqlValidatorCatalogReader catalogReader,\n+                                 HazelcastTypeFactory typeFactory, SqlConformance conformance) {\n+        super(opTab, catalogReader, typeFactory, CONFIG.withSqlConformance(conformance));\n+        setTypeCoercion(new HazelcastTypeCoercion(this));\n+    }\n+\n+    /**\n+     * Sets {@code type} as the known type for {@code node}.\n+     *\n+     * @param node the node to set the known type of.\n+     * @param type the type to set the know node type to.\n+     */\n+    public void setKnownNodeType(SqlNode node, RelDataType type) {\n+        assert !getUnknownType().equals(type);\n+        knownNodeTypes.put(node, type);\n+    }\n+\n+    /**\n+     * Obtains a type known by this validator for the given node.\n+     *\n+     * @param node the node to obtain the type of.\n+     * @return the node type known by this validator or {@code null} if the type\n+     * of the given node is not known yet.\n+     */\n+    public RelDataType getKnownNodeType(SqlNode node) {", "originalCommit": "1e5c9a84cbe56c63dbf43102116d335ce6cacfc4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjc1Mzg0MA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r462753840", "bodyText": "fixed in 598a751", "author": "taburet", "createdAt": "2020-07-30T06:02:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjI1NTcxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcyNzIzNA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452727234", "bodyText": "This method does nothing in the current PR since we do not support LIMIT/OFFSET.\nI would propose to remove it for now and keep only in the sql branch because from the 4.1 perspective this is a not-tested dead code.", "author": "devozerov", "createdAt": "2020-07-10T09:19:07Z", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/HazelcastSqlValidator.java", "diffHunk": "@@ -17,53 +17,284 @@\n package com.hazelcast.sql.impl.calcite.validate;\n \n import com.hazelcast.sql.impl.calcite.schema.HazelcastTable;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastIntegerType;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeCoercion;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeFactory;\n import org.apache.calcite.rel.type.RelDataType;\n-import org.apache.calcite.rel.type.RelDataTypeFactory;\n import org.apache.calcite.sql.SqlCall;\n import org.apache.calcite.sql.SqlIdentifier;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.SqlLiteral;\n import org.apache.calcite.sql.SqlNode;\n import org.apache.calcite.sql.SqlOperatorTable;\n+import org.apache.calcite.sql.SqlSelect;\n+import org.apache.calcite.sql.SqlUtil;\n+import org.apache.calcite.sql.type.SqlTypeName;\n import org.apache.calcite.sql.validate.SelectScope;\n import org.apache.calcite.sql.validate.SqlConformance;\n import org.apache.calcite.sql.validate.SqlQualified;\n import org.apache.calcite.sql.validate.SqlValidatorCatalogReader;\n import org.apache.calcite.sql.validate.SqlValidatorImpl;\n+import org.apache.calcite.sql.validate.SqlValidatorScope;\n import org.apache.calcite.sql.validate.SqlValidatorTable;\n import org.apache.calcite.util.Util;\n \n+import java.math.BigDecimal;\n+import java.util.IdentityHashMap;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n+import static com.hazelcast.sql.impl.calcite.validate.SqlNodeUtil.isLiteral;\n+import static com.hazelcast.sql.impl.calcite.validate.SqlNodeUtil.isParameter;\n+import static com.hazelcast.sql.impl.calcite.validate.SqlNodeUtil.numericValue;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.canRepresent;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.isInteger;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.isNumeric;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.narrowestTypeFor;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.typeName;\n+import static org.apache.calcite.sql.type.SqlTypeName.CHAR;\n+import static org.apache.calcite.sql.type.SqlTypeName.DECIMAL;\n+import static org.apache.calcite.sql.type.SqlTypeName.DOUBLE;\n+import static org.apache.calcite.sql.type.SqlTypeName.NULL;\n+import static org.apache.calcite.sql.type.SqlTypeName.NUMERIC_TYPES;\n+import static org.apache.calcite.sql.type.SqlTypeName.VARCHAR;\n+import static org.apache.calcite.util.Static.RESOURCE;\n+\n /**\n  * Hazelcast-specific SQL validator.\n  */\n public class HazelcastSqlValidator extends SqlValidatorImpl {\n-    public HazelcastSqlValidator(\n-        SqlOperatorTable opTab,\n-        SqlValidatorCatalogReader catalogReader,\n-        RelDataTypeFactory typeFactory,\n-        SqlConformance conformance\n-    ) {\n-        super(opTab, catalogReader, typeFactory, Config.DEFAULT.withSqlConformance(conformance));\n+\n+    private static final Config CONFIG = Config.DEFAULT.withIdentifierExpansion(true);\n+\n+    private final Map<SqlNode, RelDataType> knownNodeTypes = new IdentityHashMap<>();\n+\n+    public HazelcastSqlValidator(SqlOperatorTable opTab, SqlValidatorCatalogReader catalogReader,\n+                                 HazelcastTypeFactory typeFactory, SqlConformance conformance) {\n+        super(opTab, catalogReader, typeFactory, CONFIG.withSqlConformance(conformance));\n+        setTypeCoercion(new HazelcastTypeCoercion(this));\n+    }\n+\n+    /**\n+     * Sets {@code type} as the known type for {@code node}.\n+     *\n+     * @param node the node to set the known type of.\n+     * @param type the type to set the know node type to.\n+     */\n+    public void setKnownNodeType(SqlNode node, RelDataType type) {\n+        assert !getUnknownType().equals(type);\n+        knownNodeTypes.put(node, type);\n+    }\n+\n+    /**\n+     * Obtains a type known by this validator for the given node.\n+     *\n+     * @param node the node to obtain the type of.\n+     * @return the node type known by this validator or {@code null} if the type\n+     * of the given node is not known yet.\n+     */\n+    public RelDataType getKnownNodeType(SqlNode node) {\n+        return knownNodeTypes.get(node);\n+    }\n+\n+    @Override\n+    public void validateQuery(SqlNode node, SqlValidatorScope scope, RelDataType targetRowType) {", "originalCommit": "1e5c9a84cbe56c63dbf43102116d335ce6cacfc4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjc2MDUzOA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r462760538", "bodyText": "fixed in 255db16", "author": "taburet", "createdAt": "2020-07-30T06:21:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcyNzIzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcyNzcwOA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452727708", "bodyText": "DDL is not supported in this PR, so the whole validate method could be removed safely.", "author": "devozerov", "createdAt": "2020-07-10T09:20:00Z", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/HazelcastSqlValidator.java", "diffHunk": "@@ -17,53 +17,284 @@\n package com.hazelcast.sql.impl.calcite.validate;\n \n import com.hazelcast.sql.impl.calcite.schema.HazelcastTable;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastIntegerType;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeCoercion;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeFactory;\n import org.apache.calcite.rel.type.RelDataType;\n-import org.apache.calcite.rel.type.RelDataTypeFactory;\n import org.apache.calcite.sql.SqlCall;\n import org.apache.calcite.sql.SqlIdentifier;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.SqlLiteral;\n import org.apache.calcite.sql.SqlNode;\n import org.apache.calcite.sql.SqlOperatorTable;\n+import org.apache.calcite.sql.SqlSelect;\n+import org.apache.calcite.sql.SqlUtil;\n+import org.apache.calcite.sql.type.SqlTypeName;\n import org.apache.calcite.sql.validate.SelectScope;\n import org.apache.calcite.sql.validate.SqlConformance;\n import org.apache.calcite.sql.validate.SqlQualified;\n import org.apache.calcite.sql.validate.SqlValidatorCatalogReader;\n import org.apache.calcite.sql.validate.SqlValidatorImpl;\n+import org.apache.calcite.sql.validate.SqlValidatorScope;\n import org.apache.calcite.sql.validate.SqlValidatorTable;\n import org.apache.calcite.util.Util;\n \n+import java.math.BigDecimal;\n+import java.util.IdentityHashMap;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n+import static com.hazelcast.sql.impl.calcite.validate.SqlNodeUtil.isLiteral;\n+import static com.hazelcast.sql.impl.calcite.validate.SqlNodeUtil.isParameter;\n+import static com.hazelcast.sql.impl.calcite.validate.SqlNodeUtil.numericValue;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.canRepresent;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.isInteger;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.isNumeric;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.narrowestTypeFor;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.typeName;\n+import static org.apache.calcite.sql.type.SqlTypeName.CHAR;\n+import static org.apache.calcite.sql.type.SqlTypeName.DECIMAL;\n+import static org.apache.calcite.sql.type.SqlTypeName.DOUBLE;\n+import static org.apache.calcite.sql.type.SqlTypeName.NULL;\n+import static org.apache.calcite.sql.type.SqlTypeName.NUMERIC_TYPES;\n+import static org.apache.calcite.sql.type.SqlTypeName.VARCHAR;\n+import static org.apache.calcite.util.Static.RESOURCE;\n+\n /**\n  * Hazelcast-specific SQL validator.\n  */\n public class HazelcastSqlValidator extends SqlValidatorImpl {\n-    public HazelcastSqlValidator(\n-        SqlOperatorTable opTab,\n-        SqlValidatorCatalogReader catalogReader,\n-        RelDataTypeFactory typeFactory,\n-        SqlConformance conformance\n-    ) {\n-        super(opTab, catalogReader, typeFactory, Config.DEFAULT.withSqlConformance(conformance));\n+\n+    private static final Config CONFIG = Config.DEFAULT.withIdentifierExpansion(true);\n+\n+    private final Map<SqlNode, RelDataType> knownNodeTypes = new IdentityHashMap<>();\n+\n+    public HazelcastSqlValidator(SqlOperatorTable opTab, SqlValidatorCatalogReader catalogReader,\n+                                 HazelcastTypeFactory typeFactory, SqlConformance conformance) {\n+        super(opTab, catalogReader, typeFactory, CONFIG.withSqlConformance(conformance));\n+        setTypeCoercion(new HazelcastTypeCoercion(this));\n+    }\n+\n+    /**\n+     * Sets {@code type} as the known type for {@code node}.\n+     *\n+     * @param node the node to set the known type of.\n+     * @param type the type to set the know node type to.\n+     */\n+    public void setKnownNodeType(SqlNode node, RelDataType type) {\n+        assert !getUnknownType().equals(type);\n+        knownNodeTypes.put(node, type);\n+    }\n+\n+    /**\n+     * Obtains a type known by this validator for the given node.\n+     *\n+     * @param node the node to obtain the type of.\n+     * @return the node type known by this validator or {@code null} if the type\n+     * of the given node is not known yet.\n+     */\n+    public RelDataType getKnownNodeType(SqlNode node) {\n+        return knownNodeTypes.get(node);\n+    }\n+\n+    @Override\n+    public void validateQuery(SqlNode node, SqlValidatorScope scope, RelDataType targetRowType) {\n+        super.validateQuery(node, scope, targetRowType);\n+\n+        if (node instanceof SqlSelect) {\n+            // Derive the types for offset-fetch expressions, Calcite doesn't do\n+            // that automatically.\n+\n+            SqlSelect select = (SqlSelect) node;\n+\n+            SqlNode offset = select.getOffset();\n+            if (offset != null) {\n+                deriveType(scope, offset);\n+            }\n+\n+            SqlNode fetch = select.getFetch();\n+            if (fetch != null) {\n+                deriveType(scope, fetch);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public SqlNode validate(SqlNode topNode) {\n+        if (topNode.getKind().belongsTo(SqlKind.DDL)) {", "originalCommit": "1e5c9a84cbe56c63dbf43102116d335ce6cacfc4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjc2MDkzOQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r462760939", "bodyText": "fixrd in 417d1eb", "author": "taburet", "createdAt": "2020-07-30T06:22:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcyNzcwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcyODUwMw==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452728503", "bodyText": "Can we have an example of before-and-after states here, to better understand the reason of having this rewrite?", "author": "devozerov", "createdAt": "2020-07-10T09:21:31Z", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/HazelcastSqlValidator.java", "diffHunk": "@@ -17,53 +17,284 @@\n package com.hazelcast.sql.impl.calcite.validate;\n \n import com.hazelcast.sql.impl.calcite.schema.HazelcastTable;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastIntegerType;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeCoercion;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeFactory;\n import org.apache.calcite.rel.type.RelDataType;\n-import org.apache.calcite.rel.type.RelDataTypeFactory;\n import org.apache.calcite.sql.SqlCall;\n import org.apache.calcite.sql.SqlIdentifier;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.SqlLiteral;\n import org.apache.calcite.sql.SqlNode;\n import org.apache.calcite.sql.SqlOperatorTable;\n+import org.apache.calcite.sql.SqlSelect;\n+import org.apache.calcite.sql.SqlUtil;\n+import org.apache.calcite.sql.type.SqlTypeName;\n import org.apache.calcite.sql.validate.SelectScope;\n import org.apache.calcite.sql.validate.SqlConformance;\n import org.apache.calcite.sql.validate.SqlQualified;\n import org.apache.calcite.sql.validate.SqlValidatorCatalogReader;\n import org.apache.calcite.sql.validate.SqlValidatorImpl;\n+import org.apache.calcite.sql.validate.SqlValidatorScope;\n import org.apache.calcite.sql.validate.SqlValidatorTable;\n import org.apache.calcite.util.Util;\n \n+import java.math.BigDecimal;\n+import java.util.IdentityHashMap;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n+import static com.hazelcast.sql.impl.calcite.validate.SqlNodeUtil.isLiteral;\n+import static com.hazelcast.sql.impl.calcite.validate.SqlNodeUtil.isParameter;\n+import static com.hazelcast.sql.impl.calcite.validate.SqlNodeUtil.numericValue;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.canRepresent;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.isInteger;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.isNumeric;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.narrowestTypeFor;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.typeName;\n+import static org.apache.calcite.sql.type.SqlTypeName.CHAR;\n+import static org.apache.calcite.sql.type.SqlTypeName.DECIMAL;\n+import static org.apache.calcite.sql.type.SqlTypeName.DOUBLE;\n+import static org.apache.calcite.sql.type.SqlTypeName.NULL;\n+import static org.apache.calcite.sql.type.SqlTypeName.NUMERIC_TYPES;\n+import static org.apache.calcite.sql.type.SqlTypeName.VARCHAR;\n+import static org.apache.calcite.util.Static.RESOURCE;\n+\n /**\n  * Hazelcast-specific SQL validator.\n  */\n public class HazelcastSqlValidator extends SqlValidatorImpl {\n-    public HazelcastSqlValidator(\n-        SqlOperatorTable opTab,\n-        SqlValidatorCatalogReader catalogReader,\n-        RelDataTypeFactory typeFactory,\n-        SqlConformance conformance\n-    ) {\n-        super(opTab, catalogReader, typeFactory, Config.DEFAULT.withSqlConformance(conformance));\n+\n+    private static final Config CONFIG = Config.DEFAULT.withIdentifierExpansion(true);\n+\n+    private final Map<SqlNode, RelDataType> knownNodeTypes = new IdentityHashMap<>();\n+\n+    public HazelcastSqlValidator(SqlOperatorTable opTab, SqlValidatorCatalogReader catalogReader,\n+                                 HazelcastTypeFactory typeFactory, SqlConformance conformance) {\n+        super(opTab, catalogReader, typeFactory, CONFIG.withSqlConformance(conformance));\n+        setTypeCoercion(new HazelcastTypeCoercion(this));\n+    }\n+\n+    /**\n+     * Sets {@code type} as the known type for {@code node}.\n+     *\n+     * @param node the node to set the known type of.\n+     * @param type the type to set the know node type to.\n+     */\n+    public void setKnownNodeType(SqlNode node, RelDataType type) {\n+        assert !getUnknownType().equals(type);\n+        knownNodeTypes.put(node, type);\n+    }\n+\n+    /**\n+     * Obtains a type known by this validator for the given node.\n+     *\n+     * @param node the node to obtain the type of.\n+     * @return the node type known by this validator or {@code null} if the type\n+     * of the given node is not known yet.\n+     */\n+    public RelDataType getKnownNodeType(SqlNode node) {\n+        return knownNodeTypes.get(node);\n+    }\n+\n+    @Override\n+    public void validateQuery(SqlNode node, SqlValidatorScope scope, RelDataType targetRowType) {\n+        super.validateQuery(node, scope, targetRowType);\n+\n+        if (node instanceof SqlSelect) {\n+            // Derive the types for offset-fetch expressions, Calcite doesn't do\n+            // that automatically.\n+\n+            SqlSelect select = (SqlSelect) node;\n+\n+            SqlNode offset = select.getOffset();\n+            if (offset != null) {\n+                deriveType(scope, offset);\n+            }\n+\n+            SqlNode fetch = select.getFetch();\n+            if (fetch != null) {\n+                deriveType(scope, fetch);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public SqlNode validate(SqlNode topNode) {\n+        if (topNode.getKind().belongsTo(SqlKind.DDL)) {\n+            return topNode;\n+        }\n+\n+        return super.validate(topNode);\n     }\n \n     @Override\n-    protected void addToSelectList(\n-        List<SqlNode> list,\n-        Set<String> aliases,\n-        List<Map.Entry<String, RelDataType>> fieldList,\n-        SqlNode exp,\n-        SelectScope scope,\n-        boolean includeSystemVars\n-    ) {\n+    protected void addToSelectList(List<SqlNode> list, Set<String> aliases, List<Map.Entry<String, RelDataType>> fieldList,\n+                                   SqlNode exp, SelectScope scope, boolean includeSystemVars) {\n         if (isHiddenColumn(exp, scope)) {\n             return;\n         }\n \n         super.addToSelectList(list, aliases, fieldList, exp, scope, includeSystemVars);\n     }\n \n+    @Override\n+    public RelDataType deriveType(SqlValidatorScope scope, SqlNode expression) {\n+        RelDataType derived = super.deriveType(scope, expression);\n+        assert derived != null;\n+\n+        if (derived.getSqlTypeName() == CHAR) {\n+            // normalize CHAR to VARCHAR\n+            derived = HazelcastTypeFactory.INSTANCE.createSqlType(VARCHAR, derived.isNullable());\n+            setValidatedNodeType(expression, derived);\n+        }\n+\n+        switch (expression.getKind()) {\n+            case LITERAL:\n+                return deriveLiteralType(derived, expression);\n+\n+            case CAST:\n+                return deriveCastType(derived, scope, expression);\n+\n+            default:\n+                return derived;\n+        }\n+    }\n+\n+    @Override\n+    public void validateLiteral(SqlLiteral literal) {\n+        validateLiteral(literal, getValidatedNodeType(literal));\n+    }\n+\n+    @Override\n+    public void validateCall(SqlCall call, SqlValidatorScope scope) {\n+        // Enforce type derivation for all calls before validation. Calcite may\n+        // skip it if a call has a fixed type, for instance AND always has\n+        // BOOLEAN type, so operands may end up having no validated type.\n+        deriveType(scope, call);\n+        super.validateCall(call, scope);\n+    }\n+\n+    @Override\n+    protected SqlNode performUnconditionalRewrites(SqlNode node, boolean underFrom) {\n+        SqlNode rewritten = super.performUnconditionalRewrites(node, underFrom);\n+\n+        if (rewritten != null && rewritten.isA(SqlKind.TOP_LEVEL)) {\n+            // rewrite operators to Hazelcast ones starting at every top node", "originalCommit": "1e5c9a84cbe56c63dbf43102116d335ce6cacfc4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjc2NTA1OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r462765059", "bodyText": "fixed in 1c19573", "author": "taburet", "createdAt": "2020-07-30T06:33:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcyODUwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjczMTk1OA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452731958", "bodyText": "Could you please clarify the reason of this DECIMAL -> DOUBLE conversion? I tried to disable this branch and several tests failed, such as\nExpected :DOUBLE\nActual   :DECIMAL(38, 38)\n\nBut from this failure, it is not clear why is this a problem in the first place. What would happen if we leave DECIMAL here unchanged?", "author": "devozerov", "createdAt": "2020-07-10T09:28:32Z", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/HazelcastSqlValidator.java", "diffHunk": "@@ -17,53 +17,284 @@\n package com.hazelcast.sql.impl.calcite.validate;\n \n import com.hazelcast.sql.impl.calcite.schema.HazelcastTable;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastIntegerType;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeCoercion;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeFactory;\n import org.apache.calcite.rel.type.RelDataType;\n-import org.apache.calcite.rel.type.RelDataTypeFactory;\n import org.apache.calcite.sql.SqlCall;\n import org.apache.calcite.sql.SqlIdentifier;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.SqlLiteral;\n import org.apache.calcite.sql.SqlNode;\n import org.apache.calcite.sql.SqlOperatorTable;\n+import org.apache.calcite.sql.SqlSelect;\n+import org.apache.calcite.sql.SqlUtil;\n+import org.apache.calcite.sql.type.SqlTypeName;\n import org.apache.calcite.sql.validate.SelectScope;\n import org.apache.calcite.sql.validate.SqlConformance;\n import org.apache.calcite.sql.validate.SqlQualified;\n import org.apache.calcite.sql.validate.SqlValidatorCatalogReader;\n import org.apache.calcite.sql.validate.SqlValidatorImpl;\n+import org.apache.calcite.sql.validate.SqlValidatorScope;\n import org.apache.calcite.sql.validate.SqlValidatorTable;\n import org.apache.calcite.util.Util;\n \n+import java.math.BigDecimal;\n+import java.util.IdentityHashMap;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n+import static com.hazelcast.sql.impl.calcite.validate.SqlNodeUtil.isLiteral;\n+import static com.hazelcast.sql.impl.calcite.validate.SqlNodeUtil.isParameter;\n+import static com.hazelcast.sql.impl.calcite.validate.SqlNodeUtil.numericValue;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.canRepresent;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.isInteger;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.isNumeric;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.narrowestTypeFor;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.typeName;\n+import static org.apache.calcite.sql.type.SqlTypeName.CHAR;\n+import static org.apache.calcite.sql.type.SqlTypeName.DECIMAL;\n+import static org.apache.calcite.sql.type.SqlTypeName.DOUBLE;\n+import static org.apache.calcite.sql.type.SqlTypeName.NULL;\n+import static org.apache.calcite.sql.type.SqlTypeName.NUMERIC_TYPES;\n+import static org.apache.calcite.sql.type.SqlTypeName.VARCHAR;\n+import static org.apache.calcite.util.Static.RESOURCE;\n+\n /**\n  * Hazelcast-specific SQL validator.\n  */\n public class HazelcastSqlValidator extends SqlValidatorImpl {\n-    public HazelcastSqlValidator(\n-        SqlOperatorTable opTab,\n-        SqlValidatorCatalogReader catalogReader,\n-        RelDataTypeFactory typeFactory,\n-        SqlConformance conformance\n-    ) {\n-        super(opTab, catalogReader, typeFactory, Config.DEFAULT.withSqlConformance(conformance));\n+\n+    private static final Config CONFIG = Config.DEFAULT.withIdentifierExpansion(true);\n+\n+    private final Map<SqlNode, RelDataType> knownNodeTypes = new IdentityHashMap<>();\n+\n+    public HazelcastSqlValidator(SqlOperatorTable opTab, SqlValidatorCatalogReader catalogReader,\n+                                 HazelcastTypeFactory typeFactory, SqlConformance conformance) {\n+        super(opTab, catalogReader, typeFactory, CONFIG.withSqlConformance(conformance));\n+        setTypeCoercion(new HazelcastTypeCoercion(this));\n+    }\n+\n+    /**\n+     * Sets {@code type} as the known type for {@code node}.\n+     *\n+     * @param node the node to set the known type of.\n+     * @param type the type to set the know node type to.\n+     */\n+    public void setKnownNodeType(SqlNode node, RelDataType type) {\n+        assert !getUnknownType().equals(type);\n+        knownNodeTypes.put(node, type);\n+    }\n+\n+    /**\n+     * Obtains a type known by this validator for the given node.\n+     *\n+     * @param node the node to obtain the type of.\n+     * @return the node type known by this validator or {@code null} if the type\n+     * of the given node is not known yet.\n+     */\n+    public RelDataType getKnownNodeType(SqlNode node) {\n+        return knownNodeTypes.get(node);\n+    }\n+\n+    @Override\n+    public void validateQuery(SqlNode node, SqlValidatorScope scope, RelDataType targetRowType) {\n+        super.validateQuery(node, scope, targetRowType);\n+\n+        if (node instanceof SqlSelect) {\n+            // Derive the types for offset-fetch expressions, Calcite doesn't do\n+            // that automatically.\n+\n+            SqlSelect select = (SqlSelect) node;\n+\n+            SqlNode offset = select.getOffset();\n+            if (offset != null) {\n+                deriveType(scope, offset);\n+            }\n+\n+            SqlNode fetch = select.getFetch();\n+            if (fetch != null) {\n+                deriveType(scope, fetch);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public SqlNode validate(SqlNode topNode) {\n+        if (topNode.getKind().belongsTo(SqlKind.DDL)) {\n+            return topNode;\n+        }\n+\n+        return super.validate(topNode);\n     }\n \n     @Override\n-    protected void addToSelectList(\n-        List<SqlNode> list,\n-        Set<String> aliases,\n-        List<Map.Entry<String, RelDataType>> fieldList,\n-        SqlNode exp,\n-        SelectScope scope,\n-        boolean includeSystemVars\n-    ) {\n+    protected void addToSelectList(List<SqlNode> list, Set<String> aliases, List<Map.Entry<String, RelDataType>> fieldList,\n+                                   SqlNode exp, SelectScope scope, boolean includeSystemVars) {\n         if (isHiddenColumn(exp, scope)) {\n             return;\n         }\n \n         super.addToSelectList(list, aliases, fieldList, exp, scope, includeSystemVars);\n     }\n \n+    @Override\n+    public RelDataType deriveType(SqlValidatorScope scope, SqlNode expression) {\n+        RelDataType derived = super.deriveType(scope, expression);\n+        assert derived != null;\n+\n+        if (derived.getSqlTypeName() == CHAR) {\n+            // normalize CHAR to VARCHAR\n+            derived = HazelcastTypeFactory.INSTANCE.createSqlType(VARCHAR, derived.isNullable());\n+            setValidatedNodeType(expression, derived);\n+        }\n+\n+        switch (expression.getKind()) {\n+            case LITERAL:\n+                return deriveLiteralType(derived, expression);\n+\n+            case CAST:\n+                return deriveCastType(derived, scope, expression);\n+\n+            default:\n+                return derived;\n+        }\n+    }\n+\n+    @Override\n+    public void validateLiteral(SqlLiteral literal) {\n+        validateLiteral(literal, getValidatedNodeType(literal));\n+    }\n+\n+    @Override\n+    public void validateCall(SqlCall call, SqlValidatorScope scope) {\n+        // Enforce type derivation for all calls before validation. Calcite may\n+        // skip it if a call has a fixed type, for instance AND always has\n+        // BOOLEAN type, so operands may end up having no validated type.\n+        deriveType(scope, call);\n+        super.validateCall(call, scope);\n+    }\n+\n+    @Override\n+    protected SqlNode performUnconditionalRewrites(SqlNode node, boolean underFrom) {\n+        SqlNode rewritten = super.performUnconditionalRewrites(node, underFrom);\n+\n+        if (rewritten != null && rewritten.isA(SqlKind.TOP_LEVEL)) {\n+            // rewrite operators to Hazelcast ones starting at every top node\n+            rewritten.accept(HazelcastOperatorTableVisitor.INSTANCE);\n+        }\n+\n+        return rewritten;\n+    }\n+\n+    private RelDataType deriveLiteralType(RelDataType derived, SqlNode expression) {\n+        RelDataType known = knownNodeTypes.get(expression);\n+        if (derived == known) {\n+            return derived;\n+        }\n+\n+        SqlLiteral literal = (SqlLiteral) expression;\n+\n+        if (HazelcastIntegerType.supports(typeName(derived)) && literal.getValue() != null) {\n+            // Assign narrowest type to non-null integer literals.\n+\n+            derived = HazelcastIntegerType.deriveLiteralType(literal);\n+            setKnownAndValidatedNodeType(expression, derived);\n+        } else if (typeName(derived) == DECIMAL) {\n+            // Assign DOUBLE type to any standalone floating point literal: the\n+            // exact type is inferred later from the context in which the literal\n+            // appears.\n+\n+            derived = HazelcastTypeFactory.INSTANCE.createSqlType(DOUBLE);", "originalCommit": "1e5c9a84cbe56c63dbf43102116d335ce6cacfc4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjc4Mjg2MA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r462782860", "bodyText": "The idea is that there should be no decimals if there are no explicit decimal operands involved in the expression (decimal columns or something explicitly casted to decimal). So any standalone floating point literal receives double type initially and later, if it's involved in some decimal calculation, its type is upgraded to decimal.", "author": "taburet", "createdAt": "2020-07-30T06:59:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjczMTk1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjgxNzE5Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r462817193", "bodyText": "But we may lose the precision in this case? What is the motivation of preferring the inexact type instead of the exact one? From the user perspective, he writes the exact number.", "author": "devozerov", "createdAt": "2020-07-30T07:56:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjczMTk1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg4MzY5MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r462883691", "bodyText": "With decimals we still can loose precision since they have finite precision (38 digits). The motivation is described above: no explicit decimals gives no implicit decimals. What is your idea? Switch to decimals for floating point computations by default?", "author": "taburet", "createdAt": "2020-07-30T09:51:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjczMTk1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg4ODYwNA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r462888604", "bodyText": "Sorry, I still cannot get the motivation. The user provides an exact number, we convert it to inexact. This seems confusing. Consider the following two queries. Will they produce the same result?\nSELECT 1.1 + 1.1 FROM table\n\nSELECT a + b FROM (SELECT 1.1 a, 1.1 b FROM table)", "author": "devozerov", "createdAt": "2020-07-30T10:00:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjczMTk1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg5MDg5Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r462890897", "bodyText": "Other databases use a separate notation for exact and inexact numeric literals [1] [2]:\n1.1    // exact\n1.1.E5 // inexact\n\n[1] https://docs.microsoft.com/ru-ru/sql/t-sql/data-types/constants-transact-sql?view=sql-server-ver15#float-and-real-constants\n[2] https://dev.mysql.com/doc/refman/5.7/en/number-literals.html", "author": "devozerov", "createdAt": "2020-07-30T10:05:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjczMTk1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjkxMTU3Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r462911577", "bodyText": "Now I got it, looks like that would require some significant changes in literal handling, converters and tests. Let me see what I can do.", "author": "taburet", "createdAt": "2020-07-30T10:46:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjczMTk1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDMyNDUxMA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r464324510", "bodyText": "fixed in 45df152", "author": "taburet", "createdAt": "2020-08-03T10:18:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjczMTk1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjczOTE3Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452739176", "bodyText": "AFAIU we lose some error context here. It could be observed it verify test results when a conversion from a very large numeric literal causes \"numeric overflow\" exception, while conversion from the same literal in single quotes causes \"cannot convert to BIGINT\" exception. I checked Postgres and it is consistent - both values yeilds the same overflow exception,\nI think it should be easy for us to fix this - instead of doing a single canRepresent check, we may first check if types are convertible (if not - throw cannot convert), and only after that perform a separate test for real conversion.", "author": "devozerov", "createdAt": "2020-07-10T09:42:44Z", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/HazelcastSqlValidator.java", "diffHunk": "@@ -17,53 +17,284 @@\n package com.hazelcast.sql.impl.calcite.validate;\n \n import com.hazelcast.sql.impl.calcite.schema.HazelcastTable;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastIntegerType;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeCoercion;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeFactory;\n import org.apache.calcite.rel.type.RelDataType;\n-import org.apache.calcite.rel.type.RelDataTypeFactory;\n import org.apache.calcite.sql.SqlCall;\n import org.apache.calcite.sql.SqlIdentifier;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.SqlLiteral;\n import org.apache.calcite.sql.SqlNode;\n import org.apache.calcite.sql.SqlOperatorTable;\n+import org.apache.calcite.sql.SqlSelect;\n+import org.apache.calcite.sql.SqlUtil;\n+import org.apache.calcite.sql.type.SqlTypeName;\n import org.apache.calcite.sql.validate.SelectScope;\n import org.apache.calcite.sql.validate.SqlConformance;\n import org.apache.calcite.sql.validate.SqlQualified;\n import org.apache.calcite.sql.validate.SqlValidatorCatalogReader;\n import org.apache.calcite.sql.validate.SqlValidatorImpl;\n+import org.apache.calcite.sql.validate.SqlValidatorScope;\n import org.apache.calcite.sql.validate.SqlValidatorTable;\n import org.apache.calcite.util.Util;\n \n+import java.math.BigDecimal;\n+import java.util.IdentityHashMap;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n+import static com.hazelcast.sql.impl.calcite.validate.SqlNodeUtil.isLiteral;\n+import static com.hazelcast.sql.impl.calcite.validate.SqlNodeUtil.isParameter;\n+import static com.hazelcast.sql.impl.calcite.validate.SqlNodeUtil.numericValue;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.canRepresent;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.isInteger;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.isNumeric;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.narrowestTypeFor;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.typeName;\n+import static org.apache.calcite.sql.type.SqlTypeName.CHAR;\n+import static org.apache.calcite.sql.type.SqlTypeName.DECIMAL;\n+import static org.apache.calcite.sql.type.SqlTypeName.DOUBLE;\n+import static org.apache.calcite.sql.type.SqlTypeName.NULL;\n+import static org.apache.calcite.sql.type.SqlTypeName.NUMERIC_TYPES;\n+import static org.apache.calcite.sql.type.SqlTypeName.VARCHAR;\n+import static org.apache.calcite.util.Static.RESOURCE;\n+\n /**\n  * Hazelcast-specific SQL validator.\n  */\n public class HazelcastSqlValidator extends SqlValidatorImpl {\n-    public HazelcastSqlValidator(\n-        SqlOperatorTable opTab,\n-        SqlValidatorCatalogReader catalogReader,\n-        RelDataTypeFactory typeFactory,\n-        SqlConformance conformance\n-    ) {\n-        super(opTab, catalogReader, typeFactory, Config.DEFAULT.withSqlConformance(conformance));\n+\n+    private static final Config CONFIG = Config.DEFAULT.withIdentifierExpansion(true);\n+\n+    private final Map<SqlNode, RelDataType> knownNodeTypes = new IdentityHashMap<>();\n+\n+    public HazelcastSqlValidator(SqlOperatorTable opTab, SqlValidatorCatalogReader catalogReader,\n+                                 HazelcastTypeFactory typeFactory, SqlConformance conformance) {\n+        super(opTab, catalogReader, typeFactory, CONFIG.withSqlConformance(conformance));\n+        setTypeCoercion(new HazelcastTypeCoercion(this));\n+    }\n+\n+    /**\n+     * Sets {@code type} as the known type for {@code node}.\n+     *\n+     * @param node the node to set the known type of.\n+     * @param type the type to set the know node type to.\n+     */\n+    public void setKnownNodeType(SqlNode node, RelDataType type) {\n+        assert !getUnknownType().equals(type);\n+        knownNodeTypes.put(node, type);\n+    }\n+\n+    /**\n+     * Obtains a type known by this validator for the given node.\n+     *\n+     * @param node the node to obtain the type of.\n+     * @return the node type known by this validator or {@code null} if the type\n+     * of the given node is not known yet.\n+     */\n+    public RelDataType getKnownNodeType(SqlNode node) {\n+        return knownNodeTypes.get(node);\n+    }\n+\n+    @Override\n+    public void validateQuery(SqlNode node, SqlValidatorScope scope, RelDataType targetRowType) {\n+        super.validateQuery(node, scope, targetRowType);\n+\n+        if (node instanceof SqlSelect) {\n+            // Derive the types for offset-fetch expressions, Calcite doesn't do\n+            // that automatically.\n+\n+            SqlSelect select = (SqlSelect) node;\n+\n+            SqlNode offset = select.getOffset();\n+            if (offset != null) {\n+                deriveType(scope, offset);\n+            }\n+\n+            SqlNode fetch = select.getFetch();\n+            if (fetch != null) {\n+                deriveType(scope, fetch);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public SqlNode validate(SqlNode topNode) {\n+        if (topNode.getKind().belongsTo(SqlKind.DDL)) {\n+            return topNode;\n+        }\n+\n+        return super.validate(topNode);\n     }\n \n     @Override\n-    protected void addToSelectList(\n-        List<SqlNode> list,\n-        Set<String> aliases,\n-        List<Map.Entry<String, RelDataType>> fieldList,\n-        SqlNode exp,\n-        SelectScope scope,\n-        boolean includeSystemVars\n-    ) {\n+    protected void addToSelectList(List<SqlNode> list, Set<String> aliases, List<Map.Entry<String, RelDataType>> fieldList,\n+                                   SqlNode exp, SelectScope scope, boolean includeSystemVars) {\n         if (isHiddenColumn(exp, scope)) {\n             return;\n         }\n \n         super.addToSelectList(list, aliases, fieldList, exp, scope, includeSystemVars);\n     }\n \n+    @Override\n+    public RelDataType deriveType(SqlValidatorScope scope, SqlNode expression) {\n+        RelDataType derived = super.deriveType(scope, expression);\n+        assert derived != null;\n+\n+        if (derived.getSqlTypeName() == CHAR) {\n+            // normalize CHAR to VARCHAR\n+            derived = HazelcastTypeFactory.INSTANCE.createSqlType(VARCHAR, derived.isNullable());\n+            setValidatedNodeType(expression, derived);\n+        }\n+\n+        switch (expression.getKind()) {\n+            case LITERAL:\n+                return deriveLiteralType(derived, expression);\n+\n+            case CAST:\n+                return deriveCastType(derived, scope, expression);\n+\n+            default:\n+                return derived;\n+        }\n+    }\n+\n+    @Override\n+    public void validateLiteral(SqlLiteral literal) {\n+        validateLiteral(literal, getValidatedNodeType(literal));\n+    }\n+\n+    @Override\n+    public void validateCall(SqlCall call, SqlValidatorScope scope) {\n+        // Enforce type derivation for all calls before validation. Calcite may\n+        // skip it if a call has a fixed type, for instance AND always has\n+        // BOOLEAN type, so operands may end up having no validated type.\n+        deriveType(scope, call);\n+        super.validateCall(call, scope);\n+    }\n+\n+    @Override\n+    protected SqlNode performUnconditionalRewrites(SqlNode node, boolean underFrom) {\n+        SqlNode rewritten = super.performUnconditionalRewrites(node, underFrom);\n+\n+        if (rewritten != null && rewritten.isA(SqlKind.TOP_LEVEL)) {\n+            // rewrite operators to Hazelcast ones starting at every top node\n+            rewritten.accept(HazelcastOperatorTableVisitor.INSTANCE);\n+        }\n+\n+        return rewritten;\n+    }\n+\n+    private RelDataType deriveLiteralType(RelDataType derived, SqlNode expression) {\n+        RelDataType known = knownNodeTypes.get(expression);\n+        if (derived == known) {\n+            return derived;\n+        }\n+\n+        SqlLiteral literal = (SqlLiteral) expression;\n+\n+        if (HazelcastIntegerType.supports(typeName(derived)) && literal.getValue() != null) {\n+            // Assign narrowest type to non-null integer literals.\n+\n+            derived = HazelcastIntegerType.deriveLiteralType(literal);\n+            setKnownAndValidatedNodeType(expression, derived);\n+        } else if (typeName(derived) == DECIMAL) {\n+            // Assign DOUBLE type to any standalone floating point literal: the\n+            // exact type is inferred later from the context in which the literal\n+            // appears.\n+\n+            derived = HazelcastTypeFactory.INSTANCE.createSqlType(DOUBLE);\n+            setKnownAndValidatedNodeType(expression, derived);\n+        }\n+\n+        return derived;\n+    }\n+\n+    @SuppressWarnings({\"checkstyle:CyclomaticComplexity\", \"checkstyle:NPathComplexity\"})\n+    private RelDataType deriveCastType(RelDataType derived, SqlValidatorScope scope, SqlNode expression) {\n+        RelDataType known = knownNodeTypes.get(expression);\n+        if (derived == known) {\n+            return derived;\n+        }\n+\n+        SqlCall call = (SqlCall) expression;\n+        SqlNode operand = call.operand(0);\n+        RelDataType from = deriveType(scope, operand);\n+\n+        RelDataType to = deriveType(scope, call.operand(1));\n+        assert !to.isNullable();\n+\n+        // Handle NULL.\n+\n+        if (SqlUtil.isNullLiteral(operand, false)) {\n+            setKnownAndValidatedNodeType(operand, HazelcastTypeFactory.INSTANCE.createSqlType(NULL));\n+            derived = HazelcastTypeFactory.INSTANCE.createTypeWithNullability(to, true);\n+            setKnownAndValidatedNodeType(expression, derived);\n+            return derived;\n+        }\n+\n+        derived = to;\n+\n+        // Assign type for parameters.\n+\n+        if (isParameter(operand)) {\n+            from = HazelcastTypeFactory.INSTANCE.createTypeWithNullability(to, true);\n+        }\n+\n+        // Assign type to numeric literals and validate them.\n+\n+        BigDecimal numeric = isNumeric(from) || isNumeric(to) ? numericValue(operand) : null;\n+\n+        if (numeric != null) {\n+            from = narrowestTypeFor(numeric, typeName(to));\n+        }\n+\n+        if (isLiteral(operand)) {\n+            validateLiteral((SqlLiteral) operand, to);\n+        }\n+\n+        // Infer return type.\n+\n+        if (isInteger(to) && isInteger(from)) {\n+            derived = HazelcastIntegerType.deriveCastType(from, to);\n+        } else if (isInteger(to) && numeric != null) {\n+            long longValue = numeric.longValue();\n+            derived = HazelcastIntegerType.deriveCastType(longValue, to);\n+        }\n+\n+        derived = HazelcastTypeFactory.INSTANCE.createTypeWithNullability(derived, from.isNullable());\n+\n+        setKnownAndValidatedNodeType(operand, from);\n+        setKnownAndValidatedNodeType(expression, derived);\n+\n+        return derived;\n+    }\n+\n+    private void validateLiteral(SqlLiteral literal, RelDataType type) {\n+        SqlTypeName literalTypeName = literal.getTypeName();\n+\n+        if (!canRepresent(literal, type)) {\n+            if (NUMERIC_TYPES.contains(literalTypeName) && isNumeric(type)) {\n+                throw newValidationError(literal, RESOURCE.numberLiteralOutOfRange(literal.toString()));\n+            } else {\n+                throw SqlUtil.newContextException(literal.getParserPosition(),", "originalCommit": "1e5c9a84cbe56c63dbf43102116d335ce6cacfc4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDgyNzk3NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r464827975", "bodyText": "created an issue #17300 for 4.2", "author": "taburet", "createdAt": "2020-08-04T06:30:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjczOTE3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc4ODYwNw==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452788607", "bodyText": "Calcite's error message is too vague here. What exactly is wrong with the dynamic parameter in this branch?", "author": "devozerov", "createdAt": "2020-07-10T11:33:33Z", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/operators/HazelcastSqlCaseOperator.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.validate.operators;\n+\n+import com.hazelcast.sql.impl.calcite.validate.HazelcastSqlValidator;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.sql.SqlCall;\n+import org.apache.calcite.sql.SqlCallBinding;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.SqlLiteral;\n+import org.apache.calcite.sql.SqlNode;\n+import org.apache.calcite.sql.SqlNodeList;\n+import org.apache.calcite.sql.SqlOperandCountRange;\n+import org.apache.calcite.sql.SqlOperator;\n+import org.apache.calcite.sql.SqlOperatorBinding;\n+import org.apache.calcite.sql.SqlSyntax;\n+import org.apache.calcite.sql.SqlWriter;\n+import org.apache.calcite.sql.fun.SqlCase;\n+import org.apache.calcite.sql.fun.SqlCaseOperator;\n+import org.apache.calcite.sql.parser.SqlParserPos;\n+import org.apache.calcite.sql.type.InferTypes;\n+import org.apache.calcite.sql.validate.SqlValidator;\n+import org.apache.calcite.sql.validate.SqlValidatorScope;\n+\n+import static org.apache.calcite.util.Static.RESOURCE;\n+\n+/**\n+ * Custom Hazelcast {@link SqlCaseOperator} to override the default return type\n+ * inference strategy for CASE.\n+ *\n+ * @see HazelcastSqlCase\n+ */\n+public final class HazelcastSqlCaseOperator extends SqlOperator {\n+\n+    public HazelcastSqlCaseOperator() {\n+        super(SqlCaseOperator.INSTANCE.getName(), SqlKind.CASE, MDX_PRECEDENCE, true, null, InferTypes.RETURN_TYPE, null);\n+    }\n+\n+    @Override\n+    public void validateCall(SqlCall call, SqlValidator validator, SqlValidatorScope scope, SqlValidatorScope operandScope) {\n+        SqlCaseOperator.INSTANCE.validateCall(call, validator, scope, operandScope);\n+    }\n+\n+    @Override\n+    public RelDataType deriveType(SqlValidator validator, SqlValidatorScope scope, SqlCall call) {\n+        // SqlCaseOperator is doing the same\n+        return validateOperands(validator, scope, call);\n+    }\n+\n+    @Override\n+    public boolean checkOperandTypes(SqlCallBinding binding, boolean throwOnFailure) {\n+        return SqlCaseOperator.INSTANCE.checkOperandTypes(binding, throwOnFailure);\n+    }\n+\n+    @Override\n+    public RelDataType inferReturnType(SqlOperatorBinding binding) {\n+        if (binding instanceof SqlCallBinding) {\n+            SqlCallBinding sqlBinding = (SqlCallBinding) binding;\n+            SqlCase call = (SqlCase) sqlBinding.getCall();\n+            HazelcastSqlValidator validator = (HazelcastSqlValidator) sqlBinding.getValidator();\n+\n+            validator.getTypeCoercion().caseWhenCoercion(sqlBinding);\n+            RelDataType caseType = validator.getKnownNodeType(call);\n+            if (caseType == null) {\n+                throw sqlBinding.newValidationError(RESOURCE.dynamicParamIllegal());", "originalCommit": "1e5c9a84cbe56c63dbf43102116d335ce6cacfc4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYzMzM2NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r466633365", "bodyText": "Resolving. There is a ticket to clarify parameter behavior.", "author": "devozerov", "createdAt": "2020-08-06T19:20:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc4ODYwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc5MzU1MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r452793551", "bodyText": "This exception also doesn't help the user much - which exact combination is illegal? We can add our custom error message here easily. Same for the similar exception a below", "author": "devozerov", "createdAt": "2020-07-10T11:46:03Z", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/operators/HazelcastSqlCaseOperator.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.validate.operators;\n+\n+import com.hazelcast.sql.impl.calcite.validate.HazelcastSqlValidator;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.sql.SqlCall;\n+import org.apache.calcite.sql.SqlCallBinding;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.SqlLiteral;\n+import org.apache.calcite.sql.SqlNode;\n+import org.apache.calcite.sql.SqlNodeList;\n+import org.apache.calcite.sql.SqlOperandCountRange;\n+import org.apache.calcite.sql.SqlOperator;\n+import org.apache.calcite.sql.SqlOperatorBinding;\n+import org.apache.calcite.sql.SqlSyntax;\n+import org.apache.calcite.sql.SqlWriter;\n+import org.apache.calcite.sql.fun.SqlCase;\n+import org.apache.calcite.sql.fun.SqlCaseOperator;\n+import org.apache.calcite.sql.parser.SqlParserPos;\n+import org.apache.calcite.sql.type.InferTypes;\n+import org.apache.calcite.sql.validate.SqlValidator;\n+import org.apache.calcite.sql.validate.SqlValidatorScope;\n+\n+import static org.apache.calcite.util.Static.RESOURCE;\n+\n+/**\n+ * Custom Hazelcast {@link SqlCaseOperator} to override the default return type\n+ * inference strategy for CASE.\n+ *\n+ * @see HazelcastSqlCase\n+ */\n+public final class HazelcastSqlCaseOperator extends SqlOperator {\n+\n+    public HazelcastSqlCaseOperator() {\n+        super(SqlCaseOperator.INSTANCE.getName(), SqlKind.CASE, MDX_PRECEDENCE, true, null, InferTypes.RETURN_TYPE, null);\n+    }\n+\n+    @Override\n+    public void validateCall(SqlCall call, SqlValidator validator, SqlValidatorScope scope, SqlValidatorScope operandScope) {\n+        SqlCaseOperator.INSTANCE.validateCall(call, validator, scope, operandScope);\n+    }\n+\n+    @Override\n+    public RelDataType deriveType(SqlValidator validator, SqlValidatorScope scope, SqlCall call) {\n+        // SqlCaseOperator is doing the same\n+        return validateOperands(validator, scope, call);\n+    }\n+\n+    @Override\n+    public boolean checkOperandTypes(SqlCallBinding binding, boolean throwOnFailure) {\n+        return SqlCaseOperator.INSTANCE.checkOperandTypes(binding, throwOnFailure);\n+    }\n+\n+    @Override\n+    public RelDataType inferReturnType(SqlOperatorBinding binding) {\n+        if (binding instanceof SqlCallBinding) {\n+            SqlCallBinding sqlBinding = (SqlCallBinding) binding;\n+            SqlCase call = (SqlCase) sqlBinding.getCall();\n+            HazelcastSqlValidator validator = (HazelcastSqlValidator) sqlBinding.getValidator();\n+\n+            validator.getTypeCoercion().caseWhenCoercion(sqlBinding);\n+            RelDataType caseType = validator.getKnownNodeType(call);\n+            if (caseType == null) {\n+                throw sqlBinding.newValidationError(RESOURCE.dynamicParamIllegal());\n+            }\n+\n+            for (SqlNode thenOperand : call.getThenOperands()) {\n+                RelDataType thenOperandType = validator.deriveType(sqlBinding.getScope(), thenOperand);\n+                if (!HazelcastTypeSystem.canCast(thenOperandType, caseType)) {\n+                    throw sqlBinding.newValidationError(RESOURCE.illegalMixingOfTypes());", "originalCommit": "1e5c9a84cbe56c63dbf43102116d335ce6cacfc4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODUxMjkzNQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r468512935", "bodyText": "case removed in c1a5855 and 7f29e69, #17329 created", "author": "taburet", "createdAt": "2020-08-11T11:33:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc5MzU1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM1MDIzMQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r453350231", "bodyText": "Is this \"no-overflow checking\" integrated with expressions somehow? For example, in the PLUS function, we always check for overflow, even for BIGINT(62), where the overflow is impossible.", "author": "devozerov", "createdAt": "2020-07-12T18:48:42Z", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/types/HazelcastIntegerType.java", "diffHunk": "@@ -0,0 +1,421 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.validate.types;\n+\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.sql.SqlLiteral;\n+import org.apache.calcite.sql.type.BasicSqlType;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.apache.calcite.sql.type.SqlTypeName.BIGINT;\n+import static org.apache.calcite.sql.type.SqlTypeName.INTEGER;\n+import static org.apache.calcite.sql.type.SqlTypeName.SMALLINT;\n+import static org.apache.calcite.sql.type.SqlTypeName.TINYINT;\n+\n+/**\n+ * Represents integer-valued types for Calcite.\n+ * <p>\n+ * Unlike the standard Calcite implementation for TINYINT, SMALLINT, INT and\n+ * BIGINT, this implementation tracks the actual bit width required to represent\n+ * integer values. That bit width information is not directly related to the\n+ * underlying machine representation. The closest concept is SQL precision\n+ * tracking done for DECIMAL type, but the bit width information tracks the\n+ * precision in terms of binary (base-2) digits instead of decimal (base-10)\n+ * digits. For instance, -1 and 1 require a single binary digit, 14 requires 4\n+ * binary digits.\n+ * <p>\n+ * In general, for an N-bit integer type the valid range of bit widths is from 0\n+ * to N: zero bit width corresponds to 0 integer value, bit widths from 1 to\n+ * N - 1 correspond to regular integer values, bit width of N bits has a special\n+ * meaning and indicates a possibility of an overflow.\n+ * <p>\n+ * For instance, for BIGINT type represented as Java {@code long} type:\n+ * the valid bit width range is from 0 to 64, 0L has BIGINT(0) type, -14L has\n+ * BIGINT(4) type, a BIGINT SQL column has BIGINT(63) type, BIGINT(64) indicates\n+ * a potential overflow.\n+ * <p>\n+ * Each arithmetic operation acting on integer types infers its return type\n+ * based on the bit width information: INT(4) + INT(10) -> INT(11),\n+ * INT(4) + INT(31) -> BIGINT(32), INT(10) + BIGINT(63) -> BIGINT(64). In the\n+ * first example the bit width was expanded; in the second example the bit width\n+ * was expanded and the type was promoted to the next wider integer type; in the\n+ * last example the bit width was expanded, but there was no wider integer type\n+ * to promote to and avoid a possible overflow.\n+ * <p>\n+ * The benefits of that bit width approach are: the smallest possible type is\n+ * always selected to represent a result of a certain operation and it's always\n+ * possible to tell from the selected type alone whether overflow checking is", "originalCommit": "1e5c9a84cbe56c63dbf43102116d335ce6cacfc4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjc0ODUyNA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r462748524", "bodyText": "explained here #17183 (comment)", "author": "taburet", "createdAt": "2020-07-30T05:44:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM1MDIzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM1MTIxMA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r453351210", "bodyText": "This might be a topic for a separate PR, but still - it seems that maximum possible value is a better candidate than bit width. Consider an example when we add value of the same type N times. Every PLUS operation will add an additional bit, thus, estimating the maximum value to 2^N * MAX_VALUE, while in reality, the max value is only N * MAX_VALUE. This way we may avoid unnecessary expansions.", "author": "devozerov", "createdAt": "2020-07-12T18:58:30Z", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/types/HazelcastIntegerType.java", "diffHunk": "@@ -0,0 +1,421 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.validate.types;\n+\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.sql.SqlLiteral;\n+import org.apache.calcite.sql.type.BasicSqlType;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.apache.calcite.sql.type.SqlTypeName.BIGINT;\n+import static org.apache.calcite.sql.type.SqlTypeName.INTEGER;\n+import static org.apache.calcite.sql.type.SqlTypeName.SMALLINT;\n+import static org.apache.calcite.sql.type.SqlTypeName.TINYINT;\n+\n+/**\n+ * Represents integer-valued types for Calcite.\n+ * <p>\n+ * Unlike the standard Calcite implementation for TINYINT, SMALLINT, INT and\n+ * BIGINT, this implementation tracks the actual bit width required to represent\n+ * integer values. That bit width information is not directly related to the\n+ * underlying machine representation. The closest concept is SQL precision\n+ * tracking done for DECIMAL type, but the bit width information tracks the\n+ * precision in terms of binary (base-2) digits instead of decimal (base-10)\n+ * digits. For instance, -1 and 1 require a single binary digit, 14 requires 4\n+ * binary digits.\n+ * <p>\n+ * In general, for an N-bit integer type the valid range of bit widths is from 0\n+ * to N: zero bit width corresponds to 0 integer value, bit widths from 1 to\n+ * N - 1 correspond to regular integer values, bit width of N bits has a special\n+ * meaning and indicates a possibility of an overflow.\n+ * <p>\n+ * For instance, for BIGINT type represented as Java {@code long} type:\n+ * the valid bit width range is from 0 to 64, 0L has BIGINT(0) type, -14L has\n+ * BIGINT(4) type, a BIGINT SQL column has BIGINT(63) type, BIGINT(64) indicates\n+ * a potential overflow.\n+ * <p>\n+ * Each arithmetic operation acting on integer types infers its return type\n+ * based on the bit width information: INT(4) + INT(10) -> INT(11),\n+ * INT(4) + INT(31) -> BIGINT(32), INT(10) + BIGINT(63) -> BIGINT(64). In the\n+ * first example the bit width was expanded; in the second example the bit width\n+ * was expanded and the type was promoted to the next wider integer type; in the\n+ * last example the bit width was expanded, but there was no wider integer type\n+ * to promote to and avoid a possible overflow.\n+ * <p>\n+ * The benefits of that bit width approach are: the smallest possible type is\n+ * always selected to represent a result of a certain operation and it's always\n+ * possible to tell from the selected type alone whether overflow checking is\n+ * necessary while executing the operation.\n+ */\n+public final class HazelcastIntegerType extends BasicSqlType {\n+\n+    private static final Map<SqlTypeName, HazelcastIntegerType[]> TYPES = new HashMap<>();\n+    private static final Map<SqlTypeName, HazelcastIntegerType[]> NULLABLE_TYPES = new HashMap<>();\n+\n+    static {\n+        // Preallocate all possible types of all possible bit widths.\n+\n+        TYPES.put(TINYINT, new HazelcastIntegerType[Byte.SIZE + 1]);\n+        TYPES.put(SMALLINT, new HazelcastIntegerType[Short.SIZE + 1]);\n+        TYPES.put(INTEGER, new HazelcastIntegerType[Integer.SIZE + 1]);\n+        TYPES.put(BIGINT, new HazelcastIntegerType[Long.SIZE + 1]);\n+\n+        for (Map.Entry<SqlTypeName, HazelcastIntegerType[]> entry : TYPES.entrySet()) {\n+            SqlTypeName typeName = entry.getKey();\n+            HazelcastIntegerType[] types = entry.getValue();\n+\n+            HazelcastIntegerType[] nullableTypes = new HazelcastIntegerType[types.length];\n+            NULLABLE_TYPES.put(typeName, nullableTypes);\n+\n+            for (int i = 0; i < types.length; ++i) {\n+                types[i] = new HazelcastIntegerType(typeName, false, i);\n+                nullableTypes[i] = new HazelcastIntegerType(typeName, true, i);\n+            }\n+        }\n+    }\n+\n+    private static final HazelcastIntegerType[] TYPES_BY_BIT_WIDTH = new HazelcastIntegerType[Long.SIZE + 1];\n+    private static final HazelcastIntegerType[] NULLABLE_TYPES_BY_BIT_WIDTH = new HazelcastIntegerType[Long.SIZE + 1];\n+\n+    static {\n+        // Build reverse mapping structures to map from a bit width to a\n+        // preferred integer type.\n+\n+        for (int i = 0; i <= Long.SIZE; ++i) {\n+            HazelcastIntegerType type;\n+            HazelcastIntegerType nullableType;\n+            if (i < Byte.SIZE) {\n+                type = TYPES.get(TINYINT)[i];\n+                nullableType = NULLABLE_TYPES.get(TINYINT)[i];\n+            } else if (i < Short.SIZE) {\n+                type = TYPES.get(SMALLINT)[i];\n+                nullableType = NULLABLE_TYPES.get(SMALLINT)[i];\n+            } else if (i < Integer.SIZE) {\n+                type = TYPES.get(INTEGER)[i];\n+                nullableType = NULLABLE_TYPES.get(INTEGER)[i];\n+            } else {\n+                type = TYPES.get(BIGINT)[i];\n+                nullableType = NULLABLE_TYPES.get(BIGINT)[i];\n+            }\n+\n+            TYPES_BY_BIT_WIDTH[i] = type;\n+            NULLABLE_TYPES_BY_BIT_WIDTH[i] = nullableType;\n+        }\n+    }\n+\n+    private final int bitWidth;", "originalCommit": "1e5c9a84cbe56c63dbf43102116d335ce6cacfc4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjc4OTQwNg==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r462789406", "bodyText": "Yes, and it also might help with overflow detection for floating point types.", "author": "taburet", "createdAt": "2020-07-30T07:07:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM1MTIxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTUwNTU1OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r465505559", "bodyText": "Can we have a ticket for this?", "author": "devozerov", "createdAt": "2020-08-05T06:39:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM1MTIxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTYwMTk0NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r465601945", "bodyText": "done #17308", "author": "taburet", "createdAt": "2020-08-05T09:39:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM1MTIxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM1MjExNg==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r453352116", "bodyText": "We do we disallow all-null operands? I see that the same behavior is observed in, e.g., PostgreSQL. Is it possible to explain the reason of this decision in the design doc?", "author": "devozerov", "createdAt": "2020-07-12T19:07:45Z", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/types/HazelcastOperandTypes.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.validate.types;\n+\n+import org.apache.calcite.rel.type.RelDataTypeComparability;\n+import org.apache.calcite.sql.SqlCallBinding;\n+import org.apache.calcite.sql.SqlNode;\n+import org.apache.calcite.sql.SqlOperandCountRange;\n+import org.apache.calcite.sql.SqlOperator;\n+import org.apache.calcite.sql.type.ComparableOperandTypeChecker;\n+import org.apache.calcite.sql.type.OperandTypes;\n+import org.apache.calcite.sql.type.SqlOperandTypeChecker;\n+import org.apache.calcite.sql.type.SqlSingleOperandTypeChecker;\n+\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.typeName;\n+import static org.apache.calcite.sql.type.SqlTypeName.ANY;\n+import static org.apache.calcite.sql.type.SqlTypeName.NULL;\n+\n+/**\n+ * A collection of operand type checkers. Basically, a mirror of {@link\n+ * OperandTypes} provided by Calcite with various enhancements.\n+ */\n+public final class HazelcastOperandTypes {\n+\n+    /**\n+     * The same as Calcite's {@link OperandTypes#COMPARABLE_ORDERED_COMPARABLE_ORDERED},\n+     * but selects the least restrictive type as a common type. We do character\n+     * coercion provided by {@link SqlOperandTypeChecker.Consistency#COMPARE} and\n+     * used by Calcite on our own.\n+     */\n+    public static final SqlOperandTypeChecker COMPARABLE_ORDERED_COMPARABLE_ORDERED =\n+            new ComparableOperandTypeChecker(2, RelDataTypeComparability.ALL,\n+                    SqlOperandTypeChecker.Consistency.LEAST_RESTRICTIVE);\n+\n+    private HazelcastOperandTypes() {\n+    }\n+\n+    /**\n+     * @return the base operand type checker wrapped into a new type checker\n+     * disallowing ANY type.\n+     */\n+    public static SqlSingleOperandTypeChecker notAny(SqlOperandTypeChecker base) {\n+        return new NotAny(base);\n+    }\n+\n+    /**\n+     * @return the base operand type checker wrapped into a new type checker\n+     * disallowing all of the operands to be of NULL type simultaneously.\n+     */\n+    public static SqlOperandTypeChecker notAllNull(SqlOperandTypeChecker base) {", "originalCommit": "1e5c9a84cbe56c63dbf43102116d335ce6cacfc4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjgxNDM5NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r462814394", "bodyText": "There is a conceptual problem with NULLs and operator overloads: NULL inherently doesn't have any type, so it's impossible to select an overload unambiguously if all operands are NULL. And there is a technical problem: Calcite expects that every NULL literal participating in expression should have a type assigned (NULL type doesn't work here), so they use the same approach as PG. I have tried to workaround that and make NULL type a first class citizen, but that produced enormous amount of strange artifacts in Calcite type inference. As far as I remember, it was something like NULL + NULL -> NULL, but at the same time NULL + NULL + NULL -> DECIMAL, ABS(NULL + NULL) was producing an error while ABS(NULL) was fine, etc. So I decided to give up, especially considering that queries like NULL + NULL are pretty rare in practice.", "author": "taburet", "createdAt": "2020-07-30T07:51:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM1MjExNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM1MjE2OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r453352169", "bodyText": "NULL type should be reflected in the design doc.", "author": "devozerov", "createdAt": "2020-07-12T19:08:18Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/SqlColumnType.java", "diffHunk": "@@ -67,7 +67,14 @@\n     TIMESTAMP_WITH_TIME_ZONE(OffsetDateTime.class),\n \n     /** OBJECT type, could be represented by any Java class. */\n-    OBJECT(Object.class);\n+    OBJECT(Object.class),\n+\n+    /**\n+     * The type of the generic SQL {@code NULL} literal.\n+     * <p>\n+     * The only valid value of {@code NULL} type is {@code null}.\n+     */\n+    NULL(Void.class);", "originalCommit": "1e5c9a84cbe56c63dbf43102116d335ce6cacfc4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTYxNDU3NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r465614575", "bodyText": "fixed in 80d4cc1", "author": "taburet", "createdAt": "2020-08-05T10:01:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM1MjE2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM1MjcyOQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r453352729", "bodyText": "This error message is misleading. E.g. it will show \"cannot apply NULL + NULL, possible combination NUMBER + NUMBER, ...\", while in reality NUMBER + NULL is possible. Another problem is that this exception will print info about types that are not supported in the scope of this PR, such as temporal types and intervals.\nWe should provide our own sensible error message here. E.g. this is how PostgreSQL error looks like:\nERROR: operator is not unique: unknown + unknown Hint: Could not choose a best candidate operator. You might need to add explicit type casts. Position: 14", "author": "devozerov", "createdAt": "2020-07-12T19:13:51Z", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/types/HazelcastOperandTypes.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.validate.types;\n+\n+import org.apache.calcite.rel.type.RelDataTypeComparability;\n+import org.apache.calcite.sql.SqlCallBinding;\n+import org.apache.calcite.sql.SqlNode;\n+import org.apache.calcite.sql.SqlOperandCountRange;\n+import org.apache.calcite.sql.SqlOperator;\n+import org.apache.calcite.sql.type.ComparableOperandTypeChecker;\n+import org.apache.calcite.sql.type.OperandTypes;\n+import org.apache.calcite.sql.type.SqlOperandTypeChecker;\n+import org.apache.calcite.sql.type.SqlSingleOperandTypeChecker;\n+\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.typeName;\n+import static org.apache.calcite.sql.type.SqlTypeName.ANY;\n+import static org.apache.calcite.sql.type.SqlTypeName.NULL;\n+\n+/**\n+ * A collection of operand type checkers. Basically, a mirror of {@link\n+ * OperandTypes} provided by Calcite with various enhancements.\n+ */\n+public final class HazelcastOperandTypes {\n+\n+    /**\n+     * The same as Calcite's {@link OperandTypes#COMPARABLE_ORDERED_COMPARABLE_ORDERED},\n+     * but selects the least restrictive type as a common type. We do character\n+     * coercion provided by {@link SqlOperandTypeChecker.Consistency#COMPARE} and\n+     * used by Calcite on our own.\n+     */\n+    public static final SqlOperandTypeChecker COMPARABLE_ORDERED_COMPARABLE_ORDERED =\n+            new ComparableOperandTypeChecker(2, RelDataTypeComparability.ALL,\n+                    SqlOperandTypeChecker.Consistency.LEAST_RESTRICTIVE);\n+\n+    private HazelcastOperandTypes() {\n+    }\n+\n+    /**\n+     * @return the base operand type checker wrapped into a new type checker\n+     * disallowing ANY type.\n+     */\n+    public static SqlSingleOperandTypeChecker notAny(SqlOperandTypeChecker base) {\n+        return new NotAny(base);\n+    }\n+\n+    /**\n+     * @return the base operand type checker wrapped into a new type checker\n+     * disallowing all of the operands to be of NULL type simultaneously.\n+     */\n+    public static SqlOperandTypeChecker notAllNull(SqlOperandTypeChecker base) {\n+        return new NotAllNull(base);\n+    }\n+\n+    private static final class NotAny implements SqlSingleOperandTypeChecker {\n+\n+        private final SqlOperandTypeChecker base;\n+\n+        NotAny(SqlOperandTypeChecker base) {\n+            this.base = base;\n+        }\n+\n+        @Override\n+        public boolean checkOperandTypes(SqlCallBinding binding, boolean throwOnFailure) {\n+            if (!base.checkOperandTypes(binding, throwOnFailure)) {\n+                return false;\n+            }\n+\n+            for (int i = 0; i < binding.getOperandCount(); ++i) {\n+                if (!checkSingleOperandType(binding, binding.operand(i), i, throwOnFailure)) {\n+                    return false;\n+                }\n+            }\n+\n+            return true;\n+        }\n+\n+        @Override\n+        public SqlOperandCountRange getOperandCountRange() {\n+            return base.getOperandCountRange();\n+        }\n+\n+        @Override\n+        public String getAllowedSignatures(SqlOperator op, String opName) {\n+            return base.getAllowedSignatures(op, opName);\n+        }\n+\n+        @Override\n+        public Consistency getConsistency() {\n+            return base.getConsistency();\n+        }\n+\n+        @Override\n+        public boolean isOptional(int i) {\n+            return base.isOptional(i);\n+        }\n+\n+        @Override\n+        public boolean checkSingleOperandType(SqlCallBinding binding, SqlNode operand, int index, boolean throwOnFailure) {\n+            if (typeName(binding.getOperandType(index)) == ANY) {\n+                if (throwOnFailure) {\n+                    throw binding.newValidationSignatureError();\n+                }\n+                return false;\n+            }\n+\n+            return true;\n+        }\n+\n+    }\n+\n+    private static final class NotAllNull implements SqlOperandTypeChecker {\n+\n+        private final SqlOperandTypeChecker base;\n+\n+        NotAllNull(SqlOperandTypeChecker base) {\n+            this.base = base;\n+        }\n+\n+        @Override\n+        public boolean checkOperandTypes(SqlCallBinding binding, boolean throwOnFailure) {\n+            boolean seenNonNull = false;\n+            for (int i = 0; i < binding.getOperandCount(); ++i) {\n+                if (typeName(binding.getOperandType(i)) != NULL) {\n+                    seenNonNull = true;\n+                    break;\n+                }\n+            }\n+\n+            if (!seenNonNull) {\n+                if (throwOnFailure) {\n+                    throw binding.newValidationSignatureError();", "originalCommit": "1e5c9a84cbe56c63dbf43102116d335ce6cacfc4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDgzNjc3Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r464836772", "bodyText": "created an issue #17301 for 4.2", "author": "taburet", "createdAt": "2020-08-04T06:52:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM1MjcyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM1Mjk4Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r453352983", "bodyText": "The same problem as with \"not all null\" - the error message contains invalid \"supported forms\".", "author": "devozerov", "createdAt": "2020-07-12T19:16:25Z", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/types/HazelcastOperandTypes.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.validate.types;\n+\n+import org.apache.calcite.rel.type.RelDataTypeComparability;\n+import org.apache.calcite.sql.SqlCallBinding;\n+import org.apache.calcite.sql.SqlNode;\n+import org.apache.calcite.sql.SqlOperandCountRange;\n+import org.apache.calcite.sql.SqlOperator;\n+import org.apache.calcite.sql.type.ComparableOperandTypeChecker;\n+import org.apache.calcite.sql.type.OperandTypes;\n+import org.apache.calcite.sql.type.SqlOperandTypeChecker;\n+import org.apache.calcite.sql.type.SqlSingleOperandTypeChecker;\n+\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.typeName;\n+import static org.apache.calcite.sql.type.SqlTypeName.ANY;\n+import static org.apache.calcite.sql.type.SqlTypeName.NULL;\n+\n+/**\n+ * A collection of operand type checkers. Basically, a mirror of {@link\n+ * OperandTypes} provided by Calcite with various enhancements.\n+ */\n+public final class HazelcastOperandTypes {\n+\n+    /**\n+     * The same as Calcite's {@link OperandTypes#COMPARABLE_ORDERED_COMPARABLE_ORDERED},\n+     * but selects the least restrictive type as a common type. We do character\n+     * coercion provided by {@link SqlOperandTypeChecker.Consistency#COMPARE} and\n+     * used by Calcite on our own.\n+     */\n+    public static final SqlOperandTypeChecker COMPARABLE_ORDERED_COMPARABLE_ORDERED =\n+            new ComparableOperandTypeChecker(2, RelDataTypeComparability.ALL,\n+                    SqlOperandTypeChecker.Consistency.LEAST_RESTRICTIVE);\n+\n+    private HazelcastOperandTypes() {\n+    }\n+\n+    /**\n+     * @return the base operand type checker wrapped into a new type checker\n+     * disallowing ANY type.\n+     */\n+    public static SqlSingleOperandTypeChecker notAny(SqlOperandTypeChecker base) {\n+        return new NotAny(base);\n+    }\n+\n+    /**\n+     * @return the base operand type checker wrapped into a new type checker\n+     * disallowing all of the operands to be of NULL type simultaneously.\n+     */\n+    public static SqlOperandTypeChecker notAllNull(SqlOperandTypeChecker base) {\n+        return new NotAllNull(base);\n+    }\n+\n+    private static final class NotAny implements SqlSingleOperandTypeChecker {\n+\n+        private final SqlOperandTypeChecker base;\n+\n+        NotAny(SqlOperandTypeChecker base) {\n+            this.base = base;\n+        }\n+\n+        @Override\n+        public boolean checkOperandTypes(SqlCallBinding binding, boolean throwOnFailure) {\n+            if (!base.checkOperandTypes(binding, throwOnFailure)) {\n+                return false;\n+            }\n+\n+            for (int i = 0; i < binding.getOperandCount(); ++i) {\n+                if (!checkSingleOperandType(binding, binding.operand(i), i, throwOnFailure)) {\n+                    return false;\n+                }\n+            }\n+\n+            return true;\n+        }\n+\n+        @Override\n+        public SqlOperandCountRange getOperandCountRange() {\n+            return base.getOperandCountRange();\n+        }\n+\n+        @Override\n+        public String getAllowedSignatures(SqlOperator op, String opName) {\n+            return base.getAllowedSignatures(op, opName);\n+        }\n+\n+        @Override\n+        public Consistency getConsistency() {\n+            return base.getConsistency();\n+        }\n+\n+        @Override\n+        public boolean isOptional(int i) {\n+            return base.isOptional(i);\n+        }\n+\n+        @Override\n+        public boolean checkSingleOperandType(SqlCallBinding binding, SqlNode operand, int index, boolean throwOnFailure) {\n+            if (typeName(binding.getOperandType(index)) == ANY) {\n+                if (throwOnFailure) {\n+                    throw binding.newValidationSignatureError();", "originalCommit": "1e5c9a84cbe56c63dbf43102116d335ce6cacfc4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDgzNjgzNg==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r464836836", "bodyText": "created an issue #17301 for 4.2", "author": "taburet", "createdAt": "2020-08-04T06:52:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM1Mjk4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM1Mzg2Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r453353862", "bodyText": "The branch is never invoked in tests.", "author": "devozerov", "createdAt": "2020-07-12T19:26:15Z", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/types/HazelcastTypeCoercion.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.validate.types;\n+\n+import com.hazelcast.sql.impl.calcite.validate.HazelcastSqlOperatorTable;\n+import com.hazelcast.sql.impl.calcite.validate.HazelcastSqlValidator;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.sql.SqlCall;\n+import org.apache.calcite.sql.SqlCallBinding;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.SqlLiteral;\n+import org.apache.calcite.sql.SqlNode;\n+import org.apache.calcite.sql.SqlNodeList;\n+import org.apache.calcite.sql.SqlUtil;\n+import org.apache.calcite.sql.fun.SqlCase;\n+import org.apache.calcite.sql.parser.SqlParserPos;\n+import org.apache.calcite.sql.type.SqlTypeFamily;\n+import org.apache.calcite.sql.type.SqlTypeUtil;\n+import org.apache.calcite.sql.validate.SqlValidatorScope;\n+import org.apache.calcite.sql.validate.implicit.TypeCoercionImpl;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static com.hazelcast.sql.impl.calcite.validate.SqlNodeUtil.isLiteral;\n+import static com.hazelcast.sql.impl.calcite.validate.SqlNodeUtil.isParameter;\n+import static com.hazelcast.sql.impl.calcite.validate.SqlNodeUtil.numericValue;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.canCast;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.isChar;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.isFloatingPoint;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.isInteger;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.isNumeric;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.isTemporal;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.narrowestTypeFor;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.typeName;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.withHigherPrecedence;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.withHigherPrecedenceForLiterals;\n+import static org.apache.calcite.sql.SqlKind.BETWEEN;\n+import static org.apache.calcite.sql.SqlKind.BINARY_ARITHMETIC;\n+import static org.apache.calcite.sql.SqlKind.BINARY_COMPARISON;\n+import static org.apache.calcite.sql.SqlKind.BINARY_EQUALITY;\n+import static org.apache.calcite.sql.SqlKind.MINUS_PREFIX;\n+import static org.apache.calcite.sql.SqlKind.PLUS_PREFIX;\n+import static org.apache.calcite.sql.type.SqlTypeName.ANY;\n+import static org.apache.calcite.sql.type.SqlTypeName.BIGINT;\n+import static org.apache.calcite.sql.type.SqlTypeName.BOOLEAN;\n+import static org.apache.calcite.sql.type.SqlTypeName.CHAR_TYPES;\n+import static org.apache.calcite.sql.type.SqlTypeName.DECIMAL;\n+import static org.apache.calcite.sql.type.SqlTypeName.DOUBLE;\n+import static org.apache.calcite.sql.type.SqlTypeName.NULL;\n+\n+/**\n+ * Provides custom coercion strategies supporting {@link HazelcastIntegerType}\n+ * and assigning more precise types comparing to the standard Calcite coercion.\n+ */\n+public final class HazelcastTypeCoercion extends TypeCoercionImpl {\n+\n+    private static final HazelcastTypeFactory TYPE_FACTORY = HazelcastTypeFactory.INSTANCE;\n+\n+    public HazelcastTypeCoercion(HazelcastSqlValidator validator) {\n+        super(TYPE_FACTORY, validator);\n+    }\n+\n+    @Override\n+    public boolean binaryArithmeticCoercion(SqlCallBinding binding) {\n+        SqlKind kind = binding.getOperator().getKind();\n+        if (!kind.belongsTo(BINARY_ARITHMETIC) && kind != PLUS_PREFIX && kind != MINUS_PREFIX) {\n+            return super.binaryArithmeticCoercion(binding);\n+        }\n+\n+        // Infer types.\n+\n+        RelDataType[] types = inferTypes(binding.getScope(), binding.operands(), true);\n+        if (types == null) {\n+            return false;\n+        }\n+\n+        // Do the coercion.\n+\n+        boolean coerced = false;\n+        for (int i = 0; i < types.length - 1; ++i) {\n+            boolean operandCoerced = coerceOperandType(binding.getScope(), binding.getCall(), i, types[i]);\n+            coerced |= operandCoerced;\n+        }\n+\n+        return coerced;\n+    }\n+\n+    @Override\n+    public boolean binaryComparisonCoercion(SqlCallBinding binding) {\n+        SqlKind kind = binding.getOperator().getKind();\n+        if (!kind.belongsTo(BINARY_EQUALITY) && !kind.belongsTo(BINARY_COMPARISON) && kind != BETWEEN) {\n+            return super.binaryComparisonCoercion(binding);\n+        }\n+\n+        // Infer types.\n+\n+        RelDataType[] types = inferTypes(binding.getScope(), binding.operands(), false);\n+        if (types == null) {\n+            return false;\n+        }\n+\n+        // Do the coercion.\n+\n+        RelDataType commonType = types[types.length - 1];\n+\n+        boolean coerced = false;\n+        for (int i = 0; i < types.length - 1; ++i) {\n+            RelDataType type = types[i];\n+            type = TYPE_FACTORY.createTypeWithNullability(commonType, type.isNullable());\n+            boolean operandCoerced = coerceOperandType(binding.getScope(), binding.getCall(), i, type);\n+            coerced |= operandCoerced;\n+\n+            // If the operand was coerced to integer type, reassign its CAST type\n+            // back to the common type: '0':VARCHAR -> CAST('0' AS INT(31)):INT(0)\n+            // -> CAST('0' AS INT(31)):INT(31).\n+            if (operandCoerced && isInteger(type)) {\n+                updateInferredType(binding.operand(i), type);\n+            }\n+        }\n+\n+        return coerced;\n+    }\n+\n+    @Override\n+    public boolean caseWhenCoercion(SqlCallBinding binding) {\n+        // Infer types.\n+\n+        SqlCase call = (SqlCase) binding.getCall();\n+        SqlNodeList thenOperands = call.getThenOperands();\n+\n+        List<SqlNode> operands = new ArrayList<>(thenOperands.size() + 1);\n+        operands.addAll(thenOperands.getList());\n+        operands.add(call.getElseOperand());\n+\n+        RelDataType[] types = inferTypes(binding.getScope(), operands, false);\n+        if (types == null) {\n+            return false;\n+        }\n+\n+        // Do the coercion.\n+\n+        boolean coerced = false;\n+        for (int i = 0; i < operands.size() - 1; ++i) {\n+            coerced |= coerceElementType(binding.getScope(), thenOperands, i, types[i]);\n+        }\n+        coerced |= coerceOperandType(binding.getScope(), call, 3, types[operands.size() - 1]);\n+\n+        updateInferredType(call, types[types.length - 1]);\n+\n+        return coerced;\n+    }\n+\n+    @Override\n+    public RelDataType implicitCast(RelDataType in, SqlTypeFamily expected) {\n+        // enables implicit conversion from CHAR to BOOLEAN\n+        if (CHAR_TYPES.contains(typeName(in)) && expected == SqlTypeFamily.BOOLEAN) {\n+            return TYPE_FACTORY.createSqlType(BOOLEAN, in.isNullable());\n+        }\n+\n+        return super.implicitCast(in, expected);\n+    }\n+\n+    @Override\n+    protected void updateInferredType(SqlNode node, RelDataType type) {\n+        ((HazelcastSqlValidator) validator).setKnownNodeType(node, type);\n+        super.updateInferredType(node, type);\n+    }\n+\n+    @Override\n+    protected boolean coerceOperandType(SqlValidatorScope scope, SqlCall call, int index, RelDataType to) {\n+        SqlNode operand = call.getOperandList().get(index);\n+        RelDataType from = validator.deriveType(scope, operand);\n+\n+        // Just update the inferred type if casting is not needed. But if casting\n+        // is not possible, still insert the cast to fail on its validation later.\n+        if (!needToCast(scope, operand, to) && canCast(from, to)) {\n+            updateInferredType(operand, to);\n+            return false;\n+        }\n+\n+        SqlNode cast = makeCast(operand, to);\n+        call.setOperand(index, cast);\n+        // derive the type of the newly created CAST immediately\n+        validator.deriveType(scope, cast);\n+        return true;\n+    }\n+\n+    @SuppressWarnings(\"checkstyle:NPathComplexity\")\n+    @Override\n+    protected boolean needToCast(SqlValidatorScope scope, SqlNode node, RelDataType to) {\n+        RelDataType from = validator.deriveType(scope, node);\n+\n+        if (typeName(from) == typeName(to)) {\n+            // already of the same type\n+            return false;\n+        }\n+\n+        if (typeName(from) == NULL || SqlUtil.isNullLiteral(node, false)) {\n+            // never cast NULLs, just assign types to them\n+            return false;\n+        }\n+\n+        if (typeName(to) == ANY) {\n+            // all types can be implicitly interpreted as ANY\n+            return false;\n+        }\n+        if (typeName(from) == ANY) {\n+            // casting from ANY is always required\n+            return true;", "originalCommit": "1e5c9a84cbe56c63dbf43102116d335ce6cacfc4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDM1MTQzMw==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r464351433", "bodyText": "fixed in 30cedde", "author": "taburet", "createdAt": "2020-08-03T11:21:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM1Mzg2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM1NDMzNw==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r453354337", "bodyText": "But if casting is not possible, still insert the cast to fail on its validation later\n\nDo we have a test for that? I am interested in the exact error that will be thrown in this case", "author": "devozerov", "createdAt": "2020-07-12T19:31:15Z", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/types/HazelcastTypeCoercion.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.validate.types;\n+\n+import com.hazelcast.sql.impl.calcite.validate.HazelcastSqlOperatorTable;\n+import com.hazelcast.sql.impl.calcite.validate.HazelcastSqlValidator;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.sql.SqlCall;\n+import org.apache.calcite.sql.SqlCallBinding;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.SqlLiteral;\n+import org.apache.calcite.sql.SqlNode;\n+import org.apache.calcite.sql.SqlNodeList;\n+import org.apache.calcite.sql.SqlUtil;\n+import org.apache.calcite.sql.fun.SqlCase;\n+import org.apache.calcite.sql.parser.SqlParserPos;\n+import org.apache.calcite.sql.type.SqlTypeFamily;\n+import org.apache.calcite.sql.type.SqlTypeUtil;\n+import org.apache.calcite.sql.validate.SqlValidatorScope;\n+import org.apache.calcite.sql.validate.implicit.TypeCoercionImpl;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static com.hazelcast.sql.impl.calcite.validate.SqlNodeUtil.isLiteral;\n+import static com.hazelcast.sql.impl.calcite.validate.SqlNodeUtil.isParameter;\n+import static com.hazelcast.sql.impl.calcite.validate.SqlNodeUtil.numericValue;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.canCast;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.isChar;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.isFloatingPoint;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.isInteger;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.isNumeric;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.isTemporal;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.narrowestTypeFor;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.typeName;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.withHigherPrecedence;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.withHigherPrecedenceForLiterals;\n+import static org.apache.calcite.sql.SqlKind.BETWEEN;\n+import static org.apache.calcite.sql.SqlKind.BINARY_ARITHMETIC;\n+import static org.apache.calcite.sql.SqlKind.BINARY_COMPARISON;\n+import static org.apache.calcite.sql.SqlKind.BINARY_EQUALITY;\n+import static org.apache.calcite.sql.SqlKind.MINUS_PREFIX;\n+import static org.apache.calcite.sql.SqlKind.PLUS_PREFIX;\n+import static org.apache.calcite.sql.type.SqlTypeName.ANY;\n+import static org.apache.calcite.sql.type.SqlTypeName.BIGINT;\n+import static org.apache.calcite.sql.type.SqlTypeName.BOOLEAN;\n+import static org.apache.calcite.sql.type.SqlTypeName.CHAR_TYPES;\n+import static org.apache.calcite.sql.type.SqlTypeName.DECIMAL;\n+import static org.apache.calcite.sql.type.SqlTypeName.DOUBLE;\n+import static org.apache.calcite.sql.type.SqlTypeName.NULL;\n+\n+/**\n+ * Provides custom coercion strategies supporting {@link HazelcastIntegerType}\n+ * and assigning more precise types comparing to the standard Calcite coercion.\n+ */\n+public final class HazelcastTypeCoercion extends TypeCoercionImpl {\n+\n+    private static final HazelcastTypeFactory TYPE_FACTORY = HazelcastTypeFactory.INSTANCE;\n+\n+    public HazelcastTypeCoercion(HazelcastSqlValidator validator) {\n+        super(TYPE_FACTORY, validator);\n+    }\n+\n+    @Override\n+    public boolean binaryArithmeticCoercion(SqlCallBinding binding) {\n+        SqlKind kind = binding.getOperator().getKind();\n+        if (!kind.belongsTo(BINARY_ARITHMETIC) && kind != PLUS_PREFIX && kind != MINUS_PREFIX) {\n+            return super.binaryArithmeticCoercion(binding);\n+        }\n+\n+        // Infer types.\n+\n+        RelDataType[] types = inferTypes(binding.getScope(), binding.operands(), true);\n+        if (types == null) {\n+            return false;\n+        }\n+\n+        // Do the coercion.\n+\n+        boolean coerced = false;\n+        for (int i = 0; i < types.length - 1; ++i) {\n+            boolean operandCoerced = coerceOperandType(binding.getScope(), binding.getCall(), i, types[i]);\n+            coerced |= operandCoerced;\n+        }\n+\n+        return coerced;\n+    }\n+\n+    @Override\n+    public boolean binaryComparisonCoercion(SqlCallBinding binding) {\n+        SqlKind kind = binding.getOperator().getKind();\n+        if (!kind.belongsTo(BINARY_EQUALITY) && !kind.belongsTo(BINARY_COMPARISON) && kind != BETWEEN) {\n+            return super.binaryComparisonCoercion(binding);\n+        }\n+\n+        // Infer types.\n+\n+        RelDataType[] types = inferTypes(binding.getScope(), binding.operands(), false);\n+        if (types == null) {\n+            return false;\n+        }\n+\n+        // Do the coercion.\n+\n+        RelDataType commonType = types[types.length - 1];\n+\n+        boolean coerced = false;\n+        for (int i = 0; i < types.length - 1; ++i) {\n+            RelDataType type = types[i];\n+            type = TYPE_FACTORY.createTypeWithNullability(commonType, type.isNullable());\n+            boolean operandCoerced = coerceOperandType(binding.getScope(), binding.getCall(), i, type);\n+            coerced |= operandCoerced;\n+\n+            // If the operand was coerced to integer type, reassign its CAST type\n+            // back to the common type: '0':VARCHAR -> CAST('0' AS INT(31)):INT(0)\n+            // -> CAST('0' AS INT(31)):INT(31).\n+            if (operandCoerced && isInteger(type)) {\n+                updateInferredType(binding.operand(i), type);\n+            }\n+        }\n+\n+        return coerced;\n+    }\n+\n+    @Override\n+    public boolean caseWhenCoercion(SqlCallBinding binding) {\n+        // Infer types.\n+\n+        SqlCase call = (SqlCase) binding.getCall();\n+        SqlNodeList thenOperands = call.getThenOperands();\n+\n+        List<SqlNode> operands = new ArrayList<>(thenOperands.size() + 1);\n+        operands.addAll(thenOperands.getList());\n+        operands.add(call.getElseOperand());\n+\n+        RelDataType[] types = inferTypes(binding.getScope(), operands, false);\n+        if (types == null) {\n+            return false;\n+        }\n+\n+        // Do the coercion.\n+\n+        boolean coerced = false;\n+        for (int i = 0; i < operands.size() - 1; ++i) {\n+            coerced |= coerceElementType(binding.getScope(), thenOperands, i, types[i]);\n+        }\n+        coerced |= coerceOperandType(binding.getScope(), call, 3, types[operands.size() - 1]);\n+\n+        updateInferredType(call, types[types.length - 1]);\n+\n+        return coerced;\n+    }\n+\n+    @Override\n+    public RelDataType implicitCast(RelDataType in, SqlTypeFamily expected) {\n+        // enables implicit conversion from CHAR to BOOLEAN\n+        if (CHAR_TYPES.contains(typeName(in)) && expected == SqlTypeFamily.BOOLEAN) {\n+            return TYPE_FACTORY.createSqlType(BOOLEAN, in.isNullable());\n+        }\n+\n+        return super.implicitCast(in, expected);\n+    }\n+\n+    @Override\n+    protected void updateInferredType(SqlNode node, RelDataType type) {\n+        ((HazelcastSqlValidator) validator).setKnownNodeType(node, type);\n+        super.updateInferredType(node, type);\n+    }\n+\n+    @Override\n+    protected boolean coerceOperandType(SqlValidatorScope scope, SqlCall call, int index, RelDataType to) {\n+        SqlNode operand = call.getOperandList().get(index);\n+        RelDataType from = validator.deriveType(scope, operand);\n+\n+        // Just update the inferred type if casting is not needed. But if casting\n+        // is not possible, still insert the cast to fail on its validation later.", "originalCommit": "1e5c9a84cbe56c63dbf43102116d335ce6cacfc4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDM5MjQ0Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r464392442", "bodyText": "Looks like it was doing something useful at some point, I clearly remember I have added it to fix some test. But now the only difference I have found is error messages produced during processing of literals: \"Cast function cannot convert value of type BOOLEAN to type TINYINT\" vs \"Literal 'FALSE' can not be parsed to type 'TINYINT'\". It might make some difference for temporal types, initially I started writing tests for them too and later deleted the tests. I'm going to remove the && canCast(from, to) part.", "author": "taburet", "createdAt": "2020-08-03T12:51:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM1NDMzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM1NDM4NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r453354384", "bodyText": "Why DOUBLE, and not DECIMAL?", "author": "devozerov", "createdAt": "2020-07-12T19:31:47Z", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/types/HazelcastTypeCoercion.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.validate.types;\n+\n+import com.hazelcast.sql.impl.calcite.validate.HazelcastSqlOperatorTable;\n+import com.hazelcast.sql.impl.calcite.validate.HazelcastSqlValidator;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.sql.SqlCall;\n+import org.apache.calcite.sql.SqlCallBinding;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.SqlLiteral;\n+import org.apache.calcite.sql.SqlNode;\n+import org.apache.calcite.sql.SqlNodeList;\n+import org.apache.calcite.sql.SqlUtil;\n+import org.apache.calcite.sql.fun.SqlCase;\n+import org.apache.calcite.sql.parser.SqlParserPos;\n+import org.apache.calcite.sql.type.SqlTypeFamily;\n+import org.apache.calcite.sql.type.SqlTypeUtil;\n+import org.apache.calcite.sql.validate.SqlValidatorScope;\n+import org.apache.calcite.sql.validate.implicit.TypeCoercionImpl;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static com.hazelcast.sql.impl.calcite.validate.SqlNodeUtil.isLiteral;\n+import static com.hazelcast.sql.impl.calcite.validate.SqlNodeUtil.isParameter;\n+import static com.hazelcast.sql.impl.calcite.validate.SqlNodeUtil.numericValue;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.canCast;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.isChar;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.isFloatingPoint;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.isInteger;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.isNumeric;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.isTemporal;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.narrowestTypeFor;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.typeName;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.withHigherPrecedence;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.withHigherPrecedenceForLiterals;\n+import static org.apache.calcite.sql.SqlKind.BETWEEN;\n+import static org.apache.calcite.sql.SqlKind.BINARY_ARITHMETIC;\n+import static org.apache.calcite.sql.SqlKind.BINARY_COMPARISON;\n+import static org.apache.calcite.sql.SqlKind.BINARY_EQUALITY;\n+import static org.apache.calcite.sql.SqlKind.MINUS_PREFIX;\n+import static org.apache.calcite.sql.SqlKind.PLUS_PREFIX;\n+import static org.apache.calcite.sql.type.SqlTypeName.ANY;\n+import static org.apache.calcite.sql.type.SqlTypeName.BIGINT;\n+import static org.apache.calcite.sql.type.SqlTypeName.BOOLEAN;\n+import static org.apache.calcite.sql.type.SqlTypeName.CHAR_TYPES;\n+import static org.apache.calcite.sql.type.SqlTypeName.DECIMAL;\n+import static org.apache.calcite.sql.type.SqlTypeName.DOUBLE;\n+import static org.apache.calcite.sql.type.SqlTypeName.NULL;\n+\n+/**\n+ * Provides custom coercion strategies supporting {@link HazelcastIntegerType}\n+ * and assigning more precise types comparing to the standard Calcite coercion.\n+ */\n+public final class HazelcastTypeCoercion extends TypeCoercionImpl {\n+\n+    private static final HazelcastTypeFactory TYPE_FACTORY = HazelcastTypeFactory.INSTANCE;\n+\n+    public HazelcastTypeCoercion(HazelcastSqlValidator validator) {\n+        super(TYPE_FACTORY, validator);\n+    }\n+\n+    @Override\n+    public boolean binaryArithmeticCoercion(SqlCallBinding binding) {\n+        SqlKind kind = binding.getOperator().getKind();\n+        if (!kind.belongsTo(BINARY_ARITHMETIC) && kind != PLUS_PREFIX && kind != MINUS_PREFIX) {\n+            return super.binaryArithmeticCoercion(binding);\n+        }\n+\n+        // Infer types.\n+\n+        RelDataType[] types = inferTypes(binding.getScope(), binding.operands(), true);\n+        if (types == null) {\n+            return false;\n+        }\n+\n+        // Do the coercion.\n+\n+        boolean coerced = false;\n+        for (int i = 0; i < types.length - 1; ++i) {\n+            boolean operandCoerced = coerceOperandType(binding.getScope(), binding.getCall(), i, types[i]);\n+            coerced |= operandCoerced;\n+        }\n+\n+        return coerced;\n+    }\n+\n+    @Override\n+    public boolean binaryComparisonCoercion(SqlCallBinding binding) {\n+        SqlKind kind = binding.getOperator().getKind();\n+        if (!kind.belongsTo(BINARY_EQUALITY) && !kind.belongsTo(BINARY_COMPARISON) && kind != BETWEEN) {\n+            return super.binaryComparisonCoercion(binding);\n+        }\n+\n+        // Infer types.\n+\n+        RelDataType[] types = inferTypes(binding.getScope(), binding.operands(), false);\n+        if (types == null) {\n+            return false;\n+        }\n+\n+        // Do the coercion.\n+\n+        RelDataType commonType = types[types.length - 1];\n+\n+        boolean coerced = false;\n+        for (int i = 0; i < types.length - 1; ++i) {\n+            RelDataType type = types[i];\n+            type = TYPE_FACTORY.createTypeWithNullability(commonType, type.isNullable());\n+            boolean operandCoerced = coerceOperandType(binding.getScope(), binding.getCall(), i, type);\n+            coerced |= operandCoerced;\n+\n+            // If the operand was coerced to integer type, reassign its CAST type\n+            // back to the common type: '0':VARCHAR -> CAST('0' AS INT(31)):INT(0)\n+            // -> CAST('0' AS INT(31)):INT(31).\n+            if (operandCoerced && isInteger(type)) {\n+                updateInferredType(binding.operand(i), type);\n+            }\n+        }\n+\n+        return coerced;\n+    }\n+\n+    @Override\n+    public boolean caseWhenCoercion(SqlCallBinding binding) {\n+        // Infer types.\n+\n+        SqlCase call = (SqlCase) binding.getCall();\n+        SqlNodeList thenOperands = call.getThenOperands();\n+\n+        List<SqlNode> operands = new ArrayList<>(thenOperands.size() + 1);\n+        operands.addAll(thenOperands.getList());\n+        operands.add(call.getElseOperand());\n+\n+        RelDataType[] types = inferTypes(binding.getScope(), operands, false);\n+        if (types == null) {\n+            return false;\n+        }\n+\n+        // Do the coercion.\n+\n+        boolean coerced = false;\n+        for (int i = 0; i < operands.size() - 1; ++i) {\n+            coerced |= coerceElementType(binding.getScope(), thenOperands, i, types[i]);\n+        }\n+        coerced |= coerceOperandType(binding.getScope(), call, 3, types[operands.size() - 1]);\n+\n+        updateInferredType(call, types[types.length - 1]);\n+\n+        return coerced;\n+    }\n+\n+    @Override\n+    public RelDataType implicitCast(RelDataType in, SqlTypeFamily expected) {\n+        // enables implicit conversion from CHAR to BOOLEAN\n+        if (CHAR_TYPES.contains(typeName(in)) && expected == SqlTypeFamily.BOOLEAN) {\n+            return TYPE_FACTORY.createSqlType(BOOLEAN, in.isNullable());\n+        }\n+\n+        return super.implicitCast(in, expected);\n+    }\n+\n+    @Override\n+    protected void updateInferredType(SqlNode node, RelDataType type) {\n+        ((HazelcastSqlValidator) validator).setKnownNodeType(node, type);\n+        super.updateInferredType(node, type);\n+    }\n+\n+    @Override\n+    protected boolean coerceOperandType(SqlValidatorScope scope, SqlCall call, int index, RelDataType to) {\n+        SqlNode operand = call.getOperandList().get(index);\n+        RelDataType from = validator.deriveType(scope, operand);\n+\n+        // Just update the inferred type if casting is not needed. But if casting\n+        // is not possible, still insert the cast to fail on its validation later.\n+        if (!needToCast(scope, operand, to) && canCast(from, to)) {\n+            updateInferredType(operand, to);\n+            return false;\n+        }\n+\n+        SqlNode cast = makeCast(operand, to);\n+        call.setOperand(index, cast);\n+        // derive the type of the newly created CAST immediately\n+        validator.deriveType(scope, cast);\n+        return true;\n+    }\n+\n+    @SuppressWarnings(\"checkstyle:NPathComplexity\")\n+    @Override\n+    protected boolean needToCast(SqlValidatorScope scope, SqlNode node, RelDataType to) {\n+        RelDataType from = validator.deriveType(scope, node);\n+\n+        if (typeName(from) == typeName(to)) {\n+            // already of the same type\n+            return false;\n+        }\n+\n+        if (typeName(from) == NULL || SqlUtil.isNullLiteral(node, false)) {\n+            // never cast NULLs, just assign types to them\n+            return false;\n+        }\n+\n+        if (typeName(to) == ANY) {\n+            // all types can be implicitly interpreted as ANY\n+            return false;\n+        }\n+        if (typeName(from) == ANY) {\n+            // casting from ANY is always required\n+            return true;\n+        }\n+\n+        if (isParameter(node)) {\n+            // never cast parameters, just assign types to them\n+            return false;\n+        }\n+\n+        if (isLiteral(node) && !(isTemporal(from) || isTemporal(to) || isChar(from) || isChar(to))) {\n+            // never cast literals, let Calcite decide on temporal and char ones\n+            return false;\n+        }\n+\n+        return super.needToCast(scope, node, to);\n+    }\n+\n+    private boolean coerceElementType(SqlValidatorScope scope, SqlNodeList list, int index, RelDataType to) {\n+        SqlNode element = list.get(index);\n+        RelDataType from = validator.deriveType(scope, element);\n+\n+        // Just update the inferred type if casting is not needed. But if casting\n+        // is not possible, still insert the cast to fail later on its validation.\n+        if (!needToCast(scope, element, to) && canCast(from, to)) {\n+            updateInferredType(element, to);\n+            return false;\n+        }\n+\n+        SqlNode cast = makeCast(element, to);\n+        list.set(index, cast);\n+        // derive the type of the newly created CAST immediately\n+        validator.deriveType(scope, cast);\n+        return true;\n+    }\n+\n+    private static SqlNode makeCast(SqlNode node, RelDataType type) {\n+        return HazelcastSqlOperatorTable.CAST.createCall(SqlParserPos.ZERO, node, SqlTypeUtil.convertTypeToSpec(type));\n+    }\n+\n+    @SuppressWarnings({\"checkstyle:CyclomaticComplexity\", \"checkstyle:MethodLength\", \"checkstyle:NPathComplexity\",\n+            \"checkstyle:NestedIfDepth\"})\n+    private RelDataType[] inferTypes(SqlValidatorScope scope, List<SqlNode> operands, boolean assumeNumeric) {\n+        // Infer common type from columns and sub-expressions.\n+\n+        RelDataType commonType = null;\n+        boolean seenParameters = false;\n+        boolean seenChar = false;\n+\n+        for (SqlNode operand : operands) {\n+            RelDataType operandType = validator.deriveType(scope, operand);\n+            if (isLiteral(operand)) {\n+                continue;\n+            }\n+\n+            if (isParameter(operand)) {\n+                seenParameters = true;\n+            } else {\n+                commonType = commonType == null ? operandType : withHigherPrecedence(operandType, commonType);\n+                seenChar |= isChar(operandType);\n+            }\n+        }\n+\n+        // Continue common type inference on numeric literals.\n+\n+        for (SqlNode operand : operands) {\n+            RelDataType operandType = validator.deriveType(scope, operand);\n+            if (!isLiteral(operand) || !isNumeric(operandType)) {\n+                continue;\n+            }\n+            SqlLiteral literal = (SqlLiteral) operand;\n+\n+            if (literal.getValue() == null) {\n+                operandType = TYPE_FACTORY.createSqlType(NULL);\n+            } else {\n+                BigDecimal numeric = literal.getValueAs(BigDecimal.class);\n+                operandType = narrowestTypeFor(numeric, commonType == null ? null : typeName(commonType));\n+            }\n+\n+            commonType = commonType == null ? operandType : withHigherPrecedenceForLiterals(operandType, commonType);\n+        }\n+\n+        // Continue common type inference on non-numeric literals.\n+\n+        for (SqlNode operand : operands) {\n+            RelDataType operandType = validator.deriveType(scope, operand);\n+            if (!isLiteral(operand) || isNumeric(operandType)) {\n+                continue;\n+            }\n+            SqlLiteral literal = (SqlLiteral) operand;\n+\n+            if (literal.getValue() == null) {\n+                operandType = TYPE_FACTORY.createSqlType(NULL);\n+            } else if (isChar(operandType) && (commonType != null && isNumeric(commonType) || assumeNumeric)) {\n+                // Infer proper numeric type for char literals.\n+\n+                BigDecimal numeric = numericValue(operand);\n+                assert numeric != null;\n+                operandType = narrowestTypeFor(numeric, commonType == null ? null : typeName(commonType));\n+            }\n+\n+            commonType = commonType == null ? operandType : withHigherPrecedenceForLiterals(operandType, commonType);\n+        }\n+\n+        // seen only parameters\n+        if (commonType == null) {\n+            assert seenParameters;\n+            return null;\n+        }\n+\n+        // can't infer parameter types if seen only NULLs\n+        if (typeName(commonType) == NULL && seenParameters) {\n+            return null;\n+        }\n+\n+        // fallback to DOUBLE from CHAR, if numeric types assumed\n+        if (isChar(commonType) && assumeNumeric) {\n+            commonType = TYPE_FACTORY.createSqlType(DOUBLE);", "originalCommit": "1e5c9a84cbe56c63dbf43102116d335ce6cacfc4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTAzOTIwOA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r465039208", "bodyText": "The idea was to avoid implicit conversions producing decimals. Still not sure which one to pick, wdyt?", "author": "taburet", "createdAt": "2020-08-04T13:12:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM1NDM4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTUwNDk1OA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r465504958", "bodyText": "The question is - what does it mean for users? Could you please show an example of a query when this branch kicks in? The main problem with DOUBLE is that it is inexact, which may easily lead to surprising results for users.", "author": "devozerov", "createdAt": "2020-08-05T06:37:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM1NDM4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTUxNDE3OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r465514179", "bodyText": "For instance, SELECT varcharColumn * varcharColumn.", "author": "taburet", "createdAt": "2020-08-05T06:59:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM1NDM4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTUzMjIzOA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r465532238", "bodyText": "I think, such a combination should not work at all, because it is ambiguous and there is not enough context to understand the user's intent.", "author": "devozerov", "createdAt": "2020-08-05T07:36:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM1NDM4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTYyNjg1Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r465626857", "bodyText": "created an issue for 4.2 #17311", "author": "taburet", "createdAt": "2020-08-05T10:25:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM1NDM4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM1Njk1Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r453356957", "bodyText": "INT type is displayed as INTEGER in Calcite exception. I think we'd better rename our type to INTEGER", "author": "devozerov", "createdAt": "2020-07-12T19:57:53Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/SqlColumnType.java", "diffHunk": "@@ -67,7 +67,14 @@\n     TIMESTAMP_WITH_TIME_ZONE(OffsetDateTime.class),\n \n     /** OBJECT type, could be represented by any Java class. */\n-    OBJECT(Object.class);\n+    OBJECT(Object.class),", "originalCommit": "b4fc2cb65857e9e3f59c91b56da643807522ca91", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ4NzE3MA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r465487170", "bodyText": "fixed int 6609ac1", "author": "taburet", "createdAt": "2020-08-05T05:47:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM1Njk1Nw=="}], "type": "inlineReview"}, {"oid": "80c991bd54ee8a81bb91d53dbd54107c04865257", "url": "https://github.com/hazelcast/hazelcast/commit/80c991bd54ee8a81bb91d53dbd54107c04865257", "message": "verify return types after conversion", "committedDate": "2020-07-13T09:54:23Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg5NTU4OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r456895589", "bodyText": "Typo: bellow -> below", "author": "petrpleshachkov", "createdAt": "2020-07-19T11:16:31Z", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/HazelcastRexBuilder.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite;\n+\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastIntegerType;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeFactory;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rel.type.RelDataTypeFactory;\n+import org.apache.calcite.rex.RexBuilder;\n+import org.apache.calcite.rex.RexNode;\n+\n+import static org.apache.calcite.sql.type.SqlTypeName.ANY;\n+import static org.apache.calcite.sql.type.SqlTypeName.REAL;\n+\n+/**\n+ * Custom Hazelcast expression builder.\n+ * <p>\n+ * Currently, this custom expression builder is used just to workaround quirks\n+ * of the default Calcite expression builder.\n+ */\n+public final class HazelcastRexBuilder extends RexBuilder {\n+\n+    public HazelcastRexBuilder(RelDataTypeFactory typeFactory) {\n+        super(typeFactory);\n+        assert typeFactory instanceof HazelcastTypeFactory;\n+    }\n+\n+    @Override\n+    public RexNode makeLiteral(Object value, RelDataType type, boolean allowCast) {\n+        // XXX: Calcite evaluates casts like CAST(0 AS ANY) statically and\n+        // assigns imprecise types: BIGINT for any integer value and DOUBLE for\n+        // any floating-point value (except BigDecimal). The code bellow fixes", "originalCommit": "a6ddd45d93de22e1b18f017c4a041231cc5b3229", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ4NzQ5OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r465487499", "bodyText": "fixed in dd2d5d7", "author": "taburet", "createdAt": "2020-08-05T05:48:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg5NTU4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzE0NDM1OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r457144359", "bodyText": "Can we reuse here super.equals()?", "author": "petrpleshachkov", "createdAt": "2020-07-20T07:50:12Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/BiExpressionWithType.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression;\n+\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+\n+/**\n+ * Base class for expressions acting on two operands and having a variable result\n+ * type.\n+ */\n+public abstract class BiExpressionWithType<T> extends BiExpression<T> {\n+\n+    protected QueryDataType resultType;\n+\n+    protected BiExpressionWithType() {\n+        // No-op.\n+    }\n+\n+    protected BiExpressionWithType(Expression<?> operand1, Expression<?> operand2, QueryDataType resultType) {\n+        this.operand1 = operand1;\n+        this.operand2 = operand2;\n+        this.resultType = resultType;\n+    }\n+\n+    @Override\n+    public QueryDataType getType() {\n+        return resultType;\n+    }\n+\n+    @Override\n+    public void writeData(ObjectDataOutput out) throws IOException {\n+        super.writeData(out);\n+\n+        out.writeObject(resultType);\n+    }\n+\n+    @Override\n+    public void readData(ObjectDataInput in) throws IOException {\n+        super.readData(in);\n+\n+        resultType = in.readObject();\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(operand1, operand2, resultType);\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+\n+        BiExpressionWithType<?> that = (BiExpressionWithType<?>) o;\n+\n+        return Objects.equals(operand1, that.operand1) && Objects.equals(operand2, that.operand2) && Objects.equals(resultType,", "originalCommit": "a6ddd45d93de22e1b18f017c4a041231cc5b3229", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ5NDY0Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r465494647", "bodyText": "fixed in f866c31", "author": "taburet", "createdAt": "2020-08-05T06:09:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzE0NDM1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzE2ODM2OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r457168369", "bodyText": "Why do we expect here uneven expressions count?", "author": "petrpleshachkov", "createdAt": "2020-07-20T08:23:41Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/predicate/CaseExpression.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.predicate;\n+\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+/**\n+ * Implements evaluation of SQL CASE operator.\n+ */\n+public final class CaseExpression<T> implements Expression<T>, IdentifiedDataSerializable {\n+\n+    private Expression<Boolean>[] conditions;\n+    private Expression<?>[] results;\n+    private QueryDataType resultType;\n+\n+    public CaseExpression() {\n+        // No-op.\n+    }\n+\n+    private CaseExpression(Expression<Boolean>[] conditions, Expression<?>[] results, QueryDataType resultType) {\n+        this.conditions = conditions;\n+        this.results = results;\n+        this.resultType = resultType;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public static CaseExpression<?> create(Expression<?>[] expressions, QueryDataType resultType) {\n+        // Split conditions and expressions.\n+        assert expressions != null;\n+        assert expressions.length % 2 == 1;", "originalCommit": "a6ddd45d93de22e1b18f017c4a041231cc5b3229", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE2ODE2NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r462168164", "bodyText": "clarified in 6201d4d", "author": "taburet", "createdAt": "2020-07-29T09:33:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzE2ODM2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzI4OTMyNg==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r457289326", "bodyText": "More JavaDoc about the precedence argument would be helpful. Are these numbers taken from the spec?", "author": "petrpleshachkov", "createdAt": "2020-07-20T11:14:59Z", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/HazelcastSqlOperatorTable.java", "diffHunk": "@@ -16,13 +16,257 @@\n \n package com.hazelcast.sql.impl.calcite.validate;\n \n+import com.hazelcast.sql.impl.calcite.validate.operators.HazelcastSqlBinaryOperator;\n+import com.hazelcast.sql.impl.calcite.validate.operators.HazelcastSqlCaseOperator;\n+import com.hazelcast.sql.impl.calcite.validate.operators.HazelcastSqlCastFunction;\n+import com.hazelcast.sql.impl.calcite.validate.operators.HazelcastSqlMonotonicBinaryOperator;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastInferTypes;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastOperandTypes;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastReturnTypes;\n+import org.apache.calcite.sql.SqlBinaryOperator;\n+import org.apache.calcite.sql.SqlFunction;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.SqlOperator;\n+import org.apache.calcite.sql.SqlPostfixOperator;\n+import org.apache.calcite.sql.SqlPrefixOperator;\n+import org.apache.calcite.sql.type.InferTypes;\n+import org.apache.calcite.sql.type.OperandTypes;\n+import org.apache.calcite.sql.type.ReturnTypes;\n import org.apache.calcite.sql.util.ReflectiveSqlOperatorTable;\n \n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastOperandTypes.notAllNull;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastOperandTypes.notAny;\n+\n /**\n- * An additional functions that are resolved during query parsing/validation.\n+ * Custom functions and operators.\n  */\n public final class HazelcastSqlOperatorTable extends ReflectiveSqlOperatorTable {\n \n+    //@formatter:off\n+\n+    public static final SqlFunction CAST = new HazelcastSqlCastFunction();\n+\n+    public static final SqlOperator CASE = new HazelcastSqlCaseOperator();\n+\n+    //#region Predicates.\n+\n+    public static final SqlBinaryOperator AND = new HazelcastSqlBinaryOperator(\n+        \"AND\",\n+        SqlKind.AND,\n+        24,", "originalCommit": "a6ddd45d93de22e1b18f017c4a041231cc5b3229", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTUxNDM1MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r465514351", "bodyText": "fixed in d1860f6", "author": "taburet", "createdAt": "2020-08-05T06:59:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzI4OTMyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQ3NTUwMw==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r459475503", "bodyText": "There is one strange thing about type coercion I observe with IN and OR operators. Consider that we have a table t(f INT), The following two queries are presumably equivalent:\nSELECT * FROM t WHERE f=? OR f=?\nSELECT * FROM t WHERE f IN (?,?)\n\nHowever, generated filters are not equivalent:\nOR(=(CAST($0):BIGINT(63), ?0), =(CAST($0):BIGINT(63), ?0))\nOR(=($0, ?0), =($0, ?1))\n\nThat is, we do upcast for OR, but not for IN.", "author": "devozerov", "createdAt": "2020-07-23T14:05:44Z", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/types/HazelcastTypeCoercion.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.validate.types;\n+\n+import com.hazelcast.sql.impl.calcite.validate.HazelcastSqlOperatorTable;\n+import com.hazelcast.sql.impl.calcite.validate.HazelcastSqlValidator;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.sql.SqlCall;\n+import org.apache.calcite.sql.SqlCallBinding;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.SqlLiteral;\n+import org.apache.calcite.sql.SqlNode;\n+import org.apache.calcite.sql.SqlNodeList;\n+import org.apache.calcite.sql.SqlUtil;\n+import org.apache.calcite.sql.fun.SqlCase;\n+import org.apache.calcite.sql.parser.SqlParserPos;\n+import org.apache.calcite.sql.type.SqlTypeFamily;\n+import org.apache.calcite.sql.type.SqlTypeUtil;\n+import org.apache.calcite.sql.validate.SqlValidatorScope;\n+import org.apache.calcite.sql.validate.implicit.TypeCoercionImpl;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static com.hazelcast.sql.impl.calcite.validate.SqlNodeUtil.isLiteral;\n+import static com.hazelcast.sql.impl.calcite.validate.SqlNodeUtil.isParameter;\n+import static com.hazelcast.sql.impl.calcite.validate.SqlNodeUtil.numericValue;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.canCast;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.isChar;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.isFloatingPoint;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.isInteger;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.isNumeric;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.isTemporal;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.narrowestTypeFor;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.typeName;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.withHigherPrecedence;\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeSystem.withHigherPrecedenceForLiterals;\n+import static org.apache.calcite.sql.SqlKind.BETWEEN;\n+import static org.apache.calcite.sql.SqlKind.BINARY_ARITHMETIC;\n+import static org.apache.calcite.sql.SqlKind.BINARY_COMPARISON;\n+import static org.apache.calcite.sql.SqlKind.BINARY_EQUALITY;\n+import static org.apache.calcite.sql.SqlKind.MINUS_PREFIX;\n+import static org.apache.calcite.sql.SqlKind.PLUS_PREFIX;\n+import static org.apache.calcite.sql.type.SqlTypeName.ANY;\n+import static org.apache.calcite.sql.type.SqlTypeName.BIGINT;\n+import static org.apache.calcite.sql.type.SqlTypeName.BOOLEAN;\n+import static org.apache.calcite.sql.type.SqlTypeName.CHAR_TYPES;\n+import static org.apache.calcite.sql.type.SqlTypeName.DECIMAL;\n+import static org.apache.calcite.sql.type.SqlTypeName.DOUBLE;\n+import static org.apache.calcite.sql.type.SqlTypeName.NULL;\n+\n+/**\n+ * Provides custom coercion strategies supporting {@link HazelcastIntegerType}\n+ * and assigning more precise types comparing to the standard Calcite coercion.\n+ */\n+public final class HazelcastTypeCoercion extends TypeCoercionImpl {", "originalCommit": "61a4f52218d94010087f1955d09fac33d8b70543", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQ3Njg5Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r459476892", "bodyText": "The same problem applies to BETWEEN statement: there is coercion for 'f >= ? AND f <= ?', but not for f BETWEEN ? AND ?.", "author": "devozerov", "createdAt": "2020-07-23T14:07:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQ3NTUwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQ5OTA1MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r459499051", "bodyText": "There is no support for in and between in this PR. I started some work on supporting them in sql branch, but decided to postpone it until basic expressions would be working. As far as I remember, the conversion of in into or and between into and is done during generation of RexNodes, but the coercion works on SqlNode level before the RexNodes are generated, that's why the outputs are not equivalent.", "author": "taburet", "createdAt": "2020-07-23T14:37:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQ3NTUwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUwNDM1OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r459504359", "bodyText": "Got it. Can we have a ticket for 4.2 for this, to ensure that we do not miss this fix?", "author": "devozerov", "createdAt": "2020-07-23T14:44:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQ3NTUwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg2ODczMw==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r459868733", "bodyText": "Thinking more about it, I have one additional question - what would be the behavior of the query SELECT * FROM t WHERE f_int IN (?, ?), when the passed parameter is Long? Will it fail on the parameter validation stage or during actual query execution? What would be the error message?", "author": "devozerov", "createdAt": "2020-07-24T06:12:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQ3NTUwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTkwMDg0OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r459900849", "bodyText": "At the current state of this PR, it should fail during parameter validation if the passed long value is outside of the int representable range, the message should mention the parameter position with a failure reason specified as something like \"numeric overflow ...\".", "author": "taburet", "createdAt": "2020-07-24T07:47:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQ3NTUwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDg0OTg5Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r464849897", "bodyText": "Created an issue #17303 for 4.2, but there is still a chance it can be squeezed to 4.1.", "author": "taburet", "createdAt": "2020-08-04T07:20:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQ3NTUwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUwMDQ4Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r459500483", "bodyText": "It seems that the comparison of objects is not supported. When I attempt to do f=f for t(f:ANY), the following exception is thrown:\nCannot apply '=' to arguments of type '<ANY> = <ANY>'. Supported form(s): '<COMPARABLE_TYPE> = <COMPARABLE_TYPE>'\n\nThere are two potential problems here:\n\nWhy object comparison is not supported in the first place?\nIf there is a reason to not support it right now, then error message is not intuitive: ANY could be COMPARABLE_TYPE", "author": "devozerov", "createdAt": "2020-07-23T14:39:28Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/predicate/ComparisonPredicate.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.predicate;\n+\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.BiExpression;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+\n+/**\n+ * Implements evaluation of SQL comparison predicates.\n+ *\n+ * @see ComparisonMode\n+ */\n+public final class ComparisonPredicate extends BiExpression<Boolean> implements IdentifiedDataSerializable {", "originalCommit": "61a4f52218d94010087f1955d09fac33d8b70543", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDgzNzA2MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r464837061", "bodyText": "created an issue #17301 for 4.2", "author": "taburet", "createdAt": "2020-08-04T06:52:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUwMDQ4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDg0NDE3NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r464844175", "bodyText": "created an issue #17302 for 4.2", "author": "taburet", "createdAt": "2020-08-04T07:08:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUwMDQ4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI1Mzc2NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r460253765", "bodyText": "This assertion fails for some types, e.g. for QueryDataType DECIMAL_BIG_INTEGER\nWhen we do bigIntegerColumn=?, then on the left side we have QueryDataType DECIMAL_BIG_INTEGER, but on the right side we have QueryDataType DECIMAL. They are not equal.\nPerhaps the correct assert should check for type family, not type.", "author": "devozerov", "createdAt": "2020-07-24T19:43:15Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/predicate/ComparisonPredicate.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.predicate;\n+\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.BiExpression;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+\n+/**\n+ * Implements evaluation of SQL comparison predicates.\n+ *\n+ * @see ComparisonMode\n+ */\n+public final class ComparisonPredicate extends BiExpression<Boolean> implements IdentifiedDataSerializable {\n+\n+    private ComparisonMode mode;\n+\n+    public ComparisonPredicate() {\n+        // No-op.\n+    }\n+\n+    private ComparisonPredicate(Expression<?> left, Expression<?> right, ComparisonMode mode) {\n+        super(left, right);\n+        this.mode = mode;\n+    }\n+\n+    public static ComparisonPredicate create(Expression<?> left, Expression<?> right, ComparisonMode comparisonMode) {\n+        assert left.getType().equals(right.getType());", "originalCommit": "be03c993b308fb3e328b19f54795d4172ac82d6c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDcwODA0MA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r460708040", "bodyText": "There are no non-canonical types on expressions level: types of literals, parameters and subexpressions are assigned by Calcite side and they are always canonical since Calcite side doesn't know anything about non-canonical ones, ColumnExpression is always reporting canonical types now.", "author": "taburet", "createdAt": "2020-07-27T07:51:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI1Mzc2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc0MTYxNQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r460741615", "bodyText": "Consider the following query that fails due to this assertion:\nSELECT * FROM table WHERE big_integer_column=1\n\nThis is a valid query with a supported data type. If I change the assertion to\nassert left.getType().getTypeFamily().equals(right.getType().getTypeFamily());\n\n... then the query works fine and produces correct results.\nThe same problem is applicable to java.lang.Character columns that are mapped to VARCHAR_CHARACTER. In future it will also be a problem for temporal types.\nShould we fix it to the assertion I mentioned above?", "author": "devozerov", "createdAt": "2020-07-27T08:51:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI1Mzc2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc0MzE2OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r460743169", "bodyText": "Or maybe this works differently in this PR comparing to the sql branch? I tried it in the sql branch. So perhaps I reported the problem that doesn't exist anymore.", "author": "devozerov", "createdAt": "2020-07-27T08:54:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI1Mzc2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc0NDAyMA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r460744020", "bodyText": "yes, just checked it, it works fine against this PR branch", "author": "taburet", "createdAt": "2020-07-27T08:55:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI1Mzc2NQ=="}], "type": "inlineReview"}, {"oid": "563815a422393a794bca782047009b922bd8f020", "url": "https://github.com/hazelcast/hazelcast/commit/563815a422393a794bca782047009b922bd8f020", "message": "minsu end-to-end test", "committedDate": "2020-07-27T09:30:54Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUxMjQwNg==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r463512406", "bodyText": "I came across this error message (here and in many other expressions) when doing tests that causes overflow. The problem is that it is not specific - the user will just receive it in runtime, without any understanding of what exactly went wrong.\nWhen implementing new operators I do something like this:\nthrow QueryException.error(SqlErrorCode.DATA_EXCEPTION,\n    \"BIGINT overflow in ABS function (consider adding explicit CAST to DECIMAL)\");\n\nI borrowed this approach from Postgres error messages - they always try to provide better user experience by adding more context to the error message.\nI propose to follow a similar approach in the expressions in this PR.", "author": "devozerov", "createdAt": "2020-07-31T09:42:30Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/math/PlusFunction.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.math;\n+\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.SqlErrorCode;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.BiExpressionWithType;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import com.hazelcast.sql.impl.type.QueryDataTypeFamily;\n+\n+import java.math.BigDecimal;\n+\n+/**\n+ * Implements evaluation of SQL plus operator.\n+ */\n+public final class PlusFunction<T> extends BiExpressionWithType<T> implements IdentifiedDataSerializable {\n+\n+    public PlusFunction() {\n+        // No-op.\n+    }\n+\n+    private PlusFunction(Expression<?> operand1, Expression<?> operand2, QueryDataType resultType) {\n+        super(operand1, operand2, resultType);\n+    }\n+\n+    public static PlusFunction<?> create(Expression<?> operand1, Expression<?> operand2, QueryDataType resultType) {\n+        return new PlusFunction<>(operand1, operand2, resultType);\n+    }\n+\n+    @Override\n+    public int getFactoryId() {\n+        return SqlDataSerializerHook.F_ID;\n+    }\n+\n+    @Override\n+    public int getClassId() {\n+        return SqlDataSerializerHook.EXPRESSION_PLUS;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public T eval(Row row, ExpressionEvalContext context) {\n+        Object left = operand1.eval(row, context);\n+        if (left == null) {\n+            return null;\n+        }\n+\n+        Object right = operand2.eval(row, context);\n+        if (right == null) {\n+            return null;\n+        }\n+\n+        QueryDataTypeFamily family = resultType.getTypeFamily();\n+        if (family.isTemporal()) {\n+            throw new UnsupportedOperationException(\"temporal types are unsupported currently\");\n+        }\n+\n+        return (T) evalNumeric((Number) left, (Number) right, family);\n+    }\n+\n+    private static Object evalNumeric(Number left, Number right, QueryDataTypeFamily family) {\n+        switch (family) {\n+            case TINYINT:\n+                return (byte) (left.byteValue() + right.byteValue());\n+            case SMALLINT:\n+                return (short) (left.shortValue() + right.shortValue());\n+            case INT:\n+                return left.intValue() + right.intValue();\n+            case BIGINT:\n+                try {\n+                    return Math.addExact(left.longValue(), right.longValue());\n+                } catch (ArithmeticException e) {\n+                    throw QueryException.error(SqlErrorCode.DATA_EXCEPTION, \"BIGINT overflow\");", "originalCommit": "1c19573976bfd66fa2aa2616e22787493cacba4c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjE1NjM4Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r466156383", "bodyText": "fixed in 4718719", "author": "taburet", "createdAt": "2020-08-06T05:34:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUxMjQwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDIyNzE5Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r464227192", "bodyText": "The comment relates to this piece of code and other code places where we dump the value. This could be a potential security vulnerability: we add the value to the message, and it could be printed to the application log.\nImagine an application where there are two roles - administrator and HR. An HR submits an invalid query that prints something like \"Cannot convert VARCHAR to DECIMAL: \". Now, by knowing the nature of the application the administrator can infer sensitive information from logs.\nOr imagine that in future we added some sort of row-level security, that allows users to query only rows that satisfy a certain predicate. Again, by carefully constructing the query a user may dump values that he should not have access to.\nNote that some values a harmless, e.g. literals. While others could be sensitive, e.g. column values.\n@kwart What do you think about that? I think we should avoid printing arbitrary internal values to logs.", "author": "devozerov", "createdAt": "2020-08-03T06:57:29Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/type/converter/Converter.java", "diffHunk": "@@ -318,6 +318,20 @@ protected final QueryException cannotConvert(QueryDataTypeFamily source, QueryDa\n         return QueryException.error(SqlErrorCode.DATA_EXCEPTION, message);\n     }\n \n+    protected final QueryException numericOverflow(QueryDataTypeFamily target, Object val) {\n+        return numericOverflow(typeFamily, target, val);\n+    }\n+\n+    protected final QueryException numericOverflow(QueryDataTypeFamily source, QueryDataTypeFamily target, Object val) {\n+        String message = \"Numeric overflow while converting \" + source + \" to \" + target;\n+\n+        if (val != null) {\n+            message += \": \" + val;", "originalCommit": "1c19573976bfd66fa2aa2616e22787493cacba4c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODUwMTczNg==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r468501736", "bodyText": "fixed in 9082f7d", "author": "taburet", "createdAt": "2020-08-11T11:10:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDIyNzE5Mg=="}], "type": "inlineReview"}, {"oid": "8bcaecc322c40f6efa45deb4b9a6bffdcdd2f7c3", "url": "https://github.com/hazelcast/hazelcast/commit/8bcaecc322c40f6efa45deb4b9a6bffdcdd2f7c3", "message": "rebase and fix compilation errors", "committedDate": "2020-08-05T06:01:26Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTUwODExNw==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r465508117", "bodyText": "catch (QueryException) misses other types of exceptions. It seems we need catch (Exception) here", "author": "devozerov", "createdAt": "2020-08-05T06:45:36Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/SqlInternalService.java", "diffHunk": "@@ -209,4 +210,33 @@ public QueryOperationHandlerImpl getOperationHandler() {\n     public QueryClientStateRegistry getClientStateRegistry() {\n         return clientStateRegistry;\n     }\n+\n+    private void prepareParameters(Plan plan, List<Object> params) {\n+        assert params != null;\n+        QueryParameterMetadata parameterMetadata = plan.getParameterMetadata();\n+\n+        int parameterCount = parameterMetadata.getParameterCount();\n+        if (parameterCount != params.size()) {\n+            throw QueryException.error(SqlErrorCode.DATA_EXCEPTION,\n+                    \"Unexpected parameter count: expected \" + parameterCount + \", got \" + params.size());\n+        }\n+\n+        for (int i = 0; i < params.size(); ++i) {\n+            Object value = params.get(i);\n+            if (value == null) {\n+                continue;\n+            }\n+\n+            Converter valueConverter = Converters.getConverter(value.getClass());\n+            Converter typeConverter = parameterMetadata.getParameterType(i).getConverter();\n+            try {\n+                value = typeConverter.convertToSelf(valueConverter, value);\n+            } catch (QueryException e) {", "originalCommit": "d1860f6d7e6df82a64ebaadb622ab723a3f1ce50", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTU0Nzc4NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r465547785", "bodyText": "Other types of exceptions are not related to conversion, users should not deal with them under the normal conditions.", "author": "taburet", "createdAt": "2020-08-05T08:04:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTUwODExNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTU1NTEwNA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r465555104", "bodyText": "Not really. Consider DoubleConverter. In the current branch, it cannot process conversion to DECIMAL properly in case of NaN and infinity. The result is an arithmetic exception with the error message Infinite or NaN. This is precisely what the user gets in the end: an SqlException with errorCode=-1 (GENERIC) and the message Infinite or NaN. There is no way for him to understand what is the real problem.\nWe cannot guarantee that we handle all exceptions in our converters. We may get all sorts of problems there, but users should get proper hint on where the exception happened - when attempting to convert this specific parameter to this specific type.", "author": "devozerov", "createdAt": "2020-08-05T08:18:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTUwODExNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTYzMDQwNA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r465630404", "bodyText": "fixd in d5fae6a", "author": "taburet", "createdAt": "2020-08-05T10:32:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTUwODExNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTUxMTM0Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r465511343", "bodyText": "Can we have a more specific error message here? Strictly speaking, NaN -> Long is not an overflow, but an invalid conversion.", "author": "devozerov", "createdAt": "2020-08-05T06:52:37Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/type/converter/FloatConverter.java", "diffHunk": "@@ -38,27 +40,66 @@ private FloatConverter() {\n \n     @Override\n     public byte asTinyint(Object val) {\n-        return (byte) cast(val);\n+        float casted = cast(val);\n+        // here the overflow may happen: (byte) casted = (byte) (int) casted\n+        byte converted = (byte) casted;\n+\n+        // casts from float to int are saturating\n+        if (converted != (int) casted || !Float.isFinite(casted)) {\n+            throw numericOverflow(QueryDataTypeFamily.TINYINT, val);\n+        }\n+\n+        return converted;\n     }\n \n     @Override\n     public short asSmallint(Object val) {\n-        return (short) cast(val);\n+        float casted = cast(val);\n+        // here the overflow may happen: (short) casted = (short) (int) casted\n+        short converted = (short) casted;\n+\n+        // casts from float to int are saturating\n+        if (converted != (int) casted || !Float.isFinite(casted)) {\n+            throw numericOverflow(QueryDataTypeFamily.SMALLINT, val);\n+        }\n+\n+        return converted;\n     }\n \n     @Override\n     public int asInt(Object val) {\n-        return (int) cast(val);\n+        float casted = cast(val);\n+        // casts from float to int are saturating\n+        int converted = (int) casted;\n+\n+        // casts from float to long are saturating\n+        if (converted != (long) casted || !Float.isFinite(casted)) {\n+            throw numericOverflow(QueryDataTypeFamily.INT, val);\n+        }\n+\n+        return converted;\n     }\n \n     @Override\n     public long asBigint(Object val) {\n-        return (long) cast(val);\n+        float casted = cast(val);\n+        float truncated = (float) (casted > 0.0 ? Math.floor(casted) : Math.ceil(casted));\n+        // casts from float to long are saturating\n+        long converted = (long) truncated;\n+\n+        // No checks for NaNs and infinities are needed: NaNs are zeros and\n+        // infinities are Long.MAX/MIN_VALUE when converted to long.\n+        if ((float) converted != truncated) {", "originalCommit": "d1860f6d7e6df82a64ebaadb622ab723a3f1ce50", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjE2NTM2Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r466165363", "bodyText": "fixed in bec5306", "author": "taburet", "createdAt": "2020-08-06T06:04:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTUxMTM0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTUyMDY5NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r465520694", "bodyText": "What would happen if we have a literal that just happened to have e or E character, but otherwise is not a number? The exception mentions that the literal \"cannot be converted to DECIMAL\", while this is not really the case - we may have attempted to convert it to DOUBLE. Can we change it to something like ... cannot be converted to numeric type?", "author": "devozerov", "createdAt": "2020-08-05T07:13:25Z", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/SqlNodeUtil.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.validate;\n+\n+import com.hazelcast.sql.SqlErrorCode;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.type.converter.StringConverter;\n+import org.apache.calcite.runtime.CalciteContextException;\n+import org.apache.calcite.sql.SqlDynamicParam;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.SqlLiteral;\n+import org.apache.calcite.sql.SqlNode;\n+import org.apache.calcite.sql.SqlUtil;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+\n+import java.math.BigDecimal;\n+\n+import static org.apache.calcite.sql.type.SqlTypeName.APPROX_TYPES;\n+import static org.apache.calcite.sql.type.SqlTypeName.CHAR_TYPES;\n+import static org.apache.calcite.sql.type.SqlTypeName.DECIMAL;\n+import static org.apache.calcite.sql.type.SqlTypeName.EXACT_TYPES;\n+import static org.apache.calcite.util.Static.RESOURCE;\n+\n+/**\n+ * Utility methods to work with {@link SqlNode}s.\n+ */\n+public final class SqlNodeUtil {\n+\n+    private SqlNodeUtil() {\n+    }\n+\n+    /**\n+     * @return {@code true} if the given node is a {@linkplain SqlDynamicParam\n+     * dynamic parameter}, {@code false} otherwise.\n+     */\n+    public static boolean isParameter(SqlNode node) {\n+        return node.getKind() == SqlKind.DYNAMIC_PARAM;\n+    }\n+\n+    /**\n+     * @return {@code true} if the given node is a {@linkplain SqlLiteral literal},\n+     * {@code false} otherwise.\n+     */\n+    public static boolean isLiteral(SqlNode node) {\n+        return node.getKind() == SqlKind.LITERAL;\n+    }\n+\n+    /**\n+     * Obtains a numeric value of the given node if it's a numeric or string\n+     * {@linkplain SqlLiteral literal}.\n+     * <p>\n+     * If the literal represents an exact value (see {@link\n+     * SqlTypeName#EXACT_TYPES}), the obtained numeric value is {@link BigDecimal}.\n+     * Otherwise, if the literal represents an approximate value (see {@link\n+     * SqlTypeName#APPROX_TYPES}), the obtained numeric value is {@link Double}.\n+     *\n+     * @param node the node to obtain the numeric value of.\n+     * @return the obtained numeric value or {@code null} if the given node is\n+     * not a numeric or string literal.\n+     * @throws CalciteContextException if the given node is a string literal\n+     *                                 that doesn't have a valid numeric\n+     *                                 representation.\n+     */\n+    public static Number numericValue(SqlNode node) {\n+        if (node.getKind() != SqlKind.LITERAL) {\n+            return null;\n+        }\n+\n+        SqlLiteral literal = (SqlLiteral) node;\n+        SqlTypeName typeName = literal.getTypeName();\n+\n+        if (CHAR_TYPES.contains(typeName)) {\n+            try {\n+                String value = literal.getValueAs(String.class);\n+                if (value == null) {\n+                    return null;\n+                }\n+\n+                if (value.contains(\"e\") || value.contains(\"E\")) {", "originalCommit": "d1860f6d7e6df82a64ebaadb622ab723a3f1ce50", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY5MjA0OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r465692049", "bodyText": "fixed in f19f51f", "author": "taburet", "createdAt": "2020-08-05T12:33:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTUyMDY5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTUyNTM4OA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r465525388", "bodyText": "The test doesn't assert MIN_VALUE-s. For example, Byte.MAX_VALUE yields TINYINT, while Byte.MIN_VALUE yields SMALLINT. Is there a reason for this?", "author": "devozerov", "createdAt": "2020-08-05T07:22:52Z", "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/LiteralEndToEndTest.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression;\n+\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import java.math.BigDecimal;\n+\n+import static com.hazelcast.sql.SqlColumnType.BIGINT;\n+import static com.hazelcast.sql.SqlColumnType.BOOLEAN;\n+import static com.hazelcast.sql.SqlColumnType.DECIMAL;\n+import static com.hazelcast.sql.SqlColumnType.DOUBLE;\n+import static com.hazelcast.sql.SqlColumnType.INTEGER;\n+import static com.hazelcast.sql.SqlColumnType.NULL;\n+import static com.hazelcast.sql.SqlColumnType.SMALLINT;\n+import static com.hazelcast.sql.SqlColumnType.TINYINT;\n+import static com.hazelcast.sql.SqlColumnType.VARCHAR;\n+\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class LiteralEndToEndTest extends ExpressionEndToEndTestBase {\n+\n+    @Test\n+    public void testValid() {\n+        assertRow(\"0\", EXPR0, TINYINT, (byte) 0);\n+        assertRow(\"-0\", EXPR0, TINYINT, (byte) 0);\n+        assertRow(\"000\", EXPR0, TINYINT, (byte) 0);\n+        assertRow(\"1\", EXPR0, TINYINT, (byte) 1);\n+        assertRow(\"-1\", EXPR0, TINYINT, (byte) -1);\n+        assertRow(\"-01\", EXPR0, TINYINT, (byte) -1);\n+        assertRow(\"001\", EXPR0, TINYINT, (byte) 1);\n+        assertRow(\"100\", EXPR0, TINYINT, (byte) 100);\n+        assertRow(Byte.toString(Byte.MAX_VALUE), EXPR0, TINYINT, Byte.MAX_VALUE);", "originalCommit": "d1860f6d7e6df82a64ebaadb622ab723a3f1ce50", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjE4NTg3Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r466185873", "bodyText": "fixed in 25f20bb", "author": "taburet", "createdAt": "2020-08-06T06:58:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTUyNTM4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTUyNTk3NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r465525974", "bodyText": "Is it possible to specify NaN or infinite values as literal? AFAIK some databases, such as Postgres, can do that", "author": "devozerov", "createdAt": "2020-08-05T07:24:03Z", "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/LiteralEndToEndTest.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression;\n+\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import java.math.BigDecimal;\n+\n+import static com.hazelcast.sql.SqlColumnType.BIGINT;\n+import static com.hazelcast.sql.SqlColumnType.BOOLEAN;\n+import static com.hazelcast.sql.SqlColumnType.DECIMAL;\n+import static com.hazelcast.sql.SqlColumnType.DOUBLE;\n+import static com.hazelcast.sql.SqlColumnType.INTEGER;\n+import static com.hazelcast.sql.SqlColumnType.NULL;\n+import static com.hazelcast.sql.SqlColumnType.SMALLINT;\n+import static com.hazelcast.sql.SqlColumnType.TINYINT;\n+import static com.hazelcast.sql.SqlColumnType.VARCHAR;\n+\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class LiteralEndToEndTest extends ExpressionEndToEndTestBase {\n+\n+    @Test\n+    public void testValid() {\n+        assertRow(\"0\", EXPR0, TINYINT, (byte) 0);\n+        assertRow(\"-0\", EXPR0, TINYINT, (byte) 0);\n+        assertRow(\"000\", EXPR0, TINYINT, (byte) 0);\n+        assertRow(\"1\", EXPR0, TINYINT, (byte) 1);\n+        assertRow(\"-1\", EXPR0, TINYINT, (byte) -1);\n+        assertRow(\"-01\", EXPR0, TINYINT, (byte) -1);\n+        assertRow(\"001\", EXPR0, TINYINT, (byte) 1);\n+        assertRow(\"100\", EXPR0, TINYINT, (byte) 100);\n+        assertRow(Byte.toString(Byte.MAX_VALUE), EXPR0, TINYINT, Byte.MAX_VALUE);\n+\n+        assertRow(Short.toString((short) (Byte.MAX_VALUE + 1)), EXPR0, SMALLINT, (short) (Byte.MAX_VALUE + 1));\n+        assertRow(Short.toString(Short.MAX_VALUE), EXPR0, SMALLINT, Short.MAX_VALUE);\n+\n+        assertRow(Integer.toString(Short.MAX_VALUE + 1), EXPR0, INTEGER, Short.MAX_VALUE + 1);\n+        assertRow(Integer.toString(Integer.MAX_VALUE), EXPR0, INTEGER, Integer.MAX_VALUE);\n+\n+        assertRow(Long.toString(Integer.MAX_VALUE + 1L), EXPR0, BIGINT, Integer.MAX_VALUE + 1L);\n+        assertRow(Long.toString(Long.MAX_VALUE), EXPR0, BIGINT, Long.MAX_VALUE);\n+\n+        assertRow(\"0.0\", EXPR0, DECIMAL, new BigDecimal(\"0.0\"));\n+        assertRow(\"1.0\", EXPR0, DECIMAL, new BigDecimal(\"1.0\"));\n+        assertRow(\"1.000\", EXPR0, DECIMAL, new BigDecimal(\"1.000\"));\n+        assertRow(\"001.000\", EXPR0, DECIMAL, new BigDecimal(\"1.000\"));\n+        assertRow(\"1.1\", EXPR0, DECIMAL, new BigDecimal(\"1.1\"));\n+        assertRow(\"1.100\", EXPR0, DECIMAL, new BigDecimal(\"1.100\"));\n+        assertRow(\"001.100\", EXPR0, DECIMAL, new BigDecimal(\"1.100\"));\n+        assertRow(\"-0.0\", EXPR0, DECIMAL, new BigDecimal(\"0.0\"));\n+        assertRow(\"-1.0\", EXPR0, DECIMAL, new BigDecimal(\"-1.0\"));\n+        assertRow(\"-001.100\", EXPR0, DECIMAL, new BigDecimal(\"-1.100\"));\n+        assertRow(\".0\", EXPR0, DECIMAL, BigDecimal.valueOf(0.0));\n+        assertRow(\".1\", EXPR0, DECIMAL, BigDecimal.valueOf(0.1));\n+\n+        assertRow(\"0e0\", EXPR0, DOUBLE, 0.0);\n+        assertRow(\"1e0\", EXPR0, DOUBLE, 1.0);\n+        assertRow(\"1e000\", EXPR0, DOUBLE, 1.0);\n+        assertRow(\"001e000\", EXPR0, DOUBLE, 1.0);\n+        assertRow(\"1.1e0\", EXPR0, DOUBLE, 1.1);\n+        assertRow(\"1.100e0\", EXPR0, DOUBLE, 1.1);\n+        assertRow(\"001.100e0\", EXPR0, DOUBLE, 1.1);\n+        assertRow(\"-0.0e0\", EXPR0, DOUBLE, 0.0);\n+        assertRow(\"-1.0e0\", EXPR0, DOUBLE, -1.0);\n+        assertRow(\"-001.100e0\", EXPR0, DOUBLE, -1.1);\n+        assertRow(\".0e0\", EXPR0, DOUBLE, 0.0);\n+        assertRow(\".1e0\", EXPR0, DOUBLE, 0.1);\n+        assertRow(\"1.1e1\", EXPR0, DOUBLE, 11.0);\n+        assertRow(\"1.1e-1\", EXPR0, DOUBLE, 0.11);", "originalCommit": "d1860f6d7e6df82a64ebaadb622ab723a3f1ce50", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjI4NTczOQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r466285739", "bodyText": "created an issue for 4.2 #17314", "author": "taburet", "createdAt": "2020-08-06T09:34:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTUyNTk3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTUyOTAwMg==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r465529002", "bodyText": "This test mostly tests parameters with expressions but does not test parameters in isolation. The interesting part here is what would happen when the parameter's value is converted (valid or invalid), and the behavior for SELECT ? ...", "author": "devozerov", "createdAt": "2020-08-05T07:30:04Z", "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/ParameterEndToEndTest.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression;\n+\n+import com.hazelcast.sql.SqlErrorCode;\n+import com.hazelcast.sql.impl.expression.math.ExpressionMath;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+import static com.hazelcast.sql.SqlColumnType.BIGINT;\n+import static com.hazelcast.sql.SqlColumnType.BOOLEAN;\n+import static com.hazelcast.sql.SqlColumnType.DECIMAL;\n+import static com.hazelcast.sql.SqlColumnType.DOUBLE;\n+import static com.hazelcast.sql.SqlColumnType.REAL;\n+import static com.hazelcast.sql.SqlColumnType.SMALLINT;\n+\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class ParameterEndToEndTest extends ExpressionEndToEndTestBase {\n+\n+    @Test\n+    public void testBoolean() {\n+        assertRow(\"booleanTrue and ?\", EXPR0, BOOLEAN, false, false);", "originalCommit": "d1860f6d7e6df82a64ebaadb622ab723a3f1ce50", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjI4OTU4OA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r466289588", "bodyText": "fixed in 3d4560a", "author": "taburet", "createdAt": "2020-08-06T09:37:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTUyOTAwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjI5OTM2Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r466299362", "bodyText": "Sorry, I can't remember - do we have a ticket for more flexible behavior and more specific error messages for parameters?", "author": "devozerov", "createdAt": "2020-08-06T09:52:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTUyOTAwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjMxNDYyMQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r466314621", "bodyText": "here it is #17315", "author": "taburet", "createdAt": "2020-08-06T10:21:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTUyOTAwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjMxNTc0NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r466315744", "bodyText": "Please disregard. There is an open comment for parameter behavior. Resolving this.", "author": "devozerov", "createdAt": "2020-08-06T10:24:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTUyOTAwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTU0NDYyOQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r465544629", "bodyText": "There is one very subtle thing with literal conversions. Consider the following expressions and produced result types. The concrete function is not that important here, because the problem appears to be in the inference mechanics:\nSELECT ABS(1) ... // DECIMAL\nSELECT ABS(`1`) ... // DECIMAL due to inference VARCHAR -> DECIMAL\nSELECT ABS(1E0) ... // DOUBLE\nSELECT ABS(`1E0`) ... // DECIMAL due to inference path VARCHAR -> DECIMAL\n\nThe last result could be surprising to users - somehow an inexact expression is converted to the exact form. I do not say that this is definitely a bug, but ideally we should have a consistent behavior.", "author": "devozerov", "createdAt": "2020-08-05T07:59:25Z", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/SqlNodeUtil.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.validate;\n+\n+import com.hazelcast.sql.SqlErrorCode;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.type.converter.StringConverter;\n+import org.apache.calcite.runtime.CalciteContextException;\n+import org.apache.calcite.sql.SqlDynamicParam;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.SqlLiteral;\n+import org.apache.calcite.sql.SqlNode;\n+import org.apache.calcite.sql.SqlUtil;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+\n+import java.math.BigDecimal;\n+\n+import static org.apache.calcite.sql.type.SqlTypeName.APPROX_TYPES;\n+import static org.apache.calcite.sql.type.SqlTypeName.CHAR_TYPES;\n+import static org.apache.calcite.sql.type.SqlTypeName.DECIMAL;\n+import static org.apache.calcite.sql.type.SqlTypeName.EXACT_TYPES;\n+import static org.apache.calcite.util.Static.RESOURCE;\n+\n+/**\n+ * Utility methods to work with {@link SqlNode}s.\n+ */\n+public final class SqlNodeUtil {\n+\n+    private SqlNodeUtil() {\n+    }\n+\n+    /**\n+     * @return {@code true} if the given node is a {@linkplain SqlDynamicParam\n+     * dynamic parameter}, {@code false} otherwise.\n+     */\n+    public static boolean isParameter(SqlNode node) {\n+        return node.getKind() == SqlKind.DYNAMIC_PARAM;\n+    }\n+\n+    /**\n+     * @return {@code true} if the given node is a {@linkplain SqlLiteral literal},\n+     * {@code false} otherwise.\n+     */\n+    public static boolean isLiteral(SqlNode node) {\n+        return node.getKind() == SqlKind.LITERAL;\n+    }\n+\n+    /**\n+     * Obtains a numeric value of the given node if it's a numeric or string\n+     * {@linkplain SqlLiteral literal}.\n+     * <p>\n+     * If the literal represents an exact value (see {@link\n+     * SqlTypeName#EXACT_TYPES}), the obtained numeric value is {@link BigDecimal}.\n+     * Otherwise, if the literal represents an approximate value (see {@link\n+     * SqlTypeName#APPROX_TYPES}), the obtained numeric value is {@link Double}.\n+     *\n+     * @param node the node to obtain the numeric value of.\n+     * @return the obtained numeric value or {@code null} if the given node is\n+     * not a numeric or string literal.\n+     * @throws CalciteContextException if the given node is a string literal\n+     *                                 that doesn't have a valid numeric\n+     *                                 representation.\n+     */\n+    public static Number numericValue(SqlNode node) {", "originalCommit": "d1860f6d7e6df82a64ebaadb622ab723a3f1ce50", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY0NzIzNw==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r465647237", "bodyText": "I don't see inference path for SELECT ABS(1E0) in SqlNodeUtil.numericValue leading to DECIMAL. Most likely no custom type coercion/inference is even performed for ABS, what you see is the standard Calcite behavior, it coerces VARCHAR to DECIMAL in numeric contexts. Feel free to provide a fix in math functions PR.", "author": "taburet", "createdAt": "2020-08-05T11:07:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTU0NDYyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjMwNjk4MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r466306981", "bodyText": "Sorry, I do not quite understand what sort of fix do you mean. What I see is that the problem is in our code: the literal is resolved correctly to DOUBLE. But before that, the CAST to DECIMAL is added in HazelcastTypeCoercion#coerceOperandType. Why do we add this cast in case of literal?", "author": "devozerov", "createdAt": "2020-08-06T10:06:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTU0NDYyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjMxNDc4NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r466314785", "bodyText": "To clarify - I'd like to understand how to use the basis we built for new functions. It seems that it is not enough to just declare the new function with the proper parameter in the HazelcastSqlOperatorTable. What is supposed to be the proper process of doing it?", "author": "devozerov", "createdAt": "2020-08-06T10:22:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTU0NDYyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjMyMTc1OA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r466321758", "bodyText": "Perhaps the problem is in HazelcastSqlValidator#deriveLiteralType - when a literal with single quotes is passed there, the resulting literal type is VARCHAR. It seems that if we resolve the type properly here to DECIMAL/DOUBLE (in addition to the existing logic), the problem will go away.", "author": "devozerov", "createdAt": "2020-08-06T10:36:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTU0NDYyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjQwMjcyMw==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r466402723", "bodyText": "What you see is the standard Calcite behavior, it coerces VARCHAR to DECIMAL in numeric contexts, ABS expects numeric value, so Calcite inserts CAST('1E0' AS DECIMAL), so '1E0' is now interpreted as a numeric value, for which a proper type (DOUBLE) is inferred since it represents an approximate numeric literal, but the cast is still there: CAST('1E0':DOUBLE AS DECIMAL):DECIMAL.\nNot quite sure how the proposed fix of HazelcastSqlValidator.deriveLiteralType might work, basically all VARCHAR literals resembling numbers would receive numeric types: LENGTH('1E0') -> LENGTH(CAST('1E0' AS DOUBLE)), that should produce an error since there is no implicit conversion from DOUBLE to VARCHAR and there is no LENGTH overload accepting DOUBLE.\nMost likely a proper fix would require some customization of TypeCoercionImpl behavior using HazelcastTypeCoercion. Not sure how the potential fix would look like at the moment, let's leave it for math functions PR.", "author": "taburet", "createdAt": "2020-08-06T13:14:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTU0NDYyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjQzNjkyMQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r466436921", "bodyText": "In the case of ABS, the target type is NUMERIC, while the operand type is VARCHAR. The latter comes from our code HazelcastSqlValidator.deriveLiteralType. If I add additional logic, that returns DOUBLE for this literal, the test passes as expected: target type is NUMERIC, the literal type is DOUBLE -> final type is DOUBLE and no conversion is needed.\nI think we should not postpone this to other expressions because this is not tied to math functions. Every expression is potentially affected. It seems natural to have a consistent type derivation logic for literals implemented in the first place so that we do not need to adjust literals in every future expression separately.", "author": "devozerov", "createdAt": "2020-08-06T14:04:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTU0NDYyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjQ3NDk3MA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r466474970", "bodyText": "I tried to apply the fix, formally the expression worked, but now other things like SELECT LENGTH('1e5') show incorrect results.\nYes, it seems that literal handling is context-dependent, but it is still an open question - do we understand how to handle literals properly for an arbitrary function? Is it supposed that we will write a custom handling for every function? If yes, then what is the proposed developer's workflow?", "author": "devozerov", "createdAt": "2020-08-06T14:57:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTU0NDYyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjQ4NTQ4Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r466485487", "bodyText": "Honestly, I feel that I lost in our coercion strategies and the way it works in general. I would propose to have a design document with a high-level explanation of how it works. Otherwise, we would end up with a code full of magic that is hard to change and maintain (I mean mainly the class HazelcastTypeCoercion).", "author": "devozerov", "createdAt": "2020-08-06T15:12:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTU0NDYyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYzMjIxNQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r466632215", "bodyText": "To clarify on this comment - this is not a blocker for merge. We may go without aligned literals semantics because literals are still work in progress (e.g. temporal ones), and specifically about quoted inexact literals - there is a workaround not to use quotes.\nRegarding design, I have a feeling that we do not have a clear picture of how expressions should work in general. We have some conversions and coercion here and there, but it is hard to see the design behind them. Nevertheless, I have a feeling that we already did much more than many other products wrt Calcite integration, and created a good basis. Ideally, we should come with a nice and consistent design in 4.2, because if there is a common-sense on how the system works that users could grasp easily, it will make user experience much better. To me, a good example is Postgres, where they explain functions through overloads, that could even be queried from the system table. We have a plenty of things to understand - how to deal with parameters, what exactly \"implicit conversion\" means (e.g. should LENGTH(boolField) work or not?), etc.\nTherefore, marking this discussion as resolved for now, to avoid delays with merge.", "author": "devozerov", "createdAt": "2020-08-06T19:18:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTU0NDYyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTU1NzQzNQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r465557435", "bodyText": "We throw overflow exceptions for NaN/Infinite. However, it seems that conversion to VARCHAR works fine in this case. Consider the following statement\nSELECT ... CAST((CAST doubleCol as VARCHAR) as DOUBLE) ...\n\nWhat would happen if the value of the column is NaN? Will it convert the NaN string back to Double.NaN?", "author": "devozerov", "createdAt": "2020-08-05T08:22:13Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/type/converter/DoubleConverter.java", "diffHunk": "@@ -38,27 +40,65 @@ private DoubleConverter() {\n \n     @Override\n     public byte asTinyint(Object val) {\n-        return (byte) cast(val);\n+        double casted = cast(val);\n+        // here the overflow may happen: (byte) casted = (byte) (int) casted\n+        byte converted = (byte) casted;\n+\n+        // casts from double to int are saturating\n+        if (converted != (int) casted || !Double.isFinite(casted)) {\n+            throw numericOverflow(QueryDataTypeFamily.TINYINT, val);\n+        }\n+\n+        return converted;\n     }\n \n     @Override\n     public short asSmallint(Object val) {\n-        return (short) cast(val);\n+        double casted = cast(val);\n+        // here the overflow may happen: (short) casted = (short) (int) casted\n+        short converted = (short) casted;\n+\n+        // casts from double to int are saturating\n+        if (converted != (int) casted || !Double.isFinite(casted)) {\n+            throw numericOverflow(QueryDataTypeFamily.SMALLINT, val);\n+        }\n+\n+        return converted;\n     }\n \n     @Override\n     public int asInt(Object val) {\n-        return (int) cast(val);\n+        double casted = cast(val);\n+        int converted = (int) casted;\n+\n+        // casts from double to long are saturating\n+        if (converted != (long) casted || !Double.isFinite(casted)) {\n+            throw numericOverflow(QueryDataTypeFamily.INT, val);\n+        }\n+\n+        return converted;\n     }\n \n     @Override\n     public long asBigint(Object val) {\n-        return (long) cast(val);\n+        double casted = cast(val);\n+        double truncated = casted > 0.0 ? Math.floor(casted) : Math.ceil(casted);\n+        // casts from double to long are saturating\n+        long converted = (long) truncated;\n+\n+        // No checks for NaNs and infinities are needed: NaNs are zeros and\n+        // infinities are Long.MAX/MIN_VALUE when converted to long.\n+        if ((double) converted != truncated) {\n+            throw numericOverflow(QueryDataTypeFamily.BIGINT, val);", "originalCommit": "d1860f6d7e6df82a64ebaadb622ab723a3f1ce50", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTU4MDY2Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r465580666", "bodyText": "Yes, it will convert Double.NaN to 'NaN' and then back to Double.NaN, other special values are working the same way. Why you are considering it as an issue? Double-to-string is lossless and reversible, but double-to-bigint is lossy and not reversible because of that.", "author": "taburet", "createdAt": "2020-08-05T09:02:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTU1NzQzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjI5NDgxMg==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r466294812", "bodyText": "My concern was whether it is possible to convert \"NaN\" from VARCHAR back to REAL/DOUBLE. If this is the case, then I do not see any issues.", "author": "devozerov", "createdAt": "2020-08-06T09:44:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTU1NzQzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjM2ODI2OA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r466368268", "bodyText": "I would propose to add the type to which we tried to convert. E.g.:\nFailed to convert parameter at position 1 to VARCHAR: ...", "author": "devozerov", "createdAt": "2020-08-06T12:14:08Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/SqlInternalService.java", "diffHunk": "@@ -209,4 +210,33 @@ public QueryOperationHandlerImpl getOperationHandler() {\n     public QueryClientStateRegistry getClientStateRegistry() {\n         return clientStateRegistry;\n     }\n+\n+    private void prepareParameters(Plan plan, List<Object> params) {\n+        assert params != null;\n+        QueryParameterMetadata parameterMetadata = plan.getParameterMetadata();\n+\n+        int parameterCount = parameterMetadata.getParameterCount();\n+        if (parameterCount != params.size()) {\n+            throw QueryException.error(SqlErrorCode.DATA_EXCEPTION,\n+                    \"Unexpected parameter count: expected \" + parameterCount + \", got \" + params.size());\n+        }\n+\n+        for (int i = 0; i < params.size(); ++i) {\n+            Object value = params.get(i);\n+            if (value == null) {\n+                continue;\n+            }\n+\n+            Converter valueConverter = Converters.getConverter(value.getClass());\n+            Converter typeConverter = parameterMetadata.getParameterType(i).getConverter();\n+            try {\n+                value = typeConverter.convertToSelf(valueConverter, value);\n+            } catch (RuntimeException e) {\n+                throw QueryException.error(SqlErrorCode.DATA_EXCEPTION,", "originalCommit": "3d4560a657e7723584fa0dfb6e4b7d2c498b1cfc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njg0NjkzMg==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r466846932", "bodyText": "fixed in efba7d6", "author": "taburet", "createdAt": "2020-08-07T06:30:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjM2ODI2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODAwMDg1Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r468000857", "bodyText": "If I understand this comment correctly, bitWidthOf(N) = bitWidthOf(-N). But it doesn't hold here, bitWidthOf(128) = 8 and bitWidthOf(-128) = 7. Is this correct?", "author": "viliam-durina", "createdAt": "2020-08-10T15:42:26Z", "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/impl/calcite/validate/types/HazelcastIntegerTypeTest.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.validate.types;\n+\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.sql.SqlLiteral;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static com.hazelcast.test.HazelcastTestSupport.assertThrows;\n+import static org.apache.calcite.sql.parser.SqlParserPos.ZERO;\n+import static org.apache.calcite.sql.type.SqlTypeName.BIGINT;\n+import static org.apache.calcite.sql.type.SqlTypeName.INTEGER;\n+import static org.apache.calcite.sql.type.SqlTypeName.SMALLINT;\n+import static org.apache.calcite.sql.type.SqlTypeName.TINYINT;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class HazelcastIntegerTypeTest {\n+\n+    @Test\n+    public void testIntegerTypeOfTypeName() {\n+        assertType(TINYINT, Byte.SIZE - 1, false, HazelcastIntegerType.of(TINYINT));\n+        assertType(SMALLINT, Short.SIZE - 1, false, HazelcastIntegerType.of(SMALLINT));\n+        assertType(INTEGER, Integer.SIZE - 1, false, HazelcastIntegerType.of(INTEGER));\n+        assertType(BIGINT, Long.SIZE - 1, false, HazelcastIntegerType.of(BIGINT));\n+    }\n+\n+    @Test\n+    public void testNullableIntegerTypeOfTypeName() {\n+        assertType(TINYINT, Byte.SIZE - 1, false, HazelcastIntegerType.of(TINYINT, false));\n+        assertType(SMALLINT, Short.SIZE - 1, false, HazelcastIntegerType.of(SMALLINT, false));\n+        assertType(INTEGER, Integer.SIZE - 1, false, HazelcastIntegerType.of(INTEGER, false));\n+        assertType(BIGINT, Long.SIZE - 1, false, HazelcastIntegerType.of(BIGINT, false));\n+\n+        assertType(TINYINT, Byte.SIZE - 1, true, HazelcastIntegerType.of(TINYINT, true));\n+        assertType(SMALLINT, Short.SIZE - 1, true, HazelcastIntegerType.of(SMALLINT, true));\n+        assertType(INTEGER, Integer.SIZE - 1, true, HazelcastIntegerType.of(INTEGER, true));\n+        assertType(BIGINT, Long.SIZE - 1, true, HazelcastIntegerType.of(BIGINT, true));\n+    }\n+\n+    @Test\n+    public void testNullableIntegerTypeOfType() {\n+        RelDataType intType = HazelcastIntegerType.of(INTEGER);\n+        RelDataType nullableIntType = HazelcastIntegerType.of(INTEGER, true);\n+\n+        assertSame(intType, HazelcastIntegerType.of(intType, false));\n+        assertSame(nullableIntType, HazelcastIntegerType.of(intType, true));\n+\n+        assertSame(intType, HazelcastIntegerType.of(nullableIntType, false));\n+        assertSame(nullableIntType, HazelcastIntegerType.of(nullableIntType, true));\n+    }\n+\n+    @Test\n+    public void testNullableIntegerTypeOfBitWidth() {\n+        for (int i = 0; i < Long.SIZE + 10; ++i) {\n+            RelDataType type = HazelcastIntegerType.of(i, false);\n+            RelDataType nullableType = HazelcastIntegerType.of(i, true);\n+\n+            if (i < Byte.SIZE) {\n+                assertType(TINYINT, i, false, type);\n+                assertType(TINYINT, i, true, nullableType);\n+\n+                assertFalse(HazelcastIntegerType.canOverflow(type));\n+                assertFalse(HazelcastIntegerType.canOverflow(nullableType));\n+\n+                assertEquals(i, HazelcastIntegerType.noOverflowBitWidthOf(type));\n+                assertEquals(i, HazelcastIntegerType.noOverflowBitWidthOf(nullableType));\n+            } else if (i < Short.SIZE) {\n+                assertType(SMALLINT, i, false, type);\n+                assertType(SMALLINT, i, true, nullableType);\n+\n+                assertFalse(HazelcastIntegerType.canOverflow(type));\n+                assertFalse(HazelcastIntegerType.canOverflow(nullableType));\n+\n+                assertEquals(i, HazelcastIntegerType.noOverflowBitWidthOf(type));\n+                assertEquals(i, HazelcastIntegerType.noOverflowBitWidthOf(nullableType));\n+            } else if (i < Integer.SIZE) {\n+                assertType(INTEGER, i, false, type);\n+                assertType(INTEGER, i, true, nullableType);\n+\n+                assertFalse(HazelcastIntegerType.canOverflow(type));\n+                assertFalse(HazelcastIntegerType.canOverflow(nullableType));\n+\n+                assertEquals(i, HazelcastIntegerType.noOverflowBitWidthOf(type));\n+                assertEquals(i, HazelcastIntegerType.noOverflowBitWidthOf(nullableType));\n+            } else if (i < Long.SIZE) {\n+                assertType(BIGINT, i, false, type);\n+                assertType(BIGINT, i, true, nullableType);\n+\n+                assertFalse(HazelcastIntegerType.canOverflow(type));\n+                assertFalse(HazelcastIntegerType.canOverflow(nullableType));\n+\n+                assertEquals(i, HazelcastIntegerType.noOverflowBitWidthOf(type));\n+                assertEquals(i, HazelcastIntegerType.noOverflowBitWidthOf(nullableType));\n+            } else {\n+                assertType(BIGINT, Long.SIZE, false, type);\n+                assertType(BIGINT, Long.SIZE, true, nullableType);\n+\n+                assertTrue(HazelcastIntegerType.canOverflow(type));\n+                assertTrue(HazelcastIntegerType.canOverflow(nullableType));\n+\n+                assertEquals(Long.SIZE - 1, HazelcastIntegerType.noOverflowBitWidthOf(type));\n+                assertEquals(Long.SIZE - 1, HazelcastIntegerType.noOverflowBitWidthOf(nullableType));\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testSupports() {\n+        for (SqlTypeName typeName : SqlTypeName.values()) {\n+            assertEquals(typeName == TINYINT || typeName == SMALLINT || typeName == INTEGER || typeName == BIGINT,\n+                    HazelcastIntegerType.supports(typeName));\n+        }\n+    }\n+\n+    @Test\n+    public void testBitWidthOfLong() {\n+        assertEquals(0, HazelcastIntegerType.bitWidthOf(0));\n+        assertEquals(1, HazelcastIntegerType.bitWidthOf(1));\n+        assertEquals(1, HazelcastIntegerType.bitWidthOf(-1));\n+        assertEquals(2, HazelcastIntegerType.bitWidthOf(2));\n+        assertEquals(2, HazelcastIntegerType.bitWidthOf(-2));\n+        assertEquals(10, HazelcastIntegerType.bitWidthOf(555));\n+        assertEquals(10, HazelcastIntegerType.bitWidthOf(-555));\n+\n+        assertEquals(Long.SIZE - 1, HazelcastIntegerType.bitWidthOf(Long.MAX_VALUE));\n+        assertEquals(Long.SIZE - 1, HazelcastIntegerType.bitWidthOf(Long.MIN_VALUE));\n+\n+        assertEquals(Integer.SIZE - 1, HazelcastIntegerType.bitWidthOf(Integer.MAX_VALUE));\n+        assertEquals(Integer.SIZE - 1, HazelcastIntegerType.bitWidthOf(Integer.MIN_VALUE));\n+\n+        assertEquals(Short.SIZE - 1, HazelcastIntegerType.bitWidthOf(Short.MAX_VALUE));\n+        assertEquals(Short.SIZE - 1, HazelcastIntegerType.bitWidthOf(Short.MIN_VALUE));\n+\n+        assertEquals(Byte.SIZE - 1, HazelcastIntegerType.bitWidthOf(Byte.MAX_VALUE));\n+        assertEquals(Byte.SIZE - 1, HazelcastIntegerType.bitWidthOf(Byte.MIN_VALUE));", "originalCommit": "81c4f6c7c99845ed6246413cb1e14f7c51b7a9e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODAyMTcwMQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r468021701", "bodyText": "Maybe this is related", "author": "viliam-durina", "createdAt": "2020-08-10T16:15:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODAwMDg1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM1OTk3Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r468359973", "bodyText": "Yes, this is correct, documented in 1f0b562", "author": "taburet", "createdAt": "2020-08-11T06:43:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODAwMDg1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODAzNzM5Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r468037397", "bodyText": "What about adding this field to the Record in ExpressionEndToEndTestBase:\npublic Object booleanTrueObject = Boolean.TRUE;\nand then add the following line here:\nassertRow(\"cast(booleanTrueObject as boolean)\", EXPR0, BOOLEAN, true);\nAlso for other types. It will check the conversion from OBJECT type.", "author": "viliam-durina", "createdAt": "2020-08-10T16:41:45Z", "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/CastEndToEndTest.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression;\n+\n+import com.hazelcast.sql.impl.expression.math.ExpressionMath;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import java.math.BigDecimal;\n+\n+import static com.hazelcast.sql.SqlColumnType.BIGINT;\n+import static com.hazelcast.sql.SqlColumnType.BOOLEAN;\n+import static com.hazelcast.sql.SqlColumnType.DECIMAL;\n+import static com.hazelcast.sql.SqlColumnType.DOUBLE;\n+import static com.hazelcast.sql.SqlColumnType.INTEGER;\n+import static com.hazelcast.sql.SqlColumnType.OBJECT;\n+import static com.hazelcast.sql.SqlColumnType.REAL;\n+import static com.hazelcast.sql.SqlColumnType.SMALLINT;\n+import static com.hazelcast.sql.SqlColumnType.TINYINT;\n+import static com.hazelcast.sql.SqlColumnType.VARCHAR;\n+\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class CastEndToEndTest extends ExpressionEndToEndTestBase {\n+\n+    @Test\n+    public void testBoolean() {\n+        assertRow(\"cast(booleanTrue as boolean)\", EXPR0, BOOLEAN, true);\n+\n+        assertParsingError(\"cast(byte1 as boolean)\", \"Cast function cannot convert value of type TINYINT to type BOOLEAN\");\n+        assertParsingError(\"cast(short1 as boolean)\", \"Cast function cannot convert value of type SMALLINT to type BOOLEAN\");\n+        assertParsingError(\"cast(int1 as boolean)\", \"Cast function cannot convert value of type INTEGER to type BOOLEAN\");\n+        assertParsingError(\"cast(long1 as boolean)\", \"Cast function cannot convert value of type BIGINT to type BOOLEAN\");\n+\n+        assertParsingError(\"cast(float1 as boolean)\", \"Cast function cannot convert value of type REAL to type BOOLEAN\");\n+        assertParsingError(\"cast(double1 as boolean)\", \"Cast function cannot convert value of type DOUBLE to type BOOLEAN\");\n+\n+        assertParsingError(\"cast(decimal1 as boolean)\",\n+                \"Cast function cannot convert value of type DECIMAL(38, 38) to type BOOLEAN\");\n+        assertParsingError(\"cast(bigInteger1 as boolean)\",\n+                \"Cast function cannot convert value of type DECIMAL(38, 38) to type BOOLEAN\");\n+\n+        assertDataError(\"cast(string1 as boolean)\", \"VARCHAR value cannot be converted to BOOLEAN: 1\");\n+        assertRow(\"cast(stringFalse as boolean)\", EXPR0, BOOLEAN, false);\n+        assertDataError(\"cast(char1 as boolean)\", \"VARCHAR value cannot be converted to BOOLEAN: 1\");\n+\n+        assertDataError(\"cast(object as boolean)\", \"Cannot convert OBJECT to BOOLEAN\");", "originalCommit": "81c4f6c7c99845ed6246413cb1e14f7c51b7a9e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODUwMTIzOA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r468501238", "bodyText": "fixed in 9082f7d", "author": "taburet", "createdAt": "2020-08-11T11:09:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODAzNzM5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA0MDExOA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r468040118", "bodyText": "Why don't we test temporal types here?", "author": "viliam-durina", "createdAt": "2020-08-10T16:46:24Z", "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/CastEndToEndTest.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression;\n+\n+import com.hazelcast.sql.impl.expression.math.ExpressionMath;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import java.math.BigDecimal;\n+\n+import static com.hazelcast.sql.SqlColumnType.BIGINT;\n+import static com.hazelcast.sql.SqlColumnType.BOOLEAN;\n+import static com.hazelcast.sql.SqlColumnType.DECIMAL;\n+import static com.hazelcast.sql.SqlColumnType.DOUBLE;\n+import static com.hazelcast.sql.SqlColumnType.INTEGER;\n+import static com.hazelcast.sql.SqlColumnType.OBJECT;\n+import static com.hazelcast.sql.SqlColumnType.REAL;\n+import static com.hazelcast.sql.SqlColumnType.SMALLINT;\n+import static com.hazelcast.sql.SqlColumnType.TINYINT;\n+import static com.hazelcast.sql.SqlColumnType.VARCHAR;\n+\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class CastEndToEndTest extends ExpressionEndToEndTestBase {", "originalCommit": "81c4f6c7c99845ed6246413cb1e14f7c51b7a9e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM2MDc0Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r468360743", "bodyText": "This PR doesn't provide support for temporal types.", "author": "taburet", "createdAt": "2020-08-11T06:45:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA0MDExOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA0MTc2Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r468041767", "bodyText": "With every other source type we include the value that failed to convert in the error message, we should do that same with OBJECT.", "author": "viliam-durina", "createdAt": "2020-08-10T16:49:23Z", "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/CastEndToEndTest.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression;\n+\n+import com.hazelcast.sql.impl.expression.math.ExpressionMath;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import java.math.BigDecimal;\n+\n+import static com.hazelcast.sql.SqlColumnType.BIGINT;\n+import static com.hazelcast.sql.SqlColumnType.BOOLEAN;\n+import static com.hazelcast.sql.SqlColumnType.DECIMAL;\n+import static com.hazelcast.sql.SqlColumnType.DOUBLE;\n+import static com.hazelcast.sql.SqlColumnType.INTEGER;\n+import static com.hazelcast.sql.SqlColumnType.OBJECT;\n+import static com.hazelcast.sql.SqlColumnType.REAL;\n+import static com.hazelcast.sql.SqlColumnType.SMALLINT;\n+import static com.hazelcast.sql.SqlColumnType.TINYINT;\n+import static com.hazelcast.sql.SqlColumnType.VARCHAR;\n+\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class CastEndToEndTest extends ExpressionEndToEndTestBase {\n+\n+    @Test\n+    public void testBoolean() {\n+        assertRow(\"cast(booleanTrue as boolean)\", EXPR0, BOOLEAN, true);\n+\n+        assertParsingError(\"cast(byte1 as boolean)\", \"Cast function cannot convert value of type TINYINT to type BOOLEAN\");\n+        assertParsingError(\"cast(short1 as boolean)\", \"Cast function cannot convert value of type SMALLINT to type BOOLEAN\");\n+        assertParsingError(\"cast(int1 as boolean)\", \"Cast function cannot convert value of type INTEGER to type BOOLEAN\");\n+        assertParsingError(\"cast(long1 as boolean)\", \"Cast function cannot convert value of type BIGINT to type BOOLEAN\");\n+\n+        assertParsingError(\"cast(float1 as boolean)\", \"Cast function cannot convert value of type REAL to type BOOLEAN\");\n+        assertParsingError(\"cast(double1 as boolean)\", \"Cast function cannot convert value of type DOUBLE to type BOOLEAN\");\n+\n+        assertParsingError(\"cast(decimal1 as boolean)\",\n+                \"Cast function cannot convert value of type DECIMAL(38, 38) to type BOOLEAN\");\n+        assertParsingError(\"cast(bigInteger1 as boolean)\",\n+                \"Cast function cannot convert value of type DECIMAL(38, 38) to type BOOLEAN\");\n+\n+        assertDataError(\"cast(string1 as boolean)\", \"VARCHAR value cannot be converted to BOOLEAN: 1\");\n+        assertRow(\"cast(stringFalse as boolean)\", EXPR0, BOOLEAN, false);\n+        assertDataError(\"cast(char1 as boolean)\", \"VARCHAR value cannot be converted to BOOLEAN: 1\");\n+\n+        assertDataError(\"cast(object as boolean)\", \"Cannot convert OBJECT to BOOLEAN\");\n+    }\n+\n+    @Test\n+    public void testTinyint() {\n+        assertParsingError(\"cast(booleanTrue as tinyint)\", \"Cast function cannot convert value of type BOOLEAN to type TINYINT\");\n+\n+        assertRow(\"cast(byte1 as tinyint)\", EXPR0, TINYINT, (byte) 1);\n+        assertRow(\"cast(byteMax as tinyint)\", EXPR0, TINYINT, Byte.MAX_VALUE);\n+        assertRow(\"cast(short1 as tinyint)\", EXPR0, TINYINT, (byte) 1);\n+        assertDataError(\"cast(shortMax as tinyint)\", \"Numeric overflow while converting SMALLINT to TINYINT: 32767\");\n+        assertRow(\"cast(int1 as tinyint)\", EXPR0, TINYINT, (byte) 1);\n+        assertDataError(\"cast(intMax as tinyint)\", \"Numeric overflow while converting INT to TINYINT: 2147483647\");\n+        assertRow(\"cast(long1 as tinyint)\", EXPR0, TINYINT, (byte) 1);\n+        assertDataError(\"cast(longMax as tinyint)\", \"Numeric overflow while converting BIGINT to TINYINT: 9223372036854775807\");\n+\n+        assertRow(\"cast(float1 as tinyint)\", EXPR0, TINYINT, (byte) 1);\n+        assertDataError(\"cast(floatMax as tinyint)\", \"Numeric overflow while converting REAL to TINYINT: 3.4028235E38\");\n+        assertRow(\"cast(double1 as tinyint)\", EXPR0, TINYINT, (byte) 1);\n+        assertDataError(\"cast(doubleMax as tinyint)\",\n+                \"Numeric overflow while converting DOUBLE to TINYINT: 1.7976931348623157E308\");\n+\n+        assertRow(\"cast(decimal1 as tinyint)\", EXPR0, TINYINT, (byte) 1);\n+        assertDataError(\"cast(decimalBig as tinyint)\",\n+                \"Numeric overflow while converting DECIMAL to TINYINT: 92233720368547758070\");\n+        assertRow(\"cast(bigInteger1 as tinyint)\", EXPR0, TINYINT, (byte) 1);\n+        assertDataError(\"cast(bigIntegerBig as tinyint)\",\n+                \"Numeric overflow while converting DECIMAL to TINYINT: 92233720368547758070\");\n+\n+        assertRow(\"cast(string1 as tinyint)\", EXPR0, TINYINT, (byte) 1);\n+        assertDataError(\"cast(stringBig as tinyint)\", \"Cannot convert VARCHAR to TINYINT: 92233720368547758070\");\n+        assertDataError(\"cast(stringFoo as tinyint)\", \"Cannot convert VARCHAR to TINYINT: foo\");\n+        assertRow(\"cast(char1 as tinyint)\", EXPR0, TINYINT, (byte) 1);\n+        assertDataError(\"cast(charF as tinyint)\", \"Cannot convert VARCHAR to TINYINT: f\");\n+\n+        assertDataError(\"cast(object as tinyint)\", \"Cannot convert OBJECT to TINYINT\");", "originalCommit": "81c4f6c7c99845ed6246413cb1e14f7c51b7a9e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQ1MTM4MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r468451381", "bodyText": "Due to this comment, let's just include the value class in the message.", "author": "viliam-durina", "createdAt": "2020-08-11T09:33:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA0MTc2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODUwMTI3OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r468501279", "bodyText": "fixed in 9082f7d", "author": "taburet", "createdAt": "2020-08-11T11:09:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA0MTc2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQwMjM0Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r468402342", "bodyText": "We can add this test:\n    @Test\n    public void testMixedTypes() {\n        SqlService sql = createEndToEndRecords();\n        assertQueryThrows(sql, \"select __key from records where case boolean1 when true then int1 else boolean1 end\",\n                \"Illegal mixing of types in CASE or COALESCE statement\");\n    }", "author": "viliam-durina", "createdAt": "2020-08-11T08:10:19Z", "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/predicate/CaseExpressionTest.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.predicate;\n+\n+import com.hazelcast.sql.SqlService;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.ConstantExpression;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionTestBase;\n+import com.hazelcast.sql.impl.expression.SimpleExpressionEvalContext;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import static com.hazelcast.sql.impl.type.QueryDataType.BIGINT;\n+import static com.hazelcast.sql.impl.type.QueryDataType.BOOLEAN;\n+import static com.hazelcast.sql.impl.type.QueryDataType.INT;\n+import static org.junit.Assert.assertEquals;\n+\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class CaseExpressionTest extends ExpressionTestBase {", "originalCommit": "3c4f1a091791e4047d14c23e9372c3da25561b37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODUxMzIxMw==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r468513213", "bodyText": "case removed in c1a5855 and 7f29e69, #17329 created", "author": "taburet", "createdAt": "2020-08-11T11:34:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQwMjM0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQxMTY2Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r468411662", "bodyText": "This error message is not precise, better would be \"must be a boolean expression\". You can use a boolean literal, but is that a condition?\nHowever, it comes from calcite code, so if it's not easy to replace it, maybe it's not worth the trouble:\n\tat org.apache.calcite.sql.validate.SqlValidatorImpl.validateWhereOrOn(SqlValidatorImpl.java:4200)\n\tat org.apache.calcite.sql.validate.SqlValidatorImpl.validateWhereClause(SqlValidatorImpl.java:4184)\n\tat org.apache.calcite.sql.validate.SqlValidatorImpl.validateSelect(SqlValidatorImpl.java:3513)\n\tat org.apache.calcite.sql.validate.SelectNamespace.validateImpl(SelectNamespace.java:60)\n\tat org.apache.calcite.sql.validate.AbstractNamespace.validate(AbstractNamespace.java:84)\n\tat org.apache.calcite.sql.validate.SqlValidatorImpl.validateNamespace(SqlValidatorImpl.java:1110)\n\tat org.apache.calcite.sql.validate.SqlValidatorImpl.validateQuery(SqlValidatorImpl.java:1084)\n\tat org.apache.calcite.sql.SqlSelect.validate(SqlSelect.java:232)\n\tat org.apache.calcite.sql.validate.SqlValidatorImpl.validateScopedExpression(SqlValidatorImpl.java:1059)\n\tat org.apache.calcite.sql.validate.SqlValidatorImpl.validate(SqlValidatorImpl.java:766)\n\tat com.hazelcast.sql.impl.calcite.parse.QueryParser.parse(QueryParser.java:55)", "author": "viliam-durina", "createdAt": "2020-08-11T08:26:15Z", "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/predicate/CaseExpressionTest.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.predicate;\n+\n+import com.hazelcast.sql.SqlService;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.ConstantExpression;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionTestBase;\n+import com.hazelcast.sql.impl.expression.SimpleExpressionEvalContext;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import static com.hazelcast.sql.impl.type.QueryDataType.BIGINT;\n+import static com.hazelcast.sql.impl.type.QueryDataType.BOOLEAN;\n+import static com.hazelcast.sql.impl.type.QueryDataType.INT;\n+import static org.junit.Assert.assertEquals;\n+\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class CaseExpressionTest extends ExpressionTestBase {\n+\n+    @Test\n+    public void testEndToEnd() {\n+        SqlService sql = createEndToEndRecords();\n+        assertRows(query(sql, \"select __key from records where case boolean1 when true then false when false then true end\"),\n+                keyRange(0, 500));\n+        assertRows(query(sql, \"select __key from records where case not boolean1 when true then false when false then true end\"),\n+                keyRange(500, 1000));\n+        assertRows(query(sql,\n+                \"select __key, case when __key < 500 then double1 when __key < 1000 then int1 else decimal1 end from records\"),\n+                keyRange(0, 1000, 5000, 6000), k -> {\n+                    if (k < 500) {\n+                        return 2000.1 + k;\n+                    } else if (k < 1000) {\n+                        return 1000.0 + k;\n+                    } else {\n+                        return k == 5000 ? 9001.0 : null;\n+                    }\n+                });\n+        assertQueryThrows(sql, \"select * from records where case boolean1 when true then string1 end\",\n+                \"where clause must be a condition\");", "originalCommit": "1f0b562628e25e8cd2941ff956afedd5fd8c5d42", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODUxMzMyMQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r468513321", "bodyText": "case removed in c1a5855 and 7f29e69, #17329 created", "author": "taburet", "createdAt": "2020-08-11T11:34:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQxMTY2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU3NTExMw==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r468575113", "bodyText": "This is not specific to CASE expression.", "author": "viliam-durina", "createdAt": "2020-08-11T13:23:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQxMTY2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQxMzIwMA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r468413200", "bodyText": "Why do we expect here <BOOLEAN> * <BOOLEAN> instead of VARCHAR?", "author": "petrpleshachkov", "createdAt": "2020-08-11T08:28:43Z", "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/math/MultiplyEndToEndTest.java", "diffHunk": "@@ -0,0 +1,475 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.math;\n+\n+import com.hazelcast.sql.impl.expression.ExpressionEndToEndTestBase;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import java.math.BigDecimal;\n+\n+import static com.hazelcast.sql.SqlColumnType.BIGINT;\n+import static com.hazelcast.sql.SqlColumnType.DECIMAL;\n+import static com.hazelcast.sql.SqlColumnType.DOUBLE;\n+import static com.hazelcast.sql.SqlColumnType.INTEGER;\n+import static com.hazelcast.sql.SqlColumnType.REAL;\n+import static com.hazelcast.sql.SqlColumnType.SMALLINT;\n+\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class MultiplyEndToEndTest extends ExpressionEndToEndTestBase {\n+\n+    @Test\n+    public void testBoolean() {\n+        assertParsingError(\"booleanTrue * booleanTrue\", \"Cannot apply '*' to arguments of type '<BOOLEAN> * <BOOLEAN>'\");\n+\n+        assertParsingError(\"booleanTrue * byte1\", \"Cannot apply '*' to arguments of type '<BOOLEAN> * <TINYINT>'\");\n+        assertParsingError(\"booleanTrue * short1\", \"Cannot apply '*' to arguments of type '<BOOLEAN> * <SMALLINT>'\");\n+        assertParsingError(\"booleanTrue * int1\", \"Cannot apply '*' to arguments of type '<BOOLEAN> * <INTEGER>'\");\n+        assertParsingError(\"booleanTrue * long1\", \"Cannot apply '*' to arguments of type '<BOOLEAN> * <BIGINT>'\");\n+\n+        assertParsingError(\"booleanTrue * float1\", \"Cannot apply '*' to arguments of type '<BOOLEAN> * <REAL>'\");\n+        assertParsingError(\"booleanTrue * double1\", \"Cannot apply '*' to arguments of type '<BOOLEAN> * <DOUBLE>'\");\n+\n+        assertParsingError(\"booleanTrue * decimal1\", \"Cannot apply '*' to arguments of type '<BOOLEAN> * <DECIMAL(38, 38)>'\");\n+        assertParsingError(\"booleanTrue * bigInteger1\", \"Cannot apply '*' to arguments of type '<BOOLEAN> * <DECIMAL(38, 38)>'\");\n+\n+        assertParsingError(\"booleanTrue * string1\", \"Cannot apply '*' to arguments of type '<BOOLEAN> * <BOOLEAN>'\");", "originalCommit": "09c52aa98d7b273a7cdc992ea5e122e4c9041294", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQxOTA1OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r468419059", "bodyText": "That's because of implicit coercion of varchar to boolean, we have an issue to improve such messages #17301", "author": "taburet", "createdAt": "2020-08-11T08:38:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQxMzIwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQ1Mjk2OA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r468452968", "bodyText": "This is not correct, Inf / 5 results in infinite too, but it's not division by zero. The user might be looking for a zero in the data and find none. The Inf can be already present in the user data, even though we don't support such literal for now.\nSame issue is for floats below.", "author": "viliam-durina", "createdAt": "2020-08-11T09:36:26Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/math/ExpressionMath.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.math;\n+\n+import com.hazelcast.sql.SqlErrorCode;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+\n+import java.math.MathContext;\n+import java.math.RoundingMode;\n+\n+import static com.hazelcast.sql.impl.type.QueryDataType.MAX_DECIMAL_PRECISION;\n+\n+/**\n+ * Utility methods for math functions.\n+ */\n+public final class ExpressionMath {\n+\n+    /**\n+     * Math context used by expressions while doing math on BigDecimal values.\n+     * <p>\n+     * The context uses {@link RoundingMode#HALF_UP HALF_UP} rounding mode, with\n+     * which most users should be familiar from school, and limits the precision\n+     * to {@link QueryDataType#MAX_DECIMAL_PRECISION}.\n+     */\n+    public static final MathContext DECIMAL_MATH_CONTEXT = new MathContext(MAX_DECIMAL_PRECISION, RoundingMode.HALF_UP);\n+\n+    private ExpressionMath() {\n+        // No-op.\n+    }\n+\n+    /**\n+     * Divides the left-hand side operand by the right-hand side operand.\n+     * <p>\n+     * Unlike the regular Java division operator, throws an exception if division\n+     * resulted in overflow.\n+     *\n+     * @param left  the left-hand side operand.\n+     * @param right the right-hand side operand.\n+     * @return a division result.\n+     * @throws QueryException if overflow or division by zero is detected.\n+     */\n+    public static long divideExact(long left, long right) {\n+        if (left == Long.MIN_VALUE && right == -1) {\n+            throw QueryException.error(SqlErrorCode.DATA_EXCEPTION,\n+                    \"BIGINT overflow in '/' operator (consider adding explicit CAST to DECIMAL)\");\n+        }\n+        try {\n+            return left / right;\n+        } catch (ArithmeticException e) {\n+            throw QueryException.error(SqlErrorCode.DATA_EXCEPTION, \"division by zero\");\n+        }\n+    }\n+\n+    /**\n+     * Divides the left-hand side operand by the right-hand side operand.\n+     * <p>\n+     * Unlike the regular Java division operator, throws an exception if division\n+     * by zero is detected.\n+     *\n+     * @param left  the left-hand side operand.\n+     * @param right the right-hand side operand.\n+     * @return a division result.\n+     * @throws QueryException if division by zero is detected.\n+     */\n+    public static double divideExact(double left, double right) {\n+        double result = left / right;\n+        if (Double.isInfinite(result)) {\n+            throw QueryException.error(SqlErrorCode.DATA_EXCEPTION, \"division by zero\");", "originalCommit": "1f0b562628e25e8cd2941ff956afedd5fd8c5d42", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODUyMjYyMw==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r468522623", "bodyText": "fixed 084c08a", "author": "taburet", "createdAt": "2020-08-11T11:53:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQ1Mjk2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU1MTg4OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r468551889", "bodyText": "But why do we single out this case: we allow any special value on input and also any special value on output (NaN can be produced from inf/inf). Wouldn't it be better to just do the standard floating-point arithmetic?", "author": "viliam-durina", "createdAt": "2020-08-11T12:46:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQ1Mjk2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQ1MzEzNg==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r468453136", "bodyText": "We can return NaN if both operands are 0, is that ok?\nSame issue is for floats below.", "author": "viliam-durina", "createdAt": "2020-08-11T09:36:43Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/math/ExpressionMath.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.math;\n+\n+import com.hazelcast.sql.SqlErrorCode;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+\n+import java.math.MathContext;\n+import java.math.RoundingMode;\n+\n+import static com.hazelcast.sql.impl.type.QueryDataType.MAX_DECIMAL_PRECISION;\n+\n+/**\n+ * Utility methods for math functions.\n+ */\n+public final class ExpressionMath {\n+\n+    /**\n+     * Math context used by expressions while doing math on BigDecimal values.\n+     * <p>\n+     * The context uses {@link RoundingMode#HALF_UP HALF_UP} rounding mode, with\n+     * which most users should be familiar from school, and limits the precision\n+     * to {@link QueryDataType#MAX_DECIMAL_PRECISION}.\n+     */\n+    public static final MathContext DECIMAL_MATH_CONTEXT = new MathContext(MAX_DECIMAL_PRECISION, RoundingMode.HALF_UP);\n+\n+    private ExpressionMath() {\n+        // No-op.\n+    }\n+\n+    /**\n+     * Divides the left-hand side operand by the right-hand side operand.\n+     * <p>\n+     * Unlike the regular Java division operator, throws an exception if division\n+     * resulted in overflow.\n+     *\n+     * @param left  the left-hand side operand.\n+     * @param right the right-hand side operand.\n+     * @return a division result.\n+     * @throws QueryException if overflow or division by zero is detected.\n+     */\n+    public static long divideExact(long left, long right) {\n+        if (left == Long.MIN_VALUE && right == -1) {\n+            throw QueryException.error(SqlErrorCode.DATA_EXCEPTION,\n+                    \"BIGINT overflow in '/' operator (consider adding explicit CAST to DECIMAL)\");\n+        }\n+        try {\n+            return left / right;\n+        } catch (ArithmeticException e) {\n+            throw QueryException.error(SqlErrorCode.DATA_EXCEPTION, \"division by zero\");\n+        }\n+    }\n+\n+    /**\n+     * Divides the left-hand side operand by the right-hand side operand.\n+     * <p>\n+     * Unlike the regular Java division operator, throws an exception if division\n+     * by zero is detected.\n+     *\n+     * @param left  the left-hand side operand.\n+     * @param right the right-hand side operand.\n+     * @return a division result.\n+     * @throws QueryException if division by zero is detected.\n+     */\n+    public static double divideExact(double left, double right) {\n+        double result = left / right;\n+        if (Double.isInfinite(result)) {\n+            throw QueryException.error(SqlErrorCode.DATA_EXCEPTION, \"division by zero\");\n+        }\n+        return result;", "originalCommit": "1f0b562628e25e8cd2941ff956afedd5fd8c5d42", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODUyMjY1MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r468522651", "bodyText": "fixed 084c08a", "author": "taburet", "createdAt": "2020-08-11T11:53:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQ1MzEzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQ3OTk5MA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r468479990", "bodyText": "Might be useful to test a conversion with precision loss:\nassertEquals(1, converter.asTinyint(BigDecimal.valueOf(1.1)));", "author": "viliam-durina", "createdAt": "2020-08-11T10:26:30Z", "path": "hazelcast/src/test/java/com/hazelcast/sql/impl/type/converter/ConvertersTest.java", "diffHunk": "@@ -263,13 +278,18 @@ public void testBigDecimalConverter() {\n         checkConverterConversions(converter, VARCHAR, TINYINT, SMALLINT, INT, BIGINT, REAL, DOUBLE, OBJECT);\n \n         BigDecimal val = BigDecimal.valueOf(11, 1);\n+        BigDecimal bigValue = BigDecimal.valueOf(Long.MAX_VALUE).add(new BigDecimal(\"1.1\"));\n \n         assertEquals(\"1.1\", converter.asVarchar(val));\n \n         assertEquals(1, converter.asTinyint(val));\n+        checkDataException(() -> converter.asTinyint(bigValue));", "originalCommit": "1f0b562628e25e8cd2941ff956afedd5fd8c5d42", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODUyOTc5OA==", "url": "https://github.com/hazelcast/hazelcast/pull/17183#discussion_r468529798", "bodyText": "Looks like it's already tested at the line above, val = BigDecimal.valueOf(11, 1) = 1.1", "author": "taburet", "createdAt": "2020-08-11T12:06:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQ3OTk5MA=="}], "type": "inlineReview"}, {"oid": "4619167e052d3bb9e9440163f38217c4bb2491fd", "url": "https://github.com/hazelcast/hazelcast/commit/4619167e052d3bb9e9440163f38217c4bb2491fd", "message": "Add basic SQL expressions support\n\nThis commit adds support for the following SQL types:\n\n- Integer types: `TINYINT`, `SMALLINT`, `(INT)EGER` and `BIGINT`.\n  The implementation always tries to select the narrowest integer type\n  possible to represent integer literals and results of operators\n  returning integer values. At the same time, the implementation\n  performs the widening of operator result types to avoid arithmetic\n  overflows. This all achieved by providing a custom Calcite type:\n  `HazelcastIntegerType`.\n\n- Floating-point types: `REAL` (Java's `float`), `DOUBLE` and `DECIMAL`.\n  The implementation never assigns `DECIMAL` type to literals,\n  parameters and operator result types if there are no `DECIMAL` columns\n  or explicit casts to `DECIMAL` involved in the expression.\n\n- String types: `VARCHAR` and `CHAR`. Where possible, string types are\n  normalized to `VARCHAR`, but, for instance, string literals still\n  have `CHAR` type as required by Calcite. Such `CHAR` usages are purely\n  internal and not accessible by users: `CAST(foo AS CHAR)` is invalid.\n\n- `BOOLEAN` type. The usual SQL ternary boolean logic type.\n\n- `NULL` type. The implementation follows the standard Calcite approach\n  on assigning more specific types than just `NULL` to operands of\n  expressions. For instance, consider the following expression:\n  `1 + NULL`, the `NULL` literal would receive nullable `TINYINT` type.\n  But in some cases it's impossible to assign a more specific type, so\n  the raw `NULL` type may appear: `SELECT NULL FROM table`, the `NULL`\n  literal doesn't have any specific type in this example.\n\n- `OBJECT` type currently mapped to `ANY` Calcite type, that mapping\n   might change in the future. The only reason for such mapping is that\n   `ANY` type transparently passes through all validation, type inference\n   and coercion stages without producing obscure errors, so more concise\n   errors can be reported for operators that don't support `OBJECT` as\n   an input.\n\nThe following expressions are supported for the types listed above:\n\n- Arithmetics: binary and unary `+`, binary and unary `-`, `*`, `/`.\n\n- Comparison: `=`, `!=`, `<`, `>`, `<=`, `>=`.\n\n- Logic: `AND`, `OR`, `NOT`.\n\n- `IS` predicates: `IS [NOT] TRUE`, `IS [NOT] FALSE`, `IS [NOT] NULL`.\n\n- `CAST` and `CASE`.\n\nAll expressions, including columns, literals and parameters, are\nstatically typed: their types are assigned once during query plan\ncreation and never change. This allows to avoid unnecessary type\nconversion and overflow checks during query execution. Necessary\nimplicit type conversions are still performed according to the type\nconversion rules defined in the type system design document. Type\nprecedence defined in the document is also respected while selecting\nan appropriate overload provided by a certain operator.\n\nSome initial support for temporal types is added as well, but currently\nthere are no operators and functions supporting temporal operands.", "committedDate": "2020-08-11T12:43:36Z", "type": "commit"}, {"oid": "32cdd5924813aae87a5b9e3c1d45564c15bc12ee", "url": "https://github.com/hazelcast/hazelcast/commit/32cdd5924813aae87a5b9e3c1d45564c15bc12ee", "message": "remove unused methods", "committedDate": "2020-08-11T12:43:36Z", "type": "commit"}, {"oid": "bf2db28c53ffd79947625f5eef20e27b27eb199a", "url": "https://github.com/hazelcast/hazelcast/commit/bf2db28c53ffd79947625f5eef20e27b27eb199a", "message": "Grammar", "committedDate": "2020-08-11T12:43:36Z", "type": "commit"}, {"oid": "0154e73ed51124bc4bbb9dcc489fe3fa2572b640", "url": "https://github.com/hazelcast/hazelcast/commit/0154e73ed51124bc4bbb9dcc489fe3fa2572b640", "message": "add explicit case for CHAR", "committedDate": "2020-08-11T12:43:37Z", "type": "commit"}, {"oid": "0ba198ab0e0150adbca98ed24210b1ed145cc636", "url": "https://github.com/hazelcast/hazelcast/commit/0ba198ab0e0150adbca98ed24210b1ed145cc636", "message": "simplify asserts\n\nCo-authored-by: Viliam Durina <viliam-durina@users.noreply.github.com>", "committedDate": "2020-08-11T12:43:37Z", "type": "commit"}, {"oid": "826a52c3a017e21254e8a59bda5228fb5063f278", "url": "https://github.com/hazelcast/hazelcast/commit/826a52c3a017e21254e8a59bda5228fb5063f278", "message": "simplify CASE rewriting", "committedDate": "2020-08-11T12:43:37Z", "type": "commit"}, {"oid": "2cdd96adf606b599e3e19611b2ca02e81598f754", "url": "https://github.com/hazelcast/hazelcast/commit/2cdd96adf606b599e3e19611b2ca02e81598f754", "message": "use IdentityHashMap instead of HashMap for node type tracking", "committedDate": "2020-08-11T12:43:37Z", "type": "commit"}, {"oid": "ae86c3122d8e1b55b7a0055fc6aa1f2f66b3c1d5", "url": "https://github.com/hazelcast/hazelcast/commit/ae86c3122d8e1b55b7a0055fc6aa1f2f66b3c1d5", "message": "simplify javadoc wording\n\nCo-authored-by: Viliam Durina <viliam-durina@users.noreply.github.com>", "committedDate": "2020-08-11T12:43:37Z", "type": "commit"}, {"oid": "f5765c88ab53240721dbfa3cbc5d48234c1d218f", "url": "https://github.com/hazelcast/hazelcast/commit/f5765c88ab53240721dbfa3cbc5d48234c1d218f", "message": "check for edge case values in ConvertersTest for double and float", "committedDate": "2020-08-11T12:43:37Z", "type": "commit"}, {"oid": "0a05587b170f16b1ae09d654027efab551bf35d3", "url": "https://github.com/hazelcast/hazelcast/commit/0a05587b170f16b1ae09d654027efab551bf35d3", "message": "make overflow error messages more concise in converters", "committedDate": "2020-08-11T12:43:37Z", "type": "commit"}]}