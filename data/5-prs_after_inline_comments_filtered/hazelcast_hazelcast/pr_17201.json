{"pr_number": 17201, "pr_title": "Feature/priority queue support", "pr_createdAt": "2020-07-10T06:48:50Z", "pr_url": "https://github.com/hazelcast/hazelcast/pull/17201", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc4MzQ5NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17201#discussion_r452783494", "bodyText": "This doesn't seem very intuitive. Because a comparator is set, it becomes a priority queue.", "author": "pveentjer", "createdAt": "2020-07-10T11:20:55Z", "path": "hazelcast/src/main/java/com/hazelcast/config/QueueConfig.java", "diffHunk": "@@ -323,6 +327,57 @@ public QueueConfig setMergePolicyConfig(MergePolicyConfig mergePolicyConfig) {\n         return this;\n     }\n \n+    /**", "originalCommit": "58af35720bb7aa554539c48c8fad696bf74f6619", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzE3MjIwMA==", "url": "https://github.com/hazelcast/hazelcast/pull/17201#discussion_r453172200", "bodyText": "It's how we avoid yet another config class and another interface and another method on HazelcastInstance. I don't mind, as long as the documentation is clear. Any other suggestions for exposing a priority queue?", "author": "mmedenjak", "createdAt": "2020-07-11T08:31:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc4MzQ5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQ1NDIzMw==", "url": "https://github.com/hazelcast/hazelcast/pull/17201#discussion_r453454233", "bodyText": "I do mind because it isn't intuitive. I think having an explicit property on it like 'boolean priorityQueue' makes more sense en have a default comparator implementation be in place that makes use of the Comparable interface. So the only thin someone should need to do is 'queueConfig.setPriorityQueue(true)....' This way it is explicit.", "author": "pveentjer", "createdAt": "2020-07-13T06:12:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc4MzQ5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzUxODU4MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17201#discussion_r453518581", "bodyText": "@pveentjer\nI agree that API should be intuitive for usage. What's your take on below suggestions?\n<!-- Current implementation -->\n<queue name=\"myQueue\">\n        <comparator-class-name>com.mycompany.MyQueueItemSpecificComparator</comparator-class-name>\n        <duplicate-allowed>false</duplicate-allowed>\n</queue>\n\n<!-- Alternative 1  priority-queue element with a cardinality min = 0 and max = 1 -->\n<queue name=\"myQueue\">\n\t\t<priority-queue>\n\t\t\t<comparator-class-name>com.mycompany.MyQueueItemSpecificComparator</comparator-class-name>\n\t\t\t<duplicate-allowed>false</duplicate-allowed>\n\t\t</priority-queue>\n</queue>\n\n<!-- Alternative 2: This is my favorite: when one of comparator-class-name or duplicate-allowed is not null, then kind is always a priority-queue -->\n<queue name=\"myQueue\" kind=\"priority-queue\" comparator-class-name=\"com.mycompany.MyQueueItemSpecificComparator\" duplicate-allowed=false>\n</queue>", "author": "wangumer", "createdAt": "2020-07-13T09:30:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc4MzQ5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDE3MjIwOA==", "url": "https://github.com/hazelcast/hazelcast/pull/17201#discussion_r454172208", "bodyText": "Following suggestions done above, I finally went for this to configure a priority based queue\n<queue name=\"myQueue\" queue-type=\"PRIORITY_QUEUE\" comparator-class-name=\"com.mycompany.MyQueueItemSpecificComparator\" duplicate-allowed=false></queue>", "author": "wangumer", "createdAt": "2020-07-14T07:54:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc4MzQ5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc4Mzg2NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17201#discussion_r452783865", "bodyText": "This seems to be very use case specific. I'm not sure we want to have this in the codebase.", "author": "pveentjer", "createdAt": "2020-07-10T11:21:53Z", "path": "hazelcast/src/main/java/com/hazelcast/config/QueueConfig.java", "diffHunk": "@@ -323,6 +327,57 @@ public QueueConfig setMergePolicyConfig(MergePolicyConfig mergePolicyConfig) {\n         return this;\n     }\n \n+    /**\n+     * Check if underlying implementation is a {@code PriorityQueue}. Otherwise it is a FIFO queue\n+     *\n+     * @return {@code true} if priority queue has been configured, {@code false} otherwise\n+     */\n+    public boolean isPriorityQueue() {\n+        return comparatorClassName != null;\n+    }\n+\n+    /**\n+     * Returns the class name of the configured {@link Comparator} implementation.\n+     *\n+     * @return the class name of the configured {@link Comparator} implementation\n+     */\n+    public String getComparatorClassName() {\n+        return comparatorClassName;\n+    }\n+\n+    /**\n+     * Sets the class name of the configured {@link Comparator} implementation.\n+     *\n+     * @param comparatorClassName the class name of the\n+     *                            configured {@link Comparator} implementation\n+     * @return this QueueConfig instance\n+     */\n+    public QueueConfig setComparatorClassName(String comparatorClassName) {\n+        this.comparatorClassName = comparatorClassName;\n+        return this;\n+    }\n+\n+    /**\n+     * Check if duplicates are allowed for this queue.\n+     *\n+     * @return {@code true} if duplicates are allowed, {@code false} otherwise\n+     */\n+    public boolean isDuplicateAllowed() {", "originalCommit": "58af35720bb7aa554539c48c8fad696bf74f6619", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQ2MzA5Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17201#discussion_r453463096", "bodyText": "Hi Peter,\nThanks for your kind feedback so far.\nYou are right. This is really use case specific. I would have like to provide a solution without altering internal of Queue implementation.\nI am open for alternative solution.", "author": "wangumer", "createdAt": "2020-07-13T06:40:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc4Mzg2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM3MDk4MA==", "url": "https://github.com/hazelcast/hazelcast/pull/17201#discussion_r459370980", "bodyText": "I don't think there is an alternative solution. But there is no queue implementation that has duplicate detection and I have never had the need for it. So I don't see a good reason why it should be in here; this is a general-purpose data-structure and we should prevent add use case-specific additions. It makes the code complex to maintain and use.", "author": "pveentjer", "createdAt": "2020-07-23T11:03:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc4Mzg2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQ5ODY0MA==", "url": "https://github.com/hazelcast/hazelcast/pull/17201#discussion_r459498640", "bodyText": "What happens when a regular queue is created and duplicate allowed is set to false? Afaik there is no duplicate checking in the regular queue (would be undesirable due to complexity). So is there an exception if you set the duplicates allowed to false, but don't create a priority queue? Or is the setting ignored?", "author": "pveentjer", "createdAt": "2020-07-23T14:37:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc4Mzg2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTkzNTMzMQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17201#discussion_r459935331", "bodyText": "Attribute duplicate-allowed in the config holds only for priority queue. This setting is completely ignored for regular queue.", "author": "wangumer", "createdAt": "2020-07-24T09:03:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc4Mzg2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDAyMjQ1MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17201#discussion_r460022451", "bodyText": "I don't think there is an alternative solution. But there is no queue implementation that has duplicate detection and I have never had the need for it. So I don't see a good reason why it should be in here; this is a general-purpose data-structure and we should prevent add use case-specific additions. It makes the code complex to maintain and use.\n\nI can understand your concerns about providing use case specific additions on general data structure. In the current case the addition is transparent for API user and the default works for standard data structure as in previous release.\nYes, real usecase can be rare to find. In our case we are currently using this in production with HC V.3.12 (we have our own queue implementation) and we would want to keep the functionality. I am not sure it is something we would want to handle at the application level without trying to build the same distribution already supported in HC.\nYou are right about the complexity that this could add to the codebase. For this enhancement, it just turns out that it was rather limited in my opinion.", "author": "wangumer", "createdAt": "2020-07-24T12:30:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc4Mzg2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc4NDY1Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17201#discussion_r452784653", "bodyText": "What is the advantage of using a getter here?", "author": "pveentjer", "createdAt": "2020-07-10T11:24:02Z", "path": "hazelcast/src/main/java/com/hazelcast/collection/impl/queue/QueueItem.java", "diffHunk": "@@ -96,10 +96,10 @@ public void readData(ObjectDataInput in) throws IOException {\n     }\n \n     @Override\n-    public int compareTo(QueueItem o) {\n-        if (itemId < o.getItemId()) {\n+    public int compareTo(QueueItem other) {\n+        if (getItemId() < other.getItemId()) {", "originalCommit": "58af35720bb7aa554539c48c8fad696bf74f6619", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQ2MzUyMA==", "url": "https://github.com/hazelcast/hazelcast/pull/17201#discussion_r453463520", "bodyText": "Nope. Will revert back.", "author": "wangumer", "createdAt": "2020-07-13T06:41:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc4NDY1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc4NTk3MA==", "url": "https://github.com/hazelcast/hazelcast/pull/17201#discussion_r452785970", "bodyText": "The NoDuplicatePriorityQueue is stored in a single partition and as a consequence will not be accessed concurrently. There should not be any need to synchronize.", "author": "pveentjer", "createdAt": "2020-07-10T11:27:08Z", "path": "hazelcast/src/main/java/com/hazelcast/collection/impl/queue/NoDuplicatePriorityQueue.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\r\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\r\n+ *\r\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+\r\n+package com.hazelcast.collection.impl.queue;\r\n+\r\n+import com.hazelcast.internal.serialization.Data;\r\n+\r\n+import java.util.Comparator;\r\n+import java.util.HashSet;\r\n+import java.util.PriorityQueue;\r\n+import java.util.Set;\r\n+import java.util.concurrent.locks.Lock;\r\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\r\n+\r\n+/**\r\n+ * A {@link PriorityQueue} which did not allowed duplicate values.\r\n+ * Duplicate check is not done on QueueItem but on {@link QueueItem#getData()}\r\n+ */\r\n+public final class NoDuplicatePriorityQueue extends PriorityQueue<QueueItem> {\r\n+    private Set<Data> dataSet = new HashSet();\r\n+    private final ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();\r\n+\r\n+    /**\r\n+     * Constructs an instance of {@code NoDuplicatePriorityQueue}\r\n+     *\r\n+     * @param comparator supplied comparator to be used by this priority queue\r\n+     */\r\n+    public NoDuplicatePriorityQueue(Comparator<QueueItem> comparator) {\r\n+        super(comparator);\r\n+    }\r\n+\r\n+    @Override\r\n+    public boolean offer(QueueItem e) {\r\n+        Lock lock = this.readWriteLock.writeLock();\r\n+        Data otherData = e.getData();\r\n+        if (dataSet.contains(otherData)) {\r\n+            return false;\r\n+        }\r\n+        lock.lock();\r", "originalCommit": "58af35720bb7aa554539c48c8fad696bf74f6619", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQ2OTQyMA==", "url": "https://github.com/hazelcast/hazelcast/pull/17201#discussion_r453469420", "bodyText": "Ok", "author": "wangumer", "createdAt": "2020-07-13T07:10:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc4NTk3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc4NjY1MA==", "url": "https://github.com/hazelcast/hazelcast/pull/17201#discussion_r452786650", "bodyText": "This add a constant memory overhead per item stored. I can't say I'm too excited about that.", "author": "pveentjer", "createdAt": "2020-07-10T11:28:46Z", "path": "hazelcast/src/main/java/com/hazelcast/collection/impl/queue/NoDuplicatePriorityQueue.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\r\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\r\n+ *\r\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+\r\n+package com.hazelcast.collection.impl.queue;\r\n+\r\n+import com.hazelcast.internal.serialization.Data;\r\n+\r\n+import java.util.Comparator;\r\n+import java.util.HashSet;\r\n+import java.util.PriorityQueue;\r\n+import java.util.Set;\r\n+import java.util.concurrent.locks.Lock;\r\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\r\n+\r\n+/**\r\n+ * A {@link PriorityQueue} which did not allowed duplicate values.\r\n+ * Duplicate check is not done on QueueItem but on {@link QueueItem#getData()}\r\n+ */\r\n+public final class NoDuplicatePriorityQueue extends PriorityQueue<QueueItem> {\r\n+    private Set<Data> dataSet = new HashSet();\r", "originalCommit": "58af35720bb7aa554539c48c8fad696bf74f6619", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTkzOTI4Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17201#discussion_r459939283", "bodyText": "Right. This is a comparable implementation of something we are using in production with HC 3.12 where IQueue SPI allowed creation of specialized queue.\nAny suggestion on how to improve this?", "author": "wangumer", "createdAt": "2020-07-24T09:10:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc4NjY1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc5MDM1Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17201#discussion_r452790352", "bodyText": "The complexity to add an item to the priority is O(Log(N)) because the priority queue is based on a binary heap.\nBut now the value that is added, is deserialized very every value it needs to be compared with.\nSo with N items, the total number of deserializations is 2Log(N)). If there are many items in the priority queue or when the items take a long time to deserialize, this can be a serious performance problem. So I would at least optimize is so that Log(N)+1 deserialization are needed instead of 2Log(N))", "author": "pveentjer", "createdAt": "2020-07-10T11:38:00Z", "path": "hazelcast/src/main/java/com/hazelcast/collection/impl/queue/ForwardingQueueItemComparator.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\r\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\r\n+ *\r\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+\r\n+package com.hazelcast.collection.impl.queue;\r\n+\r\n+import com.hazelcast.internal.serialization.SerializationService;\r\n+\r\n+import java.util.Comparator;\r\n+import java.util.Objects;\r\n+\r\n+/**\r\n+ * A comparator which forwards its {@link Comparator#compare(Object, Object)} to another supplied comparator.\r\n+ * If {@code comparator} is {@code null}, then {@link Comparator#compare(Object, Object)}\r\n+ * uses {@link QueueItem#compareTo(QueueItem)}\r\n+ *\r\n+ * @param <T> the type of objects that may be compared by the delegated comparator\r\n+ *           as defined by the supplied comparator instance in {QueueConfig}\r\n+ */\r\n+public final class ForwardingQueueItemComparator<T> implements Comparator<QueueItem> {\r\n+\r\n+    private final Comparator<T> customComparator;\r\n+    private final SerializationService serializationService;\r\n+\r\n+    public ForwardingQueueItemComparator(final Comparator<T> customComparator,\r\n+                                         final SerializationService serializationService) {\r\n+        Objects.requireNonNull(customComparator, \"Custom comparator cannot be null.\");\r\n+        this.customComparator = customComparator;\r\n+        this.serializationService = serializationService;\r\n+    }\r\n+\r\n+    @Override\r\n+    public int compare(QueueItem o1, QueueItem o2) {\r\n+        T object1 = (T) serializationService.toObject(o1.getData());\r", "originalCommit": "58af35720bb7aa554539c48c8fad696bf74f6619", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQ1NTE0MA==", "url": "https://github.com/hazelcast/hazelcast/pull/17201#discussion_r453455140", "bodyText": "You could cache the value in the comparator but be very careful with caching a value indefinably. I'm not sure if a new comparator is created or an existing one is recycled.", "author": "pveentjer", "createdAt": "2020-07-13T06:15:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc5MDM1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjc4MDk3NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17201#discussion_r472780975", "bodyText": "Added deserialized value caching in QueueItem, it will only be used in case of priority queue.", "author": "mmedenjak", "createdAt": "2020-08-19T07:00:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc5MDM1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc5NjY1Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17201#discussion_r452796656", "bodyText": "I don't see any change in the 'constructors' array", "author": "pveentjer", "createdAt": "2020-07-10T11:54:04Z", "path": "hazelcast/src/main/java/com/hazelcast/collection/impl/queue/QueueDataSerializerHook.java", "diffHunk": "@@ -127,6 +127,8 @@\n     public static final int MERGE = 44;\n     public static final int MERGE_BACKUP = 45;\n \n+    public static final int PRIORITY_QUEUE_COMPARATOR = 46;", "originalCommit": "58af35720bb7aa554539c48c8fad696bf74f6619", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc5NzE0Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/17201#discussion_r452797147", "bodyText": "I don't believe we need an explicit serializer for this logic. It can just piggyback on whatever kind of serialization is in place. So let it implement the appropriate serialization interface.", "author": "pveentjer", "createdAt": "2020-07-10T11:55:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc5NjY1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQ2NDMxNA==", "url": "https://github.com/hazelcast/hazelcast/pull/17201#discussion_r453464314", "bodyText": "Ups! This just a tryout which slips into commit. Will revert it.", "author": "wangumer", "createdAt": "2020-07-13T06:44:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc5NjY1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQ5MzQyNQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17201#discussion_r459493425", "bodyText": "This is not going to work. The issue is that the same data might be serialized differently from time to time; so the same instance is not guaranteed to give the same Data.", "author": "pveentjer", "createdAt": "2020-07-23T14:30:08Z", "path": "hazelcast/src/main/java/com/hazelcast/collection/impl/queue/NoDuplicatePriorityQueue.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/*\r\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\r\n+ *\r\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+\r\n+package com.hazelcast.collection.impl.queue;\r\n+\r\n+import com.hazelcast.internal.serialization.BinaryInterface;\r\n+import com.hazelcast.internal.serialization.Data;\r\n+import java.util.Comparator;\r\n+import java.util.HashSet;\r\n+import java.util.PriorityQueue;\r\n+import java.util.Set;\r\n+\r\n+/**\r\n+ * A {@link PriorityQueue} which did not allowed duplicate values.\r\n+ * Duplicate check is not done on QueueItem but on {@link QueueItem#getData()}\r\n+ */\r\n+@BinaryInterface\r\n+public final class NoDuplicatePriorityQueue extends PriorityQueue<QueueItem> {\r\n+\r\n+    private Set<Data> dataSet = new HashSet();\r\n+\r\n+    /**\r\n+     * Constructs an instance of {@code NoDuplicatePriorityQueue}\r\n+     *\r\n+     * @param comparator supplied comparator to be used by this priority queue\r\n+     */\r\n+    public NoDuplicatePriorityQueue(Comparator<QueueItem> comparator) {\r\n+        super(comparator);\r\n+    }\r\n+\r\n+    @Override\r\n+    public boolean offer(QueueItem e) {\r\n+        Data otherData = e.getData();\r", "originalCommit": "bb78280dd0b5f3224a038329ce47809dde1e5ddc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjc4MTQ1Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17201#discussion_r472781456", "bodyText": "Can you elaborate how the same instance serializes as different Data instances?", "author": "mmedenjak", "createdAt": "2020-08-19T07:01:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQ5MzQyNQ=="}], "type": "inlineReview"}, {"oid": "2cf6f41f2e86d502ebfdc1ea43df85c83e7527a3", "url": "https://github.com/hazelcast/hazelcast/commit/2cf6f41f2e86d502ebfdc1ea43df85c83e7527a3", "message": "Cleanup\n\n- fix imports\n- reformat config class and add nullability annotations\n- remove unused class\n- add rolling upgrade checks\n- add missing config infrastructure and test code\n- minor typos\n- regenerate client codecs", "committedDate": "2020-08-14T10:06:40Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI2MTU4Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/17201#discussion_r477261587", "bodyText": "I would consider caching config.isPriorityQueue() in a final field. If the config changes - that is shouldn't, but still - for any reason, we get a funky behavior.", "author": "blazember", "createdAt": "2020-08-26T12:29:24Z", "path": "hazelcast/src/main/java/com/hazelcast/collection/impl/queue/QueueContainer.java", "diffHunk": "@@ -430,22 +446,32 @@ public QueueItem txnPeek(long offerId, UUID transactionId) {\n     // TX Methods Ends\n \n     public long offer(Data data) {\n-        QueueItem item = new QueueItem(this, nextId(), null);\n+        Data itemData = shouldKeepItemData() ? data : null;\n+        QueueItem item = new QueueItem(this, nextId(), itemData);\n         if (store.isEnabled()) {\n             try {\n                 store.store(item.getItemId(), data);\n             } catch (Exception e) {\n                 throw new HazelcastException(e);\n             }\n         }\n-        if (!store.isEnabled() || store.getMemoryLimit() > getItemQueue().size()) {\n-            item.setData(data);\n-        }\n         getItemQueue().offer(item);\n         cancelEvictionIfExists();\n         return item.getItemId();\n     }\n \n+    /**\n+     * Returns {@code true} if we should keep queue item data in-memory. This is\n+     * the case if the queue store is disabled, we have not yet hit the in-memory\n+     * limit or we are using a priority queue which needs item values to sort the\n+     * queue items.\n+     */\n+    private boolean shouldKeepItemData() {\n+        return !store.isEnabled() || store.getMemoryLimit() > getItemQueue().size()\n+                || config.isPriorityQueue();", "originalCommit": "edbdf8c06041a210c4b9636f6b740ba8167683ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM0NzQ0OA==", "url": "https://github.com/hazelcast/hazelcast/pull/17201#discussion_r478347448", "bodyText": "Cached. I see we have other calls to config in various methods but I'll keep that for another PR.", "author": "mmedenjak", "createdAt": "2020-08-27T11:30:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI2MTU4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI3MTc2Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17201#discussion_r477271762", "bodyText": "\ud83d\udc4d", "author": "blazember", "createdAt": "2020-08-26T12:45:52Z", "path": "hazelcast/src/main/java/com/hazelcast/collection/impl/queue/QueueStoreWrapper.java", "diffHunk": "@@ -78,24 +66,29 @@ private QueueStoreWrapper(String name) {\n      * @param serializationService serialization service.\n      * @return returns a new instance of {@link QueueStoreWrapper}\n      */\n-    public static QueueStoreWrapper create(String name, QueueStoreConfig storeConfig\n-            , SerializationService serializationService, ClassLoader classLoader) {\n+    public static QueueStoreWrapper create(@Nonnull String name,\n+                                           @Nullable QueueStoreConfig storeConfig,\n+                                           @Nonnull SerializationService serializationService,\n+                                           @Nullable ClassLoader classLoader) {\n         checkNotNull(name, \"name should not be null\");\n         checkNotNull(serializationService, \"serializationService should not be null\");\n \n-        final QueueStoreWrapper storeWrapper = new QueueStoreWrapper(name);\n+        QueueStoreWrapper storeWrapper = new QueueStoreWrapper(name);\n         storeWrapper.setSerializationService(serializationService);\n         if (storeConfig == null || !storeConfig.isEnabled()) {\n             return storeWrapper;\n         }\n         // create queue store.\n-        final QueueStore queueStore = createQueueStore(name, storeConfig, classLoader);\n+        QueueStore queueStore = createQueueStore(name, storeConfig, classLoader);\n         if (queueStore != null) {\n-            storeWrapper.setEnabled(storeConfig.isEnabled());\n-            storeWrapper.setBinary(Boolean.parseBoolean(storeConfig.getProperty(STORE_BINARY)));\n-            storeWrapper.setMemoryLimit(parseInt(STORE_MEMORY_LIMIT, DEFAULT_MEMORY_LIMIT, storeConfig));\n-            storeWrapper.setBulkLoad(parseInt(STORE_BULK_LOAD, DEFAULT_BULK_LOAD, storeConfig));\n-            storeWrapper.setStore(queueStore);\n+            boolean isBinary = Boolean.parseBoolean(storeConfig.getProperty(QueueStoreConfig.STORE_BINARY));\n+            int memoryLimit = parseInt(QueueStoreConfig.STORE_MEMORY_LIMIT, DEFAULT_MEMORY_LIMIT, storeConfig);\n+            int bulkLoad = parseInt(QueueStoreConfig.STORE_BULK_LOAD, DEFAULT_BULK_LOAD, storeConfig);\n+            storeWrapper.setEnabled(storeConfig.isEnabled())\n+                        .setBinary(isBinary)\n+                        .setMemoryLimit(memoryLimit)\n+                        .setBulkLoad(bulkLoad)\n+                        .setStore(queueStore);", "originalCommit": "edbdf8c06041a210c4b9636f6b740ba8167683ed", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI3NTkzNg==", "url": "https://github.com/hazelcast/hazelcast/pull/17201#discussion_r477275936", "bodyText": "I'd consider adding a check here that warns if queueStoreConfig#memoryLimit is set together with comparatorClassName. I'd even consider treating this situation an invalid configuration since we ignore memoryLimit in the implementation, which is against the user's intention.", "author": "blazember", "createdAt": "2020-08-26T12:52:36Z", "path": "hazelcast/src/main/java/com/hazelcast/config/QueueConfig.java", "diffHunk": "@@ -207,7 +217,7 @@ public QueueStoreConfig getQueueStoreConfig() {\n      * @param queueStoreConfig set the QueueStore configuration to this configuration\n      * @return the QueueStore configuration\n      */\n-    public QueueConfig setQueueStoreConfig(QueueStoreConfig queueStoreConfig) {\n+    public QueueConfig setQueueStoreConfig(@Nullable QueueStoreConfig queueStoreConfig) {", "originalCommit": "edbdf8c06041a210c4b9636f6b740ba8167683ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM0NzIxOQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17201#discussion_r478347219", "bodyText": "As agreed, added warning on queue container startup because of two reasons:\n\nthere is a limit set by default and the only way to disable it is to set it to Integer.MAX_VALUE\nI prefer not to do validation while the config is still being created, maybe the user is in the process of making it valid.", "author": "mmedenjak", "createdAt": "2020-08-27T11:30:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI3NTkzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI3NjcxMQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17201#discussion_r477276711", "bodyText": "I would add that setting this to non-null also makes the store's memory limit setting ignored.", "author": "blazember", "createdAt": "2020-08-26T12:53:56Z", "path": "hazelcast/src/main/java/com/hazelcast/config/QueueConfig.java", "diffHunk": "@@ -318,11 +328,44 @@ public MergePolicyConfig getMergePolicyConfig() {\n      *\n      * @return the updated queue configuration\n      */\n-    public QueueConfig setMergePolicyConfig(MergePolicyConfig mergePolicyConfig) {\n+    public QueueConfig setMergePolicyConfig(@Nonnull MergePolicyConfig mergePolicyConfig) {\n         this.mergePolicyConfig = checkNotNull(mergePolicyConfig, \"mergePolicyConfig cannot be null\");\n         return this;\n     }\n \n+    /**\n+     * Check if underlying implementation is a {@code PriorityQueue}. Otherwise\n+     * it is a FIFO queue.\n+     *\n+     * @return {@code true} if priority queue has been configured, {@code false}\n+     * otherwise\n+     */\n+    public boolean isPriorityQueue() {\n+        return !StringUtil.isNullOrEmptyAfterTrim(priorityComparatorClassName);\n+    }\n+\n+    /**\n+     * Returns the class name that will be used to compare queue items.\n+     * If the returned class name is non-empty, the queue will behave as a priority\n+     * queue, otherwise it behaves as a FIFO queue.\n+     */\n+    public @Nullable String getPriorityComparatorClassName() {\n+        return priorityComparatorClassName;\n+    }\n+\n+    /**\n+     * Sets the class name that will be used to compare queue items.\n+     * If the provided class name is non-empty, the queue will behave as a priority\n+     * queue, otherwise it behaves as a FIFO queue.", "originalCommit": "edbdf8c06041a210c4b9636f6b740ba8167683ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM0NjYzMQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17201#discussion_r478346631", "bodyText": "Fixed.", "author": "mmedenjak", "createdAt": "2020-08-27T11:29:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI3NjcxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI4NTcyNw==", "url": "https://github.com/hazelcast/hazelcast/pull/17201#discussion_r477285727", "bodyText": "Already queueTriple \ud83d\ude04", "author": "blazember", "createdAt": "2020-08-26T13:08:03Z", "path": "hazelcast/src/test/java/com/hazelcast/collection/impl/queue/QueuePriorityWithDuplicateCheckTest.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\r\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\r\n+ *\r\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+\r\n+package com.hazelcast.collection.impl.queue;\r\n+\r\n+import com.hazelcast.collection.IQueue;\r\n+import com.hazelcast.collection.impl.queue.model.PriorityElement;\r\n+import com.hazelcast.collection.impl.queue.model.PriorityElementComparator;\r\n+import com.hazelcast.config.Config;\r\n+import com.hazelcast.core.HazelcastInstance;\r\n+import com.hazelcast.logging.ILogger;\r\n+import com.hazelcast.logging.Logger;\r\n+import com.hazelcast.map.IMap;\r\n+import com.hazelcast.test.HazelcastParallelClassRunner;\r\n+import com.hazelcast.test.HazelcastTestSupport;\r\n+import com.hazelcast.test.annotation.ParallelJVMTest;\r\n+import com.hazelcast.test.annotation.QuickTest;\r\n+import org.junit.Before;\r\n+import org.junit.Test;\r\n+import org.junit.experimental.categories.Category;\r\n+import org.junit.runner.RunWith;\r\n+\r\n+import java.util.concurrent.ConcurrentSkipListSet;\r\n+import java.util.concurrent.ExecutorService;\r\n+import java.util.concurrent.Executors;\r\n+import java.util.concurrent.Semaphore;\r\n+import java.util.concurrent.atomic.AtomicInteger;\r\n+\r\n+import static org.junit.Assert.assertEquals;\r\n+import static org.junit.Assert.assertFalse;\r\n+import static org.junit.Assert.assertNull;\r\n+import static org.junit.Assert.assertTrue;\r\n+\r\n+@RunWith(HazelcastParallelClassRunner.class)\r\n+@Category({QuickTest.class, ParallelJVMTest.class})\r\n+public class QueuePriorityWithDuplicateCheckTest extends HazelcastTestSupport {\r\n+\r\n+    private static final ILogger LOG = Logger.getLogger(QueuePriorityWithDuplicateCheckTest.class);\r\n+    private PriorityElementTaskQueueImpl queue;\r\n+\r\n+    @Before\r\n+    public void before() {\r\n+        Config config = smallInstanceConfig();\r\n+        String queueName = randomName();\r\n+        String mapName = randomName();\r\n+\r\n+        config.getQueueConfig(queueName)\r\n+              .setPriorityComparatorClassName(\"com.hazelcast.collection.impl.queue.model.PriorityElementComparator\");\r\n+        HazelcastInstance hz = createHazelcastInstance(config);\r\n+        queue = new PriorityElementTaskQueueImpl(hz.getQueue(queueName), hz.getMap(mapName));\r\n+    }\r\n+\r\n+    @Test\r\n+    public void queue() {\r\n+        PriorityElement element = new PriorityElement(false, 1);\r\n+        queue.enqueue(element);\r\n+        assertEquals(element, queue.dequeue());\r\n+        assertNull(queue.dequeue());\r\n+    }\r\n+\r\n+    @Test\r\n+    public void queueDouble() {\r\n+        PriorityElement element = new PriorityElement(false, 1);\r\n+        queue.enqueue(element);\r\n+        queue.enqueue(element);\r\n+        queue.enqueue(element);\r", "originalCommit": "edbdf8c06041a210c4b9636f6b740ba8167683ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM0NjIyMg==", "url": "https://github.com/hazelcast/hazelcast/pull/17201#discussion_r478346222", "bodyText": "Fixed.", "author": "mmedenjak", "createdAt": "2020-08-27T11:28:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI4NTcyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM0NjUwMg==", "url": "https://github.com/hazelcast/hazelcast/pull/17201#discussion_r478346502", "bodyText": "Also changed the Semaphores with negative initial values to CountDownLatch.", "author": "mmedenjak", "createdAt": "2020-08-27T11:29:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI4NTcyNw=="}], "type": "inlineReview"}, {"oid": "0d90fb075a7d66efb647c05f7b754176a74fd81e", "url": "https://github.com/hazelcast/hazelcast/commit/0d90fb075a7d66efb647c05f7b754176a74fd81e", "message": "Fix compilation issue after rebase and regenerate protocol", "committedDate": "2020-08-27T10:13:30Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM0Mzc1Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17201#discussion_r478343752", "bodyText": "Shall we shutdown the executor in the end of the test to avoid leak?", "author": "petrpleshachkov", "createdAt": "2020-08-27T11:23:39Z", "path": "hazelcast/src/test/java/com/hazelcast/collection/impl/queue/QueuePriorityTest.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.collection.impl.queue;\n+\n+import com.hazelcast.collection.IQueue;\n+import com.hazelcast.collection.impl.queue.model.PriorityElement;\n+import com.hazelcast.collection.impl.queue.model.PriorityElementComparator;\n+import com.hazelcast.config.Config;\n+import com.hazelcast.core.HazelcastInstance;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.HazelcastTestSupport;\n+import com.hazelcast.test.TestHazelcastInstanceFactory;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import java.util.concurrent.ConcurrentSkipListSet;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class QueuePriorityTest extends HazelcastTestSupport {\n+    private IQueue<PriorityElement> queue;\n+\n+    @Before\n+    public void before() {\n+        Config config = smallInstanceConfig();\n+        config.getQueueConfig(\"default\")\n+              .setPriorityComparatorClassName(\"com.hazelcast.collection.impl.queue.model.PriorityElementComparator\");\n+        TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(3);\n+        HazelcastInstance[] instances = factory.newInstances(config);\n+        queue = instances[0].getQueue(generateKeyOwnedBy(instances[1]));\n+    }\n+\n+    @Test\n+    public void testPriorityQueue_whenHighestOfferedSecond_thenTakeHighest() {\n+\n+        PriorityElement elementLow = new PriorityElement(false, 1);\n+        PriorityElement elementHigh = new PriorityElement(true, 1);\n+\n+        assertTrue(queue.offer(elementLow));\n+        assertTrue(queue.offer(elementHigh));\n+        assertEquals(2, queue.size());\n+        assertTrue(queue.poll().isHighPriority());\n+        assertFalse(queue.poll().isHighPriority());\n+        assertEquals(0, queue.size());\n+    }\n+\n+    @Test\n+    public void testPriorityQueue_whenHighestOfferedFirst_thenTakeHighest() {\n+\n+        PriorityElement elementLow = new PriorityElement(false, 1);\n+        PriorityElement elementHigh = new PriorityElement(true, 1);\n+\n+        assertTrue(queue.offer(elementHigh));\n+        assertTrue(queue.offer(elementLow));\n+        assertEquals(2, queue.size());\n+        assertTrue(queue.poll().isHighPriority());\n+        assertFalse(queue.poll().isHighPriority());\n+        assertEquals(0, queue.size());\n+    }\n+\n+    @Test\n+    public void testPriorityQueue_whenTwoHighest_thenTakeFirstVersion() {\n+        PriorityElement elementHigh1 = new PriorityElement(true, 1);\n+        PriorityElement elementHigh2 = new PriorityElement(true, 2);\n+\n+        assertTrue(queue.offer(elementHigh1));\n+        assertTrue(queue.offer(elementHigh2));\n+        assertEquals(2, queue.size());\n+        assertEquals(1, queue.poll().getVersion());\n+        assertEquals(2, queue.poll().getVersion());\n+        assertEquals(0, queue.size());\n+    }\n+\n+    @Test\n+    public void testPriorityQueue_whenTwoHighest_thenTakeFirstVersionAgain() {\n+\n+        PriorityElement elementHigh1 = new PriorityElement(true, 1);\n+        PriorityElement elementHigh2 = new PriorityElement(true, 2);\n+\n+        assertTrue(queue.offer(elementHigh2));\n+        assertTrue(queue.offer(elementHigh1));\n+        assertEquals(2, queue.size());\n+        assertEquals(1, queue.poll().getVersion());\n+        assertEquals(2, queue.poll().getVersion());\n+        assertEquals(0, queue.size());\n+    }\n+\n+    @Test\n+    public void queue() {\n+        PriorityElement element = new PriorityElement(false, 1);\n+        queue.offer(element);\n+        assertEquals(element, queue.poll());\n+        assertNull(queue.poll());\n+    }\n+\n+    @Test\n+    public void queuePrioritizing() {\n+        int count = 0;\n+        int elementCount = 100;\n+        for (int i = 0; i < elementCount; i++) {\n+            queue.offer(new PriorityElement(false, count));\n+            queue.offer(new PriorityElement(true, count));\n+            count++;\n+        }\n+\n+        for (int i = 0; i < elementCount; i++) {\n+            PriorityElement dequeue = queue.poll();\n+            assertTrue(\"High priority first\", dequeue.isHighPriority());\n+            assertEquals(i, dequeue.getVersion());\n+        }\n+        for (int i = 0; i < elementCount; i++) {\n+            PriorityElement dequeue = queue.poll();\n+            assertFalse(\"Low priority afterwards\", dequeue.isHighPriority());\n+            assertEquals(i, dequeue.getVersion());\n+        }\n+        assertNull(queue.poll());\n+    }\n+\n+    @Test\n+    public void queueConsistency() throws InterruptedException {\n+        int count = 0;\n+        for (int i = 0; i < 500; i++) {\n+            queue.offer(new PriorityElement(false, count));\n+            queue.offer(new PriorityElement(true, count));\n+            count++;\n+        }\n+        ExecutorService threadPool = Executors.newCachedThreadPool();\n+        ConcurrentSkipListSet<PriorityElement> tasks = new ConcurrentSkipListSet<>(new PriorityElementComparator());\n+        Semaphore sem = new Semaphore(-99);\n+        for (int i = 0; i < 100; i++) {\n+            threadPool.execute(() -> {\n+                PriorityElement task;\n+                while ((task = queue.poll()) != null) {\n+                    tasks.add(task);\n+                }\n+                sem.release();\n+            });\n+        }\n+        sem.acquire();\n+        assertEquals(500 * 2, tasks.size());\n+        assertNull(queue.poll());\n+    }", "originalCommit": "0d90fb075a7d66efb647c05f7b754176a74fd81e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM0NzY4NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17201#discussion_r478347684", "bodyText": "Nice catch! Added creation and destruction in Before and After blocks.", "author": "mmedenjak", "createdAt": "2020-08-27T11:31:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM0Mzc1Mg=="}], "type": "inlineReview"}, {"oid": "f64a0c59ea0e987b415bf5a1b35d1e12d899aeef", "url": "https://github.com/hazelcast/hazelcast/commit/f64a0c59ea0e987b415bf5a1b35d1e12d899aeef", "message": "Proof of concept for priority queue support\n\nDefined comparator class name in QueueConfig which can be queried to set user defined comparator for PriorityQueue in QueueContainer\n\nDefine a comparator attribute in config xsd queue element\n\nProcess and supply value to QueueConfig for server XML configuration\n\nDefine a comparator holder which deserializes queueItem data before comparison", "committedDate": "2020-08-31T06:54:34Z", "type": "commit"}, {"oid": "39f2a630c4240e48c402621a6888a6776b350868", "url": "https://github.com/hazelcast/hazelcast/commit/39f2a630c4240e48c402621a6888a6776b350868", "message": "Configuration attribute to for queue without duplicates\n\nImplementation of a priority queue which get rid of duplicates\nProvide additional javadocs\n\nProvide configuration for new priority queue\n\nImprove javadocs and provide additional tests\n\nAdd configuration for PriorityQueue in QueueConfig\n\nFollow steps defined in https://github.com/hazelcast/hazelcast/wiki/Checklist-for-Hazelcast-config-changes", "committedDate": "2020-08-31T06:54:35Z", "type": "commit"}, {"oid": "a969644cfee4acec14e8de3059e2016e774f246b", "url": "https://github.com/hazelcast/hazelcast/commit/a969644cfee4acec14e8de3059e2016e774f246b", "message": "Take into account new concerns on queue migration,\n\nqueue backup within a cluster,\ntransaction rollback on timeout.\nAll those changes are related to itemQueue datastructure change\nin QueueContainer from LinkedList to PriorityQueue", "committedDate": "2020-08-31T06:54:35Z", "type": "commit"}, {"oid": "b475ba187e9a3dd5182bcb0db68768eb0c26f304", "url": "https://github.com/hazelcast/hazelcast/commit/b475ba187e9a3dd5182bcb0db68768eb0c26f304", "message": "Use Queue interface in QueueContainer\n\nProvide Priority Queue specialization alongside the LinkedList to support both queue types depending on queue configuration", "committedDate": "2020-08-31T06:54:35Z", "type": "commit"}, {"oid": "d0181c8cfae11317110ba771c362ec7a044809e2", "url": "https://github.com/hazelcast/hazelcast/commit/d0181c8cfae11317110ba771c362ec7a044809e2", "message": "Forbid a cluster version less than 4.1 to be used with priority queue", "committedDate": "2020-08-31T06:54:35Z", "type": "commit"}, {"oid": "304e70382d36ef159c701d5b58543a06c6acac6d", "url": "https://github.com/hazelcast/hazelcast/commit/304e70382d36ef159c701d5b58543a06c6acac6d", "message": "Apply pull request suggestions and fix unittest failures", "committedDate": "2020-08-31T06:54:35Z", "type": "commit"}, {"oid": "dfe50978439ebc3ba010616a3a6a4ecaa2a2e124", "url": "https://github.com/hazelcast/hazelcast/commit/dfe50978439ebc3ba010616a3a6a4ecaa2a2e124", "message": "Cache deserialized data to improve PriorityQueue item comparison performance", "committedDate": "2020-08-31T06:54:35Z", "type": "commit"}, {"oid": "97fbd975fee93d58b695211f562eac756eb707e4", "url": "https://github.com/hazelcast/hazelcast/commit/97fbd975fee93d58b695211f562eac756eb707e4", "message": "Priority queue configuration now defined as attributes of queue element", "committedDate": "2020-08-31T06:54:35Z", "type": "commit"}, {"oid": "85417ad906b8b0f03b34f983427107baf129b125", "url": "https://github.com/hazelcast/hazelcast/commit/85417ad906b8b0f03b34f983427107baf129b125", "message": "revert no duplicate queue support", "committedDate": "2020-08-31T06:54:35Z", "type": "commit"}, {"oid": "34eb5b1f90102bc04cb7e44b5387ed3dab8733c8", "url": "https://github.com/hazelcast/hazelcast/commit/34eb5b1f90102bc04cb7e44b5387ed3dab8733c8", "message": "Cleanup\n\n- fix imports\n- reformat config class and add nullability annotations\n- remove unused class\n- add rolling upgrade checks\n- add missing config infrastructure and test code\n- minor typos\n- regenerate client codecs", "committedDate": "2020-08-31T06:54:36Z", "type": "commit"}, {"oid": "c7e3299e0ba801af1126a8296c8ae0a4529b0b36", "url": "https://github.com/hazelcast/hazelcast/commit/c7e3299e0ba801af1126a8296c8ae0a4529b0b36", "message": "Fix tests", "committedDate": "2020-08-31T06:54:36Z", "type": "commit"}, {"oid": "3a139c70bd95a1e0be5acc823079f16e6a803eb5", "url": "https://github.com/hazelcast/hazelcast/commit/3a139c70bd95a1e0be5acc823079f16e6a803eb5", "message": "Further cleanup\n\n- remove guava\n- remove unnecessary import reordering\n- align code with master to avoid unnecessary code changes\n- cleanup generics\n- remove unnecessary instance creation", "committedDate": "2020-08-31T06:54:36Z", "type": "commit"}, {"oid": "a3b151e002a5851ee4127ecdfbb19765d1973ba7", "url": "https://github.com/hazelcast/hazelcast/commit/a3b151e002a5851ee4127ecdfbb19765d1973ba7", "message": "Fix tests", "committedDate": "2020-08-31T06:54:36Z", "type": "commit"}, {"oid": "e7918383af8ca730454decc2a1bf12b648528911", "url": "https://github.com/hazelcast/hazelcast/commit/e7918383af8ca730454decc2a1bf12b648528911", "message": "Attempt at caching deserialized values for queue items", "committedDate": "2020-08-31T06:54:36Z", "type": "commit"}, {"oid": "f1323ebf0c3e4ef3833fdcda3897b6c53d3f575d", "url": "https://github.com/hazelcast/hazelcast/commit/f1323ebf0c3e4ef3833fdcda3897b6c53d3f575d", "message": "test cases added for priority queue behavior, incl. duplicate check test case", "committedDate": "2020-08-31T06:54:36Z", "type": "commit"}, {"oid": "a82c80fec08dc389de9a8a548dfb24cbc35a6588", "url": "https://github.com/hazelcast/hazelcast/commit/a82c80fec08dc389de9a8a548dfb24cbc35a6588", "message": "Fix checkstyle", "committedDate": "2020-08-31T06:54:36Z", "type": "commit"}, {"oid": "5643082e1c643f0a1bbe01eb7a0581fa5aa6757d", "url": "https://github.com/hazelcast/hazelcast/commit/5643082e1c643f0a1bbe01eb7a0581fa5aa6757d", "message": "Cleanup tests and add migration test", "committedDate": "2020-08-31T06:54:36Z", "type": "commit"}, {"oid": "e1c4ff103e4c5917957440e7bc47fe86bc6f3dc7", "url": "https://github.com/hazelcast/hazelcast/commit/e1c4ff103e4c5917957440e7bc47fe86bc6f3dc7", "message": "Add more tests for priority queue, fix minor issues\n\n- parametrize existing queue tests\n- fix issues found during testing\n- add javadoc to config class and move properties which are meant for configuration\n- minor cleanups", "committedDate": "2020-08-31T06:54:36Z", "type": "commit"}, {"oid": "b5937d2be0bd3bba8e502b9a790bbbc7a2bf9c63", "url": "https://github.com/hazelcast/hazelcast/commit/b5937d2be0bd3bba8e502b9a790bbbc7a2bf9c63", "message": "Fix checkstyle", "committedDate": "2020-08-31T06:54:36Z", "type": "commit"}, {"oid": "a8d0446d9ba2503cc7c4b4f397cb2c2b012fb399", "url": "https://github.com/hazelcast/hazelcast/commit/a8d0446d9ba2503cc7c4b4f397cb2c2b012fb399", "message": "Fix compilation issue after rebase and regenerate protocol", "committedDate": "2020-08-31T06:54:53Z", "type": "commit"}, {"oid": "58229dd09fb98040f26bf7e6f0ac279e521bb572", "url": "https://github.com/hazelcast/hazelcast/commit/58229dd09fb98040f26bf7e6f0ac279e521bb572", "message": "Address review comments", "committedDate": "2020-08-31T06:54:53Z", "type": "commit"}, {"oid": "7b50cca0034b86ec8b12c53b58e3c3f8e8aa96fd", "url": "https://github.com/hazelcast/hazelcast/commit/7b50cca0034b86ec8b12c53b58e3c3f8e8aa96fd", "message": "Address review comments", "committedDate": "2020-08-31T06:54:53Z", "type": "commit"}, {"oid": "c18004752044ca1d690da6fa84f1a0e844b7da0c", "url": "https://github.com/hazelcast/hazelcast/commit/c18004752044ca1d690da6fa84f1a0e844b7da0c", "message": "Checkstyle", "committedDate": "2020-08-31T06:54:53Z", "type": "commit"}, {"oid": "f4028b0f37a76a4c1ffec76091900d16a20d25e2", "url": "https://github.com/hazelcast/hazelcast/commit/f4028b0f37a76a4c1ffec76091900d16a20d25e2", "message": "Regenerate client protocol", "committedDate": "2020-08-31T06:57:03Z", "type": "commit"}, {"oid": "f4028b0f37a76a4c1ffec76091900d16a20d25e2", "url": "https://github.com/hazelcast/hazelcast/commit/f4028b0f37a76a4c1ffec76091900d16a20d25e2", "message": "Regenerate client protocol", "committedDate": "2020-08-31T06:57:03Z", "type": "forcePushed"}]}