{"pr_number": 17039, "pr_title": "SQL: Basic optimization for project/filter/scan (#17005)", "pr_createdAt": "2020-06-02T12:28:06Z", "pr_url": "https://github.com/hazelcast/hazelcast/pull/17039", "timeline": [{"oid": "4fa70829fefe01f6f9b1a0cbfd3fb54690562f89", "url": "https://github.com/hazelcast/hazelcast/commit/4fa70829fefe01f6f9b1a0cbfd3fb54690562f89", "message": "SQL: Apache Calcite integration (#17005)", "committedDate": "2020-06-02T12:23:53Z", "type": "commit"}, {"oid": "de594a496ed0639fb68ba1d7155a854b55d65065", "url": "https://github.com/hazelcast/hazelcast/commit/de594a496ed0639fb68ba1d7155a854b55d65065", "message": "Typos and minor fixes", "committedDate": "2020-06-03T13:32:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ2NTk3OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17039#discussion_r434465979", "bodyText": "This comment looks irrelevant.", "author": "viliam-durina", "createdAt": "2020-06-03T10:25:17Z", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/opt/AbstractMapScanRel.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.opt;\n+\n+import com.hazelcast.sql.impl.calcite.opt.cost.CostUtils;\n+import com.hazelcast.sql.impl.schema.map.AbstractMapTable;\n+import org.apache.calcite.plan.RelOptCluster;\n+import org.apache.calcite.plan.RelOptCost;\n+import org.apache.calcite.plan.RelOptPlanner;\n+import org.apache.calcite.plan.RelOptTable;\n+import org.apache.calcite.plan.RelTraitSet;\n+import org.apache.calcite.rel.RelWriter;\n+import org.apache.calcite.rel.metadata.RelMetadataQuery;\n+import org.apache.calcite.rex.RexNode;\n+\n+import java.util.List;\n+\n+/**\n+ * Base class for map scans.\n+ */\n+public abstract class AbstractMapScanRel extends AbstractScanRel {\n+    /** Filter. */\n+    protected final RexNode filter;\n+\n+    public AbstractMapScanRel(\n+        RelOptCluster cluster,\n+        RelTraitSet traitSet,\n+        RelOptTable table,\n+        List<Integer> projects,\n+        RexNode filter\n+    ) {\n+        super(cluster, traitSet, table, projects);\n+\n+        this.filter = filter;\n+    }\n+\n+    public List<Integer> getProjects() {\n+        return projects != null ? projects : identity();\n+    }\n+\n+    public RexNode getFilter() {\n+        return filter;\n+    }\n+\n+    public AbstractMapTable getMap() {\n+        return getTableUnwrapped().getTarget();\n+    }\n+\n+    @Override\n+    public RelWriter explainTerms(RelWriter pw) {\n+        return super.explainTerms(pw).itemIf(\"filter\", filter, filter != null);\n+    }\n+\n+    @Override\n+    public final double estimateRowCount(RelMetadataQuery mq) {\n+        double rowCount = super.estimateRowCount(mq);\n+\n+        if (filter != null) {\n+            double selectivity = mq.getSelectivity(this, filter);\n+\n+            rowCount = rowCount * selectivity;\n+        }\n+\n+        return rowCount;\n+    }\n+\n+    @Override\n+    public RelOptCost computeSelfCost(RelOptPlanner planner, RelMetadataQuery mq) {\n+        return computeSelfCost(\n+            planner,\n+            mq,\n+            table.getRowCount(),\n+            filter,\n+            getProjects().size(),\n+            CostUtils.TABLE_SCAN_CPU_MULTIPLIER\n+        );\n+    }\n+\n+    protected RelOptCost computeSelfCost(\n+        RelOptPlanner planner,\n+        RelMetadataQuery mq,\n+        double scanRowCount,\n+        RexNode filter,\n+        int projectCount,\n+        double costMultiplier\n+    ) {\n+        // 1. Get cost of the scan itself. For replicated map cost is multiplied by the number of nodes.", "originalCommit": "4fa70829fefe01f6f9b1a0cbfd3fb54690562f89", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5610da8026e323459e0697aba64830274d390787", "url": "https://github.com/hazelcast/hazelcast/commit/5610da8026e323459e0697aba64830274d390787", "message": "Fix checkstyle", "committedDate": "2020-06-03T13:58:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE0MTE1NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17039#discussion_r435141154", "bodyText": "CostUtil.adjustFilteredRowCount?", "author": "taburet", "createdAt": "2020-06-04T10:07:51Z", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/opt/AbstractMapScanRel.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.opt;\n+\n+import com.hazelcast.sql.impl.calcite.opt.cost.CostUtils;\n+import com.hazelcast.sql.impl.schema.map.AbstractMapTable;\n+import org.apache.calcite.plan.RelOptCluster;\n+import org.apache.calcite.plan.RelOptCost;\n+import org.apache.calcite.plan.RelOptPlanner;\n+import org.apache.calcite.plan.RelOptTable;\n+import org.apache.calcite.plan.RelTraitSet;\n+import org.apache.calcite.rel.RelWriter;\n+import org.apache.calcite.rel.metadata.RelMetadataQuery;\n+import org.apache.calcite.rex.RexNode;\n+\n+import java.util.List;\n+\n+/**\n+ * Base class for map scans.\n+ */\n+public abstract class AbstractMapScanRel extends AbstractScanRel {\n+    /** Filter. */\n+    protected final RexNode filter;\n+\n+    public AbstractMapScanRel(\n+        RelOptCluster cluster,\n+        RelTraitSet traitSet,\n+        RelOptTable table,\n+        List<Integer> projects,\n+        RexNode filter\n+    ) {\n+        super(cluster, traitSet, table, projects);\n+\n+        this.filter = filter;\n+    }\n+\n+    public List<Integer> getProjects() {\n+        return projects != null ? projects : identity();\n+    }\n+\n+    public RexNode getFilter() {\n+        return filter;\n+    }\n+\n+    public AbstractMapTable getMap() {\n+        return getTableUnwrapped().getTarget();\n+    }\n+\n+    @Override\n+    public RelWriter explainTerms(RelWriter pw) {\n+        return super.explainTerms(pw).itemIf(\"filter\", filter, filter != null);\n+    }\n+\n+    @Override\n+    public final double estimateRowCount(RelMetadataQuery mq) {\n+        double rowCount = super.estimateRowCount(mq);\n+\n+        if (filter != null) {\n+            double selectivity = mq.getSelectivity(this, filter);\n+\n+            rowCount = rowCount * selectivity;", "originalCommit": "5610da8026e323459e0697aba64830274d390787", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTIyMTM3MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17039#discussion_r435221371", "bodyText": "Yes, we may use this method. However, this piece of code will go away soon once we introduce project/filter-into-scan rules, so it is safe to keep it for now as is.", "author": "devozerov", "createdAt": "2020-06-04T12:40:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE0MTE1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE0NDU0Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17039#discussion_r435144542", "bodyText": "shouldn't the class be abstract?", "author": "taburet", "createdAt": "2020-06-04T10:14:10Z", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/opt/AbstractRootRel.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.opt;\n+\n+import org.apache.calcite.plan.RelOptCluster;\n+import org.apache.calcite.plan.RelOptCost;\n+import org.apache.calcite.plan.RelOptPlanner;\n+import org.apache.calcite.plan.RelTraitSet;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.RelWriter;\n+import org.apache.calcite.rel.SingleRel;\n+import org.apache.calcite.rel.metadata.RelMetadataQuery;\n+\n+/**\n+ * Base class for root operators.\n+ */\n+public class AbstractRootRel extends SingleRel implements HazelcastRelNode {", "originalCommit": "5610da8026e323459e0697aba64830274d390787", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTIyNTQ3MA==", "url": "https://github.com/hazelcast/hazelcast/pull/17039#discussion_r435225470", "bodyText": "Fixed.", "author": "devozerov", "createdAt": "2020-06-04T12:47:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE0NDU0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE0OTg3NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17039#discussion_r435149874", "bodyText": "assert toConvention == LOGICAL?", "author": "taburet", "createdAt": "2020-06-04T10:23:09Z", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/opt/HazelcastConventions.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.opt;\n+\n+import com.hazelcast.sql.impl.calcite.opt.logical.LogicalRel;\n+import com.hazelcast.sql.impl.calcite.opt.physical.PhysicalRel;\n+import org.apache.calcite.plan.Convention;\n+import org.apache.calcite.plan.RelTraitSet;\n+\n+/**\n+ * Hazelcast conventions.\n+ */\n+public final class HazelcastConventions {\n+    /** Convention used during logical planning. */\n+    public static final Convention LOGICAL = new Convention.Impl(\"LOGICAL\", LogicalRel.class);\n+\n+    /** Convention used during physical planning. */\n+    public static final Convention PHYSICAL = new Convention.Impl(\"PHYSICAL\", PhysicalRel.class) {\n+        @Override\n+        public boolean canConvertConvention(Convention toConvention) {\n+            // Allows conversion between LOGICAL and PHYSICAL conventions.", "originalCommit": "5610da8026e323459e0697aba64830274d390787", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTIyNTQ0Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17039#discussion_r435225442", "bodyText": "Done.", "author": "devozerov", "createdAt": "2020-06-04T12:47:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE0OTg3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE2NzA2OA==", "url": "https://github.com/hazelcast/hazelcast/pull/17039#discussion_r435167068", "bodyText": "Suspicious that traitDef itself is not used for in equals and hashCode.", "author": "taburet", "createdAt": "2020-06-04T10:56:17Z", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/opt/distribution/DistributionTrait.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.opt.distribution;\n+\n+import org.apache.calcite.plan.RelOptPlanner;\n+import org.apache.calcite.plan.RelTrait;\n+import org.apache.calcite.plan.RelTraitDef;\n+\n+import static com.hazelcast.sql.impl.calcite.opt.distribution.DistributionType.ANY;\n+\n+/**\n+ * Defines how the given relation is distributed in the cluster.\n+ */\n+public class DistributionTrait implements RelTrait {\n+    /** Trait definition. */\n+    private final DistributionTraitDef traitDef;\n+\n+    /** Distribution type. */\n+    private final DistributionType type;\n+\n+    DistributionTrait(DistributionTraitDef traitDef, DistributionType type) {\n+        this.traitDef = traitDef;\n+        this.type = type;\n+    }\n+\n+    public DistributionType getType() {\n+        return type;\n+    }\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    @Override\n+    public RelTraitDef getTraitDef() {\n+        return traitDef;\n+    }\n+\n+    @Override\n+    public boolean satisfies(RelTrait targetTrait) {\n+        if (!(targetTrait instanceof DistributionTrait)) {\n+            return false;\n+        }\n+\n+        // For single-member deployments all distributions satisfy each other.\n+        if (traitDef.getMemberCount() == 1) {\n+            return true;\n+        }\n+\n+        DistributionType targetType = ((DistributionTrait) targetTrait).getType();\n+\n+        // Any type satisfies ANY.\n+        if (targetType == ANY) {\n+            return true;\n+        }\n+\n+        // Otherwise compare two distributions.\n+        return this.equals(targetTrait);\n+    }\n+\n+    @Override\n+    public void register(RelOptPlanner planner) {\n+        // No-op.\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {", "originalCommit": "5610da8026e323459e0697aba64830274d390787", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTIyNTI5Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17039#discussion_r435225296", "bodyText": "Nice catch! Fixed.", "author": "devozerov", "createdAt": "2020-06-04T12:47:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE2NzA2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE5MzUwNg==", "url": "https://github.com/hazelcast/hazelcast/pull/17039#discussion_r435193506", "bodyText": "Does the operand really can be null?", "author": "taburet", "createdAt": "2020-06-04T11:49:13Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/UniExpression.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression;\n+\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+\n+/**\n+ * Expression with one operand.\n+ */\n+public abstract class UniExpression<T> implements Expression<T> {\n+\n+    protected Expression<?> operand;\n+\n+    protected UniExpression() {\n+        // No-op.\n+    }\n+\n+    protected UniExpression(Expression<?> operand) {\n+        this.operand = operand;\n+    }\n+\n+    public Expression<?> getOperand() {\n+        return operand;\n+    }\n+\n+    @Override\n+    public void writeData(ObjectDataOutput out) throws IOException {\n+        out.writeObject(operand);\n+    }\n+\n+    @Override\n+    public void readData(ObjectDataInput in) throws IOException {\n+        operand = in.readObject();\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return operand != null ? operand.hashCode() : 0;", "originalCommit": "5610da8026e323459e0697aba64830274d390787", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTIyNTQwOQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17039#discussion_r435225409", "bodyText": "I think it can't, Fixed.", "author": "devozerov", "createdAt": "2020-06-04T12:47:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE5MzUwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE5OTI5NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17039#discussion_r435199294", "bodyText": "It also makes sense to include changes to 01-type-system.md regarding BIT to BOOLEAN transition.", "author": "taburet", "createdAt": "2020-06-04T12:00:43Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/type/converter/AbstractObjectConverter.java", "diffHunk": "@@ -33,8 +33,8 @@ protected AbstractObjectConverter(int id, QueryDataTypeFamily typeFamily) {\n     }\n \n     @Override\n-    public boolean asBit(Object val) {\n-        return resolveConverter(val, QueryDataTypeFamily.BOOLEAN).asBit(val);\n+    public boolean asBoolean(Object val) {\n+        return resolveConverter(val, QueryDataTypeFamily.BOOLEAN).asBoolean(val);", "originalCommit": "5610da8026e323459e0697aba64830274d390787", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTIxOTMyNg==", "url": "https://github.com/hazelcast/hazelcast/pull/17039#discussion_r435219326", "bodyText": "Addressed.", "author": "devozerov", "createdAt": "2020-06-04T12:37:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE5OTI5NA=="}], "type": "inlineReview"}, {"oid": "a0d4e58a58bdc845b0a73299bd02856a96d64d76", "url": "https://github.com/hazelcast/hazelcast/commit/a0d4e58a58bdc845b0a73299bd02856a96d64d76", "message": "BIT -> BOOLEAN in the design docs.", "committedDate": "2020-06-04T12:36:51Z", "type": "commit"}, {"oid": "30af12c8de6320fae0134e780c62d5b8c294ab15", "url": "https://github.com/hazelcast/hazelcast/commit/30af12c8de6320fae0134e780c62d5b8c294ab15", "message": "Review comments.", "committedDate": "2020-06-04T12:46:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI4NDU4Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17039#discussion_r435284582", "bodyText": "Minor: True -> true?", "author": "petrpleshachkov", "createdAt": "2020-06-04T14:05:28Z", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/opt/OptUtils.java", "diffHunk": "@@ -0,0 +1,209 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.opt;\n+\n+import com.hazelcast.sql.impl.calcite.opt.distribution.DistributionTrait;\n+import com.hazelcast.sql.impl.calcite.opt.distribution.DistributionTraitDef;\n+import org.apache.calcite.plan.Convention;\n+import org.apache.calcite.plan.ConventionTraitDef;\n+import org.apache.calcite.plan.HazelcastRelOptCluster;\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleOperand;\n+import org.apache.calcite.plan.RelTrait;\n+import org.apache.calcite.plan.RelTraitSet;\n+import org.apache.calcite.plan.volcano.RelSubset;\n+import org.apache.calcite.rel.RelNode;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.IdentityHashMap;\n+import java.util.Set;\n+\n+import static org.apache.calcite.plan.RelOptRule.convert;\n+\n+/**\n+ * Utility methods for rules.\n+ */\n+public final class OptUtils {\n+    private OptUtils() {\n+        // No-op.\n+    }\n+\n+    /**\n+     * Get operand matching a single node.\n+     *\n+     * @param cls Node class.\n+     * @param convention Convention.\n+     * @return Operand.\n+     */\n+    public static <R extends RelNode> RelOptRuleOperand single(Class<R> cls, Convention convention) {\n+        return RelOptRule.operand(cls, convention, RelOptRule.any());\n+    }\n+\n+    /**\n+     * Get operand matching a node with specific child node.\n+     *\n+     * @param cls Node class.\n+     * @param childCls Child node class.\n+     * @param convention Convention.\n+     * @return Operand.\n+     */\n+    public static <R1 extends RelNode, R2 extends RelNode> RelOptRuleOperand parentChild(Class<R1> cls,\n+        Class<R2> childCls, Convention convention) {\n+        RelOptRuleOperand childOperand = RelOptRule.operand(childCls, RelOptRule.any());\n+\n+        return RelOptRule.operand(cls, convention, RelOptRule.some(childOperand));\n+    }\n+\n+    /**\n+     * Add a single trait to the trait set.\n+     *\n+     * @param traitSet Original trait set.\n+     * @param trait Trait to add.\n+     * @return Resulting trait set.\n+     */\n+    public static RelTraitSet traitPlus(RelTraitSet traitSet, RelTrait trait) {\n+        return traitSet.plus(trait).simplify();\n+    }\n+\n+    /**\n+     * Add two traits to the trait set.\n+     *\n+     * @param traitSet Original trait set.\n+     * @param trait1 Trait to add.\n+     * @param trait2 Trait to add.\n+     * @return Resulting trait set.\n+     */\n+    public static RelTraitSet traitPlus(RelTraitSet traitSet, RelTrait trait1, RelTrait trait2) {\n+        return traitSet.plus(trait1).plus(trait2).simplify();\n+    }\n+\n+    /**\n+     * Convert the given trait set to logical convention.\n+     *\n+     * @param traitSet Original trait set.\n+     * @return New trait set with logical convention.\n+     */\n+    public static RelTraitSet toLogicalConvention(RelTraitSet traitSet) {\n+        return traitPlus(traitSet, HazelcastConventions.LOGICAL);\n+    }\n+\n+    /**\n+     * Convert the given input into logical input.\n+     *\n+     * @param input Original input.\n+     * @return Logical input.\n+     */\n+    public static RelNode toLogicalInput(RelNode input) {\n+        return convert(input, toLogicalConvention(input.getTraitSet()));\n+    }\n+\n+    /**\n+     * Convert the given trait set to physical convention.\n+     *\n+     * @param traitSet Original trait set.\n+     * @return New trait set with physical convention and provided distribution.\n+     */\n+    public static RelTraitSet toPhysicalConvention(RelTraitSet traitSet) {\n+        return traitPlus(traitSet, HazelcastConventions.PHYSICAL);\n+    }\n+\n+    /**\n+     * Convert the given trait set to physical convention.\n+     *\n+     * @param traitSet Original trait set.\n+     * @param distribution Distribution.\n+     * @return New trait set with physical convention and provided distribution.\n+     */\n+    public static RelTraitSet toPhysicalConvention(RelTraitSet traitSet, DistributionTrait distribution) {\n+        return traitPlus(traitSet, HazelcastConventions.PHYSICAL, distribution);\n+    }\n+\n+    /**\n+     * Convert the given input into physical input.\n+     *\n+     * @param input Original input.\n+     * @return Logical input.\n+     */\n+    public static RelNode toPhysicalInput(RelNode input) {\n+        return convert(input, toPhysicalConvention(input.getTraitSet()));\n+    }\n+\n+    /**\n+     * Convert the given input into physical input.\n+     *\n+     * @param input Original input.\n+     * @param distribution Distribution.\n+     * @return Logical input.\n+     */\n+    public static RelNode toPhysicalInput(RelNode input, DistributionTrait distribution) {\n+        return convert(input, toPhysicalConvention(input.getTraitSet(), distribution));\n+    }\n+\n+    /**\n+     * @param rel Node.\n+     * @return {@code True} if the given node is physical node.", "originalCommit": "30af12c8de6320fae0134e780c62d5b8c294ab15", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcxOTUxMw==", "url": "https://github.com/hazelcast/hazelcast/pull/17039#discussion_r435719513", "bodyText": "Too late, it is merged. I'll fix it in the next PR. Bad habit from Apache Ignite days - we had such word as a requirement to code styling :-)", "author": "devozerov", "createdAt": "2020-06-05T06:42:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI4NDU4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI4NTkzNA==", "url": "https://github.com/hazelcast/hazelcast/pull/17039#discussion_r435285934", "bodyText": "Maybe IllegalStateException is more appropriate here?", "author": "petrpleshachkov", "createdAt": "2020-06-04T14:07:05Z", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/opt/cost/Cost.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.opt.cost;\n+\n+import org.apache.calcite.plan.RelOptCost;\n+import org.apache.calcite.plan.RelOptUtil;\n+\n+/**\n+ * Cost of relational operator.\n+ * <p>\n+ * We use our own implementation instead of the one provided by Apache Calcite. In Apache Calcite, the cost is a vector of\n+ * three values - row count, CPU and IO. First, it has some problems with comparison semantics [1]. Second, its comparison\n+ * depends mostly on row count, while in our case other factors, such as network, are more important. Last, it has a\n+ * number of methods and variables that are otherwise unused (or mostly unused).\n+ * <p>\n+ * Our implementation still tracks row count, CPU and network, but it doesn't implement unnecessary methods, has proper\n+ * comparison semantics, and use CPU and network for cost comparison instead row count.\n+ * <p>\n+ * [1] https://issues.apache.org/jira/browse/CALCITE-3956\n+ */\n+public class Cost implements RelOptCost {\n+\n+    public static final Cost ZERO = new Cost(0.0d, 0.0d, 0.0d);\n+    public static final Cost TINY = new Cost(1.0d, 1.0d, 0.0d);\n+    public static final Cost HUGE = new Cost(Double.MAX_VALUE, Double.MAX_VALUE, Double.MAX_VALUE);\n+    public static final Cost INFINITY = new Cost(Double.MAX_VALUE, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);\n+\n+    private final double rows;\n+    private final double cpu;\n+    private final double network;\n+\n+    Cost(double rows, double cpu, double network) {\n+        this.rows = rows;\n+        this.cpu = cpu;\n+        this.network = network;\n+    }\n+\n+    public double getRowsInternal() {\n+        return rows;\n+    }\n+\n+    public double getCpuInternal() {\n+        return cpu;\n+    }\n+\n+    public double getNetworkInternal() {\n+        return network;\n+    }\n+\n+    @Override\n+    public double getRows() {\n+        // Make sure that Calcite doesn't rely on our values.\n+        throw new UnsupportedOperationException(\"Should not be called.\");", "originalCommit": "30af12c8de6320fae0134e780c62d5b8c294ab15", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcyMDAyMg==", "url": "https://github.com/hazelcast/hazelcast/pull/17039#discussion_r435720022", "bodyText": "Invocations of this method are located deep inside Apache Calcite internals, so a specific exception type should not make much difference.", "author": "devozerov", "createdAt": "2020-06-05T06:44:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI4NTkzNA=="}], "type": "inlineReview"}]}