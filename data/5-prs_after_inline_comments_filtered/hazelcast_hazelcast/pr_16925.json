{"pr_number": 16925, "pr_title": "Multiple TCP connections between members", "pr_createdAt": "2020-04-24T04:09:16Z", "pr_url": "https://github.com/hazelcast/hazelcast/pull/16925", "timeline": [{"oid": "3b6ede78204ae207a5d768d046e2223614f9d799", "url": "https://github.com/hazelcast/hazelcast/commit/3b6ede78204ae207a5d768d046e2223614f9d799", "message": "Introduce support multiple tco member connections", "committedDate": "2020-04-24T04:10:00Z", "type": "forcePushed"}, {"oid": "160f725430bdf091d6eea8158d1ec08eb99d3a7e", "url": "https://github.com/hazelcast/hazelcast/commit/160f725430bdf091d6eea8158d1ec08eb99d3a7e", "message": "Adds support for multiple connections between members\n\nHaving a single connection between members can lead to suboptimal\nperformance. On some environments like EC2 there is even a bandwidth\nlimit on a single flow (tcp connection) regardless of the actual\navailable network bandwidth.\n\nAlso under certain conditions like many clients and 2 member cluster,\nthe member to member connection needs to deal with all the backups of\nthe clients which can lead to an imbalance.\n\nWith multiple connections per members, these issues can be resolved.\n\nCurrently this is only available for members, but we'll probably apply\nthis approach as well to client to member connections at some point", "committedDate": "2020-04-24T04:12:48Z", "type": "forcePushed"}, {"oid": "f7e870f00f42c49d1812d107645b8f994fa502bf", "url": "https://github.com/hazelcast/hazelcast/commit/f7e870f00f42c49d1812d107645b8f994fa502bf", "message": "WIP", "committedDate": "2020-05-05T08:09:26Z", "type": "forcePushed"}, {"oid": "da6d7400a8113fdc70a0a0bad8bfeca829e94973", "url": "https://github.com/hazelcast/hazelcast/commit/da6d7400a8113fdc70a0a0bad8bfeca829e94973", "message": "Adds support for multiple connections between members\n\nHaving a single connection between members can lead to suboptimal\nperformance. On some environments like EC2 there is even a bandwidth\nlimit on a single flow (tcp connection) regardless of the actual\navailable network bandwidth.\n\nAlso under certain conditions like many clients and 2 member cluster,\nthe member to member connection needs to deal with all the backups of\nthe clients which can lead to an imbalance.\n\nWith multiple connections per members, these issues can be resolved.\n\nCurrently this is only available for members, but we'll probably apply\nthis approach as well to client to member connections at some point", "committedDate": "2020-05-05T08:10:05Z", "type": "forcePushed"}, {"oid": "0019657b14722366bf30db2a4852869be5e6a404", "url": "https://github.com/hazelcast/hazelcast/commit/0019657b14722366bf30db2a4852869be5e6a404", "message": "Adds support for multiple connections between members\n\nHaving a single connection between members can lead to suboptimal\nperformance. On some environments like EC2 there is even a bandwidth\nlimit on a single flow (tcp connection) regardless of the actual\navailable network bandwidth.\n\nAlso under certain conditions like many clients and 2 member cluster,\nthe member to member connection needs to deal with all the backups of\nthe clients which can lead to an imbalance.\n\nWith multiple connections per members, these issues can be resolved.\n\nCurrently this is only available for members, but we'll probably apply\nthis approach as well to client to member connections at some point", "committedDate": "2020-05-05T08:48:18Z", "type": "forcePushed"}, {"oid": "0f1dacd1b3f419b1a3b214307923b0136c72a3bd", "url": "https://github.com/hazelcast/hazelcast/commit/0f1dacd1b3f419b1a3b214307923b0136c72a3bd", "message": "Adds support for multiple connections between members\n\nHaving a single connection between members can lead to suboptimal\nperformance. On some environments like EC2 there is even a bandwidth\nlimit on a single flow (tcp connection) regardless of the actual\navailable network bandwidth.\n\nAlso under certain conditions like many clients and 2 member cluster,\nthe member to member connection needs to deal with all the backups of\nthe clients which can lead to an imbalance.\n\nWith multiple connections per members, these issues can be resolved.\n\nCurrently this is only available for members, but we'll probably apply\nthis approach as well to client to member connections at some point", "committedDate": "2020-05-05T11:46:00Z", "type": "forcePushed"}, {"oid": "f7cc454e71d8309b0676f816aca4ff4ba486110e", "url": "https://github.com/hazelcast/hazelcast/commit/f7cc454e71d8309b0676f816aca4ff4ba486110e", "message": "Adds support for multiple connections between members\n\nHaving a single connection between members can lead to suboptimal\nperformance. On some environments like EC2 there is even a bandwidth\nlimit on a single flow (tcp connection) regardless of the actual\navailable network bandwidth.\n\nAlso under certain conditions like many clients and 2 member cluster,\nthe member to member connection needs to deal with all the backups of\nthe clients which can lead to an imbalance.\n\nWith multiple connections per members, these issues can be resolved.\n\nCurrently this is only available for members, but we'll probably apply\nthis approach as well to client to member connections at some point", "committedDate": "2020-05-05T11:51:30Z", "type": "forcePushed"}, {"oid": "68729a66df4732cbf8d47064b2ab8aad9e2ec346", "url": "https://github.com/hazelcast/hazelcast/commit/68729a66df4732cbf8d47064b2ab8aad9e2ec346", "message": "Adds support for multiple connections between members\n\nHaving a single connection between members can lead to suboptimal\nperformance. On some environments like EC2 there is even a bandwidth\nlimit on a single flow (tcp connection) regardless of the actual\navailable network bandwidth.\n\nAlso under certain conditions like many clients and 2 member cluster,\nthe member to member connection needs to deal with all the backups of\nthe clients which can lead to an imbalance.\n\nWith multiple connections per members, these issues can be resolved.\n\nCurrently this is only available for members, but we'll probably apply\nthis approach as well to client to member connections at some point", "committedDate": "2020-05-06T06:32:35Z", "type": "forcePushed"}, {"oid": "3d874421c3f8bbfe1dbc55ca20d8169452fbbb8a", "url": "https://github.com/hazelcast/hazelcast/commit/3d874421c3f8bbfe1dbc55ca20d8169452fbbb8a", "message": "WIP", "committedDate": "2020-05-20T07:42:52Z", "type": "forcePushed"}, {"oid": "bb537bf36bbb5e8ceb6b18f7c714f74f4ac191e2", "url": "https://github.com/hazelcast/hazelcast/commit/bb537bf36bbb5e8ceb6b18f7c714f74f4ac191e2", "message": "WIP", "committedDate": "2020-05-29T08:41:54Z", "type": "forcePushed"}, {"oid": "7136d7ffc313eee72d82c93d1b0119c518507b54", "url": "https://github.com/hazelcast/hazelcast/commit/7136d7ffc313eee72d82c93d1b0119c518507b54", "message": "WIP", "committedDate": "2020-06-02T07:30:51Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk0NTExNQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16925#discussion_r444945115", "bodyText": "Is this going to be the same in the final version? Can/shouldn't we allow setting the plane count without stopping the cluster and restarting the members?", "author": "blazember", "createdAt": "2020-06-24T14:40:42Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/server/tcp/AbstractChannelInitializer.java", "diffHunk": "@@ -60,37 +60,46 @@ protected AbstractChannelInitializer(ServerContext serverContext, EndpointConfig\n         private final ILogger logger;\n         private final boolean spoofingChecks;\n         private final boolean unifiedEndpointManager;\n-\n         private final Set<ProtocolType> supportedProtocolTypes;\n+        private final int expectedPlaneCount;\n \n-        public MemberHandshakeHandler(TcpServerConnectionManager connectionManager, ServerContext serverContext, ILogger logger,\n+        public MemberHandshakeHandler(TcpServerConnectionManager connectionManager,\n+                                      ServerContext serverContext,\n+                                      ILogger logger,\n                                       Set<ProtocolType> supportedProtocolTypes) {\n             this.connectionManager = connectionManager;\n             this.serverContext = serverContext;\n             this.logger = logger;\n-            this.spoofingChecks = serverContext.properties().getBoolean(ClusterProperty.BIND_SPOOFING_CHECKS);\n+            this.spoofingChecks = serverContext.properties().getBoolean(BIND_SPOOFING_CHECKS);\n             this.supportedProtocolTypes = supportedProtocolTypes;\n             this.unifiedEndpointManager = connectionManager.getEndpointQualifier() == null;\n+            this.expectedPlaneCount = serverContext.properties().getInteger(CHANNEL_COUNT);\n         }\n \n         public void process(Packet packet) {\n-            Object o = serverContext.getSerializationService().toObject(packet);\n+            MemberHandshake handshake = serverContext.getSerializationService().toObject(packet);\n             TcpServerConnection connection = (TcpServerConnection) packet.getConn();\n-            if (connection.setHandshake()) {\n-                MemberHandshake handshake = (MemberHandshake) o;\n-                process(connection, handshake);\n-            } else {\n+            if (!connection.setHandshake()) {\n                 if (logger.isFinestEnabled()) {\n-                    logger.finest(\"Connection \" + connection + \" is already bound, ignoring incoming \" + o);\n+                    logger.finest(\"Connection \" + connection + \" handshake is already completed, ignoring incoming \" + handshake);\n                 }\n+                return;\n             }\n-        }\n \n-        private synchronized boolean process(TcpServerConnection connection, MemberHandshake handshake) {\n-            if (logger.isFinestEnabled()) {\n-                logger.finest(\"Handshake \" + connection + \", complete message is \" + handshake);\n+            if (handshake.getPlaneCount() != expectedPlaneCount) {", "originalCommit": "7136d7ffc313eee72d82c93d1b0119c518507b54", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc3OTIxMQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16925#discussion_r450779211", "bodyText": "In this POC it is fixed. In the final version is should be negotiated on a per connection basis. But this opens a can of worms when one of the connections is established, but the handshake hasn't completed yet and we don't know how many connections are actually going to be created. This can lead to the wrong number of connections or packets ending up in the wrong connection.", "author": "pveentjer", "createdAt": "2020-07-07T10:56:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk0NTExNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk2MTc1NA==", "url": "https://github.com/hazelcast/hazelcast/pull/16925#discussion_r444961754", "bodyText": "Will streamId always be the partitionId? These are different concerns though, but it feels (so far) we just introduce a different term for the same thing. The property talks about channel count, its description partition count. So just a reminder for the final version: we need to agree on the term and use it consistently.", "author": "blazember", "createdAt": "2020-06-24T15:01:55Z", "path": "hazelcast/src/main/java/com/hazelcast/spi/impl/operationservice/impl/Invocation.java", "diffHunk": "@@ -595,9 +595,16 @@ private void doInvokeLocal(boolean isAsync) {\n     private void doInvokeRemote() {\n         assert connectionManager != null : \"Endpoint manager was null\";\n \n-        ServerConnection connection = connectionManager.getOrConnect(targetAddress);\n+        ServerConnection connection = connectionManager.getOrConnect(targetAddress, op.getPartitionId());", "originalCommit": "7136d7ffc313eee72d82c93d1b0119c518507b54", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjA0MjM3OA==", "url": "https://github.com/hazelcast/hazelcast/pull/16925#discussion_r452042378", "bodyText": "Channel count is not partition count. Channel count will be very low; partition count is much higher.\nAbout partition id and stream id; n this PR it is the same thing although partition id -1 will always be mapped to stream 0. But streams could be used for other things that want to guarantee ordering within the stream.", "author": "pveentjer", "createdAt": "2020-07-09T08:13:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk2MTc1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjEyODM2Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/16925#discussion_r452128362", "bodyText": "Also partitions can move around. So it could be that one moment your partition is one one machine and one moment later on another. But streams do not move around; streams are within a connection.", "author": "pveentjer", "createdAt": "2020-07-09T10:44:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk2MTc1NA=="}], "type": "inlineReview"}, {"oid": "7cbbeb2926025aebe302f2d1360052d37ca71c49", "url": "https://github.com/hazelcast/hazelcast/commit/7cbbeb2926025aebe302f2d1360052d37ca71c49", "message": "WIP", "committedDate": "2020-06-30T08:39:54Z", "type": "forcePushed"}, {"oid": "b1a5934c56d825eeb458901536d5ca0afe6829b6", "url": "https://github.com/hazelcast/hazelcast/commit/b1a5934c56d825eeb458901536d5ca0afe6829b6", "message": "WIP", "committedDate": "2020-07-06T07:09:45Z", "type": "forcePushed"}, {"oid": "a8be4debc969f9e5ce8aa60e31004fc004fc09fb", "url": "https://github.com/hazelcast/hazelcast/commit/a8be4debc969f9e5ce8aa60e31004fc004fc09fb", "message": "WIP", "committedDate": "2020-07-09T11:45:45Z", "type": "forcePushed"}, {"oid": "1522f75489b653898558fdac9a45d5eaa77928a3", "url": "https://github.com/hazelcast/hazelcast/commit/1522f75489b653898558fdac9a45d5eaa77928a3", "message": "WIP", "committedDate": "2020-07-09T11:52:40Z", "type": "forcePushed"}, {"oid": "61c1ef6b67bf749a65f6792d18d34f46118905b5", "url": "https://github.com/hazelcast/hazelcast/commit/61c1ef6b67bf749a65f6792d18d34f46118905b5", "message": "WIP", "committedDate": "2020-07-10T06:44:00Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQ1NTM0Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/16925#discussion_r453455342", "bodyText": "re-enable?", "author": "tkountis", "createdAt": "2020-07-13T06:16:25Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/server/tcp/AbstractChannelInitializer.java", "diffHunk": "@@ -60,37 +61,49 @@ protected AbstractChannelInitializer(ServerContext serverContext, EndpointConfig\n         private final ILogger logger;\n         private final boolean spoofingChecks;\n         private final boolean unifiedEndpointManager;\n-\n         private final Set<ProtocolType> supportedProtocolTypes;\n+        private final int expectedPlaneCount;\n \n-        public MemberHandshakeHandler(TcpServerConnectionManager connectionManager, ServerContext serverContext, ILogger logger,\n+        public MemberHandshakeHandler(TcpServerConnectionManager connectionManager,\n+                                      ServerContext serverContext,\n+                                      ILogger logger,\n                                       Set<ProtocolType> supportedProtocolTypes) {\n             this.connectionManager = connectionManager;\n             this.serverContext = serverContext;\n             this.logger = logger;\n-            this.spoofingChecks = serverContext.properties().getBoolean(ClusterProperty.BIND_SPOOFING_CHECKS);\n+            this.spoofingChecks = serverContext.properties().getBoolean(BIND_SPOOFING_CHECKS);\n             this.supportedProtocolTypes = supportedProtocolTypes;\n             this.unifiedEndpointManager = connectionManager.getEndpointQualifier() == null;\n+            this.expectedPlaneCount = serverContext.properties().getInteger(CHANNEL_COUNT);\n         }\n \n         public void process(Packet packet) {\n-            Object o = serverContext.getSerializationService().toObject(packet);\n+            MemberHandshake handshake = serverContext.getSerializationService().toObject(packet);\n             TcpServerConnection connection = (TcpServerConnection) packet.getConn();\n-            if (connection.setHandshake()) {\n-                MemberHandshake handshake = (MemberHandshake) o;\n-                process(connection, handshake);\n-            } else {\n+            if (!connection.setHandshake()) {\n                 if (logger.isFinestEnabled()) {\n-                    logger.finest(\"Connection \" + connection + \" is already bound, ignoring incoming \" + o);\n+                    logger.finest(\"Connection \" + connection + \" handshake is already completed, ignoring incoming \" + handshake);\n                 }\n+                return;\n             }\n-        }\n \n-        private synchronized boolean process(TcpServerConnection connection, MemberHandshake handshake) {\n-            if (logger.isFinestEnabled()) {\n-                logger.finest(\"Handshake \" + connection + \", complete message is \" + handshake);\n+            if (handshake.getPlaneCount() != expectedPlaneCount) {\n+                connection.close(\"The connection handshake has incorrect number of planes. \"\n+                        + \"Expected \" + expectedPlaneCount + \" found \" + handshake.getPlaneCount(), null);\n+                return;\n             }\n \n+            // before we register the connection on the plane, we make sure the plane index is set on the connection\n+            // so that we can safely remove the connection from the plane.\n+            connection.setPlaneIndex(handshake.getPlaneIndex());\n+            process(connection, handshake);\n+        }\n+\n+        private synchronized void process(TcpServerConnection connection, MemberHandshake handshake) {\n+            // if (logger.isFinestEnabled()) {", "originalCommit": "61c1ef6b67bf749a65f6792d18d34f46118905b5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU3MTA5MA==", "url": "https://github.com/hazelcast/hazelcast/pull/16925#discussion_r453571090", "bodyText": "Fixed", "author": "pveentjer", "createdAt": "2020-07-13T11:04:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQ1NTM0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQ1Njc5MA==", "url": "https://github.com/hazelcast/hazelcast/pull/16925#discussion_r453456790", "bodyText": "?", "author": "tkountis", "createdAt": "2020-07-13T06:20:48Z", "path": "hazelcast/src/test/java/com/hazelcast/internal/server/FirewallingServer.java", "diffHunk": "@@ -236,27 +240,27 @@ private long getRandomBetween(long max, long min) {\n             return (long) ((max - min) * Math.random() + min);\n         }\n \n-        @Override\n-        public boolean transmit(Packet packet, ServerConnection connection) {\n-            if (connection != null) {\n-                PacketFilter.Action action = applyFilter(packet, connection.getRemoteAddress());\n-                switch (action) {\n-                    case DROP:\n-                        return true;\n-                    case REJECT:\n-                        return false;\n-                    case DELAY:\n-                        scheduledExecutor.schedule(new DelayedPacketTask(packet, connection), getDelayMs(), MILLISECONDS);\n-                        return true;\n-                    default:\n-                        // NOP\n-                }\n-            }\n-            return delegate.transmit(packet, connection);\n-        }\n+//        @Override", "originalCommit": "61c1ef6b67bf749a65f6792d18d34f46118905b5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "25b2313675e55e60cb4d1bec247a0b4be3686dda", "url": "https://github.com/hazelcast/hazelcast/commit/25b2313675e55e60cb4d1bec247a0b4be3686dda", "message": "WIP", "committedDate": "2020-07-13T11:05:43Z", "type": "forcePushed"}, {"oid": "7176d4ff30bc385cac58d8b927e0ffd7c30e0169", "url": "https://github.com/hazelcast/hazelcast/commit/7176d4ff30bc385cac58d8b927e0ffd7c30e0169", "message": "WIP", "committedDate": "2020-07-15T04:29:10Z", "type": "forcePushed"}, {"oid": "16c3c2105bc80600a45c9b34119330df9bcb16d0", "url": "https://github.com/hazelcast/hazelcast/commit/16c3c2105bc80600a45c9b34119330df9bcb16d0", "message": "WIP", "committedDate": "2020-07-15T06:49:08Z", "type": "forcePushed"}, {"oid": "890770d493f4b02d9a193599780c5db9fce55584", "url": "https://github.com/hazelcast/hazelcast/commit/890770d493f4b02d9a193599780c5db9fce55584", "message": "WIP", "committedDate": "2020-07-15T07:07:38Z", "type": "forcePushed"}, {"oid": "b123a55b9d52fca7d7c3010066c0538b5e6c7b21", "url": "https://github.com/hazelcast/hazelcast/commit/b123a55b9d52fca7d7c3010066c0538b5e6c7b21", "message": "Adds support for multiple connections between members\n\nHaving a single connection between members can lead to suboptimal\nperformance. On some environments like EC2 there is even a bandwidth\nlimit on a single flow (tcp connection) regardless of the actual\navailable network bandwidth.\n\nAlso under certain conditions like many clients and 2 member cluster,\nthe member to member connection needs to deal with all the backups of\nthe clients which can lead to an imbalance.\n\nWith multiple connections per members, these issues can be resolved.\n\nCurrently this is only available for members, but we'll probably apply\nthis approach as well to client to member connections at some point", "committedDate": "2020-07-15T11:09:35Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTY3NzYwNg==", "url": "https://github.com/hazelcast/hazelcast/pull/16925#discussion_r455677606", "bodyText": "Needs javadoc update.", "author": "blazember", "createdAt": "2020-07-16T10:11:54Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/server/ServerConnectionManager.java", "diffHunk": "@@ -73,15 +78,19 @@ default int connectionCount() {\n      * @param connection    - The connection to be registered\n      * @return True if the call was successful\n      */\n-    boolean register(Address remoteAddress, ServerConnection connection);\n+    boolean register(Address remoteAddress, ServerConnection connection, int streamId);", "originalCommit": "b123a55b9d52fca7d7c3010066c0538b5e6c7b21", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e0560a785fda52483699c80e465d28829dc69b65", "url": "https://github.com/hazelcast/hazelcast/commit/e0560a785fda52483699c80e465d28829dc69b65", "message": "Adds support for multiple connections between members\n\nHaving a single connection between members can lead to suboptimal\nperformance. On some environments like EC2 there is even a bandwidth\nlimit on a single flow (tcp connection) regardless of the actual\navailable network bandwidth.\n\nAlso under certain conditions like many clients and 2 member cluster,\nthe member to member connection needs to deal with all the backups of\nthe clients which can lead to an imbalance.\n\nWith multiple connections per members, these issues can be resolved.\n\nCurrently this is only available for members, but we'll probably apply\nthis approach as well to client to member connections at some point", "committedDate": "2020-07-16T11:14:41Z", "type": "forcePushed"}, {"oid": "0c0571523864351f896de84ed1db6ad4045bf382", "url": "https://github.com/hazelcast/hazelcast/commit/0c0571523864351f896de84ed1db6ad4045bf382", "message": "Adds support for multiple connections between members\n\nHaving a single connection between members can lead to suboptimal\nperformance. On some environments like EC2 there is even a bandwidth\nlimit on a single flow (tcp connection) regardless of the actual\navailable network bandwidth.\n\nAlso under certain conditions like many clients and 2 member cluster,\nthe member to member connection needs to deal with all the backups of\nthe clients which can lead to an imbalance.\n\nWith multiple connections per members, these issues can be resolved.\n\nCurrently this is only available for members, but we'll probably apply\nthis approach as well to client to member connections at some point", "committedDate": "2020-07-16T11:30:41Z", "type": "commit"}, {"oid": "0c0571523864351f896de84ed1db6ad4045bf382", "url": "https://github.com/hazelcast/hazelcast/commit/0c0571523864351f896de84ed1db6ad4045bf382", "message": "Adds support for multiple connections between members\n\nHaving a single connection between members can lead to suboptimal\nperformance. On some environments like EC2 there is even a bandwidth\nlimit on a single flow (tcp connection) regardless of the actual\navailable network bandwidth.\n\nAlso under certain conditions like many clients and 2 member cluster,\nthe member to member connection needs to deal with all the backups of\nthe clients which can lead to an imbalance.\n\nWith multiple connections per members, these issues can be resolved.\n\nCurrently this is only available for members, but we'll probably apply\nthis approach as well to client to member connections at some point", "committedDate": "2020-07-16T11:30:41Z", "type": "forcePushed"}]}