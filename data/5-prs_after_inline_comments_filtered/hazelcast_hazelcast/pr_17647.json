{"pr_number": 17647, "pr_title": "Fixes race in AbstractInvocationFuture#exceptionally", "pr_createdAt": "2020-09-30T11:19:56Z", "pr_url": "https://github.com/hazelcast/hazelcast/pull/17647", "timeline": [{"oid": "fe787a981400ee015292eec464aabac4ee9576c0", "url": "https://github.com/hazelcast/hazelcast/commit/fe787a981400ee015292eec464aabac4ee9576c0", "message": "Fixes race in AbstractInvocationFuture#exceptionally\n\nRegistration of any dependent action on a\nnon-complete AbstractInvocationFuture will result in\nstate being an instance of an inner class like\nAbstractInvocationFuture$WhenCompleteNode. When calling\nexceptionally, it is possible that this non-complete\nstate is observed and then the AbstractInvocationFuture\nwill erroneously be considered as completed because\nthe condition checks a previously observed value of\nstate along with its current isDone() status.", "committedDate": "2020-09-30T11:17:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQzMjYyNw==", "url": "https://github.com/hazelcast/hazelcast/pull/17647#discussion_r497432627", "bodyText": "It is wrong to resolve the state at this point and then use its value in a further condition. Instead, we should first check if AbstractInvocationFuture#isDone, similarly to all other CompletionStage API implementations.", "author": "vbekiaris", "createdAt": "2020-09-30T11:21:55Z", "path": "hazelcast/src/main/java/com/hazelcast/spi/impl/AbstractInvocationFuture.java", "diffHunk": "@@ -864,33 +879,19 @@ protected void unblockWhenComplete(@Nonnull final BiConsumer<? super V, ? super\n         }\n     }\n \n-    @Override\n-    public InternalCompletableFuture<V> exceptionally(@Nonnull Function<Throwable, ? extends V> fn) {\n-        requireNonNull(fn);\n+    private void unblockExceptionally(@Nonnull Function<Throwable, ? extends V> fn,\n+                                      InternalCompletableFuture<V> future) {\n         Object result = resolve(state);", "originalCommit": "fe787a981400ee015292eec464aabac4ee9576c0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQzMzc2NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17647#discussion_r497433764", "bodyText": "Here result may be not UNRESOLVED but another valid value of a non-complete future like Thread, AbstractInvocationFuture$WhenCompleteNode etc. The problem is that isDone() operates on field state but result reflects a potentially stale value of state field -> it is possible that result != UNRESOLVED and isDone() are both true and yet result is not the actual completion value.", "author": "vbekiaris", "createdAt": "2020-09-30T11:24:08Z", "path": "hazelcast/src/main/java/com/hazelcast/spi/impl/AbstractInvocationFuture.java", "diffHunk": "@@ -864,33 +879,19 @@ protected void unblockWhenComplete(@Nonnull final BiConsumer<? super V, ? super\n         }\n     }\n \n-    @Override\n-    public InternalCompletableFuture<V> exceptionally(@Nonnull Function<Throwable, ? extends V> fn) {\n-        requireNonNull(fn);\n+    private void unblockExceptionally(@Nonnull Function<Throwable, ? extends V> fn,\n+                                      InternalCompletableFuture<V> future) {\n         Object result = resolve(state);\n-        final InternalCompletableFuture<V> future = newCompletableFuture();\n-        for (; ; ) {\n-            if (result != UNRESOLVED && isDone()) {", "originalCommit": "fe787a981400ee015292eec464aabac4ee9576c0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}