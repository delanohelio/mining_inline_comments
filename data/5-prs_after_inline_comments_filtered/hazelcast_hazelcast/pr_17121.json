{"pr_number": 17121, "pr_title": "TenantControl - creating cache records must use tenant", "pr_createdAt": "2020-06-23T01:37:00Z", "pr_url": "https://github.com/hazelcast/hazelcast/pull/17121", "timeline": [{"oid": "daa86a079d9deeb8b429f10a7904ef1e7481c30b", "url": "https://github.com/hazelcast/hazelcast/commit/daa86a079d9deeb8b429f10a7904ef1e7481c30b", "message": "invoke tenant control when creating cache, so\nwhen factories get invoked, appropriate tenant environment is created", "committedDate": "2020-06-23T01:29:38Z", "type": "commit"}, {"oid": "08482d9750781fdd63799c79fd391b4c9c1336e0", "url": "https://github.com/hazelcast/hazelcast/commit/08482d9750781fdd63799c79fd391b4c9c1336e0", "message": "Merge remote-tracking branch 'upstream/3.12.z' into TENANT_CACHE_CREATE_FIX", "committedDate": "2020-06-23T01:42:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDEzNzQzMw==", "url": "https://github.com/hazelcast/hazelcast/pull/17121#discussion_r444137433", "bodyText": "use throw ExceptionUtil.rethrow(ex); instead here. If ex is already a runtime exception, it will be thrown as is, otherwise it will be wrapped in a HazelcastException.", "author": "vbekiaris", "createdAt": "2020-06-23T10:55:51Z", "path": "hazelcast/src/main/java/com/hazelcast/cache/impl/AbstractCacheRecordStore.java", "diffHunk": "@@ -162,53 +164,62 @@ public AbstractCacheRecordStore(String cacheNameWithPrefix, int partitionId, Nod\n             throw new CacheNotExistsException(\"Cache \" + cacheNameWithPrefix + \" is already destroyed or not created yet, on \"\n                     + nodeEngine.getLocalMember());\n         }\n-        this.eventJournalConfig = nodeEngine.getConfig().findCacheEventJournalConfig(cacheConfig.getName());\n-        this.evictionConfig = cacheConfig.getEvictionConfig();\n-        if (evictionConfig == null) {\n-            throw new IllegalStateException(\"Eviction config cannot be null!\");\n-        }\n-        this.wanReplicationEnabled = cacheService.isWanReplicationEnabled(cacheNameWithPrefix);\n-        this.disablePerEntryInvalidationEvents = cacheConfig.isDisablePerEntryInvalidationEvents();\n-        if (cacheConfig.isStatisticsEnabled()) {\n-            statistics = cacheService.createCacheStatIfAbsent(cacheNameWithPrefix);\n-        }\n-        if (cacheConfig.getCacheLoaderFactory() != null) {\n-            Factory<CacheLoader> cacheLoaderFactory = cacheConfig.getCacheLoaderFactory();\n-            injectDependencies(cacheLoaderFactory);\n-            cacheLoader = cacheLoaderFactory.create();\n-            injectDependencies(cacheLoader);\n-        }\n-        if (cacheConfig.getCacheWriterFactory() != null) {\n-            Factory<CacheWriter> cacheWriterFactory = cacheConfig.getCacheWriterFactory();\n-            injectDependencies(cacheWriterFactory);\n-            cacheWriter = cacheWriterFactory.create();\n-            injectDependencies(cacheWriter);\n-        }\n-        if (cacheConfig.getExpiryPolicyFactory() != null) {\n-            Factory<ExpiryPolicy> expiryPolicyFactory = cacheConfig.getExpiryPolicyFactory();\n-            injectDependencies(expiryPolicyFactory);\n-            defaultExpiryPolicy = expiryPolicyFactory.create();\n-            injectDependencies(defaultExpiryPolicy);\n-        } else {\n-            throw new IllegalStateException(\"Expiry policy factory cannot be null!\");\n-        }\n-\n-        this.cacheContext = cacheService.getOrCreateCacheContext(cacheNameWithPrefix);\n-        this.records = createRecordCacheMap();\n-        this.evictionChecker = createCacheEvictionChecker(evictionConfig.getSize(), evictionConfig.getMaximumSizePolicy());\n-        this.evictionPolicyEvaluator = createEvictionPolicyEvaluator(evictionConfig);\n-        this.evictionStrategy = createEvictionStrategy(evictionConfig);\n-        this.objectNamespace = CacheService.getObjectNamespace(cacheNameWithPrefix);\n-        this.persistWanReplicatedData = canPersistWanReplicatedData(cacheConfig, nodeEngine);\n-        this.cacheRecordFactory = new CacheRecordFactory(cacheConfig.getInMemoryFormat(), ss);\n-        this.valueComparator = getValueComparatorOf(cacheConfig.getInMemoryFormat());\n-        this.clearExpiredRecordsTask = cacheService.getExpirationManager().getTask();\n-\n-        injectDependencies(evictionPolicyEvaluator.getEvictionPolicyComparator());\n-        registerResourceIfItIsClosable(cacheWriter);\n-        registerResourceIfItIsClosable(cacheLoader);\n-        registerResourceIfItIsClosable(defaultExpiryPolicy);\n-        init();\n+        Closeable tenantContext = CacheConfigAccessor.getTenantControl(cacheConfig).setTenant(true);\n+        try {\n+            this.eventJournalConfig = nodeEngine.getConfig().findCacheEventJournalConfig(cacheConfig.getName());\n+            this.evictionConfig = cacheConfig.getEvictionConfig();\n+            if (evictionConfig == null) {\n+                throw new IllegalStateException(\"Eviction config cannot be null!\");\n+            }\n+            this.wanReplicationEnabled = cacheService.isWanReplicationEnabled(cacheNameWithPrefix);\n+            this.disablePerEntryInvalidationEvents = cacheConfig.isDisablePerEntryInvalidationEvents();\n+            if (cacheConfig.isStatisticsEnabled()) {\n+                statistics = cacheService.createCacheStatIfAbsent(cacheNameWithPrefix);\n+            }\n+            if (cacheConfig.getCacheLoaderFactory() != null) {\n+                Factory<CacheLoader> cacheLoaderFactory = cacheConfig.getCacheLoaderFactory();\n+                injectDependencies(cacheLoaderFactory);\n+                cacheLoader = cacheLoaderFactory.create();\n+                injectDependencies(cacheLoader);\n+            }\n+            if (cacheConfig.getCacheWriterFactory() != null) {\n+                Factory<CacheWriter> cacheWriterFactory = cacheConfig.getCacheWriterFactory();\n+                injectDependencies(cacheWriterFactory);\n+                cacheWriter = cacheWriterFactory.create();\n+                injectDependencies(cacheWriter);\n+            }\n+            if (cacheConfig.getExpiryPolicyFactory() != null) {\n+                Factory<ExpiryPolicy> expiryPolicyFactory = cacheConfig.getExpiryPolicyFactory();\n+                injectDependencies(expiryPolicyFactory);\n+                defaultExpiryPolicy = expiryPolicyFactory.create();\n+                injectDependencies(defaultExpiryPolicy);\n+            } else {\n+                throw new IllegalStateException(\"Expiry policy factory cannot be null!\");\n+            }\n+\n+            this.cacheContext = cacheService.getOrCreateCacheContext(cacheNameWithPrefix);\n+            this.records = createRecordCacheMap();\n+            this.evictionChecker = createCacheEvictionChecker(evictionConfig.getSize(), evictionConfig.getMaximumSizePolicy());\n+            this.evictionPolicyEvaluator = createEvictionPolicyEvaluator(evictionConfig);\n+            this.evictionStrategy = createEvictionStrategy(evictionConfig);\n+            this.objectNamespace = CacheService.getObjectNamespace(cacheNameWithPrefix);\n+            this.persistWanReplicatedData = canPersistWanReplicatedData(cacheConfig, nodeEngine);\n+            this.cacheRecordFactory = new CacheRecordFactory(cacheConfig.getInMemoryFormat(), ss);\n+            this.valueComparator = getValueComparatorOf(cacheConfig.getInMemoryFormat());\n+            this.clearExpiredRecordsTask = cacheService.getExpirationManager().getTask();\n+\n+            injectDependencies(evictionPolicyEvaluator.getEvictionPolicyComparator());\n+            registerResourceIfItIsClosable(cacheWriter);\n+            registerResourceIfItIsClosable(cacheLoader);\n+            registerResourceIfItIsClosable(defaultExpiryPolicy);\n+            init();\n+        } finally {\n+            try {\n+                tenantContext.close();\n+            } catch (IOException ex) {\n+                throw new RuntimeException(ex);", "originalCommit": "08482d9750781fdd63799c79fd391b4c9c1336e0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "17c413484339ec2d470ff292ed5a6f472bfb531f", "url": "https://github.com/hazelcast/hazelcast/commit/17c413484339ec2d470ff292ed5a6f472bfb531f", "message": "- using ExceptionUtils.rethrow() instead of throw RuntimeException()\n- moved some of constructor's functionality into a private method to comply with checkstyle rules", "committedDate": "2020-06-23T16:49:40Z", "type": "commit"}, {"oid": "308765aa5d0b96441f7cd804e15c56ac97766433", "url": "https://github.com/hazelcast/hazelcast/commit/308765aa5d0b96441f7cd804e15c56ac97766433", "message": "fixed failing test", "committedDate": "2020-06-23T20:17:30Z", "type": "commit"}]}