{"pr_number": 18013, "pr_title": "[IMDG-129] SQL: implementation of the ORDER BY clause", "pr_createdAt": "2020-12-28T11:12:59Z", "pr_url": "https://github.com/hazelcast/hazelcast/pull/18013", "timeline": [{"oid": "486c7ea21970440796b4b277e3b94ec39efbed23", "url": "https://github.com/hazelcast/hazelcast/commit/486c7ea21970440796b4b277e3b94ec39efbed23", "message": "Implemented IdentifiedDataSerializable in ReceiveSortMergePlanNode", "committedDate": "2021-01-22T13:49:38Z", "type": "commit"}, {"oid": "574c3e2ce09d51a5331e4f594a8dd29ee1cbcafa", "url": "https://github.com/hazelcast/hazelcast/commit/574c3e2ce09d51a5331e4f594a8dd29ee1cbcafa", "message": "Removed not used code", "committedDate": "2021-01-22T13:49:38Z", "type": "commit"}, {"oid": "5099351140e5def76667f88aa80e69526404ac4b", "url": "https://github.com/hazelcast/hazelcast/commit/5099351140e5def76667f88aa80e69526404ac4b", "message": "Minor improvement: replaced List with array", "committedDate": "2021-01-22T13:49:38Z", "type": "commit"}, {"oid": "7e77bab6acf6932f8c4242462666e952bb7beb9f", "url": "https://github.com/hazelcast/hazelcast/commit/7e77bab6acf6932f8c4242462666e952bb7beb9f", "message": "Fixed equals/hashCode methods", "committedDate": "2021-01-22T13:49:38Z", "type": "commit"}, {"oid": "f9156f1430c44775973138f61025313350a41bb3", "url": "https://github.com/hazelcast/hazelcast/commit/f9156f1430c44775973138f61025313350a41bb3", "message": "Simplified code", "committedDate": "2021-01-22T13:49:38Z", "type": "commit"}, {"oid": "e8c981fa1d72750010e38826a2b3b0330407475f", "url": "https://github.com/hazelcast/hazelcast/commit/e8c981fa1d72750010e38826a2b3b0330407475f", "message": "Fixed index scan creation\n\n1. Generate full scans when a filter exists\n2. Exclude full scans covered by lookups with the same collation\n3. Unit testing", "committedDate": "2021-01-22T13:49:38Z", "type": "commit"}, {"oid": "cde45cf36c81666db961d10651a1a0dc81b3bba0", "url": "https://github.com/hazelcast/hazelcast/commit/cde45cf36c81666db961d10651a1a0dc81b3bba0", "message": "Simplified unit test", "committedDate": "2021-01-22T13:49:38Z", "type": "commit"}, {"oid": "8fd1a96597279ec23e4406c7fe8c7188b33c76fb", "url": "https://github.com/hazelcast/hazelcast/commit/8fd1a96597279ec23e4406c7fe8c7188b33c76fb", "message": "Removed a leftover", "committedDate": "2021-01-22T13:49:38Z", "type": "commit"}, {"oid": "78e65cf016255e59f4dbfe2c094c6d4198f59b89", "url": "https://github.com/hazelcast/hazelcast/commit/78e65cf016255e59f4dbfe2c094c6d4198f59b89", "message": "Generalized fields collation\n\nUse List<Boolean> for fields collation instead of one boolean flag to\nprepare for [ASC, DESC] sortings in the future. The change is mostly\nneeded to keep the protocol unchanged in the future.", "committedDate": "2021-01-22T13:49:38Z", "type": "commit"}, {"oid": "64c8d3db3f49f67400f6a317d48fdbc1696d8401", "url": "https://github.com/hazelcast/hazelcast/commit/64c8d3db3f49f67400f6a317d48fdbc1696d8401", "message": "Generalized a unit test", "committedDate": "2021-01-22T13:49:38Z", "type": "commit"}, {"oid": "47c50b5038b336cd7a876f4f38f6ebe19d8dee5b", "url": "https://github.com/hazelcast/hazelcast/commit/47c50b5038b336cd7a876f4f38f6ebe19d8dee5b", "message": "Use NoPartitioning partitioner for the sorting unicast send", "committedDate": "2021-01-22T13:49:38Z", "type": "commit"}, {"oid": "a62bd901143c8df6d78d004eef10e4aad0aa321b", "url": "https://github.com/hazelcast/hazelcast/commit/a62bd901143c8df6d78d004eef10e4aad0aa321b", "message": "Minor: make the field package-private", "committedDate": "2021-01-22T13:49:38Z", "type": "commit"}, {"oid": "af00e7f418b414e154511aea1a7e05bd815eefea", "url": "https://github.com/hazelcast/hazelcast/commit/af00e7f418b414e154511aea1a7e05bd815eefea", "message": "Assert SingleValuePartitioner is used", "committedDate": "2021-01-22T13:49:38Z", "type": "commit"}, {"oid": "860c69cb99b3235cb53f3f36f47b411e601e7c2b", "url": "https://github.com/hazelcast/hazelcast/commit/860c69cb99b3235cb53f3f36f47b411e601e7c2b", "message": "NULL values handling", "committedDate": "2021-01-22T13:49:38Z", "type": "commit"}, {"oid": "c40ac7804296961cfcb0dc478698242d5d0b0b55", "url": "https://github.com/hazelcast/hazelcast/commit/c40ac7804296961cfcb0dc478698242d5d0b0b55", "message": "Improved error message on not supported ORDER BY", "committedDate": "2021-01-22T13:49:38Z", "type": "commit"}, {"oid": "4e01dfd54333b820ed48fd01a4b5767d17e940ef", "url": "https://github.com/hazelcast/hazelcast/commit/4e01dfd54333b820ed48fd01a4b5767d17e940ef", "message": "More tests for the Exec components", "committedDate": "2021-01-22T13:49:38Z", "type": "commit"}, {"oid": "47cbf545dfa74f47b7f0d3e7914d073ac9e5d87b", "url": "https://github.com/hazelcast/hazelcast/commit/47cbf545dfa74f47b7f0d3e7914d073ac9e5d87b", "message": "Simplified code", "committedDate": "2021-01-22T13:49:38Z", "type": "commit"}, {"oid": "a13bbf963766401020fa974cc68c8ed024c4c2b9", "url": "https://github.com/hazelcast/hazelcast/commit/a13bbf963766401020fa974cc68c8ed024c4c2b9", "message": "Fixed typos", "committedDate": "2021-01-22T13:49:38Z", "type": "commit"}, {"oid": "154514f77d99a5ec6a34d8be4bd96508a8d758d8", "url": "https://github.com/hazelcast/hazelcast/commit/154514f77d99a5ec6a34d8be4bd96508a8d758d8", "message": "Fixed checkstyle", "committedDate": "2021-01-22T13:49:39Z", "type": "commit"}, {"oid": "8807e668d4fa70a16702a04c3fa888c64a921632", "url": "https://github.com/hazelcast/hazelcast/commit/8807e668d4fa70a16702a04c3fa888c64a921632", "message": "Remove unnecessary code", "committedDate": "2021-01-22T13:49:39Z", "type": "commit"}, {"oid": "d6bddf682f05f5548007926e5256bc1ad311baaa", "url": "https://github.com/hazelcast/hazelcast/commit/d6bddf682f05f5548007926e5256bc1ad311baaa", "message": "Renamed class to ZeroPartitioner and implemented IdentifiedDataSerializable", "committedDate": "2021-01-22T13:50:36Z", "type": "commit"}, {"oid": "ed52a50c75cb7462044d28fc7d8a32c94ad5736a", "url": "https://github.com/hazelcast/hazelcast/commit/ed52a50c75cb7462044d28fc7d8a32c94ad5736a", "message": "Improved hashCode() calculation", "committedDate": "2021-01-22T13:50:36Z", "type": "commit"}, {"oid": "c756faaeb719e02d612435d070932458c9bcebe3", "url": "https://github.com/hazelcast/hazelcast/commit/c756faaeb719e02d612435d070932458c9bcebe3", "message": "Replicased List with int[]", "committedDate": "2021-01-22T13:50:36Z", "type": "commit"}, {"oid": "6d99e1140672b072630f81431f9fde8cf1cd2ee4", "url": "https://github.com/hazelcast/hazelcast/commit/6d99e1140672b072630f81431f9fde8cf1cd2ee4", "message": "Simplified code a bit", "committedDate": "2021-01-22T13:50:36Z", "type": "commit"}, {"oid": "f778cbea33ce14c86ac70c5be444ecb33000fb0a", "url": "https://github.com/hazelcast/hazelcast/commit/f778cbea33ce14c86ac70c5be444ecb33000fb0a", "message": "Optimized code a bit", "committedDate": "2021-01-22T13:50:36Z", "type": "commit"}, {"oid": "e0f6249453e4ac55f5c59079ed014b8b31f80ced", "url": "https://github.com/hazelcast/hazelcast/commit/e0f6249453e4ac55f5c59079ed014b8b31f80ced", "message": "Use singleton", "committedDate": "2021-01-22T13:50:36Z", "type": "commit"}, {"oid": "6fc55b7c022c686d5128ee091dbf20d0e9c5a0ed", "url": "https://github.com/hazelcast/hazelcast/commit/6fc55b7c022c686d5128ee091dbf20d0e9c5a0ed", "message": "Order NULL values before any other values in IndexInFilter and tests", "committedDate": "2021-01-22T13:50:36Z", "type": "commit"}, {"oid": "e890835d91f1d04a2c6769e284743233a1a4a1c1", "url": "https://github.com/hazelcast/hazelcast/commit/e890835d91f1d04a2c6769e284743233a1a4a1c1", "message": "Return back to the generic error message", "committedDate": "2021-01-22T13:50:36Z", "type": "commit"}, {"oid": "adf0d0524a0a8f993b3a0edc5345fb531a18a533", "url": "https://github.com/hazelcast/hazelcast/commit/adf0d0524a0a8f993b3a0edc5345fb531a18a533", "message": "Cleanup unit tests on every run to avoid leftover indexes", "committedDate": "2021-01-22T13:50:36Z", "type": "commit"}, {"oid": "c891b671af094f54d2a67296eaec5efa0c5cb0d2", "url": "https://github.com/hazelcast/hazelcast/commit/c891b671af094f54d2a67296eaec5efa0c5cb0d2", "message": "Checkstyle fixes", "committedDate": "2021-01-22T13:50:36Z", "type": "commit"}, {"oid": "1c33920249673a1a67456c8504ef2e095febdddb", "url": "https://github.com/hazelcast/hazelcast/commit/1c33920249673a1a67456c8504ef2e095febdddb", "message": "Spotbugs fixes", "committedDate": "2021-01-22T13:50:36Z", "type": "commit"}, {"oid": "06ffa2157ed2f6367e78777bc0291938c850349b", "url": "https://github.com/hazelcast/hazelcast/commit/06ffa2157ed2f6367e78777bc0291938c850349b", "message": "Fixed Calcite rules and a few tests", "committedDate": "2021-01-22T13:50:36Z", "type": "commit"}, {"oid": "3f0a9d01797378c0394677bef981716abfe023fc", "url": "https://github.com/hazelcast/hazelcast/commit/3f0a9d01797378c0394677bef981716abfe023fc", "message": "Fixed a test", "committedDate": "2021-01-22T13:50:36Z", "type": "commit"}, {"oid": "92489a78f2f2fe2a10fec7cc4fd28af024d016c9", "url": "https://github.com/hazelcast/hazelcast/commit/92489a78f2f2fe2a10fec7cc4fd28af024d016c9", "message": "Simplified code and revised getPhysicalRelsFromSubset", "committedDate": "2021-01-22T13:53:39Z", "type": "commit"}, {"oid": "f7ac2bad0ceea5286ae90749d3ecd56e46176ffc", "url": "https://github.com/hazelcast/hazelcast/commit/f7ac2bad0ceea5286ae90749d3ecd56e46176ffc", "message": "Minor change for EE testing", "committedDate": "2021-01-22T13:53:39Z", "type": "commit"}, {"oid": "3899dabddb1f4890abeb15d43d1f8ff865920606", "url": "https://github.com/hazelcast/hazelcast/commit/3899dabddb1f4890abeb15d43d1f8ff865920606", "message": "Added our own ExpandConversionRule to overcome Calcite's bug", "committedDate": "2021-01-22T13:53:39Z", "type": "commit"}, {"oid": "3899dabddb1f4890abeb15d43d1f8ff865920606", "url": "https://github.com/hazelcast/hazelcast/commit/3899dabddb1f4890abeb15d43d1f8ff865920606", "message": "Added our own ExpandConversionRule to overcome Calcite's bug", "committedDate": "2021-01-22T13:53:39Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTYwMzE0MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549603141", "bodyText": "A single flag for the whole index means that we will not be able to support multi-direction scans in the future without breaking the backward compatibility. Perhaps it makes sense to use List<Boolean>, where every element is the direction of the scan of an individual component. Now they will be either all true, true, ... or false, false, ....\nBut in the future, we will be able to add the multidirectional scan by simply changing the relevant Exec class, and without breaking the protocol.", "author": "devozerov", "createdAt": "2020-12-29T07:45:25Z", "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/opt/physical/MapIndexScanPhysicalRel.java", "diffHunk": "@@ -45,6 +45,7 @@\n     private final List<QueryDataType> converterTypes;\n     private final RexNode indexExp;\n     private final RexNode remainderExp;\n+    private final boolean descending;", "originalCommit": "ab8c4e0d3ca1dac7fe4a229dc4a8c70c8a05d864", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTY4MDgxNw==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549680817", "bodyText": "I'm not sure that I got the idea how the List<Boolean> will help with the multidirectional scan. My understanding is that if we want to support [a ASC, b DESC] ordering on the index level, we will have to extend our SORTED index configuration and explicitly specify this collation so that the entries will be stored pre-sorted. Such index will also support [a DESC, b ASC] sorting. In both cases, we don't need a per component specification of the ordering. This is why I'm not sure we have to add the List<Boolean>. @devozerov , can you please elaborate more on the idea?", "author": "petrpleshachkov", "createdAt": "2020-12-29T12:08:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTYwMzE0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTcyMjQ3NA==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549722474", "bodyText": "Consider that we have an index [a ASC, b ASC]. In theory, it should be possible to use it to do ORDER BY a ASC, b DESC. We do not support it now, but it should not be difficult to add such capability to our indexing infrastructure. If we add such a feature, it would not be possible to describe the desired direction with a single flag. Instead, we will pass a ASC, b DESC, which could be encoded as List {false, true}.", "author": "devozerov", "createdAt": "2020-12-29T14:22:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTYwMzE0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIxODM2MA==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r551218360", "bodyText": "Added in 858e478", "author": "petrpleshachkov", "createdAt": "2021-01-04T10:01:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTYwMzE0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTYwMzgzMQ==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549603831", "bodyText": "Descending flag (or flags) should be added to explainTerms. Otherwise, Calcite will treat nodes with different flag values as equivalent nodes, and it is hard to predict the consequences of it. Also, the signature will be used for EXPLAIN in the future, and flag value would be useful there as well.", "author": "devozerov", "createdAt": "2020-12-29T07:47:50Z", "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/opt/physical/MapIndexScanPhysicalRel.java", "diffHunk": "@@ -103,9 +111,9 @@ public void visit(PhysicalRelVisitor visitor) {\n     @Override\n     public RelWriter explainTerms(RelWriter pw) {\n         return super.explainTerms(pw)\n-           .item(\"index\", index.getName())\n-           .item(\"indexExp\", indexExp)\n-           .item(\"remainderExp\", remainderExp);\n+            .item(\"index\", index.getName())", "originalCommit": "ab8c4e0d3ca1dac7fe4a229dc4a8c70c8a05d864", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTY4MTYwOQ==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549681609", "bodyText": "Addressed in c364ce9", "author": "petrpleshachkov", "createdAt": "2020-12-29T12:11:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTYwMzgzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTYwNDI2Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549604262", "bodyText": "Minor note: it seems that your IDEA adds indents automatically whenever the class is opened. It is better to disable this option because it makes PRs bigger and adds unnecessary entries to the file history.", "author": "devozerov", "createdAt": "2020-12-29T07:49:29Z", "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/opt/physical/MapScanPhysicalRule.java", "diffHunk": "@@ -40,8 +40,8 @@\n \n     private MapScanPhysicalRule() {\n         super(\n-            OptUtils.single(MapScanLogicalRel.class, HazelcastConventions.LOGICAL),\n-            MapScanPhysicalRule.class.getSimpleName()\n+                OptUtils.single(MapScanLogicalRel.class, HazelcastConventions.LOGICAL),", "originalCommit": "ab8c4e0d3ca1dac7fe4a229dc4a8c70c8a05d864", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTY2NDQxNQ==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549664415", "bodyText": "Fixed in 7c3b680", "author": "petrpleshachkov", "createdAt": "2020-12-29T11:07:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTYwNDI2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTYwNTkyNw==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549605927", "bodyText": "Perhaps we should add unit tests for the reverse direction in IndexEqualsFilterIterationTest, IndexInFilterIterationTest and IndexRangeFilterIterationTest. These are the isolated tests for iteration over entries for the given filter.", "author": "devozerov", "createdAt": "2020-12-29T07:55:54Z", "path": "hazelcast/src/test/java/com/hazelcast/sql/impl/exec/scan/index/IndexEqualsFilterIterationTest.java", "diffHunk": "@@ -54,27 +54,27 @@ private void checkIteratorSimple(IndexType indexType) {\n         ExpressionEvalContext evalContext = SimpleExpressionEvalContext.create();\n \n         // Check missing value.\n-        checkIterator(new IndexEqualsFilter(intValue(1)).getEntries(index, evalContext));\n+        checkIterator(new IndexEqualsFilter(intValue(1)).getEntries(index, false, evalContext));", "originalCommit": "ab8c4e0d3ca1dac7fe4a229dc4a8c70c8a05d864", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTk2NjUwNQ==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549966505", "bodyText": "Added tests in the 4b9dd4e", "author": "petrpleshachkov", "createdAt": "2020-12-30T07:02:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTYwNTkyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTYwNjM0Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549606342", "bodyText": "Tests for \"descending=true\"?", "author": "devozerov", "createdAt": "2020-12-29T07:57:17Z", "path": "hazelcast/src/test/java/com/hazelcast/sql/impl/exec/scan/index/MapIndexScanExecTest.java", "diffHunk": "@@ -405,20 +405,21 @@ private void checkScan(\n         List<Integer> projects = Collections.singletonList(0);\n \n         MapIndexScanExec exec = new MapIndexScanExec(\n-            1,\n-            getMapContainer(map),\n-            partitions,\n-            GenericQueryTargetDescriptor.DEFAULT,\n-            GenericQueryTargetDescriptor.DEFAULT,\n-            fieldPaths,\n-            fieldTypes,\n-            projects,\n-            remainderFilter,\n-            getSerializationService(member),\n-            indexName,\n-            expectedComponentCount,\n-            indexFilter,\n-            converterTypes\n+                1,\n+                getMapContainer(map),\n+                partitions,\n+                GenericQueryTargetDescriptor.DEFAULT,\n+                GenericQueryTargetDescriptor.DEFAULT,\n+                fieldPaths,\n+                fieldTypes,\n+                projects,\n+                remainderFilter,\n+                getSerializationService(member),\n+                indexName,\n+                expectedComponentCount,\n+                indexFilter,\n+                converterTypes,\n+                false", "originalCommit": "ab8c4e0d3ca1dac7fe4a229dc4a8c70c8a05d864", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQzNTIxNA==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r550435214", "bodyText": "@devozerov , I took a look more close at the MapIndexScanExecTest and I'm not sure the test is correct. There is a checkScan method that is supposed to check in the end the returned results. But instead, it has only the below lines that assert nothing.\n        results.sort(Integer::compareTo);\n        expectedResults0.sort(Integer::compareTo);\n\nMoreover, we run the scan only on the local partitions and we actually cannot assume what is the expected result, because the local partitions contain only a part of the entries.\nCan you please clarify this?", "author": "petrpleshachkov", "createdAt": "2020-12-31T09:07:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTYwNjM0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ1Mzk3MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r550453971", "bodyText": "Perhaps, this is a bug.", "author": "devozerov", "createdAt": "2020-12-31T10:39:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTYwNjM0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIyNTA2OA==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r551225068", "bodyText": "Generalized the test in 07be5e9\nCreated an issue to fix the tests logic #18030", "author": "petrpleshachkov", "createdAt": "2021-01-04T10:15:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTYwNjM0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTYwNjk4OA==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549606988", "bodyText": "Why do we need AllFieldRowPartitioner for sorting that always sends data to a single member? Perhaps this class should not be part of the PR.", "author": "devozerov", "createdAt": "2020-12-29T07:59:43Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/partitioner/AllFieldsRowPartitioner.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.partitioner;\n+\n+import com.hazelcast.internal.serialization.InternalSerializationService;\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.sql.impl.row.Row;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Hash function which uses all row columns to calculate the hash.\n+ */\n+public class AllFieldsRowPartitioner extends AbstractFieldsRowPartitioner {", "originalCommit": "ab8c4e0d3ca1dac7fe4a229dc4a8c70c8a05d864", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI0MTA2Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r551241067", "bodyText": "Removed as part of the ba2cf9f", "author": "petrpleshachkov", "createdAt": "2021-01-04T10:45:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTYwNjk4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTYwNzY0Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549607642", "bodyText": "Same as AllFieldsRowPartitioner - this should not be needed for sorting that always send data to a single member AFAIU.", "author": "devozerov", "createdAt": "2020-12-29T08:02:37Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/partitioner/AbstractFieldsRowPartitioner.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.partitioner;\n+\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.internal.serialization.InternalSerializationService;\n+import com.hazelcast.internal.util.HashUtil;\n+import com.hazelcast.sql.impl.row.Row;\n+\n+import static com.hazelcast.internal.serialization.impl.SerializationUtil.EMPTY_PARTITIONING_STRATEGY;\n+\n+/**\n+ * Partitioner that calculates row partition based on row field values.\n+ */\n+public abstract class AbstractFieldsRowPartitioner implements RowPartitioner {", "originalCommit": "ab8c4e0d3ca1dac7fe4a229dc4a8c70c8a05d864", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI0MTI2OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r551241269", "bodyText": "Removed as part of the ba2cf9f", "author": "petrpleshachkov", "createdAt": "2021-01-04T10:45:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTYwNzY0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTYwODExNw==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549608117", "bodyText": "Do we support null values?\nAFAIK Calcite also supports NULL FIRST / NULLS LAST. Do we support it?", "author": "devozerov", "createdAt": "2020-12-29T08:04:24Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/sort/SortKeyComparator.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.exec.sort;\n+\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+\n+import java.util.Comparator;\n+import java.util.List;\n+\n+/**\n+ * Comparator fot the sort key.\n+ */\n+@SuppressFBWarnings(value = \"SE_COMPARATOR_SHOULD_BE_SERIALIZABLE\", justification = \"Never serialized\")\n+public class SortKeyComparator implements Comparator<SortKey> {\n+    /** List of ascending collations. */\n+    private final List<Boolean> ascs;\n+\n+    public SortKeyComparator(List<Boolean> ascs) {\n+        this.ascs = ascs;\n+    }\n+\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    @Override\n+    public int compare(SortKey o1, SortKey o2) {\n+        for (int i = 0; i < ascs.size(); i++) {\n+            boolean asc = ascs.get(i);\n+\n+            Object item1 = o1.getKey().get(i);\n+            Object item2 = o2.getKey().get(i);\n+\n+            Comparable item1Comp = (Comparable) item1;\n+            Comparable item2Comp = (Comparable) item2;\n+\n+            int res = asc ? item1Comp.compareTo(item2Comp) : item2Comp.compareTo(item1Comp);", "originalCommit": "ab8c4e0d3ca1dac7fe4a229dc4a8c70c8a05d864", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTg2MDgxNw==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r551860817", "bodyText": "Addressed in 421a841 In this release we support only default ordering strategy defined by the index, that is NULL is less than any other value. We don't support explicit NULL FIRST / NULL_LAST in the ORDER BY clause.", "author": "petrpleshachkov", "createdAt": "2021-01-05T10:59:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTYwODExNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTYxMjQzNA==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549612434", "bodyText": "Why do we pass false here? Wouldn't it break the expected collation?", "author": "devozerov", "createdAt": "2020-12-29T08:19:19Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/scan/index/IndexInFilter.java", "diffHunk": "@@ -168,7 +168,7 @@ private LazyIterator(InternalIndex index, ExpressionEvalContext evalContext, Col\n             while (filterIterator.hasNext()) {\n                 IndexFilter filter = filterIterator.next();\n \n-                Iterator<QueryableEntry> iterator = filter.getEntries(index, evalContext);\n+                Iterator<QueryableEntry> iterator = filter.getEntries(index, false, evalContext);", "originalCommit": "ab8c4e0d3ca1dac7fe4a229dc4a8c70c8a05d864", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTYzMzQzMg==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549633432", "bodyText": "Fixed in the 5abe68e", "author": "petrpleshachkov", "createdAt": "2020-12-29T09:28:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTYxMjQzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTYxMzA4NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549613085", "bodyText": "Perhaps the descending flag should be propagated to the index iterator, otherwise, we may lose the collation. Do we have tests that ensure that the values returned from different index lookups (equals, in, range) follow the expected collation?", "author": "devozerov", "createdAt": "2020-12-29T08:21:58Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/scan/index/IndexEqualsFilter.java", "diffHunk": "@@ -49,7 +49,7 @@ public IndexFilterValue getValue() {\n     }\n \n     @Override\n-    public Iterator<QueryableEntry> getEntries(InternalIndex index, ExpressionEvalContext evalContext) {\n+    public Iterator<QueryableEntry> getEntries(InternalIndex index, boolean descending, ExpressionEvalContext evalContext) {", "originalCommit": "ab8c4e0d3ca1dac7fe4a229dc4a8c70c8a05d864", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTY3NDUxOA==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549674518", "bodyText": "The index.getSqlRecordIterator(value) returns entries with the same index values so that they're already pre-sorted descending and ascending. This is why we don't propagate the descending flag downwards to the index.", "author": "petrpleshachkov", "createdAt": "2020-12-29T11:45:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTYxMzA4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTYxMzIzNg==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549613236", "bodyText": "Do we need limit in this PR, provided that LIMIT/OFFSET is not supported yet?", "author": "devozerov", "createdAt": "2020-12-29T08:22:28Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/sort/MergeSort.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.exec.sort;\n+\n+import com.hazelcast.sql.impl.row.Row;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.PriorityQueue;\n+import java.util.Set;\n+\n+/**\n+ * An utility class to perform merge sort with min-heap.\n+ */\n+public class MergeSort {\n+    /** Constant for unlimited number of rows. */\n+    public static final int UNLIMITED = 0;\n+\n+    /** Sources. */\n+    private final MergeSortSource[] sources;\n+\n+    /** Current items. */\n+    private final PriorityQueue<SortKey> heap;\n+\n+    /** Optional limit on the number of returned results. */\n+    private final int limit;", "originalCommit": "ab8c4e0d3ca1dac7fe4a229dc4a8c70c8a05d864", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTYzNTA5Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549635096", "bodyText": "The leftover, removed in the 31db685", "author": "petrpleshachkov", "createdAt": "2020-12-29T09:33:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTYxMzIzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTYxMzMyMA==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549613320", "bodyText": "Minor: perhaps Object[] could be a slightly better choice here because there could be plenty of SortKey created leading to big memory consumption.", "author": "devozerov", "createdAt": "2020-12-29T08:22:48Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/sort/SortKey.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.exec.sort;\n+\n+import java.util.List;\n+\n+/**\n+ * Single sort key.\n+ */\n+public class SortKey {\n+    /** The key */\n+    private final List<Object> key;", "originalCommit": "ab8c4e0d3ca1dac7fe4a229dc4a8c70c8a05d864", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTY0MDMzMA==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549640330", "bodyText": "Addressed in the c07a1f1", "author": "petrpleshachkov", "createdAt": "2020-12-29T09:50:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTYxMzMyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTYxNDg1NA==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549614854", "bodyText": "As mentioned in the other comment, it seems strange that the Iterator<QueryableEntry> getSqlRecordIterator(Comparable value) overload doesn't take descending as an argument. Or is it because EqualsFilter always has values for all index components, and it is guaranteed that returned entries will have the same values for all columns of the desired collation?", "author": "devozerov", "createdAt": "2020-12-29T08:27:43Z", "path": "hazelcast/src/main/java/com/hazelcast/query/impl/IndexStore.java", "diffHunk": "@@ -127,9 +127,12 @@\n     Set<QueryableEntry> evaluate(Predicate predicate, TypeConverter converter);\n \n     /**\n+     * @param descending whether the entries should come in the descending order.\n+     *                   {@code true} means a descending order,\n+     *                   {@code false} means an ascending order.\n      * @return iterator over all index entries\n      */\n-    Iterator<QueryableEntry> getSqlRecordIterator();\n+    Iterator<QueryableEntry> getSqlRecordIterator(boolean descending);", "originalCommit": "ab8c4e0d3ca1dac7fe4a229dc4a8c70c8a05d864", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTY2MTcxNg==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549661716", "bodyText": "The Iterator<QueryableEntry> getSqlRecordIterator(Comparable value) is used only for all index key components and in this case, the ordering is not needed since all the values are equal.", "author": "petrpleshachkov", "createdAt": "2020-12-29T10:58:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTYxNDg1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTYxNTI3Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549615276", "bodyText": "Perhaps we need tests for unsupported features (LIMIT/OFFSET, NULLS FIRST/LAST)", "author": "devozerov", "createdAt": "2020-12-29T08:29:05Z", "path": "hazelcast-sql-core/src/test/java/com/hazelcast/sql/impl/calcite/parse/ParserOperationsTest.java", "diffHunk": "@@ -97,14 +106,6 @@ public void testUnsupportedWhereScalar() {\n         );\n     }\n \n-    @Test\n-    public void testUnsupportedOrderBy() {", "originalCommit": "ab8c4e0d3ca1dac7fe4a229dc4a8c70c8a05d864", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTg4NzQ3MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r551887471", "bodyText": "Added in 5ac898c", "author": "petrpleshachkov", "createdAt": "2021-01-05T11:56:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTYxNTI3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTYxNTc1MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549615751", "bodyText": "Do we handle unsupported parts of the ORDER BY (LIMIT/OFFSET, NULLS FIRST/LAST)?", "author": "devozerov", "createdAt": "2020-12-29T08:30:58Z", "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/parse/UnsupportedOperationVisitor.java", "diffHunk": "@@ -301,10 +305,6 @@ private void processCall(SqlCall call) {\n     }\n \n     private void processSelect(SqlSelect select) {\n-        if (select.hasOrderBy()) {", "originalCommit": "ab8c4e0d3ca1dac7fe4a229dc4a8c70c8a05d864", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTY0ODQxNA==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r555648414", "bodyText": "We have unit tests for the not supported parts 5ac898c\nLIMIT/OFFSET will come in the next PR.", "author": "petrpleshachkov", "createdAt": "2021-01-12T09:59:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTYxNTc1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTcyMzQ1OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549723459", "bodyText": "This change will not be needed if we remove AllFieldsRowPartitioner, which, in turn, should not be needed for this PR either.", "author": "devozerov", "createdAt": "2020-12-29T14:25:25Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/serialization/impl/SerializationUtil.java", "diffHunk": "@@ -54,7 +54,7 @@\n \n public final class SerializationUtil {\n \n-    static final PartitioningStrategy EMPTY_PARTITIONING_STRATEGY = new EmptyPartitioningStrategy();\n+    public static final PartitioningStrategy EMPTY_PARTITIONING_STRATEGY = new EmptyPartitioningStrategy();", "originalCommit": "c364ce930090559c002db51c124c8f048a22192c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI1ODMzMg==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r551258332", "bodyText": "Addressed in cd3befd", "author": "petrpleshachkov", "createdAt": "2021-01-04T11:20:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTcyMzQ1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTcyNDY4Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549724682", "bodyText": "Why do we use only index to check for equality? This violates the semantics of SortKeyComparator.", "author": "devozerov", "createdAt": "2020-12-29T14:28:57Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/sort/SortKey.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.exec.sort;\n+\n+/**\n+ * Single sort key.\n+ */\n+public class SortKey {\n+    /** The key */\n+    private final Object[] key;\n+\n+    /** Index to make rows unique. */\n+    private final long index;\n+\n+    public SortKey(Object[] key, long index) {\n+        this.key = key;\n+        this.index = index;\n+    }\n+\n+    public Object[] getKey() {\n+        return key;\n+    }\n+\n+    public long getIndex() {\n+        return index;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Long.hashCode(index);\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj instanceof SortKey) {\n+            SortKey other = (SortKey) obj;\n+\n+            return index == other.index;", "originalCommit": "c364ce930090559c002db51c124c8f048a22192c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQyNTI2MA==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r550425260", "bodyText": "Fixed in 6844874", "author": "petrpleshachkov", "createdAt": "2020-12-31T08:15:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTcyNDY4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTcyNDk1Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549724953", "bodyText": "boolean[] could be a better choice from the performance perspective since this is a pretty sensitive place.", "author": "devozerov", "createdAt": "2020-12-29T14:29:46Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/sort/SortKeyComparator.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.exec.sort;\n+\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+\n+import java.util.Comparator;\n+import java.util.List;\n+\n+/**\n+ * Comparator fot the sort key.\n+ */\n+@SuppressFBWarnings(value = \"SE_COMPARATOR_SHOULD_BE_SERIALIZABLE\", justification = \"Never serialized\")\n+public class SortKeyComparator implements Comparator<SortKey> {\n+    /** List of ascending collations. */\n+    private final List<Boolean> ascs;", "originalCommit": "c364ce930090559c002db51c124c8f048a22192c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQyMjA2NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r550422065", "bodyText": "Improved in 6c035fb", "author": "petrpleshachkov", "createdAt": "2020-12-31T07:56:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTcyNDk1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTcyNTU4NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549725585", "bodyText": "limit is not used.", "author": "devozerov", "createdAt": "2020-12-29T14:31:45Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/sort/MergeSort.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.exec.sort;\n+\n+import com.hazelcast.sql.impl.row.Row;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.PriorityQueue;\n+import java.util.Set;\n+\n+/**\n+ * An utility class to perform merge sort with min-heap.\n+ */\n+public class MergeSort {\n+    /** Constant for unlimited number of rows. */\n+    public static final int UNLIMITED = 0;\n+\n+    /** Sources. */\n+    private final MergeSortSource[] sources;\n+\n+    /** Current items. */\n+    private final PriorityQueue<SortKey> heap;\n+\n+    /** Sources which are not in the heap yet. */\n+    private final Set<Integer> missingSourceIndexes = new HashSet<>();\n+\n+    /** Whether the sorting is finished. */\n+    private boolean done;\n+\n+    public MergeSort(MergeSortSource[] sources, SortKeyComparator comparator) {\n+        this(sources, comparator, UNLIMITED);\n+    }\n+\n+    @SuppressFBWarnings(value = \"EI_EXPOSE_REP2\", justification = \"This is an internal class\")\n+    public MergeSort(MergeSortSource[] sources, SortKeyComparator comparator, int limit) {", "originalCommit": "c364ce930090559c002db51c124c8f048a22192c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQxOTA5Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r550419093", "bodyText": "Removed in 399bc6d", "author": "petrpleshachkov", "createdAt": "2020-12-31T07:38:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTcyNTU4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTcyNjU3MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549726571", "bodyText": "Class doesn't implement IdentifiedDataSerializable.", "author": "devozerov", "createdAt": "2020-12-29T14:34:49Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/plan/node/io/ReceiveSortMergePlanNode.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.plan.node.io;\n+\n+import com.hazelcast.internal.serialization.impl.SerializationUtil;\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.plan.node.PlanNodeSchema;\n+import com.hazelcast.sql.impl.plan.node.ZeroInputPlanNode;\n+import com.hazelcast.sql.impl.plan.node.PlanNodeVisitor;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * Physical node which receives from remote stripes and performs sort-merge.\n+ */\n+@SuppressWarnings(\"rawtypes\")\n+public class ReceiveSortMergePlanNode extends ZeroInputPlanNode implements EdgeAwarePlanNode {", "originalCommit": "c364ce930090559c002db51c124c8f048a22192c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQxODM0Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r550418342", "bodyText": "Fixed in e0c3e81", "author": "petrpleshachkov", "createdAt": "2020-12-31T07:34:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTcyNjU3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTcyNjgwMg==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549726802", "bodyText": "Is it ok that fieldTypes are not used in equals/hashCode?", "author": "devozerov", "createdAt": "2020-12-29T14:35:27Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/plan/node/io/ReceiveSortMergePlanNode.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.plan.node.io;\n+\n+import com.hazelcast.internal.serialization.impl.SerializationUtil;\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.plan.node.PlanNodeSchema;\n+import com.hazelcast.sql.impl.plan.node.ZeroInputPlanNode;\n+import com.hazelcast.sql.impl.plan.node.PlanNodeVisitor;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * Physical node which receives from remote stripes and performs sort-merge.\n+ */\n+@SuppressWarnings(\"rawtypes\")\n+public class ReceiveSortMergePlanNode extends ZeroInputPlanNode implements EdgeAwarePlanNode {\n+    /** Edge iD. */\n+    private int edgeId;\n+\n+    /** Field types. */\n+    private List<QueryDataType> fieldTypes;\n+\n+    /** Expressions to be used for sorting. */\n+    private List<Expression> expressions;\n+\n+    /** Sort directions. */\n+    private List<Boolean> ascs;\n+\n+    public ReceiveSortMergePlanNode() {\n+        // No-op.\n+    }\n+\n+    public ReceiveSortMergePlanNode(\n+            int id,\n+            int edgeId,\n+            List<QueryDataType> fieldTypes,\n+            List<Expression> expressions,\n+            List<Boolean> ascs\n+    ) {\n+        super(id);\n+\n+        this.edgeId = edgeId;\n+        this.fieldTypes = fieldTypes;\n+        this.expressions = expressions;\n+        this.ascs = ascs;\n+    }\n+\n+    public List<Expression> getExpressions() {\n+        return expressions;\n+    }\n+\n+    public List<Boolean> getAscs() {\n+        return ascs;\n+    }\n+\n+    @Override\n+    public int getEdgeId() {\n+        return edgeId;\n+    }\n+\n+    @Override\n+    public boolean isSender() {\n+        return false;\n+    }\n+\n+    @Override\n+    public void visit(PlanNodeVisitor visitor) {\n+        visitor.onReceiveSortMergeNode(this);\n+    }\n+\n+    @Override\n+    public PlanNodeSchema getSchema0() {\n+        return new PlanNodeSchema(fieldTypes);\n+    }\n+\n+    @Override\n+    public void writeData0(ObjectDataOutput out) throws IOException {\n+        out.writeInt(edgeId);\n+        SerializationUtil.writeList(fieldTypes, out);\n+        out.writeObject(expressions);\n+        out.writeObject(ascs);\n+    }\n+\n+    @Override\n+    public void readData0(ObjectDataInput in) throws IOException {\n+        edgeId = in.readInt();\n+        fieldTypes = SerializationUtil.readList(in);\n+        expressions = in.readObject();\n+        ascs = in.readObject();\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(id, edgeId, expressions, ascs);", "originalCommit": "c364ce930090559c002db51c124c8f048a22192c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQxODI1Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r550418257", "bodyText": "Fixed in a4b6a61", "author": "petrpleshachkov", "createdAt": "2020-12-31T07:33:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTcyNjgwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTcyNjk1NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549726955", "bodyText": "Class doesn't implement IdentifiedDataSerializable.", "author": "devozerov", "createdAt": "2020-12-29T14:35:48Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/plan/node/io/UnicastSendPlanNode.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.plan.node.io;\n+\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.sql.impl.plan.node.PlanNode;\n+import com.hazelcast.sql.impl.plan.node.UniInputPlanNode;\n+import com.hazelcast.sql.impl.partitioner.RowPartitioner;\n+import com.hazelcast.sql.impl.plan.node.PlanNodeVisitor;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+\n+/**\n+ * Node which unicasts data to remote stripes.\n+ */\n+public class UnicastSendPlanNode extends UniInputPlanNode implements EdgeAwarePlanNode {", "originalCommit": "c364ce930090559c002db51c124c8f048a22192c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDI5NTY2NA==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r550295664", "bodyText": "Fixed in 6741c52.\nand e0c3e81", "author": "petrpleshachkov", "createdAt": "2020-12-30T19:00:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTcyNjk1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTcyODEyNg==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549728126", "bodyText": "The partitioner is not used, which indicates an incorrect implementation of the CreateExecPlanNodeVisitor.onUnicastSendNode.", "author": "devozerov", "createdAt": "2020-12-29T14:38:58Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/plan/node/io/UnicastSendPlanNode.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.plan.node.io;\n+\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.sql.impl.plan.node.PlanNode;\n+import com.hazelcast.sql.impl.plan.node.UniInputPlanNode;\n+import com.hazelcast.sql.impl.partitioner.RowPartitioner;\n+import com.hazelcast.sql.impl.plan.node.PlanNodeVisitor;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+\n+/**\n+ * Node which unicasts data to remote stripes.\n+ */\n+public class UnicastSendPlanNode extends UniInputPlanNode implements EdgeAwarePlanNode {\n+    /** Edge ID. */\n+    private int edgeId;\n+\n+    /** Partition hasher (get partition hash from row). */\n+    private RowPartitioner partitioner;\n+\n+    public UnicastSendPlanNode() {\n+        // No-op.\n+    }\n+\n+    public UnicastSendPlanNode(int id, PlanNode upstream, int edgeId, RowPartitioner partitioner) {\n+        super(id, upstream);\n+\n+        this.edgeId = edgeId;\n+        this.partitioner = partitioner;\n+    }\n+\n+    public RowPartitioner getPartitioner() {", "originalCommit": "c364ce930090559c002db51c124c8f048a22192c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI2NDY2Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r551264663", "bodyText": "Assert that SingleValuePartitioner is used f47bac3\nThis part will change when we implement a more generic plan generation.", "author": "petrpleshachkov", "createdAt": "2021-01-04T11:34:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTcyODEyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjM1ODE3Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r556358172", "bodyText": "I am concerned that the partitioner is still not used. Why don't we pass it to the UnicastSendExec? This leaves PR in a strange state: we introduce partitioners but do not use them. Let's either remove them completely and reintroduce them later, or integrate them properly.", "author": "devozerov", "createdAt": "2021-01-13T08:56:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTcyODEyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTcyOTMzMg==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549729332", "bodyText": "Static code analysis indicates that while(true) actually never loops. We need isolated unit tests for all involved components (ReceiveSortMergeExec, MergeSort, MergeSortSource, SortKey, SortKeyComparator, StripedInbox). Otherwise, there is a high risk of bugs, since these classes are complex.\nExamples of isolated Exec tests could be found in the com.hazelcast.sql.impl.exec test package (e.g. FilterExecTest).", "author": "devozerov", "createdAt": "2020-12-29T14:42:21Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/io/ReceiveSortMergeExec.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.exec.io;\n+\n+import com.hazelcast.sql.impl.exec.AbstractExec;\n+import com.hazelcast.sql.impl.exec.IterationResult;\n+import com.hazelcast.sql.impl.exec.sort.MergeSort;\n+import com.hazelcast.sql.impl.exec.sort.MergeSortSource;\n+import com.hazelcast.sql.impl.exec.sort.SortKey;\n+import com.hazelcast.sql.impl.exec.sort.SortKeyComparator;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.row.EmptyRowBatch;\n+import com.hazelcast.sql.impl.row.ListRowBatch;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.row.RowBatch;\n+import com.hazelcast.sql.impl.worker.QueryFragmentContext;\n+\n+import java.util.List;\n+\n+/**\n+ * Executor which receives entries from multiple sources and merges them into a single sorted stream.\n+ */\n+@SuppressWarnings(\"rawtypes\")\n+public class ReceiveSortMergeExec extends AbstractExec {\n+    /**\n+     * AbstractInbox to consume results from.\n+     */\n+    private final StripedInbox inbox;\n+\n+    /**\n+     * Expressions.\n+     */\n+    private final List<Expression> expressions;\n+\n+    /**\n+     * Sorter.\n+     */\n+    private final MergeSort sorter;\n+\n+    /**\n+     * Current batch.\n+     */\n+    private RowBatch curBatch;\n+\n+    public ReceiveSortMergeExec(\n+        int id,\n+        StripedInbox inbox,\n+        List<Expression> expressions,\n+        List<Boolean> ascs\n+    ) {\n+        super(id);\n+\n+        this.inbox = inbox;\n+        this.expressions = expressions;\n+\n+        MergeSortSource[] sources = new MergeSortSource[inbox.getStripeCount()];\n+\n+        for (int i = 0; i < inbox.getStripeCount(); i++) {\n+            sources[i] = new Source(i);\n+        }\n+\n+        sorter = new MergeSort(sources, new SortKeyComparator(ascs));\n+    }\n+\n+    @Override\n+    protected void setup0(QueryFragmentContext ctx) {\n+        inbox.setup();\n+    }\n+\n+    @Override\n+    public IterationResult advance0() {\n+        while (true) {", "originalCommit": "c364ce930090559c002db51c124c8f048a22192c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDI1NjE1Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r550256156", "bodyText": "Removed unnecessary loop in dc96300\nThe tests will be in the follow-up commit.", "author": "petrpleshachkov", "createdAt": "2020-12-30T16:41:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTcyOTMzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTYzMjIzNg==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r555632236", "bodyText": "Added tests in 132d767", "author": "petrpleshachkov", "createdAt": "2021-01-12T09:36:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTcyOTMzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTcyOTY4MA==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549729680", "bodyText": "As mentioned before, the partitioner is simply ignored here. We need unit tests to ensure that the visitor produces the expected node. See CreateExecPlanNodeVisitorTest.", "author": "devozerov", "createdAt": "2020-12-29T14:43:31Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/CreateExecPlanNodeVisitor.java", "diffHunk": "@@ -300,14 +362,24 @@ public void onMapIndexScanNode(MapIndexScanPlanNode node) {\n                     node.getIndexName(),\n                     node.getIndexComponentCount(),\n                     node.getIndexFilter(),\n-                    node.getConverterTypes()\n+                    node.getConverterTypes(),\n+                    node.getDescending()\n                 );\n             }\n         }\n \n         push(res);\n     }\n \n+    @Override\n+    public void onUnicastSendNode(UnicastSendPlanNode node) {\n+        Outbox[] outboxes = prepareOutboxes(node);", "originalCommit": "c364ce930090559c002db51c124c8f048a22192c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTY0OTEyOQ==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r555649129", "bodyText": "Will be part of the generalized node change.", "author": "petrpleshachkov", "createdAt": "2021-01-12T10:00:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTcyOTY4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTczMDM0Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549730342", "bodyText": "This method is not used in the PR because CreateExecPlanNodeVisitor ignores the partitioner.", "author": "devozerov", "createdAt": "2020-12-29T14:45:18Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/partitioner/RowPartitioner.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.partitioner;\n+\n+import com.hazelcast.internal.serialization.InternalSerializationService;\n+import com.hazelcast.nio.serialization.DataSerializable;\n+import com.hazelcast.sql.impl.row.Row;\n+\n+/**\n+ * Function which maps rows to partitions.\n+ */\n+public interface RowPartitioner extends DataSerializable {\n+    /**\n+     * Get partition for the row.\n+     *\n+     * @param row Row.\n+     * @param partitionCount Number of partitions.\n+     * @param serializationService Serialization service for partition calculation.\n+     * @return Partition, between 0 (inclusive) and .\n+     */\n+    int getPartition(Row row, int partitionCount, InternalSerializationService serializationService);", "originalCommit": "c364ce930090559c002db51c124c8f048a22192c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTY1MTQzOQ==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r555651439", "bodyText": "We now use SingleValuePartitioner only. This part will go away in the generalized code generation.", "author": "petrpleshachkov", "createdAt": "2021-01-12T10:04:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTczMDM0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTczMTQ0NA==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549731444", "bodyText": "It would be nice to have isolated unit tests for this method to ensure the stability of the implementation.", "author": "devozerov", "createdAt": "2020-12-29T14:48:03Z", "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/opt/distribution/DistributionTrait.java", "diffHunk": "@@ -76,6 +76,32 @@ public boolean satisfies(RelTrait targetTrait) {\n         return this.equals(targetTrait);\n     }\n \n+    /**\n+     * Checks whtehr the result set of the node having this trait is guaranteed to exist on all members that will execute a\n+     * fragment with this node.\n+     *\n+     * @return {@code true} if the full result set exists on all participants of the fragment hosting this node.\n+     */\n+    public boolean isFullResultSetOnAllParticipants() {", "originalCommit": "c364ce930090559c002db51c124c8f048a22192c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTY0NDA3MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r555644071", "bodyText": "Added in 653e813", "author": "petrpleshachkov", "createdAt": "2021-01-12T09:53:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTczMTQ0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTczMTkxNw==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549731917", "bodyText": "We do not support offset/fetch, so it is better to disallow passing them for now.", "author": "devozerov", "createdAt": "2020-12-29T14:49:12Z", "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/opt/logical/SortLogicalRel.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.opt.logical;\n+\n+import org.apache.calcite.plan.RelOptCluster;\n+import org.apache.calcite.plan.RelTraitSet;\n+import org.apache.calcite.rel.RelCollation;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.RelWriter;\n+import org.apache.calcite.rel.core.Sort;\n+import org.apache.calcite.rex.RexNode;\n+\n+/**\n+ * Logical sorting.\n+ */\n+public class SortLogicalRel extends Sort implements LogicalRel {\n+    public SortLogicalRel(\n+            RelOptCluster cluster,\n+            RelTraitSet traits,\n+            RelNode child,\n+            RelCollation collation,\n+            RexNode offset,\n+            RexNode fetch\n+    ) {\n+        super(cluster, traits, child, collation, offset, fetch);", "originalCommit": "c364ce930090559c002db51c124c8f048a22192c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDE5NjEyNQ==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r550196125", "bodyText": "Fixed in c78b9e4", "author": "petrpleshachkov", "createdAt": "2020-12-30T13:32:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTczMTkxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTczMjIwMg==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549732202", "bodyText": "Since limit/offset are not supported, we'd better assert that they are null.", "author": "devozerov", "createdAt": "2020-12-29T14:50:00Z", "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/opt/logical/SortLogicalRule.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.opt.logical;\n+\n+import com.hazelcast.sql.impl.calcite.opt.HazelcastConventions;\n+import com.hazelcast.sql.impl.calcite.opt.OptUtils;\n+import org.apache.calcite.plan.Convention;\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.convert.ConverterRule;\n+import org.apache.calcite.rel.core.Sort;\n+import org.apache.calcite.rel.logical.LogicalSort;\n+\n+/**\n+ * Converts abstract sorting to logical sorting.\n+ */\n+public final class SortLogicalRule extends ConverterRule {\n+    public static final RelOptRule INSTANCE = new SortLogicalRule();\n+\n+    private SortLogicalRule() {\n+        super(\n+            LogicalSort.class,\n+            Convention.NONE,\n+            HazelcastConventions.LOGICAL,\n+            SortLogicalRule.class.getSimpleName()\n+        );\n+    }\n+\n+    @Override\n+    public RelNode convert(RelNode rel) {\n+        Sort sort = (Sort) rel;\n+        RelNode input = sort.getInput();\n+\n+        return new SortLogicalRel(\n+            sort.getCluster(),\n+            OptUtils.toLogicalConvention(sort.getTraitSet()),\n+            OptUtils.toLogicalInput(input),\n+            sort.getCollation(),\n+            sort.offset,", "originalCommit": "c364ce930090559c002db51c124c8f048a22192c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDE5Nzc4MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r550197781", "bodyText": "Added in  c85d10e", "author": "petrpleshachkov", "createdAt": "2020-12-30T13:37:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTczMjIwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTczNTE2Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549735162", "bodyText": "The error message doesn't explain the problem properly:\n\nSorting could be located on top of any operator, and it could be impossible to add any index on it (imagine sorting on top of aggregation or join).\nIt is not clear what nested sorting means, is it a well-known term in the SQL world?\nIf the user needs to add an index, can we tell him which exact tables and columns are affected?", "author": "devozerov", "createdAt": "2020-12-29T14:58:14Z", "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/opt/physical/visitor/PlanCreateVisitor.java", "diffHunk": "@@ -253,6 +261,12 @@ public void onMapIndexScan(MapIndexScanPhysicalRel rel) {\n         mapNames.add(table.getMapName());\n     }\n \n+    @Override\n+    public void onSort(SortPhysicalRel rel) {\n+        throw QueryException.error(\"Cannot perform ORDER BY clause without matching index.\"", "originalCommit": "c364ce930090559c002db51c124c8f048a22192c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjYyNzEwNg==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r552627106", "bodyText": "Improved in e47c583", "author": "petrpleshachkov", "createdAt": "2021-01-06T13:47:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTczNTE2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjM2NDUwNg==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r556364506", "bodyText": "The error message is still incorrect. ORDER BY is supported on top of any operator, for so long the operator has the proper collation.  This collation, in turn, is pulled from children operators, and so on. Moreover, a map index scan below the Sort operator will almost never happen in a distributed setting. Last, but not least, our rels are private API, so exposing their names in the error message will not help user anyhow.\nThe ideal implementation will go through children operators and look for the original column in some map scan. There is some built-in support for this in Apache Calcite (RelMdColumnOrigins), but I do not know how reliable it is. Even if good enough, we would need to integrate the metadata propagation for our custom operators, which would like to consume a lot of time. Therefore, I would propose to have a simple and general enough error message for now and consider using the column origins for the future.\nAn example of an error message that is general enough: Cannot execute ORDER BY, because its input is not sorted. Consider adding a sorted index to the data source.", "author": "devozerov", "createdAt": "2021-01-13T09:06:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTczNTE2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjU0Mzk0NA==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r556543944", "bodyText": "Returned back to the generic error message in 4141464", "author": "petrpleshachkov", "createdAt": "2021-01-13T14:06:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTczNTE2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTczNjI3NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549736275", "bodyText": "It seems that the only expression that is ever passed to ReceiveSortMergePlanNode is ColumnExpression. Do we really need to serialize them? Perhaps just idx would be enough (i.e. List<Integer> instead of List<Expression>)", "author": "devozerov", "createdAt": "2020-12-29T15:01:31Z", "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/opt/physical/visitor/PlanCreateVisitor.java", "diffHunk": "@@ -318,6 +332,49 @@ public void onFilter(FilterPhysicalRel rel) {\n         pushUpstream(filterNode);\n     }\n \n+    @Override\n+    public void onSortMergeExchange(SortMergeExchangePhysicalRel rel) {\n+        PlanNode upstreamNode = pollSingleUpstream();\n+        PlanNodeSchema upstreamNodeSchema = upstreamNode.getSchema();\n+\n+        // Create sender and push it as a fragment.\n+        int edge = nextEdge();\n+\n+        int id = pollId(rel);\n+\n+        UnicastSendPlanNode sendNode = new UnicastSendPlanNode(\n+            id,\n+            upstreamNode,\n+            edge,\n+            AllFieldsRowPartitioner.INSTANCE\n+        );\n+\n+        addFragment(sendNode, dataMemberMapping());\n+\n+        List<RelFieldCollation> collations = rel.getCollation().getFieldCollations();\n+        List<Expression> expressions = new ArrayList<>(collations.size());\n+        List<Boolean> ascs = new ArrayList<>(collations.size());\n+\n+        for (RelFieldCollation collation : collations) {\n+            RelFieldCollation.Direction direction = collation.getDirection();\n+            int idx = collation.getFieldIndex();\n+\n+            expressions.add(ColumnExpression.create(idx, upstreamNodeSchema.getType(idx)));", "originalCommit": "c364ce930090559c002db51c124c8f048a22192c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDIwNTE1OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r550205159", "bodyText": "Fixed in d94b802", "author": "petrpleshachkov", "createdAt": "2020-12-30T14:02:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTczNjI3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTczNzA1OA==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549737058", "bodyText": "Since our current implementation always pass values to a single node (ROOT), we do not need AllFieldsRowPartitioner.INSTANCE, because there always be only one target member, and any partition will be assigned to that member. We may introduce a static partitioner, that assigns zero partition to every row.", "author": "devozerov", "createdAt": "2020-12-29T15:03:44Z", "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/opt/physical/visitor/PlanCreateVisitor.java", "diffHunk": "@@ -318,6 +332,49 @@ public void onFilter(FilterPhysicalRel rel) {\n         pushUpstream(filterNode);\n     }\n \n+    @Override\n+    public void onSortMergeExchange(SortMergeExchangePhysicalRel rel) {\n+        PlanNode upstreamNode = pollSingleUpstream();\n+        PlanNodeSchema upstreamNodeSchema = upstreamNode.getSchema();\n+\n+        // Create sender and push it as a fragment.\n+        int edge = nextEdge();\n+\n+        int id = pollId(rel);\n+\n+        UnicastSendPlanNode sendNode = new UnicastSendPlanNode(\n+            id,\n+            upstreamNode,\n+            edge,\n+            AllFieldsRowPartitioner.INSTANCE", "originalCommit": "c364ce930090559c002db51c124c8f048a22192c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI3MzM5MA==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r551273390", "bodyText": "Fixed in ba2cf9f", "author": "petrpleshachkov", "createdAt": "2021-01-04T11:54:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTczNzA1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc1MzA5OA==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549753098", "bodyText": "I am not quite sure how we update the collation here. Consider we have a query SELECT a+b FROM table[a,b]. The plan will look like this:\nProjectRel[0:$0+$1]\n    ScanRel[0:a, 1:b]\n\nNow, if we execute the code below, we will get the following map:\n0 -> 0 // Column \"a\" mapped to \"a+b\"\n1 -> 0 // Column \"b\" mapped to \"a+b\"\n\nThen, if we had the original collation [a ASC], it would be converted to 0:ASC, which means a+b ASC, which is incorrect.\nAFAIU, instead it should work like this:\n\nCollect the list of top-level RexInputRef of the project\nRemap the input collation to these new refs accordingly\n\nAlso, we need extensive test coverage for trait propagation, because this is a complicated part of code, and if we have a single bug here, it may break many queries.", "author": "devozerov", "createdAt": "2020-12-29T15:47:45Z", "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/opt/physical/ProjectPhysicalRule.java", "diffHunk": "@@ -74,20 +83,77 @@ public void onMatch(RelOptRuleCall call) {\n      * @param convertedInput Input.\n      * @return Conversions (converted input + trait set).\n      */\n-    private static Collection<InputAndTraitSet> getTransforms(RelNode convertedInput) {\n+    private static Collection<InputAndTraitSet> getTransforms(List<RexNode> projects, RelNode convertedInput) {\n         List<InputAndTraitSet> res = new ArrayList<>(1);\n \n         Collection<RelNode> physicalInputs = OptUtils.getPhysicalRelsFromSubset(convertedInput);\n \n+        // Initialize a field index to the project index map\n+        Map<Integer, Integer> inputFieldIndex2ProjectIndexMap = new HashMap<>();\n+        for (int i = 0; i < projects.size(); ++i) {\n+            RexNode projectExp = projects.get(i);\n+            ProjectFieldVisitor projectFieldVisitor = new ProjectFieldVisitor(inputFieldIndex2ProjectIndexMap, i);\n+            projectExp.accept(projectFieldVisitor);\n+        }\n+\n         for (RelNode physicalInput : physicalInputs) {\n-            RelTraitSet finalTraitSet = createPhysicalTraitSet(physicalInput);\n+            RelTraitSet traitSet = createPhysicalTraitSet(physicalInput);\n+            RelCollation transformedCollation =\n+                convertCollation(inputFieldIndex2ProjectIndexMap, traitSet.getTrait(RelCollationTraitDef.INSTANCE));\n+            RelTraitSet finalTraitSet = OptUtils.traitPlus(traitSet, transformedCollation);\n \n             res.add(new InputAndTraitSet(physicalInput, finalTraitSet));\n         }\n \n         return res;\n     }\n \n+    /**\n+     * Transforms the collation remapping the collation fields in accordance with the\n+     * project fields.\n+     * @param inputFieldIndex2ProjectIndex a mapping from the input index field to the project index\n+     * @param collation an initial collation\n+     * @return the transformed collation\n+     */\n+    private static RelCollation convertCollation(Map<Integer, Integer> inputFieldIndex2ProjectIndex, RelCollation collation) {", "originalCommit": "c364ce930090559c002db51c124c8f048a22192c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ0ODQxMA==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r550448410", "bodyText": "Actually, the above logic has been done in the ProjectFieldVisitor. I simplified the code in 82ee434  to make it more obvious.", "author": "petrpleshachkov", "createdAt": "2020-12-31T10:12:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc1MzA5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc1Njk5NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549756995", "bodyText": "Index resolution is a heavy operation. Instead of calling it twice, we may just create a copy of relAscending and change the collation.", "author": "devozerov", "createdAt": "2020-12-29T15:58:50Z", "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/opt/physical/index/IndexResolver.java", "diffHunk": "@@ -135,21 +159,122 @@ private IndexResolver() {\n             return Collections.emptyList();\n         }\n \n-        List<RelNode> rels = new ArrayList<>(supportedIndexes.size());\n \n         for (MapTableIndex index : supportedIndexes) {\n             // Create index scan based on candidates, if possible. Candidates could be merged into more complex\n             // filters whenever possible.\n-            RelNode rel = createIndexScan(scan, distribution, index, conjunctions, candidates);\n \n-            if (rel != null) {\n-                rels.add(rel);\n+            RelNode relAscending = createIndexScan(scan, distribution, index, conjunctions, candidates, false);\n+            RelNode relDescending = createIndexScan(scan, distribution, index, conjunctions, candidates, true);", "originalCommit": "c364ce930090559c002db51c124c8f048a22192c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDIyMjI0Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r550222243", "bodyText": "Addressed in 88f7e91", "author": "petrpleshachkov", "createdAt": "2020-12-30T14:56:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc1Njk5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc1NzY1NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549757655", "bodyText": "Even if there is a filter, we still should generate full scans for the non-involved indexes. Otherwise, some plans will not work. Do we have a test, where:\n\nThere is an index on column a\nCondition on the same column\nORDER BY on the other column?\n\nE.g. SELECT a, b FROM table(index(a)) WHERE a=1 ORDER BY b", "author": "devozerov", "createdAt": "2020-12-29T16:00:45Z", "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/opt/physical/index/IndexResolver.java", "diffHunk": "@@ -116,6 +118,28 @@ private IndexResolver() {\n             return Collections.emptyList();\n         }\n \n+        List<RelNode> rels = new ArrayList<>(supportedIndexes.size());\n+\n+        if (filter == null) {\n+            // There is no filter, still generate index scans for\n+            // possible ORDER BY clause on the upper level\n+            for (MapTableIndex index : supportedIndexes) {", "originalCommit": "c364ce930090559c002db51c124c8f048a22192c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ3MTgzNw==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r550471837", "bodyText": "Fixed in 30dc043 and added the test", "author": "petrpleshachkov", "createdAt": "2020-12-31T12:19:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc1NzY1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc1OTgyMg==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549759822", "bodyText": "What if there are two relations with the same collation? E.g. a user accidentally created two identical indexes.", "author": "devozerov", "createdAt": "2020-12-29T16:06:48Z", "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/opt/physical/index/IndexResolver.java", "diffHunk": "@@ -135,21 +159,122 @@ private IndexResolver() {\n             return Collections.emptyList();\n         }\n \n-        List<RelNode> rels = new ArrayList<>(supportedIndexes.size());\n \n         for (MapTableIndex index : supportedIndexes) {\n             // Create index scan based on candidates, if possible. Candidates could be merged into more complex\n             // filters whenever possible.\n-            RelNode rel = createIndexScan(scan, distribution, index, conjunctions, candidates);\n \n-            if (rel != null) {\n-                rels.add(rel);\n+            RelNode relAscending = createIndexScan(scan, distribution, index, conjunctions, candidates, false);\n+            RelNode relDescending = createIndexScan(scan, distribution, index, conjunctions, candidates, true);\n+\n+            if (relAscending != null) {\n+                rels.add(relAscending);\n+            }\n+\n+            if (relDescending != null) {\n+                rels.add(relDescending);\n             }\n         }\n \n         return rels;\n     }\n \n+\n+    /**\n+     * Filters out index scans which collation is covered (prefix based) by another index scan in the rels.\n+     *\n+     * @param rels the list of index scans\n+     * @return the list of filtered out index scans\n+     */\n+    @SuppressWarnings(\"checkstyle:NPathComplexity\")\n+    private static List<RelNode> excludeCoveredCollations(List<RelNode> rels) {\n+        // Order the index scans based on their collation\n+        TreeMap<RelCollation, RelNode> relsTreeMap = new TreeMap<>((coll1, coll2) -> {\n+            // Compare the collations field by field\n+            int coll1Size = coll1.getFieldCollations().size();\n+            int coll2Size = coll2.getFieldCollations().size();\n+\n+            for (int i = 0; i < coll1Size; ++i) {\n+                if (i >= coll2Size) {\n+                    // The coll1 has more fields and the prefixes are equal\n+                    return 1;\n+                }\n+\n+                RelFieldCollation fieldColl1 = coll1.getFieldCollations().get(i);\n+                RelFieldCollation fieldColl2 = coll2.getFieldCollations().get(i);\n+                // First, compare directions\n+                int cmp = fieldColl1.getDirection().compareTo(fieldColl2.getDirection());\n+                if (cmp == 0) {\n+                    // Directions are the same\n+                    if (fieldColl1.getFieldIndex() == fieldColl2.getFieldIndex()) {\n+                        // And fieldIndex is the same, try the next field\n+                        continue;\n+                    } else {\n+                        return Integer.compare(fieldColl1.getFieldIndex(), fieldColl2.getFieldIndex());\n+                    }\n+                }\n+                return cmp;\n+            }\n+\n+            // All the fields from coll1 are equal to the fields from coll2, compare the size\n+            return Integer.compare(coll1Size, coll2Size);\n+        });\n+\n+        // Put the rels into the ordered TreeMap\n+        for (RelNode rel : rels) {\n+            relsTreeMap.put(rel.getTraitSet().getTrait(RelCollationTraitDef.INSTANCE), rel);", "originalCommit": "c364ce930090559c002db51c124c8f048a22192c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc2NDQ3OA==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549764478", "bodyText": "Then one of them will be filtered out since the collation1 covers collation2 if they are equal.", "author": "petrpleshachkov", "createdAt": "2020-12-29T16:19:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc1OTgyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc3NDQ0Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549774443", "bodyText": "This way we may lose good plans. E.g. we may have IndexScan[a ASC] and IndexLookup[a ASC, filter], and the second one will be filtered.", "author": "devozerov", "createdAt": "2020-12-29T16:50:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc1OTgyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ3MjE1Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r550472153", "bodyText": "Addressed in 30dc043\nFirst, exclude only covered full scans leaving the scans with the \"longest\" collations. Then filter out full scans covered by the lookups (with the same collation).", "author": "petrpleshachkov", "createdAt": "2020-12-31T12:21:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc1OTgyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc2MDg2NA==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549760864", "bodyText": "I would suggest moving the comparison logic into a separate class and tests it separatelyly. Otherwise, we cannot test it to a sufficient extent.", "author": "devozerov", "createdAt": "2020-12-29T16:09:44Z", "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/opt/physical/index/IndexResolver.java", "diffHunk": "@@ -135,21 +159,122 @@ private IndexResolver() {\n             return Collections.emptyList();\n         }\n \n-        List<RelNode> rels = new ArrayList<>(supportedIndexes.size());\n \n         for (MapTableIndex index : supportedIndexes) {\n             // Create index scan based on candidates, if possible. Candidates could be merged into more complex\n             // filters whenever possible.\n-            RelNode rel = createIndexScan(scan, distribution, index, conjunctions, candidates);\n \n-            if (rel != null) {\n-                rels.add(rel);\n+            RelNode relAscending = createIndexScan(scan, distribution, index, conjunctions, candidates, false);\n+            RelNode relDescending = createIndexScan(scan, distribution, index, conjunctions, candidates, true);\n+\n+            if (relAscending != null) {\n+                rels.add(relAscending);\n+            }\n+\n+            if (relDescending != null) {\n+                rels.add(relDescending);\n             }\n         }\n \n         return rels;\n     }\n \n+\n+    /**\n+     * Filters out index scans which collation is covered (prefix based) by another index scan in the rels.\n+     *\n+     * @param rels the list of index scans\n+     * @return the list of filtered out index scans\n+     */\n+    @SuppressWarnings(\"checkstyle:NPathComplexity\")\n+    private static List<RelNode> excludeCoveredCollations(List<RelNode> rels) {\n+        // Order the index scans based on their collation\n+        TreeMap<RelCollation, RelNode> relsTreeMap = new TreeMap<>((coll1, coll2) -> {", "originalCommit": "c364ce930090559c002db51c124c8f048a22192c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTcwNTA2Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r555705066", "bodyText": "Added in c4b7e90", "author": "petrpleshachkov", "createdAt": "2021-01-12T11:34:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc2MDg2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc2NDAwNw==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549764007", "bodyText": "Perhaps this method could be replaced with RelCollation.satisfies(RelCollation).", "author": "devozerov", "createdAt": "2020-12-29T16:18:31Z", "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/opt/physical/index/IndexResolver.java", "diffHunk": "@@ -135,21 +159,122 @@ private IndexResolver() {\n             return Collections.emptyList();\n         }\n \n-        List<RelNode> rels = new ArrayList<>(supportedIndexes.size());\n \n         for (MapTableIndex index : supportedIndexes) {\n             // Create index scan based on candidates, if possible. Candidates could be merged into more complex\n             // filters whenever possible.\n-            RelNode rel = createIndexScan(scan, distribution, index, conjunctions, candidates);\n \n-            if (rel != null) {\n-                rels.add(rel);\n+            RelNode relAscending = createIndexScan(scan, distribution, index, conjunctions, candidates, false);\n+            RelNode relDescending = createIndexScan(scan, distribution, index, conjunctions, candidates, true);\n+\n+            if (relAscending != null) {\n+                rels.add(relAscending);\n+            }\n+\n+            if (relDescending != null) {\n+                rels.add(relDescending);\n             }\n         }\n \n         return rels;\n     }\n \n+\n+    /**\n+     * Filters out index scans which collation is covered (prefix based) by another index scan in the rels.\n+     *\n+     * @param rels the list of index scans\n+     * @return the list of filtered out index scans\n+     */\n+    @SuppressWarnings(\"checkstyle:NPathComplexity\")\n+    private static List<RelNode> excludeCoveredCollations(List<RelNode> rels) {\n+        // Order the index scans based on their collation\n+        TreeMap<RelCollation, RelNode> relsTreeMap = new TreeMap<>((coll1, coll2) -> {\n+            // Compare the collations field by field\n+            int coll1Size = coll1.getFieldCollations().size();\n+            int coll2Size = coll2.getFieldCollations().size();\n+\n+            for (int i = 0; i < coll1Size; ++i) {\n+                if (i >= coll2Size) {\n+                    // The coll1 has more fields and the prefixes are equal\n+                    return 1;\n+                }\n+\n+                RelFieldCollation fieldColl1 = coll1.getFieldCollations().get(i);\n+                RelFieldCollation fieldColl2 = coll2.getFieldCollations().get(i);\n+                // First, compare directions\n+                int cmp = fieldColl1.getDirection().compareTo(fieldColl2.getDirection());\n+                if (cmp == 0) {\n+                    // Directions are the same\n+                    if (fieldColl1.getFieldIndex() == fieldColl2.getFieldIndex()) {\n+                        // And fieldIndex is the same, try the next field\n+                        continue;\n+                    } else {\n+                        return Integer.compare(fieldColl1.getFieldIndex(), fieldColl2.getFieldIndex());\n+                    }\n+                }\n+                return cmp;\n+            }\n+\n+            // All the fields from coll1 are equal to the fields from coll2, compare the size\n+            return Integer.compare(coll1Size, coll2Size);\n+        });\n+\n+        // Put the rels into the ordered TreeMap\n+        for (RelNode rel : rels) {\n+            relsTreeMap.put(rel.getTraitSet().getTrait(RelCollationTraitDef.INSTANCE), rel);\n+        }\n+\n+        List<RelNode> resultRels = new ArrayList<>();\n+        Map.Entry<RelCollation, RelNode> prevEntry = null;\n+        // Go through the ordered collations and exclude covered ones\n+        for (Map.Entry<RelCollation, RelNode> entry : relsTreeMap.descendingMap().entrySet()) {\n+            RelCollation collation = entry.getKey();\n+            RelNode relNode = entry.getValue();\n+\n+            if (prevEntry == null) {\n+                resultRels.add(relNode);\n+                prevEntry = entry;\n+            } else {\n+                RelCollation prevCollation = prevEntry.getKey();\n+                if (!coveredCollation(prevCollation, collation)) {\n+                    prevEntry = entry;\n+                    resultRels.add(relNode);\n+                }\n+            }\n+        }\n+        return resultRels;\n+    }\n+\n+    /**\n+     * Tests whether collation1 covers (prefix based) collation2\n+     *\n+     * @param collation1 the collation\n+     * @param collation2 the collation\n+     * @return {@code true} if collation1 covers collation2, otherwise {@code false}\n+     */\n+    private static boolean coveredCollation(RelCollation collation1, RelCollation collation2) {\n+        if (collation1.getFieldCollations().size() < collation2.getFieldCollations().size()) {", "originalCommit": "c364ce930090559c002db51c124c8f048a22192c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTcxMDcyMQ==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r555710721", "bodyText": "Indeed, simplified in 419012d", "author": "petrpleshachkov", "createdAt": "2021-01-12T11:44:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc2NDAwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc2NDk2Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549764967", "bodyText": "We cannot throw out covered collations if there is an index scan found. Consider that we resolved the following candidates:\n\n[a ASC, b ASC] -> index scan\n[an ASC] -> index lookup\nThe second relation is covered by the first one, but it has a filter, whilst the first one does the full scan. Therefore, we may loose a very good plan with a lookup.", "author": "devozerov", "createdAt": "2020-12-29T16:21:19Z", "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/opt/physical/index/IndexResolver.java", "diffHunk": "@@ -135,21 +159,122 @@ private IndexResolver() {\n             return Collections.emptyList();\n         }\n \n-        List<RelNode> rels = new ArrayList<>(supportedIndexes.size());\n \n         for (MapTableIndex index : supportedIndexes) {\n             // Create index scan based on candidates, if possible. Candidates could be merged into more complex\n             // filters whenever possible.\n-            RelNode rel = createIndexScan(scan, distribution, index, conjunctions, candidates);\n \n-            if (rel != null) {\n-                rels.add(rel);\n+            RelNode relAscending = createIndexScan(scan, distribution, index, conjunctions, candidates, false);\n+            RelNode relDescending = createIndexScan(scan, distribution, index, conjunctions, candidates, true);\n+\n+            if (relAscending != null) {\n+                rels.add(relAscending);\n+            }\n+\n+            if (relDescending != null) {\n+                rels.add(relDescending);\n             }\n         }\n \n         return rels;\n     }\n \n+\n+    /**\n+     * Filters out index scans which collation is covered (prefix based) by another index scan in the rels.\n+     *\n+     * @param rels the list of index scans\n+     * @return the list of filtered out index scans\n+     */\n+    @SuppressWarnings(\"checkstyle:NPathComplexity\")\n+    private static List<RelNode> excludeCoveredCollations(List<RelNode> rels) {\n+        // Order the index scans based on their collation\n+        TreeMap<RelCollation, RelNode> relsTreeMap = new TreeMap<>((coll1, coll2) -> {\n+            // Compare the collations field by field\n+            int coll1Size = coll1.getFieldCollations().size();\n+            int coll2Size = coll2.getFieldCollations().size();\n+\n+            for (int i = 0; i < coll1Size; ++i) {\n+                if (i >= coll2Size) {\n+                    // The coll1 has more fields and the prefixes are equal\n+                    return 1;\n+                }\n+\n+                RelFieldCollation fieldColl1 = coll1.getFieldCollations().get(i);\n+                RelFieldCollation fieldColl2 = coll2.getFieldCollations().get(i);\n+                // First, compare directions\n+                int cmp = fieldColl1.getDirection().compareTo(fieldColl2.getDirection());\n+                if (cmp == 0) {\n+                    // Directions are the same\n+                    if (fieldColl1.getFieldIndex() == fieldColl2.getFieldIndex()) {\n+                        // And fieldIndex is the same, try the next field\n+                        continue;\n+                    } else {\n+                        return Integer.compare(fieldColl1.getFieldIndex(), fieldColl2.getFieldIndex());\n+                    }\n+                }\n+                return cmp;\n+            }\n+\n+            // All the fields from coll1 are equal to the fields from coll2, compare the size\n+            return Integer.compare(coll1Size, coll2Size);\n+        });\n+\n+        // Put the rels into the ordered TreeMap\n+        for (RelNode rel : rels) {\n+            relsTreeMap.put(rel.getTraitSet().getTrait(RelCollationTraitDef.INSTANCE), rel);\n+        }\n+\n+        List<RelNode> resultRels = new ArrayList<>();\n+        Map.Entry<RelCollation, RelNode> prevEntry = null;\n+        // Go through the ordered collations and exclude covered ones\n+        for (Map.Entry<RelCollation, RelNode> entry : relsTreeMap.descendingMap().entrySet()) {\n+            RelCollation collation = entry.getKey();\n+            RelNode relNode = entry.getValue();\n+\n+            if (prevEntry == null) {\n+                resultRels.add(relNode);\n+                prevEntry = entry;\n+            } else {\n+                RelCollation prevCollation = prevEntry.getKey();", "originalCommit": "c364ce930090559c002db51c124c8f048a22192c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ3MjU3MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r550472571", "bodyText": "Addressed in the 30dc043 the full scan never \"covers\" the full scans.", "author": "petrpleshachkov", "createdAt": "2020-12-31T12:24:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc2NDk2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc2NjEzMA==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549766130", "bodyText": "Looks like this method could be private.", "author": "devozerov", "createdAt": "2020-12-29T16:24:55Z", "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/opt/physical/index/IndexResolver.java", "diffHunk": "@@ -691,41 +822,61 @@ private static MapIndexScanPhysicalRel createIndexScan(\n             filter,\n             converterTypes,\n             exp,\n-            remainderExp\n+            remainderExp,\n+            descending\n         );\n     }\n \n     /**\n-     * Create an index scan without any filter. Used by HD maps only.\n+     * Builds a collation with collation fields re-mapped according with the table projects\n      *\n-     * @param scan the original scan operator\n+     * @param scan       the logical map scan\n+     * @param index      the index\n+     * @param descending whether the collation is descending\n+     * @return the new collation trait\n+     */\n+    private static RelCollation buildCollationTrait(MapScanLogicalRel scan,\n+                                                    MapTableIndex index,\n+                                                    boolean descending) {\n+        List<RelFieldCollation> fields = new ArrayList<>(index.getFieldOrdinals().size());\n+        HazelcastTable table = scan.getTableUnwrapped();\n+        for (Integer indexFieldOrdinal : index.getFieldOrdinals()) {\n+            int remappedIndexFieldOrdinal = table.getProjects().indexOf(indexFieldOrdinal);\n+            if (remappedIndexFieldOrdinal == -1) {\n+                // The field is not used in the query\n+                break;\n+            }\n+            RelFieldCollation.Direction direction = descending ? RelFieldCollation.Direction.DESCENDING\n+                : RelFieldCollation.Direction.ASCENDING;\n+            RelFieldCollation fieldCollation = new RelFieldCollation(remappedIndexFieldOrdinal, direction);\n+            fields.add(fieldCollation);\n+        }\n+        return RelCollations.of(fields);\n+    }\n+\n+    /**\n+     * Creates an index scan without any filter.\n+     *\n+     * @param scan         the original scan operator\n      * @param distribution the original distribution\n-     * @param indexes available indexes\n+     * @param index        available indexes\n      * @return index scan or {@code null}\n      */\n     public static RelNode createFullIndexScan(", "originalCommit": "c364ce930090559c002db51c124c8f048a22192c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDIyNDU3Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r550224576", "bodyText": "Fixed in c2468be", "author": "petrpleshachkov", "createdAt": "2020-12-30T15:03:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc2NjEzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc2NjMxNg==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549766316", "bodyText": "Can we filter out the candidate index early if we realize that it has no collation?", "author": "devozerov", "createdAt": "2020-12-29T16:25:30Z", "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/opt/physical/index/IndexResolver.java", "diffHunk": "@@ -665,6 +792,10 @@ private static MapIndexScanPhysicalRel createIndexScan(\n         // Prepare traits\n         RelTraitSet traitSet = OptUtils.toPhysicalConvention(scan.getTraitSet(), distribution);\n \n+        // Make a collation trait\n+        RelCollation relCollation = buildCollationTrait(scan, index, descending);", "originalCommit": "c364ce930090559c002db51c124c8f048a22192c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDIyNzYzOA==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r550227638", "bodyText": "Why would we filter it out? Even if there is no collation it might be used by lookup? We don't know on this stage whether an actual sorting exists or not?", "author": "petrpleshachkov", "createdAt": "2020-12-30T15:12:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc2NjMxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDI1MjA5NA==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r550252094", "bodyText": "Added the optimization to the full index scans in 91e69a2", "author": "petrpleshachkov", "createdAt": "2020-12-30T16:28:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc2NjMxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc2NzQ1Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549767457", "bodyText": "Looks like this is a leftover.", "author": "devozerov", "createdAt": "2020-12-29T16:28:35Z", "path": "hazelcast-sql-core/src/test/java/com/hazelcast/sql/impl/calcite/opt/physical/index/PhysicalIndexExpressionTest.java", "diffHunk": "@@ -189,4 +190,9 @@ private void checkNoIndexForCondition(String condition, String hdRemainderFilter\n             checkNoIndex(sql, INT, INT, INT, INT, INT);\n         }\n     }\n+\n+    @RunWith(HazelcastSerialClassRunner.class)\n+    @Category({QuickTest.class, ParallelJVMTest.class})\n+    public static class PhysicalSortIndexTest extends OptimizerTestSupport {", "originalCommit": "c364ce930090559c002db51c124c8f048a22192c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ4MzA4OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r550483089", "bodyText": "Fixed in 58a2368", "author": "petrpleshachkov", "createdAt": "2020-12-31T13:26:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc2NzQ1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc3MDAwOQ==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549770009", "bodyText": "We need more tests to handle typical cases here:\n\nTests when there is no merge phase\nTests when sorting is combined with index lookups\nNegative tests, e.g. for HASH indexes, missing indexes, lost collations", "author": "devozerov", "createdAt": "2020-12-29T16:36:16Z", "path": "hazelcast-sql-core/src/test/java/com/hazelcast/sql/impl/calcite/opt/physical/index/PhysicalSortIndexTest.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.opt.physical.index;\n+\n+import com.hazelcast.config.IndexType;\n+import com.hazelcast.sql.impl.calcite.opt.physical.MapIndexScanPhysicalRel;\n+import com.hazelcast.sql.impl.calcite.opt.physical.MapScanPhysicalRel;\n+import com.hazelcast.sql.impl.calcite.opt.physical.ProjectPhysicalRel;\n+import com.hazelcast.sql.impl.calcite.opt.physical.RootPhysicalRel;\n+import com.hazelcast.sql.impl.calcite.opt.physical.SortPhysicalRel;\n+import com.hazelcast.sql.impl.calcite.opt.physical.exchange.SortMergeExchangePhysicalRel;\n+import com.hazelcast.sql.impl.calcite.schema.HazelcastSchema;\n+import com.hazelcast.sql.impl.calcite.schema.HazelcastTable;\n+import com.hazelcast.sql.impl.schema.map.MapTableIndex;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.apache.calcite.schema.Table;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static com.hazelcast.sql.impl.type.QueryDataType.INT;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.singletonList;\n+\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class PhysicalSortIndexTest extends IndexOptimizerTestSupport {", "originalCommit": "c364ce930090559c002db51c124c8f048a22192c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDUwMDU0NA==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r550500544", "bodyText": "Added in fa9da4a", "author": "petrpleshachkov", "createdAt": "2020-12-31T15:03:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc3MDAwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc3MTAxMw==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549771013", "bodyText": "I would recommend adding isolated unit tests for createIndexScans to ensure that all the logic works as expected. It is difficult to assess the correctness because currently, we have only integration tests that check the final plan, but not the alternatives generated in MEMO. It should be relatively simple to create [scan, distribution, indexes] by hand and check which alternatives are returned.", "author": "devozerov", "createdAt": "2020-12-29T16:39:11Z", "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/opt/physical/index/IndexResolver.java", "diffHunk": "@@ -82,23 +89,18 @@ private IndexResolver() {\n      * Analyzes the filter of the input scan operator, and produces zero, one or more {@link MapIndexScanPhysicalRel}\n      * operators.\n      *\n-     * @param scan scan operator to be analyzed\n+     * @param scan         scan operator to be analyzed\n      * @param distribution distribution that will be passed to created index scan rels\n-     * @param indexes indexes available on the map being scanned\n+     * @param indexes      indexes available on the map being scanned\n      * @return zero, one or more index scan rels\n      */\n     public static List<RelNode> createIndexScans(", "originalCommit": "c364ce930090559c002db51c124c8f048a22192c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDAyOTE4OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r554029189", "bodyText": "Addressed in 351d44b", "author": "petrpleshachkov", "createdAt": "2021-01-08T15:56:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc3MTAxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc3MTQyNQ==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549771425", "bodyText": "Do we really need to run the tests below with all the combinations of parameters?", "author": "devozerov", "createdAt": "2020-12-29T16:40:31Z", "path": "hazelcast-sql-core/src/test/java/com/hazelcast/sql/SqlOrderByTest.java", "diffHunk": "@@ -0,0 +1,526 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql;\n+\n+import com.hazelcast.config.Config;\n+import com.hazelcast.config.InMemoryFormat;\n+import com.hazelcast.config.IndexConfig;\n+import com.hazelcast.config.IndexType;\n+import com.hazelcast.config.MapConfig;\n+import com.hazelcast.core.HazelcastInstance;\n+import com.hazelcast.map.IMap;\n+import com.hazelcast.sql.impl.SqlTestSupport;\n+import com.hazelcast.test.HazelcastSerialParametersRunnerFactory;\n+import com.hazelcast.test.TestHazelcastInstanceFactory;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameter;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+import static com.hazelcast.sql.SqlBasicTest.AbstractPojo;\n+import static com.hazelcast.sql.SqlBasicTest.AbstractPojoKey;\n+import static com.hazelcast.sql.SqlBasicTest.DataSerializablePojo;\n+import static com.hazelcast.sql.SqlBasicTest.DataSerializablePojoKey;\n+import static com.hazelcast.sql.SqlBasicTest.IdentifiedDataSerializablePojo;\n+import static com.hazelcast.sql.SqlBasicTest.IdentifiedDataSerializablePojoKey;\n+import static com.hazelcast.sql.SqlBasicTest.PortablePojo;\n+import static com.hazelcast.sql.SqlBasicTest.PortablePojoKey;\n+import static com.hazelcast.sql.SqlBasicTest.SerializablePojo;\n+import static com.hazelcast.sql.SqlBasicTest.SerializablePojoKey;\n+import static com.hazelcast.sql.SqlBasicTest.SerializationMode;\n+import static com.hazelcast.sql.SqlBasicTest.portableFieldName;\n+import static com.hazelcast.sql.SqlBasicTest.serializationConfig;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.fail;\n+\n+/**\n+ * Test that covers basic column read operations through SQL.\n+ */\n+@RunWith(Parameterized.class)\n+@Parameterized.UseParametersRunnerFactory(HazelcastSerialParametersRunnerFactory.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+@SuppressWarnings(\"checkstyle:RedundantModifier\")\n+public class SqlOrderByTest extends SqlTestSupport {\n+\n+    private static final String MAP_OBJECT = \"map_object\";\n+    private static final String MAP_BINARY = \"map_binary\";\n+\n+    private static final int[] PAGE_SIZES = {256};\n+    private static final int[] DATA_SET_SIZES = {4096};\n+    private static final SqlTestInstanceFactory FACTORY = SqlTestInstanceFactory.create();\n+\n+    private static TestHazelcastInstanceFactory factory;\n+    private static List<HazelcastInstance> members;\n+    private static HazelcastInstance member;\n+\n+    private static HazelcastInstance member1;\n+    private static HazelcastInstance member2;\n+\n+    @Parameter\n+    public int cursorBufferSize;", "originalCommit": "c364ce930090559c002db51c124c8f048a22192c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ3NTA3Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r550475073", "bodyText": "Simplified in 3592175", "author": "petrpleshachkov", "createdAt": "2020-12-31T12:39:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc3MTQyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc3MjU5Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r549772593", "bodyText": "I am not sure that this test covers sufficient number of cases. E.g.:\n\nAll supported types (e.g. these are no tests for float)\nHandling of null values\nHandling of the same values (e.g. 1, 2, 2)\nTesting index lookups and ORDER BY together\nSingle member (no merge) and multiple members (with merge)", "author": "devozerov", "createdAt": "2020-12-29T16:44:26Z", "path": "hazelcast-sql-core/src/test/java/com/hazelcast/sql/SqlOrderByTest.java", "diffHunk": "@@ -0,0 +1,526 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql;\n+\n+import com.hazelcast.config.Config;\n+import com.hazelcast.config.InMemoryFormat;\n+import com.hazelcast.config.IndexConfig;\n+import com.hazelcast.config.IndexType;\n+import com.hazelcast.config.MapConfig;\n+import com.hazelcast.core.HazelcastInstance;\n+import com.hazelcast.map.IMap;\n+import com.hazelcast.sql.impl.SqlTestSupport;\n+import com.hazelcast.test.HazelcastSerialParametersRunnerFactory;\n+import com.hazelcast.test.TestHazelcastInstanceFactory;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameter;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+import static com.hazelcast.sql.SqlBasicTest.AbstractPojo;\n+import static com.hazelcast.sql.SqlBasicTest.AbstractPojoKey;\n+import static com.hazelcast.sql.SqlBasicTest.DataSerializablePojo;\n+import static com.hazelcast.sql.SqlBasicTest.DataSerializablePojoKey;\n+import static com.hazelcast.sql.SqlBasicTest.IdentifiedDataSerializablePojo;\n+import static com.hazelcast.sql.SqlBasicTest.IdentifiedDataSerializablePojoKey;\n+import static com.hazelcast.sql.SqlBasicTest.PortablePojo;\n+import static com.hazelcast.sql.SqlBasicTest.PortablePojoKey;\n+import static com.hazelcast.sql.SqlBasicTest.SerializablePojo;\n+import static com.hazelcast.sql.SqlBasicTest.SerializablePojoKey;\n+import static com.hazelcast.sql.SqlBasicTest.SerializationMode;\n+import static com.hazelcast.sql.SqlBasicTest.portableFieldName;\n+import static com.hazelcast.sql.SqlBasicTest.serializationConfig;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.fail;\n+\n+/**\n+ * Test that covers basic column read operations through SQL.\n+ */\n+@RunWith(Parameterized.class)\n+@Parameterized.UseParametersRunnerFactory(HazelcastSerialParametersRunnerFactory.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+@SuppressWarnings(\"checkstyle:RedundantModifier\")\n+public class SqlOrderByTest extends SqlTestSupport {", "originalCommit": "c364ce930090559c002db51c124c8f048a22192c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ5NTg1Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r552495853", "bodyText": "Addressed in f24b6ea", "author": "petrpleshachkov", "createdAt": "2021-01-06T10:34:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc3MjU5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDg5NTMwMA==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r554895300", "bodyText": "The override is here just to make it final, right?", "author": "taburet", "createdAt": "2021-01-11T08:51:31Z", "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/opt/logical/SortLogicalRel.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.opt.logical;\n+\n+import org.apache.calcite.plan.RelOptCluster;\n+import org.apache.calcite.plan.RelTraitSet;\n+import org.apache.calcite.rel.RelCollation;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.RelWriter;\n+import org.apache.calcite.rel.core.Sort;\n+import org.apache.calcite.rex.RexNode;\n+\n+/**\n+ * Logical sorting.\n+ */\n+public class SortLogicalRel extends Sort implements LogicalRel {\n+    public SortLogicalRel(\n+            RelOptCluster cluster,\n+            RelTraitSet traits,\n+            RelNode child,\n+            RelCollation collation\n+    ) {\n+        super(cluster, traits, child, collation);\n+    }\n+\n+    @Override\n+    public final Sort copy(RelTraitSet traitSet, RelNode input, RelCollation collation, RexNode offset, RexNode fetch) {\n+        return new SortLogicalRel(getCluster(), traitSet, input, collation);\n+    }\n+\n+    @Override\n+    public final RelWriter explainTerms(RelWriter pw) {", "originalCommit": "351d44b171ac38d0c560ab2fac985c3007a19787", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDkxODY3NA==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r554918674", "bodyText": "Just to indicate that there is a method in the superclass which we're overriding.", "author": "petrpleshachkov", "createdAt": "2021-01-11T09:36:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDg5NTMwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTAyNjMxNw==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r555026317", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 *                   {@code false} means an ascending order.**\n          \n          \n            \n                 *                   {@code false} means an ascending order.", "author": "alex-dukhno", "createdAt": "2021-01-11T12:53:58Z", "path": "hazelcast/src/main/java/com/hazelcast/query/impl/Index.java", "diffHunk": "@@ -125,18 +128,25 @@\n     /**\n      * @param comparison comparison type\n      * @param value value\n+     * @param descending whether the entries should come in the descending order.\n+     *                   {@code true} means a descending order,\n+     *                   {@code false} means an ascending order.**", "originalCommit": "f3bd9c2e163ebac5b152856b719dcff43dd55850", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTcxNDc0MA==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r555714740", "bodyText": "Fixed in 2f05ca9", "author": "petrpleshachkov", "createdAt": "2021-01-12T11:52:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTAyNjMxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTAyNjQzNQ==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r555026435", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 *                   {@code false} means an ascending order.*\n          \n          \n            \n                 *                   {@code false} means an ascending order.", "author": "alex-dukhno", "createdAt": "2021-01-11T12:54:12Z", "path": "hazelcast/src/main/java/com/hazelcast/query/impl/Index.java", "diffHunk": "@@ -125,18 +128,25 @@\n     /**\n      * @param comparison comparison type\n      * @param value value\n+     * @param descending whether the entries should come in the descending order.\n+     *                   {@code true} means a descending order,\n+     *                   {@code false} means an ascending order.**\n      * @return iterator over index entries that are matching the given comparions type and value\n      */\n-    Iterator<QueryableEntry> getSqlRecordIterator(Comparison comparison, Comparable value);\n+    Iterator<QueryableEntry> getSqlRecordIterator(Comparison comparison, Comparable value, boolean descending);\n \n     /**\n      * @param from lower bound\n      * @param fromInclusive lower bound inclusive flag\n      * @param to upper bound\n      * @param toInclusive upper bound inclusive flag\n+     * @param descending whether the entries should come in the descending order.\n+     *                   {@code true} means a descending order,\n+     *                   {@code false} means an ascending order.*", "originalCommit": "f3bd9c2e163ebac5b152856b719dcff43dd55850", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTcxNTAwOA==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r555715008", "bodyText": "Fixed in 2f05ca9", "author": "petrpleshachkov", "createdAt": "2021-01-12T11:52:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTAyNjQzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTAyNjgwNA==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r555026804", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 *                   {@code false} means an ascending order.*\n          \n          \n            \n                 *                   {@code false} means an ascending order.", "author": "alex-dukhno", "createdAt": "2021-01-11T12:54:51Z", "path": "hazelcast/src/main/java/com/hazelcast/query/impl/IndexStore.java", "diffHunk": "@@ -140,18 +143,25 @@\n     /**\n      * @param comparison comparison type\n      * @param value value\n+     * @param descending whether the entries should come in the descending order.\n+     *                   {@code true} means a descending order,\n+     *                   {@code false} means an ascending order.*", "originalCommit": "f3bd9c2e163ebac5b152856b719dcff43dd55850", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTcxNTA2MA==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r555715060", "bodyText": "Fixed in 2f05ca9", "author": "petrpleshachkov", "createdAt": "2021-01-12T11:52:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTAyNjgwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTAyNjg5OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r555026899", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 *                   {@code false} means an ascending order.*\n          \n          \n            \n                 *                   {@code false} means an ascending order.", "author": "alex-dukhno", "createdAt": "2021-01-11T12:55:03Z", "path": "hazelcast/src/main/java/com/hazelcast/query/impl/IndexStore.java", "diffHunk": "@@ -140,18 +143,25 @@\n     /**\n      * @param comparison comparison type\n      * @param value value\n+     * @param descending whether the entries should come in the descending order.\n+     *                   {@code true} means a descending order,\n+     *                   {@code false} means an ascending order.*\n      * @return iterator over index entries that are matching the given comparions type and value\n      */\n-    Iterator<QueryableEntry> getSqlRecordIterator(Comparison comparison, Comparable value);\n+    Iterator<QueryableEntry> getSqlRecordIterator(Comparison comparison, Comparable value, boolean descending);\n \n     /**\n      * @param from lower bound\n      * @param fromInclusive lower bound inclusive flag\n      * @param to upper bound\n      * @param toInclusive upper bound inclusive flag\n+     * @param descending whether the entries should come in the descending order.\n+     *                   {@code true} means a descending order,\n+     *                   {@code false} means an ascending order.*", "originalCommit": "f3bd9c2e163ebac5b152856b719dcff43dd55850", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTcxNTkzNQ==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r555715935", "bodyText": "With the new satisfies check, the upper equals check is no longer needed.", "author": "devozerov", "createdAt": "2021-01-12T11:54:32Z", "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/opt/distribution/DistributionTraitDef.java", "diffHunk": "@@ -97,6 +97,10 @@ public RelNode convert(\n             return rel;\n         }\n \n+        if (currentTrait.satisfies(targetTrait)) {", "originalCommit": "2f05ca9c96801041307fb61fd2a5e023a3faff18", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjM1MzEzNg==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r556353136", "bodyText": "Addressed in 7d123a6", "author": "petrpleshachkov", "createdAt": "2021-01-13T08:48:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTcxNTkzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjM0ODU5MA==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r556348590", "bodyText": "In IndexInFilter, we put NULLs last for ASC. But in SortKeyComparator we have the following code, which AFAIU puts NULLs first for ASC:\nif (o1 == null) {\n    return asc ? -1 : 1;\n}\n\nWhat is the canonical implementation that we would like to have? Do we have tests that cover all types of filters, as well as distributed vs non-distirubted case? Another question - does composite filters handle nulls in the same way as we expect?", "author": "devozerov", "createdAt": "2021-01-13T08:40:59Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/scan/index/IndexInFilter.java", "diffHunk": "@@ -70,8 +72,21 @@ public IndexInFilter(List<IndexFilter> filters) {\n     }\n \n     @Override\n-    public Iterator<QueryableEntry> getEntries(InternalIndex index, ExpressionEvalContext evalContext) {\n-        Map<Comparable, IndexFilter> canonicalFilters = new HashMap<>();\n+    public Iterator<QueryableEntry> getEntries(InternalIndex index, boolean descending, ExpressionEvalContext evalContext) {\n+\n+        // Sort the filter Comparables\n+        // NULLs are coming last if the sort is ASC\n+        // NULLs are coming first if the sort is DESC\n+        NavigableMap<Comparable, IndexFilter> canonicalFilters = new TreeMap<>((o1, o2) -> {\n+            if (o1 == NULL) {", "originalCommit": "2f05ca9c96801041307fb61fd2a5e023a3faff18", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjUxNjc4Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r556516786", "bodyText": "That is a leftover because we changed our decision and now support the same NULLs collation as in the composite index. I fixed it in the 5a7d73a as well as individual unit tests.", "author": "petrpleshachkov", "createdAt": "2021-01-13T13:25:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjM0ODU5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjM1MzQxNw==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r556353417", "bodyText": "Objects.hash produces an array on every call. This is not very good for the hot code path. We'd better use manually created hashCode implementation.", "author": "devozerov", "createdAt": "2021-01-13T08:49:06Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/sort/SortKey.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.exec.sort;\n+\n+import java.util.Arrays;\n+import java.util.Objects;\n+\n+/**\n+ * Single sort key.\n+ */\n+public class SortKey {\n+    /** The key */\n+    private final Object[] key;\n+\n+    /** Index to make rows unique. */\n+    private final long index;\n+\n+    public SortKey(Object[] key, long index) {\n+        this.key = key;\n+        this.index = index;\n+    }\n+\n+    public Object[] getKey() {\n+        return key;\n+    }\n+\n+    public long getIndex() {\n+        return index;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(index, key);", "originalCommit": "7d123a63b095335ec190e28d54c4bce3488a4a02", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjM3MDM4MA==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r556370380", "bodyText": "Improved in 8f8fcd8", "author": "petrpleshachkov", "createdAt": "2021-01-13T09:16:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjM1MzQxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjM1NTcyNw==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r556355727", "bodyText": "SingleValuePartitioner is not a very correct name for this class, because there is no value. Maybe it should be something like ZeroPartitioner, SinglePartitionPartitioner or so, to better reflect the purpose.", "author": "devozerov", "createdAt": "2021-01-13T08:52:59Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/partitioner/SingleValuePartitioner.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.partitioner;\n+\n+import com.hazelcast.internal.serialization.InternalSerializationService;\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.sql.impl.row.Row;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Partitioner that is not making actual partitioning mapping all rows to the same partition.\n+ */\n+public final class SingleValuePartitioner implements RowPartitioner {", "originalCommit": "7d123a63b095335ec190e28d54c4bce3488a4a02", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjM1OTUwOQ==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r556359509", "bodyText": "It partitions everything into the same partition, and that is where the single value comes from. But I'll rename.", "author": "petrpleshachkov", "createdAt": "2021-01-13T08:58:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjM1NTcyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjM2NTE0Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r556365142", "bodyText": "Renamed in df15a94", "author": "petrpleshachkov", "createdAt": "2021-01-13T09:08:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjM1NTcyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjM1NjAxOA==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r556356018", "bodyText": "Since this class is passed over the wire, it should implement IdentifiedDataSerializable.", "author": "devozerov", "createdAt": "2021-01-13T08:53:25Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/partitioner/SingleValuePartitioner.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.partitioner;\n+\n+import com.hazelcast.internal.serialization.InternalSerializationService;\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.sql.impl.row.Row;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Partitioner that is not making actual partitioning mapping all rows to the same partition.\n+ */\n+public final class SingleValuePartitioner implements RowPartitioner {", "originalCommit": "7d123a63b095335ec190e28d54c4bce3488a4a02", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjM2NTA0Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r556365047", "bodyText": "Added in df15a94", "author": "petrpleshachkov", "createdAt": "2021-01-13T09:07:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjM1NjAxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjM2NTY2Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r556365667", "bodyText": "columnIndexes could be an int[], which will make the serialization slightly more efficient.", "author": "devozerov", "createdAt": "2021-01-13T09:08:52Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/plan/node/io/ReceiveSortMergePlanNode.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.plan.node.io;\n+\n+import com.hazelcast.internal.serialization.impl.SerializationUtil;\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.plan.node.PlanNodeSchema;\n+import com.hazelcast.sql.impl.plan.node.PlanNodeVisitor;\n+import com.hazelcast.sql.impl.plan.node.ZeroInputPlanNode;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * Physical node which receives from remote stripes and performs sort-merge.\n+ */\n+@SuppressWarnings(\"rawtypes\")\n+public class ReceiveSortMergePlanNode extends ZeroInputPlanNode implements EdgeAwarePlanNode, IdentifiedDataSerializable {\n+    /**\n+     * Edge iD.\n+     */\n+    private int edgeId;\n+\n+    /**\n+     * Field types.\n+     */\n+    private List<QueryDataType> fieldTypes;\n+\n+    /**\n+     * Indexes of columns to be used for sorting.\n+     */\n+    private List<Integer> columnIndexes;", "originalCommit": "df15a9460ab87640faf70aaec530a8115cba9176", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjM4NDg5Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r556384897", "bodyText": "Replaced in  4119819", "author": "petrpleshachkov", "createdAt": "2021-01-13T09:38:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjM2NTY2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjM4NDEzNw==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r556384137", "bodyText": "Minor: probably we do not need this method at all.", "author": "devozerov", "createdAt": "2021-01-13T09:37:38Z", "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/opt/physical/SortPhysicalRule.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.opt.physical;\n+\n+import com.hazelcast.sql.impl.calcite.opt.HazelcastConventions;\n+import com.hazelcast.sql.impl.calcite.opt.OptUtils;\n+import com.hazelcast.sql.impl.calcite.opt.distribution.DistributionTrait;\n+import com.hazelcast.sql.impl.calcite.opt.logical.SortLogicalRel;\n+import com.hazelcast.sql.impl.calcite.opt.physical.exchange.SortMergeExchangePhysicalRel;\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.plan.RelTraitSet;\n+import org.apache.calcite.rel.RelCollation;\n+import org.apache.calcite.rel.RelCollationTraitDef;\n+import org.apache.calcite.rel.RelFieldCollation;\n+import org.apache.calcite.rel.RelNode;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+\n+/**\n+ * The rule that converts logical sort into its physical counterpart. In the current release\n+ * we support only a limited case that relies on the locally pre-sorted indexes to avoid local sorting.\n+ * <p>\n+ * However, if the input is located on a few nodes, and extra merge sort {@link SortMergeExchangePhysicalRel}\n+ * is created to sort locally pre-sorted entries.\n+ */\n+public final class SortPhysicalRule extends RelOptRule {\n+    public static final RelOptRule INSTANCE = new SortPhysicalRule();\n+\n+    private SortPhysicalRule() {\n+        super(\n+            OptUtils.parentChild(SortLogicalRel.class, RelNode.class, HazelcastConventions.LOGICAL),\n+            SortPhysicalRule.class.getSimpleName()\n+        );\n+    }\n+\n+    @Override\n+    public void onMatch(RelOptRuleCall call) {\n+        SortLogicalRel sort = call.rel(0);\n+        RelNode input = sort.getInput();\n+\n+        RelNode convertedInput = OptUtils.toPhysicalInput(input);\n+\n+        Collection<RelNode> transforms = getTransforms(sort, convertedInput);\n+\n+        for (RelNode transform : transforms) {\n+            call.transformTo(transform);\n+        }\n+    }\n+\n+    /**\n+     * Get possible transformations for the given input.\n+     *\n+     * @param logicalSort    logical sort.\n+     * @param convertedInput Converted input.\n+     * @return Possible transforms.\n+     */\n+    private Collection<RelNode> getTransforms(SortLogicalRel logicalSort, RelNode convertedInput) {\n+        List<RelNode> requiresLocalSortRels = new ArrayList<>(1);\n+        List<RelNode> noLocalSortRels = new ArrayList<>(1);\n+\n+        for (RelNode physicalInput : OptUtils.getPhysicalRelsFromSubset(convertedInput)) {\n+            // Check whether local sorting is needed\n+            boolean requiresLocalSort = requiresLocalSort(\n+                logicalSort.getCollation(),\n+                physicalInput.getTraitSet().getTrait(RelCollationTraitDef.INSTANCE)\n+            );\n+\n+            RelNode rel;\n+\n+            if (requiresLocalSort) {\n+                rel = createLocalSort(logicalSort, physicalInput);\n+            } else {\n+                rel = createLocalNoSort(physicalInput);\n+            }\n+\n+            // Add merge phase if needed.\n+            DistributionTrait physicalInputDist = OptUtils.getDistribution(physicalInput);\n+\n+            if (!physicalInputDist.isFullResultSetOnAllParticipants()) {\n+                rel = createMerge(rel, logicalSort);\n+            }\n+\n+            // Add to the list of transformations.\n+            if (requiresLocalSort) {\n+                requiresLocalSortRels.add(rel);\n+            } else {\n+                noLocalSortRels.add(rel);\n+            }\n+        }\n+\n+        // Pick up a plan that doesn't require local sorting,\n+        // otherwise an exception will be thrown when local sort\n+        // is touched in runtime.\n+        if (noLocalSortRels.size() > 0) {\n+            return noLocalSortRels;\n+        } else {\n+            return requiresLocalSortRels;\n+        }\n+    }\n+\n+    /**\n+     * Check if local sorting phase is needed. It could be avoided iff sort collation is a prefix of input collation.\n+     *\n+     * @return {@code true} if local sorting is needed, {@code false} otherwise.\n+     */\n+    private static boolean requiresLocalSort(RelCollation sortCollation, RelCollation inputCollation) {\n+        if (sortCollation.getFieldCollations().isEmpty()) {\n+            // No need for sorting\n+            return false;\n+        }\n+\n+        List<RelFieldCollation> sortFields = sortCollation.getFieldCollations();\n+        List<RelFieldCollation> inputFields = inputCollation.getFieldCollations();\n+\n+        if (sortFields.size() <= inputFields.size()) {\n+            for (int i = 0; i < sortFields.size(); i++) {\n+                RelFieldCollation sortField = sortFields.get(i);\n+                RelFieldCollation inputField = inputFields.get(i);\n+\n+                // Different collation, local sorting is needed.\n+                if (!sortField.equals(inputField)) {\n+                    return true;\n+                }\n+            }\n+\n+            // Prefix is confirmed, no local sorting is needed.\n+            return false;\n+        } else {\n+            // Input has less collated fields than sort. Definitely not a prefix => local sorting is needed.\n+            return true;\n+        }\n+    }\n+\n+    private static SortPhysicalRel createLocalSort(SortLogicalRel logicalSort, RelNode physicalInput) {\n+        // Input traits are propagated, but new collation is used.\n+        RelTraitSet traitSet = OptUtils.traitPlus(physicalInput.getTraitSet(),\n+            logicalSort.getCollation()\n+        );\n+\n+        return new SortPhysicalRel(\n+            logicalSort.getCluster(),\n+            traitSet,\n+            physicalInput,\n+            logicalSort.getCollation()\n+        );\n+    }\n+\n+    private RelNode createLocalNoSort(RelNode input) {\n+        return input;", "originalCommit": "8f8fcd84e7bf109643f84e61f121d2396db77322", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjM4OTgxMQ==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r556389811", "bodyText": "Addressed in f9419cf", "author": "petrpleshachkov", "createdAt": "2021-01-13T09:46:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjM4NDEzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjM5MDM5Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r556390393", "bodyText": "A call to containsKey is not needed, since remove already does this check. Similarly for the other containsKey call below.", "author": "devozerov", "createdAt": "2021-01-13T09:47:22Z", "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/opt/physical/index/IndexResolver.java", "diffHunk": "@@ -136,20 +174,101 @@ private IndexResolver() {\n         }\n \n         List<RelNode> rels = new ArrayList<>(supportedIndexes.size());\n-\n         for (MapTableIndex index : supportedIndexes) {\n             // Create index scan based on candidates, if possible. Candidates could be merged into more complex\n             // filters whenever possible.\n-            RelNode rel = createIndexScan(scan, distribution, index, conjunctions, candidates);\n+            List<Boolean> ascs = buildFieldDirections(index, true);\n+            RelNode relAscending = createIndexScan(scan, distribution, index, conjunctions, candidates, ascs);\n+\n+            if (relAscending != null) {\n+                RelCollation relAscCollation = getCollation(relAscending);\n+                if (fullScanRelsMap.containsKey(relAscCollation)) {", "originalCommit": "8f8fcd84e7bf109643f84e61f121d2396db77322", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjM5OTUyMA==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r556399520", "bodyText": "Optimized in 341d45d", "author": "petrpleshachkov", "createdAt": "2021-01-13T10:00:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjM5MDM5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjM5MjAxNA==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r556392014", "bodyText": "RelCollationComparator could be a singleton.", "author": "devozerov", "createdAt": "2021-01-13T09:49:53Z", "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/opt/physical/index/IndexResolver.java", "diffHunk": "@@ -136,20 +174,101 @@ private IndexResolver() {\n         }\n \n         List<RelNode> rels = new ArrayList<>(supportedIndexes.size());\n-\n         for (MapTableIndex index : supportedIndexes) {\n             // Create index scan based on candidates, if possible. Candidates could be merged into more complex\n             // filters whenever possible.\n-            RelNode rel = createIndexScan(scan, distribution, index, conjunctions, candidates);\n+            List<Boolean> ascs = buildFieldDirections(index, true);\n+            RelNode relAscending = createIndexScan(scan, distribution, index, conjunctions, candidates, ascs);\n+\n+            if (relAscending != null) {\n+                RelCollation relAscCollation = getCollation(relAscending);\n+                if (fullScanRelsMap.containsKey(relAscCollation)) {\n+                    // The fulls scan has the same collation, exclude it\n+                    fullScanRelsMap.remove(relAscCollation);\n+                }\n+\n+                rels.add(relAscending);\n \n-            if (rel != null) {\n-                rels.add(rel);\n+                if (relAscCollation.getFieldCollations().size() > 0) {\n+                    RelNode relDescending = replaceCollationDirection(relAscending, DESCENDING);\n+                    rels.add(relDescending);\n+\n+                    RelCollation relDescCollation = getCollation(relDescending);\n+                    if (fullScanRelsMap.containsKey(relDescCollation)) {\n+                        // The fulls scan has the same collation, exclude it\n+                        fullScanRelsMap.remove(relDescCollation);\n+                    }\n+                }\n             }\n         }\n \n+        rels.addAll(fullScanRelsMap.values());\n         return rels;\n     }\n \n+    private static RelCollation getCollation(RelNode rel) {\n+        return rel.getTraitSet().getTrait(RelCollationTraitDef.INSTANCE);\n+    }\n+\n+    /**\n+     * Replaces a direction in the collation trait of the rel\n+     * @param rel       the rel\n+     * @param direction the collation\n+     * @return the rel with changed collation\n+     */\n+    private static RelNode replaceCollationDirection(RelNode rel, Direction direction) {\n+        RelCollation collation = rel.getTraitSet().getTrait(RelCollationTraitDef.INSTANCE);\n+\n+        List<RelFieldCollation> newFields = new ArrayList<>(collation.getFieldCollations().size());\n+        for (RelFieldCollation fieldCollation : collation.getFieldCollations()) {\n+            RelFieldCollation newFieldCollation = new RelFieldCollation(fieldCollation.getFieldIndex(), direction);\n+            newFields.add(newFieldCollation);\n+        }\n+\n+        RelCollation newCollation = RelCollations.of(newFields);\n+        RelTraitSet traitSet = rel.getTraitSet();\n+        traitSet = OptUtils.traitPlus(traitSet, newCollation);\n+\n+        return rel.copy(traitSet, rel.getInputs());\n+    }\n+\n+    /**\n+     * Filters out index scans which collation is covered (prefix based) by another index scan in the rels.\n+     *\n+     * @param rels the list of index scans\n+     * @return a filtered out map of collation to rel\n+     */\n+    @SuppressWarnings(\"checkstyle:NPathComplexity\")\n+    private static Map<RelCollation, RelNode> excludeCoveredCollations(List<RelNode> rels) {\n+        // Order the index scans based on their collation\n+        TreeMap<RelCollation, RelNode> relsTreeMap = new TreeMap<>(new RelCollationComparator());", "originalCommit": "8f8fcd84e7bf109643f84e61f121d2396db77322", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjQwMjczNw==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r556402737", "bodyText": "Addressed in 0d7ec9a", "author": "petrpleshachkov", "createdAt": "2021-01-13T10:05:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjM5MjAxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjQwMTcwMQ==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r556401701", "bodyText": "Here we have ASC NULLS FIRST and DESC NULLS LAST. Could you please confirm that it works the same way for :\n\nComposite indexes (e.g. [x, NULL] comes before [x, y] for ASC, and vice versa for DESC)\nMerge sorter\nIN filter", "author": "devozerov", "createdAt": "2021-01-13T10:04:18Z", "path": "hazelcast/src/main/java/com/hazelcast/query/impl/OrderedIndexStore.java", "diffHunk": "@@ -115,11 +116,19 @@ public boolean canEvaluate(Class<? extends Predicate> predicateClass) {\n     }\n \n     @Override\n-    public Iterator<QueryableEntry> getSqlRecordIterator() {\n-        Iterator<QueryableEntry> iterator = new IndexEntryFlatteningIterator(recordMap.values().iterator());\n-        Iterator<QueryableEntry> nullIterator = recordsWithNullValue.values().iterator();\n+    public Iterator<QueryableEntry> getSqlRecordIterator(boolean descending) {", "originalCommit": "f9419cfe53b49156bfacd109deae81e73631f1c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjQwNDc5Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r556404793", "bodyText": "Consider the we have LESS THAN EQUALS 2 operator and a collection of values [0, 1, 2, 3, 4].\nFor ASC we call headMap(2, true), and get [0, 1, 2]. For DESC we call tailMap(2, true), and get [2, 3, 4].\nLooks like we return completely wrong results here unless I am missing something. Do we have tests for these cases?", "author": "devozerov", "createdAt": "2021-01-13T10:09:14Z", "path": "hazelcast/src/main/java/com/hazelcast/query/impl/OrderedIndexStore.java", "diffHunk": "@@ -138,21 +147,38 @@ public boolean canEvaluate(Class<? extends Predicate> predicateClass) {\n     }\n \n     @Override\n-    public Iterator<QueryableEntry> getSqlRecordIterator(Comparison comparison, Comparable searchedValue) {\n+    public Iterator<QueryableEntry> getSqlRecordIterator(Comparison comparison, Comparable searchedValue, boolean descending) {\n         Iterator<Map<Data, QueryableEntry>> iterator;\n \n+        ConcurrentNavigableMap navigableMap = descending ? recordMap.descendingMap() : recordMap;\n         switch (comparison) {\n             case LESS:\n-                iterator = recordMap.headMap(searchedValue, false).values().iterator();\n+                if (descending) {", "originalCommit": "f9419cfe53b49156bfacd109deae81e73631f1c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjQwNTYzNw==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r556405637", "bodyText": "Nevermind, I missed the navigableMap initialization. Resolving.", "author": "devozerov", "createdAt": "2021-01-13T10:10:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjQwNDc5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODExMjc0OA==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r558112748", "bodyText": "Minor: formally, we do not do any conversions here.", "author": "devozerov", "createdAt": "2021-01-15T09:23:22Z", "path": "hazelcast-sql-core/src/main/java/org/apache/calcite/plan/volcano/HazelcastRelSubsetUtil.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.calcite.plan.volcano;\n+\n+import com.hazelcast.sql.impl.calcite.opt.HazelcastConventions;\n+\n+/**\n+ * Utility class to access package-private Calcite internals.\n+ */\n+public final class HazelcastRelSubsetUtil {\n+\n+    private HazelcastRelSubsetUtil() {\n+    }\n+\n+    /**\n+     * Convert the given input into input with PHYSICAL convention.", "originalCommit": "e1a3cea708fa1326aa6b1bde521b7c2d2810d034", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODMyODIzOQ==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r558328239", "bodyText": "Addressed in acd0028", "author": "petrpleshachkov", "createdAt": "2021-01-15T14:06:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODExMjc0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODEyMjg2OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r558122869", "bodyText": "Here we convert a physical subset to another physical rel traits. I do not know the exact consequences of it, but perhaps it would be better to do convert(rel, rel.getTraitSet()). In any case, let's double-check that this convert call doesn't lead to the creation of new converters.", "author": "devozerov", "createdAt": "2021-01-15T09:30:12Z", "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/opt/OptUtils.java", "diffHunk": "@@ -172,31 +173,35 @@ public static boolean isPhysical(RelNode rel) {\n     /**\n      * Get possible physical rels from the given subset. Every returned input is guaranteed to have a unique trait set.\n      *\n-     * @param subset Subset.\n+     * @param input Subset.\n      * @return Physical rels.\n      */\n-    public static Collection<RelNode> getPhysicalRelsFromSubset(RelNode subset) {\n-        if (subset instanceof RelSubset) {\n-            RelSubset subset0 = (RelSubset) subset;\n+    public static Collection<RelNode> getPhysicalRelsFromSubset(RelNode input) {\n \n-            Set<RelTraitSet> traitSets = new HashSet<>();\n+        RelNode convertedInput = convert(input, input.getTraitSet());\n \n-            Set<RelNode> res = Collections.newSetFromMap(new IdentityHashMap<>());\n+        if (!(convertedInput instanceof RelSubset)) {\n+            return Collections.emptyList();\n+        }\n+\n+        RelSubset logicalSubset = (RelSubset) convertedInput;\n+        RelSubset physicalSubset = HazelcastRelSubsetUtil.getPhysicalSubSet(logicalSubset);\n+\n+        Set<RelTraitSet> traitSets = new HashSet<>();\n \n-            for (RelNode rel : subset0.getRelList()) {\n-                if (!isPhysical(rel)) {\n-                    continue;\n-                }\n+        Set<RelNode> res = Collections.newSetFromMap(new IdentityHashMap<>());\n \n-                if (traitSets.add(rel.getTraitSet())) {\n-                    res.add(convert(subset, rel.getTraitSet()));\n-                }\n+        for (RelNode rel : physicalSubset.getRelList()) {\n+            if (!isPhysical(rel)) {\n+                continue;\n             }\n \n-            return res;\n-        } else {\n-            return Collections.emptyList();\n+            if (traitSets.add(rel.getTraitSet())) {\n+                res.add(convert(physicalSubset, rel.getTraitSet()));", "originalCommit": "e1a3cea708fa1326aa6b1bde521b7c2d2810d034", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODMyODE3Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r558328173", "bodyText": "Addressed in acd0028", "author": "petrpleshachkov", "createdAt": "2021-01-15T14:06:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODEyMjg2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODEyMzkxMw==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r558123913", "bodyText": "Strictly speaking, logicalSubset is not necessarily logical. It could be physical as well. So I would rename this variable to avoid confusion.", "author": "devozerov", "createdAt": "2021-01-15T09:30:54Z", "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/opt/OptUtils.java", "diffHunk": "@@ -172,31 +173,35 @@ public static boolean isPhysical(RelNode rel) {\n     /**\n      * Get possible physical rels from the given subset. Every returned input is guaranteed to have a unique trait set.\n      *\n-     * @param subset Subset.\n+     * @param input Subset.\n      * @return Physical rels.\n      */\n-    public static Collection<RelNode> getPhysicalRelsFromSubset(RelNode subset) {\n-        if (subset instanceof RelSubset) {\n-            RelSubset subset0 = (RelSubset) subset;\n+    public static Collection<RelNode> getPhysicalRelsFromSubset(RelNode input) {\n \n-            Set<RelTraitSet> traitSets = new HashSet<>();\n+        RelNode convertedInput = convert(input, input.getTraitSet());\n \n-            Set<RelNode> res = Collections.newSetFromMap(new IdentityHashMap<>());\n+        if (!(convertedInput instanceof RelSubset)) {\n+            return Collections.emptyList();\n+        }\n+\n+        RelSubset logicalSubset = (RelSubset) convertedInput;", "originalCommit": "e1a3cea708fa1326aa6b1bde521b7c2d2810d034", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODMyODA4OA==", "url": "https://github.com/hazelcast/hazelcast/pull/18013#discussion_r558328088", "bodyText": "Addressed in acd0028", "author": "petrpleshachkov", "createdAt": "2021-01-15T14:06:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODEyMzkxMw=="}], "type": "inlineReview"}, {"oid": "46cf92f7bc553174750752a05bbd182e32701f68", "url": "https://github.com/hazelcast/hazelcast/commit/46cf92f7bc553174750752a05bbd182e32701f68", "message": "SQL: implementation of the ORDER BY clause\n\nInitial implementation of the SQL's ORDER BY clause. It supports\nothe ASC and DESC sortings, but there are some limitations.\n\nThe sorting is only supported only if there is a matching index that\nstores the key/value pairs already pre-sorted. Otherwise, an exception\nis thrown.\n\nThe nested sortings are supported, but again only if the supporting\ncomposite SORTED index is created.", "committedDate": "2021-01-22T13:43:19Z", "type": "commit"}, {"oid": "f6ee1bc3ee471973b3f03c727939aad5dbff37c9", "url": "https://github.com/hazelcast/hazelcast/commit/f6ee1bc3ee471973b3f03c727939aad5dbff37c9", "message": "Minor improvements, checkstyle, formatting", "committedDate": "2021-01-22T13:43:19Z", "type": "commit"}, {"oid": "689e5177dc7ef959df8a440887a118300a42de12", "url": "https://github.com/hazelcast/hazelcast/commit/689e5177dc7ef959df8a440887a118300a42de12", "message": "Minor improvements", "committedDate": "2021-01-22T13:43:19Z", "type": "commit"}, {"oid": "127f290b0cf7b945a23ad0e04fa0740ad44eb131", "url": "https://github.com/hazelcast/hazelcast/commit/127f290b0cf7b945a23ad0e04fa0740ad44eb131", "message": "Minors", "committedDate": "2021-01-22T13:43:19Z", "type": "commit"}, {"oid": "593b73d8b939d59a7d4aa7fa54e4927994b461e9", "url": "https://github.com/hazelcast/hazelcast/commit/593b73d8b939d59a7d4aa7fa54e4927994b461e9", "message": "Propagate descending flag properly", "committedDate": "2021-01-22T13:43:19Z", "type": "commit"}, {"oid": "4c8edd2300073eb0150b6dfc68a47244f77c3fff", "url": "https://github.com/hazelcast/hazelcast/commit/4c8edd2300073eb0150b6dfc68a47244f77c3fff", "message": "Removed a leftover", "committedDate": "2021-01-22T13:43:19Z", "type": "commit"}, {"oid": "6d0a6ce4cf2c3fe41e9060051b86a4c821badd85", "url": "https://github.com/hazelcast/hazelcast/commit/6d0a6ce4cf2c3fe41e9060051b86a4c821badd85", "message": "Addresses reviewer's comment\n\nReplace List<Object> with the Object[] in the SortKey.\nCheckstyle fixes.", "committedDate": "2021-01-22T13:43:19Z", "type": "commit"}, {"oid": "b4784a3582c2bc7dd170af94ff294e248ec7def3", "url": "https://github.com/hazelcast/hazelcast/commit/b4784a3582c2bc7dd170af94ff294e248ec7def3", "message": "Fixed formatting", "committedDate": "2021-01-22T13:43:19Z", "type": "commit"}, {"oid": "21a6b05739456c8c48960bb31864b3adb9fa17c5", "url": "https://github.com/hazelcast/hazelcast/commit/21a6b05739456c8c48960bb31864b3adb9fa17c5", "message": "Added descending flag to the explainTerms(...)", "committedDate": "2021-01-22T13:43:19Z", "type": "commit"}, {"oid": "999b1391fbbded3f721bbc73a7f23473d45ce706", "url": "https://github.com/hazelcast/hazelcast/commit/999b1391fbbded3f721bbc73a7f23473d45ce706", "message": "Extended Filter tests with descending navigation support.\n\nFixed some issues in the filters.", "committedDate": "2021-01-22T13:43:19Z", "type": "commit"}, {"oid": "92edccadde00f182d2c4a631941ab91c0bc94ecc", "url": "https://github.com/hazelcast/hazelcast/commit/92edccadde00f182d2c4a631941ab91c0bc94ecc", "message": "Removed not used parameters", "committedDate": "2021-01-22T13:43:19Z", "type": "commit"}, {"oid": "d9d13966a66f23076cc6fbc4333e85b8d2fabfdb", "url": "https://github.com/hazelcast/hazelcast/commit/d9d13966a66f23076cc6fbc4333e85b8d2fabfdb", "message": "Minor: added more asserts", "committedDate": "2021-01-22T13:43:19Z", "type": "commit"}, {"oid": "c703f2a539ded71f37dcaa85dc080c2045fe1c37", "url": "https://github.com/hazelcast/hazelcast/commit/c703f2a539ded71f37dcaa85dc080c2045fe1c37", "message": "Removed unnecessary passing of column expressions", "committedDate": "2021-01-22T13:43:19Z", "type": "commit"}, {"oid": "bb2fb561a2960b5013f6ff39f6f37a3d2018a948", "url": "https://github.com/hazelcast/hazelcast/commit/bb2fb561a2960b5013f6ff39f6f37a3d2018a948", "message": "Optimized full index scan generation", "committedDate": "2021-01-22T13:43:19Z", "type": "commit"}, {"oid": "8190a507dbad5b56f20645491431aa9b6c2b4e61", "url": "https://github.com/hazelcast/hazelcast/commit/8190a507dbad5b56f20645491431aa9b6c2b4e61", "message": "Minor: made method private", "committedDate": "2021-01-22T13:43:19Z", "type": "commit"}, {"oid": "600741a4041fb305398d48e0015cf93f8141c170", "url": "https://github.com/hazelcast/hazelcast/commit/600741a4041fb305398d48e0015cf93f8141c170", "message": "Filter out a full index scan if there is no collation", "committedDate": "2021-01-22T13:43:19Z", "type": "commit"}, {"oid": "7360b8ff6ea67a7c0a848b6ed61087829ef669f0", "url": "https://github.com/hazelcast/hazelcast/commit/7360b8ff6ea67a7c0a848b6ed61087829ef669f0", "message": "Removed unnecessary code", "committedDate": "2021-01-22T13:43:19Z", "type": "commit"}, {"oid": "e4259dcdc0aa41dae304cec260b699ff2da2b406", "url": "https://github.com/hazelcast/hazelcast/commit/e4259dcdc0aa41dae304cec260b699ff2da2b406", "message": "Implement IdentifiedDataSerializable in UnicastSendPlanNode", "committedDate": "2021-01-22T13:47:18Z", "type": "commit"}, {"oid": "486c7ea21970440796b4b277e3b94ec39efbed23", "url": "https://github.com/hazelcast/hazelcast/commit/486c7ea21970440796b4b277e3b94ec39efbed23", "message": "Implemented IdentifiedDataSerializable in ReceiveSortMergePlanNode", "committedDate": "2021-01-22T13:49:38Z", "type": "commit"}, {"oid": "068da3eaecbca541a36329130fd9b20a4f0561a7", "url": "https://github.com/hazelcast/hazelcast/commit/068da3eaecbca541a36329130fd9b20a4f0561a7", "message": "Fixed hashCode/equals method", "committedDate": "2021-01-22T13:49:38Z", "type": "commit"}, {"oid": "574c3e2ce09d51a5331e4f594a8dd29ee1cbcafa", "url": "https://github.com/hazelcast/hazelcast/commit/574c3e2ce09d51a5331e4f594a8dd29ee1cbcafa", "message": "Removed not used code", "committedDate": "2021-01-22T13:49:38Z", "type": "commit"}, {"oid": "5099351140e5def76667f88aa80e69526404ac4b", "url": "https://github.com/hazelcast/hazelcast/commit/5099351140e5def76667f88aa80e69526404ac4b", "message": "Minor improvement: replaced List with array", "committedDate": "2021-01-22T13:49:38Z", "type": "commit"}, {"oid": "7e77bab6acf6932f8c4242462666e952bb7beb9f", "url": "https://github.com/hazelcast/hazelcast/commit/7e77bab6acf6932f8c4242462666e952bb7beb9f", "message": "Fixed equals/hashCode methods", "committedDate": "2021-01-22T13:49:38Z", "type": "commit"}, {"oid": "f9156f1430c44775973138f61025313350a41bb3", "url": "https://github.com/hazelcast/hazelcast/commit/f9156f1430c44775973138f61025313350a41bb3", "message": "Simplified code", "committedDate": "2021-01-22T13:49:38Z", "type": "commit"}, {"oid": "e8c981fa1d72750010e38826a2b3b0330407475f", "url": "https://github.com/hazelcast/hazelcast/commit/e8c981fa1d72750010e38826a2b3b0330407475f", "message": "Fixed index scan creation\n\n1. Generate full scans when a filter exists\n2. Exclude full scans covered by lookups with the same collation\n3. Unit testing", "committedDate": "2021-01-22T13:49:38Z", "type": "commit"}, {"oid": "cde45cf36c81666db961d10651a1a0dc81b3bba0", "url": "https://github.com/hazelcast/hazelcast/commit/cde45cf36c81666db961d10651a1a0dc81b3bba0", "message": "Simplified unit test", "committedDate": "2021-01-22T13:49:38Z", "type": "commit"}, {"oid": "8fd1a96597279ec23e4406c7fe8c7188b33c76fb", "url": "https://github.com/hazelcast/hazelcast/commit/8fd1a96597279ec23e4406c7fe8c7188b33c76fb", "message": "Removed a leftover", "committedDate": "2021-01-22T13:49:38Z", "type": "commit"}, {"oid": "20066dee21a60bf5296742bbc002d3694dd377c8", "url": "https://github.com/hazelcast/hazelcast/commit/20066dee21a60bf5296742bbc002d3694dd377c8", "message": "More tests on the index plans with sorting", "committedDate": "2021-01-22T13:49:38Z", "type": "commit"}, {"oid": "78e65cf016255e59f4dbfe2c094c6d4198f59b89", "url": "https://github.com/hazelcast/hazelcast/commit/78e65cf016255e59f4dbfe2c094c6d4198f59b89", "message": "Generalized fields collation\n\nUse List<Boolean> for fields collation instead of one boolean flag to\nprepare for [ASC, DESC] sortings in the future. The change is mostly\nneeded to keep the protocol unchanged in the future.", "committedDate": "2021-01-22T13:49:38Z", "type": "commit"}, {"oid": "64c8d3db3f49f67400f6a317d48fdbc1696d8401", "url": "https://github.com/hazelcast/hazelcast/commit/64c8d3db3f49f67400f6a317d48fdbc1696d8401", "message": "Generalized a unit test", "committedDate": "2021-01-22T13:49:38Z", "type": "commit"}, {"oid": "47c50b5038b336cd7a876f4f38f6ebe19d8dee5b", "url": "https://github.com/hazelcast/hazelcast/commit/47c50b5038b336cd7a876f4f38f6ebe19d8dee5b", "message": "Use NoPartitioning partitioner for the sorting unicast send", "committedDate": "2021-01-22T13:49:38Z", "type": "commit"}, {"oid": "a62bd901143c8df6d78d004eef10e4aad0aa321b", "url": "https://github.com/hazelcast/hazelcast/commit/a62bd901143c8df6d78d004eef10e4aad0aa321b", "message": "Minor: make the field package-private", "committedDate": "2021-01-22T13:49:38Z", "type": "commit"}, {"oid": "af00e7f418b414e154511aea1a7e05bd815eefea", "url": "https://github.com/hazelcast/hazelcast/commit/af00e7f418b414e154511aea1a7e05bd815eefea", "message": "Assert SingleValuePartitioner is used", "committedDate": "2021-01-22T13:49:38Z", "type": "commit"}, {"oid": "860c69cb99b3235cb53f3f36f47b411e601e7c2b", "url": "https://github.com/hazelcast/hazelcast/commit/860c69cb99b3235cb53f3f36f47b411e601e7c2b", "message": "NULL values handling", "committedDate": "2021-01-22T13:49:38Z", "type": "commit"}, {"oid": "3e33e8042ad18dbe8ce7499c2732c12d1cad4832", "url": "https://github.com/hazelcast/hazelcast/commit/3e33e8042ad18dbe8ce7499c2732c12d1cad4832", "message": "Added tests for unsupported features", "committedDate": "2021-01-22T13:49:38Z", "type": "commit"}]}