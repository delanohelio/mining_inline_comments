{"pr_number": 16870, "pr_title": "Connection manager simplification", "pr_createdAt": "2020-04-09T11:53:56Z", "pr_url": "https://github.com/hazelcast/hazelcast/pull/16870", "timeline": [{"oid": "3d98a75ef4848b4e3231b36a80f266b363874828", "url": "https://github.com/hazelcast/hazelcast/commit/3d98a75ef4848b4e3231b36a80f266b363874828", "message": "WIP", "committedDate": "2020-04-09T12:48:22Z", "type": "forcePushed"}, {"oid": "4e4f1d3b855fa6831dabc9d85b1a57265662cdae", "url": "https://github.com/hazelcast/hazelcast/commit/4e4f1d3b855fa6831dabc9d85b1a57265662cdae", "message": "WIP", "committedDate": "2020-04-10T04:21:48Z", "type": "forcePushed"}, {"oid": "6c54e5702f9fadc050f4cce8bcbb6710c9ce7681", "url": "https://github.com/hazelcast/hazelcast/commit/6c54e5702f9fadc050f4cce8bcbb6710c9ce7681", "message": "WIP", "committedDate": "2020-04-10T06:15:06Z", "type": "forcePushed"}, {"oid": "0dd4cc5fda80c22f87d466d26e912e3fb4a82fa2", "url": "https://github.com/hazelcast/hazelcast/commit/0dd4cc5fda80c22f87d466d26e912e3fb4a82fa2", "message": "ConnectionManager class simplification", "committedDate": "2020-04-10T12:54:34Z", "type": "forcePushed"}, {"oid": "c016bd3e09aa182420413ff43e02da408b3d70ad", "url": "https://github.com/hazelcast/hazelcast/commit/c016bd3e09aa182420413ff43e02da408b3d70ad", "message": "ConnectionManager class simplification", "committedDate": "2020-04-14T08:48:11Z", "type": "forcePushed"}, {"oid": "57841f20d6f831cd1e74b70f639a384a0120548b", "url": "https://github.com/hazelcast/hazelcast/commit/57841f20d6f831cd1e74b70f639a384a0120548b", "message": "ConnectionManager class simplification", "committedDate": "2020-04-15T12:21:11Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjA2MzYwOA==", "url": "https://github.com/hazelcast/hazelcast/pull/16870#discussion_r412063608", "bodyText": "Is this todo meant to be addressed in this PR?", "author": "vbekiaris", "createdAt": "2020-04-21T10:24:49Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/server/Server.java", "diffHunk": "@@ -17,44 +17,51 @@\n package com.hazelcast.internal.server;\n \n import com.hazelcast.instance.EndpointQualifier;\n-import com.hazelcast.internal.server.tcp.ClientViewUnifiedEndpointManager;\n-import com.hazelcast.internal.server.tcp.MemberViewUnifiedServerConnectionManager;\n-import com.hazelcast.internal.server.tcp.TextViewUnifiedServerConnectionManager;\n+import com.hazelcast.internal.nio.ConnectionListenable;\n+\n+import java.util.Collection;\n+import java.util.Map;\n \n /**\n  * The Server is responsible for managing {@link ServerConnection} instances.\n  *\n  * Given an {@link EndpointQualifier} an {@link ServerConnectionManager} can be retrieved\n  * by {@link #getConnectionManager(EndpointQualifier)} to create or get connections on that end.\n  */\n-public interface Server {\n+public interface Server extends ConnectionListenable<ServerConnection> {\n \n     /**\n      * Returns the ServerContext.\n      */\n     ServerContext getContext();\n \n     /**\n-     * Return an aggregate endpoint which acts as a view of all endpoints merged together for reporting purposes\n-     * eg. Read total-connections\n+     * Returns the relevant {@link ServerConnectionManager} given an {@link EndpointQualifier}\n      */\n-    AggregateServerConnectionManager getAggregateConnectionManager();\n+    ServerConnectionManager getConnectionManager(EndpointQualifier qualifier);\n \n     /**\n-     * Returns the relevant {@link ServerConnectionManager} given an {@link EndpointQualifier}\n-     * On single-endpoint setups (legacy mode), then a View relevant to the requested Endpoint is returned which purely acts\n-     * as a facade to hide the API differences and maintain common signatures.\n-     * eg.\n-     * {@link com.hazelcast.instance.ProtocolType#MEMBER} -&gt;\n-     * {@link MemberViewUnifiedServerConnectionManager}\n-     * {@link com.hazelcast.instance.ProtocolType#CLIENT} -&gt;\n-     * {@link ClientViewUnifiedEndpointManager}\n-     * {@link com.hazelcast.instance.ProtocolType#REST} -&gt;\n-     * {@link TextViewUnifiedServerConnectionManager}\n-     * {@link com.hazelcast.instance.ProtocolType#MEMCACHE} -&gt;\n-     * {@link TextViewUnifiedServerConnectionManager}\n+     * Returns all connections that have been successfully established.\n+     *\n+     * @return active connections\n      */\n-    ServerConnectionManager getConnectionManager(EndpointQualifier qualifier);\n+    Collection<ServerConnection> getConnections();\n+\n+    // todo: probably we want to get rid of this method.", "originalCommit": "57841f20d6f831cd1e74b70f639a384a0120548b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ5MzE3MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16870#discussion_r413493171", "bodyText": "Not as part of this PR. But we have a getConnections and getActiveConnections and there is no clear distinction between the 2 kinds of methods; so one should IMHO go.", "author": "pveentjer", "createdAt": "2020-04-23T04:06:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjA2MzYwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE1MzA5MA==", "url": "https://github.com/hazelcast/hazelcast/pull/16870#discussion_r412153090", "bodyText": "Accessing directly Node#server field can potentially break future compatibility tests, could we use the accessor instead?", "author": "vbekiaris", "createdAt": "2020-04-21T12:46:51Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/cluster/impl/AbstractJoiner.java", "diffHunk": "@@ -238,7 +239,7 @@ private SplitBrainJoinMessage sendSplitBrainJoinMessage(Address target, SplitBra\n             logger.fine(\"Sending SplitBrainJoinMessage to \" + target);\n         }\n \n-        Connection conn = node.getConnectionManager(MEMBER).getOrConnect(target, true);\n+        Connection conn = node.server.getConnectionManager(MEMBER).getOrConnect(target, true);", "originalCommit": "57841f20d6f831cd1e74b70f639a384a0120548b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjc2MTYwNQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16870#discussion_r412761605", "bodyText": "Sure. But why would it break future compatibility tests?", "author": "pveentjer", "createdAt": "2020-04-22T08:02:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE1MzA5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjc3NTM4Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/16870#discussion_r412775382", "bodyText": "Some compatibility tests that use internals (like getting the Node of a HazelcastInstance) rely on mocks with custom Answers that handle translating method arguments & return types across different classloaders (each having loaded a different hazelcast version). Direct field access cannot be intercepted like a method call, so custom workarounds may have to be implemented.", "author": "vbekiaris", "createdAt": "2020-04-22T08:22:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE1MzA5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg3OTgxNg==", "url": "https://github.com/hazelcast/hazelcast/pull/16870#discussion_r412879816", "bodyText": "I have changed the usages to 'getServer'.", "author": "pveentjer", "createdAt": "2020-04-22T10:54:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE1MzA5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjIxNjI0OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16870#discussion_r412216249", "bodyText": "The purpose of the [Client|Member|...]ViewUnifiedConnectionManagers was to present the corresponding view of the unified connection manager with the ConnectionManager API. So client code using getConnectionManager(CLIENT) would get a ConnectionManager presenting a view of CLIENT connections backed by the unified connection manager.\nAssuming 2 members with single-socket configuration (advancedNetworkConfig#enabled == false) + 1 client connected, then\nmember1Node.getServer().getConnectionManager(CLIENT).getActiveConnections(); previously returned just 1 connection with CLIENT protocol type. With this PR, this will return the unifiedConnectionManager itself -> getActiveConnections() will return 2 connections (1 to the other cluster member + 1 to the client) which does not make sense from the point of view of an API client requesting getConnectionManager(CLIENT).", "author": "vbekiaris", "createdAt": "2020-04-21T14:07:12Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/server/tcp/TcpServer.java", "diffHunk": "@@ -233,48 +182,87 @@ public synchronized void shutdown() {\n         if (unifiedConnectionManager != null) {\n             unifiedConnectionManager.reset(true);\n         } else {\n-            for (ServerConnectionManager connectionManager : connectionManagers.values()) {\n-                ((TcpServerConnectionManager) connectionManager).reset(true);\n+            connectionManagers.values().forEach(connectionManager -> connectionManager.reset(true));\n+        }\n+    }\n+\n+    @Override\n+    public Collection<ServerConnection> getConnections() {\n+        if (unifiedConnectionManager != null) {\n+            return unifiedConnectionManager.getConnections();\n+        }\n+\n+        Set<ServerConnection> connections = null;\n+        for (TcpServerConnectionManager connectionManager : connectionManagers.values()) {\n+            Collection<ServerConnection> endpointConnections = connectionManager.getConnections();\n+            if (endpointConnections != null && !endpointConnections.isEmpty()) {\n+                if (connections == null) {\n+                    connections = new HashSet<>();\n+                }\n+\n+                connections.addAll(endpointConnections);\n             }\n         }\n+\n+        return connections == null ? Collections.emptySet() : connections;\n     }\n \n-    /**\n-     * The aggregate endpoint manager acts as a composite of all configured endpoints.\n-     * This is never null. In an environment with multiple endpoints, this is a super endpoint\n-     * that wraps them all and reports total connections or registers listeners to all separate endpoints.\n-     * Note: You can't create a connection through it, you will have to access the respective endpoint for that.\n-     *\n-     * In an environment with a unified endpoint, this will also act as a wrapper on the views of the unified endpoint\n-     * (see {@link MemberViewUnifiedServerConnectionManager} and the others).\n-     *\n-     * @return\n-     */\n     @Override\n-    public AggregateServerConnectionManager getAggregateConnectionManager() {\n-        return aggregateConnectionManager;\n+    public Collection<ServerConnection> getActiveConnections() {\n+        if (unifiedConnectionManager != null) {\n+            return unifiedConnectionManager.getActiveConnections();\n+        }\n+\n+        Set<ServerConnection> connections = null;\n+        for (TcpServerConnectionManager connectionManager : connectionManagers.values()) {\n+            Collection<ServerConnection> endpointConnections = connectionManager.getActiveConnections();\n+            if (endpointConnections != null && !endpointConnections.isEmpty()) {\n+                if (connections == null) {\n+                    connections = new HashSet<>();\n+                }\n+\n+                connections.addAll(endpointConnections);\n+            }\n+        }\n+        return connections == null ? Collections.emptySet() : connections;\n     }\n \n-    /**\n-     * Returns the respective endpoint manager based on the qualifier.\n-     * Under unified endpoint environments, this will return the respective view of the {@link UnifiedServerConnectionManager}\n-     * eg. {@link MemberViewUnifiedServerConnectionManager} or {@link ClientViewUnifiedEndpointManager} which report\n-     * connections based on the qualifier, but they register/create connection directly on the Unified manager.\n-     *\n-     * @param qualifier\n-     * @return\n-     */\n-    public ServerConnectionManager getConnectionManager(EndpointQualifier qualifier) {\n-        ServerConnectionManager mgr = connectionManagers.get(qualifier);\n-        if (mgr == null) {\n-            logger.finest(\"An connection manager for qualifier \" + qualifier + \" was never registered.\");\n+    @Override\n+    public Map<EndpointQualifier, NetworkStats> getNetworkStats() {\n+        if (unifiedConnectionManager != null) {\n+            return emptyMap();\n         }\n \n-        return mgr;\n+        Map<EndpointQualifier, NetworkStats> stats = null;\n+        for (Map.Entry<EndpointQualifier, TcpServerConnectionManager> entry : connectionManagers.entrySet()) {\n+            if (stats == null) {\n+                stats = new HashMap<>();\n+            }\n+            stats.put(entry.getKey(), entry.getValue().getNetworkStats());\n+        }\n+        return stats == null ? emptyMap() : stats;\n     }\n \n-    ServerConnectionManager getUnifiedOrDedicatedEndpointManager(EndpointQualifier qualifier) {\n-        return unifiedConnectionManager != null ? unifiedConnectionManager : connectionManagers.get(qualifier);\n+    @Override\n+    public void addConnectionListener(ConnectionListener<ServerConnection> listener) {\n+        if (unifiedConnectionManager != null) {\n+            unifiedConnectionManager.addConnectionListener(listener);\n+        } else {\n+            connectionManagers.values().forEach(manager -> manager.addConnectionListener(listener));\n+        }\n+    }\n+\n+    @Override\n+    public TcpServerConnectionManager getConnectionManager(EndpointQualifier qualifier) {\n+        if (unifiedConnectionManager != null) {\n+            return unifiedConnectionManager;", "originalCommit": "57841f20d6f831cd1e74b70f639a384a0120548b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjcwODk3MA==", "url": "https://github.com/hazelcast/hazelcast/pull/16870#discussion_r412708970", "bodyText": "The purpose of the [Client|Member|...]ViewUnifiedConnectionManagers was to present the corresponding view of the unified connection manager with the ConnectionManager API. \nIt might be the goal, but the actual implementation doesn't implement that goal:\n\nfiltering isn't done consistently.\nAPI doesn't match the views.\n\nFor example the MemberViewUnifiedServerConnectionManager will not return only members:\n @Override\n    public Collection<ServerConnection> getConnections() {\n        return unifiedEndpointManager.getConnections();\n    }\n\nIt will also return clients.\nAnd if you would register for example a connection listener on the MemberViewUnifiedServerConnectionManager and a client connection gets added in the underlying unifiedEndpointManager, the listener will get triggered on this MemberViewUnifiedServerConnectionManager. In short; you think you register for member events, but you will receive all events.\nSo filtering is ad hoc.\nAnd here is where the API doesn't make any sense. This comes from the ClientViewUnifiedEndpointManager\n   @Override\n    public ServerConnection getOrConnect(Address address) {\n        return unifiedEndpointManager.getOrConnect(address);\n    }\n\nIt doesn't make any sense for a client view because you can't connect to a client if the connection is missing. Apart from that Views are typically read only; and that isn't the case here.\nApart from being broken, I found the code very difficult to comprehend and I'm one of the main maintainers of the connection logic. So I want to simplify the logic and in some next round come up with a better approach.", "author": "pveentjer", "createdAt": "2020-04-22T06:37:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjIxNjI0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU5OTYxMA==", "url": "https://github.com/hazelcast/hazelcast/pull/16870#discussion_r413599610", "bodyText": "As discussed, the getConnectionManager(EndpointQualifier) API purpose is now clarified in javadoc. Wrong stats due to missing connection filtering will be addressed in a further PR, along with cleanup of getConnections / getActiveConnections", "author": "vbekiaris", "createdAt": "2020-04-23T08:02:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjIxNjI0OQ=="}], "type": "inlineReview"}, {"oid": "0937394b312c28c3d80a4f9f3db3bd9de112757c", "url": "https://github.com/hazelcast/hazelcast/commit/0937394b312c28c3d80a4f9f3db3bd9de112757c", "message": "ConnectionManager class simplification", "committedDate": "2020-04-22T10:53:55Z", "type": "forcePushed"}, {"oid": "2c113c47f74ea0b07beff3be4da5dd5ace640530", "url": "https://github.com/hazelcast/hazelcast/commit/2c113c47f74ea0b07beff3be4da5dd5ace640530", "message": "ConnectionManager class simplification", "committedDate": "2020-04-22T11:07:39Z", "type": "forcePushed"}, {"oid": "c4aa925e27ddd7d9a7ae4550a02f148afb766125", "url": "https://github.com/hazelcast/hazelcast/commit/c4aa925e27ddd7d9a7ae4550a02f148afb766125", "message": "ConnectionManager class simplification", "committedDate": "2020-04-22T11:53:23Z", "type": "forcePushed"}, {"oid": "ea975f8bec3cd27a87631b692392fc323f720115", "url": "https://github.com/hazelcast/hazelcast/commit/ea975f8bec3cd27a87631b692392fc323f720115", "message": "ConnectionManager class simplification", "committedDate": "2020-04-23T04:03:49Z", "type": "commit"}, {"oid": "ea975f8bec3cd27a87631b692392fc323f720115", "url": "https://github.com/hazelcast/hazelcast/commit/ea975f8bec3cd27a87631b692392fc323f720115", "message": "ConnectionManager class simplification", "committedDate": "2020-04-23T04:03:49Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU2Mjg1NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16870#discussion_r413562855", "bodyText": "to be fixed in a further PR", "author": "vbekiaris", "createdAt": "2020-04-23T07:04:21Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/ascii/TextCommandServiceImpl.java", "diffHunk": "@@ -174,13 +173,12 @@ public Stats getStats() {\n         stats.setIncrMisses(incrementMisses.get());\n         stats.setDecrHits(decrementHits.get());\n         stats.setDecrMisses(decrementMisses.get());\n-        Server server = node.server;\n+        Server server = node.getServer();\n         ServerConnectionManager cm = server.getConnectionManager(MEMCACHE);\n         int totalText = (cm != null ? cm.getActiveConnections().size() : 0);\n \n-        AggregateServerConnectionManager aem = server.getAggregateConnectionManager();\n         stats.setCurrConnections(totalText);\n-        stats.setTotalConnections(aem.getActiveConnections().size());\n+        stats.setTotalConnections(server.getActiveConnections().size());", "originalCommit": "ea975f8bec3cd27a87631b692392fc323f720115", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}