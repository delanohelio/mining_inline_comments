{"pr_number": 17174, "pr_title": "SQL client support (#17173)", "pr_createdAt": "2020-07-03T13:18:45Z", "pr_url": "https://github.com/hazelcast/hazelcast/pull/17174", "timeline": [{"oid": "4fdf806a8c42d41a2319643146855a324c5dfc3c", "url": "https://github.com/hazelcast/hazelcast/commit/4fdf806a8c42d41a2319643146855a324c5dfc3c", "message": "SQL client support", "committedDate": "2020-07-03T13:14:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDAxMzc0Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450013746", "bodyText": "We can't change public API.", "author": "viliam-durina", "createdAt": "2020-07-06T06:44:28Z", "path": "hazelcast/src/main/java/com/hazelcast/client/LoadBalancer.java", "diffHunk": "@@ -43,9 +43,10 @@\n     void init(Cluster cluster, ClientConfig config);\n \n     /**\n-     * Returns the next member to route to.\n+     * Returns the next data member to route to.\n      *\n-     * @return Returns the next member or null if no member is available\n+     * @param dataMember {@code true} if only data members should be considered\n+     * @return Returns the next data member or null if no member is available\n      */\n-    Member next();\n+    Member next(boolean dataMember);", "originalCommit": "4fdf806a8c42d41a2319643146855a324c5dfc3c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDAzNDAzMg==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450034032", "bodyText": "Fixed. Please take a look", "author": "devozerov", "createdAt": "2020-07-06T07:31:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDAxMzc0Ng=="}], "type": "inlineReview"}, {"oid": "f8156be67c7ba2308c3093a693f159b9bed599a8", "url": "https://github.com/hazelcast/hazelcast/commit/f8156be67c7ba2308c3093a693f159b9bed599a8", "message": "Fixed public API changes.", "committedDate": "2020-07-06T07:30:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDAyMTEzNg==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450021136", "bodyText": "Why is this in initializeManagementCenterTaskFactories method? We can maybe create initializeSqlTaskFactories.", "author": "viliam-durina", "createdAt": "2020-07-06T07:02:19Z", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/protocol/DefaultMessageTaskFactoryProvider.java", "diffHunk": "@@ -1779,6 +1785,15 @@ private void initializeManagementCenterTaskFactories() {\n                 (cm, con) -> new HotRestartTriggerBackupMessageTask(cm, node, con));\n         factories.put(MCInterruptHotRestartBackupCodec.REQUEST_MESSAGE_TYPE,\n                 (cm, con) -> new HotRestartInterruptBackupMessageTask(cm, node, con));\n+\n+// region ----------- REGISTRATION FOR SQL\n+        factories.put(SqlExecuteCodec.REQUEST_MESSAGE_TYPE,\n+            (cm, con) -> new SqlExecuteMessageTask(cm, node, con));\n+        factories.put(SqlFetchCodec.REQUEST_MESSAGE_TYPE,\n+            (cm, con) -> new SqlFetchMessageTask(cm, node, con));\n+        factories.put(SqlCloseCodec.REQUEST_MESSAGE_TYPE,\n+            (cm, con) -> new SqlCloseMessageTask(cm, node, con));\n+//endregion", "originalCommit": "4fdf806a8c42d41a2319643146855a324c5dfc3c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA3Mzk4OA==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450073988", "bodyText": "Fixed", "author": "devozerov", "createdAt": "2020-07-06T08:46:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDAyMTEzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDAyNTI3MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450025271", "bodyText": "Not really part of this PR, but since we only use set and get, we can replace this with a volatile field.", "author": "viliam-durina", "createdAt": "2020-07-06T07:12:19Z", "path": "hazelcast/src/main/java/com/hazelcast/client/util/AbstractLoadBalancer.java", "diffHunk": "@@ -32,8 +34,9 @@\n  */\n public abstract class AbstractLoadBalancer implements LoadBalancer, InitialMembershipListener {\n \n-    private final AtomicReference<Member[]> membersRef = new AtomicReference<Member[]>(new Member[0]);\n+    private static final Member[] EMPTY_MEMBERS = new Member[0];\n \n+    private final AtomicReference<Members> membersRef = new AtomicReference<>(new Members(EMPTY_MEMBERS, EMPTY_MEMBERS));", "originalCommit": "4fdf806a8c42d41a2319643146855a324c5dfc3c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA4NTkyNA==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450085924", "bodyText": "Agree, but as you mentioned, this is not part of this PR", "author": "devozerov", "createdAt": "2020-07-06T09:06:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDAyNTI3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDAzOTUxNw==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450039517", "bodyText": "null should be returned if no member is available, not if we're lazy to find one.", "author": "viliam-durina", "createdAt": "2020-07-06T07:42:13Z", "path": "hazelcast/src/main/java/com/hazelcast/client/util/StaticLB.java", "diffHunk": "@@ -38,7 +38,7 @@ public void init(Cluster cluster, ClientConfig config) {\n     }\n \n     @Override\n-    public Member next() {\n-        return member;\n+    public Member next(boolean dataMember) {\n+        return dataMember && member.isLiteMember() ? null : member;", "originalCommit": "4fdf806a8c42d41a2319643146855a324c5dfc3c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA3NDQyMw==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450074423", "bodyText": "I am not sure I understand what you mean. This is a static load balancer that always returns the same member. If this member doesn't happen to be a data member, we return null.", "author": "devozerov", "createdAt": "2020-07-06T08:47:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDAzOTUxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDEwOTg5MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450109891", "bodyText": "I think it would be better to throw in this case. By setting the StaticLB one asks that all traffic goes to a specific member, but here we return null which in turn will go to some data member.", "author": "viliam-durina", "createdAt": "2020-07-06T09:49:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDAzOTUxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDExMTE1MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450111151", "bodyText": "This is OK, since traffic may go to another member for many reasons:\n\nIf smart routing is disabled\nIf the member that is set is no longer reachable\nNow we add the third case - if the added member is not a data member", "author": "devozerov", "createdAt": "2020-07-06T09:51:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDAzOTUxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDExMTU2NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450111564", "bodyText": "In other words, there is no such semantics, that forces us to use a specific member. Load balancer is a hint.", "author": "devozerov", "createdAt": "2020-07-06T09:52:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDAzOTUxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA0NDU0Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450044546", "bodyText": "We could declare the return type as Set<UUID>. We actually only call contains on the returned value, a Set indicates that it's designed for that.", "author": "viliam-durina", "createdAt": "2020-07-06T07:51:57Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/NodeServiceProviderImpl.java", "diffHunk": "@@ -63,6 +64,17 @@ public UUID getLocalMemberId() {\n         return res;\n     }\n \n+    @Override\n+    public Collection<UUID> getClientMembersIds() {", "originalCommit": "f8156be67c7ba2308c3093a693f159b9bed599a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA4NTQ1MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450085451", "bodyText": "Changed to Set", "author": "devozerov", "createdAt": "2020-07-06T09:05:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA0NDU0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA0NTM0NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450045345", "bodyText": "We probably should say just \"Client cannot be reached\", a client is not a member.", "author": "viliam-durina", "createdAt": "2020-07-06T07:53:34Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/QueryException.java", "diffHunk": "@@ -62,15 +63,19 @@ public static QueryException error(int code, String message, Throwable cause, UU\n     }\n \n     public static QueryException memberConnection(UUID memberId) {\n-        return error(SqlErrorCode.MEMBER_CONNECTION, \"Connection to the member is broken: \" + memberId);\n+        return error(SqlErrorCode.MEMBER_CONNECTION, \"Member cannot be reached: \" + memberId);\n     }\n \n-    public static QueryException memberLeave(UUID memberId) {\n-        return error(SqlErrorCode.MEMBER_LEAVE, \"Participating member has left the topology: \" + memberId);\n+    public static QueryException memberConnection(Address address) {\n+        return error(SqlErrorCode.MEMBER_CONNECTION, \"Member cannot be reached: \" + address);\n     }\n \n-    public static QueryException memberLeave(Collection<UUID> memberIds) {\n-        return error(SqlErrorCode.MEMBER_LEAVE, \"Participating members have left the topology: \" + memberIds);\n+    public static QueryException memberConnection(Collection<UUID> memberIds) {\n+        return error(SqlErrorCode.MEMBER_CONNECTION, \"Members cannot be reached: \" + memberIds);\n+    }\n+\n+    public static QueryException clientMemberConnection(UUID clientId) {\n+        return error(SqlErrorCode.MEMBER_CONNECTION, \"Client member cannot be reached: \" + clientId);", "originalCommit": "f8156be67c7ba2308c3093a693f159b9bed599a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA4NTI5OA==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450085298", "bodyText": "Fixed", "author": "devozerov", "createdAt": "2020-07-06T09:05:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA0NTM0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA1MTEzMA==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450051130", "bodyText": "Suggested by intellij\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return rows != null ? rows.equals(page.rows) : page.rows == null;\n          \n          \n            \n                    return Objects.equals(rows, page.rows);", "author": "viliam-durina", "createdAt": "2020-07-06T08:05:04Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/client/SqlPage.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.client;\n+\n+import com.hazelcast.internal.serialization.Data;\n+\n+import java.util.List;\n+\n+public class SqlPage {\n+\n+    private final List<Data> rows;\n+    private final boolean last;\n+\n+    public SqlPage(List<Data> rows, boolean last) {\n+        this.rows = rows;\n+        this.last = last;\n+    }\n+\n+    public List<Data> getRows() {\n+        return rows;\n+    }\n+\n+    public boolean isLast() {\n+        return last;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+\n+        SqlPage page = (SqlPage) o;\n+\n+        if (last != page.last) {\n+            return false;\n+        }\n+\n+        return rows != null ? rows.equals(page.rows) : page.rows == null;", "originalCommit": "f8156be67c7ba2308c3093a693f159b9bed599a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA4NTIwOQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450085209", "bodyText": "Fixed", "author": "devozerov", "createdAt": "2020-07-06T09:05:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA1MTEzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA1OTIyMw==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450059223", "bodyText": "This is a fallback code that's used when the load balancer returned null, even though it should return null only if there's no member available. But it's also a fallback when the load balancer doesn't implement the nextDataMember method, and in this case we should find the first data member.\nWhat if the first member returned by the iterator isn't a data member? A user upgrading to 4.2 that has a custom LB can get random \"Client must be connected to at least one data member to execute SQL queries\" errors.", "author": "viliam-durina", "createdAt": "2020-07-06T08:20:21Z", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/connection/tcp/TcpClientConnectionManager.java", "diffHunk": "@@ -767,8 +779,25 @@ public ClientConnection getRandomConnection() {\n             }\n         }\n \n-        Iterator<TcpClientConnection> iterator = activeConnections.values().iterator();\n-        return iterator.hasNext() ? iterator.next() : null;\n+        Iterator<Map.Entry<UUID, TcpClientConnection>> iterator = activeConnections.entrySet().iterator();\n+\n+        Map.Entry<UUID, TcpClientConnection> connectionEntry = iterator.hasNext() ? iterator.next() : null;\n+\n+        if (connectionEntry != null) {\n+            if (dataMember) {\n+                UUID memberId = connectionEntry.getKey();\n+\n+                Member member = client.getClientClusterService().getMember(memberId);\n+\n+                if (member == null || member.isLiteMember()) {\n+                    return null;", "originalCommit": "f8156be67c7ba2308c3093a693f159b9bed599a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA2MTkwMQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450061901", "bodyText": "It's also used for non-smart client - can such client be connected to a lite member? Won't SQL work at all in that case?", "author": "viliam-durina", "createdAt": "2020-07-06T08:25:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA1OTIyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA3Njc4MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450076781", "bodyText": "Not really. LB is only used when smart routing is enabled (see isSmartRoutingEnabled check). Otherwise, we always use the very first member connection (aka \"unisocket\" client).\n@sancar could you please give your comments on the correct behavior?", "author": "devozerov", "createdAt": "2020-07-06T08:51:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA1OTIyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA4MzAzMQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450083031", "bodyText": "Reworked the connection handling so that dataMember=true will return a connection to a data member, even if it is not the first one.", "author": "devozerov", "createdAt": "2020-07-06T09:01:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA1OTIyMw=="}], "type": "inlineReview"}, {"oid": "f650b0b2268ad9a0695a09f19271faeaba9df0e6", "url": "https://github.com/hazelcast/hazelcast/commit/f650b0b2268ad9a0695a09f19271faeaba9df0e6", "message": "Typos", "committedDate": "2020-07-06T08:25:22Z", "type": "commit"}, {"oid": "fe85d5c72092b58e986b9ed512cd7ff034fcf121", "url": "https://github.com/hazelcast/hazelcast/commit/fe85d5c72092b58e986b9ed512cd7ff034fcf121", "message": "Proper method placement in DefaultMessageTaskFactoryProvider.java", "committedDate": "2020-07-06T08:45:57Z", "type": "commit"}, {"oid": "a1c0d6732b4f34edd97f25e3d6c12e26d6cff20c", "url": "https://github.com/hazelcast/hazelcast/commit/a1c0d6732b4f34edd97f25e3d6c12e26d6cff20c", "message": "Merge remote-tracking branch 'devozerov/issues/17173' into issues/17173", "committedDate": "2020-07-06T08:46:07Z", "type": "commit"}, {"oid": "d4f2316ad26d9fee60a302104d98fa23561e4d90", "url": "https://github.com/hazelcast/hazelcast/commit/d4f2316ad26d9fee60a302104d98fa23561e4d90", "message": "Reworked random connection handling.", "committedDate": "2020-07-06T09:00:52Z", "type": "commit"}, {"oid": "55633b28d49ce6102ad8d37e2ad752704d869b4f", "url": "https://github.com/hazelcast/hazelcast/commit/55633b28d49ce6102ad8d37e2ad752704d869b4f", "message": "Minors.", "committedDate": "2020-07-06T09:05:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDExMjc4Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450112786", "bodyText": "Should be Set<UUID> also here", "author": "viliam-durina", "createdAt": "2020-07-06T09:54:41Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/state/QueryStateRegistryUpdater.java", "diffHunk": "@@ -153,6 +160,12 @@ private void checkMemberState() {\n             }\n         }\n \n+        private void checkClientState() {\n+            Collection<UUID> activeClientIds = nodeServiceProvider.getClientIds();", "originalCommit": "55633b28d49ce6102ad8d37e2ad752704d869b4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDY0NzU4NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450647584", "bodyText": "Fixed, now Set is used.", "author": "devozerov", "createdAt": "2020-07-07T06:54:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDExMjc4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDEyNTgwNw==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450125807", "bodyText": "It would be much easier to understand if we represent the empty list with an actually empty list rather than null.\nI have checked the SqlExecuteMessageTask code. It would simplify the code there also.\nInstead of\n if (parameters.parameters != null && !parameters.parameters.isEmpty()) {\n                for (Data param : parameters.parameters) {\n                    query.addParameter(serializationService.toObject(param));\n                }\n            }\n\nthe following will suffice\n                for (Data param : parameters.parameters) {\n                    query.addParameter(serializationService.toObject(param));\n                }", "author": "sancar", "createdAt": "2020-07-06T10:19:12Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/client/SqlClientService.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.client;\n+\n+import com.hazelcast.client.impl.ClientDelegatingFuture;\n+import com.hazelcast.client.impl.clientside.ClientMessageDecoder;\n+import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;\n+import com.hazelcast.client.impl.protocol.ClientMessage;\n+import com.hazelcast.client.impl.protocol.codec.SqlCloseCodec;\n+import com.hazelcast.client.impl.protocol.codec.SqlExecuteCodec;\n+import com.hazelcast.client.impl.protocol.codec.SqlFetchCodec;\n+import com.hazelcast.client.impl.spi.impl.ClientInvocation;\n+import com.hazelcast.client.impl.spi.impl.ClientInvocationFuture;\n+import com.hazelcast.internal.nio.Connection;\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.internal.serialization.InternalSerializationService;\n+import com.hazelcast.sql.SqlErrorCode;\n+import com.hazelcast.sql.SqlException;\n+import com.hazelcast.sql.SqlQuery;\n+import com.hazelcast.sql.SqlResult;\n+import com.hazelcast.sql.SqlService;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.QueryId;\n+import com.hazelcast.sql.impl.QueryUtils;\n+import com.hazelcast.sql.impl.row.Row;\n+\n+import javax.annotation.Nonnull;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+/**\n+ * Client-side implementation of SQL service.\n+ */\n+public class SqlClientService implements SqlService {\n+\n+    private static final ClientMessageDecoder<SqlExecuteResponse> EXECUTE_DECODER = clientMessage -> {\n+        SqlExecuteCodec.ResponseParameters response = SqlExecuteCodec.decodeResponse(clientMessage);\n+\n+        return new SqlExecuteResponse(response.queryId, response.rowMetadata, response.rowPage, response.error);\n+    };\n+\n+    private static final ClientMessageDecoder<SqlFetchResponse> FETCH_DECODER = clientMessage -> {\n+        SqlFetchCodec.ResponseParameters response = SqlFetchCodec.decodeResponse(clientMessage);\n+\n+        return new SqlFetchResponse(response.rowPage, response.error);\n+    };\n+\n+    private static final ClientMessageDecoder<Void> CLOSE_DECODER = clientMessage -> {\n+        SqlCloseCodec.decodeResponse(clientMessage);\n+\n+        return null;\n+    };\n+\n+    private final HazelcastClientInstanceImpl client;\n+\n+    public SqlClientService(HazelcastClientInstanceImpl client) {\n+        this.client = client;\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public SqlResult query(@Nonnull SqlQuery query) {\n+        Connection connection = client.getConnectionManager().getRandomConnection(true);\n+\n+        if (connection == null) {\n+            throw rethrow(QueryException.error(\n+                SqlErrorCode.CONNECTION_PROBLEM,\n+                \"Client must be connected to at least one data member to execute SQL queries\"\n+            ));\n+        }\n+\n+        try {\n+            List<Object> params = query.getParameters();\n+            List<Data> params0;\n+\n+            if (!params.isEmpty()) {\n+                params0 = new ArrayList<>(params.size());\n+\n+                for (Object param : params) {\n+                    params0.add(serializeParameter(param));\n+                }\n+            } else {\n+                params0 = null;", "originalCommit": "55633b28d49ce6102ad8d37e2ad752704d869b4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDY0NzUwNQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450647505", "bodyText": "Fixed, now parameters are non-null.", "author": "devozerov", "createdAt": "2020-07-07T06:54:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDEyNTgwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDEyOTkxMw==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450129913", "bodyText": "You don't need the ClientDelegatingFuture since you are doing a sync call. It is mostly needed when we need to pass a future to the user(or other part of the system)\nWhy not just do the following instead?\nClientMessage clientMessage = fut.get();\nreturn decoder.decodeClientMessage(clientMessage);\n\nEven further, there is no need for static decoder functions because they are all sync calls.\nI would suggest making the return type ClientMessage.  For the fetch method:\n            ClientMessage responseMessage = invoke(message, connection);\n            SqlFetchCodec.ResponseParameters response = SqlFetchCodec.decodeResponse(responseMessage);\n            SqlFetchResponse res = new SqlFetchResponse(response.rowPage, response.error);\n            handleResponseError(res.getError());\n\nStatic decoder functions and delegating future are used for async cases. There is no need to complicate the code with them when not needed.", "author": "sancar", "createdAt": "2020-07-06T10:27:25Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/client/SqlClientService.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.client;\n+\n+import com.hazelcast.client.impl.ClientDelegatingFuture;\n+import com.hazelcast.client.impl.clientside.ClientMessageDecoder;\n+import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;\n+import com.hazelcast.client.impl.protocol.ClientMessage;\n+import com.hazelcast.client.impl.protocol.codec.SqlCloseCodec;\n+import com.hazelcast.client.impl.protocol.codec.SqlExecuteCodec;\n+import com.hazelcast.client.impl.protocol.codec.SqlFetchCodec;\n+import com.hazelcast.client.impl.spi.impl.ClientInvocation;\n+import com.hazelcast.client.impl.spi.impl.ClientInvocationFuture;\n+import com.hazelcast.internal.nio.Connection;\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.internal.serialization.InternalSerializationService;\n+import com.hazelcast.sql.SqlErrorCode;\n+import com.hazelcast.sql.SqlException;\n+import com.hazelcast.sql.SqlQuery;\n+import com.hazelcast.sql.SqlResult;\n+import com.hazelcast.sql.SqlService;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.QueryId;\n+import com.hazelcast.sql.impl.QueryUtils;\n+import com.hazelcast.sql.impl.row.Row;\n+\n+import javax.annotation.Nonnull;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+/**\n+ * Client-side implementation of SQL service.\n+ */\n+public class SqlClientService implements SqlService {\n+\n+    private static final ClientMessageDecoder<SqlExecuteResponse> EXECUTE_DECODER = clientMessage -> {\n+        SqlExecuteCodec.ResponseParameters response = SqlExecuteCodec.decodeResponse(clientMessage);\n+\n+        return new SqlExecuteResponse(response.queryId, response.rowMetadata, response.rowPage, response.error);\n+    };\n+\n+    private static final ClientMessageDecoder<SqlFetchResponse> FETCH_DECODER = clientMessage -> {\n+        SqlFetchCodec.ResponseParameters response = SqlFetchCodec.decodeResponse(clientMessage);\n+\n+        return new SqlFetchResponse(response.rowPage, response.error);\n+    };\n+\n+    private static final ClientMessageDecoder<Void> CLOSE_DECODER = clientMessage -> {\n+        SqlCloseCodec.decodeResponse(clientMessage);\n+\n+        return null;\n+    };\n+\n+    private final HazelcastClientInstanceImpl client;\n+\n+    public SqlClientService(HazelcastClientInstanceImpl client) {\n+        this.client = client;\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public SqlResult query(@Nonnull SqlQuery query) {\n+        Connection connection = client.getConnectionManager().getRandomConnection(true);\n+\n+        if (connection == null) {\n+            throw rethrow(QueryException.error(\n+                SqlErrorCode.CONNECTION_PROBLEM,\n+                \"Client must be connected to at least one data member to execute SQL queries\"\n+            ));\n+        }\n+\n+        try {\n+            List<Object> params = query.getParameters();\n+            List<Data> params0;\n+\n+            if (!params.isEmpty()) {\n+                params0 = new ArrayList<>(params.size());\n+\n+                for (Object param : params) {\n+                    params0.add(serializeParameter(param));\n+                }\n+            } else {\n+                params0 = null;\n+            }\n+\n+            ClientMessage message = SqlExecuteCodec.encodeRequest(\n+                query.getSql(),\n+                params0,\n+                query.getTimeoutMillis(),\n+                query.getCursorBufferSize()\n+            );\n+\n+            SqlExecuteResponse response = invoke(message, connection, EXECUTE_DECODER);\n+\n+            handleResponseError(response.getError());\n+\n+            return new SqlClientResult(\n+                this,\n+                connection,\n+                response.getQueryId(),\n+                response.getRowMetadata(),\n+                response.getPage(),\n+                query.getCursorBufferSize()\n+            );\n+        } catch (Exception e) {\n+            throw rethrow(e, connection);\n+        }\n+    }\n+\n+    /**\n+     * Fetch the next page of the given query.\n+     *\n+     * @param connection Connection.\n+     * @param queryId Query ID.\n+     * @return Pair: fetched rows + last page flag.\n+     */\n+    public SqlPage fetch(Connection connection, QueryId queryId, int cursorBufferSize) {\n+        try {\n+            ClientMessage message = SqlFetchCodec.encodeRequest(queryId, cursorBufferSize);\n+\n+            SqlFetchResponse res = invoke(message, connection, FETCH_DECODER);\n+\n+            handleResponseError(res.getError());\n+\n+            return res.getPage();\n+        } catch (Exception e) {\n+            throw rethrow(e, connection);\n+        }\n+    }\n+\n+    /**\n+     * Close remote query cursor.\n+     *\n+     * @param connection Connection.\n+     * @param queryId Query ID.\n+     */\n+    void close(Connection connection, QueryId queryId) {\n+        try {\n+            ClientMessage request = SqlCloseCodec.encodeRequest(queryId);\n+\n+            invoke(request, connection, CLOSE_DECODER);\n+        } catch (Exception e) {\n+            throw rethrow(e, connection);\n+        }\n+    }\n+\n+    private Data serializeParameter(Object parameter) {\n+        try {\n+            return getSerializationService().toData(parameter);\n+        } catch (Exception e) {\n+            throw rethrow(\n+                QueryException.error(\"Failed to serialize query parameter \" + parameter + \": \" + e.getMessage())\n+            );\n+        }\n+    }\n+\n+    Row deserializeRow(Data data) {\n+        try {\n+            return getSerializationService().toObject(data);\n+        } catch (Exception e) {\n+            throw rethrow(\n+                QueryException.error(\"Failed to deserialize query result row: \" + e.getMessage())\n+            );\n+        }\n+    }\n+\n+    private UUID getClientId() {\n+        return client.getLocalEndpoint().getUuid();\n+    }\n+\n+    private InternalSerializationService getSerializationService() {\n+        return client.getSerializationService();\n+    }\n+\n+    private <T> T invoke(ClientMessage request, Connection connection, ClientMessageDecoder<T> decoder) throws Exception {\n+        ClientInvocation invocation = new ClientInvocation(client, request, null, connection);\n+\n+        ClientInvocationFuture fut = invocation.invoke();\n+\n+        return new ClientDelegatingFuture<T>(fut, getSerializationService(), decoder, false).get();", "originalCommit": "55633b28d49ce6102ad8d37e2ad752704d869b4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDY1MjAyNg==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450652026", "bodyText": "Simplified as you suggested.", "author": "devozerov", "createdAt": "2020-07-07T07:04:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDEyOTkxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDEzMzgwNA==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450133804", "bodyText": "So a un\u0131socket client that is connected to a lite member can not run a query?\nThis is not suited to our unisocket client behavior. Our unisocket clients should be able to operate same regardless of the member type they are connected to.", "author": "sancar", "createdAt": "2020-07-06T10:35:36Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/client/SqlClientService.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.client;\n+\n+import com.hazelcast.client.impl.ClientDelegatingFuture;\n+import com.hazelcast.client.impl.clientside.ClientMessageDecoder;\n+import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;\n+import com.hazelcast.client.impl.protocol.ClientMessage;\n+import com.hazelcast.client.impl.protocol.codec.SqlCloseCodec;\n+import com.hazelcast.client.impl.protocol.codec.SqlExecuteCodec;\n+import com.hazelcast.client.impl.protocol.codec.SqlFetchCodec;\n+import com.hazelcast.client.impl.spi.impl.ClientInvocation;\n+import com.hazelcast.client.impl.spi.impl.ClientInvocationFuture;\n+import com.hazelcast.internal.nio.Connection;\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.internal.serialization.InternalSerializationService;\n+import com.hazelcast.sql.SqlErrorCode;\n+import com.hazelcast.sql.SqlException;\n+import com.hazelcast.sql.SqlQuery;\n+import com.hazelcast.sql.SqlResult;\n+import com.hazelcast.sql.SqlService;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.QueryId;\n+import com.hazelcast.sql.impl.QueryUtils;\n+import com.hazelcast.sql.impl.row.Row;\n+\n+import javax.annotation.Nonnull;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+/**\n+ * Client-side implementation of SQL service.\n+ */\n+public class SqlClientService implements SqlService {\n+\n+    private static final ClientMessageDecoder<SqlExecuteResponse> EXECUTE_DECODER = clientMessage -> {\n+        SqlExecuteCodec.ResponseParameters response = SqlExecuteCodec.decodeResponse(clientMessage);\n+\n+        return new SqlExecuteResponse(response.queryId, response.rowMetadata, response.rowPage, response.error);\n+    };\n+\n+    private static final ClientMessageDecoder<SqlFetchResponse> FETCH_DECODER = clientMessage -> {\n+        SqlFetchCodec.ResponseParameters response = SqlFetchCodec.decodeResponse(clientMessage);\n+\n+        return new SqlFetchResponse(response.rowPage, response.error);\n+    };\n+\n+    private static final ClientMessageDecoder<Void> CLOSE_DECODER = clientMessage -> {\n+        SqlCloseCodec.decodeResponse(clientMessage);\n+\n+        return null;\n+    };\n+\n+    private final HazelcastClientInstanceImpl client;\n+\n+    public SqlClientService(HazelcastClientInstanceImpl client) {\n+        this.client = client;\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public SqlResult query(@Nonnull SqlQuery query) {\n+        Connection connection = client.getConnectionManager().getRandomConnection(true);\n+\n+        if (connection == null) {\n+            throw rethrow(QueryException.error(\n+                SqlErrorCode.CONNECTION_PROBLEM,\n+                \"Client must be connected to at least one data member to execute SQL queries\"", "originalCommit": "55633b28d49ce6102ad8d37e2ad752704d869b4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE1Nzg2Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450157862", "bodyText": "You can check CreateProxyMessageTask. It is one of the places that we explicitly redirect to a data member.\nThe partition-based ones solve the problem automatically since they will run on their partition owner anyway. Even if we invoke the operation on a lite member, the invocation system redirects it to the partition owner.", "author": "sancar", "createdAt": "2020-07-06T11:28:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDEzMzgwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE5MjIxOQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450192219", "bodyText": "Yes, SQL may not work if there lite members in the topology. This is ok for the beta stage at least. Lite member support might be added in the future if we see a demand from users.\nThis limitation will be mentioned explicitly in the product's documentation.", "author": "devozerov", "createdAt": "2020-07-06T12:40:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDEzMzgwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE5NjQzOQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450196439", "bodyText": "I think it's pretty bad that it will fail to work randomly, depending on the member the non-smart client happens to connect. Users might try it and see that it works and then have this misleading error at runtime. In that case we should disallow non-smart clients entirely.", "author": "viliam-durina", "createdAt": "2020-07-06T12:48:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDEzMzgwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDIwMDc1NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450200754", "bodyText": "Documentation solves this. Again - we do not support lite members not because we are lazy, or because we do not understand the implications. This is a necessary measure given the huge scope.\nMoreover, in the current PR, we iterate over all members to find the data member for SQL. The flakiness you mentioned is only possible if a user will toggle the member's state back and forth. This is extremely unlikely.", "author": "devozerov", "createdAt": "2020-07-06T12:55:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDEzMzgwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDIxNTc2Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450215763", "bodyText": "Iterating all connections does not help unisocket client. It will only have one connection. If the client disconnect from data member and connects to lite member, then it will fail.\nIf this is the decision, we basically say that for the uniscoket client, if you use query, your cluster should not contain a lite member. For the smart client, I agree that the problem is very unlikely to occur.", "author": "sancar", "createdAt": "2020-07-06T13:21:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDEzMzgwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE0NzIzOQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450147239", "bodyText": "Both serialization service and client protocol have built-in UUID support. If the only purpose of these High and Low part splits is to support them, I think you can just use UUID instead.", "author": "asimarslan", "createdAt": "2020-07-06T11:04:32Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/QueryId.java", "diffHunk": "@@ -35,20 +35,20 @@\n     private long memberIdLow;\n \n     /** Local ID: most significant bits. */\n-    private long localHigh;\n+    private long localIdHigh;\n \n     /** Local ID: least significant bits. */\n-    private long localLow;\n+    private long localIdLow;\n \n     public QueryId() {\n         // No-op.\n     }\n \n-    QueryId(long memberIdHigh, long memberIdLow, long localHigh, long localLow) {\n+    public QueryId(long memberIdHigh, long memberIdLow, long localIdHigh, long localIdLow) {\n         this.memberIdHigh = memberIdHigh;\n         this.memberIdLow = memberIdLow;\n-        this.localHigh = localHigh;\n-        this.localLow = localLow;\n+        this.localIdHigh = localIdHigh;", "originalCommit": "55633b28d49ce6102ad8d37e2ad752704d869b4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE0ODMxNA==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450148314", "bodyText": "protocol schema will redirect you if you configure it on the protocol side.\nhttps://github.com/hazelcast/hazelcast-client-protocol/blob/master/schema/protocol-schema.json#L26", "author": "asimarslan", "createdAt": "2020-07-06T11:06:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE0NzIzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE5MzI4Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450193282", "bodyText": "UUID content is inlined into the QueryId to reduce the amount of litter. Real UUIDs are rarely extracted from this object. We only do equals/hashCode on hot paths.", "author": "devozerov", "createdAt": "2020-07-06T12:42:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE0NzIzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQyMTgyNQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r451421825", "bodyText": "@devozerov I understand the optimization but UUID is a common class that we use. This will be an exception to how we represent it. I would prefer using UUID for the sake of readability.", "author": "sancar", "createdAt": "2020-07-08T09:50:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE0NzIzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQyNTQwMA==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r451425400", "bodyText": "Let me highlight this once again - QueryId is not UUID. We use two UUID-s to guarantee its uniqueness, but other than that it is mostly an opaque blob.", "author": "devozerov", "createdAt": "2020-07-08T09:57:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE0NzIzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQyOTkwMw==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r451429903", "bodyText": "This way of this UUID usage does not match to protocol style. Not all languages use to high low split of a UUID as java.\nMemberID is already created somewhere on the member, you don't need to split it for litter optimization. let the protocol encode/Decode it.\nFor the localId, how many local id's are created in the system? if they are per query, I don't think you should worry about the litter it creates.\nWe already use UUID in memberId and listenerRegistrationId etc, which are also infrequent.\nI understand you want to optimize it in the best way possible but protocol definition is also an important part of our architecture. Moreover, we cannot change the protocol when we publish it.", "author": "asimarslan", "createdAt": "2020-07-08T10:05:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE0NzIzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTk4NDg5MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r451984891", "bodyText": "Colleagues, I would like to emphasize one more time what is the nature of query ID. From the client perspective, it is an opaque blob that is passed back and forth. From the server perspective, this is an object that serves multiple purposes, such as 1) guaranteeing cluster-wide uniqueness; 2) providing an ability to find the originator member ID without remote requests.\nThe design of the client protocol cannot enforce the content of this object, because client doesn't use any features of it, while the server does. Therefore, it cannot be UUID.\nOn the other hand, I share your concerns about future protocol changes. So I propose the other solution - to change it to String. This would be a good choice from the protocol perspective for an opaque object. If we would like to change the content of this object on the server, the client protocol will not be affected.\nI merged these changes to the PR, please take a look.", "author": "devozerov", "createdAt": "2020-07-09T06:10:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE0NzIzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODA0NDQ5OA==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r458044498", "bodyText": "@devozerov if the client doesn't need the content of this, I think 4 long value representation is much better than string. String needs to be parsed on server side and it's not a good idea.\nOur initial concern was about parsing the internal UUIDs but as you say the client won't need it.\nThe original QueryId should be used instead of a string.", "author": "asimarslan", "createdAt": "2020-07-21T12:04:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE0NzIzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIzNDY0OA==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r458234648", "bodyText": "I used to think that QueryId was good solution, but now I think that String is better.\nAs explained before, the query ID is completely opaque to the client, I.e. it is only passed back and forth. String representation has two advantages over QueryId:\n\nIt is more stable - we can change the server-side representation without breaking protocol compatibility\nIt makes client implementation simpler. Consider that we will have SQL implemented in many clients in future. All of them would have to implement a custom object that does zero useful work\n\nThat said, IMO String is good enough. Also please note that there is no parsing on the sever side. We convert QueryId to String once (see QueryId.unparse) and then use this String as a key. There should be no negative performance impact from this.\nWDYT?", "author": "devozerov", "createdAt": "2020-07-21T16:35:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE0NzIzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE3MTM1OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450171359", "bodyText": "This does not seem correct. We are not using Data for builtin IdentifiedDataSerializable objects on our protocol as much as possible. It is hard to define what is Data in the protocol. More importantly, they don't support evolution, it is very likely to make a mistake.\nI see that Row is an interface. Which Row implementations can we return to the client?", "author": "sancar", "createdAt": "2020-07-06T11:58:02Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/client/QueryClientStateRegistry.java", "diffHunk": "@@ -0,0 +1,167 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.client;\n+\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.internal.serialization.InternalSerializationService;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.SqlRow;\n+import com.hazelcast.sql.impl.QueryId;\n+import com.hazelcast.sql.impl.SqlResultImpl;\n+import com.hazelcast.sql.impl.SqlRowImpl;\n+import com.hazelcast.sql.impl.row.Row;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * Registry of active client cursors.\n+ */\n+public class QueryClientStateRegistry {\n+    /** Registered client cursors. */\n+    private final ConcurrentHashMap<QueryId, QueryClientState> clientCursors = new ConcurrentHashMap<>();\n+\n+    public SqlPage registerAndFetch(\n+        UUID clientId,\n+        SqlResultImpl cursor,\n+        int cursorBufferSize,\n+        InternalSerializationService serializationService\n+    ) {\n+        QueryClientState clientCursor = new QueryClientState(clientId, cursor);\n+\n+        SqlPage page = fetchInternal(clientCursor, cursorBufferSize, serializationService);\n+\n+        if (!page.isLast()) {\n+            clientCursors.put(cursor.getQueryId(), clientCursor);\n+        }\n+\n+        return page;\n+    }\n+\n+    public SqlPage fetch(\n+        UUID clientId,\n+        QueryId queryId,\n+        int cursorBufferSize,\n+        InternalSerializationService serializationService\n+    ) {\n+        QueryClientState clientCursor = getClientCursor(clientId, queryId);\n+\n+        if (clientCursor == null) {\n+            throw QueryException.error(\"Query cursor is not found (closed?): \" + queryId);\n+        }\n+\n+        SqlPage page = fetchInternal(clientCursor, cursorBufferSize, serializationService);\n+\n+        if (page.isLast()) {\n+            deleteClientCursor(clientCursor);\n+        }\n+\n+        return page;\n+    }\n+\n+    private SqlPage fetchInternal(\n+        QueryClientState clientCursor,\n+        int cursorBufferSize,\n+        InternalSerializationService serializationService\n+    ) {\n+        Iterator<SqlRow> iterator = clientCursor.getIterator();\n+\n+        List<Data> page = new ArrayList<>(cursorBufferSize);\n+        boolean last = fetchPage(iterator, page, cursorBufferSize, serializationService);\n+\n+        if (last) {\n+            deleteClientCursor(clientCursor);\n+        }\n+\n+        return new SqlPage(page, last);\n+    }\n+\n+    private boolean fetchPage(\n+        Iterator<SqlRow> iterator,\n+        List<Data> page,\n+        int cursorBufferSize,\n+        InternalSerializationService serializationService\n+    ) {\n+        while (iterator.hasNext()) {\n+            SqlRow row = iterator.next();\n+            Row rowInternal = ((SqlRowImpl) row).getDelegate();\n+            Data rowData = serializationService.toData(rowInternal);", "originalCommit": "55633b28d49ce6102ad8d37e2ad752704d869b4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE5MTMwNw==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450191307", "bodyText": "I'll change it to List<Data>. There is no model for a row at the moment.", "author": "devozerov", "createdAt": "2020-07-06T12:38:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE3MTM1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDY0NzkwOA==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450647908", "bodyText": "Fixed. Now List<Data> is used to represent row values. Please take a look.", "author": "devozerov", "createdAt": "2020-07-07T06:55:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE3MTM1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE4MTcyMA==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450181720", "bodyText": "I could not find the cleanup code for the case where a client lefts the cluster without closing the query.\nYou can use ClientEndpoint.addDestroyAction(UUID registrationId, Callable<Boolean> removeAction); for this.\nA client enndpoint is removed and all desrtoy actions are called when the assocaiated connection is disconnected. Since the queries are desinged to be sticky it looks like a good fit.", "author": "sancar", "createdAt": "2020-07-06T12:19:43Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/client/QueryClientStateRegistry.java", "diffHunk": "@@ -0,0 +1,167 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.client;\n+\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.internal.serialization.InternalSerializationService;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.SqlRow;\n+import com.hazelcast.sql.impl.QueryId;\n+import com.hazelcast.sql.impl.SqlResultImpl;\n+import com.hazelcast.sql.impl.SqlRowImpl;\n+import com.hazelcast.sql.impl.row.Row;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * Registry of active client cursors.\n+ */\n+public class QueryClientStateRegistry {\n+    /** Registered client cursors. */\n+    private final ConcurrentHashMap<QueryId, QueryClientState> clientCursors = new ConcurrentHashMap<>();", "originalCommit": "55633b28d49ce6102ad8d37e2ad752704d869b4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE4MjEwNQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450182105", "bodyText": "And can we have a test to verify that cleanups are done correctly?", "author": "sancar", "createdAt": "2020-07-06T12:20:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE4MTcyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE4ODg0NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450188844", "bodyText": "I see that QueryClientStateRegistry.update is used for this purpose. I think, our standard solution with ClientEndpoint addDestroyAction is enough for this. What do you think ?", "author": "sancar", "createdAt": "2020-07-06T12:33:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE4MTcyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE5MDU1Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450190557", "bodyText": "Please see:\ncom.hazelcast.sql.impl.client.QueryClientStateRegistry#update\ncom.hazelcast.sql.SqlErrorClientTest#testCursorCleanupOnClientLeave", "author": "devozerov", "createdAt": "2020-07-06T12:36:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE4MTcyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDIwNTg0NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450205845", "bodyText": "ClientEndpoint addDestroyAction looks heavier to me - one have to register it for every request, and also be careful to deregister it properly.\nThe key observation is that majority of requests will be completed normally, without client disconnects. I think the current approach handles it better - we do no do any additional actions for the most queries.", "author": "devozerov", "createdAt": "2020-07-06T13:04:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE4MTcyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTMzMDcyNg==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r451330726", "bodyText": "Ok. Fair enough.", "author": "sancar", "createdAt": "2020-07-08T07:14:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE4MTcyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE4MzM2OA==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450183368", "bodyText": "Is permission left null on purpose? I think, SQL permissions are important.", "author": "sancar", "createdAt": "2020-07-06T12:23:00Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/client/SqlExecuteMessageTask.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.client;\n+\n+import com.hazelcast.client.impl.protocol.ClientMessage;\n+import com.hazelcast.client.impl.protocol.codec.SqlExecuteCodec;\n+import com.hazelcast.client.impl.protocol.task.AbstractCallableMessageTask;\n+import com.hazelcast.instance.impl.Node;\n+import com.hazelcast.internal.nio.Connection;\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.sql.SqlQuery;\n+import com.hazelcast.sql.impl.SqlInternalService;\n+import com.hazelcast.sql.impl.SqlResultImpl;\n+import com.hazelcast.sql.impl.SqlServiceImpl;\n+\n+import java.security.Permission;\n+\n+/**\n+ * SQL query execute task.\n+ */\n+public class SqlExecuteMessageTask extends AbstractCallableMessageTask<SqlExecuteCodec.RequestParameters> {\n+    public SqlExecuteMessageTask(ClientMessage clientMessage, Node node, Connection connection) {\n+        super(clientMessage, node, connection);\n+    }\n+\n+    @Override\n+    protected Object call() throws Exception {\n+        try {\n+            SqlQuery query = new SqlQuery(parameters.sql);\n+\n+            if (parameters.parameters != null && !parameters.parameters.isEmpty()) {\n+                for (Data param : parameters.parameters) {\n+                    query.addParameter(serializationService.toObject(param));\n+                }\n+            }\n+\n+            query.setTimeoutMillis(parameters.timeoutMillis);\n+            query.setCursorBufferSize(parameters.cursorBufferSize);\n+\n+            SqlServiceImpl sqlService = nodeEngine.getSqlService();\n+\n+            SqlResultImpl cursor = (SqlResultImpl) sqlService.query(query);\n+\n+            SqlPage page = sqlService.getInternalService().getClientStateRegistry().registerAndFetch(\n+                endpoint.getUuid(),\n+                cursor,\n+                parameters.cursorBufferSize,\n+                serializationService\n+            );\n+\n+            return new SqlExecuteResponse(\n+                cursor.getQueryId(),\n+                cursor.getRowMetadata(),\n+                page,\n+                null\n+            );\n+        } catch (Exception e) {\n+            SqlError error = SqlClientUtils.exceptionToClientError(e, nodeEngine.getLocalMember().getUuid());\n+\n+            return new SqlExecuteResponse(null, null, null, error);\n+        }\n+    }\n+\n+    @Override\n+    protected SqlExecuteCodec.RequestParameters decodeClientMessage(ClientMessage clientMessage) {\n+        return SqlExecuteCodec.decodeRequest(clientMessage);\n+    }\n+\n+    @Override\n+    protected ClientMessage encodeResponse(Object response) {\n+        SqlExecuteResponse response0 = (SqlExecuteResponse) response;\n+\n+        return SqlExecuteCodec.encodeResponse(\n+            response0.getQueryId(),\n+            response0.getRowMetadata(),\n+            response0.getPage(),\n+            response0.getError()\n+        );\n+    }\n+\n+    @Override\n+    public String getServiceName() {\n+        return SqlInternalService.SERVICE_NAME;\n+    }\n+\n+    @Override\n+    public String getDistributedObjectName() {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getMethodName() {\n+        return \"execute\";\n+    }\n+\n+    @Override\n+    public Object[] getParameters() {\n+        return new Object[] {\n+            parameters.sql,\n+            parameters.parameters,\n+            parameters.timeoutMillis,\n+            parameters.cursorBufferSize\n+        } ;\n+    }\n+\n+    @Override\n+    public Permission getRequiredPermission() {\n+        return null;", "originalCommit": "55633b28d49ce6102ad8d37e2ad752704d869b4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE4OTc1Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450189756", "bodyText": "We do not have a security model yet. Given that an SQL script could trigger any kind of action (e.g. read from several maps, or start Jet job, etc), it is impossible to define the required permissions on that level. The permissions will be known after parsing only.\nMeanwhile, we may add a global flag to disable SQL on the member, but this is out of scope of this PR.", "author": "devozerov", "createdAt": "2020-07-06T12:35:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE4MzM2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE5ODk5Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450198993", "bodyText": "I think we may define a global \"query\" permission that will govern whether the user can execute any query or not. And more deep integration will be implemented later.", "author": "devozerov", "createdAt": "2020-07-06T12:52:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE4MzM2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDY4NjcwNQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450686705", "bodyText": "Added the sql permission, modeled after the transaction permission.", "author": "devozerov", "createdAt": "2020-07-07T08:13:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE4MzM2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE4Mzk0Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450183942", "bodyText": "for the method name, we usually use the user API method name. So should it be query?  And note that related tests are on the enterprise repo. Make sure that you have SecurityInterceptor and permission tests for the new use case.", "author": "sancar", "createdAt": "2020-07-06T12:24:10Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/client/SqlExecuteMessageTask.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.client;\n+\n+import com.hazelcast.client.impl.protocol.ClientMessage;\n+import com.hazelcast.client.impl.protocol.codec.SqlExecuteCodec;\n+import com.hazelcast.client.impl.protocol.task.AbstractCallableMessageTask;\n+import com.hazelcast.instance.impl.Node;\n+import com.hazelcast.internal.nio.Connection;\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.sql.SqlQuery;\n+import com.hazelcast.sql.impl.SqlInternalService;\n+import com.hazelcast.sql.impl.SqlResultImpl;\n+import com.hazelcast.sql.impl.SqlServiceImpl;\n+\n+import java.security.Permission;\n+\n+/**\n+ * SQL query execute task.\n+ */\n+public class SqlExecuteMessageTask extends AbstractCallableMessageTask<SqlExecuteCodec.RequestParameters> {\n+    public SqlExecuteMessageTask(ClientMessage clientMessage, Node node, Connection connection) {\n+        super(clientMessage, node, connection);\n+    }\n+\n+    @Override\n+    protected Object call() throws Exception {\n+        try {\n+            SqlQuery query = new SqlQuery(parameters.sql);\n+\n+            if (parameters.parameters != null && !parameters.parameters.isEmpty()) {\n+                for (Data param : parameters.parameters) {\n+                    query.addParameter(serializationService.toObject(param));\n+                }\n+            }\n+\n+            query.setTimeoutMillis(parameters.timeoutMillis);\n+            query.setCursorBufferSize(parameters.cursorBufferSize);\n+\n+            SqlServiceImpl sqlService = nodeEngine.getSqlService();\n+\n+            SqlResultImpl cursor = (SqlResultImpl) sqlService.query(query);\n+\n+            SqlPage page = sqlService.getInternalService().getClientStateRegistry().registerAndFetch(\n+                endpoint.getUuid(),\n+                cursor,\n+                parameters.cursorBufferSize,\n+                serializationService\n+            );\n+\n+            return new SqlExecuteResponse(\n+                cursor.getQueryId(),\n+                cursor.getRowMetadata(),\n+                page,\n+                null\n+            );\n+        } catch (Exception e) {\n+            SqlError error = SqlClientUtils.exceptionToClientError(e, nodeEngine.getLocalMember().getUuid());\n+\n+            return new SqlExecuteResponse(null, null, null, error);\n+        }\n+    }\n+\n+    @Override\n+    protected SqlExecuteCodec.RequestParameters decodeClientMessage(ClientMessage clientMessage) {\n+        return SqlExecuteCodec.decodeRequest(clientMessage);\n+    }\n+\n+    @Override\n+    protected ClientMessage encodeResponse(Object response) {\n+        SqlExecuteResponse response0 = (SqlExecuteResponse) response;\n+\n+        return SqlExecuteCodec.encodeResponse(\n+            response0.getQueryId(),\n+            response0.getRowMetadata(),\n+            response0.getPage(),\n+            response0.getError()\n+        );\n+    }\n+\n+    @Override\n+    public String getServiceName() {\n+        return SqlInternalService.SERVICE_NAME;\n+    }\n+\n+    @Override\n+    public String getDistributedObjectName() {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getMethodName() {\n+        return \"execute\";", "originalCommit": "55633b28d49ce6102ad8d37e2ad752704d869b4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE5NTM1Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450195353", "bodyText": "I can change it to query, but what is the goal of this? From the user perspective, he executes a query, but internally it is translated into several different commands, that are not directly mapped to the public API. Moreover, the result of this operation contains internal objects, which also highlights that this is not a direct API call.", "author": "devozerov", "createdAt": "2020-07-06T12:46:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE4Mzk0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDIxMDI4MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450210281", "bodyText": "Well, we don't really have a clear answer. In the end, whatever you choose must be documented clearly. We select it as same as the public method name to make it more intuitive. Not sure what to do when it is multiple requests per API call.\nJust be aware that what you choose here is also a public API and needs to be documented.", "author": "sancar", "createdAt": "2020-07-06T13:12:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE4Mzk0Mg=="}], "type": "inlineReview"}, {"oid": "1d0414080aef15b7526eb961cc1505f5614f28b9", "url": "https://github.com/hazelcast/hazelcast/commit/1d0414080aef15b7526eb961cc1505f5614f28b9", "message": "1) Added more tests for server-side cursor cleanup\n2) Reworked protocol page representation from List<Data> to List<List<Data>\n3) Made query parameters non-nullable in the protocol\n4) Several other minor changes", "committedDate": "2020-07-07T06:53:31Z", "type": "commit"}, {"oid": "57f99ce30c1fa43c5fa602b15394b503b972a753", "url": "https://github.com/hazelcast/hazelcast/commit/57f99ce30c1fa43c5fa602b15394b503b972a753", "message": "Removed delegating future.", "committedDate": "2020-07-07T06:57:59Z", "type": "commit"}, {"oid": "185dc6749498837536ad3e03909d83cf51a98a1b", "url": "https://github.com/hazelcast/hazelcast/commit/185dc6749498837536ad3e03909d83cf51a98a1b", "message": "Removed decoders.", "committedDate": "2020-07-07T07:04:00Z", "type": "commit"}, {"oid": "b7f8b720ed2b9a4263ae3f104d46db5699c85678", "url": "https://github.com/hazelcast/hazelcast/commit/b7f8b720ed2b9a4263ae3f104d46db5699c85678", "message": "Added security support.", "committedDate": "2020-07-07T08:09:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg0MDg1Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450840856", "bodyText": "Typo: double type?", "author": "petrpleshachkov", "createdAt": "2020-07-07T12:53:42Z", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/protocol/codec/builtin/CustomTypeFactory.java", "diffHunk": "@@ -197,4 +200,14 @@ public static EndpointQualifier createEndpointQualifier(int type, String identif\n         }\n         return EndpointQualifier.resolve(protocolType, identifier);\n     }\n+\n+    public static SqlColumnMetadata createSqlColumnMetadata(String name, int type) {\n+        SqlColumnType sqlColumnType = SqlColumnType.getById(type);\n+\n+        if (sqlColumnType == null) {\n+            throw new HazelcastException(\"Unexpected SQL column type type = [\" + type + \"]\");", "originalCommit": "b7f8b720ed2b9a4263ae3f104d46db5699c85678", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTMzMjYyMg==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r451332622", "bodyText": "Fixed", "author": "devozerov", "createdAt": "2020-07-08T07:18:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg0MDg1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg1MjkzMw==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450852933", "bodyText": "Not sure that I got why do we need to convert the result to Data if we are already on the client?", "author": "petrpleshachkov", "createdAt": "2020-07-07T13:12:40Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/client/QueryClientStateRegistry.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.client;\n+\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.internal.serialization.InternalSerializationService;\n+import com.hazelcast.sql.SqlRow;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.QueryId;\n+import com.hazelcast.sql.impl.SqlResultImpl;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * Registry of active client cursors.\n+ */\n+public class QueryClientStateRegistry {\n+\n+    private final ConcurrentHashMap<QueryId, QueryClientState> clientCursors = new ConcurrentHashMap<>();\n+\n+    public SqlPage registerAndFetch(\n+        UUID clientId,\n+        SqlResultImpl cursor,\n+        int cursorBufferSize,\n+        InternalSerializationService serializationService\n+    ) {\n+        QueryClientState clientCursor = new QueryClientState(clientId, cursor);\n+\n+        SqlPage page = fetchInternal(clientCursor, cursorBufferSize, serializationService);\n+\n+        if (!page.isLast()) {\n+            clientCursors.put(cursor.getQueryId(), clientCursor);\n+        }\n+\n+        return page;\n+    }\n+\n+    public SqlPage fetch(\n+        UUID clientId,\n+        QueryId queryId,\n+        int cursorBufferSize,\n+        InternalSerializationService serializationService\n+    ) {\n+        QueryClientState clientCursor = getClientCursor(clientId, queryId);\n+\n+        if (clientCursor == null) {\n+            throw QueryException.error(\"Query cursor is not found (closed?): \" + queryId);\n+        }\n+\n+        SqlPage page = fetchInternal(clientCursor, cursorBufferSize, serializationService);\n+\n+        if (page.isLast()) {\n+            deleteClientCursor(clientCursor);\n+        }\n+\n+        return page;\n+    }\n+\n+    private SqlPage fetchInternal(\n+        QueryClientState clientCursor,\n+        int cursorBufferSize,\n+        InternalSerializationService serializationService\n+    ) {\n+        Iterator<SqlRow> iterator = clientCursor.getIterator();\n+\n+        List<SqlPageRow> page = new ArrayList<>(cursorBufferSize);\n+        boolean last = fetchPage(iterator, page, cursorBufferSize, serializationService);\n+\n+        if (last) {\n+            deleteClientCursor(clientCursor);\n+        }\n+\n+        return new SqlPage(page, last);\n+    }\n+\n+    private static boolean fetchPage(\n+        Iterator<SqlRow> iterator,\n+        List<SqlPageRow> page,\n+        int cursorBufferSize,\n+        InternalSerializationService serializationService\n+    ) {\n+        while (iterator.hasNext()) {\n+            SqlRow row = iterator.next();\n+            SqlPageRow convertedRow = convertRow(row, serializationService);\n+\n+            page.add(convertedRow);\n+\n+            if (page.size() == cursorBufferSize) {\n+                break;\n+            }\n+        }\n+\n+        return !iterator.hasNext();\n+    }\n+\n+    private static SqlPageRow convertRow(SqlRow row, InternalSerializationService serializationService) {\n+        int columnCount = row.getMetadata().getColumnCount();\n+\n+        List<Data> values = new ArrayList<>(columnCount);\n+\n+        for (int i = 0; i < columnCount; i++) {\n+            values.add(serializationService.toData(row.getObject(i)));", "originalCommit": "b7f8b720ed2b9a4263ae3f104d46db5699c85678", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg1OTE4OA==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450859188", "bodyText": "This code is invoked on the member", "author": "devozerov", "createdAt": "2020-07-07T13:22:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg1MjkzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg2OTQ1NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450869454", "bodyText": "Shall we move it then somewhere to the member related class?", "author": "petrpleshachkov", "createdAt": "2020-07-07T13:36:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg1MjkzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTMzMjc1MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r451332751", "bodyText": "Makes sense. Moved to the com.hazelcast.sql.impl.state package.", "author": "devozerov", "createdAt": "2020-07-08T07:18:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg1MjkzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg1NjE0MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450856141", "bodyText": "If an exception is thrown from service.close(connection, queryId) then we still mark the iterator as closed while it is not?", "author": "petrpleshachkov", "createdAt": "2020-07-07T13:17:36Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/client/SqlClientResult.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.client;\n+\n+import com.hazelcast.internal.nio.Connection;\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.sql.SqlResult;\n+import com.hazelcast.sql.SqlRow;\n+import com.hazelcast.sql.SqlRowMetadata;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.QueryId;\n+import com.hazelcast.sql.impl.SqlRowImpl;\n+import com.hazelcast.sql.impl.row.HeapRow;\n+import com.hazelcast.sql.impl.row.Row;\n+\n+import javax.annotation.Nonnull;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+/**\n+ * Client-side cursor.\n+ */\n+public class SqlClientResult implements SqlResult {\n+\n+    private final SqlClientService service;\n+    private final Connection connection;\n+    private final QueryId queryId;\n+    private final SqlRowMetadata rowMetadata;\n+    private final ClientIterator iterator = new ClientIterator();\n+\n+    private int cursorBufferSize;\n+    private boolean closed;\n+    private boolean iteratorAccessed;\n+\n+    public SqlClientResult(\n+        SqlClientService service,\n+        Connection connection,\n+        QueryId queryId,\n+        SqlRowMetadata rowMetadata,\n+        SqlPage page,\n+        int cursorBufferSize\n+    ) {\n+        this.service = service;\n+        this.connection = connection;\n+        this.queryId = queryId;\n+        this.rowMetadata = rowMetadata;\n+        this.cursorBufferSize = cursorBufferSize;\n+\n+        iterator.onNextPage(page);\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public SqlRowMetadata getRowMetadata() {\n+        return rowMetadata;\n+    }\n+\n+    @Override\n+    @Nonnull\n+    public Iterator<SqlRow> iterator() {\n+        if (!iteratorAccessed) {\n+            iteratorAccessed = true;\n+\n+            return iterator;\n+        } else {\n+            throw new IllegalStateException(\"Iterator could be requested only once\");\n+        }\n+    }\n+\n+    @Override\n+    public void close() {\n+        try {\n+            if (!closed) {\n+                if (iterator.last) {\n+                    // The last page accessed, so the remote cursor is already closed. No-op.\n+                    return;\n+                }\n+\n+                service.close(connection, queryId);\n+            }\n+        } finally {\n+            closed = true;", "originalCommit": "b7f8b720ed2b9a4263ae3f104d46db5699c85678", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTMzMDczNA==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r451330734", "bodyText": "The only reason for the exception here is a broken connection. If it is broken, there is no sense trying to keep the result opened, because no more rows could be fetched anyway.", "author": "devozerov", "createdAt": "2020-07-08T07:14:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg1NjE0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg1NjU0NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450856544", "bodyText": "What is the meaning for the cursorBufferSize=0?", "author": "petrpleshachkov", "createdAt": "2020-07-07T13:18:16Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/client/SqlClientResult.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.client;\n+\n+import com.hazelcast.internal.nio.Connection;\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.sql.SqlResult;\n+import com.hazelcast.sql.SqlRow;\n+import com.hazelcast.sql.SqlRowMetadata;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.QueryId;\n+import com.hazelcast.sql.impl.SqlRowImpl;\n+import com.hazelcast.sql.impl.row.HeapRow;\n+import com.hazelcast.sql.impl.row.Row;\n+\n+import javax.annotation.Nonnull;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+/**\n+ * Client-side cursor.\n+ */\n+public class SqlClientResult implements SqlResult {\n+\n+    private final SqlClientService service;\n+    private final Connection connection;\n+    private final QueryId queryId;\n+    private final SqlRowMetadata rowMetadata;\n+    private final ClientIterator iterator = new ClientIterator();\n+\n+    private int cursorBufferSize;\n+    private boolean closed;\n+    private boolean iteratorAccessed;\n+\n+    public SqlClientResult(\n+        SqlClientService service,\n+        Connection connection,\n+        QueryId queryId,\n+        SqlRowMetadata rowMetadata,\n+        SqlPage page,\n+        int cursorBufferSize\n+    ) {\n+        this.service = service;\n+        this.connection = connection;\n+        this.queryId = queryId;\n+        this.rowMetadata = rowMetadata;\n+        this.cursorBufferSize = cursorBufferSize;\n+\n+        iterator.onNextPage(page);\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public SqlRowMetadata getRowMetadata() {\n+        return rowMetadata;\n+    }\n+\n+    @Override\n+    @Nonnull\n+    public Iterator<SqlRow> iterator() {\n+        if (!iteratorAccessed) {\n+            iteratorAccessed = true;\n+\n+            return iterator;\n+        } else {\n+            throw new IllegalStateException(\"Iterator could be requested only once\");\n+        }\n+    }\n+\n+    @Override\n+    public void close() {\n+        try {\n+            if (!closed) {\n+                if (iterator.last) {\n+                    // The last page accessed, so the remote cursor is already closed. No-op.\n+                    return;\n+                }\n+\n+                service.close(connection, queryId);\n+            }\n+        } finally {\n+            closed = true;\n+        }\n+    }\n+\n+    public int getCursorBufferSize() {\n+        return cursorBufferSize;\n+    }\n+\n+    public void setCursorBufferSize(int cursorBufferSize) {\n+        assert cursorBufferSize >= 0;", "originalCommit": "b7f8b720ed2b9a4263ae3f104d46db5699c85678", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTMyOTg3NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r451329875", "bodyText": "These methods are not used in this PR, they are needed by JDBC. Removed them for now to avoid confusion.", "author": "devozerov", "createdAt": "2020-07-08T07:12:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg1NjU0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg1NzkyMg==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450857922", "bodyText": "Shall we add if(closed) check here as well?", "author": "petrpleshachkov", "createdAt": "2020-07-07T13:20:24Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/client/SqlClientResult.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.client;\n+\n+import com.hazelcast.internal.nio.Connection;\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.sql.SqlResult;\n+import com.hazelcast.sql.SqlRow;\n+import com.hazelcast.sql.SqlRowMetadata;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.QueryId;\n+import com.hazelcast.sql.impl.SqlRowImpl;\n+import com.hazelcast.sql.impl.row.HeapRow;\n+import com.hazelcast.sql.impl.row.Row;\n+\n+import javax.annotation.Nonnull;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+/**\n+ * Client-side cursor.\n+ */\n+public class SqlClientResult implements SqlResult {\n+\n+    private final SqlClientService service;\n+    private final Connection connection;\n+    private final QueryId queryId;\n+    private final SqlRowMetadata rowMetadata;\n+    private final ClientIterator iterator = new ClientIterator();\n+\n+    private int cursorBufferSize;\n+    private boolean closed;\n+    private boolean iteratorAccessed;\n+\n+    public SqlClientResult(\n+        SqlClientService service,\n+        Connection connection,\n+        QueryId queryId,\n+        SqlRowMetadata rowMetadata,\n+        SqlPage page,\n+        int cursorBufferSize\n+    ) {\n+        this.service = service;\n+        this.connection = connection;\n+        this.queryId = queryId;\n+        this.rowMetadata = rowMetadata;\n+        this.cursorBufferSize = cursorBufferSize;\n+\n+        iterator.onNextPage(page);\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public SqlRowMetadata getRowMetadata() {\n+        return rowMetadata;\n+    }\n+\n+    @Override\n+    @Nonnull\n+    public Iterator<SqlRow> iterator() {\n+        if (!iteratorAccessed) {\n+            iteratorAccessed = true;\n+\n+            return iterator;\n+        } else {\n+            throw new IllegalStateException(\"Iterator could be requested only once\");\n+        }\n+    }\n+\n+    @Override\n+    public void close() {\n+        try {\n+            if (!closed) {\n+                if (iterator.last) {\n+                    // The last page accessed, so the remote cursor is already closed. No-op.\n+                    return;\n+                }\n+\n+                service.close(connection, queryId);\n+            }\n+        } finally {\n+            closed = true;\n+        }\n+    }\n+\n+    public int getCursorBufferSize() {\n+        return cursorBufferSize;\n+    }\n+\n+    public void setCursorBufferSize(int cursorBufferSize) {\n+        assert cursorBufferSize >= 0;\n+\n+        this.cursorBufferSize = cursorBufferSize;\n+    }\n+\n+    private void fetchNextPage(ClientIterator iterator) {\n+        SqlPage page = service.fetch(connection, queryId, cursorBufferSize);\n+\n+        iterator.onNextPage(page);\n+    }\n+\n+    private List<Row> convertPageRows(List<SqlPageRow> serializedRows) {\n+        List<Row> rows = new ArrayList<>(serializedRows.size());\n+\n+        for (SqlPageRow serializedRow : serializedRows) {\n+            List<Data> serializedValues = serializedRow.getValues();\n+            Object[] values = new Object[serializedValues.size()];\n+\n+            for (int i = 0; i < serializedValues.size(); i++) {\n+                values[i] = service.deserializeRowValue(serializedValues.get(i));\n+            }\n+\n+            rows.add(new HeapRow(values));\n+        }\n+\n+        return rows;\n+    }\n+\n+    /**\n+     * Implementation of lazy iterator, which fetches results as needed.\n+     */\n+    private class ClientIterator implements Iterator<SqlRow> {\n+\n+        private List<Row> currentRows;\n+        private int currentPosition;\n+        private boolean last;\n+\n+        @Override\n+        public boolean hasNext() {\n+            if (closed) {\n+                throw service.rethrow(QueryException.cancelledByUser());\n+            }\n+\n+            while (currentPosition == currentRows.size()) {\n+                // Reached end of the page. Try fetching the next one if possible.\n+                if (!last) {\n+                    fetchNextPage(this);\n+                } else {\n+                    // No more pages expected, so return false.\n+                    return false;\n+                }\n+            }\n+\n+            return true;\n+        }\n+\n+        @Override\n+        public SqlRow next() {", "originalCommit": "b7f8b720ed2b9a4263ae3f104d46db5699c85678", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTMyODUxMg==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r451328512", "bodyText": "This method first invokes hasNext that does this check.", "author": "devozerov", "createdAt": "2020-07-08T07:10:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg1NzkyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg2NTUyOQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450865529", "bodyText": "Javadoc would be useful.", "author": "petrpleshachkov", "createdAt": "2020-07-07T13:31:00Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/client/SqlPage.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.client;\n+\n+import java.util.List;\n+import java.util.Objects;\n+", "originalCommit": "b7f8b720ed2b9a4263ae3f104d46db5699c85678", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTMyODEwMg==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r451328102", "bodyText": "Added JavaDoc", "author": "devozerov", "createdAt": "2020-07-08T07:09:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg2NTUyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg2ODMyNg==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r450868326", "bodyText": "Why do we return the last member in this case?", "author": "petrpleshachkov", "createdAt": "2020-07-07T13:34:52Z", "path": "hazelcast/src/test/java/com/hazelcast/client/txn/ClientTxnUniSocketTest.java", "diffHunk": "@@ -65,6 +65,23 @@ public Member next() {\n                 }\n                 return members[0];\n             }\n+\n+            @Override\n+            public Member nextDataMember() {\n+                Member[] members = getDataMembers();\n+                if (members == null || members.length == 0) {\n+                    return null;\n+                }\n+                if (members.length == 2) {", "originalCommit": "b7f8b720ed2b9a4263ae3f104d46db5699c85678", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTMyNzc2MA==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r451327760", "bodyText": "I do not know, this is just a copy-paste from the next() method to let the test compile. There is this comment above:\n//try to force second member to connect when exist", "author": "devozerov", "createdAt": "2020-07-08T07:08:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg2ODMyNg=="}], "type": "inlineReview"}, {"oid": "b258543a7c9921c5e7c043c1035f7ec470c9edeb", "url": "https://github.com/hazelcast/hazelcast/commit/b258543a7c9921c5e7c043c1035f7ec470c9edeb", "message": "JavaDocs for SqlPage.", "committedDate": "2020-07-08T07:08:57Z", "type": "commit"}, {"oid": "a5bfad4117617a4e3bd5142bcf0e1f9c2c630424", "url": "https://github.com/hazelcast/hazelcast/commit/a5bfad4117617a4e3bd5142bcf0e1f9c2c630424", "message": "Removed unused methods from SqlClientResult.", "committedDate": "2020-07-08T07:12:14Z", "type": "commit"}, {"oid": "11c7fc8b345b0ff9de7ee27ff56bab1f54c4679f", "url": "https://github.com/hazelcast/hazelcast/commit/11c7fc8b345b0ff9de7ee27ff56bab1f54c4679f", "message": "Minors.", "committedDate": "2020-07-08T07:18:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM2MDcwMQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r451360701", "bodyText": "There is no need for SqlExecuteResponse object anymore here.", "author": "sancar", "createdAt": "2020-07-08T08:08:37Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/client/SqlClientService.java", "diffHunk": "@@ -0,0 +1,208 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.client;\n+\n+import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;\n+import com.hazelcast.client.impl.protocol.ClientMessage;\n+import com.hazelcast.client.impl.protocol.codec.SqlCloseCodec;\n+import com.hazelcast.client.impl.protocol.codec.SqlExecuteCodec;\n+import com.hazelcast.client.impl.protocol.codec.SqlFetchCodec;\n+import com.hazelcast.client.impl.spi.impl.ClientInvocation;\n+import com.hazelcast.client.impl.spi.impl.ClientInvocationFuture;\n+import com.hazelcast.internal.nio.Connection;\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.internal.serialization.InternalSerializationService;\n+import com.hazelcast.sql.SqlErrorCode;\n+import com.hazelcast.sql.SqlException;\n+import com.hazelcast.sql.SqlQuery;\n+import com.hazelcast.sql.SqlResult;\n+import com.hazelcast.sql.SqlService;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.QueryId;\n+import com.hazelcast.sql.impl.QueryUtils;\n+\n+import javax.annotation.Nonnull;\n+import java.security.AccessControlException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+/**\n+ * Client-side implementation of SQL service.\n+ */\n+public class SqlClientService implements SqlService {\n+\n+    private final HazelcastClientInstanceImpl client;\n+\n+    public SqlClientService(HazelcastClientInstanceImpl client) {\n+        this.client = client;\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public SqlResult query(@Nonnull SqlQuery query) {\n+        Connection connection = client.getConnectionManager().getRandomConnection(true);\n+\n+        if (connection == null) {\n+            throw rethrow(QueryException.error(\n+                SqlErrorCode.CONNECTION_PROBLEM,\n+                \"Client must be connected to at least one data member to execute SQL queries\"\n+            ));\n+        }\n+\n+        try {\n+            List<Object> params = query.getParameters();\n+\n+            List<Data> params0 = new ArrayList<>(params.size());\n+\n+            for (Object param : params) {\n+                params0.add(serializeParameter(param));\n+            }\n+\n+            ClientMessage requestMessage = SqlExecuteCodec.encodeRequest(\n+                query.getSql(),\n+                params0,\n+                query.getTimeoutMillis(),\n+                query.getCursorBufferSize()\n+            );\n+\n+            ClientMessage responseMessage = invoke(requestMessage, connection);\n+\n+            SqlExecuteCodec.ResponseParameters responseParameters = SqlExecuteCodec.decodeResponse(responseMessage);\n+\n+            SqlExecuteResponse response = new SqlExecuteResponse(", "originalCommit": "11c7fc8b345b0ff9de7ee27ff56bab1f54c4679f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTk4MzQxOQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r451983419", "bodyText": "Fixed.", "author": "devozerov", "createdAt": "2020-07-09T06:06:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM2MDcwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM2MTA3Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r451361076", "bodyText": "There is no need for SqlFetchResponse  object anymore here.", "author": "sancar", "createdAt": "2020-07-08T08:09:19Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/client/SqlClientService.java", "diffHunk": "@@ -0,0 +1,208 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.client;\n+\n+import com.hazelcast.client.impl.clientside.HazelcastClientInstanceImpl;\n+import com.hazelcast.client.impl.protocol.ClientMessage;\n+import com.hazelcast.client.impl.protocol.codec.SqlCloseCodec;\n+import com.hazelcast.client.impl.protocol.codec.SqlExecuteCodec;\n+import com.hazelcast.client.impl.protocol.codec.SqlFetchCodec;\n+import com.hazelcast.client.impl.spi.impl.ClientInvocation;\n+import com.hazelcast.client.impl.spi.impl.ClientInvocationFuture;\n+import com.hazelcast.internal.nio.Connection;\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.internal.serialization.InternalSerializationService;\n+import com.hazelcast.sql.SqlErrorCode;\n+import com.hazelcast.sql.SqlException;\n+import com.hazelcast.sql.SqlQuery;\n+import com.hazelcast.sql.SqlResult;\n+import com.hazelcast.sql.SqlService;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.QueryId;\n+import com.hazelcast.sql.impl.QueryUtils;\n+\n+import javax.annotation.Nonnull;\n+import java.security.AccessControlException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+/**\n+ * Client-side implementation of SQL service.\n+ */\n+public class SqlClientService implements SqlService {\n+\n+    private final HazelcastClientInstanceImpl client;\n+\n+    public SqlClientService(HazelcastClientInstanceImpl client) {\n+        this.client = client;\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public SqlResult query(@Nonnull SqlQuery query) {\n+        Connection connection = client.getConnectionManager().getRandomConnection(true);\n+\n+        if (connection == null) {\n+            throw rethrow(QueryException.error(\n+                SqlErrorCode.CONNECTION_PROBLEM,\n+                \"Client must be connected to at least one data member to execute SQL queries\"\n+            ));\n+        }\n+\n+        try {\n+            List<Object> params = query.getParameters();\n+\n+            List<Data> params0 = new ArrayList<>(params.size());\n+\n+            for (Object param : params) {\n+                params0.add(serializeParameter(param));\n+            }\n+\n+            ClientMessage requestMessage = SqlExecuteCodec.encodeRequest(\n+                query.getSql(),\n+                params0,\n+                query.getTimeoutMillis(),\n+                query.getCursorBufferSize()\n+            );\n+\n+            ClientMessage responseMessage = invoke(requestMessage, connection);\n+\n+            SqlExecuteCodec.ResponseParameters responseParameters = SqlExecuteCodec.decodeResponse(responseMessage);\n+\n+            SqlExecuteResponse response = new SqlExecuteResponse(\n+                    responseParameters.queryId,\n+                    responseParameters.rowMetadata,\n+                    responseParameters.rowPage,\n+                    responseParameters.error\n+            );\n+\n+            handleResponseError(response.getError());\n+\n+            return new SqlClientResult(\n+                this,\n+                connection,\n+                response.getQueryId(),\n+                response.getRowMetadata(),\n+                response.getPage(),\n+                query.getCursorBufferSize()\n+            );\n+        } catch (Exception e) {\n+            throw rethrow(e, connection);\n+        }\n+    }\n+\n+    /**\n+     * Fetch the next page of the given query.\n+     *\n+     * @param connection Connection.\n+     * @param queryId Query ID.\n+     * @return Pair: fetched rows + last page flag.\n+     */\n+    public SqlPage fetch(Connection connection, QueryId queryId, int cursorBufferSize) {\n+        try {\n+            ClientMessage requestMessage = SqlFetchCodec.encodeRequest(queryId, cursorBufferSize);\n+            ClientMessage responseMessage = invoke(requestMessage, connection);\n+            SqlFetchCodec.ResponseParameters responseParameters = SqlFetchCodec.decodeResponse(responseMessage);\n+            SqlFetchResponse response = new SqlFetchResponse(responseParameters.rowPage, responseParameters.error);", "originalCommit": "11c7fc8b345b0ff9de7ee27ff56bab1f54c4679f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTk4MzM2NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r451983365", "bodyText": "Fixed.", "author": "devozerov", "createdAt": "2020-07-09T06:06:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM2MTA3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM5MDI1OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r451390259", "bodyText": "Would it be possible to use List<Data> instead of SqlPageRow here. And also in the protocol ?\nIt would eliminate the need for creating a new type in the protocol, as well as creating extra objects here.\nIn the protocol, we may also eliminate SqlPage in the protocol and put the last boolean as one of the response params.", "author": "sancar", "createdAt": "2020-07-08T08:56:59Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/state/QueryClientStateRegistry.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.state;\n+\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.internal.serialization.InternalSerializationService;\n+import com.hazelcast.sql.SqlRow;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.QueryId;\n+import com.hazelcast.sql.impl.SqlResultImpl;\n+import com.hazelcast.sql.impl.client.SqlPage;\n+import com.hazelcast.sql.impl.client.SqlPageRow;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * Registry of active client cursors.\n+ */\n+public class QueryClientStateRegistry {\n+\n+    private final ConcurrentHashMap<QueryId, QueryClientState> clientCursors = new ConcurrentHashMap<>();\n+\n+    public SqlPage registerAndFetch(\n+        UUID clientId,\n+        SqlResultImpl cursor,\n+        int cursorBufferSize,\n+        InternalSerializationService serializationService\n+    ) {\n+        QueryClientState clientCursor = new QueryClientState(clientId, cursor);\n+\n+        SqlPage page = fetchInternal(clientCursor, cursorBufferSize, serializationService);\n+\n+        if (!page.isLast()) {\n+            clientCursors.put(cursor.getQueryId(), clientCursor);\n+        }\n+\n+        return page;\n+    }\n+\n+    public SqlPage fetch(\n+        UUID clientId,\n+        QueryId queryId,\n+        int cursorBufferSize,\n+        InternalSerializationService serializationService\n+    ) {\n+        QueryClientState clientCursor = getClientCursor(clientId, queryId);\n+\n+        if (clientCursor == null) {\n+            throw QueryException.error(\"Query cursor is not found (closed?): \" + queryId);\n+        }\n+\n+        SqlPage page = fetchInternal(clientCursor, cursorBufferSize, serializationService);\n+\n+        if (page.isLast()) {\n+            deleteClientCursor(clientCursor);\n+        }\n+\n+        return page;\n+    }\n+\n+    private SqlPage fetchInternal(\n+        QueryClientState clientCursor,\n+        int cursorBufferSize,\n+        InternalSerializationService serializationService\n+    ) {\n+        Iterator<SqlRow> iterator = clientCursor.getIterator();\n+\n+        List<SqlPageRow> page = new ArrayList<>(cursorBufferSize);\n+        boolean last = fetchPage(iterator, page, cursorBufferSize, serializationService);\n+\n+        if (last) {\n+            deleteClientCursor(clientCursor);\n+        }\n+\n+        return new SqlPage(page, last);\n+    }\n+\n+    private static boolean fetchPage(\n+        Iterator<SqlRow> iterator,\n+        List<SqlPageRow> page,", "originalCommit": "11c7fc8b345b0ff9de7ee27ff56bab1f54c4679f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjAxMTAzOA==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r452011038", "bodyText": "Removed SqlPage from the protocol, although it is still used in the server-side part, because we need to return rows and a flag anyway.", "author": "devozerov", "createdAt": "2020-07-09T07:14:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM5MDI1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM5MjkwNg==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r451392906", "bodyText": "You can eliminate the need for creating SqlFetchResponse class by returning page or error directly.\nencodeResponse method could act accordingle by checking if response is instanceOf Exception or not.", "author": "sancar", "createdAt": "2020-07-08T09:01:14Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/client/SqlFetchMessageTask.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.client;\n+\n+import com.hazelcast.client.impl.protocol.ClientMessage;\n+import com.hazelcast.client.impl.protocol.codec.SqlFetchCodec;\n+import com.hazelcast.client.impl.protocol.task.AbstractCallableMessageTask;\n+import com.hazelcast.instance.impl.Node;\n+import com.hazelcast.internal.nio.Connection;\n+import com.hazelcast.security.permission.SqlPermission;\n+import com.hazelcast.sql.impl.SqlInternalService;\n+\n+import java.security.Permission;\n+import java.util.UUID;\n+\n+/**\n+ * SQL query fetch task.\n+ */\n+public class SqlFetchMessageTask extends AbstractCallableMessageTask<SqlFetchCodec.RequestParameters> {\n+    public SqlFetchMessageTask(ClientMessage clientMessage, Node node, Connection connection) {\n+        super(clientMessage, node, connection);\n+    }\n+\n+    @Override\n+    protected Object call() throws Exception {\n+        UUID localMemberId = nodeEngine.getLocalMember().getUuid();\n+        SqlInternalService service = nodeEngine.getSqlService().getInternalService();\n+\n+        SqlPage page = null;\n+        SqlError error = null;\n+\n+        try {\n+            page = service.getClientStateRegistry().fetch(\n+                endpoint.getUuid(),\n+                parameters.queryId,\n+                parameters.cursorBufferSize,\n+                serializationService\n+            );\n+        } catch (Exception e) {\n+            error = SqlClientUtils.exceptionToClientError(e, localMemberId);\n+        }\n+\n+        return new SqlFetchResponse(page, error);", "originalCommit": "11c7fc8b345b0ff9de7ee27ff56bab1f54c4679f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTk3NjgxMg==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r451976812", "bodyText": "It will make the code harder to follow because we will use different ways of returning results for execute and fetch commands.", "author": "devozerov", "createdAt": "2020-07-09T05:45:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM5MjkwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQwMDI5Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r451400292", "bodyText": "@devozerov This part is confusing to me. Can you document when can a client be null? To me, it looked like it can not, or maybe I am missing something.", "author": "sancar", "createdAt": "2020-07-08T09:14:24Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/state/QueryClientStateRegistry.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.state;\n+\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.internal.serialization.InternalSerializationService;\n+import com.hazelcast.sql.SqlRow;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.QueryId;\n+import com.hazelcast.sql.impl.SqlResultImpl;\n+import com.hazelcast.sql.impl.client.SqlPage;\n+import com.hazelcast.sql.impl.client.SqlPageRow;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * Registry of active client cursors.\n+ */\n+public class QueryClientStateRegistry {\n+\n+    private final ConcurrentHashMap<QueryId, QueryClientState> clientCursors = new ConcurrentHashMap<>();\n+\n+    public SqlPage registerAndFetch(\n+        UUID clientId,\n+        SqlResultImpl cursor,\n+        int cursorBufferSize,\n+        InternalSerializationService serializationService\n+    ) {\n+        QueryClientState clientCursor = new QueryClientState(clientId, cursor);\n+\n+        SqlPage page = fetchInternal(clientCursor, cursorBufferSize, serializationService);\n+\n+        if (!page.isLast()) {\n+            clientCursors.put(cursor.getQueryId(), clientCursor);\n+        }\n+\n+        return page;\n+    }\n+\n+    public SqlPage fetch(\n+        UUID clientId,\n+        QueryId queryId,\n+        int cursorBufferSize,\n+        InternalSerializationService serializationService\n+    ) {\n+        QueryClientState clientCursor = getClientCursor(clientId, queryId);\n+\n+        if (clientCursor == null) {\n+            throw QueryException.error(\"Query cursor is not found (closed?): \" + queryId);\n+        }\n+\n+        SqlPage page = fetchInternal(clientCursor, cursorBufferSize, serializationService);\n+\n+        if (page.isLast()) {\n+            deleteClientCursor(clientCursor);\n+        }\n+\n+        return page;\n+    }\n+\n+    private SqlPage fetchInternal(\n+        QueryClientState clientCursor,\n+        int cursorBufferSize,\n+        InternalSerializationService serializationService\n+    ) {\n+        Iterator<SqlRow> iterator = clientCursor.getIterator();\n+\n+        List<SqlPageRow> page = new ArrayList<>(cursorBufferSize);\n+        boolean last = fetchPage(iterator, page, cursorBufferSize, serializationService);\n+\n+        if (last) {\n+            deleteClientCursor(clientCursor);\n+        }\n+\n+        return new SqlPage(page, last);\n+    }\n+\n+    private static boolean fetchPage(\n+        Iterator<SqlRow> iterator,\n+        List<SqlPageRow> page,\n+        int cursorBufferSize,\n+        InternalSerializationService serializationService\n+    ) {\n+        while (iterator.hasNext()) {\n+            SqlRow row = iterator.next();\n+            SqlPageRow convertedRow = convertRow(row, serializationService);\n+\n+            page.add(convertedRow);\n+\n+            if (page.size() == cursorBufferSize) {\n+                break;\n+            }\n+        }\n+\n+        return !iterator.hasNext();\n+    }\n+\n+    private static SqlPageRow convertRow(SqlRow row, InternalSerializationService serializationService) {\n+        int columnCount = row.getMetadata().getColumnCount();\n+\n+        List<Data> values = new ArrayList<>(columnCount);\n+\n+        for (int i = 0; i < columnCount; i++) {\n+            values.add(serializationService.toData(row.getObject(i)));\n+        }\n+\n+        return new SqlPageRow(values);\n+    }\n+\n+    public void close(UUID clientId, QueryId queryId) {\n+        QueryClientState clientCursor = getClientCursor(clientId, queryId);\n+\n+        if (clientCursor != null) {\n+            clientCursor.getSqlResult().close();\n+\n+            deleteClientCursor(clientCursor);\n+        }\n+    }\n+\n+    public void reset() {\n+        clientCursors.clear();\n+    }\n+\n+    public void update(Set<UUID> activeClientIds) {\n+        List<QueryClientState> victims = new ArrayList<>();\n+\n+        for (QueryClientState clientCursor : clientCursors.values()) {\n+            if (!activeClientIds.contains(clientCursor.getClientId())) {\n+                victims.add(clientCursor);\n+            }\n+        }\n+\n+        for (QueryClientState victim : victims) {\n+            QueryException error = QueryException.clientMemberConnection(victim.getClientId());\n+\n+            victim.getSqlResult().closeOnError(error);\n+\n+            deleteClientCursor(victim);\n+        }\n+    }\n+\n+    private QueryClientState getClientCursor(UUID clientId, QueryId queryId) {\n+        QueryClientState cursor = clientCursors.get(queryId);\n+\n+        if (cursor == null || (clientId != null && !cursor.getClientId().equals(clientId))) {", "originalCommit": "11c7fc8b345b0ff9de7ee27ff56bab1f54c4679f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTk4MzIyMw==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r451983223", "bodyText": "Fixed. Part of this expression was redundant.", "author": "devozerov", "createdAt": "2020-07-09T06:05:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQwMDI5Mg=="}], "type": "inlineReview"}, {"oid": "cecc200ec59e63dbcf3b0c61a52d151bd4773346", "url": "https://github.com/hazelcast/hazelcast/commit/cecc200ec59e63dbcf3b0c61a52d151bd4773346", "message": "1) Fixed if-statement in the QueryClientStateRegistry\n2) Changed query ID to String in the protocol\n3) Removed unnecessary allocations in SqlClientService", "committedDate": "2020-07-09T06:05:00Z", "type": "commit"}, {"oid": "406e59f944d8dbd814788ac38a18eb806fe74b8c", "url": "https://github.com/hazelcast/hazelcast/commit/406e59f944d8dbd814788ac38a18eb806fe74b8c", "message": "Execute SQL tasks in the query executor", "committedDate": "2020-07-09T06:17:04Z", "type": "commit"}, {"oid": "03810a4af80ae36600b3cf4686bbd5f9062538fa", "url": "https://github.com/hazelcast/hazelcast/commit/03810a4af80ae36600b3cf4686bbd5f9062538fa", "message": "Removed SqlPage from the protocol level.", "committedDate": "2020-07-09T06:48:12Z", "type": "commit"}, {"oid": "49eef72128852d8d8943382a0858061cc5d19fd6", "url": "https://github.com/hazelcast/hazelcast/commit/49eef72128852d8d8943382a0858061cc5d19fd6", "message": "Merge branch 'master' into issues/17173\n\n# Conflicts:\n#\thazelcast/src/test/java/com/hazelcast/client/protocol/compatibility/ClientCompatibilityNullTest_2_0_1.java\n#\thazelcast/src/test/java/com/hazelcast/client/protocol/compatibility/ClientCompatibilityTest_2_0_1.java\n#\thazelcast/src/test/java/com/hazelcast/client/protocol/compatibility/MemberCompatibilityNullTest_2_0_1.java\n#\thazelcast/src/test/java/com/hazelcast/client/protocol/compatibility/MemberCompatibilityTest_2_0_1.java", "committedDate": "2020-07-09T06:49:14Z", "type": "commit"}, {"oid": "0dc4fac9bb52b09dd09eb4866760dd033ec97d81", "url": "https://github.com/hazelcast/hazelcast/commit/0dc4fac9bb52b09dd09eb4866760dd033ec97d81", "message": "Merge with master.", "committedDate": "2020-07-09T06:56:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjA3NTI2MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17174#discussion_r452075261", "bodyText": "Javadoc of UUID.toString() specifies that the result is always 36 chars, so we could just split there. But UUID.fromString doesn't assume that, so I don't know. The below code is safe in this regard and doesn't deal with regexes.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    String[] parts = input.split(\"_\");\n          \n          \n            \n            \n          \n          \n            \n                    if (parts.length != 2) {\n          \n          \n            \n                        throw new IllegalArgumentException(\"Query ID is malformed: \" + input);\n          \n          \n            \n                    }\n          \n          \n            \n            \n          \n          \n            \n                    try {\n          \n          \n            \n                        UUID memberId = UUID.fromString(parts[0]);\n          \n          \n            \n                        UUID localId = UUID.fromString(parts[1]);\n          \n          \n            \n                    int underscorePos = input.indexOf(\"_\");\n          \n          \n            \n            \n          \n          \n            \n                    if (underscorePos < 0) {\n          \n          \n            \n                        throw new IllegalArgumentException(\"Query ID is malformed: \" + input);\n          \n          \n            \n                    }\n          \n          \n            \n            \n          \n          \n            \n                    try {\n          \n          \n            \n                        UUID memberId = UUID.fromString(input.substring(0, underscorePos));\n          \n          \n            \n                        UUID localId = UUID.fromString(input.substring(underscorePos + 1);", "author": "viliam-durina", "createdAt": "2020-07-09T09:09:04Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/QueryId.java", "diffHunk": "@@ -58,22 +58,72 @@ public QueryId() {\n      * @return Query ID.\n      */\n     public static QueryId create(UUID memberId) {\n-        UUID qryId = UuidUtil.newUnsecureUUID();\n+        UUID localId = UuidUtil.newUnsecureUUID();\n \n         return new QueryId(\n             memberId.getMostSignificantBits(),\n             memberId.getLeastSignificantBits(),\n-            qryId.getMostSignificantBits(),\n-            qryId.getLeastSignificantBits()\n+            localId.getMostSignificantBits(),\n+            localId.getLeastSignificantBits()\n         );\n     }\n \n+    public static QueryId parse(String input) {\n+        assert input != null;\n+\n+        String[] parts = input.split(\"_\");\n+\n+        if (parts.length != 2) {\n+            throw new IllegalArgumentException(\"Query ID is malformed: \" + input);\n+        }\n+\n+        try {\n+            UUID memberId = UUID.fromString(parts[0]);\n+            UUID localId = UUID.fromString(parts[1]);", "originalCommit": "0dc4fac9bb52b09dd09eb4866760dd033ec97d81", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7570e47f972cd88104a45880fa4e8e60c62ec9af", "url": "https://github.com/hazelcast/hazelcast/commit/7570e47f972cd88104a45880fa4e8e60c62ec9af", "message": "Update hazelcast/src/main/java/com/hazelcast/sql/impl/QueryId.java\n\nCo-authored-by: Viliam Durina <viliam-durina@users.noreply.github.com>", "committedDate": "2020-07-09T09:45:14Z", "type": "commit"}, {"oid": "842a479df5e6e856490ccc15e8dff6ba3970488b", "url": "https://github.com/hazelcast/hazelcast/commit/842a479df5e6e856490ccc15e8dff6ba3970488b", "message": "Fix compilation.", "committedDate": "2020-07-09T13:32:19Z", "type": "commit"}, {"oid": "030f982da27dfa9b3d1d4db3d37f0e63e5b4b90d", "url": "https://github.com/hazelcast/hazelcast/commit/030f982da27dfa9b3d1d4db3d37f0e63e5b4b90d", "message": "Merge branch 'master' into issues/17173", "committedDate": "2020-07-14T11:49:01Z", "type": "commit"}, {"oid": "244d974d117be1ba270a3164a9293d841db29fc6", "url": "https://github.com/hazelcast/hazelcast/commit/244d974d117be1ba270a3164a9293d841db29fc6", "message": "Improved compatibility support.", "committedDate": "2020-07-14T12:36:17Z", "type": "commit"}, {"oid": "1dbba16d216aaee28471e7ca8f4f3933d08e08f2", "url": "https://github.com/hazelcast/hazelcast/commit/1dbba16d216aaee28471e7ca8f4f3933d08e08f2", "message": "Fixes discussed with Asim.", "committedDate": "2020-07-14T14:04:16Z", "type": "commit"}, {"oid": "5638d1f5209e63c20fa42cb0816a7b990b25fae5", "url": "https://github.com/hazelcast/hazelcast/commit/5638d1f5209e63c20fa42cb0816a7b990b25fae5", "message": "Merge branch 'master' into issues/17173", "committedDate": "2020-07-15T13:17:49Z", "type": "commit"}, {"oid": "22c58a650cd0be04f31c240d11c2d4d918d68422", "url": "https://github.com/hazelcast/hazelcast/commit/22c58a650cd0be04f31c240d11c2d4d918d68422", "message": "WIP on document.", "committedDate": "2020-07-15T13:29:14Z", "type": "commit"}, {"oid": "baa16db36108a7ed24a49a547ac4e032941fe2b1", "url": "https://github.com/hazelcast/hazelcast/commit/baa16db36108a7ed24a49a547ac4e032941fe2b1", "message": "Design doc.", "committedDate": "2020-07-15T14:50:13Z", "type": "commit"}, {"oid": "fe7f8ff368bcae77ea7d8277b19010d8369e46fc", "url": "https://github.com/hazelcast/hazelcast/commit/fe7f8ff368bcae77ea7d8277b19010d8369e46fc", "message": "Added missing element to YAML config.", "committedDate": "2020-07-17T06:50:20Z", "type": "commit"}, {"oid": "4361ff7d1f8f82daeadc845f8cd74afdeff187d0", "url": "https://github.com/hazelcast/hazelcast/commit/4361ff7d1f8f82daeadc845f8cd74afdeff187d0", "message": "Merge branch 'master' into issues/17173", "committedDate": "2020-07-17T06:51:16Z", "type": "commit"}, {"oid": "9f6d668cf0d5e544929b7d653b53db4dd9d3ce6f", "url": "https://github.com/hazelcast/hazelcast/commit/9f6d668cf0d5e544929b7d653b53db4dd9d3ce6f", "message": "Fix class compliance checks.", "committedDate": "2020-07-17T11:18:01Z", "type": "commit"}, {"oid": "f8bde71f71caab6b2b5040d06a25109a645efbdb", "url": "https://github.com/hazelcast/hazelcast/commit/f8bde71f71caab6b2b5040d06a25109a645efbdb", "message": "Merge branch 'master' into issues/17173", "committedDate": "2020-07-21T18:03:59Z", "type": "commit"}, {"oid": "6151619cc1efacf6ca8db743384ad241481c68f2", "url": "https://github.com/hazelcast/hazelcast/commit/6151619cc1efacf6ca8db743384ad241481c68f2", "message": "Removed SqlRowMetadata from the protocol.", "committedDate": "2020-07-21T18:16:10Z", "type": "commit"}, {"oid": "b34d32137b9fbe04f936a5d7ef22c5bb85161a60", "url": "https://github.com/hazelcast/hazelcast/commit/b34d32137b9fbe04f936a5d7ef22c5bb85161a60", "message": "Merge branch 'master' into issues/17173", "committedDate": "2020-07-23T10:22:08Z", "type": "commit"}, {"oid": "06295b4bc1bff291f926f8921a3f9515bcbdc14f", "url": "https://github.com/hazelcast/hazelcast/commit/06295b4bc1bff291f926f8921a3f9515bcbdc14f", "message": "Removed SqlRow from the protocol.", "committedDate": "2020-07-23T10:53:15Z", "type": "commit"}, {"oid": "fecbe0761967b35a0b93bb13b0fa234f889d551d", "url": "https://github.com/hazelcast/hazelcast/commit/fecbe0761967b35a0b93bb13b0fa234f889d551d", "message": "Use Collection<Collection<Data>> instead of List<List<Data>> for Java protocol definitions.", "committedDate": "2020-07-23T11:22:51Z", "type": "commit"}, {"oid": "3fda547ad5fcb4aea6ec70028934cbd9cc053a25", "url": "https://github.com/hazelcast/hazelcast/commit/3fda547ad5fcb4aea6ec70028934cbd9cc053a25", "message": "Returned back QueryId to the protocol.", "committedDate": "2020-07-23T11:35:55Z", "type": "commit"}, {"oid": "64ecbfc46da530d3fbac8836a95623f283723b58", "url": "https://github.com/hazelcast/hazelcast/commit/64ecbfc46da530d3fbac8836a95623f283723b58", "message": "Fixed the design doc reflect that QueryId is no longer a string.", "committedDate": "2020-07-23T13:33:03Z", "type": "commit"}, {"oid": "dd6e1cf9562c1187abae7dc7b65f9c696b1f9a16", "url": "https://github.com/hazelcast/hazelcast/commit/dd6e1cf9562c1187abae7dc7b65f9c696b1f9a16", "message": "Design doc: \"queryId : String\" -> \"queryId : SqlQueryId\"", "committedDate": "2020-07-23T13:38:03Z", "type": "commit"}, {"oid": "2f5dce5b50cade31600186addab6148e68bc5333", "url": "https://github.com/hazelcast/hazelcast/commit/2f5dce5b50cade31600186addab6148e68bc5333", "message": "Merge branch 'master' into issues/17173", "committedDate": "2020-07-23T15:10:06Z", "type": "commit"}]}