{"pr_number": 17257, "pr_title": "New Types Support On Portable For Sql", "pr_createdAt": "2020-07-22T09:29:47Z", "pr_url": "https://github.com/hazelcast/hazelcast/pull/17257", "timeline": [{"oid": "181a168b548652fdeb027e9d24fef81dafbbc9a1", "url": "https://github.com/hazelcast/hazelcast/commit/181a168b548652fdeb027e9d24fef81dafbbc9a1", "message": "New Types Support On Serialization For Sql\n\nThe following types are added to serialization system.\nThe need comes from the SQL work.\n\nBigInteger,BigDecimal,LocalTime,LocalDate\n,LocalDateTime,OffsetDateTime\n\nAdded root serializers for each of the type. That means that\nthese types can be put to any data structure. They were\nserialized via default Java Serialization before. Now, they\nhave their own serializer id's. That means that these can be\nadded to any non-java client, and they can be distinguised\nby id when doing query.\n\nThese types are also added to Portable. Each one have their own\nmethod on PortableReader/Writer. Also the support for Array of\neach type is also added. Note that a field of an array can be\nnull. Since writeUTFArray had a null item support on arrays,\nthe rest  is made inline with that.\n\nWe did not add new types to ObjectDataOutput/Input classes.\nDataSerializable/IdentifiedDataSerializable does not support\nthem. The reason behind it that, they already have write/readObject\nThis enables using these classes on Java. For non-java clients,\nthis work is posptponed for now(because it is likely that we\nwill deprecate DataSerializable soon)", "committedDate": "2020-07-22T11:54:54Z", "type": "forcePushed"}, {"oid": "6a4ec19b97b1d38b7a63b91b56c99efdc2f9dc51", "url": "https://github.com/hazelcast/hazelcast/commit/6a4ec19b97b1d38b7a63b91b56c99efdc2f9dc51", "message": "New Types Support On Serialization For Sql\n\nThe following types are added to serialization system.\nThe need comes from the SQL work.\n\nBigInteger,BigDecimal,LocalTime,LocalDate\n,LocalDateTime,OffsetDateTime\n\nAdded root serializers for each of the type. That means that\nthese types can be put to any data structure. They were\nserialized via default Java Serialization before. Now, they\nhave their own serializer id's. That means that these can be\nadded to any non-java client, and they can be distinguised\nby id when doing query.\n\nThese types are also added to Portable. Each one have their own\nmethod on PortableReader/Writer. Also the support for Array of\neach type is also added. Note that a field of an array can be\nnull. Since writeUTFArray had a null item support on arrays,\nthe rest  is made inline with that.\n\nWe did not add new types to ObjectDataOutput/Input classes.\nDataSerializable/IdentifiedDataSerializable does not support\nthem. The reason behind it that, they already have write/readObject\nThis enables using these classes on Java. For non-java clients,\nthis work is posptponed for now(because it is likely that we\nwill deprecate DataSerializable soon)", "committedDate": "2020-07-23T14:03:51Z", "type": "forcePushed"}, {"oid": "395cb58820e2e5f548e5a9f93995b211cd8bf3e7", "url": "https://github.com/hazelcast/hazelcast/commit/395cb58820e2e5f548e5a9f93995b211cd8bf3e7", "message": "remove null item support in Array", "committedDate": "2020-08-19T13:24:18Z", "type": "forcePushed"}, {"oid": "719e3a593881ed3998480bed25d0ab08a97d398b", "url": "https://github.com/hazelcast/hazelcast/commit/719e3a593881ed3998480bed25d0ab08a97d398b", "message": "reverted support for root serializer for new types", "committedDate": "2020-08-20T14:48:19Z", "type": "forcePushed"}, {"oid": "3b6ea6ed962882af9cb2bd2404775a1c7cdd2830", "url": "https://github.com/hazelcast/hazelcast/commit/3b6ea6ed962882af9cb2bd2404775a1c7cdd2830", "message": "reverted support for root serializer for new types", "committedDate": "2020-08-21T07:39:29Z", "type": "forcePushed"}, {"oid": "87af9099f3f14b42e2a110d9325d30813fbefcb1", "url": "https://github.com/hazelcast/hazelcast/commit/87af9099f3f14b42e2a110d9325d30813fbefcb1", "message": "New Types Support On Serialization For Sql\n\nThe following types are added to serialization system.\nThe need comes from the SQL work.\n\nBigInteger,BigDecimal,LocalTime,LocalDate\n,LocalDateTime,OffsetDateTime\n\nAdded root serializers for each of the type. That means that\nthese types can be put to any data structure. They were\nserialized via default Java Serialization before. Now, they\nhave their own serializer id's. That means that these can be\nadded to any non-java client, and they can be distinguised\nby id when doing query.\n\nThese types are also added to Portable. Each one have their own\nmethod on PortableReader/Writer. Also the support for Array of\neach type is also added. Note that a field of an array can be\nnull. Since writeUTFArray had a null item support on arrays,\nthe rest  is made inline with that.\n\nWe did not add new types to ObjectDataOutput/Input classes.\nDataSerializable/IdentifiedDataSerializable does not support\nthem. The reason behind it that, they already have write/readObject\nThis enables using these classes on Java. For non-java clients,\nthis work is posptponed for now(because it is likely that we\nwill deprecate DataSerializable soon)", "committedDate": "2020-08-21T12:49:44Z", "type": "forcePushed"}, {"oid": "dcdf4527c8b07f5909ad7c9d5c49d7dad09bd764", "url": "https://github.com/hazelcast/hazelcast/commit/dcdf4527c8b07f5909ad7c9d5c49d7dad09bd764", "message": "New Types Support On Serialization For Sql\n\nThe following types are added to serialization system.\nThe need comes from the SQL work.\n\nBigInteger,BigDecimal,LocalTime,LocalDate\n,LocalDateTime,OffsetDateTime\n\nAdded root serializers for each of the type. That means that\nthese types can be put to any data structure. They were\nserialized via default Java Serialization before. Now, they\nhave their own serializer id's. That means that these can be\nadded to any non-java client, and they can be distinguised\nby id when doing query.\n\nThese types are also added to Portable. Each one have their own\nmethod on PortableReader/Writer. Also the support for Array of\neach type is also added. Note that a field of an array can be\nnull. Since writeUTFArray had a null item support on arrays,\nthe rest  is made inline with that.\n\nWe did not add new types to ObjectDataOutput/Input classes.\nDataSerializable/IdentifiedDataSerializable does not support\nthem. The reason behind it that, they already have write/readObject\nThis enables using these classes on Java. For non-java clients,\nthis work is posptponed for now(because it is likely that we\nwill deprecate DataSerializable soon)", "committedDate": "2020-08-24T08:25:11Z", "type": "forcePushed"}, {"oid": "cfaef6045f726965d8cc63fa69c39e39c7f155ba", "url": "https://github.com/hazelcast/hazelcast/commit/cfaef6045f726965d8cc63fa69c39e39c7f155ba", "message": "New Types Support On Serialization For Sql\n\nThe following types are added to serialization system.\nThe need comes from the SQL work.\n\nBigInteger,BigDecimal,LocalTime,LocalDate\n,LocalDateTime,OffsetDateTime\n\nAdded root serializers for each of the type. That means that\nthese types can be put to any data structure. They were\nserialized via default Java Serialization before. Now, they\nhave their own serializer id's. That means that these can be\nadded to any non-java client, and they can be distinguised\nby id when doing query.\n\nThese types are also added to Portable. Each one have their own\nmethod on PortableReader/Writer. Also the support for Array of\neach type is also added. Note that a field of an array can be\nnull. Since writeUTFArray had a null item support on arrays,\nthe rest  is made inline with that.\n\nWe did not add new types to ObjectDataOutput/Input classes.\nDataSerializable/IdentifiedDataSerializable does not support\nthem. The reason behind it that, they already have write/readObject\nThis enables using these classes on Java. For non-java clients,\nthis work is posptponed for now(because it is likely that we\nwill deprecate DataSerializable soon)", "committedDate": "2020-08-24T19:45:49Z", "type": "forcePushed"}, {"oid": "bb97435c8ac382c4c131ce949568c8fcd66b5968", "url": "https://github.com/hazelcast/hazelcast/commit/bb97435c8ac382c4c131ce949568c8fcd66b5968", "message": "New Types Support On Serialization For Sql\n\nThe following types are added to serialization system.\nThe need comes from the SQL work.\n\nBigInteger,BigDecimal,LocalTime,LocalDate\n,LocalDateTime,OffsetDateTime\n\nAdded root serializers for each of the type. That means that\nthese types can be put to any data structure. They were\nserialized via default Java Serialization before. Now, they\nhave their own serializer id's. That means that these can be\nadded to any non-java client, and they can be distinguised\nby id when doing query.\n\nThese types are also added to Portable. Each one have their own\nmethod on PortableReader/Writer. Also the support for Array of\neach type is also added. Note that a field of an array can be\nnull. Since writeUTFArray had a null item support on arrays,\nthe rest  is made inline with that.\n\nWe did not add new types to ObjectDataOutput/Input classes.\nDataSerializable/IdentifiedDataSerializable does not support\nthem. The reason behind it that, they already have write/readObject\nThis enables using these classes on Java. For non-java clients,\nthis work is posptponed for now(because it is likely that we\nwill deprecate DataSerializable soon)", "committedDate": "2020-08-25T07:57:24Z", "type": "forcePushed"}, {"oid": "3ee3b38b6daa6fb300ec7b21a0fcee082373ce65", "url": "https://github.com/hazelcast/hazelcast/commit/3ee3b38b6daa6fb300ec7b21a0fcee082373ce65", "message": "New Types Support On Serialization For Sql\n\nThe following types are added to serialization system.\nThe need comes from the SQL work.\n\nBigInteger,BigDecimal,LocalTime,LocalDate\n,LocalDateTime,OffsetDateTime\n\nAdded root serializers for each of the type. That means that\nthese types can be put to any data structure. They were\nserialized via default Java Serialization before. Now, they\nhave their own serializer id's. That means that these can be\nadded to any non-java client, and they can be distinguised\nby id when doing query.\n\nThese types are also added to Portable. Each one have their own\nmethod on PortableReader/Writer. Also the support for Array of\neach type is also added. Note that a field of an array can be\nnull. Since writeUTFArray had a null item support on arrays,\nthe rest  is made inline with that.\n\nWe did not add new types to ObjectDataOutput/Input classes.\nDataSerializable/IdentifiedDataSerializable does not support\nthem. The reason behind it that, they already have write/readObject\nThis enables using these classes on Java. For non-java clients,\nthis work is posptponed for now(because it is likely that we\nwill deprecate DataSerializable soon)", "committedDate": "2020-08-25T08:30:10Z", "type": "forcePushed"}, {"oid": "23e337c3fae463c9e33e1e2597afcf63eb180c92", "url": "https://github.com/hazelcast/hazelcast/commit/23e337c3fae463c9e33e1e2597afcf63eb180c92", "message": " New Types Support On Serialization For Sql\n\n    The following types are added to serialization system.\n    The need comes from the SQL work.\n\n    BigInteger,BigDecimal,LocalTime,LocalDate\n    ,LocalDateTime,OffsetDateTime\n\n    These types are added to Portable. Each one have their own\n    method on PortableReader/Writer. Also the support for Array of\n    each type is also added. Note that a field of an array can be\n    null. Since writeUTFArray had a null item support on arrays,\n    the rest  is made inline with that.\n\n    We did not add new types to ObjectDataOutput/Input classes.\n    DataSerializable/IdentifiedDataSerializable does not support\n    them. The reason behind it that, they already have write/readObject\n    This enables using these classes on Java. For non-java clients,\n    this work is posptponed for now(because it is likely that we\n    will deprecate DataSerializable soon)", "committedDate": "2020-08-25T09:57:31Z", "type": "forcePushed"}, {"oid": "0eedfe54023ff2f3f8de886e3a1036955358e35d", "url": "https://github.com/hazelcast/hazelcast/commit/0eedfe54023ff2f3f8de886e3a1036955358e35d", "message": "New Types Support On Portable For Sql\n\nThe following types are added to the Portable. The need comes from the SQL work.\n\nBigDecimal,LocalTime,LocalDate,LocalDateTime,OffsetDateTime\n\nEach one has its own method on PortableReader/Writer, GenericRecord/Builder,\nClassDefinitionBuilder, etc.. Also, the support for the array of each type is also added.\n\nWe did not add these types to ObjectDataOutput/Input or to root serializers.", "committedDate": "2021-01-22T08:17:41Z", "type": "forcePushed"}, {"oid": "b5cd572aaffa449c0820dbc6711f91644e2ecb07", "url": "https://github.com/hazelcast/hazelcast/commit/b5cd572aaffa449c0820dbc6711f91644e2ecb07", "message": "New Types Support On Portable For Sql\n\nThe following types are added to the Portable. The need comes from the SQL work.\n\nBigDecimal,LocalTime,LocalDate,LocalDateTime,OffsetDateTime\n\nEach one has its own method on PortableReader/Writer, GenericRecord/Builder,\nClassDefinitionBuilder, etc.. Also, the support for the array of each type is also added.\n\nWe did not add these types to ObjectDataOutput/Input or to root serializers.", "committedDate": "2021-01-22T09:19:19Z", "type": "forcePushed"}, {"oid": "3e15eab389b40c682e3043610c0902d88ec9be69", "url": "https://github.com/hazelcast/hazelcast/commit/3e15eab389b40c682e3043610c0902d88ec9be69", "message": "New Types Support On Portable For Sql\n\nThe following types are added to the Portable. The need comes from the SQL work.\n\nBigDecimal,LocalTime,LocalDate,LocalDateTime,OffsetDateTime\n\nEach one has its own method on PortableReader/Writer, GenericRecord/Builder,\nClassDefinitionBuilder, etc.. Also, the support for the array of each type is also added.\n\nWe did not add these types to ObjectDataOutput/Input or to root serializers.", "committedDate": "2021-01-27T09:29:09Z", "type": "commit"}, {"oid": "3f6700dc655a021e99587f5ce87fa841df98119b", "url": "https://github.com/hazelcast/hazelcast/commit/3f6700dc655a021e99587f5ce87fa841df98119b", "message": "Add missing parts on AbstractGenericRecord\n\nalso add tests for missing part", "committedDate": "2021-01-27T11:14:51Z", "type": "commit"}, {"oid": "3f6700dc655a021e99587f5ce87fa841df98119b", "url": "https://github.com/hazelcast/hazelcast/commit/3f6700dc655a021e99587f5ce87fa841df98119b", "message": "Add missing parts on AbstractGenericRecord\n\nalso add tests for missing part", "committedDate": "2021-01-27T11:14:51Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTE5NTg3Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17257#discussion_r565195876", "bodyText": "It seems that this code piece is duplicated. Maybe we can put it into a separate function", "author": "mdumandag", "createdAt": "2021-01-27T10:29:05Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/serialization/impl/portable/DefaultPortableWriter.java", "diffHunk": "@@ -182,61 +190,111 @@ public void writeNullPortable(String fieldName, int factoryId, int classId) thro\n     }\n \n     @Override\n-    public void writeByteArray(String fieldName, byte[] values) throws IOException {\n+    public void writeDecimal(@Nonnull String fieldName, @Nullable BigDecimal value) throws IOException {\n+        setPosition(fieldName, FieldType.DECIMAL);", "originalCommit": "b5cd572aaffa449c0820dbc6711f91644e2ecb07", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTE5NzE5Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17257#discussion_r565197192", "bodyText": "We can add @Nullable annotation to portable parameter", "author": "mdumandag", "createdAt": "2021-01-27T10:30:56Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/serialization/impl/portable/DefaultPortableWriter.java", "diffHunk": "@@ -135,7 +143,7 @@ public void writePortable(String fieldName, Portable portable) throws IOExceptio\n         }\n     }\n \n-    public void writeGenericRecord(String fieldName, GenericRecord portable) throws IOException {\n+    public void writeGenericRecord(@Nonnull String fieldName, GenericRecord portable) throws IOException {", "originalCommit": "b5cd572aaffa449c0820dbc6711f91644e2ecb07", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTIwNjM4NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17257#discussion_r565206384", "bodyText": "Minor: Should we add @Nullable annotation to the return value? We do it for parameters and IDE shows a warning about that in the super class", "author": "mdumandag", "createdAt": "2021-01-27T10:45:07Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/serialization/impl/portable/MorphingPortableReader.java", "diffHunk": "@@ -204,113 +217,118 @@ public short readShort(String fieldName) throws IOException {\n     }\n \n     @Override\n-    public byte[] readByteArray(String fieldName) throws IOException {\n-        FieldDefinition fd = cd.getField(fieldName);\n-        if (fd == null) {\n-            return null;\n-        }\n-        validateTypeCompatibility(fd, BYTE_ARRAY);\n-        return super.readByteArray(fieldName);\n+    public BigDecimal readDecimal(@Nonnull String fieldName) throws IOException {", "originalCommit": "b5cd572aaffa449c0820dbc6711f91644e2ecb07", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTIwNzU0NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17257#discussion_r565207544", "bodyText": "Minor: There are some missing @Nullable annotations in this file", "author": "mdumandag", "createdAt": "2021-01-27T10:46:54Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/serialization/impl/portable/PortableGenericRecord.java", "diffHunk": "@@ -172,13 +210,38 @@ public String readUTF(@Nonnull String fieldName) {\n         return read(fieldName, FieldType.UTF_ARRAY);\n     }\n \n-    private <T> T read(String fieldName, FieldType fieldType) {\n+    @Override\n+    public BigDecimal[] readDecimalArray(@Nonnull String fieldName) {", "originalCommit": "b5cd572aaffa449c0820dbc6711f91644e2ecb07", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTI0NDg2Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17257#discussion_r565244866", "bodyText": "I tried to address the public API's only.", "author": "sancar", "createdAt": "2021-01-27T11:46:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTIwNzU0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTIwOTkzOA==", "url": "https://github.com/hazelcast/hazelcast/pull/17257#discussion_r565209938", "bodyText": "This is the second time we define such an interface. Maybe we can define this once in IOUtil. (and Writer interface used in other files)", "author": "mdumandag", "createdAt": "2021-01-27T10:50:26Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/serialization/impl/portable/PortableInternalGenericRecord.java", "diffHunk": "@@ -182,6 +194,52 @@ public String readUTF(@Nonnull String fieldName) {\n         }\n     }\n \n+    protected interface Reader<T, R> {", "originalCommit": "b5cd572aaffa449c0820dbc6711f91644e2ecb07", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTI0ODI1MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17257#discussion_r565248251", "bodyText": "We have a FunctionEx but it does not fit here because of the thrown exception type.  I did not want to add one more yet. May be later when need arise we can refactor.", "author": "sancar", "createdAt": "2021-01-27T11:52:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTIwOTkzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTIxMTcyOQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17257#discussion_r565211729", "bodyText": "Should we add @Nullable annotation to the return value?", "author": "mdumandag", "createdAt": "2021-01-27T10:52:53Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/serialization/impl/portable/PortableInternalGenericRecord.java", "diffHunk": "@@ -182,6 +194,52 @@ public String readUTF(@Nonnull String fieldName) {\n         }\n     }\n \n+    protected interface Reader<T, R> {\n+        R read(T t) throws IOException;\n+    }\n+\n+    private <T> T readNullableField(@Nonnull String fieldName, FieldType fieldType, Reader<ObjectDataInput, T> reader) {", "originalCommit": "b5cd572aaffa449c0820dbc6711f91644e2ecb07", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTIxNDE4Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17257#discussion_r565214186", "bodyText": "On what conditions can pos be -1?", "author": "mdumandag", "createdAt": "2021-01-27T10:56:40Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/serialization/impl/portable/PortableInternalGenericRecord.java", "diffHunk": "@@ -340,6 +398,66 @@ private boolean isNullOrEmpty(int pos) {\n         }\n     }\n \n+\n+    private <T> T[] readObjectArrayField(@Nonnull String fieldName, FieldType fieldType, Function<Integer, T[]> constructor,\n+                                         Reader<ObjectDataInput, T> reader) {\n+        int currentPos = in.position();\n+        try {\n+            int position = readPosition(fieldName, fieldType);\n+            if (isNullOrEmpty(position)) {\n+                return null;\n+            }\n+            in.position(position);\n+            int len = in.readInt();\n+\n+            if (len == Bits.NULL_ARRAY_LENGTH) {\n+                return null;\n+            }\n+\n+            T[] values = constructor.apply(len);\n+            if (len > 0) {\n+                int offset = in.position();\n+                for (int i = 0; i < len; i++) {\n+                    int pos = in.readInt(offset + i * Bits.INT_SIZE_IN_BYTES);\n+                    if (pos != -1) {", "originalCommit": "b5cd572aaffa449c0820dbc6711f91644e2ecb07", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTI0ODE4Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17257#discussion_r565248182", "bodyText": "Looks like a leftover. At first I allowed null items in the array, later we have decided not to. I will remove this check.", "author": "sancar", "createdAt": "2021-01-27T11:52:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTIxNDE4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTIxNjcxNg==", "url": "https://github.com/hazelcast/hazelcast/pull/17257#discussion_r565216716", "bodyText": "There is also a lot of duplication here", "author": "mdumandag", "createdAt": "2021-01-27T11:00:20Z", "path": "hazelcast/src/main/java/com/hazelcast/nio/serialization/ClassDefinitionBuilder.java", "diffHunk": "@@ -183,19 +184,92 @@ public ClassDefinitionBuilder addFloatField(String fieldName) {\n      * @throws HazelcastSerializationException if a field with same name already exists or\n      *                                         if this method is called after {@link ClassDefinitionBuilder#build()}\n      */\n-    public ClassDefinitionBuilder addShortField(String fieldName) {\n+    public ClassDefinitionBuilder addShortField(@Nonnull String fieldName) {\n         check(fieldName);\n         fieldDefinitions.add(new FieldDefinitionImpl(index++, fieldName, FieldType.SHORT, version));\n         return this;\n     }\n \n+    /**\n+     * Adds a decimal which is arbitrary precision and scale floating-point number to the class definition\n+     *\n+     * @param fieldName name of the field that will be added to this class definition\n+     * @return itself for chaining\n+     * @throws HazelcastSerializationException if a field with same name already exists or\n+     *                                         if this method is called after {@link ClassDefinitionBuilder#build()}\n+     */\n+    public ClassDefinitionBuilder addDecimalField(@Nonnull String fieldName) {\n+        check(fieldName);", "originalCommit": "b5cd572aaffa449c0820dbc6711f91644e2ecb07", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTIxNzU3MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17257#discussion_r565217571", "bodyText": "year , month -> year, month", "author": "mdumandag", "createdAt": "2021-01-27T11:01:41Z", "path": "hazelcast/src/main/java/com/hazelcast/nio/serialization/ClassDefinitionBuilder.java", "diffHunk": "@@ -183,19 +184,92 @@ public ClassDefinitionBuilder addFloatField(String fieldName) {\n      * @throws HazelcastSerializationException if a field with same name already exists or\n      *                                         if this method is called after {@link ClassDefinitionBuilder#build()}\n      */\n-    public ClassDefinitionBuilder addShortField(String fieldName) {\n+    public ClassDefinitionBuilder addShortField(@Nonnull String fieldName) {\n         check(fieldName);\n         fieldDefinitions.add(new FieldDefinitionImpl(index++, fieldName, FieldType.SHORT, version));\n         return this;\n     }\n \n+    /**\n+     * Adds a decimal which is arbitrary precision and scale floating-point number to the class definition\n+     *\n+     * @param fieldName name of the field that will be added to this class definition\n+     * @return itself for chaining\n+     * @throws HazelcastSerializationException if a field with same name already exists or\n+     *                                         if this method is called after {@link ClassDefinitionBuilder#build()}\n+     */\n+    public ClassDefinitionBuilder addDecimalField(@Nonnull String fieldName) {\n+        check(fieldName);\n+        fieldDefinitions.add(new FieldDefinitionImpl(index++, fieldName, FieldType.DECIMAL, version));\n+        return this;\n+    }\n+\n+    /**\n+     * Adds a time field consisting of hour, minute, seconds and nanos parts to the class definition\n+     *\n+     * @param fieldName name of the field that will be added to this class definition\n+     * @return itself for chaining\n+     * @throws HazelcastSerializationException if a field with same name already exists or\n+     *                                         if this method is called after {@link ClassDefinitionBuilder#build()}\n+     */\n+    public ClassDefinitionBuilder addTimeField(@Nonnull String fieldName) {\n+        check(fieldName);\n+        fieldDefinitions.add(new FieldDefinitionImpl(index++, fieldName, FieldType.TIME, version));\n+        return this;\n+    }\n+\n+    /**\n+     * Adds a date field consisting of year , month of the year and day of the month to the class definition", "originalCommit": "b5cd572aaffa449c0820dbc6711f91644e2ecb07", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTIzMjk4MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17257#discussion_r565232981", "bodyText": "Same applies to PortableReader, PortableWriter and GenericRecord javadocs", "author": "mdumandag", "createdAt": "2021-01-27T11:26:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTIxNzU3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTIxNzgxNQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17257#discussion_r565217815", "bodyText": "year , month -> year, month\nmonth of the year and day of the month -> month of the year, day of the month", "author": "mdumandag", "createdAt": "2021-01-27T11:02:03Z", "path": "hazelcast/src/main/java/com/hazelcast/nio/serialization/ClassDefinitionBuilder.java", "diffHunk": "@@ -183,19 +184,92 @@ public ClassDefinitionBuilder addFloatField(String fieldName) {\n      * @throws HazelcastSerializationException if a field with same name already exists or\n      *                                         if this method is called after {@link ClassDefinitionBuilder#build()}\n      */\n-    public ClassDefinitionBuilder addShortField(String fieldName) {\n+    public ClassDefinitionBuilder addShortField(@Nonnull String fieldName) {\n         check(fieldName);\n         fieldDefinitions.add(new FieldDefinitionImpl(index++, fieldName, FieldType.SHORT, version));\n         return this;\n     }\n \n+    /**\n+     * Adds a decimal which is arbitrary precision and scale floating-point number to the class definition\n+     *\n+     * @param fieldName name of the field that will be added to this class definition\n+     * @return itself for chaining\n+     * @throws HazelcastSerializationException if a field with same name already exists or\n+     *                                         if this method is called after {@link ClassDefinitionBuilder#build()}\n+     */\n+    public ClassDefinitionBuilder addDecimalField(@Nonnull String fieldName) {\n+        check(fieldName);\n+        fieldDefinitions.add(new FieldDefinitionImpl(index++, fieldName, FieldType.DECIMAL, version));\n+        return this;\n+    }\n+\n+    /**\n+     * Adds a time field consisting of hour, minute, seconds and nanos parts to the class definition\n+     *\n+     * @param fieldName name of the field that will be added to this class definition\n+     * @return itself for chaining\n+     * @throws HazelcastSerializationException if a field with same name already exists or\n+     *                                         if this method is called after {@link ClassDefinitionBuilder#build()}\n+     */\n+    public ClassDefinitionBuilder addTimeField(@Nonnull String fieldName) {\n+        check(fieldName);\n+        fieldDefinitions.add(new FieldDefinitionImpl(index++, fieldName, FieldType.TIME, version));\n+        return this;\n+    }\n+\n+    /**\n+     * Adds a date field consisting of year , month of the year and day of the month to the class definition\n+     *\n+     * @param fieldName name of the field that will be added to this class definition\n+     * @return itself for chaining\n+     * @throws HazelcastSerializationException if a field with same name already exists or\n+     *                                         if this method is called after {@link ClassDefinitionBuilder#build()}\n+     */\n+    public ClassDefinitionBuilder addDateField(@Nonnull String fieldName) {\n+        check(fieldName);\n+        fieldDefinitions.add(new FieldDefinitionImpl(index++, fieldName, FieldType.DATE, version));\n+        return this;\n+    }\n+\n+    /**\n+     * Adds a timestamp field consisting of\n+     * year , month of the year and day of the month, hour, minute, seconds, nanos parts to the class definition", "originalCommit": "b5cd572aaffa449c0820dbc6711f91644e2ecb07", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTIzMzAzNw==", "url": "https://github.com/hazelcast/hazelcast/pull/17257#discussion_r565233037", "bodyText": "Same applies to PortableReader, PortableWriter and GenericRecord javadocs", "author": "mdumandag", "createdAt": "2021-01-27T11:26:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTIxNzgxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTIxODU5OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17257#discussion_r565218599", "bodyText": "year , month -> year, month\nmonth of the year and day of the month -> month of the year, day of the month", "author": "mdumandag", "createdAt": "2021-01-27T11:03:14Z", "path": "hazelcast/src/main/java/com/hazelcast/nio/serialization/ClassDefinitionBuilder.java", "diffHunk": "@@ -183,19 +184,92 @@ public ClassDefinitionBuilder addFloatField(String fieldName) {\n      * @throws HazelcastSerializationException if a field with same name already exists or\n      *                                         if this method is called after {@link ClassDefinitionBuilder#build()}\n      */\n-    public ClassDefinitionBuilder addShortField(String fieldName) {\n+    public ClassDefinitionBuilder addShortField(@Nonnull String fieldName) {\n         check(fieldName);\n         fieldDefinitions.add(new FieldDefinitionImpl(index++, fieldName, FieldType.SHORT, version));\n         return this;\n     }\n \n+    /**\n+     * Adds a decimal which is arbitrary precision and scale floating-point number to the class definition\n+     *\n+     * @param fieldName name of the field that will be added to this class definition\n+     * @return itself for chaining\n+     * @throws HazelcastSerializationException if a field with same name already exists or\n+     *                                         if this method is called after {@link ClassDefinitionBuilder#build()}\n+     */\n+    public ClassDefinitionBuilder addDecimalField(@Nonnull String fieldName) {\n+        check(fieldName);\n+        fieldDefinitions.add(new FieldDefinitionImpl(index++, fieldName, FieldType.DECIMAL, version));\n+        return this;\n+    }\n+\n+    /**\n+     * Adds a time field consisting of hour, minute, seconds and nanos parts to the class definition\n+     *\n+     * @param fieldName name of the field that will be added to this class definition\n+     * @return itself for chaining\n+     * @throws HazelcastSerializationException if a field with same name already exists or\n+     *                                         if this method is called after {@link ClassDefinitionBuilder#build()}\n+     */\n+    public ClassDefinitionBuilder addTimeField(@Nonnull String fieldName) {\n+        check(fieldName);\n+        fieldDefinitions.add(new FieldDefinitionImpl(index++, fieldName, FieldType.TIME, version));\n+        return this;\n+    }\n+\n+    /**\n+     * Adds a date field consisting of year , month of the year and day of the month to the class definition\n+     *\n+     * @param fieldName name of the field that will be added to this class definition\n+     * @return itself for chaining\n+     * @throws HazelcastSerializationException if a field with same name already exists or\n+     *                                         if this method is called after {@link ClassDefinitionBuilder#build()}\n+     */\n+    public ClassDefinitionBuilder addDateField(@Nonnull String fieldName) {\n+        check(fieldName);\n+        fieldDefinitions.add(new FieldDefinitionImpl(index++, fieldName, FieldType.DATE, version));\n+        return this;\n+    }\n+\n+    /**\n+     * Adds a timestamp field consisting of\n+     * year , month of the year and day of the month, hour, minute, seconds, nanos parts to the class definition\n+     *\n+     * @param fieldName name of the field that will be added to this class definition\n+     * @return itself for chaining\n+     * @throws HazelcastSerializationException if a field with same name already exists or\n+     *                                         if this method is called after {@link ClassDefinitionBuilder#build()}\n+     */\n+    public ClassDefinitionBuilder addTimestampField(@Nonnull String fieldName) {\n+        check(fieldName);\n+        fieldDefinitions.add(new FieldDefinitionImpl(index++, fieldName, FieldType.TIMESTAMP, version));\n+        return this;\n+    }\n+\n+    /**\n+     * Adds a timestamp with timezone field consisting of\n+     * year , month of the year and day of the month, offset seconds , hour, minute, seconds, nanos parts", "originalCommit": "b5cd572aaffa449c0820dbc6711f91644e2ecb07", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTIzMzA4MA==", "url": "https://github.com/hazelcast/hazelcast/pull/17257#discussion_r565233080", "bodyText": "Same applies to PortableReader, PortableWriter and GenericRecord javadocs", "author": "mdumandag", "createdAt": "2021-01-27T11:26:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTIxODU5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTIyOTMxOQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17257#discussion_r565229319", "bodyText": "Missing @Nullable annotation in the return value", "author": "mdumandag", "createdAt": "2021-01-27T11:20:30Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/serialization/impl/portable/DefaultPortableReader.java", "diffHunk": "@@ -158,7 +227,7 @@ public String readUTF(String fieldName) throws IOException {\n \n     @Override\n     @SuppressWarnings(\"unchecked\")\n-    public Portable readPortable(String fieldName) throws IOException {\n+    public Portable readPortable(@Nonnull String fieldName) throws IOException {", "originalCommit": "3f6700dc655a021e99587f5ce87fa841df98119b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTI2MjM2Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17257#discussion_r565262363", "bodyText": "Is this check also unnecessary?", "author": "mdumandag", "createdAt": "2021-01-27T12:17:07Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/serialization/impl/portable/PortableInternalGenericRecord.java", "diffHunk": "@@ -685,13 +803,67 @@ public Object readObjectFromArray(String fieldName, int index) {\n         }\n     }\n \n+\n+    private <T> T readObjectFromArrayField(@Nonnull String fieldName, FieldType fieldType,\n+                                           Reader<ObjectDataInput, T> reader, int index) {\n+        int currentPos = in.position();\n+        try {\n+            int position = readPosition(fieldName, fieldType);\n+            if (isNullOrEmpty(position)) {\n+                return null;\n+            }\n+            in.position(position);\n+            int len = in.readInt();\n+            if (len == Bits.NULL_ARRAY_LENGTH || len == 0 || len <= index) {\n+                return null;\n+            }\n+\n+            int offset = in.position();\n+            int pos = in.readInt(offset + index * Bits.INT_SIZE_IN_BYTES);\n+            if (pos != -1) {", "originalCommit": "5396ef7b7299d7415f8fc4a8762e945fbb8ff0a0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTI3MTk0Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/17257#discussion_r565271947", "bodyText": "Removed this check as well. leftover as before.", "author": "sancar", "createdAt": "2021-01-27T12:33:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTI2MjM2Mw=="}], "type": "inlineReview"}, {"oid": "b2c4239a5040874845fdce9750c8995b1133a600", "url": "https://github.com/hazelcast/hazelcast/commit/b2c4239a5040874845fdce9750c8995b1133a600", "message": "addressing review comments", "committedDate": "2021-01-27T12:32:28Z", "type": "commit"}, {"oid": "b2c4239a5040874845fdce9750c8995b1133a600", "url": "https://github.com/hazelcast/hazelcast/commit/b2c4239a5040874845fdce9750c8995b1133a600", "message": "addressing review comments", "committedDate": "2021-01-27T12:32:28Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTg2Mjk2Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17257#discussion_r565862963", "bodyText": "nit: suggestion for this and other write*ArrayField methods\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        out.writeZeroBytes(len * 4);\n          \n          \n            \n                        out.writeZeroBytes(len * INT_SIZE_IN_BYTES);", "author": "puzpuzpuz", "createdAt": "2021-01-28T07:08:25Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/serialization/impl/portable/DefaultPortableWriter.java", "diffHunk": "@@ -257,7 +300,58 @@ public void writePortableArray(String fieldName, Portable[] portables) throws IO\n         }\n     }\n \n-    void writeGenericRecordArray(String fieldName, GenericRecord[] portables) throws IOException {\n+    interface Writer<O, T> {\n+\n+        void write(O out, T value) throws IOException;\n+    }\n+\n+    private <T> void writeObjectArrayField(@Nonnull String fieldName, FieldType fieldType, @Nullable T[] values,\n+                                           Writer<ObjectDataOutput, T> writer) throws IOException {\n+        setPosition(fieldName, fieldType);\n+        final int len = values == null ? NULL_ARRAY_LENGTH : values.length;\n+        out.writeInt(len);\n+\n+        if (len > 0) {\n+            final int offset = out.position();\n+            out.writeZeroBytes(len * 4);", "originalCommit": "b2c4239a5040874845fdce9750c8995b1133a600", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTg2NDg4OA==", "url": "https://github.com/hazelcast/hazelcast/pull/17257#discussion_r565864888", "bodyText": "nit: can be shortened\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return readIncompatibleField(fieldName, UTF, MorphingPortableReader.super::readUTF);\n          \n          \n            \n                    return readIncompatibleField(fieldName, UTF, super::readUTF);", "author": "puzpuzpuz", "createdAt": "2021-01-28T07:13:20Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/serialization/impl/portable/MorphingPortableReader.java", "diffHunk": "@@ -100,17 +117,13 @@ public long readLong(String fieldName) throws IOException {\n     }\n \n     @Override\n-    public String readUTF(String fieldName) throws IOException {\n-        FieldDefinition fd = cd.getField(fieldName);\n-        if (fd == null) {\n-            return null;\n-        }\n-        validateTypeCompatibility(fd, UTF);\n-        return super.readUTF(fieldName);\n+    @Nullable\n+    public String readUTF(@Nonnull String fieldName) throws IOException {\n+        return readIncompatibleField(fieldName, UTF, MorphingPortableReader.super::readUTF);", "originalCommit": "b2c4239a5040874845fdce9750c8995b1133a600", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTg2ODI4MA==", "url": "https://github.com/hazelcast/hazelcast/pull/17257#discussion_r565868280", "bodyText": "nit: could be marked with @FunctionalInterface", "author": "puzpuzpuz", "createdAt": "2021-01-28T07:21:25Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/serialization/impl/portable/PortableInternalGenericRecord.java", "diffHunk": "@@ -182,6 +195,53 @@ public String readUTF(@Nonnull String fieldName) {\n         }\n     }\n \n+    protected interface Reader<T, R> {", "originalCommit": "b2c4239a5040874845fdce9750c8995b1133a600", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTg3MTQ1OA==", "url": "https://github.com/hazelcast/hazelcast/pull/17257#discussion_r565871458", "bodyText": "nit: could be marked with @FunctionalInterface", "author": "puzpuzpuz", "createdAt": "2021-01-28T07:28:57Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/serialization/impl/portable/DefaultPortableReader.java", "diffHunk": "@@ -105,47 +122,99 @@ final void end() {\n     }\n \n     @Override\n-    public byte readByte(String fieldName) throws IOException {\n+    public byte readByte(@Nonnull String fieldName) throws IOException {\n         return in.readByte(readPosition(fieldName, FieldType.BYTE));\n     }\n \n     @Override\n-    public short readShort(String fieldName) throws IOException {\n+    public short readShort(@Nonnull String fieldName) throws IOException {\n         return in.readShort(readPosition(fieldName, FieldType.SHORT));\n     }\n \n+    protected interface Reader<T, R> {", "originalCommit": "b2c4239a5040874845fdce9750c8995b1133a600", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTg3MTc4NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17257#discussion_r565871785", "bodyText": "nit: could be private", "author": "puzpuzpuz", "createdAt": "2021-01-28T07:29:45Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/serialization/impl/portable/PortableInternalGenericRecord.java", "diffHunk": "@@ -182,6 +195,53 @@ public String readUTF(@Nonnull String fieldName) {\n         }\n     }\n \n+    protected interface Reader<T, R> {", "originalCommit": "b2c4239a5040874845fdce9750c8995b1133a600", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTg3MjUwNg==", "url": "https://github.com/hazelcast/hazelcast/pull/17257#discussion_r565872506", "bodyText": "nit: consider renaming to newUnknownFieldException", "author": "puzpuzpuz", "createdAt": "2021-01-28T07:31:23Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/serialization/impl/portable/PortableInternalGenericRecord.java", "diffHunk": "@@ -367,7 +485,7 @@ private IllegalStateException illegalStateException(IOException e) {\n         return new IllegalStateException(\"IOException is not expected since we read from a well known format and position\");\n     }\n \n-    private HazelcastSerializationException throwUnknownFieldException(String fieldName) {\n+    private HazelcastSerializationException throwUnknownFieldException(@Nonnull String fieldName) {", "originalCommit": "b2c4239a5040874845fdce9750c8995b1133a600", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTg3MzI5NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17257#discussion_r565873295", "bodyText": "nit: does it make sense to @Nonnull in private method? If you think it makes sense, constructor parameter and return type also need to be annotated. The same consideration applies to other privates methods in this class.", "author": "puzpuzpuz", "createdAt": "2021-01-28T07:33:16Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/serialization/impl/portable/PortableInternalGenericRecord.java", "diffHunk": "@@ -406,7 +524,7 @@ public Builder cloneWithBuilder() {\n         return readNestedArray(fieldName, GenericRecord[]::new, false);\n     }\n \n-    private <T> T[] readNestedArray(String fieldName, Function<Integer, T[]> constructor, boolean asPortable) {\n+    private <T> T[] readNestedArray(@Nonnull String fieldName, Function<Integer, T[]> constructor, boolean asPortable) {", "originalCommit": "b2c4239a5040874845fdce9750c8995b1133a600", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTg3MzQ1OA==", "url": "https://github.com/hazelcast/hazelcast/pull/17257#discussion_r565873458", "bodyText": "nit: consider renaming to newIllegalStateException", "author": "puzpuzpuz", "createdAt": "2021-01-28T07:33:39Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/serialization/impl/portable/PortableInternalGenericRecord.java", "diffHunk": "@@ -182,6 +195,53 @@ public String readUTF(@Nonnull String fieldName) {\n         }\n     }\n \n+    protected interface Reader<T, R> {\n+        R read(T t) throws IOException;\n+    }\n+\n+    @Nullable\n+    private <T> T readNullableField(@Nonnull String fieldName, FieldType fieldType, Reader<ObjectDataInput, T> reader) {\n+        int currentPos = in.position();\n+        try {\n+            int pos = readPosition(fieldName, fieldType);\n+            in.position(pos);\n+            boolean isNull = in.readBoolean();\n+            if (isNull) {\n+                return null;\n+            }\n+            return reader.read(in);\n+        } catch (IOException e) {\n+            throw illegalStateException(e);", "originalCommit": "b2c4239a5040874845fdce9750c8995b1133a600", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTg3NDM4OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17257#discussion_r565874389", "bodyText": "nit: might be a good idea to include some details from e into the final exception", "author": "puzpuzpuz", "createdAt": "2021-01-28T07:35:44Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/serialization/impl/portable/PortableInternalGenericRecord.java", "diffHunk": "@@ -367,7 +485,7 @@ private IllegalStateException illegalStateException(IOException e) {\n         return new IllegalStateException(\"IOException is not expected since we read from a well known format and position\");", "originalCommit": "b2c4239a5040874845fdce9750c8995b1133a600", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTg3NTIwNg==", "url": "https://github.com/hazelcast/hazelcast/pull/17257#discussion_r565875206", "bodyText": "nit: needs @Nullable annotation for return type. The same consideration applies to other public methods in this class.", "author": "puzpuzpuz", "createdAt": "2021-01-28T07:37:40Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/serialization/impl/portable/PortableInternalGenericRecord.java", "diffHunk": "@@ -182,6 +195,53 @@ public String readUTF(@Nonnull String fieldName) {\n         }\n     }\n \n+    protected interface Reader<T, R> {\n+        R read(T t) throws IOException;\n+    }\n+\n+    @Nullable\n+    private <T> T readNullableField(@Nonnull String fieldName, FieldType fieldType, Reader<ObjectDataInput, T> reader) {\n+        int currentPos = in.position();\n+        try {\n+            int pos = readPosition(fieldName, fieldType);\n+            in.position(pos);\n+            boolean isNull = in.readBoolean();\n+            if (isNull) {\n+                return null;\n+            }\n+            return reader.read(in);\n+        } catch (IOException e) {\n+            throw illegalStateException(e);\n+        } finally {\n+            in.position(currentPos);\n+        }\n+    }\n+\n+    @Override\n+    public BigDecimal readDecimal(@Nonnull String fieldName) {", "originalCommit": "b2c4239a5040874845fdce9750c8995b1133a600", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTg3NjMyMg==", "url": "https://github.com/hazelcast/hazelcast/pull/17257#discussion_r565876322", "bodyText": "Should be removed in favor of javax.annotation.Nonnull", "author": "puzpuzpuz", "createdAt": "2021-01-28T07:40:01Z", "path": "hazelcast/src/main/java/com/hazelcast/nio/serialization/ClassDefinitionBuilder.java", "diffHunk": "@@ -19,7 +19,9 @@\n import com.hazelcast.internal.serialization.impl.portable.ClassDefinitionImpl;\n import com.hazelcast.internal.serialization.impl.portable.FieldDefinitionImpl;\n import com.hazelcast.spi.annotation.PrivateApi;\n+import org.jetbrains.annotations.NotNull;", "originalCommit": "b2c4239a5040874845fdce9750c8995b1133a600", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTg3NjY2MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17257#discussion_r565876661", "bodyText": "nit: return type could be annotated with @Nonnull here and in other public methods in this class", "author": "puzpuzpuz", "createdAt": "2021-01-28T07:40:48Z", "path": "hazelcast/src/main/java/com/hazelcast/nio/serialization/ClassDefinitionBuilder.java", "diffHunk": "@@ -75,10 +77,8 @@ public ClassDefinitionBuilder(int factoryId, int classId, int version) {\n      * @throws HazelcastSerializationException if a field with same name already exists or\n      *                                         if this method is called after {@link ClassDefinitionBuilder#build()}\n      */\n-    public ClassDefinitionBuilder addIntField(String fieldName) {\n-        check(fieldName);\n-        fieldDefinitions.add(new FieldDefinitionImpl(index++, fieldName, FieldType.INT, version));\n-        return this;\n+    public ClassDefinitionBuilder addIntField(@Nonnull String fieldName) {", "originalCommit": "b2c4239a5040874845fdce9750c8995b1133a600", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTg3ODU5OA==", "url": "https://github.com/hazelcast/hazelcast/pull/17257#discussion_r565878598", "bodyText": "nit: does it make sense to mention j.t.LocalTime class here? Otherwise, method's javadoc reads as if the final Portable supports multiple options for time field type. The same question applies to other newly introduced methods (incl. addDecimalField).\nAlso, current javadoc seems to provide internal details on how the field is serialized into a binary. Is it on purpose?", "author": "puzpuzpuz", "createdAt": "2021-01-28T07:45:22Z", "path": "hazelcast/src/main/java/com/hazelcast/nio/serialization/ClassDefinitionBuilder.java", "diffHunk": "@@ -183,58 +167,71 @@ public ClassDefinitionBuilder addFloatField(String fieldName) {\n      * @throws HazelcastSerializationException if a field with same name already exists or\n      *                                         if this method is called after {@link ClassDefinitionBuilder#build()}\n      */\n-    public ClassDefinitionBuilder addShortField(String fieldName) {\n-        check(fieldName);\n-        fieldDefinitions.add(new FieldDefinitionImpl(index++, fieldName, FieldType.SHORT, version));\n-        return this;\n+    public ClassDefinitionBuilder addShortField(@Nonnull String fieldName) {\n+        return addField(fieldName, FieldType.SHORT);\n     }\n \n     /**\n+     * Adds a decimal which is arbitrary precision and scale floating-point number to the class definition\n+     *\n      * @param fieldName name of the field that will be added to this class definition\n      * @return itself for chaining\n      * @throws HazelcastSerializationException if a field with same name already exists or\n      *                                         if this method is called after {@link ClassDefinitionBuilder#build()}\n      */\n-    public ClassDefinitionBuilder addByteArrayField(String fieldName) {\n-        check(fieldName);\n-        fieldDefinitions.add(new FieldDefinitionImpl(index++, fieldName, FieldType.BYTE_ARRAY, version));\n-        return this;\n+    public ClassDefinitionBuilder addDecimalField(@Nonnull String fieldName) {\n+        return addField(fieldName, FieldType.DECIMAL);\n     }\n \n     /**\n+     * Adds a time field consisting of hour, minute, seconds and nanos parts to the class definition", "originalCommit": "b2c4239a5040874845fdce9750c8995b1133a600", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTk2NDYxOQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17257#discussion_r565964619", "bodyText": "The idea is that we may support multiple types in the future.\nI wanted to make what is carries as data obvious so that user will know what to expect when we support multiple types.\nThe supported types will be clear on their respective read/write methods on PortableReader/Writer from the parameters&return types.", "author": "sancar", "createdAt": "2021-01-28T10:03:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTg3ODU5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjAzMTY2NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17257#discussion_r566031665", "bodyText": "In this case we should at least reference corresponding methods of PortableReader/Writer. Current javadoc leaves the reader with too many questions.", "author": "puzpuzpuz", "createdAt": "2021-01-28T11:48:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTg3ODU5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTg4MDEwMg==", "url": "https://github.com/hazelcast/hazelcast/pull/17257#discussion_r565880102", "bodyText": "nit: dot is missing here and in other new methods' javadoc\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Adds a decimal which is arbitrary precision and scale floating-point number to the class definition\n          \n          \n            \n                 * Adds a decimal which is arbitrary precision and scale floating-point number to the class definition.", "author": "puzpuzpuz", "createdAt": "2021-01-28T07:48:10Z", "path": "hazelcast/src/main/java/com/hazelcast/nio/serialization/ClassDefinitionBuilder.java", "diffHunk": "@@ -183,58 +167,71 @@ public ClassDefinitionBuilder addFloatField(String fieldName) {\n      * @throws HazelcastSerializationException if a field with same name already exists or\n      *                                         if this method is called after {@link ClassDefinitionBuilder#build()}\n      */\n-    public ClassDefinitionBuilder addShortField(String fieldName) {\n-        check(fieldName);\n-        fieldDefinitions.add(new FieldDefinitionImpl(index++, fieldName, FieldType.SHORT, version));\n-        return this;\n+    public ClassDefinitionBuilder addShortField(@Nonnull String fieldName) {\n+        return addField(fieldName, FieldType.SHORT);\n     }\n \n     /**\n+     * Adds a decimal which is arbitrary precision and scale floating-point number to the class definition", "originalCommit": "b2c4239a5040874845fdce9750c8995b1133a600", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTg4MTQ4Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17257#discussion_r565881482", "bodyText": "nit: we should reference j.m.BigDecimal instead of Decimal", "author": "puzpuzpuz", "createdAt": "2021-01-28T07:51:00Z", "path": "hazelcast/src/main/java/com/hazelcast/nio/serialization/ClassDefinitionBuilder.java", "diffHunk": "@@ -318,15 +347,86 @@ public ClassDefinitionBuilder addPortableArrayField(String fieldName, ClassDefin\n         return this;\n     }\n \n+    /**\n+     * Adds an array of Decimal's to the class definition", "originalCommit": "b2c4239a5040874845fdce9750c8995b1133a600", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTg4MjMzMg==", "url": "https://github.com/hazelcast/hazelcast/pull/17257#discussion_r565882332", "bodyText": "nit: does it make sense to use BIG_DECIMAL instead of DECIMAL here and in related public methods? Decimal does not provide a hint that it's an arbitrary precision number. Say, both double and float types stand for decimal numbers.", "author": "puzpuzpuz", "createdAt": "2021-01-28T07:52:46Z", "path": "hazelcast/src/main/java/com/hazelcast/nio/serialization/FieldType.java", "diffHunk": "@@ -50,7 +50,18 @@\n     LONG_ARRAY(16, MAX_VALUE),\n     FLOAT_ARRAY(17, MAX_VALUE),\n     DOUBLE_ARRAY(18, MAX_VALUE),\n-    UTF_ARRAY(19, MAX_VALUE);\n+    UTF_ARRAY(19, MAX_VALUE),\n+\n+    DECIMAL(20, MAX_VALUE),", "originalCommit": "b2c4239a5040874845fdce9750c8995b1133a600", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTk2NTQ4Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17257#discussion_r565965483", "bodyText": "What Decimal is documented on the corresponding methods on ClassDefinitionBuilder/PortableReader/Writer. I think it should be enough.", "author": "sancar", "createdAt": "2021-01-28T10:04:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTg4MjMzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjAzMjUyMQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17257#discussion_r566032521", "bodyText": "Word Decimal is not used consistently in ClassDefinitionBuilder/PortableReader/Writer. So, once again the user might have question which can be avoided by using the prefix.", "author": "puzpuzpuz", "createdAt": "2021-01-28T11:49:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTg4MjMzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTg4MzA3Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17257#discussion_r565883076", "bodyText": "nit: might be a good idea to put a comment on backward compatibility for types with id > 19. Or, at least describe the changed structure as TYPES_COUNT constant being 10 doesn't make sense anymore.", "author": "puzpuzpuz", "createdAt": "2021-01-28T07:54:18Z", "path": "hazelcast/src/main/java/com/hazelcast/nio/serialization/FieldType.java", "diffHunk": "@@ -50,7 +50,18 @@\n     LONG_ARRAY(16, MAX_VALUE),\n     FLOAT_ARRAY(17, MAX_VALUE),\n     DOUBLE_ARRAY(18, MAX_VALUE),\n-    UTF_ARRAY(19, MAX_VALUE);\n+    UTF_ARRAY(19, MAX_VALUE),\n+\n+    DECIMAL(20, MAX_VALUE),", "originalCommit": "b2c4239a5040874845fdce9750c8995b1133a600", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTg5MDEzMQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17257#discussion_r565890131", "bodyText": "nit: trailing dot is missing here and in below.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Reads a decimal which is arbitrary precision and scale floating-point number to BigDecimal\n          \n          \n            \n                 * Reads a decimal which is arbitrary precision and scale floating-point number to BigDecimal.", "author": "puzpuzpuz", "createdAt": "2021-01-28T08:07:52Z", "path": "hazelcast/src/main/java/com/hazelcast/nio/serialization/GenericRecord.java", "diffHunk": "@@ -199,6 +204,64 @@\n     @Nullable\n     String readUTF(@Nonnull String fieldName);\n \n+    /**\n+     * Reads a decimal which is arbitrary precision and scale floating-point number to BigDecimal", "originalCommit": "b2c4239a5040874845fdce9750c8995b1133a600", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTg5MTIwOQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17257#discussion_r565891209", "bodyText": "nit: might be a good idea to mark return type with @Nonnull here and in other builder methods", "author": "puzpuzpuz", "createdAt": "2021-01-28T08:09:54Z", "path": "hazelcast/src/main/java/com/hazelcast/nio/serialization/GenericRecord.java", "diffHunk": "@@ -467,11 +599,89 @@ static Builder portable(@Nonnull ClassDefinition classDefinition) {\n         Builder writeGenericRecord(@Nonnull String fieldName, @Nullable GenericRecord value);\n \n         /**\n+         * Writes a decimal which is arbitrary precision and scale floating-point number\n          * It is illegal to write to the same field twice.\n          *\n          * @param fieldName name of the field as it is defined in its class definition.\n          *                  See {@link ClassDefinition} for {@link Portable}\n-         * @param value\n+         * @param value     to set to GenericRecord\n+         * @return itself for chaining\n+         * @throws HazelcastSerializationException if the field name does not exist in the class definition or\n+         *                                         the type of the field does not match the one in the class definition or\n+         *                                         Same field is trying to be overwritten without using\n+         *                                         {@link GenericRecord#cloneWithBuilder()}.\n+         */\n+        Builder writeDecimal(@Nonnull String fieldName, @Nullable BigDecimal value);", "originalCommit": "b2c4239a5040874845fdce9750c8995b1133a600", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTk2NjI1OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17257#discussion_r565966259", "bodyText": "Somehow I find it awkward to put @Nonnull to builder pattern. Probably because it is obvious but, I will put it for the sake of completeness.", "author": "sancar", "createdAt": "2021-01-28T10:05:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTg5MTIwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjAzMzM4Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17257#discussion_r566033382", "bodyText": "IDE and other tools like Kotlin compiler can't recognize builder pattern while these annotations are valuable for them.", "author": "puzpuzpuz", "createdAt": "2021-01-28T11:51:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTg5MTIwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTg5MjQ5NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17257#discussion_r565892494", "bodyText": "nit: might be a good idea to annotate return type with @Nonnull here", "author": "puzpuzpuz", "createdAt": "2021-01-28T08:12:06Z", "path": "hazelcast/src/main/java/com/hazelcast/nio/serialization/PortableReader.java", "diffHunk": "@@ -36,165 +43,285 @@\n      * @param fieldName name of the field (does not support nested paths)\n      * @return true if field exist in this class.\n      */\n-    boolean hasField(String fieldName);\n+    boolean hasField(@Nonnull String fieldName);\n \n     /**\n      * @return set of field names on this portable class\n      */\n+    @Nonnull\n     Set<String> getFieldNames();\n \n     /**\n      * @param fieldName name of the field\n      * @return field type of given fieldName\n      */\n-    FieldType getFieldType(String fieldName);\n+    FieldType getFieldType(@Nonnull String fieldName);", "originalCommit": "b2c4239a5040874845fdce9750c8995b1133a600", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTg5Mjg3MA==", "url": "https://github.com/hazelcast/hazelcast/pull/17257#discussion_r565892870", "bodyText": "nit: javadoc doesn't mention the fact that this method throws IllegalArgumentException when the field is not present", "author": "puzpuzpuz", "createdAt": "2021-01-28T08:12:44Z", "path": "hazelcast/src/main/java/com/hazelcast/nio/serialization/PortableReader.java", "diffHunk": "@@ -36,165 +43,285 @@\n      * @param fieldName name of the field (does not support nested paths)\n      * @return true if field exist in this class.\n      */\n-    boolean hasField(String fieldName);\n+    boolean hasField(@Nonnull String fieldName);\n \n     /**\n      * @return set of field names on this portable class\n      */\n+    @Nonnull\n     Set<String> getFieldNames();\n \n     /**\n      * @param fieldName name of the field\n      * @return field type of given fieldName", "originalCommit": "b2c4239a5040874845fdce9750c8995b1133a600", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTg5MzI5NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17257#discussion_r565893294", "bodyText": "nit: missing trailing dot here and in below\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Reads a decimal which is arbitrary precision and scale floating-point number to BigDecimal\n          \n          \n            \n                 * Reads a decimal which is arbitrary precision and scale floating-point number to BigDecimal.", "author": "puzpuzpuz", "createdAt": "2021-01-28T08:13:35Z", "path": "hazelcast/src/main/java/com/hazelcast/nio/serialization/PortableReader.java", "diffHunk": "@@ -36,165 +43,285 @@\n      * @param fieldName name of the field (does not support nested paths)\n      * @return true if field exist in this class.\n      */\n-    boolean hasField(String fieldName);\n+    boolean hasField(@Nonnull String fieldName);\n \n     /**\n      * @return set of field names on this portable class\n      */\n+    @Nonnull\n     Set<String> getFieldNames();\n \n     /**\n      * @param fieldName name of the field\n      * @return field type of given fieldName\n      */\n-    FieldType getFieldType(String fieldName);\n+    FieldType getFieldType(@Nonnull String fieldName);\n \n     /**\n      * @param fieldName name of the field\n      * @return classId of given field\n      */\n-    int getFieldClassId(String fieldName);\n+    int getFieldClassId(@Nonnull String fieldName);\n \n     /**\n      * @param fieldName name of the field\n      * @return the int value read\n      * @throws IOException in case of any exceptional case\n      */\n-    int readInt(String fieldName) throws IOException;\n+    int readInt(@Nonnull String fieldName) throws IOException;\n \n     /**\n      * @param fieldName name of the field\n      * @return the long value read\n      * @throws IOException in case of any exceptional case\n      */\n-    long readLong(String fieldName) throws IOException;\n+    long readLong(@Nonnull String fieldName) throws IOException;\n \n     /**\n      * @param fieldName name of the field\n      * @return the utf string value read\n      * @throws IOException in case of any exceptional case\n      */\n-    String readUTF(String fieldName) throws IOException;\n+    @Nullable\n+    String readUTF(@Nonnull String fieldName) throws IOException;\n \n     /**\n      * @param fieldName name of the field\n      * @return the boolean value read\n      * @throws IOException in case of any exceptional case\n      */\n-    boolean readBoolean(String fieldName) throws IOException;\n+    boolean readBoolean(@Nonnull String fieldName) throws IOException;\n \n     /**\n      * @param fieldName name of the field\n      * @return the byte value read\n      * @throws IOException in case of any exceptional case\n      */\n-    byte readByte(String fieldName) throws IOException;\n+    byte readByte(@Nonnull String fieldName) throws IOException;\n \n     /**\n      * @param fieldName name of the field\n      * @return the char value read\n      * @throws IOException in case of any exceptional case\n      */\n-    char readChar(String fieldName) throws IOException;\n+    char readChar(@Nonnull String fieldName) throws IOException;\n \n     /**\n      * @param fieldName name of the field\n      * @return the double value read\n      * @throws IOException in case of any exceptional case\n      */\n-    double readDouble(String fieldName) throws IOException;\n+    double readDouble(@Nonnull String fieldName) throws IOException;\n \n     /**\n      * @param fieldName name of the field\n      * @return the float value read\n      * @throws IOException in case of any exceptional case\n      */\n-    float readFloat(String fieldName) throws IOException;\n+    float readFloat(@Nonnull String fieldName) throws IOException;\n \n     /**\n      * @param fieldName name of the field\n      * @return the short value read\n      * @throws IOException in case of any exceptional case\n      */\n-    short readShort(String fieldName) throws IOException;\n+    short readShort(@Nonnull String fieldName) throws IOException;\n \n     /**\n      * @param fieldName name of the field\n      * @param <P>       the type of the portable read\n      * @return the portable value read\n      * @throws IOException in case of any exceptional case\n      */\n-    <P extends Portable> P readPortable(String fieldName) throws IOException;\n+    @Nullable\n+    <P extends Portable> P readPortable(@Nonnull String fieldName) throws IOException;\n+\n+    /**\n+     * Reads a decimal which is arbitrary precision and scale floating-point number to BigDecimal", "originalCommit": "b2c4239a5040874845fdce9750c8995b1133a600", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTg5NDM3MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17257#discussion_r565894371", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Use {@link #writeNullPortable(String, int, int)} to write a {@code null} Portable\n          \n          \n            \n                 * Use {@link #writeNullPortable(String, int, int)} to write a {@code null} Portable.", "author": "puzpuzpuz", "createdAt": "2021-01-28T08:15:34Z", "path": "hazelcast/src/main/java/com/hazelcast/nio/serialization/PortableWriter.java", "diffHunk": "@@ -105,16 +112,17 @@\n      * @param value     int value to be written\n      * @throws IOException in case of any exceptional case\n      */\n-    void writeShort(String fieldName, short value) throws IOException;\n+    void writeShort(@Nonnull String fieldName, short value) throws IOException;\n \n     /**\n      * Writes a Portable.\n+     * Use {@link #writeNullPortable(String, int, int)} to write a {@code null} Portable", "originalCommit": "b2c4239a5040874845fdce9750c8995b1133a600", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTg5NjQwNw==", "url": "https://github.com/hazelcast/hazelcast/pull/17257#discussion_r565896407", "bodyText": "This method seems to accept nulls (at least in DefaultPortableWriter). Does it make sense to provide more context on why the user should prefer writeNullPortable over this method in the javadoc?", "author": "puzpuzpuz", "createdAt": "2021-01-28T08:19:02Z", "path": "hazelcast/src/main/java/com/hazelcast/nio/serialization/PortableWriter.java", "diffHunk": "@@ -105,16 +112,17 @@\n      * @param value     int value to be written\n      * @throws IOException in case of any exceptional case\n      */\n-    void writeShort(String fieldName, short value) throws IOException;\n+    void writeShort(@Nonnull String fieldName, short value) throws IOException;\n \n     /**\n      * Writes a Portable.\n+     * Use {@link #writeNullPortable(String, int, int)} to write a {@code null} Portable", "originalCommit": "b2c4239a5040874845fdce9750c8995b1133a600", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTg5NjY0NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17257#discussion_r565896645", "bodyText": "nit: trailing dot is missing here and in below\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Writes a decimal which is arbitrary precision and scale floating-point number\n          \n          \n            \n                 * Writes a decimal which is arbitrary precision and scale floating-point number.", "author": "puzpuzpuz", "createdAt": "2021-01-28T08:19:27Z", "path": "hazelcast/src/main/java/com/hazelcast/nio/serialization/PortableWriter.java", "diffHunk": "@@ -124,7 +132,54 @@\n      * @param classId   class ID of related portable class\n      * @throws IOException in case of any exceptional case\n      */\n-    void writeNullPortable(String fieldName, int factoryId, int classId) throws IOException;\n+    void writeNullPortable(@Nonnull String fieldName, int factoryId, int classId) throws IOException;\n+\n+    /**\n+     * Writes a decimal which is arbitrary precision and scale floating-point number", "originalCommit": "b2c4239a5040874845fdce9750c8995b1133a600", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTg5ODMxNQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17257#discussion_r565898315", "bodyText": "nit: ClassDefinitionWriter's implementation of writePortable/writeNullPortable also throws HazelcastSerializationException. Not sure if we want to mention this fact here.", "author": "puzpuzpuz", "createdAt": "2021-01-28T08:22:23Z", "path": "hazelcast/src/main/java/com/hazelcast/nio/serialization/PortableWriter.java", "diffHunk": "@@ -105,16 +112,17 @@\n      * @param value     int value to be written\n      * @throws IOException in case of any exceptional case\n      */\n-    void writeShort(String fieldName, short value) throws IOException;\n+    void writeShort(@Nonnull String fieldName, short value) throws IOException;\n \n     /**\n      * Writes a Portable.\n+     * Use {@link #writeNullPortable(String, int, int)} to write a {@code null} Portable\n      *\n      * @param fieldName name of the field\n      * @param portable  Portable to be written\n      * @throws IOException in case of any exceptional case", "originalCommit": "b2c4239a5040874845fdce9750c8995b1133a600", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTkwMTMyNQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17257#discussion_r565901325", "bodyText": "nit: it might be a good idea to use a BigDecimal with non-zero scale as one of test values.", "author": "puzpuzpuz", "createdAt": "2021-01-28T08:27:36Z", "path": "hazelcast/src/test/java/com/hazelcast/genericrecord/AbstractGenericRecordTest.java", "diffHunk": "@@ -314,4 +268,108 @@ public void testInconsistentClassDefinition() {\n         map.put(2, inConsistentNamedRecord);\n     }\n \n+    @NotNull\n+    private MainPortable createMainPortable() {\n+        NamedPortable[] nn = new NamedPortable[2];\n+        nn[0] = new NamedPortable(\"name\", 123);\n+        nn[1] = new NamedPortable(\"name\", 123);\n+        InnerPortable inner = new InnerPortable(new byte[]{0, 1, 2}, new char[]{'c', 'h', 'a', 'r'},\n+                new short[]{3, 4, 5}, new int[]{9, 8, 7, 6}, new long[]{0, 1, 5, 7, 9, 11},\n+                new float[]{0.6543f, -3.56f, 45.67f}, new double[]{456.456, 789.789, 321.321}, nn,\n+                new BigDecimal[]{new BigDecimal(\"12345\"), new BigDecimal(\"123456\")},", "originalCommit": "b2c4239a5040874845fdce9750c8995b1133a600", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTkwMjExNg==", "url": "https://github.com/hazelcast/hazelcast/pull/17257#discussion_r565902116", "bodyText": "nit: this line is too long after the update. Could be improved by moving .setPortableVersion(1) into a new line", "author": "puzpuzpuz", "createdAt": "2021-01-28T08:28:42Z", "path": "hazelcast/src/test/java/com/hazelcast/internal/serialization/impl/portable/PortableTest.java", "diffHunk": "@@ -728,7 +746,7 @@ public void testWriteObjectWithCustomSerializable() {\n                 .setTypeClass(CustomSerializationTest.Foo.class);\n         config.addSerializerConfig(sc);\n         SerializationService serializationService = new DefaultSerializationServiceBuilder().setPortableVersion(1)\n-                .addPortableFactory(PORTABLE_FACTORY_ID, new TestPortableFactory()).setConfig(config).build();\n+                                                                                            .addPortableFactory(PORTABLE_FACTORY_ID, new TestPortableFactory()).setConfig(config).build();", "originalCommit": "b2c4239a5040874845fdce9750c8995b1133a600", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTkwNDE4MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17257#discussion_r565904181", "bodyText": "nit: might be a good idea to cover newly introduced methods here.", "author": "puzpuzpuz", "createdAt": "2021-01-28T08:32:13Z", "path": "hazelcast/src/test/java/com/hazelcast/nio/IOUtilTest.java", "diffHunk": "@@ -730,100 +729,6 @@ public void testCopyToHeapBuffer_whenSourceIsNull() {\n         assertEquals(0, copyToHeapBuffer(null, dst));\n     }\n \n-    @Test", "originalCommit": "b2c4239a5040874845fdce9750c8995b1133a600", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3d4986ac137cb9e6685acf0bd3235c9329416af7", "url": "https://github.com/hazelcast/hazelcast/commit/3d4986ac137cb9e6685acf0bd3235c9329416af7", "message": "addressing review comments", "committedDate": "2021-01-28T10:21:07Z", "type": "commit"}]}