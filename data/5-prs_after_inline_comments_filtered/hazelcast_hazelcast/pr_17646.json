{"pr_number": 17646, "pr_title": "Refactoring client deregister listener behaviour", "pr_createdAt": "2020-09-30T11:17:59Z", "pr_url": "https://github.com/hazelcast/hazelcast/pull/17646", "timeline": [{"oid": "b7169be8935c023540cdde606524688fa52f2274", "url": "https://github.com/hazelcast/hazelcast/commit/b7169be8935c023540cdde606524688fa52f2274", "message": "Refactoring client deregister listener behaviour\n\nWe were returning `false` as the return value if we were not\nsuccessuflly deregister from any member and events was able to\ncontinue to delivered for non deregistered members.\n\nWe have changed the behaviour so that we return `true` if a\nregistration is found always. And after this point, user will not\nget any event. We will cleanup all the local handlers right away\nto make sure of that.\n\nSecondly we have set invocation timeout as infinite so that the\nderegistartion from a connection is retried as long as the\nconnection is there until it is succesful.\n\nI have left logging the exception when there is an unexpected\nfailure. We do not expect any but this is to be able to diagnose\nif the unexpected happens.", "committedDate": "2020-09-30T13:05:05Z", "type": "commit"}, {"oid": "b7169be8935c023540cdde606524688fa52f2274", "url": "https://github.com/hazelcast/hazelcast/commit/b7169be8935c023540cdde606524688fa52f2274", "message": "Refactoring client deregister listener behaviour\n\nWe were returning `false` as the return value if we were not\nsuccessuflly deregister from any member and events was able to\ncontinue to delivered for non deregistered members.\n\nWe have changed the behaviour so that we return `true` if a\nregistration is found always. And after this point, user will not\nget any event. We will cleanup all the local handlers right away\nto make sure of that.\n\nSecondly we have set invocation timeout as infinite so that the\nderegistartion from a connection is retried as long as the\nconnection is there until it is succesful.\n\nI have left logging the exception when there is an unexpected\nfailure. We do not expect any but this is to be able to diagnose\nif the unexpected happens.", "committedDate": "2020-09-30T13:05:05Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODE2NjkxNg==", "url": "https://github.com/hazelcast/hazelcast/pull/17646#discussion_r498166916", "bodyText": "nit: should be has failed for address instead of has failed to address", "author": "puzpuzpuz", "createdAt": "2020-10-01T11:16:50Z", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/spi/impl/listener/ClientListenerServiceImpl.java", "diffHunk": "@@ -307,39 +306,33 @@ private Boolean deregisterListenerInternal(@Nullable UUID userRegistrationId) {\n         //This method should only be called from registrationExecutor\n         assert (Thread.currentThread().getName().contains(\"eventRegistration\"));\n \n-        ClientListenerRegistration listenerRegistration = registrations.get(userRegistrationId);\n+        ClientListenerRegistration listenerRegistration = registrations.remove(userRegistrationId);\n         if (listenerRegistration == null) {\n             return false;\n         }\n-        boolean successful = true;\n \n         Map<Connection, ClientConnectionRegistration> registrations = listenerRegistration.getConnectionRegistrations();\n-        Iterator<Map.Entry<Connection, ClientConnectionRegistration>> iterator = registrations.entrySet().iterator();\n-        while (iterator.hasNext()) {\n-            Map.Entry<Connection, ClientConnectionRegistration> entry = iterator.next();\n+        for (Map.Entry<Connection, ClientConnectionRegistration> entry : registrations.entrySet()) {\n             ClientConnectionRegistration registration = entry.getValue();\n-            Connection subscriber = entry.getKey();\n-            try {\n-                ListenerMessageCodec listenerMessageCodec = listenerRegistration.getCodec();\n-                UUID serverRegistrationId = registration.getServerRegistrationId();\n-                ClientMessage request = listenerMessageCodec.encodeRemoveRequest(serverRegistrationId);\n-                if (request != null) {\n-                    new ClientInvocation(client, request, null, subscriber).invoke().get();\n-                }\n-                ((ClientConnection) subscriber).removeEventHandler(registration.getCallId());\n-                iterator.remove();\n-            } catch (Exception e) {\n-                if (subscriber.isAlive()) {\n-                    successful = false;\n-                    logger.warning(\"Deregistration of listener with ID \" + userRegistrationId\n-                            + \" has failed to address \" + subscriber.getRemoteAddress(), e);\n-                }\n+            ClientConnection subscriber = (ClientConnection) entry.getKey();\n+            //remove local handler\n+            subscriber.removeEventHandler(registration.getCallId());\n+            //the rest is for deleting remote registration\n+            ListenerMessageCodec listenerMessageCodec = listenerRegistration.getCodec();\n+            UUID serverRegistrationId = registration.getServerRegistrationId();\n+            ClientMessage request = listenerMessageCodec.encodeRemoveRequest(serverRegistrationId);\n+            if (request == null) {\n+                continue;\n             }\n+            ClientInvocation clientInvocation = new ClientInvocation(client, request, null, subscriber);\n+            clientInvocation.setInvocationTimeoutMillis(Long.MAX_VALUE);\n+            clientInvocation.invokeUrgent().exceptionally(throwable -> {\n+                logger.warning(\"Deregistration of listener with ID \" + userRegistrationId\n+                        + \" has failed to address \" + subscriber.getRemoteAddress(), throwable);", "originalCommit": "b7169be8935c023540cdde606524688fa52f2274", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODE2ODU2MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17646#discussion_r498168561", "bodyText": "Question: what if the underlying connections gets closed due to missed heartbeats or the client shuts down? Shouldn't we avoid log messages in this case (i.e. filter out HazelcastClientNotActiveException and TargetDisconnectedException)?", "author": "puzpuzpuz", "createdAt": "2020-10-01T11:19:59Z", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/spi/impl/listener/ClientListenerServiceImpl.java", "diffHunk": "@@ -307,39 +306,33 @@ private Boolean deregisterListenerInternal(@Nullable UUID userRegistrationId) {\n         //This method should only be called from registrationExecutor\n         assert (Thread.currentThread().getName().contains(\"eventRegistration\"));\n \n-        ClientListenerRegistration listenerRegistration = registrations.get(userRegistrationId);\n+        ClientListenerRegistration listenerRegistration = registrations.remove(userRegistrationId);\n         if (listenerRegistration == null) {\n             return false;\n         }\n-        boolean successful = true;\n \n         Map<Connection, ClientConnectionRegistration> registrations = listenerRegistration.getConnectionRegistrations();\n-        Iterator<Map.Entry<Connection, ClientConnectionRegistration>> iterator = registrations.entrySet().iterator();\n-        while (iterator.hasNext()) {\n-            Map.Entry<Connection, ClientConnectionRegistration> entry = iterator.next();\n+        for (Map.Entry<Connection, ClientConnectionRegistration> entry : registrations.entrySet()) {\n             ClientConnectionRegistration registration = entry.getValue();\n-            Connection subscriber = entry.getKey();\n-            try {\n-                ListenerMessageCodec listenerMessageCodec = listenerRegistration.getCodec();\n-                UUID serverRegistrationId = registration.getServerRegistrationId();\n-                ClientMessage request = listenerMessageCodec.encodeRemoveRequest(serverRegistrationId);\n-                if (request != null) {\n-                    new ClientInvocation(client, request, null, subscriber).invoke().get();\n-                }\n-                ((ClientConnection) subscriber).removeEventHandler(registration.getCallId());\n-                iterator.remove();\n-            } catch (Exception e) {\n-                if (subscriber.isAlive()) {\n-                    successful = false;\n-                    logger.warning(\"Deregistration of listener with ID \" + userRegistrationId\n-                            + \" has failed to address \" + subscriber.getRemoteAddress(), e);\n-                }\n+            ClientConnection subscriber = (ClientConnection) entry.getKey();\n+            //remove local handler\n+            subscriber.removeEventHandler(registration.getCallId());\n+            //the rest is for deleting remote registration\n+            ListenerMessageCodec listenerMessageCodec = listenerRegistration.getCodec();\n+            UUID serverRegistrationId = registration.getServerRegistrationId();\n+            ClientMessage request = listenerMessageCodec.encodeRemoveRequest(serverRegistrationId);\n+            if (request == null) {\n+                continue;\n             }\n+            ClientInvocation clientInvocation = new ClientInvocation(client, request, null, subscriber);\n+            clientInvocation.setInvocationTimeoutMillis(Long.MAX_VALUE);\n+            clientInvocation.invokeUrgent().exceptionally(throwable -> {\n+                logger.warning(\"Deregistration of listener with ID \" + userRegistrationId", "originalCommit": "b7169be8935c023540cdde606524688fa52f2274", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODE3NTU1OA==", "url": "https://github.com/hazelcast/hazelcast/pull/17646#discussion_r498175558", "bodyText": "nit: there is one small problem related with this async remote deregistration. Namely, users might see some No eventHandler for callId... warnings in the log for a period of time until remote calls succeeds. Same thing could happen with the old code, but the time frame increases with the async approach. We could reduce log level to fine, but I'm not sure if that's a good idea.", "author": "puzpuzpuz", "createdAt": "2020-10-01T11:34:32Z", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/spi/impl/listener/ClientListenerServiceImpl.java", "diffHunk": "@@ -307,39 +306,33 @@ private Boolean deregisterListenerInternal(@Nullable UUID userRegistrationId) {\n         //This method should only be called from registrationExecutor\n         assert (Thread.currentThread().getName().contains(\"eventRegistration\"));\n \n-        ClientListenerRegistration listenerRegistration = registrations.get(userRegistrationId);\n+        ClientListenerRegistration listenerRegistration = registrations.remove(userRegistrationId);\n         if (listenerRegistration == null) {\n             return false;\n         }\n-        boolean successful = true;\n \n         Map<Connection, ClientConnectionRegistration> registrations = listenerRegistration.getConnectionRegistrations();\n-        Iterator<Map.Entry<Connection, ClientConnectionRegistration>> iterator = registrations.entrySet().iterator();\n-        while (iterator.hasNext()) {\n-            Map.Entry<Connection, ClientConnectionRegistration> entry = iterator.next();\n+        for (Map.Entry<Connection, ClientConnectionRegistration> entry : registrations.entrySet()) {\n             ClientConnectionRegistration registration = entry.getValue();\n-            Connection subscriber = entry.getKey();\n-            try {\n-                ListenerMessageCodec listenerMessageCodec = listenerRegistration.getCodec();\n-                UUID serverRegistrationId = registration.getServerRegistrationId();\n-                ClientMessage request = listenerMessageCodec.encodeRemoveRequest(serverRegistrationId);\n-                if (request != null) {\n-                    new ClientInvocation(client, request, null, subscriber).invoke().get();\n-                }\n-                ((ClientConnection) subscriber).removeEventHandler(registration.getCallId());\n-                iterator.remove();\n-            } catch (Exception e) {\n-                if (subscriber.isAlive()) {\n-                    successful = false;\n-                    logger.warning(\"Deregistration of listener with ID \" + userRegistrationId\n-                            + \" has failed to address \" + subscriber.getRemoteAddress(), e);\n-                }\n+            ClientConnection subscriber = (ClientConnection) entry.getKey();\n+            //remove local handler\n+            subscriber.removeEventHandler(registration.getCallId());\n+            //the rest is for deleting remote registration\n+            ListenerMessageCodec listenerMessageCodec = listenerRegistration.getCodec();\n+            UUID serverRegistrationId = registration.getServerRegistrationId();\n+            ClientMessage request = listenerMessageCodec.encodeRemoveRequest(serverRegistrationId);\n+            if (request == null) {\n+                continue;\n             }\n+            ClientInvocation clientInvocation = new ClientInvocation(client, request, null, subscriber);\n+            clientInvocation.setInvocationTimeoutMillis(Long.MAX_VALUE);\n+            clientInvocation.invokeUrgent().exceptionally(throwable -> {", "originalCommit": "b7169be8935c023540cdde606524688fa52f2274", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODIzNzYyMQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17646#discussion_r498237621", "bodyText": "I think log level fine is fine. I will change that.", "author": "sancar", "createdAt": "2020-10-01T13:19:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODE3NTU1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODE3ODk5Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17646#discussion_r498178996", "bodyText": "nit: in the old code subscriber.removeEventHandler call made only if listenerMessageCodec.encodeRemoveRequest returns a non-null. Do we need to keep this logic?", "author": "puzpuzpuz", "createdAt": "2020-10-01T11:41:08Z", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/spi/impl/listener/ClientListenerServiceImpl.java", "diffHunk": "@@ -307,39 +306,33 @@ private Boolean deregisterListenerInternal(@Nullable UUID userRegistrationId) {\n         //This method should only be called from registrationExecutor\n         assert (Thread.currentThread().getName().contains(\"eventRegistration\"));\n \n-        ClientListenerRegistration listenerRegistration = registrations.get(userRegistrationId);\n+        ClientListenerRegistration listenerRegistration = registrations.remove(userRegistrationId);\n         if (listenerRegistration == null) {\n             return false;\n         }\n-        boolean successful = true;\n \n         Map<Connection, ClientConnectionRegistration> registrations = listenerRegistration.getConnectionRegistrations();\n-        Iterator<Map.Entry<Connection, ClientConnectionRegistration>> iterator = registrations.entrySet().iterator();\n-        while (iterator.hasNext()) {\n-            Map.Entry<Connection, ClientConnectionRegistration> entry = iterator.next();\n+        for (Map.Entry<Connection, ClientConnectionRegistration> entry : registrations.entrySet()) {\n             ClientConnectionRegistration registration = entry.getValue();\n-            Connection subscriber = entry.getKey();\n-            try {\n-                ListenerMessageCodec listenerMessageCodec = listenerRegistration.getCodec();\n-                UUID serverRegistrationId = registration.getServerRegistrationId();\n-                ClientMessage request = listenerMessageCodec.encodeRemoveRequest(serverRegistrationId);\n-                if (request != null) {\n-                    new ClientInvocation(client, request, null, subscriber).invoke().get();\n-                }\n-                ((ClientConnection) subscriber).removeEventHandler(registration.getCallId());\n-                iterator.remove();\n-            } catch (Exception e) {\n-                if (subscriber.isAlive()) {\n-                    successful = false;\n-                    logger.warning(\"Deregistration of listener with ID \" + userRegistrationId\n-                            + \" has failed to address \" + subscriber.getRemoteAddress(), e);\n-                }\n+            ClientConnection subscriber = (ClientConnection) entry.getKey();\n+            //remove local handler\n+            subscriber.removeEventHandler(registration.getCallId());", "originalCommit": "b7169be8935c023540cdde606524688fa52f2274", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODIzOTQzNw==", "url": "https://github.com/hazelcast/hazelcast/pull/17646#discussion_r498239437", "bodyText": "if (request != null)  this check for only remote request in the old code as well.", "author": "sancar", "createdAt": "2020-10-01T13:22:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODE3ODk5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODMwMTkzNQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17646#discussion_r498301935", "bodyText": "Yes, you're right.", "author": "puzpuzpuz", "createdAt": "2020-10-01T14:46:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODE3ODk5Ng=="}], "type": "inlineReview"}, {"oid": "315e001a58a22b2387a7e0185d36adad0a8130bf", "url": "https://github.com/hazelcast/hazelcast/commit/315e001a58a22b2387a7e0185d36adad0a8130bf", "message": "addressing review comments", "committedDate": "2020-10-01T13:38:45Z", "type": "commit"}]}