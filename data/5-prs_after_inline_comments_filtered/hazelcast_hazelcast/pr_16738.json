{"pr_number": 16738, "pr_title": "SQL: Type system (#15241)", "pr_createdAt": "2020-03-11T09:18:08Z", "pr_url": "https://github.com/hazelcast/hazelcast/pull/16738", "timeline": [{"oid": "24ad7231c6a7174e2e566475bcc59120e45a51e6", "url": "https://github.com/hazelcast/hazelcast/commit/24ad7231c6a7174e2e566475bcc59120e45a51e6", "message": "SQL type system.", "committedDate": "2020-03-11T09:15:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTU0ODIwOA==", "url": "https://github.com/hazelcast/hazelcast/pull/16738#discussion_r391548208", "bodyText": "Minor: the usual naming pattern is <Module>DataSerializerHook, SqlDataSerializerHook?", "author": "taburet", "createdAt": "2020-03-12T11:07:20Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/QuerySerializationHook.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl;\n+\n+import com.hazelcast.internal.serialization.DataSerializerHook;\n+import com.hazelcast.internal.serialization.impl.ArrayDataSerializableFactory;\n+import com.hazelcast.internal.serialization.impl.FactoryIdHelper;\n+import com.hazelcast.internal.util.ConstructorFunction;\n+import com.hazelcast.nio.serialization.DataSerializableFactory;\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+\n+import static com.hazelcast.internal.serialization.impl.FactoryIdHelper.SQL_DS_FACTORY;\n+import static com.hazelcast.internal.serialization.impl.FactoryIdHelper.SQL_DS_FACTORY_ID;\n+\n+/**\n+ * Serialization hook for SQL classes.\n+ */\n+public class QuerySerializationHook implements DataSerializerHook {", "originalCommit": "24ad7231c6a7174e2e566475bcc59120e45a51e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTU2MTM3MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16738#discussion_r391561371", "bodyText": "Renamed to SqlDataSerializerHook", "author": "devozerov", "createdAt": "2020-03-12T11:35:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTU0ODIwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTU1MDYxNQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16738#discussion_r391550615", "bodyText": "(De)serialization is not covered in tests.", "author": "taburet", "createdAt": "2020-03-12T11:12:11Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/type/QueryDataType.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.type;\n+\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.impl.QuerySerializationHook;\n+import com.hazelcast.sql.impl.type.converter.BigDecimalConverter;\n+import com.hazelcast.sql.impl.type.converter.BigIntegerConverter;\n+import com.hazelcast.sql.impl.type.converter.BooleanConverter;\n+import com.hazelcast.sql.impl.type.converter.ByteConverter;\n+import com.hazelcast.sql.impl.type.converter.CalendarConverter;\n+import com.hazelcast.sql.impl.type.converter.CharacterConverter;\n+import com.hazelcast.sql.impl.type.converter.Converter;\n+import com.hazelcast.sql.impl.type.converter.Converters;\n+import com.hazelcast.sql.impl.type.converter.DateConverter;\n+import com.hazelcast.sql.impl.type.converter.DoubleConverter;\n+import com.hazelcast.sql.impl.type.converter.FloatConverter;\n+import com.hazelcast.sql.impl.type.converter.InstantConverter;\n+import com.hazelcast.sql.impl.type.converter.IntegerConverter;\n+import com.hazelcast.sql.impl.type.converter.LateConverter;\n+import com.hazelcast.sql.impl.type.converter.LocalDateConverter;\n+import com.hazelcast.sql.impl.type.converter.LocalDateTimeConverter;\n+import com.hazelcast.sql.impl.type.converter.LocalTimeConverter;\n+import com.hazelcast.sql.impl.type.converter.LongConverter;\n+import com.hazelcast.sql.impl.type.converter.ObjectConverter;\n+import com.hazelcast.sql.impl.type.converter.OffsetDateTimeConverter;\n+import com.hazelcast.sql.impl.type.converter.ShortConverter;\n+import com.hazelcast.sql.impl.type.converter.StringConverter;\n+import com.hazelcast.sql.impl.type.converter.ZonedDateTimeConverter;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Data type represents a type of concrete expression which is based on some basic data type.\n+ */\n+public class QueryDataType implements IdentifiedDataSerializable {\n+    public static final int PRECISION_BIT = 1;\n+    public static final int PRECISION_TINYINT = 4;\n+    public static final int PRECISION_SMALLINT = 7;\n+    public static final int PRECISION_INT = 11;\n+    public static final int PRECISION_BIGINT = 20;\n+    public static final int PRECISION_UNLIMITED = -1;\n+\n+    public static final QueryDataType LATE = new QueryDataType(LateConverter.INSTANCE);\n+\n+    public static final QueryDataType VARCHAR = new QueryDataType(StringConverter.INSTANCE);\n+    public static final QueryDataType VARCHAR_CHARACTER = new QueryDataType(CharacterConverter.INSTANCE);\n+\n+    public static final QueryDataType BIT = new QueryDataType(BooleanConverter.INSTANCE, PRECISION_BIT);\n+    public static final QueryDataType TINYINT = new QueryDataType(ByteConverter.INSTANCE, PRECISION_TINYINT);\n+    public static final QueryDataType SMALLINT = new QueryDataType(ShortConverter.INSTANCE, PRECISION_SMALLINT);\n+    public static final QueryDataType INT = new QueryDataType(IntegerConverter.INSTANCE, PRECISION_INT);\n+    public static final QueryDataType BIGINT = new QueryDataType(LongConverter.INSTANCE, PRECISION_BIGINT);\n+    public static final QueryDataType DECIMAL = new QueryDataType(BigDecimalConverter.INSTANCE);\n+    public static final QueryDataType DECIMAL_BIG_INTEGER = new QueryDataType(BigIntegerConverter.INSTANCE);\n+    public static final QueryDataType REAL = new QueryDataType(FloatConverter.INSTANCE);\n+    public static final QueryDataType DOUBLE = new QueryDataType(DoubleConverter.INSTANCE);\n+\n+    public static final QueryDataType TIME = new QueryDataType(LocalTimeConverter.INSTANCE);\n+    public static final QueryDataType DATE = new QueryDataType(LocalDateConverter.INSTANCE);\n+    public static final QueryDataType TIMESTAMP = new QueryDataType(LocalDateTimeConverter.INSTANCE);\n+    public static final QueryDataType TIMESTAMP_WITH_TZ_DATE = new QueryDataType(DateConverter.INSTANCE);\n+    public static final QueryDataType TIMESTAMP_WITH_TZ_CALENDAR = new QueryDataType(CalendarConverter.INSTANCE);\n+    public static final QueryDataType TIMESTAMP_WITH_TZ_INSTANT = new QueryDataType(InstantConverter.INSTANCE);\n+    public static final QueryDataType TIMESTAMP_WITH_TZ_OFFSET_DATE_TIME = new QueryDataType(OffsetDateTimeConverter.INSTANCE);\n+    public static final QueryDataType TIMESTAMP_WITH_TZ_ZONED_DATE_TIME = new QueryDataType(ZonedDateTimeConverter.INSTANCE);\n+\n+    public static final QueryDataType OBJECT = new QueryDataType(ObjectConverter.INSTANCE);\n+\n+    /** Converter. */\n+    private Converter converter;\n+\n+    /** Precision. */\n+    private int precision;\n+\n+    public QueryDataType() {\n+        // No-op.\n+    }\n+\n+    QueryDataType(Converter converter) {\n+        this(converter, PRECISION_UNLIMITED);\n+    }\n+\n+    QueryDataType(Converter converter, int precision) {\n+        this.converter = converter;\n+        this.precision = precision;\n+    }\n+\n+    public QueryDataTypeFamily getTypeFamily() {\n+        return converter.getTypeFamily();\n+    }\n+\n+    public Converter getConverter() {\n+        return converter;\n+    }\n+\n+    public int getPrecision() {\n+        return precision;\n+    }\n+\n+    @Override\n+    public int getFactoryId() {\n+        return QuerySerializationHook.F_ID;\n+    }\n+\n+    @Override\n+    public int getClassId() {\n+        return QuerySerializationHook.QUERY_DATA_TYPE;\n+    }\n+\n+    @Override\n+    public void writeData(ObjectDataOutput out) throws IOException {\n+        out.writeInt(converter.getId());\n+        out.writeInt(precision);\n+    }\n+\n+    @Override\n+    public void readData(ObjectDataInput in) throws IOException {\n+        converter = Converters.getConverter(in.readInt());\n+        precision = in.readInt();\n+    }", "originalCommit": "24ad7231c6a7174e2e566475bcc59120e45a51e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTU1MzgzNw==", "url": "https://github.com/hazelcast/hazelcast/pull/16738#discussion_r391553837", "bodyText": "I forgot to add it here but then added these tests in the subsequent PR, which will introduce a number of other serializable classes. Let's look at it in the next PR to save on re-review time? Alternatively, I can backport it.", "author": "devozerov", "createdAt": "2020-03-12T11:18:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTU1MDYxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE0OTg0NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16738#discussion_r392149845", "bodyText": "Just don't forget about it ;)", "author": "taburet", "createdAt": "2020-03-13T10:37:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTU1MDYxNQ=="}], "type": "inlineReview"}, {"oid": "6a96bbf03ef9119da2c28de1a62be71596b9c501", "url": "https://github.com/hazelcast/hazelcast/commit/6a96bbf03ef9119da2c28de1a62be71596b9c501", "message": "Fixed review comments.", "committedDate": "2020-03-12T11:34:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTU2MzMyMw==", "url": "https://github.com/hazelcast/hazelcast/pull/16738#discussion_r391563323", "bodyText": "If the javadoc is merely duplicating the field name, what is the purpose in having it?", "author": "taburet", "createdAt": "2020-03-12T11:39:44Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/type/QueryDataType.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.type;\n+\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.impl.QuerySerializationHook;\n+import com.hazelcast.sql.impl.type.converter.BigDecimalConverter;\n+import com.hazelcast.sql.impl.type.converter.BigIntegerConverter;\n+import com.hazelcast.sql.impl.type.converter.BooleanConverter;\n+import com.hazelcast.sql.impl.type.converter.ByteConverter;\n+import com.hazelcast.sql.impl.type.converter.CalendarConverter;\n+import com.hazelcast.sql.impl.type.converter.CharacterConverter;\n+import com.hazelcast.sql.impl.type.converter.Converter;\n+import com.hazelcast.sql.impl.type.converter.Converters;\n+import com.hazelcast.sql.impl.type.converter.DateConverter;\n+import com.hazelcast.sql.impl.type.converter.DoubleConverter;\n+import com.hazelcast.sql.impl.type.converter.FloatConverter;\n+import com.hazelcast.sql.impl.type.converter.InstantConverter;\n+import com.hazelcast.sql.impl.type.converter.IntegerConverter;\n+import com.hazelcast.sql.impl.type.converter.LateConverter;\n+import com.hazelcast.sql.impl.type.converter.LocalDateConverter;\n+import com.hazelcast.sql.impl.type.converter.LocalDateTimeConverter;\n+import com.hazelcast.sql.impl.type.converter.LocalTimeConverter;\n+import com.hazelcast.sql.impl.type.converter.LongConverter;\n+import com.hazelcast.sql.impl.type.converter.ObjectConverter;\n+import com.hazelcast.sql.impl.type.converter.OffsetDateTimeConverter;\n+import com.hazelcast.sql.impl.type.converter.ShortConverter;\n+import com.hazelcast.sql.impl.type.converter.StringConverter;\n+import com.hazelcast.sql.impl.type.converter.ZonedDateTimeConverter;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Data type represents a type of concrete expression which is based on some basic data type.\n+ */\n+public class QueryDataType implements IdentifiedDataSerializable {\n+    public static final int PRECISION_BIT = 1;\n+    public static final int PRECISION_TINYINT = 4;\n+    public static final int PRECISION_SMALLINT = 7;\n+    public static final int PRECISION_INT = 11;\n+    public static final int PRECISION_BIGINT = 20;\n+    public static final int PRECISION_UNLIMITED = -1;\n+\n+    public static final QueryDataType LATE = new QueryDataType(LateConverter.INSTANCE);\n+\n+    public static final QueryDataType VARCHAR = new QueryDataType(StringConverter.INSTANCE);\n+    public static final QueryDataType VARCHAR_CHARACTER = new QueryDataType(CharacterConverter.INSTANCE);\n+\n+    public static final QueryDataType BIT = new QueryDataType(BooleanConverter.INSTANCE, PRECISION_BIT);\n+    public static final QueryDataType TINYINT = new QueryDataType(ByteConverter.INSTANCE, PRECISION_TINYINT);\n+    public static final QueryDataType SMALLINT = new QueryDataType(ShortConverter.INSTANCE, PRECISION_SMALLINT);\n+    public static final QueryDataType INT = new QueryDataType(IntegerConverter.INSTANCE, PRECISION_INT);\n+    public static final QueryDataType BIGINT = new QueryDataType(LongConverter.INSTANCE, PRECISION_BIGINT);\n+    public static final QueryDataType DECIMAL = new QueryDataType(BigDecimalConverter.INSTANCE);\n+    public static final QueryDataType DECIMAL_BIG_INTEGER = new QueryDataType(BigIntegerConverter.INSTANCE);\n+    public static final QueryDataType REAL = new QueryDataType(FloatConverter.INSTANCE);\n+    public static final QueryDataType DOUBLE = new QueryDataType(DoubleConverter.INSTANCE);\n+\n+    public static final QueryDataType TIME = new QueryDataType(LocalTimeConverter.INSTANCE);\n+    public static final QueryDataType DATE = new QueryDataType(LocalDateConverter.INSTANCE);\n+    public static final QueryDataType TIMESTAMP = new QueryDataType(LocalDateTimeConverter.INSTANCE);\n+    public static final QueryDataType TIMESTAMP_WITH_TZ_DATE = new QueryDataType(DateConverter.INSTANCE);\n+    public static final QueryDataType TIMESTAMP_WITH_TZ_CALENDAR = new QueryDataType(CalendarConverter.INSTANCE);\n+    public static final QueryDataType TIMESTAMP_WITH_TZ_INSTANT = new QueryDataType(InstantConverter.INSTANCE);\n+    public static final QueryDataType TIMESTAMP_WITH_TZ_OFFSET_DATE_TIME = new QueryDataType(OffsetDateTimeConverter.INSTANCE);\n+    public static final QueryDataType TIMESTAMP_WITH_TZ_ZONED_DATE_TIME = new QueryDataType(ZonedDateTimeConverter.INSTANCE);\n+\n+    public static final QueryDataType OBJECT = new QueryDataType(ObjectConverter.INSTANCE);\n+\n+    /** Converter. */\n+    private Converter converter;\n+\n+    /** Precision. */\n+    private int precision;", "originalCommit": "24ad7231c6a7174e2e566475bcc59120e45a51e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTU2NTcxNA==", "url": "https://github.com/hazelcast/hazelcast/pull/16738#discussion_r391565714", "bodyText": "Some artifacts from the early prototype. Remove useless JavaDocs here and in other classes.", "author": "devozerov", "createdAt": "2020-03-12T11:44:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTU2MzMyMw=="}], "type": "inlineReview"}, {"oid": "b75fcfe8ad980a9426c96a5f2a5d2499e9e5f5ce", "url": "https://github.com/hazelcast/hazelcast/commit/b75fcfe8ad980a9426c96a5f2a5d2499e9e5f5ce", "message": "Removed useless JavaDocs.", "committedDate": "2020-03-12T11:44:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTYyMTE0OA==", "url": "https://github.com/hazelcast/hazelcast/pull/16738#discussion_r391621148", "bodyText": "Looks like we need some documentation here or/and in the design document: \"bigger\" and \"precedence is an integer number which defines context-dependent type resolution rules\" don't sound that self-explanatory.\nIsn't the meaning of \"precedence\"/\"bigger\" kind of inverted/confusing here? The type with the higher precedence value and higher precision is considered \"bigger\". Usually the lower precedence value means higher priority and when comparing things higher priority means bigger. Probably \"widest\" is a better name for this method. It's especially confusing seeing LATE (which is a special name for unknown/object, AFAIU) having the lowest precedence value among all types which implies it's the most specific/restrictive type, so every other type is bigger/wider than the unknown type.\nAnd also types having PRECISION_UNLIMITED are really confusing, PRECISION_UNLIMITED is actually the lowest precision possible according to bigger, probably a better name is something like PRECISION_NONE/UNSPECIFIED/UNAPPLICABLE.", "author": "taburet", "createdAt": "2020-03-12T13:30:55Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/type/QueryDataTypeUtils.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.type;\n+\n+import com.hazelcast.sql.impl.type.converter.BigDecimalConverter;\n+import com.hazelcast.sql.impl.type.converter.BigIntegerConverter;\n+import com.hazelcast.sql.impl.type.converter.CalendarConverter;\n+import com.hazelcast.sql.impl.type.converter.CharacterConverter;\n+import com.hazelcast.sql.impl.type.converter.Converter;\n+import com.hazelcast.sql.impl.type.converter.Converters;\n+import com.hazelcast.sql.impl.type.converter.DateConverter;\n+import com.hazelcast.sql.impl.type.converter.InstantConverter;\n+import com.hazelcast.sql.impl.type.converter.OffsetDateTimeConverter;\n+import com.hazelcast.sql.impl.type.converter.StringConverter;\n+import com.hazelcast.sql.impl.type.converter.ZonedDateTimeConverter;\n+\n+/**\n+ * Utility methods for SQL data types.\n+ */\n+public final class QueryDataTypeUtils {\n+    /** 12 (hdr) + 12 (fields) + 12 (arr) + 4 (arr len) + 16 (eight chars) */\n+    public static final int TYPE_LEN_VARCHAR = 12 + 4 + 8 + 12 + 4 + 16;\n+\n+    /** 12 (hdr) + 28 (fields + padding) + 12 (int hdr) + 28 (int fields) + (12 arr hdr) + 4 (arr len) + 8 (eight digits). */\n+    public static final int TYPE_LEN_DECIMAL = 12 + 28 + 12 + 28 + 12 + 4 + 8;\n+\n+    /** 12 (hdr) + 12 (fields + padding). */\n+    public static final int TYPE_LEN_TIME = 12 + 12;\n+\n+    /** 12 (hdr) + 12 (fields + padding). */\n+    public static final int TYPE_LEN_DATE = 12 + 12;\n+\n+    /** 12 (hdr) + 20 (fields + padding) + date + time. */\n+    public static final int TYPE_LEN_TIMESTAMP = 12 + 20 + TYPE_LEN_TIME + TYPE_LEN_DATE;\n+\n+    /** 12 (hdr) + 20 (fields + padding) + timestamp + 12 (offset hdr) + 12 (offset fields). */\n+    public static final int TYPE_LEN_TIMESTAMP_WITH_OFFSET = 12 + 20 + TYPE_LEN_TIMESTAMP + 12 + 12;\n+\n+    /** 12 (hdr) + 36 (arbitrary content). */\n+    public static final int TYPE_LEN_OBJECT = 12 + 36;\n+\n+    private static final QueryDataType[] INTEGER_TYPES = new QueryDataType[QueryDataType.PRECISION_BIGINT + 1];\n+\n+    static {\n+        for (int i = 1; i <= QueryDataType.PRECISION_BIGINT; i++) {\n+            QueryDataType type;\n+\n+            if (i == QueryDataType.PRECISION_BIT) {\n+                type = QueryDataType.BIT;\n+            } else if (i < QueryDataType.PRECISION_TINYINT) {\n+                type = new QueryDataType(QueryDataType.TINYINT.getConverter(), i);\n+            } else if (i == QueryDataType.PRECISION_TINYINT) {\n+                type = QueryDataType.TINYINT;\n+            } else if (i < QueryDataType.PRECISION_SMALLINT) {\n+                type = new QueryDataType(QueryDataType.SMALLINT.getConverter(), i);\n+            } else if (i == QueryDataType.PRECISION_SMALLINT) {\n+                type = QueryDataType.SMALLINT;\n+            } else if (i < QueryDataType.PRECISION_INT) {\n+                type = new QueryDataType(QueryDataType.INT.getConverter(), i);\n+            } else if (i == QueryDataType.PRECISION_INT) {\n+                type = QueryDataType.INT;\n+            } else if (i < QueryDataType.PRECISION_BIGINT) {\n+                type = new QueryDataType(QueryDataType.BIGINT.getConverter(), i);\n+            } else {\n+                type = QueryDataType.BIGINT;\n+            }\n+\n+            INTEGER_TYPES[i] = type;\n+        }\n+    }\n+\n+    private QueryDataTypeUtils() {\n+        // No-op.\n+    }\n+\n+    public static QueryDataType resolveType(Object obj) {\n+        if (obj == null) {\n+            return QueryDataType.LATE;\n+        }\n+\n+        Class<?> clazz = obj.getClass();\n+\n+        return resolveTypeForClass(clazz);\n+    }\n+\n+    @SuppressWarnings({\"checkstyle:CyclomaticComplexity\", \"checkstyle:ReturnCount\", \"checkstyle:MethodLength\"})\n+    public static QueryDataType resolveTypeForClass(Class<?> clazz) {\n+        Converter converter = Converters.getConverter(clazz);\n+\n+        QueryDataTypeFamily typeFamily = converter.getTypeFamily();\n+\n+        switch (typeFamily) {\n+            case VARCHAR:\n+                if (converter == StringConverter.INSTANCE) {\n+                    return QueryDataType.VARCHAR;\n+                } else {\n+                    assert converter == CharacterConverter.INSTANCE;\n+\n+                    return QueryDataType.VARCHAR_CHARACTER;\n+                }\n+\n+            case BIT:\n+                return QueryDataType.BIT;\n+\n+            case TINYINT:\n+                return QueryDataType.TINYINT;\n+\n+            case SMALLINT:\n+                return QueryDataType.SMALLINT;\n+\n+            case INT:\n+                return QueryDataType.INT;\n+\n+            case BIGINT:\n+                return QueryDataType.BIGINT;\n+\n+            case DECIMAL:\n+                if (converter == BigDecimalConverter.INSTANCE) {\n+                    return QueryDataType.DECIMAL;\n+                } else {\n+                    assert converter == BigIntegerConverter.INSTANCE;\n+\n+                    return QueryDataType.DECIMAL_BIG_INTEGER;\n+                }\n+\n+            case REAL:\n+                return QueryDataType.REAL;\n+\n+            case DOUBLE:\n+                return QueryDataType.DOUBLE;\n+\n+            case DATE:\n+                return QueryDataType.DATE;\n+\n+            case TIME:\n+                return QueryDataType.TIME;\n+\n+            case TIMESTAMP:\n+                return QueryDataType.TIMESTAMP;\n+\n+            case TIMESTAMP_WITH_TIMEZONE:\n+                if (converter == DateConverter.INSTANCE) {\n+                    return QueryDataType.TIMESTAMP_WITH_TZ_DATE;\n+                } else if (converter == CalendarConverter.INSTANCE) {\n+                    return QueryDataType.TIMESTAMP_WITH_TZ_CALENDAR;\n+                } else if (converter == InstantConverter.INSTANCE) {\n+                    return QueryDataType.TIMESTAMP_WITH_TZ_INSTANT;\n+                } else if (converter == OffsetDateTimeConverter.INSTANCE) {\n+                    return QueryDataType.TIMESTAMP_WITH_TZ_OFFSET_DATE_TIME;\n+                } else {\n+                    assert converter == ZonedDateTimeConverter.INSTANCE;\n+\n+                    return QueryDataType.TIMESTAMP_WITH_TZ_ZONED_DATE_TIME;\n+                }\n+\n+            case OBJECT:\n+                return QueryDataType.OBJECT;\n+\n+            default:\n+                assert typeFamily == QueryDataTypeFamily.LATE;\n+\n+                throw new IllegalArgumentException(\"Unexpected class: \" + clazz);\n+        }\n+    }\n+\n+    @SuppressWarnings({\"checkstyle:CyclomaticComplexity\", \"checkstyle:ReturnCount\", \"checkstyle:MethodLength\"})\n+    public static QueryDataType resolveTypeForTypeFamily(QueryDataTypeFamily typeFamily) {\n+        switch (typeFamily) {\n+            case VARCHAR:\n+                return QueryDataType.VARCHAR;\n+\n+            case BIT:\n+                return QueryDataType.BIT;\n+\n+            case TINYINT:\n+                return QueryDataType.TINYINT;\n+\n+            case SMALLINT:\n+                return QueryDataType.SMALLINT;\n+\n+            case INT:\n+                return QueryDataType.INT;\n+\n+            case BIGINT:\n+                return QueryDataType.BIGINT;\n+\n+            case DECIMAL:\n+                return QueryDataType.DECIMAL;\n+\n+            case REAL:\n+                return QueryDataType.REAL;\n+\n+            case DOUBLE:\n+                return QueryDataType.DOUBLE;\n+\n+            case DATE:\n+                return QueryDataType.DATE;\n+\n+            case TIME:\n+                return QueryDataType.TIME;\n+\n+            case TIMESTAMP:\n+                return QueryDataType.TIMESTAMP;\n+\n+            case TIMESTAMP_WITH_TIMEZONE:\n+                return QueryDataType.TIMESTAMP_WITH_TZ_OFFSET_DATE_TIME;\n+\n+            case OBJECT:\n+                return QueryDataType.OBJECT;\n+\n+            default:\n+                assert typeFamily == QueryDataTypeFamily.LATE;\n+\n+                throw new IllegalArgumentException(\"Unexpected type family: \" + typeFamily);\n+        }\n+    }\n+\n+    /**\n+     * Get integer type for the given precision.\n+     *\n+     * @param precision Precision.\n+     * @return Type.\n+     */\n+    public static QueryDataType integerType(int precision) {\n+        if (precision == 0) {\n+            throw new IllegalArgumentException(\"Precision cannot be zero.\");\n+        }\n+\n+        if (precision == QueryDataType.PRECISION_UNLIMITED) {\n+            return QueryDataType.DECIMAL;\n+        } else if (precision <= QueryDataType.PRECISION_BIGINT) {\n+            return INTEGER_TYPES[precision];\n+        } else {\n+            return QueryDataType.DECIMAL;\n+        }\n+    }\n+\n+    public static QueryDataType bigger(QueryDataType first, QueryDataType second) {", "originalCommit": "b75fcfe8ad980a9426c96a5f2a5d2499e9e5f5ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTY2MTk2Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/16738#discussion_r391661966", "bodyText": "The only thing is needed is an ability to establish a total order between types. bigger function picks the type with higher priority. How the comparison is implemented internally, and whether we use \">\" or \"<\" for that is implementation-defined. Most vendors don't provide any specific information on these implementation details. I used the same approach as in MS SQL, where a type with higher precedence is a type with higher priority [1]. I do not see the value of inverting it, as this is merely a question of taste:\n\nthe data type with the lower precedence is first converted to the data type with the higher precedence\n\nSince LATE has the lowest value of the precedence, it is always the type with the lowest priority.\nwidest doesn't work, because, e.g. DATE is not wider than TIME, it just has higher precedence. bigger has the same issue. I renamed it to withHigherPrecedence, it should add clarity.\nPRECISION_UNLIMITED is applied to several types, such as REAL/DOUBLE/DECIMAL, where we have a virtually unlimited number of significant digits. A type with a higher number of significant digits wins, e.g. INT(12) has precedence over INT(11). Does it address your comment?\nRegarding the documentation, I tried to rephrase it a bit, but it is vague still:\n\nPrecedence is a comparable value which is used for type inference in expressions\n\nI couldn't come with a better explanation in the context of this document because precedence is used differently in expressions. E.g. INT(11) + SMALLINT(7) -> BIGINT(12), but INT(11) + VARCHAR -> DECIMAL(UNLIMITED). So exact usage of precedence should be documented in expressions design, not here.\n[1] https://docs.microsoft.com/en-us/sql/t-sql/data-types/data-type-precedence-transact-sql?view=sql-server-ver15", "author": "devozerov", "createdAt": "2020-03-12T14:32:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTYyMTE0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE0NDk0Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/16738#discussion_r392144943", "bodyText": "PRECISION_UNLIMITED is applied to several types, such as REAL/DOUBLE/DECIMAL, where we have a virtually unlimited number of significant digits. A type with a higher number of significant digits wins, e.g. INT(12) has precedence over INT(11).\n\nAt the same time PRECISION_UNLIMITED is defined as -1. If we have two types belonging to the same family (having the same precedence), the one having PRECISION_UNLIMITED would be considered having less precedence comparing to the other one having precision of say 10, while it should be the opposite (AFAIU). At least some kind of assertion should be introduced to avoid such erroneous ordering of types. Another option, is to define PRECISION_UNLIMITED as Integer.MAX_VALUE, so we can avoid the erroneous ordering described above. And even better is to introduce something like PRECISION_NONE for types like VARCHAR or OBJECT for which the concept of precision doesn't apply at all (-1 with assertion it never participates in precision comparison?).\nI understand that with the current family/precedence/type table it's impossible to order the types incorrectly, but to understand that one needs to scan and match all the definitions from QueryDataTypeFamily and QueryDataType. Moreover, if one recklessly edits the family/precedence/type table, there is no protection from the incorrect ordering.", "author": "taburet", "createdAt": "2020-03-13T10:27:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTYyMTE0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE3OTg0MA==", "url": "https://github.com/hazelcast/hazelcast/pull/16738#discussion_r392179840", "bodyText": "Added explicit assertions on the current behavior. Let's keep it simple for now. I think that we will have to rethink the approach in the future when JDBC is ready. In this case every type will have to report some precision, and both -1 or Integer.MAX_VALUE will be inapplicable, say, for DECIMAL. But at the same time, if we report a precision, we will have to ensure that follow it, i.e. trim values. Since we do not need that at the moment, let's keep the implementation as simple as possible.", "author": "devozerov", "createdAt": "2020-03-13T11:45:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTYyMTE0OA=="}], "type": "inlineReview"}, {"oid": "af90816527413e2d6663ceba6b5687708459c7cf", "url": "https://github.com/hazelcast/hazelcast/commit/af90816527413e2d6663ceba6b5687708459c7cf", "message": "Clarification on precedence.", "committedDate": "2020-03-12T14:32:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjEzMzIyNw==", "url": "https://github.com/hazelcast/hazelcast/pull/16738#discussion_r392133227", "bodyText": "checkPrecedence?", "author": "taburet", "createdAt": "2020-03-13T10:03:54Z", "path": "hazelcast/src/test/java/com/hazelcast/sql/impl/type/QueryDataTypeTest.java", "diffHunk": "@@ -239,10 +239,10 @@ private void checkResolvedTypeForTypeFamily(QueryDataType expectedType, QueryDat\n     }\n \n     private void checkBigger(QueryDataType bigger, QueryDataType smaller) {", "originalCommit": "af90816527413e2d6663ceba6b5687708459c7cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE3ODQxNQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16738#discussion_r392178415", "bodyText": "Fixed.", "author": "devozerov", "createdAt": "2020-03-13T11:41:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjEzMzIyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE2MDQ1NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16738#discussion_r392160455", "bodyText": "... for {@link Object} type.", "author": "taburet", "createdAt": "2020-03-13T10:59:47Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/type/converter/ObjectConverter.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.type.converter;\n+\n+import com.hazelcast.sql.impl.type.QueryDataTypeFamily;\n+\n+/**\n+ * Converter for {@link Integer} type.", "originalCommit": "af90816527413e2d6663ceba6b5687708459c7cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE3ODM5Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/16738#discussion_r392178392", "bodyText": "Fixed.", "author": "devozerov", "createdAt": "2020-03-13T11:41:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE2MDQ1NQ=="}], "type": "inlineReview"}, {"oid": "52853076caf0544f7f19bb0ee38902af052a8255", "url": "https://github.com/hazelcast/hazelcast/commit/52853076caf0544f7f19bb0ee38902af052a8255", "message": "Fixes.", "committedDate": "2020-03-13T11:41:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjIxNDAxNA==", "url": "https://github.com/hazelcast/hazelcast/pull/16738#discussion_r392214014", "bodyText": "Looks like it might be null as well.", "author": "taburet", "createdAt": "2020-03-13T13:04:28Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/type/converter/BooleanConverter.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.type.converter;\n+\n+import com.hazelcast.sql.impl.type.QueryDataTypeFamily;\n+\n+/**\n+ * Converter for {@link java.lang.Boolean} type.\n+ */\n+public final class BooleanConverter extends Converter {\n+\n+    public static final BooleanConverter INSTANCE = new BooleanConverter();\n+\n+    protected static final String TRUE = \"true\";\n+    protected static final String FALSE = \"false\";\n+\n+    private BooleanConverter() {\n+        super(ID_BOOLEAN, QueryDataTypeFamily.BIT);\n+    }\n+\n+    @Override\n+    public Class<?> getValueClass() {\n+        return Boolean.class;\n+    }\n+\n+    @Override\n+    public boolean asBit(Object val) {\n+        return ((Boolean) val);\n+    }\n+\n+    @Override\n+    public String asVarchar(Object val) {\n+        boolean val0 = (Boolean) val;\n+\n+        return val0 ? TRUE : FALSE;", "originalCommit": "52853076caf0544f7f19bb0ee38902af052a8255", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjIxNjc2Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/16738#discussion_r392216767", "bodyText": "There are no null-checks throughout converters code, we assume that the value passed to the converter should never be null. null-checks may degrade performance because most expressions have special treatment for null-s, so null-check is already performed before the converter is called. Two alternative solutions:\n\nHave null-checks in both expressions and converters - bad, since these are very performance-critical places\nHave null-checks in converters only - doesn't work, since expression must process null-s separately anyway", "author": "devozerov", "createdAt": "2020-03-13T13:10:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjIxNDAxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI1MTIwMw==", "url": "https://github.com/hazelcast/hazelcast/pull/16738#discussion_r392251203", "bodyText": "The design document specifies that BIT should be convertible to VARCHAR, BIT, TINYINT, SMALLINT, INT, BINGINT, DECIMAL, REAL  and DOUBLE. But the converter supports only conversions to VARCHAR and BIT. Could you please check other converters as well.\nAlso, it's not clear how converters in general distinguish between implicit and explicit conversion: AFAIU, currently if a converter supports some kind of a conversion it would be applied no matter is it implicit or explicit. For instance, ... WHERE LENGTH(intColumn) = 1 is considered valid in the current code base while the design document treats INT to VARCHAR conversion as explicit. Looks like we need to convey that implicit-explicit information somehow from the converters or by some other means. Another set of methods? Like canConvertImplicitly/Explicitly and probably implicit/explicitAs*.", "author": "taburet", "createdAt": "2020-03-13T14:10:53Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/type/converter/BooleanConverter.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.type.converter;\n+\n+import com.hazelcast.sql.impl.type.QueryDataTypeFamily;\n+\n+/**\n+ * Converter for {@link java.lang.Boolean} type.\n+ */\n+public final class BooleanConverter extends Converter {", "originalCommit": "52853076caf0544f7f19bb0ee38902af052a8255", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM3ODMzNw==", "url": "https://github.com/hazelcast/hazelcast/pull/16738#discussion_r392378337", "bodyText": "There are two ways how BIT could be managed:\n\nSQL standard and some vendors restrict conversions between BIT and numeric types\nBut some vendors, e.g. MySQL, treat BIT as another numeric type\nIn my initial implementation, I followed MySQL approach. Then I decided to follow the ANSI standard, as it will simplify the implementation of expressions, but forgot to update the compatibility matrix. It is fixed now.\n\nRegarding implicit/explicit, this is not a converter's concern. Instead, conversion rules are managed by expressions. We may think of any function as a family of overridden functions with different argument types. And during plan preparation, we resolve the correct instance of the function. But resolution rules are typically more complex than \"can I convert this to that implicitly?\". My previous example demonstrates this:\n\nINT(11) + BIGINT(20) is resolved as CAST(INT(11) AS BIGINT(20) + BIGINT(20))\nINT(11) + VARCHAR is resolved as CAST(INT(11) AS DECIMAL) + CAST(VARCHAR as DECIMAL)\nDATE + INT(11) is failed; not because of an invalid implicit cast for INT, but because there is only one valid override for DATE, which is DATE + INTERVAL, and INT cannot be converted to INTERVAL, neither implicitly, nor explicitly.\n\nAs a result, there is no immediate need for implicit/explicit checks right now. Maybe we will come with some uniform abstraction for implicit/explicit cast checks, but it is unlikely to be a converter's concern anyway.", "author": "devozerov", "createdAt": "2020-03-13T17:43:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI1MTIwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjgzNzk3Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/16738#discussion_r392837972", "bodyText": "I see, so the converters basically define the set of valid type pairs for CAST operator, which are just the set of valid explicit conversions. One thing that I can't understand, what is the purpose of precedence/withHigherPrecedence then? Looks like it just prioritizes implicit conversion to one type over the other for a pair of values of certain types, but doesn't care about the implicit conversion possibility (which is defined by the type conversion matrix in the design document, BTW).", "author": "taburet", "createdAt": "2020-03-16T07:57:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI1MTIwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg2NDY4NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16738#discussion_r392864685", "bodyText": "Converters define the logic of conversion between types, irrespectively of conversion type (implicit or explicit). Precedence determines which function override should be called for the given argument(s). Every function has own rules, but as general guidance, explicit conversions should not be performed without CAST operator. I.e. the implementation of expression should throw an exception in case the conversion is required for the given function override, but it is not implicit.\nSo that table should be considered as a guide for expression implementors.", "author": "devozerov", "createdAt": "2020-03-16T08:55:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI1MTIwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg2NjQ4OA==", "url": "https://github.com/hazelcast/hazelcast/pull/16738#discussion_r392866488", "bodyText": "And withHigherPrecedence is a kind of helper method, which helps expressions to pick the right function override. But this is not the strict rule, only a helper method, which defines part of the selection logic. The example with + function and VARCHAR demonstrates this well: VARCHAR + INT is resolved not as \"pick the type with higher precedence\", but instead as:\n\nIf there is a VARCHAR, then convert it to DECIMAL\nThen pick the type with higher precedence", "author": "devozerov", "createdAt": "2020-03-16T08:58:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI1MTIwMw=="}], "type": "inlineReview"}, {"oid": "2b7f32db0896793357a09edc4d882005a69ae530", "url": "https://github.com/hazelcast/hazelcast/commit/2b7f32db0896793357a09edc4d882005a69ae530", "message": "Fixed type compatibility matrix for BIT.", "committedDate": "2020-03-13T17:29:02Z", "type": "commit"}, {"oid": "8dbfa537ad955200f980c576ccf9945913006c2c", "url": "https://github.com/hazelcast/hazelcast/commit/8dbfa537ad955200f980c576ccf9945913006c2c", "message": "Merge branch 'master' into issues/15241", "committedDate": "2020-03-16T06:27:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjgzODExNg==", "url": "https://github.com/hazelcast/hazelcast/pull/16738#discussion_r392838116", "bodyText": "short", "author": "taburet", "createdAt": "2020-03-16T07:57:38Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/type/converter/ShortConverter.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.type.converter;\n+\n+import com.hazelcast.sql.impl.type.QueryDataTypeFamily;\n+\n+import java.math.BigDecimal;\n+\n+/**\n+ * Converter for {@link java.lang.Float} type.", "originalCommit": "8dbfa537ad955200f980c576ccf9945913006c2c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg2Mjg2OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16738#discussion_r392862869", "bodyText": "Fixed.", "author": "devozerov", "createdAt": "2020-03-16T08:51:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjgzODExNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjgzODMxNw==", "url": "https://github.com/hazelcast/hazelcast/pull/16738#discussion_r392838317", "bodyText": "It's not necessarily a literal.", "author": "taburet", "createdAt": "2020-03-16T07:58:08Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/type/converter/AbstractStringConverter.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.type.converter;\n+\n+import com.hazelcast.sql.HazelcastSqlException;\n+import com.hazelcast.sql.SqlErrorCode;\n+import com.hazelcast.sql.impl.type.QueryDataTypeFamily;\n+\n+import java.math.BigDecimal;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.time.OffsetDateTime;\n+import java.time.format.DateTimeParseException;\n+\n+/**\n+ * Common converter for string-based classes.\n+ */\n+public abstract class AbstractStringConverter extends Converter {\n+    protected AbstractStringConverter(int id) {\n+        super(id, QueryDataTypeFamily.VARCHAR);\n+    }\n+\n+    @Override\n+    public final boolean asBit(Object val) {\n+        String val0 = cast(val);\n+\n+        if (val0.equalsIgnoreCase(BooleanConverter.TRUE)) {\n+            return true;\n+        } else if (val0.equalsIgnoreCase(BooleanConverter.FALSE)) {\n+            return false;\n+        }\n+\n+        throw HazelcastSqlException.error(SqlErrorCode.DATA_EXCEPTION, \"String literal cannot be converter to BIT: \" + val);", "originalCommit": "8dbfa537ad955200f980c576ccf9945913006c2c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg2MjkxOA==", "url": "https://github.com/hazelcast/hazelcast/pull/16738#discussion_r392862918", "bodyText": "Fixed.", "author": "devozerov", "createdAt": "2020-03-16T08:51:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjgzODMxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg0Mjg4OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16738#discussion_r392842889", "bodyText": "Why some converters are trying to convert the passed value to their own type while others are not doing that? For instance, IntegerConverter and many others are not trying to convert.", "author": "taburet", "createdAt": "2020-03-16T08:09:29Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/type/converter/AbstractDecimalConverter.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.type.converter;\n+\n+import com.hazelcast.sql.impl.type.QueryDataTypeFamily;\n+\n+public abstract class AbstractDecimalConverter extends Converter {\n+    protected AbstractDecimalConverter(int id) {\n+        super(id, QueryDataTypeFamily.DECIMAL);\n+    }\n+\n+    @Override\n+    public final Object asObject(Object val) {\n+        return asDecimal(val);", "originalCommit": "8dbfa537ad955200f980c576ccf9945913006c2c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg0NDAxNw==", "url": "https://github.com/hazelcast/hazelcast/pull/16738#discussion_r392844017", "bodyText": "Because there are several descendants of AbstractDecimalConverter, so we do not know the value of the passed val argument. Specifically, here it could be either BitDecimal or BigInteger.", "author": "devozerov", "createdAt": "2020-03-16T08:12:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg0Mjg4OQ=="}], "type": "inlineReview"}, {"oid": "cdf9f084335595402a030e0a8e243f1cc4773a0d", "url": "https://github.com/hazelcast/hazelcast/commit/cdf9f084335595402a030e0a8e243f1cc4773a0d", "message": "Fix review comments.", "committedDate": "2020-03-16T08:51:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg4MzU0MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16738#discussion_r392883541", "bodyText": "Should it be final?", "author": "petrpleshachkov", "createdAt": "2020-03-16T09:30:37Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/HazelcastSqlException.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql;\n+\n+import com.hazelcast.core.HazelcastException;\n+\n+/**\n+ * Exception occurred during SQL query execution.\n+ */\n+public final class HazelcastSqlException extends HazelcastException {\n+    /** Code of the exception. */\n+    private int code;", "originalCommit": "24ad7231c6a7174e2e566475bcc59120e45a51e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjk5NjAwMQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16738#discussion_r392996001", "bodyText": "It is advised by the checkstyle since there are no public constructors. I do not see any problems with it for now, since we do not have any children classes. We may remove it in the future if needed.", "author": "devozerov", "createdAt": "2020-03-16T12:44:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg4MzU0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg4MzkyMg==", "url": "https://github.com/hazelcast/hazelcast/pull/16738#discussion_r392883922", "bodyText": "type: and-> an ?", "author": "petrpleshachkov", "createdAt": "2020-03-16T09:31:19Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/HazelcastSqlException.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql;\n+\n+import com.hazelcast.core.HazelcastException;\n+\n+/**\n+ * Exception occurred during SQL query execution.\n+ */\n+public final class HazelcastSqlException extends HazelcastException {\n+    /** Code of the exception. */\n+    private int code;\n+\n+    private HazelcastSqlException(int code, String message, Throwable cause) {\n+        super(message, cause);\n+\n+        this.code = code;\n+    }\n+\n+    /**\n+     * Constructs a generic error.\n+     *\n+     * @param message Error message.\n+     * @return Exception object.\n+     */\n+    public static HazelcastSqlException error(String message) {\n+        return error(message, null);\n+    }\n+\n+    /**\n+     * Constructs a generic error with the cause.\n+     *\n+     * @param message Error message.\n+     * @return Exception object.\n+     */\n+    public static HazelcastSqlException error(String message, Throwable cause) {\n+        return error(SqlErrorCode.GENERIC, message, cause);\n+    }\n+\n+    /**\n+     * Constructs an error with specific code.\n+     *\n+     * @param code Error code.\n+     * @param message Error message.\n+     * @return Exception object.\n+     */\n+    public static HazelcastSqlException error(int code, String message) {\n+        return error(code, message, null);\n+    }\n+\n+    /**\n+     * Constructs and error with specific code and cause.", "originalCommit": "24ad7231c6a7174e2e566475bcc59120e45a51e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzAwNTA1NA==", "url": "https://github.com/hazelcast/hazelcast/pull/16738#discussion_r393005054", "bodyText": "Fixed", "author": "devozerov", "createdAt": "2020-03-16T12:59:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg4MzkyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg4NTM4Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/16738#discussion_r392885382", "bodyText": "Why not to use enum?", "author": "petrpleshachkov", "createdAt": "2020-03-16T09:33:58Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/SqlErrorCode.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql;\n+\n+/**\n+ * Error codes used in Hazelcast SQL.\n+ */\n+public final class SqlErrorCode {", "originalCommit": "24ad7231c6a7174e2e566475bcc59120e45a51e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjk5Njk5OA==", "url": "https://github.com/hazelcast/hazelcast/pull/16738#discussion_r392996998", "bodyText": "We will have dozens of error codes in the future. They are part of public API and are transferred over the wire. For this reason, it is better to use ints to prevent compatibility problems.", "author": "devozerov", "createdAt": "2020-03-16T12:45:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg4NTM4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg5MjI2Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/16738#discussion_r392892263", "bodyText": "Minor: in the comment we say 12 (fields) which consists of 4 + 8 in the code. Should we document this further?", "author": "petrpleshachkov", "createdAt": "2020-03-16T09:45:53Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/type/QueryDataTypeUtils.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.type;\n+\n+import com.hazelcast.sql.impl.type.converter.BigDecimalConverter;\n+import com.hazelcast.sql.impl.type.converter.BigIntegerConverter;\n+import com.hazelcast.sql.impl.type.converter.CalendarConverter;\n+import com.hazelcast.sql.impl.type.converter.CharacterConverter;\n+import com.hazelcast.sql.impl.type.converter.Converter;\n+import com.hazelcast.sql.impl.type.converter.Converters;\n+import com.hazelcast.sql.impl.type.converter.DateConverter;\n+import com.hazelcast.sql.impl.type.converter.InstantConverter;\n+import com.hazelcast.sql.impl.type.converter.OffsetDateTimeConverter;\n+import com.hazelcast.sql.impl.type.converter.StringConverter;\n+import com.hazelcast.sql.impl.type.converter.ZonedDateTimeConverter;\n+\n+/**\n+ * Utility methods for SQL data types.\n+ */\n+public final class QueryDataTypeUtils {\n+    /** 12 (hdr) + 12 (fields) + 12 (arr) + 4 (arr len) + 16 (eight chars) */\n+    public static final int TYPE_LEN_VARCHAR = 12 + 4 + 8 + 12 + 4 + 16;", "originalCommit": "24ad7231c6a7174e2e566475bcc59120e45a51e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjk5ODIzNQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16738#discussion_r392998235", "bodyText": "This might be too verbose, especially for complex types, such as temporal classes. I would leave it as is without explicitly typing the fields names of classes from the Java standard library.", "author": "devozerov", "createdAt": "2020-03-16T12:47:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg5MjI2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjkyODcxOQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16738#discussion_r392928719", "bodyText": "Shall we add assert val0 != null as in the CharacterConverter?", "author": "petrpleshachkov", "createdAt": "2020-03-16T10:43:41Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/type/converter/BooleanConverter.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.type.converter;\n+\n+import com.hazelcast.sql.impl.type.QueryDataTypeFamily;\n+\n+/**\n+ * Converter for {@link java.lang.Boolean} type.\n+ */\n+public final class BooleanConverter extends Converter {\n+    /** Singleton instance. */\n+    public static final BooleanConverter INSTANCE = new BooleanConverter();\n+\n+    protected static final String TRUE = \"true\";\n+    protected static final String FALSE = \"false\";\n+\n+    private BooleanConverter() {\n+        super(ID_BOOLEAN, QueryDataTypeFamily.BIT);\n+    }\n+\n+    @Override\n+    public Class<?> getValueClass() {\n+        return Boolean.class;\n+    }\n+\n+    @Override\n+    public boolean asBit(Object val) {\n+        return ((Boolean) val);\n+    }\n+\n+    @Override\n+    public String asVarchar(Object val) {\n+        boolean val0 = (Boolean) val;\n+", "originalCommit": "24ad7231c6a7174e2e566475bcc59120e45a51e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzAwNDk0Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/16738#discussion_r393004946", "bodyText": "We discussed this with Sergey here: #16738 (comment)\nWe have a contract that null values are not allowed in converters. We may add assertions, but will nearly double the size of the code of the converters because every conversion method follows this contract. This will decrease readability, so I preferred not to add them in the first place.\nI added some clarifications about that to Converter JavaDoc.", "author": "devozerov", "createdAt": "2020-03-16T12:59:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjkyODcxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjkzNDA4NA==", "url": "https://github.com/hazelcast/hazelcast/pull/16738#discussion_r392934084", "bodyText": "Shall we add id and typeFamily here?", "author": "petrpleshachkov", "createdAt": "2020-03-16T10:53:10Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/type/converter/Converter.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.type.converter;\n+\n+import com.hazelcast.core.HazelcastException;\n+import com.hazelcast.sql.HazelcastSqlException;\n+import com.hazelcast.sql.SqlErrorCode;\n+import com.hazelcast.sql.impl.type.QueryDataTypeFamily;\n+\n+import java.lang.reflect.Method;\n+import java.math.BigDecimal;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.time.OffsetDateTime;\n+\n+/**\n+ * Interface to convert an item from one type to another.\n+ */\n+@SuppressWarnings(\"checkstyle:MethodCount\")\n+public abstract class Converter {\n+    protected static final int ID_LATE = 0;\n+    protected static final int ID_BOOLEAN = 1;\n+    protected static final int ID_BYTE = 2;\n+    protected static final int ID_SHORT = 3;\n+    protected static final int ID_INTEGER = 4;\n+    protected static final int ID_LONG = 5;\n+    protected static final int ID_BIG_INTEGER = 6;\n+    protected static final int ID_BIG_DECIMAL = 7;\n+    protected static final int ID_FLOAT = 8;\n+    protected static final int ID_DOUBLE = 9;\n+    protected static final int ID_CHARACTER = 10;\n+    protected static final int ID_STRING = 11;\n+    protected static final int ID_DATE = 12;\n+    protected static final int ID_CALENDAR = 13;\n+    protected static final int ID_LOCAL_DATE = 14;\n+    protected static final int ID_LOCAL_TIME = 15;\n+    protected static final int ID_LOCAL_DATE_TIME = 16;\n+    protected static final int ID_INSTANT = 17;\n+    protected static final int ID_OFFSET_DATE_TIME = 18;\n+    protected static final int ID_ZONED_DATE_TIME = 19;\n+    protected static final int ID_OBJECT = 20;\n+\n+    private final int id;\n+    private final QueryDataTypeFamily typeFamily;\n+\n+    private final boolean convertToBit;\n+    private final boolean convertToTinyint;\n+    private final boolean convertToSmallint;\n+    private final boolean convertToInt;\n+    private final boolean convertToBigint;\n+    private final boolean convertToDecimal;\n+    private final boolean convertToReal;\n+    private final boolean convertToDouble;\n+    private final boolean convertToVarchar;\n+    private final boolean convertToDate;\n+    private final boolean convertToTime;\n+    private final boolean convertToTimestamp;\n+    private final boolean convertToTimestampWithTimezone;\n+    private final boolean convertToObject;\n+\n+    protected Converter(int id, QueryDataTypeFamily typeFamily) {\n+        this.id = id;\n+        this.typeFamily = typeFamily;\n+\n+        try {\n+            Class<? extends Converter> clazz = getClass();\n+\n+            convertToBit = canConvert(clazz.getMethod(\"asBit\", Object.class));\n+            convertToTinyint = canConvert(clazz.getMethod(\"asTinyint\", Object.class));\n+            convertToSmallint = canConvert(clazz.getMethod(\"asSmallint\", Object.class));\n+            convertToInt = canConvert(clazz.getMethod(\"asInt\", Object.class));\n+            convertToBigint = canConvert(clazz.getMethod(\"asBigint\", Object.class));\n+            convertToDecimal = canConvert(clazz.getMethod(\"asDecimal\", Object.class));\n+            convertToReal = canConvert(clazz.getMethod(\"asReal\", Object.class));\n+            convertToDouble = canConvert(clazz.getMethod(\"asDouble\", Object.class));\n+            convertToVarchar = canConvert(clazz.getMethod(\"asVarchar\", Object.class));\n+            convertToDate = canConvert(clazz.getMethod(\"asDate\", Object.class));\n+            convertToTime = canConvert(clazz.getMethod(\"asTime\", Object.class));\n+            convertToTimestamp = canConvert(clazz.getMethod(\"asTimestamp\", Object.class));\n+            convertToTimestampWithTimezone = canConvert(clazz.getMethod(\"asTimestampWithTimezone\", Object.class));\n+            convertToObject = canConvert(clazz.getMethod(\"asObject\", Object.class));\n+        } catch (ReflectiveOperationException e) {\n+            throw new HazelcastException(\"Failed to initialize converter: \" + getClass().getName(), e);\n+        }\n+    }\n+\n+    public final int getId() {\n+        return id;\n+    }\n+\n+    public final QueryDataTypeFamily getTypeFamily() {\n+        return typeFamily;\n+    }\n+\n+    public abstract Class<?> getValueClass();\n+\n+    @NotConvertible\n+    public boolean asBit(Object val) {\n+        throw cannotConvert(QueryDataTypeFamily.BIT);\n+    }\n+\n+    @NotConvertible\n+    public byte asTinyint(Object val) {\n+        throw cannotConvert(QueryDataTypeFamily.TINYINT);\n+    }\n+\n+    @NotConvertible\n+    public short asSmallint(Object val) {\n+        throw cannotConvert(QueryDataTypeFamily.SMALLINT);\n+    }\n+\n+    @NotConvertible\n+    public int asInt(Object val) {\n+        throw cannotConvert(QueryDataTypeFamily.INT);\n+    }\n+\n+    @NotConvertible\n+    public long asBigint(Object val) {\n+        throw cannotConvert(QueryDataTypeFamily.BIGINT);\n+    }\n+\n+    @NotConvertible\n+    public BigDecimal asDecimal(Object val) {\n+        throw cannotConvert(QueryDataTypeFamily.DECIMAL);\n+    }\n+\n+    @NotConvertible\n+    public float asReal(Object val) {\n+        throw cannotConvert(QueryDataTypeFamily.REAL);\n+    }\n+\n+    @NotConvertible\n+    public double asDouble(Object val) {\n+        throw cannotConvert(QueryDataTypeFamily.DOUBLE);\n+    }\n+\n+    @NotConvertible\n+    public String asVarchar(Object val) {\n+        throw cannotConvert(QueryDataTypeFamily.VARCHAR);\n+    }\n+\n+    @NotConvertible\n+    public LocalDate asDate(Object val) {\n+        throw cannotConvert(QueryDataTypeFamily.DATE);\n+    }\n+\n+    @NotConvertible\n+    public LocalTime asTime(Object val) {\n+        throw cannotConvert(QueryDataTypeFamily.TIME);\n+    }\n+\n+    @NotConvertible\n+    public LocalDateTime asTimestamp(Object val) {\n+        throw cannotConvert(QueryDataTypeFamily.TIMESTAMP);\n+    }\n+\n+    @NotConvertible\n+    public OffsetDateTime asTimestampWithTimezone(Object val) {\n+        throw cannotConvert(QueryDataTypeFamily.TIMESTAMP_WITH_TIMEZONE);\n+    }\n+\n+    public Object asObject(Object val) {\n+        return val;\n+    }\n+\n+    public final boolean canConvertToBit() {\n+        return convertToBit;\n+    }\n+\n+    public final boolean canConvertToTinyint() {\n+        return convertToTinyint;\n+    }\n+\n+    public final boolean canConvertToSmallint() {\n+        return convertToSmallint;\n+    }\n+\n+    public final boolean canConvertToInt() {\n+        return convertToInt;\n+    }\n+\n+    public final boolean canConvertToBigint() {\n+        return convertToBigint;\n+    }\n+\n+    public final boolean canConvertToDecimal() {\n+        return convertToDecimal;\n+    }\n+\n+    public final boolean canConvertToReal() {\n+        return convertToReal;\n+    }\n+\n+    public final boolean canConvertToDouble() {\n+        return convertToDouble;\n+    }\n+\n+    public final boolean canConvertToVarchar() {\n+        return convertToVarchar;\n+    }\n+\n+    public final boolean canConvertToDate() {\n+        return convertToDate;\n+    }\n+\n+    public final boolean canConvertToTime() {\n+        return convertToTime;\n+    }\n+\n+    public final boolean canConvertToTimestamp() {\n+        return convertToTimestamp;\n+    }\n+\n+    public final boolean canConvertToTimestampWithTimezone() {\n+        return convertToTimestampWithTimezone;\n+    }\n+\n+    public final boolean canConvertToObject() {\n+        return convertToObject;\n+    }\n+\n+    @SuppressWarnings({\"checkstyle:CyclomaticComplexity\", \"checkstyle:ReturnCount\"})\n+    public final boolean canConvertTo(QueryDataTypeFamily typeFamily) {\n+        switch (typeFamily) {\n+            case BIT:\n+                return canConvertToBit();\n+\n+            case TINYINT:\n+                return canConvertToTinyint();\n+\n+            case SMALLINT:\n+                return canConvertToSmallint();\n+\n+            case INT:\n+                return canConvertToInt();\n+\n+            case BIGINT:\n+                return canConvertToBigint();\n+\n+            case DECIMAL:\n+                return canConvertToDecimal();\n+\n+            case REAL:\n+                return canConvertToReal();\n+\n+            case DOUBLE:\n+                return canConvertToDouble();\n+\n+            case VARCHAR:\n+                return canConvertToVarchar();\n+\n+            case DATE:\n+                return canConvertToDate();\n+\n+            case TIME:\n+                return canConvertToTime();\n+\n+            case TIMESTAMP:\n+                return canConvertToTimestamp();\n+\n+            case TIMESTAMP_WITH_TIMEZONE:\n+                return canConvertToTimestampWithTimezone();\n+\n+            case OBJECT:\n+                return canConvertToObject();\n+\n+            default:\n+                return getTypeFamily() == typeFamily;\n+        }\n+    }\n+\n+    public abstract Object convertToSelf(Converter converter, Object val);\n+\n+    protected final HazelcastSqlException cannotConvert(QueryDataTypeFamily target) {\n+        return cannotConvert(target, null);\n+    }\n+\n+    protected final HazelcastSqlException cannotConvert(QueryDataTypeFamily target, Object val) {\n+        return cannotConvert(typeFamily, target, val);\n+    }\n+\n+    protected final HazelcastSqlException cannotConvert(QueryDataTypeFamily source, QueryDataTypeFamily target, Object val) {\n+        String message = \"Cannot convert \" + source + \" to \" + target;\n+\n+        if (val != null) {\n+            message += \": \" + val;\n+        }\n+\n+        return HazelcastSqlException.error(SqlErrorCode.DATA_EXCEPTION, message);\n+    }\n+\n+    private static boolean canConvert(Method method) {\n+        return method.getAnnotation(NotConvertible.class) == null;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return getClass().getSimpleName();", "originalCommit": "24ad7231c6a7174e2e566475bcc59120e45a51e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzAwMzczOQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16738#discussion_r393003739", "bodyText": "Converters are internal classes, we do not expect that users should see them in any exception or log message. For us, as implementors, this information is of little use.", "author": "devozerov", "createdAt": "2020-03-16T12:57:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjkzNDA4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjkzNTk3Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/16738#discussion_r392935973", "bodyText": "Initialize res with the size of converters?", "author": "petrpleshachkov", "createdAt": "2020-03-16T10:56:46Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/type/converter/Converters.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.type.converter;\n+\n+import com.hazelcast.core.HazelcastException;\n+import com.hazelcast.sql.HazelcastSqlException;\n+\n+import java.util.ArrayList;\n+import java.util.Calendar;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+\n+/**\n+ * Utility methods for converters.\n+ */\n+@SuppressWarnings(\"checkstyle:ExecutableStatementCount\")\n+public final class Converters {\n+    /** Synthetic maximum number of converters to prevent an accidental bug which will generate too big array. */\n+    private static final int MAX_CONVERTER_COUNT = 100;\n+\n+    private static final Converter[] CONVERTERS;\n+    private static final Map<Class<?>, Converter> CLASS_TO_CONVERTER;\n+\n+    static {\n+        List<Converter> converters = getConverters();\n+\n+        CONVERTERS = createConvertersArray(converters);\n+        CLASS_TO_CONVERTER = createConvertersMap(converters);\n+    }\n+\n+    private Converters() {\n+        // No-op.\n+    }\n+\n+    public static Converter getConverter(int converterId) {\n+        if (converterId < CONVERTERS.length) {\n+            return CONVERTERS[converterId];\n+        }\n+\n+        throw HazelcastSqlException.error(\"Converter with ID \" + converterId + \" doesn't exist\");\n+    }\n+\n+    /**\n+     * Get converter for the given class.\n+     *\n+     * @param clazz Class.\n+     * @return Converter or exception if no matching converters found.\n+     */\n+    public static Converter getConverter(Class<?> clazz) {\n+        Converter res = CLASS_TO_CONVERTER.get(clazz);\n+\n+        if (res == null) {\n+            if (Calendar.class.isAssignableFrom(clazz)) {\n+                res = CalendarConverter.INSTANCE;\n+            } else {\n+                res = ObjectConverter.INSTANCE;\n+            }\n+        }\n+\n+        return res;\n+    }\n+\n+    /**\n+     * @return List of all supported converters.\n+     */\n+    private static List<Converter> getConverters() {\n+        List<Converter> converters = new ArrayList<>();\n+\n+        // Late binding support.\n+        converters.add(LateConverter.INSTANCE);\n+\n+        // Boolean converter.\n+        converters.add(BooleanConverter.INSTANCE);\n+\n+        // Converters for exact numeric types.\n+        converters.add(ByteConverter.INSTANCE);\n+        converters.add(ShortConverter.INSTANCE);\n+        converters.add(IntegerConverter.INSTANCE);\n+        converters.add(LongConverter.INSTANCE);\n+        converters.add(BigIntegerConverter.INSTANCE);\n+        converters.add(BigDecimalConverter.INSTANCE);\n+\n+        // Converters for inexact numeric types.\n+        converters.add(FloatConverter.INSTANCE);\n+        converters.add(DoubleConverter.INSTANCE);\n+\n+        // String converters.\n+        converters.add(CharacterConverter.INSTANCE);\n+        converters.add(StringConverter.INSTANCE);\n+\n+        // Converters for temporal data types.\n+        converters.add(DateConverter.INSTANCE);\n+        converters.add(CalendarConverter.INSTANCE);\n+\n+        converters.add(LocalDateConverter.INSTANCE);\n+        converters.add(LocalTimeConverter.INSTANCE);\n+        converters.add(LocalDateTimeConverter.INSTANCE);\n+        converters.add(InstantConverter.INSTANCE);\n+        converters.add(OffsetDateTimeConverter.INSTANCE);\n+        converters.add(ZonedDateTimeConverter.INSTANCE);\n+\n+        // Object converter.\n+        converters.add(ObjectConverter.INSTANCE);\n+\n+        return converters;\n+    }\n+\n+    private static Map<Class<?>, Converter> createConvertersMap(List<Converter> converters) {\n+        Map<Class<?>, Converter> res = new HashMap<>();", "originalCommit": "24ad7231c6a7174e2e566475bcc59120e45a51e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzAwNDg4OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16738#discussion_r393004889", "bodyText": "Fixed.", "author": "devozerov", "createdAt": "2020-03-16T12:59:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjkzNTk3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjkzNjcwNA==", "url": "https://github.com/hazelcast/hazelcast/pull/16738#discussion_r392936704", "bodyText": "The same here.", "author": "petrpleshachkov", "createdAt": "2020-03-16T10:58:12Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/type/converter/Converters.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.type.converter;\n+\n+import com.hazelcast.core.HazelcastException;\n+import com.hazelcast.sql.HazelcastSqlException;\n+\n+import java.util.ArrayList;\n+import java.util.Calendar;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+\n+/**\n+ * Utility methods for converters.\n+ */\n+@SuppressWarnings(\"checkstyle:ExecutableStatementCount\")\n+public final class Converters {\n+    /** Synthetic maximum number of converters to prevent an accidental bug which will generate too big array. */\n+    private static final int MAX_CONVERTER_COUNT = 100;\n+\n+    private static final Converter[] CONVERTERS;\n+    private static final Map<Class<?>, Converter> CLASS_TO_CONVERTER;\n+\n+    static {\n+        List<Converter> converters = getConverters();\n+\n+        CONVERTERS = createConvertersArray(converters);\n+        CLASS_TO_CONVERTER = createConvertersMap(converters);\n+    }\n+\n+    private Converters() {\n+        // No-op.\n+    }\n+\n+    public static Converter getConverter(int converterId) {\n+        if (converterId < CONVERTERS.length) {\n+            return CONVERTERS[converterId];\n+        }\n+\n+        throw HazelcastSqlException.error(\"Converter with ID \" + converterId + \" doesn't exist\");\n+    }\n+\n+    /**\n+     * Get converter for the given class.\n+     *\n+     * @param clazz Class.\n+     * @return Converter or exception if no matching converters found.\n+     */\n+    public static Converter getConverter(Class<?> clazz) {\n+        Converter res = CLASS_TO_CONVERTER.get(clazz);\n+\n+        if (res == null) {\n+            if (Calendar.class.isAssignableFrom(clazz)) {\n+                res = CalendarConverter.INSTANCE;\n+            } else {\n+                res = ObjectConverter.INSTANCE;\n+            }\n+        }\n+\n+        return res;\n+    }\n+\n+    /**\n+     * @return List of all supported converters.\n+     */\n+    private static List<Converter> getConverters() {\n+        List<Converter> converters = new ArrayList<>();\n+\n+        // Late binding support.\n+        converters.add(LateConverter.INSTANCE);\n+\n+        // Boolean converter.\n+        converters.add(BooleanConverter.INSTANCE);\n+\n+        // Converters for exact numeric types.\n+        converters.add(ByteConverter.INSTANCE);\n+        converters.add(ShortConverter.INSTANCE);\n+        converters.add(IntegerConverter.INSTANCE);\n+        converters.add(LongConverter.INSTANCE);\n+        converters.add(BigIntegerConverter.INSTANCE);\n+        converters.add(BigDecimalConverter.INSTANCE);\n+\n+        // Converters for inexact numeric types.\n+        converters.add(FloatConverter.INSTANCE);\n+        converters.add(DoubleConverter.INSTANCE);\n+\n+        // String converters.\n+        converters.add(CharacterConverter.INSTANCE);\n+        converters.add(StringConverter.INSTANCE);\n+\n+        // Converters for temporal data types.\n+        converters.add(DateConverter.INSTANCE);\n+        converters.add(CalendarConverter.INSTANCE);\n+\n+        converters.add(LocalDateConverter.INSTANCE);\n+        converters.add(LocalTimeConverter.INSTANCE);\n+        converters.add(LocalDateTimeConverter.INSTANCE);\n+        converters.add(InstantConverter.INSTANCE);\n+        converters.add(OffsetDateTimeConverter.INSTANCE);\n+        converters.add(ZonedDateTimeConverter.INSTANCE);\n+\n+        // Object converter.\n+        converters.add(ObjectConverter.INSTANCE);\n+\n+        return converters;\n+    }\n+\n+    private static Map<Class<?>, Converter> createConvertersMap(List<Converter> converters) {\n+        Map<Class<?>, Converter> res = new HashMap<>();\n+\n+        for (Converter converter : converters) {\n+            Class<?> valueClass = converter.getValueClass();\n+\n+            if (valueClass != null) {\n+                Converter prevConverter = res.put(valueClass, converter);\n+\n+                if (prevConverter != null) {\n+                    throw new HazelcastException(\"Duplicate converter for class [class=\" + valueClass\n+                         + \", converter1=\" + prevConverter.getValueClass().getName()\n+                         + \", converter2=\" + valueClass.getName()\n+                         + ']');\n+                }\n+\n+                Class<?> primitiveValueClass = getPrimitiveClass(valueClass);\n+\n+                if (primitiveValueClass != null) {\n+                    res.put(primitiveValueClass, converter);\n+                }\n+            }\n+        }\n+\n+        return res;\n+    }\n+\n+    private static Converter[] createConvertersArray(List<Converter> converters) {\n+        TreeMap<Integer, Converter> map = new TreeMap<>();", "originalCommit": "24ad7231c6a7174e2e566475bcc59120e45a51e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzAwNDg1Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/16738#discussion_r393004857", "bodyText": "TreeMap doesn't have such a constructor.", "author": "devozerov", "createdAt": "2020-03-16T12:59:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjkzNjcwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjk5NjAyNg==", "url": "https://github.com/hazelcast/hazelcast/pull/16738#discussion_r392996026", "bodyText": "Minor: make it final?", "author": "petrpleshachkov", "createdAt": "2020-03-16T12:44:26Z", "path": "hazelcast/src/test/java/com/hazelcast/sql/impl/type/converter/ConvertersTest.java", "diffHunk": "@@ -0,0 +1,1074 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.type.converter;\n+\n+import com.hazelcast.sql.HazelcastSqlException;\n+import com.hazelcast.sql.SqlErrorCode;\n+import com.hazelcast.sql.impl.type.QueryDataTypeFamily;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.time.OffsetDateTime;\n+import java.time.ZoneId;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.Arrays;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.GregorianCalendar;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static com.hazelcast.sql.impl.type.QueryDataTypeFamily.BIGINT;\n+import static com.hazelcast.sql.impl.type.QueryDataTypeFamily.BIT;\n+import static com.hazelcast.sql.impl.type.QueryDataTypeFamily.DATE;\n+import static com.hazelcast.sql.impl.type.QueryDataTypeFamily.DECIMAL;\n+import static com.hazelcast.sql.impl.type.QueryDataTypeFamily.DOUBLE;\n+import static com.hazelcast.sql.impl.type.QueryDataTypeFamily.INT;\n+import static com.hazelcast.sql.impl.type.QueryDataTypeFamily.LATE;\n+import static com.hazelcast.sql.impl.type.QueryDataTypeFamily.OBJECT;\n+import static com.hazelcast.sql.impl.type.QueryDataTypeFamily.REAL;\n+import static com.hazelcast.sql.impl.type.QueryDataTypeFamily.SMALLINT;\n+import static com.hazelcast.sql.impl.type.QueryDataTypeFamily.TIME;\n+import static com.hazelcast.sql.impl.type.QueryDataTypeFamily.TIMESTAMP;\n+import static com.hazelcast.sql.impl.type.QueryDataTypeFamily.TIMESTAMP_WITH_TIMEZONE;\n+import static com.hazelcast.sql.impl.type.QueryDataTypeFamily.TINYINT;\n+import static com.hazelcast.sql.impl.type.QueryDataTypeFamily.VARCHAR;\n+import static com.hazelcast.sql.impl.type.QueryDataTypeFamily.values;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+@SuppressWarnings(\"SimplifiableJUnitAssertion\")\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class ConvertersTest {\n+    @Test\n+    public void testGetById() {\n+        checkGetById(LateConverter.INSTANCE);\n+\n+        checkGetById(StringConverter.INSTANCE);\n+        checkGetById(CharacterConverter.INSTANCE);\n+\n+        checkGetById(BooleanConverter.INSTANCE);\n+        checkGetById(ByteConverter.INSTANCE);\n+        checkGetById(ShortConverter.INSTANCE);\n+        checkGetById(IntegerConverter.INSTANCE);\n+        checkGetById(LongConverter.INSTANCE);\n+        checkGetById(BigDecimalConverter.INSTANCE);\n+        checkGetById(BigIntegerConverter.INSTANCE);\n+        checkGetById(FloatConverter.INSTANCE);\n+        checkGetById(DoubleConverter.INSTANCE);\n+\n+        checkGetById(LocalTimeConverter.INSTANCE);\n+        checkGetById(LocalDateConverter.INSTANCE);\n+        checkGetById(LocalDateTimeConverter.INSTANCE);\n+        checkGetById(DateConverter.INSTANCE);\n+        checkGetById(CalendarConverter.INSTANCE);\n+        checkGetById(InstantConverter.INSTANCE);\n+        checkGetById(OffsetDateTimeConverter.INSTANCE);\n+        checkGetById(ZonedDateTimeConverter.INSTANCE);\n+\n+        checkGetById(ObjectConverter.INSTANCE);\n+    }\n+\n+    @Test\n+    public void testGetByClass() {\n+        checkGetByClass(StringConverter.INSTANCE, String.class);\n+        checkGetByClass(CharacterConverter.INSTANCE, char.class, Character.class);\n+\n+        checkGetByClass(BooleanConverter.INSTANCE, boolean.class, Boolean.class);\n+        checkGetByClass(ByteConverter.INSTANCE, byte.class, Byte.class);\n+        checkGetByClass(ShortConverter.INSTANCE, short.class, Short.class);\n+        checkGetByClass(IntegerConverter.INSTANCE, int.class, Integer.class);\n+        checkGetByClass(LongConverter.INSTANCE, long.class, Long.class);\n+        checkGetByClass(BigDecimalConverter.INSTANCE, BigDecimal.class);\n+        checkGetByClass(BigIntegerConverter.INSTANCE, BigInteger.class);\n+        checkGetByClass(FloatConverter.INSTANCE, float.class, Float.class);\n+        checkGetByClass(DoubleConverter.INSTANCE, double.class, Double.class);\n+\n+        checkGetByClass(LocalTimeConverter.INSTANCE, LocalTime.class);\n+        checkGetByClass(LocalDateConverter.INSTANCE, LocalDate.class);\n+        checkGetByClass(LocalDateTimeConverter.INSTANCE, LocalDateTime.class);\n+        checkGetByClass(DateConverter.INSTANCE, Date.class);\n+        checkGetByClass(CalendarConverter.INSTANCE, Calendar.class, GregorianCalendar.class);\n+        checkGetByClass(InstantConverter.INSTANCE, Instant.class);\n+        checkGetByClass(OffsetDateTimeConverter.INSTANCE, OffsetDateTime.class);\n+        checkGetByClass(ZonedDateTimeConverter.INSTANCE, ZonedDateTime.class);\n+\n+        checkGetByClass(ObjectConverter.INSTANCE, Object.class, CustomClass.class);\n+    }\n+\n+    @Test\n+    public void testBooleanConverter() {\n+        BooleanConverter converter = BooleanConverter.INSTANCE;\n+\n+        checkConverter(converter, Converter.ID_BOOLEAN, BIT, Boolean.class);\n+        checkConverterConversions(converter, VARCHAR, OBJECT);\n+\n+        assertEquals(\"true\", converter.asVarchar(true));\n+        assertEquals(\"false\", converter.asVarchar(false));\n+\n+        assertEquals(true, converter.asObject(true));\n+\n+        checkConverterSelf(converter);\n+    }\n+\n+    @Test\n+    public void testByteConverter() {\n+        ByteConverter converter = ByteConverter.INSTANCE;\n+\n+        checkConverter(converter, Converter.ID_BYTE, TINYINT, Byte.class);\n+        checkConverterConversions(converter, VARCHAR, SMALLINT, INT, BIGINT, DECIMAL, REAL, DOUBLE, OBJECT);\n+\n+        assertEquals(\"1\", converter.asVarchar((byte) 1));\n+\n+        assertEquals(1, converter.asTinyint((byte) 1));\n+        assertEquals(1, converter.asSmallint((byte) 1));\n+        assertEquals(1, converter.asInt((byte) 1));\n+        assertEquals(1L, converter.asBigint((byte) 1));\n+        assertEquals(BigDecimal.ONE, converter.asDecimal((byte) 1));\n+\n+        assertEquals(1.0f, converter.asReal((byte) 1), 0);\n+        assertEquals(1.0d, converter.asDouble((byte) 1), 0);\n+\n+        assertEquals((byte) 1, converter.asObject((byte) 1));\n+\n+        checkConverterSelf(converter);\n+    }\n+\n+    @Test\n+    public void testShortConverter() {\n+        ShortConverter converter = ShortConverter.INSTANCE;\n+\n+        checkConverter(converter, Converter.ID_SHORT, SMALLINT, Short.class);\n+        checkConverterConversions(converter, VARCHAR, TINYINT, INT, BIGINT, DECIMAL, REAL, DOUBLE, OBJECT);\n+\n+        assertEquals(\"1\", converter.asVarchar((short) 1));\n+\n+        assertEquals(1, converter.asTinyint((short) 1));\n+        assertEquals(1, converter.asSmallint((short) 1));\n+        assertEquals(1, converter.asInt((short) 1));\n+        assertEquals(1L, converter.asBigint((short) 1));\n+        assertEquals(BigDecimal.ONE, converter.asDecimal((short) 1));\n+\n+        assertEquals(1.0f, converter.asReal((short) 1), 0);\n+        assertEquals(1.0d, converter.asDouble((short) 1), 0);\n+\n+        assertEquals((short) 1, converter.asObject((short) 1));\n+\n+        checkConverterSelf(converter);\n+    }\n+\n+    @Test\n+    public void testIntConverter() {\n+        IntegerConverter converter = IntegerConverter.INSTANCE;\n+\n+        checkConverter(converter, Converter.ID_INTEGER, INT, Integer.class);\n+        checkConverterConversions(converter, VARCHAR, TINYINT, SMALLINT, BIGINT, DECIMAL, REAL, DOUBLE, OBJECT);\n+\n+        assertEquals(\"1\", converter.asVarchar(1));\n+\n+        assertEquals(1, converter.asTinyint(1));\n+        assertEquals(1, converter.asSmallint(1));\n+        assertEquals(1, converter.asInt(1));\n+        assertEquals(1L, converter.asBigint(1));\n+        assertEquals(BigDecimal.ONE, converter.asDecimal(1));\n+\n+        assertEquals(1.0f, converter.asReal(1), 0);\n+        assertEquals(1.0d, converter.asDouble(1), 0);\n+\n+        assertEquals(1, converter.asObject(1));\n+\n+        checkConverterSelf(converter);\n+    }\n+\n+    @Test\n+    public void testLongConverter() {\n+        LongConverter converter = LongConverter.INSTANCE;\n+\n+        checkConverter(converter, Converter.ID_LONG, BIGINT, Long.class);\n+        checkConverterConversions(converter, VARCHAR, TINYINT, SMALLINT, INT, DECIMAL, REAL, DOUBLE, OBJECT);\n+\n+        assertEquals(\"1\", converter.asVarchar(1L));\n+\n+        assertEquals(1, converter.asTinyint(1L));\n+        assertEquals(1, converter.asSmallint(1L));\n+        assertEquals(1, converter.asInt(1L));\n+        assertEquals(1L, converter.asBigint(1L));\n+        assertEquals(BigDecimal.ONE, converter.asDecimal(1L));\n+\n+        assertEquals(1.0f, converter.asReal(1L), 0);\n+        assertEquals(1.0d, converter.asDouble(1L), 0);\n+\n+        assertEquals(1L, converter.asObject(1L));\n+\n+        checkConverterSelf(converter);\n+    }\n+\n+    @Test\n+    public void testBigIntegerConverter() {\n+        BigIntegerConverter converter = BigIntegerConverter.INSTANCE;\n+\n+        checkConverter(converter, Converter.ID_BIG_INTEGER, DECIMAL, BigInteger.class);\n+        checkConverterConversions(converter, VARCHAR, TINYINT, SMALLINT, INT, BIGINT, REAL, DOUBLE, OBJECT);\n+\n+        assertEquals(\"1\", converter.asVarchar(BigInteger.ONE));\n+\n+        assertEquals(1, converter.asTinyint(BigInteger.ONE));\n+        assertEquals(1, converter.asSmallint(BigInteger.ONE));\n+        assertEquals(1, converter.asInt(BigInteger.ONE));\n+        assertEquals(1L, converter.asBigint(BigInteger.ONE));\n+        assertEquals(BigDecimal.ONE, converter.asDecimal(BigInteger.ONE));\n+\n+        assertEquals(1.0f, converter.asReal(BigInteger.ONE), 0);\n+        assertEquals(1.0d, converter.asDouble(BigInteger.ONE), 0);\n+\n+        assertEquals(BigDecimal.ONE, converter.asObject(BigInteger.ONE));\n+\n+        checkConverterSelf(converter);\n+    }\n+\n+    @Test\n+    public void testBigDecimalConverter() {\n+        BigDecimalConverter converter = BigDecimalConverter.INSTANCE;\n+\n+        checkConverter(converter, Converter.ID_BIG_DECIMAL, DECIMAL, BigDecimal.class);\n+        checkConverterConversions(converter, VARCHAR, TINYINT, SMALLINT, INT, BIGINT, REAL, DOUBLE, OBJECT);\n+\n+        BigDecimal val = BigDecimal.valueOf(11, 1);\n+\n+        assertEquals(\"1.1\", converter.asVarchar(val));\n+\n+        assertEquals(1, converter.asTinyint(val));\n+        assertEquals(1, converter.asSmallint(val));\n+        assertEquals(1, converter.asInt(val));\n+        assertEquals(1L, converter.asBigint(val));\n+        assertEquals(val, converter.asDecimal(val));\n+\n+        assertEquals(1.1f, converter.asReal(val), 0);\n+        assertEquals(1.1d, converter.asDouble(val), 0);\n+\n+        assertEquals(val, converter.asObject(val));\n+\n+        checkConverterSelf(converter);\n+    }\n+\n+    @Test\n+    public void testFloatConverter() {\n+        FloatConverter converter = FloatConverter.INSTANCE;\n+\n+        checkConverter(converter, Converter.ID_FLOAT, REAL, Float.class);\n+        checkConverterConversions(converter, VARCHAR, TINYINT, SMALLINT, INT, BIGINT, DECIMAL, DOUBLE, OBJECT);\n+\n+        float val = 1.1f;\n+\n+        assertEquals(\"1.1\", converter.asVarchar(val));\n+\n+        assertEquals(1, converter.asTinyint(val));\n+        assertEquals(1, converter.asSmallint(val));\n+        assertEquals(1, converter.asInt(val));\n+        assertEquals(1L, converter.asBigint(val));\n+        assertEquals(BigDecimal.valueOf(val), converter.asDecimal(val));\n+\n+        assertEquals(1.1f, converter.asReal(val), 0);\n+        assertEquals(1.1f, converter.asDouble(val), 0);\n+\n+        assertEquals(1.1f, converter.asObject(val));\n+\n+        checkConverterSelf(converter);\n+    }\n+\n+    @Test\n+    public void testDoubleConverter() {\n+        DoubleConverter converter = DoubleConverter.INSTANCE;\n+\n+        checkConverter(converter, Converter.ID_DOUBLE, DOUBLE, Double.class);\n+        checkConverterConversions(converter, VARCHAR, TINYINT, SMALLINT, INT, BIGINT, DECIMAL, REAL, OBJECT);\n+\n+        double val = 1.1d;\n+\n+        assertEquals(\"1.1\", converter.asVarchar(val));\n+\n+        assertEquals(1, converter.asTinyint(val));\n+        assertEquals(1, converter.asSmallint(val));\n+        assertEquals(1, converter.asInt(val));\n+        assertEquals(1L, converter.asBigint(val));\n+        assertEquals(BigDecimal.valueOf(val), converter.asDecimal(val));\n+\n+        assertEquals(1.1f, converter.asReal(val), 0);\n+        assertEquals(1.1d, converter.asDouble(val), 0);\n+\n+        assertEquals(1.1d, converter.asObject(val));\n+\n+        checkConverterSelf(converter);\n+    }\n+\n+    @Test\n+    public void testLocalTimeConverter() {\n+        LocalTimeConverter converter = LocalTimeConverter.INSTANCE;\n+\n+        checkConverter(converter, Converter.ID_LOCAL_TIME, TIME, LocalTime.class);\n+        checkConverterConversions(converter, VARCHAR, TIMESTAMP, TIMESTAMP_WITH_TIMEZONE, OBJECT);\n+\n+        String timeString = \"11:22:33.444\";\n+        LocalTime time = LocalTime.parse(timeString);\n+        LocalDate date = LocalDate.now();\n+        LocalDateTime dateTime = LocalDateTime.of(date, time);\n+        OffsetDateTime globalDateTime = OffsetDateTime.ofInstant(dateTime.toInstant(ZoneOffset.UTC), ZoneId.systemDefault());\n+\n+        assertEquals(timeString, converter.asVarchar(time));\n+        assertEquals(time, converter.asTime(time));\n+        assertEquals(dateTime, converter.asTimestamp(time));\n+        assertEquals(globalDateTime, converter.asTimestampWithTimezone(time));\n+\n+        checkConverterSelf(converter);\n+    }\n+\n+    @Test\n+    public void testLocalDateConverter() {\n+        LocalDateConverter converter = LocalDateConverter.INSTANCE;\n+\n+        checkConverter(converter, Converter.ID_LOCAL_DATE, DATE, LocalDate.class);\n+        checkConverterConversions(converter, VARCHAR, TIMESTAMP, TIMESTAMP_WITH_TIMEZONE, OBJECT);\n+\n+        String dateString = \"2020-02-02\";\n+        LocalDate date = LocalDate.parse(dateString);\n+        LocalDateTime dateTime = date.atStartOfDay();\n+        OffsetDateTime globalDateTime = OffsetDateTime.ofInstant(dateTime.toInstant(ZoneOffset.UTC), ZoneId.systemDefault());\n+\n+        assertEquals(dateString, converter.asVarchar(date));\n+        assertEquals(date, converter.asDate(date));\n+        assertEquals(dateTime, converter.asTimestamp(date));\n+        assertEquals(globalDateTime, converter.asTimestampWithTimezone(date));\n+\n+        checkConverterSelf(converter);\n+    }\n+\n+    @Test\n+    public void testLocalDateTimeConverter() {\n+        LocalDateTimeConverter converter = LocalDateTimeConverter.INSTANCE;\n+\n+        checkConverter(converter, Converter.ID_LOCAL_DATE_TIME, TIMESTAMP, LocalDateTime.class);\n+        checkConverterConversions(converter, VARCHAR, TIME, DATE, TIMESTAMP_WITH_TIMEZONE, OBJECT);\n+\n+        String dateTimeString = \"2020-02-02T11:22:33.444\";\n+        LocalDateTime dateTime = LocalDateTime.parse(dateTimeString);\n+        OffsetDateTime globalDateTime = OffsetDateTime.ofInstant(dateTime.toInstant(ZoneOffset.UTC), ZoneId.systemDefault());\n+\n+        assertEquals(dateTimeString, converter.asVarchar(dateTime));\n+        assertEquals(dateTime.toLocalDate(), converter.asDate(dateTime));\n+        assertEquals(dateTime.toLocalTime(), converter.asTime(dateTime));\n+        assertEquals(dateTime, converter.asTimestamp(dateTime));\n+        assertEquals(globalDateTime, converter.asTimestampWithTimezone(dateTime));\n+\n+        checkConverterSelf(converter);\n+    }\n+\n+    @Test\n+    public void testDateConverter() {\n+        DateConverter converter = DateConverter.INSTANCE;\n+\n+        checkConverter(converter, Converter.ID_DATE, TIMESTAMP_WITH_TIMEZONE, Date.class);\n+        checkConverterConversions(converter, VARCHAR, TIME, DATE, TIMESTAMP, OBJECT);\n+\n+        Date val = new Date();\n+\n+        checkTimestampWithTimezone(converter, val, OffsetDateTime.ofInstant(val.toInstant(), ZoneOffset.UTC));\n+\n+        checkConverterSelf(converter);\n+    }\n+\n+    @Test\n+    public void testCalendarConverter() {\n+        CalendarConverter converter = CalendarConverter.INSTANCE;\n+\n+        checkConverter(converter, Converter.ID_CALENDAR, TIMESTAMP_WITH_TIMEZONE, Calendar.class);\n+        checkConverterConversions(converter, VARCHAR, TIME, DATE, TIMESTAMP, OBJECT);\n+\n+        Calendar val = Calendar.getInstance();\n+\n+        checkTimestampWithTimezone(converter, val, OffsetDateTime.ofInstant(val.toInstant(), ZoneOffset.UTC));\n+\n+        checkConverterSelf(converter);\n+    }\n+\n+    @Test\n+    public void testInstantConverter() {\n+        InstantConverter converter = InstantConverter.INSTANCE;\n+\n+        checkConverter(converter, Converter.ID_INSTANT, TIMESTAMP_WITH_TIMEZONE, Instant.class);\n+        checkConverterConversions(converter, VARCHAR, TIME, DATE, TIMESTAMP, OBJECT);\n+\n+        Instant val = Instant.now();\n+\n+        checkTimestampWithTimezone(converter, val, OffsetDateTime.ofInstant(val, ZoneOffset.UTC));\n+\n+        checkConverterSelf(converter);\n+    }\n+\n+    @Test\n+    public void testOffsetDateTimeConverter() {\n+        OffsetDateTimeConverter converter = OffsetDateTimeConverter.INSTANCE;\n+\n+        checkConverter(converter, Converter.ID_OFFSET_DATE_TIME, TIMESTAMP_WITH_TIMEZONE, OffsetDateTime.class);\n+        checkConverterConversions(converter, VARCHAR, TIME, DATE, TIMESTAMP, OBJECT);\n+\n+        OffsetDateTime val = OffsetDateTime.now();\n+\n+        checkTimestampWithTimezone(converter, val, val);\n+\n+        checkConverterSelf(converter);\n+    }\n+\n+    @Test\n+    public void testZonedDateTimeConverter() {\n+        ZonedDateTimeConverter converter = ZonedDateTimeConverter.INSTANCE;\n+\n+        checkConverter(converter, Converter.ID_ZONED_DATE_TIME, TIMESTAMP_WITH_TIMEZONE, ZonedDateTime.class);\n+        checkConverterConversions(converter, VARCHAR, TIME, DATE, TIMESTAMP, OBJECT);\n+\n+        ZonedDateTime val = ZonedDateTime.now();\n+\n+        checkTimestampWithTimezone(converter, val, val.toOffsetDateTime());\n+\n+        checkConverterSelf(converter);\n+    }\n+\n+    @Test\n+    public void testStringConverter() {\n+        StringConverter c = StringConverter.INSTANCE;\n+\n+        checkConverter(c, Converter.ID_STRING, VARCHAR, String.class);\n+        checkConverterConversions(c,\n+            BIT, TINYINT, SMALLINT, INT, BIGINT, DECIMAL, REAL, DOUBLE, TIME, DATE, TIMESTAMP, TIMESTAMP_WITH_TIMEZONE, OBJECT);\n+\n+        // Boolean\n+        assertEquals(false, c.asBit(\"false\"));\n+        assertEquals(false, c.asBit(\"False\"));\n+        assertEquals(true, c.asBit(\"true\"));\n+        assertEquals(true, c.asBit(\"True\"));\n+        checkDataException(() -> c.asBit(\"0\"));\n+        checkDataException(() -> c.asBit(\"1\"));\n+\n+        // Numeric\n+        String invalid = \"invalid\";\n+\n+        assertEquals((byte) 1, c.asTinyint(\"1\"));\n+        checkDataException(() -> c.asTinyint(invalid));\n+\n+        assertEquals((short) 1, c.asSmallint(\"1\"));\n+        checkDataException(() -> c.asSmallint(invalid));\n+\n+        assertEquals(1, c.asInt(\"1\"));\n+        checkDataException(() -> c.asInt(invalid));\n+\n+        assertEquals(1L, c.asBigint(\"1\"));\n+        checkDataException(() -> c.asBigint(invalid));\n+\n+        assertEquals(new BigDecimal(\"1.1\"), c.asDecimal(\"1.1\"));\n+        checkDataException(() -> c.asDecimal(invalid));\n+\n+        assertEquals(1.1f, c.asReal(\"1.1\"), 0);\n+        checkDataException(() -> c.asReal(invalid));\n+\n+        assertEquals(1.1d, c.asDouble(\"1.1\"), 0);\n+        checkDataException(() -> c.asDouble(invalid));\n+\n+        // Temporal\n+        assertEquals(LocalTime.parse(\"11:22\"), c.asTime(\"11:22\"));\n+        assertEquals(LocalTime.parse(\"11:22:33\"), c.asTime(\"11:22:33\"));\n+        assertEquals(LocalTime.parse(\"11:22:33.444\"), c.asTime(\"11:22:33.444\"));\n+        assertEquals(LocalTime.parse(\"11:22:33.444444444\"), c.asTime(\"11:22:33.444444444\"));\n+        checkDataException(() -> c.asTime(\"33:22\"));\n+        checkDataException(() -> c.asTime(\"11:66\"));\n+        checkDataException(() -> c.asTime(\"11:22:66\"));\n+        checkDataException(() -> c.asTime(\"11:22:33.4444444444\"));\n+        checkDataException(() -> c.asTime(invalid));\n+\n+        assertEquals(LocalDate.parse(\"2020-01-01\"), c.asDate(\"2020-01-01\"));\n+        checkDataException(() -> c.asDate(\"2020-13-01\"));\n+        checkDataException(() -> c.asDate(\"2020-01-35\"));\n+        checkDataException(() -> c.asDate(invalid));\n+\n+        assertEquals(LocalDateTime.parse(\"2020-01-01T11:22\"), c.asTimestamp(\"2020-01-01T11:22\"));\n+        assertEquals(LocalDateTime.parse(\"2020-01-01T11:22:33\"), c.asTimestamp(\"2020-01-01T11:22:33\"));\n+        assertEquals(LocalDateTime.parse(\"2020-01-01T11:22:33.444\"), c.asTimestamp(\"2020-01-01T11:22:33.444\"));\n+        assertEquals(LocalDateTime.parse(\"2020-01-01T11:22:33.444444444\"), c.asTimestamp(\"2020-01-01T11:22:33.444444444\"));\n+        checkDataException(() -> c.asTimestamp(\"2020-13-01T11:22\"));\n+        checkDataException(() -> c.asTimestamp(\"2020-01-35T11:22\"));\n+        checkDataException(() -> c.asTimestamp(\"2020-01-01T33:22\"));\n+        checkDataException(() -> c.asTimestamp(\"2020-01-01T11:66\"));\n+        checkDataException(() -> c.asTimestamp(\"2020-01-01T11:22:66\"));\n+        checkDataException(() -> c.asTimestamp(\"2020-01-01T11:22:33.4444444444\"));\n+        checkDataException(() -> c.asTimestamp(invalid));\n+\n+        assertEquals(OffsetDateTime.parse(\"2020-01-01T11:22:33.444444444Z\"),\n+            c.asTimestampWithTimezone(\"2020-01-01T11:22:33.444444444Z\"));\n+        assertEquals(OffsetDateTime.parse(\"2020-01-01T11:22:33.444444444+01:00\"),\n+            c.asTimestampWithTimezone(\"2020-01-01T11:22:33.444444444+01:00\"));\n+        checkDataException(() -> c.asTimestampWithTimezone(invalid));\n+\n+        // Object\n+        assertEquals(\"val\", c.asObject(\"val\"));\n+\n+        checkConverterSelf(c);\n+    }\n+\n+    @Test\n+    public void testCharacterConverter() {\n+        CharacterConverter c = CharacterConverter.INSTANCE;\n+\n+        checkConverter(c, Converter.ID_CHARACTER, VARCHAR, Character.class);\n+        checkConverterConversions(c,\n+            BIT, TINYINT, SMALLINT, INT, BIGINT, DECIMAL, REAL, DOUBLE, TIME, DATE, TIMESTAMP, TIMESTAMP_WITH_TIMEZONE, OBJECT);\n+\n+        char invalid = 'c';\n+\n+        assertEquals((byte) 1, c.asTinyint('1'));\n+        checkDataException(() -> c.asTinyint(invalid));\n+\n+        assertEquals((short) 1, c.asSmallint('1'));\n+        checkDataException(() -> c.asSmallint(invalid));\n+\n+        assertEquals(1, c.asInt('1'));\n+        checkDataException(() -> c.asInt(invalid));\n+\n+        assertEquals(1L, c.asBigint('1'));\n+        checkDataException(() -> c.asBigint(invalid));\n+\n+        assertEquals(new BigDecimal(\"1\"), c.asDecimal('1'));\n+        checkDataException(() -> c.asDecimal(invalid));\n+\n+        assertEquals(1f, c.asReal('1'), 0);\n+        checkDataException(() -> c.asReal(invalid));\n+\n+        assertEquals(1d, c.asDouble('1'), 0);\n+        checkDataException(() -> c.asDouble(invalid));\n+\n+        assertEquals(\"c\", c.asObject('c'));\n+\n+        checkConverterSelf(c);\n+    }\n+\n+    @Test\n+    public void testObjectConverter() {\n+        ObjectConverter c = ObjectConverter.INSTANCE;\n+\n+        checkConverter(c, Converter.ID_OBJECT, OBJECT, Object.class);\n+        checkConverterConversions(c,\n+            BIT, TINYINT, SMALLINT, INT, BIGINT, DECIMAL, REAL, DOUBLE, TIME, DATE, TIMESTAMP, TIMESTAMP_WITH_TIMEZONE, VARCHAR);\n+\n+        checkObjectConverter(c);\n+\n+        checkConverterSelf(c);\n+    }\n+\n+    @Test\n+    public void testLateConverter() {\n+        LateConverter c = LateConverter.INSTANCE;\n+\n+        checkConverter(c, Converter.ID_LATE, LATE, null);\n+        checkConverterConversions(c, BIT, TINYINT, SMALLINT, INT, BIGINT, DECIMAL, REAL, DOUBLE, TIME, DATE, TIMESTAMP,\n+            TIMESTAMP_WITH_TIMEZONE, VARCHAR, OBJECT);\n+\n+        checkObjectConverter(c);\n+\n+        MockConverter mockConverter = new MockConverter();\n+        c.convertToSelf(mockConverter, new Object());\n+        assertTrue(mockConverter.isInvokedSelf());\n+    }\n+\n+    private void checkDataException(Runnable runnable) {\n+        try {\n+            runnable.run();\n+\n+            fail(\"Must fail\");\n+        } catch (HazelcastSqlException e) {\n+            assertEquals(SqlErrorCode.DATA_EXCEPTION, e.getCode());\n+        }\n+    }\n+\n+    private void checkTimestampWithTimezone(Converter converter, Object value, OffsetDateTime timestampWithTimezone) {\n+        LocalDateTime timestamp = timestampWithTimezone.atZoneSameInstant(ZoneId.systemDefault()).toLocalDateTime();\n+        LocalDate date = timestamp.toLocalDate();\n+        LocalTime time = timestamp.toLocalTime();\n+\n+        assertEquals(timestampWithTimezone.toString(), converter.asVarchar(value));\n+        assertEquals(date, converter.asDate(value));\n+        assertEquals(time, converter.asTime(value));\n+        assertEquals(timestamp, converter.asTimestamp(value));\n+        assertEquals(timestampWithTimezone, converter.asTimestampWithTimezone(value));\n+        assertEquals(timestampWithTimezone, converter.asObject(value));\n+    }\n+\n+    private void checkObjectConverter(Converter c) {\n+        // Boolean\n+        assertEquals(true, c.asBit(true));\n+        assertEquals(true, c.asBit(\"true\"));\n+        assertEquals(false, c.asBit(false));\n+        assertEquals(false, c.asBit(\"false\"));\n+        checkDataException(() -> c.asBit(\"1\"));\n+        checkDataException(() -> c.asBit(1));\n+        checkDataException(() -> c.asBit(new Object()));\n+\n+        // Numeric\n+        String invalid = \"invalid\";\n+\n+        assertEquals((byte) 1, c.asTinyint(1));\n+        assertEquals((byte) 1, c.asTinyint(\"1\"));\n+        checkDataException(() -> c.asTinyint(invalid));\n+\n+        assertEquals((short) 1, c.asSmallint(1));\n+        assertEquals((short) 1, c.asSmallint(\"1\"));\n+        checkDataException(() -> c.asSmallint(invalid));\n+\n+        assertEquals(1, c.asInt(1));\n+        assertEquals(1, c.asInt(\"1\"));\n+        checkDataException(() -> c.asInt(invalid));\n+\n+        assertEquals(1L, c.asBigint(1));\n+        assertEquals(1L, c.asBigint(\"1\"));\n+        checkDataException(() -> c.asBigint(invalid));\n+\n+        assertEquals(new BigDecimal(\"1.1\"), c.asDecimal(new BigDecimal(\"1.1\")));\n+        assertEquals(new BigDecimal(\"1.1\"), c.asDecimal(\"1.1\"));\n+        checkDataException(() -> c.asDecimal(invalid));\n+\n+        assertEquals(1.1f, c.asReal(1.1f), 0);\n+        assertEquals(1.1f, c.asReal(\"1.1\"), 0);\n+        checkDataException(() -> c.asReal(invalid));\n+\n+        assertEquals(1.1d, c.asDouble(1.1d), 0);\n+        assertEquals(1.1d, c.asDouble(\"1.1\"), 0);\n+        checkDataException(() -> c.asDouble(invalid));\n+\n+        // Temporal\n+        assertEquals(LocalTime.parse(\"11:22\"), c.asTime(LocalTime.parse(\"11:22\")));\n+        assertEquals(LocalTime.parse(\"11:22\"), c.asTime(LocalDateTime.parse(\"2020-01-01T11:22\")));\n+        assertEquals(LocalTime.parse(\"11:22\"), c.asTime(\"11:22\"));\n+        checkDataException(() -> c.asTime(invalid));\n+\n+        assertEquals(LocalDate.parse(\"2020-01-01\"), c.asDate(LocalDate.parse(\"2020-01-01\")));\n+        assertEquals(LocalDate.parse(\"2020-01-01\"), c.asDate(LocalDateTime.parse(\"2020-01-01T11:22:33\")));\n+        assertEquals(LocalDate.parse(\"2020-01-01\"), c.asDate(\"2020-01-01\"));\n+        checkDataException(() -> c.asDate(invalid));\n+\n+        assertEquals(LocalDateTime.parse(\"2020-01-01T11:22:33.444444444\"),\n+            c.asTimestamp(LocalDateTime.parse(\"2020-01-01T11:22:33.444444444\")));\n+        assertEquals(LocalDateTime.parse(\"2020-01-01T11:22:33.444444444\"), c.asTimestamp(\"2020-01-01T11:22:33.444444444\"));\n+        checkDataException(() -> c.asTimestamp(invalid));\n+\n+        assertEquals(OffsetDateTime.parse(\"2020-01-01T11:22:33.444444444+01:00\"),\n+            c.asTimestampWithTimezone(OffsetDateTime.parse(\"2020-01-01T11:22:33.444444444+01:00\")));\n+        assertEquals(OffsetDateTime.parse(\"2020-01-01T11:22:33.444444444+01:00\"),\n+            c.asTimestampWithTimezone(\"2020-01-01T11:22:33.444444444+01:00\"));\n+        checkDataException(() -> c.asTimestampWithTimezone(invalid));\n+\n+        // Strings.\n+        assertEquals(\"c\", c.asVarchar('c'));\n+        assertEquals(\"val\", c.asVarchar(\"val\"));\n+        assertEquals(\"2020-01-01T11:22:33.444444444\", c.asVarchar(LocalDateTime.parse(\"2020-01-01T11:22:33.444444444\")));\n+        assertEquals(new CustomClass(1).toString(), c.asVarchar(new CustomClass(1)));\n+\n+        // Object\n+        assertEquals(\"val\", c.asObject(\"val\"));\n+        assertEquals(1, c.asObject(1));\n+        assertEquals(new CustomClass(1), c.asObject(new CustomClass(1)));\n+    }\n+\n+    private void checkGetById(Converter converter) {\n+        Converter other = Converters.getConverter(converter.getId());\n+\n+        assertSame(converter, other);\n+    }\n+\n+    private void checkGetByClass(Converter expectedConverter, Class<?>... classes) {\n+        for (Class<?> clazz : classes) {\n+            Converter other = Converters.getConverter(clazz);\n+\n+            assertSame(expectedConverter, other);\n+        }\n+    }\n+\n+    private void checkConverter(\n+        Converter converter,\n+        int expectedId,\n+        QueryDataTypeFamily expectedTypeFamily,\n+        Class<?> expectedValueClass\n+    ) {\n+        assertEquals(expectedId, converter.getId());\n+        assertEquals(expectedTypeFamily, converter.getTypeFamily());\n+        assertEquals(expectedValueClass, converter.getValueClass());\n+    }\n+\n+    private void checkConverterConversions(Converter converter, QueryDataTypeFamily... expectedSupportedConversions) {\n+        Set<QueryDataTypeFamily> expectedSupportedConversions0 = new HashSet<>();\n+\n+        expectedSupportedConversions0.add(converter.getTypeFamily());\n+        expectedSupportedConversions0.addAll(Arrays.asList(expectedSupportedConversions));\n+\n+        for (QueryDataTypeFamily typeFamily : values()) {\n+            checkConverterConversion(converter, typeFamily, expectedSupportedConversions0.contains(typeFamily));\n+        }\n+    }\n+\n+    private void checkConverterConversion(Converter converter, QueryDataTypeFamily typeFamily, boolean expected) {\n+        assertEquals(typeFamily + \": \" + expected, expected, converter.canConvertTo(typeFamily));\n+\n+        switch (typeFamily) {\n+            case VARCHAR:\n+                assertEquals(expected, converter.canConvertToVarchar());\n+\n+                break;\n+\n+            case BIT:\n+                assertEquals(expected, converter.canConvertToBit());\n+\n+                break;\n+\n+            case TINYINT:\n+                assertEquals(expected, converter.canConvertToTinyint());\n+\n+                break;\n+\n+            case SMALLINT:\n+                assertEquals(expected, converter.canConvertToSmallint());\n+\n+                break;\n+\n+            case INT:\n+                assertEquals(expected, converter.canConvertToInt());\n+\n+                break;\n+\n+            case BIGINT:\n+                assertEquals(expected, converter.canConvertToBigint());\n+\n+                break;\n+\n+            case DECIMAL:\n+                assertEquals(expected, converter.canConvertToDecimal());\n+\n+                break;\n+\n+            case REAL:\n+                assertEquals(expected, converter.canConvertToReal());\n+\n+                break;\n+\n+            case DOUBLE:\n+                assertEquals(expected, converter.canConvertToDouble());\n+\n+                break;\n+\n+            case TIME:\n+                assertEquals(expected, converter.canConvertToTime());\n+\n+                break;\n+\n+            case DATE:\n+                assertEquals(expected, converter.canConvertToDate());\n+\n+                break;\n+\n+            case TIMESTAMP:\n+                assertEquals(expected, converter.canConvertToTimestamp());\n+\n+                break;\n+\n+            case TIMESTAMP_WITH_TIMEZONE:\n+                assertEquals(expected, converter.canConvertToTimestampWithTimezone());\n+\n+                break;\n+\n+            case OBJECT:\n+                assertEquals(expected, converter.canConvertToObject());\n+\n+                break;\n+        }\n+\n+        if (!expected) {\n+            checkCannotConvert(converter, typeFamily);\n+        }\n+    }\n+\n+    private void checkCannotConvert(Converter converter, QueryDataTypeFamily typeFamily) {\n+        try {\n+            Object val = new Object();\n+\n+            switch (typeFamily) {\n+                case VARCHAR:\n+                    converter.asVarchar(val);\n+\n+                    break;\n+\n+                case BIT:\n+                    converter.asBit(val);\n+\n+                    break;\n+\n+                case TINYINT:\n+                    converter.asTinyint(val);\n+\n+                    break;\n+\n+                case SMALLINT:\n+                    converter.asSmallint(val);\n+\n+                    break;\n+\n+                case INT:\n+                    converter.asInt(val);\n+\n+                    break;\n+\n+                case BIGINT:\n+                    converter.asBigint(val);\n+\n+                    break;\n+\n+                case DECIMAL:\n+                    converter.asDecimal(val);\n+\n+                    break;\n+\n+                case REAL:\n+                    converter.asReal(val);\n+\n+                    break;\n+\n+                case DOUBLE:\n+                    converter.asDouble(val);\n+\n+                    break;\n+\n+                case TIME:\n+                    converter.asTime(val);\n+\n+                    break;\n+\n+                case DATE:\n+                    converter.asDate(val);\n+\n+                    break;\n+\n+                case TIMESTAMP:\n+                    converter.asTimestamp(val);\n+\n+                    break;\n+\n+                case TIMESTAMP_WITH_TIMEZONE:\n+                    converter.asTimestampWithTimezone(val);\n+\n+                    break;\n+\n+                case OBJECT:\n+                    converter.asObject(val);\n+\n+                    break;\n+\n+                default:\n+                    return;\n+            }\n+\n+            fail(\"Must fail: \" + typeFamily);\n+        } catch (HazelcastSqlException e) {\n+            assertEquals(SqlErrorCode.DATA_EXCEPTION, e.getCode());\n+        }\n+    }\n+\n+    private void checkConverterSelf(Converter converter) {\n+        MockConverter mockConverter = new MockConverter();\n+\n+        converter.convertToSelf(mockConverter, new Object());\n+\n+        assertEquals(converter.getTypeFamily(), mockConverter.getInvoked());\n+    }\n+\n+    private static final class CustomClass {\n+        private int val;", "originalCommit": "24ad7231c6a7174e2e566475bcc59120e45a51e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzAwNDQ1MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16738#discussion_r393004451", "bodyText": "This class will go away in the next PR, where more tests are added. Its counterpart might be used in serialization, so I would avoid final here.", "author": "devozerov", "createdAt": "2020-03-16T12:58:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjk5NjAyNg=="}], "type": "inlineReview"}, {"oid": "76c5c7fa0493c5888169dd7b04cbf3d597133f8f", "url": "https://github.com/hazelcast/hazelcast/commit/76c5c7fa0493c5888169dd7b04cbf3d597133f8f", "message": "Review comments.", "committedDate": "2020-03-16T13:00:02Z", "type": "commit"}]}