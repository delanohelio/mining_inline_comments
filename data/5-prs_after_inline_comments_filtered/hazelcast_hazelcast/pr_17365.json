{"pr_number": 17365, "pr_title": "Support Jet SQL statements", "pr_createdAt": "2020-08-17T13:16:14Z", "pr_url": "https://github.com/hazelcast/hazelcast/pull/17365", "timeline": [{"oid": "2284a0b39ea5ced6bf923b3f87dfca6b7d318654", "url": "https://github.com/hazelcast/hazelcast/commit/2284a0b39ea5ced6bf923b3f87dfca6b7d318654", "message": "Support Jet SQL statements", "committedDate": "2020-08-17T13:13:19Z", "type": "commit"}, {"oid": "7ceb88c282ddc03e5003f118048fa3f359458249", "url": "https://github.com/hazelcast/hazelcast/commit/7ceb88c282ddc03e5003f118048fa3f359458249", "message": "Cleanup", "committedDate": "2020-08-17T13:18:33Z", "type": "commit"}, {"oid": "ceeb2ce1241cb5f5d082f602e501ad3a370be620", "url": "https://github.com/hazelcast/hazelcast/commit/ceeb2ce1241cb5f5d082f602e501ad3a370be620", "message": "Refactor HazelcastSqlBackend", "committedDate": "2020-08-17T13:27:09Z", "type": "commit"}, {"oid": "e2da70fd4e3a77a0a5238f8d25fc9e31c8089955", "url": "https://github.com/hazelcast/hazelcast/commit/e2da70fd4e3a77a0a5238f8d25fc9e31c8089955", "message": "Add QueryParser test", "committedDate": "2020-08-17T15:20:28Z", "type": "commit"}, {"oid": "59f53124a940801e2840fe54de1d78493602516c", "url": "https://github.com/hazelcast/hazelcast/commit/59f53124a940801e2840fe54de1d78493602516c", "message": "Make checkstyle happier", "committedDate": "2020-08-17T15:27:16Z", "type": "commit"}, {"oid": "aa1f11140f624fef7f8384ddd8a69911da36dd80", "url": "https://github.com/hazelcast/hazelcast/commit/aa1f11140f624fef7f8384ddd8a69911da36dd80", "message": "Add JetSqlService test", "committedDate": "2020-08-18T07:04:29Z", "type": "commit"}, {"oid": "41cb820d219126dd16bcbfc77737c734baa88a3f", "url": "https://github.com/hazelcast/hazelcast/commit/41cb820d219126dd16bcbfc77737c734baa88a3f", "message": "Merge branch 'master' into support-jet\n\n# Conflicts:\n#\thazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/parse/UnsupportedOperationVisitor.java", "committedDate": "2020-08-18T07:13:19Z", "type": "commit"}, {"oid": "c2679643c84f3e09f98a891e638596a25f47c8a6", "url": "https://github.com/hazelcast/hazelcast/commit/c2679643c84f3e09f98a891e638596a25f47c8a6", "message": "Make checkstyle happier", "committedDate": "2020-08-18T07:16:49Z", "type": "commit"}, {"oid": "80861199b4d0f086dfcd5344ec040fbe151e17d2", "url": "https://github.com/hazelcast/hazelcast/commit/80861199b4d0f086dfcd5344ec040fbe151e17d2", "message": "Make checkstyle happier", "committedDate": "2020-08-18T07:49:12Z", "type": "commit"}, {"oid": "72110803f1e35931fe5468f9db23baec593136f0", "url": "https://github.com/hazelcast/hazelcast/commit/72110803f1e35931fe5468f9db23baec593136f0", "message": "Fix test", "committedDate": "2020-08-18T09:06:54Z", "type": "commit"}, {"oid": "770f2b85cc63004bbaed451ccb12a1d4b2827eda", "url": "https://github.com/hazelcast/hazelcast/commit/770f2b85cc63004bbaed451ccb12a1d4b2827eda", "message": "Fix test", "committedDate": "2020-08-18T09:10:16Z", "type": "commit"}, {"oid": "5871fef9dde942c85c906a445a8103478542da3e", "url": "https://github.com/hazelcast/hazelcast/commit/5871fef9dde942c85c906a445a8103478542da3e", "message": "Make checkstyle happier", "committedDate": "2020-08-18T09:15:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3MjE2Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/17365#discussion_r472072167", "bodyText": "Why do we throw a new RuntimeException here? Will throw doneError; be proper to address #17160?", "author": "devozerov", "createdAt": "2020-08-18T10:17:59Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/root/BlockingRootResultConsumer.java", "diffHunk": "@@ -34,27 +33,32 @@\n     /** Iterator over produced rows. */\n     private final InternalIterator iterator = new InternalIterator();\n \n-    /** Query context to schedule root execution when the next batch is needed. */\n-    private volatile QueryFragmentContext context;\n+    /** A callback to schedule root execution when the next batch is needed. */\n+    private volatile ScheduleCallback scheduleCallback;\n \n     /** The batch that is currently being consumed. */\n     private List<Row> currentBatch;\n \n-    /** When \"true\" no more batches are expected. */\n+    /** When \"true\", no more batches are expected. */\n     private boolean done;\n \n     /** Error which occurred during query execution. */\n     private QueryException doneError;\n \n     @Override\n-    public void setup(QueryFragmentContext context) {\n-        this.context = context;\n+    public void setup(ScheduleCallback scheduleCallback) {\n+        this.scheduleCallback = scheduleCallback;\n     }\n \n     @Override\n     public boolean consume(List<Row> batch, boolean last) {\n         synchronized (mux) {\n-            assert !done;\n+            if (done) {\n+                // this is possible if the query was concurrently cancelled\n+                // see https://github.com/hazelcast/hazelcast/issues/17160\n+                assert doneError != null;\n+                throw new RuntimeException(doneError);", "originalCommit": "5871fef9dde942c85c906a445a8103478542da3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3NTEyNg==", "url": "https://github.com/hazelcast/hazelcast/pull/17365#discussion_r472075126", "bodyText": "We wrap in another RuntimeException to have a proper stack trace: we want a stack trace from the place where the exception was thrown, not where it was created. This exception is not propagated to the user, it is used to tear down the jet job after a cancellation and will be logged on the member. It also cancels the scheduled imdg task.\nYes, it's a fix to #17160.", "author": "viliam-durina", "createdAt": "2020-08-18T10:23:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3MjE2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA4MzQwMA==", "url": "https://github.com/hazelcast/hazelcast/pull/17365#discussion_r472083400", "bodyText": "Is this condition specific to Jet only?", "author": "devozerov", "createdAt": "2020-08-18T10:40:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3MjE2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjI0MDAyOA==", "url": "https://github.com/hazelcast/hazelcast/pull/17365#discussion_r472240028", "bodyText": "Nope, it's a general principle. Without this wrapping the stack trace will point you somewhere completely else than where the exception was actually thrown.", "author": "viliam-durina", "createdAt": "2020-08-18T14:28:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3MjE2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQxMTYxMA==", "url": "https://github.com/hazelcast/hazelcast/pull/17365#discussion_r472411610", "bodyText": "I do not quite get how it plays with the IMDG engine. First question - why we choose RuntimeException, while in all other parts of the engine we work with QueryException that carries additional information, which is eventually converted to public SqlException?\nThe second question is more important - why should we rethrow an exception at all? The idea of doneError is that this is an exception that is propagated to the user eventually. But consume is an internal method. From the IMDG perspective, there is no sense to throw an exception there, because the error is already reported, so the executor will be terminate soon anyway, and throwing another exception from consume will do nothing. Why do we need to throw an exception from here for Jet?", "author": "devozerov", "createdAt": "2020-08-18T18:54:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3MjE2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjc2NTg2Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/17365#discussion_r472765867", "bodyText": "Reverted that particular change", "author": "gierlachg", "createdAt": "2020-08-19T06:41:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3MjE2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjc3MTc5NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17365#discussion_r472771795", "bodyText": "But now we hit the problem with the wrong assert :-) What I meant is that for the IMDG engine, throwing error from here is basically no-op because the other error has already been installed. So the following code is most likely to work just fine:\npublic boolean consume(List<Row> batch, boolean last) {\n    synchronized (mux) {\n        if (done) {\n            return false;\n        }\n        ...\n    }  \n}\n\nIn this case, the RootExec will return WAIT and deactivate the fragment. This is ok because the original error already triggered cancel operation, which will clear the fragment eventually. Re-throwing the error here makes no difference because the original error is already installed, and the new error will be ignored in QueryState.cancel when doing CAS(null, error).\nThe question is whether Jet requires throwing an error from consume?", "author": "devozerov", "createdAt": "2020-08-19T06:49:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3MjE2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjc3MzkwNA==", "url": "https://github.com/hazelcast/hazelcast/pull/17365#discussion_r472773904", "bodyText": "I feel like addressing this issue should be part of a separate PR", "author": "gierlachg", "createdAt": "2020-08-19T06:52:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3MjE2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjgwNjg3Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/17365#discussion_r472806877", "bodyText": "I consider copying this whole class. It's tailored for IMDG needs, it's not a well-defined reusable API. For example, Jet doesn't need the setup or the callback. It's prone to incompatible changes in the future.\nThen the issue #17160 remains to be fixed by imdg guys.", "author": "viliam-durina", "createdAt": "2020-08-19T07:32:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3MjE2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3MzE3Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17365#discussion_r472073172", "bodyText": "Does Jet still require Expression to be serializable? Ideally, we should avoid adding Serializable here, since this is just an internal class that is passed over the wire, and is not meant to be serialized by some generic mechanism in IMDG\nSame question for QueryPath, QueryDataType, Converter", "author": "devozerov", "createdAt": "2020-08-18T10:20:00Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/Expression.java", "diffHunk": "@@ -20,12 +20,15 @@\n import com.hazelcast.sql.impl.row.Row;\n import com.hazelcast.sql.impl.type.QueryDataType;\n \n+import java.io.Serializable;\n+\n /**\n  * Defines expression contract for SQL.\n  *\n  * @param <T> the return type of this expression.\n  */\n-public interface Expression<T> extends DataSerializable {\n+public interface Expression<T> extends DataSerializable, Serializable {", "originalCommit": "5871fef9dde942c85c906a445a8103478542da3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjI0NDc3NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17365#discussion_r472244774", "bodyText": "I tried to fix this. It's doable, but it's extremely lot of extra code and the gain is little. We have to replace a simple serializable lambda with a class that implements DataSerializable and writes all the captured state manually. For example:\n\nI started with it but stopped after few hours with the light at the end of the tunnel still far ahead. We use lambdas everywhere and often wrap them in another lambdas to modify some behavior.\nThe benefit is little: it makes the job initialization slightly faster, but Jet never aimed at maximum job deployment performance. My guess is that the speedup is less than 1ms per job.", "author": "viliam-durina", "createdAt": "2020-08-18T14:34:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3MzE3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjI1MDAzNw==", "url": "https://github.com/hazelcast/hazelcast/pull/17365#discussion_r472250037", "bodyText": "Actually, I removed it from QueryPath", "author": "viliam-durina", "createdAt": "2020-08-18T14:41:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3MzE3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3NjcyMQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17365#discussion_r472076721", "bodyText": "Does Jet service have any state that needs to be cleaned or reinitialized on member stop or rejoin? If yes, we should consider adding callbacks to reset and shutdown methods.", "author": "devozerov", "createdAt": "2020-08-18T10:27:08Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/SqlServiceImpl.java", "diffHunk": "@@ -99,21 +104,31 @@ public SqlServiceImpl(NodeEngineImpl nodeEngine) {\n         assert operationPoolSize > 0;\n         assert queryTimeout >= 0L;\n \n+        this.executorPoolSize = executorPoolSize;\n+        this.operationPoolSize = operationPoolSize;\n         this.queryTimeout = queryTimeout;\n+    }\n \n-        nodeServiceProvider = new NodeServiceProviderImpl(nodeEngine);\n+    public void start() {\n+        try {\n+            jetSqlService = nodeEngine.getService(JetSqlService.SERVICE_NAME);", "originalCommit": "5871fef9dde942c85c906a445a8103478542da3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA4MTU4NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17365#discussion_r472081584", "bodyText": "They are not needed at the moment but maybe it's safer to add them now", "author": "gierlachg", "createdAt": "2020-08-18T10:36:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3NjcyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA4MjgyNQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17365#discussion_r472082825", "bodyText": "I also think so. It is better to have no-op implementations now rather than waiting for the next IMDG release in case the risk becomes real.", "author": "devozerov", "createdAt": "2020-08-18T10:39:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3NjcyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjc2NTk3OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17365#discussion_r472765979", "bodyText": "So it is done", "author": "gierlachg", "createdAt": "2020-08-19T06:41:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3NjcyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3ODc3MA==", "url": "https://github.com/hazelcast/hazelcast/pull/17365#discussion_r472078770", "bodyText": "What is the purpose of this whole check?", "author": "devozerov", "createdAt": "2020-08-18T10:31:20Z", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/parse/UnsupportedOperationVisitor.java", "diffHunk": "@@ -154,6 +161,16 @@ public Void visit(SqlNodeList nodeList) {\n \n     @Override\n     public Void visit(SqlIdentifier id) {\n+        SqlValidatorTable table = catalogReader.getTable(id.names);", "originalCommit": "5871fef9dde942c85c906a445a8103478542da3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA4MjQzOQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17365#discussion_r472082439", "bodyText": "For instance SELECT * FROM kafka should fail, even if all operators are supported by IMDG, it does not mean it can handle such statement", "author": "gierlachg", "createdAt": "2020-08-18T10:38:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3ODc3MA=="}], "type": "inlineReview"}, {"oid": "5da27a77f618208aa23e09e99d787cb64ff3ade6", "url": "https://github.com/hazelcast/hazelcast/commit/5da27a77f618208aa23e09e99d787cb64ff3ade6", "message": "Add reset() & shutdown() to JetSqlService", "committedDate": "2020-08-18T10:36:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA4MTIzNQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17365#discussion_r472081235", "bodyText": "Minor comment: I still have a worry that this interface might render insufficient for some commands in the future, which will block Jet from making some changes until the relevant codebase is adjusted in IMDG.\nI do not have any specific examples right now, so this is not a comment to address immediately. We just need to be aware of the alternative approach, where the backend just consumes the SqlQuery and produces the abstract result. In this case, the risk of required changes in IMDG will be minimal at the cost of more complicated backend implementation in Jet (possibly with some code duplication).\nHopefully, the current approach will work well enough for us.", "author": "devozerov", "createdAt": "2020-08-18T10:36:02Z", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/SqlBackend.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite;\n+\n+import com.hazelcast.sql.impl.calcite.parse.QueryParseResult;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeFactory;\n+import com.hazelcast.sql.impl.optimizer.OptimizationTask;\n+import com.hazelcast.sql.impl.optimizer.SqlPlan;\n+import org.apache.calcite.plan.RelOptCluster;\n+import org.apache.calcite.plan.RelOptTable;\n+import org.apache.calcite.prepare.Prepare;\n+import org.apache.calcite.prepare.Prepare.CatalogReader;\n+import org.apache.calcite.sql.parser.SqlParserImplFactory;\n+import org.apache.calcite.sql.util.SqlVisitor;\n+import org.apache.calcite.sql.validate.SqlConformance;\n+import org.apache.calcite.sql.validate.SqlValidator;\n+import org.apache.calcite.sql2rel.SqlRexConvertletTable;\n+import org.apache.calcite.sql2rel.SqlToRelConverter;\n+import org.apache.calcite.sql2rel.SqlToRelConverter.Config;\n+\n+/**\n+ * Provides various customization points for the optimization engine.\n+ */\n+public interface SqlBackend {", "originalCommit": "5871fef9dde942c85c906a445a8103478542da3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA5MzA0OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17365#discussion_r472093049", "bodyText": "Right, that would require duplicating fair amount of code. Not mentioning, we (Jet) would need to carefully monitor all the commits that go into sql module to replicate the changes on the Jet side (we want exactly same behavior for IMDG queries as if Jet would not be there). Moreover, the logic would most probably look exactly as it does currently in IMDG...\nRegarding unknown unknowns, I was thinking about introducing JetSqlService.execute(SqlQuery sql) - the logic would could go like this:\nif (jetSqlService != null) {\n    SqlResult result = jetSqlService.execute(query);\n    if (result != null) {\n         return result;\n    }\n}\n// otherwise continue with current flow\n\nRight now, we would leave it returning null but if we really encounter a case which does not fit the current solution we could plugin required logic until we get another IMDG release. WDYT?", "author": "gierlachg", "createdAt": "2020-08-18T10:59:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA4MTIzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA5NDg4MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17365#discussion_r472094881", "bodyText": "AFAIU we do not have concrete examples where the current approach doesn't work. So perhaps we may leave it as is for now.", "author": "devozerov", "createdAt": "2020-08-18T11:03:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA4MTIzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzcxMDkzNA==", "url": "https://github.com/hazelcast/hazelcast/pull/17365#discussion_r473710934", "bodyText": "Also, we might add a default method on the interface with the more generic signature. Shared code can be located in that method and it might call another, more concrete, method on the same interface. If at some point jet needs more control, it can switch from implementing the more concrete method to implementing the more generic method. Hopefully this comment makes sense :)", "author": "mmedenjak", "createdAt": "2020-08-20T07:43:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA4MTIzNQ=="}], "type": "inlineReview"}, {"oid": "e03f50cbbf4c3304dc7708e9153e8b7a610767c3", "url": "https://github.com/hazelcast/hazelcast/commit/e03f50cbbf4c3304dc7708e9153e8b7a610767c3", "message": "QueryPath doesn't need to be Serializable", "committedDate": "2020-08-18T14:39:37Z", "type": "commit"}, {"oid": "fdfca2f03d0c70a414390d4670aec014c7f43208", "url": "https://github.com/hazelcast/hazelcast/commit/fdfca2f03d0c70a414390d4670aec014c7f43208", "message": "Revert retrhrowing doneError", "committedDate": "2020-08-19T06:40:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjgwNDMxMw==", "url": "https://github.com/hazelcast/hazelcast/pull/17365#discussion_r472804313", "bodyText": "As far as I see, this is not a client test. TestHazelcastInstanceFactory should be enough instead of this one.", "author": "sancar", "createdAt": "2020-08-19T07:29:13Z", "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/impl/JetSqlTest.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.hazelcast.client.test.TestHazelcastFactory;\n+import com.hazelcast.config.Config;\n+import com.hazelcast.core.HazelcastInstance;\n+import com.hazelcast.instance.impl.DefaultNodeExtension;\n+import com.hazelcast.instance.impl.Node;\n+import com.hazelcast.instance.impl.NodeContext;\n+import com.hazelcast.instance.impl.NodeExtension;\n+import com.hazelcast.spi.impl.NodeEngine;\n+import com.hazelcast.sql.SqlResult;\n+import com.hazelcast.sql.impl.calcite.SqlBackend;\n+import com.hazelcast.sql.impl.optimizer.OptimizationTask;\n+import com.hazelcast.sql.impl.optimizer.SqlOptimizer;\n+import com.hazelcast.sql.impl.optimizer.SqlPlan;\n+import com.hazelcast.sql.impl.plan.cache.PlanObjectKey;\n+import com.hazelcast.sql.impl.schema.ConstantTableStatistics;\n+import com.hazelcast.sql.impl.schema.Table;\n+import com.hazelcast.sql.impl.schema.TableResolver;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import com.hazelcast.test.mocknetwork.MockNodeContext;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+\n+import java.util.Map;\n+\n+import static com.hazelcast.instance.impl.HazelcastInstanceFactory.newHazelcastInstance;\n+import static com.hazelcast.sql.impl.QueryUtils.CATALOG;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.singletonList;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.anyList;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.BDDMockito.given;\n+import static org.mockito.Mockito.mock;\n+\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class JetSqlTest extends SqlTestSupport {\n+\n+    private static final TestHazelcastFactory FACTORY = new TestHazelcastFactory(1);", "originalCommit": "fdfca2f03d0c70a414390d4670aec014c7f43208", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d7b9c3be0b7d3194b571cb8b7c51a7a60559612c", "url": "https://github.com/hazelcast/hazelcast/commit/d7b9c3be0b7d3194b571cb8b7c51a7a60559612c", "message": "Use TestHazelcastInstanceFactory in JetSqlTest", "committedDate": "2020-08-19T07:30:48Z", "type": "commit"}, {"oid": "1888e9be3934632f7dd79bdd11299aa740f0b6c9", "url": "https://github.com/hazelcast/hazelcast/commit/1888e9be3934632f7dd79bdd11299aa740f0b6c9", "message": "Add JetSqlService nullability check in reset & shutdown...", "committedDate": "2020-08-19T08:05:53Z", "type": "commit"}, {"oid": "643d0fd0f94c640abe845fc02a9fbde09e4fae77", "url": "https://github.com/hazelcast/hazelcast/commit/643d0fd0f94c640abe845fc02a9fbde09e4fae77", "message": "Merge branch 'master' into support-jet", "committedDate": "2020-08-19T09:59:11Z", "type": "commit"}, {"oid": "fd965a6039cc2367102960f604b5b33677204b48", "url": "https://github.com/hazelcast/hazelcast/commit/fd965a6039cc2367102960f604b5b33677204b48", "message": "Add InternalService nullability check in reset & shutdown...", "committedDate": "2020-08-19T10:27:21Z", "type": "commit"}]}