{"pr_number": 17985, "pr_title": "New SQL threading model [IMDG-127]", "pr_createdAt": "2020-12-18T10:47:53Z", "pr_url": "https://github.com/hazelcast/hazelcast/pull/17985", "timeline": [{"oid": "59cf3ac4c58a35abdfdb275b21bd7428d0dfd5b7", "url": "https://github.com/hazelcast/hazelcast/commit/59cf3ac4c58a35abdfdb275b21bd7428d0dfd5b7", "message": "New pools", "committedDate": "2020-09-17T12:05:45Z", "type": "commit"}, {"oid": "5aeb00050ca87257b9bcfab67705cdc43073648f", "url": "https://github.com/hazelcast/hazelcast/commit/5aeb00050ca87257b9bcfab67705cdc43073648f", "message": "Minors", "committedDate": "2020-09-17T12:08:03Z", "type": "commit"}, {"oid": "74625a22c333c3b39003ed406a762fdb8962d5d7", "url": "https://github.com/hazelcast/hazelcast/commit/74625a22c333c3b39003ed406a762fdb8962d5d7", "message": "WIP", "committedDate": "2020-09-17T16:46:15Z", "type": "commit"}, {"oid": "47415d3d1a8efc79f30da06759a788dcb396d453", "url": "https://github.com/hazelcast/hazelcast/commit/47415d3d1a8efc79f30da06759a788dcb396d453", "message": "Flow control", "committedDate": "2020-09-17T17:05:42Z", "type": "commit"}, {"oid": "a63efc30c29e27cd01ebfd653d989d5c6d1152bc", "url": "https://github.com/hazelcast/hazelcast/commit/a63efc30c29e27cd01ebfd653d989d5c6d1152bc", "message": "Cancel rework", "committedDate": "2020-09-17T17:37:07Z", "type": "commit"}, {"oid": "e012ba09b435fb41b0e45145f187d6de6296f898", "url": "https://github.com/hazelcast/hazelcast/commit/e012ba09b435fb41b0e45145f187d6de6296f898", "message": "WIP", "committedDate": "2020-09-18T07:21:32Z", "type": "commit"}, {"oid": "517751d5353bc7f8cc0e89101fe4c9cfdfc4f0b6", "url": "https://github.com/hazelcast/hazelcast/commit/517751d5353bc7f8cc0e89101fe4c9cfdfc4f0b6", "message": "WIP", "committedDate": "2020-09-18T09:18:45Z", "type": "commit"}, {"oid": "5dfaf76c6631b7d9727d4009dc68b087e4a0fd2c", "url": "https://github.com/hazelcast/hazelcast/commit/5dfaf76c6631b7d9727d4009dc68b087e4a0fd2c", "message": "Merge branch 'master' into sql-threading", "committedDate": "2020-09-18T10:09:11Z", "type": "commit"}, {"oid": "423f173689f5b40520fb3592aac796a298a95068", "url": "https://github.com/hazelcast/hazelcast/commit/423f173689f5b40520fb3592aac796a298a95068", "message": "Merge branch 'before-module-split' into sql-threading\n\n# Conflicts:\n#\thazelcast-sql/src/test/java/com/hazelcast/sql/index/SqlIndexTest.java\n#\thazelcast/src/main/java/com/hazelcast/internal/nio/Packet.java\n#\thazelcast/src/main/java/com/hazelcast/sql/impl/operation/QueryOperationHandlerImpl.java\n#\thazelcast/src/main/java/com/hazelcast/sql/impl/worker/QueryPoolTask.java\n#\thazelcast/src/test/java/com/hazelcast/sql/impl/operation/QueryOperationChannelTest.java\n#\thazelcast/src/test/java/com/hazelcast/sql/impl/operation/QueryOperationHandlerTest.java\n#\thazelcast/src/test/java/com/hazelcast/sql/impl/state/QueryStateRegistryTest.java\n#\thazelcast/src/test/java/com/hazelcast/test/HazelcastTestSupport.java", "committedDate": "2020-12-15T09:28:12Z", "type": "commit"}, {"oid": "1a52e39698ffd2cba430be8b38b59e2cf2f964a4", "url": "https://github.com/hazelcast/hazelcast/commit/1a52e39698ffd2cba430be8b38b59e2cf2f964a4", "message": "WIP", "committedDate": "2020-12-15T09:37:38Z", "type": "commit"}, {"oid": "fc278b8c0958177e4093039568a10bc308cfc0bd", "url": "https://github.com/hazelcast/hazelcast/commit/fc278b8c0958177e4093039568a10bc308cfc0bd", "message": "WIP", "committedDate": "2020-12-15T09:41:09Z", "type": "commit"}, {"oid": "44c15cbcae86deaa6836af481e32e727b44c0e1c", "url": "https://github.com/hazelcast/hazelcast/commit/44c15cbcae86deaa6836af481e32e727b44c0e1c", "message": "WIP", "committedDate": "2020-12-15T09:42:01Z", "type": "commit"}, {"oid": "8c184c9bf070ef5287bca52af81c3197c6c92465", "url": "https://github.com/hazelcast/hazelcast/commit/8c184c9bf070ef5287bca52af81c3197c6c92465", "message": "Merge branch 'master' into sql-threading", "committedDate": "2020-12-15T09:42:24Z", "type": "commit"}, {"oid": "35469f5a874cc2708e0862dcb3395502777b1685", "url": "https://github.com/hazelcast/hazelcast/commit/35469f5a874cc2708e0862dcb3395502777b1685", "message": "Checkstyle", "committedDate": "2020-12-15T09:49:08Z", "type": "commit"}, {"oid": "6d1be36111458563b384eb8549144e7166fc03ad", "url": "https://github.com/hazelcast/hazelcast/commit/6d1be36111458563b384eb8549144e7166fc03ad", "message": "WIP", "committedDate": "2020-12-15T10:06:49Z", "type": "commit"}, {"oid": "250baa8a0ad4fce814d827df4158b3028347a5cb", "url": "https://github.com/hazelcast/hazelcast/commit/250baa8a0ad4fce814d827df4158b3028347a5cb", "message": "Fixing", "committedDate": "2020-12-15T11:05:56Z", "type": "commit"}, {"oid": "ee98c91db153c9e4ef44210161f73fc27689f94e", "url": "https://github.com/hazelcast/hazelcast/commit/ee98c91db153c9e4ef44210161f73fc27689f94e", "message": "Docs", "committedDate": "2020-12-16T08:09:22Z", "type": "commit"}, {"oid": "4783ce963a9de0352df2391357f3bdfd2c23e2ca", "url": "https://github.com/hazelcast/hazelcast/commit/4783ce963a9de0352df2391357f3bdfd2c23e2ca", "message": "WIP", "committedDate": "2020-12-16T08:10:32Z", "type": "commit"}, {"oid": "1c5367c98161d7a076fe1bfff3bc8207870dd0b7", "url": "https://github.com/hazelcast/hazelcast/commit/1c5367c98161d7a076fe1bfff3bc8207870dd0b7", "message": "WIP", "committedDate": "2020-12-16T08:18:44Z", "type": "commit"}, {"oid": "aec38c67d47fcd9cbbf06fd25233be45bb0c46e2", "url": "https://github.com/hazelcast/hazelcast/commit/aec38c67d47fcd9cbbf06fd25233be45bb0c46e2", "message": "WIP", "committedDate": "2020-12-16T08:26:12Z", "type": "commit"}, {"oid": "1b2a5112d028f56afc0f0c1184c56f676b86672d", "url": "https://github.com/hazelcast/hazelcast/commit/1b2a5112d028f56afc0f0c1184c56f676b86672d", "message": "WIP on the new test", "committedDate": "2020-12-16T11:22:38Z", "type": "commit"}, {"oid": "56a6ce018a6560d16eac96140c261ab07753422c", "url": "https://github.com/hazelcast/hazelcast/commit/56a6ce018a6560d16eac96140c261ab07753422c", "message": "WIP on tests.", "committedDate": "2020-12-17T09:34:08Z", "type": "commit"}, {"oid": "9bc4a57b6d78f3145be8415a10ead86c7ec3c590", "url": "https://github.com/hazelcast/hazelcast/commit/9bc4a57b6d78f3145be8415a10ead86c7ec3c590", "message": "WIP on tests", "committedDate": "2020-12-17T09:37:56Z", "type": "commit"}, {"oid": "ac02f13ba575c098112dd3b80a67bbd0d9668c22", "url": "https://github.com/hazelcast/hazelcast/commit/ac02f13ba575c098112dd3b80a67bbd0d9668c22", "message": "WIP", "committedDate": "2020-12-17T09:39:25Z", "type": "commit"}, {"oid": "28194f644d94e7520a22beeca4032e7b730d82fa", "url": "https://github.com/hazelcast/hazelcast/commit/28194f644d94e7520a22beeca4032e7b730d82fa", "message": "WIP", "committedDate": "2020-12-17T09:47:12Z", "type": "commit"}, {"oid": "fa6c2742cb5f6b72d00bf16890c0da8249f97116", "url": "https://github.com/hazelcast/hazelcast/commit/fa6c2742cb5f6b72d00bf16890c0da8249f97116", "message": "Tests", "committedDate": "2020-12-17T10:10:47Z", "type": "commit"}, {"oid": "9067621550b8186cb17058164ab0617fde768cc9", "url": "https://github.com/hazelcast/hazelcast/commit/9067621550b8186cb17058164ab0617fde768cc9", "message": "WIP", "committedDate": "2020-12-17T10:23:34Z", "type": "commit"}, {"oid": "f000031d70e1611f97471adc914cdcc1e7fed650", "url": "https://github.com/hazelcast/hazelcast/commit/f000031d70e1611f97471adc914cdcc1e7fed650", "message": "WIP on tests", "committedDate": "2020-12-17T10:37:12Z", "type": "commit"}, {"oid": "5407c61ece0607b3b43c2c52116725792eaf3bdb", "url": "https://github.com/hazelcast/hazelcast/commit/5407c61ece0607b3b43c2c52116725792eaf3bdb", "message": "WIP", "committedDate": "2020-12-17T11:09:56Z", "type": "commit"}, {"oid": "b75df1d0c03c06cad95dca1f241596b02179f101", "url": "https://github.com/hazelcast/hazelcast/commit/b75df1d0c03c06cad95dca1f241596b02179f101", "message": "WIP", "committedDate": "2020-12-17T12:03:23Z", "type": "commit"}, {"oid": "676c49ca122536931398097bfa972f93d6064c06", "url": "https://github.com/hazelcast/hazelcast/commit/676c49ca122536931398097bfa972f93d6064c06", "message": "Added tests for initiator, they hang", "committedDate": "2020-12-17T12:14:06Z", "type": "commit"}, {"oid": "4ea634cafbcb9fb8c6f9879c71ee157334db1726", "url": "https://github.com/hazelcast/hazelcast/commit/4ea634cafbcb9fb8c6f9879c71ee157334db1726", "message": "Tests for both initiator and participant", "committedDate": "2020-12-17T12:53:54Z", "type": "commit"}, {"oid": "a9795880d5d4c247afcca328d46dd3c33568c7b9", "url": "https://github.com/hazelcast/hazelcast/commit/a9795880d5d4c247afcca328d46dd3c33568c7b9", "message": "WIP", "committedDate": "2020-12-17T12:55:10Z", "type": "commit"}, {"oid": "d728e4b25326bf3da3e2f3ceb5da17b1f1dc42e4", "url": "https://github.com/hazelcast/hazelcast/commit/d728e4b25326bf3da3e2f3ceb5da17b1f1dc42e4", "message": "Asserting proper thread pool", "committedDate": "2020-12-18T07:03:31Z", "type": "commit"}, {"oid": "c7473bbb4f040f22a0999e0917f26645ee10a5f0", "url": "https://github.com/hazelcast/hazelcast/commit/c7473bbb4f040f22a0999e0917f26645ee10a5f0", "message": "Fix vertical parallelism", "committedDate": "2020-12-18T08:20:19Z", "type": "commit"}, {"oid": "460e8b0dd5e2bae526de6541fc480ce74c4074a3", "url": "https://github.com/hazelcast/hazelcast/commit/460e8b0dd5e2bae526de6541fc480ce74c4074a3", "message": "Design docs adjustment.", "committedDate": "2020-12-18T08:39:30Z", "type": "commit"}, {"oid": "fc45e07cc28afbb55685ab93211f6219025dadae", "url": "https://github.com/hazelcast/hazelcast/commit/fc45e07cc28afbb55685ab93211f6219025dadae", "message": "Remove operation thread pool size config.", "committedDate": "2020-12-18T10:46:18Z", "type": "commit"}, {"oid": "6cc735b5ebb10b3c76949057f0e89525fa0d637a", "url": "https://github.com/hazelcast/hazelcast/commit/6cc735b5ebb10b3c76949057f0e89525fa0d637a", "message": "Merge branch 'master' into sql-threading", "committedDate": "2020-12-18T10:46:29Z", "type": "commit"}, {"oid": "e02dc88ca7afd4429dd3873709448470ed917f76", "url": "https://github.com/hazelcast/hazelcast/commit/e02dc88ca7afd4429dd3873709448470ed917f76", "message": "Propagate ordered flag.", "committedDate": "2020-12-18T11:31:36Z", "type": "commit"}, {"oid": "516199c8eabfdc5a10ebc775ee86f0e73b555eb0", "url": "https://github.com/hazelcast/hazelcast/commit/516199c8eabfdc5a10ebc775ee86f0e73b555eb0", "message": "Added missing default ctor.", "committedDate": "2020-12-18T11:41:01Z", "type": "commit"}, {"oid": "12efe8e13ff383b4454e925e8e2566af8561b2f4", "url": "https://github.com/hazelcast/hazelcast/commit/12efe8e13ff383b4454e925e8e2566af8561b2f4", "message": "Merge branch 'master' into sql-threading\n\n# Conflicts:\n#\thazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/opt/physical/visitor/PlanCreateVisitor.java", "committedDate": "2021-01-19T09:11:55Z", "type": "commit"}, {"oid": "767cd634418ebe27ac73f44650e4a7cd7416954f", "url": "https://github.com/hazelcast/hazelcast/commit/767cd634418ebe27ac73f44650e4a7cd7416954f", "message": "Merge branch 'master' into sql-threading\n\n# Conflicts:\n#\thazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/opt/physical/visitor/PlanCreateVisitor.java\n#\thazelcast/src/test/java/com/hazelcast/sql/impl/operation/QueryOperationHandlerTest.java", "committedDate": "2021-01-26T12:03:10Z", "type": "commit"}, {"oid": "5710f85b73b562b711175fec11c6bfd0ade60cc8", "url": "https://github.com/hazelcast/hazelcast/commit/5710f85b73b562b711175fec11c6bfd0ade60cc8", "message": "Compilation fixes.", "committedDate": "2021-01-26T12:10:54Z", "type": "commit"}, {"oid": "6729f32d1c1acb2902fe012bfdac6b05b13c4add", "url": "https://github.com/hazelcast/hazelcast/commit/6729f32d1c1acb2902fe012bfdac6b05b13c4add", "message": "Merge branch 'master' into sql-threading", "committedDate": "2021-02-01T08:39:40Z", "type": "commit"}, {"oid": "d498e1d50a503e5c663a9648c2dd67b943915d4a", "url": "https://github.com/hazelcast/hazelcast/commit/d498e1d50a503e5c663a9648c2dd67b943915d4a", "message": "Fixes after merge.", "committedDate": "2021-02-01T08:45:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Nzg1OTI0NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17985#discussion_r567859245", "bodyText": "minor: at this point, assuming this has not escaped, you can just set(true).", "author": "vbekiaris", "createdAt": "2021-02-01T14:19:55Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/state/QueryState.java", "diffHunk": "@@ -98,6 +106,14 @@ private QueryState(\n \n         startTime = clockProvider.currentTimeMillis();\n         checkTime = startTime;\n+\n+        this.cancelled = cancelled;\n+\n+        if (cancelled) {\n+            completionGuard.compareAndSet(false, true);", "originalCommit": "d498e1d50a503e5c663a9648c2dd67b943915d4a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODQzMzU1Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/17985#discussion_r568433557", "bodyText": "Good catch, thanks. Fixed.", "author": "devozerov", "createdAt": "2021-02-02T09:07:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Nzg1OTI0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Nzg4Nzg1NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17985#discussion_r567887855", "bodyText": "Seems like those two volatile variables are actually assigned constant values (SqlServiceImpl#STATE_CHECK_FREQUENCY and DEFAULT_ORPHANED_QUERY_STATE_CHECK_FREQUENCY). They could be final,  except for test code. Can we make them final and override their values in tests via properties? eg\nprivate final long stateCheckFrequency = Long.getLong(\"hazelcast.sql.stateCheckFrequency\", 1_000L);\n...\n// test code\n@Rule\npublic OverridePropertyRule setStateCheckFreq = set(\"hazelcast.sql.stateCheckFrequency\", \"100\");\n\nIf that is not a viable alternative, then we should add comments so that the reason for being volatile is clear.", "author": "vbekiaris", "createdAt": "2021-02-01T14:57:34Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/state/QueryStateRegistryUpdater.java", "diffHunk": "@@ -37,12 +37,15 @@\n  */\n public class QueryStateRegistryUpdater {\n \n+    private static final long DEFAULT_ORPHANED_QUERY_STATE_CHECK_FREQUENCY = 30_000L;\n+\n     private final NodeServiceProvider nodeServiceProvider;\n     private final QueryStateRegistry stateRegistry;\n     private final QueryClientStateRegistry clientStateRegistry;\n     private final QueryOperationHandler operationHandler;\n     private final PlanCacheChecker planCacheChecker;\n-    private final long stateCheckFrequency;\n+    private volatile long stateCheckFrequency;\n+    private volatile long orphanedQueryStateCheckFrequency = DEFAULT_ORPHANED_QUERY_STATE_CHECK_FREQUENCY;", "originalCommit": "d498e1d50a503e5c663a9648c2dd67b943915d4a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODQzNDE2NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17985#discussion_r568434165", "bodyText": "Added comments. We cannot use properties, because in our tests we need to change the value for the already created instance.", "author": "devozerov", "createdAt": "2021-02-02T09:08:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Nzg4Nzg1NQ=="}], "type": "inlineReview"}, {"oid": "236828966ad577d989ee787435faa86185bda7ee", "url": "https://github.com/hazelcast/hazelcast/commit/236828966ad577d989ee787435faa86185bda7ee", "message": "Address review comments.", "committedDate": "2021-02-02T09:05:22Z", "type": "commit"}, {"oid": "ed07dae7aa103fbc2ba9f332b1ff7689e0e976db", "url": "https://github.com/hazelcast/hazelcast/commit/ed07dae7aa103fbc2ba9f332b1ff7689e0e976db", "message": "Merge branch 'master' into sql-threading\n\n# Conflicts:\n#\thazelcast/src/main/java/com/hazelcast/sql/impl/operation/QueryOperationHandlerImpl.java\n#\thazelcast/src/main/java/com/hazelcast/sql/impl/worker/QueryFragmentExecutable.java\n#\thazelcast/src/test/java/com/hazelcast/sql/impl/worker/QueryFragmentExecutableTest.java", "committedDate": "2021-02-02T09:47:34Z", "type": "commit"}, {"oid": "193d98f1058fa7ab2b59a1fbcda346fed222edf3", "url": "https://github.com/hazelcast/hazelcast/commit/193d98f1058fa7ab2b59a1fbcda346fed222edf3", "message": "Split slow \"ORDER BY\" test.", "committedDate": "2021-02-02T09:56:33Z", "type": "commit"}, {"oid": "aaf143f69c2b923e9addd60ec8562f5aec1b4227", "url": "https://github.com/hazelcast/hazelcast/commit/aaf143f69c2b923e9addd60ec8562f5aec1b4227", "message": "Split slow \"ORDER BY\" test.", "committedDate": "2021-02-02T09:57:25Z", "type": "commit"}, {"oid": "1963491ff831f30748b8bdf94beee44c666dfb37", "url": "https://github.com/hazelcast/hazelcast/commit/1963491ff831f30748b8bdf94beee44c666dfb37", "message": "Merge branch 'master' into sql-threading\n\n# Conflicts:\n#\thazelcast/src/main/java/com/hazelcast/sql/impl/operation/QueryOperationChannelImpl.java\n#\thazelcast/src/main/java/com/hazelcast/sql/impl/worker/QueryFragmentWorkerPool.java\n#\thazelcast/src/test/java/com/hazelcast/sql/impl/operation/QueryOperationChannelTest.java", "committedDate": "2021-02-03T11:16:27Z", "type": "commit"}, {"oid": "355bf76a5dc7cbfa65af11f842cc444f3e046e39", "url": "https://github.com/hazelcast/hazelcast/commit/355bf76a5dc7cbfa65af11f842cc444f3e046e39", "message": "Fix checkstyle.", "committedDate": "2021-02-03T11:19:17Z", "type": "commit"}, {"oid": "e66bcc2c4e15171d6e35ee33b4f70b29b5d187ef", "url": "https://github.com/hazelcast/hazelcast/commit/e66bcc2c4e15171d6e35ee33b4f70b29b5d187ef", "message": "Minor changes", "committedDate": "2021-02-03T13:59:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTI3MjEwNw==", "url": "https://github.com/hazelcast/hazelcast/pull/17985#discussion_r569272107", "bodyText": "Style note: I'm wondering why don't we have the execute method on the operation?", "author": "viliam-durina", "createdAt": "2021-02-03T09:48:57Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/operation/QueryOperationHandlerImpl.java", "diffHunk": "@@ -131,31 +145,18 @@ public boolean submitRemote(UUID callerId, Connection connection, QueryOperation\n         }\n     }\n \n-    @Override\n-    public QueryOperationChannel createChannel(UUID sourceMemberId, UUID targetMemberId) {\n-        if (targetMemberId.equals(getLocalMemberId())) {\n-            return new QueryOperationChannelImpl(this, sourceMemberId, null);\n-        } else {\n-            Connection connection = getConnection(targetMemberId);\n-\n-            if (connection == null) {\n-                throw QueryException.memberConnection(targetMemberId);\n-            }\n-\n-            return new QueryOperationChannelImpl(this, sourceMemberId, connection);\n-        }\n-    }\n-\n     @Override\n     public void execute(QueryOperation operation) {\n+        assert operation.isSystem() == QueryOperationWorkerPool.isSystemThread();\n+\n         if (operation instanceof QueryExecuteOperation) {\n             handleExecute((QueryExecuteOperation) operation);\n-        } else if (operation instanceof QueryBatchExchangeOperation) {\n-            handleBatch((QueryBatchExchangeOperation) operation);\n+        } else if (operation instanceof QueryExecuteFragmentOperation) {", "originalCommit": "aaf143f69c2b923e9addd60ec8562f5aec1b4227", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTk5NjUzNA==", "url": "https://github.com/hazelcast/hazelcast/pull/17985#discussion_r569996534", "bodyText": "Just a way to organize the code. Currently, messages are POJOs, and the logic is concentrated in the QueryOperationHandlerImpl. Otherwise, we would have to pass some context/state to messages, which may make the code a little bit more complicated. But in any case, this is primarily about styling. Both approaches work.", "author": "devozerov", "createdAt": "2021-02-04T07:22:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTI3MjEwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTI4MDAyNA==", "url": "https://github.com/hazelcast/hazelcast/pull/17985#discussion_r569280024", "bodyText": "This whole javadoc is an exact copy of the javadoc of onDistributedQueryStarted. I think we should delete it.", "author": "viliam-durina", "createdAt": "2021-02-03T09:59:34Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/state/QueryStateRegistry.java", "diffHunk": "@@ -90,17 +90,50 @@ public QueryState onInitiatorQueryStarted(\n      * of these events. This is not a problem, because {@link QueryStateRegistryUpdater} will eventually detect that\n      * the query is not longer active on the initiator member.\n      *\n-     * @param localMemberId Cache local member ID.\n-     * @param queryId Query ID.\n-     * @param completionCallback Callback that will be invoked when the query is completed.\n-     * @return Query state or {@code null} if the query with the given ID is guaranteed to be already completed.\n+     * @param localMemberId cached local member ID\n+     * @param queryId query ID\n+     * @param completionCallback callback that will be invoked when the query is completed\n+     * @param cancelled if the query should be created in the cancelled state\n+     * @return query state or {@code null} if the query with the given ID is guaranteed to be already completed\n      */\n     public QueryState onDistributedQueryStarted(\n         UUID localMemberId,\n         QueryId queryId,\n-        QueryStateCompletionCallback completionCallback\n+        QueryStateCompletionCallback completionCallback,\n+        boolean cancelled\n+    ) {\n+        QueryState state = onDistributedQueryStarted0(localMemberId, queryId, completionCallback, cancelled);\n+\n+        if (state != null) {\n+            state.updateLastActivityTime();\n+        }\n+\n+        return state;\n+    }\n+\n+    /**\n+     * Registers a distributed query in response to query start message or query batch message.", "originalCommit": "aaf143f69c2b923e9addd60ec8562f5aec1b4227", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTk5Njk3OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17985#discussion_r569996979", "bodyText": "Removed the duplicated JavaDoc.", "author": "devozerov", "createdAt": "2021-02-04T07:23:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTI4MDAyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTM5MDY5OA==", "url": "https://github.com/hazelcast/hazelcast/pull/17985#discussion_r569390698", "bodyText": "The targetIsParticipant  name is misleading. IIUIC it means whether the operations are executed on the initiator or on the other member. But the initiator is also a participant. A better name would be targetIsInitiator (with inverse meaning).", "author": "viliam-durina", "createdAt": "2021-02-03T12:55:51Z", "path": "hazelcast/src/test/java/com/hazelcast/sql/impl/operation/QueryOperationHandlerTest.java", "diffHunk": "@@ -465,162 +540,124 @@ private QueryExecuteOperation createExecuteOperation(UUID toMemberId) {\n         );\n     }\n \n-    private QueryBatchExchangeOperation createBatch1Operation(UUID toMemberId) {\n-        return new QueryBatchExchangeOperation(\n-            testState.getQueryId(),\n-            EDGE_ID,\n-            toMemberId,\n-            createMonotonicBatch(0, BATCH_SIZE),\n-            false,\n-            Long.MAX_VALUE\n-        );\n-    }\n+    private QueryBatchExchangeOperation createBatchOperation(UUID targetMemberId, int value) {\n+        long ordinal = value;\n+        boolean last = value == 1;\n+        ListRowBatch rows = createMonotonicBatch(value, 1);\n \n-    private QueryBatchExchangeOperation createBatch2Operation(UUID toMemberId) {\n         return new QueryBatchExchangeOperation(\n-            testState.getQueryId(),\n+            queryId,\n             EDGE_ID,\n-            toMemberId,\n-            createMonotonicBatch(BATCH_SIZE, BATCH_SIZE),\n-            true,\n+            targetMemberId,\n+            rows,\n+            ordinal,\n+            last,\n             Long.MAX_VALUE\n         );\n     }\n \n-    private QueryCancelOperation createCancelOperation(UUID fromMemberId) {\n+    private QueryCancelOperation createCancelOperation(UUID sourceMemberId) {\n         return new QueryCancelOperation(\n-            testState.getQueryId(),\n+            queryId,\n             SqlErrorCode.GENERIC,\n             \"Error\",\n-            fromMemberId\n+            sourceMemberId\n         );\n     }\n \n-    private State startQueryOnInitiator(long timeout) {\n-        Plan plan = new Plan(\n-            partitionMap,\n-            Collections.emptyList(),\n-            Collections.emptyList(),\n-            Collections.emptyMap(),\n-            Collections.emptyMap(),\n-            Collections.emptyMap(),\n-            null,\n-            QueryParameterMetadata.EMPTY,\n-            null,\n-            Collections.emptySet(),\n-            Collections.emptyList()\n-        );\n-\n-        QueryId queryId = initiatorService.getStateRegistry().onInitiatorQueryStarted(\n-            QueryId.create(initiatorId),\n-            initiatorId,\n-            timeout,\n-            plan,\n-            null,\n-            null,\n-            new BlockingRootResultConsumer(),\n-            initiatorService.getOperationHandler()\n-        ).getQueryId();\n-\n-        testState = new State(queryId);\n-\n-        return testState;\n+    private UUID targetId() {\n+        return targetIsParticipant ? participantId : initiatorId;", "originalCommit": "355bf76a5dc7cbfa65af11f842cc444f3e046e39", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTk5NzU5Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17985#discussion_r569997596", "bodyText": "Renamed to targetIsNotInitiator.", "author": "devozerov", "createdAt": "2021-02-04T07:24:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTM5MDY5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTQxNTE5Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17985#discussion_r569415192", "bodyText": "We can probably remove this line, same code is on line 447.", "author": "viliam-durina", "createdAt": "2021-02-03T13:33:30Z", "path": "hazelcast/src/test/java/com/hazelcast/sql/impl/operation/QueryOperationHandlerTest.java", "diffHunk": "@@ -105,357 +93,444 @@\n \n     private Map<UUID, PartitionIdSet> partitionMap;\n \n-    private QueryExecuteOperation initiatorExecuteOperation;\n-    private QueryBatchExchangeOperation initiatorBatch1Operation;\n-    private QueryBatchExchangeOperation initiatorBatch2Operation;\n-    private QueryCancelOperation initiatorCancelOperation;\n+    private QueryId queryId;\n+\n+    @Parameterized.Parameter\n+    public boolean targetIsParticipant;\n+\n+    @Parameterized.Parameters(name = \"targetIsParticipant:{0}\")\n+    public static Collection<Object[]> parameters() {\n+        List<Object[]> res = new ArrayList<>();\n \n-    private QueryExecuteOperation participantExecuteOperation;\n-    private QueryBatchExchangeOperation participantBatch1Operation;\n-    private QueryBatchExchangeOperation participantBatch2Operation;\n-    private QueryCancelOperation participantCancelOperation;\n+        res.add(new Object[] { true });\n+        res.add(new Object[] { false });\n \n-    private QueryOperationChannel toInitiatorChannel;\n-    private QueryOperationChannel toParticipantChannel;\n+        return res;\n+    }\n+\n+    @Override\n+    protected Config getConfig() {\n+        return smallInstanceConfig();\n+    }\n \n     @Before\n     public void before() {\n-        factory = new TestHazelcastInstanceFactory(2);\n-\n-        initiator = (HazelcastInstanceProxy) factory.newHazelcastInstance();\n-        participant = (HazelcastInstanceProxy) factory.newHazelcastInstance();\n+        HazelcastInstanceProxy initiator = (HazelcastInstanceProxy) factory.newHazelcastInstance();\n+        HazelcastInstanceProxy participant = (HazelcastInstanceProxy) factory.newHazelcastInstance();\n \n         initiatorId = initiator.getLocalEndpoint().getUuid();\n         participantId = participant.getLocalEndpoint().getUuid();\n \n-        initiatorService = setInternalService(initiator, STATE_CHECK_FREQUENCY);\n-        participantService = setInternalService(participant, STATE_CHECK_FREQUENCY);\n+        initiatorService = sqlInternalService(initiator);\n+        participantService = sqlInternalService(participant);\n+\n+        setStateCheckFrequency(Long.MAX_VALUE);\n \n         partitionMap = new HashMap<>();\n         partitionMap.put(initiatorId, new PartitionIdSet(2, Collections.singletonList(1)));\n-        partitionMap.put(participantId, new PartitionIdSet(1, Collections.singletonList(2)));\n+        partitionMap.put(participantId, new PartitionIdSet(2, Collections.singletonList(2)));\n+\n+        queryId = QueryId.create(initiatorId);\n+    }\n+\n+    @After\n+    public void after() {\n+        factory.shutdownAll();\n+    }\n+\n+    @Test\n+    public void test_E() {\n+        sendExecute(false);\n+        assertQueryRegisteredEventually(queryId);\n+\n+        if (targetIsParticipant) {\n+            setOrphanedQueryStateCheckFrequency(100L);\n+            setStateCheckFrequency(100L);\n+            assertQueryNotRegisteredEventually(queryId);\n+        }\n+    }\n \n-        // Start the query with maximum timeout by default.\n-        prepare(Long.MAX_VALUE);\n+    @Test\n+    public void test_E_B1_B2_ordered() {\n+        check_E_B1_B2(true);\n     }\n \n-    private void prepare(long timeout) {\n-        testState = startQueryOnInitiator(timeout);\n+    @Test\n+    public void test_E_B1_B2_unordered() {\n+        check_E_B1_B2(false);\n+    }\n \n-        initiatorExecuteOperation = createExecuteOperation(initiatorId);\n-        participantExecuteOperation = createExecuteOperation(participantId);\n+    private void check_E_B1_B2(boolean ordered) {\n+        sendExecute(ordered);\n+        QueryState state = assertQueryRegisteredEventually(queryId);\n \n-        initiatorBatch1Operation = createBatch1Operation(initiatorId);\n-        participantBatch1Operation = createBatch1Operation(participantId);\n+        TestExec exec = assertExecCreatedEventually(state);\n+        assertFalse(exec.consumed0);\n+        assertFalse(exec.consumed1);\n \n-        initiatorBatch2Operation = createBatch2Operation(initiatorId);\n-        participantBatch2Operation = createBatch2Operation(participantId);\n+        sendBatch(VALUE_0);\n+        assertConsumedEventually(exec, VALUE_0);\n \n-        initiatorCancelOperation = createCancelOperation(participantId);\n-        participantCancelOperation = createCancelOperation(initiatorId);\n+        sendBatch(VALUE_1);\n+        assertConsumedEventually(exec, VALUE_1);\n \n-        toInitiatorChannel = participantService.getOperationHandler().createChannel(participantId, initiatorId);\n-        toParticipantChannel = initiatorService.getOperationHandler().createChannel(initiatorId, participantId);\n+        assertQueryNotRegisteredEventually(queryId);\n     }\n \n-    @After\n-    public void after() {\n-        if (factory != null) {\n-            factory.shutdownAll();\n-        }\n+    @Test\n+    public void test_E_B2_B1_ordered() {\n+        check_E_B2_B1(true);\n     }\n \n     @Test\n-    public void test_initiator_timeout() {\n-        stopQueryOnInitiator();\n-        prepare(50L);\n-\n-        sendToInitiator(initiatorExecuteOperation);\n-        checkNoQueryOnInitiator();\n+    public void test_E_B2_B1_unordered() {\n+        check_E_B2_B1(false);\n     }\n \n-    @Test\n-    public void test_initiator_E_B1_B2_C() {\n-        // EXECUTE\n-        sendToInitiator(initiatorExecuteOperation);\n-        testState.assertStartedEventually();\n+    public void check_E_B2_B1(boolean ordered) {\n+        sendExecute(ordered);\n \n-        // BATCH 1\n-        sendToInitiator(initiatorBatch1Operation);\n-        ListRowBatch batch = testState.assertRowsArrived(BATCH_SIZE);\n-        checkMonotonicBatch(batch, 0, BATCH_SIZE);\n+        QueryState state = assertQueryRegisteredEventually(queryId);\n \n-        // BATCH 2\n-        sendToInitiator(initiatorBatch2Operation);\n-        batch = testState.assertRowsArrived(BATCH_SIZE);\n-        checkMonotonicBatch(batch, BATCH_SIZE, BATCH_SIZE);\n-        testState.assertCompletedEventually();\n-        checkNoQueryOnInitiator();\n+        TestExec exec = assertExecCreatedEventually(state);\n+        assertFalse(exec.consumed0);\n+        assertFalse(exec.consumed1);\n \n-        // CANCEL\n-        sendToInitiator(initiatorCancelOperation);\n-        checkNoQueryOnInitiator();\n-    }\n+        // Send the second batch, only unordered exec should process it\n+        sendBatch(VALUE_1);\n \n-    @Test\n-    public void test_initiator_E_B1_C_B2() {\n-        // EXECUTE\n-        sendToInitiator(initiatorExecuteOperation);\n-        testState.assertStartedEventually();\n+        if (ordered) {\n+            assertNotConsumedWithDelay(exec, VALUE_1);\n+        } else {\n+            assertConsumedEventually(exec, VALUE_1);\n+        }\n \n-        // BATCH 1\n-        sendToInitiator(initiatorBatch1Operation);\n-        ListRowBatch batch = testState.assertRowsArrived(BATCH_SIZE);\n-        checkMonotonicBatch(batch, 0, BATCH_SIZE);\n+        // Send the first batch, processing should be finished in both modes\n+        sendBatch(VALUE_0);\n \n-        // CANCEL\n-        sendToInitiator(initiatorCancelOperation);\n-        checkNoQueryOnInitiator();\n+        assertConsumedEventually(exec, VALUE_0);\n+\n+        if (ordered) {\n+            assertConsumedEventually(exec, VALUE_1);\n+            assertFalse(exec.reordered);\n+        } else {\n+            assertTrue(exec.reordered);\n+        }\n \n-        // BATCH 2\n-        sendToInitiator(initiatorBatch2Operation);\n-        checkNoQueryOnInitiator();\n-        testState.assertNoRows();\n+        assertQueryNotRegisteredEventually(queryId);\n     }\n \n     @Test\n-    public void test_initiator_E_C_B1_B2() {\n-        // EXECUTE\n-        sendToInitiator(initiatorExecuteOperation);\n-        testState.assertStartedEventually();\n+    public void test_E_B_C() {\n+        sendExecute(false);\n+\n+        QueryState state = assertQueryRegisteredEventually(queryId);\n \n-        // CANCEL\n-        sendToInitiator(initiatorCancelOperation);\n-        checkNoQueryOnInitiator();\n+        TestExec exec = assertExecCreatedEventually(state);\n+        assertFalse(exec.consumed0);\n+        assertFalse(exec.consumed1);\n \n-        // BATCH 1\n-        sendToInitiator(initiatorBatch1Operation);\n-        checkNoQueryOnInitiator();\n+        sendBatch(VALUE_0);\n+        assertConsumedEventually(exec, VALUE_0);\n \n-        // BATCH 2\n-        sendToInitiator(initiatorBatch2Operation);\n-        checkNoQueryOnInitiator();\n-        testState.assertNoRows();\n+        sendCancel();\n+        assertQueryNotRegisteredEventually(queryId);\n     }\n \n     @Test\n-    public void test_initiator_E_L_B() {\n-        // EXECUTE\n-        sendToInitiator(initiatorExecuteOperation);\n-        testState.assertStartedEventually();\n+    public void test_E_C_B() {\n+        sendExecute(false);\n+\n+        QueryState state = assertQueryRegisteredEventually(queryId);\n+\n+        TestExec exec = assertExecCreatedEventually(state);\n+        assertFalse(exec.consumed0);\n+        assertFalse(exec.consumed1);\n+\n+        sendCancel();\n+        assertQueryNotRegisteredEventually(queryId);\n \n-        // LEAVE\n-        participant.shutdown();\n-        checkNoQueryOnInitiator();\n+        sendBatch(VALUE_0);\n \n-        // BATCH\n-        sendToInitiator(initiatorBatch1Operation);\n-        checkNoQueryOnInitiator();\n+        if (targetIsParticipant) {\n+            assertQueryRegisteredEventually(queryId);\n+\n+            setStateCheckFrequency(100L);\n+        }\n+\n+        assertQueryNotRegisteredEventually(queryId);\n     }\n \n     @Test\n-    public void test_participant_E_B1_B2_C() {\n-        // EXECUTE\n-        sendToParticipant(participantExecuteOperation);\n-        testState.assertStartedEventually();\n+    public void test_B() {\n+        sendBatch(VALUE_0);\n \n-        // BATCH 1\n-        sendToParticipant(participantBatch1Operation);\n-        ListRowBatch batch = testState.assertRowsArrived(BATCH_SIZE);\n-        checkMonotonicBatch(batch, 0, BATCH_SIZE);\n+        if (targetIsParticipant) {\n+            QueryState state = assertQueryRegisteredEventually(queryId);\n+            assertExecNotCreatedWithDelay(state);\n \n-        // BATCH 2\n-        sendToParticipant(participantBatch2Operation);\n-        batch = testState.assertRowsArrived(BATCH_SIZE);\n-        checkMonotonicBatch(batch, BATCH_SIZE, BATCH_SIZE);\n-        testState.assertCompletedEventually();\n-        checkNoQueryOnParticipant();\n+            setStateCheckFrequency(100L);\n+        }\n \n-        // CANCEL\n-        sendToParticipant(participantCancelOperation);\n-        checkNoQueryOnParticipant();\n+        assertQueryNotRegisteredEventually(queryId);\n     }\n \n     @Test\n-    public void test_participant_E_B1_C_B2() {\n-        // EXECUTE\n-        sendToParticipant(participantExecuteOperation);\n-        testState.assertStartedEventually();\n+    public void test_B_C() {\n+        sendBatch(VALUE_0);\n+\n+        if (targetIsParticipant) {\n+            QueryState state = assertQueryRegisteredEventually(queryId);\n+            assertExecNotCreatedWithDelay(state);\n \n-        // BATCH 1\n-        sendToParticipant(participantBatch1Operation);\n-        ListRowBatch batch = testState.assertRowsArrived(BATCH_SIZE);\n-        checkMonotonicBatch(batch, 0, BATCH_SIZE);\n+            sendCancel();\n+        }\n \n-        // CANCEL\n-        sendToParticipant(participantCancelOperation);\n-        checkNoQueryOnParticipant();\n+        assertQueryNotRegisteredEventually(queryId);\n+    }\n \n-        // BATCH 2\n-        sendToParticipant(participantBatch2Operation);\n-        checkQueryOnParticipant();\n-        stopQueryOnInitiator();\n-        checkNoQueryOnParticipant();\n-        testState.assertNoRows();\n+    @Test\n+    public void test_B1_E_B2_ordered() {\n+        check_B1_E_B2(true);\n     }\n \n     @Test\n-    public void test_participant_E_C_B1_B2() {\n-        // EXECUTE\n-        sendToParticipant(participantExecuteOperation);\n-        testState.assertStartedEventually();\n+    public void test_B1_E_B2_unordered() {\n+        check_B1_E_B2(false);\n+    }\n+\n+    private void check_B1_E_B2(boolean ordered) {\n+        if (targetIsParticipant) {\n+            sendBatch(VALUE_0);\n+            QueryState state = assertQueryRegisteredEventually(queryId);\n+            assertExecNotCreatedWithDelay(state);\n \n-        // CANCEL\n-        sendToParticipant(participantCancelOperation);\n-        checkNoQueryOnParticipant();\n+            sendExecute(ordered);\n+            TestExec exec = assertExecCreatedEventually(state);\n+            assertConsumedEventually(exec, VALUE_0);\n \n-        // BATCH 1\n-        sendToParticipant(participantBatch1Operation);\n-        checkQueryOnParticipant();\n+            sendBatch(VALUE_1);\n+            assertConsumedEventually(exec, VALUE_1);\n \n-        // BATCH 2\n-        sendToParticipant(participantBatch2Operation);\n-        checkQueryOnParticipant();\n-        stopQueryOnInitiator();\n-        checkNoQueryOnParticipant();\n-        testState.assertNoRows();\n+            assertQueryNotRegisteredEventually(queryId);\n+        }\n     }\n \n-    @Ignore(\"https://github.com/hazelcast/hazelcast/issues/16868\")\n     @Test\n-    public void test_participant_C_E_B1_B2() {\n-        fail(\"Cannot handle reordered cancel -> execute\");\n+    public void test_B2_E_B1_ordered() {\n+        check_B2_E_B1(true);\n     }\n \n     @Test\n-    public void test_participant_B1_E_B2_C() {\n-        // BATCH 1\n-        sendToParticipant(participantBatch1Operation);\n-        checkQueryOnParticipant();\n+    public void test_B2_E_B1_unordered() {\n+        check_B2_E_B1(false);\n+    }\n+\n+    private void check_B2_E_B1(boolean ordered) {\n+        if (targetIsParticipant) {\n+            sendBatch(VALUE_1);\n+            QueryState state = assertQueryRegisteredEventually(queryId);\n+            assertExecNotCreatedWithDelay(state);\n+\n+            sendExecute(ordered);\n+            TestExec exec = assertExecCreatedEventually(state);\n+\n+            if (ordered) {\n+                assertNotConsumedWithDelay(exec, VALUE_1);\n+            } else {\n+                assertConsumedEventually(exec, VALUE_1);\n+            }\n \n-        // EXECUTE\n-        sendToParticipant(participantExecuteOperation);\n-        testState.assertStartedEventually();\n+            sendBatch(VALUE_0);\n+            assertConsumedEventually(exec, VALUE_0);\n \n-        // BATCH 2\n-        sendToParticipant(participantBatch2Operation);\n-        RowBatch batch = testState.assertRowsArrived(BATCH_SIZE * 2);\n-        checkMonotonicBatch(batch, 0, BATCH_SIZE * 2);\n-        testState.assertCompletedEventually();\n-        checkNoQueryOnParticipant();\n+            if (ordered) {\n+                assertConsumedEventually(exec, VALUE_1);\n+                assertFalse(exec.reordered);\n+            } else {\n+                assertTrue(exec.reordered);\n+            }\n \n-        // CANCEL\n-        sendToParticipant(participantCancelOperation);\n-        checkNoQueryOnParticipant();\n+            assertQueryNotRegisteredEventually(queryId);\n+        }\n     }\n \n     @Test\n-    public void test_participant_B1_E_C_B2() {\n-        // BATCH 1\n-        sendToParticipant(participantBatch1Operation);\n-        checkQueryOnParticipant();\n-\n-        // EXECUTE\n-        sendToParticipant(participantExecuteOperation);\n-        testState.assertStartedEventually();\n-        RowBatch batch = testState.assertRowsArrived(BATCH_SIZE);\n-        checkMonotonicBatch(batch, 0, BATCH_SIZE);\n-\n-        // CANCEL\n-        sendToParticipant(participantCancelOperation);\n-        checkNoQueryOnParticipant();\n-\n-        // BATCH 2\n-        sendToParticipant(participantBatch2Operation);\n-        checkQueryOnParticipant();\n-        stopQueryOnInitiator();\n-        checkNoQueryOnParticipant();\n-        testState.assertNoRows();\n-    }\n-\n-    @Ignore(\"https://github.com/hazelcast/hazelcast/issues/16868\")\n+    public void test_B1_B2_E_ordered() {\n+        check_B1_B2_E(true);\n+    }\n+\n     @Test\n-    public void test_participant_B1_C_E_B2() {\n-        fail(\"Cannot handle reordered cancel -> execute\");\n+    public void test_B1_B2_E_unordered() {\n+        check_B1_B2_E(false);\n+    }\n+\n+    private void check_B1_B2_E(boolean ordered) {\n+        if (targetIsParticipant) {\n+            sendBatch(VALUE_0);\n+            QueryState state = assertQueryRegisteredEventually(queryId);\n+            assertExecNotCreatedWithDelay(state);\n+\n+            sendBatch(VALUE_1);\n+            assertExecNotCreatedWithDelay(state);\n+\n+            sendExecute(ordered);\n+            TestExec exec = assertExecCreatedEventually(state);\n+            assertConsumedEventually(exec, VALUE_0);\n+            assertConsumedEventually(exec, VALUE_1);\n+            assertFalse(exec.reordered);\n+\n+            assertQueryNotRegisteredEventually(queryId);\n+        }\n     }\n \n-    @Ignore(\"https://github.com/hazelcast/hazelcast/issues/16868\")\n     @Test\n-    public void test_participant_C_B1_E_B2() {\n-        fail(\"Cannot handle reordered cancel -> execute\");\n+    public void test_B2_B1_E_ordered() {\n+        check_B2_B1_E(true);\n     }\n \n     @Test\n-    public void test_participant_B1_B2_E_C() {\n-        // BATCH 1\n-        sendToParticipant(participantBatch1Operation);\n-        checkQueryOnParticipant();\n+    public void test_B2_B1_E_unordered() {\n+        check_B2_B1_E(false);\n+    }\n \n-        // BATCH 2\n-        sendToParticipant(participantBatch2Operation);\n-        checkQueryOnParticipant();\n+    private void check_B2_B1_E(boolean ordered) {\n+        if (targetIsParticipant) {\n+            sendBatch(VALUE_1);\n+            QueryState state = assertQueryRegisteredEventually(queryId);\n+            assertExecNotCreatedWithDelay(state);\n \n-        // EXECUTE\n-        sendToParticipant(participantExecuteOperation);\n-        testState.assertStartedEventually();\n+            sendBatch(VALUE_0);\n+            assertExecNotCreatedWithDelay(state);\n \n-        // BATCH 2\n-        RowBatch batch = testState.assertRowsArrived(BATCH_SIZE * 2);\n-        checkMonotonicBatch(batch, 0, BATCH_SIZE * 2);\n-        testState.assertCompletedEventually();\n-        checkNoQueryOnParticipant();\n+            sendExecute(ordered);\n+            TestExec exec = assertExecCreatedEventually(state);\n+            assertConsumedEventually(exec, VALUE_0);\n+            assertConsumedEventually(exec, VALUE_1);\n \n-        // CANCEL\n-        sendToParticipant(participantCancelOperation);\n-        checkNoQueryOnParticipant();\n+            if (ordered) {\n+                assertFalse(exec.reordered);\n+            } else {\n+                assertTrue(exec.reordered);\n+            }\n+\n+            assertQueryNotRegisteredEventually(queryId);\n+        }\n     }\n \n-    @Ignore(\"https://github.com/hazelcast/hazelcast/issues/16868\")\n     @Test\n-    public void test_participant_B1_B2_C_E() {\n-        fail(\"Cannot handle reordered cancel -> execute\");\n+    public void test_C() {\n+        sendCancel();\n+\n+        if (targetIsParticipant) {\n+            QueryState state = assertQueryRegisteredEventually(queryId);\n+            assertTrue(state.isCancelled());\n+\n+            setStateCheckFrequency(100L);\n+        }\n+\n+        assertQueryNotRegisteredEventually(queryId);\n     }\n \n-    @Ignore(\"https://github.com/hazelcast/hazelcast/issues/16868\")\n     @Test\n-    public void test_participant_B1_C_B2_E() {\n-        fail(\"Cannot handle reordered cancel -> execute\");\n+    public void test_C_E() {\n+        sendCancel();\n+\n+        if (targetIsParticipant) {\n+            QueryState state = assertQueryRegisteredEventually(queryId);\n+            assertTrue(state.isCancelled());\n+\n+            sendExecute(false);\n+            assertQueryNotRegisteredEventually(queryId);", "originalCommit": "355bf76a5dc7cbfa65af11f842cc444f3e046e39", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTk5ODkxOA==", "url": "https://github.com/hazelcast/hazelcast/pull/17985#discussion_r569998918", "bodyText": "Removed the unnecessary line.", "author": "devozerov", "createdAt": "2021-02-04T07:27:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTQxNTE5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTQxNjk0OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17985#discussion_r569416949", "bodyText": "We miss a test for cancel after a completed execution (test_E_B1_B2_C)", "author": "viliam-durina", "createdAt": "2021-02-03T13:35:57Z", "path": "hazelcast/src/test/java/com/hazelcast/sql/impl/operation/QueryOperationHandlerTest.java", "diffHunk": "@@ -16,86 +16,74 @@\n \n package com.hazelcast.sql.impl.operation;\n \n-import com.hazelcast.core.HazelcastInstance;\n+import com.hazelcast.config.Config;\n import com.hazelcast.instance.impl.HazelcastInstanceProxy;\n-import com.hazelcast.internal.serialization.InternalSerializationService;\n import com.hazelcast.internal.util.collection.PartitionIdSet;\n-import com.hazelcast.spi.impl.NodeEngineImpl;\n-import com.hazelcast.sql.impl.SqlErrorCode;\n-import com.hazelcast.sql.impl.NodeServiceProviderImpl;\n import com.hazelcast.sql.impl.QueryId;\n import com.hazelcast.sql.impl.QueryParameterMetadata;\n+import com.hazelcast.sql.impl.SqlErrorCode;\n import com.hazelcast.sql.impl.SqlInternalService;\n-import com.hazelcast.sql.impl.SqlServiceImpl;\n import com.hazelcast.sql.impl.SqlTestSupport;\n import com.hazelcast.sql.impl.exec.AbstractUpstreamAwareExec;\n import com.hazelcast.sql.impl.exec.CreateExecPlanNodeVisitor;\n import com.hazelcast.sql.impl.exec.CreateExecPlanNodeVisitorCallback;\n import com.hazelcast.sql.impl.exec.Exec;\n import com.hazelcast.sql.impl.exec.IterationResult;\n-import com.hazelcast.sql.impl.exec.root.BlockingRootResultConsumer;\n import com.hazelcast.sql.impl.plan.Plan;\n import com.hazelcast.sql.impl.plan.node.PlanNode;\n import com.hazelcast.sql.impl.plan.node.PlanNodeVisitor;\n import com.hazelcast.sql.impl.plan.node.UniInputPlanNode;\n import com.hazelcast.sql.impl.plan.node.io.ReceivePlanNode;\n import com.hazelcast.sql.impl.row.EmptyRowBatch;\n import com.hazelcast.sql.impl.row.ListRowBatch;\n-import com.hazelcast.sql.impl.row.Row;\n import com.hazelcast.sql.impl.row.RowBatch;\n+import com.hazelcast.sql.impl.state.QueryState;\n import com.hazelcast.sql.impl.type.QueryDataType;\n-import com.hazelcast.test.HazelcastSerialClassRunner;\n+import com.hazelcast.sql.impl.worker.QueryFragmentExecutable;\n+import com.hazelcast.test.HazelcastParallelParametersRunnerFactory;\n import com.hazelcast.test.TestHazelcastInstanceFactory;\n import com.hazelcast.test.annotation.ParallelJVMTest;\n import com.hazelcast.test.annotation.QuickTest;\n import org.junit.After;\n import org.junit.Before;\n-import org.junit.Ignore;\n import org.junit.Test;\n import org.junit.experimental.categories.Category;\n import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n \n+import java.time.Duration;\n import java.util.ArrayList;\n+import java.util.Collection;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.Set;\n import java.util.UUID;\n-import java.util.concurrent.BlockingQueue;\n-import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n \n+import static org.junit.Assert.assertFalse;\n import static org.junit.Assert.assertNotNull;\n import static org.junit.Assert.assertNull;\n import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n \n /**\n- * A set of integration tests for query message processing on a single member.\n- * <p>\n- * Abbreviations:\n- * <ul>\n- *     <li>E - execute</li>\n- *     <li>Bx - batch request with x ordinal</li>\n- *     <li>C - cancel</li>\n- *     <li>L - leave of the other member</li>\n- * </ul>\n+ * Tests for different combinations of events\n  */\n-@RunWith(HazelcastSerialClassRunner.class)\n+@RunWith(Parameterized.class)\n+@Parameterized.UseParametersRunnerFactory(HazelcastParallelParametersRunnerFactory.class)\n @Category({QuickTest.class, ParallelJVMTest.class})\n-@Ignore(\"https://github.com/hazelcast/hazelcast/issues/16929#issuecomment-699819103\")\n public class QueryOperationHandlerTest extends SqlTestSupport {", "originalCommit": "355bf76a5dc7cbfa65af11f842cc444f3e046e39", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTk5NzkxNA==", "url": "https://github.com/hazelcast/hazelcast/pull/17985#discussion_r569997914", "bodyText": "This case is covered in test_C because we do not leave any state once the query is completed.", "author": "devozerov", "createdAt": "2021-02-04T07:25:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTQxNjk0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDE1NDg4Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/17985#discussion_r570154887", "bodyText": "I still think such a test might be worthwhile. The current impl does as you say, but it's a common scenario and it should be easy to add such a test.", "author": "viliam-durina", "createdAt": "2021-02-04T11:36:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTQxNjk0OQ=="}], "type": "inlineReview"}, {"oid": "52c012d3d00a57db94f1922b4cdaf88f872ec5c6", "url": "https://github.com/hazelcast/hazelcast/commit/52c012d3d00a57db94f1922b4cdaf88f872ec5c6", "message": "Merge branch 'master' into sql-threading", "committedDate": "2021-02-04T07:15:17Z", "type": "commit"}, {"oid": "e1cf4e5ec00a4ab14ccc1cc343980cb7f7f67b90", "url": "https://github.com/hazelcast/hazelcast/commit/e1cf4e5ec00a4ab14ccc1cc343980cb7f7f67b90", "message": "Merge remote-tracking branch 'devozerov/sql-threading' into sql-threading", "committedDate": "2021-02-04T07:15:58Z", "type": "commit"}, {"oid": "7c6d7e32c03858cf7b51771b48778beb8521785e", "url": "https://github.com/hazelcast/hazelcast/commit/7c6d7e32c03858cf7b51771b48778beb8521785e", "message": "Update docs/design/sql/04-parallel-execution.md\n\nCo-authored-by: Viliam Durina <viliam-durina@users.noreply.github.com>", "committedDate": "2021-02-04T07:16:25Z", "type": "commit"}, {"oid": "06364d9ed46a569d551680d1adbd38ca3186c14b", "url": "https://github.com/hazelcast/hazelcast/commit/06364d9ed46a569d551680d1adbd38ca3186c14b", "message": "Update docs/design/sql/04-parallel-execution.md\n\nCo-authored-by: Viliam Durina <viliam-durina@users.noreply.github.com>", "committedDate": "2021-02-04T07:16:59Z", "type": "commit"}, {"oid": "785f86a8408bc211f8d8069fe337483e9ff87a6b", "url": "https://github.com/hazelcast/hazelcast/commit/785f86a8408bc211f8d8069fe337483e9ff87a6b", "message": "Remove the confusing line from the document.", "committedDate": "2021-02-04T07:19:59Z", "type": "commit"}, {"oid": "4ac020dbfd3870439b0217084ad82cc4bd694f41", "url": "https://github.com/hazelcast/hazelcast/commit/4ac020dbfd3870439b0217084ad82cc4bd694f41", "message": "Removed unnecessary JavaDoc.", "committedDate": "2021-02-04T07:23:02Z", "type": "commit"}, {"oid": "528a4eb4c8cea60569fb17eb75c2ed76580577fa", "url": "https://github.com/hazelcast/hazelcast/commit/528a4eb4c8cea60569fb17eb75c2ed76580577fa", "message": "Renamed a variable with the unclear name.", "committedDate": "2021-02-04T07:24:24Z", "type": "commit"}, {"oid": "994d1bedc091094d2b768c1729e7474913df8b1d", "url": "https://github.com/hazelcast/hazelcast/commit/994d1bedc091094d2b768c1729e7474913df8b1d", "message": "Removed unnecessary line of code from the test.", "committedDate": "2021-02-04T07:27:11Z", "type": "commit"}, {"oid": "8d81c0fa5c673d9d1e5e1f196cd87aa8dd292b28", "url": "https://github.com/hazelcast/hazelcast/commit/8d81c0fa5c673d9d1e5e1f196cd87aa8dd292b28", "message": "Merge branch 'master' into sql-threading", "committedDate": "2021-02-04T07:32:49Z", "type": "commit"}]}