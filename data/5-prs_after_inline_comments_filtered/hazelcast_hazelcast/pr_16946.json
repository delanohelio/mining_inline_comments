{"pr_number": 16946, "pr_title": "#4233 Add ITopic.publishAll, ITopic.publishAllAsync and ITopic.publishAsync methods", "pr_createdAt": "2020-05-01T15:04:14Z", "pr_url": "https://github.com/hazelcast/hazelcast/pull/16946", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI3MTg4OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r421271889", "bodyText": "partition id is used by TotalOrderedTopicProxy to make sure the total order.\nThis one should not need it.\nSee https://docs.hazelcast.org/docs/4.0.1/manual/html-single/index.html#understanding-topic-behavior", "author": "sancar", "createdAt": "2020-05-07T06:39:41Z", "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/TopicProxy.java", "diffHunk": "@@ -36,9 +41,11 @@\n \n     protected static final String NULL_MESSAGE_IS_NOT_ALLOWED = \"Null message is not allowed!\";\n     protected static final String NULL_LISTENER_IS_NOT_ALLOWED = \"Null listener is not allowed!\";\n+    private final int partitionId;\n \n     public TopicProxy(String name, NodeEngine nodeEngine, TopicService service) {\n         super(name, nodeEngine, service);\n+        this.partitionId = nodeEngine.getPartitionService().getPartitionId(getNameAsPartitionAwareData());", "originalCommit": "0dbd74c23b3e84de88fc484f1ebe15ecb1ed38c1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI3MzkzMQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r421273931", "bodyText": "I believe this should be called with invokeOnPartition. Also async ones should have partitionId as the fourth parameter.\nI have got suspicious about this and deleted my comment. It seems, we are using partition id on ClientTopicProxy but not on ClientReliableTopicProxy. Order guarantees may not be given for Reliable one.  Can you still add tests for order guarantees for all of the new methods ?\nWe can add tests as following for new methods to verify the behaviour.\nhttps://github.com/hazelcast/hazelcast/blob/master/hazelcast/src/test/java/com/hazelcast/topic/TopicTest.java#L141\nhttps://github.com/hazelcast/hazelcast/blob/master/hazelcast/src/test/java/com/hazelcast/topic/TopicTest.java#L220\nIt seems tests are missing on the client side. Don't forget to add them for client side as well ?\nEasiest could be to make ClientTopicTest to extend TopicTest. We don't have to, but we are using this pattern to avoid writing tests twice when it fits. See if these tests are suitable. Here is an example:\nhttps://github.com/hazelcast/hazelcast/blob/master/hazelcast/src/test/java/com/hazelcast/collection/impl/queue/QueueBasicLocalTest.java#L29", "author": "sancar", "createdAt": "2020-05-07T06:44:40Z", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientReliableTopicProxy.java", "diffHunk": "@@ -118,6 +138,21 @@ public void publish(@Nonnull E payload) {\n         }\n     }\n \n+    @Override\n+    public CompletionStage<E> publishAsync(@Nonnull E message) {\n+        checkNotNull(message, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        Data element = toData(message);\n+        ClientMessage request = TopicPublishCodec.encodeRequest(name, element);\n+        try {\n+            ClientInvocationFuture invocationFuture = new ClientInvocation(getClient(), request, getName()).invoke();", "originalCommit": "0dbd74c23b3e84de88fc484f1ebe15ecb1ed38c1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "56fdd9732809f72e46508f75745e4517e07597c4", "url": "https://github.com/hazelcast/hazelcast/commit/56fdd9732809f72e46508f75745e4517e07597c4", "message": "#4233 review-advised changes\nmore UnitTests, removed additional operations, fixed return values of async methods", "committedDate": "2020-05-11T20:58:15Z", "type": "forcePushed"}, {"oid": "7bd347cabbde9a29e6bdddc08f5dc03795189a3d", "url": "https://github.com/hazelcast/hazelcast/commit/7bd347cabbde9a29e6bdddc08f5dc03795189a3d", "message": "#4233 review-advised changes\nmore UnitTests, removed additional operations, fixed return values of async methods", "committedDate": "2020-05-12T12:54:25Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU3NzkyOA==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r434577928", "bodyText": "We have to distinguish between \"reliable topic\" and \"topic\" here. \"Reliable topic\" (meaning *ReliableTopicProxy classes, obtained through HazelcastInstance#getReliableTopic) use another user-facing structure under the covers - Ringbuffer<ReliableTopicMessage>. On the other hand, \"topic\" (meaning TopicProxy and ClientTopicProxy classes, obtained through HazelcastInstance#getTopic) don't use the ringbuffer but use the \"eventing system\" instead.\nWhat I'm trying to say is, the reliable topic proxies need to use the ringbuffer. Now, that will make your life both easier and harder :D I'm not sure how easy it will be but you should switch to using ringbuffer.addAllAsync() in the reliable topic proxies.\nAfter you try it out, you can let us know if you ran into some difficulties there and we'll continue from there on.", "author": "mmedenjak", "createdAt": "2020-06-03T13:45:02Z", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientReliableTopicProxy.java", "diffHunk": "@@ -118,6 +129,15 @@ public void publish(@Nonnull E payload) {\n         }\n     }\n \n+    @Override\n+    public InternalCompletableFuture<E> publishAsync(@Nonnull E message) {\n+        checkNotNull(message, NULL_MESSAGE_IS_NOT_ALLOWED);", "originalCommit": "7bd347cabbde9a29e6bdddc08f5dc03795189a3d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgzMTI4Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r443831282", "bodyText": "Hello @mmedenjak, sorry, but I fail with the ClientReliableTopicProxy#addWithBackoff Method. This is a synchronous method and I actually have no idea how to implement an asynchronous one. Do you have an idea?", "author": "andrewoelfing", "createdAt": "2020-06-22T21:16:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU3NzkyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk5MTU5NA==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r448991594", "bodyText": "That one is problematic, true. I guess BLOCK is not really a good name for the policy but maybe you can create a future and a self-scheduling task which will reschedule itself if it cannot add the item. Once it manages to add the item, it completes the task. So calling get() on such a future would yield the same behaviour as the sync variant. Not sure if it makes sense and let me know if you need help with an example of how I see it.", "author": "mmedenjak", "createdAt": "2020-07-02T13:13:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU3NzkyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzMwODUzMA==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r453308530", "bodyText": "Hello @mmedenjak, I know what you mean, but do you have an example of such a self-scheduling task?\nAlso RingBuffer#addAllAsync returns a CompletionStage with a Long generic type. This collides with the expected generic type E.", "author": "andrewoelfing", "createdAt": "2020-07-12T12:09:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU3NzkyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDIzODgwNw==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r464238807", "bodyText": "Hey, I was off for three weeks, I'll try to figure out an example and send it to you.", "author": "mmedenjak", "createdAt": "2020-08-03T07:27:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU3NzkyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTMyNDA3OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r465324079", "bodyText": "Hey Matko! I can give you a little bit more information about the generics problem..\nThe problem is, that every RingBuffer method returns a CompletableFuture<Long> and not a CompletableFuture<E>.\n    @Override\n    public CompletableFuture<E> publishAllAsync(@Nonnull Collection<? extends E> payloads) {\n        checkNotNull(payloads, NULL_MESSAGE_IS_NOT_ALLOWED);\n        checkNoNullInside(payloads, NULL_MESSAGE_IS_NOT_ALLOWED);\n        CompletableFuture<Long> completableFuture = null;\n        try {\n            Collection<ReliableTopicMessage> messages = new ArrayList<>(payloads.size());\n            payloads.forEach(payload -> messages.add(new ReliableTopicMessage(toData(payload), null)));\n            switch (overloadPolicy) {\n                case ERROR:\n                case DISCARD_NEWEST:\n                    completableFuture = ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture();\n                    break;\n                case DISCARD_OLDEST:\n                    completableFuture = ringbuffer.addAllAsync(messages, OverflowPolicy.OVERWRITE).toCompletableFuture();\n                    break;\n                case BLOCK:\n                    completableFuture = addWithBackoffAsync(messages);\n                    break;\n                default:\n                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n            }\n        } catch (Exception e) {\n            throw (RuntimeException) peel(e, null,\n                    \"Failed to publish message: \" + payloads + \" to topic:\" + getName());\n        }\n        return new completableFuture;\n    }", "author": "andrewoelfing", "createdAt": "2020-08-04T20:53:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU3NzkyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkwOTIyMw==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r469909223", "bodyText": "Hey, not sure if you might still be willing to work on this issue but I managed to take a look and here are my conclusions. I believe we should change all return types for publishAsync and publishAllAsync to these:\nCompletionStage<Void> publishAsync(@Nonnull E message);\nCompletionStage<Void> publishAllAsync(@Nonnull Collection<? extends E> messages);\nThe reasons are:\n\nall other async methods on our public API return CompletionStage and none return InternalCompletableFuture since it's an internal implementation\nthe generic type should probably be Void since different implementations of ITopic use different backing structures and since ITopic#publish returns void anyway and not the ID or the message. Of course, we could return the messages themselves and I'm sure each implementation may create a new future which will be completed with the provided messages but I don't think that's necessary. The messages were provided as a parameter to the async methods which means the user already has references to them. What matters is the future itself and being able to react to the completion and not the messages themselves.\n\nThis also means you will have to adapt some methods to return a newly created future which will be completed when some operation completes. For instance, in ReliableTopicProxy#publishAsync:\n    @Override\n    public CompletionStage<Void> publishAsync(@Nonnull E message) {\n        checkNotNull(message, NULL_MESSAGE_IS_NOT_ALLOWED);\n        Data data = toData(message);\n        InternalCompletableFuture<Void> returnFuture = new InternalCompletableFuture<>();\n        invokeOnPartition(new PublishOperation(name, data))\n                .whenCompleteAsync((o, t) -> {\n                    if (t != null) {\n                        returnFuture.completeExceptionally(t);\n                    } else {\n                        returnFuture.complete(null);\n                    }\n                });\n        return returnFuture;\n    }\nNote: I haven't tested this but I believe it works correctly, you'll need to verify this.", "author": "mmedenjak", "createdAt": "2020-08-13T12:20:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU3NzkyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkxMDI0Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r469910246", "bodyText": "As for the self-scheduling and other details of the ReliableTopicProxy implementation, here's what I came up with:\n    @Override\n    public void publishAll(@Nonnull Collection<? extends E> payload) {\n        checkNotNull(payload, NULL_MESSAGES_IS_NOT_ALLOWED);\n        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n\n        try {\n            List<ReliableTopicMessage> messages = payload.stream()\n                                                         .map(m -> new ReliableTopicMessage(nodeEngine.toData(m), thisAddress))\n                                                         .collect(Collectors.toList());\n            switch (overloadPolicy) {\n                case ERROR:\n                    long sequenceId = ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n                    if (sequenceId == -1) {\n                        throw new TopicOverloadException(\"Failed to publish messages: \" + payload + \" on topic:\" + getName());\n                    }\n                    break;\n                case DISCARD_OLDEST:\n                    ringbuffer.addAllAsync(messages, OverflowPolicy.OVERWRITE).toCompletableFuture().get();\n                    break;\n                case DISCARD_NEWEST:\n                    ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n                    break;\n                case BLOCK:\n                    long timeoutMs = INITIAL_BACKOFF_MS;\n                    for (; ; ) {\n                        long result = ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n                        if (result != -1) {\n                            break;\n                        }\n\n                        MILLISECONDS.sleep(timeoutMs);\n                        timeoutMs *= 2;\n                        if (timeoutMs > MAX_BACKOFF) {\n                            timeoutMs = MAX_BACKOFF;\n                        }\n                    }\n                    break;\n                default:\n                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n            }\n\n            localTopicStats.incrementPublishes();\n        } catch (Exception e) {\n            throw (RuntimeException) peel(e, null, \"Failed to publish messages: \" + payload + \" to topic:\" + getName());\n        }\n    }\n\n    @Override\n    public CompletionStage<Void> publishAllAsync(@Nonnull Collection<? extends E> payload) {\n        checkNotNull(payload, NULL_MESSAGES_IS_NOT_ALLOWED);\n        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n        InternalCompletableFuture<Void> returnFuture = new InternalCompletableFuture<>();\n\n        try {\n            List<ReliableTopicMessage> messages = payload.stream()\n                                                         .map(m -> new ReliableTopicMessage(nodeEngine.toData(m), thisAddress))\n                                                         .collect(Collectors.toList());\n            switch (overloadPolicy) {\n                case ERROR:\n                    ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL)\n                              .whenCompleteAsync((id, t) -> {\n                                  if (t != null) {\n                                      returnFuture.completeExceptionally(t);\n                                  }\n                                  if (id == -1) {\n                                      returnFuture.completeExceptionally(new TopicOverloadException(\n                                              \"Failed to publish messages: \" + payload + \" on topic:\" + getName()));\n                                  }\n                                  localTopicStats.incrementPublishes(payload.size());\n                                  returnFuture.complete(null);\n                              });\n\n                    break;\n                case DISCARD_OLDEST:\n                    ringbuffer.addAllAsync(messages, OverflowPolicy.OVERWRITE)\n                              .whenCompleteAsync((id, t) -> {\n                                  if (t != null) {\n                                      returnFuture.completeExceptionally(t);\n                                  }\n                                  localTopicStats.incrementPublishes(payload.size());\n                                  returnFuture.complete(null);\n                              });\n                    break;\n                case DISCARD_NEWEST:\n                    ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL)\n                              .whenCompleteAsync((id, t) -> {\n                                  if (t != null) {\n                                      returnFuture.completeExceptionally(t);\n                                  }\n                                  localTopicStats.incrementPublishes(payload.size());\n                                  returnFuture.complete(null);\n                              });\n                    break;\n                case BLOCK:\n                    addAsyncAndBlock(payload, returnFuture, messages, INITIAL_BACKOFF_MS);\n                    break;\n                default:\n                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n            }\n        } catch (Exception e) {\n            returnFuture.completeExceptionally(peel(e, null, \"Failed to publish messages: \" + payload + \" to topic:\" + getName()));\n        }\n\n        return returnFuture;\n    }\n\n    private void addAsyncAndBlock(@Nonnull Collection<? extends E> payload,\n                                  InternalCompletableFuture<Void> returnFuture,\n                                  List<ReliableTopicMessage> messages,\n                                  long pauseMillis) {\n        ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).whenCompleteAsync((id, t) -> {\n            if (t != null) {\n                returnFuture.completeExceptionally(t);\n            }\n            if (id == -1) {\n                nodeEngine.getExecutionService().schedule(\n                        () -> addAsyncAndBlock(payload, returnFuture, messages, Math.min(pauseMillis * 2, MAX_BACKOFF)),\n                        pauseMillis, MILLISECONDS);\n                returnFuture.completeExceptionally(new TopicOverloadException(\n                        \"Failed to publish messages: \" + payload + \" on topic:\" + getName()));\n            }\n            localTopicStats.incrementPublishes(payload.size());\n            returnFuture.complete(null);\n        });\n    }\nI'm sure it can be cleaned up a bit and it definitely needs to be tested but that's what I was thinking about.", "author": "mmedenjak", "createdAt": "2020-08-13T12:21:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU3NzkyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU4MzIzNQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r434583235", "bodyText": "Since this task may be fired in a cluster which contains a 4.0 member which doesn't have this operation, we need to add a check for the cluster version somewhere here, just like the ones you've added in your previous PR I believe. Maybe something like this:\n        Version clusterVersion = nodeEngine.getClusterService().getClusterVersion();\n        if (!clusterVersion.isGreaterOrEqual(Versions.V4_1)) {\n            throw new UnsupportedOperationException(\n                    \"Publish all is unavailable at cluster version \" + clusterVersion);\n        }\n        return new PublishAllOperation(parameters.name, items());", "author": "mmedenjak", "createdAt": "2020-06-03T13:52:09Z", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/protocol/task/topic/TopicPublishAllMessageTask.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.client.impl.protocol.task.topic;\n+\n+import com.hazelcast.client.impl.protocol.ClientMessage;\n+import com.hazelcast.client.impl.protocol.codec.TopicPublishAllCodec;\n+import com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\n+import com.hazelcast.instance.impl.Node;\n+import com.hazelcast.internal.nio.Connection;\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.security.permission.ActionConstants;\n+import com.hazelcast.security.permission.TopicPermission;\n+import com.hazelcast.spi.impl.operationservice.Operation;\n+import com.hazelcast.topic.impl.PublishAllOperation;\n+import com.hazelcast.topic.impl.TopicService;\n+\n+import java.security.Permission;\n+import java.util.List;\n+\n+public class TopicPublishAllMessageTask\n+        extends AbstractPartitionMessageTask<TopicPublishAllCodec.RequestParameters> {\n+\n+    public TopicPublishAllMessageTask(ClientMessage clientMessage, Node node, Connection connection) {\n+        super(clientMessage, node, connection);\n+    }\n+\n+    @Override\n+    protected Operation prepareOperation() {\n+        return new PublishAllOperation(parameters.name, items());", "originalCommit": "7bd347cabbde9a29e6bdddc08f5dc03795189a3d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ3OTI4NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r443479285", "bodyText": "Easy to fix - done.", "author": "andrewoelfing", "createdAt": "2020-06-22T10:59:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU4MzIzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU4NjcwOQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r434586709", "bodyText": "It's a shame sync and async methods don't share the code and sync simply being async().get() I see there's an additional object created for the async case so maybe that's not possible. Or maybe you can extract at least some part.", "author": "mmedenjak", "createdAt": "2020-06-03T13:56:42Z", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientTopicProxy.java", "diffHunk": "@@ -77,6 +95,27 @@ public LocalTopicStats getLocalTopicStats() {\n         throw new UnsupportedOperationException(\"Locality is ambiguous for client!\");\n     }\n \n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> messages) {\n+        checkNotNull(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        Collection<Data> dataCollection = objectToDataCollection(messages, getSerializationService());\n+\n+        ClientMessage request = TopicPublishAllCodec.encodeRequest(name, dataCollection);\n+        invokeOnPartition(request);\n+    }\n+\n+    @Override\n+    public InternalCompletableFuture<E> publishAllAsync(@Nonnull Collection<? extends E> messages) {\n+        checkNotNull(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        Collection<Data> dataCollection = objectToDataCollection(messages, getSerializationService());\n+        final ClientMessage clientMessage = TopicPublishAllCodec.encodeRequest(name, dataCollection);\n+        return publishAsyncInternal(clientMessage);", "originalCommit": "7bd347cabbde9a29e6bdddc08f5dc03795189a3d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ3OTQ1NA==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r443479454", "bodyText": "Also done. :)", "author": "andrewoelfing", "createdAt": "2020-06-22T10:59:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU4NjcwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkxMjIxOQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r469912219", "bodyText": "With the latest iteration of changes, this would become:\n    @Override\n    public CompletionStage<Void> publishAsync(@Nonnull E message) {\n        checkNotNull(message, NULL_MESSAGE_IS_NOT_ALLOWED);\n\n        Data data = toData(message);\n        final ClientMessage clientMessage = TopicPublishCodec.encodeRequest(name, data);\n        InternalCompletableFuture<Void> returnFuture = new InternalCompletableFuture<>();\n        publishAsyncInternal(clientMessage).whenCompleteAsync((o, t) -> {\n            if (t != null) {\n                returnFuture.completeExceptionally(t);\n            } else {\n                returnFuture.complete(null);\n            }\n        });\n        return returnFuture;\n    }\n\n    protected ClientInvocationFuture publishAsyncInternal(ClientMessage clientMessage) {\n        try {\n            return new ClientInvocation(getClient(), clientMessage, getName(), getPartitionId()).invoke();\n        } catch (Exception e) {\n            throw rethrow(e);\n        }\n    }", "author": "mmedenjak", "createdAt": "2020-08-13T12:25:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU4NjcwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU5MjM0MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r434592341", "bodyText": "Another layer of complexity :) In addition to reliable topic vs topic, \"topic\" can be different if we're talking about \"totally-ordered\" topic and \"non-totally-ordered\" topic (determined by TopicConfig#isGlobalOrderingEnabled). The \"non-ordered\" is implemented in TopicProxy and ClientTopicProxy and here you avoid firing any partition operations since partition operations are ordered. On the other hand, in TotalOrderedTopicProxy you can override the method from TopicProxy and fire the PublishAllOperation (but remember to check for the cluster version first).\nLooks like clients don't have non-ordered topics, they send a message task which then sends a publish operation. Basically turning it into an ordered topic always.\nThis also means that the async member-side non-ordered implementation of TopicProxy#publishAllAsync is basically the same as the sync one, since the TopicProxySupport#publishInternal doesn't usually block. Usually meaning there's some silly rule that every 100000th event should block. This IMHO is a poor backpressure mechanism and I think we should remove it anyway.", "author": "mmedenjak", "createdAt": "2020-06-03T14:04:12Z", "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/TopicProxy.java", "diffHunk": "@@ -47,6 +56,13 @@ public void publish(@Nonnull E message) {\n         publishInternal(message);\n     }\n \n+    @Override\n+    public InternalCompletableFuture<E> publishAsync(@Nonnull E message) {", "originalCommit": "7bd347cabbde9a29e6bdddc08f5dc03795189a3d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgzNDY4Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r443834686", "bodyText": "Ok, here I'm lost... Do you mean, that I should implement the missing methods in the class TotalOrderedTopicProxy? And which clients do you think of?", "author": "andrewoelfing", "createdAt": "2020-06-22T21:24:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU5MjM0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTAwMDAzMw==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r449000033", "bodyText": "When talking about ITopic implementations, there are several:\n\nTopicProxy - member side implementation, no ordering guarantees, events are published through EventService#publishEvent which means every member can notify every other member\nTotalOrderedTopicProxy - member side implementation, an extension of TopicProxy which is used when TopicConfig#isGlobalOrderingEnabled, doesn't publish events locally through EventService#publishEvent but sends partition operations to the same partition so events published on all members are ordered\nClientTopicProxy - client side implementation, invokes operations on the partition owner for the topic name, which means the events are ordered. That member, on the other hand, calls the EventService#publishEvent in PublishOperation#run\nReliableTopicProxy, ClientReliableTopicProxy - use ringbuffer instead of EventService#publishEvent, all implementations order messages because they use a single ringbuffer as a backing structure. Since it doesn't use EventService, it's not supposed to be lossy\n\nIf I remember correctly, what I meant to say is - don't invoke partition operations then in TopicProxy, use the EventService#publishEvent. It is already async so probably your sync and async implementation in TopicProxy will be the same. On the other hand, you should invoke partition operations in TotalOrderedTopicProxy since there events published from different members will then be serialized and published through a single partition owner.\nIf it still doesn't make sense, please tell me, I'll take a closer look and provide some code snippets, I just didn't want to keep you waiting for months :)", "author": "mmedenjak", "createdAt": "2020-07-02T13:26:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU5MjM0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTYxNTY0NA==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r449615644", "bodyText": "Something like this:\npublic abstract class TopicProxySupport extends AbstractDistributedObject<TopicService> implements InitializingObject {\n\n    protected final LocalTopicStatsImpl topicStats;\n    \n    private final String name;\n    private final ClassLoader configClassLoader;\n    private final TopicService topicService;\n    private boolean multithreaded;\n\n    public TopicProxySupport(String name, NodeEngine nodeEngine, TopicService service) {\n        super(nodeEngine, service);\n        this.name = name;\n        this.configClassLoader = nodeEngine.getConfigClassLoader();\n        this.topicService = service;\n        this.topicStats = topicService.getLocalTopicStats(name);\n    }\n\n    @Override\n    public void initialize() {\n        NodeEngine nodeEngine = getNodeEngine();\n        TopicConfig config = nodeEngine.getConfig().findTopicConfig(name);\n        multithreaded = config.isMultiThreadingEnabled();\n        for (ListenerConfig listenerConfig : config.getMessageListenerConfigs()) {\n            initialize(listenerConfig);\n        }\n    }\n\n    private void initialize(ListenerConfig listenerConfig) {\n        NodeEngine nodeEngine = getNodeEngine();\n\n        MessageListener listener = loadListener(listenerConfig);\n\n        if (listener == null) {\n            return;\n        }\n\n        if (listener instanceof HazelcastInstanceAware) {\n            HazelcastInstanceAware hazelcastInstanceAware = (HazelcastInstanceAware) listener;\n            hazelcastInstanceAware.setHazelcastInstance(nodeEngine.getHazelcastInstance());\n        }\n        addMessageListenerInternal(listener);\n    }\n\n    private MessageListener loadListener(ListenerConfig listenerConfig) {\n        try {\n            MessageListener listener = (MessageListener) listenerConfig.getImplementation();\n            if (listener == null && listenerConfig.getClassName() != null) {\n                listener = ClassLoaderUtil.newInstance(configClassLoader, listenerConfig.getClassName());\n            }\n            return listener;\n        } catch (Exception e) {\n            throw ExceptionUtil.rethrow(e);\n        }\n    }\n\n    public LocalTopicStats getLocalTopicStatsInternal() {\n        return topicService.getLocalTopicStats(name);\n    }\n\n    /**\n     * Publishes the message and increases the local statistics\n     * for the number of published messages.\n     *\n     * @param message the message to be published\n     */\n    public void publishInternal(@Nonnull Object message) {\n        topicStats.incrementPublishes();\n        topicService.publishMessage(name, message, multithreaded);\n    }\n\n    public @Nonnull\n    UUID addMessageListenerInternal(@Nonnull MessageListener listener) {\n        return topicService.addMessageListener(name, listener);\n    }\n\n    public boolean removeMessageListenerInternal(@Nonnull UUID registrationId) {\n        return topicService.removeMessageListener(name, registrationId);\n    }\n\n    @Override\n    public String getServiceName() {\n        return TopicService.SERVICE_NAME;\n    }\n\n    @Override\n    public String getName() {\n        return name;\n    }\n}\npublic class TopicProxy<E> extends TopicProxySupport implements ITopic<E> {\n\n    protected static final String NULL_MESSAGE_IS_NOT_ALLOWED = \"Null message is not allowed!\";\n    protected static final String NULL_LISTENER_IS_NOT_ALLOWED = \"Null listener is not allowed!\";\n\n    public TopicProxy(String name, NodeEngine nodeEngine, TopicService service) {\n        super(name, nodeEngine, service);\n    }\n\n    @Override\n    public void publish(@Nonnull E message) {\n        checkNotNull(message, NULL_MESSAGE_IS_NOT_ALLOWED);\n        publishInternal(message);\n    }\n\n    @Override\n    public CompletionStage<E> publishAsync(@Nonnull E message) {\n        publish(message);\n        return InternalCompletableFuture.completedFuture(null);\n    }\n\n    @Override\n    public void publishAll(@Nonnull Collection<? extends E> messages) {\n        checkNotNull(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n        checkNoNullInside(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n        messages.forEach(this::publishInternal);\n    }\n\n    @Override\n    public CompletionStage<E> publishAllAsync(@Nonnull Collection<? extends E> messages) {\n        publishAll(messages);\n        return InternalCompletableFuture.completedFuture(null);\n    }\n\n    @Nonnull\n    @Override\n    public UUID addMessageListener(@Nonnull MessageListener<E> listener) {\n        checkNotNull(listener, NULL_LISTENER_IS_NOT_ALLOWED);\n        return addMessageListenerInternal(listener);\n    }\n\n    @Override\n    public boolean removeMessageListener(@Nonnull UUID registrationId) {\n        return removeMessageListenerInternal(registrationId);\n    }\n\n    @Nonnull\n    @Override\n    public LocalTopicStats getLocalTopicStats() {\n        return getLocalTopicStatsInternal();\n    }\n}\npublic class TotalOrderedTopicProxy<E> extends TopicProxy<E> {\n\n    private final OperationService operationService;\n    private final SerializationService serializationService;\n    private final int partitionId;\n\n    public TotalOrderedTopicProxy(String name, NodeEngine nodeEngine, TopicService service) {\n        super(name, nodeEngine, service);\n        this.partitionId = nodeEngine.getPartitionService()\n                                     .getPartitionId(getNameAsPartitionAwareData());\n        this.operationService = nodeEngine.getOperationService();\n        this.serializationService = nodeEngine.getSerializationService();\n    }\n\n    @Override\n    public void publish(@Nonnull  E message) {\n        checkNotNull(message, NULL_MESSAGE_IS_NOT_ALLOWED);\n        Operation op = new PublishOperation(getName(), toData(message))\n                .setPartitionId(partitionId);\n        publishInternalAsync(op).joinInternal();\n    }\n\n    @Override\n    public CompletionStage<E> publishAsync(@Nonnull E message) {\n        checkNotNull(message, NULL_MESSAGE_IS_NOT_ALLOWED);\n        Operation op = new PublishOperation(getName(), toData(message))\n                .setPartitionId(partitionId);\n        return newDelegatingFuture(serializationService, publishInternalAsync(op));\n    }\n\n    @Override\n    public void publishAll(@Nonnull Collection<? extends E> messages) {\n        checkNotNull(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n        checkNoNullInside(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n\n        Operation op = new PublishAllOperation(getName(), toDataArray(messages));\n        publishInternalAsync(op).joinInternal();\n    }\n\n    @Override\n    public CompletionStage<E> publishAllAsync(@Nonnull Collection<? extends E> messages) {\n        checkNotNull(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n        checkNoNullInside(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n        \n        Operation op = new PublishAllOperation(getName(), toDataArray(messages));\n        return newDelegatingFuture(serializationService, publishInternalAsync(op));\n    }\n\n    private Data[] toDataArray(Collection<? extends E> collection) {\n        Data[] items = new Data[collection.size()];\n        int k = 0;\n        for (E item : collection) {\n            checkNotNull(item, \"collection mustn't contains null items\");\n            items[k] = toData(item);\n            k++;\n        }\n        return items;\n    }\n\n    private InternalCompletableFuture<Data> publishInternalAsync(Operation operation) {\n        topicStats.incrementPublishes();\n        try {\n            InvocationFuture<Data> future = operationService.invokeOnPartition(SERVICE_NAME, operation, partitionId);\n            return future;\n        } catch (Throwable t) {\n            throw rethrow(t);\n        }\n    }\n}", "author": "mmedenjak", "createdAt": "2020-07-03T14:40:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU5MjM0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYyNzgwNQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r434627805", "bodyText": "Haven't looked at the tests too closely (will look after other comments are addressed) but as a general idea since all implementations share the same interface, I suggest that you write the test once and just parametrize it - either use the reliable topic or regular topic, the ordered or non-ordered topic.", "author": "mmedenjak", "createdAt": "2020-06-03T14:51:15Z", "path": "hazelcast/src/test/java/com/hazelcast/client/topic/ClientReliableTopicTest.java", "diffHunk": "@@ -56,7 +56,7 @@\n \n @RunWith(HazelcastParallelClassRunner.class)\n @Category({QuickTest.class, ParallelJVMTest.class})\n-public class ClientReliableTopicTest extends HazelcastTestSupport {\n+public class ClientReliableTopicTest extends TopicTest {", "originalCommit": "7bd347cabbde9a29e6bdddc08f5dc03795189a3d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ4NTQyMA==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r443485420", "bodyText": "As @sancar mentioned, it is the easiest way to extend this class.\n#16946 (comment)\nOr do you have any other problem in mind?", "author": "andrewoelfing", "createdAt": "2020-06-22T11:12:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYyNzgwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTAwMTg2Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r449001862", "bodyText": "Yeah, that'll work too. Parametrized tests are good if you stick to a single instance type (member or client) and then want to test different implementations - ordered vs non-ordered, reliable topic vs non-reliable topic.\nAnd then, once you have such a parametrized test using a member as the test instance, you override it as you say and call the same methods on the client.\nAnyway, if you see yourself copying the same tests for testing different topic implementations, think about parametrizing tests.", "author": "mmedenjak", "createdAt": "2020-07-02T13:29:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYyNzgwNQ=="}], "type": "inlineReview"}, {"oid": "1fceb14e25cc2237b2adcbfb2a7af3b989640de5", "url": "https://github.com/hazelcast/hazelcast/commit/1fceb14e25cc2237b2adcbfb2a7af3b989640de5", "message": "#4233 WIP review-advised changes\ncode refactorings, version check,", "committedDate": "2020-07-12T12:14:30Z", "type": "forcePushed"}, {"oid": "3f19e53074510f0ec3624e9642d620f0605ca023", "url": "https://github.com/hazelcast/hazelcast/commit/3f19e53074510f0ec3624e9642d620f0605ca023", "message": "#4233 Add ITopic.publishAll, ITopic.publishAllAsync and ITopic.publishAsync methods\nImplementing UnitTests\nCleanUp Code\npublishAll, publishAsync, publishAllAsync", "committedDate": "2020-08-01T06:08:26Z", "type": "commit"}, {"oid": "bda213ae52a3fab1bc10d8f2703c5f8419ae0e06", "url": "https://github.com/hazelcast/hazelcast/commit/bda213ae52a3fab1bc10d8f2703c5f8419ae0e06", "message": "#4233 Fixed CodecHashTest issue\nalso implemented more unit tests", "committedDate": "2020-08-01T06:08:27Z", "type": "commit"}, {"oid": "f64be4c384ebbe5464549fe3213e969674129555", "url": "https://github.com/hazelcast/hazelcast/commit/f64be4c384ebbe5464549fe3213e969674129555", "message": "#4233 fixes after review", "committedDate": "2020-08-01T06:08:27Z", "type": "commit"}, {"oid": "6a1ffb41918968abe5807804ccc993cb3cd697ca", "url": "https://github.com/hazelcast/hazelcast/commit/6a1ffb41918968abe5807804ccc993cb3cd697ca", "message": "#4233 review-advised changes\nmore UnitTests, removed additional operations, fixed return values of async methods", "committedDate": "2020-08-01T06:08:27Z", "type": "commit"}, {"oid": "8e9aec279487de2ce281fa58ae2d751c48e1367e", "url": "https://github.com/hazelcast/hazelcast/commit/8e9aec279487de2ce281fa58ae2d751c48e1367e", "message": "#4233 WIP review-advised changes\ncode refactorings, version check,", "committedDate": "2020-08-01T06:08:27Z", "type": "commit"}, {"oid": "f2a63fb2076478f5922489b29a8f7cf74a01cf97", "url": "https://github.com/hazelcast/hazelcast/commit/f2a63fb2076478f5922489b29a8f7cf74a01cf97", "message": "#4233 WIP review-advised changes\ncode refactorings, version check,", "committedDate": "2020-08-01T06:08:28Z", "type": "commit"}, {"oid": "06bf94d90dce7969f542325a4d0d2dab5475540d", "url": "https://github.com/hazelcast/hazelcast/commit/06bf94d90dce7969f542325a4d0d2dab5475540d", "message": "#4233 WIP review-advised changes", "committedDate": "2020-08-25T21:50:19Z", "type": "commit"}, {"oid": "06bf94d90dce7969f542325a4d0d2dab5475540d", "url": "https://github.com/hazelcast/hazelcast/commit/06bf94d90dce7969f542325a4d0d2dab5475540d", "message": "#4233 WIP review-advised changes", "committedDate": "2020-08-25T21:50:19Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIwNzI4Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r478207283", "bodyText": "Do we actually throw it or do we complete the future with this exception?", "author": "mmedenjak", "createdAt": "2020-08-27T07:17:01Z", "path": "hazelcast/src/main/java/com/hazelcast/topic/ITopic.java", "diffHunk": "@@ -63,6 +66,16 @@\n      */\n     void publish(@Nonnull E message);\n \n+    /**\n+     * Publishes the message to all subscribers of this topic.\n+     *\n+     * @param message the message to publish to all subscribers of this topic\n+     * @return the CompletionStage to synchronize on completion.\n+     * @throws TopicOverloadException if the consumer is too slow", "originalCommit": "06bf94d90dce7969f542325a4d0d2dab5475540d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY1MDE5OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r478650199", "bodyText": "Ok, you are right. The future is completed with this exception returnFuture.completeExceptionally(t);\nI removed the @throws.", "author": "andrewoelfing", "createdAt": "2020-08-27T19:36:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIwNzI4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIwNzU5Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r478207596", "bodyText": "Same comment as on publishAsync", "author": "mmedenjak", "createdAt": "2020-08-27T07:17:40Z", "path": "hazelcast/src/main/java/com/hazelcast/topic/ITopic.java", "diffHunk": "@@ -95,4 +108,23 @@\n      * @return statistics about this topic\n      */\n     @Nonnull LocalTopicStats getLocalTopicStats();\n+\n+    /**\n+     * Publishes all messages to all subscribers of this topic.\n+     *\n+     * @param messages the messages to publish to all subscribers of this topic\n+     * @throws TopicOverloadException if the consumer is too slow\n+     *                                (only works in combination with reliable topic)\n+     */\n+    void publishAll(@Nonnull Collection<? extends E> messages) throws ExecutionException, InterruptedException;\n+\n+    /**\n+     * Publishes all messages to all subscribers of this topic.\n+     *\n+     * @param messages the messages to publish to all subscribers of this topic\n+     * @return the CompletionStage to synchronize on completion.\n+     * @throws TopicOverloadException if the consumer is too slow", "originalCommit": "06bf94d90dce7969f542325a4d0d2dab5475540d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY1MDM1OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r478650359", "bodyText": "Same answer. ;)", "author": "andrewoelfing", "createdAt": "2020-08-27T19:36:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIwNzU5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIwODA0Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r478208042", "bodyText": "Can you check if this statistic is per-message or per-operation?", "author": "mmedenjak", "createdAt": "2020-08-27T07:18:36Z", "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/PublishAllOperation.java", "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.topic.impl;\n+\n+import com.hazelcast.config.TopicConfig;\n+import com.hazelcast.internal.nio.IOUtil;\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.spi.impl.eventservice.EventRegistration;\n+import com.hazelcast.spi.impl.eventservice.EventService;\n+import com.hazelcast.spi.impl.operationservice.AbstractNamedOperation;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.concurrent.locks.Lock;\n+\n+/**\n+ * ITopic publication operation used when global ordering is enabled\n+ * (all nodes listening to the same topic get their messages in the same order).\n+ *\n+ * @see TotalOrderedTopicProxy\n+ * @see TopicConfig#isGlobalOrderingEnabled()\n+ */\n+public class PublishAllOperation extends AbstractNamedOperation\n+        implements IdentifiedDataSerializable {\n+\n+    private Data[] messages;\n+\n+    public PublishAllOperation() {\n+    }\n+\n+    @SuppressFBWarnings(\"EI_EXPOSE_REP\")\n+    public PublishAllOperation(String name, Data[] messages) {\n+        super(name);\n+        this.messages = messages;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * Increments the local statistics for the number of published\n+     * messages.\n+     *\n+     * @throws Exception\n+     */\n+    @Override\n+    public void beforeRun() throws Exception {\n+        TopicService service = getService();\n+        service.incrementPublishes(name);", "originalCommit": "06bf94d90dce7969f542325a4d0d2dab5475540d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY1Nzg5Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r478657896", "bodyText": "It seems that the statistics are calculated per-message (com.hazelcast.topic.impl.TopicService#dispatchEvent).\nBecause of this, I have to move this method call inside the com.hazelcast.topic.impl.PublishAllOperation#run method where all the messages are published? Correct?", "author": "andrewoelfing", "createdAt": "2020-08-27T19:51:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIwODA0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTMxNTc3NA==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r479315774", "bodyText": "Yes, right, looks good.", "author": "mmedenjak", "createdAt": "2020-08-28T13:56:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIwODA0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIxMDE5MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r478210191", "bodyText": "Since PublishAllOperation is a new operation and since this member might be running in a cluster with older members, we need to introduce the cluster version check:\n        Version clusterVersion = getNodeEngine().getClusterService().getClusterVersion();\n        // RU_COMPAT_4_0\n        if (!clusterVersion.isGreaterOrEqual(Versions.V4_1)){\n            throw new UnsupportedOperationException(\"Publish all is not available on cluster version \" + clusterVersion\n                    + \". Please upgrade the cluster version to \" + Versions.V4_1);\n        }\nSame in other methods using this operation.", "author": "mmedenjak", "createdAt": "2020-08-27T07:22:52Z", "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/TotalOrderedTopicProxy.java", "diffHunk": "@@ -47,4 +65,41 @@ public void publish(@Nonnull  E message) {\n         InternalCompletableFuture f = invokeOnPartition(operation);\n         f.joinInternal();\n     }\n+\n+    @Override\n+    public CompletionStage<Void> publishAsync(@Nonnull E message) {\n+        checkNotNull(message, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        Operation op = new PublishOperation(getName(), toData(message))\n+                .setPartitionId(partitionId);\n+        return newDelegatingFuture(serializationService, publishInternalAsync(op));\n+    }\n+\n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> messages) {\n+        checkNotNull(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        Operation op = new PublishAllOperation(getName(), toDataArray(messages));", "originalCommit": "06bf94d90dce7969f542325a4d0d2dab5475540d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY1MTc1OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r478651759", "bodyText": "Got it - changed it.", "author": "andrewoelfing", "createdAt": "2020-08-27T19:39:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIxMDE5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIxNTM0OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r478215349", "bodyText": "Since none of the operations that are passed as arguments to this method actually have a Data result (or even have any kind of result), you can change it to InternalCompletableFuture<Void>. Also, then you don't need to wrap it in newDelegatingFuture(serializationService, publishInternalAsync(op)) as the serialization service doesn't have anything to deserialize.\nIn the end, we then get this:\n    @Override\n    public CompletionStage<Void> publishAsync(@Nonnull E message) {\n        checkNotNull(message, NULL_MESSAGE_IS_NOT_ALLOWED);\n        Operation op = new PublishOperation(getName(), toData(message))\n                .setPartitionId(partitionId);\n        return publishInternalAsync(op);\n    }\n\n    @Override\n    public void publishAll(@Nonnull Collection<? extends E> messages) {\n        checkNotNull(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n        checkNoNullInside(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n        Version clusterVersion = getNodeEngine().getClusterService().getClusterVersion();\n        // RU_COMPAT_4_0\n        if (!clusterVersion.isGreaterOrEqual(Versions.V4_1)) {\n            throw new UnsupportedOperationException(\"Publish all is not available on cluster version \" + clusterVersion\n                    + \". Please upgrade the cluster version to \" + Versions.V4_1);\n        }\n\n        Operation op = new PublishAllOperation(getName(), toDataArray(messages));\n        publishInternalAsync(op).joinInternal();\n    }\n\n    @Override\n    public InternalCompletableFuture<Void> publishAllAsync(@Nonnull Collection<? extends E> messages) {\n        checkNotNull(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n        checkNoNullInside(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n        Version clusterVersion = getNodeEngine().getClusterService().getClusterVersion();\n        // RU_COMPAT_4_0\n        if (!clusterVersion.isGreaterOrEqual(Versions.V4_1)) {\n            throw new UnsupportedOperationException(\"Publish all is not available on cluster version \" + clusterVersion\n                    + \". Please upgrade the cluster version to \" + Versions.V4_1);\n        }\n\n        Operation op = new PublishAllOperation(getName(), toDataArray(messages));\n        return publishInternalAsync(op);\n    }\n\n    private InternalCompletableFuture<Void> publishInternalAsync(Operation operation) {\n        topicStats.incrementPublishes();\n        try {\n            return operationService.invokeOnPartition(OperationService.SERVICE_NAME, operation, partitionId);\n        } catch (Throwable t) {\n            throw rethrow(t);\n        }\n    }", "author": "mmedenjak", "createdAt": "2020-08-27T07:32:45Z", "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/TotalOrderedTopicProxy.java", "diffHunk": "@@ -47,4 +65,41 @@ public void publish(@Nonnull  E message) {\n         InternalCompletableFuture f = invokeOnPartition(operation);\n         f.joinInternal();\n     }\n+\n+    @Override\n+    public CompletionStage<Void> publishAsync(@Nonnull E message) {\n+        checkNotNull(message, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        Operation op = new PublishOperation(getName(), toData(message))\n+                .setPartitionId(partitionId);\n+        return newDelegatingFuture(serializationService, publishInternalAsync(op));\n+    }\n+\n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> messages) {\n+        checkNotNull(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        Operation op = new PublishAllOperation(getName(), toDataArray(messages));\n+        publishInternalAsync(op).joinInternal();\n+    }\n+\n+    @Override\n+    public CompletionStage<Void> publishAllAsync(@Nonnull Collection<? extends E> messages) {\n+        checkNotNull(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        Operation op = new PublishAllOperation(getName(), toDataArray(messages));\n+        return newDelegatingFuture(serializationService, publishInternalAsync(op));\n+    }\n+\n+    private InternalCompletableFuture<Data> publishInternalAsync(Operation operation) {", "originalCommit": "06bf94d90dce7969f542325a4d0d2dab5475540d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY5NTE0MA==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r478695140", "bodyText": "Ok, makes sense. Changed it.", "author": "andrewoelfing", "createdAt": "2020-08-27T21:05:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIxNTM0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIxNzIxMA==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r478217210", "bodyText": "Minor: add the // RU_COMPAT_4_0 comment here so we can easily find it and remove it in 4.2.", "author": "mmedenjak", "createdAt": "2020-08-27T07:36:10Z", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/protocol/task/topic/TopicPublishAllMessageTask.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.client.impl.protocol.task.topic;\n+\n+import com.hazelcast.client.impl.protocol.ClientMessage;\n+import com.hazelcast.client.impl.protocol.codec.TopicPublishAllCodec;\n+import com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\n+import com.hazelcast.instance.impl.Node;\n+import com.hazelcast.internal.cluster.Versions;\n+import com.hazelcast.internal.nio.Connection;\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.security.permission.ActionConstants;\n+import com.hazelcast.security.permission.TopicPermission;\n+import com.hazelcast.spi.impl.operationservice.Operation;\n+import com.hazelcast.topic.impl.PublishAllOperation;\n+import com.hazelcast.topic.impl.TopicService;\n+import com.hazelcast.version.Version;\n+\n+import java.security.Permission;\n+import java.util.List;\n+\n+public class TopicPublishAllMessageTask\n+        extends AbstractPartitionMessageTask<TopicPublishAllCodec.RequestParameters> {\n+\n+    public TopicPublishAllMessageTask(ClientMessage clientMessage, Node node, Connection connection) {\n+        super(clientMessage, node, connection);\n+    }\n+\n+    @Override\n+    protected Operation prepareOperation() {\n+        Version clusterVersion = nodeEngine.getClusterService().getClusterVersion();", "originalCommit": "06bf94d90dce7969f542325a4d0d2dab5475540d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY4NTQ1MA==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r478685450", "bodyText": "Fixed", "author": "andrewoelfing", "createdAt": "2020-08-27T20:45:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIxNzIxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIxOTgyMQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r478219821", "bodyText": "Minor: you can use Collections.singleton(payload).", "author": "mmedenjak", "createdAt": "2020-08-27T07:40:53Z", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientReliableTopicProxy.java", "diffHunk": "@@ -118,6 +126,14 @@ public void publish(@Nonnull E payload) {\n         }\n     }\n \n+    @Override\n+    public CompletionStage<Void> publishAsync(@Nonnull E payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        Collection<E> messages = new ArrayList<>();\n+        messages.add(payload);\n+        return publishAllAsync(messages);", "originalCommit": "06bf94d90dce7969f542325a4d0d2dab5475540d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY2MTQ2Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r478661463", "bodyText": "Fixed", "author": "andrewoelfing", "createdAt": "2020-08-27T19:57:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIxOTgyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIyMjA2NA==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r478222064", "bodyText": "Just occurred to me - can you check if this addition is atomic - either all are added or none? Asking because then it's safe to retry but if we added some and not others, we might end up adding some items multiple times.", "author": "mmedenjak", "createdAt": "2020-08-27T07:45:00Z", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientReliableTopicProxy.java", "diffHunk": "@@ -197,6 +213,125 @@ public LocalTopicStats getLocalTopicStats() {\n         throw new UnsupportedOperationException(\"Locality is ambiguous for client!\");\n     }\n \n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        try {\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(toData(m), null))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    long sequenceId = ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    if (sequenceId == -1) {\n+                        throw new TopicOverloadException(\"Failed to publish messages: \" + payload + \" on topic:\" + getName());\n+                    }\n+                    break;\n+                case DISCARD_OLDEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.OVERWRITE).toCompletableFuture().get();\n+                    break;\n+                case DISCARD_NEWEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    break;\n+                case BLOCK:\n+                    long timeoutMs = INITIAL_BACKOFF_MS;\n+                    for (; ; ) {\n+                        long result = ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();", "originalCommit": "06bf94d90dce7969f542325a4d0d2dab5475540d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY5MjQ4OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r478692489", "bodyText": "Ok, I investigated this. The com.hazelcast.ringbuffer.impl.RingbufferProxy#addAllAsync method uses the com.hazelcast.ringbuffer.impl.operations.AddAllOperation class for adding messages. In this operation (please see the run method), a check about the remaining capacity is accomplished. So either every item is added to the ringbuffer or none.", "author": "andrewoelfing", "createdAt": "2020-08-27T20:59:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIyMjA2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTMxODUwOQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r479318509", "bodyText": "Great, thanks!", "author": "mmedenjak", "createdAt": "2020-08-28T13:59:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIyMjA2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIyMzMwOA==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r478223308", "bodyText": "Minor: this was previously in the try-catch block and was wrapped in case serialization failed (I think) so maybe we can follow the same approach here. Not sure if we should complete the future or throw it to the caller. Maybe fail-fast and throwing it directly is the better option here.", "author": "mmedenjak", "createdAt": "2020-08-27T07:47:15Z", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientReliableTopicProxy.java", "diffHunk": "@@ -197,6 +213,125 @@ public LocalTopicStats getLocalTopicStats() {\n         throw new UnsupportedOperationException(\"Locality is ambiguous for client!\");\n     }\n \n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        try {\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(toData(m), null))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    long sequenceId = ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    if (sequenceId == -1) {\n+                        throw new TopicOverloadException(\"Failed to publish messages: \" + payload + \" on topic:\" + getName());\n+                    }\n+                    break;\n+                case DISCARD_OLDEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.OVERWRITE).toCompletableFuture().get();\n+                    break;\n+                case DISCARD_NEWEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    break;\n+                case BLOCK:\n+                    long timeoutMs = INITIAL_BACKOFF_MS;\n+                    for (; ; ) {\n+                        long result = ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                        if (result != -1) {\n+                            break;\n+                        }\n+\n+                        MILLISECONDS.sleep(timeoutMs);\n+                        timeoutMs *= 2;\n+                        if (timeoutMs > MAX_BACKOFF) {\n+                            timeoutMs = MAX_BACKOFF;\n+                        }\n+                    }\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+            }\n+        } catch (RuntimeException e) {\n+            throw e;\n+        } catch (Exception e) {\n+            throw (RuntimeException) peel(e, null,\n+                    \"Failed to publish messages: \" + payload + \" to topic:\" + getName());\n+        }\n+    }\n+\n+    @Override\n+    public CompletionStage<Void> publishAllAsync(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        InternalCompletableFuture<Void> returnFuture = new InternalCompletableFuture<>();\n+\n+        List<ReliableTopicMessage> messages = payload.stream()", "originalCommit": "06bf94d90dce7969f542325a4d0d2dab5475540d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODg1MTE1Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r478851156", "bodyText": "I've changed the code in the same way like publishAll", "author": "andrewoelfing", "createdAt": "2020-08-28T06:11:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIyMzMwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTMyMTg3Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r479321872", "bodyText": "I don't see the change, have you pushed it?", "author": "mmedenjak", "createdAt": "2020-08-28T14:03:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIyMzMwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgyMDU0Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r479820546", "bodyText": "Now it's pushed.", "author": "andrewoelfing", "createdAt": "2020-08-30T21:54:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIyMzMwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIyNDAxOA==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r478224018", "bodyText": "Do you have a test where this is exercised? I'd like to see which threads are involved in this execution and if it works nicely.", "author": "mmedenjak", "createdAt": "2020-08-27T07:48:36Z", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientReliableTopicProxy.java", "diffHunk": "@@ -197,6 +213,125 @@ public LocalTopicStats getLocalTopicStats() {\n         throw new UnsupportedOperationException(\"Locality is ambiguous for client!\");\n     }\n \n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        try {\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(toData(m), null))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    long sequenceId = ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    if (sequenceId == -1) {\n+                        throw new TopicOverloadException(\"Failed to publish messages: \" + payload + \" on topic:\" + getName());\n+                    }\n+                    break;\n+                case DISCARD_OLDEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.OVERWRITE).toCompletableFuture().get();\n+                    break;\n+                case DISCARD_NEWEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    break;\n+                case BLOCK:\n+                    long timeoutMs = INITIAL_BACKOFF_MS;\n+                    for (; ; ) {\n+                        long result = ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                        if (result != -1) {\n+                            break;\n+                        }\n+\n+                        MILLISECONDS.sleep(timeoutMs);\n+                        timeoutMs *= 2;\n+                        if (timeoutMs > MAX_BACKOFF) {\n+                            timeoutMs = MAX_BACKOFF;\n+                        }\n+                    }\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+            }\n+        } catch (RuntimeException e) {\n+            throw e;\n+        } catch (Exception e) {\n+            throw (RuntimeException) peel(e, null,\n+                    \"Failed to publish messages: \" + payload + \" to topic:\" + getName());\n+        }\n+    }\n+\n+    @Override\n+    public CompletionStage<Void> publishAllAsync(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        InternalCompletableFuture<Void> returnFuture = new InternalCompletableFuture<>();\n+\n+        List<ReliableTopicMessage> messages = payload.stream()\n+                .map(m -> new ReliableTopicMessage(toData(m), null))\n+                .collect(Collectors.toList());\n+        switch (overloadPolicy) {\n+            case ERROR:\n+                ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL)\n+                        .whenCompleteAsync((id, t) -> {\n+                            if (t != null) {\n+                                returnFuture.completeExceptionally(t);\n+                            }\n+                            if (id == -1) {\n+                                returnFuture.completeExceptionally(new TopicOverloadException(\n+                                        \"Failed to publish messages: \" + payload + \" on topic:\" + getName()));\n+                            }\n+                            returnFuture.complete(null);\n+                        });\n+\n+                break;\n+            case DISCARD_OLDEST:\n+                ringbuffer.addAllAsync(messages, OverflowPolicy.OVERWRITE)\n+                        .whenCompleteAsync((id, t) -> {\n+                            if (t != null) {\n+                                returnFuture.completeExceptionally(t);\n+                            }\n+                            returnFuture.complete(null);\n+                        });\n+                break;\n+            case DISCARD_NEWEST:\n+                ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL)\n+                        .whenCompleteAsync((id, t) -> {\n+                            if (t != null) {\n+                                returnFuture.completeExceptionally(t);\n+                            }\n+                            returnFuture.complete(null);\n+                        });\n+                break;\n+            case BLOCK:\n+                addAsyncAndBlock(payload, returnFuture, messages, INITIAL_BACKOFF_MS);\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+        }\n+\n+        return returnFuture;\n+    }\n+\n+    private void addAsyncAndBlock(@Nonnull Collection<? extends E> payload,", "originalCommit": "06bf94d90dce7969f542325a4d0d2dab5475540d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA3Nzc4MA==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r484077780", "bodyText": "Hello @mmedenjak, I've finished implementing some extended tests. Please see com.hazelcast.client.topic.ClientReliableTopicOverloadTest (and in special the extended abstract class com.hazelcast.topic.impl.reliable.TopicOverloadAbstractTest)", "author": "andrewoelfing", "createdAt": "2020-09-06T14:35:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIyNDAxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIyNjMyMQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r478226321", "bodyText": "Do we have to honor the overloadPolicy here? Seems like we do in publish and we also increment the stats (keep in mind that you need to check if we increment per-message or per-operation). Same comment for publishAll and publishAllAsync", "author": "mmedenjak", "createdAt": "2020-08-27T07:52:59Z", "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/reliable/ReliableTopicProxy.java", "diffHunk": "@@ -184,6 +194,22 @@ public void publish(@Nonnull E payload) {\n         }\n     }\n \n+    @Override\n+    public CompletionStage<Void> publishAsync(@Nonnull E message) {\n+        checkNotNull(message, NULL_MESSAGE_IS_NOT_ALLOWED);", "originalCommit": "06bf94d90dce7969f542325a4d0d2dab5475540d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgyMTcyNA==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r479821724", "bodyText": "Ok, I've changed (and pushed) it but the class with all its methods looks like a big mess.\nI will try to cleanup some things tomorrow.", "author": "andrewoelfing", "createdAt": "2020-08-30T22:06:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIyNjMyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk2NTAwMw==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r481965003", "bodyText": "Ok, I've fixed and cleaned it up a little bit. The only thing actually missing is the dedicated test for addAsyncAndBlock.", "author": "andrewoelfing", "createdAt": "2020-09-02T10:27:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIyNjMyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIyNzY5OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r478227699", "bodyText": "If you want, replace this with:\n        return collection.stream().map(item -> {\n            checkNotNull(item, \"collection can't contains null items\");\n            return toData(item);\n        }).toArray(Data[]::new);", "author": "mmedenjak", "createdAt": "2020-08-27T07:55:28Z", "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/TopicProxy.java", "diffHunk": "@@ -64,6 +79,33 @@ public boolean removeMessageListener(@Nonnull UUID registrationId) {\n     public LocalTopicStats getLocalTopicStats() {\n         return getLocalTopicStatsInternal();\n     }\n+\n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> messages) {\n+        checkNotNull(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        messages.forEach(this::publishInternal);\n+    }\n+\n+    @Override\n+    public CompletionStage<Void> publishAllAsync(@Nonnull Collection<? extends E> messages) {\n+        checkNotNull(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        publishAll(messages);\n+        return InternalCompletableFuture.completedFuture(null);\n+    }\n+\n+\n+    protected Data[] toDataArray(Collection<? extends E> collection) {\n+        Data[] items = new Data[collection.size()];", "originalCommit": "06bf94d90dce7969f542325a4d0d2dab5475540d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY1MTUwOA==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r478651508", "bodyText": "Much more beautiful. :)\nI've changed it.", "author": "andrewoelfing", "createdAt": "2020-08-27T19:38:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIyNzY5OQ=="}], "type": "inlineReview"}, {"oid": "07ba970db2c3e893d5211520367764a628094703", "url": "https://github.com/hazelcast/hazelcast/commit/07ba970db2c3e893d5211520367764a628094703", "message": "#4233 WIP - code beautification, changed some jdoc", "committedDate": "2020-08-27T21:18:55Z", "type": "commit"}, {"oid": "e9e9a6da6c194a858ab8a2ad1b79c987c1d7ff7f", "url": "https://github.com/hazelcast/hazelcast/commit/e9e9a6da6c194a858ab8a2ad1b79c987c1d7ff7f", "message": "#4233 WIP - Fixed overloadpolicy, fixed try catch", "committedDate": "2020-08-30T21:43:34Z", "type": "commit"}, {"oid": "87a91dce0aa4a4f6b7e62774006d817810c69f4a", "url": "https://github.com/hazelcast/hazelcast/commit/87a91dce0aa4a4f6b7e62774006d817810c69f4a", "message": "#4233 WIP - clean up code", "committedDate": "2020-09-01T05:29:24Z", "type": "commit"}, {"oid": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09", "url": "https://github.com/hazelcast/hazelcast/commit/7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09", "message": "#4233 extended ReliableTopic tests (block, 2x discard, error)", "committedDate": "2020-09-06T14:33:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQyMTA5MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r493421091", "bodyText": "I think this is the wrong kind of NotNull, should probably use javax.annotation.Nonnull", "author": "mmedenjak", "createdAt": "2020-09-23T10:25:57Z", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientReliableTopicProxy.java", "diffHunk": "@@ -35,15 +36,22 @@\n import com.hazelcast.topic.impl.reliable.MessageRunner;\n import com.hazelcast.topic.impl.reliable.ReliableMessageListenerAdapter;\n import com.hazelcast.topic.impl.reliable.ReliableTopicMessage;\n+import org.jetbrains.annotations.NotNull;", "originalCommit": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU4NTcxNA==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r494585714", "bodyText": "Fixed it.", "author": "andrewoelfing", "createdAt": "2020-09-24T20:17:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQyMTA5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQzMTY4NA==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r493431684", "bodyText": "Why do we need this first catch block? Same in publishAllAsync.", "author": "mmedenjak", "createdAt": "2020-09-23T10:37:19Z", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientReliableTopicProxy.java", "diffHunk": "@@ -197,6 +213,120 @@ public LocalTopicStats getLocalTopicStats() {\n         throw new UnsupportedOperationException(\"Locality is ambiguous for client!\");\n     }\n \n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        try {\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(toData(m), null))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    long sequenceId = ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    if (sequenceId == -1) {\n+                        throw new TopicOverloadException(\"Failed to publish messages: \" + payload + \" on topic:\" + getName());\n+                    }\n+                    break;\n+                case DISCARD_OLDEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.OVERWRITE).toCompletableFuture().get();\n+                    break;\n+                case DISCARD_NEWEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    break;\n+                case BLOCK:\n+                    addWithBackoff(messages);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+            }\n+        } catch (RuntimeException e) {", "originalCommit": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU4NTkzMg==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r494585932", "bodyText": "Removed the catch block (both)", "author": "andrewoelfing", "createdAt": "2020-09-24T20:17:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQzMTY4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQzODQxMA==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r493438410", "bodyText": "I think it should be fine, but let's just avoid completing the same future several times and guard it with if-else-if statements. Same on other methods.\nAlso, don't complete it here in case we've scheduled another run because there was no room left for all items.", "author": "mmedenjak", "createdAt": "2020-09-23T10:44:48Z", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientReliableTopicProxy.java", "diffHunk": "@@ -197,6 +213,120 @@ public LocalTopicStats getLocalTopicStats() {\n         throw new UnsupportedOperationException(\"Locality is ambiguous for client!\");\n     }\n \n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        try {\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(toData(m), null))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    long sequenceId = ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    if (sequenceId == -1) {\n+                        throw new TopicOverloadException(\"Failed to publish messages: \" + payload + \" on topic:\" + getName());\n+                    }\n+                    break;\n+                case DISCARD_OLDEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.OVERWRITE).toCompletableFuture().get();\n+                    break;\n+                case DISCARD_NEWEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    break;\n+                case BLOCK:\n+                    addWithBackoff(messages);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+            }\n+        } catch (RuntimeException e) {\n+            throw e;\n+        } catch (Exception e) {\n+            throw (RuntimeException) peel(e, null,\n+                    \"Failed to publish messages: \" + payload + \" to topic:\" + getName());\n+        }\n+    }\n+\n+    @Override\n+    public CompletionStage<Void> publishAllAsync(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        InternalCompletableFuture<Void> returnFuture = new InternalCompletableFuture<>();\n+\n+        try {\n+\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(toData(m), null))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    addAsyncOrFail(payload, returnFuture, messages);\n+                    break;\n+                case DISCARD_OLDEST:\n+                    addAsync(messages, OverflowPolicy.OVERWRITE);\n+                    break;\n+                case DISCARD_NEWEST:\n+                    addAsync(messages, OverflowPolicy.FAIL);\n+                    break;\n+                case BLOCK:\n+                    addAsyncAndBlock(payload, returnFuture, messages, INITIAL_BACKOFF_MS);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+            }\n+        } catch (RuntimeException e) {\n+            throw e;\n+        } catch (Exception e) {\n+            throw (RuntimeException) peel(e, null,\n+                    \"Failed to publish messages: \" + payload + \" to topic:\" + getName());\n+        }\n+        return returnFuture;\n+    }\n+\n+    private void addAsyncAndBlock(@Nonnull Collection<? extends E> payload, InternalCompletableFuture<Void> returnFuture,\n+                                  List<ReliableTopicMessage> messages, long pauseMillis) {\n+        ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).whenCompleteAsync((id, t) -> {\n+            if (t != null) {\n+                returnFuture.completeExceptionally(t);\n+            }\n+            if (id == -1) {\n+                getContext().getTaskScheduler().schedule(\n+                        () -> addAsyncAndBlock(payload, returnFuture, messages, Math.min(pauseMillis * 2, MAX_BACKOFF)),\n+                        pauseMillis, MILLISECONDS);\n+                returnFuture.completeExceptionally(new TopicOverloadException(\n+                        \"Failed to publish messages: \" + payload + \" on topic:\" + getName()));\n+            }\n+            returnFuture.complete(null);", "originalCommit": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU4NjQ2NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r494586465", "bodyText": "Ok, I hope I understand it correctly. Fixed it.", "author": "andrewoelfing", "createdAt": "2020-09-24T20:19:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQzODQxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ0MzU1Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r493443553", "bodyText": "This looks odd. We schedule the task but also complete the future. I think we should probably not complete exceptionally here.", "author": "mmedenjak", "createdAt": "2020-09-23T10:50:29Z", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientReliableTopicProxy.java", "diffHunk": "@@ -197,6 +213,120 @@ public LocalTopicStats getLocalTopicStats() {\n         throw new UnsupportedOperationException(\"Locality is ambiguous for client!\");\n     }\n \n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        try {\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(toData(m), null))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    long sequenceId = ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    if (sequenceId == -1) {\n+                        throw new TopicOverloadException(\"Failed to publish messages: \" + payload + \" on topic:\" + getName());\n+                    }\n+                    break;\n+                case DISCARD_OLDEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.OVERWRITE).toCompletableFuture().get();\n+                    break;\n+                case DISCARD_NEWEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    break;\n+                case BLOCK:\n+                    addWithBackoff(messages);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+            }\n+        } catch (RuntimeException e) {\n+            throw e;\n+        } catch (Exception e) {\n+            throw (RuntimeException) peel(e, null,\n+                    \"Failed to publish messages: \" + payload + \" to topic:\" + getName());\n+        }\n+    }\n+\n+    @Override\n+    public CompletionStage<Void> publishAllAsync(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        InternalCompletableFuture<Void> returnFuture = new InternalCompletableFuture<>();\n+\n+        try {\n+\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(toData(m), null))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    addAsyncOrFail(payload, returnFuture, messages);\n+                    break;\n+                case DISCARD_OLDEST:\n+                    addAsync(messages, OverflowPolicy.OVERWRITE);\n+                    break;\n+                case DISCARD_NEWEST:\n+                    addAsync(messages, OverflowPolicy.FAIL);\n+                    break;\n+                case BLOCK:\n+                    addAsyncAndBlock(payload, returnFuture, messages, INITIAL_BACKOFF_MS);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+            }\n+        } catch (RuntimeException e) {\n+            throw e;\n+        } catch (Exception e) {\n+            throw (RuntimeException) peel(e, null,\n+                    \"Failed to publish messages: \" + payload + \" to topic:\" + getName());\n+        }\n+        return returnFuture;\n+    }\n+\n+    private void addAsyncAndBlock(@Nonnull Collection<? extends E> payload, InternalCompletableFuture<Void> returnFuture,\n+                                  List<ReliableTopicMessage> messages, long pauseMillis) {\n+        ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).whenCompleteAsync((id, t) -> {\n+            if (t != null) {\n+                returnFuture.completeExceptionally(t);\n+            }\n+            if (id == -1) {\n+                getContext().getTaskScheduler().schedule(", "originalCommit": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU4NjY1NA==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r494586654", "bodyText": "Fixed it.", "author": "andrewoelfing", "createdAt": "2020-09-24T20:19:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ0MzU1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ0NjMyNw==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r493446327", "bodyText": "Not used.", "author": "mmedenjak", "createdAt": "2020-09-23T10:53:38Z", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/PartitionSpecificClientProxy.java", "diffHunk": "@@ -87,4 +87,8 @@ protected ClientMessage invokeOnPartition(ClientMessage req) {\n             throw ExceptionUtil.rethrowAllowInterrupted(e);\n         }\n     }\n+\n+    public int getPartitionId() {", "originalCommit": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU4NjcxMA==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r494586710", "bodyText": "removed", "author": "andrewoelfing", "createdAt": "2020-09-24T20:19:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ0NjMyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ0OTI2OA==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r493449268", "bodyText": "Same as in client proxy.", "author": "mmedenjak", "createdAt": "2020-09-23T10:56:57Z", "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/reliable/ReliableTopicProxy.java", "diffHunk": "@@ -21,29 +21,39 @@\n import com.hazelcast.config.ReliableTopicConfig;\n import com.hazelcast.core.HazelcastException;\n import com.hazelcast.core.HazelcastInstanceAware;\n+import com.hazelcast.internal.cluster.Versions;\n import com.hazelcast.internal.monitor.impl.LocalTopicStatsImpl;\n import com.hazelcast.internal.nio.ClassLoaderUtil;\n+import com.hazelcast.internal.serialization.Data;\n import com.hazelcast.internal.util.ExceptionUtil;\n import com.hazelcast.internal.util.UuidUtil;\n-import com.hazelcast.internal.serialization.Data;\n import com.hazelcast.ringbuffer.OverflowPolicy;\n import com.hazelcast.ringbuffer.Ringbuffer;\n import com.hazelcast.spi.impl.AbstractDistributedObject;\n+import com.hazelcast.spi.impl.InternalCompletableFuture;\n import com.hazelcast.spi.impl.NodeEngine;\n import com.hazelcast.topic.ITopic;\n import com.hazelcast.topic.LocalTopicStats;\n import com.hazelcast.topic.MessageListener;\n import com.hazelcast.topic.ReliableMessageListener;\n import com.hazelcast.topic.TopicOverloadException;\n import com.hazelcast.topic.TopicOverloadPolicy;\n+import com.hazelcast.version.Version;\n+import org.jetbrains.annotations.NotNull;", "originalCommit": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU4NjgxMw==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r494586813", "bodyText": "fixed", "author": "andrewoelfing", "createdAt": "2020-09-24T20:19:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ0OTI2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ1MTI5Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r493451297", "bodyText": "Since the stat says it is the number of published messages, we need to increment this by number of messages, and only in cases we successfully published. I guess the publish is wrong then and it should be fixed but I can do it in another PR.", "author": "mmedenjak", "createdAt": "2020-09-23T10:59:17Z", "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/reliable/ReliableTopicProxy.java", "diffHunk": "@@ -255,4 +276,138 @@ protected void postDestroy() {\n     public LocalTopicStats getLocalTopicStats() {\n         return localTopicStats;\n     }\n+\n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        // RU_COMPAT_4_0\n+        checkClusterVersion(Versions.V4_1);\n+\n+        try {\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(nodeEngine.toData(m), thisAddress))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    long sequenceId = ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    if (sequenceId == -1) {\n+                        throw new TopicOverloadException(\n+                                String.format(\"Failed to publish messages: %s on topic: %s\", payload, getName()));\n+                    }\n+                    break;\n+                case DISCARD_OLDEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.OVERWRITE).toCompletableFuture().get();\n+                    break;\n+                case DISCARD_NEWEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    break;\n+                case BLOCK:\n+                    addWithBackoff(messages);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+            }\n+\n+            localTopicStats.incrementPublishes();", "originalCommit": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU4NzIxMw==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r494587213", "bodyText": "Ok, I think I've found every line where the stats are incremented.", "author": "andrewoelfing", "createdAt": "2020-09-24T20:20:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ1MTI5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ1NDk3OA==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r493454978", "bodyText": "In the member-side we complete the future in the client-side we throw directly. We should probably have the same behaviour and between the two, I think I'd prefer the client-side one (throwing directly) as it's an early indicator of failure, like the instance already been shutdown, or the message not being serializable.", "author": "mmedenjak", "createdAt": "2020-09-23T11:03:44Z", "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/reliable/ReliableTopicProxy.java", "diffHunk": "@@ -255,4 +276,138 @@ protected void postDestroy() {\n     public LocalTopicStats getLocalTopicStats() {\n         return localTopicStats;\n     }\n+\n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        // RU_COMPAT_4_0\n+        checkClusterVersion(Versions.V4_1);\n+\n+        try {\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(nodeEngine.toData(m), thisAddress))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    long sequenceId = ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    if (sequenceId == -1) {\n+                        throw new TopicOverloadException(\n+                                String.format(\"Failed to publish messages: %s on topic: %s\", payload, getName()));\n+                    }\n+                    break;\n+                case DISCARD_OLDEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.OVERWRITE).toCompletableFuture().get();\n+                    break;\n+                case DISCARD_NEWEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    break;\n+                case BLOCK:\n+                    addWithBackoff(messages);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+            }\n+\n+            localTopicStats.incrementPublishes();\n+        } catch (Exception e) {\n+            throw (RuntimeException) peel(e, null,\n+                    String.format(\"Failed to publish messages: %s on topic: %s\", payload, getName()));\n+        }\n+    }\n+\n+    @Override\n+    public CompletionStage<Void> publishAllAsync(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        // RU_COMPAT_4_0\n+        checkClusterVersion(Versions.V4_1);\n+\n+        InternalCompletableFuture<Void> returnFuture = new InternalCompletableFuture<>();\n+        try {\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(nodeEngine.toData(m), thisAddress))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    addAsyncOrFail(payload, returnFuture, messages);\n+                    break;\n+                case DISCARD_OLDEST:\n+                    addAsync(messages, OverflowPolicy.OVERWRITE);\n+                    break;\n+                case DISCARD_NEWEST:\n+                    addAsync(messages, OverflowPolicy.FAIL);\n+                    break;\n+                case BLOCK:\n+                    addAsyncAndBlock(payload, returnFuture, messages, INITIAL_BACKOFF_MS);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+            }\n+        } catch (Exception e) {\n+            returnFuture.completeExceptionally(peel(e, null,", "originalCommit": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU4NzUzNA==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r494587534", "bodyText": "Fixed", "author": "andrewoelfing", "createdAt": "2020-09-24T20:21:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ1NDk3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ1NTEyOA==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r493455128", "bodyText": "Same as in client-side", "author": "mmedenjak", "createdAt": "2020-09-23T11:03:57Z", "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/reliable/ReliableTopicProxy.java", "diffHunk": "@@ -255,4 +276,138 @@ protected void postDestroy() {\n     public LocalTopicStats getLocalTopicStats() {\n         return localTopicStats;\n     }\n+\n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        // RU_COMPAT_4_0\n+        checkClusterVersion(Versions.V4_1);\n+\n+        try {\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(nodeEngine.toData(m), thisAddress))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    long sequenceId = ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    if (sequenceId == -1) {\n+                        throw new TopicOverloadException(\n+                                String.format(\"Failed to publish messages: %s on topic: %s\", payload, getName()));\n+                    }\n+                    break;\n+                case DISCARD_OLDEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.OVERWRITE).toCompletableFuture().get();\n+                    break;\n+                case DISCARD_NEWEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    break;\n+                case BLOCK:\n+                    addWithBackoff(messages);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+            }\n+\n+            localTopicStats.incrementPublishes();\n+        } catch (Exception e) {\n+            throw (RuntimeException) peel(e, null,\n+                    String.format(\"Failed to publish messages: %s on topic: %s\", payload, getName()));\n+        }\n+    }\n+\n+    @Override\n+    public CompletionStage<Void> publishAllAsync(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        // RU_COMPAT_4_0\n+        checkClusterVersion(Versions.V4_1);\n+\n+        InternalCompletableFuture<Void> returnFuture = new InternalCompletableFuture<>();\n+        try {\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(nodeEngine.toData(m), thisAddress))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    addAsyncOrFail(payload, returnFuture, messages);\n+                    break;\n+                case DISCARD_OLDEST:\n+                    addAsync(messages, OverflowPolicy.OVERWRITE);\n+                    break;\n+                case DISCARD_NEWEST:\n+                    addAsync(messages, OverflowPolicy.FAIL);\n+                    break;\n+                case BLOCK:\n+                    addAsyncAndBlock(payload, returnFuture, messages, INITIAL_BACKOFF_MS);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+            }\n+        } catch (Exception e) {\n+            returnFuture.completeExceptionally(peel(e, null,\n+                    String.format(\"Failed to publish messages: %s on topic: %s\", payload, getName())));\n+        }\n+\n+        return returnFuture;\n+    }\n+\n+    private void addAsyncOrFail(@NotNull Collection<? extends E> payload, InternalCompletableFuture<Void> returnFuture,\n+                                List<ReliableTopicMessage> messages) {\n+        ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).whenCompleteAsync((id, t) -> {\n+            if (t != null) {\n+                returnFuture.completeExceptionally(t);\n+            }\n+            if (id == -1) {\n+                returnFuture.completeExceptionally(new TopicOverloadException(\n+                        \"Failed to publish messages: \" + payload + \" on topic:\" + getName()));\n+            }\n+            messages.forEach(p -> localTopicStats.incrementPublishes());\n+            returnFuture.complete(null);\n+        });\n+    }\n+\n+    private InternalCompletableFuture<Void> addAsync(List<ReliableTopicMessage> messages, OverflowPolicy overflowPolicy) {\n+        InternalCompletableFuture<Void> returnFuture = new InternalCompletableFuture<>();\n+        ringbuffer.addAllAsync(messages, overflowPolicy).whenCompleteAsync((id, t) -> {\n+            if (t != null) {\n+                returnFuture.completeExceptionally(t);\n+            }\n+            messages.forEach(p -> localTopicStats.incrementPublishes());\n+            returnFuture.complete(null);\n+        });\n+        return returnFuture;\n+    }\n+\n+    private void addAsyncAndBlock(@Nonnull Collection<? extends E> payload,\n+                                  InternalCompletableFuture<Void> returnFuture,\n+                                  List<ReliableTopicMessage> messages,\n+                                  long pauseMillis) {\n+        ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).whenCompleteAsync((id, t) -> {\n+            if (t != null) {\n+                returnFuture.completeExceptionally(t);\n+            }\n+            if (id == -1) {\n+                nodeEngine.getExecutionService().schedule(\n+                        () -> addAsyncAndBlock(payload, returnFuture, messages, Math.min(pauseMillis * 2, MAX_BACKOFF)),\n+                        pauseMillis, MILLISECONDS);\n+                returnFuture.completeExceptionally(new TopicOverloadException(", "originalCommit": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU4NzYyMw==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r494587623", "bodyText": "fixed", "author": "andrewoelfing", "createdAt": "2020-09-24T20:21:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ1NTEyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ1NzcxMA==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r493457710", "bodyText": "It's actually interesting that the PublishOperation is also wrong here. We should increment after we successfully published, not before, as the stat says it is the number of successfully published messages. You can fix it here, I'll fix the rest in another PR.", "author": "mmedenjak", "createdAt": "2020-09-23T11:06:51Z", "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/PublishAllOperation.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.topic.impl;\n+\n+import com.hazelcast.config.TopicConfig;\n+import com.hazelcast.internal.nio.IOUtil;\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.spi.impl.eventservice.EventRegistration;\n+import com.hazelcast.spi.impl.eventservice.EventService;\n+import com.hazelcast.spi.impl.operationservice.AbstractNamedOperation;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.concurrent.locks.Lock;\n+\n+/**\n+ * ITopic publication operation used when global ordering is enabled\n+ * (all nodes listening to the same topic get their messages in the same order).\n+ *\n+ * @see TotalOrderedTopicProxy\n+ * @see TopicConfig#isGlobalOrderingEnabled()\n+ */\n+public class PublishAllOperation extends AbstractNamedOperation\n+        implements IdentifiedDataSerializable {\n+\n+    private Data[] messages;\n+\n+    public PublishAllOperation() {\n+    }\n+\n+    @SuppressFBWarnings(\"EI_EXPOSE_REP\")\n+    public PublishAllOperation(String name, Data[] messages) {\n+        super(name);\n+        this.messages = messages;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * Increments the local statistics for the number of published\n+     * messages.\n+     *\n+     * @throws Exception\n+     */\n+    @Override\n+    public void beforeRun() throws Exception { }\n+\n+    @Override\n+    public void run() throws Exception {\n+        TopicService service = getService();\n+        EventService eventService = getNodeEngine().getEventService();\n+        Collection<EventRegistration> registrations = eventService.getRegistrations(TopicService.SERVICE_NAME, name);\n+\n+        Lock lock = service.getOrderLock(name);\n+        lock.lock();\n+        try {\n+            for (Data item : messages) {\n+                TopicEvent topicEvent = new TopicEvent(name, item, getCallerAddress());\n+                service.incrementPublishes(name);", "originalCommit": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU4ODYwNQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r494588605", "bodyText": "I also fixed the wrong PublishOperation code (changed beforeRune to afterRun)", "author": "andrewoelfing", "createdAt": "2020-09-24T20:23:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ1NzcxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ1ODYwNA==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r493458604", "bodyText": "I don't think we need the service anymore.", "author": "mmedenjak", "createdAt": "2020-09-23T11:07:51Z", "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/TopicProxy.java", "diffHunk": "@@ -36,9 +42,11 @@\n \n     protected static final String NULL_MESSAGE_IS_NOT_ALLOWED = \"Null message is not allowed!\";\n     protected static final String NULL_LISTENER_IS_NOT_ALLOWED = \"Null listener is not allowed!\";\n+    private final SerializationService serializationService;\n \n     public TopicProxy(String name, NodeEngine nodeEngine, TopicService service) {\n         super(name, nodeEngine, service);\n+        this.serializationService = nodeEngine.getSerializationService();", "originalCommit": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU4ODY3Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r494588677", "bodyText": "Removed", "author": "andrewoelfing", "createdAt": "2020-09-24T20:23:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ1ODYwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ1ODk2MA==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r493458960", "bodyText": "Not used.", "author": "mmedenjak", "createdAt": "2020-09-23T11:08:16Z", "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/TopicProxySupport.java", "diffHunk": "@@ -100,6 +112,16 @@ public void publishInternal(@Nonnull Object message) {\n         topicService.publishMessage(name, message, multithreaded);\n     }\n \n+    protected InternalCompletableFuture<Data> putAsyncInternal(Operation operation) {", "originalCommit": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU4ODcyNw==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r494588727", "bodyText": "removed", "author": "andrewoelfing", "createdAt": "2020-09-24T20:23:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ1ODk2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ1OTQ4Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r493459482", "bodyText": "serializationService not used.", "author": "mmedenjak", "createdAt": "2020-09-23T11:08:54Z", "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/TotalOrderedTopicProxy.java", "diffHunk": "@@ -32,11 +40,18 @@\n  */\n public class TotalOrderedTopicProxy<E> extends TopicProxy<E> {\n \n+    private final OperationService operationService;\n+    private final SerializationService serializationService;", "originalCommit": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU5MDA1OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r494590059", "bodyText": "removed", "author": "andrewoelfing", "createdAt": "2020-09-24T20:26:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ1OTQ4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ2MTE0NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r493461145", "bodyText": "No need to set the partition ID if it'll be invoked on the partition by the helper method.", "author": "mmedenjak", "createdAt": "2020-09-23T11:10:46Z", "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/TotalOrderedTopicProxy.java", "diffHunk": "@@ -47,4 +62,53 @@ public void publish(@Nonnull  E message) {\n         InternalCompletableFuture f = invokeOnPartition(operation);\n         f.joinInternal();\n     }\n+\n+    @Override\n+    public InternalCompletableFuture<Void> publishAsync(@Nonnull E message) {\n+        checkNotNull(message, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        Operation op = new PublishOperation(getName(), toData(message)).setPartitionId(partitionId);", "originalCommit": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU5MDExMg==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r494590112", "bodyText": "removed", "author": "andrewoelfing", "createdAt": "2020-09-24T20:26:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ2MTE0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ2MTgyOA==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r493461828", "bodyText": "You can just call publishAllAsync here.", "author": "mmedenjak", "createdAt": "2020-09-23T11:11:37Z", "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/TotalOrderedTopicProxy.java", "diffHunk": "@@ -47,4 +62,53 @@ public void publish(@Nonnull  E message) {\n         InternalCompletableFuture f = invokeOnPartition(operation);\n         f.joinInternal();\n     }\n+\n+    @Override\n+    public InternalCompletableFuture<Void> publishAsync(@Nonnull E message) {\n+        checkNotNull(message, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        Operation op = new PublishOperation(getName(), toData(message)).setPartitionId(partitionId);\n+        return publishInternalAsync(op);\n+    }\n+\n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> messages) {\n+        checkNotNull(messages, NULL_MESSAGE_IS_NOT_ALLOWED);", "originalCommit": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU5MDE2NA==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r494590164", "bodyText": "changed", "author": "andrewoelfing", "createdAt": "2020-09-24T20:26:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ2MTgyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ2MjQzOQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r493462439", "bodyText": "Again, the issue with successfully published statistics. Maybe you can avoid it alltogether, and keep the current behaviour, and I'll fix it in another PR in all places.", "author": "mmedenjak", "createdAt": "2020-09-23T11:12:20Z", "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/TotalOrderedTopicProxy.java", "diffHunk": "@@ -47,4 +62,53 @@ public void publish(@Nonnull  E message) {\n         InternalCompletableFuture f = invokeOnPartition(operation);\n         f.joinInternal();\n     }\n+\n+    @Override\n+    public InternalCompletableFuture<Void> publishAsync(@Nonnull E message) {\n+        checkNotNull(message, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        Operation op = new PublishOperation(getName(), toData(message)).setPartitionId(partitionId);\n+        return publishInternalAsync(op);\n+    }\n+\n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> messages) {\n+        checkNotNull(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        // RU_COMPAT_4_0\n+        checkClusterVersion(Versions.V4_1);\n+\n+        Operation op = new PublishAllOperation(getName(), toDataArray(messages));\n+        publishInternalAsync(op).joinInternal();\n+    }\n+\n+    @Override\n+    public InternalCompletableFuture<Void> publishAllAsync(@Nonnull Collection<? extends E> messages) {\n+        checkNotNull(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        // RU_COMPAT_4_0\n+        checkClusterVersion(Versions.V4_1);\n+\n+        Operation op = new PublishAllOperation(getName(), toDataArray(messages));\n+        return publishInternalAsync(op);\n+    }\n+\n+    private InternalCompletableFuture<Void> publishInternalAsync(Operation operation) {\n+        topicStats.incrementPublishes();\n+        try {\n+            return operationService.invokeOnPartition(OperationService.SERVICE_NAME, operation, partitionId);", "originalCommit": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU5MDY2Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r494590667", "bodyText": "As mentioned earlier, I think I've found every call of incrementPublishes", "author": "andrewoelfing", "createdAt": "2020-09-24T20:27:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ2MjQzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDgwNzA5MA==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r494807090", "bodyText": "Ideally, we should increment once the future is done, but let's not nitpick now, I'll do it later.", "author": "mmedenjak", "createdAt": "2020-09-25T07:44:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ2MjQzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ2NTMwMg==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r493465302", "bodyText": "testPublishAll and testPublishAllAsync are the same. Can you fix that? I guess they can share a single helper method to avoid duplication.\nSame for other two tests when it comes to avoiding duplication.", "author": "mmedenjak", "createdAt": "2020-09-23T11:15:42Z", "path": "hazelcast/src/test/java/com/hazelcast/client/topic/ClientTopicTest.java", "diffHunk": "@@ -93,4 +107,117 @@ public void testGetLocalTopicStats() throws Exception {\n \n         topic.getLocalTopicStats();\n     }\n+\n+    @Test\n+    public void testPublish() throws InterruptedException {\n+        String publishValue = \"message\";\n+        ITopic<String> topic = client.getTopic(randomString());\n+        final AtomicInteger count = new AtomicInteger(0);\n+        final Collection<String> receivedValues = new ArrayList<>();\n+\n+        topic.addMessageListener(new MessageListener<String>() {\n+\n+            @Override\n+            public void onMessage(Message<String> message) {\n+                count.incrementAndGet();\n+                receivedValues.add(message.getMessageObject());\n+            }\n+        });\n+        topic.publish(publishValue);\n+        assertTrueEventually(new AssertTask() {\n+            @Override\n+            public void run() {\n+                assertEquals(1, count.get());\n+                assertTrue(receivedValues.contains(publishValue));\n+            }\n+        });\n+    }\n+\n+\n+    @Test\n+    public void testPublishAsync() throws InterruptedException {\n+        ITopic<String> topic = client.getTopic(randomString());\n+        final AtomicInteger count = new AtomicInteger(0);\n+        final List<String> receivedValues = new ArrayList<>();\n+\n+        topic.addMessageListener(new MessageListener<String>() {\n+\n+            @Override\n+            public void onMessage(Message<String> message) {\n+                count.incrementAndGet();\n+                receivedValues.add(message.getMessageObject());\n+            }\n+        });\n+        final String message = \"message\";\n+        topic.publishAsync(message);\n+        assertTrueEventually(new AssertTask() {\n+            @Override\n+            public void run() {\n+                assertEquals(1, count.get());\n+                assertEquals(Arrays.asList(message), receivedValues);\n+            }\n+        });\n+    }\n+\n+    @Test\n+    public void testPublishAll() throws InterruptedException {", "originalCommit": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU5MTA0MA==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r494591040", "bodyText": "Oh no, this was a bad copy paste error. -_-", "author": "andrewoelfing", "createdAt": "2020-09-24T20:27:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ2NTMwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ2ODk0OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r493468949", "bodyText": "You can use assertCompletesEventually to avoid blocking the test forever in case it never completes, same in other test methods doing the same.", "author": "mmedenjak", "createdAt": "2020-09-23T11:19:48Z", "path": "hazelcast/src/test/java/com/hazelcast/topic/TopicTest.java", "diffHunk": "@@ -136,6 +140,108 @@ public void run() {\n         });\n     }\n \n+    @Test\n+    public void testTopicPublishAsync() throws Exception {\n+        final String randomName = \"testTopicPublishAsync\" + generateRandomString(5);\n+        final AtomicInteger count = new AtomicInteger(0);\n+\n+        TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(1);\n+        HazelcastInstance instance = factory.newHazelcastInstance();\n+        ITopic<String> topic = instance.getTopic(randomName);\n+        topic.addMessageListener(new MessageListener<String>() {\n+\n+            @Override\n+            public void onMessage(Message<String> message) {\n+                count.incrementAndGet();\n+            }\n+        });\n+\n+        final CompletableFuture<Void> f = topic.publishAsync(\"TestMessage\").toCompletableFuture();", "originalCommit": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYxNDA5NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r494614095", "bodyText": "Done", "author": "andrewoelfing", "createdAt": "2020-09-24T21:13:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ2ODk0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ4MDYxNg==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r493480616", "bodyText": "Since none of the methods in TopicTest use the client instance, I don't think it's worth extending it here. If you want to make the tests reusable, we need more involvement on different levels.\nFirst off, it should look like this:\n\nClientReliableTopicTest extends ClientTopicTest (client-side tests)\nReliableTopicAbstractTest extends TopicTest (member-side tests)\n\nThen, you'd need to go over all of the test methods and make sure they aren't calling something like instance.getTopic() or client.getReliableTopic() directly in the test. Instead, they would need to call something like getTopicImplementation().publish() where getTopicImplementation would be some abstract method which is overriden in different tests. For instance:\n\nClientReliableTopicTest would return client.getReliableTopic\nReliableTopicAbstractTest would return member.getReliableTopic\nClientTopicTest would return client.getTopic\nTopicTest would return member.getTopic\n\nPersonally, I think it's too much involvement for this PR and we can do it in a separate PR. Now, we might just add similar tests on client and member-side, and for both regular topic and ITopic.", "author": "mmedenjak", "createdAt": "2020-09-23T11:33:53Z", "path": "hazelcast/src/test/java/com/hazelcast/client/topic/ClientReliableTopicTest.java", "diffHunk": "@@ -56,7 +56,7 @@\n \n @RunWith(HazelcastParallelClassRunner.class)\n @Category({QuickTest.class, ParallelJVMTest.class})\n-public class ClientReliableTopicTest extends HazelcastTestSupport {\n+public class ClientReliableTopicTest extends TopicTest {", "originalCommit": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYxNDY4OA==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r494614688", "bodyText": "I've changed it back to HazelcastTestSupport.\nI can have a deeper look into when this PR is finished. :)", "author": "andrewoelfing", "createdAt": "2020-09-24T21:15:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ4MDYxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ5OTkzOA==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r493499938", "bodyText": "I've also noticed we have no tests for BLOCK overload policy. So here's a suggestion, you can do analogous tests for topic, reliable topic, member and client side.\n    @Before\n    public void setup() {\n        Config config = smallInstanceConfig();\n        config.addRingBufferConfig(new RingbufferConfig(\"blockingReliableTopic*\")\n                .setCapacity(10)\n                .setTimeToLiveSeconds(60));\n        hazelcastFactory.newHazelcastInstance(config);\n\n        // for member-side ReliableTopicAbstractTest\n        config.addReliableTopicConfig(new ReliableTopicConfig(\"blockingReliableTopic*\")\n                .setReadBatchSize(10)\n                .setTopicOverloadPolicy(TopicOverloadPolicy.BLOCK));\n        \n        // for client-side ClientReliableTopicTest\n        ClientConfig clientConfig = new ClientConfig()\n                .addReliableTopicConfig(new ClientReliableTopicConfig(\"blockingReliableTopic*\")\n                        .setReadBatchSize(10)\n                        .setTopicOverloadPolicy(TopicOverloadPolicy.BLOCK));\n        \n        client = hazelcastFactory.newHazelcastClient(clientConfig);\n    }\n    \n    @Test\n    public void testBlockingAsync() {\n        String randomName = \"blockingReliableTopic\" + generateRandomString(5);\n        AtomicInteger count = new AtomicInteger(0);\n\n        ITopic<Object> topic = client.getReliableTopic(randomName);\n        topic.addMessageListener(message -> count.incrementAndGet());\n\n\n        for (int i = 0; i < 10; i++) {\n            topic.publish(\"message\");\n        }\n        assertTrueEventually(() -> assertEquals(10, count.get()));\n        assertCompletesEventually(topic.publishAllAsync(asList(\"msg 1\", \"msg 2\", \"msg 3\", \"msg 4\", \"msg 5\")).toCompletableFuture());\n        assertTrueEventually(() -> assertEquals(15, count.get()));\n    }", "author": "mmedenjak", "createdAt": "2020-09-23T11:55:22Z", "path": "hazelcast/src/test/java/com/hazelcast/client/topic/ClientReliableTopicTest.java", "diffHunk": "@@ -56,7 +56,7 @@\n \n @RunWith(HazelcastParallelClassRunner.class)\n @Category({QuickTest.class, ParallelJVMTest.class})\n-public class ClientReliableTopicTest extends HazelcastTestSupport {\n+public class ClientReliableTopicTest extends TopicTest {", "originalCommit": "7d866f63d87a3c1c05ee66cd6a8b2f2ffd387c09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQ5MTk2Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r495491966", "bodyText": "I've created more tests (and extended the existing ones).", "author": "andrewoelfing", "createdAt": "2020-09-26T20:21:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ5OTkzOA=="}], "type": "inlineReview"}, {"oid": "0a215bdfa1b797ebe33535000eba9dbb690dd3ba", "url": "https://github.com/hazelcast/hazelcast/commit/0a215bdfa1b797ebe33535000eba9dbb690dd3ba", "message": "#4233 code review\nremoved unused code, corrected imports, better exception handling, changed task scheduling, added some tests", "committedDate": "2020-09-24T20:07:20Z", "type": "commit"}, {"oid": "acbc348e59a3308a6a869b2a9ca324db8ec6d392", "url": "https://github.com/hazelcast/hazelcast/commit/acbc348e59a3308a6a869b2a9ca324db8ec6d392", "message": "#4233 code review\nFixed unit tests", "committedDate": "2020-09-24T21:37:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDg0OTQ2MA==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r494849460", "bodyText": "Move this to the else block so we don't complete or increment when there's an exception. Same on client side.", "author": "mmedenjak", "createdAt": "2020-09-25T09:01:02Z", "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/reliable/ReliableTopicProxy.java", "diffHunk": "@@ -255,4 +277,139 @@ protected void postDestroy() {\n     public LocalTopicStats getLocalTopicStats() {\n         return localTopicStats;\n     }\n+\n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        // RU_COMPAT_4_0\n+        checkClusterVersion(Versions.V4_1);\n+\n+        try {\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(nodeEngine.toData(m), thisAddress))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    long sequenceId = ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    if (sequenceId == -1) {\n+                        throw new TopicOverloadException(\n+                                String.format(\"Failed to publish messages: %s on topic: %s\", payload, getName()));\n+                    }\n+                    localTopicStats.incrementPublishes();\n+                    break;\n+                case DISCARD_OLDEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.OVERWRITE).toCompletableFuture().get();\n+                    localTopicStats.incrementPublishes();\n+                    break;\n+                case DISCARD_NEWEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    localTopicStats.incrementPublishes();\n+                    break;\n+                case BLOCK:\n+                    addWithBackoff(messages);\n+                    localTopicStats.incrementPublishes();\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+            }\n+        } catch (Exception e) {\n+            throw (RuntimeException) peel(e, null,\n+                    String.format(\"Failed to publish messages: %s on topic: %s\", payload, getName()));\n+        }\n+    }\n+\n+    @Override\n+    public CompletionStage<Void> publishAllAsync(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        // RU_COMPAT_4_0\n+        checkClusterVersion(Versions.V4_1);\n+\n+        InternalCompletableFuture<Void> returnFuture = new InternalCompletableFuture<>();\n+        try {\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(nodeEngine.toData(m), thisAddress))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    addAsyncOrFail(payload, returnFuture, messages);\n+                    break;\n+                case DISCARD_OLDEST:\n+                    addAsync(messages, OverflowPolicy.OVERWRITE);\n+                    break;\n+                case DISCARD_NEWEST:\n+                    addAsync(messages, OverflowPolicy.FAIL);\n+                    break;\n+                case BLOCK:\n+                    addAsyncAndBlock(payload, returnFuture, messages, INITIAL_BACKOFF_MS);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+            }\n+        } catch (Exception e) {\n+            throw (RuntimeException) peel(e, null,\n+                    String.format(\"Failed to publish messages: %s on topic: %s\", payload, getName()));\n+        }\n+\n+        return returnFuture;\n+    }\n+\n+    private void addAsyncOrFail(@Nonnull Collection<? extends E> payload, InternalCompletableFuture<Void> returnFuture,\n+                                List<ReliableTopicMessage> messages) {\n+        ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).whenCompleteAsync((id, t) -> {\n+            if (t != null) {\n+                returnFuture.completeExceptionally(t);\n+            } else if (id == -1) {\n+                returnFuture.completeExceptionally(new TopicOverloadException(\n+                        \"Failed to publish messages: \" + payload + \" on topic:\" + getName()));\n+            } else {\n+                returnFuture.complete(null);\n+                messages.forEach(p -> localTopicStats.incrementPublishes());\n+            }\n+        });\n+    }\n+\n+    private InternalCompletableFuture<Void> addAsync(List<ReliableTopicMessage> messages, OverflowPolicy overflowPolicy) {\n+        InternalCompletableFuture<Void> returnFuture = new InternalCompletableFuture<>();\n+        ringbuffer.addAllAsync(messages, overflowPolicy).whenCompleteAsync((id, t) -> {\n+            if (t != null) {\n+                returnFuture.completeExceptionally(t);\n+            }\n+            returnFuture.complete(null);", "originalCommit": "acbc348e59a3308a6a869b2a9ca324db8ec6d392", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQ5MTkxMA==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r495491910", "bodyText": "Done", "author": "andrewoelfing", "createdAt": "2020-09-26T20:20:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDg0OTQ2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDg1MDM0NA==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r494850344", "bodyText": "Here it's not that critical as on member-side (because of statistics) but move this to an else block.", "author": "mmedenjak", "createdAt": "2020-09-25T09:02:36Z", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientReliableTopicProxy.java", "diffHunk": "@@ -197,6 +212,114 @@ public LocalTopicStats getLocalTopicStats() {\n         throw new UnsupportedOperationException(\"Locality is ambiguous for client!\");\n     }\n \n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        try {\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(toData(m), null))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    long sequenceId = ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    if (sequenceId == -1) {\n+                        throw new TopicOverloadException(\"Failed to publish messages: \" + payload + \" on topic:\" + getName());\n+                    }\n+                    break;\n+                case DISCARD_OLDEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.OVERWRITE).toCompletableFuture().get();\n+                    break;\n+                case DISCARD_NEWEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    break;\n+                case BLOCK:\n+                    addWithBackoff(messages);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+            }\n+        } catch (Exception e) {\n+            throw (RuntimeException) peel(e, null,\n+                    \"Failed to publish messages: \" + payload + \" to topic:\" + getName());\n+        }\n+    }\n+\n+    @Override\n+    public CompletionStage<Void> publishAllAsync(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        InternalCompletableFuture<Void> returnFuture = new InternalCompletableFuture<>();\n+\n+        try {\n+\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(toData(m), null))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    addAsyncOrFail(payload, returnFuture, messages);\n+                    break;\n+                case DISCARD_OLDEST:\n+                    addAsync(messages, OverflowPolicy.OVERWRITE);\n+                    break;\n+                case DISCARD_NEWEST:\n+                    addAsync(messages, OverflowPolicy.FAIL);\n+                    break;\n+                case BLOCK:\n+                    addAsyncAndBlock(payload, returnFuture, messages, INITIAL_BACKOFF_MS);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+            }\n+        } catch (Exception e) {\n+            throw (RuntimeException) peel(e, null,\n+                    String.format(\"Failed to publish messages: %s on topic: %s\", payload, getName()));\n+        }\n+        return returnFuture;\n+    }\n+\n+    private void addAsyncAndBlock(@Nonnull Collection<? extends E> payload, InternalCompletableFuture<Void> returnFuture,\n+                                  List<ReliableTopicMessage> messages, long pauseMillis) {\n+        ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).whenCompleteAsync((id, t) -> {\n+            if (t != null) {\n+                returnFuture.completeExceptionally(t);\n+            } else if (id == -1) {\n+                getContext().getTaskScheduler().schedule(\n+                        () -> addAsyncAndBlock(payload, returnFuture, messages, Math.min(pauseMillis * 2, MAX_BACKOFF)),\n+                        pauseMillis, MILLISECONDS);\n+            } else {\n+                returnFuture.complete(null);\n+            }\n+        });\n+    }\n+\n+    private void addAsyncOrFail(@Nonnull Collection<? extends E> payload, InternalCompletableFuture<Void> returnFuture,\n+                                List<ReliableTopicMessage> messages) {\n+        ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).whenCompleteAsync((id, t) -> {\n+            if (t != null) {\n+                returnFuture.completeExceptionally(t);\n+            } else if (id == -1) {\n+                returnFuture.completeExceptionally(new TopicOverloadException(\n+                        \"Failed to publish messages: \" + payload + \" on topic:\" + getName()));\n+            } else {\n+                returnFuture.complete(null);\n+            }\n+        });\n+    }\n+\n+    private InternalCompletableFuture<Void> addAsync(List<ReliableTopicMessage> messages, OverflowPolicy overflowPolicy) {\n+        InternalCompletableFuture<Void> returnFuture = new InternalCompletableFuture<>();\n+        ringbuffer.addAllAsync(messages, overflowPolicy).whenCompleteAsync((id, t) -> {\n+            if (t != null) {\n+                returnFuture.completeExceptionally(t);\n+            }\n+            returnFuture.complete(null);", "originalCommit": "acbc348e59a3308a6a869b2a9ca324db8ec6d392", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQ5MTkyMg==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r495491922", "bodyText": "Done", "author": "andrewoelfing", "createdAt": "2020-09-26T20:20:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDg1MDM0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDg1MTQwMg==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r494851402", "bodyText": "Looks like stats are incremented in the operation so you can remove it from here.", "author": "mmedenjak", "createdAt": "2020-09-25T09:04:42Z", "path": "hazelcast/src/main/java/com/hazelcast/topic/impl/TotalOrderedTopicProxy.java", "diffHunk": "@@ -32,19 +40,68 @@\n  */\n public class TotalOrderedTopicProxy<E> extends TopicProxy<E> {\n \n+    private final OperationService operationService;\n     private final int partitionId;\n+    private final LocalTopicStatsImpl topicStats;\n \n     public TotalOrderedTopicProxy(String name, NodeEngine nodeEngine, TopicService service) {\n         super(name, nodeEngine, service);\n-        this.partitionId = nodeEngine.getPartitionService().getPartitionId(getNameAsPartitionAwareData());\n+        this.partitionId = nodeEngine.getPartitionService()\n+                .getPartitionId(getNameAsPartitionAwareData());\n+        this.operationService = nodeEngine.getOperationService();\n+        this.topicStats = service.getLocalTopicStats(name);\n     }\n \n     @Override\n     public void publish(@Nonnull  E message) {\n         checkNotNull(message, NULL_MESSAGE_IS_NOT_ALLOWED);\n-        Operation operation = new PublishOperation(getName(), toData(message))\n-                .setPartitionId(partitionId);\n+        Operation operation = new PublishOperation(getName(), toData(message)).setPartitionId(partitionId);\n         InternalCompletableFuture f = invokeOnPartition(operation);\n         f.joinInternal();\n     }\n+\n+    @Override\n+    public InternalCompletableFuture<Void> publishAsync(@Nonnull E message) {\n+        checkNotNull(message, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        Operation op = new PublishOperation(getName(), toData(message));\n+        return publishInternalAsync(op);\n+    }\n+\n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> messages) {\n+        publishAllAsync(messages).joinInternal();\n+    }\n+\n+    @Override\n+    public InternalCompletableFuture<Void> publishAllAsync(@Nonnull Collection<? extends E> messages) {\n+        checkNotNull(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        // RU_COMPAT_4_0\n+        checkClusterVersion(Versions.V4_1);\n+\n+        Operation op = new PublishAllOperation(getName(), toDataArray(messages));\n+        return publishInternalAsync(op);\n+    }\n+\n+    private InternalCompletableFuture<Void> publishInternalAsync(Operation operation) {\n+        try {\n+            final InvocationFuture<Void> invocationFuture = operationService.invokeOnPartition(\n+                    OperationService.SERVICE_NAME, operation, partitionId);\n+            topicStats.incrementPublishes();", "originalCommit": "acbc348e59a3308a6a869b2a9ca324db8ec6d392", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQ5MTkyNw==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r495491927", "bodyText": "Done", "author": "andrewoelfing", "createdAt": "2020-09-26T20:20:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDg1MTQwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDk0MTAwMw==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r494941003", "bodyText": "ClientMessageDecoder can not be null.\nIf you add completionStage.toCompletableFuture().join(); in your tests you will get NullPointerException. Please add this version to tests as well.\nYou can pass  clientMessage -> null instead of null to fix the problem easily.\nPlease check publishAsync method as well for the same.", "author": "sancar", "createdAt": "2020-09-25T12:03:54Z", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientTopicProxy.java", "diffHunk": "@@ -77,6 +91,27 @@ public LocalTopicStats getLocalTopicStats() {\n         throw new UnsupportedOperationException(\"Locality is ambiguous for client!\");\n     }\n \n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> messages) {\n+        checkNotNull(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        ClientMessage request = getClientMessage(messages);\n+        invokeOnPartition(request);\n+    }\n+\n+    @Override\n+    public InternalCompletableFuture<Void> publishAllAsync(@Nonnull Collection<? extends E> messages) {\n+        checkNotNull(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(messages, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        final ClientMessage clientMessage = getClientMessage(messages);\n+        return invokeOnPartitionAsync(clientMessage, null);", "originalCommit": "acbc348e59a3308a6a869b2a9ca324db8ec6d392", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQ5MjAyMw==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r495492023", "bodyText": "Hello @sancar, I've fixed this and created one more test.", "author": "andrewoelfing", "createdAt": "2020-09-26T20:21:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDk0MTAwMw=="}], "type": "inlineReview"}, {"oid": "30049ee1f3f9b7b0a330fa3e737c249a4ed8dab1", "url": "https://github.com/hazelcast/hazelcast/commit/30049ee1f3f9b7b0a330fa3e737c249a4ed8dab1", "message": "#4233 code review\ncorrected conditions, add more tests", "committedDate": "2020-09-26T20:16:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg4MzEyOQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r495883129", "bodyText": "The test name is confusing. I know what you mean but only because I know the background.\nCan you rename it to something like testPublishAllAsync_thenJoin ?", "author": "sancar", "createdAt": "2020-09-28T11:56:09Z", "path": "hazelcast/src/test/java/com/hazelcast/client/topic/ClientTopicTest.java", "diffHunk": "@@ -177,6 +179,39 @@ public void run() {\n         });\n     }\n \n+    @Test\n+    public void testNullMessageDecoder() {", "originalCommit": "30049ee1f3f9b7b0a330fa3e737c249a4ed8dab1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkwMDcyNA==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r495900724", "bodyText": "Renamed it.", "author": "andrewoelfing", "createdAt": "2020-09-28T12:29:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg4MzEyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg4MzI0NA==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r495883244", "bodyText": "This is unused.", "author": "sancar", "createdAt": "2020-09-28T11:56:23Z", "path": "hazelcast/src/test/java/com/hazelcast/client/topic/ClientTopicTest.java", "diffHunk": "@@ -177,6 +179,39 @@ public void run() {\n         });\n     }\n \n+    @Test\n+    public void testNullMessageDecoder() {\n+        final AtomicInteger count = new AtomicInteger(0);\n+        final Collection<String> receivedValues = new ArrayList<>();\n+        ITopic<String> topic = createTopic(count, receivedValues);\n+\n+        final List<String> messages = Arrays.asList(\"message 1\", \"message 2\", \"messgae 3\");\n+        final CompletionStage<Void> completionStage = topic.publishAllAsync(messages);\n+        completionStage.toCompletableFuture().join();\n+        assertTrueEventually(new AssertTask() {\n+            @Override\n+            public void run() {\n+                assertEquals(messages.size(), count.get());\n+                assertTrue(messages.containsAll(receivedValues));\n+            }\n+        });\n+    }\n+\n+    @Test\n+    public void testBlockingAsync() {\n+        AtomicInteger count = new AtomicInteger(0);\n+        final Collection<String> receivedValues = new ArrayList<>();", "originalCommit": "30049ee1f3f9b7b0a330fa3e737c249a4ed8dab1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkwMDc3NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r495900775", "bodyText": "Removed", "author": "andrewoelfing", "createdAt": "2020-09-28T12:29:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg4MzI0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg4NTc4OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r495885789", "bodyText": "This payload parameter is unused. It can be removed. Please check the member side proxy as well.", "author": "sancar", "createdAt": "2020-09-28T12:01:23Z", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientReliableTopicProxy.java", "diffHunk": "@@ -197,6 +212,115 @@ public LocalTopicStats getLocalTopicStats() {\n         throw new UnsupportedOperationException(\"Locality is ambiguous for client!\");\n     }\n \n+    @Override\n+    public void publishAll(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+\n+        try {\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(toData(m), null))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    long sequenceId = ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    if (sequenceId == -1) {\n+                        throw new TopicOverloadException(\"Failed to publish messages: \" + payload + \" on topic:\" + getName());\n+                    }\n+                    break;\n+                case DISCARD_OLDEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.OVERWRITE).toCompletableFuture().get();\n+                    break;\n+                case DISCARD_NEWEST:\n+                    ringbuffer.addAllAsync(messages, OverflowPolicy.FAIL).toCompletableFuture().get();\n+                    break;\n+                case BLOCK:\n+                    addWithBackoff(messages);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+            }\n+        } catch (Exception e) {\n+            throw (RuntimeException) peel(e, null,\n+                    \"Failed to publish messages: \" + payload + \" to topic:\" + getName());\n+        }\n+    }\n+\n+    @Override\n+    public CompletionStage<Void> publishAllAsync(@Nonnull Collection<? extends E> payload) {\n+        checkNotNull(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        checkNoNullInside(payload, NULL_MESSAGE_IS_NOT_ALLOWED);\n+        InternalCompletableFuture<Void> returnFuture = new InternalCompletableFuture<>();\n+\n+        try {\n+\n+            List<ReliableTopicMessage> messages = payload.stream()\n+                    .map(m -> new ReliableTopicMessage(toData(m), null))\n+                    .collect(Collectors.toList());\n+            switch (overloadPolicy) {\n+                case ERROR:\n+                    addAsyncOrFail(payload, returnFuture, messages);\n+                    break;\n+                case DISCARD_OLDEST:\n+                    addAsync(messages, OverflowPolicy.OVERWRITE);\n+                    break;\n+                case DISCARD_NEWEST:\n+                    addAsync(messages, OverflowPolicy.FAIL);\n+                    break;\n+                case BLOCK:\n+                    addAsyncAndBlock(payload, returnFuture, messages, INITIAL_BACKOFF_MS);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown overloadPolicy:\" + overloadPolicy);\n+            }\n+        } catch (Exception e) {\n+            throw (RuntimeException) peel(e, null,\n+                    String.format(\"Failed to publish messages: %s on topic: %s\", payload, getName()));\n+        }\n+        return returnFuture;\n+    }\n+\n+    private void addAsyncAndBlock(@Nonnull Collection<? extends E> payload, InternalCompletableFuture<Void> returnFuture,", "originalCommit": "30049ee1f3f9b7b0a330fa3e737c249a4ed8dab1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkwMDg0OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16946#discussion_r495900849", "bodyText": "Removed", "author": "andrewoelfing", "createdAt": "2020-09-28T12:29:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg4NTc4OQ=="}], "type": "inlineReview"}, {"oid": "3e11e4c5a08f82c8fd22595c097d049251e2e02e", "url": "https://github.com/hazelcast/hazelcast/commit/3e11e4c5a08f82c8fd22595c097d049251e2e02e", "message": "#4233 code review\nmethod renaming, removed unused code, removed unused parameter", "committedDate": "2020-09-28T12:29:21Z", "type": "commit"}]}