{"pr_number": 16461, "pr_title": "[BACKPORT] Avoid using on-heap indexes while indexing is in progress", "pr_createdAt": "2020-01-10T12:09:48Z", "pr_url": "https://github.com/hazelcast/hazelcast/pull/16461", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTIyNTU4Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/16461#discussion_r365225586", "bodyText": "The implementation of this class looks suspicious to me. Evaluate predicate is an indexed predicate over some other predicate. matchIndex may return null if the target index is not ready, causing NPE during query execution. We need to add tests for bitmap indexes in addition to existing tests, to make sure that the logic works properly.", "author": "devozerov", "createdAt": "2020-01-10T13:08:56Z", "path": "hazelcast/src/main/java/com/hazelcast/query/impl/predicates/EvaluatePredicate.java", "diffHunk": "@@ -72,13 +72,13 @@ public boolean apply(Map.Entry mapEntry) {\n     }\n \n     @Override\n-    public Set<QueryableEntry> filter(QueryContext queryContext) {\n-        Index index = queryContext.matchIndex(indexName, QueryContext.IndexMatchHint.EXACT_NAME);\n+    public Set<QueryableEntry> filter(QueryContext queryContext, int ownedPartitionCount) {\n+        Index index = queryContext.matchIndex(indexName, QueryContext.IndexMatchHint.EXACT_NAME, ownedPartitionCount);", "originalCommit": "6f3e9678d5e5d4a6549e5080476ce19aabcde3ca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTIyNjAwOA==", "url": "https://github.com/hazelcast/hazelcast/pull/16461#discussion_r365226008", "bodyText": "Shouldn't we do something like this instead?\nreturn queryContext.matchIndex(indexName, QueryContext.IndexMatchHint.EXACT_NAME, ownedPartitionCount) != null;", "author": "devozerov", "createdAt": "2020-01-10T13:10:10Z", "path": "hazelcast/src/main/java/com/hazelcast/query/impl/predicates/EvaluatePredicate.java", "diffHunk": "@@ -72,13 +72,13 @@ public boolean apply(Map.Entry mapEntry) {\n     }\n \n     @Override\n-    public Set<QueryableEntry> filter(QueryContext queryContext) {\n-        Index index = queryContext.matchIndex(indexName, QueryContext.IndexMatchHint.EXACT_NAME);\n+    public Set<QueryableEntry> filter(QueryContext queryContext, int ownedPartitionCount) {\n+        Index index = queryContext.matchIndex(indexName, QueryContext.IndexMatchHint.EXACT_NAME, ownedPartitionCount);\n         return index.evaluate(predicate);\n     }\n \n     @Override\n-    public boolean isIndexed(QueryContext queryContext) {\n+    public boolean isIndexed(QueryContext queryContext, int ownedPartitionCount) {\n         return true;", "originalCommit": "6f3e9678d5e5d4a6549e5080476ce19aabcde3ca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTI3OTM1Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/16461#discussion_r365279356", "bodyText": "EvaluatePredicate already assume that we decided to use an index, so we should not check the nested predicate. Instead, we should use EvaluatePredicate.indexName with EXACT_NAME rule to check if the index is ready.", "author": "devozerov", "createdAt": "2020-01-10T15:10:55Z", "path": "hazelcast/src/main/java/com/hazelcast/query/impl/predicates/EvaluatePredicate.java", "diffHunk": "@@ -72,13 +72,23 @@ public boolean apply(Map.Entry mapEntry) {\n     }\n \n     @Override\n-    public Set<QueryableEntry> filter(QueryContext queryContext) {\n-        Index index = queryContext.matchIndex(indexName, QueryContext.IndexMatchHint.EXACT_NAME);\n+    public Set<QueryableEntry> filter(QueryContext queryContext, int ownedPartitionCount) {\n+        Index index = queryContext.matchIndex(indexName, QueryContext.IndexMatchHint.EXACT_NAME, ownedPartitionCount);\n+        if (index == null) {\n+            return null;\n+        }\n         return index.evaluate(predicate);\n     }\n \n     @Override\n-    public boolean isIndexed(QueryContext queryContext) {\n+    public boolean isIndexed(QueryContext queryContext, int ownedPartitionCount) {\n+        if (predicate instanceof IndexAwarePredicate) {", "originalCommit": "b5406be863956e23ee38f933ea05b7dd77b79370", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTI4MTAzNQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16461#discussion_r365281035", "bodyText": "Only several predicates are checked, whilst other types still may fail. E,g, AndPredicate, OrPredicate. We'd better extend the check for all built-in predicate types.\nBitmap indexes may generate different predicates during the optimization process (EvaluatePredicate), so a separate test for bitmaps is needed, with matching predicate types.", "author": "devozerov", "createdAt": "2020-01-10T15:14:21Z", "path": "hazelcast/src/test/java/com/hazelcast/query/impl/IndexConcurrencyTest.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.query.impl;\n+\n+import com.hazelcast.config.Config;\n+import com.hazelcast.core.HazelcastInstance;\n+import com.hazelcast.core.IMap;\n+import com.hazelcast.query.Predicates;\n+import com.hazelcast.query.SqlPredicate;\n+import com.hazelcast.test.HazelcastSerialClassRunner;\n+import com.hazelcast.test.annotation.ParallelTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import java.util.Collection;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+\n+@RunWith(HazelcastSerialClassRunner.class)\n+@Category({QuickTest.class, ParallelTest.class})\n+public class IndexConcurrencyTest extends AbstractIndexConcurrencyTest {\n+\n+    @Override\n+    protected Config getConfig() {\n+        return smallInstanceConfig();\n+    }\n+\n+    @Test\n+    public void testIndexCreationAndQueryDeterministicConcurrency() {\n+        Config config = getConfig();\n+\n+        HazelcastInstance node = createHazelcastInstance(config);\n+        IMap<Integer, Person> map = node.getMap(randomMapName());\n+\n+        // put some data\n+        for (int i = 0; i < 10000; ++i) {\n+            map.put(i, new Person(i));\n+        }\n+\n+        // initialize age field access counter\n+        Person.accessCountDown = new AtomicLong(5000);\n+\n+        // start indexer, it will await for latch in the middle\n+        AtomicReference<Throwable> exception = new AtomicReference<Throwable>();\n+        Thread indexer = new Thread(new Runnable() {\n+\n+            @Override\n+            public void run() {\n+                try {\n+                    map.addIndex(\"age\", true);\n+                } catch (Throwable t) {\n+                    exception.compareAndSet(null, t);\n+                }\n+            }\n+        });\n+        indexer.start();\n+\n+        // await for query latch\n+        assertOpenEventually(Person.queryLatch);\n+        Person.accessCountDown = null;\n+\n+        // run checking query\n+        Collection<Person> persons = map.values(new SqlPredicate(\"age >= 5000\"));\n+        assertEquals(5000, persons.size());\n+\n+        persons = map.values(Predicates.equal(\"age\", \"20\"));\n+        assertEquals(1, persons.size());\n+\n+        persons = map.values(Predicates.greaterThan(\"age\", \"5000\"));\n+        assertEquals(4999, persons.size());", "originalCommit": "b5406be863956e23ee38f933ea05b7dd77b79370", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "43837945d39fedeb7cc9fd2eba18d0a809f0b78a", "url": "https://github.com/hazelcast/hazelcast/commit/43837945d39fedeb7cc9fd2eba18d0a809f0b78a", "message": "Avoid NPE if index is under construction\n\nCheck that the matched index might be null in the query engine and if\nso, don't try to use it.\nAdded more unit tests.", "committedDate": "2020-01-10T18:44:55Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODkwMTU4Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/16461#discussion_r368901582", "bodyText": "Is it OK to pass -1 here? It seem that we may cache inconsistent results here if the check for partition count is skipped, don't we?", "author": "devozerov", "createdAt": "2020-01-21T09:51:10Z", "path": "hazelcast/src/main/java/com/hazelcast/map/impl/querycache/subscriber/DefaultQueryCache.java", "diffHunk": "@@ -334,7 +334,7 @@ public V get(Object key) {\n \n         Set<K> resultingSet = new HashSet<K>();\n \n-        Set<QueryableEntry> query = indexes.query(predicate);\n+        Set<QueryableEntry> query = indexes.query(predicate, -1);", "originalCommit": "27918909ce2376c0b405d1ea5ab492cda5eb4140", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODkyMTQxOQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16461#discussion_r368921419", "bodyText": "Seems like it's impossible to fix that without introducing changes to query cache itself and that's out of scope of this task. Probably we should just open a new issue. @ahmetmircik wdyt?", "author": "taburet", "createdAt": "2020-01-21T10:30:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODkwMTU4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODkyOTQ0Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/16461#discussion_r368929443", "bodyText": "I've created an issue #16513 for 4.1 milestone to track this.", "author": "petrpleshachkov", "createdAt": "2020-01-21T10:47:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODkwMTU4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODk1MTc3OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16461#discussion_r368951779", "bodyText": "Maybe i'm missing something, but QueryCache indexes are local and should have no relation with partitioning subsystem.", "author": "ahmetmircik", "createdAt": "2020-01-21T11:38:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODkwMTU4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODk2MDEwNA==", "url": "https://github.com/hazelcast/hazelcast/pull/16461#discussion_r368960104", "bodyText": "@ahmetmircik yes, but one can still call addIndex on one thread while running queries from another. Until addIndex wouldn't be finished with its job, queries would return inconsistent results.", "author": "taburet", "createdAt": "2020-01-21T11:58:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODkwMTU4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODk2Mzc4OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16461#discussion_r368963789", "bodyText": "Thanks for clarification, now the opened issue makes sense.", "author": "ahmetmircik", "createdAt": "2020-01-21T12:08:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODkwMTU4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODkwMjQ3NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16461#discussion_r368902475", "bodyText": "I am a little worried with plain -1 in many places. Shouldn't we declare it as a static final constant instead?", "author": "devozerov", "createdAt": "2020-01-21T09:52:53Z", "path": "hazelcast/src/main/java/com/hazelcast/query/impl/predicates/EvaluateVisitor.java", "diffHunk": "@@ -51,7 +51,7 @@ public Predicate visit(AndPredicate andPredicate, Indexes indexes) {\n \n             EvaluatePredicate evaluatePredicate = (EvaluatePredicate) subPredicate;\n             String indexName = evaluatePredicate.getIndexName();\n-            Index index = indexes.matchIndex(indexName, QueryContext.IndexMatchHint.EXACT_NAME);\n+            Index index = indexes.matchIndex(indexName, QueryContext.IndexMatchHint.EXACT_NAME, -1);", "originalCommit": "27918909ce2376c0b405d1ea5ab492cda5eb4140", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6fb3aed101af0722931040985654df02aec5a2ec", "url": "https://github.com/hazelcast/hazelcast/commit/6fb3aed101af0722931040985654df02aec5a2ec", "message": "[BACKPORT] Avoid using on-heap indexes while indexing is in progress (#16367)\n\nFixed the race condition checking that all partitions are indexed\nbefore using an index for query. In combination with migration stamp\ncheck which guarantees there is no concurrent partition migration,\nthe using of incomplete index is avoided and query engine falls back to\nthe full partitions scan algorithm.\n\nFixes: https://github.com/hazelcast/hazelcast/issues/16311", "committedDate": "2020-01-21T11:14:57Z", "type": "commit"}, {"oid": "6fb3aed101af0722931040985654df02aec5a2ec", "url": "https://github.com/hazelcast/hazelcast/commit/6fb3aed101af0722931040985654df02aec5a2ec", "message": "[BACKPORT] Avoid using on-heap indexes while indexing is in progress (#16367)\n\nFixed the race condition checking that all partitions are indexed\nbefore using an index for query. In combination with migration stamp\ncheck which guarantees there is no concurrent partition migration,\nthe using of incomplete index is avoided and query engine falls back to\nthe full partitions scan algorithm.\n\nFixes: https://github.com/hazelcast/hazelcast/issues/16311", "committedDate": "2020-01-21T11:14:57Z", "type": "forcePushed"}]}