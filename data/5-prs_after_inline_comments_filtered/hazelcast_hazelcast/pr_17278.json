{"pr_number": 17278, "pr_title": "SQL plan cache implementation (#17277)", "pr_createdAt": "2020-07-29T08:07:56Z", "pr_url": "https://github.com/hazelcast/hazelcast/pull/17278", "timeline": [{"oid": "11bde31933a1308b1c3a9353586036db69d93075", "url": "https://github.com/hazelcast/hazelcast/commit/11bde31933a1308b1c3a9353586036db69d93075", "message": "SQL plan cache implementation (#17277)", "committedDate": "2020-07-29T08:02:36Z", "type": "commit"}, {"oid": "f3fbe0e2e417b4d19e7bbca346b5a9d0c14d32b8", "url": "https://github.com/hazelcast/hazelcast/commit/f3fbe0e2e417b4d19e7bbca346b5a9d0c14d32b8", "message": "Minors.", "committedDate": "2020-07-29T09:27:08Z", "type": "commit"}, {"oid": "34432c71454da9e0f2cb42afd95233810f63a327", "url": "https://github.com/hazelcast/hazelcast/commit/34432c71454da9e0f2cb42afd95233810f63a327", "message": "Merge branch 'master' into issues/17277", "committedDate": "2020-08-04T13:05:13Z", "type": "commit"}, {"oid": "27f2595a576b35d2084c05b1c96f0a55db2dc468", "url": "https://github.com/hazelcast/hazelcast/commit/27f2595a576b35d2084c05b1c96f0a55db2dc468", "message": "Fixes after merge from master.", "committedDate": "2020-08-04T13:08:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY5Njg3MA==", "url": "https://github.com/hazelcast/hazelcast/pull/17278#discussion_r465696870", "bodyText": "We should use searchPaths to be consistent", "author": "viliam-durina", "createdAt": "2020-08-05T12:41:22Z", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/OptimizerContext.java", "diffHunk": "@@ -165,6 +161,8 @@ public RelNode optimize(RelNode node, RuleSet rules, RelTraitSet traitSet) {\n         HazelcastSchema rootSchema,\n         List<List<String>> schemaPaths\n     ) {\n+        assert schemaPaths != null;", "originalCommit": "27f2595a576b35d2084c05b1c96f0a55db2dc468", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjMyODI1Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17278#discussion_r466328253", "bodyText": "Renamed", "author": "devozerov", "createdAt": "2020-08-06T10:49:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY5Njg3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTcwMTM5NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17278#discussion_r465701395", "bodyText": "TableField doesn't have equals method implemented. It's not strictly necessary for imdg because it never uses it, but it's necessary for Jet because we use it for some connectors.", "author": "viliam-durina", "createdAt": "2020-08-05T12:48:51Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/plan/cache/PartitionedMapPlanObjectId.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.plan.cache;\n+\n+import com.hazelcast.sql.impl.extract.QueryTargetDescriptor;\n+import com.hazelcast.sql.impl.schema.TableField;\n+\n+import java.util.List;\n+import java.util.Set;\n+\n+public class PartitionedMapPlanObjectId implements PlanObjectId {\n+\n+    private final String schemaName;\n+    private final String name;\n+    private final List<TableField> fields;\n+    private final QueryTargetDescriptor keyDescriptor;\n+    private final QueryTargetDescriptor valueDescriptor;\n+    private final Set<String> conflictingSchemas;\n+\n+    public PartitionedMapPlanObjectId(\n+        String schemaName,\n+        String name,\n+        List<TableField> fields,\n+        Set<String> conflictingSchemas,\n+        QueryTargetDescriptor keyDescriptor,\n+        QueryTargetDescriptor valueDescriptor\n+    ) {\n+        this.schemaName = schemaName;\n+        this.name = name;\n+        this.fields = fields;\n+        this.keyDescriptor = keyDescriptor;\n+        this.valueDescriptor = valueDescriptor;\n+        this.conflictingSchemas = conflictingSchemas;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+\n+        PartitionedMapPlanObjectId that = (PartitionedMapPlanObjectId) o;\n+\n+        return schemaName.equals(that.schemaName)\n+            && name.equals(that.name)\n+            && fields.equals(that.fields)", "originalCommit": "27f2595a576b35d2084c05b1c96f0a55db2dc468", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjMzMDc0Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17278#discussion_r466330746", "bodyText": "Added equals/hashCode", "author": "devozerov", "createdAt": "2020-08-06T10:55:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTcwMTM5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc0NjIwNg==", "url": "https://github.com/hazelcast/hazelcast/pull/17278#discussion_r465746206", "bodyText": "We can add this test to understand the logic here:\n@RunWith(HazelcastSerialClassRunner.class)\n@Category({QuickTest.class, ParallelJVMTest.class})\npublic class SqlCatalogTest {\n\n    @Test\n    public void when_sameNameInTwoSchemas_then_conflict() {\n        // When\n        Table s1t1 = new MockTable(\"s1\", \"t1\");\n        Table s1t2 = new MockTable(\"s1\", \"t2\");\n        Table s2t2 = new MockTable(\"s2\", \"t2\");\n\n        TableResolver tr1 = new MockTableResolver(s1t1, s1t2, s2t2);\n        new SqlCatalog(singletonList(tr1));\n\n        // Then\n        assertEquals(emptySet(), s1t1.getConflictingSchemas());\n        assertEquals(new HashSet<>(asList(\"s1\", \"s2\")), s1t2.getConflictingSchemas());\n        assertEquals(new HashSet<>(asList(\"s1\", \"s2\")), s2t2.getConflictingSchemas());\n    }\n\n    @Test\n    public void when_sameFqn_then_noConflict() {\n        Table s1t1_1 = new MockTable(\"s1\", \"t1\");\n        Table s1t1_2 = new MockTable(\"s1\", \"t1\");\n\n        // When\n        TableResolver tr1 = new MockTableResolver(s1t1_1, s1t1_2);\n        new SqlCatalog(singletonList(tr1));\n\n        // Then\n        assertEquals(emptySet(), s1t1_1.getConflictingSchemas());\n        assertEquals(emptySet(), s1t1_2.getConflictingSchemas());\n    }\n\n    @Test\n    public void when_sameFqnAndConflict_then_conflict() {\n        Table s1t1_1 = new MockTable(\"s1\", \"t1\");\n        Table s1t1_2 = new MockTable(\"s1\", \"t1\");\n        Table s2t1 = new MockTable(\"s2\", \"t1\");\n\n        // When\n        TableResolver tr1 = new MockTableResolver(s1t1_1);\n        TableResolver tr2 = new MockTableResolver(s1t1_2, s2t1);\n        new SqlCatalog(asList(tr1, tr2));\n\n        // Then\n        Set<String> bothSchemas = new HashSet<>(asList(\"s1\", \"s2\"));\n        assertEquals(bothSchemas, s1t1_1.getConflictingSchemas());\n        // the second occurrence of s1t1 doesn't have the conflicts set\n        assertEquals(emptySet(), s1t1_2.getConflictingSchemas());\n        assertEquals(bothSchemas, s2t1.getConflictingSchemas());\n    }\n\n    private static class MockTableResolver implements TableResolver {\n        private final List<Table> tables;\n\n        private MockTableResolver(Table ... tables) {\n            this.tables = asList(tables);\n        }\n\n        @Override\n        public List<List<String>> getDefaultSearchPaths() {\n            throw new UnsupportedOperationException();\n        }\n\n        @Nonnull\n        @Override\n        public List<Table> getTables() {\n            return tables;\n        }\n\n    }\n\n    private static class MockTable extends Table {\n        MockTable(String schema, String tableName) {\n            super(schema, tableName, emptyList(), null);\n        }\n\n        @Override\n        public PlanObjectId getObjectId() {\n            return null;\n        }\n    }\n}", "author": "viliam-durina", "createdAt": "2020-08-05T13:58:03Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/schema/SqlCatalog.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.schema;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Schema that is used for the duration of query.\n+ */\n+public class SqlCatalog {\n+\n+    private final Map<String, Map<String, Table>> schemas;\n+\n+    public SqlCatalog(List<TableResolver> tableResolvers) {", "originalCommit": "27f2595a576b35d2084c05b1c96f0a55db2dc468", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjMzMjU2MA==", "url": "https://github.com/hazelcast/hazelcast/pull/17278#discussion_r466332560", "bodyText": "Added to the PR, thank you for the suggestion!", "author": "devozerov", "createdAt": "2020-08-06T10:58:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc0NjIwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc0NzA2OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17278#discussion_r465747069", "bodyText": "Is it guaranteed that if there are two objects with the same FQN, the second one will never be resolved, given the table resolver list isn't changed? We rely on it.", "author": "viliam-durina", "createdAt": "2020-08-05T13:59:13Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/schema/SqlCatalog.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.schema;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Schema that is used for the duration of query.\n+ */\n+public class SqlCatalog {\n+\n+    private final Map<String, Map<String, Table>> schemas;\n+\n+    public SqlCatalog(List<TableResolver> tableResolvers) {\n+        // Populate schemas and tables.\n+        schemas = new HashMap<>();\n+\n+        Map<String, Set<Table>> tableConflicts = new HashMap<>();\n+\n+        for (TableResolver tableResolver : tableResolvers) {\n+            Collection<Table> tables = tableResolver.getTables();\n+\n+            for (Table table : tables) {\n+                String schemaName = table.getSchemaName();\n+                String tableName = table.getName();\n+\n+                Table oldTable = schemas.computeIfAbsent(schemaName, key -> new HashMap<>()).putIfAbsent(tableName, table);\n+\n+                if (oldTable == null) {", "originalCommit": "27f2595a576b35d2084c05b1c96f0a55db2dc468", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjMyNzU0Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17278#discussion_r466327543", "bodyText": "If there are two objects with the same FQN, then they are guaranteed to be in the same schema. computeIfAbsent ensures that only one object per schema is registered, and hence only one object with the given FQN is resolved. The list of resolvers is fixed for the duration of the process lifetime.\nNow consider that in one run a resolver returned two tables with the same FQN in the order [T1, T2], and in all subsequent runs the order is {T2, T1]. As a result, in the first run we will have a table [T1], and in the next runs we will have only [T2].\nConsider that we cached a plan with the table [T1] in the first run. On the second run, we will not find the table [T1] in the list of catalog tables, and hence the cached plan will be invalidated.", "author": "devozerov", "createdAt": "2020-08-06T10:48:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc0NzA2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc1MzIyMg==", "url": "https://github.com/hazelcast/hazelcast/pull/17278#discussion_r465753222", "bodyText": "We can use Map<String, org.apache.calcite.schema.Table> here and remove the @SuppressWarnings", "author": "viliam-durina", "createdAt": "2020-08-05T14:07:48Z", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/schema/HazelcastSchemaUtils.java", "diffHunk": "@@ -57,38 +55,33 @@ public static HazelcastSchema createCatalog(Schema schema) {\n      * objects such as IMap and ReplicatedMap as well as external tables created by Jet. This approach will not work well\n      * should we need a relaxed/dynamic object resolution at some point in future.\n      *\n-     * @param tableResolvers Table resolver to be used to get the list of existing tables.\n      * @return Top-level schema.\n      */\n     @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n-    public static HazelcastSchema createRootSchema(List<TableResolver> tableResolvers) {\n-        // Create tables.\n-        Map<String, Map<String, HazelcastTable>> tableMap = new HashMap<>();\n+    public static HazelcastSchema createRootSchema(SqlCatalog catalog) {\n+        // Create schemas.\n+        Map<String, Schema> schemaMap = new HashMap<>();\n+\n+        for (Map.Entry<String, Map<String, Table>> currentSchemaEntry : catalog.getSchemas().entrySet()) {\n+            String schemaName = currentSchemaEntry.getKey();\n+\n+            Map schemaTables = new HashMap<>();", "originalCommit": "27f2595a576b35d2084c05b1c96f0a55db2dc468", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjMyNDM0MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17278#discussion_r466324341", "bodyText": "Fixed.", "author": "devozerov", "createdAt": "2020-08-06T10:41:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc1MzIyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc2OTgwNg==", "url": "https://github.com/hazelcast/hazelcast/pull/17278#discussion_r465769806", "bodyText": "A better name would be CacheablePlan", "author": "viliam-durina", "createdAt": "2020-08-05T14:30:03Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/plan/cache/CachedPlan.java", "diffHunk": "@@ -0,0 +1,29 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.plan.cache;\n+\n+import com.hazelcast.sql.impl.optimizer.SqlPlan;\n+\n+/**\n+ * Plan that could be cached.\n+ */\n+public interface CachedPlan extends SqlPlan {", "originalCommit": "27f2595a576b35d2084c05b1c96f0a55db2dc468", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjMyMzkwNA==", "url": "https://github.com/hazelcast/hazelcast/pull/17278#discussion_r466323904", "bodyText": "Renamed", "author": "devozerov", "createdAt": "2020-08-06T10:40:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc2OTgwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc4MzgyOQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17278#discussion_r465783829", "bodyText": "Bad import", "author": "viliam-durina", "createdAt": "2020-08-05T14:49:13Z", "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/impl/calcite/TestMapTable.java", "diffHunk": "@@ -17,11 +17,13 @@\n package com.hazelcast.sql.impl.calcite;\n \n import com.hazelcast.sql.impl.extract.GenericQueryTargetDescriptor;\n+import com.hazelcast.sql.impl.plan.cache.PlanObjectId;\n import com.hazelcast.sql.impl.schema.ConstantTableStatistics;\n import com.hazelcast.sql.impl.schema.TableField;\n import com.hazelcast.sql.impl.schema.TableStatistics;\n import com.hazelcast.sql.impl.schema.map.AbstractMapTable;\n import com.hazelcast.sql.impl.type.QueryDataType;\n+import com.sun.corba.se.spi.ior.ObjectId;", "originalCommit": "27f2595a576b35d2084c05b1c96f0a55db2dc468", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjMyMzI5MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17278#discussion_r466323291", "bodyText": "Fixed", "author": "devozerov", "createdAt": "2020-08-06T10:39:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc4MzgyOQ=="}], "type": "inlineReview"}, {"oid": "35aa44836a6b033f03234fd9804ccbbf0b72a54e", "url": "https://github.com/hazelcast/hazelcast/commit/35aa44836a6b033f03234fd9804ccbbf0b72a54e", "message": "Fix bad import.", "committedDate": "2020-08-06T10:39:32Z", "type": "commit"}, {"oid": "ea315ab28125fd68ac6f5592b3f45499e7241c65", "url": "https://github.com/hazelcast/hazelcast/commit/ea315ab28125fd68ac6f5592b3f45499e7241c65", "message": "CachedPlan -> CacheablePlan", "committedDate": "2020-08-06T10:40:37Z", "type": "commit"}, {"oid": "f777f92be7323f5651c6dfbe9d517181fcc2f8a3", "url": "https://github.com/hazelcast/hazelcast/commit/f777f92be7323f5651c6dfbe9d517181fcc2f8a3", "message": "Remove unnecessary suppression.", "committedDate": "2020-08-06T10:41:38Z", "type": "commit"}, {"oid": "d97ba396693d17ca3468665478da2363bf63c2ed", "url": "https://github.com/hazelcast/hazelcast/commit/d97ba396693d17ca3468665478da2363bf63c2ed", "message": "Minor rename", "committedDate": "2020-08-06T10:48:56Z", "type": "commit"}, {"oid": "61d595af05ff3dbcb641bec8f945086cab737707", "url": "https://github.com/hazelcast/hazelcast/commit/61d595af05ff3dbcb641bec8f945086cab737707", "message": "Remove unrelated .gitignore", "committedDate": "2020-08-06T10:49:16Z", "type": "commit"}, {"oid": "d7bf9540969dbeb94ea6a4254e9f2311ac1ce6d6", "url": "https://github.com/hazelcast/hazelcast/commit/d7bf9540969dbeb94ea6a4254e9f2311ac1ce6d6", "message": "Typo", "committedDate": "2020-08-06T10:50:05Z", "type": "commit"}, {"oid": "ac274daf6161e2a597e3544345caa9b6361ef651", "url": "https://github.com/hazelcast/hazelcast/commit/ac274daf6161e2a597e3544345caa9b6361ef651", "message": "Added equals to TableField", "committedDate": "2020-08-06T10:54:47Z", "type": "commit"}, {"oid": "e560f89a36d2d63729eb6b930de148ac62a4a93a", "url": "https://github.com/hazelcast/hazelcast/commit/e560f89a36d2d63729eb6b930de148ac62a4a93a", "message": "Unit tests for SqlCatalog from Viliam.", "committedDate": "2020-08-06T10:57:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjQyNzkwOA==", "url": "https://github.com/hazelcast/hazelcast/pull/17278#discussion_r466427908", "bodyText": "\"Object ID\" sounds too generic to me. ID implies that it's stable, but it changes with any property change. Maybe \"comparison key\" would be better. Or \"object key\", for brevity. Also should contain \"plan\", because the key is tailored for plan. What about this?:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public PlanObjectId getObjectId() {\n          \n          \n            \n                public PlanObjectKey getPlanObjectKey() {", "author": "viliam-durina", "createdAt": "2020-08-06T13:52:01Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/schema/map/PartitionedMapTable.java", "diffHunk": "@@ -39,4 +41,20 @@ public PartitionedMapTable(\n     public PartitionedMapTable(String name, QueryException exception) {\n         super(SCHEMA_NAME_PARTITIONED, name, exception);\n     }\n+\n+    @Override\n+    public PlanObjectId getObjectId() {", "originalCommit": "e560f89a36d2d63729eb6b930de148ac62a4a93a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjQzMjk4Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17278#discussion_r466432982", "bodyText": "Renamed", "author": "devozerov", "createdAt": "2020-08-06T13:58:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjQyNzkwOA=="}], "type": "inlineReview"}, {"oid": "d1e5df9a208bfa6ad07eec638546a37376abc4dc", "url": "https://github.com/hazelcast/hazelcast/commit/d1e5df9a208bfa6ad07eec638546a37376abc4dc", "message": "ObjectKey -> ObjectId", "committedDate": "2020-08-06T13:58:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTE0MTk5NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17278#discussion_r469141995", "bodyText": "What is a reasoning behind this default?", "author": "petrpleshachkov", "createdAt": "2020-08-12T09:50:35Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/SqlServiceImpl.java", "diffHunk": "@@ -51,6 +59,8 @@\n     /** Default state check frequency. */\n     private static final long STATE_CHECK_FREQUENCY = 1_000L;\n \n+    private static final int PLAN_CACHE_SIZE = 10_000;", "originalCommit": "d1e5df9a208bfa6ad07eec638546a37376abc4dc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTM3MTM0MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17278#discussion_r469371341", "bodyText": "There is no precise reasoning around this default. The cache should be big enough to avoid evictions in most cases, and small enough to avoid excessive memory consumption for unfortunate workloads.\nTypical applications do not have many different queries. On the other hand, the memory consumed by each plan is not that big (around several KB), so there is not much sense to make the cache size too small.", "author": "devozerov", "createdAt": "2020-08-12T16:02:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTE0MTk5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTE0NDI3NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17278#discussion_r469144274", "bodyText": "What is the reasoning behind magic number 3 ?", "author": "petrpleshachkov", "createdAt": "2020-08-12T09:54:35Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/SqlServiceImpl.java", "diffHunk": "@@ -242,4 +291,12 @@ private SqlOptimizer createOptimizer(NodeEngine nodeEngine) {\n             throw new HazelcastException(\"Failed to instantiate the optimizer class \" + className + \": \" + e.getMessage(), e);\n         }\n     }\n+\n+    private static List<TableResolver> createTableResolvers(NodeEngine nodeEngine) {\n+        List<TableResolver> res = new ArrayList<>(3);", "originalCommit": "d1e5df9a208bfa6ad07eec638546a37376abc4dc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTM0OTQyMw==", "url": "https://github.com/hazelcast/hazelcast/pull/17278#discussion_r469349423", "bodyText": "It makes no sense now. Removed.", "author": "devozerov", "createdAt": "2020-08-12T15:34:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTE0NDI3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTE0ODQ5NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17278#discussion_r469148494", "bodyText": "Javadoc of the interface methods would be helpful.", "author": "petrpleshachkov", "createdAt": "2020-08-12T10:02:15Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/scan/KeyValueIterator.java", "diffHunk": "@@ -0,0 +1,27 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.exec.scan;\n+\n+/**\n+ * Iterator over key/value pairs.\n+ */\n+public interface KeyValueIterator {\n+    boolean tryAdvance();", "originalCommit": "d1e5df9a208bfa6ad07eec638546a37376abc4dc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTM3MTQ0OA==", "url": "https://github.com/hazelcast/hazelcast/pull/17278#discussion_r469371448", "bodyText": "Added JavaDoc.", "author": "devozerov", "createdAt": "2020-08-12T16:02:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTE0ODQ5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTE1NTk4Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17278#discussion_r469155986", "bodyText": "Javadoc", "author": "petrpleshachkov", "createdAt": "2020-08-12T10:16:53Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/plan/cache/CachedPlanInvalidationCallback.java", "diffHunk": "@@ -0,0 +1,21 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.plan.cache;\n+", "originalCommit": "d1e5df9a208bfa6ad07eec638546a37376abc4dc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTM3MTUzMA==", "url": "https://github.com/hazelcast/hazelcast/pull/17278#discussion_r469371530", "bodyText": "Added JavaDoc.", "author": "devozerov", "createdAt": "2020-08-12T16:02:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTE1NTk4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTE2MDczMA==", "url": "https://github.com/hazelcast/hazelcast/pull/17278#discussion_r469160730", "bodyText": "Sorting on every put might be very expensive, have you considered to use ordered concurrent data structure (e.g. ConcurrentSkipListMap) for the cache to avoid this intermediate step?", "author": "petrpleshachkov", "createdAt": "2020-08-12T10:26:09Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/plan/cache/PlanCache.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.plan.cache;\n+\n+import java.util.TreeMap;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * Cache for plans.\n+ */\n+public class PlanCache implements CachedPlanInvalidationCallback {\n+\n+    private final int maxSize;\n+    private final ConcurrentHashMap<PlanCacheKey, CacheablePlan> plans = new ConcurrentHashMap<>();\n+\n+    public PlanCache(int maxSize) {\n+        assert maxSize > 0;\n+\n+        this.maxSize = maxSize;\n+    }\n+\n+    public CacheablePlan get(PlanCacheKey key) {\n+        CacheablePlan plan = plans.get(key);\n+\n+        if (plan != null) {\n+            plan.onPlanUsed();\n+\n+            return plan;\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    public void put(PlanCacheKey key, CacheablePlan plan) {\n+        plans.put(key, plan);\n+\n+        plan.onPlanUsed();\n+\n+        shrinkIfNeeded();\n+    }\n+\n+    public void invalidate(CacheablePlan plan) {\n+        remove(plan);\n+    }\n+\n+    public void clear() {\n+        plans.clear();\n+    }\n+\n+    public int size() {\n+        return plans.size();\n+    }\n+\n+    public void check(PlanCheckContext context) {\n+        plans.values().removeIf(plan -> !plan.isPlanValid(context));\n+    }\n+\n+    private void shrinkIfNeeded() {\n+        int oversize = plans.size() - maxSize;\n+\n+        if (oversize <= 0) {\n+            return;\n+        }\n+\n+        // Sort plans according to their last used timestamps\n+        TreeMap<Long, CacheablePlan> sorted = new TreeMap<>();\n+\n+        for (CacheablePlan plan : plans.values()) {", "originalCommit": "d1e5df9a208bfa6ad07eec638546a37376abc4dc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI3Mjk1NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17278#discussion_r469272954", "bodyText": "We had similar use case in Jet. What we did is that when the maximum number was exceeded, we sorted the data and deleted 100 items at once.", "author": "viliam-durina", "createdAt": "2020-08-12T13:48:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTE2MDczMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTM2ODg5Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/17278#discussion_r469368897", "bodyText": "We assume that normally the number of plans is limited and normally should not exceed the maximum size. So the slow path is almost never invoked. If this happens, then a user is in trouble anyway, because planning takes significant time. For example, this may happen if a user uses literals with concatenation instead of parameters.\nThis assumption means that there is a high hit rate. We would like to make plan lookup as cheap as possible. Therefore, ConcurrentSkipListMap is not an option: we use LRU algorithm and with ConcurrentSkipListMap we would have to update this data structure on every access.", "author": "devozerov", "createdAt": "2020-08-12T15:58:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTE2MDczMA=="}], "type": "inlineReview"}, {"oid": "0552acff9adf466547f8961e0ae4c8b53801e7f1", "url": "https://github.com/hazelcast/hazelcast/commit/0552acff9adf466547f8961e0ae4c8b53801e7f1", "message": "Removed unnecessary magic number.", "committedDate": "2020-08-12T15:33:54Z", "type": "commit"}, {"oid": "8b1c0712dd7d52f92d1b24e65085a4b6b9e09be5", "url": "https://github.com/hazelcast/hazelcast/commit/8b1c0712dd7d52f92d1b24e65085a4b6b9e09be5", "message": "JavaDoc", "committedDate": "2020-08-12T16:02:09Z", "type": "commit"}, {"oid": "906c50142e3e93bf1b84f3c8c9fff7a05d7f5d25", "url": "https://github.com/hazelcast/hazelcast/commit/906c50142e3e93bf1b84f3c8c9fff7a05d7f5d25", "message": "Merge branch 'master' into issues/17277\n\n# Conflicts:\n#\thazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/CalciteSqlOptimizer.java\n#\thazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/OptimizerContext.java\n#\thazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/opt/physical/visitor/PlanCreateVisitor.java\n#\thazelcast/src/main/java/com/hazelcast/sql/impl/SqlInternalService.java\n#\thazelcast/src/main/java/com/hazelcast/sql/impl/exec/scan/AbstractMapScanExec.java\n#\thazelcast/src/main/java/com/hazelcast/sql/impl/extract/AbstractGenericExtractor.java\n#\thazelcast/src/main/java/com/hazelcast/sql/impl/extract/GenericQueryTarget.java\n#\thazelcast/src/main/java/com/hazelcast/sql/impl/plan/Plan.java\n#\thazelcast/src/test/java/com/hazelcast/sql/impl/SqlResultImplTest.java\n#\thazelcast/src/test/java/com/hazelcast/sql/impl/SqlTestSupport.java\n#\thazelcast/src/test/java/com/hazelcast/sql/impl/client/SqlClientResultTest.java\n#\thazelcast/src/test/java/com/hazelcast/sql/impl/operation/QueryExecuteOperationFactoryTest.java\n#\thazelcast/src/test/java/com/hazelcast/sql/impl/operation/QueryOperationHandlerTest.java\n#\thazelcast/src/test/java/com/hazelcast/sql/impl/plan/PlanTest.java\n#\thazelcast/src/test/java/com/hazelcast/sql/impl/state/QueryInitiatorStateTest.java", "committedDate": "2020-08-12T16:11:54Z", "type": "commit"}, {"oid": "be5f78b8654839186e97c07ff8b3c35c7042b18e", "url": "https://github.com/hazelcast/hazelcast/commit/be5f78b8654839186e97c07ff8b3c35c7042b18e", "message": "Merge with master", "committedDate": "2020-08-12T16:24:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQyMzk5Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17278#discussion_r469423992", "bodyText": "A leftover?", "author": "viliam-durina", "createdAt": "2020-08-12T17:29:15Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/scan/KeyValueIterator.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.exec.scan;\n+\n+/**\n+ * Iterator over key/value pairs.\n+ */\n+public interface KeyValueIterator {\n+    /**\n+     * Advances the iterator to the next available record.\n+     * <p>\n+     * If the method has returned {@code true}, the key and the value could be accessed through\n+     * {@link #getKey()} and {@link #getValue()} respectively.\n+     *\n+     * @return {@code} t", "originalCommit": "be5f78b8654839186e97c07ff8b3c35c7042b18e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc2NjI2MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17278#discussion_r469766261", "bodyText": "Yes, thanks for spotting this. Fixed.", "author": "devozerov", "createdAt": "2020-08-13T07:56:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQyMzk5Mg=="}], "type": "inlineReview"}, {"oid": "eedc2f63d9d5ce8f0b7402e4dc3644aec4834143", "url": "https://github.com/hazelcast/hazelcast/commit/eedc2f63d9d5ce8f0b7402e4dc3644aec4834143", "message": "Do no update read schema if there are no plans.", "committedDate": "2020-08-13T04:58:39Z", "type": "commit"}, {"oid": "132959ef5ffad3e7a225d958ea18759cbdb45054", "url": "https://github.com/hazelcast/hazelcast/commit/132959ef5ffad3e7a225d958ea18759cbdb45054", "message": "Minor.", "committedDate": "2020-08-13T07:56:20Z", "type": "commit"}]}