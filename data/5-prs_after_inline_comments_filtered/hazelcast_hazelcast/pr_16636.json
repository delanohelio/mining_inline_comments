{"pr_number": 16636, "pr_title": "Added support for ConcurrentMap.computeIfPresent #11958", "pr_createdAt": "2020-02-11T04:13:18Z", "pr_url": "https://github.com/hazelcast/hazelcast/pull/16636", "timeline": [{"oid": "c31f41c7eedb2fba97d9ae4cb6347a51412a3457", "url": "https://github.com/hazelcast/hazelcast/commit/c31f41c7eedb2fba97d9ae4cb6347a51412a3457", "message": "Added support for ConcurrentMap.computeIfPresent #11958", "committedDate": "2020-02-11T04:09:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ0MDI2Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/16636#discussion_r377440263", "bodyText": "Removing this part of the documentation as Hz is already compiled with Java 8, and we have a plan to support Java 8 methods (#14913).\nHappy to revert this change in case I should keep this until we actually address #14913", "author": "webashutosh", "createdAt": "2020-02-11T04:15:33Z", "path": "hazelcast/src/main/java/com/hazelcast/map/IMap.java", "diffHunk": "@@ -70,28 +70,6 @@\n  * {@code entrySet}, return an <b>immutable</b> collection clone of the values.\n  * The collection is <b>NOT</b> backed by the map, so changes to the map are\n  * <b>NOT</b> reflected in the collection.</li>\n- * <li>Since Hazelcast is compiled with Java 1.6, we can't override default\n- * methods introduced in later Java versions, nor can we add documentation\n- * to them. Methods, including but not limited to {@code computeIfPresent},\n- * may behave incorrectly if the value passed to the update function is\n- * modified in-place and returned as a result of the invocation.\n- * You should create a new value instance and return it as a result.\n- * <p>\n- * For example, following code fragment will behave incorrectly and will\n- * enter an infinite loop:\n- * <pre>\n- * map.computeIfPresent(\"key\", (key, value) -&gt; {\n- *     value.setSomeAttribute(\"newAttributeValue\");\n- *     return value;\n- * });\n- * </pre>\n- * It should be replaced with:\n- * <pre>\n- * map.computeIfPresent(\"key\", (key, value) -&gt; {\n- *     return new ObjectWithSomeAttribute(\"newAttributeValue\");\n- * });\n- * </pre>\n- * </li>", "originalCommit": "c31f41c7eedb2fba97d9ae4cb6347a51412a3457", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ5NjY3NA==", "url": "https://github.com/hazelcast/hazelcast/pull/16636#discussion_r377496674", "bodyText": "Yes, let's remove that once we actually have the implementations ready and covered by tests.", "author": "mmedenjak", "createdAt": "2020-02-11T08:36:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ0MDI2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ0MDU1NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16636#discussion_r377440555", "bodyText": "I could not think of a way to combine the get() + replace() operation into a single remote call. Mainly because I don't know how to send the BiFunction code/body across the wire (the function may've used classes/utilities that are only present on the client JVM)", "author": "webashutosh", "createdAt": "2020-02-11T04:17:53Z", "path": "hazelcast/src/main/java/com/hazelcast/map/impl/proxy/MapProxyImpl.java", "diffHunk": "@@ -1025,4 +1026,27 @@ private static void checkNotPagingPredicate(Predicate predicate, String method)\n             throw new IllegalArgumentException(\"PagingPredicate not supported in \" + method + \" method\");\n         }\n     }\n+\n+    @Override\n+    public V computeIfPresent(K key,\n+                               BiFunction<? super K, ? super V, ? extends V> remappingFunction) {\n+        checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);\n+\n+        while (true) {\n+            Data oldValueData = toData(getInternal(key));\n+            if (oldValueData == null) {\n+                return null;\n+            }\n+\n+            V oldValueClone = toObject(oldValueData);\n+            V newValue = remappingFunction.apply(key, oldValueClone);\n+            if (newValue != null) {\n+                if (replaceInternal(key, oldValueData, toData(newValue))) {\n+                    return newValue;\n+                }\n+            } else if (removeInternal(key, oldValueData)) {\n+                return null;\n+            }\n+        }\n+    }", "originalCommit": "c31f41c7eedb2fba97d9ae4cb6347a51412a3457", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ5MjEwMA==", "url": "https://github.com/hazelcast/hazelcast/pull/16636#discussion_r377492100", "bodyText": "I think this is main issue that needs to be resolved. The problem is that this implementation can consume a lot of resources because of the retrying and the long latency. It could even end up in a livelock.\nThe best approach is to get everything done in a single remote call. There is no retrying needed here because the operation will have exclusive access to the partition.", "author": "pveentjer", "createdAt": "2020-02-11T08:24:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ0MDU1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ5NTE3MA==", "url": "https://github.com/hazelcast/hazelcast/pull/16636#discussion_r377495170", "bodyText": "Sure @pveentjer , I'd look into that then.\nJust to confirm - this means that we want the BiFunction also to execute on the remote machine, correct (because we need to know the existing value of the entry before we can apply the function)?", "author": "webashutosh", "createdAt": "2020-02-11T08:32:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ0MDU1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ5NjUxMA==", "url": "https://github.com/hazelcast/hazelcast/pull/16636#discussion_r377496510", "bodyText": "Yes, this probably will be the better approach. You're going to have to create a new operation which will contain the mapping function - similar to how the EntryProcessor is transmitted when you invoke IMap#executeOnKey. On that note, would it not be simpler if you wrapped the mapping function in an EntryProcessor and used the same methods that that method already uses?\nAlso, I don't see any client-side support (ClientMapProxy) or client tests. Please add those.", "author": "mmedenjak", "createdAt": "2020-02-11T08:36:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ0MDU1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzUwNjcyMA==", "url": "https://github.com/hazelcast/hazelcast/pull/16636#discussion_r377506720", "bodyText": "Sounds good, thanks @mmedenjak , will do.", "author": "webashutosh", "createdAt": "2020-02-11T09:00:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ0MDU1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTUzMjAxNA==", "url": "https://github.com/hazelcast/hazelcast/pull/16636#discussion_r379532014", "bodyText": "@pveentjer @mmedenjak @taburet\nI tested scenarios where a client node (JVM A) would pass an EntryProcessor as an anonymous class or a lambda to a server node (JVM B). I can confirm that such calls fail on the sever node, because the server fails to deserialize the anonymous-class/lambda instance (the server node doesn't have that \"class\" on its classpath).\nThis may not be so much of a problem for EntryProcessors (because people must be creating a named subclass file in advance, and must be deploying the subclass on both (client and server) JVMs.\nHowever, when people call methods that take Java 8 functional classes as args, its very likely that they'd use a lambda (I've almost never seen anyone creating named subclass files for a BiFunction or a Function). In such cases, the computeIfPresent() will fail (since the server would fail to deserialize the BiFunction lambda).\nGiven this, should we continue evaluating the BiFunction on the client JVM itself?\nOtherwise the new/updated implementation of computeIfPresent () would cause existing usages of the method to start failing (if someone is passing the BiFunction arg as a lambda)\nThoughts?\nPS: Should I be discussing such things on Gitter instead?", "author": "webashutosh", "createdAt": "2020-02-14T16:41:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ0MDU1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgwOTc0OA==", "url": "https://github.com/hazelcast/hazelcast/pull/16636#discussion_r379809748", "bodyText": "How about if you enable user code deployment? Does that work with lambdas? For 4.1, there's some work in progress to enable re-deployment of such classes using UCD.", "author": "cangencer", "createdAt": "2020-02-15T08:48:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ0MDU1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg3NjU2NA==", "url": "https://github.com/hazelcast/hazelcast/pull/16636#discussion_r379876564", "bodyText": "Hi @cangencer, great suggestion! I tested that if we enable UCD on both sides, and add all the client-only classes to the UCD config, then that works!\nThere are some nuances to it, but I think I'd raise a PR using UCD and see where that goes.", "author": "webashutosh", "createdAt": "2020-02-16T05:33:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ0MDU1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDA0MTk4MA==", "url": "https://github.com/hazelcast/hazelcast/pull/16636#discussion_r380041980", "bodyText": "You're right and there is another issue - classes might be defined on all instances but since BiFunction doesn't implement Serializable or any other serialization technique, it might not work until you either cast it or you define a named class with some serialisation technique defined. Unfortunately, UCD doesn't help there.\nFeels like we should try to get the EP approach running but if it's too hacky, we might revert back to the original approach from running from the client. Yes, it has its' drawbacks but it's better than an infinite loop.", "author": "mmedenjak", "createdAt": "2020-02-17T08:35:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ0MDU1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDA3MDY4Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/16636#discussion_r380070686", "bodyText": "Sure @mmedenjak - let me send through a PR with this approach (using EP + UCD) - like you said, we can take a decision then ...", "author": "webashutosh", "createdAt": "2020-02-17T09:34:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ0MDU1NQ=="}], "type": "inlineReview"}, {"oid": "c783f1955bfc87861f783a6a3c168f8cc6831c16", "url": "https://github.com/hazelcast/hazelcast/commit/c783f1955bfc87861f783a6a3c168f8cc6831c16", "message": "Added support for ConcurrentMap.computeIfPresent #11958 #14913", "committedDate": "2020-02-29T05:27:24Z", "type": "commit"}, {"oid": "bc5711f30f81e60eb98fbfc7e481ef78256a0108", "url": "https://github.com/hazelcast/hazelcast/commit/bc5711f30f81e60eb98fbfc7e481ef78256a0108", "message": "Removed unnecessary exception handling #11958 #14913", "committedDate": "2020-02-29T05:38:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAwNDE4NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16636#discussion_r386004185", "bodyText": "These tests cover execution from both the client and the server (we need to execute the same set of tests for both). So I didn't write a separate test class for the client.", "author": "webashutosh", "createdAt": "2020-02-29T05:46:10Z", "path": "hazelcast/src/test/java/com/hazelcast/map/ComputeConditionallyTests.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.map;\n+\n+import com.hazelcast.client.config.ClientConfig;\n+import com.hazelcast.client.test.TestHazelcastFactory;\n+import com.hazelcast.config.Config;\n+import com.hazelcast.core.HazelcastInstance;\n+import com.hazelcast.nio.serialization.HazelcastSerializationException;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.HazelcastTestSupport;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+import testsubjects.ClientOnlyStaticSerializableBiFunction;\n+import testsubjects.NonStaticFunctionFactory;\n+import testsubjects.StaticNonSerializableBiFunction;\n+import testsubjects.StaticSerializableBiFunction;\n+\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.BiFunction;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.fail;\n+\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class ComputeConditionallyTests extends HazelcastTestSupport {", "originalCommit": "bc5711f30f81e60eb98fbfc7e481ef78256a0108", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY0MzM1OA==", "url": "https://github.com/hazelcast/hazelcast/pull/16636#discussion_r395643358", "bodyText": "All the tests that are using clients should reside in client package.", "author": "sancar", "createdAt": "2020-03-20T13:42:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAwNDE4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY0ODc5MA==", "url": "https://github.com/hazelcast/hazelcast/pull/16636#discussion_r395648790", "bodyText": "I could not find the test runs computeIfPresent from the server. Is it missing ?", "author": "sancar", "createdAt": "2020-03-20T13:50:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAwNDE4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY0OTM0Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/16636#discussion_r395649347", "bodyText": "Sorry, I just saw them.", "author": "sancar", "createdAt": "2020-03-20T13:51:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAwNDE4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE3NDM1NA==", "url": "https://github.com/hazelcast/hazelcast/pull/16636#discussion_r386174354", "bodyText": "From here down, its all test classes I wrote in non-hazelcast base package.\nThese are to make sure that the solution works for static/non-static and serializable/non-serializable bi-functions", "author": "webashutosh", "createdAt": "2020-03-02T02:36:49Z", "path": "hazelcast/src/test/java/testsubjects/ClientOnlyStaticSerializableBiFunction.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*", "originalCommit": "bc5711f30f81e60eb98fbfc7e481ef78256a0108", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY4NjM4OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16636#discussion_r387686389", "bodyText": "Maybe it's an overkill having a separate class for this, you can move this to ComputeConditionallyTests.\nAlso, can you move the package testsubjects under com.hazelcast.test. And what does testsubjects stand for?", "author": "mmedenjak", "createdAt": "2020-03-04T14:05:30Z", "path": "hazelcast/src/test/java/testsubjects/NonStaticFunctionFactory.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package testsubjects;\n+\n+import java.util.function.BiFunction;\n+\n+public class NonStaticFunctionFactory {\n+\n+    private NonStaticFunctionFactory() {\n+    }\n+\n+    public static BiFunction<String, String, String> getAnonymousNonSerializableBiFunction(final String returnValue) {\n+        return new BiFunction<String, String, String>() {", "originalCommit": "bc5711f30f81e60eb98fbfc7e481ef78256a0108", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzc2ODYyOA==", "url": "https://github.com/hazelcast/hazelcast/pull/16636#discussion_r387768628", "bodyText": "Overall background -\nIn ComputeConditionallyTests, ideally I wanted to test scenarios where the client and servers would be on different JVMs, and the client has classes that are NOT present on the server JVM.\nTo simulate this, I used a custom class-loader for the server. That way, the classes visible to the client aren't visible to the server classloader.\nFurther to this, I noticed that during class-loading, classes inside com.hazelcast have an additional fallback (link). I wanted to avoid this fallback for the tests (to make the tests stricter)\nAbout naming the new package testsubjects -\nI thought we can use this package to host classes that act like \"subjects\" of tests (classes that aren't tests themselves. Other tests use them like subjects). Happy to rename it ... suggestions?\nAbout the separate class -\nYes, it's kind of an overkill. I wanted the anonymous class to have a package other than com.hazelcast. Any other solution comes to mind?", "author": "webashutosh", "createdAt": "2020-03-04T16:07:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY4NjM4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzYzNzQyMA==", "url": "https://github.com/hazelcast/hazelcast/pull/16636#discussion_r393637420", "bodyText": "Forgot about the com.hazelcast package rule. Thanks, let's keep it as it is.", "author": "mmedenjak", "createdAt": "2020-03-17T12:19:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY4NjM4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY4ODE2Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/16636#discussion_r387688166", "bodyText": "You can use com.hazelcast.internal.util.RootCauseMatcher instead. See here for an example.", "author": "mmedenjak", "createdAt": "2020-03-04T14:08:32Z", "path": "hazelcast/src/test/java/com/hazelcast/map/ComputeConditionallyTests.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.map;\n+\n+import com.hazelcast.client.config.ClientConfig;\n+import com.hazelcast.client.test.TestHazelcastFactory;\n+import com.hazelcast.config.Config;\n+import com.hazelcast.core.HazelcastInstance;\n+import com.hazelcast.nio.serialization.HazelcastSerializationException;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.HazelcastTestSupport;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+import testsubjects.ClientOnlyStaticSerializableBiFunction;\n+import testsubjects.NonStaticFunctionFactory;\n+import testsubjects.StaticNonSerializableBiFunction;\n+import testsubjects.StaticSerializableBiFunction;\n+\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.BiFunction;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.fail;\n+\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class ComputeConditionallyTests extends HazelcastTestSupport {\n+\n+    private final TestHazelcastFactory hazelcastFactory = new TestHazelcastFactory();\n+\n+    private HazelcastInstance server;\n+    private HazelcastInstance client;\n+\n+    @Before\n+    public void setup() {\n+        ClassLoader customClassLoader = new ClassLoader(Thread.currentThread().getContextClassLoader().getParent()) {\n+        };\n+        Config config = getConfig();\n+        config.setClassLoader(customClassLoader);\n+        config.getUserCodeDeploymentConfig().setEnabled(true);\n+        server = hazelcastFactory.newHazelcastInstance(config);\n+\n+        ClientConfig clientConfig = new ClientConfig();\n+        clientConfig.getUserCodeDeploymentConfig().setEnabled(true);\n+        clientConfig.getUserCodeDeploymentConfig().addClass(StaticSerializableBiFunction.class);\n+        clientConfig.getUserCodeDeploymentConfig().addClass(StaticNonSerializableBiFunction.class);\n+        client = hazelcastFactory.newHazelcastClient(clientConfig);\n+    }\n+\n+    @After\n+    public void tearDown() {\n+        hazelcastFactory.terminateAll();\n+    }\n+\n+    @Test\n+    public void testComputeIfPresentWithLambdaReMappingFunction() {\n+        final String outer_state = \"outer_state\";\n+        BiFunction biFunction = (key, oldValue) -> \"new_value_from_lambda_and_\" + outer_state;\n+        testComputeIfPresentForFunction(biFunction, \"new_value_from_lambda_and_outer_state\");\n+    }\n+\n+\n+    @Test\n+    public void testComputeIfPresentWithAnonymousReMappingFunction() {\n+        BiFunction<String, String, String> biFunction = NonStaticFunctionFactory\n+                .getAnonymousNonSerializableBiFunction(\"new_value\");\n+        testComputeIfPresentForFunction(biFunction, \"new_value\");\n+    }\n+\n+    @Test\n+    public void testComputeIfPresentWithStaticSerializableRemappingFunction() {\n+        StaticSerializableBiFunction biFunction = new StaticSerializableBiFunction(\"new_value\");\n+        testComputeIfPresentForFunction(biFunction, \"new_value\");\n+    }\n+\n+    @Test\n+    public void testComputeIfPresentWithStaticNonSerializableRemappingFunction() {\n+        StaticNonSerializableBiFunction biFunction = new StaticNonSerializableBiFunction(\"new_value\");\n+        testComputeIfPresentForFunction(biFunction, \"new_value\");\n+    }\n+\n+    @Test(expected = ClassNotFoundException.class)\n+    public void testComputeIfPresentWithRemappingFunctionPresentOnClientJVMOnly() throws Throwable {\n+        ClientOnlyStaticSerializableBiFunction biFunction = new ClientOnlyStaticSerializableBiFunction(\"new_value\");\n+        try {\n+            testComputeIfPresentForFunction(biFunction, \"new_value\");\n+        } catch (HazelcastSerializationException e) {", "originalCommit": "bc5711f30f81e60eb98fbfc7e481ef78256a0108", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY5MDIxMA==", "url": "https://github.com/hazelcast/hazelcast/pull/16636#discussion_r387690210", "bodyText": "You can move these kind of methods in SerializationUtil. Specifically, there is already a similar method there - SerializationUtil#checkSerializable.\nA bigger issue is that this does not cover some serialisation techniques that HZ supports, such as IdentifiedDataSerializable, DataSerializable and others. For instance (although it's not that common), the user can define a function like this:\npublic class IDSBiFunction implements BiFunction<String, String, String>, IdentifiedDataSerializable {\n    private String returnValue;\n    public IDSBiFunction() {\n    }\n\n    public IDSBiFunction(String returnValue) {\n        this.returnValue = returnValue;\n    }\n\n    @Override\n    public String apply(String key, String oldValue) {\n        return returnValue;\n    }\n\n    @Override\n    public int getFactoryId() {\n        return 1;\n    }\n\n    @Override\n    public int getClassId() {\n        return 0;\n    }\n\n    @Override\n    public void writeData(ObjectDataOutput out) throws IOException {\n        out.writeUTF(returnValue);\n    }\n\n    @Override\n    public void readData(ObjectDataInput in) throws IOException {\n        returnValue = in.readUTF();\n    }\n}\nIf this class is registered with a factory, such as: config.getSerializationConfig().addDataSerializableFactory(1, typeId -> new IDSBiFunction());, it will be possible to serialize and deserialize the class.\nUnfortunately, checking for all possible serialization strategies is probably not going to be easy to do in a utility method. I was initially thinking that we should simply try to serialise the function here but that might incur an unnecessary overhead for most users trying to submit non-serializable functions. So maybe for a best-effort approach we can additionally check if the class inherits DataSerializable or Portable.  If the class doesn't implement these but is serializable, we can always add more checks in the future.\n@cangencer @taburet WDYT?", "author": "mmedenjak", "createdAt": "2020-03-04T14:12:00Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/util/ClassMetadataUtil.java", "diffHunk": "@@ -0,0 +1,31 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.internal.util;\n+\n+import java.io.Serializable;\n+\n+public final class ClassMetadataUtil {\n+\n+    private ClassMetadataUtil() {\n+    }\n+\n+    public static boolean isClassStaticAndSerializable(Class clazz) {", "originalCommit": "bc5711f30f81e60eb98fbfc7e481ef78256a0108", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzcyMjgzOQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16636#discussion_r387722839", "bodyText": "Talking with Marko, seems like the case where the provided instance would implement IDS is something very awkward and usually users would be ok with simple lambdas and Serializable. IDS and other serialization techniques would simply execute locally. That means you don't need to change anything. Does that sound ok @cangencer @taburet?", "author": "mmedenjak", "createdAt": "2020-03-04T15:01:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY5MDIxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODEyMjczMA==", "url": "https://github.com/hazelcast/hazelcast/pull/16636#discussion_r388122730", "bodyText": "It should take BiFunctionEx instead of BiFunction. Then it would be automatically serializable. This was how the jet j.u.s hooks were working (before we removed the implementation) see an example here (DistributedStream is analogous to IMap, implementing a standard java interface..): https://github.com/hazelcast/hazelcast-jet/blob/v0.5/hazelcast-jet-core/src/main/java/com/hazelcast/jet/stream/DistributedStream.java", "author": "cangencer", "createdAt": "2020-03-05T07:44:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY5MDIxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODEzMDI1Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/16636#discussion_r388130256", "bodyText": "@cangencer we're talking about overriding java.util.concurrent.ConcurrentMap#computeIfPresent(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction).\nHow would it accept BiFunctionEx  instead of BiFunction? Am I missing something?", "author": "mmedenjak", "createdAt": "2020-03-05T08:04:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY5MDIxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODEzNDIwMQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16636#discussion_r388134201", "bodyText": "See the example I posted, it's possible to do it by adding another method and then upcasting. I would also suggest a \"checkSerializable\" method to fail fast, if something is not serializable: https://github.com/hazelcast/hazelcast-jet/blob/master/hazelcast-jet-core/src/main/java/com/hazelcast/jet/impl/util/Util.java#L168", "author": "cangencer", "createdAt": "2020-03-05T08:14:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY5MDIxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODEzNDQ4Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/16636#discussion_r388134483", "bodyText": "distributedStream extends Stream -> DistributedStream is analogous to IMap and Stream is analogous to ConcurrentMap. DistributedPredicate etc are equivalent to PredicateEx (older names of it)", "author": "cangencer", "createdAt": "2020-03-05T08:14:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY5MDIxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkxMTA4NA==", "url": "https://github.com/hazelcast/hazelcast/pull/16636#discussion_r388911084", "bodyText": "Hi @cangencer @mmedenjak ... I pushed a commit to address all feedback received so far.\nI didn't yet add an overloaded version to accept a BiFunctionEx. For computeIfPresent() implementation, in addition to checking if the BiFunction is Serializable, we also need to check if has a \"static\" class. The new overloaded method would only have avoided the Serialization check. I thought the performance cost saving would be minimal (+ I am sure the JVM would also need to do a check or two to figure out which version of the overloaded computeIfPresent() to call).\nAlso, the SerializationUtil.checkSerializable() is more robust (in addition to checking Serialization interface, it actually tries to serialize the object, to detect non-serializable fields).\nDoes this sound okay? Happy to be corrected ...", "author": "webashutosh", "createdAt": "2020-03-06T13:47:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY5MDIxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDIzNzI5OA==", "url": "https://github.com/hazelcast/hazelcast/pull/16636#discussion_r390237298", "bodyText": "If you have BiFunctionEx it should automatically made serializable without having to cast it explicitly. That's the main benefit.", "author": "cangencer", "createdAt": "2020-03-10T11:01:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY5MDIxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzYzOTQ3NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16636#discussion_r393639475", "bodyText": "I'm fine with the current state, resolving this comment. If @cangencer has other comments, let's open a new thread.", "author": "mmedenjak", "createdAt": "2020-03-17T12:23:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY5MDIxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzcwNzMwMA==", "url": "https://github.com/hazelcast/hazelcast/pull/16636#discussion_r387707300", "bodyText": "It would be great if you could make this class implement IdentifiedDataSerializable since currently this class uses java serialisation which is not efficient and does not allow class evolution. It does get complicated here, though. Once you add the interface, you'll have to implement some additional methods, like:\n@Override\n    public int getFactoryId() {\n        return MapDataSerializerHook.F_ID;\n    }\n\n    @Override\n    public int getClassId() {\n        return MapDataSerializerHook.BI_FUNCTION_EXECUTING_EP;\n    }\n\n    @Override\n    public void writeData(ObjectDataOutput out) throws IOException {\n        out.writeObject(biFunction);\n    }\n\n    @Override\n    public void readData(ObjectDataInput in) throws IOException {\n        biFunction = in.readObject();\n    }\n\nThis will also require adding a new row in MapDataSerializerHook but also a new client message and you'll need to modify the client protocol. I suggest you look at the EntryRemovingProcessor class and how it's instantiated and used from other parts of the code.", "author": "mmedenjak", "createdAt": "2020-03-04T14:38:16Z", "path": "hazelcast/src/main/java/com/hazelcast/map/impl/BiFunctionExecutingEntryProcessor.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.map.impl;\n+\n+import com.hazelcast.map.EntryProcessor;\n+\n+import javax.annotation.Nullable;\n+import java.util.Map;\n+import java.util.function.BiFunction;\n+\n+public class BiFunctionExecutingEntryProcessor<K, V> implements EntryProcessor<K, V, V> {", "originalCommit": "bc5711f30f81e60eb98fbfc7e481ef78256a0108", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkwMDQ1MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16636#discussion_r388900451", "bodyText": "Hi @mmedenjak , I am done with all changes. Just that I am not sure if/why would I need to add a new client message and modify the client protocol. I am using existing operations in the implementation for ClientMapProxy.java, which already have an existing implementation ... am I missing something?", "author": "webashutosh", "createdAt": "2020-03-06T13:26:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzcwNzMwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTAwNzkzMA==", "url": "https://github.com/hazelcast/hazelcast/pull/16636#discussion_r389007930", "bodyText": "Also wanted to check, do I need to provide this implementation for clients in other languages too?", "author": "webashutosh", "createdAt": "2020-03-06T16:34:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzcwNzMwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzYzOTgzOQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16636#discussion_r393639839", "bodyText": "Looks good to me. You don't need to provide an implementation for other languages and it seems you're right, there is no change needed to the client protocol. Resolving this comment.", "author": "mmedenjak", "createdAt": "2020-03-17T12:23:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzcwNzMwMA=="}], "type": "inlineReview"}, {"oid": "a4ca6a9cc86274a8b33db2a859124c7a2de5f16d", "url": "https://github.com/hazelcast/hazelcast/commit/a4ca6a9cc86274a8b33db2a859124c7a2de5f16d", "message": "Addressed review comments #11958 #14913", "committedDate": "2020-03-06T13:37:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzYzMTU3MA==", "url": "https://github.com/hazelcast/hazelcast/pull/16636#discussion_r393631570", "bodyText": "IMHO Looks good now. You're going to have to add one more check. We have a feature calling \"rolling upgrade\" where a cluster can be consisted out of members with 1 minor version difference. This means, if this feature is released in 4.1, the cluster may contain members with version 4.0 which will not be able to deserialise the new entry processor. So, the check should be added:\nVersion clusterVersion = getNodeEngine().getClusterService().getClusterVersion();\n\n        if (SerializationUtil.isClassStaticAndSerializable(remappingFunction)\n                && clusterVersion.isGreaterOrEqual(Versions.V4_1)) {", "author": "mmedenjak", "createdAt": "2020-03-17T12:07:42Z", "path": "hazelcast/src/main/java/com/hazelcast/map/impl/proxy/MapProxyImpl.java", "diffHunk": "@@ -1025,4 +1028,41 @@ private static void checkNotPagingPredicate(Predicate predicate, String method)\n             throw new IllegalArgumentException(\"PagingPredicate not supported in \" + method + \" method\");\n         }\n     }\n+\n+    @Override\n+    public V computeIfPresent(K key,\n+                              BiFunction<? super K, ? super V, ? extends V> remappingFunction) {\n+        checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);\n+        checkNotNull(key, NULL_BIFUNCTION_IS_NOT_ALLOWED);\n+\n+        if (SerializationUtil.isClassStaticAndSerializable(remappingFunction)) {", "originalCommit": "a4ca6a9cc86274a8b33db2a859124c7a2de5f16d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzYzNTc4MA==", "url": "https://github.com/hazelcast/hazelcast/pull/16636#discussion_r393635780", "bodyText": "This is where it gets tricky again. The client is not aware of the version of the cluster it is connected to. So it might happen that the function is serializable and static and is sent to the cluster but the cluster members fail to deserialise it. Unfortunately, this would mean there is no other option for the user but to not have a serializable function when calling from the client or to upgrade the member versions.\nI don't have a good idea how to tackle this. As a poor-man's solution (but, still better than an infinite loop which we have now), we can avoid this optimisation on the client and simply use computeIfPresentLocally in all cases. WDYT? cc @sancar", "author": "mmedenjak", "createdAt": "2020-03-17T12:16:10Z", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientMapProxy.java", "diffHunk": "@@ -1984,4 +1988,39 @@ protected void onDestroy() {\n             super.onDestroy();\n         }\n     }\n+\n+    @Override\n+    public V computeIfPresent(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction) {\n+        checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);\n+        checkNotNull(key, NULL_BIFUNCTION_IS_NOT_ALLOWED);\n+\n+        if (SerializationUtil.isClassStaticAndSerializable(remappingFunction)) {", "originalCommit": "a4ca6a9cc86274a8b33db2a859124c7a2de5f16d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY0MDAzNQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16636#discussion_r395640035", "bodyText": "Hi, @mmedenjak  is right we need a fallback mechanism when server is not available. Having a fallback mechanism have greater scope. Lets make the computeIfPresentLocally only implementation for now for the client. The optimisation for the client can be addressed later.", "author": "sancar", "createdAt": "2020-03-20T13:36:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzYzNTc4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY3ODU5NA==", "url": "https://github.com/hazelcast/hazelcast/pull/16636#discussion_r395678594", "bodyText": "Thanks @mmedenjak @sancar! I will push a commit to address all feedback.", "author": "webashutosh", "createdAt": "2020-03-20T14:36:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzYzNTc4MA=="}], "type": "inlineReview"}, {"oid": "2b5eedd2ece3ec0d9a3a2f9a3826f55c9daaf044", "url": "https://github.com/hazelcast/hazelcast/commit/2b5eedd2ece3ec0d9a3a2f9a3826f55c9daaf044", "message": "Addressed review comments #11958 #14913", "committedDate": "2020-03-21T17:39:54Z", "type": "commit"}, {"oid": "96621632ebbae3111c353524bea837ea29a9cb2f", "url": "https://github.com/hazelcast/hazelcast/commit/96621632ebbae3111c353524bea837ea29a9cb2f", "message": "Addressed review comments #11958 #14913", "committedDate": "2020-03-21T17:56:54Z", "type": "commit"}]}