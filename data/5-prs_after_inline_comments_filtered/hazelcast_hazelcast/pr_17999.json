{"pr_number": 17999, "pr_title": "Changes to SQL expressions needed for Jet", "pr_createdAt": "2020-12-23T14:56:49Z", "pr_url": "https://github.com/hazelcast/hazelcast/pull/17999", "timeline": [{"oid": "46843c6648286d5de33392e13aa1302e088e5d3d", "url": "https://github.com/hazelcast/hazelcast/commit/46843c6648286d5de33392e13aa1302e088e5d3d", "message": "Changes to SQL expressions needed for Jet", "committedDate": "2020-12-23T14:56:26Z", "type": "commit"}, {"oid": "3941febb7223608df5fa95d4bb1a41e267075ece", "url": "https://github.com/hazelcast/hazelcast/commit/3941febb7223608df5fa95d4bb1a41e267075ece", "message": "Unrelated javadoc fixes", "committedDate": "2020-12-23T14:56:28Z", "type": "commit"}, {"oid": "1e66e76b512f867400d8aa48519d210599de5069", "url": "https://github.com/hazelcast/hazelcast/commit/1e66e76b512f867400d8aa48519d210599de5069", "message": "Fix style", "committedDate": "2020-12-23T14:56:30Z", "type": "commit"}, {"oid": "3c623c6d3ecf7499c9a66bedb4f980fb931c052f", "url": "https://github.com/hazelcast/hazelcast/commit/3c623c6d3ecf7499c9a66bedb4f980fb931c052f", "message": "Grammar fixes", "committedDate": "2020-12-23T22:31:30Z", "type": "commit"}, {"oid": "6394fb8904bf0459928f066351637880b7d6124a", "url": "https://github.com/hazelcast/hazelcast/commit/6394fb8904bf0459928f066351637880b7d6124a", "message": "Use explicit cast when inferOperandTypes changes the type", "committedDate": "2020-12-23T23:06:11Z", "type": "commit"}, {"oid": "6394fb8904bf0459928f066351637880b7d6124a", "url": "https://github.com/hazelcast/hazelcast/commit/6394fb8904bf0459928f066351637880b7d6124a", "message": "Use explicit cast when inferOperandTypes changes the type", "committedDate": "2020-12-23T23:06:11Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTI5NTk5Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17999#discussion_r549295996", "bodyText": "What is the result of sql-to-rex conversion of the SqlNode with the SqlKind.DEFAULT?", "author": "devozerov", "createdAt": "2020-12-28T10:26:46Z", "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/HazelcastSqlToRelConverter.java", "diffHunk": "@@ -169,19 +169,24 @@ private RexNode convertCast(SqlCall call, Blackboard blackboard) {\n \n     /**\n      * This method overcomes a bug in Apache Calcite that ignores previously resolved return types of the expression\n-     * and instead attempts to infer them again using different logic. Without this fix, we will get type resolution\n-     * errors after SQL-to-rel conversion.\n+     * and instead attempts to infer them again using a different logic. Without this fix, we will get type resolution\n+     * errors after a SQL-to-rel conversion.\n      * <p>\n      * The method relies on the fact that all operators use {@link HazelcastReturnTypeInference} as a top-level return type\n      * inference method.\n      * <ul>\n-     *     <li>When a call node is observed for the first time, get it's return type and save it to a thread local variable</li>\n-     *     <li>Then delegate back to original converter code</li>\n-     *     <li>When converter attempts to resolve the return type of a call, he will get the previously saved type from\n-     *     the thread-local variable</li>\n+     *     <li>When a call node is observed for the first time, get its return type and save it to a thread-local variable\n+     *     <li>Then delegate back to original converter code\n+     *     <li>When converter attempts to resolve the return type of a call, it will get the previously saved type from\n+     *     the thread-local variable\n      * </ul>\n      */\n     private RexNode convertCall(SqlNode node, Blackboard blackboard) {\n+        // ignore DEFAULT (used for default function arguments). It doesn't support getValidatedNodeType()\n+        if (node.getKind() == SqlKind.DEFAULT) {", "originalCommit": "6394fb8904bf0459928f066351637880b7d6124a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTcyNDcwNA==", "url": "https://github.com/hazelcast/hazelcast/pull/17999#discussion_r549724704", "bodyText": "It's this:", "author": "viliam-durina", "createdAt": "2020-12-29T14:29:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTI5NTk5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTEzMzA2Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17999#discussion_r555133062", "bodyText": "Do we understand why exactly getValidatedNodeType is not supported here? Does it mean that the DEFAULT node is not validated? Because if it has been validated before, it should be saved in the validator's node-to-type map.", "author": "devozerov", "createdAt": "2021-01-11T15:37:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTI5NTk5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTE3OTAzNQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17999#discussion_r555179035", "bodyText": "The exception it throws is this:\nCaused by: java.lang.UnsupportedOperationException: class org.apache.calcite.sql.SqlBasicCall: DEFAULT\n\tat org.apache.calcite.util.Util.needToImplement(Util.java:967)\n\tat org.apache.calcite.sql.validate.SqlValidatorImpl.getValidatedNodeType(SqlValidatorImpl.java:1701)\n\tat com.hazelcast.sql.impl.calcite.HazelcastSqlToRelConverter.convertCall(HazelcastSqlToRelConverter.java:193)\n\nBtw, the node before translation is this:\n\nI debugged it a bit more and the reason might be this: We have a function with 4 arguments. But we only pass 3, the remaining one is default. In SqlCallBinding.permutedCall() it matches the actual operands with defined, and adds SqlCallBinding.DEFAULT_CALL as the 4th argument. Therefore, this SqlNode is not present in the tree when validating, but is added when converting. I don't think you can pass a DEFAULT value explicitly, so it can be only created this way.", "author": "viliam-durina", "createdAt": "2021-01-11T16:31:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTI5NTk5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTU5MzUwMA==", "url": "https://github.com/hazelcast/hazelcast/pull/17999#discussion_r555593500", "bodyText": "Thank you for the explanation. I am ok with the change then. Maybe be just a minor thought: it would be great to extend the comment with your findings. So that we always remember, that the DEFAULT operator is treated in a special way because it is created inside the SqlCallBinding.permutedCall(), and is not validated as other nodes.", "author": "devozerov", "createdAt": "2021-01-12T08:34:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTI5NTk5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTI5NjU5MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17999#discussion_r549296591", "bodyText": "Could you please remind me in which case the delegate could be null?", "author": "devozerov", "createdAt": "2020-12-28T10:28:44Z", "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/validate/operators/HazelcastReturnTypeInference.java", "diffHunk": "@@ -27,34 +28,40 @@\n import org.apache.calcite.sql.SqlOperatorBinding;\n import org.apache.calcite.sql.type.SqlReturnTypeInference;\n \n+import javax.annotation.Nullable;\n import java.util.ArrayDeque;\n import java.util.Deque;\n \n /**\n- * The inference strategy that allows to thransfer return type info between validation and conversion phases.\n+ * The inference strategy that allows to transfer the return type info between validation and conversion phases.\n  * <p>\n- * When doing sql-to-rel conversion Apache Calcite ignores information about the inferred return types from the validation\n+ * When doing sql-to-rel conversion, Apache Calcite ignores information about the inferred return types from the validation\n  * phase. To fix this, we intercept {@link SqlCall} conversions in the {@link HazelcastSqlToRelConverter}, lookup the\n- * real return type, and put it to the thread-local. Then, when the return type inference is invoked again during the\n- * conversion phase, it uses the information from the thread-local, rather than trying to infer again.\n+ * real return type, and put it to thread-local stack. Then, when the return type inference is invoked again during the\n+ * conversion phase, it peeks the thread-local stack, rather than trying to infer again.\n  * <p>\n  * In order for this workaround to work, every operator must have {@code HazelcastReturnTypeInference} as a\n  * return type inference strategy. This is controlled by the automated test. To simplify the development of operators,\n  * we create a number of base operator classes that set the required return type inference: {@link HazelcastFunction},\n  * {@link HazelcastPrefixOperator}, {@link HazelcastPostfixOperator}, {@link HazelcastBinaryOperator},\n- * {@link HazelcastSpecialOperator}. Every defined operator should extend one of these classes.\n+ * {@link HazelcastSpecialOperator}, {@link HazelcastAggFunction}. Every defined operator should extend one of these\n+ * classes.\n  */\n public final class HazelcastReturnTypeInference implements SqlReturnTypeInference {\n \n-    private static final ThreadLocal<Deque<RelDataType>> QUEUE = new ThreadLocal<>();\n+    private static final ThreadLocal<Deque<RelDataType>> QUEUE = ThreadLocal.withInitial(() -> new ArrayDeque<>(2));\n \n     private final SqlReturnTypeInference delegate;\n \n     private HazelcastReturnTypeInference(SqlReturnTypeInference delegate) {\n         this.delegate = delegate;\n     }\n \n-    public static HazelcastReturnTypeInference wrap(SqlReturnTypeInference delegate) {\n+    @Nullable\n+    public static HazelcastReturnTypeInference wrap(@Nullable SqlReturnTypeInference delegate) {\n+        if (delegate == null) {", "originalCommit": "6394fb8904bf0459928f066351637880b7d6124a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTY2MzU5Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17999#discussion_r549663593", "bodyText": "Here: https://github.com/viliam-durina/hazelcast-jet/blob/f5ab5ebbf7e84510a6cfee7f7734f71a11890c6c/hazelcast-jet-sql/src/main/java/com/hazelcast/jet/sql/impl/validate/operators/HazelcastRowOperator.java#L44\nThe null value is copied from here: https://github.com/apache/calcite/blob/6dba0ac4b8085426d67574a094f23eb407b3633d/core/src/main/java/org/apache/calcite/sql/fun/SqlRowOperator.java#L46. I don't know why it's so...", "author": "viliam-durina", "createdAt": "2020-12-29T11:04:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTI5NjU5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTEzNzkwOQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17999#discussion_r555137909", "bodyText": "I think we should never allow nulls here. Otherwise, we are risking losing the inferred types. The SqlRowOperator has a null return type inference, but it doesn't mean that there is no inference. Instead, it relies on its own SqlRowOperator.inferReturnType.\nI propose to disallow nulls in this part of the code (probably even add an assertion) and create a custom inference for our own ROW operator, that will delegate to SqlRowOperator.inferReturnType.", "author": "devozerov", "createdAt": "2021-01-11T15:43:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTI5NjU5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTkxODIyMQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17999#discussion_r561918221", "bodyText": "Fixed", "author": "viliam-durina", "createdAt": "2021-01-21T14:22:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTI5NjU5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTI5NjkwNg==", "url": "https://github.com/hazelcast/hazelcast/pull/17999#discussion_r549296906", "bodyText": "I do not like that COUNT(*) leaks into a general-purpose ReplaceUnknownOperandTypeInference. Let's use another specialized implementation for ReplaceUnknownOperandTypeInference instead.", "author": "devozerov", "createdAt": "2020-12-28T10:29:50Z", "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/validate/operators/ReplaceUnknownOperandTypeInference.java", "diffHunk": "@@ -51,6 +51,10 @@ public ReplaceUnknownOperandTypeInference(SqlTypeName[] typeNames, SqlTypeName d\n \n     @Override\n     public void inferOperandTypes(SqlCallBinding callBinding, RelDataType returnType, RelDataType[] operandTypes) {\n+        if (callBinding.getCall().isCountStar()) {", "originalCommit": "6394fb8904bf0459928f066351637880b7d6124a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTY3NDUwMQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17999#discussion_r549674501", "bodyText": "I ended up using null SqlOperandTypeInference, as the SqlCountAggFunction does. It's probably not needed because COUNT accepts any type. I did the same for HazelcastMinMaxAggFunction.", "author": "viliam-durina", "createdAt": "2020-12-29T11:45:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTI5NjkwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTI5NzQxNg==", "url": "https://github.com/hazelcast/hazelcast/pull/17999#discussion_r549297416", "bodyText": "This should not be there. Coercion is specific to operators and should not be enforced on the global level.", "author": "devozerov", "createdAt": "2020-12-28T10:31:28Z", "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/validate/operators/common/HazelcastOperandTypeCheckerAware.java", "diffHunk": "@@ -73,6 +73,9 @@ default HazelcastCallBinding prepareBinding(SqlCallBinding binding) {\n             operandTypeInference.inferOperandTypes(binding, binding.getValidator().getUnknownType(), operandTypes);\n \n             for (int i = 0; i < binding.getOperandCount(); i++) {\n+                if (binding.getOperandType(i).getSqlTypeName() != operandTypes[i].getSqlTypeName()) {", "originalCommit": "6394fb8904bf0459928f066351637880b7d6124a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTI5ODQ1MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17999#discussion_r549298451", "bodyText": "rowTypeCoercion, querySourceCoercion, and other similar methods are added here to ensure that we never rely on Calcite's coercion logic, but instead provide our own. Removal of these methods means that we again rely on Calcite, breaking the whole idea of controllable operator behavior.\nInstead, we should ensure that these functions are never invoked by providing the proper type checking implementations to the required operators.", "author": "devozerov", "createdAt": "2020-12-28T10:35:02Z", "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/validate/types/HazelcastTypeCoercion.java", "diffHunk": "@@ -100,11 +98,6 @@ public boolean binaryComparisonCoercion(SqlCallBinding binding) {\n         throw new UnsupportedOperationException(\"Should not be called\");\n     }\n \n-    @Override\n-    public boolean rowTypeCoercion(SqlValidatorScope scope, SqlNode query, int columnIndex, RelDataType targetType) {", "originalCommit": "6394fb8904bf0459928f066351637880b7d6124a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTE1MDA0Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17999#discussion_r555150042", "bodyText": "Do we have a final decision about querySourceCoercion and rowTypeCoercion methods? If we are going to use the Calcite implementation, can we leave the overridden methods, delegate them to Calcite's super, but add a comment, explaining the motivation?", "author": "devozerov", "createdAt": "2021-01-11T15:55:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTI5ODQ1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTI5OTEyOQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17999#discussion_r549299129", "bodyText": "This change is incorrect. We add CAST only when type names are different. If type names are equal, but types are different (e.g. BIGINT(63) vs BIGINT(64)), we only update the operand type in the validator. See usages of HazelcastTypeCoercion.coerceOperandType.", "author": "devozerov", "createdAt": "2020-12-28T10:36:59Z", "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/validate/types/HazelcastTypeCoercion.java", "diffHunk": "@@ -79,15 +79,13 @@ public boolean coerceOperandType(SqlValidatorScope scope, SqlCall call, int inde\n     private boolean requiresCast(SqlValidatorScope scope, SqlNode node, RelDataType to) {\n         RelDataType from = validator.deriveType(scope, node);\n \n-        assert from.isNullable() == to.isNullable();\n-\n         if (from.getSqlTypeName() == NULL || SqlUtil.isNullLiteral(node, false) || node.getKind() == SqlKind.DYNAMIC_PARAM) {\n             // Never cast NULLs or dynamic params, just assign types to them\n             return false;\n         }\n \n         // CAST is only required between different types.\n-        return from.getSqlTypeName() != to.getSqlTypeName();\n+        return !from.equals(to);", "originalCommit": "6394fb8904bf0459928f066351637880b7d6124a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTI5OTc2Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/17999#discussion_r549299767", "bodyText": "Changes to ReplicatedMap, NamedOperation, BaseInvocation, and MessageListener are not relevant to this PR and the SQL engine as a whole. I would propose to apply them in a separate PR to avoid mixing changes to unrelated parts of the product in a single PR.", "author": "devozerov", "createdAt": "2020-12-28T10:39:05Z", "path": "hazelcast/src/main/java/com/hazelcast/topic/MessageListener.java", "diffHunk": "@@ -20,23 +20,23 @@\n \n /**\n  * Message listener for {@link ITopic}.\n- *\n- * Provided that a MessageListener is not registered twice, a MessageListener will never be called concurrently. So there\n- * is no need to provide thread-safety on internal state in the MessageListener. Also there is no need to enforce safe\n- * publication, the ITopic is responsible for the memory consistency effects. In other words, there is no need to make\n+ * <p>\n+ * A MessageListener will never be called concurrently (provided that it's not registered twice). So there\n+ * is no need to synchronize access to the internal state in the MessageListener. Also there is no need to enforce\n+ * safe publication, the ITopic is responsible for memory consistency effects. In other words, there is no need to make\n  * internal fields of the MessageListener volatile or access them using synchronized blocks.\n  *\n- * @param <E> message\n+ * @param <E> message type\n  */\n @FunctionalInterface\n public interface MessageListener<E> extends EventListener {", "originalCommit": "6394fb8904bf0459928f066351637880b7d6124a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "809f2fa4f562f3a41457dca38d23a7346255a3fe", "url": "https://github.com/hazelcast/hazelcast/commit/809f2fa4f562f3a41457dca38d23a7346255a3fe", "message": "Remove space before comma", "committedDate": "2020-12-29T11:00:10Z", "type": "commit"}, {"oid": "5d9fa71594ce393e4694977d216cf7088f324974", "url": "https://github.com/hazelcast/hazelcast/commit/5d9fa71594ce393e4694977d216cf7088f324974", "message": "Remove the hack for COUNT(*)", "committedDate": "2020-12-29T14:08:42Z", "type": "commit"}, {"oid": "8d44f28f006353cd553090818b10583bc0590c7c", "url": "https://github.com/hazelcast/hazelcast/commit/8d44f28f006353cd553090818b10583bc0590c7c", "message": "Remove contested changes", "committedDate": "2020-12-29T14:31:48Z", "type": "commit"}, {"oid": "405c18bdff739180801bd295af8b25c0be644ee9", "url": "https://github.com/hazelcast/hazelcast/commit/405c18bdff739180801bd295af8b25c0be644ee9", "message": "Remove unrelated typo fixes", "committedDate": "2020-12-29T14:33:13Z", "type": "commit"}, {"oid": "7e8433d4093a98dbac24adc0f7d45a09e91ecc01", "url": "https://github.com/hazelcast/hazelcast/commit/7e8433d4093a98dbac24adc0f7d45a09e91ecc01", "message": "Merge branch 'master' into jet-expressions", "committedDate": "2020-12-29T14:43:55Z", "type": "commit"}, {"oid": "e471a5c3a5d0ebcdc5a887b3a173eaefbea48030", "url": "https://github.com/hazelcast/hazelcast/commit/e471a5c3a5d0ebcdc5a887b3a173eaefbea48030", "message": "Final changes", "committedDate": "2021-01-04T10:32:50Z", "type": "commit"}, {"oid": "4d5a581f412e42787ad602b24e77362680231571", "url": "https://github.com/hazelcast/hazelcast/commit/4d5a581f412e42787ad602b24e77362680231571", "message": "Merge remote-tracking branch 'remotes/hazelcast/master' into jet-expressions", "committedDate": "2021-01-11T15:41:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTEzOTQ5MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17999#discussion_r555139491", "bodyText": "If we use this constructor, we do not wrap the return type inference, which means that we may lose the return type inferred during the validation. All our constructors should have a non-null inference strategy wrapped with HazelcastReturnTypeInference.wrap.", "author": "devozerov", "createdAt": "2021-01-11T15:46:07Z", "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/validate/operators/common/HazelcastSpecialOperator.java", "diffHunk": "@@ -31,6 +31,13 @@\n  * See {@link HazelcastOperandTypeCheckerAware} for motivation.\n  */\n public abstract class HazelcastSpecialOperator extends SqlSpecialOperator implements HazelcastOperandTypeCheckerAware {\n+    protected HazelcastSpecialOperator(", "originalCommit": "7e8433d4093a98dbac24adc0f7d45a09e91ecc01", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTkxODM5Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17999#discussion_r561918393", "bodyText": "Constructor removed.", "author": "viliam-durina", "createdAt": "2021-01-21T14:22:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTEzOTQ5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTE0MTk2OA==", "url": "https://github.com/hazelcast/hazelcast/pull/17999#discussion_r555141968", "bodyText": "Is there a reason to limit all aggregate operators to a single operand only? I think this should be decided on a per-operator basis (e.g. see LISTAGG function).", "author": "devozerov", "createdAt": "2021-01-11T15:49:26Z", "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/validate/operators/common/HazelcastAggFunction.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.validate.operators.common;\n+\n+import com.hazelcast.sql.impl.calcite.validate.HazelcastCallBinding;\n+import org.apache.calcite.sql.SqlAggFunction;\n+import org.apache.calcite.sql.SqlCallBinding;\n+import org.apache.calcite.sql.SqlFunctionCategory;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.SqlOperandCountRange;\n+import org.apache.calcite.sql.type.SqlOperandCountRanges;\n+import org.apache.calcite.sql.type.SqlOperandTypeChecker;\n+import org.apache.calcite.sql.type.SqlOperandTypeInference;\n+import org.apache.calcite.sql.type.SqlReturnTypeInference;\n+import org.apache.calcite.util.Optionality;\n+\n+import static com.hazelcast.sql.impl.calcite.validate.operators.HazelcastReturnTypeInference.wrap;\n+\n+/**\n+ * A common subclass for aggregate functions (in Jet).\n+ * <p>\n+ * See {@link HazelcastOperandTypeCheckerAware} for motivation.\n+ */\n+public abstract class HazelcastAggFunction extends SqlAggFunction implements HazelcastOperandTypeCheckerAware {\n+\n+    public HazelcastAggFunction(\n+            String name,\n+            SqlKind kind,\n+            SqlReturnTypeInference returnTypeInference,\n+            SqlOperandTypeInference operandTypeInference,\n+            SqlOperandTypeChecker operandTypeChecker,\n+            SqlFunctionCategory funcType,\n+            boolean requiresOrder,\n+            boolean requiresOver,\n+            Optionality requiresGroupOrder\n+    ) {\n+        super(name, null, kind, wrap(returnTypeInference), operandTypeInference, operandTypeChecker,\n+                funcType, requiresOrder, requiresOver, requiresGroupOrder);\n+    }\n+\n+    @Override\n+    public final boolean checkOperandTypes(SqlCallBinding callBinding, boolean throwOnFailure) {\n+        HazelcastCallBinding bindingOverride = prepareBinding(callBinding);\n+\n+        return checkOperandTypes(bindingOverride, throwOnFailure);\n+    }\n+\n+    @Override\n+    public SqlOperandCountRange getOperandCountRange() {\n+        return SqlOperandCountRanges.between(1, 1);", "originalCommit": "7e8433d4093a98dbac24adc0f7d45a09e91ecc01", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDI4MTM5OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17999#discussion_r560281399", "bodyText": "All current agg functions have 1 argument. If some future function will have more, it can override.", "author": "viliam-durina", "createdAt": "2021-01-19T15:52:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTE0MTk2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDcxNDY0OA==", "url": "https://github.com/hazelcast/hazelcast/pull/17999#discussion_r560714648", "bodyText": "Some Calcite functions support more than one argument. My question is why do we restrict it for all operators, instead of setting the proper operand counts on a case-by-case basis? If we know for sure, that some functions require more than one argument, then we may implement the base class properly right from the beginning, especially given that this is a small change, the requires only slight code reorganization (e.g. move the method to concrete classes, or pass the argument count from the constructor, etc.).", "author": "devozerov", "createdAt": "2021-01-20T06:48:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTE0MTk2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDg4NTIyMQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17999#discussion_r560885221", "bodyText": "We're not restricting it. 100% of functions currently have 1 argument, if we add LISTAGG one day, then 90% of the functions will have 1 argument. Think of it as a good default for most cases, overriding the method is a third option of providing this information from the subclass.", "author": "viliam-durina", "createdAt": "2021-01-20T11:22:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTE0MTk2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTE0NDc1MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17999#discussion_r555144751", "bodyText": "In which cases an operandTypeInference could be null? Generally, this should never happen, because otherwise, we may miss some inferred types of the children nodes, as explained in the JavaDoc.", "author": "devozerov", "createdAt": "2021-01-11T15:51:37Z", "path": "hazelcast-sql-core/src/main/java/com/hazelcast/sql/impl/calcite/validate/operators/common/HazelcastOperandTypeCheckerAware.java", "diffHunk": "@@ -70,10 +70,12 @@ default HazelcastCallBinding prepareBinding(SqlCallBinding binding) {\n             RelDataType[] operandTypes = new RelDataType[binding.getOperandCount()];\n             Arrays.fill(operandTypes, unknownType);\n \n-            operandTypeInference.inferOperandTypes(binding, binding.getValidator().getUnknownType(), operandTypes);\n+            if (operandTypeInference != null) {", "originalCommit": "7e8433d4093a98dbac24adc0f7d45a09e91ecc01", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTA2NTA2NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17999#discussion_r561065064", "bodyText": "Fixed - it's again non-null.", "author": "viliam-durina", "createdAt": "2021-01-20T15:42:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTE0NDc1MQ=="}], "type": "inlineReview"}, {"oid": "ea8644ba78967e931323f8c8f217a35113202ab1", "url": "https://github.com/hazelcast/hazelcast/commit/ea8644ba78967e931323f8c8f217a35113202ab1", "message": "Add more explanation for DEFAULT", "committedDate": "2021-01-12T09:58:58Z", "type": "commit"}, {"oid": "47532dbf0d772366835e927eb757056549cde93f", "url": "https://github.com/hazelcast/hazelcast/commit/47532dbf0d772366835e927eb757056549cde93f", "message": "Merge branch 'master' into jet-expressions", "committedDate": "2021-01-14T08:13:28Z", "type": "commit"}, {"oid": "03efb874912afcc326d5073b25ebe0f2fee62661", "url": "https://github.com/hazelcast/hazelcast/commit/03efb874912afcc326d5073b25ebe0f2fee62661", "message": "Merge branch 'master' into jet-expressions", "committedDate": "2021-01-19T14:45:13Z", "type": "commit"}, {"oid": "e56e1a4471ff32a9dc1e1fb9c9933b4f7e039faf", "url": "https://github.com/hazelcast/hazelcast/commit/e56e1a4471ff32a9dc1e1fb9c9933b4f7e039faf", "message": "Make operandTypeInference mandatory", "committedDate": "2021-01-20T15:39:53Z", "type": "commit"}, {"oid": "9d2316582d409d320163df3385836d8198ab2b16", "url": "https://github.com/hazelcast/hazelcast/commit/9d2316582d409d320163df3385836d8198ab2b16", "message": "Remove null ReturnTypeInference", "committedDate": "2021-01-21T14:21:18Z", "type": "commit"}]}