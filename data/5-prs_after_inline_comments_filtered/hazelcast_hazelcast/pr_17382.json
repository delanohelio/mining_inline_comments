{"pr_number": 17382, "pr_title": "SQL index support (#17381)", "pr_createdAt": "2020-08-19T13:53:07Z", "pr_url": "https://github.com/hazelcast/hazelcast/pull/17382", "timeline": [{"oid": "0af8832761bcf0f710de8a2d3579af16294cd689", "url": "https://github.com/hazelcast/hazelcast/commit/0af8832761bcf0f710de8a2d3579af16294cd689", "message": "SQL index support (#17378)", "committedDate": "2020-08-19T13:32:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzEwNDE4OA==", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r473104188", "bodyText": "Javadoc for the new methods would be useful.", "author": "petrpleshachkov", "createdAt": "2020-08-19T15:10:31Z", "path": "hazelcast/src/main/java/com/hazelcast/query/impl/Index.java", "diffHunk": "@@ -109,6 +111,14 @@\n      */\n     Set<QueryableEntry> evaluate(Predicate predicate);\n \n+    Iterator<QueryableEntry> getRecordIterator();", "originalCommit": "0af8832761bcf0f710de8a2d3579af16294cd689", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzI0OTg1Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r473249856", "bodyText": "Added JavaDoc", "author": "devozerov", "createdAt": "2020-08-19T18:52:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzEwNDE4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzEwNjI3OA==", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r473106278", "bodyText": "I'd return null values first because NULL is less than any other key.", "author": "petrpleshachkov", "createdAt": "2020-08-19T15:13:26Z", "path": "hazelcast/src/main/java/com/hazelcast/query/impl/OrderedIndexStore.java", "diffHunk": "@@ -110,6 +115,81 @@ public boolean canEvaluate(Class<? extends Predicate> predicateClass) {\n         throw new UnsupportedOperationException();\n     }\n \n+    @Override\n+    public Iterator<QueryableEntry> getRecordIterator() {\n+        Iterator<QueryableEntry> iterator = new IndexEntryCompositeIterator(recordMap.values().iterator());\n+        Iterator<QueryableEntry> nullIterator = recordsWithNullValue.values().iterator();\n+\n+        return new FlatCompositeIterator<>(Arrays.asList(iterator, nullIterator).iterator());", "originalCommit": "0af8832761bcf0f710de8a2d3579af16294cd689", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzI1MTA4OA==", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r473251088", "bodyText": "Moved NULL values to the beginning of the data stream.", "author": "devozerov", "createdAt": "2020-08-19T18:54:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzEwNjI3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzExMDQwMA==", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r473110400", "bodyText": "In the old Set based implementation we supported a similar method. Yes, not efficiently, but we didn't throw an exception.", "author": "petrpleshachkov", "createdAt": "2020-08-19T15:19:15Z", "path": "hazelcast/src/main/java/com/hazelcast/query/impl/UnorderedIndexStore.java", "diffHunk": "@@ -136,6 +140,44 @@ public boolean canEvaluate(Class<? extends Predicate> predicateClass) {\n         throw new UnsupportedOperationException();\n     }\n \n+    @Override\n+    public Iterator<QueryableEntry> getRecordIterator() {\n+        Iterator<QueryableEntry> iterator = new IndexEntryCompositeIterator(recordMap.values().iterator());\n+        Iterator<QueryableEntry> nullIterator = recordsWithNullValue.values().iterator();\n+\n+        return new FlatCompositeIterator<>(Arrays.asList(iterator, nullIterator).iterator());\n+    }\n+\n+    @Override\n+    public Iterator<QueryableEntry> getRecordIterator(Comparable value) {\n+        if (value == NULL) {\n+            return recordsWithNullValue.values().iterator();\n+        } else {\n+            Map<Data, QueryableEntry> res = recordMap.get(canonicalize(value));\n+\n+            if (res == null) {\n+                return Collections.emptyIterator();\n+            }\n+\n+            return res.values().iterator();\n+        }\n+    }\n+\n+    @Override\n+    public Iterator<QueryableEntry> getRecordIterator(Comparison comparison, Comparable value) {\n+        throw new UnsupportedOperationException();", "originalCommit": "0af8832761bcf0f710de8a2d3579af16294cd689", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzI1MTQzNA==", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r473251434", "bodyText": "We do not use HASH indexes for range lookups - it doesn't make sense from the performance perspective. Therefore, this method is not implemented - it is just never called.", "author": "devozerov", "createdAt": "2020-08-19T18:55:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzExMDQwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzgxODAwOQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r473818009", "bodyText": "@taburet , for the Set -based methods we do have an implementation of similar methods. Can we still use them?", "author": "petrpleshachkov", "createdAt": "2020-08-20T09:36:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzExMDQwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzgyMzY1NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r473823654", "bodyText": "Yes, there are implementations for Set-based methods. The key question - why do we want to use them at all?\nCurrently, the planner does not consider HASH indexes for range requests. And therefore these unsupported methods are never invoked. The motivation for this is that the HASH index cannot speedup range queries.", "author": "devozerov", "createdAt": "2020-08-20T09:43:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzExMDQwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU1OTI0Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r475559246", "bodyText": "@petrpleshachkov Yes, the old set-based methods are still used in the old engine. To my understanding the idea of using hash indexes for range full scans was to avoid deserialization/extraction of the attribute in question since index keys are already extracted/deserialized. Never measured the actual performance benefits, but there should be some :)", "author": "taburet", "createdAt": "2020-08-24T12:22:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzExMDQwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzExNDQxMQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r473114411", "bodyText": "Why for NULL we don't get them from the index?", "author": "petrpleshachkov", "createdAt": "2020-08-19T15:24:16Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/scan/index/IndexRangeFilter.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.exec.scan.index;\n+\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.query.impl.AbstractIndex;\n+import com.hazelcast.query.impl.Comparison;\n+import com.hazelcast.query.impl.InternalIndex;\n+import com.hazelcast.query.impl.QueryableEntry;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.Objects;\n+\n+@SuppressWarnings(\"rawtypes\")\n+public class IndexRangeFilter implements IndexFilter, IdentifiedDataSerializable {\n+\n+    private IndexFilterValue from;\n+    private boolean fromInclusive;\n+    private IndexFilterValue to;\n+    private boolean toInclusive;\n+\n+    public IndexRangeFilter() {\n+        // No-op.\n+    }\n+\n+    public IndexRangeFilter(IndexFilterValue from, boolean fromInclusive, IndexFilterValue to, boolean toInclusive) {\n+        this.from = from;\n+        this.fromInclusive = fromInclusive;\n+        this.to = to;\n+        this.toInclusive = toInclusive;\n+    }\n+\n+    @SuppressWarnings(\"checkstyle:CyclomaticComplexity\")\n+    @Override\n+    public Iterator<QueryableEntry> getEntries(InternalIndex index, ExpressionEvalContext evalContext) {\n+        if (from != null && to == null) {\n+            // Left bound only\n+            Comparable fromValue = from.getValue(evalContext);\n+            Comparison fromComparison = fromInclusive ? Comparison.GREATER_OR_EQUAL : Comparison.GREATER;\n+\n+            if (fromValue == null || fromValue == AbstractIndex.NULL) {\n+                return Collections.emptyIterator();", "originalCommit": "0af8832761bcf0f710de8a2d3579af16294cd689", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzI1MjUzMQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r473252531", "bodyText": "This comes from the SQL semantics: predicates like a > NULL or a = NULL never return any entries. So if we observe a null bound, we just return an empty result set.", "author": "devozerov", "createdAt": "2020-08-19T18:57:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzExNDQxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDU5NjU2NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r474596564", "bodyText": "It might make sense to document that special null meaning (in IndexFilterValue and IndexFilter?), it took me ~20 minutes to unravel all the code paths. If there would be a comment like the one above, it might significantly reduce the review time and make life easier for the future generations.", "author": "taburet", "createdAt": "2020-08-21T09:53:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzExNDQxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ5MjkzMw==", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r475492933", "bodyText": "value == AbstractIndex.NULL appeared to be dead code. Added an assert for this with JavaDocs.\nSee 4f748cc", "author": "devozerov", "createdAt": "2020-08-24T10:13:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzExNDQxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzExNjA4Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r473116082", "bodyText": "if from == null and to == null then we will go to this branch?", "author": "petrpleshachkov", "createdAt": "2020-08-19T15:26:36Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/scan/index/IndexRangeFilter.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.exec.scan.index;\n+\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.query.impl.AbstractIndex;\n+import com.hazelcast.query.impl.Comparison;\n+import com.hazelcast.query.impl.InternalIndex;\n+import com.hazelcast.query.impl.QueryableEntry;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.Objects;\n+\n+@SuppressWarnings(\"rawtypes\")\n+public class IndexRangeFilter implements IndexFilter, IdentifiedDataSerializable {\n+\n+    private IndexFilterValue from;\n+    private boolean fromInclusive;\n+    private IndexFilterValue to;\n+    private boolean toInclusive;\n+\n+    public IndexRangeFilter() {\n+        // No-op.\n+    }\n+\n+    public IndexRangeFilter(IndexFilterValue from, boolean fromInclusive, IndexFilterValue to, boolean toInclusive) {\n+        this.from = from;\n+        this.fromInclusive = fromInclusive;\n+        this.to = to;\n+        this.toInclusive = toInclusive;\n+    }\n+\n+    @SuppressWarnings(\"checkstyle:CyclomaticComplexity\")\n+    @Override\n+    public Iterator<QueryableEntry> getEntries(InternalIndex index, ExpressionEvalContext evalContext) {\n+        if (from != null && to == null) {\n+            // Left bound only\n+            Comparable fromValue = from.getValue(evalContext);\n+            Comparison fromComparison = fromInclusive ? Comparison.GREATER_OR_EQUAL : Comparison.GREATER;\n+\n+            if (fromValue == null || fromValue == AbstractIndex.NULL) {\n+                return Collections.emptyIterator();\n+            }\n+\n+            return index.getRecordIterator(fromComparison, fromValue);\n+        } else if (from == null && to != null) {\n+            // Right bound only\n+            Comparable toValue = to.getValue(evalContext);\n+            Comparison toComparison = toInclusive ? Comparison.LESS_OR_EQUAL : Comparison.LESS;\n+\n+            if (toValue == null || toValue == AbstractIndex.NULL) {\n+                return Collections.emptyIterator();\n+            }\n+\n+            return index.getRecordIterator(toComparison, toValue);\n+        } else {\n+            assert from != null;", "originalCommit": "0af8832761bcf0f710de8a2d3579af16294cd689", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzI1NTYxMA==", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r473255610", "bodyText": "from == null && to == null is not possible. Added assertions and rearranged the code to demonstrate in more clear way.", "author": "devozerov", "createdAt": "2020-08-19T19:03:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzExNjA4Mg=="}], "type": "inlineReview"}, {"oid": "eec916ef782651bfc4e1eb4ff2ea5bdcb8728a0b", "url": "https://github.com/hazelcast/hazelcast/commit/eec916ef782651bfc4e1eb4ff2ea5bdcb8728a0b", "message": "Fixed MapIndexScanPlanNode serialization and equality.", "committedDate": "2020-08-19T18:46:47Z", "type": "commit"}, {"oid": "b1fddde298baf41fe4bc201d6c637b424b7b6667", "url": "https://github.com/hazelcast/hazelcast/commit/b1fddde298baf41fe4bc201d6c637b424b7b6667", "message": "JavaDoc for new index methods. Added \"sql\" word to them to stress out that they should be used for SQL only.", "committedDate": "2020-08-19T18:51:54Z", "type": "commit"}, {"oid": "480b43d858d34b6dba0f27154c257c7523713928", "url": "https://github.com/hazelcast/hazelcast/commit/480b43d858d34b6dba0f27154c257c7523713928", "message": "Move NULLs to the beginning for OrderedIndexStore.", "committedDate": "2020-08-19T18:54:23Z", "type": "commit"}, {"oid": "93423f0e9262f722d2280c0032cb94420c7edf89", "url": "https://github.com/hazelcast/hazelcast/commit/93423f0e9262f722d2280c0032cb94420c7edf89", "message": "Better code arrangement in IndexRangeFilter", "committedDate": "2020-08-19T19:01:28Z", "type": "commit"}, {"oid": "73b642509f5df21624bdeaae4e3641cfea9a9412", "url": "https://github.com/hazelcast/hazelcast/commit/73b642509f5df21624bdeaae4e3641cfea9a9412", "message": "Merge branch 'master' into issues/17381", "committedDate": "2020-08-20T08:44:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzcyNDU2Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r473724566", "bodyText": "Is there any real concurrency here?", "author": "petrpleshachkov", "createdAt": "2020-08-20T07:54:15Z", "path": "hazelcast/src/test/java/com/hazelcast/sql/impl/SqlTestSupport.java", "diffHunk": "@@ -219,4 +229,119 @@ public static SqlInternalService sqlInternalService(HazelcastInstance instance)\n     public static void clearPlanCache(HazelcastInstance member) {\n         ((SqlServiceImpl) member.getSql()).getPlanCache().clear();\n     }\n+\n+    public static int getLocalPartition(HazelcastInstance member) {\n+        PartitionIdSet partitions = getLocalPartitions(member);\n+\n+        if (partitions.isEmpty()) {\n+            throw new RuntimeException(\"Member does nave local partitions\");\n+        }\n+\n+        return partitions.iterator().next();\n+    }\n+\n+    public static PartitionIdSet getLocalPartitions(HazelcastInstance member) {\n+        PartitionService partitionService = member.getPartitionService();\n+\n+        PartitionIdSet res = new PartitionIdSet(partitionService.getPartitions().size());\n+\n+        for (Partition partition : partitionService.getPartitions()) {\n+            if (partition.getOwner().localMember()) {\n+                res.add(partition.getPartitionId());\n+            }\n+        }\n+\n+        return res;\n+    }\n+\n+    public static <K> K getLocalKey(\n+        HazelcastInstance member,\n+        IntFunction<K> keyProducer\n+    ) {\n+        return getLocalKeys(member, 1, keyProducer).get(0);\n+    }\n+\n+    public static <K> List<K> getLocalKeys(\n+        HazelcastInstance member,\n+        int count,\n+        IntFunction<K> keyProducer\n+    ) {\n+        return new ArrayList<>(getLocalEntries(member, count, keyProducer, keyProducer).keySet());\n+    }\n+\n+    public static <K, V> Map.Entry<K, V> getLocalEntry(\n+        HazelcastInstance member,\n+        IntFunction<K> keyProducer,\n+        IntFunction<V> valueProducer\n+    ) {\n+        return getLocalEntries(member, 1, keyProducer, valueProducer).entrySet().iterator().next();\n+    }\n+\n+    public static <K, V> Map<K, V> getLocalEntries(\n+        HazelcastInstance member,\n+        int count,\n+        IntFunction<K> keyProducer,\n+        IntFunction<V> valueProducer\n+    ) {\n+        if (count == 0) {\n+            return Collections.emptyMap();\n+        }\n+\n+        PartitionService partitionService = member.getPartitionService();\n+\n+        Map<K, V> res = new LinkedHashMap<>();\n+\n+        for (int i = 0; i < Integer.MAX_VALUE; i++) {\n+            K key = keyProducer.apply(i);\n+\n+            if (key == null) {\n+                continue;\n+            }\n+\n+            Partition partition = partitionService.getPartition(key);\n+\n+            if (!partition.getOwner().localMember()) {\n+                continue;\n+            }\n+\n+            V value = valueProducer.apply(i);\n+\n+            if (value == null) {\n+                continue;\n+            }\n+\n+            res.put(key, value);\n+\n+            if (res.size() == count) {\n+                break;\n+            }\n+        }\n+\n+        if (res.size() < count) {\n+            throw new RuntimeException(\"Failed to get the necesasry number of key: \" + res.size());\n+        }\n+\n+        return res;\n+    }\n+\n+    protected static MapIndexScanPlanNode findFirstIndexNode(SqlResult result) {\n+        SqlResultImpl result0 = (SqlResultImpl) result;\n+\n+        AtomicReference<MapIndexScanPlanNode> nodeRef = new AtomicReference<>();\n+\n+        for (int i = 0; i < result0.getPlan().getFragmentCount(); i++) {\n+            PlanNode fragment = result0.getPlan().getFragment(i);\n+\n+            fragment.visit(new TestPlanNodeVisitorAdapter() {\n+                @Override\n+                public void onMapIndexScanNode(MapIndexScanPlanNode node) {\n+                    nodeRef.compareAndSet(null, node);", "originalCommit": "0af8832761bcf0f710de8a2d3579af16294cd689", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzgxNzMzOQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r473817339", "bodyText": "No, but we need a way to update a field of the enclosing method. This is the simplest way of doing this", "author": "devozerov", "createdAt": "2020-08-20T09:36:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzcyNDU2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzgxMzQwNA==", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r473813404", "bodyText": "Do we have HD version of the test in the EE PR?", "author": "petrpleshachkov", "createdAt": "2020-08-20T09:31:25Z", "path": "hazelcast/src/test/java/com/hazelcast/sql/impl/exec/scan/index/IndexRangeFilterTest.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.exec.scan.index;\n+\n+import com.hazelcast.query.impl.AbstractIndex;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.expression.SimpleExpressionEvalContext;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class IndexRangeFilterTest extends IndexFilterTestSupport {", "originalCommit": "0af8832761bcf0f710de8a2d3579af16294cd689", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzgxNzQ0OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r473817449", "bodyText": "Yes", "author": "devozerov", "createdAt": "2020-08-20T09:36:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzgxMzQwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzgxNDU4NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r473814585", "bodyText": "Cannot find HD version of the test in the EE PR.", "author": "petrpleshachkov", "createdAt": "2020-08-20T09:32:51Z", "path": "hazelcast/src/test/java/com/hazelcast/sql/impl/exec/scan/index/MapIndexScanExecTest.java", "diffHunk": "@@ -0,0 +1,406 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.exec.scan.index;\n+\n+import com.hazelcast.config.Config;\n+import com.hazelcast.config.IndexConfig;\n+import com.hazelcast.config.IndexType;\n+import com.hazelcast.core.HazelcastInstance;\n+import com.hazelcast.internal.util.collection.PartitionIdSet;\n+import com.hazelcast.map.IMap;\n+import com.hazelcast.sql.SqlErrorCode;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.SqlTestSupport;\n+import com.hazelcast.sql.impl.exec.IterationResult;\n+import com.hazelcast.sql.impl.exec.scan.AbstractMapScanExec;\n+import com.hazelcast.sql.impl.expression.ColumnExpression;\n+import com.hazelcast.sql.impl.expression.ConstantExpression;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.predicate.ComparisonMode;\n+import com.hazelcast.sql.impl.expression.predicate.ComparisonPredicate;\n+import com.hazelcast.sql.impl.extract.GenericQueryTargetDescriptor;\n+import com.hazelcast.sql.impl.extract.QueryPath;\n+import com.hazelcast.sql.impl.row.RowBatch;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.TestHazelcastInstanceFactory;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.IntStream;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class MapIndexScanExecTest extends SqlTestSupport {", "originalCommit": "0af8832761bcf0f710de8a2d3579af16294cd689", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzgxNzk3NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r473817974", "bodyText": "There is no need for HD counterpart since there is only one exec for both HD and non-HD maps.", "author": "devozerov", "createdAt": "2020-08-20T09:36:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzgxNDU4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzgxNTU2Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r473815562", "bodyText": "Add HD version as well?", "author": "petrpleshachkov", "createdAt": "2020-08-20T09:34:03Z", "path": "hazelcast/src/test/java/com/hazelcast/sql/impl/schema/map/MapTableIndexTest.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.schema.map;\n+\n+import com.hazelcast.config.IndexType;\n+import com.hazelcast.sql.impl.SqlTestSupport;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import java.util.List;\n+\n+import static com.hazelcast.config.IndexType.HASH;\n+import static com.hazelcast.config.IndexType.SORTED;\n+import static com.hazelcast.sql.impl.type.QueryDataType.BIGINT;\n+import static com.hazelcast.sql.impl.type.QueryDataType.INT;\n+import static java.util.Collections.singletonList;\n+import static org.junit.Assert.assertEquals;\n+\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class MapTableIndexTest extends SqlTestSupport {", "originalCommit": "0af8832761bcf0f710de8a2d3579af16294cd689", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzgxODQ3MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r473818471", "bodyText": "No need for this, since there is no HD-specific code", "author": "devozerov", "createdAt": "2020-08-20T09:37:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzgxNTU2Mg=="}], "type": "inlineReview"}, {"oid": "66b59b835ca52cdfacaf6035fe10835e61c096cd", "url": "https://github.com/hazelcast/hazelcast/commit/66b59b835ca52cdfacaf6035fe10835e61c096cd", "message": "Make sure that the engine do not use non-concurrent HD indexes.", "committedDate": "2020-08-20T09:34:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzgyMjIzMQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r473822231", "bodyText": "What is about BITMAP indexes? Are they filtered out on a higher level?", "author": "petrpleshachkov", "createdAt": "2020-08-20T09:41:53Z", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/opt/cost/CostUtils.java", "diffHunk": "@@ -43,6 +50,29 @@ private CostUtils() {\n         // No-op.\n     }\n \n+    /**\n+     * Get CPU multiplier for index scan. It ensures that normal scans are preferred over index scans when there are no\n+     * conditions and collation provided by the index is not important for the specific query.\n+     * <p>\n+     * We assume that index scan is more expensive than normal scan due to additional level of indirection. This is not the\n+     * case for covering index scans, but we do not support them yet.\n+     * <p>\n+     * We assume that HASH index lookup is cheaper than SORTED index lookup in general case, because the former has O(1)\n+     * complexity, while the latter has O(N) complexity.\n+     *\n+     * @param type Index type.\n+     * @return CPU multiplier.\n+     */\n+    public static double indexScanCpuMultiplier(IndexType type) {\n+        if (type == IndexType.HASH) {\n+            return INDEX_SCAN_CPU_MULTIPLIER_HASH;\n+        } else {\n+            assert type == IndexType.SORTED;", "originalCommit": "73b642509f5df21624bdeaae4e3641cfea9a9412", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzkxNTE0MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r473915141", "bodyText": "Yes, BITMAP indexes are filtered out in IndexResolver.isIndexSupported", "author": "devozerov", "createdAt": "2020-08-20T11:58:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzgyMjIzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzgyNjExNA==", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r473826114", "bodyText": "Typo: thos", "author": "petrpleshachkov", "createdAt": "2020-08-20T09:46:36Z", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/opt/physical/index/IndexComponentCandidate.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.opt.physical.index;\n+\n+import com.hazelcast.sql.impl.exec.scan.index.IndexFilter;\n+import org.apache.calcite.rex.RexNode;\n+\n+/**\n+ * A candidate expression that could potentially be used to form a filter on some index component.\n+ * <p>\n+ * Consider the query {@code SELECT * FROM person WHERE name=? AND age=?}. After analysis two candidates would be\n+ * created: one for the {@code name=?} expression, and another for the {@code age=?} expression. If there is an index\n+ * on any of thos columns, the engine will attempt to apply the candidate to the index to form an {@link IndexComponentFilter}.", "originalCommit": "73b642509f5df21624bdeaae4e3641cfea9a9412", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzkxNTU2MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r473915561", "bodyText": "Fixed", "author": "devozerov", "createdAt": "2020-08-20T11:58:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzgyNjExNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzg0MTcyOQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r473841729", "bodyText": "Do we expect here any specific Sql exception? I feel a bit uncomfortable to catch a random exception and potentially hiding an issue in the code.", "author": "petrpleshachkov", "createdAt": "2020-08-20T10:05:04Z", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/opt/physical/index/IndexResolver.java", "diffHunk": "@@ -0,0 +1,1117 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.opt.physical.index;\n+\n+import com.hazelcast.config.IndexType;\n+import com.hazelcast.internal.util.BiTuple;\n+import com.hazelcast.query.impl.ComparableIdentifiedDataSerializable;\n+import com.hazelcast.query.impl.TypeConverters;\n+import com.hazelcast.sql.impl.QueryParameterMetadata;\n+import com.hazelcast.sql.impl.calcite.SqlToQueryType;\n+import com.hazelcast.sql.impl.calcite.opt.OptUtils;\n+import com.hazelcast.sql.impl.calcite.opt.distribution.DistributionTrait;\n+import com.hazelcast.sql.impl.calcite.opt.logical.MapScanLogicalRel;\n+import com.hazelcast.sql.impl.calcite.opt.physical.MapIndexScanPhysicalRel;\n+import com.hazelcast.sql.impl.calcite.opt.physical.visitor.RexToExpressionVisitor;\n+import com.hazelcast.sql.impl.calcite.schema.HazelcastRelOptTable;\n+import com.hazelcast.sql.impl.calcite.schema.HazelcastTable;\n+import com.hazelcast.sql.impl.exec.scan.index.IndexEqualsFilter;\n+import com.hazelcast.sql.impl.exec.scan.index.IndexFilter;\n+import com.hazelcast.sql.impl.exec.scan.index.IndexFilterValue;\n+import com.hazelcast.sql.impl.exec.scan.index.IndexInFilter;\n+import com.hazelcast.sql.impl.exec.scan.index.IndexRangeFilter;\n+import com.hazelcast.sql.impl.expression.ConstantExpression;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.plan.node.PlanNodeFieldTypeProvider;\n+import com.hazelcast.sql.impl.schema.map.MapTableIndex;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import org.apache.calcite.plan.RelOptTable;\n+import org.apache.calcite.plan.RelOptUtil;\n+import org.apache.calcite.plan.RelTraitSet;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexBuilder;\n+import org.apache.calcite.rex.RexCall;\n+import org.apache.calcite.rex.RexInputRef;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.rex.RexUtil;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.hazelcast.query.impl.CompositeValue.NEGATIVE_INFINITY;\n+import static com.hazelcast.query.impl.CompositeValue.POSITIVE_INFINITY;\n+import static java.util.Collections.singletonList;\n+import static org.apache.calcite.sql.type.SqlTypeFamily.NUMERIC;\n+\n+/**\n+ * Helper class to resolve indexes.\n+ */\n+@SuppressWarnings(\"rawtypes\")\n+public final class IndexResolver {\n+    private IndexResolver() {\n+        // No-op.\n+    }\n+\n+    public static List<RelNode> createIndexScans(\n+        MapScanLogicalRel scan,\n+        DistributionTrait distribution,\n+        List<MapTableIndex> indexes\n+    ) {\n+        // Early return if there is no filter.\n+        RexNode filter = scan.getTableUnwrapped().getFilter();\n+\n+        if (filter == null) {\n+            return Collections.emptyList();\n+        }\n+\n+        // Filter out unsupported indexes.\n+        List<MapTableIndex> supportedIndexes = new ArrayList<>(indexes.size());\n+        Set<Integer> allIndexedFieldOrdinals = new HashSet<>();\n+\n+        for (MapTableIndex index : indexes) {\n+            if (isIndexSupported(index)) {\n+                supportedIndexes.add(index);\n+\n+                allIndexedFieldOrdinals.addAll(index.getFieldOrdinals());\n+            }\n+        }\n+\n+        // Early return if there are no indexes to consider.\n+        if (supportedIndexes.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        // Convert expression into CNF\n+        List<RexNode> conjunctions = createConjunctiveFilter(filter);\n+\n+        // Prepare candidates from conjunctive expressions.\n+        Map<Integer, List<IndexComponentCandidate>> candidates = prepareSingleColumnCandidates(\n+            conjunctions,\n+            OptUtils.getCluster(scan).getParameterMetadata(),\n+            allIndexedFieldOrdinals\n+        );\n+\n+        if (candidates.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        // Create index relational operators based on candidates.\n+        List<RelNode> rels = new ArrayList<>(supportedIndexes.size());\n+\n+        for (MapTableIndex index : supportedIndexes) {\n+            RelNode rel = createIndexScan(scan, distribution, index, conjunctions, candidates);\n+\n+            if (rel != null) {\n+                rels.add(rel);\n+            }\n+        }\n+\n+        return rels;\n+    }\n+\n+    /**\n+     * Creates an object for convenient access to part of the predicate in the CNF.\n+     */\n+    private static List<RexNode> createConjunctiveFilter(RexNode filter) {\n+        List<RexNode> conjunctions = new ArrayList<>(1);\n+\n+        RelOptUtil.decomposeConjunction(filter, conjunctions);\n+\n+        return conjunctions;\n+    }\n+\n+    /**\n+     * Creates a map from the scan column ordinal to expressions that could be potentially used by indexes created over\n+     * this column.\n+     *\n+     * @param nodes                   CNF nodes\n+     * @param allIndexedFieldOrdinals Ordinals of all columns that have some indexes. Helps to filter out candidates that\n+     *                                definitely cannot be used earlier.\n+     */\n+    private static Map<Integer, List<IndexComponentCandidate>> prepareSingleColumnCandidates(\n+        List<RexNode> nodes,\n+        QueryParameterMetadata parameterMetadata,\n+        Set<Integer> allIndexedFieldOrdinals\n+    ) {\n+        Map<Integer, List<IndexComponentCandidate>> res = new HashMap<>();\n+\n+        for (RexNode node : nodes) {\n+            IndexComponentCandidate candidate = prepareSingleColumnCandidate(node, parameterMetadata);\n+\n+            if (candidate == null) {\n+                // Expression cannot be used for indexes\n+                continue;\n+            }\n+\n+            if (!allIndexedFieldOrdinals.contains(candidate.getColumnIndex())) {\n+                // Expression could be used for indexes, but there are no matching indexes\n+                continue;\n+            }\n+\n+            res.computeIfAbsent(candidate.getColumnIndex(), (k) -> new ArrayList<>()).add(candidate);\n+        }\n+\n+        return res;\n+    }\n+\n+    /**\n+     * Prepares an expression candidate for the given RexNode.\n+     * <p>\n+     * We consider two types of expressions: comparison predicates and OR condition. We try to interpret OR as IN, otherwise\n+     * it is ignored.\n+     *\n+     * @param exp calcite expression\n+     * @return candidate or {@code null} if the expression cannot be used with indexes\n+     */\n+    @SuppressWarnings(\"checkstyle:CyclomaticComplexity\")\n+    private static IndexComponentCandidate prepareSingleColumnCandidate(\n+        RexNode exp,\n+        QueryParameterMetadata parameterMetadata\n+    ) {\n+        SqlKind kind = exp.getKind();\n+\n+        switch (kind) {\n+            case INPUT_REF:\n+                // Special case for boolean columns: SELECT * FROM t WHERE f_boolean\n+                return prepareSingleColumnCandidateBooleanIsTrueFalse(exp, exp, SqlKind.IS_TRUE);\n+\n+            case IS_TRUE:\n+            case IS_FALSE:\n+            case IS_NOT_TRUE:\n+            case IS_NOT_FALSE:\n+                return prepareSingleColumnCandidateBooleanIsTrueFalse(\n+                    exp,\n+                    removeCastIfPossible(((RexCall) exp).getOperands().get(0), false),\n+                    kind\n+                );\n+\n+            case NOT:\n+                return prepareSingleColumnCandidateBooleanIsTrueFalse(\n+                    exp,\n+                    removeCastIfPossible(((RexCall) exp).getOperands().get(0), false),\n+                    SqlKind.IS_FALSE\n+                );\n+\n+            case IS_NULL:\n+                return prepareSingleColumnCandidateIsNull(\n+                    exp,\n+                    removeCastIfPossible(((RexCall) exp).getOperands().get(0), true)\n+                );\n+\n+            case GREATER_THAN:\n+            case GREATER_THAN_OR_EQUAL:\n+            case LESS_THAN:\n+            case LESS_THAN_OR_EQUAL:\n+            case EQUALS:\n+                BiTuple<RexNode, RexNode> operands = extractComparisonOperands(exp);\n+\n+                return prepareSingleColumnCandidateComparison(\n+                    exp,\n+                    kind,\n+                    operands.element1(),\n+                    operands.element2(),\n+                    parameterMetadata\n+                );\n+\n+            case OR:\n+                return prepareSingleColumnCandidateOr(\n+                    exp,\n+                    ((RexCall) exp).getOperands(),\n+                    parameterMetadata\n+                );\n+\n+            default:\n+                return null;\n+        }\n+    }\n+\n+    /**\n+     * Prepare a candidate for {@code IS (NOT) TRUE/FALSE} expression.\n+     * <p>\n+     * The fundamental observation is that boolean column may have only three values - TRUE/FALSE/NULL. Therefore, every\n+     * such expression could be converted to equivalent equals or IN predicate.\n+     *\n+     * @param exp expression\n+     * @param operand operand with CAST unwrapped\n+     * @param kind expression type\n+     * @return candidate or {@code null}\n+     */\n+    private static IndexComponentCandidate prepareSingleColumnCandidateBooleanIsTrueFalse(\n+        RexNode exp,\n+        RexNode operand,\n+        SqlKind kind\n+    ) {\n+        if (operand.getKind() != SqlKind.INPUT_REF) {\n+            return null;\n+        }\n+\n+        if (operand.getType().getSqlTypeName() != SqlTypeName.BOOLEAN) {\n+            // Only boolean columns could be used with this optimization\n+            return null;\n+        }\n+\n+        int columnIndex = ((RexInputRef) operand).getIndex();\n+\n+        IndexFilter filter;\n+\n+        switch (kind) {\n+            case IS_TRUE:\n+                filter = new IndexEqualsFilter(new IndexFilterValue(\n+                    singletonList(ConstantExpression.create(true, QueryDataType.BOOLEAN)), singletonList(false)\n+                ));\n+\n+                break;\n+\n+            case IS_FALSE:\n+                filter = new IndexEqualsFilter(new IndexFilterValue(\n+                    singletonList(ConstantExpression.create(false, QueryDataType.BOOLEAN)), singletonList(false)\n+                ));\n+\n+                break;\n+\n+            case IS_NOT_TRUE:\n+                filter = new IndexInFilter(\n+                    new IndexEqualsFilter(new IndexFilterValue(\n+                        singletonList(ConstantExpression.create(false, QueryDataType.BOOLEAN)), singletonList(false)\n+                    )),\n+                    new IndexEqualsFilter(new IndexFilterValue(\n+                        singletonList(ConstantExpression.create(null, QueryDataType.BOOLEAN)), singletonList(true)\n+                    ))\n+                );\n+\n+                break;\n+\n+            default:\n+                assert kind == SqlKind.IS_NOT_FALSE;\n+\n+                filter = new IndexInFilter(\n+                    new IndexEqualsFilter(new IndexFilterValue(\n+                        singletonList(ConstantExpression.create(true, QueryDataType.BOOLEAN)), singletonList(false)\n+                    )),\n+                    new IndexEqualsFilter(new IndexFilterValue(\n+                        singletonList(ConstantExpression.create(null, QueryDataType.BOOLEAN)), singletonList(true)\n+                    ))\n+                );\n+        }\n+\n+        return new IndexComponentCandidate(exp, columnIndex, filter);\n+    }\n+\n+    private static IndexComponentCandidate prepareSingleColumnCandidateIsNull(RexNode exp, RexNode operand) {\n+        if (operand.getKind() != SqlKind.INPUT_REF) {\n+            return null;\n+        }\n+\n+        int columnIndex = ((RexInputRef) operand).getIndex();\n+\n+        QueryDataType type = SqlToQueryType.map(operand.getType().getSqlTypeName());\n+\n+        IndexFilterValue filterValue = new IndexFilterValue(\n+            singletonList(ConstantExpression.create(null, type)),\n+            singletonList(true)\n+        );\n+\n+        IndexFilter filter = new IndexEqualsFilter(filterValue);\n+\n+        return new IndexComponentCandidate(\n+            exp,\n+            columnIndex,\n+            filter\n+        );\n+    }\n+\n+    private static IndexComponentCandidate prepareSingleColumnCandidateComparison(\n+        RexNode exp,\n+        SqlKind kind,\n+        RexNode operand1,\n+        RexNode operand2,\n+        QueryParameterMetadata parameterMetadata\n+    ) {\n+        // Normalize operand positions, so that the column is always goes first\n+        if (operand1.getKind() != SqlKind.INPUT_REF && operand2.getKind() == SqlKind.INPUT_REF) {\n+            kind = inverseIndexConditionKind(kind);\n+\n+            RexNode tmp = operand1;\n+            operand1 = operand2;\n+            operand2 = tmp;\n+        }\n+\n+        // Exit if the first operand is not a column\n+        if (operand1.getKind() != SqlKind.INPUT_REF) {\n+            return null;\n+        }\n+\n+        int columnIndex = ((RexInputRef) operand1).getIndex();\n+\n+        if (!IndexRexVisitor.isValid(operand2)) {\n+            // The second operand cannot be used for index filter\n+            return null;\n+        }\n+\n+        Expression<?> filterValue = convertToExpression(operand2, parameterMetadata);\n+\n+        if (filterValue == null) {\n+            // Operand cannot be converted to expression. Do not throw an exception here, just do not use the faulty condition\n+            // for index. The proper exception will be thrown on later stages when attempting to convert Calcite rel tree to\n+            // Hazelcast plan.\n+            return null;\n+        }\n+\n+        IndexFilterValue filterValue0 = new IndexFilterValue(\n+            singletonList(filterValue),\n+            singletonList(false)\n+        );\n+\n+        IndexFilter filter;\n+\n+        switch (kind) {\n+            case EQUALS:\n+                filter = new IndexEqualsFilter(filterValue0);\n+\n+                break;\n+\n+            case GREATER_THAN:\n+                filter = new IndexRangeFilter(filterValue0, false, null, false);\n+\n+                break;\n+\n+            case GREATER_THAN_OR_EQUAL:\n+                filter = new IndexRangeFilter(filterValue0, true, null, false);\n+\n+                break;\n+\n+            case LESS_THAN:\n+                filter = new IndexRangeFilter(null, false, filterValue0, false);\n+\n+                break;\n+\n+            default:\n+                assert kind == SqlKind.LESS_THAN_OR_EQUAL;\n+\n+                filter = new IndexRangeFilter(null, false, filterValue0, true);\n+        }\n+\n+        return new IndexComponentCandidate(\n+            exp,\n+            columnIndex,\n+            filter\n+        );\n+    }\n+\n+    private static Expression<?> convertToExpression(RexNode operand, QueryParameterMetadata parameterMetadata) {\n+        try {\n+            RexToExpressionVisitor visitor = new RexToExpressionVisitor(FieldTypeProvider.INSTANCE, parameterMetadata);\n+\n+            return operand.accept(visitor);\n+        } catch (Exception e) {\n+            return null;", "originalCommit": "73b642509f5df21624bdeaae4e3641cfea9a9412", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzkxNjUzMQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r473916531", "bodyText": "Here we try to convert Calcite expression to HZ expression. Normally it should never fail. But given that the Calcite is a kind of black box for us, we may get some unexpected behavior here.\nIt is ok to ignore the exception at this stage because the same visitor will be invoked later after planning, and the exception will be re-thrown to the user with proper wrapping. If we throw it from here, the user will get a very creepy stack trace, possibly with additional wrapping into Calcite-related exception classes.", "author": "devozerov", "createdAt": "2020-08-20T12:00:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzg0MTcyOQ=="}], "type": "inlineReview"}, {"oid": "c47b1e179b47dfce6ed488350060b7347a1c9052", "url": "https://github.com/hazelcast/hazelcast/commit/c47b1e179b47dfce6ed488350060b7347a1c9052", "message": "Fixed typo", "committedDate": "2020-08-20T11:58:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQ3ODIwMw==", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r474478203", "bodyText": "Do we need initialized flag? Can we check the currentIterator != null instead?", "author": "petrpleshachkov", "createdAt": "2020-08-21T07:39:57Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/util/AbstractCompositeIterator.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.internal.util;\n+\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+\n+public abstract class AbstractCompositeIterator<E> implements Iterator<E> {\n+\n+    private Iterator<E> currentIterator;\n+    private boolean initialized;\n+\n+    @Override\n+    public boolean hasNext() {\n+        if (!initialized) {", "originalCommit": "c47b1e179b47dfce6ed488350060b7347a1c9052", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDYyNzUwNA==", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r474627504", "bodyText": "nextIterator may return null if there are no more entries. The flag is needed to avoid unnecessary invocation of the nextIterator method.", "author": "devozerov", "createdAt": "2020-08-21T11:00:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQ3ODIwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQ4MTMyMw==", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r474481323", "bodyText": "Why for not set converter we always return empty result? Is it a valid use case to have an empty converter?", "author": "petrpleshachkov", "createdAt": "2020-08-21T07:43:41Z", "path": "hazelcast/src/main/java/com/hazelcast/query/impl/AbstractIndex.java", "diffHunk": "@@ -173,6 +176,47 @@ public boolean canEvaluate(Class<? extends Predicate> predicateClass) {\n         return indexStore.evaluate(predicate, converter);\n     }\n \n+    @Override\n+    public Iterator<QueryableEntry> getSqlRecordIterator() {\n+        if (converter == null) {", "originalCommit": "c47b1e179b47dfce6ed488350060b7347a1c9052", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDUxNjY2Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r474516662", "bodyText": "An empty converter means that there were no insertions into this index, so it is definitely empty.", "author": "devozerov", "createdAt": "2020-08-21T08:24:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQ4MTMyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQ4MzQ2NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r474483465", "bodyText": "I'd also specify that NULL values are also returned.", "author": "petrpleshachkov", "createdAt": "2020-08-21T07:46:10Z", "path": "hazelcast/src/main/java/com/hazelcast/query/impl/Index.java", "diffHunk": "@@ -109,6 +111,33 @@\n      */\n     Set<QueryableEntry> evaluate(Predicate predicate);\n \n+    /**\n+     * @return iterator over all index entries\n+     */\n+    Iterator<QueryableEntry> getSqlRecordIterator();", "originalCommit": "c47b1e179b47dfce6ed488350060b7347a1c9052", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDYyODAzNw==", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r474628037", "bodyText": "I am not sure I get the idea of the comment. NULL values are part of the index, so they qualify to \"all index entries\" already", "author": "devozerov", "createdAt": "2020-08-21T11:01:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQ4MzQ2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQ5NTI1Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r474495257", "bodyText": "It seems IndexEntryFlatteningIterator name would fit better.", "author": "petrpleshachkov", "createdAt": "2020-08-21T07:59:58Z", "path": "hazelcast/src/main/java/com/hazelcast/query/impl/OrderedIndexStore.java", "diffHunk": "@@ -110,6 +115,81 @@ public boolean canEvaluate(Class<? extends Predicate> predicateClass) {\n         throw new UnsupportedOperationException();\n     }\n \n+    @Override\n+    public Iterator<QueryableEntry> getSqlRecordIterator() {\n+        Iterator<QueryableEntry> iterator = new IndexEntryCompositeIterator(recordMap.values().iterator());\n+        Iterator<QueryableEntry> nullIterator = recordsWithNullValue.values().iterator();\n+\n+        return new FlatCompositeIterator<>(Arrays.asList(nullIterator, iterator).iterator());\n+    }\n+\n+    @Override\n+    public Iterator<QueryableEntry> getSqlRecordIterator(Comparable value) {\n+        if (value == NULL) {\n+            return recordsWithNullValue.values().iterator();\n+        } else {\n+            Map<Data, QueryableEntry> entries = recordMap.get(value);\n+\n+            if (entries == null) {\n+                return Collections.emptyIterator();\n+            } else {\n+                return entries.values().iterator();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public Iterator<QueryableEntry> getSqlRecordIterator(Comparison comparison, Comparable searchedValue) {\n+        Iterator<Map<Data, QueryableEntry>> iterator;\n+\n+        switch (comparison) {\n+            case LESS:\n+                iterator = recordMap.headMap(searchedValue, false).values().iterator();\n+                break;\n+            case LESS_OR_EQUAL:\n+                iterator = recordMap.headMap(searchedValue, true).values().iterator();\n+                break;\n+            case GREATER:\n+                iterator = recordMap.tailMap(searchedValue, false).values().iterator();\n+                break;\n+            case GREATER_OR_EQUAL:\n+                iterator = recordMap.tailMap(searchedValue, true).values().iterator();\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Unrecognized comparison: \" + comparison);\n+        }\n+\n+        return new IndexEntryCompositeIterator(iterator);\n+    }\n+\n+    @Override\n+    public Iterator<QueryableEntry> getSqlRecordIterator(\n+        Comparable from,\n+        boolean fromInclusive,\n+        Comparable to,\n+        boolean toInclusive\n+    ) {\n+        int order = Comparables.compare(from, to);\n+\n+        if (order == 0) {\n+            if (!fromInclusive || !toInclusive) {\n+                return emptyIterator();\n+            }\n+\n+            Map<Data, QueryableEntry> res = recordMap.get(from);\n+\n+            if (res == null) {\n+                return emptyIterator();\n+            }\n+\n+            return res.values().iterator();\n+        } else if (order > 0) {\n+            return emptyIterator();\n+        }\n+\n+        return new IndexEntryCompositeIterator(recordMap.subMap(from, fromInclusive, to, toInclusive).values().iterator());", "originalCommit": "c47b1e179b47dfce6ed488350060b7347a1c9052", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDYyODUxNg==", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r474628516", "bodyText": "Renamed", "author": "devozerov", "createdAt": "2020-08-21T11:03:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQ5NTI1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQ5NTc4Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r474495786", "bodyText": "nullIterator first?", "author": "petrpleshachkov", "createdAt": "2020-08-21T08:00:37Z", "path": "hazelcast/src/main/java/com/hazelcast/query/impl/UnorderedIndexStore.java", "diffHunk": "@@ -136,6 +140,44 @@ public boolean canEvaluate(Class<? extends Predicate> predicateClass) {\n         throw new UnsupportedOperationException();\n     }\n \n+    @Override\n+    public Iterator<QueryableEntry> getSqlRecordIterator() {\n+        Iterator<QueryableEntry> iterator = new IndexEntryCompositeIterator(recordMap.values().iterator());\n+        Iterator<QueryableEntry> nullIterator = recordsWithNullValue.values().iterator();\n+\n+        return new FlatCompositeIterator<>(Arrays.asList(iterator, nullIterator).iterator());", "originalCommit": "c47b1e179b47dfce6ed488350060b7347a1c9052", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDYyODk4Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r474628987", "bodyText": "Changed to return nulls first. Although, this change doesn't make any difference - HASH index is not ordered anyway.", "author": "devozerov", "createdAt": "2020-08-21T11:04:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQ5NTc4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQ5ODU2Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r474498567", "bodyText": "What if value == null. In the getEntries() method we do this check.", "author": "petrpleshachkov", "createdAt": "2020-08-21T08:03:59Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/scan/index/IndexEqualsFilter.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.exec.scan.index;\n+\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.query.impl.InternalIndex;\n+import com.hazelcast.query.impl.QueryableEntry;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.Iterator;\n+\n+@SuppressWarnings(\"rawtypes\")\n+public class IndexEqualsFilter implements IndexFilter, IdentifiedDataSerializable {\n+\n+    private IndexFilterValue value;\n+\n+    public IndexEqualsFilter() {\n+        // No-op.\n+    }\n+\n+    public IndexEqualsFilter(IndexFilterValue value) {\n+        this.value = value;\n+    }\n+\n+    public IndexFilterValue getValue() {\n+        return value;\n+    }\n+\n+    @Override\n+    public Iterator<QueryableEntry> getEntries(InternalIndex index, ExpressionEvalContext evalContext) {\n+        Comparable value = getComparable(evalContext);\n+\n+        if (value == null) {\n+            return Collections.emptyIterator();\n+        }\n+\n+        return index.getSqlRecordIterator(value);\n+    }\n+\n+    @Override\n+    public Comparable getComparable(ExpressionEvalContext evalContext) {\n+        return value.getValue(evalContext);\n+    }\n+\n+    @Override\n+    public int getFactoryId() {\n+        return SqlDataSerializerHook.F_ID;\n+    }\n+\n+    @Override\n+    public int getClassId() {\n+        return SqlDataSerializerHook.INDEX_FILTER_EQUALS;\n+    }\n+\n+    @Override\n+    public void writeData(ObjectDataOutput out) throws IOException {\n+        out.writeObject(value);\n+    }\n+\n+    @Override\n+    public void readData(ObjectDataInput in) throws IOException {\n+        value = in.readObject();\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+\n+        IndexEqualsFilter that = (IndexEqualsFilter) o;\n+\n+        return value.equals(that.value);", "originalCommit": "c47b1e179b47dfce6ed488350060b7347a1c9052", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDYyOTQ4Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r474629486", "bodyText": "IndexEqualsFilter.value is never null. In getEntries() we check nullability of local variable.", "author": "devozerov", "createdAt": "2020-08-21T11:05:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQ5ODU2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDUwMTg5MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r474501891", "bodyText": "What if allowNulls.get returns false? Do we handle this case?", "author": "petrpleshachkov", "createdAt": "2020-08-21T08:08:05Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/scan/index/IndexFilterValue.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.exec.scan.index;\n+\n+import com.hazelcast.internal.serialization.impl.SerializationUtil;\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.query.impl.AbstractIndex;\n+import com.hazelcast.query.impl.CompositeValue;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.row.Row;\n+\n+import java.io.IOException;\n+import java.util.List;\n+\n+/**\n+ * Value that is used for filter lookup operations.\n+ */\n+@SuppressWarnings(\"rawtypes\")\n+public class IndexFilterValue implements IdentifiedDataSerializable {\n+\n+    private List<Expression> components;\n+    private List<Boolean> allowNulls;\n+\n+    public IndexFilterValue() {\n+        // No-op.\n+    }\n+\n+    public IndexFilterValue(List<Expression> components, List<Boolean> allowNulls) {\n+        this.components = components;\n+        this.allowNulls = allowNulls;\n+    }\n+\n+    public Comparable getValue(ExpressionEvalContext evalContext) {\n+        if (components.size() == 1) {\n+            return getComponentValue(0, evalContext);\n+        } else {\n+            Comparable[] componentValues = new Comparable[components.size()];\n+\n+            for (int i = 0; i < components.size(); i++) {\n+                Comparable componentValue = getComponentValue(i, evalContext);\n+\n+                if (componentValue == null) {\n+                    return null;\n+                }\n+\n+                componentValues[i] = componentValue;\n+            }\n+\n+            return new CompositeValue(componentValues);\n+        }\n+    }\n+\n+    private Comparable getComponentValue(int index, ExpressionEvalContext evalContext) {\n+        Object value = components.get(index).eval(NoColumnAccessRow.INSTANCE, evalContext);\n+\n+        if (value == null && allowNulls.get(index)) {\n+            value = AbstractIndex.NULL;", "originalCommit": "c47b1e179b47dfce6ed488350060b7347a1c9052", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDYzMDE0Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r474630146", "bodyText": "Yes, consumers of IndexFilterValue handles this properly.", "author": "devozerov", "createdAt": "2020-08-21T11:07:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDUwMTg5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDUxMjI5NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r474512295", "bodyText": "I'd make all these fields final", "author": "petrpleshachkov", "createdAt": "2020-08-21T08:19:58Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/scan/index/IndexRangeFilter.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.exec.scan.index;\n+\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.query.impl.AbstractIndex;\n+import com.hazelcast.query.impl.Comparison;\n+import com.hazelcast.query.impl.InternalIndex;\n+import com.hazelcast.query.impl.QueryableEntry;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.Objects;\n+\n+@SuppressWarnings(\"rawtypes\")\n+public class IndexRangeFilter implements IndexFilter, IdentifiedDataSerializable {\n+\n+    private IndexFilterValue from;", "originalCommit": "c47b1e179b47dfce6ed488350060b7347a1c9052", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDYzMDU5Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r474630592", "bodyText": "We cannot have final fields in classes extending IdentifiedDataSerializable, because it requires no-arg constructor.", "author": "devozerov", "createdAt": "2020-08-21T11:08:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDUxMjI5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDUxNzQ5MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r474517491", "bodyText": "If toValue is not null we still have to return empty result?", "author": "petrpleshachkov", "createdAt": "2020-08-21T08:25:48Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/scan/index/IndexRangeFilter.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.exec.scan.index;\n+\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.query.impl.AbstractIndex;\n+import com.hazelcast.query.impl.Comparison;\n+import com.hazelcast.query.impl.InternalIndex;\n+import com.hazelcast.query.impl.QueryableEntry;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.Objects;\n+\n+@SuppressWarnings(\"rawtypes\")\n+public class IndexRangeFilter implements IndexFilter, IdentifiedDataSerializable {\n+\n+    private IndexFilterValue from;\n+    private boolean fromInclusive;\n+    private IndexFilterValue to;\n+    private boolean toInclusive;\n+\n+    public IndexRangeFilter() {\n+        // No-op.\n+    }\n+\n+    public IndexRangeFilter(IndexFilterValue from, boolean fromInclusive, IndexFilterValue to, boolean toInclusive) {\n+        assert from != null || to != null;\n+\n+        this.from = from;\n+        this.fromInclusive = fromInclusive;\n+        this.to = to;\n+        this.toInclusive = toInclusive;\n+    }\n+\n+    @SuppressWarnings(\"checkstyle:CyclomaticComplexity\")\n+    @Override\n+    public Iterator<QueryableEntry> getEntries(InternalIndex index, ExpressionEvalContext evalContext) {\n+        if (from != null) {\n+            if (to != null) {\n+                // Lower and upper bounds\n+                Comparable fromValue = from.getValue(evalContext);\n+\n+                if (fromValue == null || fromValue == AbstractIndex.NULL) {", "originalCommit": "c47b1e179b47dfce6ed488350060b7347a1c9052", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDYzMTE1Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r474631156", "bodyText": "Yes, any comparison with NULL always yields NULL for all rows, therefore we are free to return NULL here.", "author": "devozerov", "createdAt": "2020-08-21T11:10:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDUxNzQ5MQ=="}], "type": "inlineReview"}, {"oid": "d50082e6a80a49e79e3ba3c9d1fb829395b6f6fb", "url": "https://github.com/hazelcast/hazelcast/commit/d50082e6a80a49e79e3ba3c9d1fb829395b6f6fb", "message": "Merge branch 'master' into issues/17381\n\n# Conflicts:\n#\thazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/ExpressionTestBase.java\n#\thazelcast/src/main/java/com/hazelcast/sql/impl/SqlDataSerializerHook.java\n#\thazelcast/src/main/java/com/hazelcast/sql/impl/schema/map/PartitionedMapTable.java", "committedDate": "2020-08-21T08:27:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDUyMDk0Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r474520943", "bodyText": "If the index has been removed concurrently, shall we throw this exception to the user instead of falling back to the map scan?", "author": "petrpleshachkov", "createdAt": "2020-08-21T08:29:43Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/scan/index/MapIndexScanExecIterator.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.exec.scan.index;\n+\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.internal.util.collection.PartitionIdSet;\n+import com.hazelcast.map.impl.MapContainer;\n+import com.hazelcast.query.impl.InternalIndex;\n+import com.hazelcast.query.impl.QueryableEntry;\n+import com.hazelcast.sql.SqlErrorCode;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.exec.scan.KeyValueIterator;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.schema.map.MapTableUtils;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+/**\n+ * Iterator for index-based partitioned map access.\n+ */\n+@SuppressWarnings(\"rawtypes\")\n+public class MapIndexScanExecIterator implements KeyValueIterator {\n+\n+    private final Iterator<QueryableEntry> iterator;\n+\n+    private Data currentKey;\n+    private Object currentValue;\n+    private Data nextKey;\n+    private Object nextValue;\n+\n+    public MapIndexScanExecIterator(\n+        MapContainer map,\n+        String indexName,\n+        int expectedComponentCount,\n+        IndexFilter indexFilter,\n+        List<QueryDataType> expectedConverterTypes,\n+        PartitionIdSet expectedPartitions,\n+        ExpressionEvalContext evalContext\n+    ) {\n+        iterator = getIndexEntries(\n+            map,\n+            indexName,\n+            indexFilter,\n+            evalContext,\n+            expectedComponentCount,\n+            expectedConverterTypes,\n+            expectedPartitions\n+        );\n+\n+        advance0();\n+    }\n+\n+    @Override\n+    public boolean tryAdvance() {\n+        if (!done()) {\n+            currentKey = nextKey;\n+            currentValue = nextValue;\n+\n+            advance0();\n+\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    @Override\n+    public boolean done() {\n+        return nextKey == null;\n+    }\n+\n+    @Override\n+    public Object getKey() {\n+        return currentKey;\n+    }\n+\n+    @Override\n+    public Object getValue() {\n+        return currentValue;\n+    }\n+\n+    private void advance0() {\n+        if (iterator.hasNext()) {\n+            QueryableEntry<?, ?> entry = iterator.next();\n+\n+            nextKey = entry.getKeyData();\n+            nextValue = entry.getValue();\n+        } else {\n+            nextKey = null;\n+            nextValue = null;\n+        }\n+    }\n+\n+    private Iterator<QueryableEntry> getIndexEntries(\n+        MapContainer map,\n+        String indexName,\n+        IndexFilter indexFilter,\n+        ExpressionEvalContext evalContext,\n+        int expectedComponentCount,\n+        List<QueryDataType> expectedConverterTypes,\n+        PartitionIdSet expectedPartitions\n+    ) {\n+        // Find the index\n+        InternalIndex index = map.getIndexes().getIndex(indexName);\n+\n+        if (index == null) {\n+            throw QueryException.error(", "originalCommit": "c47b1e179b47dfce6ed488350060b7347a1c9052", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDYzMjMwMw==", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r474632303", "bodyText": "Yes, we have to throw here. If the plan has been built for index A, and it is no longer available, we cannot simply fall back to map scan for several reasons:\n\nThere could be other indexes that would otherwise produce better plans\nParent operators may rely on index scan collation. So in addition to using a map scan, we would have to sort the result set", "author": "devozerov", "createdAt": "2020-08-21T11:13:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDUyMDk0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDYwMzQyOQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r474603429", "bodyText": "It might make sense to document what this visitor considers valid (literals, parameters and calls on them?), otherwise it requires inspecting every method of the base class to understand what is valid and what is not.", "author": "taburet", "createdAt": "2020-08-21T10:06:33Z", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/opt/physical/index/IndexRexVisitor.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.opt.physical.index;\n+\n+import org.apache.calcite.rex.RexCorrelVariable;\n+import org.apache.calcite.rex.RexFieldAccess;\n+import org.apache.calcite.rex.RexInputRef;\n+import org.apache.calcite.rex.RexLocalRef;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.rex.RexOver;\n+import org.apache.calcite.rex.RexPatternFieldRef;\n+import org.apache.calcite.rex.RexRangeRef;\n+import org.apache.calcite.rex.RexSubQuery;\n+import org.apache.calcite.rex.RexTableInputRef;\n+import org.apache.calcite.rex.RexVisitorImpl;\n+\n+public final class IndexRexVisitor extends RexVisitorImpl<Void> {", "originalCommit": "d50082e6a80a49e79e3ba3c9d1fb829395b6f6fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDYzNDk3Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r474634972", "bodyText": "Added JavaDoc", "author": "devozerov", "createdAt": "2020-08-21T11:19:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDYwMzQyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDYwNTc4OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r474605789", "bodyText": "Is this change intentional?", "author": "taburet", "createdAt": "2020-08-21T10:11:37Z", "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/SqlErrorTest.java", "diffHunk": "@@ -96,7 +96,6 @@ public void testMemberLeave() {\n \n         // Start query\n         SqlException error = assertSqlException(instance1, query());\n-        assertEquals(SqlErrorCode.CONNECTION_PROBLEM, error.getCode());", "originalCommit": "d50082e6a80a49e79e3ba3c9d1fb829395b6f6fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDYzNjcxNw==", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r474636717", "bodyText": "A leftover. This test failed from time to time because depending on random timings, either connection-related error or partition migration error happens. It is not easy to write the test with a precise error code.\nI relaxed the test to check for one of these two error codes instead of only CONNECTION_PROBLEM\nSee 3408445", "author": "devozerov", "createdAt": "2020-08-21T11:23:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDYwNTc4OQ=="}], "type": "inlineReview"}, {"oid": "9fe83bcaf95fb6d4f41744e17cfb63f9a75d0711", "url": "https://github.com/hazelcast/hazelcast/commit/9fe83bcaf95fb6d4f41744e17cfb63f9a75d0711", "message": "Fix checkstyle", "committedDate": "2020-08-21T10:57:20Z", "type": "commit"}, {"oid": "75bbc626ff4a720a28747fcc6e44319ff0d49e24", "url": "https://github.com/hazelcast/hazelcast/commit/75bbc626ff4a720a28747fcc6e44319ff0d49e24", "message": "IndexEntryCompositeIterator -> IndexEntryFlatteningIterator", "committedDate": "2020-08-21T11:02:56Z", "type": "commit"}, {"oid": "99641cbb68434a0786bc3a1c6101c44c2091c793", "url": "https://github.com/hazelcast/hazelcast/commit/99641cbb68434a0786bc3a1c6101c44c2091c793", "message": "NULLs first for UnorderedIndexStore.", "committedDate": "2020-08-21T11:03:37Z", "type": "commit"}, {"oid": "4785941346d0f81e314abb834b57b08b717514ad", "url": "https://github.com/hazelcast/hazelcast/commit/4785941346d0f81e314abb834b57b08b717514ad", "message": "JavaDoc for IndexRexVisitor.", "committedDate": "2020-08-21T11:19:19Z", "type": "commit"}, {"oid": "3408445e08a927818f51db7b5754ab3fbae8e169", "url": "https://github.com/hazelcast/hazelcast/commit/3408445e08a927818f51db7b5754ab3fbae8e169", "message": "Fix to SqlErrorTest", "committedDate": "2020-08-21T11:21:56Z", "type": "commit"}, {"oid": "42786117b894e378590fa5cbae4eaf82f992a266", "url": "https://github.com/hazelcast/hazelcast/commit/42786117b894e378590fa5cbae4eaf82f992a266", "message": "Typo", "committedDate": "2020-08-21T18:25:41Z", "type": "commit"}, {"oid": "05dbe61c23f0cff45417a815e083d5967e347502", "url": "https://github.com/hazelcast/hazelcast/commit/05dbe61c23f0cff45417a815e083d5967e347502", "message": "Merge branch 'master' into issues/17381\n\n# Conflicts:\n#\thazelcast-sql/src/test/java/com/hazelcast/sql/SqlErrorTest.java\n#\thazelcast/src/main/java/com/hazelcast/sql/SqlColumnType.java", "committedDate": "2020-08-22T06:38:37Z", "type": "commit"}, {"oid": "5a181eda26e47a2ad0462ab359d63f33d577d0a7", "url": "https://github.com/hazelcast/hazelcast/commit/5a181eda26e47a2ad0462ab359d63f33d577d0a7", "message": "Merge with master", "committedDate": "2020-08-22T06:44:42Z", "type": "commit"}, {"oid": "02543afd7f25a9983c3b03ede8faed477e1212f4", "url": "https://github.com/hazelcast/hazelcast/commit/02543afd7f25a9983c3b03ede8faed477e1212f4", "message": "Minors", "committedDate": "2020-08-22T07:01:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTM3MDA0Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r475370046", "bodyText": "Range filters are never created for hash indexes and that's how preference of hash indexes (1.1 < 1.2) over sorted ones is avoided for range filters, right?", "author": "taburet", "createdAt": "2020-08-24T06:32:38Z", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/opt/cost/CostUtils.java", "diffHunk": "@@ -30,6 +31,12 @@\n     /** CPU multiplier applied to normal scan. */\n     public static final double TABLE_SCAN_CPU_MULTIPLIER = 1.0d;\n \n+    /** CPU multiplier applied to index scan (sorted). */\n+    public static final double INDEX_SCAN_CPU_MULTIPLIER_SORTED = 1.2d;\n+\n+    /** CPU multiplier applied to index scan (hash). */\n+    public static final double INDEX_SCAN_CPU_MULTIPLIER_HASH = 1.1d;", "originalCommit": "02543afd7f25a9983c3b03ede8faed477e1212f4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTM3NDM1OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r475374359", "bodyText": "Range filters for HASH indexes are ruled out in IndexResolver, see if (type == IndexType.SORTED) condition.\nThese costs in CostUtils are required to prefer HASH index over SORTED index if there is a condition that matches both indexes. E.g. we have a table t(a INT), and two indexes SORTED(a) and HASH(a). For the condition WHERE a=? both indexes match, but HASH takes precedence.\nNote that this precedence doesn't mean that HASH index will always be preferred over SORTED index for equality conditions. In the future, we will add collations, and they will influence planning as well. For instance, in the example above the SORTED index could be better still, if the whole query looks like:\nSELECT * FROM t WHERE a=? ORDER BY a", "author": "devozerov", "createdAt": "2020-08-24T06:44:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTM3MDA0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTM4MTgxOA==", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r475381818", "bodyText": "Doesn't look safe to remove it for any numeric-to-numeric conversion: cast(bigintColumn as tinyint) < 1 should produce an error for values outside of tinyint range.", "author": "taburet", "createdAt": "2020-08-24T07:02:53Z", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/opt/physical/index/IndexResolver.java", "diffHunk": "@@ -0,0 +1,1117 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.opt.physical.index;\n+\n+import com.hazelcast.config.IndexType;\n+import com.hazelcast.internal.util.BiTuple;\n+import com.hazelcast.query.impl.ComparableIdentifiedDataSerializable;\n+import com.hazelcast.query.impl.TypeConverters;\n+import com.hazelcast.sql.impl.QueryParameterMetadata;\n+import com.hazelcast.sql.impl.calcite.SqlToQueryType;\n+import com.hazelcast.sql.impl.calcite.opt.OptUtils;\n+import com.hazelcast.sql.impl.calcite.opt.distribution.DistributionTrait;\n+import com.hazelcast.sql.impl.calcite.opt.logical.MapScanLogicalRel;\n+import com.hazelcast.sql.impl.calcite.opt.physical.MapIndexScanPhysicalRel;\n+import com.hazelcast.sql.impl.calcite.opt.physical.visitor.RexToExpressionVisitor;\n+import com.hazelcast.sql.impl.calcite.schema.HazelcastRelOptTable;\n+import com.hazelcast.sql.impl.calcite.schema.HazelcastTable;\n+import com.hazelcast.sql.impl.exec.scan.index.IndexEqualsFilter;\n+import com.hazelcast.sql.impl.exec.scan.index.IndexFilter;\n+import com.hazelcast.sql.impl.exec.scan.index.IndexFilterValue;\n+import com.hazelcast.sql.impl.exec.scan.index.IndexInFilter;\n+import com.hazelcast.sql.impl.exec.scan.index.IndexRangeFilter;\n+import com.hazelcast.sql.impl.expression.ConstantExpression;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.plan.node.PlanNodeFieldTypeProvider;\n+import com.hazelcast.sql.impl.schema.map.MapTableIndex;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import org.apache.calcite.plan.RelOptTable;\n+import org.apache.calcite.plan.RelOptUtil;\n+import org.apache.calcite.plan.RelTraitSet;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexBuilder;\n+import org.apache.calcite.rex.RexCall;\n+import org.apache.calcite.rex.RexInputRef;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.rex.RexUtil;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.hazelcast.query.impl.CompositeValue.NEGATIVE_INFINITY;\n+import static com.hazelcast.query.impl.CompositeValue.POSITIVE_INFINITY;\n+import static java.util.Collections.singletonList;\n+import static org.apache.calcite.sql.type.SqlTypeFamily.NUMERIC;\n+\n+/**\n+ * Helper class to resolve indexes.\n+ */\n+@SuppressWarnings(\"rawtypes\")\n+public final class IndexResolver {\n+    private IndexResolver() {\n+        // No-op.\n+    }\n+\n+    public static List<RelNode> createIndexScans(\n+        MapScanLogicalRel scan,\n+        DistributionTrait distribution,\n+        List<MapTableIndex> indexes\n+    ) {\n+        // Early return if there is no filter.\n+        RexNode filter = scan.getTableUnwrapped().getFilter();\n+\n+        if (filter == null) {\n+            return Collections.emptyList();\n+        }\n+\n+        // Filter out unsupported indexes.\n+        List<MapTableIndex> supportedIndexes = new ArrayList<>(indexes.size());\n+        Set<Integer> allIndexedFieldOrdinals = new HashSet<>();\n+\n+        for (MapTableIndex index : indexes) {\n+            if (isIndexSupported(index)) {\n+                supportedIndexes.add(index);\n+\n+                allIndexedFieldOrdinals.addAll(index.getFieldOrdinals());\n+            }\n+        }\n+\n+        // Early return if there are no indexes to consider.\n+        if (supportedIndexes.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        // Convert expression into CNF\n+        List<RexNode> conjunctions = createConjunctiveFilter(filter);\n+\n+        // Prepare candidates from conjunctive expressions.\n+        Map<Integer, List<IndexComponentCandidate>> candidates = prepareSingleColumnCandidates(\n+            conjunctions,\n+            OptUtils.getCluster(scan).getParameterMetadata(),\n+            allIndexedFieldOrdinals\n+        );\n+\n+        if (candidates.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        // Create index relational operators based on candidates.\n+        List<RelNode> rels = new ArrayList<>(supportedIndexes.size());\n+\n+        for (MapTableIndex index : supportedIndexes) {\n+            RelNode rel = createIndexScan(scan, distribution, index, conjunctions, candidates);\n+\n+            if (rel != null) {\n+                rels.add(rel);\n+            }\n+        }\n+\n+        return rels;\n+    }\n+\n+    /**\n+     * Creates an object for convenient access to part of the predicate in the CNF.\n+     */\n+    private static List<RexNode> createConjunctiveFilter(RexNode filter) {\n+        List<RexNode> conjunctions = new ArrayList<>(1);\n+\n+        RelOptUtil.decomposeConjunction(filter, conjunctions);\n+\n+        return conjunctions;\n+    }\n+\n+    /**\n+     * Creates a map from the scan column ordinal to expressions that could be potentially used by indexes created over\n+     * this column.\n+     *\n+     * @param nodes                   CNF nodes\n+     * @param allIndexedFieldOrdinals Ordinals of all columns that have some indexes. Helps to filter out candidates that\n+     *                                definitely cannot be used earlier.\n+     */\n+    private static Map<Integer, List<IndexComponentCandidate>> prepareSingleColumnCandidates(\n+        List<RexNode> nodes,\n+        QueryParameterMetadata parameterMetadata,\n+        Set<Integer> allIndexedFieldOrdinals\n+    ) {\n+        Map<Integer, List<IndexComponentCandidate>> res = new HashMap<>();\n+\n+        for (RexNode node : nodes) {\n+            IndexComponentCandidate candidate = prepareSingleColumnCandidate(node, parameterMetadata);\n+\n+            if (candidate == null) {\n+                // Expression cannot be used for indexes\n+                continue;\n+            }\n+\n+            if (!allIndexedFieldOrdinals.contains(candidate.getColumnIndex())) {\n+                // Expression could be used for indexes, but there are no matching indexes\n+                continue;\n+            }\n+\n+            res.computeIfAbsent(candidate.getColumnIndex(), (k) -> new ArrayList<>()).add(candidate);\n+        }\n+\n+        return res;\n+    }\n+\n+    /**\n+     * Prepares an expression candidate for the given RexNode.\n+     * <p>\n+     * We consider two types of expressions: comparison predicates and OR condition. We try to interpret OR as IN, otherwise\n+     * it is ignored.\n+     *\n+     * @param exp calcite expression\n+     * @return candidate or {@code null} if the expression cannot be used with indexes\n+     */\n+    @SuppressWarnings(\"checkstyle:CyclomaticComplexity\")\n+    private static IndexComponentCandidate prepareSingleColumnCandidate(\n+        RexNode exp,\n+        QueryParameterMetadata parameterMetadata\n+    ) {\n+        SqlKind kind = exp.getKind();\n+\n+        switch (kind) {\n+            case INPUT_REF:\n+                // Special case for boolean columns: SELECT * FROM t WHERE f_boolean\n+                return prepareSingleColumnCandidateBooleanIsTrueFalse(exp, exp, SqlKind.IS_TRUE);\n+\n+            case IS_TRUE:\n+            case IS_FALSE:\n+            case IS_NOT_TRUE:\n+            case IS_NOT_FALSE:\n+                return prepareSingleColumnCandidateBooleanIsTrueFalse(\n+                    exp,\n+                    removeCastIfPossible(((RexCall) exp).getOperands().get(0), false),\n+                    kind\n+                );\n+\n+            case NOT:\n+                return prepareSingleColumnCandidateBooleanIsTrueFalse(\n+                    exp,\n+                    removeCastIfPossible(((RexCall) exp).getOperands().get(0), false),\n+                    SqlKind.IS_FALSE\n+                );\n+\n+            case IS_NULL:\n+                return prepareSingleColumnCandidateIsNull(\n+                    exp,\n+                    removeCastIfPossible(((RexCall) exp).getOperands().get(0), true)\n+                );\n+\n+            case GREATER_THAN:\n+            case GREATER_THAN_OR_EQUAL:\n+            case LESS_THAN:\n+            case LESS_THAN_OR_EQUAL:\n+            case EQUALS:\n+                BiTuple<RexNode, RexNode> operands = extractComparisonOperands(exp);\n+\n+                return prepareSingleColumnCandidateComparison(\n+                    exp,\n+                    kind,\n+                    operands.element1(),\n+                    operands.element2(),\n+                    parameterMetadata\n+                );\n+\n+            case OR:\n+                return prepareSingleColumnCandidateOr(\n+                    exp,\n+                    ((RexCall) exp).getOperands(),\n+                    parameterMetadata\n+                );\n+\n+            default:\n+                return null;\n+        }\n+    }\n+\n+    /**\n+     * Prepare a candidate for {@code IS (NOT) TRUE/FALSE} expression.\n+     * <p>\n+     * The fundamental observation is that boolean column may have only three values - TRUE/FALSE/NULL. Therefore, every\n+     * such expression could be converted to equivalent equals or IN predicate.\n+     *\n+     * @param exp expression\n+     * @param operand operand with CAST unwrapped\n+     * @param kind expression type\n+     * @return candidate or {@code null}\n+     */\n+    private static IndexComponentCandidate prepareSingleColumnCandidateBooleanIsTrueFalse(\n+        RexNode exp,\n+        RexNode operand,\n+        SqlKind kind\n+    ) {\n+        if (operand.getKind() != SqlKind.INPUT_REF) {\n+            return null;\n+        }\n+\n+        if (operand.getType().getSqlTypeName() != SqlTypeName.BOOLEAN) {\n+            // Only boolean columns could be used with this optimization\n+            return null;\n+        }\n+\n+        int columnIndex = ((RexInputRef) operand).getIndex();\n+\n+        IndexFilter filter;\n+\n+        switch (kind) {\n+            case IS_TRUE:\n+                filter = new IndexEqualsFilter(new IndexFilterValue(\n+                    singletonList(ConstantExpression.create(true, QueryDataType.BOOLEAN)), singletonList(false)\n+                ));\n+\n+                break;\n+\n+            case IS_FALSE:\n+                filter = new IndexEqualsFilter(new IndexFilterValue(\n+                    singletonList(ConstantExpression.create(false, QueryDataType.BOOLEAN)), singletonList(false)\n+                ));\n+\n+                break;\n+\n+            case IS_NOT_TRUE:\n+                filter = new IndexInFilter(\n+                    new IndexEqualsFilter(new IndexFilterValue(\n+                        singletonList(ConstantExpression.create(false, QueryDataType.BOOLEAN)), singletonList(false)\n+                    )),\n+                    new IndexEqualsFilter(new IndexFilterValue(\n+                        singletonList(ConstantExpression.create(null, QueryDataType.BOOLEAN)), singletonList(true)\n+                    ))\n+                );\n+\n+                break;\n+\n+            default:\n+                assert kind == SqlKind.IS_NOT_FALSE;\n+\n+                filter = new IndexInFilter(\n+                    new IndexEqualsFilter(new IndexFilterValue(\n+                        singletonList(ConstantExpression.create(true, QueryDataType.BOOLEAN)), singletonList(false)\n+                    )),\n+                    new IndexEqualsFilter(new IndexFilterValue(\n+                        singletonList(ConstantExpression.create(null, QueryDataType.BOOLEAN)), singletonList(true)\n+                    ))\n+                );\n+        }\n+\n+        return new IndexComponentCandidate(exp, columnIndex, filter);\n+    }\n+\n+    private static IndexComponentCandidate prepareSingleColumnCandidateIsNull(RexNode exp, RexNode operand) {\n+        if (operand.getKind() != SqlKind.INPUT_REF) {\n+            return null;\n+        }\n+\n+        int columnIndex = ((RexInputRef) operand).getIndex();\n+\n+        QueryDataType type = SqlToQueryType.map(operand.getType().getSqlTypeName());\n+\n+        IndexFilterValue filterValue = new IndexFilterValue(\n+            singletonList(ConstantExpression.create(null, type)),\n+            singletonList(true)\n+        );\n+\n+        IndexFilter filter = new IndexEqualsFilter(filterValue);\n+\n+        return new IndexComponentCandidate(\n+            exp,\n+            columnIndex,\n+            filter\n+        );\n+    }\n+\n+    private static IndexComponentCandidate prepareSingleColumnCandidateComparison(\n+        RexNode exp,\n+        SqlKind kind,\n+        RexNode operand1,\n+        RexNode operand2,\n+        QueryParameterMetadata parameterMetadata\n+    ) {\n+        // Normalize operand positions, so that the column is always goes first\n+        if (operand1.getKind() != SqlKind.INPUT_REF && operand2.getKind() == SqlKind.INPUT_REF) {\n+            kind = inverseIndexConditionKind(kind);\n+\n+            RexNode tmp = operand1;\n+            operand1 = operand2;\n+            operand2 = tmp;\n+        }\n+\n+        // Exit if the first operand is not a column\n+        if (operand1.getKind() != SqlKind.INPUT_REF) {\n+            return null;\n+        }\n+\n+        int columnIndex = ((RexInputRef) operand1).getIndex();\n+\n+        if (!IndexRexVisitor.isValid(operand2)) {\n+            // The second operand cannot be used for index filter\n+            return null;\n+        }\n+\n+        Expression<?> filterValue = convertToExpression(operand2, parameterMetadata);\n+\n+        if (filterValue == null) {\n+            // Operand cannot be converted to expression. Do not throw an exception here, just do not use the faulty condition\n+            // for index. The proper exception will be thrown on later stages when attempting to convert Calcite rel tree to\n+            // Hazelcast plan.\n+            return null;\n+        }\n+\n+        IndexFilterValue filterValue0 = new IndexFilterValue(\n+            singletonList(filterValue),\n+            singletonList(false)\n+        );\n+\n+        IndexFilter filter;\n+\n+        switch (kind) {\n+            case EQUALS:\n+                filter = new IndexEqualsFilter(filterValue0);\n+\n+                break;\n+\n+            case GREATER_THAN:\n+                filter = new IndexRangeFilter(filterValue0, false, null, false);\n+\n+                break;\n+\n+            case GREATER_THAN_OR_EQUAL:\n+                filter = new IndexRangeFilter(filterValue0, true, null, false);\n+\n+                break;\n+\n+            case LESS_THAN:\n+                filter = new IndexRangeFilter(null, false, filterValue0, false);\n+\n+                break;\n+\n+            default:\n+                assert kind == SqlKind.LESS_THAN_OR_EQUAL;\n+\n+                filter = new IndexRangeFilter(null, false, filterValue0, true);\n+        }\n+\n+        return new IndexComponentCandidate(\n+            exp,\n+            columnIndex,\n+            filter\n+        );\n+    }\n+\n+    private static Expression<?> convertToExpression(RexNode operand, QueryParameterMetadata parameterMetadata) {\n+        try {\n+            RexToExpressionVisitor visitor = new RexToExpressionVisitor(FieldTypeProvider.INSTANCE, parameterMetadata);\n+\n+            return operand.accept(visitor);\n+        } catch (Exception e) {\n+            return null;\n+        }\n+    }\n+\n+    private static IndexComponentCandidate prepareSingleColumnCandidateOr(\n+        RexNode exp,\n+        List<RexNode> nodes,\n+        QueryParameterMetadata parameterMetadata\n+    ) {\n+        Integer columnIndex = null;\n+\n+        List<IndexFilter> filters = new ArrayList<>();\n+\n+        for (RexNode node : nodes) {\n+            IndexComponentCandidate candidate = prepareSingleColumnCandidate(node, parameterMetadata);\n+\n+            if (candidate == null) {\n+                // Cannot resolve further, stop\n+                return null;\n+            }\n+\n+            // Work only with \"=\" expressions.\n+            IndexFilter candidateFilter = candidate.getFilter();\n+\n+            if (!(candidateFilter instanceof IndexEqualsFilter || candidateFilter instanceof IndexInFilter)) {\n+                // Support only equality for ORs\n+                return null;\n+            }\n+\n+            // Make sure that all '=' expressions relate to a single column\n+            if (columnIndex == null) {\n+                columnIndex = candidate.getColumnIndex();\n+            } else if (columnIndex != candidate.getColumnIndex()) {\n+                return null;\n+            }\n+\n+            // Flatten\n+            if (candidateFilter instanceof IndexEqualsFilter) {\n+                filters.add(candidateFilter);\n+            } else {\n+                filters.addAll(((IndexInFilter) candidateFilter).getFilters());\n+            }\n+        }\n+\n+        assert columnIndex != null;\n+\n+        IndexInFilter inFilter = new IndexInFilter(filters);\n+\n+        return new IndexComponentCandidate(\n+            exp,\n+            columnIndex,\n+            inFilter\n+        );\n+    }\n+\n+    /**\n+     * Create index scan for the given index if possible.\n+     *\n+     * @return Index scan or {@code null}.\n+     */\n+    public static RelNode createIndexScan(\n+        MapScanLogicalRel scan,\n+        DistributionTrait distribution,\n+        MapTableIndex index,\n+        List<RexNode> conjunctions,\n+        Map<Integer, List<IndexComponentCandidate>> candidates\n+    ) {\n+        List<IndexComponentFilter> filters = new ArrayList<>(index.getFieldOrdinals().size());\n+\n+        for (int i = 0; i < index.getFieldOrdinals().size(); i++) {\n+            int fieldOrdinal = index.getFieldOrdinals().get(i);\n+            QueryDataType fieldConverterType = index.getFieldConverterTypes().get(i);\n+\n+            List<IndexComponentCandidate> fieldCandidates = candidates.get(fieldOrdinal);\n+\n+            if (fieldCandidates == null) {\n+                // No candidates available for the given column, stop.\n+                break;\n+            }\n+\n+            IndexComponentFilter filter = selectComponentFilter(\n+                index.getType(),\n+                fieldCandidates,\n+                fieldConverterType\n+            );\n+\n+            if (filter == null) {\n+                // Cannot create a filter for the given candidates, stop.\n+                break;\n+            }\n+\n+            filters.add(filter);\n+\n+            if (!(filter.getFilter() instanceof IndexEqualsFilter)) {\n+                // For composite indexes, non-equals condition must always be the last part of the request.\n+                // If we found non-equals, then we must stop.\n+                break;\n+            }\n+        }\n+\n+        if (filters.isEmpty()) {\n+            // Failed to build any filters. The index cannot be used.\n+            return null;\n+        }\n+\n+        // Now as filters are determined, construct the physical entity.\n+        return createIndexScan(scan, distribution, index, conjunctions, filters);\n+    }\n+\n+    private static MapIndexScanPhysicalRel createIndexScan(\n+        MapScanLogicalRel scan,\n+        DistributionTrait distribution,\n+        MapTableIndex index,\n+        List<RexNode> conjunctions,\n+        List<IndexComponentFilter> filterDescriptors\n+    ) {\n+        // Collect filters and relevant expressions\n+        List<IndexFilter> filters = new ArrayList<>(filterDescriptors.size());\n+        List<QueryDataType> converterTypes = new ArrayList<>(filterDescriptors.size());\n+        Set<RexNode> exps = new HashSet<>();\n+\n+        for (IndexComponentFilter filterDescriptor : filterDescriptors) {\n+            filters.add(filterDescriptor.getFilter());\n+            converterTypes.add(filterDescriptor.getConverterType());\n+            exps.addAll(filterDescriptor.getExpressions());\n+        }\n+\n+        // Construct Calcite expressions.\n+        RexBuilder rexBuilder = scan.getCluster().getRexBuilder();\n+\n+        RexNode exp = RexUtil.composeConjunction(rexBuilder, exps);\n+\n+        List<RexNode> remainderConjunctiveExps = excludeNodes(conjunctions, exps);\n+        RexNode remainderExp =\n+            remainderConjunctiveExps.isEmpty() ? null : RexUtil.composeConjunction(rexBuilder, remainderConjunctiveExps);\n+\n+        // Prepare traits\n+        RelTraitSet traitSet = OptUtils.toPhysicalConvention(scan.getTraitSet(), distribution);\n+\n+        // Create the index scan\n+        HazelcastRelOptTable originalRelTable = (HazelcastRelOptTable) scan.getTable();\n+        HazelcastTable originalHazelcastTable = OptUtils.getHazelcastTable(scan);\n+\n+        RelOptTable newRelTable = OptUtils.createRelTable(\n+            originalRelTable,\n+            originalHazelcastTable.withFilter(null),\n+            scan.getCluster().getTypeFactory()\n+        );\n+\n+        IndexFilter filter = composeFilter(filters, index.getType(), index.getComponentsCount());\n+\n+        if (filter == null) {\n+            return null;\n+        }\n+\n+        return new MapIndexScanPhysicalRel(\n+            scan.getCluster(),\n+            traitSet,\n+            newRelTable,\n+            index,\n+            filter,\n+            converterTypes,\n+            exp,\n+            remainderExp\n+        );\n+    }\n+\n+    public static RelNode createFullIndexScan(\n+        MapScanLogicalRel scan,\n+        DistributionTrait distribution,\n+        List<MapTableIndex> indexes\n+    ) {\n+        MapTableIndex firstIndex = null;\n+\n+        for (MapTableIndex index : indexes) {\n+            if (isIndexSupported(index)) {\n+                firstIndex = index;\n+\n+                break;\n+            }\n+        }\n+\n+        if (firstIndex == null) {\n+            return null;\n+        }\n+\n+        RexNode scanFilter = scan.getTableUnwrapped().getFilter();\n+\n+        RelTraitSet traitSet = OptUtils.toPhysicalConvention(scan.getTraitSet(), distribution);\n+\n+        HazelcastRelOptTable originalRelTable = (HazelcastRelOptTable) scan.getTable();\n+        HazelcastTable originalHazelcastTable = OptUtils.getHazelcastTable(scan);\n+\n+        RelOptTable newRelTable = OptUtils.createRelTable(\n+            originalRelTable,\n+            originalHazelcastTable.withFilter(null),\n+            scan.getCluster().getTypeFactory()\n+        );\n+\n+        return new MapIndexScanPhysicalRel(\n+            scan.getCluster(),\n+            traitSet,\n+            newRelTable,\n+            firstIndex,\n+            null,\n+            Collections.emptyList(),\n+            null,\n+            scanFilter\n+        );\n+    }\n+\n+    /**\n+     * This method selects the best expression to be used as index filter from the list of candidates.\n+     *\n+     * @param type type of the index (SORTED, HASH)\n+     * @param candidates candidates that might be used as a filter\n+     * @param converterType expected converter type for the given component of the index\n+     * @return filter for the index component or {@code null} if no candidate could be applied\n+     */\n+    @SuppressWarnings({\"checkstyle:CyclomaticComplexity\", \"checkstyle:NPathComplexity\"})\n+    private static IndexComponentFilter selectComponentFilter(\n+        IndexType type,\n+        List<IndexComponentCandidate> candidates,\n+        QueryDataType converterType\n+    ) {\n+        // First look for equality conditions, assuming that it is the most restrictive\n+        for (IndexComponentCandidate candidate : candidates) {\n+            if (candidate.getFilter() instanceof IndexEqualsFilter) {\n+                return new IndexComponentFilter(\n+                    candidate.getFilter(),\n+                    singletonList(candidate.getExpression()),\n+                    converterType\n+                );\n+            }\n+        }\n+\n+        // Next look for IN, as it is worse than equality on a single value, but better than range\n+        for (IndexComponentCandidate candidate : candidates) {\n+            if (candidate.getFilter() instanceof IndexInFilter) {\n+                return new IndexComponentFilter(\n+                    candidate.getFilter(),\n+                    singletonList(candidate.getExpression()),\n+                    converterType\n+                );\n+            }\n+        }\n+\n+        // Last, look for ranges\n+        if (type == IndexType.SORTED) {\n+            IndexFilterValue from = null;\n+            boolean fromInclusive = false;\n+            IndexFilterValue to = null;\n+            boolean toInclusive = false;\n+            List<RexNode> expressions = new ArrayList<>(2);\n+\n+            for (IndexComponentCandidate candidate : candidates) {\n+                if (!(candidate.getFilter() instanceof IndexRangeFilter)) {\n+                    continue;\n+                }\n+\n+                IndexRangeFilter candidateFilter = (IndexRangeFilter) candidate.getFilter();\n+\n+                if (from == null && candidateFilter.getFrom() != null) {\n+                    from = candidateFilter.getFrom();\n+                    fromInclusive = candidateFilter.isFromInclusive();\n+                    expressions.add(candidate.getExpression());\n+                } else if (to == null && candidateFilter.getTo() != null) {\n+                    to = candidateFilter.getTo();\n+                    toInclusive = candidateFilter.isToInclusive();\n+                    expressions.add(candidate.getExpression());\n+                }\n+            }\n+\n+            if (from != null || to != null) {\n+                IndexRangeFilter filter = new IndexRangeFilter(from, fromInclusive, to, toInclusive);\n+\n+                return new IndexComponentFilter(filter, expressions, converterType);\n+            }\n+        }\n+\n+        // Cannot create an index request for the given candidates\n+        return null;\n+    }\n+\n+    /**\n+     * Composes the final filter from the list of single-column filters.\n+     *\n+     * @param filters single-column filters\n+     * @param indexType type of the index\n+     * @param indexComponentsCount number of components in the index\n+     * @return final filter or {@code null} if the filter could not be built for the given index type\n+     */\n+    private static IndexFilter composeFilter(List<IndexFilter> filters, IndexType indexType, int indexComponentsCount) {\n+\n+        if (filters.size() == 1 && indexComponentsCount == 1) {\n+            IndexFilter res = filters.get(0);\n+\n+            assert !(res instanceof IndexRangeFilter) || indexType == IndexType.SORTED;\n+\n+            return res;\n+        } else {\n+            IndexFilter lastFilter = filters.get(filters.size() - 1);\n+\n+            if (lastFilter instanceof IndexEqualsFilter) {\n+                return composeEqualsFilter(filters, (IndexEqualsFilter) lastFilter, indexType, indexComponentsCount);\n+            } else if (lastFilter instanceof IndexInFilter) {\n+                return composeInFilter(filters, (IndexInFilter) lastFilter, indexType, indexComponentsCount);\n+            } else {\n+                assert lastFilter instanceof IndexRangeFilter;\n+\n+                assert indexType == IndexType.SORTED;\n+\n+                return composeRangeFilter(filters, (IndexRangeFilter) lastFilter, indexComponentsCount);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Composes an equality filter from multiple single-column components.\n+     * <p>\n+     * If the number of single-column filters is equal to the number of index components, the resulting filter is a composite\n+     * equality filter.\n+     * <p>\n+     * If the number of single-column filters is less than the number of index components, the resulting filter is a range\n+     * filter, with missing components filled with negative/positive infinities for the left and right bounds respectively.\n+     * <p>\n+     * If the range filter is required, and the target index type is not {@link IndexType#SORTED}, the result is {@code null}.\n+     *\n+     * @return composite filter or {@code null}\n+     */\n+    private static IndexFilter composeEqualsFilter(\n+        List<IndexFilter> filters,\n+        IndexEqualsFilter lastFilter,\n+        IndexType indexType,\n+        int indexComponentsCount\n+    ) {\n+        // Flatten all known values.\n+        List<Expression> components = new ArrayList<>(filters.size());\n+        List<Boolean> allowNulls = new ArrayList<>(filters.size());\n+\n+        fillNonTerminalComponents(filters, components, allowNulls);\n+\n+        components.addAll(lastFilter.getValue().getComponents());\n+        allowNulls.addAll(lastFilter.getValue().getAllowNulls());\n+\n+        if (indexComponentsCount == components.size()) {\n+            // If there is a full match, then leave it as equals filter\n+            return new IndexEqualsFilter(new IndexFilterValue(components, allowNulls));\n+        } else {\n+            // Otherwise convert it to a range request\n+            if (indexType == IndexType.HASH) {\n+                return null;\n+            }\n+\n+            List<Expression> fromComponents = components;\n+            List<Expression> toComponents = new ArrayList<>(components);\n+\n+            List<Boolean> fromAllowNulls = allowNulls;\n+            List<Boolean> toAllowNulls = new ArrayList<>(fromAllowNulls);\n+\n+            addInfiniteRanges(fromComponents, fromAllowNulls, true, toComponents, toAllowNulls, true, indexComponentsCount);\n+\n+            return new IndexRangeFilter(\n+                new IndexFilterValue(fromComponents, fromAllowNulls),\n+                true,\n+                new IndexFilterValue(toComponents, toAllowNulls),\n+                true\n+            );\n+        }\n+    }\n+\n+    /**\n+     * Create the final IN filter from the collection of per-column filters.\n+     * <p>\n+     * Consider the expression {@code {a=1 AND b IN (2,3)}}. After the conversion, the composite filter will be\n+     * {@code {a,b} IN {{1, 2}, {1, 3}}}.\n+     *\n+     * @param filters per-column filters\n+     * @param lastFilter the last IN filter\n+     * @param indexComponentsCount the number of index components\n+     * @return composite IN filter\n+     */\n+    private static IndexFilter composeInFilter(\n+        List<IndexFilter> filters,\n+        IndexInFilter lastFilter,\n+        IndexType indexType,\n+        int indexComponentsCount\n+    ) {\n+        List<IndexFilter> newFilters = new ArrayList<>(lastFilter.getFilters().size());\n+\n+        for (IndexFilter filter : lastFilter.getFilters()) {\n+            assert filter instanceof IndexEqualsFilter;\n+\n+            IndexFilter newFilter = composeEqualsFilter(filters, (IndexEqualsFilter) filter, indexType, indexComponentsCount);\n+\n+            if (newFilter == null) {\n+                // Cannot create a filter for one of the values of the IN clause. Stop.\n+                return null;\n+            }\n+\n+            newFilters.add(newFilter);\n+        }\n+\n+        return new IndexInFilter(newFilters);\n+    }\n+\n+    /**\n+     * Create the composite range filter from the given per-column filters.\n+     * <p>\n+     * If there number of per-column filters if less than the number of index components, then infinite ranges are added\n+     * to the missing components.\n+     * <p>\n+     * Consider that we have two per-column filter as input: {@code {a=1}, {b>2 AND b<3}}.\n+     * <p>\n+     * If the index is defined as {@code {a, b}}, then the resulting filter would be {@code {a=1, b>2 AND a=1, b<3}}.\n+     * <p>\n+     * If the index is defined as {@code {a, b, c}}, then the resulting filter would be\n+     * {@code {a=1, b>2, c>NEGATIVE_INFINITY AND a=1, b<3, c<POSITIVE_INFINITY}}.\n+     *\n+     * @param filters all per-column filters\n+     * @param lastFilter the last filter (range)\n+     * @param componentsCount number of components in the filter\n+     * @return range filter\n+     */\n+    private static IndexFilter composeRangeFilter(List<IndexFilter> filters, IndexRangeFilter lastFilter, int componentsCount) {\n+        // Flatten non-terminal components.\n+        List<Expression> components = new ArrayList<>(filters.size());\n+        List<Boolean> allowNulls = new ArrayList<>();\n+\n+        fillNonTerminalComponents(filters, components, allowNulls);\n+\n+        // Add value of the current filter.\n+        List<Expression> fromComponents = components;\n+        List<Expression> toComponents = new ArrayList<>(components);\n+\n+        List<Boolean> fromAllowNulls = allowNulls;\n+        List<Boolean> toAllowNulls = new ArrayList<>(fromAllowNulls);\n+\n+        if (lastFilter.getFrom() != null) {\n+            fromComponents.add(lastFilter.getFrom().getComponents().get(0));\n+            fromAllowNulls.add(false);\n+        } else {\n+            if (componentsCount == 1) {\n+                fromComponents.add(ConstantExpression.create(NEGATIVE_INFINITY, QueryDataType.OBJECT));\n+                fromAllowNulls.add(false);\n+            } else {\n+                // In composite indexes null values are not stored separately. Therefore, we need to filter them out.\n+                fromComponents.add(ConstantExpression.create(null, QueryDataType.OBJECT));\n+                fromAllowNulls.add(true);\n+            }\n+        }\n+\n+        if (lastFilter.getTo() != null) {\n+            toComponents.add(lastFilter.getTo().getComponents().get(0));\n+        } else {\n+            toComponents.add(ConstantExpression.create(POSITIVE_INFINITY, QueryDataType.OBJECT));\n+        }\n+\n+        toAllowNulls.add(false);\n+\n+        // Fill missing part of the range request.\n+        addInfiniteRanges(\n+            fromComponents,\n+            fromAllowNulls,\n+            lastFilter.isFromInclusive(),\n+            toComponents,\n+            toAllowNulls,\n+            lastFilter.isToInclusive(),\n+            componentsCount\n+        );\n+\n+        return new IndexRangeFilter(\n+            new IndexFilterValue(fromComponents, fromAllowNulls),\n+            lastFilter.isFromInclusive(),\n+            new IndexFilterValue(toComponents, toAllowNulls),\n+            lastFilter.isToInclusive()\n+        );\n+    }\n+\n+    /**\n+     * Given the list of column filters, flatten their expressions and allow-null flags.\n+     * <p>\n+     * The operation is performed for all filters except for the last one, because treatment of the last filter might differ\n+     * depending on the total number of components in the index.\n+     *\n+     * @param filters column filters\n+     * @param components expressions that would form the final filter\n+     * @param allowNulls allow-null collection relevant to components\n+     */\n+    private static void fillNonTerminalComponents(\n+        List<IndexFilter> filters,\n+        List<Expression> components,\n+        List<Boolean> allowNulls\n+    ) {\n+        for (int i = 0; i < filters.size() - 1; i++) {\n+            IndexEqualsFilter filter0 = (IndexEqualsFilter) filters.get(i);\n+\n+            IndexFilterValue value = filter0.getValue();\n+\n+            assert value.getComponents().size() == 1;\n+\n+            components.add(value.getComponents().get(0));\n+            allowNulls.add(value.getAllowNulls().get(0));\n+        }\n+\n+        assert components.size() == filters.size() - 1;\n+        assert allowNulls.size() == filters.size() - 1;\n+    }\n+\n+    /**\n+     * Adds infinite ranges to filter components, to match the number of index components.\n+     * <p>\n+     * For example, for the index on {@code (a, b)} and the expression {@code a=1}, the original filter would be\n+     * {@code from={a=1}, to={a=1}}.\n+     * <p>\n+     * Since the index has two components, we need to add infinite ranges to components that do not have explicit filters.\n+     * After the method finishes, the filter would be {@code from={a=1, b=NEGATIVE_INFINITY}, to={a=1, b=POSITIVE_INFINITY}}.\n+     * <p>\n+     * The combination of ranges also depends on the inclusion. For example, {@code {a>1}} yields {@code NEGATIVE_INFINITY}\n+     * for {@code b} on the left side, while {@code {a>=1}} yields {@code POSITIVE_INFINITY}.\n+     *\n+     * @param fromComponents expressions for the \"from\" part\n+     * @param toComponents expressions for the \"to\" part\n+     * @param componentsCount the number of components in the index\n+     */\n+    private static void addInfiniteRanges(\n+        List<Expression> fromComponents,\n+        List<Boolean> fromAllowNulls,\n+        boolean fromInclusive,\n+        List<Expression> toComponents,\n+        List<Boolean> toAllowNulls,\n+        boolean toInclusive,\n+        int componentsCount\n+    ) {\n+        int count = componentsCount - fromComponents.size();\n+\n+        ComparableIdentifiedDataSerializable leftBound = fromInclusive ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\n+        ComparableIdentifiedDataSerializable toBound = toInclusive ? POSITIVE_INFINITY : NEGATIVE_INFINITY;\n+\n+        for (int i = 0; i < count; i++) {\n+            fromComponents.add(ConstantExpression.create(leftBound, QueryDataType.OBJECT));\n+            toComponents.add(ConstantExpression.create(toBound, QueryDataType.OBJECT));\n+\n+            fromAllowNulls.add(false);\n+            toAllowNulls.add(false);\n+        }\n+    }\n+\n+    /**\n+     * Convert the comparison operator to the opposite operator. E.g. {@code >} becomes {@code <}.\n+     * <p>\n+     * This method is invoked during expression normalization to simplify further processing. E.g. {@code ? < a} is converted\n+     * into {@code a > ?}\n+     *\n+     * @param kind original operator\n+     * @return the opposite operator\n+     */\n+    private static SqlKind inverseIndexConditionKind(SqlKind kind) {\n+        switch (kind) {\n+            case GREATER_THAN:\n+                return SqlKind.LESS_THAN;\n+\n+            case GREATER_THAN_OR_EQUAL:\n+                return SqlKind.LESS_THAN_OR_EQUAL;\n+\n+            case LESS_THAN:\n+                return SqlKind.GREATER_THAN;\n+\n+            case LESS_THAN_OR_EQUAL:\n+                return SqlKind.GREATER_THAN_OR_EQUAL;\n+\n+            default:\n+                assert kind == SqlKind.EQUALS;\n+\n+                return kind;\n+        }\n+    }\n+\n+    /**\n+     * Checks whether the index could be used by the engine.\n+     * <p>\n+     * At the moment only SORTED and HASH indexes could be used.\n+     *\n+     * @param index the index\n+     * @return {@code true} if the index could be used, {@code false} otherwise\n+     */\n+    private static boolean isIndexSupported(MapTableIndex index) {\n+        return index.getType() == IndexType.SORTED || index.getType() == IndexType.HASH;\n+    }\n+\n+    /**\n+     * Extracts comparison operands, removing CAST when possible.\n+     *\n+     * @param node original comparison node\n+     * @return a pair of operands\n+     */\n+    private static BiTuple<RexNode, RexNode> extractComparisonOperands(RexNode node) {\n+        assert node instanceof RexCall;\n+\n+        RexCall node0 = (RexCall) node;\n+\n+        assert node0.getOperands().size() == 2;\n+\n+        RexNode operand1 = node0.getOperands().get(0);\n+        RexNode operand2 = node0.getOperands().get(1);\n+\n+        RexNode normalizedOperand1 = removeCastIfPossible(operand1, false);\n+        RexNode normalizedOperand2 = removeCastIfPossible(operand2, false);\n+\n+        return BiTuple.of(normalizedOperand1, normalizedOperand2);\n+    }\n+\n+    /**\n+     * Removes CAST operator from the column expression when possible.\n+     * <p>\n+     * The following expression might be found: {@code CAST(a AS BIGINT) > ?}. This may happen either due to type coercion\n+     * during sql->rel conversion, or due to explicit user request. In the general case, a function applied to the column makes\n+     * usage of the index on that column impossible.\n+     * <p>\n+     * In case of the {@code CAST} operator we may try to remove the CAST, thus relying on internal index converters to\n+     * downcast the other side of the comparison expression. See {@link TypeConverters}.\n+     *\n+     * @param node original node, possibly CAST\n+     * @param force whether to remove CAST forcefully even for conversion that is otherwise invalid wrt the storage (used for\n+     *              {@code IS NULL} operator)\n+     * @return original node if there is nothing to unwrap, or the operand of the CAST\n+     */\n+    private static RexNode removeCastIfPossible(RexNode node, boolean force) {\n+        if (node.getKind() == SqlKind.CAST) {\n+            RexCall node0 = (RexCall) node;\n+\n+            RexNode from = node0.getOperands().get(0);\n+\n+            if (from instanceof RexInputRef) {\n+                RelDataType fromType = from.getType();\n+                RelDataType toType = node0.getType();\n+\n+                if (force) {\n+                    // Forced unwrap for IS NULL expression\n+                    return from;\n+                }\n+\n+                if (fromType.equals(toType)) {\n+                    // Redundant conversion => unwrap\n+                    return from;\n+                }\n+\n+                if (fromType.getSqlTypeName().getFamily() == NUMERIC && toType.getSqlTypeName().getFamily() == NUMERIC) {", "originalCommit": "02543afd7f25a9983c3b03ede8faed477e1212f4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQxODc1NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r475418754", "bodyText": "Disallowed invalid CAST unwrapping. Now the type precedence is used to distinguish between allowed and disallowed casts. Also, removed force flag from this method because it could lead to the same problem with IS NULL condition.\nAdded tests.\nSee bf01d45", "author": "devozerov", "createdAt": "2020-08-24T08:16:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTM4MTgxOA=="}], "type": "inlineReview"}, {"oid": "7f93e6d9d4e87eb13cceeb3e5cc4775ca9c648e6", "url": "https://github.com/hazelcast/hazelcast/commit/7f93e6d9d4e87eb13cceeb3e5cc4775ca9c648e6", "message": "WIP on JavaDoc", "committedDate": "2020-08-24T07:05:43Z", "type": "commit"}, {"oid": "0929eb251518d1daf62d1bf2bfd1c0a0d033b3a5", "url": "https://github.com/hazelcast/hazelcast/commit/0929eb251518d1daf62d1bf2bfd1c0a0d033b3a5", "message": "WIP on JavaDocs", "committedDate": "2020-08-24T07:25:11Z", "type": "commit"}, {"oid": "bf01d4544629c364427a26c94ff0d9e41974378c", "url": "https://github.com/hazelcast/hazelcast/commit/bf01d4544629c364427a26c94ff0d9e41974378c", "message": "Disallowed invalid uncasts.", "committedDate": "2020-08-24T08:15:02Z", "type": "commit"}, {"oid": "48afb200412a4efc130f8ecf1017da089d8813d1", "url": "https://github.com/hazelcast/hazelcast/commit/48afb200412a4efc130f8ecf1017da089d8813d1", "message": "WIP on JavaDoc", "committedDate": "2020-08-24T09:09:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ1NDMzOQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r475454339", "bodyText": "in and between are now enabled, but looks like there are no tests targeting them specifically", "author": "taburet", "createdAt": "2020-08-24T09:18:23Z", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/parse/UnsupportedOperationVisitor.java", "diffHunk": "@@ -96,9 +96,11 @@\n         SUPPORTED_KINDS.add(SqlKind.GREATER_THAN);\n         SUPPORTED_KINDS.add(SqlKind.GREATER_THAN_OR_EQUAL);\n         SUPPORTED_KINDS.add(SqlKind.LESS_THAN_OR_EQUAL);\n+        SUPPORTED_KINDS.add(SqlKind.IN);", "originalCommit": "0929eb251518d1daf62d1bf2bfd1c0a0d033b3a5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ3NDUwMg==", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r475474502", "bodyText": "This is an incorrect merge from the sql branch. Removed support for IN/BETWEEN.", "author": "devozerov", "createdAt": "2020-08-24T09:39:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ1NDMzOQ=="}], "type": "inlineReview"}, {"oid": "eb88151a7bcfb5df3af452f82c980b2504429d45", "url": "https://github.com/hazelcast/hazelcast/commit/eb88151a7bcfb5df3af452f82c980b2504429d45", "message": "Finished with JavaDoc for IndexResolver.", "committedDate": "2020-08-24T09:19:35Z", "type": "commit"}, {"oid": "518c0bd230deec7101fd4523b232858949d3f6c2", "url": "https://github.com/hazelcast/hazelcast/commit/518c0bd230deec7101fd4523b232858949d3f6c2", "message": "Disallow IN/BETWEEN", "committedDate": "2020-08-24T09:39:18Z", "type": "commit"}, {"oid": "ae47ee95effb89be6a1ca976ceb8d45606f05359", "url": "https://github.com/hazelcast/hazelcast/commit/ae47ee95effb89be6a1ca976ceb8d45606f05359", "message": "JavaDoc for IndexFilterValue", "committedDate": "2020-08-24T09:43:13Z", "type": "commit"}, {"oid": "b7fa8c0deb9ae9e81c3b6999ad9282f4865de48d", "url": "https://github.com/hazelcast/hazelcast/commit/b7fa8c0deb9ae9e81c3b6999ad9282f4865de48d", "message": "JavaDoc for IndexFilterValue", "committedDate": "2020-08-24T09:43:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDUyNjYzNA==", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r474526634", "bodyText": "Minor typo: indexed?", "author": "petrpleshachkov", "createdAt": "2020-08-21T08:36:10Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/scan/index/MapIndexScanExecIterator.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.exec.scan.index;\n+\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.internal.util.collection.PartitionIdSet;\n+import com.hazelcast.map.impl.MapContainer;\n+import com.hazelcast.query.impl.InternalIndex;\n+import com.hazelcast.query.impl.QueryableEntry;\n+import com.hazelcast.sql.SqlErrorCode;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.exec.scan.KeyValueIterator;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.schema.map.MapTableUtils;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+/**\n+ * Iterator for index-based partitioned map access.\n+ */\n+@SuppressWarnings(\"rawtypes\")\n+public class MapIndexScanExecIterator implements KeyValueIterator {\n+\n+    private final Iterator<QueryableEntry> iterator;\n+\n+    private Data currentKey;\n+    private Object currentValue;\n+    private Data nextKey;\n+    private Object nextValue;\n+\n+    public MapIndexScanExecIterator(\n+        MapContainer map,\n+        String indexName,\n+        int expectedComponentCount,\n+        IndexFilter indexFilter,\n+        List<QueryDataType> expectedConverterTypes,\n+        PartitionIdSet expectedPartitions,\n+        ExpressionEvalContext evalContext\n+    ) {\n+        iterator = getIndexEntries(\n+            map,\n+            indexName,\n+            indexFilter,\n+            evalContext,\n+            expectedComponentCount,\n+            expectedConverterTypes,\n+            expectedPartitions\n+        );\n+\n+        advance0();\n+    }\n+\n+    @Override\n+    public boolean tryAdvance() {\n+        if (!done()) {\n+            currentKey = nextKey;\n+            currentValue = nextValue;\n+\n+            advance0();\n+\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    @Override\n+    public boolean done() {\n+        return nextKey == null;\n+    }\n+\n+    @Override\n+    public Object getKey() {\n+        return currentKey;\n+    }\n+\n+    @Override\n+    public Object getValue() {\n+        return currentValue;\n+    }\n+\n+    private void advance0() {\n+        if (iterator.hasNext()) {\n+            QueryableEntry<?, ?> entry = iterator.next();\n+\n+            nextKey = entry.getKeyData();\n+            nextValue = entry.getValue();\n+        } else {\n+            nextKey = null;\n+            nextValue = null;\n+        }\n+    }\n+\n+    private Iterator<QueryableEntry> getIndexEntries(\n+        MapContainer map,\n+        String indexName,\n+        IndexFilter indexFilter,\n+        ExpressionEvalContext evalContext,\n+        int expectedComponentCount,\n+        List<QueryDataType> expectedConverterTypes,\n+        PartitionIdSet expectedPartitions\n+    ) {\n+        // Find the index\n+        InternalIndex index = map.getIndexes().getIndex(indexName);\n+\n+        if (index == null) {\n+            throw QueryException.error(\n+                SqlErrorCode.MAP_INDEX_NOT_EXISTS,\n+                \"Index \\\"\" + indexName + \"\\\" of the map \\\"\" + map.getName() + \"\\\" doesn't exist\"\n+            ).withInvalidate();\n+        }\n+\n+        // Make sure that required partitions are indexes\n+        validatePartitions(index, expectedPartitions);", "originalCommit": "d50082e6a80a49e79e3ba3c9d1fb829395b6f6fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ4OTcxNw==", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r475489717", "bodyText": "Fixed", "author": "devozerov", "createdAt": "2020-08-24T10:07:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDUyNjYzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDUzNzA0MA==", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r474537040", "bodyText": "I'd also explicitly add an assert here that the index is global because for partitioned index the method is not thread-safe.", "author": "petrpleshachkov", "createdAt": "2020-08-21T08:47:48Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/scan/index/MapIndexScanExecIterator.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.exec.scan.index;\n+\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.internal.util.collection.PartitionIdSet;\n+import com.hazelcast.map.impl.MapContainer;\n+import com.hazelcast.query.impl.InternalIndex;\n+import com.hazelcast.query.impl.QueryableEntry;\n+import com.hazelcast.sql.SqlErrorCode;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.exec.scan.KeyValueIterator;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.schema.map.MapTableUtils;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+/**\n+ * Iterator for index-based partitioned map access.\n+ */\n+@SuppressWarnings(\"rawtypes\")\n+public class MapIndexScanExecIterator implements KeyValueIterator {\n+\n+    private final Iterator<QueryableEntry> iterator;\n+\n+    private Data currentKey;\n+    private Object currentValue;\n+    private Data nextKey;\n+    private Object nextValue;\n+\n+    public MapIndexScanExecIterator(\n+        MapContainer map,\n+        String indexName,\n+        int expectedComponentCount,\n+        IndexFilter indexFilter,\n+        List<QueryDataType> expectedConverterTypes,\n+        PartitionIdSet expectedPartitions,\n+        ExpressionEvalContext evalContext\n+    ) {\n+        iterator = getIndexEntries(\n+            map,\n+            indexName,\n+            indexFilter,\n+            evalContext,\n+            expectedComponentCount,\n+            expectedConverterTypes,\n+            expectedPartitions\n+        );\n+\n+        advance0();\n+    }\n+\n+    @Override\n+    public boolean tryAdvance() {\n+        if (!done()) {\n+            currentKey = nextKey;\n+            currentValue = nextValue;\n+\n+            advance0();\n+\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    @Override\n+    public boolean done() {\n+        return nextKey == null;\n+    }\n+\n+    @Override\n+    public Object getKey() {\n+        return currentKey;\n+    }\n+\n+    @Override\n+    public Object getValue() {\n+        return currentValue;\n+    }\n+\n+    private void advance0() {\n+        if (iterator.hasNext()) {\n+            QueryableEntry<?, ?> entry = iterator.next();\n+\n+            nextKey = entry.getKeyData();\n+            nextValue = entry.getValue();\n+        } else {\n+            nextKey = null;\n+            nextValue = null;\n+        }\n+    }\n+\n+    private Iterator<QueryableEntry> getIndexEntries(\n+        MapContainer map,\n+        String indexName,\n+        IndexFilter indexFilter,\n+        ExpressionEvalContext evalContext,\n+        int expectedComponentCount,\n+        List<QueryDataType> expectedConverterTypes,\n+        PartitionIdSet expectedPartitions\n+    ) {\n+        // Find the index\n+        InternalIndex index = map.getIndexes().getIndex(indexName);\n+\n+        if (index == null) {\n+            throw QueryException.error(\n+                SqlErrorCode.MAP_INDEX_NOT_EXISTS,\n+                \"Index \\\"\" + indexName + \"\\\" of the map \\\"\" + map.getName() + \"\\\" doesn't exist\"\n+            ).withInvalidate();\n+        }\n+\n+        // Make sure that required partitions are indexes\n+        validatePartitions(index, expectedPartitions);\n+\n+        if (indexFilter == null) {\n+            // No filter => this is a full scan (e.g. for HD)\n+            return index.getSqlRecordIterator();\n+        }\n+\n+        int actualComponentCount = index.getComponents().length;\n+\n+        if (actualComponentCount != expectedComponentCount) {\n+            throw QueryException.error(\"Index \\\"\" + indexName + \"\\\" has \" + actualComponentCount + \" component(s), but \"\n+                + expectedComponentCount + \" expected\").withInvalidate();\n+        }\n+\n+        // Validate component types\n+        List<QueryDataType> currentConverterTypes = MapTableUtils.indexConverterToSqlTypes(index.getConverter());\n+\n+        validateConverterTypes(index, expectedConverterTypes, currentConverterTypes);\n+\n+        // Query the index\n+        return indexFilter.getEntries(index, evalContext);\n+    }\n+\n+    private void validatePartitions(InternalIndex index, PartitionIdSet expectedPartitions) {\n+        List<Integer> missingPartitions = null;\n+\n+        for (int partition : expectedPartitions) {\n+            if (!index.hasPartitionIndexed(partition)) {", "originalCommit": "d50082e6a80a49e79e3ba3c9d1fb829395b6f6fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU5MjIzMQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r475592231", "bodyText": "I couldn't find a convenient method to check that. Do we have one?", "author": "devozerov", "createdAt": "2020-08-24T13:17:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDUzNzA0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU5ODU4OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r475598589", "bodyText": "It is in the Indexes class.", "author": "petrpleshachkov", "createdAt": "2020-08-24T13:27:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDUzNzA0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTYwNzQwNQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r475607405", "bodyText": "Thanks. Added the proposed assert.", "author": "devozerov", "createdAt": "2020-08-24T13:38:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDUzNzA0MA=="}], "type": "inlineReview"}, {"oid": "1bee5cff53cce90be3f4bb7464dc29ba09c7dc50", "url": "https://github.com/hazelcast/hazelcast/commit/1bee5cff53cce90be3f4bb7464dc29ba09c7dc50", "message": "Typo", "committedDate": "2020-08-24T10:04:28Z", "type": "commit"}, {"oid": "8f9160f747258cba08741fbb6ecc013a4f0042bc", "url": "https://github.com/hazelcast/hazelcast/commit/8f9160f747258cba08741fbb6ecc013a4f0042bc", "message": "JavaDocs", "committedDate": "2020-08-24T10:05:23Z", "type": "commit"}, {"oid": "9d0b55f90467f4325ab61b9ae308ae3c8601d822", "url": "https://github.com/hazelcast/hazelcast/commit/9d0b55f90467f4325ab61b9ae308ae3c8601d822", "message": "Typo", "committedDate": "2020-08-24T10:05:37Z", "type": "commit"}, {"oid": "4f748cc85501f3f8803e6b77230c4ff572a21221", "url": "https://github.com/hazelcast/hazelcast/commit/4f748cc85501f3f8803e6b77230c4ff572a21221", "message": "Added assertion for AbstractIndex.NULL in the IndexRangeFilter - it should never appear there.", "committedDate": "2020-08-24T10:12:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUxMzE4OA==", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r475513188", "bodyText": "It might make sense to log such indexes to avoid situations when an index is not used for no apparent reason.", "author": "taburet", "createdAt": "2020-08-24T10:45:17Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/schema/map/MapTableUtils.java", "diffHunk": "@@ -54,4 +73,179 @@ public static long estimatePartitionedMapRowCount(NodeEngine nodeEngine, MapServ\n \n         return entryCount * memberCount;\n     }\n+\n+    public static List<MapTableIndex> getPartitionedMapIndexes(\n+        NodeEngine nodeEngine,\n+        MapContainer mapContainer,\n+        List<TableField> fields\n+    ) {\n+        // Do no return non-concurrent indexes for HD maps.\n+        boolean hd = mapContainer.getMapConfig().getInMemoryFormat() == InMemoryFormat.NATIVE;\n+        boolean globalIndexEnabled = nodeEngine.getProperties().getBoolean(GLOBAL_HD_INDEX_ENABLED);\n+\n+        if (hd && !globalIndexEnabled) {\n+            return Collections.emptyList();\n+        }\n+\n+        Map<QueryPath, Integer> pathToOrdinalMap = mapPathsToOrdinals(fields);\n+\n+        List<Index> indexes = mapContainer.getIndexList();\n+\n+        if (indexes.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        List<MapTableIndex> res = new ArrayList<>(indexes.size());\n+\n+        for (Index index : indexes) {\n+            IndexConfig indexConfig = index.getConfig();\n+\n+            List<QueryDataType> resolvedFieldConverterTypes = indexConverterToSqlTypes(index.getConverter());\n+\n+            List<Integer> indexFieldOrdinals = new ArrayList<>(indexConfig.getAttributes().size());\n+            List<QueryDataType> indexFieldConverterTypes = new ArrayList<>(indexConfig.getAttributes().size());\n+\n+            for (int i = 0; i < indexConfig.getAttributes().size(); i++) {\n+                String attribute = indexConfig.getAttributes().get(i);\n+\n+                QueryPath attributePath = QueryPath.create(attribute);\n+\n+                Integer ordinal = pathToOrdinalMap.get(attributePath);\n+\n+                if (ordinal == null) {\n+                    // No mapping for the field. Stop.\n+                    break;\n+                }\n+\n+                if (i >= resolvedFieldConverterTypes.size()) {\n+                    // No more resolved converters. Stop.\n+                    break;\n+                }\n+\n+                QueryDataType fieldType = fields.get(ordinal).getType();\n+                QueryDataType converterType = resolvedFieldConverterTypes.get(i);\n+\n+                if (!isCompatibleForIndexRequest(fieldType, converterType)) {\n+                    // Field and converter types are not compatible (e.g. INT vs VARCHAR).\n+                    break;", "originalCommit": "4f748cc85501f3f8803e6b77230c4ff572a21221", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUzMDQ2Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r475530466", "bodyText": "It makes sense to log it somehow. But we need some sort of throttling to avoid log pollution. I would do that in a separate PR.", "author": "devozerov", "createdAt": "2020-08-24T11:22:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUxMzE4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUyMzYwNA==", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r475523604", "bodyText": "Is this method really needed? Looks like for purpose of this PR it's never invoked if global indexes are not enabled, so it's basically equivalent to the existing MapContainer#getIndexes().", "author": "taburet", "createdAt": "2020-08-24T11:07:34Z", "path": "hazelcast/src/main/java/com/hazelcast/map/impl/MapContainer.java", "diffHunk": "@@ -431,6 +435,20 @@ public ObjectNamespace getObjectNamespace() {\n         return definitions;\n     }\n \n+    public List<Index> getIndexList() {", "originalCommit": "4f748cc85501f3f8803e6b77230c4ff572a21221", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUzMzA0Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r475533042", "bodyText": "Removed the method", "author": "devozerov", "createdAt": "2020-08-24T11:28:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUyMzYwNA=="}], "type": "inlineReview"}, {"oid": "95aff18367809a853babae6d6fb2a3742b0efbc7", "url": "https://github.com/hazelcast/hazelcast/commit/95aff18367809a853babae6d6fb2a3742b0efbc7", "message": "Fix test failures", "committedDate": "2020-08-24T11:15:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUyOTg5MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r475529891", "bodyText": "As far as I understand these getSqlRecord* methods are mostly for completeness here and not really used, right?", "author": "taburet", "createdAt": "2020-08-24T11:21:09Z", "path": "hazelcast/src/main/java/com/hazelcast/query/impl/AttributeIndexRegistry.java", "diffHunk": "@@ -235,6 +237,50 @@ public boolean canEvaluate(Class<? extends Predicate> predicateClass) {\n             return delegate.evaluate(predicate);\n         }\n \n+        @Override\n+        public Iterator<QueryableEntry> getSqlRecordIterator() {", "originalCommit": "95aff18367809a853babae6d6fb2a3742b0efbc7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUzNTQ1Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17382#discussion_r475535456", "bodyText": "I was not aware that they will be not used, because didn't understand the purpose of this class good enough.\nAfter reading docs and running tests, it is apparent that these implementations are not needed. Removed them.", "author": "devozerov", "createdAt": "2020-08-24T11:31:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUyOTg5MQ=="}], "type": "inlineReview"}, {"oid": "3be39d0677a15d3a3b66db80ddbba8cf82d046a6", "url": "https://github.com/hazelcast/hazelcast/commit/3be39d0677a15d3a3b66db80ddbba8cf82d046a6", "message": "Remove MapContainer.getIndexList", "committedDate": "2020-08-24T11:26:49Z", "type": "commit"}, {"oid": "379c8df220f149b04aea8de06145302283432888", "url": "https://github.com/hazelcast/hazelcast/commit/379c8df220f149b04aea8de06145302283432888", "message": "Removed implementations of new methods from AttributeIndexRegistry.", "committedDate": "2020-08-24T11:31:02Z", "type": "commit"}, {"oid": "563ba83a73298b537bb57c46e4629996ae3ee036", "url": "https://github.com/hazelcast/hazelcast/commit/563ba83a73298b537bb57c46e4629996ae3ee036", "message": "Assert that indexes are global for MapIndexScanExecIterator.", "committedDate": "2020-08-24T13:30:20Z", "type": "commit"}, {"oid": "dab579d25518edfc81a5ff3ba2ce57069ccc978d", "url": "https://github.com/hazelcast/hazelcast/commit/dab579d25518edfc81a5ff3ba2ce57069ccc978d", "message": "Merge branch 'master' into issues/17381", "committedDate": "2020-08-24T13:31:51Z", "type": "commit"}, {"oid": "3477af0260189e266d5323ae85fc6040cd26b6d0", "url": "https://github.com/hazelcast/hazelcast/commit/3477af0260189e266d5323ae85fc6040cd26b6d0", "message": "Merge branch 'master' into issues/17381\n\n# Conflicts:\n#\thazelcast-sql/src/test/java/com/hazelcast/sql/impl/calcite/opt/OptimizerTestSupport.java\n#\thazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/ExpressionTestBase.java\n#\thazelcast/src/main/java/com/hazelcast/sql/impl/schema/map/PartitionedMapTable.java\n#\thazelcast/src/main/java/com/hazelcast/sql/impl/schema/map/PartitionedMapTableResolver.java", "committedDate": "2020-08-25T07:50:19Z", "type": "commit"}, {"oid": "c23e61bbb8983d9dbf58030561c917a405f71d7d", "url": "https://github.com/hazelcast/hazelcast/commit/c23e61bbb8983d9dbf58030561c917a405f71d7d", "message": "Fixes after merge with master", "committedDate": "2020-08-25T07:53:29Z", "type": "commit"}]}