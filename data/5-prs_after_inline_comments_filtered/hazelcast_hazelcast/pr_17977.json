{"pr_number": 17977, "pr_title": "Introduce Per Config Record Creation ", "pr_createdAt": "2020-12-15T21:03:49Z", "pr_url": "https://github.com/hazelcast/hazelcast/pull/17977", "timeline": [{"oid": "fc278947247684c16fd96ee30e4136206f861627", "url": "https://github.com/hazelcast/hazelcast/commit/fc278947247684c16fd96ee30e4136206f861627", "message": "test fix", "committedDate": "2020-12-16T11:14:43Z", "type": "forcePushed"}, {"oid": "7249783288084e242974dcb16fda88834d52dd6f", "url": "https://github.com/hazelcast/hazelcast/commit/7249783288084e242974dcb16fda88834d52dd6f", "message": "test fix 2", "committedDate": "2020-12-24T08:43:46Z", "type": "forcePushed"}, {"oid": "6b86ffa57b64b99a230a9749abd434f71e469210", "url": "https://github.com/hazelcast/hazelcast/commit/6b86ffa57b64b99a230a9749abd434f71e469210", "message": "remove key createRecord", "committedDate": "2020-12-28T10:02:25Z", "type": "forcePushed"}, {"oid": "4dfa1f732248af866b4f7667c47549723b57ad17", "url": "https://github.com/hazelcast/hazelcast/commit/4dfa1f732248af866b4f7667c47549723b57ad17", "message": "polish", "committedDate": "2021-01-04T10:11:16Z", "type": "forcePushed"}, {"oid": "f00a535bf7dcdc562a16c1c532369e343e46cdc8", "url": "https://github.com/hazelcast/hazelcast/commit/f00a535bf7dcdc562a16c1c532369e343e46cdc8", "message": "remove old record impl except withStats extensions\n- add object header to entry costs", "committedDate": "2021-01-05T11:17:00Z", "type": "forcePushed"}, {"oid": "9a33c375b67e06bad04f0bbc9840008747a0fe0e", "url": "https://github.com/hazelcast/hazelcast/commit/9a33c375b67e06bad04f0bbc9840008747a0fe0e", "message": "remove unneeded stats update from records", "committedDate": "2021-01-06T11:09:18Z", "type": "forcePushed"}, {"oid": "05a2d6952c771881fb06b05284c868a25ca0ffc0", "url": "https://github.com/hazelcast/hazelcast/commit/05a2d6952c771881fb06b05284c868a25ca0ffc0", "message": "Object2ObjectHashMap", "committedDate": "2021-01-07T13:51:12Z", "type": "forcePushed"}, {"oid": "a21cbc4351bfbbc27384c76b5b8caec7556fdebe", "url": "https://github.com/hazelcast/hazelcast/commit/a21cbc4351bfbbc27384c76b5b8caec7556fdebe", "message": "Remove serializable from Object2ObjMap", "committedDate": "2021-01-07T16:00:00Z", "type": "forcePushed"}, {"oid": "e430b42a831b868405d818e1e88e476d097a114a", "url": "https://github.com/hazelcast/hazelcast/commit/e430b42a831b868405d818e1e88e476d097a114a", "message": "improvements", "committedDate": "2021-01-09T19:28:57Z", "type": "forcePushed"}, {"oid": "d99ee5924d67c26fb662fbaad4072dec445f7213", "url": "https://github.com/hazelcast/hazelcast/commit/d99ee5924d67c26fb662fbaad4072dec445f7213", "message": "polish", "committedDate": "2021-01-15T11:15:01Z", "type": "forcePushed"}, {"oid": "0eae15379f564a482774fa5b793157e64e44c9e1", "url": "https://github.com/hazelcast/hazelcast/commit/0eae15379f564a482774fa5b793157e64e44c9e1", "message": "desrease test run time", "committedDate": "2021-01-15T13:52:12Z", "type": "forcePushed"}, {"oid": "c48608a7db954e49e85ff1478ad31a53e18cc52b", "url": "https://github.com/hazelcast/hazelcast/commit/c48608a7db954e49e85ff1478ad31a53e18cc52b", "message": "Restrore CHM iterator", "committedDate": "2021-01-20T14:18:24Z", "type": "forcePushed"}, {"oid": "acbfa570fd63889d98795221a7f24c3e496f7c75", "url": "https://github.com/hazelcast/hazelcast/commit/acbfa570fd63889d98795221a7f24c3e496f7c75", "message": "Restrore CHM iterator", "committedDate": "2021-01-21T18:46:48Z", "type": "forcePushed"}, {"oid": "ca48a0db87fcdf94704a1ac073ee53669b0e6948", "url": "https://github.com/hazelcast/hazelcast/commit/ca48a0db87fcdf94704a1ac073ee53669b0e6948", "message": "Polishing 4", "committedDate": "2021-01-22T15:22:25Z", "type": "forcePushed"}, {"oid": "7148595cdecab4737f70815dca139c0773366126", "url": "https://github.com/hazelcast/hazelcast/commit/7148595cdecab4737f70815dca139c0773366126", "message": "perf", "committedDate": "2021-01-23T10:23:36Z", "type": "forcePushed"}, {"oid": "9184f00c7ce33b70d1e8ad62264e3188641c3b5c", "url": "https://github.com/hazelcast/hazelcast/commit/9184f00c7ce33b70d1e8ad62264e3188641c3b5c", "message": "Polishing 5", "committedDate": "2021-01-25T11:54:34Z", "type": "forcePushed"}, {"oid": "c165ad5d7867d2930c3e5ea5eba5bee0d50c0f10", "url": "https://github.com/hazelcast/hazelcast/commit/c165ad5d7867d2930c3e5ea5eba5bee0d50c0f10", "message": "factory ifelse", "committedDate": "2021-01-26T12:02:08Z", "type": "forcePushed"}, {"oid": "b09caaaae8cbe09328786ff450e042f29decae55", "url": "https://github.com/hazelcast/hazelcast/commit/b09caaaae8cbe09328786ff450e042f29decae55", "message": "factory ifelse", "committedDate": "2021-01-27T09:08:00Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTQyMTM0OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r565421349", "bodyText": "How can it be negative? Or is it just a sanity check?", "author": "blazember", "createdAt": "2021-01-27T15:51:23Z", "path": "hazelcast/src/main/java/com/hazelcast/map/impl/ExpirationTimeSetter.java", "diffHunk": "@@ -31,81 +28,15 @@\n     private ExpirationTimeSetter() {\n     }\n \n-    /**\n-     * Sets expiration time if statistics are enabled.\n-     */\n-    public static void setExpirationTime(Record record) {\n-        long expirationTime = calculateExpirationTime(record);\n-        record.setExpirationTime(expirationTime);\n-    }\n-\n-    private static long calculateExpirationTime(Record record) {\n-        // calculate TTL expiration time\n-        long ttl = checkedTime(record.getTtl());\n-        long ttlExpirationTime = sumForExpiration(ttl, getLifeStartTime(record));\n-\n-        // calculate MaxIdle expiration time\n-        long maxIdle = checkedTime(record.getMaxIdle());\n-        long maxIdleExpirationTime = sumForExpiration(maxIdle, getIdlenessStartTime(record));\n+    public static long calculateExpirationTime(long ttlMillis, long maxIdleMillis, long now) {\n         // select most nearest expiration time\n-        return Math.min(ttlExpirationTime, maxIdleExpirationTime);\n-    }\n-\n-    /**\n-     * Returns last-access-time of an entry if it was accessed before, otherwise it returns creation-time of the entry.\n-     * This calculation is required for max-idle-seconds expiration, because after first creation of an entry via\n-     * {@link IMap#put}, the {@code lastAccessTime} is zero till the first access.\n-     * Any subsequent get or update operation after first put will increase the {@code lastAccessTime}.\n-     */\n-    public static long getIdlenessStartTime(Record record) {\n-        long lastAccessTime = record.getLastAccessTime();\n-        return lastAccessTime <= 0 ? record.getCreationTime() : lastAccessTime;\n-    }\n-\n-    /**\n-     * Returns last-update-time of an entry if it was updated before, otherwise it returns creation-time of the entry.\n-     * This calculation is required for time-to-live expiration, because after first creation of an entry via\n-     * {@link IMap#put}, the {@code lastUpdateTime} is zero till the first update.\n-     */\n-    public static long getLifeStartTime(Record record) {\n-        long lastUpdateTime = record.getLastUpdateTime();\n-        return lastUpdateTime <= 0 ? record.getCreationTime() : lastUpdateTime;\n-    }\n-\n-    private static long checkedTime(long time) {\n-        return time <= 0 ? Long.MAX_VALUE : time;\n-    }\n-\n-    private static long sumForExpiration(long criteriaTime, long now) {\n-        if (criteriaTime < 0 || now < 0) {\n-            throw new IllegalArgumentException(\"Parameters can not have negative values\");\n+        long expiryTime = Math.min(ttlMillis, maxIdleMillis);\n+        if (expiryTime == Long.MAX_VALUE) {\n+            return expiryTime;\n+        } else {\n+            long nextExpiryTime = expiryTime + now;\n+            return nextExpiryTime <= 0 ? Long.MAX_VALUE : nextExpiryTime;", "originalCommit": "b09caaaae8cbe09328786ff450e042f29decae55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjEyNzE3Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r566127177", "bodyText": "it is for overflows.", "author": "ahmetmircik", "createdAt": "2021-01-28T14:17:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTQyMTM0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTQ4NDM3Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r565484377", "bodyText": "Is it safe to remove the canEvictRecord check? It seems it was protecting against removing an evicted but then readded entry on the backups.", "author": "blazember", "createdAt": "2021-01-27T17:11:22Z", "path": "hazelcast/src/main/java/com/hazelcast/map/impl/operation/EvictBatchBackupOperation.java", "diffHunk": "@@ -63,11 +62,7 @@ protected void runInternal() {\n         }\n \n         for (ExpiredKey expiredKey : expiredKeys) {\n-            Data key = expiredKey.getKey();\n-            Record existingRecord = recordStore.getRecord(key);\n-            if (canEvictRecord(existingRecord, expiredKey)) {\n-                recordStore.evict(key, true);\n-            }\n+            recordStore.evict(expiredKey.getKey(), true);", "originalCommit": "b09caaaae8cbe09328786ff450e042f29decae55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjEzODQ2OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r566138469", "bodyText": "Good point, I will work on a fix after merge, created an issue for it now: #18111", "author": "ahmetmircik", "createdAt": "2021-01-28T14:31:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTQ4NDM3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTQ4ODc1OA==", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r565488758", "bodyText": "What's the reason for removing the size check? Or what was the reason for it? \ud83d\ude04 It was just a shortcut we don't need anymore?", "author": "blazember", "createdAt": "2021-01-27T17:17:31Z", "path": "hazelcast/src/main/java/com/hazelcast/map/impl/operation/MapClearExpiredOperation.java", "diffHunk": "@@ -62,9 +62,10 @@ public void run() throws Exception {\n         PartitionContainer partitionContainer = mapServiceContext.getPartitionContainer(getPartitionId());\n         ConcurrentMap<String, RecordStore> recordStores = partitionContainer.getMaps();\n         boolean backup = !isOwner();\n+        long now = Clock.currentTimeMillis();\n         for (RecordStore recordStore : recordStores.values()) {\n-            if (recordStore.size() > 0 && recordStore.isExpirable()) {\n-                recordStore.evictExpiredEntries(expirationPercentage, backup);\n+            if (recordStore.isExpirable()) {", "originalCommit": "b09caaaae8cbe09328786ff450e042f29decae55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjE0MTEwNA==", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r566141104", "bodyText": "yes no need to it since we have a new isolated expiry system, only checking over it is fine. In most situations it is a redundant check.", "author": "ahmetmircik", "createdAt": "2021-01-28T14:35:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTQ4ODc1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTYyMzg4NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r565623884", "bodyText": "Not sure an int fits here well. I think we can overflow with a long-living, frequently updated entry.", "author": "blazember", "createdAt": "2021-01-27T20:49:55Z", "path": "hazelcast/src/main/java/com/hazelcast/map/impl/record/AbstractRecord.java", "diffHunk": "@@ -16,63 +16,45 @@\n \n package com.hazelcast.map.impl.record;\n \n-import com.hazelcast.query.impl.Metadata;\n import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n \n-import java.util.Objects;\n-\n import static com.hazelcast.internal.nio.Bits.INT_SIZE_IN_BYTES;\n-import static com.hazelcast.internal.nio.Bits.LONG_SIZE_IN_BYTES;\n-import static com.hazelcast.map.impl.record.RecordReaderWriter.DATA_RECORD_READER_WRITER;\n+import static com.hazelcast.internal.util.JVMUtil.OBJECT_HEADER_SIZE;\n+import static com.hazelcast.map.impl.record.RecordReaderWriter.DATA_RECORD_WITH_STATS_READER_WRITER;\n \n /**\n  * @param <V> the type of the value of Record.\n  */\n @SuppressWarnings({\"checkstyle:methodcount\", \"VolatileLongOrDoubleField\"})\n public abstract class AbstractRecord<V> implements Record<V> {\n \n-    private static final int NUMBER_OF_LONGS = 1;\n     private static final int NUMBER_OF_INTS = 6;\n \n-    protected int ttl;\n-    protected int maxIdle;\n-    protected long version;\n-\n+    protected int version;", "originalCommit": "b09caaaae8cbe09328786ff450e042f29decae55", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTYzNjY5Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r565636692", "bodyText": "This if is redundant.", "author": "blazember", "createdAt": "2021-01-27T21:12:51Z", "path": "hazelcast/src/main/java/com/hazelcast/map/impl/record/DataRecordFactory.java", "diffHunk": "@@ -17,31 +17,88 @@\n package com.hazelcast.map.impl.record;\n \n import com.hazelcast.config.CacheDeserializedValues;\n+import com.hazelcast.config.EvictionPolicy;\n import com.hazelcast.config.MapConfig;\n-import com.hazelcast.internal.serialization.SerializationService;\n import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.internal.serialization.SerializationService;\n+import com.hazelcast.map.impl.MapContainer;\n+\n+import javax.annotation.Nonnull;\n+\n+import static com.hazelcast.map.impl.eviction.Evictor.NULL_EVICTOR;\n \n public class DataRecordFactory implements RecordFactory<Data> {\n \n-    private final boolean statisticsEnabled;\n+    private final MapContainer mapContainer;\n     private final SerializationService ss;\n-    private final CacheDeserializedValues cacheDeserializedValues;\n \n-    public DataRecordFactory(MapConfig config, SerializationService ss) {\n+    public DataRecordFactory(MapContainer mapContainer, SerializationService ss) {\n         this.ss = ss;\n-        this.statisticsEnabled = config.isStatisticsEnabled();\n-        this.cacheDeserializedValues = config.getCacheDeserializedValues();\n+        this.mapContainer = mapContainer;\n     }\n \n     @Override\n     public Record<Data> newRecord(Object value) {\n+        MapConfig mapConfig = mapContainer.getMapConfig();\n+        boolean statisticsEnabled = mapConfig.isStatisticsEnabled();\n+        CacheDeserializedValues cacheDeserializedValues = mapConfig.getCacheDeserializedValues();\n+        boolean hasEviction = mapContainer.getEvictor() != NULL_EVICTOR;\n+\n         Data valueData = ss.toData(value);\n \n         switch (cacheDeserializedValues) {\n             case NEVER:\n-                return statisticsEnabled ? new DataRecordWithStats(valueData) : new DataRecord(valueData);\n+                return newSimpleRecord(valueData, mapConfig, statisticsEnabled, hasEviction);\n             default:\n-                return statisticsEnabled ? new CachedDataRecordWithStats(valueData) : new CachedDataRecord(valueData);\n+                return newCachedSimpleRecord(valueData, mapConfig, statisticsEnabled, hasEviction);\n+        }\n+    }\n+\n+    @Nonnull\n+    private Record<Data> newCachedSimpleRecord(Data valueData, MapConfig mapConfig,\n+                                               boolean statisticsEnabled, boolean hasEviction) {\n+        if (!statisticsEnabled && !hasEviction) {", "originalCommit": "b09caaaae8cbe09328786ff450e042f29decae55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjE5MDM5Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r566190392", "bodyText": "fixed.", "author": "ahmetmircik", "createdAt": "2021-01-28T15:37:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTYzNjY5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTYzNjk3NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r565636975", "bodyText": "Same redundancy here.", "author": "blazember", "createdAt": "2021-01-27T21:13:22Z", "path": "hazelcast/src/main/java/com/hazelcast/map/impl/record/DataRecordFactory.java", "diffHunk": "@@ -17,31 +17,88 @@\n package com.hazelcast.map.impl.record;\n \n import com.hazelcast.config.CacheDeserializedValues;\n+import com.hazelcast.config.EvictionPolicy;\n import com.hazelcast.config.MapConfig;\n-import com.hazelcast.internal.serialization.SerializationService;\n import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.internal.serialization.SerializationService;\n+import com.hazelcast.map.impl.MapContainer;\n+\n+import javax.annotation.Nonnull;\n+\n+import static com.hazelcast.map.impl.eviction.Evictor.NULL_EVICTOR;\n \n public class DataRecordFactory implements RecordFactory<Data> {\n \n-    private final boolean statisticsEnabled;\n+    private final MapContainer mapContainer;\n     private final SerializationService ss;\n-    private final CacheDeserializedValues cacheDeserializedValues;\n \n-    public DataRecordFactory(MapConfig config, SerializationService ss) {\n+    public DataRecordFactory(MapContainer mapContainer, SerializationService ss) {\n         this.ss = ss;\n-        this.statisticsEnabled = config.isStatisticsEnabled();\n-        this.cacheDeserializedValues = config.getCacheDeserializedValues();\n+        this.mapContainer = mapContainer;\n     }\n \n     @Override\n     public Record<Data> newRecord(Object value) {\n+        MapConfig mapConfig = mapContainer.getMapConfig();\n+        boolean statisticsEnabled = mapConfig.isStatisticsEnabled();\n+        CacheDeserializedValues cacheDeserializedValues = mapConfig.getCacheDeserializedValues();\n+        boolean hasEviction = mapContainer.getEvictor() != NULL_EVICTOR;\n+\n         Data valueData = ss.toData(value);\n \n         switch (cacheDeserializedValues) {\n             case NEVER:\n-                return statisticsEnabled ? new DataRecordWithStats(valueData) : new DataRecord(valueData);\n+                return newSimpleRecord(valueData, mapConfig, statisticsEnabled, hasEviction);\n             default:\n-                return statisticsEnabled ? new CachedDataRecordWithStats(valueData) : new CachedDataRecord(valueData);\n+                return newCachedSimpleRecord(valueData, mapConfig, statisticsEnabled, hasEviction);\n+        }\n+    }\n+\n+    @Nonnull\n+    private Record<Data> newCachedSimpleRecord(Data valueData, MapConfig mapConfig,\n+                                               boolean statisticsEnabled, boolean hasEviction) {\n+        if (!statisticsEnabled && !hasEviction) {\n+            return new CachedSimpleRecord(valueData);\n+        }\n+\n+        if (statisticsEnabled) {\n+            return new CachedDataRecordWithStats(valueData);\n         }\n+\n+        if (hasEviction) {\n+            if (mapConfig.getEvictionConfig().getEvictionPolicy() == EvictionPolicy.LRU) {\n+                return new CachedSimpleRecordWithLRUEviction(valueData);\n+            }\n+\n+            if (mapConfig.getEvictionConfig().getEvictionPolicy() == EvictionPolicy.LFU) {\n+                return new CachedSimpleRecordWithLFUEviction(valueData);\n+            }\n+        }\n+\n+        return new CachedSimpleRecord(valueData);\n+    }\n+\n+    @Nonnull\n+    private Record<Data> newSimpleRecord(Data valueData, MapConfig mapConfig,\n+                                         boolean statisticsEnabled, boolean hasEviction) {\n+        if (!statisticsEnabled && !hasEviction) {", "originalCommit": "b09caaaae8cbe09328786ff450e042f29decae55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjE5MDQ1NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r566190454", "bodyText": "fixed.", "author": "ahmetmircik", "createdAt": "2021-01-28T15:37:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTYzNjk3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTYzOTIzNg==", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r565639236", "bodyText": "Redundant if.", "author": "blazember", "createdAt": "2021-01-27T21:17:06Z", "path": "hazelcast/src/main/java/com/hazelcast/map/impl/record/ObjectRecordFactory.java", "diffHunk": "@@ -16,25 +16,58 @@\n \n package com.hazelcast.map.impl.record;\n \n+import com.hazelcast.config.EvictionPolicy;\n import com.hazelcast.config.MapConfig;\n import com.hazelcast.internal.serialization.SerializationService;\n+import com.hazelcast.map.impl.MapContainer;\n+\n+import javax.annotation.Nonnull;\n+\n+import static com.hazelcast.map.impl.eviction.Evictor.NULL_EVICTOR;\n \n public class ObjectRecordFactory implements RecordFactory<Object> {\n \n-    private final boolean statisticsEnabled;\n+    private final MapContainer mapContainer;\n     private final SerializationService serializationService;\n \n-    public ObjectRecordFactory(MapConfig config,\n+    public ObjectRecordFactory(MapContainer mapContainer,\n                                SerializationService serializationService) {\n         this.serializationService = serializationService;\n-        this.statisticsEnabled = config.isStatisticsEnabled();\n+        this.mapContainer = mapContainer;\n     }\n \n     @Override\n     public Record<Object> newRecord(Object value) {\n+        MapConfig mapConfig = mapContainer.getMapConfig();\n+        boolean statisticsEnabled = mapConfig.isStatisticsEnabled();\n+        boolean hasEviction = mapContainer.getEvictor() != NULL_EVICTOR;\n+\n         Object objectValue = serializationService.toObject(value);\n-        return statisticsEnabled\n-                ? new ObjectRecordWithStats(objectValue)\n-                : new ObjectRecord(objectValue);\n+\n+        return newRecord(mapConfig, statisticsEnabled, hasEviction, objectValue);\n+    }\n+\n+    @Nonnull\n+    private Record<Object> newRecord(MapConfig mapConfig, boolean statisticsEnabled,\n+                                     boolean hasEviction, Object objectValue) {\n+        if (!statisticsEnabled && !hasEviction) {", "originalCommit": "b09caaaae8cbe09328786ff450e042f29decae55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjE5MDQ5Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r566190492", "bodyText": "fixed.", "author": "ahmetmircik", "createdAt": "2021-01-28T15:37:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTYzOTIzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTY5NDYyMA==", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r565694620", "bodyText": "Can't it break the txn if we freeze max int in version?", "author": "blazember", "createdAt": "2021-01-27T22:54:55Z", "path": "hazelcast/src/main/java/com/hazelcast/map/impl/record/Record.java", "diffHunk": "@@ -197,7 +161,12 @@ default void onAccessSafe(long now) {\n     }\n \n     default void onUpdate(long now) {\n-        setVersion(getVersion() + 1);\n+        int version = getVersion();\n+        if (version < Integer.MAX_VALUE) {", "originalCommit": "b09caaaae8cbe09328786ff450e042f29decae55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjE5NjU1Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r566196556", "bodyText": "Change it to allow overflows, so it is possible that version can also be negative after overflow.", "author": "ahmetmircik", "createdAt": "2021-01-28T15:45:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTY5NDYyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTcwMzY5NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r565703694", "bodyText": "Minor: can be simplified to\nif (version.isLessThan(Versions.V4_2)) {\n  readerWriter  = RU_COMPAT_MAP.get(readerWriter);\n}\nout.writeByte(readerWriter.getId());", "author": "blazember", "createdAt": "2021-01-27T23:15:11Z", "path": "hazelcast/src/main/java/com/hazelcast/map/impl/record/Records.java", "diffHunk": "@@ -16,32 +16,74 @@\n \n package com.hazelcast.map.impl.record;\n \n+import com.hazelcast.internal.cluster.Versions;\n+import com.hazelcast.internal.serialization.Data;\n import com.hazelcast.internal.serialization.SerializationService;\n+import com.hazelcast.map.impl.recordstore.expiry.ExpiryMetadata;\n import com.hazelcast.nio.ObjectDataInput;\n import com.hazelcast.nio.ObjectDataOutput;\n-import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.version.Version;\n \n import java.io.IOException;\n+import java.util.EnumMap;\n+import java.util.Map;\n \n import static com.hazelcast.map.impl.record.Record.NOT_CACHED;\n+import static com.hazelcast.map.impl.record.RecordReaderWriter.DATA_RECORD_READER_WRITER;\n+import static com.hazelcast.map.impl.record.RecordReaderWriter.DATA_RECORD_WITH_STATS_READER_WRITER;\n+import static com.hazelcast.map.impl.record.RecordReaderWriter.SIMPLE_DATA_RECORD_READER_WRITER;\n+import static com.hazelcast.map.impl.record.RecordReaderWriter.SIMPLE_DATA_RECORD_WITH_LFU_EVICTION_READER_WRITER;\n+import static com.hazelcast.map.impl.record.RecordReaderWriter.SIMPLE_DATA_RECORD_WITH_LRU_EVICTION_READER_WRITER;\n import static com.hazelcast.map.impl.record.RecordReaderWriter.getById;\n \n /**\n- * Contains various factory &amp; helper methods for a {@link com.hazelcast.map.impl.record.Record} object.\n+ * Contains various factory &amp; helper methods for a {@link\n+ * com.hazelcast.map.impl.record.Record} object.\n  */\n public final class Records {\n \n+    // RU_COMPAT_4_1\n+    /**\n+     * Maps RecordReaderWriter objects to their 4.1 equivalents. This is used to\n+     * support compatibility between 4.1 and 4.2 during rolling upgrades.\n+     */\n+    private static final Map<RecordReaderWriter, RecordReaderWriter> RU_COMPAT_MAP = createAndInitRuCompatMap();\n+\n     private Records() {\n     }\n \n-    public static void writeRecord(ObjectDataOutput out, Record record, Data dataValue) throws IOException {\n-        out.writeByte(record.getMatchingRecordReaderWriter().getId());\n-        record.getMatchingRecordReaderWriter().writeRecord(out, record, dataValue);\n+    private static EnumMap<RecordReaderWriter, RecordReaderWriter> createAndInitRuCompatMap() {\n+        EnumMap<RecordReaderWriter, RecordReaderWriter> ruCompatMap = new EnumMap<>(RecordReaderWriter.class);\n+        ruCompatMap.put(SIMPLE_DATA_RECORD_READER_WRITER, DATA_RECORD_READER_WRITER);\n+        ruCompatMap.put(SIMPLE_DATA_RECORD_WITH_LFU_EVICTION_READER_WRITER, DATA_RECORD_READER_WRITER);\n+        ruCompatMap.put(SIMPLE_DATA_RECORD_WITH_LRU_EVICTION_READER_WRITER, DATA_RECORD_READER_WRITER);\n+        ruCompatMap.put(DATA_RECORD_READER_WRITER, DATA_RECORD_READER_WRITER);\n+        ruCompatMap.put(DATA_RECORD_WITH_STATS_READER_WRITER, DATA_RECORD_WITH_STATS_READER_WRITER);\n+\n+        assert ruCompatMap.size() == RecordReaderWriter.values().length\n+                : \"Missing enum mapping for RU compatibility\";\n+\n+        return ruCompatMap;\n+    }\n+\n+    public static void writeRecord(ObjectDataOutput out, Record record,\n+                                   Data dataValue, ExpiryMetadata expiryMetadata) throws IOException {\n+        RecordReaderWriter readerWriter = record.getMatchingRecordReaderWriter();\n+        // RU_COMPAT_4_1\n+        Version version = out.getVersion();", "originalCommit": "b09caaaae8cbe09328786ff450e042f29decae55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjE5MDU0Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r566190546", "bodyText": "fixed.", "author": "ahmetmircik", "createdAt": "2021-01-28T15:37:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTcwMzY5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTcwNzg5Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r565707897", "bodyText": "Is it intentionally 0? Shouldn't it be OBJECT_HEADER_SIZE + REFERENCE_COST_IN_BYTES?", "author": "blazember", "createdAt": "2021-01-27T23:25:09Z", "path": "hazelcast/src/main/java/com/hazelcast/map/impl/record/SimpleRecord.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.map.impl.record;\n+\n+import com.hazelcast.config.MapConfig;\n+import com.hazelcast.internal.serialization.Data;\n+\n+import java.util.Objects;\n+\n+import static com.hazelcast.internal.util.JVMUtil.OBJECT_HEADER_SIZE;\n+import static com.hazelcast.internal.util.JVMUtil.REFERENCE_COST_IN_BYTES;\n+import static com.hazelcast.map.impl.record.RecordReaderWriter.SIMPLE_DATA_RECORD_READER_WRITER;\n+\n+/**\n+ * Used when {@link MapConfig#isStatisticsEnabled()} is {@code false}\n+ */\n+@SuppressWarnings({\"checkstyle:methodcount\", \"VolatileLongOrDoubleField\"})\n+class SimpleRecord<V> implements Record<V> {\n+    protected volatile V value;\n+    private int version;\n+\n+    SimpleRecord() {\n+    }\n+\n+    SimpleRecord(V value) {\n+        setValue(value);\n+    }\n+\n+    @Override\n+    public final int getVersion() {\n+        return version;\n+    }\n+\n+    @Override\n+    public final void setVersion(int version) {\n+        this.version = version;\n+    }\n+\n+    @Override\n+    public long getLastAccessTime() {\n+        return UNSET;\n+    }\n+\n+    @Override\n+    public void setLastAccessTime(long lastAccessTime) {\n+    }\n+\n+    @Override\n+    public long getLastUpdateTime() {\n+        return UNSET;\n+    }\n+\n+    @Override\n+    public void setLastUpdateTime(long lastUpdateTime) {\n+    }\n+\n+    @Override\n+    public long getCreationTime() {\n+        return UNSET;\n+    }\n+\n+    @Override\n+    public void setCreationTime(long creationTime) {\n+    }\n+\n+    @Override\n+    public int getHits() {\n+        return UNSET;\n+    }\n+\n+    @Override\n+    public void setHits(int hits) {\n+    }\n+\n+    @Override\n+    public V getValue() {\n+        return value;\n+    }\n+\n+    @Override\n+    public void setValue(V value) {\n+        this.value = value;\n+    }\n+\n+    @Override\n+    public Object getCachedValueUnsafe() {\n+        return Record.NOT_CACHED;\n+    }\n+\n+    @Override\n+    public boolean casCachedValue(Object expectedValue, Object newValue) {\n+        return true;\n+    }\n+\n+    @Override\n+    public final long getSequence() {\n+        return UNSET;\n+    }\n+\n+    @Override\n+    public final void setSequence(long sequence) {\n+    }\n+\n+    @Override\n+    public long getLastStoredTime() {\n+        return UNSET;\n+    }\n+\n+    @Override\n+    public void setLastStoredTime(long lastStoredTime) {\n+    }\n+\n+    @Override\n+    public long getCost() {\n+        if (value instanceof Data) {\n+            return OBJECT_HEADER_SIZE\n+                    + REFERENCE_COST_IN_BYTES + ((Data) value).getHeapCost();\n+        } else {\n+            return 0;", "originalCommit": "b09caaaae8cbe09328786ff450e042f29decae55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjE5MDU4MA==", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r566190580", "bodyText": "For OBJECT in-memory-format we don't calculate cost for now. Add comment to make it clear.", "author": "ahmetmircik", "createdAt": "2021-01-28T15:37:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTcwNzg5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTcxMzI0NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r565713245", "bodyText": "Leftover", "author": "blazember", "createdAt": "2021-01-27T23:33:01Z", "path": "hazelcast/src/main/java/com/hazelcast/map/impl/recordstore/DefaultRecordStore.java", "diffHunk": "@@ -83,13 +84,12 @@\n  */\n @SuppressWarnings({\"checkstyle:methodcount\", \"checkstyle:classfanoutcomplexity\"})\n public class DefaultRecordStore extends AbstractEvictableRecordStore {\n-\n     protected final ILogger logger;\n     protected final RecordStoreLoader recordStoreLoader;\n     protected final MapKeyLoader keyLoader;\n     /**\n      * A collection of futures representing pending completion of the key and\n-     * value loading tasks.\n+     * value loading tasks.ois", "originalCommit": "b09caaaae8cbe09328786ff450e042f29decae55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjE5MDYxMw==", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r566190613", "bodyText": "removed.", "author": "ahmetmircik", "createdAt": "2021-01-28T15:37:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTcxMzI0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTcxODEzNg==", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r565718136", "bodyText": "Minor: we can simply return with the returned value, no need for the if.", "author": "blazember", "createdAt": "2021-01-27T23:42:24Z", "path": "hazelcast/src/main/java/com/hazelcast/map/impl/recordstore/DefaultRecordStore.java", "diffHunk": "@@ -827,72 +858,78 @@ private Object putInternal(Data key, Object newValue, long ttl,\n \n         // Put new record or update existing one.\n         if (record == null) {\n-            putNewRecord(key, oldValue, newValue, ttl, maxIdle, now,\n+            putNewRecord(key, oldValue, newValue, ttl, maxIdle, expiryTime, now,\n                     transactionId, putFromLoad ? LOADED : ADDED, store, backup);\n         } else {\n-            updateRecord(record, key, oldValue, newValue, ttl, maxIdle, now,\n+            updateRecord(record, key, oldValue, newValue, ttl, maxIdle, expiryTime, now,\n                     transactionId, store, countAsAccess, backup);\n         }\n         return oldValue;\n     }\n \n-    private Record getOrLoadRecord(@Nullable Record record, Data key,\n-                                   long now, Address callerAddress, boolean backup) {\n-        if (record != null) {\n-            accessRecord(record, now);\n-            return record;\n+    @SuppressWarnings(\"checkstyle:parameternumber\")\n+    protected Record putNewRecord(Data key, Object oldValue, Object newValue, long ttl,\n+                                  long maxIdle, long expiryTime, long now, UUID transactionId,\n+                                  EntryEventType entryEventType, boolean store,\n+                                  boolean backup) {\n+        Record record = createRecord(newValue, ttl, maxIdle, now);\n+        if (mapDataStore != EMPTY_MAP_DATA_STORE && store) {\n+            putIntoMapStore(record, key, newValue, ttl, maxIdle, now, transactionId);\n         }\n+        storage.put(key, record);\n \n-        Record loadedRecord = loadRecordOrNull(key, backup, callerAddress);\n-        if (loadedRecord != null) {\n-            return loadedRecord;\n-        }\n+        expirySystem.addKeyIfExpirable(key, ttl, maxIdle, expiryTime, now);\n \n-        return null;\n+        if (entryEventType == EntryEventType.LOADED) {\n+            mutationObserver.onLoadRecord(key, record, backup);\n+        } else {\n+            mutationObserver.onPutRecord(key, record, oldValue, backup);\n+        }\n+        return record;\n     }\n \n     @SuppressWarnings(\"checkstyle:parameternumber\")\n     protected void updateRecord(Record record, Data key, Object oldValue, Object newValue,\n-                                long ttl, long maxIdle, long now, UUID transactionId,\n+                                long ttl, long maxIdle, long expiryTime, long now, UUID transactionId,\n                                 boolean store, boolean countAsAccess, boolean backup) {\n         updateStatsOnPut(countAsAccess, now);\n         record.onUpdate(now);\n+\n         if (countAsAccess) {\n             record.onAccess(now);\n         }\n-        setExpirationTimes(record, ttl, maxIdle, mapContainer.getMapConfig());\n-        if (store) {\n-            newValue = putIntoMapStore(record, key, newValue, now, transactionId);\n+\n+        if (mapDataStore != EMPTY_MAP_DATA_STORE && store) {\n+            newValue = putIntoMapStore(record, key, newValue,\n+                    ttl, maxIdle, now, transactionId);\n         }\n+\n         storage.updateRecordValue(key, record, newValue);\n-        markRecordStoreExpirable(ttl, maxIdle);\n+        expirySystem.addKeyIfExpirable(key, ttl, maxIdle, expiryTime, now);\n+\n         mutationObserver.onUpdateRecord(key, record, oldValue, newValue, backup);\n     }\n \n-    @SuppressWarnings(\"checkstyle:parameternumber\")\n-    protected Record putNewRecord(Data key, Object oldValue, Object newValue, long ttlMillis,\n-                                  long maxIdleMillis, long now, UUID transactionId,\n-                                  EntryEventType entryEventType, boolean store,\n-                                  boolean backup) {\n-\n-        Record record = createRecord(key, newValue, ttlMillis, maxIdleMillis, now);\n-        if (store) {\n-            putIntoMapStore(record, key, newValue, now, transactionId);\n+    private Record getOrLoadRecord(@Nullable Record record, Data key,\n+                                   long now, Address callerAddress, boolean backup) {\n+        if (record != null) {\n+            accessRecord(key, record, now);\n+            return record;\n         }\n-        storage.put(key, record);\n-        markRecordStoreExpirable(ttlMillis, maxIdleMillis);\n-        if (entryEventType == EntryEventType.LOADED) {\n-            mutationObserver.onLoadRecord(key, record, backup);\n-        } else {\n-            mutationObserver.onPutRecord(key, record, oldValue, backup);\n+\n+        Record loadedRecord = loadRecordOrNull(key, backup, callerAddress);", "originalCommit": "b09caaaae8cbe09328786ff450e042f29decae55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjE5MDY0Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r566190643", "bodyText": "updated.", "author": "ahmetmircik", "createdAt": "2021-01-28T15:37:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTcxODEzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTcyMDg4NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r565720884", "bodyText": "Maybe these can be moved into TimeUtil?", "author": "blazember", "createdAt": "2021-01-27T23:49:38Z", "path": "hazelcast/src/main/java/com/hazelcast/map/impl/recordstore/expiry/ExpiryMetadata.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.map.impl.recordstore.expiry;\n+\n+import static com.hazelcast.map.impl.record.Record.EPOCH_TIME;\n+import static com.hazelcast.map.impl.record.Record.UNSET;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+\n+public interface ExpiryMetadata {\n+\n+    @SuppressWarnings(\"checkstyle:anoninnerlength\")\n+    ExpiryMetadata NULL = new ExpiryMetadata() {\n+        @Override\n+        public long getTtl() {\n+            return Long.MAX_VALUE;\n+        }\n+\n+        @Override\n+        public int getRawTtl() {\n+            return Integer.MAX_VALUE;\n+        }\n+\n+        @Override\n+        public ExpiryMetadata setTtl(long ttl) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public ExpiryMetadata setRawTtl(int ttl) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public long getMaxIdle() {\n+            return Long.MAX_VALUE;\n+        }\n+\n+        @Override\n+        public int getRawMaxIdle() {\n+            return Integer.MAX_VALUE;\n+        }\n+\n+        @Override\n+        public ExpiryMetadata setMaxIdle(long maxIdle) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public ExpiryMetadata setRawMaxIdle(int maxIdle) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public long getExpirationTime() {\n+            return Long.MAX_VALUE;\n+        }\n+\n+        @Override\n+        public int getRawExpirationTime() {\n+            return Integer.MAX_VALUE;\n+        }\n+\n+        @Override\n+        public ExpiryMetadata setExpirationTime(long expirationTime) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public ExpiryMetadata setRawExpirationTime(int expirationTime) {\n+            throw new UnsupportedOperationException();\n+        }\n+    };\n+\n+\n+    long getTtl();\n+\n+    int getRawTtl();\n+\n+    ExpiryMetadata setTtl(long ttl);\n+\n+    ExpiryMetadata setRawTtl(int ttl);\n+\n+    long getMaxIdle();\n+\n+    int getRawMaxIdle();\n+\n+    ExpiryMetadata setMaxIdle(long maxIdle);\n+\n+    ExpiryMetadata setRawMaxIdle(int maxIdle);\n+\n+    long getExpirationTime();\n+\n+    int getRawExpirationTime();\n+\n+    ExpiryMetadata setExpirationTime(long expirationTime);\n+\n+    ExpiryMetadata setRawExpirationTime(int expirationTime);\n+\n+    default int stripBaseTime(long value) {", "originalCommit": "b09caaaae8cbe09328786ff450e042f29decae55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjE5MDcwMQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r566190701", "bodyText": "i can do it in a later enhancement PR.", "author": "ahmetmircik", "createdAt": "2021-01-28T15:38:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTcyMDg4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTcyNTQzNQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r565725435", "bodyText": "Has this been done?", "author": "blazember", "createdAt": "2021-01-28T00:01:07Z", "path": "hazelcast/src/main/java/com/hazelcast/map/impl/recordstore/expiry/ExpirySystem.java", "diffHunk": "@@ -0,0 +1,361 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.map.impl.recordstore.expiry;\n+\n+import com.hazelcast.config.MapConfig;\n+import com.hazelcast.internal.eviction.ClearExpiredRecordsTask;\n+import com.hazelcast.internal.eviction.ExpiredKey;\n+import com.hazelcast.internal.nearcache.impl.invalidation.InvalidationQueue;\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.internal.util.MapUtil;\n+import com.hazelcast.logging.ILogger;\n+import com.hazelcast.map.impl.ExpirationTimeSetter;\n+import com.hazelcast.map.impl.MapContainer;\n+import com.hazelcast.map.impl.MapServiceContext;\n+import com.hazelcast.map.impl.eviction.Evictor;\n+import com.hazelcast.map.impl.recordstore.RecordStore;\n+import com.hazelcast.spi.impl.NodeEngine;\n+import com.hazelcast.spi.properties.ClusterProperty;\n+import com.hazelcast.spi.properties.HazelcastProperties;\n+import com.hazelcast.spi.properties.HazelcastProperty;\n+\n+import javax.annotation.Nonnull;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.hazelcast.internal.util.ToHeapDataConverter.toHeapData;\n+import static com.hazelcast.map.impl.ExpirationTimeSetter.pickMaxIdleMillis;\n+import static com.hazelcast.map.impl.ExpirationTimeSetter.pickTTLMillis;\n+import static com.hazelcast.map.impl.record.Record.UNSET;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+/**\n+ * This class has all logic to remove expired entries. Expiry reason\n+ * can be ttl or idleness. An instance of this class is created for\n+ * each {@link RecordStore} and it is always accessed by same single thread.\n+ */\n+public class ExpirySystem {\n+    private static final long DEFAULT_EXPIRED_KEY_SCAN_TIMEOUT_NANOS\n+            = TimeUnit.MILLISECONDS.toNanos(1);\n+    private static final String PROP_EXPIRED_KEY_SCAN_TIMEOUT_NANOS\n+            = \"hazelcast.internal.map.expired.key.scan.timeout.nanos\";\n+    private static final HazelcastProperty EXPIRED_KEY_SCAN_TIMEOUT_NANOS\n+            = new HazelcastProperty(PROP_EXPIRED_KEY_SCAN_TIMEOUT_NANOS,\n+            DEFAULT_EXPIRED_KEY_SCAN_TIMEOUT_NANOS, NANOSECONDS);\n+    private static final int ONE_HUNDRED_PERCENT = 100;\n+    private static final int MIN_SCANNABLE_ENTRY_COUNT = 100;\n+\n+    private final long expiryDelayMillis;\n+    private final long expiredKeyScanTimeoutNanos;\n+    private final boolean canPrimaryDriveExpiration;\n+    private final ILogger logger;\n+    private final RecordStore recordStore;\n+    private final MapContainer mapContainer;\n+    private final MapServiceContext mapServiceContext;\n+    private final ClearExpiredRecordsTask clearExpiredRecordsTask;\n+    private final InvalidationQueue<ExpiredKey> expiredKeys = new InvalidationQueue<>();\n+\n+    private Iterator<Map.Entry<Data, ExpiryMetadata>> cachedExpirationIterator;\n+    private Map<Data, ExpiryMetadata> expireTimeByKey;\n+\n+    public ExpirySystem(RecordStore recordStore,\n+                        MapContainer mapContainer,\n+                        MapServiceContext mapServiceContext) {\n+        this.recordStore = recordStore;\n+        this.clearExpiredRecordsTask = mapServiceContext.getExpirationManager().getTask();\n+        NodeEngine nodeEngine = mapServiceContext.getNodeEngine();\n+        this.logger = nodeEngine.getLogger(getClass());\n+        HazelcastProperties hazelcastProperties = nodeEngine.getProperties();\n+        this.expiryDelayMillis = hazelcastProperties.getMillis(ClusterProperty.MAP_EXPIRY_DELAY_SECONDS);\n+        this.mapContainer = mapContainer;\n+        this.mapServiceContext = mapServiceContext;\n+        this.canPrimaryDriveExpiration = mapServiceContext.getClearExpiredRecordsTask().canPrimaryDriveExpiration();\n+        this.expiredKeyScanTimeoutNanos = nodeEngine.getProperties().getNanos(EXPIRED_KEY_SCAN_TIMEOUT_NANOS);\n+    }\n+\n+    public boolean isEmpty() {\n+        return MapUtil.isNullOrEmpty(expireTimeByKey);\n+    }\n+\n+    // this method is overridden\n+    protected Map<Data, ExpiryMetadata> createExpiryTimeByKeyMap() {\n+        // Only one thread can access this class but we\n+        // used CHM here, because its iterator doesn't\n+        // throw ConcurrentModificationException.\n+        return new ConcurrentHashMap<>();\n+    }\n+\n+    // this method is overridden\n+    public void clear() {\n+        Map<Data, ExpiryMetadata> map = getOrCreateExpireTimeByKeyMap(false);\n+        map.clear();\n+    }\n+\n+    protected Map<Data, ExpiryMetadata> getOrCreateExpireTimeByKeyMap(boolean createIfAbsent) {\n+        if (expireTimeByKey != null) {\n+            return expireTimeByKey;\n+        }\n+\n+        if (createIfAbsent) {\n+            expireTimeByKey = createExpiryTimeByKeyMap();\n+            return expireTimeByKey;\n+        }\n+\n+        return Collections.emptyMap();\n+    }\n+\n+    // this method is overridden\n+    protected ExpiryMetadata createExpiryMetadata(long ttlMillis, long maxIdleMillis, long expirationTime) {\n+        return new ExpiryMetadataImpl(ttlMillis, maxIdleMillis, expirationTime);\n+    }\n+\n+    public void addKeyIfExpirable(Data key, long ttl, long maxIdle, long expiryTime, long now) {\n+        if (expiryTime <= 0) {\n+            MapConfig mapConfig = mapContainer.getMapConfig();\n+            long ttlMillis = pickTTLMillis(ttl, mapConfig);\n+            long maxIdleMillis = pickMaxIdleMillis(maxIdle, mapConfig);\n+            long expirationTime = ExpirationTimeSetter.calculateExpirationTime(ttlMillis, maxIdleMillis, now);\n+            addExpirableKey(key, ttlMillis, maxIdleMillis, expirationTime);\n+        } else {\n+            addExpirableKey(key, ttl, maxIdle, expiryTime);\n+        }\n+    }\n+\n+    private void addExpirableKey(Data key, long ttlMillis, long maxIdleMillis, long expirationTime) {\n+        if (expirationTime == Long.MAX_VALUE) {\n+            Map<Data, ExpiryMetadata> map = getOrCreateExpireTimeByKeyMap(false);\n+            if (!map.isEmpty()) {\n+                Data nativeKey = recordStore.getStorage().toBackingDataKeyFormat(key);\n+                callRemove(nativeKey, expireTimeByKey);\n+            }\n+            return;\n+        }\n+\n+        Map<Data, ExpiryMetadata> expireTimeByKey = getOrCreateExpireTimeByKeyMap(true);\n+        ExpiryMetadata expiryMetadata = expireTimeByKey.get(key);\n+        if (expiryMetadata == null) {\n+            expiryMetadata = createExpiryMetadata(ttlMillis, maxIdleMillis, expirationTime);\n+            Data nativeKey = recordStore.getStorage().toBackingDataKeyFormat(key);\n+            expireTimeByKey.put(nativeKey, expiryMetadata);\n+        } else {\n+            expiryMetadata.setTtl(ttlMillis)\n+                    .setMaxIdle(maxIdleMillis)\n+                    .setExpirationTime(expirationTime);\n+        }\n+\n+        mapServiceContext.getExpirationManager().scheduleExpirationTask();\n+    }\n+\n+    public long calculateExpirationTime(long ttl, long maxIdle, long now) {\n+        MapConfig mapConfig = mapContainer.getMapConfig();\n+        long ttlMillis = pickTTLMillis(ttl, mapConfig);\n+        long maxIdleMillis = pickMaxIdleMillis(maxIdle, mapConfig);\n+        return ExpirationTimeSetter.calculateExpirationTime(ttlMillis, maxIdleMillis, now);\n+    }\n+\n+    public void removeKeyFromExpirySystem(Data key) {\n+        Map<Data, ExpiryMetadata> expireTimeByKey = getOrCreateExpireTimeByKeyMap(false);\n+        if (expireTimeByKey.isEmpty()) {\n+            return;\n+        }\n+        callRemove(key, expireTimeByKey);\n+    }\n+\n+    // TODO add test for this.", "originalCommit": "b09caaaae8cbe09328786ff450e042f29decae55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjE5MDc0OA==", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r566190748", "bodyText": "yes we have a test for it here: ExpirationTimeTest#testExpirationTime_withMaxIdleTime_afterMultipleAccesses", "author": "ahmetmircik", "createdAt": "2021-01-28T15:38:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTcyNTQzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTczMTIzMQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r565731231", "bodyText": "To skip the records that should have already been removed by the expiry logic if it was run since the expiry time of the record elapsed?", "author": "blazember", "createdAt": "2021-01-28T00:16:52Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/scan/MapScanExecIterator.java", "diffHunk": "@@ -121,7 +121,8 @@ private void advance0() {\n             while (currentRecordStoreIterator.hasNext()) {\n                 Map.Entry<Data, Record<Object>> entry = currentRecordStoreIterator.next();\n \n-                if (!currentRecordStore.isExpired(entry.getValue(), now, false)) {\n+                // TODO why do we have expiry check here", "originalCommit": "b09caaaae8cbe09328786ff450e042f29decae55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjE5MDc5Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r566190797", "bodyText": "record-store has a forEach method for that, it may be used there.\nupdated todo comment.", "author": "ahmetmircik", "createdAt": "2021-01-28T15:38:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTczMTIzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTczMTkyNw==", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r565731927", "bodyText": "Is it intentionally remained QuickTest?", "author": "blazember", "createdAt": "2021-01-28T00:18:41Z", "path": "hazelcast/src/test/java/com/hazelcast/internal/eviction/MapExpirationStressTest.java", "diffHunk": "@@ -43,7 +43,7 @@\n import static com.hazelcast.test.backup.TestBackupUtils.assertBackupSizeEventually;\n \n @RunWith(HazelcastSerialClassRunner.class)\n-@Category(NightlyTest.class)\n+@Category(QuickTest.class)", "originalCommit": "b09caaaae8cbe09328786ff450e042f29decae55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjE5MDgzMQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r566190831", "bodyText": "put into NightlyTest back.", "author": "ahmetmircik", "createdAt": "2021-01-28T15:38:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTczMTkyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTczMjI5OA==", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r565732298", "bodyText": "Leftover?", "author": "blazember", "createdAt": "2021-01-28T00:19:44Z", "path": "hazelcast/src/test/java/com/hazelcast/map/EntryCostEstimatorTest.java", "diffHunk": "@@ -33,6 +34,7 @@\n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertTrue;\n \n+@Ignore", "originalCommit": "b09caaaae8cbe09328786ff450e042f29decae55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjE5MDg3OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r566190879", "bodyText": "Removed @Ignore", "author": "ahmetmircik", "createdAt": "2021-01-28T15:38:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTczMjI5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTczMjY5OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r565732699", "bodyText": "Are these intentionally kept scaled down?", "author": "blazember", "createdAt": "2021-01-28T00:20:52Z", "path": "hazelcast/src/test/java/com/hazelcast/map/ExpirationTimeTest.java", "diffHunk": "@@ -140,25 +140,26 @@ public void test_replicated_entries_view_equal_after_cluster_scale_up() {\n \n         HazelcastInstance node1 = factory.newHazelcastInstance(config);\n         IMap<Integer, Integer> map = node1.getMap(mapName);\n-        for (int i = 0; i < 10; i++) {\n+        for (int i = 0; i < 1; i++) {", "originalCommit": "b09caaaae8cbe09328786ff450e042f29decae55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjE5MDkyMg==", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r566190922", "bodyText": "restored original version.", "author": "ahmetmircik", "createdAt": "2021-01-28T15:38:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTczMjY5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTczMzQ3Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r565733473", "bodyText": "Leftover", "author": "blazember", "createdAt": "2021-01-28T00:22:13Z", "path": "hazelcast/src/test/java/com/hazelcast/map/impl/mapstore/writebehind/MapStoreWriteBehindTest.java", "diffHunk": "@@ -80,6 +80,7 @@\n     public void testOneMemberWriteBehindWithMaxIdle() {\n         final EventBasedMapStore testMapStore = new EventBasedMapStore();\n         Config config = newConfig(testMapStore, 5, InitialLoadMode.EAGER);\n+//        Config config = getConfig();", "originalCommit": "b09caaaae8cbe09328786ff450e042f29decae55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjE5MDk2MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r566190961", "bodyText": "yes, deleted it.", "author": "ahmetmircik", "createdAt": "2021-01-28T15:38:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTczMzQ3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTczNDgwNw==", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r565734807", "bodyText": "Leftover", "author": "blazember", "createdAt": "2021-01-28T00:23:44Z", "path": "hazelcast/src/test/java/com/hazelcast/map/impl/recordstore/LazyEvictableEntryViewTest.java", "diffHunk": "@@ -77,6 +84,8 @@ public void test_getValue() {\n     }\n \n     @Test\n+    @Ignore\n+    // TODO fixme", "originalCommit": "b09caaaae8cbe09328786ff450e042f29decae55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjE5MTAwMA==", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r566191000", "bodyText": "yes, fixed.", "author": "ahmetmircik", "createdAt": "2021-01-28T15:38:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTczNDgwNw=="}], "type": "inlineReview"}, {"oid": "51681b0c10671051246e8b0bd664bba77125373b", "url": "https://github.com/hazelcast/hazelcast/commit/51681b0c10671051246e8b0bd664bba77125373b", "message": "Zoltan reviews", "committedDate": "2021-01-28T15:36:57Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjI0NTU3Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r566245572", "bodyText": "Maybe keeping the math with the comments we had before would be better.", "author": "blazember", "createdAt": "2021-01-28T16:47:17Z", "path": "hazelcast/src/test/java/com/hazelcast/map/EntryCostEstimatorTest.java", "diffHunk": "@@ -39,22 +39,29 @@\n         extends HazelcastTestSupport {\n \n     protected TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(2);\n-    // the JVM-independent portion of the cost of Integer key + Long value record is 104 bytes\n-    // (without taking into account 8 references to key, record and value objects)\n-    private static final int JVM_INDEPENDENT_ENTRY_COST_IN_BYTES = 100;\n-    // JVM-dependent total cost of entry\n-    private static final int ENTRY_COST_IN_BYTES = JVM_INDEPENDENT_ENTRY_COST_IN_BYTES + 8 * REFERENCE_COST_IN_BYTES;\n+\n+    public static final int ENTRY_COST_IN_BYTES = getExpectedCostInBytes();\n+\n+    private static int getExpectedCostInBytes() {\n+        if (JVMUtil.is32bitJVM() && JVMUtil.isCompressedOops()) {\n+            return 140;", "originalCommit": "dfbcd8e2f8ba2f3f84c850080a1d6df991f817a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjY4NzQ1OA==", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r566687458", "bodyText": "The math is highly dependent to internals and this makes it hard to express correctly after refactorings/changes. I found the values here by logging entry costs, this seemed easy to me.", "author": "ahmetmircik", "createdAt": "2021-01-29T09:27:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjI0NTU3Mg=="}], "type": "inlineReview"}, {"oid": "31d6287bba2d28a46e1f27708250158f34f402ef", "url": "https://github.com/hazelcast/hazelcast/commit/31d6287bba2d28a46e1f27708250158f34f402ef", "message": "remove duplicate method", "committedDate": "2021-01-29T09:32:06Z", "type": "forcePushed"}, {"oid": "b401991bc204d545f557bb2bf9cd8608237e7ca9", "url": "https://github.com/hazelcast/hazelcast/commit/b401991bc204d545f557bb2bf9cd8608237e7ca9", "message": "remove duplicate method 2", "committedDate": "2021-01-29T19:09:28Z", "type": "forcePushed"}, {"oid": "4ad19b6d763861a7b1f704c6b43da775c985a23c", "url": "https://github.com/hazelcast/hazelcast/commit/4ad19b6d763861a7b1f704c6b43da775c985a23c", "message": "fix checkstyle", "committedDate": "2021-02-03T09:17:49Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTMzNzA4Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r569337086", "bodyText": "In which conditions operationTTLMillis is negative?", "author": "petrpleshachkov", "createdAt": "2021-02-03T11:26:48Z", "path": "hazelcast/src/main/java/com/hazelcast/map/impl/ExpirationTimeSetter.java", "diffHunk": "@@ -115,51 +48,41 @@ public static void setExpirationTimes(Record record, long operationTTLMillis,\n      * @param mapConfig          used to get configured TTL\n      * @return TTL value in millis to set to record\n      */\n-    private static long pickTTLMillis(long operationTTLMillis, MapConfig mapConfig) {\n-        // if user set operationTTLMillis when calling operation, use it\n-        if (operationTTLMillis > 0) {\n-            return checkedTime(operationTTLMillis);\n+    public static long pickTTLMillis(long operationTTLMillis, MapConfig mapConfig) {\n+        if (operationTTLMillis < 0 && mapConfig.getTimeToLiveSeconds() == 0) {", "originalCommit": "4ad19b6d763861a7b1f704c6b43da775c985a23c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDAxOTAwMA==", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r570019000", "bodyText": "it is negative for regular put", "author": "ahmetmircik", "createdAt": "2021-02-04T08:08:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTMzNzA4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTM1MDc5Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r569350797", "bodyText": "Not sure that I understood this change. Can you please elaborate a bit?", "author": "petrpleshachkov", "createdAt": "2021-02-03T11:49:50Z", "path": "hazelcast/src/main/java/com/hazelcast/map/impl/operation/PutIfAbsentOperation.java", "diffHunk": "@@ -63,7 +63,7 @@ public Object getResponse() {\n \n     @Override\n     public boolean shouldBackup() {\n-        return successful && recordStore.getRecord(dataKey) != null;\n+        return successful && super.shouldBackup();", "originalCommit": "4ad19b6d763861a7b1f704c6b43da775c985a23c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDAxOTY0OA==", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r570019648", "bodyText": "called super's backup-condition since they both same.", "author": "ahmetmircik", "createdAt": "2021-02-04T08:09:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTM1MDc5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTM1MTYxMA==", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r569351610", "bodyText": "Why we're not considering this case anymore?", "author": "petrpleshachkov", "createdAt": "2021-02-03T11:51:10Z", "path": "hazelcast/src/main/java/com/hazelcast/map/impl/proxy/MapProxySupport.java", "diffHunk": "@@ -1314,9 +1313,6 @@ public void addIndex(IndexConfig indexConfig) {\n \n     @Override\n     public LocalMapStats getLocalMapStats() {\n-        if (!mapConfig.isStatisticsEnabled()) {", "originalCommit": "4ad19b6d763861a7b1f704c6b43da775c985a23c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDAyMDc2Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r570020763", "bodyText": "Independent of it is enabled or not-enabled, we always collect record-store-level stats and no point to hide this.", "author": "ahmetmircik", "createdAt": "2021-02-04T08:11:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTM1MTYxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTM1MjM3NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r569352375", "bodyText": "We have metadata store only in HD case. Will it work in the on-heap scenario?", "author": "petrpleshachkov", "createdAt": "2021-02-03T11:52:28Z", "path": "hazelcast/src/main/java/com/hazelcast/map/impl/query/PartitionScanRunner.java", "diffHunk": "@@ -101,7 +100,7 @@ public void accept(Data key, Record record) {\n \n                 queryEntry.init(ss, key, value, extractors);\n                 queryEntry.setRecord(record);\n-                queryEntry.setMetadata(PartitionScanRunner.this.getMetadataFromRecord(recordStore, key, record));\n+                queryEntry.setMetadata(recordStore.getMetadataStore().get(key));", "originalCommit": "4ad19b6d763861a7b1f704c6b43da775c985a23c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDAyMTA0OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r570021049", "bodyText": "For now, we also store HD metadata on heap, so there should be no issue with this.", "author": "ahmetmircik", "createdAt": "2021-02-04T08:12:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTM1MjM3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTM2NTExMw==", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r569365113", "bodyText": "We replace long with int here. Is int enough?", "author": "petrpleshachkov", "createdAt": "2021-02-03T12:14:41Z", "path": "hazelcast/src/main/java/com/hazelcast/map/impl/record/Record.java", "diffHunk": "@@ -66,9 +65,9 @@\n      */\n     long getCost();\n \n-    long getVersion();\n+    int getVersion();", "originalCommit": "4ad19b6d763861a7b1f704c6b43da775c985a23c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDAyNzc2Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r570027766", "bodyText": "it should be ok. Reasoning: if version is updated in every millisecond, it will take nearly ~50 days to hit the same value.", "author": "ahmetmircik", "createdAt": "2021-02-04T08:23:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTM2NTExMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTM2NTc2OA==", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r569365768", "bodyText": "Is it for backward compatibility?", "author": "petrpleshachkov", "createdAt": "2021-02-03T12:15:46Z", "path": "hazelcast/src/main/java/com/hazelcast/map/impl/record/RecordReaderWriter.java", "diffHunk": "@@ -16,78 +16,165 @@\n \n package com.hazelcast.map.impl.record;\n \n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.map.impl.recordstore.expiry.ExpiryMetadata;\n import com.hazelcast.nio.ObjectDataInput;\n import com.hazelcast.nio.ObjectDataOutput;\n-import com.hazelcast.internal.serialization.Data;\n \n import java.io.IOException;\n \n import static com.hazelcast.internal.nio.IOUtil.readData;\n import static com.hazelcast.internal.nio.IOUtil.writeData;\n+import static com.hazelcast.map.impl.record.Record.UNSET;\n \n /**\n  * Used when reading and writing records\n  * for backup and replication operations\n  */\n public enum RecordReaderWriter {\n+    // RU_COMPAT_4_1\n+    // Remove enum DATA_RECORD_READER_WRITER in 4.3\n     DATA_RECORD_READER_WRITER(TypeId.DATA_RECORD_TYPE_ID) {\n         @Override\n-        void writeRecord(ObjectDataOutput out,\n-                         Record record, Data dataValue) throws IOException {\n+        void writeRecord(ObjectDataOutput out, Record record, Data dataValue,\n+                         ExpiryMetadata expiryMetadata) throws IOException {\n             writeData(out, dataValue);\n-            out.writeInt(record.getRawTtl());\n-            out.writeInt(record.getRawMaxIdle());\n-            out.writeInt(record.getRawCreationTime());\n-            out.writeInt(record.getRawLastAccessTime());\n-            out.writeInt(record.getRawLastUpdateTime());\n+            out.writeInt(expiryMetadata.getRawTtl());\n+            out.writeInt(expiryMetadata.getRawMaxIdle());\n+            out.writeInt(UNSET);", "originalCommit": "4ad19b6d763861a7b1f704c6b43da775c985a23c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDAyMjk3OA==", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r570022978", "bodyText": "Good point, i have updated this part and have removed value UNSET. If cluster version is 4.1, we need to create records that remote server can meaningfully understand, to have this, i have updated RecordFactorys, now it is creating 4.1 friendly records.", "author": "ahmetmircik", "createdAt": "2021-02-04T08:15:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTM2NTc2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTQyNTE0Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r569425147", "bodyText": "Please add Javadoc", "author": "petrpleshachkov", "createdAt": "2021-02-03T13:47:38Z", "path": "hazelcast/src/main/java/com/hazelcast/map/impl/recordstore/expiry/ExpiryReason.java", "diffHunk": "@@ -0,0 +1,23 @@\n+/*\n+ * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.map.impl.recordstore.expiry;\n+", "originalCommit": "4ad19b6d763861a7b1f704c6b43da775c985a23c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDAyMzAyMw==", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r570023023", "bodyText": "done.", "author": "ahmetmircik", "createdAt": "2021-02-04T08:15:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTQyNTE0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTQyODc0MA==", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r569428740", "bodyText": "What if the iterator has not next element?", "author": "petrpleshachkov", "createdAt": "2021-02-03T13:52:38Z", "path": "hazelcast/src/main/java/com/hazelcast/map/impl/recordstore/expiry/ExpirySystem.java", "diffHunk": "@@ -0,0 +1,360 @@\n+/*\n+ * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.map.impl.recordstore.expiry;\n+\n+import com.hazelcast.config.MapConfig;\n+import com.hazelcast.internal.eviction.ClearExpiredRecordsTask;\n+import com.hazelcast.internal.eviction.ExpiredKey;\n+import com.hazelcast.internal.nearcache.impl.invalidation.InvalidationQueue;\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.internal.util.MapUtil;\n+import com.hazelcast.logging.ILogger;\n+import com.hazelcast.map.impl.ExpirationTimeSetter;\n+import com.hazelcast.map.impl.MapContainer;\n+import com.hazelcast.map.impl.MapServiceContext;\n+import com.hazelcast.map.impl.eviction.Evictor;\n+import com.hazelcast.map.impl.recordstore.RecordStore;\n+import com.hazelcast.spi.impl.NodeEngine;\n+import com.hazelcast.spi.properties.ClusterProperty;\n+import com.hazelcast.spi.properties.HazelcastProperties;\n+import com.hazelcast.spi.properties.HazelcastProperty;\n+\n+import javax.annotation.Nonnull;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.hazelcast.internal.util.ToHeapDataConverter.toHeapData;\n+import static com.hazelcast.map.impl.ExpirationTimeSetter.pickMaxIdleMillis;\n+import static com.hazelcast.map.impl.ExpirationTimeSetter.pickTTLMillis;\n+import static com.hazelcast.map.impl.record.Record.UNSET;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+/**\n+ * This class has all logic to remove expired entries. Expiry reason\n+ * can be ttl or idleness. An instance of this class is created for\n+ * each {@link RecordStore} and it is always accessed by same single thread.\n+ */\n+public class ExpirySystem {\n+    private static final long DEFAULT_EXPIRED_KEY_SCAN_TIMEOUT_NANOS\n+            = TimeUnit.MILLISECONDS.toNanos(1);\n+    private static final String PROP_EXPIRED_KEY_SCAN_TIMEOUT_NANOS\n+            = \"hazelcast.internal.map.expired.key.scan.timeout.nanos\";\n+    private static final HazelcastProperty EXPIRED_KEY_SCAN_TIMEOUT_NANOS\n+            = new HazelcastProperty(PROP_EXPIRED_KEY_SCAN_TIMEOUT_NANOS,\n+            DEFAULT_EXPIRED_KEY_SCAN_TIMEOUT_NANOS, NANOSECONDS);\n+    private static final int ONE_HUNDRED_PERCENT = 100;\n+    private static final int MIN_SCANNABLE_ENTRY_COUNT = 100;\n+\n+    private final long expiryDelayMillis;\n+    private final long expiredKeyScanTimeoutNanos;\n+    private final boolean canPrimaryDriveExpiration;\n+    private final ILogger logger;\n+    private final RecordStore recordStore;\n+    private final MapContainer mapContainer;\n+    private final MapServiceContext mapServiceContext;\n+    private final ClearExpiredRecordsTask clearExpiredRecordsTask;\n+    private final InvalidationQueue<ExpiredKey> expiredKeys = new InvalidationQueue<>();\n+\n+    private Iterator<Map.Entry<Data, ExpiryMetadata>> cachedExpirationIterator;\n+    private Map<Data, ExpiryMetadata> expireTimeByKey;\n+\n+    public ExpirySystem(RecordStore recordStore,\n+                        MapContainer mapContainer,\n+                        MapServiceContext mapServiceContext) {\n+        this.recordStore = recordStore;\n+        this.clearExpiredRecordsTask = mapServiceContext.getExpirationManager().getTask();\n+        NodeEngine nodeEngine = mapServiceContext.getNodeEngine();\n+        this.logger = nodeEngine.getLogger(getClass());\n+        HazelcastProperties hazelcastProperties = nodeEngine.getProperties();\n+        this.expiryDelayMillis = hazelcastProperties.getMillis(ClusterProperty.MAP_EXPIRY_DELAY_SECONDS);\n+        this.mapContainer = mapContainer;\n+        this.mapServiceContext = mapServiceContext;\n+        this.canPrimaryDriveExpiration = mapServiceContext.getClearExpiredRecordsTask().canPrimaryDriveExpiration();\n+        this.expiredKeyScanTimeoutNanos = nodeEngine.getProperties().getNanos(EXPIRED_KEY_SCAN_TIMEOUT_NANOS);\n+    }\n+\n+    public boolean isEmpty() {\n+        return MapUtil.isNullOrEmpty(expireTimeByKey);\n+    }\n+\n+    // this method is overridden\n+    protected Map<Data, ExpiryMetadata> createExpiryTimeByKeyMap() {\n+        // Only one thread can access this class but we\n+        // used CHM here, because its iterator doesn't\n+        // throw ConcurrentModificationException.\n+        return new ConcurrentHashMap<>();\n+    }\n+\n+    // this method is overridden\n+    public void clear() {\n+        Map<Data, ExpiryMetadata> map = getOrCreateExpireTimeByKeyMap(false);\n+        map.clear();\n+    }\n+\n+    protected Map<Data, ExpiryMetadata> getOrCreateExpireTimeByKeyMap(boolean createIfAbsent) {\n+        if (expireTimeByKey != null) {\n+            return expireTimeByKey;\n+        }\n+\n+        if (createIfAbsent) {\n+            expireTimeByKey = createExpiryTimeByKeyMap();\n+            return expireTimeByKey;\n+        }\n+\n+        return Collections.emptyMap();\n+    }\n+\n+    // this method is overridden\n+    protected ExpiryMetadata createExpiryMetadata(long ttlMillis, long maxIdleMillis, long expirationTime) {\n+        return new ExpiryMetadataImpl(ttlMillis, maxIdleMillis, expirationTime);\n+    }\n+\n+    public void addKeyIfExpirable(Data key, long ttl, long maxIdle, long expiryTime, long now) {\n+        if (expiryTime <= 0) {\n+            MapConfig mapConfig = mapContainer.getMapConfig();\n+            long ttlMillis = pickTTLMillis(ttl, mapConfig);\n+            long maxIdleMillis = pickMaxIdleMillis(maxIdle, mapConfig);\n+            long expirationTime = ExpirationTimeSetter.calculateExpirationTime(ttlMillis, maxIdleMillis, now);\n+            addExpirableKey(key, ttlMillis, maxIdleMillis, expirationTime);\n+        } else {\n+            addExpirableKey(key, ttl, maxIdle, expiryTime);\n+        }\n+    }\n+\n+    private void addExpirableKey(Data key, long ttlMillis, long maxIdleMillis, long expirationTime) {\n+        if (expirationTime == Long.MAX_VALUE) {\n+            Map<Data, ExpiryMetadata> map = getOrCreateExpireTimeByKeyMap(false);\n+            if (!map.isEmpty()) {\n+                Data nativeKey = recordStore.getStorage().toBackingDataKeyFormat(key);\n+                callRemove(nativeKey, expireTimeByKey);\n+            }\n+            return;\n+        }\n+\n+        Map<Data, ExpiryMetadata> expireTimeByKey = getOrCreateExpireTimeByKeyMap(true);\n+        ExpiryMetadata expiryMetadata = expireTimeByKey.get(key);\n+        if (expiryMetadata == null) {\n+            expiryMetadata = createExpiryMetadata(ttlMillis, maxIdleMillis, expirationTime);\n+            Data nativeKey = recordStore.getStorage().toBackingDataKeyFormat(key);\n+            expireTimeByKey.put(nativeKey, expiryMetadata);\n+        } else {\n+            expiryMetadata.setTtl(ttlMillis)\n+                    .setMaxIdle(maxIdleMillis)\n+                    .setExpirationTime(expirationTime);\n+        }\n+\n+        mapServiceContext.getExpirationManager().scheduleExpirationTask();\n+    }\n+\n+    public long calculateExpirationTime(long ttl, long maxIdle, long now) {\n+        MapConfig mapConfig = mapContainer.getMapConfig();\n+        long ttlMillis = pickTTLMillis(ttl, mapConfig);\n+        long maxIdleMillis = pickMaxIdleMillis(maxIdle, mapConfig);\n+        return ExpirationTimeSetter.calculateExpirationTime(ttlMillis, maxIdleMillis, now);\n+    }\n+\n+    public void removeKeyFromExpirySystem(Data key) {\n+        Map<Data, ExpiryMetadata> expireTimeByKey = getOrCreateExpireTimeByKeyMap(false);\n+        if (expireTimeByKey.isEmpty()) {\n+            return;\n+        }\n+        callRemove(key, expireTimeByKey);\n+    }\n+\n+    public void extendExpiryTime(Data dataKey, long now) {\n+        if (isEmpty()) {\n+            return;\n+        }\n+\n+        Map<Data, ExpiryMetadata> expireTimeByKey = getOrCreateExpireTimeByKeyMap(false);\n+        if (expireTimeByKey.isEmpty()) {\n+            return;\n+        }\n+\n+        ExpiryMetadata expiryMetadata = getExpiryMetadataForExpiryCheck(dataKey, expireTimeByKey);\n+        if (expiryMetadata == null\n+                || expiryMetadata.getMaxIdle() == Long.MAX_VALUE) {\n+            return;\n+        }\n+\n+        long expirationTime = ExpirationTimeSetter.calculateExpirationTime(expiryMetadata.getTtl(),\n+                expiryMetadata.getMaxIdle(), now);\n+        expiryMetadata.setExpirationTime(expirationTime);\n+    }\n+\n+    public ExpiryReason hasExpired(Data key, long now, boolean backup) {\n+        Map<Data, ExpiryMetadata> expireTimeByKey = getOrCreateExpireTimeByKeyMap(false);\n+        if (expireTimeByKey.isEmpty()) {\n+            return ExpiryReason.NOT_EXPIRED;\n+        }\n+        ExpiryMetadata expiryMetadata = getExpiryMetadataForExpiryCheck(key, expireTimeByKey);\n+        return hasExpired(expiryMetadata, now, backup);\n+    }\n+\n+    private ExpiryReason hasExpired(ExpiryMetadata expiryMetadata, long now, boolean backup) {\n+        if (expiryMetadata == null) {\n+            return ExpiryReason.NOT_EXPIRED;\n+        }\n+\n+        long nextExpirationTime = backup\n+                ? expiryMetadata.getExpirationTime() + expiryDelayMillis\n+                : expiryMetadata.getExpirationTime();\n+\n+        if (nextExpirationTime > now) {\n+            return ExpiryReason.NOT_EXPIRED;\n+        }\n+\n+        ExpiryReason expiryReason = expiryMetadata.getTtl() > expiryMetadata.getMaxIdle()\n+                ? ExpiryReason.IDLENESS : ExpiryReason.TTL;\n+        if (backup && canPrimaryDriveExpiration\n+                && expiryReason == ExpiryReason.IDLENESS) {\n+            return ExpiryReason.NOT_EXPIRED;\n+        }\n+        return expiryReason;\n+    }\n+\n+    public InvalidationQueue<ExpiredKey> getExpiredKeys() {\n+        return expiredKeys;\n+    }\n+\n+    @Nonnull\n+    public ExpiryMetadata getExpiredMetadata(Data key) {\n+        ExpiryMetadata expiryMetadata = getOrCreateExpireTimeByKeyMap(false).get(key);\n+        return expiryMetadata != null ? expiryMetadata : ExpiryMetadata.NULL;\n+    }\n+\n+    @SuppressWarnings(\"checkstyle:magicnumber\")\n+    public void evictExpiredEntries(int percentage, long now, boolean backup) {\n+        Map<Data, ExpiryMetadata> expireTimeByKey = getOrCreateExpireTimeByKeyMap(false);\n+        if (expireTimeByKey.isEmpty()) {\n+            return;\n+        }\n+\n+        // Find max scannable key count\n+        int expirableKeysMapSize = expireTimeByKey.size();\n+        int keyCountInPercentage = (int) (1D * expirableKeysMapSize * percentage / ONE_HUNDRED_PERCENT);\n+        int maxScannableKeyCount = Math.max(MIN_SCANNABLE_ENTRY_COUNT, keyCountInPercentage);\n+\n+        scanAndEvictExpiredKeys(maxScannableKeyCount, now, backup);\n+\n+        accumulateOrSendExpiredKey(null);\n+    }\n+\n+    /**\n+     * Get cachedExpirationIterator or init it if it has no next entry.\n+     */\n+    private Iterator<Map.Entry<Data, ExpiryMetadata>> getOrInitCachedIterator() {\n+        if (cachedExpirationIterator == null || !cachedExpirationIterator.hasNext()) {\n+            cachedExpirationIterator = initIteratorOf(expireTimeByKey);\n+        }\n+\n+        return cachedExpirationIterator;\n+    }\n+\n+    private void scanAndEvictExpiredKeys(int maxScannableKeyCount, long now, boolean backup) {\n+        // Scan to find expired keys.\n+        long scanLoopStartNanos = System.nanoTime();\n+        List expiredKeyExpiryReasonList = new ArrayList<>();\n+        int scannedKeyCount = 0;\n+        int expiredKeyCount = 0;\n+        do {\n+            Map.Entry<Data, ExpiryMetadata> entry = getOrInitCachedIterator().next();", "originalCommit": "4ad19b6d763861a7b1f704c6b43da775c985a23c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDAyMzg5NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17977#discussion_r570023895", "bodyText": "If map is empty, we return immediately before coming that line, so there should be no problem.", "author": "ahmetmircik", "createdAt": "2021-02-04T08:17:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTQyODc0MA=="}], "type": "inlineReview"}, {"oid": "6d1a713e86ad746893bdf5703cd8772bbe54c967", "url": "https://github.com/hazelcast/hazelcast/commit/6d1a713e86ad746893bdf5703cd8772bbe54c967", "message": "Address Petr comments", "committedDate": "2021-02-03T20:01:41Z", "type": "forcePushed"}, {"oid": "75eb1bc07b0eff0ab6880b13517f5810d3d88caf", "url": "https://github.com/hazelcast/hazelcast/commit/75eb1bc07b0eff0ab6880b13517f5810d3d88caf", "message": "HD Simple data record for cluster version\nextend expiryTime for get requests", "committedDate": "2021-02-04T08:05:01Z", "type": "commit"}, {"oid": "1a95ca6703e0477d477efbc085573f32ad34240e", "url": "https://github.com/hazelcast/hazelcast/commit/1a95ca6703e0477d477efbc085573f32ad34240e", "message": "fix hd", "committedDate": "2021-02-04T08:05:01Z", "type": "commit"}, {"oid": "7fa84736eb6abb04e3848648958330fc00bd364b", "url": "https://github.com/hazelcast/hazelcast/commit/7fa84736eb6abb04e3848648958330fc00bd364b", "message": "fix expiry-system", "committedDate": "2021-02-04T08:05:01Z", "type": "commit"}, {"oid": "b2e0abef3fcdc19ba50949cf96324f49d504d5e9", "url": "https://github.com/hazelcast/hazelcast/commit/b2e0abef3fcdc19ba50949cf96324f49d504d5e9", "message": "wip overridable iterator", "committedDate": "2021-02-04T08:05:01Z", "type": "commit"}, {"oid": "7ca530c05cb9986aef95bd7fe63e627ff10e6fe5", "url": "https://github.com/hazelcast/hazelcast/commit/7ca530c05cb9986aef95bd7fe63e627ff10e6fe5", "message": "wip hd fixes", "committedDate": "2021-02-04T08:05:01Z", "type": "commit"}, {"oid": "8107cdaeed09f60713b10dc33b409f741c2c5fee", "url": "https://github.com/hazelcast/hazelcast/commit/8107cdaeed09f60713b10dc33b409f741c2c5fee", "message": "eviction test passed", "committedDate": "2021-02-04T08:05:01Z", "type": "commit"}, {"oid": "c4d4a258c5025184d2ad3309509f1bc4e4e22151", "url": "https://github.com/hazelcast/hazelcast/commit/c4d4a258c5025184d2ad3309509f1bc4e4e22151", "message": "eviction test passed 2", "committedDate": "2021-02-04T08:05:01Z", "type": "commit"}, {"oid": "04373444bb531bee80b12a76ea86917f792f9c97", "url": "https://github.com/hazelcast/hazelcast/commit/04373444bb531bee80b12a76ea86917f792f9c97", "message": "wip test foxes", "committedDate": "2021-02-04T08:05:01Z", "type": "commit"}, {"oid": "80e0bbec6be06b174990e9940aecd51a06151d63", "url": "https://github.com/hazelcast/hazelcast/commit/80e0bbec6be06b174990e9940aecd51a06151d63", "message": "backup expiry info", "committedDate": "2021-02-04T08:05:01Z", "type": "commit"}, {"oid": "a3c704ccd45008f300b438db629ec6483bcf1390", "url": "https://github.com/hazelcast/hazelcast/commit/a3c704ccd45008f300b438db629ec6483bcf1390", "message": "backup expiry info", "committedDate": "2021-02-04T08:05:01Z", "type": "commit"}, {"oid": "0f1bdbf12c741f8a717b600a9e817e8a46a64261", "url": "https://github.com/hazelcast/hazelcast/commit/0f1bdbf12c741f8a717b600a9e817e8a46a64261", "message": "wip", "committedDate": "2021-02-04T08:05:01Z", "type": "commit"}, {"oid": "91b9db6e9994b4c9f260c25274e0cc2cef5a267e", "url": "https://github.com/hazelcast/hazelcast/commit/91b9db6e9994b4c9f260c25274e0cc2cef5a267e", "message": "wip checlstyle", "committedDate": "2021-02-04T08:05:01Z", "type": "commit"}, {"oid": "5ea33b2f4155c5342c59e2ae00a19bfe270fdf83", "url": "https://github.com/hazelcast/hazelcast/commit/5ea33b2f4155c5342c59e2ae00a19bfe270fdf83", "message": "test fix", "committedDate": "2021-02-04T08:05:01Z", "type": "commit"}, {"oid": "4796eb6c24ebffbe71887a28a3eaabdccd8787e2", "url": "https://github.com/hazelcast/hazelcast/commit/4796eb6c24ebffbe71887a28a3eaabdccd8787e2", "message": "test fix", "committedDate": "2021-02-04T08:05:02Z", "type": "commit"}, {"oid": "4dc611964594afe8f7c09d6d170a287e98dbfd0b", "url": "https://github.com/hazelcast/hazelcast/commit/4dc611964594afe8f7c09d6d170a287e98dbfd0b", "message": "test fix 2", "committedDate": "2021-02-04T08:05:02Z", "type": "commit"}, {"oid": "ce29612a876a24c0e44a3fa3f25f8c30dcd36cb8", "url": "https://github.com/hazelcast/hazelcast/commit/ce29612a876a24c0e44a3fa3f25f8c30dcd36cb8", "message": "remove key createRecord", "committedDate": "2021-02-04T08:05:02Z", "type": "commit"}, {"oid": "15bd9d1a4be92a388d51dc0b31d280188225f4c7", "url": "https://github.com/hazelcast/hazelcast/commit/15bd9d1a4be92a388d51dc0b31d280188225f4c7", "message": "WIP", "committedDate": "2021-02-04T08:05:02Z", "type": "commit"}, {"oid": "3318d9b6399eedf85396c8c5fd0260e4768e734f", "url": "https://github.com/hazelcast/hazelcast/commit/3318d9b6399eedf85396c8c5fd0260e4768e734f", "message": "fix test", "committedDate": "2021-02-04T08:05:02Z", "type": "commit"}, {"oid": "90f4b2340e4a9d3c2265d5d09081a1cdd32bb47f", "url": "https://github.com/hazelcast/hazelcast/commit/90f4b2340e4a9d3c2265d5d09081a1cdd32bb47f", "message": "fix test", "committedDate": "2021-02-04T08:05:02Z", "type": "commit"}, {"oid": "e532bc392e7425a67d97a00d1cac6126011d813b", "url": "https://github.com/hazelcast/hazelcast/commit/e532bc392e7425a67d97a00d1cac6126011d813b", "message": "fix test", "committedDate": "2021-02-04T08:05:02Z", "type": "commit"}, {"oid": "d7b7ea147a3e196e65b0c3db89af1eddf7c6f06a", "url": "https://github.com/hazelcast/hazelcast/commit/d7b7ea147a3e196e65b0c3db89af1eddf7c6f06a", "message": "enhc", "committedDate": "2021-02-04T08:05:02Z", "type": "commit"}, {"oid": "f70da73a54249154a6c2c1de8a0e923d33582a2b", "url": "https://github.com/hazelcast/hazelcast/commit/f70da73a54249154a6c2c1de8a0e923d33582a2b", "message": "polish", "committedDate": "2021-02-04T08:05:02Z", "type": "commit"}, {"oid": "7419fd5600a9569415bbdeb9def052ab7a972d97", "url": "https://github.com/hazelcast/hazelcast/commit/7419fd5600a9569415bbdeb9def052ab7a972d97", "message": "test update", "committedDate": "2021-02-04T08:05:02Z", "type": "commit"}, {"oid": "d4b994252e86eedbc6ec670ab806731a7f103941", "url": "https://github.com/hazelcast/hazelcast/commit/d4b994252e86eedbc6ec670ab806731a7f103941", "message": "hdmap stress test related fixes, onshutdown, on destroy etc.", "committedDate": "2021-02-04T08:05:02Z", "type": "commit"}, {"oid": "74e3c9545bf30dfa210567c96195ab4ceb2412cb", "url": "https://github.com/hazelcast/hazelcast/commit/74e3c9545bf30dfa210567c96195ab4ceb2412cb", "message": "polish", "committedDate": "2021-02-04T08:05:02Z", "type": "commit"}, {"oid": "e2fa65c2995c9b8ca2fc8f050415251f8d014c2a", "url": "https://github.com/hazelcast/hazelcast/commit/e2fa65c2995c9b8ca2fc8f050415251f8d014c2a", "message": "enable metrics", "committedDate": "2021-02-04T08:05:02Z", "type": "commit"}, {"oid": "1319ab38549bf7d5ff98128be27cc156f63170c8", "url": "https://github.com/hazelcast/hazelcast/commit/1319ab38549bf7d5ff98128be27cc156f63170c8", "message": "metadata unification and expiry related fields removal from record objects", "committedDate": "2021-02-04T08:05:02Z", "type": "commit"}, {"oid": "c0adc7ae0253c9ce3e2c052954230aadd7d63d01", "url": "https://github.com/hazelcast/hazelcast/commit/c0adc7ae0253c9ce3e2c052954230aadd7d63d01", "message": "fix checkstyle", "committedDate": "2021-02-04T08:05:02Z", "type": "commit"}, {"oid": "a3ef9eb75ce0ac156ecfb60e5c3157f3df2ede82", "url": "https://github.com/hazelcast/hazelcast/commit/a3ef9eb75ce0ac156ecfb60e5c3157f3df2ede82", "message": "fix failed tests", "committedDate": "2021-02-04T08:05:02Z", "type": "commit"}, {"oid": "a59ac0d31538fb07e62b89d0ac54e201678606ec", "url": "https://github.com/hazelcast/hazelcast/commit/a59ac0d31538fb07e62b89d0ac54e201678606ec", "message": "fix failed tests 2", "committedDate": "2021-02-04T08:05:02Z", "type": "commit"}, {"oid": "4772e3fab25983097bbdba837a512b765d8a8c98", "url": "https://github.com/hazelcast/hazelcast/commit/4772e3fab25983097bbdba837a512b765d8a8c98", "message": "remove old record impl except withStats extensions\n- add object header to entry costs", "committedDate": "2021-02-04T08:05:02Z", "type": "commit"}, {"oid": "6e07ebf1b49f82ca43715e15a189fc5a217ad471", "url": "https://github.com/hazelcast/hazelcast/commit/6e07ebf1b49f82ca43715e15a189fc5a217ad471", "message": "map scan executor", "committedDate": "2021-02-04T08:05:02Z", "type": "commit"}, {"oid": "f2d66a1027d3f94b980c43506cfa8ae1eaf343a2", "url": "https://github.com/hazelcast/hazelcast/commit/f2d66a1027d3f94b980c43506cfa8ae1eaf343a2", "message": "hasExpired backup, canPrimaryDriveBackup", "committedDate": "2021-02-04T08:05:02Z", "type": "commit"}, {"oid": "bc9064ba44bcccc54629a520abc0e3c88825618c", "url": "https://github.com/hazelcast/hazelcast/commit/bc9064ba44bcccc54629a520abc0e3c88825618c", "message": "shared methods for record impls", "committedDate": "2021-02-04T08:05:02Z", "type": "commit"}, {"oid": "e23e062a5699f9f63a49b63bc2e3175393f72674", "url": "https://github.com/hazelcast/hazelcast/commit/e23e062a5699f9f63a49b63bc2e3175393f72674", "message": "fix failed tests", "committedDate": "2021-02-04T08:05:02Z", "type": "commit"}, {"oid": "5263299c3f8212e41cfa1abce1c5caabd9da3db2", "url": "https://github.com/hazelcast/hazelcast/commit/5263299c3f8212e41cfa1abce1c5caabd9da3db2", "message": "fix failed tests 2", "committedDate": "2021-02-04T08:05:02Z", "type": "commit"}, {"oid": "07d33411d7c0696a50b073369edb3b7c89a653b5", "url": "https://github.com/hazelcast/hazelcast/commit/07d33411d7c0696a50b073369edb3b7c89a653b5", "message": "polish", "committedDate": "2021-02-04T08:05:02Z", "type": "commit"}, {"oid": "69e66b89e0f45bc9e5ce21bd7dc81d33b1a1e1ee", "url": "https://github.com/hazelcast/hazelcast/commit/69e66b89e0f45bc9e5ce21bd7dc81d33b1a1e1ee", "message": "remove unneeded stats update from records", "committedDate": "2021-02-04T08:05:02Z", "type": "commit"}, {"oid": "2dd5e49bd215d69636ac08447efa2b49c7d130b0", "url": "https://github.com/hazelcast/hazelcast/commit/2dd5e49bd215d69636ac08447efa2b49c7d130b0", "message": "checkstyle", "committedDate": "2021-02-04T08:05:02Z", "type": "commit"}, {"oid": "ac4b65d709273bfbc7999198ef817336aaf36b2c", "url": "https://github.com/hazelcast/hazelcast/commit/ac4b65d709273bfbc7999198ef817336aaf36b2c", "message": "mapDataStore != EMPTY_MAP_DATA_STORE", "committedDate": "2021-02-04T08:05:02Z", "type": "commit"}, {"oid": "16734107d9ba933bdccd415768147324f03e2321", "url": "https://github.com/hazelcast/hazelcast/commit/16734107d9ba933bdccd415768147324f03e2321", "message": "Object2ObjectHashMap", "committedDate": "2021-02-04T08:05:02Z", "type": "commit"}, {"oid": "84e776181df54a920284b6605b7b8a393b7829a5", "url": "https://github.com/hazelcast/hazelcast/commit/84e776181df54a920284b6605b7b8a393b7829a5", "message": "fix recordstore#get", "committedDate": "2021-02-04T08:05:03Z", "type": "commit"}, {"oid": "1b02a64415ba94b7f141066ac0a15f07e093e61e", "url": "https://github.com/hazelcast/hazelcast/commit/1b02a64415ba94b7f141066ac0a15f07e093e61e", "message": "Remove serializable from Object2ObjMap", "committedDate": "2021-02-04T08:05:03Z", "type": "commit"}, {"oid": "3ab3639f724cdbdccff0b3834f74e58eb7f60c2b", "url": "https://github.com/hazelcast/hazelcast/commit/3ab3639f724cdbdccff0b3834f74e58eb7f60c2b", "message": "int version and add version", "committedDate": "2021-02-04T08:05:03Z", "type": "commit"}, {"oid": "86fbc5e1c93ae7bc4773057f9108dc821b39e4fe", "url": "https://github.com/hazelcast/hazelcast/commit/86fbc5e1c93ae7bc4773057f9108dc821b39e4fe", "message": "fix version test", "committedDate": "2021-02-04T08:05:03Z", "type": "commit"}, {"oid": "f59efeda99057d692dcf89470870d20a9afa71ee", "url": "https://github.com/hazelcast/hazelcast/commit/f59efeda99057d692dcf89470870d20a9afa71ee", "message": "fix check style", "committedDate": "2021-02-04T08:05:03Z", "type": "commit"}, {"oid": "5059d5567464d135bc4242c7e817452573ab5f55", "url": "https://github.com/hazelcast/hazelcast/commit/5059d5567464d135bc4242c7e817452573ab5f55", "message": "improvements", "committedDate": "2021-02-04T08:05:03Z", "type": "commit"}, {"oid": "b6ef3a5b92abac14cd5621bb38d06811ed73d297", "url": "https://github.com/hazelcast/hazelcast/commit/b6ef3a5b92abac14cd5621bb38d06811ed73d297", "message": "calculateExpirationTime, pickTtl,pickMaxIdle", "committedDate": "2021-02-04T08:05:03Z", "type": "commit"}, {"oid": "677430d9c05313e34fd5dd59fe78c5f1961d1b20", "url": "https://github.com/hazelcast/hazelcast/commit/677430d9c05313e34fd5dd59fe78c5f1961d1b20", "message": "calculateExpirationTime, pickTtl,pickMaxIdle fix overflow", "committedDate": "2021-02-04T08:05:03Z", "type": "commit"}, {"oid": "17b070425c0533a2f6defd3c2b23f7dd7bb7d96f", "url": "https://github.com/hazelcast/hazelcast/commit/17b070425c0533a2f6defd3c2b23f7dd7bb7d96f", "message": "calculateExpirationTime, pickTtl,pickMaxIdle fixes 2", "committedDate": "2021-02-04T08:05:03Z", "type": "commit"}, {"oid": "9e0f116ad0e793d5790ed64c032948f643f1bf8c", "url": "https://github.com/hazelcast/hazelcast/commit/9e0f116ad0e793d5790ed64c032948f643f1bf8c", "message": "polish", "committedDate": "2021-02-04T08:05:03Z", "type": "commit"}, {"oid": "9229a0633ac4b9c6b3d8b4ec2b760f186ea56995", "url": "https://github.com/hazelcast/hazelcast/commit/9229a0633ac4b9c6b3d8b4ec2b760f186ea56995", "message": "desrease test run time", "committedDate": "2021-02-04T08:05:03Z", "type": "commit"}, {"oid": "9c5cdfcfe13f4a626a0e32576a44a857189aafad", "url": "https://github.com/hazelcast/hazelcast/commit/9c5cdfcfe13f4a626a0e32576a44a857189aafad", "message": "Restrore CHM iterator", "committedDate": "2021-02-04T08:05:03Z", "type": "commit"}, {"oid": "cb933f50fce6e273583c4bf5b750c7b36451b2bb", "url": "https://github.com/hazelcast/hazelcast/commit/cb933f50fce6e273583c4bf5b750c7b36451b2bb", "message": "Polishing", "committedDate": "2021-02-04T08:05:03Z", "type": "commit"}, {"oid": "7219f66a1754965614dc7a3bb0eb3ea065184048", "url": "https://github.com/hazelcast/hazelcast/commit/7219f66a1754965614dc7a3bb0eb3ea065184048", "message": "perf", "committedDate": "2021-02-04T08:05:03Z", "type": "commit"}, {"oid": "ef31b18c5294ef87ed57491b0a5052bd7f89b029", "url": "https://github.com/hazelcast/hazelcast/commit/ef31b18c5294ef87ed57491b0a5052bd7f89b029", "message": "fix test", "committedDate": "2021-02-04T08:05:03Z", "type": "commit"}, {"oid": "2044096abd1bca50aae80a9b781e6e2442822773", "url": "https://github.com/hazelcast/hazelcast/commit/2044096abd1bca50aae80a9b781e6e2442822773", "message": "Polishing 5", "committedDate": "2021-02-04T08:05:03Z", "type": "commit"}, {"oid": "17a37f829cb41519ad38f2fadf50d9afa6cd490e", "url": "https://github.com/hazelcast/hazelcast/commit/17a37f829cb41519ad38f2fadf50d9afa6cd490e", "message": "factory ifelse", "committedDate": "2021-02-04T08:05:03Z", "type": "commit"}, {"oid": "b81af6ab5288483642084940a9d11e47047fa95a", "url": "https://github.com/hazelcast/hazelcast/commit/b81af6ab5288483642084940a9d11e47047fa95a", "message": "Zoltan reviews", "committedDate": "2021-02-04T08:05:03Z", "type": "commit"}, {"oid": "2a766a9e00d87789a9441e50dad5a18beecdbed7", "url": "https://github.com/hazelcast/hazelcast/commit/2a766a9e00d87789a9441e50dad5a18beecdbed7", "message": "Zoltan reviews: allow version overflow", "committedDate": "2021-02-04T08:05:03Z", "type": "commit"}, {"oid": "ec1e386239eb0b927a7883ed07b37071ae4505f1", "url": "https://github.com/hazelcast/hazelcast/commit/ec1e386239eb0b927a7883ed07b37071ae4505f1", "message": "Zoltan reviews: allow version overflow 2", "committedDate": "2021-02-04T08:05:03Z", "type": "commit"}, {"oid": "8716526d6617d972c2070d8a5d0e13d42a1f4ab8", "url": "https://github.com/hazelcast/hazelcast/commit/8716526d6617d972c2070d8a5d0e13d42a1f4ab8", "message": "remove duplicate method", "committedDate": "2021-02-04T08:05:03Z", "type": "commit"}, {"oid": "93f04bea319f08546e0cbe0b3c3d129b3148c62b", "url": "https://github.com/hazelcast/hazelcast/commit/93f04bea319f08546e0cbe0b3c3d129b3148c62b", "message": "remove duplicate method 2", "committedDate": "2021-02-04T08:05:03Z", "type": "commit"}, {"oid": "7b69e5f7fa94a050ba0576921cdafb053f036020", "url": "https://github.com/hazelcast/hazelcast/commit/7b69e5f7fa94a050ba0576921cdafb053f036020", "message": "fix checkstyle", "committedDate": "2021-02-04T08:05:03Z", "type": "commit"}, {"oid": "f3141525ed2facae64a1bea5b10bd19f61f9e3c8", "url": "https://github.com/hazelcast/hazelcast/commit/f3141525ed2facae64a1bea5b10bd19f61f9e3c8", "message": "Address Petr comments", "committedDate": "2021-02-04T08:05:55Z", "type": "commit"}, {"oid": "d471c80d1fc0771308f6315bc3869bd7ae58358a", "url": "https://github.com/hazelcast/hazelcast/commit/d471c80d1fc0771308f6315bc3869bd7ae58358a", "message": "Test failures", "committedDate": "2021-02-04T08:06:00Z", "type": "commit"}, {"oid": "d471c80d1fc0771308f6315bc3869bd7ae58358a", "url": "https://github.com/hazelcast/hazelcast/commit/d471c80d1fc0771308f6315bc3869bd7ae58358a", "message": "Test failures", "committedDate": "2021-02-04T08:06:00Z", "type": "forcePushed"}]}