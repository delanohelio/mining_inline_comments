{"pr_number": 16698, "pr_title": "Initial commit to add MultiMap bulk put feature request (#9079)", "pr_createdAt": "2020-02-27T11:21:42Z", "pr_url": "https://github.com/hazelcast/hazelcast/pull/16698", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA2NzIwMQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r385067201", "bodyText": "In the public interface javadoc:\n\ndescribe what the method's contract is. For example, this is the place to mention that there is no atomicity guarantee (some puts may have already been executed while puts in other partitions may still be ongoing, so clients may observe partial effects of this method).\ndo not commit to internal implementation details; the fact that the implementation will batch KVs by partition is an optimization that might be true for the current implementation however we want to be free to change implementation as needed.", "author": "vbekiaris", "createdAt": "2020-02-27T11:24:46Z", "path": "hazelcast/src/main/java/com/hazelcast/multimap/MultiMap.java", "diffHunk": "@@ -57,6 +58,33 @@\n  */\n @SuppressWarnings(\"checkstyle:methodcount\")\n public interface MultiMap<K, V> extends BaseMultiMap<K, V> {\n+\n+    /**\n+     * Stores a Map in the multimap synchronously.\n+     * <p>\n+     * This method performs a bulk put into a MultiMap\n+     * by partitions similar to Map.putAllAsync", "originalCommit": "2b2dfd27152e08ea00364879267a44f5927999a1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA2Nzc2OA==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r385067768", "bodyText": "We expose CompletionStage as public return type for our async interface methods.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                InternalCompletableFuture<Void> putAllAsync(@Nonnull Map<? extends Object, Collection> m);\n          \n          \n            \n                CompletionStage<Void> putAllAsync(@Nonnull Map<? extends K, Collection<? extends V>> m);", "author": "vbekiaris", "createdAt": "2020-02-27T11:26:06Z", "path": "hazelcast/src/main/java/com/hazelcast/multimap/MultiMap.java", "diffHunk": "@@ -57,6 +58,33 @@\n  */\n @SuppressWarnings(\"checkstyle:methodcount\")\n public interface MultiMap<K, V> extends BaseMultiMap<K, V> {\n+\n+    /**\n+     * Stores a Map in the multimap synchronously.\n+     * <p>\n+     * This method performs a bulk put into a MultiMap\n+     * by partitions similar to Map.putAllAsync\n+     *\n+     * @param m the map to be stored\n+     */\n+    void putAll(@Nonnull Map<?, Collection> m);\n+\n+    /**\n+     * Stores a Map in the multimap aynchronously.\n+     * <p>\n+     * This method performs a bulk put into a MultiMap\n+     * by partitions similar to Map.putAllAsync.\n+     * <p>\n+     * <b>Warning:</b> The Map and result of the put cannot be fetched\n+     * from the Future.\n+     *\n+     * @param m the map to be stored\n+     * @return a void Future\n+     */\n+    //FIXME:should be narrowly generic, but as it were, MultiMapProxySupport is not genericized.\n+    //Another alternative is to pass in MultiMapValue\n+    InternalCompletableFuture<Void> putAllAsync(@Nonnull Map<? extends Object, Collection> m);", "originalCommit": "2b2dfd27152e08ea00364879267a44f5927999a1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTEyNjg0Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r385126846", "bodyText": "When adding new methods in minor versions, due to rolling-upgrade restrictions we need first to check if we are allowed to run the method. In this case, one is only allowed to run the new method in version 4.1. So first instruction should be something like this:\n    if (isClusterVersionLessThan(Versions.V4_1)) {\n        throw new UnsupportedOperationException(\"MultiMap#putAll is only available with cluster version 4.1 or greater\");\n    }\n\n(same for putAll above)", "author": "vbekiaris", "createdAt": "2020-02-27T13:32:16Z", "path": "hazelcast/src/main/java/com/hazelcast/multimap/impl/MultiMapProxyImpl.java", "diffHunk": "@@ -92,6 +93,20 @@ public void initialize() {\n         }\n     }\n \n+    @Override\n+    public void putAll(@Nonnull Map<? extends Object, Collection> m) {\n+        //TODO: add contains check\n+        putAllInternal(m, null);\n+    }\n+\n+    @Override\n+    public InternalCompletableFuture<Void> putAllAsync(@Nonnull Map<? extends Object, Collection> m) {\n+        //TODO: add contains check\n+        InternalCompletableFuture<Void> future = new InternalCompletableFuture<>();", "originalCommit": "2b2dfd27152e08ea00364879267a44f5927999a1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTE0MzU3NA==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r385143574", "bodyText": "MultiMapSupport is not aware of K, V type parameters; instead it only operates with Data, the serialized binary form of keys and values. So here I would expect a Map<Data, Collection<Data>> as argument. Serialization occurs in MultiMapProxyImpl, as an example see how MultiMap#put(@Nonnull K key, @Nonnull V value) is implemented.", "author": "vbekiaris", "createdAt": "2020-02-27T14:01:44Z", "path": "hazelcast/src/main/java/com/hazelcast/multimap/impl/MultiMapProxySupport.java", "diffHunk": "@@ -16,54 +16,267 @@\n \n package com.hazelcast.multimap.impl;\n \n-import com.hazelcast.internal.locksupport.LockProxySupport;\n-import com.hazelcast.internal.locksupport.LockSupportServiceImpl;\n+import com.hazelcast.cluster.Address;\n import com.hazelcast.config.MultiMapConfig;\n import com.hazelcast.core.EntryEventType;\n+import com.hazelcast.internal.locksupport.LockProxySupport;\n+import com.hazelcast.internal.locksupport.LockSupportServiceImpl;\n+import com.hazelcast.internal.partition.IPartitionService;\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.internal.serialization.SerializationService;\n+import com.hazelcast.internal.services.DistributedObjectNamespace;\n+import com.hazelcast.internal.util.ExceptionUtil;\n+import com.hazelcast.internal.util.ThreadUtil;\n+import com.hazelcast.map.impl.MapEntries;\n import com.hazelcast.multimap.impl.operations.CountOperation;\n import com.hazelcast.multimap.impl.operations.DeleteOperation;\n import com.hazelcast.multimap.impl.operations.GetAllOperation;\n import com.hazelcast.multimap.impl.operations.MultiMapOperationFactory;\n import com.hazelcast.multimap.impl.operations.MultiMapOperationFactory.OperationFactoryType;\n+import com.hazelcast.multimap.impl.operations.MultiMapPutAllOperationFactory;\n import com.hazelcast.multimap.impl.operations.MultiMapResponse;\n import com.hazelcast.multimap.impl.operations.PutOperation;\n import com.hazelcast.multimap.impl.operations.RemoveAllOperation;\n import com.hazelcast.multimap.impl.operations.RemoveOperation;\n-import com.hazelcast.internal.serialization.Data;\n import com.hazelcast.spi.impl.AbstractDistributedObject;\n-import com.hazelcast.internal.services.DistributedObjectNamespace;\n+import com.hazelcast.spi.impl.InternalCompletableFuture;\n import com.hazelcast.spi.impl.NodeEngine;\n import com.hazelcast.spi.impl.operationservice.Operation;\n-import com.hazelcast.internal.util.ExceptionUtil;\n-import com.hazelcast.internal.util.ThreadUtil;\n+import com.hazelcast.spi.impl.operationservice.OperationFactory;\n+import com.hazelcast.spi.impl.operationservice.OperationService;\n \n+import javax.annotation.Nullable;\n+import java.util.Arrays;\n+import java.util.Collection;\n import java.util.HashSet;\n+import java.util.List;\n import java.util.Map;\n import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.Future;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.BiConsumer;\n \n+import static com.hazelcast.internal.util.CollectionUtil.asIntegerList;\n+import static com.hazelcast.internal.util.ConcurrencyUtil.CALLER_RUNS;\n+import static com.hazelcast.internal.util.ExceptionUtil.rethrow;\n+import static com.hazelcast.internal.util.Preconditions.checkNotNull;\n import static com.hazelcast.internal.util.MapUtil.toIntSize;\n+import static com.hazelcast.multimap.impl.MultiMapProxyImpl.NULL_KEY_IS_NOT_ALLOWED;\n+import static com.hazelcast.multimap.impl.MultiMapProxyImpl.NULL_VALUE_IS_NOT_ALLOWED;\n+import static com.hazelcast.spi.impl.InternalCompletableFuture.newCompletedFuture;\n+import static java.lang.Math.ceil;\n+import static java.lang.Math.log10;\n+import static java.util.Collections.singletonMap;\n \n public abstract class MultiMapProxySupport extends AbstractDistributedObject<MultiMapService> {\n \n     protected final MultiMapConfig config;\n     protected final String name;\n     protected final LockProxySupport lockSupport;\n+    protected final SerializationService serializationService;\n+    protected final OperationService operationService;\n+    protected final IPartitionService partitionService;\n+    private final float putAllInitialSizeFactor;\n \n     protected MultiMapProxySupport(MultiMapConfig config, MultiMapService service, NodeEngine nodeEngine, String name) {\n         super(nodeEngine, service);\n         this.config = config;\n         this.name = name;\n \n+        this.partitionService = nodeEngine.getPartitionService();\n+        this.serializationService = nodeEngine.getSerializationService();\n+        this.operationService = nodeEngine.getOperationService();\n+\n         lockSupport = new LockProxySupport(new DistributedObjectNamespace(MultiMapService.SERVICE_NAME, name),\n                 LockSupportServiceImpl.getMaxLeaseTimeInMillis(nodeEngine.getProperties()));\n+\n+        //TODO: implement properties and properties.getFloat(MAP_PUT_ALL_INITIAL_SIZE_FACTOR);\n+        this.putAllInitialSizeFactor = 1;\n     }\n \n     @Override\n     public String getName() {\n         return name;\n     }\n \n+    //NB: this method is copied from MapProxySupport#getPutAllInitialSize\n+    @SuppressWarnings(\"checkstyle:magicnumber\")\n+    private int getPutAllInitialSize(boolean useBatching, int mapSize, int partitionCount) {\n+        if (mapSize == 1) {\n+            return 1;\n+        }\n+        //TODO: implement batching\n+        /*\n+        if (useBatching) {\n+            return putAllBatchSize;\n+        }*/\n+        if (putAllInitialSizeFactor < 1) {\n+            // this is an educated guess for the initial size of the entries per partition, depending on the map size\n+            return (int) ceil(20f * mapSize / partitionCount / log10(mapSize));\n+        }\n+        return (int) ceil(putAllInitialSizeFactor * mapSize / partitionCount);\n+    }\n+\n+    //NB: this method is generally copied from MapProxySupport#putAllInternal\n+    @SuppressWarnings({\"checkstyle:npathcomplexity\", \"checkstyle:methodlength\"})\n+    protected void putAllInternal(Map<? extends Object, Collection> map,", "originalCommit": "2b2dfd27152e08ea00364879267a44f5927999a1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "941f97d717eb624059761c4884b9fa7381bc6c33", "url": "https://github.com/hazelcast/hazelcast/commit/941f97d717eb624059761c4884b9fa7381bc6c33", "message": " Modify new MultiMap bulk store interfaces to take in Map, MultiMap and Key and Collection (#9079)\n Implement ClientMultiMapProxy, corresponding PutAllMessageTask, unit tests and copy in generated codec.\n Address comments and fix MultiMap javadoc.\n\n Add new Precondition to throw given Exception.", "committedDate": "2020-03-22T19:07:37Z", "type": "forcePushed"}, {"oid": "d98853fc1667c392bc94f445adcb517df86ddf3b", "url": "https://github.com/hazelcast/hazelcast/commit/d98853fc1667c392bc94f445adcb517df86ddf3b", "message": "Modify new MultiMap bulk store interfaces to take in Map, MultiMap and Key and Collection (#9079)\n Implement ClientMultiMapProxy, corresponding PutAllMessageTask, unit tests and copy in generated codec.\n Address comments and fix MultiMap javadoc.\n\n Add new Precondition to throw given Exception.", "committedDate": "2020-03-22T22:31:00Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQwOTIzNQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r396409235", "bodyText": "While I appreciate the clean coding style with checkTrue(boolean, RuntimeException), this version of code will produce a lot of litter even in the happy path, when cluster version is >= 4.1. I would rather have the exception construction & message formatting code be only executed when the cluster version condition is false.", "author": "vbekiaris", "createdAt": "2020-03-23T12:20:02Z", "path": "hazelcast/src/main/java/com/hazelcast/multimap/impl/MultiMapProxyImpl.java", "diffHunk": "@@ -92,6 +100,120 @@ public void initialize() {\n         }\n     }\n \n+    @Override\n+    public void putAll(@Nonnull Map<? extends K, Collection<? extends V>> m) {\n+        checkTrue(isClusterVersionGreaterOrEqual(Versions.V4_1),", "originalCommit": "d98853fc1667c392bc94f445adcb517df86ddf3b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjUyMDQyMg==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r396520422", "bodyText": "I would rather not have this (and the async variant) API method with MultiMap as argument implemented at all. The reason is that it makes it extremely easy for users to shoot themselves in the foot, abstracting away the fact that each invocation to get an item from the MultiMap argument will be a remote invocation.", "author": "vbekiaris", "createdAt": "2020-03-23T15:05:50Z", "path": "hazelcast/src/main/java/com/hazelcast/multimap/MultiMap.java", "diffHunk": "@@ -57,6 +58,117 @@\n  */\n @SuppressWarnings(\"checkstyle:methodcount\")\n public interface MultiMap<K, V> extends BaseMultiMap<K, V> {\n+\n+    /**\n+     * Stores the given Map in the MultiMap synchronously.\n+     * <p>\n+     * This version doesn't support batching. Don't mutate the given map until the future completes.\n+     * <p>\n+     * No atomicity guarantees are given. It could be that in case of failure\n+     * some of the key/value-pairs get written, while others are not.\n+     * <p>\n+     * <b>Warning:</b> There is no warning if the input Map collection items are discarded due to uniqueness\n+     * eg. passing in List into a Set type MultiMap\n+     *\n+     * @param m the Map to be stored\n+     * @since 4.1\n+     */\n+    void putAll(@Nonnull Map<? extends K, Collection<? extends V>> m);\n+\n+    /**\n+     * Stores the given MultiMap in the MultiMap synchronously.\n+     * <p>\n+     * This version doesn't support batching. Don't mutate the given multimap until the future completes.\n+     * <p>\n+     * No atomicity guarantees are given. It could be that in case of failure\n+     * some of the key/value-pairs get written, while others are not.\n+     * <p>\n+     * <b>Warning:</b> There is no warning if the input MultiMap items are discarded due to uniqueness\n+     * eg. passing in List type MultiMap into a Set type MultiMap\n+     *\n+     * @param m the MultiMap to be stored\n+     * @since 4.1\n+     */\n+    void putAll(@Nonnull MultiMap<K, V> m);", "originalCommit": "d98853fc1667c392bc94f445adcb517df86ddf3b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU0MDQ0Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r396540447", "bodyText": "\"This version doesn't support batching.\" -> This seems superfluous for an API description, don't bother with mentioning implementation details in the contract description. If you feel like it is important to mention this so users can take it into account when planning their usage of the API, then probably it could be rephrased. From my point of view reading \"This version doesn't support batching\" indicates that there exists a version that supports batching.\n\"Don't mutate the given map until the future completes.\" -> what do you think about rephrasing as \"The results of concurrently mutating the given map are undefined\"?", "author": "vbekiaris", "createdAt": "2020-03-23T15:31:55Z", "path": "hazelcast/src/main/java/com/hazelcast/multimap/MultiMap.java", "diffHunk": "@@ -57,6 +58,117 @@\n  */\n @SuppressWarnings(\"checkstyle:methodcount\")\n public interface MultiMap<K, V> extends BaseMultiMap<K, V> {\n+\n+    /**\n+     * Stores the given Map in the MultiMap synchronously.\n+     * <p>\n+     * This version doesn't support batching. Don't mutate the given map until the future completes.", "originalCommit": "d98853fc1667c392bc94f445adcb517df86ddf3b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU5Nzg4OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r396597889", "bodyText": "Are we sure that it is worth the parallelStream setup here, also taking into account that the per-element function (in line 114 below) also contends for the same CPU cores? I think this question can have varying answers depending on the number of keys and the average number of values per key, however using parallelStream to process both the entry stream and the values collection is certain to have a detrimental effect. I would probably opt for simple sequential execution in both places (here and line 114).\nRelated reading: http://gee.cs.oswego.edu/dl/html/StreamParallelGuidance.html", "author": "vbekiaris", "createdAt": "2020-03-23T16:47:07Z", "path": "hazelcast/src/main/java/com/hazelcast/multimap/impl/MultiMapProxyImpl.java", "diffHunk": "@@ -92,6 +100,120 @@ public void initialize() {\n         }\n     }\n \n+    @Override\n+    public void putAll(@Nonnull Map<? extends K, Collection<? extends V>> m) {\n+        checkTrue(isClusterVersionGreaterOrEqual(Versions.V4_1),\n+                new UnsupportedOperationException(MessageFormat.format(MINIMUM_VERSION_ERROR_FORMAT,\n+                        \"MultiMap#putAll\", \"4.1\")));\n+        Map<Data, Collection<Data>> dataMap = new HashMap<Data, Collection<Data>>();\n+\n+        m.entrySet().parallelStream().forEach(", "originalCommit": "d98853fc1667c392bc94f445adcb517df86ddf3b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA0NTQ1NA==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r397045454", "bodyText": "new PutAllPartitionAwareOperationFactory?", "author": "vbekiaris", "createdAt": "2020-03-24T10:24:37Z", "path": "hazelcast/src/main/java/com/hazelcast/multimap/impl/MultiMapDataSerializerHook.java", "diffHunk": "@@ -172,6 +175,8 @@ public DataSerializableFactory createFactory() {\n         constructors[MERGE_BACKUP_OPERATION] = arg -> new MergeBackupOperation();\n         constructors[DELETE] = arg -> new DeleteOperation();\n         constructors[DELETE_BACKUP] = arg -> new DeleteBackupOperation();\n+        constructors[PUT_ALL] = arg -> new PutAllOperation();\n+        constructors[PUT_ALL_PARTITION_AWARE_FACTORY] = arg -> new MultiMapOperationFactory();", "originalCommit": "d98853fc1667c392bc94f445adcb517df86ddf3b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA4MDM4Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r397080387", "bodyText": "This is unnecessary", "author": "vbekiaris", "createdAt": "2020-03-24T11:25:31Z", "path": "hazelcast/src/test/java/com/hazelcast/multimap/MultiMapTest.java", "diffHunk": "@@ -104,6 +116,245 @@ public void testMultiMapPutGetRemove() {\n         assertEquals(0, multiMap.size());\n     }\n \n+    protected <K, V> EntryListener<K, V> putAllEntryListenerBuilder(Consumer<EntryEvent<K, V>> f) {\n+        return new EntryAdapter<K, V>() {\n+            public void entryAdded(EntryEvent<K, V> event) {\n+                f.accept(event);\n+            }\n+\n+            public void entryRemoved(EntryEvent<K, V> event) {\n+                System.out.println(\"entryRemoved \" + event);\n+            }\n+\n+            public void entryEvicted(EntryEvent<K, V> event) {\n+                entryRemoved(event);\n+            }\n+\n+            @Override\n+            public void mapEvicted(MapEvent event) {\n+            }\n+\n+            @Override\n+            public void mapCleared(MapEvent event) {\n+                System.out.println(\"mapCleared \" + event);\n+            }\n+        };\n+    }\n+\n+    protected HazelcastInstance testMultiMapPutAllSetup() {\n+        MultiMapConfig multiMapConfig1 = new MultiMapConfig()\n+                .setName(\"testMultiMapPutAllMapList\")\n+                .setValueCollectionType(\"LIST\")\n+                .setBinary(false);\n+        MultiMapConfig multiMapConfig2 = new MultiMapConfig()\n+                .setName(\"testMultiMapPutAllMapSet\")\n+                .setValueCollectionType(\"SET\")\n+                .setBinary(false);\n+        MultiMapConfig multiMapConfig3 = new MultiMapConfig()\n+                .setName(\"expectedMultiMap1\")\n+                .setValueCollectionType(\"LIST\")\n+                .setBinary(false);\n+        Config cfg = smallInstanceConfig()\n+                .addMultiMapConfig(multiMapConfig1)\n+                .addMultiMapConfig(multiMapConfig2)\n+                .addMultiMapConfig(multiMapConfig3);\n+        HazelcastInstance hz = createHazelcastInstanceFactory(1)\n+                .newInstances(cfg)[0];\n+\n+        Accessors.getNode(hz).getClusterService().changeClusterVersion(Version.of(4, 1));", "originalCommit": "d98853fc1667c392bc94f445adcb517df86ddf3b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzEzODc3MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r397138771", "bodyText": "The Set and List implementations used internally in the multimap container are not thread-safe. Additionally, using parallelStream here breaks the principle of a single thread accessing a partition's data. Instead, do a plain for loop (and avoid the cost of stream & consumer allocations as a bonus). This is the reason of spurious test failures you observed. One more thing, event should be only triggered when a value is actually added (so adding an already existing value to a Set-backed multimap should not trigger an event).", "author": "vbekiaris", "createdAt": "2020-03-24T13:10:10Z", "path": "hazelcast/src/main/java/com/hazelcast/multimap/impl/operations/PutAllOperation.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.multimap.impl.operations;\n+\n+import com.hazelcast.core.EntryEventType;\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.map.impl.MapEntries;\n+import com.hazelcast.memory.NativeOutOfMemoryError;\n+import com.hazelcast.multimap.impl.MultiMapContainer;\n+import com.hazelcast.multimap.impl.MultiMapDataSerializerHook;\n+import com.hazelcast.multimap.impl.MultiMapRecord;\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.spi.impl.operationservice.MutatingOperation;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+\n+public class PutAllOperation extends AbstractMultiMapOperation implements MutatingOperation {\n+    private transient int currentIndex;\n+    private MapEntries mapEntries;\n+    private long recordId;\n+\n+    public PutAllOperation() {\n+        super();\n+    }\n+\n+    public PutAllOperation(String name, MapEntries mapEntries) {\n+        super(name);\n+        this.mapEntries = mapEntries;\n+        //NB: general structure copied from c.hz.map.impl.operation.PutAllOperation\n+        //May benefit from refactoring or default interfaces\n+    }\n+\n+    @Override\n+    public final void run() {\n+        try {\n+            runInternal();\n+        } catch (NativeOutOfMemoryError e) {\n+            //TODO: implement rerun?\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    protected void runInternal() {\n+        //FIXME: potentially bad idiom?\n+        int size = mapEntries != null ? mapEntries.size() : 0;\n+        while (currentIndex < size) {\n+            Data dataKey = mapEntries.getKey(currentIndex);\n+            Data value = mapEntries.getValue(currentIndex);\n+            put(dataKey, value);\n+            currentIndex++;\n+        }\n+        //FIXME: is this the best place to set response?\n+        response = true;\n+    }\n+\n+    protected void put(Data dataKey, Data dataValue) {\n+        MultiMapContainer container = getOrCreateContainer();\n+        Collection c = (Collection) toObject(dataValue);\n+        Collection<MultiMapRecord> coll = container.getOrCreateMultiMapValue(dataKey).getCollection(false);\n+        Consumer addObjToCollection = o -> {\n+            recordId = container.nextId();\n+            MultiMapRecord record = new MultiMapRecord(recordId, o);\n+            coll.add(record);\n+            getOrCreateContainer().update();\n+            publishEvent(EntryEventType.ADDED, dataKey, o, null);\n+        };\n+\n+        if (coll instanceof Set) {\n+            c.parallelStream().distinct().forEach(addObjToCollection);", "originalCommit": "d98853fc1667c392bc94f445adcb517df86ddf3b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzE1MDM1MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r397150351", "bodyText": "Need to respect the configured in-memory format here. Do something like MultiMapRecord record = new MultiMapRecord(recordId, isBinary() ? o : toObject(o));\nwhere\npublic final boolean isBinary() {\n    return getOrCreateContainer().getConfig().isBinary();\n}", "author": "vbekiaris", "createdAt": "2020-03-24T13:27:49Z", "path": "hazelcast/src/main/java/com/hazelcast/multimap/impl/operations/PutAllOperation.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.multimap.impl.operations;\n+\n+import com.hazelcast.core.EntryEventType;\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.map.impl.MapEntries;\n+import com.hazelcast.memory.NativeOutOfMemoryError;\n+import com.hazelcast.multimap.impl.MultiMapContainer;\n+import com.hazelcast.multimap.impl.MultiMapDataSerializerHook;\n+import com.hazelcast.multimap.impl.MultiMapRecord;\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.spi.impl.operationservice.MutatingOperation;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+\n+public class PutAllOperation extends AbstractMultiMapOperation implements MutatingOperation {\n+    private transient int currentIndex;\n+    private MapEntries mapEntries;\n+    private long recordId;\n+\n+    public PutAllOperation() {\n+        super();\n+    }\n+\n+    public PutAllOperation(String name, MapEntries mapEntries) {\n+        super(name);\n+        this.mapEntries = mapEntries;\n+        //NB: general structure copied from c.hz.map.impl.operation.PutAllOperation\n+        //May benefit from refactoring or default interfaces\n+    }\n+\n+    @Override\n+    public final void run() {\n+        try {\n+            runInternal();\n+        } catch (NativeOutOfMemoryError e) {\n+            //TODO: implement rerun?\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    protected void runInternal() {\n+        //FIXME: potentially bad idiom?\n+        int size = mapEntries != null ? mapEntries.size() : 0;\n+        while (currentIndex < size) {\n+            Data dataKey = mapEntries.getKey(currentIndex);\n+            Data value = mapEntries.getValue(currentIndex);\n+            put(dataKey, value);\n+            currentIndex++;\n+        }\n+        //FIXME: is this the best place to set response?\n+        response = true;\n+    }\n+\n+    protected void put(Data dataKey, Data dataValue) {\n+        MultiMapContainer container = getOrCreateContainer();\n+        Collection c = (Collection) toObject(dataValue);\n+        Collection<MultiMapRecord> coll = container.getOrCreateMultiMapValue(dataKey).getCollection(false);\n+        Consumer addObjToCollection = o -> {\n+            recordId = container.nextId();\n+            MultiMapRecord record = new MultiMapRecord(recordId, o);", "originalCommit": "d98853fc1667c392bc94f445adcb517df86ddf3b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3e59db4b82436572d3935ebe5d12f14fdfb1ca7c", "url": "https://github.com/hazelcast/hazelcast/commit/3e59db4b82436572d3935ebe5d12f14fdfb1ca7c", "message": "Modify interface and implementations of MultiMap.putAllAsync and related classes (#9079)\n\nRemove non async putAll interfaces. Modify MultiMap.putAllInternal interface to take in Data, Data. Amend MultiMap.putAllAsync javadoc. Remove streams implementation\n\nFix PutAllOperation record saving implementation. Fix incorrect MultimapDataSerializerHook reference.\n\nImplement Preconditions.checkTrue to take in class type.", "committedDate": "2020-03-31T03:16:06Z", "type": "forcePushed"}, {"oid": "d5eab935497c3e80d0e4201d684cae3adce677c7", "url": "https://github.com/hazelcast/hazelcast/commit/d5eab935497c3e80d0e4201d684cae3adce677c7", "message": "Modify interface and implementations of MultiMap.putAllAsync and related classes (#9079)\n\nRemove non async putAll interfaces. Modify MultiMap.putAllInternal interface to take in Data, Data. Amend MultiMap.putAllAsync javadoc. Remove streams implementation\n\nFix PutAllOperation record saving implementation. Fix incorrect MultimapDataSerializerHook reference.\n\nImplement Preconditions.checkTrue to take in class type.", "committedDate": "2020-04-01T09:33:46Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTYzNDE1Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r401634156", "bodyText": "this is IMap's put all operation factory, please revert", "author": "vbekiaris", "createdAt": "2020-04-01T13:55:11Z", "path": "hazelcast/src/main/java/com/hazelcast/map/impl/operation/PutAllPartitionAwareOperationFactory.java", "diffHunk": "@@ -27,12 +26,11 @@\n \n import java.io.IOException;\n import java.util.Arrays;\n-import java.util.Map;\n \n /**\n  * Inserts the {@link MapEntries} for all partitions of a member via locally invoked {@link PutAllOperation}.\n  * <p>\n- * Used to reduce the number of remote invocations of an {@link IMap#putAll(Map)} call.\n+ * Used to reduce the number of remote invocations of an {@link MultiMap#putAllAsync(Map) } call.", "originalCommit": "d5eab935497c3e80d0e4201d684cae3adce677c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ2NjA2OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r403466069", "bodyText": "oops. i need to schedule that appointment with a brain surgeon now ...  :O", "author": "abdulazizali77", "createdAt": "2020-04-04T12:43:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTYzNDE1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTYzNDU5Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r401634593", "bodyText": "please remove also this variant of putAllAsync with MultiMap as argument", "author": "vbekiaris", "createdAt": "2020-04-01T13:55:45Z", "path": "hazelcast/src/main/java/com/hazelcast/multimap/MultiMap.java", "diffHunk": "@@ -57,6 +58,69 @@\n  */\n @SuppressWarnings(\"checkstyle:methodcount\")\n public interface MultiMap<K, V> extends BaseMultiMap<K, V> {\n+\n+\n+    /**\n+     * Stores the given Map in the MultiMap asynchronously.\n+     * <p>\n+     * The results of concurrently mutating the given map are undefined.\n+     * <p>\n+     * No atomicity guarantees are given. It could be that in case of failure\n+     * some of the key/value-pairs get written, while others are not.\n+     * <p>\n+     * <b>Warning:</b> There is no warning if the input Map collection items are discarded due to uniqueness\n+     * eg. passing in List into a Set type MultiMap\n+     * <p>\n+     * <b>Warning:</b> The Map and result of the put cannot be fetched\n+     * from the Future.\n+     *\n+     * @param m the map to be stored\n+     * @return a void CompletionStage\n+     * @since 4.1\n+     */\n+    CompletionStage<Void> putAllAsync(@Nonnull Map<? extends K, Collection<? extends V>> m);\n+\n+    /**\n+     * Stores a specified MultiMap in the MultiMap synchronously.\n+     * <p>\n+     * The results of concurrently mutating the given MultiMap are undefined\n+     * <p>\n+     * No atomicity guarantees are given. It could be that in case of failure\n+     * some of the key/value-pairs get written, while others are not.\n+     * <p>\n+     * <b>Warning:</b> There is no warning if the input MultiMap items are discarded due to uniqueness\n+     * eg. passing in List type MultiMap into a Set type MultiMap\n+     * <p>\n+     * <b>Warning:</b> The Map and result of the put cannot be fetched\n+     * from the Future.\n+     *\n+     * @param m the map to be stored\n+     * @return a void CompletionStage\n+     * @since 4.1\n+     */\n+    CompletionStage<Void> putAllAsync(@Nonnull MultiMap<K, V> m);", "originalCommit": "d5eab935497c3e80d0e4201d684cae3adce677c7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTY1NDI1Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r401654257", "bodyText": "I think reflection is too heavy weight as an alternative to something like if (!properVersion) { throw new UnsupportedOperationException(...);}. Taking also into account the Java 9+ reflection restrictions I would rather not use reflection in this case.", "author": "vbekiaris", "createdAt": "2020-04-01T14:22:25Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/util/Preconditions.java", "diffHunk": "@@ -328,6 +329,28 @@ public static void checkTrue(boolean expression, String errorMessage) {\n         }\n     }\n \n+    /**\n+     * Tests whether the supplied expression is {@code true}.\n+     *\n+     * @param expression the expression tested to see if it is {@code true}.\n+     * @param clazz      the exception class to construct.\n+     * @param message    the exception message.\n+     * @throws java.lang.RuntimeException if the supplied expression is {@code false}.\n+     */\n+    public static void checkTrue(boolean expression, Class<? extends RuntimeException> clazz, String message)\n+            throws RuntimeException {\n+        try {\n+            if (!expression) {\n+                Constructor<? extends RuntimeException> con = clazz.getConstructor(String.class);", "originalCommit": "d5eab935497c3e80d0e4201d684cae3adce677c7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTY2MDc4Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r401660787", "bodyText": "also implement BackupAwareOperation here and:\n\nshouldBackup should return true if the put all resulted in modification of the multimap (similarly to PutOperation)\ngetSync/AsyncBackupCount are already implemented in AbstractMultiMapOperation so no need to bother with those\ngetBackupOperation must return a new PutAllBackupOperation as discussed.", "author": "vbekiaris", "createdAt": "2020-04-01T14:30:41Z", "path": "hazelcast/src/main/java/com/hazelcast/multimap/impl/operations/PutAllOperation.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.multimap.impl.operations;\n+\n+import com.hazelcast.core.EntryEventType;\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.map.impl.MapEntries;\n+import com.hazelcast.memory.NativeOutOfMemoryError;\n+import com.hazelcast.multimap.impl.MultiMapContainer;\n+import com.hazelcast.multimap.impl.MultiMapDataSerializerHook;\n+import com.hazelcast.multimap.impl.MultiMapRecord;\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.spi.impl.operationservice.MutatingOperation;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Iterator;\n+\n+public class PutAllOperation extends AbstractMultiMapOperation implements MutatingOperation {", "originalCommit": "d5eab935497c3e80d0e4201d684cae3adce677c7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTY2MjM2OA==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r401662368", "bodyText": "remove this try-catch block and pull runInternal code here. MultiMap does not support NATIVE in memory format so it's not possible for NativeOutOfMemoryError to be thrown.", "author": "vbekiaris", "createdAt": "2020-04-01T14:32:44Z", "path": "hazelcast/src/main/java/com/hazelcast/multimap/impl/operations/PutAllOperation.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.multimap.impl.operations;\n+\n+import com.hazelcast.core.EntryEventType;\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.map.impl.MapEntries;\n+import com.hazelcast.memory.NativeOutOfMemoryError;\n+import com.hazelcast.multimap.impl.MultiMapContainer;\n+import com.hazelcast.multimap.impl.MultiMapDataSerializerHook;\n+import com.hazelcast.multimap.impl.MultiMapRecord;\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.spi.impl.operationservice.MutatingOperation;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Iterator;\n+\n+public class PutAllOperation extends AbstractMultiMapOperation implements MutatingOperation {\n+    private transient int currentIndex;\n+    private MapEntries mapEntries;\n+    private long recordId;\n+\n+    public PutAllOperation() {\n+        super();\n+    }\n+\n+    public PutAllOperation(String name, MapEntries mapEntries) {\n+        super(name);\n+        this.mapEntries = mapEntries;\n+        //NB: general structure copied from c.hz.map.impl.operation.PutAllOperation\n+        //May benefit from refactoring or default interfaces\n+    }\n+\n+    @Override\n+    public final void run() {\n+        try {\n+            runInternal();\n+        } catch (NativeOutOfMemoryError e) {", "originalCommit": "d5eab935497c3e80d0e4201d684cae3adce677c7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcwNDg5Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r401704892", "bodyText": "to be removed (see relevant comment in MultiMap interface)", "author": "vbekiaris", "createdAt": "2020-04-01T15:28:40Z", "path": "hazelcast/src/main/java/com/hazelcast/multimap/impl/MultiMapProxyImpl.java", "diffHunk": "@@ -92,6 +101,47 @@ public void initialize() {\n         }\n     }\n \n+    @Override\n+    public CompletionStage<Void> putAllAsync(@Nonnull Map<? extends K, Collection<? extends V>> m) {\n+        checkTrue(isClusterVersionGreaterOrEqual(Versions.V4_1),\n+                UnsupportedOperationException.class, MINIMUM_VERSION_ERROR_4_1);\n+        InternalCompletableFuture<Void> future = new InternalCompletableFuture<>();\n+        Map<Data, Data> dataMap = new HashMap<>();\n+\n+        for (Map.Entry e : m.entrySet()) {\n+            dataMap.put(toData(e.getKey()), toData(e.getValue()));\n+        }\n+        putAllInternal(dataMap, future);\n+        return future;\n+    }\n+\n+    @Override\n+    public CompletionStage<Void> putAllAsync(@Nonnull MultiMap<K, V> m) {", "originalCommit": "d5eab935497c3e80d0e4201d684cae3adce677c7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcxNDEwMg==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r401714102", "bodyText": "I would only set response to true if a value was actually added to the multimap (so if at least one of coll.add(record) in line 84 below returned true). This way, you can check response in your shouldBackup implementation to avoid sending a backup operation when no actual changes were performed. This is similar to how the existing MultiMap PutOperation works.", "author": "vbekiaris", "createdAt": "2020-04-01T15:41:01Z", "path": "hazelcast/src/main/java/com/hazelcast/multimap/impl/operations/PutAllOperation.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.multimap.impl.operations;\n+\n+import com.hazelcast.core.EntryEventType;\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.map.impl.MapEntries;\n+import com.hazelcast.memory.NativeOutOfMemoryError;\n+import com.hazelcast.multimap.impl.MultiMapContainer;\n+import com.hazelcast.multimap.impl.MultiMapDataSerializerHook;\n+import com.hazelcast.multimap.impl.MultiMapRecord;\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.spi.impl.operationservice.MutatingOperation;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Iterator;\n+\n+public class PutAllOperation extends AbstractMultiMapOperation implements MutatingOperation {\n+    private transient int currentIndex;\n+    private MapEntries mapEntries;\n+    private long recordId;\n+\n+    public PutAllOperation() {\n+        super();\n+    }\n+\n+    public PutAllOperation(String name, MapEntries mapEntries) {\n+        super(name);\n+        this.mapEntries = mapEntries;\n+        //NB: general structure copied from c.hz.map.impl.operation.PutAllOperation\n+        //May benefit from refactoring or default interfaces\n+    }\n+\n+    @Override\n+    public final void run() {\n+        try {\n+            runInternal();\n+        } catch (NativeOutOfMemoryError e) {\n+            //TODO: implement rerun?\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    protected void runInternal() {\n+        //FIXME: potentially bad idiom?\n+        int size = mapEntries != null ? mapEntries.size() : 0;\n+        while (currentIndex < size) {\n+            Data dataKey = mapEntries.getKey(currentIndex);\n+            Data value = mapEntries.getValue(currentIndex);\n+            put(dataKey, value);\n+            currentIndex++;\n+        }\n+        //FIXME: is this the best place to set response?\n+        response = true;", "originalCommit": "d5eab935497c3e80d0e4201d684cae3adce677c7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcxNTQ1NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r401715455", "bodyText": "as soon as you no longer need these System.outs (probably inserted for debugging?), please remove them.", "author": "vbekiaris", "createdAt": "2020-04-01T15:42:52Z", "path": "hazelcast/src/test/java/com/hazelcast/multimap/MultiMapTest.java", "diffHunk": "@@ -104,6 +114,184 @@ public void testMultiMapPutGetRemove() {\n         assertEquals(0, multiMap.size());\n     }\n \n+    protected <K, V> EntryListener<K, V> putAllEntryListenerBuilder(Consumer<EntryEvent<K, V>> f) {\n+        return new EntryAdapter<K, V>() {\n+            public void entryAdded(EntryEvent<K, V> event) {\n+                f.accept(event);\n+            }\n+\n+            public void entryRemoved(EntryEvent<K, V> event) {\n+                System.out.println(\"entryRemoved \" + event);", "originalCommit": "d5eab935497c3e80d0e4201d684cae3adce677c7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcyMDQzMg==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r401720432", "bodyText": "you can use the compile-time safe variant setValueCollectionType(ValueCollectionType valueCollectionType) (here + 3 more instances below).", "author": "vbekiaris", "createdAt": "2020-04-01T15:49:27Z", "path": "hazelcast/src/test/java/com/hazelcast/multimap/MultiMapTest.java", "diffHunk": "@@ -104,6 +114,184 @@ public void testMultiMapPutGetRemove() {\n         assertEquals(0, multiMap.size());\n     }\n \n+    protected <K, V> EntryListener<K, V> putAllEntryListenerBuilder(Consumer<EntryEvent<K, V>> f) {\n+        return new EntryAdapter<K, V>() {\n+            public void entryAdded(EntryEvent<K, V> event) {\n+                f.accept(event);\n+            }\n+\n+            public void entryRemoved(EntryEvent<K, V> event) {\n+                System.out.println(\"entryRemoved \" + event);\n+            }\n+\n+            public void entryEvicted(EntryEvent<K, V> event) {\n+                entryRemoved(event);\n+            }\n+\n+            @Override\n+            public void mapEvicted(MapEvent event) {\n+            }\n+\n+            @Override\n+            public void mapCleared(MapEvent event) {\n+                System.out.println(\"mapCleared \" + event);\n+            }\n+        };\n+    }\n+\n+    protected HazelcastInstance testMultiMapPutAllSetup() {\n+        MultiMapConfig multiMapConfig1 = new MultiMapConfig()\n+                .setName(\"testMultiMapPutAllMapList\")\n+                .setValueCollectionType(\"LIST\")", "originalCommit": "d5eab935497c3e80d0e4201d684cae3adce677c7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcyMjIyMA==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r401722220", "bodyText": "don't catch exceptions here, you want them to be thrown and fail the test", "author": "vbekiaris", "createdAt": "2020-04-01T15:52:00Z", "path": "hazelcast/src/test/java/com/hazelcast/multimap/MultiMapTest.java", "diffHunk": "@@ -104,6 +114,184 @@ public void testMultiMapPutGetRemove() {\n         assertEquals(0, multiMap.size());\n     }\n \n+    protected <K, V> EntryListener<K, V> putAllEntryListenerBuilder(Consumer<EntryEvent<K, V>> f) {\n+        return new EntryAdapter<K, V>() {\n+            public void entryAdded(EntryEvent<K, V> event) {\n+                f.accept(event);\n+            }\n+\n+            public void entryRemoved(EntryEvent<K, V> event) {\n+                System.out.println(\"entryRemoved \" + event);\n+            }\n+\n+            public void entryEvicted(EntryEvent<K, V> event) {\n+                entryRemoved(event);\n+            }\n+\n+            @Override\n+            public void mapEvicted(MapEvent event) {\n+            }\n+\n+            @Override\n+            public void mapCleared(MapEvent event) {\n+                System.out.println(\"mapCleared \" + event);\n+            }\n+        };\n+    }\n+\n+    protected HazelcastInstance testMultiMapPutAllSetup() {\n+        MultiMapConfig multiMapConfig1 = new MultiMapConfig()\n+                .setName(\"testMultiMapPutAllMapList\")\n+                .setValueCollectionType(\"LIST\")\n+                .setBinary(false);\n+        MultiMapConfig multiMapConfig2 = new MultiMapConfig()\n+                .setName(\"testMultiMapPutAllMapSet\")\n+                .setValueCollectionType(\"SET\")\n+                .setBinary(false);\n+        MultiMapConfig multiMapConfig3 = new MultiMapConfig()\n+                .setName(\"expectedMultiMap1\")\n+                .setValueCollectionType(\"LIST\")\n+                .setBinary(false);\n+        Config cfg = smallInstanceConfig()\n+                .addMultiMapConfig(multiMapConfig1)\n+                .addMultiMapConfig(multiMapConfig2)\n+                .addMultiMapConfig(multiMapConfig3);\n+        HazelcastInstance hz = createHazelcastInstanceFactory(1)\n+                .newInstances(cfg)[0];\n+\n+        return hz;\n+    }\n+\n+    public void testMultiMapPutAllTemplate(HazelcastInstance instance1,\n+                                           Map<String, Collection<? extends Integer>> expectedMultiMap1,\n+                                           MultiMap<String, Integer> expectedMultiMap2,\n+                                           Consumer<MultiMap<String, Integer>> putAllOperation1) {\n+\n+        MultiMap<String, Integer> mmap1 = instance1.getMultiMap(\"testMultiMapPutAllMapList\");\n+        MultiMap<String, Integer> mmap2 = instance1.getMultiMap(\"testMultiMapPutAllMapSet\");\n+        Map<String, Collection<Integer>> resultMap1 = new HashMap<>();\n+        Map<String, Collection<Integer>> resultMap2 = new HashMap<>();\n+\n+        int totalItems = 0;\n+        Set<String> ks = expectedMultiMap1 != null\n+                ? expectedMultiMap1.keySet() : expectedMultiMap2.keySet();\n+        for (String s : ks) {\n+            Collection expectedCollection = expectedMultiMap1 != null\n+                    ? expectedMultiMap1.get(s) : expectedMultiMap2.get(s);\n+            totalItems += expectedCollection.size()\n+                    + ((Long) expectedCollection.stream().distinct().count()).intValue();\n+        }\n+\n+        final CountDownLatch latchAdded = new CountDownLatch(totalItems);\n+        mmap1.addEntryListener(putAllEntryListenerBuilder((event) -> {\n+                    String key = (String) event.getKey();\n+                    Integer value = (Integer) event.getValue();\n+                    Collection<Integer> c;\n+                    if (!resultMap1.containsKey(key)) {\n+                        c = new ArrayList<>();\n+                    } else {\n+                        c = resultMap1.get(key);\n+                    }\n+                    c.add(value);\n+                    resultMap1.put(key, c);\n+                    latchAdded.countDown();\n+                }\n+        ), true);\n+        mmap2.addEntryListener(putAllEntryListenerBuilder((event) -> {\n+                    String key = (String) event.getKey();\n+                    Integer value = (Integer) event.getValue();\n+                    Collection<Integer> c;\n+                    if (!resultMap2.containsKey(key)) {\n+                        c = new ArrayList<>();\n+                    } else {\n+                        c = resultMap2.get(key);\n+                    }\n+                    c.add(value);\n+\n+                    resultMap2.put(key, c);\n+                    latchAdded.countDown();\n+                }\n+        ), true);\n+        try {\n+            putAllOperation1.accept(mmap1);\n+            putAllOperation1.accept(mmap2);\n+            latchAdded.await(5, TimeUnit.MINUTES);\n+\n+            for (String s : ks) {\n+                Collection c1 = resultMap1.get(s);\n+                Collection c2 = resultMap2.get(s);\n+                Collection expectedCollection = expectedMultiMap1 != null\n+                        ? expectedMultiMap1.get(s) : expectedMultiMap2.get(s);\n+                assertEquals(expectedCollection.size(), c1.size());\n+                assertEquals(expectedCollection.stream().distinct().count(), c2.size());\n+            }\n+\n+        } catch (Exception e) {", "originalCommit": "d5eab935497c3e80d0e4201d684cae3adce677c7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcyNDUyNA==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r401724524", "bodyText": "this class needs some clean up to get rid of too many TODOs, eg anything related to a potential future implementation of batching can be completely removed", "author": "vbekiaris", "createdAt": "2020-04-01T15:55:08Z", "path": "hazelcast/src/main/java/com/hazelcast/multimap/impl/MultiMapProxySupport.java", "diffHunk": "@@ -16,54 +16,268 @@\n \n package com.hazelcast.multimap.impl;\n \n-import com.hazelcast.internal.locksupport.LockProxySupport;\n-import com.hazelcast.internal.locksupport.LockSupportServiceImpl;\n+import com.hazelcast.cluster.Address;\n import com.hazelcast.config.MultiMapConfig;\n import com.hazelcast.core.EntryEventType;\n+import com.hazelcast.internal.locksupport.LockProxySupport;\n+import com.hazelcast.internal.locksupport.LockSupportServiceImpl;\n+import com.hazelcast.internal.partition.IPartitionService;\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.internal.serialization.SerializationService;\n+import com.hazelcast.internal.services.DistributedObjectNamespace;\n+import com.hazelcast.internal.util.ExceptionUtil;\n+import com.hazelcast.internal.util.ThreadUtil;\n+import com.hazelcast.map.impl.MapEntries;\n import com.hazelcast.multimap.impl.operations.CountOperation;\n import com.hazelcast.multimap.impl.operations.DeleteOperation;\n import com.hazelcast.multimap.impl.operations.GetAllOperation;\n import com.hazelcast.multimap.impl.operations.MultiMapOperationFactory;\n import com.hazelcast.multimap.impl.operations.MultiMapOperationFactory.OperationFactoryType;\n+import com.hazelcast.multimap.impl.operations.MultiMapPutAllOperationFactory;\n import com.hazelcast.multimap.impl.operations.MultiMapResponse;\n import com.hazelcast.multimap.impl.operations.PutOperation;\n import com.hazelcast.multimap.impl.operations.RemoveAllOperation;\n import com.hazelcast.multimap.impl.operations.RemoveOperation;\n-import com.hazelcast.internal.serialization.Data;\n import com.hazelcast.spi.impl.AbstractDistributedObject;\n-import com.hazelcast.internal.services.DistributedObjectNamespace;\n+import com.hazelcast.spi.impl.InternalCompletableFuture;\n import com.hazelcast.spi.impl.NodeEngine;\n import com.hazelcast.spi.impl.operationservice.Operation;\n-import com.hazelcast.internal.util.ExceptionUtil;\n-import com.hazelcast.internal.util.ThreadUtil;\n+import com.hazelcast.spi.impl.operationservice.OperationFactory;\n+import com.hazelcast.spi.impl.operationservice.OperationService;\n \n+import javax.annotation.Nullable;\n+import java.util.Arrays;\n import java.util.HashSet;\n+import java.util.List;\n import java.util.Map;\n import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.Future;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.BiConsumer;\n \n+import static com.hazelcast.internal.util.CollectionUtil.asIntegerList;\n+import static com.hazelcast.internal.util.ConcurrencyUtil.CALLER_RUNS;\n+import static com.hazelcast.internal.util.ExceptionUtil.rethrow;\n import static com.hazelcast.internal.util.MapUtil.toIntSize;\n+import static com.hazelcast.internal.util.Preconditions.checkNotNull;\n+import static com.hazelcast.multimap.impl.MultiMapProxyImpl.NULL_KEY_IS_NOT_ALLOWED;\n+import static com.hazelcast.multimap.impl.MultiMapProxyImpl.NULL_VALUE_IS_NOT_ALLOWED;\n+import static com.hazelcast.spi.impl.InternalCompletableFuture.newCompletedFuture;\n+import static java.lang.Math.ceil;\n+import static java.lang.Math.log10;\n+import static java.util.Collections.singletonMap;\n \n public abstract class MultiMapProxySupport extends AbstractDistributedObject<MultiMapService> {\n \n     protected final MultiMapConfig config;\n     protected final String name;\n     protected final LockProxySupport lockSupport;\n+    protected final SerializationService serializationService;\n+    protected final OperationService operationService;\n+    protected final IPartitionService partitionService;\n+    private final float putAllInitialSizeFactor;\n \n     protected MultiMapProxySupport(MultiMapConfig config, MultiMapService service, NodeEngine nodeEngine, String name) {\n         super(nodeEngine, service);\n         this.config = config;\n         this.name = name;\n \n+        this.partitionService = nodeEngine.getPartitionService();\n+        this.serializationService = nodeEngine.getSerializationService();\n+        this.operationService = nodeEngine.getOperationService();\n+\n         lockSupport = new LockProxySupport(new DistributedObjectNamespace(MultiMapService.SERVICE_NAME, name),\n                 LockSupportServiceImpl.getMaxLeaseTimeInMillis(nodeEngine.getProperties()));\n+\n+        //TODO: implement properties and properties.getFloat(MAP_PUT_ALL_INITIAL_SIZE_FACTOR);\n+        this.putAllInitialSizeFactor = 1;\n     }\n \n     @Override\n     public String getName() {\n         return name;\n     }\n \n+    //NB: this method is copied from MapProxySupport#getPutAllInitialSize\n+    @SuppressWarnings(\"checkstyle:magicnumber\")\n+    private int getPutAllInitialSize(boolean useBatching, int mapSize, int partitionCount) {", "originalCommit": "d5eab935497c3e80d0e4201d684cae3adce677c7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcyNTg1MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r401725851", "bodyText": "entry.getValue() is already Data here, no need to wrap it in toData()", "author": "vbekiaris", "createdAt": "2020-04-01T15:56:58Z", "path": "hazelcast/src/main/java/com/hazelcast/multimap/impl/MultiMapProxySupport.java", "diffHunk": "@@ -16,54 +16,268 @@\n \n package com.hazelcast.multimap.impl;\n \n-import com.hazelcast.internal.locksupport.LockProxySupport;\n-import com.hazelcast.internal.locksupport.LockSupportServiceImpl;\n+import com.hazelcast.cluster.Address;\n import com.hazelcast.config.MultiMapConfig;\n import com.hazelcast.core.EntryEventType;\n+import com.hazelcast.internal.locksupport.LockProxySupport;\n+import com.hazelcast.internal.locksupport.LockSupportServiceImpl;\n+import com.hazelcast.internal.partition.IPartitionService;\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.internal.serialization.SerializationService;\n+import com.hazelcast.internal.services.DistributedObjectNamespace;\n+import com.hazelcast.internal.util.ExceptionUtil;\n+import com.hazelcast.internal.util.ThreadUtil;\n+import com.hazelcast.map.impl.MapEntries;\n import com.hazelcast.multimap.impl.operations.CountOperation;\n import com.hazelcast.multimap.impl.operations.DeleteOperation;\n import com.hazelcast.multimap.impl.operations.GetAllOperation;\n import com.hazelcast.multimap.impl.operations.MultiMapOperationFactory;\n import com.hazelcast.multimap.impl.operations.MultiMapOperationFactory.OperationFactoryType;\n+import com.hazelcast.multimap.impl.operations.MultiMapPutAllOperationFactory;\n import com.hazelcast.multimap.impl.operations.MultiMapResponse;\n import com.hazelcast.multimap.impl.operations.PutOperation;\n import com.hazelcast.multimap.impl.operations.RemoveAllOperation;\n import com.hazelcast.multimap.impl.operations.RemoveOperation;\n-import com.hazelcast.internal.serialization.Data;\n import com.hazelcast.spi.impl.AbstractDistributedObject;\n-import com.hazelcast.internal.services.DistributedObjectNamespace;\n+import com.hazelcast.spi.impl.InternalCompletableFuture;\n import com.hazelcast.spi.impl.NodeEngine;\n import com.hazelcast.spi.impl.operationservice.Operation;\n-import com.hazelcast.internal.util.ExceptionUtil;\n-import com.hazelcast.internal.util.ThreadUtil;\n+import com.hazelcast.spi.impl.operationservice.OperationFactory;\n+import com.hazelcast.spi.impl.operationservice.OperationService;\n \n+import javax.annotation.Nullable;\n+import java.util.Arrays;\n import java.util.HashSet;\n+import java.util.List;\n import java.util.Map;\n import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.Future;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.BiConsumer;\n \n+import static com.hazelcast.internal.util.CollectionUtil.asIntegerList;\n+import static com.hazelcast.internal.util.ConcurrencyUtil.CALLER_RUNS;\n+import static com.hazelcast.internal.util.ExceptionUtil.rethrow;\n import static com.hazelcast.internal.util.MapUtil.toIntSize;\n+import static com.hazelcast.internal.util.Preconditions.checkNotNull;\n+import static com.hazelcast.multimap.impl.MultiMapProxyImpl.NULL_KEY_IS_NOT_ALLOWED;\n+import static com.hazelcast.multimap.impl.MultiMapProxyImpl.NULL_VALUE_IS_NOT_ALLOWED;\n+import static com.hazelcast.spi.impl.InternalCompletableFuture.newCompletedFuture;\n+import static java.lang.Math.ceil;\n+import static java.lang.Math.log10;\n+import static java.util.Collections.singletonMap;\n \n public abstract class MultiMapProxySupport extends AbstractDistributedObject<MultiMapService> {\n \n     protected final MultiMapConfig config;\n     protected final String name;\n     protected final LockProxySupport lockSupport;\n+    protected final SerializationService serializationService;\n+    protected final OperationService operationService;\n+    protected final IPartitionService partitionService;\n+    private final float putAllInitialSizeFactor;\n \n     protected MultiMapProxySupport(MultiMapConfig config, MultiMapService service, NodeEngine nodeEngine, String name) {\n         super(nodeEngine, service);\n         this.config = config;\n         this.name = name;\n \n+        this.partitionService = nodeEngine.getPartitionService();\n+        this.serializationService = nodeEngine.getSerializationService();\n+        this.operationService = nodeEngine.getOperationService();\n+\n         lockSupport = new LockProxySupport(new DistributedObjectNamespace(MultiMapService.SERVICE_NAME, name),\n                 LockSupportServiceImpl.getMaxLeaseTimeInMillis(nodeEngine.getProperties()));\n+\n+        //TODO: implement properties and properties.getFloat(MAP_PUT_ALL_INITIAL_SIZE_FACTOR);\n+        this.putAllInitialSizeFactor = 1;\n     }\n \n     @Override\n     public String getName() {\n         return name;\n     }\n \n+    //NB: this method is copied from MapProxySupport#getPutAllInitialSize\n+    @SuppressWarnings(\"checkstyle:magicnumber\")\n+    private int getPutAllInitialSize(boolean useBatching, int mapSize, int partitionCount) {\n+        if (mapSize == 1) {\n+            return 1;\n+        }\n+        //TODO: implement batching\n+        /*\n+        if (useBatching) {\n+            return putAllBatchSize;\n+        }*/\n+        if (putAllInitialSizeFactor < 1) {\n+            // this is an educated guess for the initial size of the entries per partition, depending on the map size\n+            return (int) ceil(20f * mapSize / partitionCount / log10(mapSize));\n+        }\n+        return (int) ceil(putAllInitialSizeFactor * mapSize / partitionCount);\n+    }\n+\n+    //NB: this method is generally copied from MapProxySupport#putAllInternal\n+    @SuppressWarnings({\"checkstyle:npathcomplexity\", \"checkstyle:methodlength\"})\n+    protected void putAllInternal(Map<Data, Data> map,\n+                                  @Nullable InternalCompletableFuture<Void> future) {\n+\n+        //get partition to entries mapping\n+        try {\n+            int mapSize = map.size();\n+            if (mapSize == 0) {\n+                if (future != null) {\n+                    future.complete(null);\n+                }\n+                return;\n+            }\n+\n+            //TODO: implement batching\n+            //boolean useBatching = future == null && isPutAllUseBatching(mapSize);\n+            int partitionCount = partitionService.getPartitionCount();\n+            int initialSize = getPutAllInitialSize(false, mapSize, partitionCount);\n+\n+            //get node to partition mapping\n+            Map<Address, List<Integer>> memberPartitionsMap = partitionService.getMemberPartitionsMap();\n+\n+            //TODO: implement batching\n+            /*\n+            MutableLong[] counterPerMember = null;\n+            Address[] addresses = null;\n+            if (useBatching) {\n+                counterPerMember = new MutableLong[partitionCount];\n+                addresses = new Address[partitionCount];\n+                for (Map.Entry<Address, List<Integer>> addressListEntry : memberPartitionsMap.entrySet()) {\n+                    MutableLong counter = new MutableLong();\n+                    Address address = addressListEntry.getKey();\n+                    for (int partitionId : addressListEntry.getValue()) {\n+                        counterPerMember[partitionId] = counter;\n+                        addresses[partitionId] = address;\n+                    }\n+                }\n+            }\n+            */\n+\n+            // fill entriesPerPartition\n+            MapEntries[] entriesPerPartition = new MapEntries[partitionCount];\n+\n+            for (Map.Entry<Data, Data> entry : map.entrySet()) {\n+                checkNotNull(entry.getKey(), NULL_KEY_IS_NOT_ALLOWED);\n+                checkNotNull(entry.getValue(), NULL_VALUE_IS_NOT_ALLOWED);\n+\n+                //TODO: add and use PartitioningStrategy?\n+                Data keyData = entry.getKey();\n+\n+                int partitionId = partitionService.getPartitionId(keyData);\n+                MapEntries entries = entriesPerPartition[partitionId];\n+                if (entries == null) {\n+                    entries = new MapEntries(initialSize);\n+                    entriesPerPartition[partitionId] = entries;\n+                }\n+                entries.add(keyData, toData(entry.getValue()));", "originalCommit": "d5eab935497c3e80d0e4201d684cae3adce677c7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcyNzMyNw==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r401727327", "bodyText": "consider adding test for stats of putAllAsync in MultiMapContainerStatisticsTest", "author": "vbekiaris", "createdAt": "2020-04-01T15:58:55Z", "path": "hazelcast/src/main/java/com/hazelcast/multimap/impl/MultiMapProxySupport.java", "diffHunk": "@@ -16,54 +16,268 @@\n \n package com.hazelcast.multimap.impl;\n \n-import com.hazelcast.internal.locksupport.LockProxySupport;\n-import com.hazelcast.internal.locksupport.LockSupportServiceImpl;\n+import com.hazelcast.cluster.Address;\n import com.hazelcast.config.MultiMapConfig;\n import com.hazelcast.core.EntryEventType;\n+import com.hazelcast.internal.locksupport.LockProxySupport;\n+import com.hazelcast.internal.locksupport.LockSupportServiceImpl;\n+import com.hazelcast.internal.partition.IPartitionService;\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.internal.serialization.SerializationService;\n+import com.hazelcast.internal.services.DistributedObjectNamespace;\n+import com.hazelcast.internal.util.ExceptionUtil;\n+import com.hazelcast.internal.util.ThreadUtil;\n+import com.hazelcast.map.impl.MapEntries;\n import com.hazelcast.multimap.impl.operations.CountOperation;\n import com.hazelcast.multimap.impl.operations.DeleteOperation;\n import com.hazelcast.multimap.impl.operations.GetAllOperation;\n import com.hazelcast.multimap.impl.operations.MultiMapOperationFactory;\n import com.hazelcast.multimap.impl.operations.MultiMapOperationFactory.OperationFactoryType;\n+import com.hazelcast.multimap.impl.operations.MultiMapPutAllOperationFactory;\n import com.hazelcast.multimap.impl.operations.MultiMapResponse;\n import com.hazelcast.multimap.impl.operations.PutOperation;\n import com.hazelcast.multimap.impl.operations.RemoveAllOperation;\n import com.hazelcast.multimap.impl.operations.RemoveOperation;\n-import com.hazelcast.internal.serialization.Data;\n import com.hazelcast.spi.impl.AbstractDistributedObject;\n-import com.hazelcast.internal.services.DistributedObjectNamespace;\n+import com.hazelcast.spi.impl.InternalCompletableFuture;\n import com.hazelcast.spi.impl.NodeEngine;\n import com.hazelcast.spi.impl.operationservice.Operation;\n-import com.hazelcast.internal.util.ExceptionUtil;\n-import com.hazelcast.internal.util.ThreadUtil;\n+import com.hazelcast.spi.impl.operationservice.OperationFactory;\n+import com.hazelcast.spi.impl.operationservice.OperationService;\n \n+import javax.annotation.Nullable;\n+import java.util.Arrays;\n import java.util.HashSet;\n+import java.util.List;\n import java.util.Map;\n import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.Future;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.BiConsumer;\n \n+import static com.hazelcast.internal.util.CollectionUtil.asIntegerList;\n+import static com.hazelcast.internal.util.ConcurrencyUtil.CALLER_RUNS;\n+import static com.hazelcast.internal.util.ExceptionUtil.rethrow;\n import static com.hazelcast.internal.util.MapUtil.toIntSize;\n+import static com.hazelcast.internal.util.Preconditions.checkNotNull;\n+import static com.hazelcast.multimap.impl.MultiMapProxyImpl.NULL_KEY_IS_NOT_ALLOWED;\n+import static com.hazelcast.multimap.impl.MultiMapProxyImpl.NULL_VALUE_IS_NOT_ALLOWED;\n+import static com.hazelcast.spi.impl.InternalCompletableFuture.newCompletedFuture;\n+import static java.lang.Math.ceil;\n+import static java.lang.Math.log10;\n+import static java.util.Collections.singletonMap;\n \n public abstract class MultiMapProxySupport extends AbstractDistributedObject<MultiMapService> {\n \n     protected final MultiMapConfig config;\n     protected final String name;\n     protected final LockProxySupport lockSupport;\n+    protected final SerializationService serializationService;\n+    protected final OperationService operationService;\n+    protected final IPartitionService partitionService;\n+    private final float putAllInitialSizeFactor;\n \n     protected MultiMapProxySupport(MultiMapConfig config, MultiMapService service, NodeEngine nodeEngine, String name) {\n         super(nodeEngine, service);\n         this.config = config;\n         this.name = name;\n \n+        this.partitionService = nodeEngine.getPartitionService();\n+        this.serializationService = nodeEngine.getSerializationService();\n+        this.operationService = nodeEngine.getOperationService();\n+\n         lockSupport = new LockProxySupport(new DistributedObjectNamespace(MultiMapService.SERVICE_NAME, name),\n                 LockSupportServiceImpl.getMaxLeaseTimeInMillis(nodeEngine.getProperties()));\n+\n+        //TODO: implement properties and properties.getFloat(MAP_PUT_ALL_INITIAL_SIZE_FACTOR);\n+        this.putAllInitialSizeFactor = 1;\n     }\n \n     @Override\n     public String getName() {\n         return name;\n     }\n \n+    //NB: this method is copied from MapProxySupport#getPutAllInitialSize\n+    @SuppressWarnings(\"checkstyle:magicnumber\")\n+    private int getPutAllInitialSize(boolean useBatching, int mapSize, int partitionCount) {\n+        if (mapSize == 1) {\n+            return 1;\n+        }\n+        //TODO: implement batching\n+        /*\n+        if (useBatching) {\n+            return putAllBatchSize;\n+        }*/\n+        if (putAllInitialSizeFactor < 1) {\n+            // this is an educated guess for the initial size of the entries per partition, depending on the map size\n+            return (int) ceil(20f * mapSize / partitionCount / log10(mapSize));\n+        }\n+        return (int) ceil(putAllInitialSizeFactor * mapSize / partitionCount);\n+    }\n+\n+    //NB: this method is generally copied from MapProxySupport#putAllInternal\n+    @SuppressWarnings({\"checkstyle:npathcomplexity\", \"checkstyle:methodlength\"})\n+    protected void putAllInternal(Map<Data, Data> map,\n+                                  @Nullable InternalCompletableFuture<Void> future) {\n+\n+        //get partition to entries mapping\n+        try {\n+            int mapSize = map.size();\n+            if (mapSize == 0) {\n+                if (future != null) {\n+                    future.complete(null);\n+                }\n+                return;\n+            }\n+\n+            //TODO: implement batching\n+            //boolean useBatching = future == null && isPutAllUseBatching(mapSize);\n+            int partitionCount = partitionService.getPartitionCount();\n+            int initialSize = getPutAllInitialSize(false, mapSize, partitionCount);\n+\n+            //get node to partition mapping\n+            Map<Address, List<Integer>> memberPartitionsMap = partitionService.getMemberPartitionsMap();\n+\n+            //TODO: implement batching\n+            /*\n+            MutableLong[] counterPerMember = null;\n+            Address[] addresses = null;\n+            if (useBatching) {\n+                counterPerMember = new MutableLong[partitionCount];\n+                addresses = new Address[partitionCount];\n+                for (Map.Entry<Address, List<Integer>> addressListEntry : memberPartitionsMap.entrySet()) {\n+                    MutableLong counter = new MutableLong();\n+                    Address address = addressListEntry.getKey();\n+                    for (int partitionId : addressListEntry.getValue()) {\n+                        counterPerMember[partitionId] = counter;\n+                        addresses[partitionId] = address;\n+                    }\n+                }\n+            }\n+            */\n+\n+            // fill entriesPerPartition\n+            MapEntries[] entriesPerPartition = new MapEntries[partitionCount];\n+\n+            for (Map.Entry<Data, Data> entry : map.entrySet()) {\n+                checkNotNull(entry.getKey(), NULL_KEY_IS_NOT_ALLOWED);\n+                checkNotNull(entry.getValue(), NULL_VALUE_IS_NOT_ALLOWED);\n+\n+                //TODO: add and use PartitioningStrategy?\n+                Data keyData = entry.getKey();\n+\n+                int partitionId = partitionService.getPartitionId(keyData);\n+                MapEntries entries = entriesPerPartition[partitionId];\n+                if (entries == null) {\n+                    entries = new MapEntries(initialSize);\n+                    entriesPerPartition[partitionId] = entries;\n+                }\n+                entries.add(keyData, toData(entry.getValue()));\n+\n+                //TODO:implement batching\n+                /*\n+                if (useBatching) {\n+                    long currentSize = ++counterPerMember[partitionId].value;\n+                    if (currentSize % putAllBatchSize == 0) {\n+                        List<Integer> partitions = memberPartitionsMap.get(addresses[partitionId]);\n+                        invokePutAllOperation(addresses[partitionId], partitions, entriesPerPartition)\n+                                .get();\n+                    }\n+                }\n+                */\n+            }\n+            // invoke operations for entriesPerPartition\n+            AtomicInteger counter = new AtomicInteger(memberPartitionsMap.size());\n+            InternalCompletableFuture<Void> resultFuture =\n+                    future != null ? future : new InternalCompletableFuture<>();\n+            BiConsumer<Void, Throwable> callback = (response, t) -> {\n+                if (t != null) {\n+                    resultFuture.completeExceptionally(t);\n+                }\n+\n+                if (counter.decrementAndGet() == 0) {\n+                    //FIXME: implement finalizePutAll(map);\n+                    if (!resultFuture.isDone()) {\n+                        resultFuture.complete(null);\n+                    }\n+                }\n+            };\n+            for (Map.Entry<Address, List<Integer>> entry : memberPartitionsMap.entrySet()) {\n+                invokePutAllOperation(entry.getKey(), entry.getValue(), entriesPerPartition).whenCompleteAsync(callback);\n+            }\n+            // if executing in sync mode, block for the responses\n+            if (future == null) {\n+                resultFuture.get();\n+            }\n+        } catch (Throwable e) {\n+            throw rethrow(e);\n+        }\n+    }\n+\n+    //NB: this method is generally copied from MapProxySupport#invokePutAllOperation\n+    private InternalCompletableFuture<Void> invokePutAllOperation(\n+            Address address,\n+            List<Integer> memberPartitions,\n+            MapEntries[] entriesPerPartition\n+    ) {\n+        int size = memberPartitions.size();\n+        int[] partitions = new int[size];\n+        int index = 0;\n+        for (Integer partitionId : memberPartitions) {\n+            if (entriesPerPartition[partitionId] != null) {\n+                partitions[index++] = partitionId;\n+            }\n+        }\n+        if (index == 0) {\n+            return newCompletedFuture(null);\n+        }\n+        // trim partition array to real size\n+        if (index < size) {\n+            partitions = Arrays.copyOf(partitions, index);\n+            size = index;\n+        }\n+\n+        index = 0;\n+        MapEntries[] entries = new MapEntries[size];\n+        long totalSize = 0;\n+        for (int partitionId : partitions) {\n+            int batchSize = entriesPerPartition[partitionId].size();\n+            //FIXME: implement batching\n+            //assert (putAllBatchSize == 0 || batchSize <= putAllBatchSize);\n+            entries[index++] = entriesPerPartition[partitionId];\n+            totalSize += batchSize;\n+            entriesPerPartition[partitionId] = null;\n+        }\n+        if (totalSize == 0) {\n+            return newCompletedFuture(null);\n+        }\n+\n+        OperationFactory factory = new MultiMapPutAllOperationFactory(name, partitions, entries);\n+        long startTimeNanos = System.nanoTime();\n+        CompletableFuture<Map<Integer, Object>> future =\n+                operationService.invokeOnPartitionsAsync(MultiMapService.SERVICE_NAME, factory,\n+                        singletonMap(address, asIntegerList(partitions)));\n+        InternalCompletableFuture<Void> resultFuture = new InternalCompletableFuture<>();\n+        long finalTotalSize = totalSize;\n+        future.whenCompleteAsync((response, t) -> {\n+            //TODO: implement putAllVisitSerializedKeys\n+            //putAllVisitSerializedKeys(entries);\n+\n+            if (t == null) {\n+                //TODO: verify stats\n+                getService().getLocalMultiMapStatsImpl(name).incrementPutLatencyNanos(finalTotalSize,", "originalCommit": "d5eab935497c3e80d0e4201d684cae3adce677c7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcyODY0MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r401728641", "bodyText": "I think serializationService can be removed as it is not used", "author": "vbekiaris", "createdAt": "2020-04-01T16:00:46Z", "path": "hazelcast/src/main/java/com/hazelcast/multimap/impl/MultiMapProxySupport.java", "diffHunk": "@@ -16,54 +16,268 @@\n \n package com.hazelcast.multimap.impl;\n \n-import com.hazelcast.internal.locksupport.LockProxySupport;\n-import com.hazelcast.internal.locksupport.LockSupportServiceImpl;\n+import com.hazelcast.cluster.Address;\n import com.hazelcast.config.MultiMapConfig;\n import com.hazelcast.core.EntryEventType;\n+import com.hazelcast.internal.locksupport.LockProxySupport;\n+import com.hazelcast.internal.locksupport.LockSupportServiceImpl;\n+import com.hazelcast.internal.partition.IPartitionService;\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.internal.serialization.SerializationService;\n+import com.hazelcast.internal.services.DistributedObjectNamespace;\n+import com.hazelcast.internal.util.ExceptionUtil;\n+import com.hazelcast.internal.util.ThreadUtil;\n+import com.hazelcast.map.impl.MapEntries;\n import com.hazelcast.multimap.impl.operations.CountOperation;\n import com.hazelcast.multimap.impl.operations.DeleteOperation;\n import com.hazelcast.multimap.impl.operations.GetAllOperation;\n import com.hazelcast.multimap.impl.operations.MultiMapOperationFactory;\n import com.hazelcast.multimap.impl.operations.MultiMapOperationFactory.OperationFactoryType;\n+import com.hazelcast.multimap.impl.operations.MultiMapPutAllOperationFactory;\n import com.hazelcast.multimap.impl.operations.MultiMapResponse;\n import com.hazelcast.multimap.impl.operations.PutOperation;\n import com.hazelcast.multimap.impl.operations.RemoveAllOperation;\n import com.hazelcast.multimap.impl.operations.RemoveOperation;\n-import com.hazelcast.internal.serialization.Data;\n import com.hazelcast.spi.impl.AbstractDistributedObject;\n-import com.hazelcast.internal.services.DistributedObjectNamespace;\n+import com.hazelcast.spi.impl.InternalCompletableFuture;\n import com.hazelcast.spi.impl.NodeEngine;\n import com.hazelcast.spi.impl.operationservice.Operation;\n-import com.hazelcast.internal.util.ExceptionUtil;\n-import com.hazelcast.internal.util.ThreadUtil;\n+import com.hazelcast.spi.impl.operationservice.OperationFactory;\n+import com.hazelcast.spi.impl.operationservice.OperationService;\n \n+import javax.annotation.Nullable;\n+import java.util.Arrays;\n import java.util.HashSet;\n+import java.util.List;\n import java.util.Map;\n import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.Future;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.BiConsumer;\n \n+import static com.hazelcast.internal.util.CollectionUtil.asIntegerList;\n+import static com.hazelcast.internal.util.ConcurrencyUtil.CALLER_RUNS;\n+import static com.hazelcast.internal.util.ExceptionUtil.rethrow;\n import static com.hazelcast.internal.util.MapUtil.toIntSize;\n+import static com.hazelcast.internal.util.Preconditions.checkNotNull;\n+import static com.hazelcast.multimap.impl.MultiMapProxyImpl.NULL_KEY_IS_NOT_ALLOWED;\n+import static com.hazelcast.multimap.impl.MultiMapProxyImpl.NULL_VALUE_IS_NOT_ALLOWED;\n+import static com.hazelcast.spi.impl.InternalCompletableFuture.newCompletedFuture;\n+import static java.lang.Math.ceil;\n+import static java.lang.Math.log10;\n+import static java.util.Collections.singletonMap;\n \n public abstract class MultiMapProxySupport extends AbstractDistributedObject<MultiMapService> {\n \n     protected final MultiMapConfig config;\n     protected final String name;\n     protected final LockProxySupport lockSupport;\n+    protected final SerializationService serializationService;", "originalCommit": "d5eab935497c3e80d0e4201d684cae3adce677c7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1a6d23ce0fcc6cef2b790248a92f599f0d23e33c", "url": "https://github.com/hazelcast/hazelcast/commit/1a6d23ce0fcc6cef2b790248a92f599f0d23e33c", "message": "Modify interface and implementations of MultiMap.putAllAsync and related classes (#9079)\n\nRemove putAll(MultiMap) interfaces and related tests. Many other small code quality changes.\n\nAdd statistics tests for putAll. Preliminary PutBackupOperation implementation.", "committedDate": "2020-04-02T08:47:28Z", "type": "forcePushed"}, {"oid": "7068f3bc7fd60a5373689601cf7cadcb1feaf9a6", "url": "https://github.com/hazelcast/hazelcast/commit/7068f3bc7fd60a5373689601cf7cadcb1feaf9a6", "message": "    Modify interface and implementations of MultiMap.putAllAsync and related classes (#9079)\n    Remove non async and MultiMap putAll interfaces. Modify MultiMap.putAllInternal interface to take in Data, Data. Amend MultiMap.putAllAsync javadoc. Remove streams implementation. Many other small code quality changes.\n\n    Fix PutAllOperation record saving implementation. Fix incorrect MultimapDataSerializerHook reference. Implement PutAllBackupOperation, parametrize MultiMapBackupTest and clean up MultiMapProxySupport.\n\n    Add statistics tests for putAll. Preliminary PutBackupOperation implementation.\n\n    Define UnsupportedException specific Preconditions checkTrue.", "committedDate": "2020-04-04T11:53:16Z", "type": "forcePushed"}, {"oid": "3badfce8976c15696c1c12128b9eafee2fbfcda1", "url": "https://github.com/hazelcast/hazelcast/commit/3badfce8976c15696c1c12128b9eafee2fbfcda1", "message": "fix checkstyle (#9079)", "committedDate": "2020-04-07T02:05:20Z", "type": "forcePushed"}, {"oid": "13dc280e79f849bce8d255ac5660ae6c323cf568", "url": "https://github.com/hazelcast/hazelcast/commit/13dc280e79f849bce8d255ac5660ae6c323cf568", "message": "    Modify interface and implementations of MultiMap.putAllAsync and related classes (#9079)\n    Remove non async and MultiMap putAll interfaces. Modify MultiMap.putAllInternal interface to take in Data, Data. Amend MultiMap.putAllAsync javadoc. Remove streams implementation. Many other small code quality changes.\n\n    Fix PutAllOperation record saving implementation. Fix incorrect MultimapDataSerializerHook reference. Implement PutAllBackupOperation, parametrize MultiMapBackupTest and clean up MultiMapProxySupport.\n\n    Add statistics tests for putAll. Preliminary PutBackupOperation implementation.\n\n    Define UnsupportedException specific Preconditions checkTrue.", "committedDate": "2020-04-07T07:43:40Z", "type": "forcePushed"}, {"oid": "d37e0291cfa5dd30d362a20b327ae1068e3a30e3", "url": "https://github.com/hazelcast/hazelcast/commit/d37e0291cfa5dd30d362a20b327ae1068e3a30e3", "message": "Fix PutAllBackup serializer constant (#9079)", "committedDate": "2020-04-08T03:59:48Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQwNjI5OA==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r405406298", "bodyText": "Two things might go wrong here:\n\nthis is an async call; it is possible that the operation has not yet been completed by the time assertNewLastAccessTime below is executed.\nyou miss a sleepMillis() statement before this one (similarly to previous code blocks in the same test) to ensure that putAllAsync is not executed in the same millisecond as the previous operation.\n\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    multiMap.putAllAsync(key, expectedMultiMap1.get(key));\n          \n          \n            \n                    sleepMillis(10);\n          \n          \n            \n                    multiMap.putAllAsync(key, expectedMultiMap1.get(key)).toCompletableFuture().join();", "author": "vbekiaris", "createdAt": "2020-04-08T10:00:23Z", "path": "hazelcast/src/test/java/com/hazelcast/multimap/MultiMapContainerStatisticsTest.java", "diffHunk": "@@ -143,6 +157,33 @@ public void testMultiMapContainerStats() {\n         assertNewLastAccessTime();\n         assertNewLastUpdateTime();\n \n+        Map<String, Collection<? extends String>> expectedMultiMap1 = new HashMap<>();\n+        // a successful putAll(Map) operation on a Hash backed mmap updates the lastAccessTime and lastUpdateTime\n+        expectedMultiMap1.put(key, new ArrayList<>(Arrays.asList(\"value\", \"value\", \"value\")));\n+        multiMap.putAllAsync(expectedMultiMap1);\n+        assertNewLastAccessTime();\n+        assertNewLastUpdateTime();\n+        // a successful clear operation updates the lastAccessTime and the lastUpdateTime\n+        sleepMillis(10);\n+        multiMap.clear();\n+        assertNewLastAccessTime();\n+        assertNewLastUpdateTime();\n+\n+        // a successful putAll(K,V) operation on a Hash backed mmap updates the lastAccessTime and lastUpdateTime\n+        multiMap.putAllAsync(key, expectedMultiMap1.get(key));", "originalCommit": "d37e0291cfa5dd30d362a20b327ae1068e3a30e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTYyMjExOA==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r405622118", "bodyText": "minor: currentIndex can be a local variable in run method", "author": "vbekiaris", "createdAt": "2020-04-08T15:41:24Z", "path": "hazelcast/src/main/java/com/hazelcast/multimap/impl/operations/PutAllOperation.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.multimap.impl.operations;\n+\n+import com.hazelcast.core.EntryEventType;\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.map.impl.MapEntries;\n+import com.hazelcast.multimap.impl.MultiMapContainer;\n+import com.hazelcast.multimap.impl.MultiMapDataSerializerHook;\n+import com.hazelcast.multimap.impl.MultiMapRecord;\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.spi.impl.operationservice.BackupAwareOperation;\n+import com.hazelcast.spi.impl.operationservice.MutatingOperation;\n+import com.hazelcast.spi.impl.operationservice.Operation;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Iterator;\n+\n+public class PutAllOperation extends AbstractMultiMapOperation implements MutatingOperation, BackupAwareOperation {\n+    private transient int currentIndex;", "originalCommit": "9f1a3464f2c64eea95c9944bf66fb530977a8fd2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTYyNDE4NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r405624185", "bodyText": "no need to track each new value. We only care if something changed so the backup operation can be created and executed or avoid the backup in case nothing changed.", "author": "vbekiaris", "createdAt": "2020-04-08T15:44:14Z", "path": "hazelcast/src/main/java/com/hazelcast/multimap/impl/operations/PutAllOperation.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.multimap.impl.operations;\n+\n+import com.hazelcast.core.EntryEventType;\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.map.impl.MapEntries;\n+import com.hazelcast.multimap.impl.MultiMapContainer;\n+import com.hazelcast.multimap.impl.MultiMapDataSerializerHook;\n+import com.hazelcast.multimap.impl.MultiMapRecord;\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.spi.impl.operationservice.BackupAwareOperation;\n+import com.hazelcast.spi.impl.operationservice.MutatingOperation;\n+import com.hazelcast.spi.impl.operationservice.Operation;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Iterator;\n+\n+public class PutAllOperation extends AbstractMultiMapOperation implements MutatingOperation, BackupAwareOperation {\n+    private transient int currentIndex;\n+    private MapEntries mapEntries;\n+\n+    public PutAllOperation() {\n+        super();\n+    }\n+\n+    public PutAllOperation(String name, MapEntries mapEntries) {\n+        super(name);\n+        this.mapEntries = mapEntries;\n+        //NB: general structure copied from c.hz.map.impl.operation.PutAllOperation\n+    }\n+\n+    @Override\n+    public final void run() {\n+        int size = mapEntries != null ? mapEntries.size() : 0;\n+        while (currentIndex < size) {\n+            Data dataKey = mapEntries.getKey(currentIndex);\n+            Data value = mapEntries.getValue(currentIndex);\n+            put(dataKey, value);\n+            currentIndex++;\n+        }\n+    }\n+\n+    protected void put(Data dataKey, Data dataValue) {\n+        MultiMapContainer container = getOrCreateContainer();\n+        Collection c = (Collection) toObject(dataValue);\n+        Collection<MultiMapRecord> coll = container.getOrCreateMultiMapValue(dataKey).getCollection(false);\n+        Iterator it = c.iterator();\n+\n+        while (it.hasNext()) {\n+            Object o = it.next();\n+            //NB: the collection values are always passed in as unencoded objects\n+            MultiMapRecord record = new MultiMapRecord(container.nextId(), isBinary() ? toData(o) : o);\n+            if (coll.add(record)) {\n+                //NB: cant put htis in afterRun because we want to notify on each new value\n+                getOrCreateContainer().update();\n+                publishEvent(EntryEventType.ADDED, dataKey, o, null);\n+                //would it be worthwhile to track all the additions and have a response array?", "originalCommit": "9f1a3464f2c64eea95c9944bf66fb530977a8fd2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTYyNjQwOA==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r405626408", "bodyText": "Sleeping for 10 seconds is a bit of a stretch for a QuickTest. Is this necessary?", "author": "vbekiaris", "createdAt": "2020-04-08T15:47:30Z", "path": "hazelcast/src/test/java/com/hazelcast/multimap/LocalMultiMapStatsTest.java", "diffHunk": "@@ -74,10 +99,65 @@ public void testPutAndHitsGenerated() {\n             map.get(i);\n         }\n         LocalMapStats localMapStats = getMultiMapStats();\n+\n         assertEquals(100, localMapStats.getPutOperationCount());\n         assertEquals(100, localMapStats.getHits());\n     }\n \n+    public void testPutAllAndHitsGeneratedTemplate(Map<Integer, Collection<? extends Integer>> expectedMultiMap1,\n+                                                   Consumer<MultiMap<Integer, Integer>> putAllOperation1) {\n+        MultiMap<Integer, Integer> mmap1 = getMultiMap();\n+        MultiMap<Integer, Integer> mmap2 = getMultiMap(mapNameSet);\n+        for (int i = 0; i < 100; i++) {\n+            expectedMultiMap1.put(i, new ArrayList<>(Arrays.asList(1, 1, 1)));\n+        }\n+\n+        putAllOperation1.accept(mmap1);\n+        putAllOperation1.accept(mmap2);\n+\n+        sleepMillis(10000);", "originalCommit": "9f1a3464f2c64eea95c9944bf66fb530977a8fd2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTYyOTUyOQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r405629529", "bodyText": "minor: could use diamond operator instead of <Integer> (here and a few more places below)", "author": "vbekiaris", "createdAt": "2020-04-08T15:51:47Z", "path": "hazelcast/src/test/java/com/hazelcast/multimap/MultiMapTest.java", "diffHunk": "@@ -104,6 +114,147 @@ public void testMultiMapPutGetRemove() {\n         assertEquals(0, multiMap.size());\n     }\n \n+    protected <K, V> EntryListener<K, V> putAllEntryListenerBuilder(Consumer<EntryEvent<K, V>> f) {\n+        return new EntryAdapter<K, V>() {\n+            public void entryAdded(EntryEvent<K, V> event) {\n+                f.accept(event);\n+            }\n+\n+            public void entryRemoved(EntryEvent<K, V> event) {\n+            }\n+\n+            public void entryEvicted(EntryEvent<K, V> event) {\n+                entryRemoved(event);\n+            }\n+\n+            @Override\n+            public void mapEvicted(MapEvent event) {\n+            }\n+\n+            @Override\n+            public void mapCleared(MapEvent event) {\n+            }\n+        };\n+    }\n+\n+    protected HazelcastInstance testMultiMapPutAllSetup() {\n+        MultiMapConfig multiMapConfig1 = new MultiMapConfig()\n+                .setName(\"testMultiMapPutAllMapList\")\n+                .setValueCollectionType(MultiMapConfig.ValueCollectionType.LIST)\n+                .setBinary(false);\n+        MultiMapConfig multiMapConfig2 = new MultiMapConfig()\n+                .setName(\"testMultiMapPutAllMapSet\")\n+                .setValueCollectionType(MultiMapConfig.ValueCollectionType.SET)\n+                .setBinary(false);\n+        MultiMapConfig multiMapConfig3 = new MultiMapConfig()\n+                .setName(\"expectedMultiMap1\")\n+                .setValueCollectionType(MultiMapConfig.ValueCollectionType.LIST)\n+                .setBinary(false);\n+        Config cfg = smallInstanceConfig()\n+                .addMultiMapConfig(multiMapConfig1)\n+                .addMultiMapConfig(multiMapConfig2)\n+                .addMultiMapConfig(multiMapConfig3);\n+        HazelcastInstance hz = createHazelcastInstanceFactory(1)\n+                .newInstances(cfg)[0];\n+\n+        return hz;\n+    }\n+\n+    public void testMultiMapPutAllTemplate(HazelcastInstance instance1,\n+                                           Map<String, Collection<? extends Integer>> expectedMultiMap1,\n+                                           Consumer<MultiMap<String, Integer>> putAllOperation1)\n+            throws InterruptedException {\n+\n+        MultiMap<String, Integer> mmap1 = instance1.getMultiMap(\"testMultiMapPutAllMapList\");\n+        MultiMap<String, Integer> mmap2 = instance1.getMultiMap(\"testMultiMapPutAllMapSet\");\n+        Map<String, Collection<Integer>> resultMap1 = new HashMap<>();\n+        Map<String, Collection<Integer>> resultMap2 = new HashMap<>();\n+\n+        int totalItems = 0;\n+        Set<String> ks = expectedMultiMap1.keySet();\n+        for (String s : ks) {\n+            Collection expectedCollection = expectedMultiMap1.get(s);\n+            totalItems += expectedCollection.size()\n+                    + ((Long) expectedCollection.stream().distinct().count()).intValue();\n+        }\n+\n+        final CountDownLatch latchAdded = new CountDownLatch(totalItems);\n+        mmap1.addEntryListener(putAllEntryListenerBuilder((event) -> {\n+                    String key = (String) event.getKey();\n+                    Integer value = (Integer) event.getValue();\n+                    Collection<Integer> c;\n+                    if (!resultMap1.containsKey(key)) {\n+                        c = new ArrayList<>();\n+                    } else {\n+                        c = resultMap1.get(key);\n+                    }\n+                    c.add(value);\n+                    resultMap1.put(key, c);\n+                    latchAdded.countDown();\n+                }\n+        ), true);\n+        mmap2.addEntryListener(putAllEntryListenerBuilder((event) -> {\n+                    String key = (String) event.getKey();\n+                    Integer value = (Integer) event.getValue();\n+                    Collection<Integer> c;\n+                    if (!resultMap2.containsKey(key)) {\n+                        c = new ArrayList<>();\n+                    } else {\n+                        c = resultMap2.get(key);\n+                    }\n+                    c.add(value);\n+\n+                    resultMap2.put(key, c);\n+                    latchAdded.countDown();\n+                }\n+        ), true);\n+\n+        putAllOperation1.accept(mmap1);\n+        putAllOperation1.accept(mmap2);\n+        latchAdded.await(5, TimeUnit.MINUTES);\n+        sleepMillis(10000);\n+\n+        for (String s : ks) {\n+            Collection c1 = resultMap1.get(s);\n+            Collection c2 = resultMap2.get(s);\n+            Collection expectedCollection = expectedMultiMap1.get(s);\n+            assertEquals(expectedCollection.size(), c1.size());\n+            assertEquals(expectedCollection.stream().distinct().count(), c2.size());\n+        }\n+    }\n+\n+    @Test\n+    public void testMultiMapPutAllAsyncMap() throws InterruptedException {\n+        Map<String, Collection<? extends Integer>> expectedMultiMap1 = new HashMap<>();\n+        expectedMultiMap1.put(\"A\", new ArrayList<Integer>(Arrays.asList(1, 1, 1, 1, 2)));", "originalCommit": "9f1a3464f2c64eea95c9944bf66fb530977a8fd2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc1OTY4Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r405759687", "bodyText": "I just realized there is an issue with the serialization of the Collection<? extends V> value here:\n\nCollection<? extends V> is serialized to Data\nIt will then be passed on as value to MapEntries field of PutAllOperation\nIn PutAllOperation it is deserialized. The Data will be deserialized to Collection<? extends V>. The problem with this is that it requires that the collection's element class Class<? extends V> must be present on the server, even when the MultiMap stores items in binary format.\n\nThe solution is to first serialize each element, so the Collection<? extends V> is turned to a Collection<Data>, then perform the serialization of Collection<Data> to a single Data to be put in your dataMap:\nfor (Map.Entry e : m.entrySet()) {\n  Collection<Data> dataCollection = asDataCollection(e.getValue());\n  dataMap.put(toData(e.getKey()), toData(dataCollection));\n}\n...\nCollection<Data> asDataCollection(Collection<? extends V> values) {\n  // iterate values and serialize each\n}", "author": "vbekiaris", "createdAt": "2020-04-08T19:24:12Z", "path": "hazelcast/src/main/java/com/hazelcast/multimap/impl/MultiMapProxyImpl.java", "diffHunk": "@@ -92,6 +101,31 @@ public void initialize() {\n         }\n     }\n \n+    @Override\n+    public CompletionStage<Void> putAllAsync(@Nonnull Map<? extends K, Collection<? extends V>> m) {\n+        checkTrueUnsupportedOperation(isClusterVersionGreaterOrEqual(Versions.V4_1), MINIMUM_VERSION_ERROR_4_1);\n+        InternalCompletableFuture<Void> future = new InternalCompletableFuture<>();\n+        Map<Data, Data> dataMap = new HashMap<>();\n+\n+        for (Map.Entry e : m.entrySet()) {\n+            dataMap.put(toData(e.getKey()), toData(e.getValue()));", "originalCommit": "9f1a3464f2c64eea95c9944bf66fb530977a8fd2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc2MDYzMA==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r405760630", "bodyText": "This will be a Collection<Data> c (once you implement serialization as described in the comment in MultiMapProxyImpl)", "author": "vbekiaris", "createdAt": "2020-04-08T19:26:08Z", "path": "hazelcast/src/main/java/com/hazelcast/multimap/impl/operations/PutAllOperation.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.multimap.impl.operations;\n+\n+import com.hazelcast.core.EntryEventType;\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.map.impl.MapEntries;\n+import com.hazelcast.multimap.impl.MultiMapContainer;\n+import com.hazelcast.multimap.impl.MultiMapDataSerializerHook;\n+import com.hazelcast.multimap.impl.MultiMapRecord;\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.spi.impl.operationservice.BackupAwareOperation;\n+import com.hazelcast.spi.impl.operationservice.MutatingOperation;\n+import com.hazelcast.spi.impl.operationservice.Operation;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Iterator;\n+\n+public class PutAllOperation extends AbstractMultiMapOperation implements MutatingOperation, BackupAwareOperation {\n+    private transient int currentIndex;\n+    private MapEntries mapEntries;\n+\n+    public PutAllOperation() {\n+        super();\n+    }\n+\n+    public PutAllOperation(String name, MapEntries mapEntries) {\n+        super(name);\n+        this.mapEntries = mapEntries;\n+        //NB: general structure copied from c.hz.map.impl.operation.PutAllOperation\n+    }\n+\n+    @Override\n+    public final void run() {\n+        int size = mapEntries != null ? mapEntries.size() : 0;\n+        while (currentIndex < size) {\n+            Data dataKey = mapEntries.getKey(currentIndex);\n+            Data value = mapEntries.getValue(currentIndex);\n+            put(dataKey, value);\n+            currentIndex++;\n+        }\n+    }\n+\n+    protected void put(Data dataKey, Data dataValue) {\n+        MultiMapContainer container = getOrCreateContainer();\n+        Collection c = (Collection) toObject(dataValue);", "originalCommit": "9f1a3464f2c64eea95c9944bf66fb530977a8fd2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc2MTY1MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r405761651", "bodyText": "o will be already Data, so instead of isBinary() ? toData(o) : o, change this to isBinary() ? o : toObject(o)\n(once you implement serialization as described in the comment in MultiMapProxyImpl).", "author": "vbekiaris", "createdAt": "2020-04-08T19:28:05Z", "path": "hazelcast/src/main/java/com/hazelcast/multimap/impl/operations/PutAllOperation.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.multimap.impl.operations;\n+\n+import com.hazelcast.core.EntryEventType;\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.map.impl.MapEntries;\n+import com.hazelcast.multimap.impl.MultiMapContainer;\n+import com.hazelcast.multimap.impl.MultiMapDataSerializerHook;\n+import com.hazelcast.multimap.impl.MultiMapRecord;\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.spi.impl.operationservice.BackupAwareOperation;\n+import com.hazelcast.spi.impl.operationservice.MutatingOperation;\n+import com.hazelcast.spi.impl.operationservice.Operation;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Iterator;\n+\n+public class PutAllOperation extends AbstractMultiMapOperation implements MutatingOperation, BackupAwareOperation {\n+    private transient int currentIndex;\n+    private MapEntries mapEntries;\n+\n+    public PutAllOperation() {\n+        super();\n+    }\n+\n+    public PutAllOperation(String name, MapEntries mapEntries) {\n+        super(name);\n+        this.mapEntries = mapEntries;\n+        //NB: general structure copied from c.hz.map.impl.operation.PutAllOperation\n+    }\n+\n+    @Override\n+    public final void run() {\n+        int size = mapEntries != null ? mapEntries.size() : 0;\n+        while (currentIndex < size) {\n+            Data dataKey = mapEntries.getKey(currentIndex);\n+            Data value = mapEntries.getValue(currentIndex);\n+            put(dataKey, value);\n+            currentIndex++;\n+        }\n+    }\n+\n+    protected void put(Data dataKey, Data dataValue) {\n+        MultiMapContainer container = getOrCreateContainer();\n+        Collection c = (Collection) toObject(dataValue);\n+        Collection<MultiMapRecord> coll = container.getOrCreateMultiMapValue(dataKey).getCollection(false);\n+        Iterator it = c.iterator();\n+\n+        while (it.hasNext()) {\n+            Object o = it.next();\n+            //NB: the collection values are always passed in as unencoded objects\n+            MultiMapRecord record = new MultiMapRecord(container.nextId(), isBinary() ? toData(o) : o);", "originalCommit": "9f1a3464f2c64eea95c9944bf66fb530977a8fd2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "22d4bca64919908655498a18f8ac25e227ed4cbe", "url": "https://github.com/hazelcast/hazelcast/commit/22d4bca64919908655498a18f8ac25e227ed4cbe", "message": "Pass in Collection<Data> to putAllOperation. (#9079)\nAllow for serializing and deserializing Data to Collections Serializer. Strip type info from Array and HashSet Serializer initially. Save and read isData flag during de/serialization.", "committedDate": "2020-04-09T11:17:50Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzM5OTUzNg==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r407399536", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        dataMap.put(toData(e.getKey()), toData(dataCollection));\n          \n          \n            \n                        dataMap.put(toData(e.getKey()), toData(new DataCollection(dataCollection)));", "author": "vbekiaris", "createdAt": "2020-04-13T09:32:47Z", "path": "hazelcast/src/main/java/com/hazelcast/multimap/impl/MultiMapProxyImpl.java", "diffHunk": "@@ -92,6 +102,37 @@ public void initialize() {\n         }\n     }\n \n+    @Override\n+    public CompletionStage<Void> putAllAsync(@Nonnull Map<? extends K, Collection<? extends V>> m) {\n+        checkTrueUnsupportedOperation(isClusterVersionGreaterOrEqual(Versions.V4_1), MINIMUM_VERSION_ERROR_4_1);\n+        InternalCompletableFuture<Void> future = new InternalCompletableFuture<>();\n+        Map<Data, Data> dataMap = new HashMap<>();\n+\n+        for (Map.Entry e : m.entrySet()) {\n+            Collection<Data> dataCollection = CollectionUtil\n+                    .objectToDataCollection(((Collection<? extends V>) e.getValue()),\n+                            getNodeEngine().getSerializationService());\n+\n+            dataMap.put(toData(e.getKey()), toData(dataCollection));", "originalCommit": "22d4bca64919908655498a18f8ac25e227ed4cbe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzM5OTY2Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r407399667", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    dataMap.put(toData(key), toData(dataCollection));\n          \n          \n            \n                    dataMap.put(toData(key), toData(new DataCollection(dataCollection)));", "author": "vbekiaris", "createdAt": "2020-04-13T09:33:08Z", "path": "hazelcast/src/main/java/com/hazelcast/multimap/impl/MultiMapProxyImpl.java", "diffHunk": "@@ -92,6 +102,37 @@ public void initialize() {\n         }\n     }\n \n+    @Override\n+    public CompletionStage<Void> putAllAsync(@Nonnull Map<? extends K, Collection<? extends V>> m) {\n+        checkTrueUnsupportedOperation(isClusterVersionGreaterOrEqual(Versions.V4_1), MINIMUM_VERSION_ERROR_4_1);\n+        InternalCompletableFuture<Void> future = new InternalCompletableFuture<>();\n+        Map<Data, Data> dataMap = new HashMap<>();\n+\n+        for (Map.Entry e : m.entrySet()) {\n+            Collection<Data> dataCollection = CollectionUtil\n+                    .objectToDataCollection(((Collection<? extends V>) e.getValue()),\n+                            getNodeEngine().getSerializationService());\n+\n+            dataMap.put(toData(e.getKey()), toData(dataCollection));\n+        }\n+        putAllInternal(dataMap, future);\n+        return future;\n+    }\n+\n+    @Override\n+    public CompletionStage<Void> putAllAsync(@Nonnull K key, @Nonnull Collection<? extends V> value) {\n+        checkTrueUnsupportedOperation(isClusterVersionGreaterOrEqual(Versions.V4_1), MINIMUM_VERSION_ERROR_4_1);\n+        InternalCompletableFuture<Void> future = new InternalCompletableFuture<>();\n+        Map<Data, Data> dataMap = new HashMap<>();\n+\n+        Collection<Data> dataCollection = CollectionUtil\n+                .objectToDataCollection(value, getNodeEngine().getSerializationService());\n+        dataMap.put(toData(key), toData(dataCollection));", "originalCommit": "22d4bca64919908655498a18f8ac25e227ed4cbe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzQwMDAwNg==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r407400006", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Collection<Data> c = (Collection<Data>) toObject(dataValue);\n          \n          \n            \n                    DataCollection c = (DataCollection) toObject(dataValue);", "author": "vbekiaris", "createdAt": "2020-04-13T09:34:07Z", "path": "hazelcast/src/main/java/com/hazelcast/multimap/impl/operations/PutAllOperation.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.multimap.impl.operations;\n+\n+import com.hazelcast.core.EntryEventType;\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.map.impl.MapEntries;\n+import com.hazelcast.multimap.impl.MultiMapContainer;\n+import com.hazelcast.multimap.impl.MultiMapDataSerializerHook;\n+import com.hazelcast.multimap.impl.MultiMapRecord;\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.spi.impl.operationservice.BackupAwareOperation;\n+import com.hazelcast.spi.impl.operationservice.MutatingOperation;\n+import com.hazelcast.spi.impl.operationservice.Operation;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Iterator;\n+\n+public class PutAllOperation extends AbstractMultiMapOperation implements MutatingOperation, BackupAwareOperation {\n+    private MapEntries mapEntries;\n+\n+    public PutAllOperation() {\n+        super();\n+    }\n+\n+    public PutAllOperation(String name, MapEntries mapEntries) {\n+        super(name);\n+        this.mapEntries = mapEntries;\n+        //NB: general structure copied from c.hz.map.impl.operation.PutAllOperation\n+    }\n+\n+    @Override\n+    public final void run() {\n+        int size = mapEntries != null ? mapEntries.size() : 0;\n+        int currentIndex = 0;\n+        while (currentIndex < size) {\n+            Data dataKey = mapEntries.getKey(currentIndex);\n+            Data value = mapEntries.getValue(currentIndex);\n+            put(dataKey, value);\n+            currentIndex++;\n+        }\n+    }\n+\n+    protected void put(Data dataKey, Data dataValue) {\n+        MultiMapContainer container = getOrCreateContainer();\n+        Collection<Data> c = (Collection<Data>) toObject(dataValue);", "originalCommit": "22d4bca64919908655498a18f8ac25e227ed4cbe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzQwMDExMg==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r407400112", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Iterator it = c.iterator();\n          \n          \n            \n                    Iterator<Data> it = c.getCollection().iterator();", "author": "vbekiaris", "createdAt": "2020-04-13T09:34:23Z", "path": "hazelcast/src/main/java/com/hazelcast/multimap/impl/operations/PutAllOperation.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.multimap.impl.operations;\n+\n+import com.hazelcast.core.EntryEventType;\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.map.impl.MapEntries;\n+import com.hazelcast.multimap.impl.MultiMapContainer;\n+import com.hazelcast.multimap.impl.MultiMapDataSerializerHook;\n+import com.hazelcast.multimap.impl.MultiMapRecord;\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.spi.impl.operationservice.BackupAwareOperation;\n+import com.hazelcast.spi.impl.operationservice.MutatingOperation;\n+import com.hazelcast.spi.impl.operationservice.Operation;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Iterator;\n+\n+public class PutAllOperation extends AbstractMultiMapOperation implements MutatingOperation, BackupAwareOperation {\n+    private MapEntries mapEntries;\n+\n+    public PutAllOperation() {\n+        super();\n+    }\n+\n+    public PutAllOperation(String name, MapEntries mapEntries) {\n+        super(name);\n+        this.mapEntries = mapEntries;\n+        //NB: general structure copied from c.hz.map.impl.operation.PutAllOperation\n+    }\n+\n+    @Override\n+    public final void run() {\n+        int size = mapEntries != null ? mapEntries.size() : 0;\n+        int currentIndex = 0;\n+        while (currentIndex < size) {\n+            Data dataKey = mapEntries.getKey(currentIndex);\n+            Data value = mapEntries.getValue(currentIndex);\n+            put(dataKey, value);\n+            currentIndex++;\n+        }\n+    }\n+\n+    protected void put(Data dataKey, Data dataValue) {\n+        MultiMapContainer container = getOrCreateContainer();\n+        Collection<Data> c = (Collection<Data>) toObject(dataValue);\n+        Collection<MultiMapRecord> coll = container.getOrCreateMultiMapValue(dataKey).getCollection(false);\n+        Iterator it = c.iterator();", "originalCommit": "22d4bca64919908655498a18f8ac25e227ed4cbe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzQwMDkyMg==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r407400922", "bodyText": "this method needs to be updated similarly to PutAllOperation to take into account serialization and also handle properly binary data.", "author": "vbekiaris", "createdAt": "2020-04-13T09:36:46Z", "path": "hazelcast/src/main/java/com/hazelcast/multimap/impl/operations/PutAllBackupOperation.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.multimap.impl.operations;\n+\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.map.impl.MapEntries;\n+import com.hazelcast.multimap.impl.MultiMapContainer;\n+import com.hazelcast.multimap.impl.MultiMapDataSerializerHook;\n+import com.hazelcast.multimap.impl.MultiMapRecord;\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.spi.impl.operationservice.BackupOperation;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Iterator;\n+\n+public class PutAllBackupOperation extends AbstractMultiMapOperation implements BackupOperation {\n+    private transient int currentIndex;\n+    private MapEntries mapEntries;\n+\n+    public PutAllBackupOperation() {\n+    }\n+\n+    public PutAllBackupOperation(String name, MapEntries mapEntries) {\n+        super(name);\n+        this.mapEntries = mapEntries;\n+    }\n+\n+    @Override\n+    public void run() throws Exception {\n+        int size = mapEntries != null ? mapEntries.size() : 0;\n+        while (currentIndex < size) {\n+            Data dataKey = mapEntries.getKey(currentIndex);\n+            Data value = mapEntries.getValue(currentIndex);\n+            put(dataKey, value);\n+            currentIndex++;\n+        }\n+    }\n+\n+    protected void put(Data dataKey, Data dataValue) {", "originalCommit": "22d4bca64919908655498a18f8ac25e227ed4cbe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "bef680b72c90e574c2c9e125159b513e8a658bd9", "url": "https://github.com/hazelcast/hazelcast/commit/bef680b72c90e574c2c9e125159b513e8a658bd9", "message": "Reduce sleep time in ClientMultiMapTests (#9079)", "committedDate": "2020-04-13T11:50:37Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzQ5NzUzOA==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r407497538", "bodyText": "I could not find a usage of this future with a null value.\n@vbekiaris Are we planning to implement sync versions of these methods ?\nIf there is no plan, can we make this @nonnull , and remove the null checks inside the method? Same goes for the MultiMapProxyImpl as well.", "author": "sancar", "createdAt": "2020-04-13T14:10:35Z", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientMultiMapProxy.java", "diffHunk": "@@ -91,6 +105,98 @@ public ClientMultiMapProxy(String serviceName, String name, ClientContext contex\n         super(serviceName, name, context);\n     }\n \n+    @Override\n+    public CompletionStage<Void> putAllAsync(@Nonnull Map<? extends K, Collection<? extends V>> m) {\n+        InternalCompletableFuture<Void> future = new InternalCompletableFuture<>();\n+        Map<Data, Data> dataMap = new HashMap<>();\n+\n+        for (Map.Entry e : m.entrySet()) {\n+            Collection<Data> dataCollection = CollectionUtil\n+                    .objectToDataCollection(((Collection<? extends V>) e.getValue()),\n+                            getSerializationService());\n+\n+            dataMap.put(toData(e.getKey()), toData(new DataCollection(dataCollection)));\n+        }\n+        putAllInternal(dataMap, future);\n+        return future;\n+    }\n+\n+    @Override\n+    public CompletionStage<Void> putAllAsync(@Nonnull K key, Collection<? extends V> value) {\n+        InternalCompletableFuture<Void> future = new InternalCompletableFuture<>();\n+        Map<Data, Data> dataMap = new HashMap<>();\n+\n+        Collection<Data> dataCollection = CollectionUtil\n+                .objectToDataCollection(value, getSerializationService());\n+        dataMap.put(toData(key), toData(new DataCollection(dataCollection)));\n+        putAllInternal(dataMap, future);\n+        return future;\n+    }\n+\n+\n+    @SuppressWarnings({\"checkstyle:cyclomaticcomplexity\", \"checkstyle:npathcomplexity\", \"checkstyle:methodlength\"})\n+    private void putAllInternal(@Nonnull Map<Data, Data> map,\n+                                @Nullable InternalCompletableFuture<Void> future) {", "originalCommit": "0e306d8be0f2b1df2b5e1090802257629920ce1a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzkwMTg1Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r407901856", "bodyText": "Quoting from #9079 (comment) :\n\n... So, instead of getAll and putAll, you can add getAllAsync and putAllAsync.\n\nThere is no concrete plan for implementing the synchronous version of these methods, unless there is interest / a PR from the community. So I would agree to have the future == null paths removed from this PR.", "author": "vbekiaris", "createdAt": "2020-04-14T06:45:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzQ5NzUzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUyNjA3Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r407526076", "bodyText": "A collection of objects should not be converted to Data. For details see my comment on protocol pr.\nhazelcast/hazelcast-client-protocol#313 (comment)\nNote that this is the case for Client only. For the member side, I believe it is ok the use DataCollection.\nFor the client, we have a protocol and it needs to be self descriptive. Details are on the protocol pr comment", "author": "sancar", "createdAt": "2020-04-13T15:05:16Z", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/ClientMultiMapProxy.java", "diffHunk": "@@ -91,6 +105,98 @@ public ClientMultiMapProxy(String serviceName, String name, ClientContext contex\n         super(serviceName, name, context);\n     }\n \n+    @Override\n+    public CompletionStage<Void> putAllAsync(@Nonnull Map<? extends K, Collection<? extends V>> m) {\n+        InternalCompletableFuture<Void> future = new InternalCompletableFuture<>();\n+        Map<Data, Data> dataMap = new HashMap<>();\n+\n+        for (Map.Entry e : m.entrySet()) {\n+            Collection<Data> dataCollection = CollectionUtil\n+                    .objectToDataCollection(((Collection<? extends V>) e.getValue()),\n+                            getSerializationService());\n+\n+            dataMap.put(toData(e.getKey()), toData(new DataCollection(dataCollection)));\n+        }\n+        putAllInternal(dataMap, future);\n+        return future;\n+    }\n+\n+    @Override\n+    public CompletionStage<Void> putAllAsync(@Nonnull K key, Collection<? extends V> value) {\n+        InternalCompletableFuture<Void> future = new InternalCompletableFuture<>();\n+        Map<Data, Data> dataMap = new HashMap<>();\n+\n+        Collection<Data> dataCollection = CollectionUtil\n+                .objectToDataCollection(value, getSerializationService());\n+        dataMap.put(toData(key), toData(new DataCollection(dataCollection)));", "originalCommit": "0e306d8be0f2b1df2b5e1090802257629920ce1a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a7bf45a34a69a1f5c824f2f16ebb8ee5289cf5c7", "url": "https://github.com/hazelcast/hazelcast/commit/a7bf45a34a69a1f5c824f2f16ebb8ee5289cf5c7", "message": "Change ClientMultiMap PutAll entries param from Map<Data, Data> to Map<Data, Collection<Data>> (#9079)\nUpdate generated codecs and tests.", "committedDate": "2020-04-17T12:21:21Z", "type": "forcePushed"}, {"oid": "e6d09aae355ed6c67efd01b94c5d80d07cca42b7", "url": "https://github.com/hazelcast/hazelcast/commit/e6d09aae355ed6c67efd01b94c5d80d07cca42b7", "message": "Make ClientMultiMapProxy.putAllInternal future @Nonnull and remove check (#9079)", "committedDate": "2020-04-17T12:44:32Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTMzMDM2Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r411330363", "bodyText": "What is this configuration is used for ? Can you remove if it is redundant ?", "author": "sancar", "createdAt": "2020-04-20T12:18:07Z", "path": "hazelcast/src/test/java/com/hazelcast/client/multimap/ClientMultiMapTest.java", "diffHunk": "@@ -65,6 +78,137 @@ public void testPut() {\n         assertTrue(mm.put(key, 1));\n     }\n \n+    protected <K, V> EntryListener<K, V> putAllEntryListenerBuilder(Consumer<EntryEvent<K, V>> f) {\n+        return new EntryAdapter<K, V>() {\n+            public void entryAdded(EntryEvent<K, V> event) {\n+                f.accept(event);\n+            }\n+\n+            public void entryRemoved(EntryEvent<K, V> event) {\n+            }\n+\n+            public void entryEvicted(EntryEvent<K, V> event) {\n+                entryRemoved(event);\n+            }\n+\n+            @Override\n+            public void mapEvicted(MapEvent event) {\n+            }\n+\n+            @Override\n+            public void mapCleared(MapEvent event) {\n+            }\n+        };\n+    }\n+\n+    protected void testMultiMapPutAllSetup() {\n+        MultiMapConfig multiMapConfig1 = new MultiMapConfig()\n+                .setName(\"testMultiMapList\")\n+                .setValueCollectionType(MultiMapConfig.ValueCollectionType.LIST)\n+                .setBinary(false);\n+        MultiMapConfig multiMapConfig2 = new MultiMapConfig()\n+                .setName(\"testMultiMapSet\")\n+                .setValueCollectionType(MultiMapConfig.ValueCollectionType.SET)\n+                .setBinary(false);\n+        MultiMapConfig multiMapConfig3 = new MultiMapConfig()\n+                .setName(\"expectedMultiMap1\")", "originalCommit": "dd153bc2dd11f13d4f9835ba5eb31efa332d4884", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM0MTE5MA==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r411341190", "bodyText": "This access is not thread safe. You should use ConcurrentHashMap .", "author": "sancar", "createdAt": "2020-04-20T12:35:49Z", "path": "hazelcast/src/test/java/com/hazelcast/client/multimap/ClientMultiMapTest.java", "diffHunk": "@@ -65,6 +78,137 @@ public void testPut() {\n         assertTrue(mm.put(key, 1));\n     }\n \n+    protected <K, V> EntryListener<K, V> putAllEntryListenerBuilder(Consumer<EntryEvent<K, V>> f) {\n+        return new EntryAdapter<K, V>() {\n+            public void entryAdded(EntryEvent<K, V> event) {\n+                f.accept(event);\n+            }\n+\n+            public void entryRemoved(EntryEvent<K, V> event) {\n+            }\n+\n+            public void entryEvicted(EntryEvent<K, V> event) {\n+                entryRemoved(event);\n+            }\n+\n+            @Override\n+            public void mapEvicted(MapEvent event) {\n+            }\n+\n+            @Override\n+            public void mapCleared(MapEvent event) {\n+            }\n+        };\n+    }\n+\n+    protected void testMultiMapPutAllSetup() {\n+        MultiMapConfig multiMapConfig1 = new MultiMapConfig()\n+                .setName(\"testMultiMapList\")\n+                .setValueCollectionType(MultiMapConfig.ValueCollectionType.LIST)\n+                .setBinary(false);\n+        MultiMapConfig multiMapConfig2 = new MultiMapConfig()\n+                .setName(\"testMultiMapSet\")\n+                .setValueCollectionType(MultiMapConfig.ValueCollectionType.SET)\n+                .setBinary(false);\n+        MultiMapConfig multiMapConfig3 = new MultiMapConfig()\n+                .setName(\"expectedMultiMap1\")\n+                .setValueCollectionType(MultiMapConfig.ValueCollectionType.LIST)\n+                .setBinary(false);\n+        client.getConfig()\n+                .addMultiMapConfig(multiMapConfig1)\n+                .addMultiMapConfig(multiMapConfig2)\n+                .addMultiMapConfig(multiMapConfig3);\n+    }\n+\n+    public void testMultiMapPutAllTemplate(Map<String, Collection<? extends Integer>> expectedMultiMap,\n+                                           Consumer<MultiMap<String, Integer>> putAllOperation1) throws InterruptedException {\n+        MultiMap<String, Integer> mmap1 = client.getMultiMap(\"testMultiMapList\");\n+        MultiMap<String, Integer> mmap2 = client.getMultiMap(\"testMultiMapSet\");\n+        Map<String, Collection<Integer>> resultMap1 = new HashMap<>();\n+        Map<String, Collection<Integer>> resultMap2 = new HashMap<>();\n+\n+        int totalItems = 0;\n+        Set<String> ks = expectedMultiMap.keySet();\n+        for (String s : ks) {\n+            Collection expectedCollection = expectedMultiMap.get(s);\n+            totalItems += expectedCollection.size()\n+                    + ((Long) expectedCollection.stream().distinct().count()).intValue();\n+        }\n+\n+        final CountDownLatch latchAdded = new CountDownLatch(totalItems);\n+        mmap1.addEntryListener(putAllEntryListenerBuilder((event) -> {\n+                    String key = (String) event.getKey();\n+                    Integer value = (Integer) event.getValue();\n+                    Collection<Integer> c;\n+                    if (!resultMap1.containsKey(key)) {", "originalCommit": "dd153bc2dd11f13d4f9835ba5eb31efa332d4884", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM0MjMxNw==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r411342317", "bodyText": "Some naming suggestions to make the code a little bit more easy to understand\nPlease remove the numbers from the names where it is not necessary . (When there is a number, I automatically search for the second one. )\nlike putAllOperation1 -> putAllOperation\nexpectedMultiMap1 -> expectedMultiMap", "author": "sancar", "createdAt": "2020-04-20T12:37:48Z", "path": "hazelcast/src/test/java/com/hazelcast/client/multimap/ClientMultiMapTest.java", "diffHunk": "@@ -65,6 +78,137 @@ public void testPut() {\n         assertTrue(mm.put(key, 1));\n     }\n \n+    protected <K, V> EntryListener<K, V> putAllEntryListenerBuilder(Consumer<EntryEvent<K, V>> f) {\n+        return new EntryAdapter<K, V>() {\n+            public void entryAdded(EntryEvent<K, V> event) {\n+                f.accept(event);\n+            }\n+\n+            public void entryRemoved(EntryEvent<K, V> event) {\n+            }\n+\n+            public void entryEvicted(EntryEvent<K, V> event) {\n+                entryRemoved(event);\n+            }\n+\n+            @Override\n+            public void mapEvicted(MapEvent event) {\n+            }\n+\n+            @Override\n+            public void mapCleared(MapEvent event) {\n+            }\n+        };\n+    }\n+\n+    protected void testMultiMapPutAllSetup() {\n+        MultiMapConfig multiMapConfig1 = new MultiMapConfig()\n+                .setName(\"testMultiMapList\")\n+                .setValueCollectionType(MultiMapConfig.ValueCollectionType.LIST)\n+                .setBinary(false);\n+        MultiMapConfig multiMapConfig2 = new MultiMapConfig()\n+                .setName(\"testMultiMapSet\")\n+                .setValueCollectionType(MultiMapConfig.ValueCollectionType.SET)\n+                .setBinary(false);\n+        MultiMapConfig multiMapConfig3 = new MultiMapConfig()\n+                .setName(\"expectedMultiMap1\")\n+                .setValueCollectionType(MultiMapConfig.ValueCollectionType.LIST)\n+                .setBinary(false);\n+        client.getConfig()\n+                .addMultiMapConfig(multiMapConfig1)\n+                .addMultiMapConfig(multiMapConfig2)\n+                .addMultiMapConfig(multiMapConfig3);\n+    }\n+\n+    public void testMultiMapPutAllTemplate(Map<String, Collection<? extends Integer>> expectedMultiMap,\n+                                           Consumer<MultiMap<String, Integer>> putAllOperation1) throws InterruptedException {", "originalCommit": "dd153bc2dd11f13d4f9835ba5eb31efa332d4884", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM0MzE5MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r411343191", "bodyText": "Please use the standard one as follows:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    latchAdded.await(5, TimeUnit.MINUTES);\n          \n          \n            \n                    assertOpenEventually(latchAdded);", "author": "sancar", "createdAt": "2020-04-20T12:39:09Z", "path": "hazelcast/src/test/java/com/hazelcast/client/multimap/ClientMultiMapTest.java", "diffHunk": "@@ -65,6 +78,137 @@ public void testPut() {\n         assertTrue(mm.put(key, 1));\n     }\n \n+    protected <K, V> EntryListener<K, V> putAllEntryListenerBuilder(Consumer<EntryEvent<K, V>> f) {\n+        return new EntryAdapter<K, V>() {\n+            public void entryAdded(EntryEvent<K, V> event) {\n+                f.accept(event);\n+            }\n+\n+            public void entryRemoved(EntryEvent<K, V> event) {\n+            }\n+\n+            public void entryEvicted(EntryEvent<K, V> event) {\n+                entryRemoved(event);\n+            }\n+\n+            @Override\n+            public void mapEvicted(MapEvent event) {\n+            }\n+\n+            @Override\n+            public void mapCleared(MapEvent event) {\n+            }\n+        };\n+    }\n+\n+    protected void testMultiMapPutAllSetup() {\n+        MultiMapConfig multiMapConfig1 = new MultiMapConfig()\n+                .setName(\"testMultiMapList\")\n+                .setValueCollectionType(MultiMapConfig.ValueCollectionType.LIST)\n+                .setBinary(false);\n+        MultiMapConfig multiMapConfig2 = new MultiMapConfig()\n+                .setName(\"testMultiMapSet\")\n+                .setValueCollectionType(MultiMapConfig.ValueCollectionType.SET)\n+                .setBinary(false);\n+        MultiMapConfig multiMapConfig3 = new MultiMapConfig()\n+                .setName(\"expectedMultiMap1\")\n+                .setValueCollectionType(MultiMapConfig.ValueCollectionType.LIST)\n+                .setBinary(false);\n+        client.getConfig()\n+                .addMultiMapConfig(multiMapConfig1)\n+                .addMultiMapConfig(multiMapConfig2)\n+                .addMultiMapConfig(multiMapConfig3);\n+    }\n+\n+    public void testMultiMapPutAllTemplate(Map<String, Collection<? extends Integer>> expectedMultiMap,\n+                                           Consumer<MultiMap<String, Integer>> putAllOperation1) throws InterruptedException {\n+        MultiMap<String, Integer> mmap1 = client.getMultiMap(\"testMultiMapList\");\n+        MultiMap<String, Integer> mmap2 = client.getMultiMap(\"testMultiMapSet\");\n+        Map<String, Collection<Integer>> resultMap1 = new HashMap<>();\n+        Map<String, Collection<Integer>> resultMap2 = new HashMap<>();\n+\n+        int totalItems = 0;\n+        Set<String> ks = expectedMultiMap.keySet();\n+        for (String s : ks) {\n+            Collection expectedCollection = expectedMultiMap.get(s);\n+            totalItems += expectedCollection.size()\n+                    + ((Long) expectedCollection.stream().distinct().count()).intValue();\n+        }\n+\n+        final CountDownLatch latchAdded = new CountDownLatch(totalItems);\n+        mmap1.addEntryListener(putAllEntryListenerBuilder((event) -> {\n+                    String key = (String) event.getKey();\n+                    Integer value = (Integer) event.getValue();\n+                    Collection<Integer> c;\n+                    if (!resultMap1.containsKey(key)) {\n+                        c = new ArrayList<>();\n+                    } else {\n+                        c = resultMap1.get(key);\n+                    }\n+                    c.add(value);\n+                    resultMap1.put(key, c);\n+                    latchAdded.countDown();\n+                }\n+        ), true);\n+        mmap2.addEntryListener(putAllEntryListenerBuilder((event) -> {\n+                    String key = (String) event.getKey();\n+                    Integer value = (Integer) event.getValue();\n+                    Collection<Integer> c;\n+                    if (!resultMap2.containsKey(key)) {\n+                        c = new ArrayList<>();\n+                    } else {\n+                        c = resultMap2.get(key);\n+                    }\n+                    c.add(value);\n+                    resultMap2.put(key, c);\n+                    latchAdded.countDown();\n+                }\n+        ), true);\n+\n+        putAllOperation1.accept(mmap1);\n+        putAllOperation1.accept(mmap2);\n+        latchAdded.await(5, TimeUnit.MINUTES);", "originalCommit": "dd153bc2dd11f13d4f9835ba5eb31efa332d4884", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM0MzY0Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r411343643", "bodyText": "A test should not rely on sleep. I believe this should not be necessary.", "author": "sancar", "createdAt": "2020-04-20T12:39:50Z", "path": "hazelcast/src/test/java/com/hazelcast/client/multimap/ClientMultiMapTest.java", "diffHunk": "@@ -65,6 +78,137 @@ public void testPut() {\n         assertTrue(mm.put(key, 1));\n     }\n \n+    protected <K, V> EntryListener<K, V> putAllEntryListenerBuilder(Consumer<EntryEvent<K, V>> f) {\n+        return new EntryAdapter<K, V>() {\n+            public void entryAdded(EntryEvent<K, V> event) {\n+                f.accept(event);\n+            }\n+\n+            public void entryRemoved(EntryEvent<K, V> event) {\n+            }\n+\n+            public void entryEvicted(EntryEvent<K, V> event) {\n+                entryRemoved(event);\n+            }\n+\n+            @Override\n+            public void mapEvicted(MapEvent event) {\n+            }\n+\n+            @Override\n+            public void mapCleared(MapEvent event) {\n+            }\n+        };\n+    }\n+\n+    protected void testMultiMapPutAllSetup() {\n+        MultiMapConfig multiMapConfig1 = new MultiMapConfig()\n+                .setName(\"testMultiMapList\")\n+                .setValueCollectionType(MultiMapConfig.ValueCollectionType.LIST)\n+                .setBinary(false);\n+        MultiMapConfig multiMapConfig2 = new MultiMapConfig()\n+                .setName(\"testMultiMapSet\")\n+                .setValueCollectionType(MultiMapConfig.ValueCollectionType.SET)\n+                .setBinary(false);\n+        MultiMapConfig multiMapConfig3 = new MultiMapConfig()\n+                .setName(\"expectedMultiMap1\")\n+                .setValueCollectionType(MultiMapConfig.ValueCollectionType.LIST)\n+                .setBinary(false);\n+        client.getConfig()\n+                .addMultiMapConfig(multiMapConfig1)\n+                .addMultiMapConfig(multiMapConfig2)\n+                .addMultiMapConfig(multiMapConfig3);\n+    }\n+\n+    public void testMultiMapPutAllTemplate(Map<String, Collection<? extends Integer>> expectedMultiMap,\n+                                           Consumer<MultiMap<String, Integer>> putAllOperation1) throws InterruptedException {\n+        MultiMap<String, Integer> mmap1 = client.getMultiMap(\"testMultiMapList\");\n+        MultiMap<String, Integer> mmap2 = client.getMultiMap(\"testMultiMapSet\");\n+        Map<String, Collection<Integer>> resultMap1 = new HashMap<>();\n+        Map<String, Collection<Integer>> resultMap2 = new HashMap<>();\n+\n+        int totalItems = 0;\n+        Set<String> ks = expectedMultiMap.keySet();\n+        for (String s : ks) {\n+            Collection expectedCollection = expectedMultiMap.get(s);\n+            totalItems += expectedCollection.size()\n+                    + ((Long) expectedCollection.stream().distinct().count()).intValue();\n+        }\n+\n+        final CountDownLatch latchAdded = new CountDownLatch(totalItems);\n+        mmap1.addEntryListener(putAllEntryListenerBuilder((event) -> {\n+                    String key = (String) event.getKey();\n+                    Integer value = (Integer) event.getValue();\n+                    Collection<Integer> c;\n+                    if (!resultMap1.containsKey(key)) {\n+                        c = new ArrayList<>();\n+                    } else {\n+                        c = resultMap1.get(key);\n+                    }\n+                    c.add(value);\n+                    resultMap1.put(key, c);\n+                    latchAdded.countDown();\n+                }\n+        ), true);\n+        mmap2.addEntryListener(putAllEntryListenerBuilder((event) -> {\n+                    String key = (String) event.getKey();\n+                    Integer value = (Integer) event.getValue();\n+                    Collection<Integer> c;\n+                    if (!resultMap2.containsKey(key)) {\n+                        c = new ArrayList<>();\n+                    } else {\n+                        c = resultMap2.get(key);\n+                    }\n+                    c.add(value);\n+                    resultMap2.put(key, c);\n+                    latchAdded.countDown();\n+                }\n+        ), true);\n+\n+        putAllOperation1.accept(mmap1);\n+        putAllOperation1.accept(mmap2);\n+        latchAdded.await(5, TimeUnit.MINUTES);\n+        sleepMillis(500);", "originalCommit": "dd153bc2dd11f13d4f9835ba5eb31efa332d4884", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM0NDUyMA==", "url": "https://github.com/hazelcast/hazelcast/pull/16698#discussion_r411344520", "bodyText": "Is this also unused ?", "author": "sancar", "createdAt": "2020-04-20T12:41:05Z", "path": "hazelcast/src/test/java/com/hazelcast/multimap/MultiMapTest.java", "diffHunk": "@@ -104,6 +114,147 @@ public void testMultiMapPutGetRemove() {\n         assertEquals(0, multiMap.size());\n     }\n \n+    protected <K, V> EntryListener<K, V> putAllEntryListenerBuilder(Consumer<EntryEvent<K, V>> f) {\n+        return new EntryAdapter<K, V>() {\n+            public void entryAdded(EntryEvent<K, V> event) {\n+                f.accept(event);\n+            }\n+\n+            public void entryRemoved(EntryEvent<K, V> event) {\n+            }\n+\n+            public void entryEvicted(EntryEvent<K, V> event) {\n+                entryRemoved(event);\n+            }\n+\n+            @Override\n+            public void mapEvicted(MapEvent event) {\n+            }\n+\n+            @Override\n+            public void mapCleared(MapEvent event) {\n+            }\n+        };\n+    }\n+\n+    protected HazelcastInstance testMultiMapPutAllSetup() {\n+        MultiMapConfig multiMapConfig1 = new MultiMapConfig()\n+                .setName(\"testMultiMapPutAllMapList\")\n+                .setValueCollectionType(MultiMapConfig.ValueCollectionType.LIST)\n+                .setBinary(false);\n+        MultiMapConfig multiMapConfig2 = new MultiMapConfig()\n+                .setName(\"testMultiMapPutAllMapSet\")\n+                .setValueCollectionType(MultiMapConfig.ValueCollectionType.SET)\n+                .setBinary(false);\n+        MultiMapConfig multiMapConfig3 = new MultiMapConfig()", "originalCommit": "dd153bc2dd11f13d4f9835ba5eb31efa332d4884", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "83119aa4e73b0830a79c51992e7373d195046fb2", "url": "https://github.com/hazelcast/hazelcast/commit/83119aa4e73b0830a79c51992e7373d195046fb2", "message": "New MultiMap bulk put feature request (#9079)\nAdd two new interfaces for MultiMap.putAllAsync and implement for MultiMapProxyImpl and ClientMultiMapProxy.\nAdd new operation classes, MultiMapPutAllOperationFactory, PutAllOperation and PutAllBackupOperation.\nAdd corresponding tests for bulk put, statistics and backup.\n\nAdd new client protocol codecs MultiMapPutAllCodec and ListDataCodec and new message handler MultiMapPutAllMessageTask. Update generated client protocol tests and resources.\nAdd new Preconditions.checkTrueUnsupportedOperation.", "committedDate": "2020-04-21T15:50:43Z", "type": "commit"}, {"oid": "83119aa4e73b0830a79c51992e7373d195046fb2", "url": "https://github.com/hazelcast/hazelcast/commit/83119aa4e73b0830a79c51992e7373d195046fb2", "message": "New MultiMap bulk put feature request (#9079)\nAdd two new interfaces for MultiMap.putAllAsync and implement for MultiMapProxyImpl and ClientMultiMapProxy.\nAdd new operation classes, MultiMapPutAllOperationFactory, PutAllOperation and PutAllBackupOperation.\nAdd corresponding tests for bulk put, statistics and backup.\n\nAdd new client protocol codecs MultiMapPutAllCodec and ListDataCodec and new message handler MultiMapPutAllMessageTask. Update generated client protocol tests and resources.\nAdd new Preconditions.checkTrueUnsupportedOperation.", "committedDate": "2020-04-21T15:50:43Z", "type": "forcePushed"}]}