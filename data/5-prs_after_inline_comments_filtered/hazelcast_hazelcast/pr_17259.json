{"pr_number": 17259, "pr_title": "Value of Average Get and Put Latency of Map as a Metric", "pr_createdAt": "2020-07-22T18:13:50Z", "pr_url": "https://github.com/hazelcast/hazelcast/pull/17259", "timeline": [{"oid": "dba95c55fe812bbbe00e5369094e8bd113cb50dc", "url": "https://github.com/hazelcast/hazelcast/commit/dba95c55fe812bbbe00e5369094e8bd113cb50dc", "message": "Average Get and Put Latency of Map", "committedDate": "2020-07-22T18:10:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTI2Mzc0Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17259#discussion_r459263746", "bodyText": "please keep using camelCase method names (first character should be lowercase)", "author": "erosb", "createdAt": "2020-07-23T07:33:13Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/util/phonehome/MapInfoCollector.java", "diffHunk": "@@ -103,4 +105,18 @@ private long countMapWithNativeInMemoryFormat() {\n         return mapConfigs.stream()\n                 .filter(mapConfig -> mapConfig != null && mapConfig.getInMemoryFormat() == InMemoryFormat.NATIVE).count();\n     }\n+\n+    private long MapPutLatency(Node node) {", "originalCommit": "dba95c55fe812bbbe00e5369094e8bd113cb50dc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTI2NDM0MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17259#discussion_r459264341", "bodyText": "before this filter, you could map to .map(IMap::getLocalMapStats) because you don't need the map itself in the rest of the operations", "author": "erosb", "createdAt": "2020-07-23T07:34:35Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/util/phonehome/MapInfoCollector.java", "diffHunk": "@@ -103,4 +105,18 @@ private long countMapWithNativeInMemoryFormat() {\n         return mapConfigs.stream()\n                 .filter(mapConfig -> mapConfig != null && mapConfig.getInMemoryFormat() == InMemoryFormat.NATIVE).count();\n     }\n+\n+    private long MapPutLatency(Node node) {\n+        return (long) mapConfigs.stream().map(mapConfig -> node.hazelcastInstance.getMap(mapConfig.getName()))\n+                .filter(map -> map.getLocalMapStats().getPutOperationCount() != 0L)", "originalCommit": "dba95c55fe812bbbe00e5369094e8bd113cb50dc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTI2NDY3MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17259#discussion_r459264671", "bodyText": "(the same comments on this method as for the above)", "author": "erosb", "createdAt": "2020-07-23T07:35:16Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/util/phonehome/MapInfoCollector.java", "diffHunk": "@@ -103,4 +105,18 @@ private long countMapWithNativeInMemoryFormat() {\n         return mapConfigs.stream()\n                 .filter(mapConfig -> mapConfig != null && mapConfig.getInMemoryFormat() == InMemoryFormat.NATIVE).count();\n     }\n+\n+    private long MapPutLatency(Node node) {\n+        return (long) mapConfigs.stream().map(mapConfig -> node.hazelcastInstance.getMap(mapConfig.getName()))\n+                .filter(map -> map.getLocalMapStats().getPutOperationCount() != 0L)\n+                .mapToDouble(map -> map.getLocalMapStats().getTotalPutLatency() / map.getLocalMapStats().getPutOperationCount())\n+                .average().orElse(0);\n+    }\n+\n+    private long MapGetLatency(Node node) {", "originalCommit": "dba95c55fe812bbbe00e5369094e8bd113cb50dc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTI2OTk4Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17259#discussion_r459269982", "bodyText": "This test calculates the expected output in the same way as the implementation, which means it will never fail. Please improve the test to use concrete input and output values (there are multiple ways of doing it, but I think you can figure it out)", "author": "erosb", "createdAt": "2020-07-23T07:46:56Z", "path": "hazelcast/src/test/java/com/hazelcast/internal/util/phonehome/PhoneHomeTest.java", "diffHunk": "@@ -503,5 +504,43 @@ public void testFlakeIDGeneratorCount() {\n \n     }\n \n+    @Test\n+    public void testMapPutLatency() {\n+        Map<String, String> parameters;\n+        parameters = phoneHome.phoneHome(true);\n+        assertEquals(parameters.get(\"mpptla\"), \"0\");\n+\n+        IMap<Object, Object> iMap = node.hazelcastInstance.getMap(\"hazelcast\");\n+        iMap.put(\"1\", \"hazelcast\");\n+        parameters = phoneHome.phoneHome(true);\n+        assertEquals(parameters.get(\"mpptla\"),\n+                String.valueOf(iMap.getLocalMapStats().getTotalPutLatency() / iMap.getLocalMapStats().getPutOperationCount()));\n+\n+        iMap.put(\"2\", \"phonehome\");\n+        parameters = phoneHome.phoneHome(true);\n+        assertEquals(parameters.get(\"mpptla\"),\n+                String.valueOf(iMap.getLocalMapStats().getTotalPutLatency() / iMap.getLocalMapStats().getPutOperationCount()));", "originalCommit": "dba95c55fe812bbbe00e5369094e8bd113cb50dc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTI3MDA2NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17259#discussion_r459270064", "bodyText": "same comment for this test", "author": "erosb", "createdAt": "2020-07-23T07:47:07Z", "path": "hazelcast/src/test/java/com/hazelcast/internal/util/phonehome/PhoneHomeTest.java", "diffHunk": "@@ -503,5 +504,43 @@ public void testFlakeIDGeneratorCount() {\n \n     }\n \n+    @Test\n+    public void testMapPutLatency() {\n+        Map<String, String> parameters;\n+        parameters = phoneHome.phoneHome(true);\n+        assertEquals(parameters.get(\"mpptla\"), \"0\");\n+\n+        IMap<Object, Object> iMap = node.hazelcastInstance.getMap(\"hazelcast\");\n+        iMap.put(\"1\", \"hazelcast\");\n+        parameters = phoneHome.phoneHome(true);\n+        assertEquals(parameters.get(\"mpptla\"),\n+                String.valueOf(iMap.getLocalMapStats().getTotalPutLatency() / iMap.getLocalMapStats().getPutOperationCount()));\n+\n+        iMap.put(\"2\", \"phonehome\");\n+        parameters = phoneHome.phoneHome(true);\n+        assertEquals(parameters.get(\"mpptla\"),\n+                String.valueOf(iMap.getLocalMapStats().getTotalPutLatency() / iMap.getLocalMapStats().getPutOperationCount()));\n+    }\n+\n+    @Test\n+    public void testMapGetLatency() {\n+        Map<String, String> parameters;\n+        parameters = phoneHome.phoneHome(true);\n+        assertEquals(parameters.get(\"mpgtla\"), \"0\");\n+\n+        IMap<Object, Object> iMap = node.hazelcastInstance.getMap(\"hazelcast\");\n+        iMap.put(\"1\", \"hazelcast\");\n+        iMap.get(\"1\");\n+        parameters = phoneHome.phoneHome(true);\n+        assertEquals(parameters.get(\"mpgtla\"),\n+                String.valueOf(iMap.getLocalMapStats().getTotalGetLatency() / iMap.getLocalMapStats().getGetOperationCount()));\n+\n+        iMap.put(\"2\", \"phonehome\");\n+        iMap.get(\"2\");\n+        parameters = phoneHome.phoneHome(true);\n+        assertEquals(parameters.get(\"mpgtla\"),\n+                String.valueOf(iMap.getLocalMapStats().getTotalGetLatency() / iMap.getLocalMapStats().getGetOperationCount()));", "originalCommit": "dba95c55fe812bbbe00e5369094e8bd113cb50dc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTI3NTA1Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/17259#discussion_r459275057", "bodyText": "Also, it is unclear what is the measurement unit here. It seems it sends everything in milliseconds, which is just too granular. How does this formula handle rounding? Please add some unittests covering rounding. Also it would be good to have a test which covers the divide-by-zero case. Last, are you sure 0 is a good marker for the no-data case? The average can also be 0 in cases when the map accesses are always fast (and that can easily happen).", "author": "erosb", "createdAt": "2020-07-23T07:57:15Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/util/phonehome/MapInfoCollector.java", "diffHunk": "@@ -103,4 +105,18 @@ private long countMapWithNativeInMemoryFormat() {\n         return mapConfigs.stream()\n                 .filter(mapConfig -> mapConfig != null && mapConfig.getInMemoryFormat() == InMemoryFormat.NATIVE).count();\n     }\n+\n+    private long MapPutLatency(Node node) {\n+        return (long) mapConfigs.stream().map(mapConfig -> node.hazelcastInstance.getMap(mapConfig.getName()))\n+                .filter(map -> map.getLocalMapStats().getPutOperationCount() != 0L)\n+                .mapToDouble(map -> map.getLocalMapStats().getTotalPutLatency() / map.getLocalMapStats().getPutOperationCount())\n+                .average().orElse(0);\n+    }\n+\n+    private long MapGetLatency(Node node) {\n+        return (long) mapConfigs.stream().map(mapConfig -> node.hazelcastInstance.getMap(mapConfig.getName()))\n+                .filter(map -> map.getLocalMapStats().getGetOperationCount() != 0L)\n+                .mapToDouble(map -> map.getLocalMapStats().getTotalGetLatency() / map.getLocalMapStats().getGetOperationCount())", "originalCommit": "dba95c55fe812bbbe00e5369094e8bd113cb50dc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e3b59c32045ec4853968b92903ab3d7cc73d9b81", "url": "https://github.com/hazelcast/hazelcast/commit/e3b59c32045ec4853968b92903ab3d7cc73d9b81", "message": "improvised the method pf calculating latency", "committedDate": "2020-07-30T15:53:28Z", "type": "commit"}, {"oid": "b58e7cecf044fd779f6eed0c538a7b914bbf177b", "url": "https://github.com/hazelcast/hazelcast/commit/b58e7cecf044fd779f6eed0c538a7b914bbf177b", "message": "Add integ test for latency", "committedDate": "2020-07-30T21:30:56Z", "type": "commit"}, {"oid": "671e8bf3afd77532145f5664e6ec064e73947b13", "url": "https://github.com/hazelcast/hazelcast/commit/671e8bf3afd77532145f5664e6ec064e73947b13", "message": "Add a fake map store to test latency", "committedDate": "2020-07-31T11:42:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU3NjkwOA==", "url": "https://github.com/hazelcast/hazelcast/pull/17259#discussion_r463576908", "bodyText": "What does this do? It doesn't seem to be necessary (actually it doesn't cause any exceptions only because the following setImplementation() call will set the className field to null)", "author": "erosb", "createdAt": "2020-07-31T12:19:10Z", "path": "hazelcast/src/test/java/com/hazelcast/internal/util/phonehome/PhoneHomeIntegrationTest.java", "diffHunk": "@@ -163,5 +167,75 @@ public void testCacheMetrics() {\n                 .withQueryParam(\"cawact\", equalTo(\"1\")));\n     }\n \n+    @Test\n+    public void testMapLatencies() {\n+        DelayMapStore mapStore = new DelayMapStore();\n+        MapStoreConfig mapStoreConfig = new MapStoreConfig();\n+        mapStoreConfig.setEnabled(true);\n+        mapStoreConfig.setClassName(getClass().getName());", "originalCommit": "671e8bf3afd77532145f5664e6ec064e73947b13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU3NzM3Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17259#discussion_r463577376", "bodyText": "nit: you can avoid the mapStore local variable (just setImplementation(new DelayMapStore()) works)", "author": "erosb", "createdAt": "2020-07-31T12:20:13Z", "path": "hazelcast/src/test/java/com/hazelcast/internal/util/phonehome/PhoneHomeIntegrationTest.java", "diffHunk": "@@ -163,5 +167,75 @@ public void testCacheMetrics() {\n                 .withQueryParam(\"cawact\", equalTo(\"1\")));\n     }\n \n+    @Test\n+    public void testMapLatencies() {\n+        DelayMapStore mapStore = new DelayMapStore();\n+        MapStoreConfig mapStoreConfig = new MapStoreConfig();\n+        mapStoreConfig.setEnabled(true);\n+        mapStoreConfig.setClassName(getClass().getName());\n+        mapStoreConfig.setImplementation(mapStore);", "originalCommit": "671e8bf3afd77532145f5664e6ec064e73947b13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2e2cc042415168ca98afba29b74ca52c896fe52f", "url": "https://github.com/hazelcast/hazelcast/commit/2e2cc042415168ca98afba29b74ca52c896fe52f", "message": "Improvised integ test for get latency", "committedDate": "2020-07-31T12:27:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU4MjMxNg==", "url": "https://github.com/hazelcast/hazelcast/pull/17259#discussion_r463582316", "bodyText": "So what happens is that first in an equalTo() call checks if the actual value is equal to a computed value, then a second assertion checks that the computed value is approximately correct.\nIt would be better to put a greaterThanOrEqualTo() call into the wiremock verification call itself, but that doesn't seem to be supported by wiremock. Briefly looking at wiremock matchers, you can create a custom GreaterThanOrEualToPattern class which extends StringValuePattern and override the match() method. Then you can use this newly created matcher like .withQueryParam(\"mpptla\", new GreaterThanOrEqualToPattern(200))", "author": "erosb", "createdAt": "2020-07-31T12:31:22Z", "path": "hazelcast/src/test/java/com/hazelcast/internal/util/phonehome/PhoneHomeIntegrationTest.java", "diffHunk": "@@ -163,5 +167,75 @@ public void testCacheMetrics() {\n                 .withQueryParam(\"cawact\", equalTo(\"1\")));\n     }\n \n+    @Test\n+    public void testMapLatencies() {\n+        DelayMapStore mapStore = new DelayMapStore();\n+        MapStoreConfig mapStoreConfig = new MapStoreConfig();\n+        mapStoreConfig.setEnabled(true);\n+        mapStoreConfig.setClassName(getClass().getName());\n+        mapStoreConfig.setImplementation(mapStore);\n+        IMap<String, String> iMap = node.hazelcastInstance.getMap(\"hazelcast\");\n+        node.getConfig().getMapConfig(\"hazelcast\").setMapStoreConfig(mapStoreConfig);\n+        iMap.put(\"1\", \"hazelcast\");\n+\n+\n+        stubFor(get(urlPathEqualTo(\"/ping\"))\n+                .willReturn(aResponse()\n+                        .withStatus(200)));\n+\n+        phoneHome.phoneHome(false);\n+        verify(1, getRequestedFor(urlPathEqualTo(\"/ping\"))\n+                .withQueryParam(\"mpptla\", equalTo(String.valueOf(iMap.getLocalMapStats().getTotalPutLatency() / iMap.getLocalMapStats().getPutOperationCount())))\n+                .withQueryParam(\"mpgtla\", equalTo(\"-1\")));\n+\n+        assertGreaterOrEquals(\"mpptla\", iMap.getLocalMapStats().getTotalPutLatency() / iMap.getLocalMapStats().getPutOperationCount(), 200);", "originalCommit": "671e8bf3afd77532145f5664e6ec064e73947b13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU4NDIyMA==", "url": "https://github.com/hazelcast/hazelcast/pull/17259#discussion_r463584220", "bodyText": "Okay I'll look into this.", "author": "chanmol1999", "createdAt": "2020-07-31T12:35:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU4MjMxNg=="}], "type": "inlineReview"}, {"oid": "06c9a6de20fb7751169316b810bf22f981258779", "url": "https://github.com/hazelcast/hazelcast/commit/06c9a6de20fb7751169316b810bf22f981258779", "message": "Removed unnecessary local variables", "committedDate": "2020-07-31T12:34:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU4NTA0OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17259#discussion_r463585049", "bodyText": "Please extract mapStats.getTotalPutLatency() / mapStats.getPutOperationCount() into a local variable, it is calculated twice (same for the mapStats.getTotalGetLatency() / mapStats.getGetOperationCount() expression)", "author": "erosb", "createdAt": "2020-07-31T12:37:14Z", "path": "hazelcast/src/test/java/com/hazelcast/internal/util/phonehome/PhoneHomeIntegrationTest.java", "diffHunk": "@@ -163,5 +169,81 @@ public void testCacheMetrics() {\n                 .withQueryParam(\"cawact\", equalTo(\"1\")));\n     }\n \n+    @Test\n+    public void testMapLatencies() {\n+        MapStoreConfig mapStoreConfig = new MapStoreConfig();\n+        mapStoreConfig.setEnabled(true);\n+        mapStoreConfig.setImplementation(new DelayMapStore());\n+        IMap<String, String> iMap = node.hazelcastInstance.getMap(\"hazelcast\");\n+        node.getConfig().getMapConfig(\"hazelcast\").setMapStoreConfig(mapStoreConfig);\n+        iMap.put(\"key1\", \"hazelcast\");\n+        iMap.put(\"key2\", \"phonehome\");\n+        iMap.get(\"key3\");\n+        LocalMapStatsImpl mapStats = (LocalMapStatsImpl) iMap.getLocalMapStats();\n+\n+\n+        stubFor(get(urlPathEqualTo(\"/ping\"))\n+                .willReturn(aResponse()\n+                        .withStatus(200)));\n+\n+        phoneHome.phoneHome(false);\n+        verify(1, getRequestedFor(urlPathEqualTo(\"/ping\"))\n+                .withQueryParam(\"mpptla\",\n+                        equalTo(String.valueOf(mapStats.getTotalPutLatency() / mapStats.getPutOperationCount())))", "originalCommit": "06c9a6de20fb7751169316b810bf22f981258779", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU4Nzg5Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17259#discussion_r463587892", "bodyText": "Please don't remove previously added assertions. If the test fails then please investigate the failure.", "author": "erosb", "createdAt": "2020-07-31T12:43:30Z", "path": "hazelcast/src/test/java/com/hazelcast/internal/util/phonehome/PhoneHomeIntegrationTest.java", "diffHunk": "@@ -101,7 +107,7 @@ public void testMapMetrics() {\n                 .withQueryParam(\"mpaoict\", equalTo(\"1\"))\n                 .withQueryParam(\"mphect\", equalTo(\"1\"))\n                 .withQueryParam(\"mpwact\", equalTo(\"1\"))\n-                .withQueryParam(\"mpaocct\", equalTo(\"1\"))\n+//                .withQueryParam(\"mpaocct\", equalTo(\"1\"))", "originalCommit": "06c9a6de20fb7751169316b810bf22f981258779", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ceb124e16c3b6d65f131d00dcae05549b96c4e3b", "url": "https://github.com/hazelcast/hazelcast/commit/ceb124e16c3b6d65f131d00dcae05549b96c4e3b", "message": "Improved Integration tests", "committedDate": "2020-08-01T08:13:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk2MDM5OA==", "url": "https://github.com/hazelcast/hazelcast/pull/17259#discussion_r463960398", "bodyText": "I would call it DISTRIBUTED_OBJECT_TYPE_COUNT", "author": "erosb", "createdAt": "2020-08-01T13:05:15Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/util/phonehome/MapInfoCollector.java", "diffHunk": "@@ -31,8 +34,8 @@\n \n class MapInfoCollector implements MetricsCollector {\n \n-    private static final int COUNT_OF_MAP_METRICS = 9;\n-    Collection<MapConfig> mapConfigs;\n+    private static final int COUNT_OF_MAP_METRICS = 11;", "originalCommit": "ceb124e16c3b6d65f131d00dcae05549b96c4e3b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8e9caa334851f13d641eaf195b8df5686ba5ea8e", "url": "https://github.com/hazelcast/hazelcast/commit/8e9caa334851f13d641eaf195b8df5686ba5ea8e", "message": "Update variable name", "committedDate": "2020-08-01T15:12:52Z", "type": "commit"}, {"oid": "90fbf09b1891710155782b7dd3fb5c418987c37f", "url": "https://github.com/hazelcast/hazelcast/commit/90fbf09b1891710155782b7dd3fb5c418987c37f", "message": "Implemented weighted average method to calculate latency", "committedDate": "2020-08-03T18:41:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDk4NDA2MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17259#discussion_r464984061", "bodyText": "The above 4 lines are duplicated in the two mapstore tests. Please extract the map initialization into a separate method to resolve the duplication.", "author": "erosb", "createdAt": "2020-08-04T11:31:34Z", "path": "hazelcast/src/test/java/com/hazelcast/internal/util/phonehome/PhoneHomeTest.java", "diffHunk": "@@ -503,5 +506,81 @@ public void testFlakeIDGeneratorCount() {\n \n     }\n \n+    @Test\n+    public void testMapPutLatencyWithoutMapStore() {\n+        Map<String, String> parameters;\n+        parameters = phoneHome.phoneHome(true);\n+        assertEquals(parameters.get(\"mpptla\"), \"-1\");\n+\n+        IMap<Object, Object> iMap = node.hazelcastInstance.getMap(\"hazelcast\");\n+        LocalMapStatsImpl localMapStats = (LocalMapStatsImpl) iMap.getLocalMapStats();\n+\n+        localMapStats.incrementPutLatencyNanos(2000000000L);\n+        parameters = phoneHome.phoneHome(true);\n+        assertEquals(parameters.get(\"mpptla\"), String.valueOf(2000));\n+\n+        localMapStats.incrementPutLatencyNanos(1000000000L);\n+        parameters = phoneHome.phoneHome(true);\n+        assertEquals(parameters.get(\"mpptla\"), String.valueOf(1500));\n+\n+        localMapStats.incrementPutLatencyNanos(2000000000L);\n+        parameters = phoneHome.phoneHome(true);\n+        assertEquals(parameters.get(\"mpptla\"), String.valueOf(1666));\n+\n+    }\n+\n+    @Test\n+    public void testMapPutLatencyWithMapStore() {\n+        Map<String, String> parameters;\n+        parameters = phoneHome.phoneHome(true);\n+        assertEquals(parameters.get(\"mpptlams\"), \"-1\");\n+\n+        IMap<Object, Object> iMap = node.hazelcastInstance.getMap(\"hazelcast\");\n+        MapStoreConfig mapStoreConfig = new MapStoreConfig();\n+        mapStoreConfig.setEnabled(true);\n+        mapStoreConfig.setImplementation(new DelayMapStore());\n+        node.getConfig().getMapConfig(\"hazelcast\").setMapStoreConfig(mapStoreConfig);\n+        iMap.put(\"key1\", \"hazelcast\");\n+        iMap.put(\"key2\", \"phonehome\");\n+        parameters = phoneHome.phoneHome(true);\n+        assertGreaterOrEquals(\"mpptlams\", Long.parseLong(parameters.get(\"mpptlams\")), 200);\n+\n+    }\n+\n+    @Test\n+    public void testMapGetLatency() {\n+        Map<String, String> parameters;\n+        parameters = phoneHome.phoneHome(true);\n+        assertEquals(parameters.get(\"mpgtla\"), \"-1\");\n+\n+        IMap<Object, Object> iMap = node.hazelcastInstance.getMap(\"hazelcast\");\n+        LocalMapStatsImpl localMapStats = (LocalMapStatsImpl) iMap.getLocalMapStats();\n+\n+        localMapStats.incrementGetLatencyNanos(2000000000L);\n+        parameters = phoneHome.phoneHome(true);\n+        assertEquals(parameters.get(\"mpgtla\"), String.valueOf(2000));\n+\n+        localMapStats.incrementGetLatencyNanos(2000000000L);\n+        parameters = phoneHome.phoneHome(true);\n+        assertEquals(parameters.get(\"mpgtla\"), String.valueOf(2000));\n+    }\n+\n+    @Test\n+    public void testMapGetLatencyWithMapStore() {\n+        Map<String, String> parameters;\n+        parameters = phoneHome.phoneHome(true);\n+        assertEquals(parameters.get(\"mpgtlams\"), \"-1\");\n+\n+        IMap<Object, Object> iMap = node.hazelcastInstance.getMap(\"hazelcast\");\n+        MapStoreConfig mapStoreConfig = new MapStoreConfig();\n+        mapStoreConfig.setEnabled(true);\n+        mapStoreConfig.setImplementation(new DelayMapStore());\n+        node.getConfig().getMapConfig(\"hazelcast\").setMapStoreConfig(mapStoreConfig);", "originalCommit": "90fbf09b1891710155782b7dd3fb5c418987c37f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDk4NjQzMQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17259#discussion_r464986431", "bodyText": "We loose data here if two maps have the same get latency, don't we? It seems only the second map stats will be included in the weighed average. Please add a unittest covering this case.\nI think most of this method will have to be dropped, and also the weightedAverageLatency() will be unnecessary if this gets implemented properly.", "author": "erosb", "createdAt": "2020-08-04T11:36:40Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/util/phonehome/MapInfoCollector.java", "diffHunk": "@@ -55,52 +59,102 @@\n         mapInfo.put(\"mpaocct\", String.valueOf(countMapWithAtleastOneAttribute()));\n         mapInfo.put(\"mpevct\", String.valueOf(countMapUsingEviction()));\n         mapInfo.put(\"mpnmct\", String.valueOf(countMapWithNativeInMemoryFormat()));\n+        mapInfo.put(\"mpptlams\", String.valueOf(mapPutLatencyWithMapStore(hazelcastNode)));\n+        mapInfo.put(\"mpptla\", String.valueOf(mapPutLatencyWithoutMapStore(hazelcastNode)));\n+        mapInfo.put(\"mpgtlams\", String.valueOf(mapGetLatencyWithMapStore(hazelcastNode)));\n+        mapInfo.put(\"mpgtla\", String.valueOf(mapGetLatencyWithoutMapStore(hazelcastNode)));\n \n         return mapInfo;\n     }\n \n     private long countMapWithBackupReadEnabled() {\n         return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.isReadBackupData()).count();\n+                .filter(MapConfig::isReadBackupData).count();\n     }\n \n     private long countMapWithMapStoreEnabled() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.getMapStoreConfig().isEnabled()).count();\n+        return mapConfigs.stream().map(MapConfig::getMapStoreConfig)\n+                .filter(MapStoreConfig::isEnabled).count();\n     }\n \n     private long countMapWithAtleastOneQueryCache() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && !(mapConfig.getQueryCacheConfigs().isEmpty())).count();\n+        return mapConfigs.stream().map(MapConfig::getQueryCacheConfigs)\n+                .filter(queryCacheConfigs -> !(queryCacheConfigs.isEmpty())).count();\n     }\n \n     private long countMapWithAtleastOneIndex() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && !(mapConfig.getIndexConfigs().isEmpty())).count();\n+        return mapConfigs.stream().map(MapConfig::getIndexConfigs)\n+                .filter(indexConfigs -> !(indexConfigs.isEmpty())).count();\n     }\n \n     private long countMapWithHotRestartEnabled() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.getHotRestartConfig().isEnabled()).count();\n+        return mapConfigs.stream().map(MapConfig::getHotRestartConfig)\n+                .filter(HotRestartConfig::isEnabled).count();\n     }\n \n     private long countMapWithWANReplication() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.getWanReplicationRef() != null).count();\n+        return mapConfigs.stream().map(MapConfig::getWanReplicationRef)\n+                .filter(Objects::nonNull).count();\n     }\n \n     private long countMapWithAtleastOneAttribute() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && !(mapConfig.getAttributeConfigs().isEmpty())).count();\n+        return mapConfigs.stream().map(MapConfig::getAttributeConfigs)\n+                .filter(attributeConfigs -> !(attributeConfigs.isEmpty())).count();\n     }\n \n     private long countMapUsingEviction() {\n-        return mapConfigs.stream().filter(mapConfig -> mapConfig != null\n-                && mapConfig.getEvictionConfig().getEvictionPolicy() != EvictionPolicy.NONE).count();\n+        return mapConfigs.stream().map(MapConfig::getEvictionConfig)\n+                .filter(evictionConfig -> evictionConfig.getEvictionPolicy() != EvictionPolicy.NONE).count();\n     }\n \n     private long countMapWithNativeInMemoryFormat() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.getInMemoryFormat() == InMemoryFormat.NATIVE).count();\n+        return mapConfigs.stream().map(MapConfig::getInMemoryFormat)\n+                .filter(inMemoryFormat -> inMemoryFormat == InMemoryFormat.NATIVE).count();\n+    }\n+\n+    private long mapPutLatencyWithoutMapStore(Node node) {\n+        Map<Long, Long> latencyInfo = new HashMap<>();\n+        mapConfigs.stream()\n+                .filter(mapConfig -> !mapConfig.getMapStoreConfig().isEnabled())\n+                .map(mapConfig -> node.hazelcastInstance.getMap(mapConfig.getName()).getLocalMapStats())\n+                .filter(mapStats -> mapStats.getPutOperationCount() != 0L)\n+                .forEach(mapStats -> latencyInfo.put(mapStats.getTotalPutLatency(), mapStats.getPutOperationCount()));\n+\n+        return MetricsCollector.weightedAverageLatency(latencyInfo);\n+    }\n+\n+    private long mapPutLatencyWithMapStore(Node node) {\n+        Map<Long, Long> latencyInfo = new HashMap<>();\n+        mapConfigs.stream()\n+                .filter(mapConfig -> mapConfig.getMapStoreConfig().isEnabled())\n+                .map(mapConfig -> node.hazelcastInstance.getMap(mapConfig.getName()).getLocalMapStats())\n+                .filter(mapStats -> mapStats.getPutOperationCount() != 0L)\n+                .forEach(mapStats -> latencyInfo.put(mapStats.getTotalPutLatency(), mapStats.getPutOperationCount()));\n+\n+        return MetricsCollector.weightedAverageLatency(latencyInfo);\n+\n+    }\n+\n+    private long mapGetLatencyWithoutMapStore(Node node) {\n+        Map<Long, Long> latencyInfo = new HashMap<>();\n+        mapConfigs.stream()\n+                .filter(mapConfig -> !mapConfig.getMapStoreConfig().isEnabled())\n+                .map(mapConfig -> node.hazelcastInstance.getMap(mapConfig.getName()).getLocalMapStats())\n+                .filter(mapStats -> mapStats.getGetOperationCount() != 0L)\n+                .forEach(mapStats -> latencyInfo.put(mapStats.getTotalGetLatency(), mapStats.getGetOperationCount()));", "originalCommit": "90fbf09b1891710155782b7dd3fb5c418987c37f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDk5NjU5NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17259#discussion_r464996594", "bodyText": "Same here. Please also resolve the duplication between the #mapGetLatencyWithoutMapStore() and #mapGetLatencyWithMapStore() methods. They are only different in one line. You can abstract that in a parameter of type Predicate in a generalized method.\nPlease also resolve the duplication in the #mapPutLatencyWithoutMapStore() and #mapPutLatencyWithMapStore() methods.", "author": "erosb", "createdAt": "2020-08-04T11:56:36Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/util/phonehome/MapInfoCollector.java", "diffHunk": "@@ -55,52 +59,102 @@\n         mapInfo.put(\"mpaocct\", String.valueOf(countMapWithAtleastOneAttribute()));\n         mapInfo.put(\"mpevct\", String.valueOf(countMapUsingEviction()));\n         mapInfo.put(\"mpnmct\", String.valueOf(countMapWithNativeInMemoryFormat()));\n+        mapInfo.put(\"mpptlams\", String.valueOf(mapPutLatencyWithMapStore(hazelcastNode)));\n+        mapInfo.put(\"mpptla\", String.valueOf(mapPutLatencyWithoutMapStore(hazelcastNode)));\n+        mapInfo.put(\"mpgtlams\", String.valueOf(mapGetLatencyWithMapStore(hazelcastNode)));\n+        mapInfo.put(\"mpgtla\", String.valueOf(mapGetLatencyWithoutMapStore(hazelcastNode)));\n \n         return mapInfo;\n     }\n \n     private long countMapWithBackupReadEnabled() {\n         return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.isReadBackupData()).count();\n+                .filter(MapConfig::isReadBackupData).count();\n     }\n \n     private long countMapWithMapStoreEnabled() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.getMapStoreConfig().isEnabled()).count();\n+        return mapConfigs.stream().map(MapConfig::getMapStoreConfig)\n+                .filter(MapStoreConfig::isEnabled).count();\n     }\n \n     private long countMapWithAtleastOneQueryCache() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && !(mapConfig.getQueryCacheConfigs().isEmpty())).count();\n+        return mapConfigs.stream().map(MapConfig::getQueryCacheConfigs)\n+                .filter(queryCacheConfigs -> !(queryCacheConfigs.isEmpty())).count();\n     }\n \n     private long countMapWithAtleastOneIndex() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && !(mapConfig.getIndexConfigs().isEmpty())).count();\n+        return mapConfigs.stream().map(MapConfig::getIndexConfigs)\n+                .filter(indexConfigs -> !(indexConfigs.isEmpty())).count();\n     }\n \n     private long countMapWithHotRestartEnabled() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.getHotRestartConfig().isEnabled()).count();\n+        return mapConfigs.stream().map(MapConfig::getHotRestartConfig)\n+                .filter(HotRestartConfig::isEnabled).count();\n     }\n \n     private long countMapWithWANReplication() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.getWanReplicationRef() != null).count();\n+        return mapConfigs.stream().map(MapConfig::getWanReplicationRef)\n+                .filter(Objects::nonNull).count();\n     }\n \n     private long countMapWithAtleastOneAttribute() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && !(mapConfig.getAttributeConfigs().isEmpty())).count();\n+        return mapConfigs.stream().map(MapConfig::getAttributeConfigs)\n+                .filter(attributeConfigs -> !(attributeConfigs.isEmpty())).count();\n     }\n \n     private long countMapUsingEviction() {\n-        return mapConfigs.stream().filter(mapConfig -> mapConfig != null\n-                && mapConfig.getEvictionConfig().getEvictionPolicy() != EvictionPolicy.NONE).count();\n+        return mapConfigs.stream().map(MapConfig::getEvictionConfig)\n+                .filter(evictionConfig -> evictionConfig.getEvictionPolicy() != EvictionPolicy.NONE).count();\n     }\n \n     private long countMapWithNativeInMemoryFormat() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.getInMemoryFormat() == InMemoryFormat.NATIVE).count();\n+        return mapConfigs.stream().map(MapConfig::getInMemoryFormat)\n+                .filter(inMemoryFormat -> inMemoryFormat == InMemoryFormat.NATIVE).count();\n+    }\n+\n+    private long mapPutLatencyWithoutMapStore(Node node) {\n+        Map<Long, Long> latencyInfo = new HashMap<>();\n+        mapConfigs.stream()\n+                .filter(mapConfig -> !mapConfig.getMapStoreConfig().isEnabled())\n+                .map(mapConfig -> node.hazelcastInstance.getMap(mapConfig.getName()).getLocalMapStats())\n+                .filter(mapStats -> mapStats.getPutOperationCount() != 0L)\n+                .forEach(mapStats -> latencyInfo.put(mapStats.getTotalPutLatency(), mapStats.getPutOperationCount()));\n+\n+        return MetricsCollector.weightedAverageLatency(latencyInfo);\n+    }\n+\n+    private long mapPutLatencyWithMapStore(Node node) {\n+        Map<Long, Long> latencyInfo = new HashMap<>();\n+        mapConfigs.stream()\n+                .filter(mapConfig -> mapConfig.getMapStoreConfig().isEnabled())\n+                .map(mapConfig -> node.hazelcastInstance.getMap(mapConfig.getName()).getLocalMapStats())\n+                .filter(mapStats -> mapStats.getPutOperationCount() != 0L)\n+                .forEach(mapStats -> latencyInfo.put(mapStats.getTotalPutLatency(), mapStats.getPutOperationCount()));\n+\n+        return MetricsCollector.weightedAverageLatency(latencyInfo);\n+\n+    }\n+\n+    private long mapGetLatencyWithoutMapStore(Node node) {\n+        Map<Long, Long> latencyInfo = new HashMap<>();\n+        mapConfigs.stream()\n+                .filter(mapConfig -> !mapConfig.getMapStoreConfig().isEnabled())\n+                .map(mapConfig -> node.hazelcastInstance.getMap(mapConfig.getName()).getLocalMapStats())\n+                .filter(mapStats -> mapStats.getGetOperationCount() != 0L)\n+                .forEach(mapStats -> latencyInfo.put(mapStats.getTotalGetLatency(), mapStats.getGetOperationCount()));\n+\n+        return MetricsCollector.weightedAverageLatency(latencyInfo);\n+\n+    }\n+\n+    private long mapGetLatencyWithMapStore(Node node) {\n+        Map<Long, Long> latencyInfo = new HashMap<>();\n+        mapConfigs.stream()\n+                .filter(mapConfig -> mapConfig.getMapStoreConfig().isEnabled())\n+                .map(mapConfig -> node.hazelcastInstance.getMap(mapConfig.getName()).getLocalMapStats())\n+                .filter(mapStats -> mapStats.getGetOperationCount() != 0L)\n+                .forEach(mapStats -> latencyInfo.put(mapStats.getTotalGetLatency(), mapStats.getGetOperationCount()));", "originalCommit": "90fbf09b1891710155782b7dd3fb5c418987c37f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5e8916913ba42705d64b4548c001900b5195cb6c", "url": "https://github.com/hazelcast/hazelcast/commit/5e8916913ba42705d64b4548c001900b5195cb6c", "message": "Removed redundant code and optimised methods using predicate:\n\nRemoved errors\n\nCorrected method name", "committedDate": "2020-08-04T17:26:11Z", "type": "commit"}, {"oid": "5e8916913ba42705d64b4548c001900b5195cb6c", "url": "https://github.com/hazelcast/hazelcast/commit/5e8916913ba42705d64b4548c001900b5195cb6c", "message": "Removed redundant code and optimised methods using predicate:\n\nRemoved errors\n\nCorrected method name", "committedDate": "2020-08-04T17:26:11Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTU5NzYzMQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17259#discussion_r465597631", "bodyText": "It isn't very useful to do something here based on the operationType (which is just an indication of the caller). It would be simpler to just move the get() and put() calls to the calling methods. Then you spare two conditionals and you can also remove the operationType parameter.", "author": "erosb", "createdAt": "2020-08-05T09:31:45Z", "path": "hazelcast/src/test/java/com/hazelcast/internal/util/phonehome/PhoneHomeTest.java", "diffHunk": "@@ -503,5 +506,82 @@ public void testFlakeIDGeneratorCount() {\n \n     }\n \n+    @Test\n+    public void testMapPutLatencyWithoutMapStore() {\n+        Map<String, String> parameters;\n+        parameters = phoneHome.phoneHome(true);\n+        assertEquals(parameters.get(\"mpptla\"), \"-1\");\n+\n+        IMap<Object, Object> iMap = node.hazelcastInstance.getMap(\"hazelcast\");\n+        LocalMapStatsImpl localMapStats = (LocalMapStatsImpl) iMap.getLocalMapStats();\n+\n+        localMapStats.incrementPutLatencyNanos(2000000000L);\n+        parameters = phoneHome.phoneHome(true);\n+        assertEquals(parameters.get(\"mpptla\"), String.valueOf(2000));\n+\n+        localMapStats.incrementPutLatencyNanos(1000000000L);\n+        parameters = phoneHome.phoneHome(true);\n+        assertEquals(parameters.get(\"mpptla\"), String.valueOf(1500));\n+\n+        localMapStats.incrementPutLatencyNanos(2000000000L);\n+        parameters = phoneHome.phoneHome(true);\n+        assertEquals(parameters.get(\"mpptla\"), String.valueOf(1666));\n+\n+    }\n+\n+    @Test\n+    public void testMapGetLatencyWithoutMapStore() {\n+        Map<String, String> parameters;\n+        parameters = phoneHome.phoneHome(true);\n+        assertEquals(parameters.get(\"mpgtla\"), \"-1\");\n+\n+        IMap<Object, Object> iMap = node.hazelcastInstance.getMap(\"hazelcast\");\n+        LocalMapStatsImpl localMapStats = (LocalMapStatsImpl) iMap.getLocalMapStats();\n+\n+        localMapStats.incrementGetLatencyNanos(2000000000L);\n+        parameters = phoneHome.phoneHome(true);\n+        assertEquals(parameters.get(\"mpgtla\"), String.valueOf(2000));\n+\n+        localMapStats.incrementGetLatencyNanos(2000000000L);\n+        parameters = phoneHome.phoneHome(true);\n+        assertEquals(parameters.get(\"mpgtla\"), String.valueOf(2000));\n+    }\n+\n+    void initialiseForMapStore(String operationType) {\n+\n+        Map<String, String> parameters;\n+        parameters = phoneHome.phoneHome(true);\n+        assertEquals(parameters.get(\"mpgtlams\"), \"-1\");\n+        assertEquals(parameters.get(\"mpptlams\"), \"-1\");\n+\n+        IMap<Object, Object> iMap = node.hazelcastInstance.getMap(\"hazelcast\");\n+        MapStoreConfig mapStoreConfig = new MapStoreConfig();\n+        mapStoreConfig.setEnabled(true);\n+        mapStoreConfig.setImplementation(new DelayMapStore());\n+        node.getConfig().getMapConfig(\"hazelcast\").setMapStoreConfig(mapStoreConfig);\n+        if (operationType.equals(\"put\")) {\n+            iMap.put(\"key1\", \"hazelcast\");\n+            iMap.put(\"key2\", \"phonehome\");\n+        }\n+        if (operationType.equals(\"get\")) {\n+            iMap.get(\"key1\");\n+            iMap.get(\"key2\");\n+        }", "originalCommit": "5e8916913ba42705d64b4548c001900b5195cb6c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTU5ODYxOA==", "url": "https://github.com/hazelcast/hazelcast/pull/17259#discussion_r465598618", "bodyText": "Please don't put asserts into a method that's purpose is performing initialization. The above 4 lines can be moved into a separate test.", "author": "erosb", "createdAt": "2020-08-05T09:33:32Z", "path": "hazelcast/src/test/java/com/hazelcast/internal/util/phonehome/PhoneHomeTest.java", "diffHunk": "@@ -503,5 +506,82 @@ public void testFlakeIDGeneratorCount() {\n \n     }\n \n+    @Test\n+    public void testMapPutLatencyWithoutMapStore() {\n+        Map<String, String> parameters;\n+        parameters = phoneHome.phoneHome(true);\n+        assertEquals(parameters.get(\"mpptla\"), \"-1\");\n+\n+        IMap<Object, Object> iMap = node.hazelcastInstance.getMap(\"hazelcast\");\n+        LocalMapStatsImpl localMapStats = (LocalMapStatsImpl) iMap.getLocalMapStats();\n+\n+        localMapStats.incrementPutLatencyNanos(2000000000L);\n+        parameters = phoneHome.phoneHome(true);\n+        assertEquals(parameters.get(\"mpptla\"), String.valueOf(2000));\n+\n+        localMapStats.incrementPutLatencyNanos(1000000000L);\n+        parameters = phoneHome.phoneHome(true);\n+        assertEquals(parameters.get(\"mpptla\"), String.valueOf(1500));\n+\n+        localMapStats.incrementPutLatencyNanos(2000000000L);\n+        parameters = phoneHome.phoneHome(true);\n+        assertEquals(parameters.get(\"mpptla\"), String.valueOf(1666));\n+\n+    }\n+\n+    @Test\n+    public void testMapGetLatencyWithoutMapStore() {\n+        Map<String, String> parameters;\n+        parameters = phoneHome.phoneHome(true);\n+        assertEquals(parameters.get(\"mpgtla\"), \"-1\");\n+\n+        IMap<Object, Object> iMap = node.hazelcastInstance.getMap(\"hazelcast\");\n+        LocalMapStatsImpl localMapStats = (LocalMapStatsImpl) iMap.getLocalMapStats();\n+\n+        localMapStats.incrementGetLatencyNanos(2000000000L);\n+        parameters = phoneHome.phoneHome(true);\n+        assertEquals(parameters.get(\"mpgtla\"), String.valueOf(2000));\n+\n+        localMapStats.incrementGetLatencyNanos(2000000000L);\n+        parameters = phoneHome.phoneHome(true);\n+        assertEquals(parameters.get(\"mpgtla\"), String.valueOf(2000));\n+    }\n+\n+    void initialiseForMapStore(String operationType) {\n+\n+        Map<String, String> parameters;\n+        parameters = phoneHome.phoneHome(true);\n+        assertEquals(parameters.get(\"mpgtlams\"), \"-1\");\n+        assertEquals(parameters.get(\"mpptlams\"), \"-1\");", "originalCommit": "5e8916913ba42705d64b4548c001900b5195cb6c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTU5OTA1NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17259#discussion_r465599054", "bodyText": "Please don't break the declaration and initial value assignment into separate statements.", "author": "erosb", "createdAt": "2020-08-05T09:34:13Z", "path": "hazelcast/src/test/java/com/hazelcast/internal/util/phonehome/PhoneHomeTest.java", "diffHunk": "@@ -503,5 +506,82 @@ public void testFlakeIDGeneratorCount() {\n \n     }\n \n+    @Test\n+    public void testMapPutLatencyWithoutMapStore() {\n+        Map<String, String> parameters;\n+        parameters = phoneHome.phoneHome(true);\n+        assertEquals(parameters.get(\"mpptla\"), \"-1\");\n+\n+        IMap<Object, Object> iMap = node.hazelcastInstance.getMap(\"hazelcast\");\n+        LocalMapStatsImpl localMapStats = (LocalMapStatsImpl) iMap.getLocalMapStats();\n+\n+        localMapStats.incrementPutLatencyNanos(2000000000L);\n+        parameters = phoneHome.phoneHome(true);\n+        assertEquals(parameters.get(\"mpptla\"), String.valueOf(2000));\n+\n+        localMapStats.incrementPutLatencyNanos(1000000000L);\n+        parameters = phoneHome.phoneHome(true);\n+        assertEquals(parameters.get(\"mpptla\"), String.valueOf(1500));\n+\n+        localMapStats.incrementPutLatencyNanos(2000000000L);\n+        parameters = phoneHome.phoneHome(true);\n+        assertEquals(parameters.get(\"mpptla\"), String.valueOf(1666));\n+\n+    }\n+\n+    @Test\n+    public void testMapGetLatencyWithoutMapStore() {\n+        Map<String, String> parameters;\n+        parameters = phoneHome.phoneHome(true);\n+        assertEquals(parameters.get(\"mpgtla\"), \"-1\");\n+\n+        IMap<Object, Object> iMap = node.hazelcastInstance.getMap(\"hazelcast\");\n+        LocalMapStatsImpl localMapStats = (LocalMapStatsImpl) iMap.getLocalMapStats();\n+\n+        localMapStats.incrementGetLatencyNanos(2000000000L);\n+        parameters = phoneHome.phoneHome(true);\n+        assertEquals(parameters.get(\"mpgtla\"), String.valueOf(2000));\n+\n+        localMapStats.incrementGetLatencyNanos(2000000000L);\n+        parameters = phoneHome.phoneHome(true);\n+        assertEquals(parameters.get(\"mpgtla\"), String.valueOf(2000));\n+    }\n+\n+    void initialiseForMapStore(String operationType) {\n+\n+        Map<String, String> parameters;\n+        parameters = phoneHome.phoneHome(true);", "originalCommit": "5e8916913ba42705d64b4548c001900b5195cb6c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTYwMDA5Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17259#discussion_r465600093", "bodyText": "Can you please also test that (at least in one of the unittests) that the latencies of multiple maps are accumulated correctly?", "author": "erosb", "createdAt": "2020-08-05T09:36:03Z", "path": "hazelcast/src/test/java/com/hazelcast/internal/util/phonehome/PhoneHomeTest.java", "diffHunk": "@@ -503,5 +506,82 @@ public void testFlakeIDGeneratorCount() {\n \n     }\n \n+    @Test\n+    public void testMapPutLatencyWithoutMapStore() {\n+        Map<String, String> parameters;\n+        parameters = phoneHome.phoneHome(true);\n+        assertEquals(parameters.get(\"mpptla\"), \"-1\");\n+\n+        IMap<Object, Object> iMap = node.hazelcastInstance.getMap(\"hazelcast\");\n+        LocalMapStatsImpl localMapStats = (LocalMapStatsImpl) iMap.getLocalMapStats();\n+\n+        localMapStats.incrementPutLatencyNanos(2000000000L);\n+        parameters = phoneHome.phoneHome(true);\n+        assertEquals(parameters.get(\"mpptla\"), String.valueOf(2000));\n+\n+        localMapStats.incrementPutLatencyNanos(1000000000L);\n+        parameters = phoneHome.phoneHome(true);\n+        assertEquals(parameters.get(\"mpptla\"), String.valueOf(1500));\n+\n+        localMapStats.incrementPutLatencyNanos(2000000000L);\n+        parameters = phoneHome.phoneHome(true);\n+        assertEquals(parameters.get(\"mpptla\"), String.valueOf(1666));\n+\n+    }\n+\n+    @Test\n+    public void testMapGetLatencyWithoutMapStore() {", "originalCommit": "5e8916913ba42705d64b4548c001900b5195cb6c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTYwMjEyOQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17259#discussion_r465602129", "bodyText": "Please create a separate class which implements ValueExtractor, instead of making PhoneHomeIntegrationTest implement it. It is very unconventional to use the test class itself as a test double.", "author": "erosb", "createdAt": "2020-08-05T09:39:37Z", "path": "hazelcast/src/test/java/com/hazelcast/internal/util/phonehome/PhoneHomeIntegrationTest.java", "diffHunk": "@@ -56,7 +60,7 @@\n import static com.hazelcast.cache.CacheTestSupport.createServerCachingProvider;\n import static com.hazelcast.test.Accessors.getNode;\n \n-public class PhoneHomeIntegrationTest extends HazelcastTestSupport {\n+public class PhoneHomeIntegrationTest extends HazelcastTestSupport implements ValueExtractor {", "originalCommit": "5e8916913ba42705d64b4548c001900b5195cb6c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTYxNDgzMw==", "url": "https://github.com/hazelcast/hazelcast/pull/17259#discussion_r465614833", "bodyText": "This two-element array is duplicated between the two methods. Can you extract this logic into a separate class?", "author": "erosb", "createdAt": "2020-08-05T10:02:25Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/util/phonehome/MapInfoCollector.java", "diffHunk": "@@ -55,52 +60,97 @@\n         mapInfo.put(\"mpaocct\", String.valueOf(countMapWithAtleastOneAttribute()));\n         mapInfo.put(\"mpevct\", String.valueOf(countMapUsingEviction()));\n         mapInfo.put(\"mpnmct\", String.valueOf(countMapWithNativeInMemoryFormat()));\n+        mapInfo.put(\"mpptlams\", String.valueOf(mapPutLatency(hazelcastNode, isMapStoreEnabled())));\n+        mapInfo.put(\"mpptla\", String.valueOf(mapPutLatency(hazelcastNode, isMapStoreDisabled())));\n+        mapInfo.put(\"mpgtlams\", String.valueOf(mapGetLatency(hazelcastNode, isMapStoreEnabled())));\n+        mapInfo.put(\"mpgtla\", String.valueOf(mapGetLatency(hazelcastNode, isMapStoreDisabled())));\n \n         return mapInfo;\n     }\n \n     private long countMapWithBackupReadEnabled() {\n         return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.isReadBackupData()).count();\n+                .filter(MapConfig::isReadBackupData).count();\n     }\n \n     private long countMapWithMapStoreEnabled() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.getMapStoreConfig().isEnabled()).count();\n+        return mapConfigs.stream().map(MapConfig::getMapStoreConfig)\n+                .filter(MapStoreConfig::isEnabled).count();\n     }\n \n     private long countMapWithAtleastOneQueryCache() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && !(mapConfig.getQueryCacheConfigs().isEmpty())).count();\n+        return mapConfigs.stream().map(MapConfig::getQueryCacheConfigs)\n+                .filter(queryCacheConfigs -> !(queryCacheConfigs.isEmpty())).count();\n     }\n \n     private long countMapWithAtleastOneIndex() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && !(mapConfig.getIndexConfigs().isEmpty())).count();\n+        return mapConfigs.stream().map(MapConfig::getIndexConfigs)\n+                .filter(indexConfigs -> !(indexConfigs.isEmpty())).count();\n     }\n \n     private long countMapWithHotRestartEnabled() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.getHotRestartConfig().isEnabled()).count();\n+        return mapConfigs.stream().map(MapConfig::getHotRestartConfig)\n+                .filter(HotRestartConfig::isEnabled).count();\n     }\n \n     private long countMapWithWANReplication() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.getWanReplicationRef() != null).count();\n+        return mapConfigs.stream().map(MapConfig::getWanReplicationRef)\n+                .filter(Objects::nonNull).count();\n     }\n \n     private long countMapWithAtleastOneAttribute() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && !(mapConfig.getAttributeConfigs().isEmpty())).count();\n+        return mapConfigs.stream().map(MapConfig::getAttributeConfigs)\n+                .filter(attributeConfigs -> !(attributeConfigs.isEmpty())).count();\n     }\n \n     private long countMapUsingEviction() {\n-        return mapConfigs.stream().filter(mapConfig -> mapConfig != null\n-                && mapConfig.getEvictionConfig().getEvictionPolicy() != EvictionPolicy.NONE).count();\n+        return mapConfigs.stream().map(MapConfig::getEvictionConfig)\n+                .filter(evictionConfig -> evictionConfig.getEvictionPolicy() != EvictionPolicy.NONE).count();\n     }\n \n     private long countMapWithNativeInMemoryFormat() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.getInMemoryFormat() == InMemoryFormat.NATIVE).count();\n+        return mapConfigs.stream().map(MapConfig::getInMemoryFormat)\n+                .filter(inMemoryFormat -> inMemoryFormat == InMemoryFormat.NATIVE).count();\n+    }\n+\n+    static Predicate<MapConfig> isMapStoreEnabled() {\n+        return p -> p.getMapStoreConfig().isEnabled();\n+    }\n+\n+    static Predicate<MapConfig> isMapStoreDisabled() {\n+        return p -> !p.getMapStoreConfig().isEnabled();\n+    }\n+\n+    private long mapPutLatency(Node node, Predicate<MapConfig> predicate) {\n+        final long[] latencyInfo = {0, 0};\n+        mapConfigs.stream()\n+                .filter(predicate)\n+                .map(mapConfig -> node.hazelcastInstance.getMap(mapConfig.getName()).getLocalMapStats())\n+                .filter(mapStats -> mapStats.getPutOperationCount() != 0L)\n+                .forEach(mapStats -> {\n+                    latencyInfo[0] += mapStats.getTotalPutLatency();\n+                    latencyInfo[1] += mapStats.getPutOperationCount();\n+                });\n+        if (latencyInfo[1] == 0) {\n+            return -1;\n+        }\n+\n+        return latencyInfo[0] / latencyInfo[1];\n+    }\n+\n+    private long mapGetLatency(Node node, Predicate<MapConfig> predicate) {\n+        final long[] latencyInfo = {0, 0};\n+        mapConfigs.stream()\n+                .filter(predicate)\n+                .map(mapConfig -> node.hazelcastInstance.getMap(mapConfig.getName()).getLocalMapStats())\n+                .filter(mapStats -> mapStats.getGetOperationCount() != 0L)\n+                .forEach(mapStats -> {\n+                    latencyInfo[0] += mapStats.getTotalGetLatency();\n+                    latencyInfo[1] += mapStats.getGetOperationCount();\n+                });\n+        if (latencyInfo[1] == 0) {\n+            return -1;\n+        }\n+        return latencyInfo[0] / latencyInfo[1];", "originalCommit": "5e8916913ba42705d64b4548c001900b5195cb6c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9ec78ff543a3db45c07f5f2a776b3128dba84004", "url": "https://github.com/hazelcast/hazelcast/commit/9ec78ff543a3db45c07f5f2a776b3128dba84004", "message": "Optimised methods and tests", "committedDate": "2020-08-05T12:13:33Z", "type": "commit"}, {"oid": "6fd6eb577cc9abad5c83fd99d279d3a896cb0b36", "url": "https://github.com/hazelcast/hazelcast/commit/6fd6eb577cc9abad5c83fd99d279d3a896cb0b36", "message": "Another implementation for average put and get latency", "committedDate": "2020-08-05T14:14:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgxNjE4Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/17259#discussion_r465816187", "bodyText": "Please give a better name for this class. This is not a test itself. It is a test double used by a test.", "author": "erosb", "createdAt": "2020-08-05T15:34:27Z", "path": "hazelcast/src/test/java/com/hazelcast/internal/util/phonehome/AttributeTest.java", "diffHunk": "@@ -0,0 +1,27 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.hazelcast.internal.util.phonehome;\n+\n+import com.hazelcast.query.extractor.ValueCollector;\n+import com.hazelcast.query.extractor.ValueExtractor;\n+\n+public class AttributeTest implements ValueExtractor {", "originalCommit": "6fd6eb577cc9abad5c83fd99d279d3a896cb0b36", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgyMDcyOA==", "url": "https://github.com/hazelcast/hazelcast/pull/17259#discussion_r465820728", "bodyText": "You can create the map in the initialiseForMapStore() method and return the map. That would reduce the 2-line initalisations to 1 line (in all above tests).", "author": "erosb", "createdAt": "2020-08-05T15:41:01Z", "path": "hazelcast/src/test/java/com/hazelcast/internal/util/phonehome/PhoneHomeTest.java", "diffHunk": "@@ -503,5 +506,93 @@ public void testFlakeIDGeneratorCount() {\n \n     }\n \n+    @Test\n+    public void testMapPutLatencyWithoutMapStore() {\n+        Map<String, String> parameters;\n+        parameters = phoneHome.phoneHome(true);\n+        assertEquals(parameters.get(\"mpptla\"), \"-1\");\n+\n+        IMap<Object, Object> iMap = node.hazelcastInstance.getMap(\"hazelcast\");\n+        LocalMapStatsImpl localMapStats = (LocalMapStatsImpl) iMap.getLocalMapStats();\n+\n+        localMapStats.incrementPutLatencyNanos(2000000000L);\n+        parameters = phoneHome.phoneHome(true);\n+        assertEquals(parameters.get(\"mpptla\"), String.valueOf(2000));\n+\n+        localMapStats.incrementPutLatencyNanos(1000000000L);\n+        parameters = phoneHome.phoneHome(true);\n+        assertEquals(parameters.get(\"mpptla\"), String.valueOf(1500));\n+\n+        localMapStats.incrementPutLatencyNanos(2000000000L);\n+        parameters = phoneHome.phoneHome(true);\n+        assertEquals(parameters.get(\"mpptla\"), String.valueOf(1666));\n+\n+    }\n+\n+    @Test\n+    public void testMapGetLatencyWithoutMapStore() {\n+        Map<String, String> parameters;\n+        parameters = phoneHome.phoneHome(true);\n+        assertEquals(parameters.get(\"mpgtla\"), \"-1\");\n+\n+        IMap<Object, Object> iMap = node.hazelcastInstance.getMap(\"hazelcast\");\n+        LocalMapStatsImpl localMapStats = (LocalMapStatsImpl) iMap.getLocalMapStats();\n+\n+        localMapStats.incrementGetLatencyNanos(2000000000L);\n+        parameters = phoneHome.phoneHome(true);\n+        assertEquals(parameters.get(\"mpgtla\"), String.valueOf(2000));\n+\n+        localMapStats.incrementGetLatencyNanos(2000000000L);\n+        parameters = phoneHome.phoneHome(true);\n+        assertEquals(parameters.get(\"mpgtla\"), String.valueOf(2000));\n+    }\n+\n+    void initialiseForMapStore(String mapName) {\n+        MapStoreConfig mapStoreConfig = new MapStoreConfig();\n+        mapStoreConfig.setEnabled(true);\n+        mapStoreConfig.setImplementation(new DelayMapStore());\n+        node.getConfig().getMapConfig(mapName).setMapStoreConfig(mapStoreConfig);\n+    }\n+\n+    @Test\n+    public void testMapPutLatencyWithMapStore() {\n+        Map<String, String> parameters;\n+        parameters = phoneHome.phoneHome(true);\n+        assertEquals(parameters.get(\"mpptlams\"), \"-1\");\n+\n+        IMap<Object, Object> iMap1 = node.hazelcastInstance.getMap(\"hazelcast\");\n+        initialiseForMapStore(iMap1.getName());\n+        iMap1.put(\"key1\", \"hazelcast\");\n+        iMap1.put(\"key2\", \"phonehome\");\n+        parameters = phoneHome.phoneHome(true);\n+        assertGreaterOrEquals(\"mpptlams\", Long.parseLong(parameters.get(\"mpptlams\")), 200);\n+\n+        IMap<Object, Object> iMap2 = node.hazelcastInstance.getMap(\"phonehome\");\n+        initialiseForMapStore(iMap2.getName());\n+        iMap2.put(\"key3\", \"hazelcast\");\n+        parameters = phoneHome.phoneHome(true);\n+        assertGreaterOrEquals(\"mpptlams\", Long.parseLong(parameters.get(\"mpptlams\")), 200);\n+    }\n+\n+\n+    @Test\n+    public void testMapGetLatencyWithMapStore() {\n+        Map<String, String> parameters;\n+        parameters = phoneHome.phoneHome(true);\n+        assertEquals(parameters.get(\"mpgtlams\"), \"-1\");\n+\n+        IMap<Object, Object> iMap1 = node.hazelcastInstance.getMap(\"hazelcast\");", "originalCommit": "6fd6eb577cc9abad5c83fd99d279d3a896cb0b36", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgyMTEzNA==", "url": "https://github.com/hazelcast/hazelcast/pull/17259#discussion_r465821134", "bodyText": "nit: please make it private", "author": "erosb", "createdAt": "2020-08-05T15:41:30Z", "path": "hazelcast/src/test/java/com/hazelcast/internal/util/phonehome/PhoneHomeTest.java", "diffHunk": "@@ -503,5 +506,93 @@ public void testFlakeIDGeneratorCount() {\n \n     }\n \n+    @Test\n+    public void testMapPutLatencyWithoutMapStore() {\n+        Map<String, String> parameters;\n+        parameters = phoneHome.phoneHome(true);\n+        assertEquals(parameters.get(\"mpptla\"), \"-1\");\n+\n+        IMap<Object, Object> iMap = node.hazelcastInstance.getMap(\"hazelcast\");\n+        LocalMapStatsImpl localMapStats = (LocalMapStatsImpl) iMap.getLocalMapStats();\n+\n+        localMapStats.incrementPutLatencyNanos(2000000000L);\n+        parameters = phoneHome.phoneHome(true);\n+        assertEquals(parameters.get(\"mpptla\"), String.valueOf(2000));\n+\n+        localMapStats.incrementPutLatencyNanos(1000000000L);\n+        parameters = phoneHome.phoneHome(true);\n+        assertEquals(parameters.get(\"mpptla\"), String.valueOf(1500));\n+\n+        localMapStats.incrementPutLatencyNanos(2000000000L);\n+        parameters = phoneHome.phoneHome(true);\n+        assertEquals(parameters.get(\"mpptla\"), String.valueOf(1666));\n+\n+    }\n+\n+    @Test\n+    public void testMapGetLatencyWithoutMapStore() {\n+        Map<String, String> parameters;\n+        parameters = phoneHome.phoneHome(true);\n+        assertEquals(parameters.get(\"mpgtla\"), \"-1\");\n+\n+        IMap<Object, Object> iMap = node.hazelcastInstance.getMap(\"hazelcast\");\n+        LocalMapStatsImpl localMapStats = (LocalMapStatsImpl) iMap.getLocalMapStats();\n+\n+        localMapStats.incrementGetLatencyNanos(2000000000L);\n+        parameters = phoneHome.phoneHome(true);\n+        assertEquals(parameters.get(\"mpgtla\"), String.valueOf(2000));\n+\n+        localMapStats.incrementGetLatencyNanos(2000000000L);\n+        parameters = phoneHome.phoneHome(true);\n+        assertEquals(parameters.get(\"mpgtla\"), String.valueOf(2000));\n+    }\n+\n+    void initialiseForMapStore(String mapName) {", "originalCommit": "6fd6eb577cc9abad5c83fd99d279d3a896cb0b36", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgyMzc2Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17259#discussion_r465823763", "bodyText": "I suspect the stream will never produce a null result, so there is no need to wrap it into an Optional. Please remove it.", "author": "erosb", "createdAt": "2020-08-05T15:45:24Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/util/phonehome/MapInfoCollector.java", "diffHunk": "@@ -55,52 +61,106 @@\n         mapInfo.put(\"mpaocct\", String.valueOf(countMapWithAtleastOneAttribute()));\n         mapInfo.put(\"mpevct\", String.valueOf(countMapUsingEviction()));\n         mapInfo.put(\"mpnmct\", String.valueOf(countMapWithNativeInMemoryFormat()));\n+        mapInfo.put(\"mpptlams\", String.valueOf(mapPutLatency(hazelcastNode, isMapStoreEnabled())));\n+        mapInfo.put(\"mpptla\", String.valueOf(mapPutLatency(hazelcastNode, isMapStoreDisabled())));\n+        mapInfo.put(\"mpgtlams\", String.valueOf(mapGetLatency(hazelcastNode, isMapStoreEnabled())));\n+        mapInfo.put(\"mpgtla\", String.valueOf(mapGetLatency(hazelcastNode, isMapStoreDisabled())));\n \n         return mapInfo;\n     }\n \n     private long countMapWithBackupReadEnabled() {\n         return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.isReadBackupData()).count();\n+                .filter(MapConfig::isReadBackupData).count();\n     }\n \n     private long countMapWithMapStoreEnabled() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.getMapStoreConfig().isEnabled()).count();\n+        return mapConfigs.stream().map(MapConfig::getMapStoreConfig)\n+                .filter(MapStoreConfig::isEnabled).count();\n     }\n \n     private long countMapWithAtleastOneQueryCache() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && !(mapConfig.getQueryCacheConfigs().isEmpty())).count();\n+        return mapConfigs.stream().map(MapConfig::getQueryCacheConfigs)\n+                .filter(queryCacheConfigs -> !(queryCacheConfigs.isEmpty())).count();\n     }\n \n     private long countMapWithAtleastOneIndex() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && !(mapConfig.getIndexConfigs().isEmpty())).count();\n+        return mapConfigs.stream().map(MapConfig::getIndexConfigs)\n+                .filter(indexConfigs -> !(indexConfigs.isEmpty())).count();\n     }\n \n     private long countMapWithHotRestartEnabled() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.getHotRestartConfig().isEnabled()).count();\n+        return mapConfigs.stream().map(MapConfig::getHotRestartConfig)\n+                .filter(HotRestartConfig::isEnabled).count();\n     }\n \n     private long countMapWithWANReplication() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.getWanReplicationRef() != null).count();\n+        return mapConfigs.stream().map(MapConfig::getWanReplicationRef)\n+                .filter(Objects::nonNull).count();\n     }\n \n     private long countMapWithAtleastOneAttribute() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && !(mapConfig.getAttributeConfigs().isEmpty())).count();\n+        return mapConfigs.stream().map(MapConfig::getAttributeConfigs)\n+                .filter(attributeConfigs -> !(attributeConfigs.isEmpty())).count();\n     }\n \n     private long countMapUsingEviction() {\n-        return mapConfigs.stream().filter(mapConfig -> mapConfig != null\n-                && mapConfig.getEvictionConfig().getEvictionPolicy() != EvictionPolicy.NONE).count();\n+        return mapConfigs.stream().map(MapConfig::getEvictionConfig)\n+                .filter(evictionConfig -> evictionConfig.getEvictionPolicy() != EvictionPolicy.NONE).count();\n     }\n \n     private long countMapWithNativeInMemoryFormat() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.getInMemoryFormat() == InMemoryFormat.NATIVE).count();\n+        return mapConfigs.stream().map(MapConfig::getInMemoryFormat)\n+                .filter(inMemoryFormat -> inMemoryFormat == InMemoryFormat.NATIVE).count();\n+    }\n+\n+    static Predicate<MapConfig> isMapStoreEnabled() {\n+        return p -> p.getMapStoreConfig().isEnabled();\n+    }\n+\n+    static Predicate<MapConfig> isMapStoreDisabled() {\n+        return p -> !p.getMapStoreConfig().isEnabled();\n+    }\n+\n+    static class LatencyInfo {\n+        private static final LatencyInfo ZERO = new LatencyInfo(0, 0);\n+        private final long totalLatency;\n+        private final long totalOperation;\n+\n+        LatencyInfo(long totalLatency, long totalOperation) {\n+            this.totalLatency = totalLatency;\n+            this.totalOperation = totalOperation;\n+        }\n+\n+        LatencyInfo sum(LatencyInfo latencyInfo) {\n+            return new LatencyInfo(this.totalLatency + latencyInfo.totalLatency, this.totalOperation + latencyInfo.totalOperation);\n+        }\n+    }\n+\n+\n+    private long mapPutLatency(Node node, Predicate<MapConfig> predicate) {\n+\n+        LatencyInfo latencyInfo = Optional.ofNullable(mapConfigs.stream()", "originalCommit": "6fd6eb577cc9abad5c83fd99d279d3a896cb0b36", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgyNzcwNA==", "url": "https://github.com/hazelcast/hazelcast/pull/17259#discussion_r465827704", "bodyText": "This is actually very nicely done. I'm worried about the performance though. This will create a new LatencyInfo object for every maps (with mapstore) , and that just generates a little bit too much garbage for the GC. In some rare cases the user can have 100k+ maps (which doesn't make much sense but in some crazy edge cases it happens). So it would be better to accumulate the values into a single (mutable) LatencyInfo object (which isn't a big change actually).\nThumbs up for applying the null object pattern and immutability. It would be very nice OO design under regular circumstances.", "author": "erosb", "createdAt": "2020-08-05T15:51:11Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/util/phonehome/MapInfoCollector.java", "diffHunk": "@@ -55,52 +61,106 @@\n         mapInfo.put(\"mpaocct\", String.valueOf(countMapWithAtleastOneAttribute()));\n         mapInfo.put(\"mpevct\", String.valueOf(countMapUsingEviction()));\n         mapInfo.put(\"mpnmct\", String.valueOf(countMapWithNativeInMemoryFormat()));\n+        mapInfo.put(\"mpptlams\", String.valueOf(mapPutLatency(hazelcastNode, isMapStoreEnabled())));\n+        mapInfo.put(\"mpptla\", String.valueOf(mapPutLatency(hazelcastNode, isMapStoreDisabled())));\n+        mapInfo.put(\"mpgtlams\", String.valueOf(mapGetLatency(hazelcastNode, isMapStoreEnabled())));\n+        mapInfo.put(\"mpgtla\", String.valueOf(mapGetLatency(hazelcastNode, isMapStoreDisabled())));\n \n         return mapInfo;\n     }\n \n     private long countMapWithBackupReadEnabled() {\n         return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.isReadBackupData()).count();\n+                .filter(MapConfig::isReadBackupData).count();\n     }\n \n     private long countMapWithMapStoreEnabled() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.getMapStoreConfig().isEnabled()).count();\n+        return mapConfigs.stream().map(MapConfig::getMapStoreConfig)\n+                .filter(MapStoreConfig::isEnabled).count();\n     }\n \n     private long countMapWithAtleastOneQueryCache() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && !(mapConfig.getQueryCacheConfigs().isEmpty())).count();\n+        return mapConfigs.stream().map(MapConfig::getQueryCacheConfigs)\n+                .filter(queryCacheConfigs -> !(queryCacheConfigs.isEmpty())).count();\n     }\n \n     private long countMapWithAtleastOneIndex() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && !(mapConfig.getIndexConfigs().isEmpty())).count();\n+        return mapConfigs.stream().map(MapConfig::getIndexConfigs)\n+                .filter(indexConfigs -> !(indexConfigs.isEmpty())).count();\n     }\n \n     private long countMapWithHotRestartEnabled() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.getHotRestartConfig().isEnabled()).count();\n+        return mapConfigs.stream().map(MapConfig::getHotRestartConfig)\n+                .filter(HotRestartConfig::isEnabled).count();\n     }\n \n     private long countMapWithWANReplication() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.getWanReplicationRef() != null).count();\n+        return mapConfigs.stream().map(MapConfig::getWanReplicationRef)\n+                .filter(Objects::nonNull).count();\n     }\n \n     private long countMapWithAtleastOneAttribute() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && !(mapConfig.getAttributeConfigs().isEmpty())).count();\n+        return mapConfigs.stream().map(MapConfig::getAttributeConfigs)\n+                .filter(attributeConfigs -> !(attributeConfigs.isEmpty())).count();\n     }\n \n     private long countMapUsingEviction() {\n-        return mapConfigs.stream().filter(mapConfig -> mapConfig != null\n-                && mapConfig.getEvictionConfig().getEvictionPolicy() != EvictionPolicy.NONE).count();\n+        return mapConfigs.stream().map(MapConfig::getEvictionConfig)\n+                .filter(evictionConfig -> evictionConfig.getEvictionPolicy() != EvictionPolicy.NONE).count();\n     }\n \n     private long countMapWithNativeInMemoryFormat() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.getInMemoryFormat() == InMemoryFormat.NATIVE).count();\n+        return mapConfigs.stream().map(MapConfig::getInMemoryFormat)\n+                .filter(inMemoryFormat -> inMemoryFormat == InMemoryFormat.NATIVE).count();\n+    }\n+\n+    static Predicate<MapConfig> isMapStoreEnabled() {\n+        return p -> p.getMapStoreConfig().isEnabled();\n+    }\n+\n+    static Predicate<MapConfig> isMapStoreDisabled() {\n+        return p -> !p.getMapStoreConfig().isEnabled();\n+    }\n+\n+    static class LatencyInfo {\n+        private static final LatencyInfo ZERO = new LatencyInfo(0, 0);\n+        private final long totalLatency;\n+        private final long totalOperation;\n+\n+        LatencyInfo(long totalLatency, long totalOperation) {\n+            this.totalLatency = totalLatency;\n+            this.totalOperation = totalOperation;\n+        }\n+\n+        LatencyInfo sum(LatencyInfo latencyInfo) {\n+            return new LatencyInfo(this.totalLatency + latencyInfo.totalLatency, this.totalOperation + latencyInfo.totalOperation);\n+        }\n+    }\n+\n+\n+    private long mapPutLatency(Node node, Predicate<MapConfig> predicate) {\n+\n+        LatencyInfo latencyInfo = Optional.ofNullable(mapConfigs.stream()\n+                .filter(predicate)\n+                .map(mapConfig -> node.hazelcastInstance.getMap(mapConfig.getName()).getLocalMapStats())\n+                .filter(mapStats -> mapStats.getPutOperationCount() != 0L)\n+                .map(mapStats -> new LatencyInfo(mapStats.getTotalPutLatency(), mapStats.getPutOperationCount()))\n+                .reduce(LatencyInfo.ZERO, LatencyInfo::sum)).orElse(LatencyInfo.ZERO);", "originalCommit": "6fd6eb577cc9abad5c83fd99d279d3a896cb0b36", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgzMTM5Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17259#discussion_r465831392", "bodyText": "There are two problems with this calculation:\n\nit is duplicated in the two latency methods\nit performs the computation on the fields of an other object (that is a code smell, AFAIR it is discussed in detail in the Refactoring book written by Fowler)\n\nSo please move it into a new method of the LatencyInfo class, that solves both problems", "author": "erosb", "createdAt": "2020-08-05T15:56:37Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/util/phonehome/MapInfoCollector.java", "diffHunk": "@@ -55,52 +61,106 @@\n         mapInfo.put(\"mpaocct\", String.valueOf(countMapWithAtleastOneAttribute()));\n         mapInfo.put(\"mpevct\", String.valueOf(countMapUsingEviction()));\n         mapInfo.put(\"mpnmct\", String.valueOf(countMapWithNativeInMemoryFormat()));\n+        mapInfo.put(\"mpptlams\", String.valueOf(mapPutLatency(hazelcastNode, isMapStoreEnabled())));\n+        mapInfo.put(\"mpptla\", String.valueOf(mapPutLatency(hazelcastNode, isMapStoreDisabled())));\n+        mapInfo.put(\"mpgtlams\", String.valueOf(mapGetLatency(hazelcastNode, isMapStoreEnabled())));\n+        mapInfo.put(\"mpgtla\", String.valueOf(mapGetLatency(hazelcastNode, isMapStoreDisabled())));\n \n         return mapInfo;\n     }\n \n     private long countMapWithBackupReadEnabled() {\n         return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.isReadBackupData()).count();\n+                .filter(MapConfig::isReadBackupData).count();\n     }\n \n     private long countMapWithMapStoreEnabled() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.getMapStoreConfig().isEnabled()).count();\n+        return mapConfigs.stream().map(MapConfig::getMapStoreConfig)\n+                .filter(MapStoreConfig::isEnabled).count();\n     }\n \n     private long countMapWithAtleastOneQueryCache() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && !(mapConfig.getQueryCacheConfigs().isEmpty())).count();\n+        return mapConfigs.stream().map(MapConfig::getQueryCacheConfigs)\n+                .filter(queryCacheConfigs -> !(queryCacheConfigs.isEmpty())).count();\n     }\n \n     private long countMapWithAtleastOneIndex() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && !(mapConfig.getIndexConfigs().isEmpty())).count();\n+        return mapConfigs.stream().map(MapConfig::getIndexConfigs)\n+                .filter(indexConfigs -> !(indexConfigs.isEmpty())).count();\n     }\n \n     private long countMapWithHotRestartEnabled() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.getHotRestartConfig().isEnabled()).count();\n+        return mapConfigs.stream().map(MapConfig::getHotRestartConfig)\n+                .filter(HotRestartConfig::isEnabled).count();\n     }\n \n     private long countMapWithWANReplication() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.getWanReplicationRef() != null).count();\n+        return mapConfigs.stream().map(MapConfig::getWanReplicationRef)\n+                .filter(Objects::nonNull).count();\n     }\n \n     private long countMapWithAtleastOneAttribute() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && !(mapConfig.getAttributeConfigs().isEmpty())).count();\n+        return mapConfigs.stream().map(MapConfig::getAttributeConfigs)\n+                .filter(attributeConfigs -> !(attributeConfigs.isEmpty())).count();\n     }\n \n     private long countMapUsingEviction() {\n-        return mapConfigs.stream().filter(mapConfig -> mapConfig != null\n-                && mapConfig.getEvictionConfig().getEvictionPolicy() != EvictionPolicy.NONE).count();\n+        return mapConfigs.stream().map(MapConfig::getEvictionConfig)\n+                .filter(evictionConfig -> evictionConfig.getEvictionPolicy() != EvictionPolicy.NONE).count();\n     }\n \n     private long countMapWithNativeInMemoryFormat() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.getInMemoryFormat() == InMemoryFormat.NATIVE).count();\n+        return mapConfigs.stream().map(MapConfig::getInMemoryFormat)\n+                .filter(inMemoryFormat -> inMemoryFormat == InMemoryFormat.NATIVE).count();\n+    }\n+\n+    static Predicate<MapConfig> isMapStoreEnabled() {\n+        return p -> p.getMapStoreConfig().isEnabled();\n+    }\n+\n+    static Predicate<MapConfig> isMapStoreDisabled() {\n+        return p -> !p.getMapStoreConfig().isEnabled();\n+    }\n+\n+    static class LatencyInfo {\n+        private static final LatencyInfo ZERO = new LatencyInfo(0, 0);\n+        private final long totalLatency;\n+        private final long totalOperation;\n+\n+        LatencyInfo(long totalLatency, long totalOperation) {\n+            this.totalLatency = totalLatency;\n+            this.totalOperation = totalOperation;\n+        }\n+\n+        LatencyInfo sum(LatencyInfo latencyInfo) {\n+            return new LatencyInfo(this.totalLatency + latencyInfo.totalLatency, this.totalOperation + latencyInfo.totalOperation);\n+        }\n+    }\n+\n+\n+    private long mapPutLatency(Node node, Predicate<MapConfig> predicate) {\n+\n+        LatencyInfo latencyInfo = Optional.ofNullable(mapConfigs.stream()\n+                .filter(predicate)\n+                .map(mapConfig -> node.hazelcastInstance.getMap(mapConfig.getName()).getLocalMapStats())\n+                .filter(mapStats -> mapStats.getPutOperationCount() != 0L)\n+                .map(mapStats -> new LatencyInfo(mapStats.getTotalPutLatency(), mapStats.getPutOperationCount()))\n+                .reduce(LatencyInfo.ZERO, LatencyInfo::sum)).orElse(LatencyInfo.ZERO);\n+\n+        return latencyInfo.totalOperation == 0 ? -1 : (latencyInfo.totalLatency / latencyInfo.totalOperation);", "originalCommit": "6fd6eb577cc9abad5c83fd99d279d3a896cb0b36", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c952f04257ed91e95b705c4eb4ef600c1db6abc0", "url": "https://github.com/hazelcast/hazelcast/commit/c952f04257ed91e95b705c4eb4ef600c1db6abc0", "message": "Improvised the functions and optimised the code\n\nImprovised", "committedDate": "2020-08-05T22:14:04Z", "type": "commit"}, {"oid": "c952f04257ed91e95b705c4eb4ef600c1db6abc0", "url": "https://github.com/hazelcast/hazelcast/commit/c952f04257ed91e95b705c4eb4ef600c1db6abc0", "message": "Improvised the functions and optimised the code\n\nImprovised", "committedDate": "2020-08-05T22:14:04Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjIxNTE4Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17259#discussion_r466215183", "bodyText": "It would be much better if calculateAverage() wouldn't access the state of an other LatencyInfo object. Can we please write it simply as return latencyInfo.calculateAverage() and update the method accordingly?", "author": "erosb", "createdAt": "2020-08-06T07:54:33Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/util/phonehome/MapInfoCollector.java", "diffHunk": "@@ -55,52 +61,115 @@\n         mapInfo.put(\"mpaocct\", String.valueOf(countMapWithAtleastOneAttribute()));\n         mapInfo.put(\"mpevct\", String.valueOf(countMapUsingEviction()));\n         mapInfo.put(\"mpnmct\", String.valueOf(countMapWithNativeInMemoryFormat()));\n+        mapInfo.put(\"mpptlams\", String.valueOf(mapPutLatency(hazelcastNode, isMapStoreEnabled())));\n+        mapInfo.put(\"mpptla\", String.valueOf(mapPutLatency(hazelcastNode, isMapStoreDisabled())));\n+        mapInfo.put(\"mpgtlams\", String.valueOf(mapGetLatency(hazelcastNode, isMapStoreEnabled())));\n+        mapInfo.put(\"mpgtla\", String.valueOf(mapGetLatency(hazelcastNode, isMapStoreDisabled())));\n \n         return mapInfo;\n     }\n \n     private long countMapWithBackupReadEnabled() {\n         return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.isReadBackupData()).count();\n+                .filter(MapConfig::isReadBackupData).count();\n     }\n \n     private long countMapWithMapStoreEnabled() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.getMapStoreConfig().isEnabled()).count();\n+        return mapConfigs.stream().map(MapConfig::getMapStoreConfig)\n+                .filter(MapStoreConfig::isEnabled).count();\n     }\n \n     private long countMapWithAtleastOneQueryCache() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && !(mapConfig.getQueryCacheConfigs().isEmpty())).count();\n+        return mapConfigs.stream().map(MapConfig::getQueryCacheConfigs)\n+                .filter(queryCacheConfigs -> !(queryCacheConfigs.isEmpty())).count();\n     }\n \n     private long countMapWithAtleastOneIndex() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && !(mapConfig.getIndexConfigs().isEmpty())).count();\n+        return mapConfigs.stream().map(MapConfig::getIndexConfigs)\n+                .filter(indexConfigs -> !(indexConfigs.isEmpty())).count();\n     }\n \n     private long countMapWithHotRestartEnabled() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.getHotRestartConfig().isEnabled()).count();\n+        return mapConfigs.stream().map(MapConfig::getHotRestartConfig)\n+                .filter(HotRestartConfig::isEnabled).count();\n     }\n \n     private long countMapWithWANReplication() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.getWanReplicationRef() != null).count();\n+        return mapConfigs.stream().map(MapConfig::getWanReplicationRef)\n+                .filter(Objects::nonNull).count();\n     }\n \n     private long countMapWithAtleastOneAttribute() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && !(mapConfig.getAttributeConfigs().isEmpty())).count();\n+        return mapConfigs.stream().map(MapConfig::getAttributeConfigs)\n+                .filter(attributeConfigs -> !(attributeConfigs.isEmpty())).count();\n     }\n \n     private long countMapUsingEviction() {\n-        return mapConfigs.stream().filter(mapConfig -> mapConfig != null\n-                && mapConfig.getEvictionConfig().getEvictionPolicy() != EvictionPolicy.NONE).count();\n+        return mapConfigs.stream().map(MapConfig::getEvictionConfig)\n+                .filter(evictionConfig -> evictionConfig.getEvictionPolicy() != EvictionPolicy.NONE).count();\n     }\n \n     private long countMapWithNativeInMemoryFormat() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.getInMemoryFormat() == InMemoryFormat.NATIVE).count();\n+        return mapConfigs.stream().map(MapConfig::getInMemoryFormat)\n+                .filter(inMemoryFormat -> inMemoryFormat == InMemoryFormat.NATIVE).count();\n+    }\n+\n+    static Predicate<MapConfig> isMapStoreEnabled() {\n+        return p -> p.getMapStoreConfig().isEnabled();\n+    }\n+\n+    static Predicate<MapConfig> isMapStoreDisabled() {\n+        return p -> !p.getMapStoreConfig().isEnabled();\n+    }\n+\n+    static class LatencyInfo {\n+        private long totalLatency;\n+        private long totalOperation;\n+\n+        LatencyInfo(long totalLatency, long totalOperation) {\n+            this.totalLatency = totalLatency;\n+            this.totalOperation = totalOperation;\n+        }\n+\n+        LatencyInfo setLatency(long totalLatency, long totalOperation) {\n+            this.totalLatency = totalLatency;\n+            this.totalOperation = totalOperation;\n+            return this;\n+        }\n+\n+        LatencyInfo sum(LatencyInfo latencyInfo) {\n+            return setLatency(this.totalLatency + latencyInfo.totalLatency,\n+                    this.totalOperation + latencyInfo.totalOperation);\n+        }\n+\n+        Long calculateAverage(LatencyInfo latencyInfo) {\n+            return latencyInfo.totalOperation == 0 ? -1 : (latencyInfo.totalLatency / latencyInfo.totalOperation);\n+        }\n+    }\n+\n+\n+    private long mapPutLatency(Node node, Predicate<MapConfig> predicate) {\n+\n+        LatencyInfo latencyInfo = mapConfigs.stream()\n+                .filter(predicate)\n+                .map(mapConfig -> node.hazelcastInstance.getMap(mapConfig.getName()).getLocalMapStats())\n+                .filter(mapStats -> mapStats.getPutOperationCount() != 0L)\n+                .map(mapStats -> info.setLatency(mapStats.getTotalPutLatency(), mapStats.getPutOperationCount()))\n+                .reduce(new LatencyInfo(0, 0), LatencyInfo::sum);\n+\n+        return info.calculateAverage(latencyInfo);", "originalCommit": "c952f04257ed91e95b705c4eb4ef600c1db6abc0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjIxNjg1Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17259#discussion_r466216856", "bodyText": "operationCount would be a more meaningful name here (also for the parameter of #setLatency())", "author": "erosb", "createdAt": "2020-08-06T07:57:25Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/util/phonehome/MapInfoCollector.java", "diffHunk": "@@ -55,52 +61,115 @@\n         mapInfo.put(\"mpaocct\", String.valueOf(countMapWithAtleastOneAttribute()));\n         mapInfo.put(\"mpevct\", String.valueOf(countMapUsingEviction()));\n         mapInfo.put(\"mpnmct\", String.valueOf(countMapWithNativeInMemoryFormat()));\n+        mapInfo.put(\"mpptlams\", String.valueOf(mapPutLatency(hazelcastNode, isMapStoreEnabled())));\n+        mapInfo.put(\"mpptla\", String.valueOf(mapPutLatency(hazelcastNode, isMapStoreDisabled())));\n+        mapInfo.put(\"mpgtlams\", String.valueOf(mapGetLatency(hazelcastNode, isMapStoreEnabled())));\n+        mapInfo.put(\"mpgtla\", String.valueOf(mapGetLatency(hazelcastNode, isMapStoreDisabled())));\n \n         return mapInfo;\n     }\n \n     private long countMapWithBackupReadEnabled() {\n         return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.isReadBackupData()).count();\n+                .filter(MapConfig::isReadBackupData).count();\n     }\n \n     private long countMapWithMapStoreEnabled() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.getMapStoreConfig().isEnabled()).count();\n+        return mapConfigs.stream().map(MapConfig::getMapStoreConfig)\n+                .filter(MapStoreConfig::isEnabled).count();\n     }\n \n     private long countMapWithAtleastOneQueryCache() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && !(mapConfig.getQueryCacheConfigs().isEmpty())).count();\n+        return mapConfigs.stream().map(MapConfig::getQueryCacheConfigs)\n+                .filter(queryCacheConfigs -> !(queryCacheConfigs.isEmpty())).count();\n     }\n \n     private long countMapWithAtleastOneIndex() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && !(mapConfig.getIndexConfigs().isEmpty())).count();\n+        return mapConfigs.stream().map(MapConfig::getIndexConfigs)\n+                .filter(indexConfigs -> !(indexConfigs.isEmpty())).count();\n     }\n \n     private long countMapWithHotRestartEnabled() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.getHotRestartConfig().isEnabled()).count();\n+        return mapConfigs.stream().map(MapConfig::getHotRestartConfig)\n+                .filter(HotRestartConfig::isEnabled).count();\n     }\n \n     private long countMapWithWANReplication() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.getWanReplicationRef() != null).count();\n+        return mapConfigs.stream().map(MapConfig::getWanReplicationRef)\n+                .filter(Objects::nonNull).count();\n     }\n \n     private long countMapWithAtleastOneAttribute() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && !(mapConfig.getAttributeConfigs().isEmpty())).count();\n+        return mapConfigs.stream().map(MapConfig::getAttributeConfigs)\n+                .filter(attributeConfigs -> !(attributeConfigs.isEmpty())).count();\n     }\n \n     private long countMapUsingEviction() {\n-        return mapConfigs.stream().filter(mapConfig -> mapConfig != null\n-                && mapConfig.getEvictionConfig().getEvictionPolicy() != EvictionPolicy.NONE).count();\n+        return mapConfigs.stream().map(MapConfig::getEvictionConfig)\n+                .filter(evictionConfig -> evictionConfig.getEvictionPolicy() != EvictionPolicy.NONE).count();\n     }\n \n     private long countMapWithNativeInMemoryFormat() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.getInMemoryFormat() == InMemoryFormat.NATIVE).count();\n+        return mapConfigs.stream().map(MapConfig::getInMemoryFormat)\n+                .filter(inMemoryFormat -> inMemoryFormat == InMemoryFormat.NATIVE).count();\n+    }\n+\n+    static Predicate<MapConfig> isMapStoreEnabled() {\n+        return p -> p.getMapStoreConfig().isEnabled();\n+    }\n+\n+    static Predicate<MapConfig> isMapStoreDisabled() {\n+        return p -> !p.getMapStoreConfig().isEnabled();\n+    }\n+\n+    static class LatencyInfo {\n+        private long totalLatency;\n+        private long totalOperation;", "originalCommit": "c952f04257ed91e95b705c4eb4ef600c1db6abc0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjIyMzgxMQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17259#discussion_r466223811", "bodyText": "As far as I understand you use the info field to temporarily hold two values (total latency and operation count). The problem is that it introduces shared mutable state, which is just error-prone (and it works only because the process is single-threaded - imagine how would this work if mapPutLatency() and mapGetLatency() would be executed concurrently).\nSo instead of the map() and reduce() operations I suggest\n\ninitializing latencyInfo as a local variable before the stream operations (both fields set to 0)\nadding a forEach(stats -> latencyInfo.add(stats.getTotalPutLatency(), stats.getPutOperationCount())\n\n(assuming that there is an LatencyInfo#add() method which works similarly as the current LatencyInfo#sum() method)", "author": "erosb", "createdAt": "2020-08-06T08:09:14Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/util/phonehome/MapInfoCollector.java", "diffHunk": "@@ -55,52 +61,115 @@\n         mapInfo.put(\"mpaocct\", String.valueOf(countMapWithAtleastOneAttribute()));\n         mapInfo.put(\"mpevct\", String.valueOf(countMapUsingEviction()));\n         mapInfo.put(\"mpnmct\", String.valueOf(countMapWithNativeInMemoryFormat()));\n+        mapInfo.put(\"mpptlams\", String.valueOf(mapPutLatency(hazelcastNode, isMapStoreEnabled())));\n+        mapInfo.put(\"mpptla\", String.valueOf(mapPutLatency(hazelcastNode, isMapStoreDisabled())));\n+        mapInfo.put(\"mpgtlams\", String.valueOf(mapGetLatency(hazelcastNode, isMapStoreEnabled())));\n+        mapInfo.put(\"mpgtla\", String.valueOf(mapGetLatency(hazelcastNode, isMapStoreDisabled())));\n \n         return mapInfo;\n     }\n \n     private long countMapWithBackupReadEnabled() {\n         return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.isReadBackupData()).count();\n+                .filter(MapConfig::isReadBackupData).count();\n     }\n \n     private long countMapWithMapStoreEnabled() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.getMapStoreConfig().isEnabled()).count();\n+        return mapConfigs.stream().map(MapConfig::getMapStoreConfig)\n+                .filter(MapStoreConfig::isEnabled).count();\n     }\n \n     private long countMapWithAtleastOneQueryCache() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && !(mapConfig.getQueryCacheConfigs().isEmpty())).count();\n+        return mapConfigs.stream().map(MapConfig::getQueryCacheConfigs)\n+                .filter(queryCacheConfigs -> !(queryCacheConfigs.isEmpty())).count();\n     }\n \n     private long countMapWithAtleastOneIndex() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && !(mapConfig.getIndexConfigs().isEmpty())).count();\n+        return mapConfigs.stream().map(MapConfig::getIndexConfigs)\n+                .filter(indexConfigs -> !(indexConfigs.isEmpty())).count();\n     }\n \n     private long countMapWithHotRestartEnabled() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.getHotRestartConfig().isEnabled()).count();\n+        return mapConfigs.stream().map(MapConfig::getHotRestartConfig)\n+                .filter(HotRestartConfig::isEnabled).count();\n     }\n \n     private long countMapWithWANReplication() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.getWanReplicationRef() != null).count();\n+        return mapConfigs.stream().map(MapConfig::getWanReplicationRef)\n+                .filter(Objects::nonNull).count();\n     }\n \n     private long countMapWithAtleastOneAttribute() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && !(mapConfig.getAttributeConfigs().isEmpty())).count();\n+        return mapConfigs.stream().map(MapConfig::getAttributeConfigs)\n+                .filter(attributeConfigs -> !(attributeConfigs.isEmpty())).count();\n     }\n \n     private long countMapUsingEviction() {\n-        return mapConfigs.stream().filter(mapConfig -> mapConfig != null\n-                && mapConfig.getEvictionConfig().getEvictionPolicy() != EvictionPolicy.NONE).count();\n+        return mapConfigs.stream().map(MapConfig::getEvictionConfig)\n+                .filter(evictionConfig -> evictionConfig.getEvictionPolicy() != EvictionPolicy.NONE).count();\n     }\n \n     private long countMapWithNativeInMemoryFormat() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.getInMemoryFormat() == InMemoryFormat.NATIVE).count();\n+        return mapConfigs.stream().map(MapConfig::getInMemoryFormat)\n+                .filter(inMemoryFormat -> inMemoryFormat == InMemoryFormat.NATIVE).count();\n+    }\n+\n+    static Predicate<MapConfig> isMapStoreEnabled() {\n+        return p -> p.getMapStoreConfig().isEnabled();\n+    }\n+\n+    static Predicate<MapConfig> isMapStoreDisabled() {\n+        return p -> !p.getMapStoreConfig().isEnabled();\n+    }\n+\n+    static class LatencyInfo {\n+        private long totalLatency;\n+        private long totalOperation;\n+\n+        LatencyInfo(long totalLatency, long totalOperation) {\n+            this.totalLatency = totalLatency;\n+            this.totalOperation = totalOperation;\n+        }\n+\n+        LatencyInfo setLatency(long totalLatency, long totalOperation) {\n+            this.totalLatency = totalLatency;\n+            this.totalOperation = totalOperation;\n+            return this;\n+        }\n+\n+        LatencyInfo sum(LatencyInfo latencyInfo) {\n+            return setLatency(this.totalLatency + latencyInfo.totalLatency,\n+                    this.totalOperation + latencyInfo.totalOperation);\n+        }\n+\n+        Long calculateAverage(LatencyInfo latencyInfo) {\n+            return latencyInfo.totalOperation == 0 ? -1 : (latencyInfo.totalLatency / latencyInfo.totalOperation);\n+        }\n+    }\n+\n+\n+    private long mapPutLatency(Node node, Predicate<MapConfig> predicate) {\n+\n+        LatencyInfo latencyInfo = mapConfigs.stream()\n+                .filter(predicate)\n+                .map(mapConfig -> node.hazelcastInstance.getMap(mapConfig.getName()).getLocalMapStats())\n+                .filter(mapStats -> mapStats.getPutOperationCount() != 0L)\n+                .map(mapStats -> info.setLatency(mapStats.getTotalPutLatency(), mapStats.getPutOperationCount()))", "originalCommit": "c952f04257ed91e95b705c4eb4ef600c1db6abc0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "34716fe09dfcc393f7fcdef563feed3384226f73", "url": "https://github.com/hazelcast/hazelcast/commit/34716fe09dfcc393f7fcdef563feed3384226f73", "message": "improve the stream operation", "committedDate": "2020-08-06T08:41:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjI1NzQyNw==", "url": "https://github.com/hazelcast/hazelcast/pull/17259#discussion_r466257427", "bodyText": "I think now there isn't much reason to keep this method around. The addition and assignment can be done in the #add() method.", "author": "erosb", "createdAt": "2020-08-06T09:08:39Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/util/phonehome/MapInfoCollector.java", "diffHunk": "@@ -55,52 +60,115 @@\n         mapInfo.put(\"mpaocct\", String.valueOf(countMapWithAtleastOneAttribute()));\n         mapInfo.put(\"mpevct\", String.valueOf(countMapUsingEviction()));\n         mapInfo.put(\"mpnmct\", String.valueOf(countMapWithNativeInMemoryFormat()));\n+        mapInfo.put(\"mpptlams\", String.valueOf(mapPutLatency(hazelcastNode, isMapStoreEnabled())));\n+        mapInfo.put(\"mpptla\", String.valueOf(mapPutLatency(hazelcastNode, isMapStoreDisabled())));\n+        mapInfo.put(\"mpgtlams\", String.valueOf(mapGetLatency(hazelcastNode, isMapStoreEnabled())));\n+        mapInfo.put(\"mpgtla\", String.valueOf(mapGetLatency(hazelcastNode, isMapStoreDisabled())));\n \n         return mapInfo;\n     }\n \n     private long countMapWithBackupReadEnabled() {\n         return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.isReadBackupData()).count();\n+                .filter(MapConfig::isReadBackupData).count();\n     }\n \n     private long countMapWithMapStoreEnabled() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.getMapStoreConfig().isEnabled()).count();\n+        return mapConfigs.stream().map(MapConfig::getMapStoreConfig)\n+                .filter(MapStoreConfig::isEnabled).count();\n     }\n \n     private long countMapWithAtleastOneQueryCache() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && !(mapConfig.getQueryCacheConfigs().isEmpty())).count();\n+        return mapConfigs.stream().map(MapConfig::getQueryCacheConfigs)\n+                .filter(queryCacheConfigs -> !(queryCacheConfigs.isEmpty())).count();\n     }\n \n     private long countMapWithAtleastOneIndex() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && !(mapConfig.getIndexConfigs().isEmpty())).count();\n+        return mapConfigs.stream().map(MapConfig::getIndexConfigs)\n+                .filter(indexConfigs -> !(indexConfigs.isEmpty())).count();\n     }\n \n     private long countMapWithHotRestartEnabled() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.getHotRestartConfig().isEnabled()).count();\n+        return mapConfigs.stream().map(MapConfig::getHotRestartConfig)\n+                .filter(HotRestartConfig::isEnabled).count();\n     }\n \n     private long countMapWithWANReplication() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.getWanReplicationRef() != null).count();\n+        return mapConfigs.stream().map(MapConfig::getWanReplicationRef)\n+                .filter(Objects::nonNull).count();\n     }\n \n     private long countMapWithAtleastOneAttribute() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && !(mapConfig.getAttributeConfigs().isEmpty())).count();\n+        return mapConfigs.stream().map(MapConfig::getAttributeConfigs)\n+                .filter(attributeConfigs -> !(attributeConfigs.isEmpty())).count();\n     }\n \n     private long countMapUsingEviction() {\n-        return mapConfigs.stream().filter(mapConfig -> mapConfig != null\n-                && mapConfig.getEvictionConfig().getEvictionPolicy() != EvictionPolicy.NONE).count();\n+        return mapConfigs.stream().map(MapConfig::getEvictionConfig)\n+                .filter(evictionConfig -> evictionConfig.getEvictionPolicy() != EvictionPolicy.NONE).count();\n     }\n \n     private long countMapWithNativeInMemoryFormat() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.getInMemoryFormat() == InMemoryFormat.NATIVE).count();\n+        return mapConfigs.stream().map(MapConfig::getInMemoryFormat)\n+                .filter(inMemoryFormat -> inMemoryFormat == InMemoryFormat.NATIVE).count();\n+    }\n+\n+    static Predicate<MapConfig> isMapStoreEnabled() {\n+        return p -> p.getMapStoreConfig().isEnabled();\n+    }\n+\n+    static Predicate<MapConfig> isMapStoreDisabled() {\n+        return p -> !p.getMapStoreConfig().isEnabled();\n+    }\n+\n+    static class LatencyInfo {\n+\n+        private long totalLatency;\n+        private long operationCount;\n+\n+        LatencyInfo(long totalLatency, long operationCount) {\n+            this.totalLatency = totalLatency;\n+            this.operationCount = operationCount;\n+        }\n+\n+        void setLatency(long totalLatency, long totalOperation) {", "originalCommit": "34716fe09dfcc393f7fcdef563feed3384226f73", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjI1Nzg4NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17259#discussion_r466257884", "bodyText": "Please avoid unnecessary boxing and change Long to long.", "author": "erosb", "createdAt": "2020-08-06T09:09:32Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/util/phonehome/MapInfoCollector.java", "diffHunk": "@@ -55,52 +60,115 @@\n         mapInfo.put(\"mpaocct\", String.valueOf(countMapWithAtleastOneAttribute()));\n         mapInfo.put(\"mpevct\", String.valueOf(countMapUsingEviction()));\n         mapInfo.put(\"mpnmct\", String.valueOf(countMapWithNativeInMemoryFormat()));\n+        mapInfo.put(\"mpptlams\", String.valueOf(mapPutLatency(hazelcastNode, isMapStoreEnabled())));\n+        mapInfo.put(\"mpptla\", String.valueOf(mapPutLatency(hazelcastNode, isMapStoreDisabled())));\n+        mapInfo.put(\"mpgtlams\", String.valueOf(mapGetLatency(hazelcastNode, isMapStoreEnabled())));\n+        mapInfo.put(\"mpgtla\", String.valueOf(mapGetLatency(hazelcastNode, isMapStoreDisabled())));\n \n         return mapInfo;\n     }\n \n     private long countMapWithBackupReadEnabled() {\n         return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.isReadBackupData()).count();\n+                .filter(MapConfig::isReadBackupData).count();\n     }\n \n     private long countMapWithMapStoreEnabled() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.getMapStoreConfig().isEnabled()).count();\n+        return mapConfigs.stream().map(MapConfig::getMapStoreConfig)\n+                .filter(MapStoreConfig::isEnabled).count();\n     }\n \n     private long countMapWithAtleastOneQueryCache() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && !(mapConfig.getQueryCacheConfigs().isEmpty())).count();\n+        return mapConfigs.stream().map(MapConfig::getQueryCacheConfigs)\n+                .filter(queryCacheConfigs -> !(queryCacheConfigs.isEmpty())).count();\n     }\n \n     private long countMapWithAtleastOneIndex() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && !(mapConfig.getIndexConfigs().isEmpty())).count();\n+        return mapConfigs.stream().map(MapConfig::getIndexConfigs)\n+                .filter(indexConfigs -> !(indexConfigs.isEmpty())).count();\n     }\n \n     private long countMapWithHotRestartEnabled() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.getHotRestartConfig().isEnabled()).count();\n+        return mapConfigs.stream().map(MapConfig::getHotRestartConfig)\n+                .filter(HotRestartConfig::isEnabled).count();\n     }\n \n     private long countMapWithWANReplication() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.getWanReplicationRef() != null).count();\n+        return mapConfigs.stream().map(MapConfig::getWanReplicationRef)\n+                .filter(Objects::nonNull).count();\n     }\n \n     private long countMapWithAtleastOneAttribute() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && !(mapConfig.getAttributeConfigs().isEmpty())).count();\n+        return mapConfigs.stream().map(MapConfig::getAttributeConfigs)\n+                .filter(attributeConfigs -> !(attributeConfigs.isEmpty())).count();\n     }\n \n     private long countMapUsingEviction() {\n-        return mapConfigs.stream().filter(mapConfig -> mapConfig != null\n-                && mapConfig.getEvictionConfig().getEvictionPolicy() != EvictionPolicy.NONE).count();\n+        return mapConfigs.stream().map(MapConfig::getEvictionConfig)\n+                .filter(evictionConfig -> evictionConfig.getEvictionPolicy() != EvictionPolicy.NONE).count();\n     }\n \n     private long countMapWithNativeInMemoryFormat() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.getInMemoryFormat() == InMemoryFormat.NATIVE).count();\n+        return mapConfigs.stream().map(MapConfig::getInMemoryFormat)\n+                .filter(inMemoryFormat -> inMemoryFormat == InMemoryFormat.NATIVE).count();\n+    }\n+\n+    static Predicate<MapConfig> isMapStoreEnabled() {\n+        return p -> p.getMapStoreConfig().isEnabled();\n+    }\n+\n+    static Predicate<MapConfig> isMapStoreDisabled() {\n+        return p -> !p.getMapStoreConfig().isEnabled();\n+    }\n+\n+    static class LatencyInfo {\n+\n+        private long totalLatency;\n+        private long operationCount;\n+\n+        LatencyInfo(long totalLatency, long operationCount) {\n+            this.totalLatency = totalLatency;\n+            this.operationCount = operationCount;\n+        }\n+\n+        void setLatency(long totalLatency, long totalOperation) {\n+            this.totalLatency = totalLatency;\n+            this.operationCount = totalOperation;\n+        }\n+\n+        void add(long totalLatency, long operationCount) {\n+            setLatency(this.totalLatency + totalLatency,\n+                    this.operationCount + operationCount);\n+        }\n+\n+        Long calculateAverage() {", "originalCommit": "34716fe09dfcc393f7fcdef563feed3384226f73", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjI2MDE0Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/17259#discussion_r466260147", "bodyText": "I'm not sure if it makes sense to have this method, since it always returns the same lambda. So this can be removed and the lambda itself extracted into a constant (eg. IS_MAP_STORE_ENABLED).\nnit: once ^this is done, the other lambda can be created as IS_MAP_STORE_ENABLED.negate()", "author": "erosb", "createdAt": "2020-08-06T09:13:04Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/util/phonehome/MapInfoCollector.java", "diffHunk": "@@ -55,52 +60,115 @@\n         mapInfo.put(\"mpaocct\", String.valueOf(countMapWithAtleastOneAttribute()));\n         mapInfo.put(\"mpevct\", String.valueOf(countMapUsingEviction()));\n         mapInfo.put(\"mpnmct\", String.valueOf(countMapWithNativeInMemoryFormat()));\n+        mapInfo.put(\"mpptlams\", String.valueOf(mapPutLatency(hazelcastNode, isMapStoreEnabled())));\n+        mapInfo.put(\"mpptla\", String.valueOf(mapPutLatency(hazelcastNode, isMapStoreDisabled())));\n+        mapInfo.put(\"mpgtlams\", String.valueOf(mapGetLatency(hazelcastNode, isMapStoreEnabled())));\n+        mapInfo.put(\"mpgtla\", String.valueOf(mapGetLatency(hazelcastNode, isMapStoreDisabled())));\n \n         return mapInfo;\n     }\n \n     private long countMapWithBackupReadEnabled() {\n         return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.isReadBackupData()).count();\n+                .filter(MapConfig::isReadBackupData).count();\n     }\n \n     private long countMapWithMapStoreEnabled() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.getMapStoreConfig().isEnabled()).count();\n+        return mapConfigs.stream().map(MapConfig::getMapStoreConfig)\n+                .filter(MapStoreConfig::isEnabled).count();\n     }\n \n     private long countMapWithAtleastOneQueryCache() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && !(mapConfig.getQueryCacheConfigs().isEmpty())).count();\n+        return mapConfigs.stream().map(MapConfig::getQueryCacheConfigs)\n+                .filter(queryCacheConfigs -> !(queryCacheConfigs.isEmpty())).count();\n     }\n \n     private long countMapWithAtleastOneIndex() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && !(mapConfig.getIndexConfigs().isEmpty())).count();\n+        return mapConfigs.stream().map(MapConfig::getIndexConfigs)\n+                .filter(indexConfigs -> !(indexConfigs.isEmpty())).count();\n     }\n \n     private long countMapWithHotRestartEnabled() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.getHotRestartConfig().isEnabled()).count();\n+        return mapConfigs.stream().map(MapConfig::getHotRestartConfig)\n+                .filter(HotRestartConfig::isEnabled).count();\n     }\n \n     private long countMapWithWANReplication() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.getWanReplicationRef() != null).count();\n+        return mapConfigs.stream().map(MapConfig::getWanReplicationRef)\n+                .filter(Objects::nonNull).count();\n     }\n \n     private long countMapWithAtleastOneAttribute() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && !(mapConfig.getAttributeConfigs().isEmpty())).count();\n+        return mapConfigs.stream().map(MapConfig::getAttributeConfigs)\n+                .filter(attributeConfigs -> !(attributeConfigs.isEmpty())).count();\n     }\n \n     private long countMapUsingEviction() {\n-        return mapConfigs.stream().filter(mapConfig -> mapConfig != null\n-                && mapConfig.getEvictionConfig().getEvictionPolicy() != EvictionPolicy.NONE).count();\n+        return mapConfigs.stream().map(MapConfig::getEvictionConfig)\n+                .filter(evictionConfig -> evictionConfig.getEvictionPolicy() != EvictionPolicy.NONE).count();\n     }\n \n     private long countMapWithNativeInMemoryFormat() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.getInMemoryFormat() == InMemoryFormat.NATIVE).count();\n+        return mapConfigs.stream().map(MapConfig::getInMemoryFormat)\n+                .filter(inMemoryFormat -> inMemoryFormat == InMemoryFormat.NATIVE).count();\n+    }\n+\n+    static Predicate<MapConfig> isMapStoreEnabled() {", "originalCommit": "34716fe09dfcc393f7fcdef563feed3384226f73", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjI2MzExMA==", "url": "https://github.com/hazelcast/hazelcast/pull/17259#discussion_r466263110", "bodyText": "Can you extract these very similarly looking stream operation chains into a parameterized shared method? What parameters would you need to do that? You will need a functional approach to solve this - please try to figure it out on your own.", "author": "erosb", "createdAt": "2020-08-06T09:15:38Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/util/phonehome/MapInfoCollector.java", "diffHunk": "@@ -55,52 +60,115 @@\n         mapInfo.put(\"mpaocct\", String.valueOf(countMapWithAtleastOneAttribute()));\n         mapInfo.put(\"mpevct\", String.valueOf(countMapUsingEviction()));\n         mapInfo.put(\"mpnmct\", String.valueOf(countMapWithNativeInMemoryFormat()));\n+        mapInfo.put(\"mpptlams\", String.valueOf(mapPutLatency(hazelcastNode, isMapStoreEnabled())));\n+        mapInfo.put(\"mpptla\", String.valueOf(mapPutLatency(hazelcastNode, isMapStoreDisabled())));\n+        mapInfo.put(\"mpgtlams\", String.valueOf(mapGetLatency(hazelcastNode, isMapStoreEnabled())));\n+        mapInfo.put(\"mpgtla\", String.valueOf(mapGetLatency(hazelcastNode, isMapStoreDisabled())));\n \n         return mapInfo;\n     }\n \n     private long countMapWithBackupReadEnabled() {\n         return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.isReadBackupData()).count();\n+                .filter(MapConfig::isReadBackupData).count();\n     }\n \n     private long countMapWithMapStoreEnabled() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.getMapStoreConfig().isEnabled()).count();\n+        return mapConfigs.stream().map(MapConfig::getMapStoreConfig)\n+                .filter(MapStoreConfig::isEnabled).count();\n     }\n \n     private long countMapWithAtleastOneQueryCache() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && !(mapConfig.getQueryCacheConfigs().isEmpty())).count();\n+        return mapConfigs.stream().map(MapConfig::getQueryCacheConfigs)\n+                .filter(queryCacheConfigs -> !(queryCacheConfigs.isEmpty())).count();\n     }\n \n     private long countMapWithAtleastOneIndex() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && !(mapConfig.getIndexConfigs().isEmpty())).count();\n+        return mapConfigs.stream().map(MapConfig::getIndexConfigs)\n+                .filter(indexConfigs -> !(indexConfigs.isEmpty())).count();\n     }\n \n     private long countMapWithHotRestartEnabled() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.getHotRestartConfig().isEnabled()).count();\n+        return mapConfigs.stream().map(MapConfig::getHotRestartConfig)\n+                .filter(HotRestartConfig::isEnabled).count();\n     }\n \n     private long countMapWithWANReplication() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.getWanReplicationRef() != null).count();\n+        return mapConfigs.stream().map(MapConfig::getWanReplicationRef)\n+                .filter(Objects::nonNull).count();\n     }\n \n     private long countMapWithAtleastOneAttribute() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && !(mapConfig.getAttributeConfigs().isEmpty())).count();\n+        return mapConfigs.stream().map(MapConfig::getAttributeConfigs)\n+                .filter(attributeConfigs -> !(attributeConfigs.isEmpty())).count();\n     }\n \n     private long countMapUsingEviction() {\n-        return mapConfigs.stream().filter(mapConfig -> mapConfig != null\n-                && mapConfig.getEvictionConfig().getEvictionPolicy() != EvictionPolicy.NONE).count();\n+        return mapConfigs.stream().map(MapConfig::getEvictionConfig)\n+                .filter(evictionConfig -> evictionConfig.getEvictionPolicy() != EvictionPolicy.NONE).count();\n     }\n \n     private long countMapWithNativeInMemoryFormat() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.getInMemoryFormat() == InMemoryFormat.NATIVE).count();\n+        return mapConfigs.stream().map(MapConfig::getInMemoryFormat)\n+                .filter(inMemoryFormat -> inMemoryFormat == InMemoryFormat.NATIVE).count();\n+    }\n+\n+    static Predicate<MapConfig> isMapStoreEnabled() {\n+        return p -> p.getMapStoreConfig().isEnabled();\n+    }\n+\n+    static Predicate<MapConfig> isMapStoreDisabled() {\n+        return p -> !p.getMapStoreConfig().isEnabled();\n+    }\n+\n+    static class LatencyInfo {\n+\n+        private long totalLatency;\n+        private long operationCount;\n+\n+        LatencyInfo(long totalLatency, long operationCount) {\n+            this.totalLatency = totalLatency;\n+            this.operationCount = operationCount;\n+        }\n+\n+        void setLatency(long totalLatency, long totalOperation) {\n+            this.totalLatency = totalLatency;\n+            this.operationCount = totalOperation;\n+        }\n+\n+        void add(long totalLatency, long operationCount) {\n+            setLatency(this.totalLatency + totalLatency,\n+                    this.operationCount + operationCount);\n+        }\n+\n+        Long calculateAverage() {\n+            return this.operationCount == 0 ? -1 : (this.totalLatency / this.operationCount);\n+        }\n+    }\n+\n+\n+    private long mapPutLatency(Node node, Predicate<MapConfig> predicate) {\n+\n+        LatencyInfo putLatencyInfo = new LatencyInfo(0L, 0L);\n+        mapConfigs.stream()\n+                .filter(predicate)\n+                .map(mapConfig -> node.hazelcastInstance.getMap(mapConfig.getName()).getLocalMapStats())\n+                .filter(mapStats -> mapStats.getPutOperationCount() != 0L)\n+                .forEach(mapStats -> putLatencyInfo.add(mapStats.getTotalPutLatency(), mapStats.getPutOperationCount()));\n+\n+        return putLatencyInfo.calculateAverage();\n+    }\n+\n+    private long mapGetLatency(Node node, Predicate<MapConfig> predicate) {\n+\n+        LatencyInfo getLatencyInfo = new LatencyInfo(0L, 0L);\n+        mapConfigs.stream()\n+                .filter(predicate)\n+                .map(mapConfig -> node.hazelcastInstance.getMap(mapConfig.getName()).getLocalMapStats())\n+                .filter(mapStats -> mapStats.getGetOperationCount() != 0L)\n+                .forEach(mapStats -> getLatencyInfo.add(mapStats.getTotalGetLatency(), mapStats.getGetOperationCount()));", "originalCommit": "34716fe09dfcc393f7fcdef563feed3384226f73", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1c2cef72ded1a6cd6894a373620b29c46b8b01e2", "url": "https://github.com/hazelcast/hazelcast/commit/1c2cef72ded1a6cd6894a373620b29c46b8b01e2", "message": "Used generic data type functions\n\nremove unnecessary lines", "committedDate": "2020-08-06T17:07:36Z", "type": "commit"}, {"oid": "1c2cef72ded1a6cd6894a373620b29c46b8b01e2", "url": "https://github.com/hazelcast/hazelcast/commit/1c2cef72ded1a6cd6894a373620b29c46b8b01e2", "message": "Used generic data type functions\n\nremove unnecessary lines", "committedDate": "2020-08-06T17:07:36Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU1NTU2OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17259#discussion_r466555569", "bodyText": "this method looks like just boilerplate for me - IMO the method name is not simpler than its implementation, so you can remove it and just use LocalMapStats::getTotalLatency in computeMetrics(). Same for the other 4 methods below.", "author": "erosb", "createdAt": "2020-08-06T17:02:33Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/util/phonehome/MapInfoCollector.java", "diffHunk": "@@ -55,52 +63,106 @@\n         mapInfo.put(\"mpaocct\", String.valueOf(countMapWithAtleastOneAttribute()));\n         mapInfo.put(\"mpevct\", String.valueOf(countMapUsingEviction()));\n         mapInfo.put(\"mpnmct\", String.valueOf(countMapWithNativeInMemoryFormat()));\n+        mapInfo.put(\"mpptlams\", String.valueOf(mapOperationLatency(hazelcastNode, IS_MAP_STORE_ENABLED,\n+                mapStatsToPutLatency(), mapStatsToPutOperationCount())));\n+        mapInfo.put(\"mpptla\", String.valueOf(mapOperationLatency(hazelcastNode, IS_MAP_STORE_ENABLED.negate(),\n+                mapStatsToPutLatency(), mapStatsToPutOperationCount())));\n+        mapInfo.put(\"mpgtlams\", String.valueOf(mapOperationLatency(hazelcastNode, IS_MAP_STORE_ENABLED,\n+                mapStatsToGetLatency(), mapStatsToGetOperationCount())));\n+        mapInfo.put(\"mpgtla\", String.valueOf(mapOperationLatency(hazelcastNode, IS_MAP_STORE_ENABLED.negate(),\n+                mapStatsToGetLatency(), mapStatsToGetOperationCount())));\n \n         return mapInfo;\n     }\n \n     private long countMapWithBackupReadEnabled() {\n         return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.isReadBackupData()).count();\n+                .filter(MapConfig::isReadBackupData).count();\n     }\n \n     private long countMapWithMapStoreEnabled() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.getMapStoreConfig().isEnabled()).count();\n+        return mapConfigs.stream().map(MapConfig::getMapStoreConfig)\n+                .filter(MapStoreConfig::isEnabled).count();\n     }\n \n     private long countMapWithAtleastOneQueryCache() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && !(mapConfig.getQueryCacheConfigs().isEmpty())).count();\n+        return mapConfigs.stream().map(MapConfig::getQueryCacheConfigs)\n+                .filter(queryCacheConfigs -> !(queryCacheConfigs.isEmpty())).count();\n     }\n \n     private long countMapWithAtleastOneIndex() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && !(mapConfig.getIndexConfigs().isEmpty())).count();\n+        return mapConfigs.stream().map(MapConfig::getIndexConfigs)\n+                .filter(indexConfigs -> !(indexConfigs.isEmpty())).count();\n     }\n \n     private long countMapWithHotRestartEnabled() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.getHotRestartConfig().isEnabled()).count();\n+        return mapConfigs.stream().map(MapConfig::getHotRestartConfig)\n+                .filter(HotRestartConfig::isEnabled).count();\n     }\n \n     private long countMapWithWANReplication() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.getWanReplicationRef() != null).count();\n+        return mapConfigs.stream().map(MapConfig::getWanReplicationRef)\n+                .filter(Objects::nonNull).count();\n     }\n \n     private long countMapWithAtleastOneAttribute() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && !(mapConfig.getAttributeConfigs().isEmpty())).count();\n+        return mapConfigs.stream().map(MapConfig::getAttributeConfigs)\n+                .filter(attributeConfigs -> !(attributeConfigs.isEmpty())).count();\n     }\n \n     private long countMapUsingEviction() {\n-        return mapConfigs.stream().filter(mapConfig -> mapConfig != null\n-                && mapConfig.getEvictionConfig().getEvictionPolicy() != EvictionPolicy.NONE).count();\n+        return mapConfigs.stream().map(MapConfig::getEvictionConfig)\n+                .filter(evictionConfig -> evictionConfig.getEvictionPolicy() != EvictionPolicy.NONE).count();\n     }\n \n     private long countMapWithNativeInMemoryFormat() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.getInMemoryFormat() == InMemoryFormat.NATIVE).count();\n+        return mapConfigs.stream().map(MapConfig::getInMemoryFormat)\n+                .filter(inMemoryFormat -> inMemoryFormat == InMemoryFormat.NATIVE).count();\n+    }\n+\n+    static class LatencyInfo {\n+        private Long totalLatency;\n+        private Long operationCount;\n+\n+        LatencyInfo(Long totalLatency, Long operationCount) {\n+            this.totalLatency = totalLatency;\n+            this.operationCount = operationCount;\n+        }\n+\n+        void add(Long totalLatency, Long operationCount) {\n+            this.totalLatency += totalLatency;\n+            this.operationCount += operationCount;\n+        }\n+\n+        Long calculateAverage() {\n+            return this.operationCount == 0 ? -1 : (this.totalLatency / this.operationCount);\n+        }\n+    }\n+\n+    Function<? super LocalMapStats, ? extends Long> mapStatsToGetLatency() {", "originalCommit": "90636eb477da53dd4ad39d879efdbd0a034a213b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU1NjM0MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17259#discussion_r466556341", "bodyText": "there was a != 0 filter here before, wasn't it? do the tests even pass without the filter?", "author": "erosb", "createdAt": "2020-08-06T17:03:55Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/util/phonehome/MapInfoCollector.java", "diffHunk": "@@ -55,52 +63,106 @@\n         mapInfo.put(\"mpaocct\", String.valueOf(countMapWithAtleastOneAttribute()));\n         mapInfo.put(\"mpevct\", String.valueOf(countMapUsingEviction()));\n         mapInfo.put(\"mpnmct\", String.valueOf(countMapWithNativeInMemoryFormat()));\n+        mapInfo.put(\"mpptlams\", String.valueOf(mapOperationLatency(hazelcastNode, IS_MAP_STORE_ENABLED,\n+                mapStatsToPutLatency(), mapStatsToPutOperationCount())));\n+        mapInfo.put(\"mpptla\", String.valueOf(mapOperationLatency(hazelcastNode, IS_MAP_STORE_ENABLED.negate(),\n+                mapStatsToPutLatency(), mapStatsToPutOperationCount())));\n+        mapInfo.put(\"mpgtlams\", String.valueOf(mapOperationLatency(hazelcastNode, IS_MAP_STORE_ENABLED,\n+                mapStatsToGetLatency(), mapStatsToGetOperationCount())));\n+        mapInfo.put(\"mpgtla\", String.valueOf(mapOperationLatency(hazelcastNode, IS_MAP_STORE_ENABLED.negate(),\n+                mapStatsToGetLatency(), mapStatsToGetOperationCount())));\n \n         return mapInfo;\n     }\n \n     private long countMapWithBackupReadEnabled() {\n         return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.isReadBackupData()).count();\n+                .filter(MapConfig::isReadBackupData).count();\n     }\n \n     private long countMapWithMapStoreEnabled() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.getMapStoreConfig().isEnabled()).count();\n+        return mapConfigs.stream().map(MapConfig::getMapStoreConfig)\n+                .filter(MapStoreConfig::isEnabled).count();\n     }\n \n     private long countMapWithAtleastOneQueryCache() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && !(mapConfig.getQueryCacheConfigs().isEmpty())).count();\n+        return mapConfigs.stream().map(MapConfig::getQueryCacheConfigs)\n+                .filter(queryCacheConfigs -> !(queryCacheConfigs.isEmpty())).count();\n     }\n \n     private long countMapWithAtleastOneIndex() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && !(mapConfig.getIndexConfigs().isEmpty())).count();\n+        return mapConfigs.stream().map(MapConfig::getIndexConfigs)\n+                .filter(indexConfigs -> !(indexConfigs.isEmpty())).count();\n     }\n \n     private long countMapWithHotRestartEnabled() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.getHotRestartConfig().isEnabled()).count();\n+        return mapConfigs.stream().map(MapConfig::getHotRestartConfig)\n+                .filter(HotRestartConfig::isEnabled).count();\n     }\n \n     private long countMapWithWANReplication() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.getWanReplicationRef() != null).count();\n+        return mapConfigs.stream().map(MapConfig::getWanReplicationRef)\n+                .filter(Objects::nonNull).count();\n     }\n \n     private long countMapWithAtleastOneAttribute() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && !(mapConfig.getAttributeConfigs().isEmpty())).count();\n+        return mapConfigs.stream().map(MapConfig::getAttributeConfigs)\n+                .filter(attributeConfigs -> !(attributeConfigs.isEmpty())).count();\n     }\n \n     private long countMapUsingEviction() {\n-        return mapConfigs.stream().filter(mapConfig -> mapConfig != null\n-                && mapConfig.getEvictionConfig().getEvictionPolicy() != EvictionPolicy.NONE).count();\n+        return mapConfigs.stream().map(MapConfig::getEvictionConfig)\n+                .filter(evictionConfig -> evictionConfig.getEvictionPolicy() != EvictionPolicy.NONE).count();\n     }\n \n     private long countMapWithNativeInMemoryFormat() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.getInMemoryFormat() == InMemoryFormat.NATIVE).count();\n+        return mapConfigs.stream().map(MapConfig::getInMemoryFormat)\n+                .filter(inMemoryFormat -> inMemoryFormat == InMemoryFormat.NATIVE).count();\n+    }\n+\n+    static class LatencyInfo {\n+        private Long totalLatency;\n+        private Long operationCount;\n+\n+        LatencyInfo(Long totalLatency, Long operationCount) {\n+            this.totalLatency = totalLatency;\n+            this.operationCount = operationCount;\n+        }\n+\n+        void add(Long totalLatency, Long operationCount) {\n+            this.totalLatency += totalLatency;\n+            this.operationCount += operationCount;\n+        }\n+\n+        Long calculateAverage() {\n+            return this.operationCount == 0 ? -1 : (this.totalLatency / this.operationCount);\n+        }\n+    }\n+\n+    Function<? super LocalMapStats, ? extends Long> mapStatsToGetLatency() {\n+        return LocalMapStats::getTotalGetLatency;\n+    }\n+\n+    Function<? super LocalMapStats, ? extends Long> mapStatsToGetOperationCount() {\n+        return LocalMapStats::getGetOperationCount;\n+    }\n+\n+    Function<? super LocalMapStats, ? extends Long> mapStatsToPutLatency() {\n+        return LocalMapStats::getTotalPutLatency;\n+    }\n+\n+    Function<? super LocalMapStats, ? extends Long> mapStatsToPutOperationCount() {\n+        return LocalMapStats::getPutOperationCount;\n+    }\n+\n+    private long mapOperationLatency(Node node, Predicate<MapConfig> predicate,\n+                                     Function<? super LocalMapStats, ? extends Long> latencyMap,\n+                                     Function<? super LocalMapStats, ? extends Long> operationMap) {\n+        LatencyInfo latencyInfo = new LatencyInfo(0L, 0L);\n+        mapConfigs.stream()\n+                .filter(predicate)\n+                .map(mapConfig -> node.hazelcastInstance.getMap(mapConfig.getName()).getLocalMapStats())", "originalCommit": "90636eb477da53dd4ad39d879efdbd0a034a213b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU2MzU4OA==", "url": "https://github.com/hazelcast/hazelcast/pull/17259#discussion_r466563588", "bodyText": "there was a filter for != 0 here previously, afair. How do the tests even pass now? Don't we cover the division-by-zero case?", "author": "erosb", "createdAt": "2020-08-06T17:16:58Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/util/phonehome/MapInfoCollector.java", "diffHunk": "@@ -55,52 +62,106 @@\n         mapInfo.put(\"mpaocct\", String.valueOf(countMapWithAtleastOneAttribute()));\n         mapInfo.put(\"mpevct\", String.valueOf(countMapUsingEviction()));\n         mapInfo.put(\"mpnmct\", String.valueOf(countMapWithNativeInMemoryFormat()));\n+        mapInfo.put(\"mpptlams\", String.valueOf(mapOperationLatency(hazelcastNode, IS_MAP_STORE_ENABLED,\n+                mapStatsToPutLatency(), mapStatsToPutOperationCount())));\n+        mapInfo.put(\"mpptla\", String.valueOf(mapOperationLatency(hazelcastNode, IS_MAP_STORE_ENABLED.negate(),\n+                mapStatsToPutLatency(), mapStatsToPutOperationCount())));\n+        mapInfo.put(\"mpgtlams\", String.valueOf(mapOperationLatency(hazelcastNode, IS_MAP_STORE_ENABLED,\n+                mapStatsToGetLatency(), mapStatsToGetOperationCount())));\n+        mapInfo.put(\"mpgtla\", String.valueOf(mapOperationLatency(hazelcastNode, IS_MAP_STORE_ENABLED.negate(),\n+                mapStatsToGetLatency(), mapStatsToGetOperationCount())));\n \n         return mapInfo;\n     }\n \n     private long countMapWithBackupReadEnabled() {\n         return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.isReadBackupData()).count();\n+                .filter(MapConfig::isReadBackupData).count();\n     }\n \n     private long countMapWithMapStoreEnabled() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.getMapStoreConfig().isEnabled()).count();\n+        return mapConfigs.stream().map(MapConfig::getMapStoreConfig)\n+                .filter(MapStoreConfig::isEnabled).count();\n     }\n \n     private long countMapWithAtleastOneQueryCache() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && !(mapConfig.getQueryCacheConfigs().isEmpty())).count();\n+        return mapConfigs.stream().map(MapConfig::getQueryCacheConfigs)\n+                .filter(queryCacheConfigs -> !(queryCacheConfigs.isEmpty())).count();\n     }\n \n     private long countMapWithAtleastOneIndex() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && !(mapConfig.getIndexConfigs().isEmpty())).count();\n+        return mapConfigs.stream().map(MapConfig::getIndexConfigs)\n+                .filter(indexConfigs -> !(indexConfigs.isEmpty())).count();\n     }\n \n     private long countMapWithHotRestartEnabled() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.getHotRestartConfig().isEnabled()).count();\n+        return mapConfigs.stream().map(MapConfig::getHotRestartConfig)\n+                .filter(HotRestartConfig::isEnabled).count();\n     }\n \n     private long countMapWithWANReplication() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.getWanReplicationRef() != null).count();\n+        return mapConfigs.stream().map(MapConfig::getWanReplicationRef)\n+                .filter(Objects::nonNull).count();\n     }\n \n     private long countMapWithAtleastOneAttribute() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && !(mapConfig.getAttributeConfigs().isEmpty())).count();\n+        return mapConfigs.stream().map(MapConfig::getAttributeConfigs)\n+                .filter(attributeConfigs -> !(attributeConfigs.isEmpty())).count();\n     }\n \n     private long countMapUsingEviction() {\n-        return mapConfigs.stream().filter(mapConfig -> mapConfig != null\n-                && mapConfig.getEvictionConfig().getEvictionPolicy() != EvictionPolicy.NONE).count();\n+        return mapConfigs.stream().map(MapConfig::getEvictionConfig)\n+                .filter(evictionConfig -> evictionConfig.getEvictionPolicy() != EvictionPolicy.NONE).count();\n     }\n \n     private long countMapWithNativeInMemoryFormat() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.getInMemoryFormat() == InMemoryFormat.NATIVE).count();\n+        return mapConfigs.stream().map(MapConfig::getInMemoryFormat)\n+                .filter(inMemoryFormat -> inMemoryFormat == InMemoryFormat.NATIVE).count();\n+    }\n+\n+    static class LatencyInfo {\n+        private Long totalLatency;\n+        private Long operationCount;\n+\n+        LatencyInfo(Long totalLatency, Long operationCount) {\n+            this.totalLatency = totalLatency;\n+            this.operationCount = operationCount;\n+        }\n+\n+        void add(Long totalLatency, Long operationCount) {\n+            this.totalLatency += totalLatency;\n+            this.operationCount += operationCount;\n+        }\n+\n+        Long calculateAverage() {\n+            return this.operationCount == 0 ? -1 : (this.totalLatency / this.operationCount);\n+        }\n+    }\n+\n+    Function<? super LocalMapStats, ? extends Long> mapStatsToGetLatency() {\n+        return LocalMapStats::getTotalGetLatency;\n+    }\n+\n+    Function<? super LocalMapStats, ? extends Long> mapStatsToGetOperationCount() {\n+        return LocalMapStats::getGetOperationCount;\n+    }\n+\n+    Function<? super LocalMapStats, ? extends Long> mapStatsToPutLatency() {\n+        return LocalMapStats::getTotalPutLatency;\n+    }\n+\n+    Function<? super LocalMapStats, ? extends Long> mapStatsToPutOperationCount() {\n+        return LocalMapStats::getPutOperationCount;\n+    }\n+\n+    private long mapOperationLatency(Node node, Predicate<MapConfig> predicate,\n+                                     Function<? super LocalMapStats, ? extends Long> latencyMap,\n+                                     Function<? super LocalMapStats, ? extends Long> operationMap) {\n+        LatencyInfo latencyInfo = new LatencyInfo(0L, 0L);\n+        mapConfigs.stream()\n+                .filter(predicate)\n+                .map(mapConfig -> node.hazelcastInstance.getMap(mapConfig.getName()).getLocalMapStats())", "originalCommit": "1c2cef72ded1a6cd6894a373620b29c46b8b01e2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU2MzY3MA==", "url": "https://github.com/hazelcast/hazelcast/pull/17259#discussion_r466563670", "bodyText": "3 notes on this:\n\nthe formal parameter names aren't descriptive. These are not maps. These are functions (used for mapping). I suggest something like totalLatencyExtractor , totalLatencyProvider , totalLatencySupplier, or even totalLatencyFn but not *Map, please. Also the second param is a function that returns the operation count. So it should be operationCountProvider or similar.\nin case of external (public) APIs it is very wise not to restrict the generic type params to a single type (and use extends and super like you do here), but since it is a very small-scoped internal API, we are ok with Function<LocalMapStats, Long>.\nre-iterating the previous one, the problem with the use of primitive wrappers is that they come with a hell of implicit auto-boxing and unboxing. Since we still want to use the stream API with primitives, Java offers specialized function types for working with them. In this case, the appropriate specialized function type is ToLongFunction (which maps an object to a long). So to sum up, please use ToLongFunction<LocalMapStats> instead of Function<? super LocalMapStats, ? extends Long>.", "author": "erosb", "createdAt": "2020-08-06T17:17:08Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/util/phonehome/MapInfoCollector.java", "diffHunk": "@@ -55,52 +62,106 @@\n         mapInfo.put(\"mpaocct\", String.valueOf(countMapWithAtleastOneAttribute()));\n         mapInfo.put(\"mpevct\", String.valueOf(countMapUsingEviction()));\n         mapInfo.put(\"mpnmct\", String.valueOf(countMapWithNativeInMemoryFormat()));\n+        mapInfo.put(\"mpptlams\", String.valueOf(mapOperationLatency(hazelcastNode, IS_MAP_STORE_ENABLED,\n+                mapStatsToPutLatency(), mapStatsToPutOperationCount())));\n+        mapInfo.put(\"mpptla\", String.valueOf(mapOperationLatency(hazelcastNode, IS_MAP_STORE_ENABLED.negate(),\n+                mapStatsToPutLatency(), mapStatsToPutOperationCount())));\n+        mapInfo.put(\"mpgtlams\", String.valueOf(mapOperationLatency(hazelcastNode, IS_MAP_STORE_ENABLED,\n+                mapStatsToGetLatency(), mapStatsToGetOperationCount())));\n+        mapInfo.put(\"mpgtla\", String.valueOf(mapOperationLatency(hazelcastNode, IS_MAP_STORE_ENABLED.negate(),\n+                mapStatsToGetLatency(), mapStatsToGetOperationCount())));\n \n         return mapInfo;\n     }\n \n     private long countMapWithBackupReadEnabled() {\n         return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.isReadBackupData()).count();\n+                .filter(MapConfig::isReadBackupData).count();\n     }\n \n     private long countMapWithMapStoreEnabled() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.getMapStoreConfig().isEnabled()).count();\n+        return mapConfigs.stream().map(MapConfig::getMapStoreConfig)\n+                .filter(MapStoreConfig::isEnabled).count();\n     }\n \n     private long countMapWithAtleastOneQueryCache() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && !(mapConfig.getQueryCacheConfigs().isEmpty())).count();\n+        return mapConfigs.stream().map(MapConfig::getQueryCacheConfigs)\n+                .filter(queryCacheConfigs -> !(queryCacheConfigs.isEmpty())).count();\n     }\n \n     private long countMapWithAtleastOneIndex() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && !(mapConfig.getIndexConfigs().isEmpty())).count();\n+        return mapConfigs.stream().map(MapConfig::getIndexConfigs)\n+                .filter(indexConfigs -> !(indexConfigs.isEmpty())).count();\n     }\n \n     private long countMapWithHotRestartEnabled() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.getHotRestartConfig().isEnabled()).count();\n+        return mapConfigs.stream().map(MapConfig::getHotRestartConfig)\n+                .filter(HotRestartConfig::isEnabled).count();\n     }\n \n     private long countMapWithWANReplication() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.getWanReplicationRef() != null).count();\n+        return mapConfigs.stream().map(MapConfig::getWanReplicationRef)\n+                .filter(Objects::nonNull).count();\n     }\n \n     private long countMapWithAtleastOneAttribute() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && !(mapConfig.getAttributeConfigs().isEmpty())).count();\n+        return mapConfigs.stream().map(MapConfig::getAttributeConfigs)\n+                .filter(attributeConfigs -> !(attributeConfigs.isEmpty())).count();\n     }\n \n     private long countMapUsingEviction() {\n-        return mapConfigs.stream().filter(mapConfig -> mapConfig != null\n-                && mapConfig.getEvictionConfig().getEvictionPolicy() != EvictionPolicy.NONE).count();\n+        return mapConfigs.stream().map(MapConfig::getEvictionConfig)\n+                .filter(evictionConfig -> evictionConfig.getEvictionPolicy() != EvictionPolicy.NONE).count();\n     }\n \n     private long countMapWithNativeInMemoryFormat() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.getInMemoryFormat() == InMemoryFormat.NATIVE).count();\n+        return mapConfigs.stream().map(MapConfig::getInMemoryFormat)\n+                .filter(inMemoryFormat -> inMemoryFormat == InMemoryFormat.NATIVE).count();\n+    }\n+\n+    static class LatencyInfo {\n+        private Long totalLatency;\n+        private Long operationCount;\n+\n+        LatencyInfo(Long totalLatency, Long operationCount) {\n+            this.totalLatency = totalLatency;\n+            this.operationCount = operationCount;\n+        }\n+\n+        void add(Long totalLatency, Long operationCount) {\n+            this.totalLatency += totalLatency;\n+            this.operationCount += operationCount;\n+        }\n+\n+        Long calculateAverage() {\n+            return this.operationCount == 0 ? -1 : (this.totalLatency / this.operationCount);\n+        }\n+    }\n+\n+    Function<? super LocalMapStats, ? extends Long> mapStatsToGetLatency() {\n+        return LocalMapStats::getTotalGetLatency;\n+    }\n+\n+    Function<? super LocalMapStats, ? extends Long> mapStatsToGetOperationCount() {\n+        return LocalMapStats::getGetOperationCount;\n+    }\n+\n+    Function<? super LocalMapStats, ? extends Long> mapStatsToPutLatency() {\n+        return LocalMapStats::getTotalPutLatency;\n+    }\n+\n+    Function<? super LocalMapStats, ? extends Long> mapStatsToPutOperationCount() {\n+        return LocalMapStats::getPutOperationCount;\n+    }\n+\n+    private long mapOperationLatency(Node node, Predicate<MapConfig> predicate,\n+                                     Function<? super LocalMapStats, ? extends Long> latencyMap,\n+                                     Function<? super LocalMapStats, ? extends Long> operationMap) {", "originalCommit": "1c2cef72ded1a6cd6894a373620b29c46b8b01e2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU2NDA0NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17259#discussion_r466564045", "bodyText": "please use primitive long everywhere", "author": "erosb", "createdAt": "2020-08-06T17:17:34Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/util/phonehome/MapInfoCollector.java", "diffHunk": "@@ -55,52 +62,106 @@\n         mapInfo.put(\"mpaocct\", String.valueOf(countMapWithAtleastOneAttribute()));\n         mapInfo.put(\"mpevct\", String.valueOf(countMapUsingEviction()));\n         mapInfo.put(\"mpnmct\", String.valueOf(countMapWithNativeInMemoryFormat()));\n+        mapInfo.put(\"mpptlams\", String.valueOf(mapOperationLatency(hazelcastNode, IS_MAP_STORE_ENABLED,\n+                mapStatsToPutLatency(), mapStatsToPutOperationCount())));\n+        mapInfo.put(\"mpptla\", String.valueOf(mapOperationLatency(hazelcastNode, IS_MAP_STORE_ENABLED.negate(),\n+                mapStatsToPutLatency(), mapStatsToPutOperationCount())));\n+        mapInfo.put(\"mpgtlams\", String.valueOf(mapOperationLatency(hazelcastNode, IS_MAP_STORE_ENABLED,\n+                mapStatsToGetLatency(), mapStatsToGetOperationCount())));\n+        mapInfo.put(\"mpgtla\", String.valueOf(mapOperationLatency(hazelcastNode, IS_MAP_STORE_ENABLED.negate(),\n+                mapStatsToGetLatency(), mapStatsToGetOperationCount())));\n \n         return mapInfo;\n     }\n \n     private long countMapWithBackupReadEnabled() {\n         return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.isReadBackupData()).count();\n+                .filter(MapConfig::isReadBackupData).count();\n     }\n \n     private long countMapWithMapStoreEnabled() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.getMapStoreConfig().isEnabled()).count();\n+        return mapConfigs.stream().map(MapConfig::getMapStoreConfig)\n+                .filter(MapStoreConfig::isEnabled).count();\n     }\n \n     private long countMapWithAtleastOneQueryCache() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && !(mapConfig.getQueryCacheConfigs().isEmpty())).count();\n+        return mapConfigs.stream().map(MapConfig::getQueryCacheConfigs)\n+                .filter(queryCacheConfigs -> !(queryCacheConfigs.isEmpty())).count();\n     }\n \n     private long countMapWithAtleastOneIndex() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && !(mapConfig.getIndexConfigs().isEmpty())).count();\n+        return mapConfigs.stream().map(MapConfig::getIndexConfigs)\n+                .filter(indexConfigs -> !(indexConfigs.isEmpty())).count();\n     }\n \n     private long countMapWithHotRestartEnabled() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.getHotRestartConfig().isEnabled()).count();\n+        return mapConfigs.stream().map(MapConfig::getHotRestartConfig)\n+                .filter(HotRestartConfig::isEnabled).count();\n     }\n \n     private long countMapWithWANReplication() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.getWanReplicationRef() != null).count();\n+        return mapConfigs.stream().map(MapConfig::getWanReplicationRef)\n+                .filter(Objects::nonNull).count();\n     }\n \n     private long countMapWithAtleastOneAttribute() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && !(mapConfig.getAttributeConfigs().isEmpty())).count();\n+        return mapConfigs.stream().map(MapConfig::getAttributeConfigs)\n+                .filter(attributeConfigs -> !(attributeConfigs.isEmpty())).count();\n     }\n \n     private long countMapUsingEviction() {\n-        return mapConfigs.stream().filter(mapConfig -> mapConfig != null\n-                && mapConfig.getEvictionConfig().getEvictionPolicy() != EvictionPolicy.NONE).count();\n+        return mapConfigs.stream().map(MapConfig::getEvictionConfig)\n+                .filter(evictionConfig -> evictionConfig.getEvictionPolicy() != EvictionPolicy.NONE).count();\n     }\n \n     private long countMapWithNativeInMemoryFormat() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.getInMemoryFormat() == InMemoryFormat.NATIVE).count();\n+        return mapConfigs.stream().map(MapConfig::getInMemoryFormat)\n+                .filter(inMemoryFormat -> inMemoryFormat == InMemoryFormat.NATIVE).count();\n+    }\n+\n+    static class LatencyInfo {\n+        private Long totalLatency;\n+        private Long operationCount;\n+\n+        LatencyInfo(Long totalLatency, Long operationCount) {\n+            this.totalLatency = totalLatency;\n+            this.operationCount = operationCount;\n+        }\n+\n+        void add(Long totalLatency, Long operationCount) {", "originalCommit": "1c2cef72ded1a6cd6894a373620b29c46b8b01e2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU2NTAyNA==", "url": "https://github.com/hazelcast/hazelcast/pull/17259#discussion_r466565024", "bodyText": "These methods aren't very useful. I would just use LocalMapStats::getTotalLatency in #computeMetrics(). Same for the other 3 methods below.", "author": "erosb", "createdAt": "2020-08-06T17:18:47Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/util/phonehome/MapInfoCollector.java", "diffHunk": "@@ -55,52 +62,106 @@\n         mapInfo.put(\"mpaocct\", String.valueOf(countMapWithAtleastOneAttribute()));\n         mapInfo.put(\"mpevct\", String.valueOf(countMapUsingEviction()));\n         mapInfo.put(\"mpnmct\", String.valueOf(countMapWithNativeInMemoryFormat()));\n+        mapInfo.put(\"mpptlams\", String.valueOf(mapOperationLatency(hazelcastNode, IS_MAP_STORE_ENABLED,\n+                mapStatsToPutLatency(), mapStatsToPutOperationCount())));\n+        mapInfo.put(\"mpptla\", String.valueOf(mapOperationLatency(hazelcastNode, IS_MAP_STORE_ENABLED.negate(),\n+                mapStatsToPutLatency(), mapStatsToPutOperationCount())));\n+        mapInfo.put(\"mpgtlams\", String.valueOf(mapOperationLatency(hazelcastNode, IS_MAP_STORE_ENABLED,\n+                mapStatsToGetLatency(), mapStatsToGetOperationCount())));\n+        mapInfo.put(\"mpgtla\", String.valueOf(mapOperationLatency(hazelcastNode, IS_MAP_STORE_ENABLED.negate(),\n+                mapStatsToGetLatency(), mapStatsToGetOperationCount())));\n \n         return mapInfo;\n     }\n \n     private long countMapWithBackupReadEnabled() {\n         return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.isReadBackupData()).count();\n+                .filter(MapConfig::isReadBackupData).count();\n     }\n \n     private long countMapWithMapStoreEnabled() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.getMapStoreConfig().isEnabled()).count();\n+        return mapConfigs.stream().map(MapConfig::getMapStoreConfig)\n+                .filter(MapStoreConfig::isEnabled).count();\n     }\n \n     private long countMapWithAtleastOneQueryCache() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && !(mapConfig.getQueryCacheConfigs().isEmpty())).count();\n+        return mapConfigs.stream().map(MapConfig::getQueryCacheConfigs)\n+                .filter(queryCacheConfigs -> !(queryCacheConfigs.isEmpty())).count();\n     }\n \n     private long countMapWithAtleastOneIndex() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && !(mapConfig.getIndexConfigs().isEmpty())).count();\n+        return mapConfigs.stream().map(MapConfig::getIndexConfigs)\n+                .filter(indexConfigs -> !(indexConfigs.isEmpty())).count();\n     }\n \n     private long countMapWithHotRestartEnabled() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.getHotRestartConfig().isEnabled()).count();\n+        return mapConfigs.stream().map(MapConfig::getHotRestartConfig)\n+                .filter(HotRestartConfig::isEnabled).count();\n     }\n \n     private long countMapWithWANReplication() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.getWanReplicationRef() != null).count();\n+        return mapConfigs.stream().map(MapConfig::getWanReplicationRef)\n+                .filter(Objects::nonNull).count();\n     }\n \n     private long countMapWithAtleastOneAttribute() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && !(mapConfig.getAttributeConfigs().isEmpty())).count();\n+        return mapConfigs.stream().map(MapConfig::getAttributeConfigs)\n+                .filter(attributeConfigs -> !(attributeConfigs.isEmpty())).count();\n     }\n \n     private long countMapUsingEviction() {\n-        return mapConfigs.stream().filter(mapConfig -> mapConfig != null\n-                && mapConfig.getEvictionConfig().getEvictionPolicy() != EvictionPolicy.NONE).count();\n+        return mapConfigs.stream().map(MapConfig::getEvictionConfig)\n+                .filter(evictionConfig -> evictionConfig.getEvictionPolicy() != EvictionPolicy.NONE).count();\n     }\n \n     private long countMapWithNativeInMemoryFormat() {\n-        return mapConfigs.stream()\n-                .filter(mapConfig -> mapConfig != null && mapConfig.getInMemoryFormat() == InMemoryFormat.NATIVE).count();\n+        return mapConfigs.stream().map(MapConfig::getInMemoryFormat)\n+                .filter(inMemoryFormat -> inMemoryFormat == InMemoryFormat.NATIVE).count();\n+    }\n+\n+    static class LatencyInfo {\n+        private Long totalLatency;\n+        private Long operationCount;\n+\n+        LatencyInfo(Long totalLatency, Long operationCount) {\n+            this.totalLatency = totalLatency;\n+            this.operationCount = operationCount;\n+        }\n+\n+        void add(Long totalLatency, Long operationCount) {\n+            this.totalLatency += totalLatency;\n+            this.operationCount += operationCount;\n+        }\n+\n+        Long calculateAverage() {\n+            return this.operationCount == 0 ? -1 : (this.totalLatency / this.operationCount);\n+        }\n+    }\n+\n+    Function<? super LocalMapStats, ? extends Long> mapStatsToGetLatency() {", "originalCommit": "1c2cef72ded1a6cd6894a373620b29c46b8b01e2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f646b3a030329252ed50c17bf0b549e80ac3f350", "url": "https://github.com/hazelcast/hazelcast/commit/f646b3a030329252ed50c17bf0b549e80ac3f350", "message": "improve generic functions", "committedDate": "2020-08-06T17:41:34Z", "type": "commit"}]}