{"pr_number": 16876, "pr_title": "SQL: Service implementation", "pr_createdAt": "2020-04-09T16:55:54Z", "pr_url": "https://github.com/hazelcast/hazelcast/pull/16876", "timeline": [{"oid": "4df4cb0a579ac8f769faf9bf608cdb9e99cd5770", "url": "https://github.com/hazelcast/hazelcast/commit/4df4cb0a579ac8f769faf9bf608cdb9e99cd5770", "message": "Implemented IO.", "committedDate": "2020-04-03T14:55:28Z", "type": "commit"}, {"oid": "d499959ed41bcfa3e4b18c305cc9772187e76834", "url": "https://github.com/hazelcast/hazelcast/commit/d499959ed41bcfa3e4b18c305cc9772187e76834", "message": "Spotbugs errors.", "committedDate": "2020-04-03T17:44:36Z", "type": "commit"}, {"oid": "d5fb96b8adf08d6ce0cbc972cf102362f0c86742", "url": "https://github.com/hazelcast/hazelcast/commit/d5fb96b8adf08d6ce0cbc972cf102362f0c86742", "message": "Minor refactoring to tests.", "committedDate": "2020-04-03T18:18:25Z", "type": "commit"}, {"oid": "bcf20e41b549eb6c2516db9dc7253804b61ec454", "url": "https://github.com/hazelcast/hazelcast/commit/bcf20e41b549eb6c2516db9dc7253804b61ec454", "message": "Merge branch 'master' into issues/16838", "committedDate": "2020-04-06T13:55:29Z", "type": "commit"}, {"oid": "0f20bab36a8a19634a93a6cd8f5c25c406377f18", "url": "https://github.com/hazelcast/hazelcast/commit/0f20bab36a8a19634a93a6cd8f5c25c406377f18", "message": "Fixed typos and unrelated checkstyle issue.", "committedDate": "2020-04-06T13:56:31Z", "type": "commit"}, {"oid": "8981ce0dfee45d57748ea8b9516ecabc21db4865", "url": "https://github.com/hazelcast/hazelcast/commit/8981ce0dfee45d57748ea8b9516ecabc21db4865", "message": "Merge branch 'master' into issues/16838\n\n# Conflicts:\n#\thazelcast/src/main/java/com/hazelcast/client/impl/protocol/task/map/MapPutAllMessageTask.java", "committedDate": "2020-04-07T07:14:09Z", "type": "commit"}, {"oid": "5e1efccb7f2762026945206f7dd3030c5ded983d", "url": "https://github.com/hazelcast/hazelcast/commit/5e1efccb7f2762026945206f7dd3030c5ded983d", "message": "Review comments.", "committedDate": "2020-04-07T10:27:51Z", "type": "commit"}, {"oid": "c517c013679d5d5e94f2231fbbedee569a20eac5", "url": "https://github.com/hazelcast/hazelcast/commit/c517c013679d5d5e94f2231fbbedee569a20eac5", "message": "WIP", "committedDate": "2020-04-07T10:41:12Z", "type": "commit"}, {"oid": "98aa2fbd6d2f760ccf228a33b41ef1baed7e2d75", "url": "https://github.com/hazelcast/hazelcast/commit/98aa2fbd6d2f760ccf228a33b41ef1baed7e2d75", "message": "WIP.", "committedDate": "2020-04-07T11:18:07Z", "type": "commit"}, {"oid": "e944c1a577ce33314b8b085f3d6093b4ec964183", "url": "https://github.com/hazelcast/hazelcast/commit/e944c1a577ce33314b8b085f3d6093b4ec964183", "message": "WIP.", "committedDate": "2020-04-07T11:39:22Z", "type": "commit"}, {"oid": "c4036eede209c53b1f2f6e965e3a32253e9c24d1", "url": "https://github.com/hazelcast/hazelcast/commit/c4036eede209c53b1f2f6e965e3a32253e9c24d1", "message": "Compilation and existing tests pass.", "committedDate": "2020-04-07T12:09:58Z", "type": "commit"}, {"oid": "773cd045bec691d71ae2050b80f1efc7e3d41cfd", "url": "https://github.com/hazelcast/hazelcast/commit/773cd045bec691d71ae2050b80f1efc7e3d41cfd", "message": "Merge branch 'master' into sql-service\n\n# Conflicts:\n#\thazelcast/src/main/java/com/hazelcast/sql/HazelcastSqlException.java\n#\thazelcast/src/main/java/com/hazelcast/sql/SqlErrorCode.java\n#\thazelcast/src/main/java/com/hazelcast/sql/impl/exec/CreateExecPlanNodeVisitor.java\n#\thazelcast/src/main/java/com/hazelcast/sql/impl/exec/io/AbstractInbox.java\n#\thazelcast/src/main/java/com/hazelcast/sql/impl/exec/io/AbstractMailbox.java\n#\thazelcast/src/main/java/com/hazelcast/sql/impl/exec/io/Inbox.java\n#\thazelcast/src/main/java/com/hazelcast/sql/impl/exec/io/Outbox.java\n#\thazelcast/src/main/java/com/hazelcast/sql/impl/exec/io/flowcontrol/FlowControl.java\n#\thazelcast/src/main/java/com/hazelcast/sql/impl/exec/io/flowcontrol/simple/SimpleFlowControl.java\n#\thazelcast/src/main/java/com/hazelcast/sql/impl/operation/QueryExecuteOperation.java\n#\thazelcast/src/main/java/com/hazelcast/sql/impl/operation/QueryExecuteOperationFragmentMapping.java\n#\thazelcast/src/main/java/com/hazelcast/sql/impl/operation/QueryOperationHandler.java\n#\thazelcast/src/test/java/com/hazelcast/sql/impl/FaultyQueryOperationHandler.java\n#\thazelcast/src/test/java/com/hazelcast/sql/impl/LoggingFlowControl.java\n#\thazelcast/src/test/java/com/hazelcast/sql/impl/LoggingQueryOperationHandler.java\n#\thazelcast/src/test/java/com/hazelcast/sql/impl/exec/CreateExecPlanNodeVisitorTest.java\n#\thazelcast/src/test/java/com/hazelcast/sql/impl/exec/io/InboxTest.java\n#\thazelcast/src/test/java/com/hazelcast/sql/impl/exec/io/OutboxTest.java\n#\thazelcast/src/test/java/com/hazelcast/sql/impl/exec/io/ReceiveExecTest.java\n#\thazelcast/src/test/java/com/hazelcast/sql/impl/exec/io/SendExecTest.java\n#\thazelcast/src/test/java/com/hazelcast/sql/impl/exec/io/flowcontrol/simple/SimpleFlowControlTest.java\n#\thazelcast/src/test/java/com/hazelcast/sql/impl/worker/QueryOperationWorkerPoolTest.java", "committedDate": "2020-04-07T14:58:10Z", "type": "commit"}, {"oid": "1479a8d86f23c894e822c1b932a2624be63893a3", "url": "https://github.com/hazelcast/hazelcast/commit/1479a8d86f23c894e822c1b932a2624be63893a3", "message": "Merged master.", "committedDate": "2020-04-07T14:59:37Z", "type": "commit"}, {"oid": "bab503b4957b1927faf9ca34c73daa256134470d", "url": "https://github.com/hazelcast/hazelcast/commit/bab503b4957b1927faf9ca34c73daa256134470d", "message": "Minors.", "committedDate": "2020-04-08T07:30:05Z", "type": "commit"}, {"oid": "4c9ecd52ad39d0b1d7d08de3a57e31d505e102d9", "url": "https://github.com/hazelcast/hazelcast/commit/4c9ecd52ad39d0b1d7d08de3a57e31d505e102d9", "message": "Moved query exception.", "committedDate": "2020-04-08T09:26:54Z", "type": "commit"}, {"oid": "61610a3e271e58285275e316f0e0cddb6bd47d9e", "url": "https://github.com/hazelcast/hazelcast/commit/61610a3e271e58285275e316f0e0cddb6bd47d9e", "message": "Minors.", "committedDate": "2020-04-08T09:52:34Z", "type": "commit"}, {"oid": "41ff3fbb9b503729e22bab27eae03426325d579a", "url": "https://github.com/hazelcast/hazelcast/commit/41ff3fbb9b503729e22bab27eae03426325d579a", "message": "Removed PlanFragment.", "committedDate": "2020-04-08T10:24:31Z", "type": "commit"}, {"oid": "75c3d2cf8475dc9cd5e897359169ab2805bc7769", "url": "https://github.com/hazelcast/hazelcast/commit/75c3d2cf8475dc9cd5e897359169ab2805bc7769", "message": "WIP.", "committedDate": "2020-04-08T11:34:45Z", "type": "commit"}, {"oid": "39faafcf15fc84456a92eb8622961d1308819e38", "url": "https://github.com/hazelcast/hazelcast/commit/39faafcf15fc84456a92eb8622961d1308819e38", "message": "WIP on tests.", "committedDate": "2020-04-08T11:57:13Z", "type": "commit"}, {"oid": "f9ff7a88b8ab92a87882c1718409ce55e1542804", "url": "https://github.com/hazelcast/hazelcast/commit/f9ff7a88b8ab92a87882c1718409ce55e1542804", "message": "WIP on tests.", "committedDate": "2020-04-08T12:15:17Z", "type": "commit"}, {"oid": "eb4b431bdf206d7ed08df1e563fe25f2e29e6116", "url": "https://github.com/hazelcast/hazelcast/commit/eb4b431bdf206d7ed08df1e563fe25f2e29e6116", "message": "Cleanup.", "committedDate": "2020-04-08T12:26:42Z", "type": "commit"}, {"oid": "6ea63ceb33a70d15b470ed6ab35c8de971f7422d", "url": "https://github.com/hazelcast/hazelcast/commit/6ea63ceb33a70d15b470ed6ab35c8de971f7422d", "message": "WIP.", "committedDate": "2020-04-08T12:37:50Z", "type": "commit"}, {"oid": "cc582ffa321fbc3a6ecbcaa88b7b4d4f0caad8c8", "url": "https://github.com/hazelcast/hazelcast/commit/cc582ffa321fbc3a6ecbcaa88b7b4d4f0caad8c8", "message": "WIP.", "committedDate": "2020-04-08T12:47:32Z", "type": "commit"}, {"oid": "71661ae93640410a727820e237950b6019e90b30", "url": "https://github.com/hazelcast/hazelcast/commit/71661ae93640410a727820e237950b6019e90b30", "message": "WIP.", "committedDate": "2020-04-08T15:01:35Z", "type": "commit"}, {"oid": "63a1c5c70ef7777784193d112ee99b7767167d2f", "url": "https://github.com/hazelcast/hazelcast/commit/63a1c5c70ef7777784193d112ee99b7767167d2f", "message": "Registry tests.", "committedDate": "2020-04-09T07:16:01Z", "type": "commit"}, {"oid": "6aee050edec293680bd5d5ae02f42a234dc3b6ea", "url": "https://github.com/hazelcast/hazelcast/commit/6aee050edec293680bd5d5ae02f42a234dc3b6ea", "message": "WIP.", "committedDate": "2020-04-09T08:46:47Z", "type": "commit"}, {"oid": "a183377424a3dea7671358d47d8e60ae339b8c05", "url": "https://github.com/hazelcast/hazelcast/commit/a183377424a3dea7671358d47d8e60ae339b8c05", "message": "WIP.", "committedDate": "2020-04-09T09:02:42Z", "type": "commit"}, {"oid": "170a983da43e5875077936517eaa3f8cd93a3b33", "url": "https://github.com/hazelcast/hazelcast/commit/170a983da43e5875077936517eaa3f8cd93a3b33", "message": "WIP.", "committedDate": "2020-04-09T10:06:42Z", "type": "commit"}, {"oid": "867b0f349a58922e1731f4eed0580186adc9da7d", "url": "https://github.com/hazelcast/hazelcast/commit/867b0f349a58922e1731f4eed0580186adc9da7d", "message": "WIP.", "committedDate": "2020-04-09T14:12:27Z", "type": "commit"}, {"oid": "8ea279d031fb6df03d4cb3b672645a95901e9447", "url": "https://github.com/hazelcast/hazelcast/commit/8ea279d031fb6df03d4cb3b672645a95901e9447", "message": "Tests for operations reordering.", "committedDate": "2020-04-09T15:16:56Z", "type": "commit"}, {"oid": "e068569fbdcfaaa1cfd185e5021e49145035fb07", "url": "https://github.com/hazelcast/hazelcast/commit/e068569fbdcfaaa1cfd185e5021e49145035fb07", "message": "Simplifying.", "committedDate": "2020-04-09T15:39:02Z", "type": "commit"}, {"oid": "e2f659559a56f6465ec459cb6b34969373bcbedf", "url": "https://github.com/hazelcast/hazelcast/commit/e2f659559a56f6465ec459cb6b34969373bcbedf", "message": "WIP.", "committedDate": "2020-04-09T15:39:40Z", "type": "commit"}, {"oid": "2f2f1137b4e6a5f3643b84e8b7a88167660950a9", "url": "https://github.com/hazelcast/hazelcast/commit/2f2f1137b4e6a5f3643b84e8b7a88167660950a9", "message": "Ready to add initiator.", "committedDate": "2020-04-09T15:45:43Z", "type": "commit"}, {"oid": "cc5b85aef95d2ad7406f9733b3eeeb12215e11d5", "url": "https://github.com/hazelcast/hazelcast/commit/cc5b85aef95d2ad7406f9733b3eeeb12215e11d5", "message": "WIP.", "committedDate": "2020-04-09T15:52:30Z", "type": "commit"}, {"oid": "7a72085126d8f5a349a76bfa915722f8ad529fc0", "url": "https://github.com/hazelcast/hazelcast/commit/7a72085126d8f5a349a76bfa915722f8ad529fc0", "message": "WIP.", "committedDate": "2020-04-09T15:55:29Z", "type": "commit"}, {"oid": "1a755b8d24f4f4a8beae96c4a4537bbda387276e", "url": "https://github.com/hazelcast/hazelcast/commit/1a755b8d24f4f4a8beae96c4a4537bbda387276e", "message": "WIP on member leaves.", "committedDate": "2020-04-09T16:12:22Z", "type": "commit"}, {"oid": "cbf353ea9108ead492628eb10b2ab275742c383b", "url": "https://github.com/hazelcast/hazelcast/commit/cbf353ea9108ead492628eb10b2ab275742c383b", "message": "WIP.", "committedDate": "2020-04-09T16:15:29Z", "type": "commit"}, {"oid": "68e432c6e3d38f73e8f10616936bb511c3976194", "url": "https://github.com/hazelcast/hazelcast/commit/68e432c6e3d38f73e8f10616936bb511c3976194", "message": "Done with complex tests.", "committedDate": "2020-04-09T16:22:21Z", "type": "commit"}, {"oid": "93620b8ddbf7cdb8dd555f9cfa063584e694702e", "url": "https://github.com/hazelcast/hazelcast/commit/93620b8ddbf7cdb8dd555f9cfa063584e694702e", "message": "Done with tests.", "committedDate": "2020-04-09T16:37:20Z", "type": "commit"}, {"oid": "74d18775daac5037e9ba1c2677165db5296fed9d", "url": "https://github.com/hazelcast/hazelcast/commit/74d18775daac5037e9ba1c2677165db5296fed9d", "message": "Checkstyle.", "committedDate": "2020-04-09T16:41:26Z", "type": "commit"}, {"oid": "a7d5edd3d961c8cfdb734594874910a749616881", "url": "https://github.com/hazelcast/hazelcast/commit/a7d5edd3d961c8cfdb734594874910a749616881", "message": "Merge branch 'master' into issues/16863", "committedDate": "2020-04-09T17:02:07Z", "type": "commit"}, {"oid": "516ae365346ed0a1c13686568c833b7e46c95b30", "url": "https://github.com/hazelcast/hazelcast/commit/516ae365346ed0a1c13686568c833b7e46c95b30", "message": "Merge with master.", "committedDate": "2020-04-09T17:06:24Z", "type": "commit"}, {"oid": "100bf7b6a2ce5e4d0cffb0ff4c65a10e29576892", "url": "https://github.com/hazelcast/hazelcast/commit/100bf7b6a2ce5e4d0cffb0ff4c65a10e29576892", "message": "Checkstyle.", "committedDate": "2020-04-09T17:07:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY0MTEzNA==", "url": "https://github.com/hazelcast/hazelcast/pull/16876#discussion_r406641134", "bodyText": "Minor: \"since\"", "author": "taburet", "createdAt": "2020-04-10T07:33:16Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/ClockProvider.java", "diffHunk": "@@ -0,0 +1,27 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl;\n+\n+/**\n+ * Clock provider.\n+ */\n+public interface ClockProvider {\n+    /**\n+     * @return Current time sinct epoch in millis.", "originalCommit": "100bf7b6a2ce5e4d0cffb0ff4c65a10e29576892", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY0OTEwNw==", "url": "https://github.com/hazelcast/hazelcast/pull/16876#discussion_r406649107", "bodyText": "Fixed", "author": "devozerov", "createdAt": "2020-04-10T07:56:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY0MTEzNA=="}], "type": "inlineReview"}, {"oid": "dbcb768c1c3145959a5c175a0c1498a0d5686ff2", "url": "https://github.com/hazelcast/hazelcast/commit/dbcb768c1c3145959a5c175a0c1498a0d5686ff2", "message": "Typo.", "committedDate": "2020-04-10T07:56:24Z", "type": "commit"}, {"oid": "09f0c58b2f5a6994ae2a9cc07a37ae06efbd1275", "url": "https://github.com/hazelcast/hazelcast/commit/09f0c58b2f5a6994ae2a9cc07a37ae06efbd1275", "message": "Minor test fixes.", "committedDate": "2020-04-10T08:22:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY3NTExOA==", "url": "https://github.com/hazelcast/hazelcast/pull/16876#discussion_r406675118", "bodyText": "Not sure, what condition absence of a member in the member list indicates?", "author": "taburet", "createdAt": "2020-04-10T09:10:51Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/operation/QueryExecuteOperationFactory.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.operation;\n+\n+import com.hazelcast.sql.impl.QueryId;\n+import com.hazelcast.sql.impl.plan.Plan;\n+import com.hazelcast.sql.impl.plan.PlanFragmentMapping;\n+import com.hazelcast.sql.impl.plan.node.PlanNode;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+\n+import static com.hazelcast.sql.impl.operation.QueryExecuteOperationFragmentMapping.DATA_MEMBERS;\n+import static com.hazelcast.sql.impl.operation.QueryExecuteOperationFragmentMapping.EXPLICIT;\n+\n+/**\n+ * Factory to create query execute operations.\n+ */\n+public class QueryExecuteOperationFactory {\n+\n+    private final Plan plan;\n+    private final List<Object> args;\n+    private final Map<Integer, Long> edgeInitialMemoryMap;\n+\n+    public QueryExecuteOperationFactory(\n+        Plan plan,\n+        List<Object> args,\n+        Map<Integer, Long> edgeInitialMemoryMap\n+    ) {\n+        this.plan = plan;\n+        this.args = args;\n+        this.edgeInitialMemoryMap = edgeInitialMemoryMap;\n+    }\n+\n+    public QueryExecuteOperation create(QueryId queryId, UUID targetMemberId) {\n+        int fragmentCount = plan.getFragmentCount();\n+\n+        // Prepare descriptors.\n+        List<QueryExecuteOperationFragment> fragments = new ArrayList<>(fragmentCount);\n+\n+        for (int i = 0; i < fragmentCount; i++) {\n+            PlanFragmentMapping planMapping = plan.getFragmentMapping(i);\n+\n+            QueryExecuteOperationFragmentMapping mapping;\n+            Collection<UUID> memberIds;\n+            PlanNode node;\n+\n+            if (planMapping.isDataMembers()) {\n+                mapping = DATA_MEMBERS;\n+                memberIds = null;\n+                node = plan.getFragment(i);\n+            } else {\n+                mapping = EXPLICIT;\n+                memberIds = planMapping.getMemberIds();\n+                node = memberIds.contains(targetMemberId) ? plan.getFragment(i) : null;", "originalCommit": "09f0c58b2f5a6994ae2a9cc07a37ae06efbd1275", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY3NzIwNw==", "url": "https://github.com/hazelcast/hazelcast/pull/16876#discussion_r406677207", "bodyText": "The EXPLICIT mapping means that we defined the list of nodes where a fragment should be executed. If the member is not in the list, then the fragment should not be executed on it. We indicate the condition \"do not execute that fragment on that node\" via node == null.", "author": "devozerov", "createdAt": "2020-04-10T09:16:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY3NTExOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY4MDAzNw==", "url": "https://github.com/hazelcast/hazelcast/pull/16876#discussion_r406680037", "bodyText": "In 4.1 we will have only one example of such a fragment - root fragment.", "author": "devozerov", "createdAt": "2020-04-10T09:24:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY3NTExOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY4NzEyNA==", "url": "https://github.com/hazelcast/hazelcast/pull/16876#discussion_r406687124", "bodyText": "Probably I'm getting something wrong, but the only thing we do with fragments having null plan is skipping them: https://github.com/hazelcast/hazelcast/pull/16876/files#diff-a72004010c5a07d55b4d36beeb25828bR184, should we just skip their creation?", "author": "taburet", "createdAt": "2020-04-10T09:45:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY3NTExOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY5MTc4MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16876#discussion_r406691781", "bodyText": "The fragment is defined by a node to be executed and target members. In order to set up streams between send and receive fragments, we need to know the number of inputs and outputs for every edge. E.g. a Receiver[member1, member2] must know that it communicates with Sender[member1, member2, member3], and therefore it should wait for 3 end markers. So we use the QueryExecuteOperationFragment not only to pass the PlanNode but mapping information as well, that is needed by IO nodes.\nYou may see it in action in the usages of CreateExecPlanNodeVisitor.getFragmentMembers - sender gets information about receiver and vice versa.", "author": "devozerov", "createdAt": "2020-04-10T09:59:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY3NTExOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzMzOTk4NA==", "url": "https://github.com/hazelcast/hazelcast/pull/16876#discussion_r407339984", "bodyText": "I see, probably that worth a mention somewhere in QueryExecuteOperationFragment javadoc, so one can easily understand that fragments having nothing to execute (PlanNode is null) are valid and what their purpose is.", "author": "taburet", "createdAt": "2020-04-13T06:31:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY3NTExOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzQyMTYzOQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16876#discussion_r407421639", "bodyText": "Added JavaDoc.", "author": "devozerov", "createdAt": "2020-04-13T10:39:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY3NTExOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc2MjgzOA==", "url": "https://github.com/hazelcast/hazelcast/pull/16876#discussion_r406762838", "bodyText": "Something for consideration in this or further PRs: sending a packet of a new type to a mixed version cluster (eg during rolling upgrade from 4.0 to 4.1 while cluster is still operating at cluster version 4.0) will result in 4.0 members logging SEVERE entries (from PacketDispatcher's default case). So whenever new-SQL packets are involved, we should always gate logic on cluster version being at least equal to 4.1.", "author": "vbekiaris", "createdAt": "2020-04-10T13:42:48Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/nio/Packet.java", "diffHunk": "@@ -309,11 +309,11 @@ public String describeFlags(char flags) {\n          */\n         MEMBER_HANDSHAKE,\n         /**\n-         * Unused packet type. Available for future use.\n+         * The type of an SQL packet.\n          * <p>\n          * {@code ordinal = 5}\n          */\n-        UNDEFINED5,\n+        SQL,", "originalCommit": "09f0c58b2f5a6994ae2a9cc07a37ae06efbd1275", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc5Njk4OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16876#discussion_r406796989", "bodyText": "We are going to implement compatibility checks separately. How it is going to work:\n\nAfter an SQL query is received we create the plan for it (or get it from cache)\nA plan has a fixed list of members where it is supposed to be executed (Plan.getMemberIds())\nWhen a plan is created we will check whether members' version is valid for the plan. If not - an exception will be thrown\n\nThe problem is that we do not have the code that creates the plan yet. It is part of Calcite integration, which is yet to be merged.\nSo our plan is to add this validation logic during Calcite integration.", "author": "devozerov", "createdAt": "2020-04-10T15:01:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc2MjgzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc3NzgxMQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16876#discussion_r406777811", "bodyText": "nit: Proxy in general is used to describe remote objects' implementation (eg. IMap -> MapProxyImpl, ITopic -> ReliableTopicProxy). Also, consider extracting an interface for SqlService, it will be a lot easier to run compatibility tests, if those tests need access to the SqlService.", "author": "vbekiaris", "createdAt": "2020-04-10T14:18:27Z", "path": "hazelcast/src/main/java/com/hazelcast/spi/impl/NodeEngine.java", "diffHunk": "@@ -114,6 +115,13 @@\n      */\n     SplitBrainProtectionService getSplitBrainProtectionService();\n \n+    /**\n+     * Gets SQL service.\n+     *\n+     * @return the SQL service\n+     */\n+    SqlServiceProxy getSqlService();", "originalCommit": "09f0c58b2f5a6994ae2a9cc07a37ae06efbd1275", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc5NDQzMg==", "url": "https://github.com/hazelcast/hazelcast/pull/16876#discussion_r406794432", "bodyText": "SqlServiceProxy is renamed to SqlServiceImpl\nThe interface part of this service is public API, which is going to be implemented in a separate ticket. So we cannot extract anything at the moment, otherwise, it will be an empty interface in the public API package. So instead I removed the method from NodeEngine, because we simply do not need it before the public API is implemented.", "author": "devozerov", "createdAt": "2020-04-10T14:55:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc3NzgxMQ=="}], "type": "inlineReview"}, {"oid": "5613a5c711231d0444fe8e01670063cdc2071c86", "url": "https://github.com/hazelcast/hazelcast/commit/5613a5c711231d0444fe8e01670063cdc2071c86", "message": "SqlServiceProxy -> SqlServiceImpl", "committedDate": "2020-04-10T14:52:19Z", "type": "commit"}, {"oid": "801da4e8e20b1ef5d34a954a2c5440630040c302", "url": "https://github.com/hazelcast/hazelcast/commit/801da4e8e20b1ef5d34a954a2c5440630040c302", "message": "Removed SqlService from NodeEngine.", "committedDate": "2020-04-10T14:53:47Z", "type": "commit"}, {"oid": "47f15d094f7890021186f01248d279746819a94b", "url": "https://github.com/hazelcast/hazelcast/commit/47f15d094f7890021186f01248d279746819a94b", "message": "JavaDoc.", "committedDate": "2020-04-13T10:39:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODgyNzU4Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/16876#discussion_r408827582", "bodyText": "And -> An ?", "author": "petrpleshachkov", "createdAt": "2020-04-15T13:08:59Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/LocalMemberIdProvider.java", "diffHunk": "@@ -0,0 +1,29 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl;\n+\n+import java.util.UUID;\n+\n+/**\n+ * And interface to get local member ID. We use it to avoid passing {@link com.hazelcast.spi.impl.NodeEngine} everywhere.", "originalCommit": "47f15d094f7890021186f01248d279746819a94b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODg2MzUxNg==", "url": "https://github.com/hazelcast/hazelcast/pull/16876#discussion_r408863516", "bodyText": "Fixed.", "author": "devozerov", "createdAt": "2020-04-15T13:58:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODgyNzU4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODgzNTk3NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16876#discussion_r408835975", "bodyText": "Do we plan to handle such sort of exceptions somewhere on the higher level to hide it from the user?", "author": "petrpleshachkov", "createdAt": "2020-04-15T13:21:41Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/SqlInternalService.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl;\n+\n+import com.hazelcast.internal.nio.Packet;\n+import com.hazelcast.internal.serialization.InternalSerializationService;\n+import com.hazelcast.sql.impl.exec.io.flowcontrol.FlowControlFactory;\n+import com.hazelcast.sql.impl.exec.io.flowcontrol.simple.SimpleFlowControlFactory;\n+import com.hazelcast.sql.impl.exec.root.BlockingRootResultConsumer;\n+import com.hazelcast.sql.impl.operation.QueryExecuteOperation;\n+import com.hazelcast.sql.impl.operation.QueryExecuteOperationFactory;\n+import com.hazelcast.sql.impl.operation.QueryOperationHandlerImpl;\n+import com.hazelcast.sql.impl.plan.Plan;\n+import com.hazelcast.sql.impl.state.QueryState;\n+import com.hazelcast.sql.impl.state.QueryStateRegistry;\n+import com.hazelcast.sql.impl.state.QueryStateRegistryUpdater;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+\n+/**\n+ * Proxy for SQL service. Backed by either Calcite-based or no-op implementation.\n+ */\n+public class SqlInternalService {\n+    /** Memory assigned to a single edge mailbox. Will be reworked to dynamic mode when memory manager is implemented. */\n+    private static final long MEMORY_PER_EDGE_MAILBOX = 512 * 1024;\n+\n+    /** Default flow control factory. */\n+    private static final FlowControlFactory FLOW_CONTROL_FACTORY = SimpleFlowControlFactory.INSTANCE;\n+\n+    /** Node service provider. */\n+    private final NodeServiceProvider nodeServiceProvider;\n+\n+    /** Registry for running queries. */\n+    private final QueryStateRegistry stateRegistry;\n+\n+    /** Operation manager. */\n+    private final QueryOperationHandlerImpl operationHandler;\n+\n+    /** State registry updater. */\n+    private final QueryStateRegistryUpdater stateRegistryUpdater;\n+\n+    public SqlInternalService(\n+        String instanceName,\n+        NodeServiceProvider nodeServiceProvider,\n+        InternalSerializationService serializationService,\n+        int operationThreadCount,\n+        int fragmentThreadCount,\n+        int outboxBatchSize,\n+        long stateCheckFrequency\n+    ) {\n+        this.nodeServiceProvider = nodeServiceProvider;\n+\n+        // Create state registries since they do not depend on anything.\n+        stateRegistry = new QueryStateRegistry(nodeServiceProvider);\n+\n+        // Operation handler depends on state registry.\n+        operationHandler = new QueryOperationHandlerImpl(\n+            instanceName,\n+            nodeServiceProvider,\n+            serializationService,\n+            stateRegistry,\n+            outboxBatchSize,\n+            FLOW_CONTROL_FACTORY,\n+            fragmentThreadCount,\n+            operationThreadCount\n+        );\n+\n+        // State checker depends on state registries and operation handler.\n+        stateRegistryUpdater = new QueryStateRegistryUpdater(\n+            instanceName,\n+            nodeServiceProvider,\n+            stateRegistry,\n+            operationHandler,\n+            stateCheckFrequency\n+        );\n+    }\n+\n+    public void start() {\n+        stateRegistryUpdater.start();\n+    }\n+\n+    public void reset() {\n+        stateRegistry.reset();\n+    }\n+\n+    public void shutdown() {\n+        stateRegistryUpdater.stop();\n+        operationHandler.stop();\n+\n+        reset();\n+    }\n+\n+    /**\n+     * Internal query execution routine.\n+     *\n+     * @return Query state.\n+     */\n+    public QueryState execute(Plan plan, List<Object> params, long timeout, int pageSize) {\n+        // Get local member ID and check if it is still part of the plan.\n+        UUID localMemberId = nodeServiceProvider.getLocalMemberId();\n+\n+        if (!plan.getPartitionMap().containsKey(localMemberId)) {\n+            throw QueryException.memberLeave(localMemberId);", "originalCommit": "47f15d094f7890021186f01248d279746819a94b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODg2MTEzOA==", "url": "https://github.com/hazelcast/hazelcast/pull/16876#discussion_r408861138", "bodyText": "Yes, all exceptions are propagated upwards and will be handled similarly in two places - API entry point and cursor returned from API. You may see it in action in the prototype branch. This is not part of the current PR, because we do not have API yet.", "author": "devozerov", "createdAt": "2020-04-15T13:55:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODgzNTk3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODgzNzQ1Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/16876#discussion_r408837457", "bodyText": "Shall we log the exception here?", "author": "petrpleshachkov", "createdAt": "2020-04-15T13:23:52Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/SqlInternalService.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl;\n+\n+import com.hazelcast.internal.nio.Packet;\n+import com.hazelcast.internal.serialization.InternalSerializationService;\n+import com.hazelcast.sql.impl.exec.io.flowcontrol.FlowControlFactory;\n+import com.hazelcast.sql.impl.exec.io.flowcontrol.simple.SimpleFlowControlFactory;\n+import com.hazelcast.sql.impl.exec.root.BlockingRootResultConsumer;\n+import com.hazelcast.sql.impl.operation.QueryExecuteOperation;\n+import com.hazelcast.sql.impl.operation.QueryExecuteOperationFactory;\n+import com.hazelcast.sql.impl.operation.QueryOperationHandlerImpl;\n+import com.hazelcast.sql.impl.plan.Plan;\n+import com.hazelcast.sql.impl.state.QueryState;\n+import com.hazelcast.sql.impl.state.QueryStateRegistry;\n+import com.hazelcast.sql.impl.state.QueryStateRegistryUpdater;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+\n+/**\n+ * Proxy for SQL service. Backed by either Calcite-based or no-op implementation.\n+ */\n+public class SqlInternalService {\n+    /** Memory assigned to a single edge mailbox. Will be reworked to dynamic mode when memory manager is implemented. */\n+    private static final long MEMORY_PER_EDGE_MAILBOX = 512 * 1024;\n+\n+    /** Default flow control factory. */\n+    private static final FlowControlFactory FLOW_CONTROL_FACTORY = SimpleFlowControlFactory.INSTANCE;\n+\n+    /** Node service provider. */\n+    private final NodeServiceProvider nodeServiceProvider;\n+\n+    /** Registry for running queries. */\n+    private final QueryStateRegistry stateRegistry;\n+\n+    /** Operation manager. */\n+    private final QueryOperationHandlerImpl operationHandler;\n+\n+    /** State registry updater. */\n+    private final QueryStateRegistryUpdater stateRegistryUpdater;\n+\n+    public SqlInternalService(\n+        String instanceName,\n+        NodeServiceProvider nodeServiceProvider,\n+        InternalSerializationService serializationService,\n+        int operationThreadCount,\n+        int fragmentThreadCount,\n+        int outboxBatchSize,\n+        long stateCheckFrequency\n+    ) {\n+        this.nodeServiceProvider = nodeServiceProvider;\n+\n+        // Create state registries since they do not depend on anything.\n+        stateRegistry = new QueryStateRegistry(nodeServiceProvider);\n+\n+        // Operation handler depends on state registry.\n+        operationHandler = new QueryOperationHandlerImpl(\n+            instanceName,\n+            nodeServiceProvider,\n+            serializationService,\n+            stateRegistry,\n+            outboxBatchSize,\n+            FLOW_CONTROL_FACTORY,\n+            fragmentThreadCount,\n+            operationThreadCount\n+        );\n+\n+        // State checker depends on state registries and operation handler.\n+        stateRegistryUpdater = new QueryStateRegistryUpdater(\n+            instanceName,\n+            nodeServiceProvider,\n+            stateRegistry,\n+            operationHandler,\n+            stateCheckFrequency\n+        );\n+    }\n+\n+    public void start() {\n+        stateRegistryUpdater.start();\n+    }\n+\n+    public void reset() {\n+        stateRegistry.reset();\n+    }\n+\n+    public void shutdown() {\n+        stateRegistryUpdater.stop();\n+        operationHandler.stop();\n+\n+        reset();\n+    }\n+\n+    /**\n+     * Internal query execution routine.\n+     *\n+     * @return Query state.\n+     */\n+    public QueryState execute(Plan plan, List<Object> params, long timeout, int pageSize) {\n+        // Get local member ID and check if it is still part of the plan.\n+        UUID localMemberId = nodeServiceProvider.getLocalMemberId();\n+\n+        if (!plan.getPartitionMap().containsKey(localMemberId)) {\n+            throw QueryException.memberLeave(localMemberId);\n+        }\n+\n+        // Prepare mappings.\n+        QueryExecuteOperationFactory operationFactory = new QueryExecuteOperationFactory(\n+            plan,\n+            params,\n+            createEdgeInitialMemoryMapForPlan(plan)\n+        );\n+\n+        // Register the state.\n+        BlockingRootResultConsumer consumer = new BlockingRootResultConsumer();\n+\n+        QueryState state = stateRegistry.onInitiatorQueryStarted(\n+            localMemberId,\n+            timeout,\n+            plan,\n+            consumer,\n+            operationHandler,\n+            true\n+        );\n+\n+        try {\n+            // Start execution on local member.\n+            QueryExecuteOperation localOp = operationFactory.create(state.getQueryId(), localMemberId);\n+\n+            localOp.setRootConsumer(consumer, pageSize);\n+\n+            operationHandler.submitLocal(localMemberId, localOp);\n+\n+            // Start execution on remote members.\n+            for (UUID memberId : plan.getMemberIds()) {\n+                if (memberId.equals(localMemberId)) {\n+                    continue;\n+                }\n+\n+                QueryExecuteOperation remoteOp = operationFactory.create(state.getQueryId(), memberId);\n+\n+                if (!operationHandler.submit(localMemberId, memberId, remoteOp)) {\n+                    throw QueryException.memberConnection(memberId);\n+                }\n+            }\n+\n+            return state;\n+        } catch (Exception e) {\n+            state.cancel(e);", "originalCommit": "47f15d094f7890021186f01248d279746819a94b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODg2MTk1NA==", "url": "https://github.com/hazelcast/hazelcast/pull/16876#discussion_r408861954", "bodyText": "The exception will be propagated to the user through API, so there is no serious need to log it.", "author": "devozerov", "createdAt": "2020-04-15T13:56:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODgzNzQ1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODg0ODM0NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16876#discussion_r408848345", "bodyText": "True-> true", "author": "petrpleshachkov", "createdAt": "2020-04-15T13:38:50Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/state/QueryDistributedState.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.state;\n+\n+import com.hazelcast.sql.impl.worker.QueryFragmentExecutable;\n+import com.hazelcast.sql.impl.operation.QueryAbstractExchangeOperation;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentLinkedDeque;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+/**\n+ * State of a distributed query execution.\n+ */\n+public class QueryDistributedState {\n+    /** Pending batches. */\n+    private final ConcurrentLinkedDeque<QueryAbstractExchangeOperation> pendingOperations = new ConcurrentLinkedDeque<>();\n+\n+    /** Lock to prevent conflicts on initialization and batch arrival. */\n+    private final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();\n+\n+    /** Initialized state. */\n+    private volatile InitializedState initializedState;\n+\n+    public boolean isStarted() {\n+        return initializedState != null;\n+    }\n+\n+    /**\n+     * Initialization routine which is called when query start task is executed.\n+     *\n+     * @param fragments Fragment executables.\n+     */\n+    public void onStart(List<QueryFragmentExecutable> fragments) {\n+        lock.writeLock().lock();\n+\n+        try {\n+            // Initialize the state.\n+            initializedState = new InitializedState(fragments);\n+\n+            // Unwind pending batches if needed.\n+            boolean hadPendingBatches = false;\n+\n+            for (QueryAbstractExchangeOperation pendingOperation : pendingOperations) {\n+                onOperation0(pendingOperation);\n+\n+                if (!hadPendingBatches) {\n+                    hadPendingBatches = true;\n+                }\n+            }\n+\n+            if (hadPendingBatches) {\n+                pendingOperations.clear();\n+            }\n+        } finally {\n+            lock.writeLock().unlock();\n+        }\n+    }\n+\n+    public QueryFragmentExecutable onOperation(QueryAbstractExchangeOperation operation) {\n+        lock.readLock().lock();\n+\n+        try {\n+            if (initializedState != null) {\n+                return onOperation0(operation);\n+            } else {\n+                pendingOperations.add(operation);\n+\n+                return null;\n+            }\n+        } finally {\n+            lock.readLock().unlock();\n+        }\n+    }\n+\n+    private QueryFragmentExecutable onOperation0(QueryAbstractExchangeOperation operation) {\n+        assert initializedState != null;\n+\n+        QueryFragmentExecutable fragment = initializedState.getFragment(operation.isInbound(), operation.getEdgeId());\n+\n+        assert fragment != null : operation;\n+\n+        fragment.addOperation(operation);\n+\n+        return fragment;\n+    }\n+\n+    /**\n+     * Callback executed when the fragment is finished.\n+     *\n+     * @return {@code True} if execution of the last fragment finished.", "originalCommit": "47f15d094f7890021186f01248d279746819a94b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODg2MzQxNg==", "url": "https://github.com/hazelcast/hazelcast/pull/16876#discussion_r408863416", "bodyText": "Fixed.", "author": "devozerov", "createdAt": "2020-04-15T13:58:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODg0ODM0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODg1NzAwOA==", "url": "https://github.com/hazelcast/hazelcast/pull/16876#discussion_r408857008", "bodyText": "thread is protected by the startMux. Why do we need volatile?", "author": "petrpleshachkov", "createdAt": "2020-04-15T13:50:17Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/state/QueryStateRegistryUpdater.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.state;\n+\n+import com.hazelcast.sql.impl.NodeServiceProvider;\n+import com.hazelcast.sql.impl.QueryId;\n+import com.hazelcast.sql.impl.QueryUtils;\n+import com.hazelcast.sql.impl.operation.QueryCheckOperation;\n+import com.hazelcast.sql.impl.operation.QueryOperationHandler;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+\n+import static com.hazelcast.sql.impl.QueryUtils.WORKER_TYPE_STATE_CHECKER;\n+\n+/**\n+ * Class performing periodic query state check.\n+ */\n+public class QueryStateRegistryUpdater {\n+    /** Node service provider. */\n+    private final NodeServiceProvider nodeServiceProvider;\n+\n+    /** State to be checked. */\n+    private final QueryStateRegistry stateRegistry;\n+\n+    /** Operation handler. */\n+    private final QueryOperationHandler operationHandler;\n+\n+    /** State check frequency. */\n+    private final long stateCheckFrequency;\n+\n+    /** Worker performing periodic state check. */\n+    private final Worker worker;\n+\n+    public QueryStateRegistryUpdater(\n+        String instanceName,\n+        NodeServiceProvider nodeServiceProvider,\n+        QueryStateRegistry stateRegistry,\n+        QueryOperationHandler operationHandler,\n+        long stateCheckFrequency\n+    ) {\n+        if (stateCheckFrequency <= 0) {\n+            throw new IllegalArgumentException(\"State check frequency must be positive: \" + stateCheckFrequency);\n+        }\n+\n+        this.nodeServiceProvider = nodeServiceProvider;\n+        this.stateRegistry = stateRegistry;\n+        this.operationHandler = operationHandler;\n+        this.stateCheckFrequency = stateCheckFrequency;\n+\n+        worker = new Worker(instanceName);\n+    }\n+\n+    public void start() {\n+        worker.start();\n+    }\n+\n+    public void stop() {\n+        worker.stop();\n+    }\n+\n+    private final class Worker implements Runnable {\n+        private final Object startMux = new Object();\n+        private final String instanceName;\n+        private volatile Thread thread;", "originalCommit": "47f15d094f7890021186f01248d279746819a94b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODg2MzM2OA==", "url": "https://github.com/hazelcast/hazelcast/pull/16876#discussion_r408863368", "bodyText": "You are right, we do not need it. Removed.", "author": "devozerov", "createdAt": "2020-04-15T13:58:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODg1NzAwOA=="}], "type": "inlineReview"}, {"oid": "7d53f15be289cd4fe06dc89b37ad6fc0c29d2ceb", "url": "https://github.com/hazelcast/hazelcast/commit/7d53f15be289cd4fe06dc89b37ad6fc0c29d2ceb", "message": "Review comments.", "committedDate": "2020-04-15T13:58:04Z", "type": "commit"}]}