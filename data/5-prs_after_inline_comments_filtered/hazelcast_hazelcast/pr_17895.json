{"pr_number": 17895, "pr_title": "External Smart Client Public Address Discovery", "pr_createdAt": "2020-11-25T07:47:27Z", "pr_url": "https://github.com/hazelcast/hazelcast/pull/17895", "timeline": [{"oid": "697ba7689b3b9a3bdfc74d81825cd165329342b8", "url": "https://github.com/hazelcast/hazelcast/commit/697ba7689b3b9a3bdfc74d81825cd165329342b8", "message": "External Smart Client Public Address Discovery\n\nThis PR makes discovery by external smart client way simpler and more secure in the cloud environments. From now on, all that the client needs to know is an address of any member (or a load balancer if members are exposed via load balancer).\n\n* Related [PRD](https://hazelcast.atlassian.net/wiki/spaces/PM/pages/2280227357/External+Smart+Client+discovery+via+LoadBalancer)\n* Related [TDD](https://hazelcast.atlassian.net/wiki/spaces/PM/pages/2689663054/External+Smart+Client+discovery+via+LoadBalancer+TDD)\n\n---------\n\nExample of how it works on **Kubernetes** (GKE)\n\n1. Create 3 members, each exposed by a separate NodePort (or LoadBalancer) service.\n```\nkubectl apply -f https://raw.githubusercontent.com/hazelcast/hazelcast-kubernetes/master/rbac.yaml\nfor i in {1..3}; do \\\n  NAME=hazelcast-${i}; \\\n  kubectl create service nodeport $NAME --tcp=5701; \\\n  kubectl run $NAME --image=leszko/hazelcast:external-client --port=5701 -l \"app=${NAME},role=hazelcast\"; \\\ndone\n```\n\n2. Connect the smart client to any of the `IP:PORT` or members and the smart client just works.\n\n3. You can also expose all members via one LoadBalancer service\n```\nkubectl create service loadbalancer hazelcast --tcp=5701 -o yaml --dry-run=client | kubectl set selector --local -f - \"role=hazelcast\" -o yaml | kubectl create -f -\n```\n\n4. Check the external IP\n```\n$ kubectl get svc/hazelcast\nNAME        TYPE           CLUSTER-IP       EXTERNAL-IP     PORT(S)          AGE\nhazelcast   LoadBalancer   10.127.245.180   35.223.84.167   5701:31368/TCP   8m57s\n```\n\n5. Connect from the Java Client\n```\nClientConfig config = new ClientConfig();\nconfig.getNetworkConfig().addAddress(\"35.223.84.167:5701\");\nHazelcastInstance instance = HazelcastClient.newHazelcastClient(config);\n```\n\n--------\n\nExample of how it works on **AWS**\n\n1. Start 3 Hazelcast on 3 EC2 Instances\n2. Assuming EC2 Instances have public IPs, connect to any public IP and smart client works correctly.\n\nThe same works for any cloud environment (Azure, GCP).\n\n**Note:** client does not need to know any AWS/Azure/GCP credentials!\n\n---------\n\nSome considerations during the review process:\n1. I implemented auto-enabling of this feature, please check [TDD](https://hazelcast.atlassian.net/wiki/spaces/PM/pages/2689663054/External+Smart+Client+discovery+via+LoadBalancer+TDD) for more details\n2. The implementation is backward and forward compatible, no changes in the client protocol are needed", "committedDate": "2020-12-01T11:18:56Z", "type": "commit"}, {"oid": "67d4b187e6f8a3ffc9b375938ad2cefaffad0f39", "url": "https://github.com/hazelcast/hazelcast/commit/67d4b187e6f8a3ffc9b375938ad2cefaffad0f39", "message": "test fixes", "committedDate": "2020-12-01T11:18:56Z", "type": "commit"}, {"oid": "0214a3958f2b77f6602b7d5d4fd526e5142aa852", "url": "https://github.com/hazelcast/hazelcast/commit/0214a3958f2b77f6602b7d5d4fd526e5142aa852", "message": "test fixes", "committedDate": "2020-12-01T11:18:56Z", "type": "commit"}, {"oid": "0214a3958f2b77f6602b7d5d4fd526e5142aa852", "url": "https://github.com/hazelcast/hazelcast/commit/0214a3958f2b77f6602b7d5d4fd526e5142aa852", "message": "test fixes", "committedDate": "2020-12-01T11:18:56Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjczOTIyMg==", "url": "https://github.com/hazelcast/hazelcast/pull/17895#discussion_r532739222", "bodyText": "nit: Returns {@code true} ...", "author": "vbekiaris", "createdAt": "2020-11-30T16:43:57Z", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/spi/ClientClusterService.java", "diffHunk": "@@ -82,6 +82,13 @@\n      */\n     long getClusterTime();\n \n+    /**\n+     * Returns if member internal address should be translated into its public address.", "originalCommit": "e0f5f9e252d8ee7f5fec3203a6882b130743cd5e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc1NDUwOQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17895#discussion_r532754509", "bodyText": "DISCOVERY_SPI_PUBLIC_IP_ENABLED now operates like a tri-state boolean:\n\nexplicitly true -> performs address translation\nexplicitly false -> does not perform address translation\ndefault null or any other explicit value -> decides based on address matching logic below\n\nIn case someone changes the default null value back to false, TranslateToPublicAddress#membersReachableOnlyViaPublicAddress will fail, which is good. Maybe this non-standard treatment of the property is worth a mention in code comment here or in ClientProperty?\nAlso, a nit: in HazelcastProperties#getBoolean, the \"any other explicit value\" bucket results in a false outcome. Would it be more consistent to arrange this as:\n\ndefault null -> decides based on address matching logic below\nexplicitly true -> performs address translation\nexplicitly any other value (false or anything explicitly set) -> does not perform address translation", "author": "vbekiaris", "createdAt": "2020-11-30T17:04:24Z", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/spi/impl/TranslateToPublicAddressProvider.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.client.impl.spi.impl;\n+\n+import com.hazelcast.client.config.ClientConfig;\n+import com.hazelcast.client.impl.connection.AddressProvider;\n+import com.hazelcast.client.properties.ClientProperty;\n+import com.hazelcast.cluster.Address;\n+import com.hazelcast.instance.EndpointQualifier;\n+import com.hazelcast.instance.ProtocolType;\n+import com.hazelcast.internal.cluster.MemberInfo;\n+import com.hazelcast.logging.ILogger;\n+import com.hazelcast.spi.properties.HazelcastProperties;\n+\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+class TranslateToPublicAddressProvider {\n+    private static final int REACHABLE_ADDRESS_TIMEOUT = 1000;\n+    private static final int NON_REACHABLE_ADDRESS_TIMEOUT = 3000;\n+    private static final int REACHABLE_CHECK_NUMBER = 3;\n+\n+    private final ClientConfig config;\n+    private final HazelcastProperties properties;\n+    private final ILogger logger;\n+\n+    private volatile boolean translateToPublicAddress;\n+\n+    TranslateToPublicAddressProvider(ClientConfig config, HazelcastProperties properties, ILogger logger) {\n+        this.config = config;\n+        this.properties = properties;\n+        this.logger = logger;\n+    }\n+\n+    void refresh(AddressProvider addressProvider, Collection<MemberInfo> members) {\n+        translateToPublicAddress = resolve(addressProvider, members);\n+    }\n+\n+    private boolean resolve(AddressProvider addressProvider, Collection<MemberInfo> members) {\n+        if (!(addressProvider instanceof DefaultAddressProvider)) {\n+            return false;\n+        }\n+\n+        String publicIpEnabledProperty = properties.getString(ClientProperty.DISCOVERY_SPI_PUBLIC_IP_ENABLED);", "originalCommit": "e0f5f9e252d8ee7f5fec3203a6882b130743cd5e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzkzNjM3NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17895#discussion_r533936375", "bodyText": "Makes sense. I will document in the code comment that null is intentional.\nAlso, I will rearrange the code so that we will be consistent with HazelcastProperties#getBoolean", "author": "sancar", "createdAt": "2020-12-02T06:59:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc1NDUwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc1NTEzOA==", "url": "https://github.com/hazelcast/hazelcast/pull/17895#discussion_r532755138", "bodyText": "typo: \"... the client is\"", "author": "vbekiaris", "createdAt": "2020-11-30T17:05:14Z", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/spi/impl/TranslateToPublicAddressProvider.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.client.impl.spi.impl;\n+\n+import com.hazelcast.client.config.ClientConfig;\n+import com.hazelcast.client.impl.connection.AddressProvider;\n+import com.hazelcast.client.properties.ClientProperty;\n+import com.hazelcast.cluster.Address;\n+import com.hazelcast.instance.EndpointQualifier;\n+import com.hazelcast.instance.ProtocolType;\n+import com.hazelcast.internal.cluster.MemberInfo;\n+import com.hazelcast.logging.ILogger;\n+import com.hazelcast.spi.properties.HazelcastProperties;\n+\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+class TranslateToPublicAddressProvider {\n+    private static final int REACHABLE_ADDRESS_TIMEOUT = 1000;\n+    private static final int NON_REACHABLE_ADDRESS_TIMEOUT = 3000;\n+    private static final int REACHABLE_CHECK_NUMBER = 3;\n+\n+    private final ClientConfig config;\n+    private final HazelcastProperties properties;\n+    private final ILogger logger;\n+\n+    private volatile boolean translateToPublicAddress;\n+\n+    TranslateToPublicAddressProvider(ClientConfig config, HazelcastProperties properties, ILogger logger) {\n+        this.config = config;\n+        this.properties = properties;\n+        this.logger = logger;\n+    }\n+\n+    void refresh(AddressProvider addressProvider, Collection<MemberInfo> members) {\n+        translateToPublicAddress = resolve(addressProvider, members);\n+    }\n+\n+    private boolean resolve(AddressProvider addressProvider, Collection<MemberInfo> members) {\n+        if (!(addressProvider instanceof DefaultAddressProvider)) {\n+            return false;\n+        }\n+\n+        String publicIpEnabledProperty = properties.getString(ClientProperty.DISCOVERY_SPI_PUBLIC_IP_ENABLED);\n+        if (\"true\".equalsIgnoreCase(publicIpEnabledProperty)) {\n+            return true;\n+        } else if (\"false\".equalsIgnoreCase(publicIpEnabledProperty)) {\n+            return false;\n+        }\n+\n+        if (members.isEmpty() || memberInternalAddressAsDefinedInClientConfig(members)) {\n+            return false;\n+        }\n+\n+        return membersReachableOnlyViaPublicAddress(members);\n+    }\n+\n+    /**\n+     * Checks if any member has its internal address as configured in ClientConfig.\n+     * <p>\n+     * If any member has its internal/private address the same as configured in ClientConfig, then it means that tje client is", "originalCommit": "e0f5f9e252d8ee7f5fec3203a6882b130743cd5e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "09c612bb7da9e9a7be1117ede2285f73b290c1e0", "url": "https://github.com/hazelcast/hazelcast/commit/09c612bb7da9e9a7be1117ede2285f73b290c1e0", "message": "addressing review comments.", "committedDate": "2020-12-02T07:04:41Z", "type": "commit"}, {"oid": "f0a6b55029471cb951e686194872090d59f216da", "url": "https://github.com/hazelcast/hazelcast/commit/f0a6b55029471cb951e686194872090d59f216da", "message": "addressing review comments. fixing 4.2 xsd.", "committedDate": "2020-12-02T09:35:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDEzMjEyOA==", "url": "https://github.com/hazelcast/hazelcast/pull/17895#discussion_r534132128", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // we will try to decide if we should use private/public address automatically int that case.\n          \n          \n            \n                    // we will try to decide if we should use private/public address automatically in that case.", "author": "vbekiaris", "createdAt": "2020-12-02T12:33:42Z", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/spi/impl/TranslateToPublicAddressProvider.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.client.impl.spi.impl;\n+\n+import com.hazelcast.client.config.ClientConfig;\n+import com.hazelcast.client.impl.connection.AddressProvider;\n+import com.hazelcast.client.properties.ClientProperty;\n+import com.hazelcast.cluster.Address;\n+import com.hazelcast.instance.EndpointQualifier;\n+import com.hazelcast.instance.ProtocolType;\n+import com.hazelcast.internal.cluster.MemberInfo;\n+import com.hazelcast.logging.ILogger;\n+import com.hazelcast.spi.properties.HazelcastProperties;\n+\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+class TranslateToPublicAddressProvider {\n+    private static final int REACHABLE_ADDRESS_TIMEOUT = 1000;\n+    private static final int NON_REACHABLE_ADDRESS_TIMEOUT = 3000;\n+    private static final int REACHABLE_CHECK_NUMBER = 3;\n+\n+    private final ClientConfig config;\n+    private final HazelcastProperties properties;\n+    private final ILogger logger;\n+\n+    private volatile boolean translateToPublicAddress;\n+\n+    TranslateToPublicAddressProvider(ClientConfig config, HazelcastProperties properties, ILogger logger) {\n+        this.config = config;\n+        this.properties = properties;\n+        this.logger = logger;\n+    }\n+\n+    void refresh(AddressProvider addressProvider, Collection<MemberInfo> members) {\n+        translateToPublicAddress = resolve(addressProvider, members);\n+    }\n+\n+    private boolean resolve(AddressProvider addressProvider, Collection<MemberInfo> members) {\n+        if (!(addressProvider instanceof DefaultAddressProvider)) {\n+            return false;\n+        }\n+\n+        // Default value of DISCOVERY_SPI_PUBLIC_IP_ENABLED is `null` intentionally.\n+        // if DISCOVERY_SPI_PUBLIC_IP_ENABLED is not set to true/false, we don't know the intention of the user,\n+        // we will try to decide if we should use private/public address automatically int that case.", "originalCommit": "f0a6b55029471cb951e686194872090d59f216da", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b10bf9d4bf231b8ad7f2c44c6decff7d00118dc5", "url": "https://github.com/hazelcast/hazelcast/commit/b10bf9d4bf231b8ad7f2c44c6decff7d00118dc5", "message": "Update hazelcast/src/main/java/com/hazelcast/client/impl/spi/impl/TranslateToPublicAddressProvider.java\n\nCo-authored-by: Vassilis Bekiaris <vbekiaris@gmail.com>", "committedDate": "2020-12-02T13:45:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDE2MDYxNA==", "url": "https://github.com/hazelcast/hazelcast/pull/17895#discussion_r534160614", "bodyText": "nit: EndpointQualifier.resolve(ProtocolType.CLIENT, \"public\") creates a new object on each call. It could be avoided with a static field const. The same consideration applies to similar server-side usages.", "author": "puzpuzpuz", "createdAt": "2020-12-02T13:20:15Z", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/connection/tcp/TcpClientConnectionManager.java", "diffHunk": "@@ -679,6 +680,17 @@ protected TcpClientConnection createSocketConnection(Address target) {\n         }\n     }\n \n+    private Address translate(Member member) {\n+        if (client.getClientClusterService().translateToPublicAddress()) {\n+            Address publicAddress = member.getAddressMap().get(EndpointQualifier.resolve(ProtocolType.CLIENT, \"public\"));", "originalCommit": "f0a6b55029471cb951e686194872090d59f216da", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDE2NDg4Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17895#discussion_r534164882", "bodyText": "nit: this field could be final", "author": "puzpuzpuz", "createdAt": "2020-12-02T13:26:46Z", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/spi/impl/ClientClusterServiceImpl.java", "diffHunk": "@@ -86,6 +85,8 @@\n     //read and written under clusterViewLock\n     private CountDownLatch initialListFetchedLatch = new CountDownLatch(1);\n \n+    private TranslateToPublicAddressProvider translateToPublicAddress;", "originalCommit": "f0a6b55029471cb951e686194872090d59f216da", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDE2Njg1OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17895#discussion_r534166859", "bodyText": "nit: _MILLIS suffix won't hurt here and in NON_REACHABLE_ADDRESS_TIMEOUT", "author": "puzpuzpuz", "createdAt": "2020-12-02T13:29:59Z", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/spi/impl/TranslateToPublicAddressProvider.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.client.impl.spi.impl;\n+\n+import com.hazelcast.client.config.ClientConfig;\n+import com.hazelcast.client.impl.connection.AddressProvider;\n+import com.hazelcast.client.properties.ClientProperty;\n+import com.hazelcast.cluster.Address;\n+import com.hazelcast.instance.EndpointQualifier;\n+import com.hazelcast.instance.ProtocolType;\n+import com.hazelcast.internal.cluster.MemberInfo;\n+import com.hazelcast.logging.ILogger;\n+import com.hazelcast.spi.properties.HazelcastProperties;\n+\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+class TranslateToPublicAddressProvider {\n+    private static final int REACHABLE_ADDRESS_TIMEOUT = 1000;", "originalCommit": "f0a6b55029471cb951e686194872090d59f216da", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDE2ODExMw==", "url": "https://github.com/hazelcast/hazelcast/pull/17895#discussion_r534168113", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // if DISCOVERY_SPI_PUBLIC_IP_ENABLED is not set to true/false, we don't know the intention of the user,\n          \n          \n            \n                    // If DISCOVERY_SPI_PUBLIC_IP_ENABLED is not set to true/false, we don't know the intention of the user,", "author": "puzpuzpuz", "createdAt": "2020-12-02T13:31:55Z", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/spi/impl/TranslateToPublicAddressProvider.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.client.impl.spi.impl;\n+\n+import com.hazelcast.client.config.ClientConfig;\n+import com.hazelcast.client.impl.connection.AddressProvider;\n+import com.hazelcast.client.properties.ClientProperty;\n+import com.hazelcast.cluster.Address;\n+import com.hazelcast.instance.EndpointQualifier;\n+import com.hazelcast.instance.ProtocolType;\n+import com.hazelcast.internal.cluster.MemberInfo;\n+import com.hazelcast.logging.ILogger;\n+import com.hazelcast.spi.properties.HazelcastProperties;\n+\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+class TranslateToPublicAddressProvider {\n+    private static final int REACHABLE_ADDRESS_TIMEOUT = 1000;\n+    private static final int NON_REACHABLE_ADDRESS_TIMEOUT = 3000;\n+    private static final int REACHABLE_CHECK_NUMBER = 3;\n+\n+    private final ClientConfig config;\n+    private final HazelcastProperties properties;\n+    private final ILogger logger;\n+\n+    private volatile boolean translateToPublicAddress;\n+\n+    TranslateToPublicAddressProvider(ClientConfig config, HazelcastProperties properties, ILogger logger) {\n+        this.config = config;\n+        this.properties = properties;\n+        this.logger = logger;\n+    }\n+\n+    void refresh(AddressProvider addressProvider, Collection<MemberInfo> members) {\n+        translateToPublicAddress = resolve(addressProvider, members);\n+    }\n+\n+    private boolean resolve(AddressProvider addressProvider, Collection<MemberInfo> members) {\n+        if (!(addressProvider instanceof DefaultAddressProvider)) {\n+            return false;\n+        }\n+\n+        // Default value of DISCOVERY_SPI_PUBLIC_IP_ENABLED is `null` intentionally.\n+        // if DISCOVERY_SPI_PUBLIC_IP_ENABLED is not set to true/false, we don't know the intention of the user,", "originalCommit": "f0a6b55029471cb951e686194872090d59f216da", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDE3MjM1OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17895#discussion_r534172359", "bodyText": "Shouldn't we update the javadoc for this property? The current one duplicates member-side prop's javadoc and doesn't seem to be correct.", "author": "puzpuzpuz", "createdAt": "2020-12-02T13:38:36Z", "path": "hazelcast/src/main/java/com/hazelcast/client/properties/ClientProperty.java", "diffHunk": "@@ -118,7 +118,7 @@\n      * <p>Discovery SPI is <b>disabled</b> by default</p>\n      */\n     public static final HazelcastProperty DISCOVERY_SPI_PUBLIC_IP_ENABLED", "originalCommit": "f0a6b55029471cb951e686194872090d59f216da", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDE5MzI0Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17895#discussion_r534193242", "bodyText": "Why do you think that it is not correct?\nFrom the discovery spi perspective, we did not change the behavior. The null results with false there. But we are using this as a hint in a new implementation.", "author": "sancar", "createdAt": "2020-12-02T14:08:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDE3MjM1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDIwNDQyNQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17895#discussion_r534204425", "bodyText": "Why do you think that it is not correct?\n\nI've double checked current usage and it seems to be correct. For some reasons I didn't see how it's used in ClusterDiscoveryServiceBuilder.\n\nBut we are using this as a hint in a new implementation.\n\nDoes it make sense to describe this hint behavior? Otherwise, this change seems to be totally uncovered in built-in documentation of the client.", "author": "puzpuzpuz", "createdAt": "2020-12-02T14:23:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDE3MjM1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDE3NjgyNA==", "url": "https://github.com/hazelcast/hazelcast/pull/17895#discussion_r534176824", "bodyText": "I didn't experiment with the code, but will java.net.Socket work in case of secure connections? I'd expect an exception in this case, but I may be wrong.", "author": "puzpuzpuz", "createdAt": "2020-12-02T13:45:02Z", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/spi/impl/TranslateToPublicAddressProvider.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.client.impl.spi.impl;\n+\n+import com.hazelcast.client.config.ClientConfig;\n+import com.hazelcast.client.impl.connection.AddressProvider;\n+import com.hazelcast.client.properties.ClientProperty;\n+import com.hazelcast.cluster.Address;\n+import com.hazelcast.instance.EndpointQualifier;\n+import com.hazelcast.instance.ProtocolType;\n+import com.hazelcast.internal.cluster.MemberInfo;\n+import com.hazelcast.logging.ILogger;\n+import com.hazelcast.spi.properties.HazelcastProperties;\n+\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+class TranslateToPublicAddressProvider {\n+    private static final int REACHABLE_ADDRESS_TIMEOUT = 1000;\n+    private static final int NON_REACHABLE_ADDRESS_TIMEOUT = 3000;\n+    private static final int REACHABLE_CHECK_NUMBER = 3;\n+\n+    private final ClientConfig config;\n+    private final HazelcastProperties properties;\n+    private final ILogger logger;\n+\n+    private volatile boolean translateToPublicAddress;\n+\n+    TranslateToPublicAddressProvider(ClientConfig config, HazelcastProperties properties, ILogger logger) {\n+        this.config = config;\n+        this.properties = properties;\n+        this.logger = logger;\n+    }\n+\n+    void refresh(AddressProvider addressProvider, Collection<MemberInfo> members) {\n+        translateToPublicAddress = resolve(addressProvider, members);\n+    }\n+\n+    private boolean resolve(AddressProvider addressProvider, Collection<MemberInfo> members) {\n+        if (!(addressProvider instanceof DefaultAddressProvider)) {\n+            return false;\n+        }\n+\n+        // Default value of DISCOVERY_SPI_PUBLIC_IP_ENABLED is `null` intentionally.\n+        // if DISCOVERY_SPI_PUBLIC_IP_ENABLED is not set to true/false, we don't know the intention of the user,\n+        // we will try to decide if we should use private/public address automatically int that case.\n+        String publicIpEnabledProperty = properties.getString(ClientProperty.DISCOVERY_SPI_PUBLIC_IP_ENABLED);\n+        if (publicIpEnabledProperty == null) {\n+            if (members.isEmpty() || memberInternalAddressAsDefinedInClientConfig(members)) {\n+                return false;\n+            }\n+\n+            return membersReachableOnlyViaPublicAddress(members);\n+        }\n+        return properties.getBoolean(ClientProperty.DISCOVERY_SPI_PUBLIC_IP_ENABLED);\n+    }\n+\n+    /**\n+     * Checks if any member has its internal address as configured in ClientConfig.\n+     * <p>\n+     * If any member has its internal/private address the same as configured in ClientConfig, then it means that the client is\n+     * able to connect to members via configured address. No need to use make any address translation.\n+     */\n+    boolean memberInternalAddressAsDefinedInClientConfig(Collection<MemberInfo> members) {\n+        List<String> addresses = config.getNetworkConfig().getAddresses();\n+        return members.stream()\n+                .map(MemberInfo::getAddress)\n+                .anyMatch(a -> addresses.contains(a.getHost())\n+                        || addresses.contains(String.format(\"%s:%s\", a.getHost(), a.getPort())));\n+    }\n+\n+    /**\n+     * Checks if members are reachable via public addresses, but not reachable via internal addresses.\n+     * <p>\n+     * We check only limited number of random members to reduce the slowdown of the startup.\n+     */\n+    private boolean membersReachableOnlyViaPublicAddress(Collection<MemberInfo> members) {\n+        Iterator<MemberInfo> iter = members.iterator();\n+        for (int i = 0; i < REACHABLE_CHECK_NUMBER; i++) {\n+            if (!iter.hasNext()) {\n+                iter = members.iterator();\n+            }\n+            MemberInfo member = iter.next();\n+            Address publicAddress = member.getAddressMap().get(EndpointQualifier.resolve(ProtocolType.CLIENT, \"public\"));\n+            if (publicAddress == null) {\n+                return false;\n+            }\n+            Address internalAddress = member.getAddress();\n+            if (isReachable(internalAddress, REACHABLE_ADDRESS_TIMEOUT)) {\n+                return false;\n+            }\n+            if (!isReachable(publicAddress, NON_REACHABLE_ADDRESS_TIMEOUT)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private boolean isReachable(Address address, int timeoutMs) {\n+        try (Socket s = new Socket()) {", "originalCommit": "f0a6b55029471cb951e686194872090d59f216da", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDIyNjcwOA==", "url": "https://github.com/hazelcast/hazelcast/pull/17895#discussion_r534226708", "bodyText": "Update. I did some experiments and this approach seems to be working with an EE member which has TLS enabled. The only minor issue is that the member logs some warnings on connection attempt, like the following one:\njavax.net.ssl.SSLException: Remote socket closed during SSL/TLS handshake.  This is probably caused by a SSL/TLS authentication problem resulting in the remote side closing the socket.\n\tat com.hazelcast.internal.nio.ssl.TLSHandshakeDecoder.newSSLException(TLSHandshakeDecoder.java:68) ~[classes/:?]\n\tat com.hazelcast.internal.nio.ssl.TLSHandshakeDecoder.interceptError(TLSHandshakeDecoder.java:63) ~[classes/:?]\n\tat com.hazelcast.internal.networking.nio.NioPipeline.onError(NioPipeline.java:271) ~[classes/:?]\n\tat com.hazelcast.internal.networking.nio.NioPipeline.lambda$start$0(NioPipeline.java:129) ~[classes/:?]\n\tat com.hazelcast.internal.networking.nio.NioThread.processTaskQueue(NioThread.java:355) [classes/:?]\n\tat com.hazelcast.internal.networking.nio.NioThread.selectLoop(NioThread.java:290) [classes/:?]\n\tat com.hazelcast.internal.networking.nio.NioThread.executeRun(NioThread.java:249) [classes/:?]\n\tat com.hazelcast.internal.util.executor.HazelcastManagedThread.run(HazelcastManagedThread.java:102) [classes/:?]\nCaused by: java.io.EOFException: Remote socket closed!\n\tat com.hazelcast.internal.networking.nio.NioInboundPipeline.process(NioInboundPipeline.java:122) ~[classes/:?]\n\tat com.hazelcast.internal.networking.nio.NioPipeline.lambda$start$0(NioPipeline.java:127) ~[classes/:?]\n\t... 4 more", "author": "puzpuzpuz", "createdAt": "2020-12-02T14:50:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDE3NjgyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQyNjMyNA==", "url": "https://github.com/hazelcast/hazelcast/pull/17895#discussion_r534426324", "bodyText": "I was not sure and tried the following code, and it is working.\nThe client is able to connect without a problem. As soon as it makes write/read it fails.\nchar[] passphrase = \"123456\".toCharArray();\n        SSLContext ctx = SSLContext.getInstance(\"TLS\");\n        KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"SunX509\");\n        KeyStore ks = KeyStore.getInstance(\"JKS\");\n        ks.load(new FileInputStream(\"/Users/sancar/projects/hazelcast-enterprise/hazelcast-enterprise/src/test/resources/com/hazelcast/nio/ssl/hazelcast.keystore\"), passphrase);\n        kmf.init(ks, passphrase);\n        ctx.init(kmf.getKeyManagers(), null, null);\n        SSLServerSocketFactory ssf = ctx.getServerSocketFactory();\n        SSLServerSocket ss = (SSLServerSocket) ssf.createServerSocket(5701);\n        ss.setNeedClientAuth(true);\n\n        new Thread(() -> {\n            while (true) {\n                try {\n                    Socket accept = ss.accept();\n                    System.out.println(\"ACCEPTED\" + accept);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n\n            }\n        }).start();\n        \n        try (Socket s = new Socket()) {\n            s.connect(new InetSocketAddress(\"127.0.0.1\", 5701), 5000);\n            System.out.println(\"CONNECTED\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }", "author": "sancar", "createdAt": "2020-12-02T19:28:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDE3NjgyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDcwMzYyNg==", "url": "https://github.com/hazelcast/hazelcast/pull/17895#discussion_r534703626", "bodyText": "I already did an experiment with a IMDG EE member which has TLS enabled. See #17895 (comment)", "author": "puzpuzpuz", "createdAt": "2020-12-03T06:01:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDE3NjgyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg4NjI2MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17895#discussion_r535886261", "bodyText": "So the logs on the server side do not look nice. To avoid the logs,\n\n\nwe may open an SSL connection and close it after the initial handshake. The downside is this heuristic will slowdown the startup more.\nI have tried to use SSL here but porting SSL connection and configuration does not seem simple to me. Maybe @pveentjer can handle it better than me?\nMost of the SSL related connections are not in this repo. And the ClientExtension seems to be for only channels. I could not figure out how to simply open a connection and closed it back after the initial handshake.\n\n\nWe can lower the SSLException log level from WARNING to FINE when the initial PROTOCOL bytes are not sent. It would mean that if normal member/client connections will also be suppressed when the connection is closed before bytes are sent.\n\n\n@jerrinot @mmedenjak Dear colleagues, can we get your ideas ? :)\nAnd to give more context, we are trying to decide if a member is reachable by opening a connection from the client-side to make a decision whether to use internal or public address of the member.\nSecondly, if we leave it like this and allow the Warning logs will be once in a lifetime of the client(and also when they switch cluster). But if you have hundreds of clients, we will see hundreds of logs in the server.\nAlso, we discussed ICMP port 7 pings with @puzpuzpuz . It does not show if a member is there but shows if the machine is reachable. It might be enough but, it is not always enabled.", "author": "sancar", "createdAt": "2020-12-04T07:20:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDE3NjgyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTkwNzg2MA==", "url": "https://github.com/hazelcast/hazelcast/pull/17895#discussion_r535907860", "bodyText": "An update after getting a valid point from @leszko\nWe have decided to go with checking config.getNetworkConfig().getSSLConfig().isEnabled()\nIf it is enabled we will not run this heuristic to decide automatically.\nThe reasoning is that if the user enables SSL, s/he already has lots of configs, it is not an out-of-the-box experience anymore. The user can put one more property, DISCOVERY_SPI_PUBLIC_IP_ENABLED true/false.", "author": "sancar", "createdAt": "2020-12-04T08:05:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDE3NjgyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTkxNzI2MA==", "url": "https://github.com/hazelcast/hazelcast/pull/17895#discussion_r535917260", "bodyText": "I'm ok with the proposed solution, but we really need to document this fancy logic, otherwise users will get confused.", "author": "puzpuzpuz", "createdAt": "2020-12-04T08:23:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDE3NjgyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk0MzI3Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17895#discussion_r535943273", "bodyText": "One more note on this one. We should add more logging around this detection mechanism to simplify diagnostics in case of reported issues.", "author": "puzpuzpuz", "createdAt": "2020-12-04T09:06:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDE3NjgyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzI2NTUxNQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17895#discussion_r537265515", "bodyText": "I have added logs.", "author": "sancar", "createdAt": "2020-12-07T06:42:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDE3NjgyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDE3NzM5Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17895#discussion_r534177393", "bodyText": "nit: would be nice to add a meaningful message for the log entry.", "author": "puzpuzpuz", "createdAt": "2020-12-02T13:45:54Z", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/spi/impl/TranslateToPublicAddressProvider.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.client.impl.spi.impl;\n+\n+import com.hazelcast.client.config.ClientConfig;\n+import com.hazelcast.client.impl.connection.AddressProvider;\n+import com.hazelcast.client.properties.ClientProperty;\n+import com.hazelcast.cluster.Address;\n+import com.hazelcast.instance.EndpointQualifier;\n+import com.hazelcast.instance.ProtocolType;\n+import com.hazelcast.internal.cluster.MemberInfo;\n+import com.hazelcast.logging.ILogger;\n+import com.hazelcast.spi.properties.HazelcastProperties;\n+\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+class TranslateToPublicAddressProvider {\n+    private static final int REACHABLE_ADDRESS_TIMEOUT = 1000;\n+    private static final int NON_REACHABLE_ADDRESS_TIMEOUT = 3000;\n+    private static final int REACHABLE_CHECK_NUMBER = 3;\n+\n+    private final ClientConfig config;\n+    private final HazelcastProperties properties;\n+    private final ILogger logger;\n+\n+    private volatile boolean translateToPublicAddress;\n+\n+    TranslateToPublicAddressProvider(ClientConfig config, HazelcastProperties properties, ILogger logger) {\n+        this.config = config;\n+        this.properties = properties;\n+        this.logger = logger;\n+    }\n+\n+    void refresh(AddressProvider addressProvider, Collection<MemberInfo> members) {\n+        translateToPublicAddress = resolve(addressProvider, members);\n+    }\n+\n+    private boolean resolve(AddressProvider addressProvider, Collection<MemberInfo> members) {\n+        if (!(addressProvider instanceof DefaultAddressProvider)) {\n+            return false;\n+        }\n+\n+        // Default value of DISCOVERY_SPI_PUBLIC_IP_ENABLED is `null` intentionally.\n+        // if DISCOVERY_SPI_PUBLIC_IP_ENABLED is not set to true/false, we don't know the intention of the user,\n+        // we will try to decide if we should use private/public address automatically int that case.\n+        String publicIpEnabledProperty = properties.getString(ClientProperty.DISCOVERY_SPI_PUBLIC_IP_ENABLED);\n+        if (publicIpEnabledProperty == null) {\n+            if (members.isEmpty() || memberInternalAddressAsDefinedInClientConfig(members)) {\n+                return false;\n+            }\n+\n+            return membersReachableOnlyViaPublicAddress(members);\n+        }\n+        return properties.getBoolean(ClientProperty.DISCOVERY_SPI_PUBLIC_IP_ENABLED);\n+    }\n+\n+    /**\n+     * Checks if any member has its internal address as configured in ClientConfig.\n+     * <p>\n+     * If any member has its internal/private address the same as configured in ClientConfig, then it means that the client is\n+     * able to connect to members via configured address. No need to use make any address translation.\n+     */\n+    boolean memberInternalAddressAsDefinedInClientConfig(Collection<MemberInfo> members) {\n+        List<String> addresses = config.getNetworkConfig().getAddresses();\n+        return members.stream()\n+                .map(MemberInfo::getAddress)\n+                .anyMatch(a -> addresses.contains(a.getHost())\n+                        || addresses.contains(String.format(\"%s:%s\", a.getHost(), a.getPort())));\n+    }\n+\n+    /**\n+     * Checks if members are reachable via public addresses, but not reachable via internal addresses.\n+     * <p>\n+     * We check only limited number of random members to reduce the slowdown of the startup.\n+     */\n+    private boolean membersReachableOnlyViaPublicAddress(Collection<MemberInfo> members) {\n+        Iterator<MemberInfo> iter = members.iterator();\n+        for (int i = 0; i < REACHABLE_CHECK_NUMBER; i++) {\n+            if (!iter.hasNext()) {\n+                iter = members.iterator();\n+            }\n+            MemberInfo member = iter.next();\n+            Address publicAddress = member.getAddressMap().get(EndpointQualifier.resolve(ProtocolType.CLIENT, \"public\"));\n+            if (publicAddress == null) {\n+                return false;\n+            }\n+            Address internalAddress = member.getAddress();\n+            if (isReachable(internalAddress, REACHABLE_ADDRESS_TIMEOUT)) {\n+                return false;\n+            }\n+            if (!isReachable(publicAddress, NON_REACHABLE_ADDRESS_TIMEOUT)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private boolean isReachable(Address address, int timeoutMs) {\n+        try (Socket s = new Socket()) {\n+            s.connect(new InetSocketAddress(address.getHost(), address.getPort()), timeoutMs);\n+        } catch (Exception e) {\n+            logger.fine(e);", "originalCommit": "f0a6b55029471cb951e686194872090d59f216da", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDE4MjQ4Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17895#discussion_r534182483", "bodyText": "nit: newAddressMap may be a better name for this method.", "author": "puzpuzpuz", "createdAt": "2020-12-02T13:53:13Z", "path": "hazelcast/src/main/java/com/hazelcast/cluster/impl/MemberImpl.java", "diffHunk": "@@ -217,4 +217,10 @@ public MemberImpl build() {\n                     attributes, liteMember, memberListJoinVersion, instance);\n         }\n     }\n+\n+    private static Map<EndpointQualifier, Address> newHashMap(EndpointQualifier member, Address address) {", "originalCommit": "b10bf9d4bf231b8ad7f2c44c6decff7d00118dc5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDE4Mzc4Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17895#discussion_r534183782", "bodyText": "Why do we need this change in this PR? Seems that it only affects WAN protocol type.", "author": "puzpuzpuz", "createdAt": "2020-12-02T13:54:57Z", "path": "hazelcast/src/main/java/com/hazelcast/instance/EndpointQualifier.java", "diffHunk": "@@ -85,10 +85,6 @@ public boolean equals(Object o) {\n             return false;\n         }\n \n-        // Single instance types - identifier doesn't matter\n-        if (type.getServerSocketCardinality() == 1) {", "originalCommit": "b10bf9d4bf231b8ad7f2c44c6decff7d00118dc5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDgwMjI0Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17895#discussion_r534802243", "bodyText": "@leszko we were not checking the identifier for equality when getServerSocketCardinality is 1 before\nbecause the only one with a different identifier was WAN. Now the CLIENT can have a different identifier and its cardinality is one. That is why we needed to remove this.", "author": "sancar", "createdAt": "2020-12-03T07:25:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDE4Mzc4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDgxNjIwNg==", "url": "https://github.com/hazelcast/hazelcast/pull/17895#discussion_r534816206", "bodyText": "I see. Then this change shouldn't break any WAN-related code.", "author": "puzpuzpuz", "createdAt": "2020-12-03T07:34:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDE4Mzc4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDE4NDQzMw==", "url": "https://github.com/hazelcast/hazelcast/pull/17895#discussion_r534184433", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    HashMap<EndpointQualifier, Address> publicAddressMap = new HashMap<>();\n          \n          \n            \n                    Map<EndpointQualifier, Address> publicAddressMap = new HashMap<>();", "author": "puzpuzpuz", "createdAt": "2020-12-02T13:55:52Z", "path": "hazelcast/src/main/java/com/hazelcast/instance/impl/DefaultAddressPicker.java", "diffHunk": "@@ -436,7 +437,9 @@ public ServerSocketChannel getServerSocketChannel(EndpointQualifier qualifier) {\n \n     @Override\n     public Map<EndpointQualifier, Address> getPublicAddressMap() {\n-        return Collections.singletonMap(MEMBER, publicAddress);\n+        HashMap<EndpointQualifier, Address> publicAddressMap = new HashMap<>();", "originalCommit": "b10bf9d4bf231b8ad7f2c44c6decff7d00118dc5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDE5MzQ0NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17895#discussion_r534193444", "bodyText": "Is it ok to remove volatile modifier for this field?", "author": "puzpuzpuz", "createdAt": "2020-12-02T14:08:37Z", "path": "hazelcast/src/test/java/com/hazelcast/client/impl/connection/tcp/TcpClientConnectionManagerTranslateTest.java", "diffHunk": "@@ -72,9 +71,124 @@ public void teardown() {\n         Hazelcast.shutdownAll();\n     }\n \n+    @Test(expected = Exception.class)\n+    public void testTranslateIsUsed() {\n+        // given\n+        ClientConfig config = new ClientConfig();\n+        config.getConnectionStrategyConfig().getConnectionRetryConfig().setClusterConnectTimeoutMillis(1000);\n+        HazelcastInstance client = HazelcastClientUtil.newHazelcastClient(new TestAddressProvider(true), config);\n+        TcpClientConnectionManager clientConnectionManager =\n+                new TcpClientConnectionManager(getHazelcastClientInstanceImpl(client));\n+\n+        // when\n+        clientConnectionManager.start();\n+\n+        // then\n+        // throws exception because it can't connect to the cluster using translated public unreachable address\n+    }\n+\n+    @Test\n+    public void testTranslateIsNotUsedOnGettingExistingConnection() {\n+        // given\n+        TestAddressProvider provider = new TestAddressProvider(false);\n+        HazelcastInstance client = HazelcastClientUtil.newHazelcastClient(provider, new ClientConfig());\n+        TcpClientConnectionManager clientConnectionManager =\n+                new TcpClientConnectionManager(getHazelcastClientInstanceImpl(client));\n+\n+        clientConnectionManager.start();\n+        clientConnectionManager.reset();\n+\n+        clientConnectionManager.getOrConnectToAddress(privateAddress);\n+        provider.shouldTranslate = true;\n+\n+        // when\n+        Connection connection = clientConnectionManager.getOrConnectToAddress(privateAddress);\n+\n+        // then\n+        assertNotNull(connection);\n+    }\n+\n+    @Test\n+    public void testTranslateIsUsedWhenMemberHasPublicClientAddress() throws UnknownHostException {\n+        // given\n+        ClientConfig clientConfig = new ClientConfig();\n+        clientConfig.setProperty(ClientProperty.DISCOVERY_SPI_PUBLIC_IP_ENABLED.getName(), \"true\");\n+\n+        HazelcastInstance client = HazelcastClientUtil.newHazelcastClient(null, clientConfig);\n+        TcpClientConnectionManager clientConnectionManager =\n+                new TcpClientConnectionManager(getHazelcastClientInstanceImpl(client));\n+        clientConnectionManager.start();\n+\n+        // private member address is unreachable\n+        Member member = new MemberImpl(new Address(\"192.168.0.1\", 5701), VERSION, false, UUID.randomUUID());\n+        // public member address is reachable\n+        member.getAddressMap().put(EndpointQualifier.resolve(ProtocolType.CLIENT, \"public\"),\n+                new Address(\"127.0.0.1\", 5701));\n+\n+        // when\n+        Connection connection = clientConnectionManager.getOrConnectToMember(member);\n+\n+        // then\n+        assertNotNull(connection);\n+    }\n+\n+    @Test(expected = Exception.class)\n+    public void testTranslateIsNotUsedWhenPublicIpDisabled() throws UnknownHostException {\n+        // given\n+        ClientConfig clientConfig = new ClientConfig();\n+        clientConfig.setProperty(ClientProperty.DISCOVERY_SPI_PUBLIC_IP_ENABLED.getName(), \"false\");\n+\n+        HazelcastInstance client = HazelcastClientUtil.newHazelcastClient(null, clientConfig);\n+        TcpClientConnectionManager clientConnectionManager =\n+                new TcpClientConnectionManager(getHazelcastClientInstanceImpl(client));\n+        clientConnectionManager.start();\n+\n+        // private member address is incorrect\n+        Member member = new MemberImpl(new Address(\"192.168.0.1\", 5701), VERSION, false);\n+        // public member address is correct\n+        member.getAddressMap().put(EndpointQualifier.resolve(ProtocolType.CLIENT, \"public\"), new Address(\"127.0.0.1\", 5701));\n+\n+        // when\n+        clientConnectionManager.getOrConnectToMember(member);\n+\n+        // then\n+        // throws exception because it can't connect to the incorrect member address\n+    }\n+\n+    @Test(expected = Exception.class)\n+    public void testTranslateFromMemberIsNotUsedWhenAlreadyTranslatedByAddressProvider() throws UnknownHostException {\n+        // given\n+        ClientConfig clientConfig = new ClientConfig();\n+        clientConfig.setProperty(ClientProperty.DISCOVERY_SPI_PUBLIC_IP_ENABLED.getName(), \"true\");\n+\n+        TestAddressProvider provider = new TestAddressProvider(false);\n+        HazelcastInstance client = HazelcastClientUtil.newHazelcastClient(provider, clientConfig);\n+        TcpClientConnectionManager clientConnectionManager =\n+                new TcpClientConnectionManager(getHazelcastClientInstanceImpl(client));\n+        clientConnectionManager.start();\n+        provider.shouldTranslate = true;\n+        privateAddress = new Address(\"192.168.0.1\", 5702);\n+\n+        // private member address is correct\n+        Member member = new MemberImpl(privateAddress, VERSION, false);\n+        // public member address is correct\n+        member.getAddressMap().put(EndpointQualifier.resolve(ProtocolType.CLIENT, \"public\"),\n+                new Address(\"127.0.0.1\", 5701));\n+\n+        // when\n+        clientConnectionManager.getOrConnectToMember(member);\n+\n+        // then\n+        // throws exception because it can't connect to the incorrect address\n+    }\n+\n     private class TestAddressProvider implements AddressProvider {\n \n-        volatile boolean shouldTranslate = false;\n+        private boolean shouldTranslate;", "originalCommit": "b10bf9d4bf231b8ad7f2c44c6decff7d00118dc5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDk0ODU5Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17895#discussion_r534948593", "bodyText": "It should not cause any harm as far as I see. We set this field before starting the instance. All threads start after this.", "author": "sancar", "createdAt": "2020-12-03T08:50:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDE5MzQ0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDIwMDE1Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17895#discussion_r534200152", "bodyText": "As MC uses address map for advanced networking support and matching some metrics, this change may affect it.\n@emre-aydin it may be a good idea to double check if this change doesn't break anything in MC. WDYT?", "author": "puzpuzpuz", "createdAt": "2020-12-02T14:17:55Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/cluster/impl/DiscoveryJoiner.java", "diffHunk": "@@ -76,10 +78,29 @@ public DiscoveryJoiner(Node node, DiscoveryService discoveryService, boolean use\n         for (DiscoveryNode discoveryNode : discoveredNodes) {\n             Address discoveredAddress = usePublicAddress ? discoveryNode.getPublicAddress() : discoveryNode.getPrivateAddress();\n             if (localAddress.equals(discoveredAddress)) {\n+                if (!usePublicAddress && discoveryNode.getPublicAddress() != null) {\n+                    // enrich member with client public address\n+                    localMember.getAddressMap().put(EndpointQualifier.resolve(ProtocolType.CLIENT, \"public\"),", "originalCommit": "b10bf9d4bf231b8ad7f2c44c6decff7d00118dc5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDIwNjQxMQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17895#discussion_r534206411", "bodyText": "Funny thing that you mention it right when I am troubleshooting a bug in this area and was just about to use Member#getSocketAddress(EndpointQualifier.CLIENT) for fixing it \ud83d\ude04\nGood idea to try changes in this branch with MC. Will add to my todo. Thanks for the ping.", "author": "emre-aydin", "createdAt": "2020-12-02T14:25:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDIwMDE1Mg=="}], "type": "inlineReview"}, {"oid": "d879bb29513dc69d554ebdbc67b0ddf4b9419ac8", "url": "https://github.com/hazelcast/hazelcast/commit/d879bb29513dc69d554ebdbc67b0ddf4b9419ac8", "message": "addressing review comments", "committedDate": "2020-12-03T06:49:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDc5NDc0Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/17895#discussion_r534794747", "bodyText": "@leszko It looks like we are retrying some members twice if the number of members is less than REACHABLE_CHECK_NUMBER.  If so, I think we should not. Am I missing something?", "author": "sancar", "createdAt": "2020-12-03T07:21:13Z", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/spi/impl/TranslateToPublicAddressProvider.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.client.impl.spi.impl;\n+\n+import com.hazelcast.client.config.ClientConfig;\n+import com.hazelcast.client.impl.connection.AddressProvider;\n+import com.hazelcast.client.properties.ClientProperty;\n+import com.hazelcast.cluster.Address;\n+import com.hazelcast.instance.EndpointQualifier;\n+import com.hazelcast.instance.ProtocolType;\n+import com.hazelcast.internal.cluster.MemberInfo;\n+import com.hazelcast.logging.ILogger;\n+import com.hazelcast.spi.properties.HazelcastProperties;\n+\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+class TranslateToPublicAddressProvider {\n+    private static final int REACHABLE_ADDRESS_TIMEOUT_MILLIS = 1000;\n+    private static final int NON_REACHABLE_ADDRESS_TIMEOUT_MILLIS = 3000;\n+    private static final int REACHABLE_CHECK_NUMBER = 3;\n+    private static final EndpointQualifier CLIENT_PUBLIC_ENDPOINT_QUALIFIER =\n+            EndpointQualifier.resolve(ProtocolType.CLIENT, \"public\");\n+    private final ClientConfig config;\n+    private final HazelcastProperties properties;\n+    private final ILogger logger;\n+\n+    private volatile boolean translateToPublicAddress;\n+\n+    TranslateToPublicAddressProvider(ClientConfig config, HazelcastProperties properties, ILogger logger) {\n+        this.config = config;\n+        this.properties = properties;\n+        this.logger = logger;\n+    }\n+\n+    void refresh(AddressProvider addressProvider, Collection<MemberInfo> members) {\n+        translateToPublicAddress = resolve(addressProvider, members);\n+    }\n+\n+    private boolean resolve(AddressProvider addressProvider, Collection<MemberInfo> members) {\n+        if (!(addressProvider instanceof DefaultAddressProvider)) {\n+            return false;\n+        }\n+\n+        // Default value of DISCOVERY_SPI_PUBLIC_IP_ENABLED is `null` intentionally.\n+        // If DISCOVERY_SPI_PUBLIC_IP_ENABLED is not set to true/false, we don't know the intention of the user,\n+        // we will try to decide if we should use private/public address automatically in that case.\n+        String publicIpEnabledProperty = properties.getString(ClientProperty.DISCOVERY_SPI_PUBLIC_IP_ENABLED);\n+        if (publicIpEnabledProperty == null) {\n+            if (members.isEmpty() || memberInternalAddressAsDefinedInClientConfig(members)) {\n+                return false;\n+            }\n+\n+            return membersReachableOnlyViaPublicAddress(members);\n+        }\n+        return properties.getBoolean(ClientProperty.DISCOVERY_SPI_PUBLIC_IP_ENABLED);\n+    }\n+\n+    /**\n+     * Checks if any member has its internal address as configured in ClientConfig.\n+     * <p>\n+     * If any member has its internal/private address the same as configured in ClientConfig, then it means that the client is\n+     * able to connect to members via configured address. No need to use make any address translation.\n+     */\n+    boolean memberInternalAddressAsDefinedInClientConfig(Collection<MemberInfo> members) {\n+        List<String> addresses = config.getNetworkConfig().getAddresses();\n+        return members.stream()\n+                .map(MemberInfo::getAddress)\n+                .anyMatch(a -> addresses.contains(a.getHost())\n+                        || addresses.contains(String.format(\"%s:%s\", a.getHost(), a.getPort())));\n+    }\n+\n+    /**\n+     * Checks if members are reachable via public addresses, but not reachable via internal addresses.\n+     * <p>\n+     * We check only limited number of random members to reduce the slowdown of the startup.\n+     */\n+    private boolean membersReachableOnlyViaPublicAddress(Collection<MemberInfo> members) {\n+        Iterator<MemberInfo> iter = members.iterator();\n+        for (int i = 0; i < REACHABLE_CHECK_NUMBER; i++) {\n+            if (!iter.hasNext()) {\n+                iter = members.iterator();", "originalCommit": "d879bb29513dc69d554ebdbc67b0ddf4b9419ac8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDg2NDgwNw==", "url": "https://github.com/hazelcast/hazelcast/pull/17895#discussion_r534864807", "bodyText": "My reasoning was that, for example, if we have just 1 member, we should anyway retry a few times, because otherwise, we risk that there was some random network congestion for just one moment and we take a decision based on that. So, in my opinion, I would retry a few times even if we only have 1 member.", "author": "leszko", "createdAt": "2020-12-03T08:02:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDc5NDc0Nw=="}], "type": "inlineReview"}, {"oid": "fa3845c8fa7dd4b9c26f16663efa0dbe3e6333f8", "url": "https://github.com/hazelcast/hazelcast/commit/fa3845c8fa7dd4b9c26f16663efa0dbe3e6333f8", "message": "add randomization to reachable check to avoid loading single member when large number of clients are used", "committedDate": "2020-12-03T08:48:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg4MjE1NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17895#discussion_r535882154", "bodyText": "Current implementation forces detection of unreachable internal address and reachable public address for 3 members in public client-server comms scenario. It follows what's written in the TDD, but it may be a bit too pessimistic. We could change this check to the following:\n            if (isReachable(publicAddress, NON_REACHABLE_ADDRESS_TIMEOUT_MILLIS)) {\n                return true;\n            }\n        }\n        return false;\nLet's consider the success path, i.e. situation when all members are up and running and network works as expected. With this check we would return early in the public client-server comm scenario, once we detect the situation for the first member. In scenario when a member is not reachable, it shouldn't change anything. When the client and members are located in the same private network and members have configured public address (which seems to be a rare case), we're going to do only one check, just like before. So, the change should only reduce the number of attempts done in the public client-server comms scenario.\n@leszko did you consider this logic? If you did what are the benefits of the current implementation?", "author": "puzpuzpuz", "createdAt": "2020-12-04T07:10:12Z", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/spi/impl/TranslateToPublicAddressProvider.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.client.impl.spi.impl;\n+\n+import com.hazelcast.client.config.ClientConfig;\n+import com.hazelcast.client.impl.connection.AddressProvider;\n+import com.hazelcast.client.properties.ClientProperty;\n+import com.hazelcast.cluster.Address;\n+import com.hazelcast.instance.EndpointQualifier;\n+import com.hazelcast.instance.ProtocolType;\n+import com.hazelcast.internal.cluster.MemberInfo;\n+import com.hazelcast.logging.ILogger;\n+import com.hazelcast.spi.properties.HazelcastProperties;\n+\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+class TranslateToPublicAddressProvider {\n+    private static final int REACHABLE_ADDRESS_TIMEOUT_MILLIS = 1000;\n+    private static final int NON_REACHABLE_ADDRESS_TIMEOUT_MILLIS = 3000;\n+    private static final int REACHABLE_CHECK_NUMBER = 3;\n+    private static final EndpointQualifier CLIENT_PUBLIC_ENDPOINT_QUALIFIER =\n+            EndpointQualifier.resolve(ProtocolType.CLIENT, \"public\");\n+    private final ClientConfig config;\n+    private final HazelcastProperties properties;\n+    private final ILogger logger;\n+\n+    private volatile boolean translateToPublicAddress;\n+\n+    TranslateToPublicAddressProvider(ClientConfig config, HazelcastProperties properties, ILogger logger) {\n+        this.config = config;\n+        this.properties = properties;\n+        this.logger = logger;\n+    }\n+\n+    void refresh(AddressProvider addressProvider, Collection<MemberInfo> members) {\n+        translateToPublicAddress = resolve(addressProvider, members);\n+    }\n+\n+    private boolean resolve(AddressProvider addressProvider, Collection<MemberInfo> members) {\n+        if (!(addressProvider instanceof DefaultAddressProvider)) {\n+            return false;\n+        }\n+\n+        // Default value of DISCOVERY_SPI_PUBLIC_IP_ENABLED is `null` intentionally.\n+        // If DISCOVERY_SPI_PUBLIC_IP_ENABLED is not set to true/false, we don't know the intention of the user,\n+        // we will try to decide if we should use private/public address automatically in that case.\n+        String publicIpEnabledProperty = properties.getString(ClientProperty.DISCOVERY_SPI_PUBLIC_IP_ENABLED);\n+        if (publicIpEnabledProperty == null) {\n+            if (members.isEmpty() || memberInternalAddressAsDefinedInClientConfig(members)) {\n+                return false;\n+            }\n+\n+            return membersReachableOnlyViaPublicAddress(members);\n+        }\n+        return properties.getBoolean(ClientProperty.DISCOVERY_SPI_PUBLIC_IP_ENABLED);\n+    }\n+\n+    /**\n+     * Checks if any member has its internal address as configured in ClientConfig.\n+     * <p>\n+     * If any member has its internal/private address the same as configured in ClientConfig, then it means that the client is\n+     * able to connect to members via configured address. No need to use make any address translation.\n+     */\n+    boolean memberInternalAddressAsDefinedInClientConfig(Collection<MemberInfo> members) {\n+        List<String> addresses = config.getNetworkConfig().getAddresses();\n+        return members.stream()\n+                .map(MemberInfo::getAddress)\n+                .anyMatch(a -> addresses.contains(a.getHost())\n+                        || addresses.contains(String.format(\"%s:%s\", a.getHost(), a.getPort())));\n+    }\n+\n+    /**\n+     * Checks if members are reachable via public addresses, but not reachable via internal addresses.\n+     * <p>\n+     * We check only limited number of random members to reduce the slowdown of the startup.\n+     */\n+    private boolean membersReachableOnlyViaPublicAddress(Collection<MemberInfo> members) {\n+        List<MemberInfo> shuffledList = new ArrayList<>(members);\n+        Collections.shuffle(shuffledList);\n+        Iterator<MemberInfo> iter = shuffledList.iterator();\n+        for (int i = 0; i < REACHABLE_CHECK_NUMBER; i++) {\n+            if (!iter.hasNext()) {\n+                iter = shuffledList.iterator();\n+            }\n+            MemberInfo member = iter.next();\n+            Address publicAddress = member.getAddressMap().get(CLIENT_PUBLIC_ENDPOINT_QUALIFIER);\n+            if (publicAddress == null) {\n+                return false;\n+            }\n+            Address internalAddress = member.getAddress();\n+            if (isReachable(internalAddress, REACHABLE_ADDRESS_TIMEOUT_MILLIS)) {\n+                return false;\n+            }\n+            if (!isReachable(publicAddress, NON_REACHABLE_ADDRESS_TIMEOUT_MILLIS)) {", "originalCommit": "237e87732e0e1ffb06354b29f76288f11acb013e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA2ODY5OA==", "url": "https://github.com/hazelcast/hazelcast/pull/17895#discussion_r536068698", "bodyText": "Hmm, I'd keep it as it is. Here's my reasoning. Let's take AWS as an example.\n\nYou start 3 EC2 Instances (by default they have both private and public addresses)\nThis mechanism checks first the private address, so it should be fine. But if there is some random lag in the network, then\nThis mechanism checks the public address and decide to use the public address for the communication\n\nThe outcome is wrong. And it can happen, because of some random network congestion. So, I'd prefer to always check 3 times. The performance impact is not high in my option, because it affects only the case when you will actually use the public address for communication.", "author": "leszko", "createdAt": "2020-12-04T12:35:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg4MjE1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA4ODEyMA==", "url": "https://github.com/hazelcast/hazelcast/pull/17895#discussion_r536088120", "bodyText": "I didn't get the scenario. On which step the network starts misbehaving?\n\nThe performance impact is not high in my option\n\nIt's not about performance, it's about client start time. Current implementation leads to +3s in the public client-server comms scenario (success path, i.e. when the network is healthy). The proposed change will turn it into +1s.", "author": "puzpuzpuz", "createdAt": "2020-12-04T13:09:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg4MjE1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA5MTA4MA==", "url": "https://github.com/hazelcast/hazelcast/pull/17895#discussion_r536091080", "bodyText": "I didn't get the scenario. On which step the network starts misbehaving?\n\nMy point is just that making a decision based on just one network call is risky. And the scenario that Hazelcast has both private and public address is a common scenario.", "author": "leszko", "createdAt": "2020-12-04T13:14:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg4MjE1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA5NDY0Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/17895#discussion_r536094647", "bodyText": "My point is just that making a decision based on just one network call is risky\n\nIn fact, the decision is made based on two network checks: the first one is supposed to fail, while the second should succeed. And current implementation makes 6 networks calls.", "author": "puzpuzpuz", "createdAt": "2020-12-04T13:20:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg4MjE1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjEwMjcxNQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17895#discussion_r536102715", "bodyText": "Yes, but it's very common that both addresses (private and public) are reachable. Then, one false negative (of private address) gives us the wrong decision. That is why I think it's risky.", "author": "leszko", "createdAt": "2020-12-04T13:34:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg4MjE1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjExMTk2NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17895#discussion_r536111964", "bodyText": "I'm certainly fine with leaving the logic as is, but we just need to decide if it's ok to add 3 seconds to client startup time (smart and non-async start modes - which are the default). @sancar WDYT?", "author": "puzpuzpuz", "createdAt": "2020-12-04T13:49:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg4MjE1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzA3NjE0Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17895#discussion_r537076143", "bodyText": "Hard to decide really. There is one point that might make the decision easier.\nWe have one more check before the time-consuming part. We are checking if configured addresses on the client-side are the same as the member's private(internal) addresses. If matches, then we avoid time-consuming connection attempts.\nSo the setups without where clients can connect internal addresses will be fast by default most of the time. I should note that there could be still slow cases like client applications prefer to use a different network interface address than members even though both are in the same LAN(I am skipping this since it is not common).\nThis also means that cloud use cases will have an additional slow startup when the client is far. In this case, with zero configuration, we are choosing between not-working and slow startup. I would like to prefer slow startup over not-working. Users can always set it explicitly to avoid slow startup as a workaround.", "author": "sancar", "createdAt": "2020-12-06T16:46:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg4MjE1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzI2OTg1Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17895#discussion_r537269852", "bodyText": "We have one more check before the time-consuming part. We are checking if configured addresses on the client-side are the same as the member's private(internal) addresses.\n\nIn fact, we do another check before doing the network check. I'm talking about addressMap check based on the data reported by particular member. If the check is successful, it means that the member was available through member-to-member comms and reported this state some time ago.\n\nThis also means that cloud use cases will have an additional slow startup when the client is far. In this case, with zero configuration, we are choosing between not-working and slow startup. I would like to prefer slow startup over not-working.\n\nNo, we're choosing between slightly slower startup with a (probably?) less reliable detection mechanism and significantly slower startup with a more reliable mechanism.", "author": "puzpuzpuz", "createdAt": "2020-12-07T06:54:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg4MjE1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk2MTIwNg==", "url": "https://github.com/hazelcast/hazelcast/pull/17895#discussion_r535961206", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            asList(member(REACHABLE_HOST, UNREACHABLE_HOST), member(UNREACHABLE_HOST, UNREACHABLE_HOST)));\n          \n          \n            \n                            asList(member(REACHABLE_HOST, UNREACHABLE_HOST), member(REACHABLE_HOST, UNREACHABLE_HOST)));", "author": "puzpuzpuz", "createdAt": "2020-12-04T09:33:58Z", "path": "hazelcast/src/test/java/com/hazelcast/client/impl/spi/impl/TranslateToPublicAddressProviderTest.java", "diffHunk": "@@ -0,0 +1,230 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.client.impl.spi.impl;\n+\n+import com.hazelcast.client.config.ClientConfig;\n+import com.hazelcast.client.impl.connection.AddressProvider;\n+import com.hazelcast.client.impl.connection.Addresses;\n+import com.hazelcast.client.properties.ClientProperty;\n+import com.hazelcast.cluster.Address;\n+import com.hazelcast.core.Hazelcast;\n+import com.hazelcast.instance.BuildInfoProvider;\n+import com.hazelcast.instance.EndpointQualifier;\n+import com.hazelcast.instance.ProtocolType;\n+import com.hazelcast.internal.cluster.MemberInfo;\n+import com.hazelcast.logging.ILogger;\n+import com.hazelcast.spi.properties.HazelcastProperties;\n+import com.hazelcast.test.HazelcastSerialClassRunner;\n+import com.hazelcast.test.annotation.QuickTest;\n+import com.hazelcast.version.MemberVersion;\n+import org.jetbrains.annotations.NotNull;\n+import org.junit.After;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import java.net.UnknownHostException;\n+import java.util.UUID;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static java.util.Collections.singletonMap;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.Mockito.mock;\n+\n+@RunWith(HazelcastSerialClassRunner.class)\n+@Category(QuickTest.class)\n+public class TranslateToPublicAddressProviderTest {\n+    private static final MemberVersion VERSION = MemberVersion.of(BuildInfoProvider.getBuildInfo().getVersion());\n+    public static final String REACHABLE_HOST = \"127.0.0.1\";\n+    public static final String UNREACHABLE_HOST = \"192.168.0.1\";\n+\n+    private final ClientConfig config = new ClientConfig();\n+\n+    @After\n+    public void teardown() {\n+        Hazelcast.shutdownAll();\n+    }\n+\n+    @Test\n+    public void nonDefaultAddressProvider() {\n+        // given\n+        TranslateToPublicAddressProvider translateProvider = createTranslateProvider();\n+\n+        // when\n+        translateProvider.refresh(new TestAddressProvider(), null);\n+        boolean result = translateProvider.get();\n+\n+        // then\n+        assertFalse(result);\n+    }\n+\n+    @Test\n+    public void propertyTrue() {\n+        // given\n+        config.setProperty(ClientProperty.DISCOVERY_SPI_PUBLIC_IP_ENABLED.toString(), \"true\");\n+        TranslateToPublicAddressProvider translateProvider = createTranslateProvider();\n+\n+        // when\n+        translateProvider.refresh(defaultAddressProvider(), null);\n+        boolean result = translateProvider.get();\n+\n+        // then\n+        assertTrue(result);\n+    }\n+\n+    @Test\n+    public void propertyFalse() {\n+        // given\n+        config.setProperty(ClientProperty.DISCOVERY_SPI_PUBLIC_IP_ENABLED.toString(), \"false\");\n+        TranslateToPublicAddressProvider translateProvider = createTranslateProvider();\n+\n+        // when\n+        translateProvider.refresh(defaultAddressProvider(), null);\n+        boolean result = translateProvider.get();\n+\n+        // then\n+        assertFalse(result);\n+    }\n+\n+    @Test\n+    public void emptyMemberList() {\n+        // given\n+        TranslateToPublicAddressProvider translateProvider = createTranslateProvider();\n+\n+        // when\n+        translateProvider.refresh(defaultAddressProvider(), emptyList());\n+        boolean result = translateProvider.get();\n+\n+        // then\n+        assertFalse(result);\n+    }\n+\n+    @Test\n+    public void memberInternalAddressAsDefinedInClientConfig() {\n+        // given\n+        config.getNetworkConfig().addAddress(\"127.0.0.1\");\n+        TranslateToPublicAddressProvider translateProvider = createTranslateProvider();\n+\n+        // when\n+        translateProvider.refresh(defaultAddressProvider(), asList(member(\"192.168.0.1\"), member(\"127.0.0.1\")));\n+        boolean result = translateProvider.get();\n+\n+        // then\n+        assertFalse(result);\n+    }\n+\n+    @Test\n+    public void membersWithoutPublicAddresses() {\n+        // given\n+        TranslateToPublicAddressProvider translateProvider = createTranslateProvider();\n+\n+        // when\n+        translateProvider.refresh(defaultAddressProvider(), asList(member(\"127.0.0.1\")));\n+        boolean result = translateProvider.get();\n+\n+        // then\n+        assertFalse(result);\n+    }\n+\n+    @Test\n+    public void membersReachableViaInternalAddress() {\n+        // given\n+        Hazelcast.newHazelcastInstance();\n+        TranslateToPublicAddressProvider translateProvider = createTranslateProvider();\n+\n+        // when\n+        translateProvider.refresh(defaultAddressProvider(),\n+                asList(member(REACHABLE_HOST, UNREACHABLE_HOST), member(UNREACHABLE_HOST, UNREACHABLE_HOST)));", "originalCommit": "237e87732e0e1ffb06354b29f76288f11acb013e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA4Mzc5MA==", "url": "https://github.com/hazelcast/hazelcast/pull/17895#discussion_r536083790", "bodyText": "This test leads to a NPE (because member.getUuid() is null) which doesn't seems to be what it's supposed to be testing. Same story with testTranslateIsNotUsedWhenPublicIpDisabled.", "author": "puzpuzpuz", "createdAt": "2020-12-04T13:02:24Z", "path": "hazelcast/src/test/java/com/hazelcast/client/impl/connection/tcp/TcpClientConnectionManagerTranslateTest.java", "diffHunk": "@@ -72,9 +71,124 @@ public void teardown() {\n         Hazelcast.shutdownAll();\n     }\n \n+    @Test(expected = Exception.class)\n+    public void testTranslateIsUsed() {\n+        // given\n+        ClientConfig config = new ClientConfig();\n+        config.getConnectionStrategyConfig().getConnectionRetryConfig().setClusterConnectTimeoutMillis(1000);\n+        HazelcastInstance client = HazelcastClientUtil.newHazelcastClient(new TestAddressProvider(true), config);\n+        TcpClientConnectionManager clientConnectionManager =\n+                new TcpClientConnectionManager(getHazelcastClientInstanceImpl(client));\n+\n+        // when\n+        clientConnectionManager.start();\n+\n+        // then\n+        // throws exception because it can't connect to the cluster using translated public unreachable address\n+    }\n+\n+    @Test\n+    public void testTranslateIsNotUsedOnGettingExistingConnection() {\n+        // given\n+        TestAddressProvider provider = new TestAddressProvider(false);\n+        HazelcastInstance client = HazelcastClientUtil.newHazelcastClient(provider, new ClientConfig());\n+        TcpClientConnectionManager clientConnectionManager =\n+                new TcpClientConnectionManager(getHazelcastClientInstanceImpl(client));\n+\n+        clientConnectionManager.start();\n+        clientConnectionManager.reset();\n+\n+        clientConnectionManager.getOrConnectToAddress(privateAddress);\n+        provider.shouldTranslate = true;\n+\n+        // when\n+        Connection connection = clientConnectionManager.getOrConnectToAddress(privateAddress);\n+\n+        // then\n+        assertNotNull(connection);\n+    }\n+\n+    @Test\n+    public void testTranslateIsUsedWhenMemberHasPublicClientAddress() throws UnknownHostException {\n+        // given\n+        ClientConfig clientConfig = new ClientConfig();\n+        clientConfig.setProperty(ClientProperty.DISCOVERY_SPI_PUBLIC_IP_ENABLED.getName(), \"true\");\n+\n+        HazelcastInstance client = HazelcastClientUtil.newHazelcastClient(null, clientConfig);\n+        TcpClientConnectionManager clientConnectionManager =\n+                new TcpClientConnectionManager(getHazelcastClientInstanceImpl(client));\n+        clientConnectionManager.start();\n+\n+        // private member address is unreachable\n+        Member member = new MemberImpl(new Address(\"192.168.0.1\", 5701), VERSION, false, UUID.randomUUID());\n+        // public member address is reachable\n+        member.getAddressMap().put(EndpointQualifier.resolve(ProtocolType.CLIENT, \"public\"),\n+                new Address(\"127.0.0.1\", 5701));\n+\n+        // when\n+        Connection connection = clientConnectionManager.getOrConnectToMember(member);\n+\n+        // then\n+        assertNotNull(connection);\n+    }\n+\n+    @Test(expected = Exception.class)\n+    public void testTranslateIsNotUsedWhenPublicIpDisabled() throws UnknownHostException {\n+        // given\n+        ClientConfig clientConfig = new ClientConfig();\n+        clientConfig.setProperty(ClientProperty.DISCOVERY_SPI_PUBLIC_IP_ENABLED.getName(), \"false\");\n+\n+        HazelcastInstance client = HazelcastClientUtil.newHazelcastClient(null, clientConfig);\n+        TcpClientConnectionManager clientConnectionManager =\n+                new TcpClientConnectionManager(getHazelcastClientInstanceImpl(client));\n+        clientConnectionManager.start();\n+\n+        // private member address is incorrect\n+        Member member = new MemberImpl(new Address(\"192.168.0.1\", 5701), VERSION, false);\n+        // public member address is correct\n+        member.getAddressMap().put(EndpointQualifier.resolve(ProtocolType.CLIENT, \"public\"), new Address(\"127.0.0.1\", 5701));\n+\n+        // when\n+        clientConnectionManager.getOrConnectToMember(member);\n+\n+        // then\n+        // throws exception because it can't connect to the incorrect member address\n+    }\n+\n+    @Test(expected = Exception.class)\n+    public void testTranslateFromMemberIsNotUsedWhenAlreadyTranslatedByAddressProvider() throws UnknownHostException {", "originalCommit": "4e81997aa7804a461ae665e3dbef08a6df1a4b60", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzI2NTI5NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17895#discussion_r537265294", "bodyText": "Fixed", "author": "sancar", "createdAt": "2020-12-07T06:42:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA4Mzc5MA=="}], "type": "inlineReview"}, {"oid": "900fc0f3810227c0868a2b4d58a73dd9326c4498", "url": "https://github.com/hazelcast/hazelcast/commit/900fc0f3810227c0868a2b4d58a73dd9326c4498", "message": "added fine level logs to TranslateToPublicAddressProvider. And fixed a test behaviour on TranslateToPublicAddressProviderTest", "committedDate": "2020-12-06T14:47:49Z", "type": "forcePushed"}, {"oid": "0bff05ae26217321f25e1d5d7babb5e324eb0ac9", "url": "https://github.com/hazelcast/hazelcast/commit/0bff05ae26217321f25e1d5d7babb5e324eb0ac9", "message": "added fine level logs to TranslateToPublicAddressProvider. And fixed a test behaviour on TranslateToPublicAddressProviderTest", "committedDate": "2020-12-06T15:03:15Z", "type": "commit"}, {"oid": "0bff05ae26217321f25e1d5d7babb5e324eb0ac9", "url": "https://github.com/hazelcast/hazelcast/commit/0bff05ae26217321f25e1d5d7babb5e324eb0ac9", "message": "added fine level logs to TranslateToPublicAddressProvider. And fixed a test behaviour on TranslateToPublicAddressProviderTest", "committedDate": "2020-12-06T15:03:15Z", "type": "forcePushed"}, {"oid": "2752792cffc4a364488156627f5d432c857dc17f", "url": "https://github.com/hazelcast/hazelcast/commit/2752792cffc4a364488156627f5d432c857dc17f", "message": "resolve the case where one side configures hostname while other side configures ip", "committedDate": "2020-12-06T17:24:57Z", "type": "commit"}, {"oid": "2752792cffc4a364488156627f5d432c857dc17f", "url": "https://github.com/hazelcast/hazelcast/commit/2752792cffc4a364488156627f5d432c857dc17f", "message": "resolve the case where one side configures hostname while other side configures ip", "committedDate": "2020-12-06T17:24:57Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzI3Mzg0Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/17895#discussion_r537273847", "bodyText": "This check looks incorrect, as further logging is done with info level.", "author": "puzpuzpuz", "createdAt": "2020-12-07T07:05:07Z", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/spi/impl/TranslateToPublicAddressProvider.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.client.impl.spi.impl;\n+\n+import com.hazelcast.client.config.ClientNetworkConfig;\n+import com.hazelcast.client.impl.connection.AddressProvider;\n+import com.hazelcast.client.properties.ClientProperty;\n+import com.hazelcast.cluster.Address;\n+import com.hazelcast.config.SSLConfig;\n+import com.hazelcast.instance.EndpointQualifier;\n+import com.hazelcast.instance.ProtocolType;\n+import com.hazelcast.internal.cluster.MemberInfo;\n+import com.hazelcast.internal.util.AddressUtil;\n+import com.hazelcast.logging.ILogger;\n+import com.hazelcast.spi.properties.HazelcastProperties;\n+\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.UnknownHostException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+class TranslateToPublicAddressProvider {\n+    private static final int REACHABLE_ADDRESS_TIMEOUT_MILLIS = 1000;\n+    private static final int NON_REACHABLE_ADDRESS_TIMEOUT_MILLIS = 3000;\n+    private static final int REACHABLE_CHECK_NUMBER = 3;\n+    private static final EndpointQualifier CLIENT_PUBLIC_ENDPOINT_QUALIFIER =\n+            EndpointQualifier.resolve(ProtocolType.CLIENT, \"public\");\n+    private final ClientNetworkConfig config;\n+    private final HazelcastProperties properties;\n+    private final ILogger logger;\n+\n+    private volatile boolean translateToPublicAddress;\n+\n+    TranslateToPublicAddressProvider(ClientNetworkConfig config, HazelcastProperties properties, ILogger logger) {\n+        this.config = config;\n+        this.properties = properties;\n+        this.logger = logger;\n+    }\n+\n+    void refresh(AddressProvider addressProvider, Collection<MemberInfo> members) {\n+        translateToPublicAddress = resolve(addressProvider, members);\n+    }\n+\n+    private boolean resolve(AddressProvider addressProvider, Collection<MemberInfo> members) {\n+        if (!(addressProvider instanceof DefaultAddressProvider)) {\n+            return false;\n+        }\n+\n+        // Default value of DISCOVERY_SPI_PUBLIC_IP_ENABLED is `null` intentionally.\n+        // If DISCOVERY_SPI_PUBLIC_IP_ENABLED is not set to true/false, we don't know the intention of the user,\n+        // we will try to decide if we should use private/public address automatically in that case.\n+        String publicIpEnabledProperty = properties.getString(ClientProperty.DISCOVERY_SPI_PUBLIC_IP_ENABLED);\n+        if (publicIpEnabledProperty == null) {\n+            SSLConfig sslConfig = config.getSSLConfig();\n+            if (sslConfig != null && sslConfig.isEnabled()) {\n+                if (logger.isFineEnabled()) {", "originalCommit": "2752792cffc4a364488156627f5d432c857dc17f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzI3NTQ0OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17895#discussion_r537275449", "bodyText": "Ups. It should have been fine level. I don't want to log these in info level. I think it is too internal for the user to see by default.", "author": "sancar", "createdAt": "2020-12-07T07:09:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzI3Mzg0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzI4MjIzNA==", "url": "https://github.com/hazelcast/hazelcast/pull/17895#discussion_r537282234", "bodyText": "I would rather use info level. This may help users and support to understand what's going on under the hood.", "author": "puzpuzpuz", "createdAt": "2020-12-07T07:24:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzI3Mzg0Nw=="}], "type": "inlineReview"}, {"oid": "31da1e40c468854f17a845687636f366f98b9a81", "url": "https://github.com/hazelcast/hazelcast/commit/31da1e40c468854f17a845687636f366f98b9a81", "message": "fix log level typo", "committedDate": "2020-12-07T07:07:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzI5MjA5MA==", "url": "https://github.com/hazelcast/hazelcast/pull/17895#discussion_r537292090", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * able to connect to members via configured address. No need to use make any address translation.\n          \n          \n            \n                 * able to connect to members via configured address. No need to use any address translation.", "author": "puzpuzpuz", "createdAt": "2020-12-07T07:45:57Z", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/spi/impl/TranslateToPublicAddressProvider.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.client.impl.spi.impl;\n+\n+import com.hazelcast.client.config.ClientNetworkConfig;\n+import com.hazelcast.client.impl.connection.AddressProvider;\n+import com.hazelcast.client.properties.ClientProperty;\n+import com.hazelcast.cluster.Address;\n+import com.hazelcast.config.SSLConfig;\n+import com.hazelcast.instance.EndpointQualifier;\n+import com.hazelcast.instance.ProtocolType;\n+import com.hazelcast.internal.cluster.MemberInfo;\n+import com.hazelcast.internal.util.AddressUtil;\n+import com.hazelcast.logging.ILogger;\n+import com.hazelcast.spi.properties.HazelcastProperties;\n+\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.UnknownHostException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+class TranslateToPublicAddressProvider {\n+    private static final int REACHABLE_ADDRESS_TIMEOUT_MILLIS = 1000;\n+    private static final int NON_REACHABLE_ADDRESS_TIMEOUT_MILLIS = 3000;\n+    private static final int REACHABLE_CHECK_NUMBER = 3;\n+    private static final EndpointQualifier CLIENT_PUBLIC_ENDPOINT_QUALIFIER =\n+            EndpointQualifier.resolve(ProtocolType.CLIENT, \"public\");\n+    private final ClientNetworkConfig config;\n+    private final HazelcastProperties properties;\n+    private final ILogger logger;\n+\n+    private volatile boolean translateToPublicAddress;\n+\n+    TranslateToPublicAddressProvider(ClientNetworkConfig config, HazelcastProperties properties, ILogger logger) {\n+        this.config = config;\n+        this.properties = properties;\n+        this.logger = logger;\n+    }\n+\n+    void refresh(AddressProvider addressProvider, Collection<MemberInfo> members) {\n+        translateToPublicAddress = resolve(addressProvider, members);\n+    }\n+\n+    private boolean resolve(AddressProvider addressProvider, Collection<MemberInfo> members) {\n+        if (!(addressProvider instanceof DefaultAddressProvider)) {\n+            return false;\n+        }\n+\n+        // Default value of DISCOVERY_SPI_PUBLIC_IP_ENABLED is `null` intentionally.\n+        // If DISCOVERY_SPI_PUBLIC_IP_ENABLED is not set to true/false, we don't know the intention of the user,\n+        // we will try to decide if we should use private/public address automatically in that case.\n+        String publicIpEnabledProperty = properties.getString(ClientProperty.DISCOVERY_SPI_PUBLIC_IP_ENABLED);\n+        if (publicIpEnabledProperty == null) {\n+            SSLConfig sslConfig = config.getSSLConfig();\n+            if (sslConfig != null && sslConfig.isEnabled()) {\n+                if (logger.isFineEnabled()) {\n+                    logger.fine(\"SSL is configured. The client will use internal addresses to communicate with the cluster. If \"\n+                            + \"members are not reachable via private addresses, \"\n+                            + \"please set \\\"hazelcast.discovery.public.ip.enabled\\\" to true \");\n+                }\n+                return false;\n+            }\n+\n+            if (memberInternalAddressAsDefinedInClientConfig(members)) {\n+                if (logger.isFineEnabled()) {\n+                    logger.fine(\"There are internal addresses of members used in the config.\"\n+                            + \" The client will use internal addresses\");\n+                }\n+                return false;\n+            }\n+\n+            return membersReachableOnlyViaPublicAddress(members);\n+        }\n+        return properties.getBoolean(ClientProperty.DISCOVERY_SPI_PUBLIC_IP_ENABLED);\n+    }\n+\n+    /**\n+     * Checks if any member has its internal address as configured in ClientConfig.\n+     * <p>\n+     * If any member has its internal/private address the same as configured in ClientConfig, then it means that the client is\n+     * able to connect to members via configured address. No need to use make any address translation.", "originalCommit": "31da1e40c468854f17a845687636f366f98b9a81", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzI5NDY2MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17895#discussion_r537294661", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        + \"  is not reachable. The client will use internal addresses\");\n          \n          \n            \n                                        + \" is not reachable. The client will use internal addresses\");", "author": "puzpuzpuz", "createdAt": "2020-12-07T07:51:10Z", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/spi/impl/TranslateToPublicAddressProvider.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.client.impl.spi.impl;\n+\n+import com.hazelcast.client.config.ClientNetworkConfig;\n+import com.hazelcast.client.impl.connection.AddressProvider;\n+import com.hazelcast.client.properties.ClientProperty;\n+import com.hazelcast.cluster.Address;\n+import com.hazelcast.config.SSLConfig;\n+import com.hazelcast.instance.EndpointQualifier;\n+import com.hazelcast.instance.ProtocolType;\n+import com.hazelcast.internal.cluster.MemberInfo;\n+import com.hazelcast.internal.util.AddressUtil;\n+import com.hazelcast.logging.ILogger;\n+import com.hazelcast.spi.properties.HazelcastProperties;\n+\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.UnknownHostException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+class TranslateToPublicAddressProvider {\n+    private static final int REACHABLE_ADDRESS_TIMEOUT_MILLIS = 1000;\n+    private static final int NON_REACHABLE_ADDRESS_TIMEOUT_MILLIS = 3000;\n+    private static final int REACHABLE_CHECK_NUMBER = 3;\n+    private static final EndpointQualifier CLIENT_PUBLIC_ENDPOINT_QUALIFIER =\n+            EndpointQualifier.resolve(ProtocolType.CLIENT, \"public\");\n+    private final ClientNetworkConfig config;\n+    private final HazelcastProperties properties;\n+    private final ILogger logger;\n+\n+    private volatile boolean translateToPublicAddress;\n+\n+    TranslateToPublicAddressProvider(ClientNetworkConfig config, HazelcastProperties properties, ILogger logger) {\n+        this.config = config;\n+        this.properties = properties;\n+        this.logger = logger;\n+    }\n+\n+    void refresh(AddressProvider addressProvider, Collection<MemberInfo> members) {\n+        translateToPublicAddress = resolve(addressProvider, members);\n+    }\n+\n+    private boolean resolve(AddressProvider addressProvider, Collection<MemberInfo> members) {\n+        if (!(addressProvider instanceof DefaultAddressProvider)) {\n+            return false;\n+        }\n+\n+        // Default value of DISCOVERY_SPI_PUBLIC_IP_ENABLED is `null` intentionally.\n+        // If DISCOVERY_SPI_PUBLIC_IP_ENABLED is not set to true/false, we don't know the intention of the user,\n+        // we will try to decide if we should use private/public address automatically in that case.\n+        String publicIpEnabledProperty = properties.getString(ClientProperty.DISCOVERY_SPI_PUBLIC_IP_ENABLED);\n+        if (publicIpEnabledProperty == null) {\n+            SSLConfig sslConfig = config.getSSLConfig();\n+            if (sslConfig != null && sslConfig.isEnabled()) {\n+                if (logger.isFineEnabled()) {\n+                    logger.fine(\"SSL is configured. The client will use internal addresses to communicate with the cluster. If \"\n+                            + \"members are not reachable via private addresses, \"\n+                            + \"please set \\\"hazelcast.discovery.public.ip.enabled\\\" to true \");\n+                }\n+                return false;\n+            }\n+\n+            if (memberInternalAddressAsDefinedInClientConfig(members)) {\n+                if (logger.isFineEnabled()) {\n+                    logger.fine(\"There are internal addresses of members used in the config.\"\n+                            + \" The client will use internal addresses\");\n+                }\n+                return false;\n+            }\n+\n+            return membersReachableOnlyViaPublicAddress(members);\n+        }\n+        return properties.getBoolean(ClientProperty.DISCOVERY_SPI_PUBLIC_IP_ENABLED);\n+    }\n+\n+    /**\n+     * Checks if any member has its internal address as configured in ClientConfig.\n+     * <p>\n+     * If any member has its internal/private address the same as configured in ClientConfig, then it means that the client is\n+     * able to connect to members via configured address. No need to use make any address translation.\n+     */\n+    boolean memberInternalAddressAsDefinedInClientConfig(Collection<MemberInfo> members) {\n+        List<String> addresses = config.getAddresses();\n+        List<String> resolvedHosts = addresses.stream().map(s -> {\n+            try {\n+                return InetAddress.getByName(AddressUtil.getAddressHolder(s, -1).getAddress()).getHostAddress();\n+            } catch (UnknownHostException e) {\n+                return null;\n+            }\n+        }).filter(Objects::nonNull).collect(Collectors.toList());\n+        return members.stream()\n+                .map(memberInfo -> {\n+                    try {\n+                        return memberInfo.getAddress().getInetAddress().getHostAddress();\n+                    } catch (UnknownHostException e) {\n+                        return null;\n+                    }\n+                }).anyMatch(resolvedHosts::contains);\n+    }\n+\n+    /**\n+     * Checks if members are reachable via public addresses, but not reachable via internal addresses.\n+     * <p>\n+     * We check only limited number of random members to reduce the slowdown of the startup.\n+     */\n+    private boolean membersReachableOnlyViaPublicAddress(Collection<MemberInfo> members) {\n+        List<MemberInfo> shuffledList = new ArrayList<>(members);\n+        Collections.shuffle(shuffledList);\n+        Iterator<MemberInfo> iter = shuffledList.iterator();\n+        for (int i = 0; i < REACHABLE_CHECK_NUMBER; i++) {\n+            if (!iter.hasNext()) {\n+                iter = shuffledList.iterator();\n+            }\n+            MemberInfo member = iter.next();\n+            Address publicAddress = member.getAddressMap().get(CLIENT_PUBLIC_ENDPOINT_QUALIFIER);\n+            Address internalAddress = member.getAddress();\n+            if (publicAddress == null) {\n+                if (logger.isFineEnabled()) {\n+                    logger.fine(\"The public address is not available on the member. The client will use internal addresses\");\n+                }\n+                return false;\n+            }\n+            if (isReachable(internalAddress, REACHABLE_ADDRESS_TIMEOUT_MILLIS)) {\n+                if (logger.isFineEnabled()) {\n+                    logger.fine(\"The internal address is reachable. The client will use the internal addresses\");\n+                }\n+                return false;\n+            }\n+            if (!isReachable(publicAddress, NON_REACHABLE_ADDRESS_TIMEOUT_MILLIS)) {\n+                if (logger.isFineEnabled()) {\n+                    logger.fine(\"Public address + \" + publicAddress\n+                            + \"  is not reachable. The client will use internal addresses\");", "originalCommit": "31da1e40c468854f17a845687636f366f98b9a81", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}