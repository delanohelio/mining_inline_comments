{"pr_number": 675, "pr_title": "Nanopore fast5 upload and display interface", "pr_createdAt": "2020-05-04T14:12:52Z", "pr_url": "https://github.com/phac-nml/irida/pull/675", "timeline": [{"oid": "d3f03593f309c305c4bc6b7b2cd081346dba4ddf", "url": "https://github.com/phac-nml/irida/commit/d3f03593f309c305c4bc6b7b2cd081346dba4ddf", "message": "Merge branch 'fast5-model' into fast5-UI", "committedDate": "2020-05-01T09:41:07Z", "type": "commit"}, {"oid": "e780aedeb2680708c51051aed208de1acc62cab4", "url": "https://github.com/phac-nml/irida/commit/e780aedeb2680708c51051aed208de1acc62cab4", "message": "\u2728\ufe0f Upload, download and delete FAST5 through UI", "committedDate": "2020-05-01T13:56:50Z", "type": "commit"}, {"oid": "ea665b3f935305809366b1b6494f541edc3e3f75", "url": "https://github.com/phac-nml/irida/commit/ea665b3f935305809366b1b6494f541edc3e3f75", "message": "added changes to samplepairer to detect fast5 files", "committedDate": "2020-05-01T15:40:47Z", "type": "commit"}, {"oid": "3f691120aab2dcfeaff6fcfd33c2d43f6c738f91", "url": "https://github.com/phac-nml/irida/commit/3f691120aab2dcfeaff6fcfd33c2d43f6c738f91", "message": "Merge branch 'nanopore-fast5' into fast5-ui-upload", "committedDate": "2020-05-04T13:44:33Z", "type": "commit"}, {"oid": "78ae6d53e8cadf002dcead2ae1f4232060ca42b5", "url": "https://github.com/phac-nml/irida/commit/78ae6d53e8cadf002dcead2ae1f4232060ca42b5", "message": "Merge branch 'nanopore-fast5' into nanopore-fast5-UI", "committedDate": "2020-05-04T13:56:37Z", "type": "commit"}, {"oid": "1464cc304355d49f21ede2f9652ba7050e4ed81b", "url": "https://github.com/phac-nml/irida/commit/1464cc304355d49f21ede2f9652ba7050e4ed81b", "message": "Merge branch 'fast5-ui-upload' into nanopore-fast5-UI", "committedDate": "2020-05-04T14:46:58Z", "type": "commit"}, {"oid": "4c0c7429470b3322017cc9bc046704487a90306f", "url": "https://github.com/phac-nml/irida/commit/4c0c7429470b3322017cc9bc046704487a90306f", "message": "Updated to work with tom's SamplePairer code.", "committedDate": "2020-05-04T15:05:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTYxNTIwOA==", "url": "https://github.com/phac-nml/irida/pull/675#discussion_r419615208", "bodyText": "Can you pull this commented code.  Sorry that's on me I had them in my other branch.", "author": "tom114", "createdAt": "2020-05-04T17:49:07Z", "path": "src/main/java/ca/corefacility/bioinformatics/irida/ria/web/samples/SamplePairer.java", "diffHunk": "@@ -12,136 +13,136 @@\n import java.util.stream.Stream;\n \n /**\n-* \tUtility class for pairing up sequence files with\n-*\tcommon prefixes and expected characters for forward\n-*\tand reverse sequence files. \n-*/\n+ * Utility class for pairing up sequence files with\n+ * common prefixes and expected characters for forward\n+ * and reverse sequence files.\n+ */\n \n public class SamplePairer {\n-\tprivate static final Logger logger = LoggerFactory.getLogger(SamplePairer.class);\n-\n-\tprivate static DiffMatchPatch diff = new DiffMatchPatch();\n-\t\n-\tprivate static String[] forwardMatches = SequenceFilePair.forwardMatches;\n-\tprivate static String[] reverseMatches = SequenceFilePair.reverseMatches;\n-\n-\t/**\n-\t * Organize files according to whether they should be paired up\n-\t *\n-\t * @param files\n-\t *            List of {@link MultipartFile}s uploaded\n-\t * @return Map of {@link Path}s to uploaded sequence files,\n-\t * \t\t\twhere the key is the common prefix of two paired files,\n-\t * \t\t\tor the full file name of a single sequence file\n-\t */\n-\tprivate static Map<String, List<MultipartFile>> organizeFiles(List<MultipartFile> files) {\n-\n-\t\tMap<String, List<MultipartFile>> organizedFiles = new HashMap<>();\n-\n-\n-\t\tMultipartFile file1, file2;\n-\n-\t\t//Want to skip files that have already been organized\n-\t\tSet<MultipartFile> wasChecked = new HashSet<>();\n-\n-\t\t//check all uploaded files to see if they should be paired or left single\n-\t\tfor (int i = 0; i < files.size(); i++) {\n-\t\t\tfile1 = files.get(i);\n-\n-\t\t\tboolean pair = false;\n-\t\t\tif (!wasChecked.contains(file1)) {\n-\t\t\t\tfor (int j = i + 1; j < files.size() && !pair; j++) {\n-\t\t\t\t\tfile2 = files.get(j);\n-\n-\t\t\t\t\tif (!wasChecked.contains(file2)) {\n-\t\t\t\t\t\tMultipartFile[] filePair = null;\n-\n-\t\t\t\t\t\tList<Diff> diffs = diff.diff_main(file1.getOriginalFilename(), file2.getOriginalFilename());\n-\t\t\t\t\t\t//The size of `diffs` is 4 when only 1 character differs between the two strings\n-\t\t\t\t\t\t//if the two files should be paired, this would be the list of diffs between the file names:\n-\t\t\t\t\t\t//\t\tdiffs[0] = common prefix\n-\t\t\t\t\t\t//\t\tdiffs[1] = unique character 1 (e.g. \"1\" or \"f\")\n-\t\t\t\t\t\t//\t\tdiffs[2] = unique character 2 (e.g. \"2\" or \"r\")\n-\t\t\t\t\t\t//\t\tdiffs[3] = common suffix (e.g. \".fastq\")\n-\t\t\t\t\t\tif (diffs.size() == 4) {\n-\t\t\t\t\t\t\tString file1ID = diffs.get(1).text;\n-\t\t\t\t\t\t\tString file2ID = diffs.get(2).text;\n-\t\t\t\t\t\t\t//Sometimes files uploaded get put in a different ordering such that\n-\t\t\t\t\t\t\t//the first file is the \"reverse\" sequence file and the last file is\n-\t\t\t\t\t\t\t//the \"forward\" sequence file. This long condition checks for that\n-\t\t\t\t\t\t\t//situation.\n-\t\t\t\t\t\t\tif ((Stream.of(forwardMatches).anyMatch(x -> file1ID.contains(x))\n-\t\t\t\t\t\t\t\t\t&& Stream.of(reverseMatches).anyMatch(x -> file2ID.contains(x)))\n-\t\t\t\t\t\t\t\t\t|| (Stream.of(reverseMatches).anyMatch(x -> file1ID.contains(x))\n-\t\t\t\t\t\t\t\t\t&& Stream.of(forwardMatches).anyMatch(x -> file2ID.contains(x)))) {\n-\t\t\t\t\t\t\t\tfilePair = new MultipartFile[]{file1, file2};\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\tif (filePair != null) {\n-\t\t\t\t\t\t\tpair = true;\n-\t\t\t\t\t\t\torganizedFiles.put(diffs.get(0).text, Arrays.asList(filePair));\n-\t\t\t\t\t\t\tlogger.trace(\"Uploaded files [\" + filePair[0].getName() + \", \" + filePair[1].getName()\n-\t\t\t\t\t\t\t\t+ \"] were paired.\");\n-\t\t\t\t\t\t\twasChecked.add(file2);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tif (!pair) {\n-\t\t\t\t\tMultipartFile[] singleFile = {file1};\n-\t\t\t\t\torganizedFiles.put(file1.getOriginalFilename(), Arrays.asList(singleFile));\n-\t\t\t\t\tlogger.trace(\"Uploaded file [\" + file1.getName() +\"] was not paired\");\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\twasChecked.add(file1);\n-\t\t}\n-\n-\t\treturn organizedFiles;\n-\t}\n-\n-\t/**\n-\t * Get {@link Path}s to all paired sequence files\n-\t *\n-\t * @param files\n-\t *            List of {@link MultipartFile}s uploaded\n-\t * @return Map of {@link Path}s to paired sequence files.\n-\t */\n-\tpublic static Map<String, List<MultipartFile>> getPairedFiles(List<MultipartFile> files) {\n-\n-\t\tMap<String, List<MultipartFile>> pairedFiles = new HashMap<>();\n-\n-\t\tMap<String, List<MultipartFile>> allFiles = organizeFiles(files);\n-\n-\t\tfor (String key : allFiles.keySet()) {\n-\t\t\tList<MultipartFile> item = allFiles.get(key);\n-\t\t\tif (item.size() > 1) {\n-\t\t\t\tpairedFiles.put(key, item);\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn pairedFiles;\n-\t}\n-\n-\t/**\n-\t * Get {@link Path}s to all single sequence files\n-\t *\n-\t * @param files\n-\t *            List of {@link MultipartFile}s uploaded\n-\t * @return List of {@link Path}s to single sequence files.\n-\t */\n-\tpublic static List<MultipartFile> getSingleFiles(List<MultipartFile> files) {\n-\n-\t\tList<MultipartFile> singleFilePaths = new ArrayList<>();\n-\n-\t\tMap<String, List<MultipartFile>> allFiles = organizeFiles(files);\n-\n-\t\tfor (String key : allFiles.keySet()) {\n-\t\t\tList<MultipartFile> item = allFiles.get(key);\n-\t\t\tif (item.size() == 1) {\n-\t\t\t\tsingleFilePaths.add(item.get(0));\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn singleFilePaths;\n-\t}\n+    private static final Logger logger = LoggerFactory.getLogger(SamplePairer.class);\n+\n+    private static DiffMatchPatch diff = new DiffMatchPatch();\n+\n+    private static String[] forwardMatches = SequenceFilePair.forwardMatches;\n+    private static String[] reverseMatches = SequenceFilePair.reverseMatches;\n+\n+    private static String FAST5_EXTENSION = \"fast5\";\n+\n+    private Map<String, List<MultipartFile>> pairedFiles;\n+    private List<MultipartFile> fast5Files;\n+    private List<MultipartFile> singleFiles;\n+\n+    public SamplePairer(List<MultipartFile> files) {\n+        this.singleFiles = new ArrayList<>();\n+        this.pairedFiles = new HashMap<>();\n+        this.fast5Files = new ArrayList<>();\n+\n+        organizeFiles(files);\n+    }\n+\n+    /**\n+     * Organize files according to whether they should be paired up\n+     *\n+     * @param files List of {@link MultipartFile}s uploaded\n+     * @return Map of {@link Path}s to uploaded sequence files,\n+     * where the key is the common prefix of two paired files,\n+     * or the full file name of a single sequence file\n+     */\n+    private Map<String, List<MultipartFile>> organizeFiles(List<MultipartFile> files) {\n+\n+        Map<String, List<MultipartFile>> organizedFiles = new HashMap<>();\n+\n+        MultipartFile file1, file2;\n+\n+        //Want to skip files that have already been organized\n+        Set<MultipartFile> wasChecked = new HashSet<>();\n+\n+        //check all uploaded files to see if they should be paired or left single\n+        for (int i = 0; i < files.size(); i++) {\n+            file1 = files.get(i);\n+\n+            boolean pair = false;\n+            if (!wasChecked.contains(file1)) {\n+                for (int j = i + 1; j < files.size() && !pair; j++) {\n+                    file2 = files.get(j);\n+\n+                    if (!wasChecked.contains(file2)) {\n+                        MultipartFile[] filePair = null;\n+\n+                        List<Diff> diffs = diff.diff_main(file1.getOriginalFilename(), file2.getOriginalFilename());\n+                        //The size of `diffs` is 4 when only 1 character differs between the two strings\n+                        //if the two files should be paired, this would be the list of diffs between the file names:\n+                        //\t\tdiffs[0] = common prefix\n+                        //\t\tdiffs[1] = unique character 1 (e.g. \"1\" or \"f\")\n+                        //\t\tdiffs[2] = unique character 2 (e.g. \"2\" or \"r\")\n+                        //\t\tdiffs[3] = common suffix (e.g. \".fastq\")\n+                        if (diffs.size() == 4) {\n+                            String file1ID = diffs.get(1).text;\n+                            String file2ID = diffs.get(2).text;\n+                            //Sometimes files uploaded get put in a different ordering such that\n+                            //the first file is the \"reverse\" sequence file and the last file is\n+                            //the \"forward\" sequence file. This long condition checks for that\n+                            //situation.\n+                            if ((Stream.of(forwardMatches).anyMatch(x -> file1ID.contains(x))\n+                                    && Stream.of(reverseMatches).anyMatch(x -> file2ID.contains(x)))\n+                                    || (Stream.of(reverseMatches).anyMatch(x -> file1ID.contains(x))\n+                                    && Stream.of(forwardMatches).anyMatch(x -> file2ID.contains(x)))) {\n+                                filePair = new MultipartFile[]{file1, file2};\n+                            }\n+                        }\n+\n+                        if (filePair != null) {\n+                            pair = true;\n+                            //organizedFiles.put(diffs.get(0).text, Arrays.asList(filePair));", "originalCommit": "4c0c7429470b3322017cc9bc046704487a90306f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk5MjIzNA==", "url": "https://github.com/phac-nml/irida/pull/675#discussion_r419992234", "bodyText": "Updated in ea379e5", "author": "joshsadam", "createdAt": "2020-05-05T09:55:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTYxNTIwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTYxNTMwOA==", "url": "https://github.com/phac-nml/irida/pull/675#discussion_r419615308", "bodyText": "Same here.  Delete it please.", "author": "tom114", "createdAt": "2020-05-04T17:49:17Z", "path": "src/main/java/ca/corefacility/bioinformatics/irida/ria/web/samples/SamplePairer.java", "diffHunk": "@@ -12,136 +13,136 @@\n import java.util.stream.Stream;\n \n /**\n-* \tUtility class for pairing up sequence files with\n-*\tcommon prefixes and expected characters for forward\n-*\tand reverse sequence files. \n-*/\n+ * Utility class for pairing up sequence files with\n+ * common prefixes and expected characters for forward\n+ * and reverse sequence files.\n+ */\n \n public class SamplePairer {\n-\tprivate static final Logger logger = LoggerFactory.getLogger(SamplePairer.class);\n-\n-\tprivate static DiffMatchPatch diff = new DiffMatchPatch();\n-\t\n-\tprivate static String[] forwardMatches = SequenceFilePair.forwardMatches;\n-\tprivate static String[] reverseMatches = SequenceFilePair.reverseMatches;\n-\n-\t/**\n-\t * Organize files according to whether they should be paired up\n-\t *\n-\t * @param files\n-\t *            List of {@link MultipartFile}s uploaded\n-\t * @return Map of {@link Path}s to uploaded sequence files,\n-\t * \t\t\twhere the key is the common prefix of two paired files,\n-\t * \t\t\tor the full file name of a single sequence file\n-\t */\n-\tprivate static Map<String, List<MultipartFile>> organizeFiles(List<MultipartFile> files) {\n-\n-\t\tMap<String, List<MultipartFile>> organizedFiles = new HashMap<>();\n-\n-\n-\t\tMultipartFile file1, file2;\n-\n-\t\t//Want to skip files that have already been organized\n-\t\tSet<MultipartFile> wasChecked = new HashSet<>();\n-\n-\t\t//check all uploaded files to see if they should be paired or left single\n-\t\tfor (int i = 0; i < files.size(); i++) {\n-\t\t\tfile1 = files.get(i);\n-\n-\t\t\tboolean pair = false;\n-\t\t\tif (!wasChecked.contains(file1)) {\n-\t\t\t\tfor (int j = i + 1; j < files.size() && !pair; j++) {\n-\t\t\t\t\tfile2 = files.get(j);\n-\n-\t\t\t\t\tif (!wasChecked.contains(file2)) {\n-\t\t\t\t\t\tMultipartFile[] filePair = null;\n-\n-\t\t\t\t\t\tList<Diff> diffs = diff.diff_main(file1.getOriginalFilename(), file2.getOriginalFilename());\n-\t\t\t\t\t\t//The size of `diffs` is 4 when only 1 character differs between the two strings\n-\t\t\t\t\t\t//if the two files should be paired, this would be the list of diffs between the file names:\n-\t\t\t\t\t\t//\t\tdiffs[0] = common prefix\n-\t\t\t\t\t\t//\t\tdiffs[1] = unique character 1 (e.g. \"1\" or \"f\")\n-\t\t\t\t\t\t//\t\tdiffs[2] = unique character 2 (e.g. \"2\" or \"r\")\n-\t\t\t\t\t\t//\t\tdiffs[3] = common suffix (e.g. \".fastq\")\n-\t\t\t\t\t\tif (diffs.size() == 4) {\n-\t\t\t\t\t\t\tString file1ID = diffs.get(1).text;\n-\t\t\t\t\t\t\tString file2ID = diffs.get(2).text;\n-\t\t\t\t\t\t\t//Sometimes files uploaded get put in a different ordering such that\n-\t\t\t\t\t\t\t//the first file is the \"reverse\" sequence file and the last file is\n-\t\t\t\t\t\t\t//the \"forward\" sequence file. This long condition checks for that\n-\t\t\t\t\t\t\t//situation.\n-\t\t\t\t\t\t\tif ((Stream.of(forwardMatches).anyMatch(x -> file1ID.contains(x))\n-\t\t\t\t\t\t\t\t\t&& Stream.of(reverseMatches).anyMatch(x -> file2ID.contains(x)))\n-\t\t\t\t\t\t\t\t\t|| (Stream.of(reverseMatches).anyMatch(x -> file1ID.contains(x))\n-\t\t\t\t\t\t\t\t\t&& Stream.of(forwardMatches).anyMatch(x -> file2ID.contains(x)))) {\n-\t\t\t\t\t\t\t\tfilePair = new MultipartFile[]{file1, file2};\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\tif (filePair != null) {\n-\t\t\t\t\t\t\tpair = true;\n-\t\t\t\t\t\t\torganizedFiles.put(diffs.get(0).text, Arrays.asList(filePair));\n-\t\t\t\t\t\t\tlogger.trace(\"Uploaded files [\" + filePair[0].getName() + \", \" + filePair[1].getName()\n-\t\t\t\t\t\t\t\t+ \"] were paired.\");\n-\t\t\t\t\t\t\twasChecked.add(file2);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tif (!pair) {\n-\t\t\t\t\tMultipartFile[] singleFile = {file1};\n-\t\t\t\t\torganizedFiles.put(file1.getOriginalFilename(), Arrays.asList(singleFile));\n-\t\t\t\t\tlogger.trace(\"Uploaded file [\" + file1.getName() +\"] was not paired\");\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\twasChecked.add(file1);\n-\t\t}\n-\n-\t\treturn organizedFiles;\n-\t}\n-\n-\t/**\n-\t * Get {@link Path}s to all paired sequence files\n-\t *\n-\t * @param files\n-\t *            List of {@link MultipartFile}s uploaded\n-\t * @return Map of {@link Path}s to paired sequence files.\n-\t */\n-\tpublic static Map<String, List<MultipartFile>> getPairedFiles(List<MultipartFile> files) {\n-\n-\t\tMap<String, List<MultipartFile>> pairedFiles = new HashMap<>();\n-\n-\t\tMap<String, List<MultipartFile>> allFiles = organizeFiles(files);\n-\n-\t\tfor (String key : allFiles.keySet()) {\n-\t\t\tList<MultipartFile> item = allFiles.get(key);\n-\t\t\tif (item.size() > 1) {\n-\t\t\t\tpairedFiles.put(key, item);\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn pairedFiles;\n-\t}\n-\n-\t/**\n-\t * Get {@link Path}s to all single sequence files\n-\t *\n-\t * @param files\n-\t *            List of {@link MultipartFile}s uploaded\n-\t * @return List of {@link Path}s to single sequence files.\n-\t */\n-\tpublic static List<MultipartFile> getSingleFiles(List<MultipartFile> files) {\n-\n-\t\tList<MultipartFile> singleFilePaths = new ArrayList<>();\n-\n-\t\tMap<String, List<MultipartFile>> allFiles = organizeFiles(files);\n-\n-\t\tfor (String key : allFiles.keySet()) {\n-\t\t\tList<MultipartFile> item = allFiles.get(key);\n-\t\t\tif (item.size() == 1) {\n-\t\t\t\tsingleFilePaths.add(item.get(0));\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn singleFilePaths;\n-\t}\n+    private static final Logger logger = LoggerFactory.getLogger(SamplePairer.class);\n+\n+    private static DiffMatchPatch diff = new DiffMatchPatch();\n+\n+    private static String[] forwardMatches = SequenceFilePair.forwardMatches;\n+    private static String[] reverseMatches = SequenceFilePair.reverseMatches;\n+\n+    private static String FAST5_EXTENSION = \"fast5\";\n+\n+    private Map<String, List<MultipartFile>> pairedFiles;\n+    private List<MultipartFile> fast5Files;\n+    private List<MultipartFile> singleFiles;\n+\n+    public SamplePairer(List<MultipartFile> files) {\n+        this.singleFiles = new ArrayList<>();\n+        this.pairedFiles = new HashMap<>();\n+        this.fast5Files = new ArrayList<>();\n+\n+        organizeFiles(files);\n+    }\n+\n+    /**\n+     * Organize files according to whether they should be paired up\n+     *\n+     * @param files List of {@link MultipartFile}s uploaded\n+     * @return Map of {@link Path}s to uploaded sequence files,\n+     * where the key is the common prefix of two paired files,\n+     * or the full file name of a single sequence file\n+     */\n+    private Map<String, List<MultipartFile>> organizeFiles(List<MultipartFile> files) {\n+\n+        Map<String, List<MultipartFile>> organizedFiles = new HashMap<>();\n+\n+        MultipartFile file1, file2;\n+\n+        //Want to skip files that have already been organized\n+        Set<MultipartFile> wasChecked = new HashSet<>();\n+\n+        //check all uploaded files to see if they should be paired or left single\n+        for (int i = 0; i < files.size(); i++) {\n+            file1 = files.get(i);\n+\n+            boolean pair = false;\n+            if (!wasChecked.contains(file1)) {\n+                for (int j = i + 1; j < files.size() && !pair; j++) {\n+                    file2 = files.get(j);\n+\n+                    if (!wasChecked.contains(file2)) {\n+                        MultipartFile[] filePair = null;\n+\n+                        List<Diff> diffs = diff.diff_main(file1.getOriginalFilename(), file2.getOriginalFilename());\n+                        //The size of `diffs` is 4 when only 1 character differs between the two strings\n+                        //if the two files should be paired, this would be the list of diffs between the file names:\n+                        //\t\tdiffs[0] = common prefix\n+                        //\t\tdiffs[1] = unique character 1 (e.g. \"1\" or \"f\")\n+                        //\t\tdiffs[2] = unique character 2 (e.g. \"2\" or \"r\")\n+                        //\t\tdiffs[3] = common suffix (e.g. \".fastq\")\n+                        if (diffs.size() == 4) {\n+                            String file1ID = diffs.get(1).text;\n+                            String file2ID = diffs.get(2).text;\n+                            //Sometimes files uploaded get put in a different ordering such that\n+                            //the first file is the \"reverse\" sequence file and the last file is\n+                            //the \"forward\" sequence file. This long condition checks for that\n+                            //situation.\n+                            if ((Stream.of(forwardMatches).anyMatch(x -> file1ID.contains(x))\n+                                    && Stream.of(reverseMatches).anyMatch(x -> file2ID.contains(x)))\n+                                    || (Stream.of(reverseMatches).anyMatch(x -> file1ID.contains(x))\n+                                    && Stream.of(forwardMatches).anyMatch(x -> file2ID.contains(x)))) {\n+                                filePair = new MultipartFile[]{file1, file2};\n+                            }\n+                        }\n+\n+                        if (filePair != null) {\n+                            pair = true;\n+                            //organizedFiles.put(diffs.get(0).text, Arrays.asList(filePair));\n+\n+                            pairedFiles.put(diffs.get(0).text, Arrays.asList(filePair));\n+\n+                            logger.trace(\"Uploaded files [\" + filePair[0].getName() + \", \" + filePair[1].getName()\n+                                    + \"] were paired.\");\n+                            wasChecked.add(file2);\n+                        }\n+                    }\n+                }\n+                if (!pair) {\n+                    MultipartFile[] singleFile = {file1};\n+                    //organizedFiles.put(file1.getOriginalFilename(), Arrays.asList(singleFile));", "originalCommit": "4c0c7429470b3322017cc9bc046704487a90306f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk5MjI4Mw==", "url": "https://github.com/phac-nml/irida/pull/675#discussion_r419992283", "bodyText": "Updated in ea379e5", "author": "joshsadam", "createdAt": "2020-05-05T09:55:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTYxNTMwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTYxNzA1Nw==", "url": "https://github.com/phac-nml/irida/pull/675#discussion_r419617057", "bodyText": "No need to cast here.  You're not doing anything with them after they're cast. It cna just be a List of SequencingObject I think.", "author": "tom114", "createdAt": "2020-05-04T17:51:56Z", "path": "src/main/java/ca/corefacility/bioinformatics/irida/ria/web/samples/SamplesController.java", "diffHunk": "@@ -286,16 +287,24 @@ public String getSampleFiles(final Model model, @PathVariable Long projectId, @P\n \t\tSample sample = sampleService.read(sampleId);\n \t\tmodel.addAttribute(\"sampleId\", sampleId);\n \n-\t\tCollection<SampleSequencingObjectJoin> filePairJoins = sequencingObjectService\n-\t\t\t\t.getSequencesForSampleOfType(sample, SequenceFilePair.class);\n-\t\tCollection<SampleSequencingObjectJoin> singleFileJoins = sequencingObjectService\n-\t\t\t\t.getSequencesForSampleOfType(sample, SingleEndSequenceFile.class);\n+\t\tCollection<SampleSequencingObjectJoin> filePairJoins = sequencingObjectService.getSequencesForSampleOfType(\n+\t\t\t\tsample, SequenceFilePair.class);\n+\t\tCollection<SampleSequencingObjectJoin> singleFileJoins = sequencingObjectService.getSequencesForSampleOfType(\n+\t\t\t\tsample, SingleEndSequenceFile.class);\n+\t\tCollection<SampleSequencingObjectJoin> fast5FileJoins = sequencingObjectService.getSequencesForSampleOfType(\n+\t\t\t\tsample, Fast5Object.class);\n+\t\tList<Fast5Object> fast5 = fast5FileJoins.stream()\n+\t\t\t\t.map(j -> (Fast5Object) j.getObject())", "originalCommit": "4c0c7429470b3322017cc9bc046704487a90306f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk5NzU4OQ==", "url": "https://github.com/phac-nml/irida/pull/675#discussion_r419997589", "bodyText": "Updated in 0d74082", "author": "joshsadam", "createdAt": "2020-05-05T10:04:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTYxNzA1Nw=="}], "type": "inlineReview"}, {"oid": "ea379e563c249e785d87b7b7906dd0ef1aa37909", "url": "https://github.com/phac-nml/irida/commit/ea379e563c249e785d87b7b7906dd0ef1aa37909", "message": ":ok_hand: Removed commented out code", "committedDate": "2020-05-05T09:52:44Z", "type": "commit"}, {"oid": "0d74082a0fff036d27cdfcfa1007c91abbd9cee6", "url": "https://github.com/phac-nml/irida/commit/0d74082a0fff036d27cdfcfa1007c91abbd9cee6", "message": ":ok_hand: Removed unnecessary cast to fast5", "committedDate": "2020-05-05T10:03:27Z", "type": "commit"}, {"oid": "04448d4847cb221c0c8cc7f3cffd2e242c5054ed", "url": "https://github.com/phac-nml/irida/commit/04448d4847cb221c0c8cc7f3cffd2e242c5054ed", "message": ":ok_hand: Don't show no sequence file message when fat5 are available.", "committedDate": "2020-05-05T10:05:15Z", "type": "commit"}, {"oid": "82d3f5f5397234fcc0b347bf1e8f669743627243", "url": "https://github.com/phac-nml/irida/commit/82d3f5f5397234fcc0b347bf1e8f669743627243", "message": ":ok_hand: Added link to fast5 fastqc page.", "committedDate": "2020-05-05T10:13:43Z", "type": "commit"}, {"oid": "fbbf5f28d102ec8438c3e2ce9477e8ff2a9be5cf", "url": "https://github.com/phac-nml/irida/commit/fbbf5f28d102ec8438c3e2ce9477e8ff2a9be5cf", "message": "Remove unused `url` variables", "committedDate": "2020-05-05T14:58:01Z", "type": "commit"}]}