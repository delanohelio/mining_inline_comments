{"pr_number": 1127, "pr_title": "Fix sorting and ambiguous join issue", "pr_createdAt": "2020-01-06T21:11:02Z", "pr_url": "https://github.com/yahoo/elide/pull/1127", "timeline": [{"oid": "75fb02cc974d1e823b46494cf77ef7750d53330a", "url": "https://github.com/yahoo/elide/commit/75fb02cc974d1e823b46494cf77ef7750d53330a", "message": "Added sorting on aggregated metric based on latest elide-5.x", "committedDate": "2020-01-06T16:37:54Z", "type": "commit"}, {"oid": "6c5760bbf45ea446822a4e6d5da256bcddf33735", "url": "https://github.com/yahoo/elide/commit/6c5760bbf45ea446822a4e6d5da256bcddf33735", "message": "Fix ambiguity problem", "committedDate": "2020-01-06T21:05:30Z", "type": "commit"}, {"oid": "0e29d4136fdb2bf379900a51466847cf8b4154e1", "url": "https://github.com/yahoo/elide/commit/0e29d4136fdb2bf379900a51466847cf8b4154e1", "message": "update comments", "committedDate": "2020-01-07T15:52:07Z", "type": "commit"}, {"oid": "d74a853db5086ed944c099771370080df54a89c3", "url": "https://github.com/yahoo/elide/commit/d74a853db5086ed944c099771370080df54a89c3", "message": "fix codacy", "committedDate": "2020-01-07T16:20:14Z", "type": "commit"}, {"oid": "1a9857cfae96dedfa9a263ff7b4120dcbe21c11f", "url": "https://github.com/yahoo/elide/commit/1a9857cfae96dedfa9a263ff7b4120dcbe21c11f", "message": "refactor generateColumnReference", "committedDate": "2020-01-07T20:17:32Z", "type": "commit"}, {"oid": "84dfe53341f49df68f0af7de661c2d84338b0c5d", "url": "https://github.com/yahoo/elide/commit/84dfe53341f49df68f0af7de661c2d84338b0c5d", "message": "update comment", "committedDate": "2020-01-07T20:23:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk0MTU5Mg==", "url": "https://github.com/yahoo/elide/pull/1127#discussion_r363941592", "bodyText": "Let's add a unit test class (JoinTrieNodeTest) to get test coverage to a high percentage.", "author": "aklish", "createdAt": "2020-01-07T20:42:38Z", "path": "elide-core/src/main/java/com/yahoo/elide/utils/JoinTrieNode.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Copyright 2019, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.utils;\n+\n+import com.yahoo.elide.core.EntityDictionary;\n+import com.yahoo.elide.core.Path;\n+\n+import lombok.Data;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * This is a structure for storing and de-duplicating elide join paths.\n+ * Basically, it is a Trie which uses relationship field names to navigate through the path.\n+ */\n+@Data\n+public class JoinTrieNode {", "originalCommit": "84dfe53341f49df68f0af7de661c2d84338b0c5d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDI5NDk0MA==", "url": "https://github.com/yahoo/elide/pull/1127#discussion_r364294940", "bodyText": "\ud83d\udc4d", "author": "hellohanchen", "createdAt": "2020-01-08T15:38:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk0MTU5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk0MzU0NA==", "url": "https://github.com/yahoo/elide/pull/1127#discussion_r363943544", "bodyText": "The set of all fields should be contained within the query itself.  Instead of passing this in as an argument, the QueryValidator can build the list of all the fields from the query.", "author": "aklish", "createdAt": "2020-01-07T20:47:35Z", "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/QueryValidator.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Copyright 2019, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.datastores.aggregation;\n+\n+import com.yahoo.elide.core.EntityDictionary;\n+import com.yahoo.elide.core.Path;\n+import com.yahoo.elide.core.exceptions.InvalidOperationException;\n+import com.yahoo.elide.core.filter.FilterPredicate;\n+import com.yahoo.elide.core.filter.expression.AndFilterExpression;\n+import com.yahoo.elide.core.filter.expression.FilterExpression;\n+import com.yahoo.elide.core.filter.expression.NotFilterExpression;\n+import com.yahoo.elide.core.filter.expression.OrFilterExpression;\n+import com.yahoo.elide.core.sort.Sorting;\n+import com.yahoo.elide.datastores.aggregation.metadata.metric.MetricFunctionInvocation;\n+import com.yahoo.elide.datastores.aggregation.metadata.models.AnalyticView;\n+import com.yahoo.elide.datastores.aggregation.query.ColumnProjection;\n+import com.yahoo.elide.datastores.aggregation.query.Query;\n+import org.apache.commons.collections.CollectionUtils;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+public class QueryValidator {\n+\n+    private Query query;\n+    private Set<String> allFields;\n+    private EntityDictionary dictionary;\n+    private Class<?> type;\n+    private AnalyticView queriedTable;\n+    private List<MetricFunctionInvocation> metrics;\n+    private Set<ColumnProjection> dimensionProjections;\n+\n+    public QueryValidator(Query query, Set<String> allFields, EntityDictionary dictionary, Class<?> type) {", "originalCommit": "84dfe53341f49df68f0af7de661c2d84338b0c5d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk0MzY5Mw==", "url": "https://github.com/yahoo/elide/pull/1127#discussion_r363943693", "bodyText": "Same comment applies to the type argument.", "author": "aklish", "createdAt": "2020-01-07T20:48:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk0MzU0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDMwMDMzMQ==", "url": "https://github.com/yahoo/elide/pull/1127#discussion_r364300331", "bodyText": "Type is fixed, for the fields one, the projections in the query are using alias, but the sorting clauses is still using fieldname, so I think it is ok to keep allFields for now.", "author": "hellohanchen", "createdAt": "2020-01-08T15:48:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk0MzU0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ1OTk4Mg==", "url": "https://github.com/yahoo/elide/pull/1127#discussion_r364459982", "bodyText": "\ud83d\udc4d", "author": "aklish", "createdAt": "2020-01-08T21:48:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk0MzU0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk0NTY2OQ==", "url": "https://github.com/yahoo/elide/pull/1127#discussion_r363945669", "bodyText": "I think we should try to make the errors friendly to a client of Elide - so we should remove things like \"classes\".\nLet's rephrase in terms of what is wrong with the API request.", "author": "aklish", "createdAt": "2020-01-07T20:53:12Z", "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/QueryValidator.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Copyright 2019, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.datastores.aggregation;\n+\n+import com.yahoo.elide.core.EntityDictionary;\n+import com.yahoo.elide.core.Path;\n+import com.yahoo.elide.core.exceptions.InvalidOperationException;\n+import com.yahoo.elide.core.filter.FilterPredicate;\n+import com.yahoo.elide.core.filter.expression.AndFilterExpression;\n+import com.yahoo.elide.core.filter.expression.FilterExpression;\n+import com.yahoo.elide.core.filter.expression.NotFilterExpression;\n+import com.yahoo.elide.core.filter.expression.OrFilterExpression;\n+import com.yahoo.elide.core.sort.Sorting;\n+import com.yahoo.elide.datastores.aggregation.metadata.metric.MetricFunctionInvocation;\n+import com.yahoo.elide.datastores.aggregation.metadata.models.AnalyticView;\n+import com.yahoo.elide.datastores.aggregation.query.ColumnProjection;\n+import com.yahoo.elide.datastores.aggregation.query.Query;\n+import org.apache.commons.collections.CollectionUtils;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+public class QueryValidator {\n+\n+    private Query query;\n+    private Set<String> allFields;\n+    private EntityDictionary dictionary;\n+    private Class<?> type;\n+    private AnalyticView queriedTable;\n+    private List<MetricFunctionInvocation> metrics;\n+    private Set<ColumnProjection> dimensionProjections;\n+\n+    public QueryValidator(Query query, Set<String> allFields, EntityDictionary dictionary, Class<?> type) {\n+        this.query = query;\n+        this.allFields = allFields;\n+        this.dictionary = dictionary;\n+        this.type = type;\n+        this.queriedTable = query.getAnalyticView();\n+        this.metrics = query.getMetrics();\n+        this.dimensionProjections = query.getDimensions();\n+    }\n+\n+    /**\n+     * Method that handles all checks to make sure query is valid before we attempt to execute the query.\n+     */\n+    public void validate() {\n+        FilterExpression havingClause = query.getHavingFilter();\n+        validateHavingClause(havingClause);\n+        validateSorting();\n+        validateMetricFunction();\n+    }\n+\n+    /**\n+     * Checks to make sure at least one metric is being aggregated on.\n+     */\n+    private void validateMetricFunction() {\n+        if (CollectionUtils.isEmpty(metrics)) {\n+            throw new InvalidOperationException(\"Must provide at least one metric in query\");\n+        }\n+    }\n+\n+    /**\n+     * Validate the having clause before execution. Having clause is not as flexible as where clause,\n+     * the fields in having clause must be either or these two:\n+     * 1. A grouped by dimension in this query\n+     * 2. An aggregated metric in this query\n+     *\n+     * All grouped by dimensions are defined in the entity bean, so the last entity class of a filter path\n+     * must match entity class of the query.\n+     *\n+     * @param havingClause having clause generated from this query\n+     */\n+    private void validateHavingClause(FilterExpression havingClause) {\n+        // TODO: support having clause for alias\n+        if (havingClause instanceof FilterPredicate) {\n+            Path path = ((FilterPredicate) havingClause).getPath();\n+            Path.PathElement last = path.lastElement().get();\n+            Class<?> cls = last.getType();\n+            String fieldName = last.getFieldName();\n+\n+            if (cls != queriedTable.getCls()) {\n+                throw new InvalidOperationException(\n+                        String.format(\n+                                \"Classes don't match when try filtering on %s in having clause of %s.\",", "originalCommit": "84dfe53341f49df68f0af7de661c2d84338b0c5d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDMwNDMyOQ==", "url": "https://github.com/yahoo/elide/pull/1127#discussion_r364304329", "bodyText": "\ud83d\udc4d", "author": "hellohanchen", "createdAt": "2020-01-08T15:55:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk0NTY2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk0NjI2OA==", "url": "https://github.com/yahoo/elide/pull/1127#discussion_r363946268", "bodyText": "Let's create a Unit Test class (QueryValidatorTest) for this class and verify all of the corner cases.", "author": "aklish", "createdAt": "2020-01-07T20:54:45Z", "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/QueryValidator.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Copyright 2019, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.datastores.aggregation;\n+\n+import com.yahoo.elide.core.EntityDictionary;\n+import com.yahoo.elide.core.Path;\n+import com.yahoo.elide.core.exceptions.InvalidOperationException;\n+import com.yahoo.elide.core.filter.FilterPredicate;\n+import com.yahoo.elide.core.filter.expression.AndFilterExpression;\n+import com.yahoo.elide.core.filter.expression.FilterExpression;\n+import com.yahoo.elide.core.filter.expression.NotFilterExpression;\n+import com.yahoo.elide.core.filter.expression.OrFilterExpression;\n+import com.yahoo.elide.core.sort.Sorting;\n+import com.yahoo.elide.datastores.aggregation.metadata.metric.MetricFunctionInvocation;\n+import com.yahoo.elide.datastores.aggregation.metadata.models.AnalyticView;\n+import com.yahoo.elide.datastores.aggregation.query.ColumnProjection;\n+import com.yahoo.elide.datastores.aggregation.query.Query;\n+import org.apache.commons.collections.CollectionUtils;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+public class QueryValidator {", "originalCommit": "84dfe53341f49df68f0af7de661c2d84338b0c5d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDM0MjY2Mg==", "url": "https://github.com/yahoo/elide/pull/1127#discussion_r364342662", "bodyText": "QueryValidator and EntityProjectionTranslator are tested in integration test.", "author": "hellohanchen", "createdAt": "2020-01-08T17:08:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk0NjI2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ1NTE2MA==", "url": "https://github.com/yahoo/elide/pull/1127#discussion_r364455160", "bodyText": "We should be doing more testing in unit tests.  Unit test are easer to maintain.  They also execute faster and keep the build times more reasonable.", "author": "aklish", "createdAt": "2020-01-08T21:36:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk0NjI2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDg5MTE4MQ==", "url": "https://github.com/yahoo/elide/pull/1127#discussion_r364891181", "bodyText": "\ud83d\udc4d", "author": "hellohanchen", "createdAt": "2020-01-09T18:22:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk0NjI2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk0ODQ1Ng==", "url": "https://github.com/yahoo/elide/pull/1127#discussion_r363948456", "bodyText": "I\"m not sure about the model.\nA player isn't tied to another player directly.  They are tied together through a match or game.", "author": "aklish", "createdAt": "2020-01-07T21:00:14Z", "path": "elide-datastore/elide-datastore-aggregation/src/test/java/com/yahoo/elide/datastores/aggregation/example/Player.java", "diffHunk": "@@ -31,4 +32,8 @@\n \n     @FriendlyName\n     private String name;\n+\n+    @OneToOne\n+    @JoinColumn(name = \"opponent_id\")\n+    private Player opponent;", "originalCommit": "84dfe53341f49df68f0af7de661c2d84338b0c5d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDMwOTg5OA==", "url": "https://github.com/yahoo/elide/pull/1127#discussion_r364309898", "bodyText": "\ud83d\udc4d This field is not needed and removed.", "author": "hellohanchen", "createdAt": "2020-01-08T16:05:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk0ODQ1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk1MzAxMA==", "url": "https://github.com/yahoo/elide/pull/1127#discussion_r363953010", "bodyText": "I think we ought to break this up into two functions.  The trie data structure ought to have a function for streaming the contents or something.\nThis function can take the result of that and build the join strings.", "author": "aklish", "createdAt": "2020-01-07T21:12:14Z", "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/queryengines/sql/SQLQueryConstructor.java", "diffHunk": "@@ -203,42 +208,74 @@ private String constructProjectionWithReference(SQLQueryTemplate template, SQLAn\n     }\n \n     /**\n-     * Given one component of the path taken to reach a particular field, extracts any table\n-     * joins that are required to perform the traversal to the field.\n+     * Build full join clause for all join paths in a {@link JoinTrieNode}.\n+     *\n+     * @param root root node which type is the queried table class\n+     * @return built join clause that contains all needed relationship dimension joins for this query.\n+     */\n+    private String extractJoin(JoinTrieNode root) {", "originalCommit": "84dfe53341f49df68f0af7de661c2d84338b0c5d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDMzMDE5MA==", "url": "https://github.com/yahoo/elide/pull/1127#discussion_r364330190", "bodyText": "\ud83d\udc4d", "author": "hellohanchen", "createdAt": "2020-01-08T16:42:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk1MzAxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk1NDI2NQ==", "url": "https://github.com/yahoo/elide/pull/1127#discussion_r363954265", "bodyText": "Logic to construct the alias name should ideally be centralized to a single place.", "author": "aklish", "createdAt": "2020-01-07T21:15:40Z", "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/queryengines/sql/SQLQueryConstructor.java", "diffHunk": "@@ -203,42 +208,74 @@ private String constructProjectionWithReference(SQLQueryTemplate template, SQLAn\n     }\n \n     /**\n-     * Given one component of the path taken to reach a particular field, extracts any table\n-     * joins that are required to perform the traversal to the field.\n+     * Build full join clause for all join paths in a {@link JoinTrieNode}.\n+     *\n+     * @param root root node which type is the queried table class\n+     * @return built join clause that contains all needed relationship dimension joins for this query.\n+     */\n+    private String extractJoin(JoinTrieNode root) {\n+        // parentAlias-JoinTrieNode pairs queue\n+        Queue<Pair<String, JoinTrieNode>> todo = new ArrayDeque<>();\n+\n+        todo.add(new Pair<>(getClassAlias(root.getType()), root));\n+        List<String> joinClauses = new ArrayList<>();\n+\n+        while (!todo.isEmpty()) {\n+            Pair<String, JoinTrieNode> current = todo.remove();\n+            String parentAlias = current.getKey();\n+            JoinTrieNode parent = current.getValue();\n+            Map<String, JoinTrieNode> fields = parent.getFields();\n+\n+            fields.forEach((name, child) -> {\n+                joinClauses.add(extractJoin(parent.getType(), parentAlias, child.getType(), name));\n+\n+                if (child.getFields().size() > 0) {\n+                    todo.add(new Pair<>(parentAlias + \"_\" + name, child));", "originalCommit": "84dfe53341f49df68f0af7de661c2d84338b0c5d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDMzMTc4Nw==", "url": "https://github.com/yahoo/elide/pull/1127#discussion_r364331787", "bodyText": "\ud83d\udc4d", "author": "hellohanchen", "createdAt": "2020-01-08T16:45:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk1NDI2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk1OTc5NQ==", "url": "https://github.com/yahoo/elide/pull/1127#discussion_r363959795", "bodyText": "We should avoid spreading out the logic to generate aliases.", "author": "aklish", "createdAt": "2020-01-07T21:29:30Z", "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/queryengines/sql/SQLQueryEngine.java", "diffHunk": "@@ -252,4 +277,24 @@ private SQLQuery toPageTotalSQL(SQLQuery sql) {\n     public static String getClassAlias(Class<?> entityClass) {\n         return FilterPredicate.getTypeAlias(entityClass);\n     }\n+\n+    /**\n+     * Generate alias for represent the join path.\n+     * The path would start with the class alias of the first element, and then each field would append \"_fieldName\" to\n+     * the result.\n+     * The last element would not be included as that's not a part of the join path.\n+     *\n+     * @param path path that represents a relationship chain\n+     * @return join path alias, i.e. <code>foo.bar.baz</code> would be <code>foo_bar</code>\n+     */\n+    public static String getJoinPathAlias(Path path) {\n+        List<Path.PathElement> elements = path.getPathElements();\n+        StringBuilder result = new StringBuilder(getClassAlias(elements.get(0).getType()));\n+\n+        for (int i = 0; i < elements.size() - 1; i++) {\n+            result.append(\"_\").append(elements.get(i).getFieldName());", "originalCommit": "84dfe53341f49df68f0af7de661c2d84338b0c5d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk2MDA3NQ==", "url": "https://github.com/yahoo/elide/pull/1127#discussion_r363960075", "bodyText": "I believe this used to live in a single place in Elide.", "author": "aklish", "createdAt": "2020-01-07T21:30:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk1OTc5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDMzMTgzOQ==", "url": "https://github.com/yahoo/elide/pull/1127#discussion_r364331839", "bodyText": "\ud83d\udc4d", "author": "hellohanchen", "createdAt": "2020-01-08T16:45:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk1OTc5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk3OTkzOQ==", "url": "https://github.com/yahoo/elide/pull/1127#discussion_r363979939", "bodyText": "What is this trying to test?", "author": "aklish", "createdAt": "2020-01-07T22:20:22Z", "path": "elide-datastore/elide-datastore-aggregation/src/test/java/com/yahoo/elide/datastores/aggregation/AggregationDataStoreIntegrationTest.java", "diffHunk": "@@ -502,10 +506,298 @@ public void timeGrainAggregationTest() throws Exception {\n                                 \"playerStats\",\n                                 selections(\n                                         field(\"highScore\", 2412),\n-                                        field(\"recordedDate\", \"2019-07-01T00:00Z\")\n+                                        field(\n+                                                \"country\",\n+                                                selections(\n+                                                        field(\"name\", \"United States\")\n+                                                )\n+                                        )\n+                                ),\n+                                selections(\n+                                        field(\"highScore\", 1000),\n+                                        field(\n+                                                \"country\",\n+                                                selections(\n+                                                        field(\"name\", \"Hong Kong\")\n+                                                )\n+                                        )\n+                                )\n+                        )\n+                )\n+        ).toResponse();\n+\n+        runQueryWithExpectedResult(graphQLRequest, expected);\n+    }\n+\n+    @Test\n+    public void nestedDimensionNotInQuerySortingTest() throws Exception {\n+        String graphQLRequest = document(\n+                selection(\n+                        field(\n+                                \"playerStats\",\n+                                arguments(\n+                                        argument(\"sort\", \"\\\"-country.name,lowScore\\\"\")\n+                                ),\n+                                selections(\n+                                        field(\"lowScore\")\n+                                )\n+                        )\n+                )\n+        ).toQuery();\n+\n+        String expected = \"\\\"Exception while fetching data (/playerStats) : Invalid operation: 'Can't sort on country as it is not present in query'\\\"\";\n+\n+        runQueryWithExpectedError(graphQLRequest, expected);\n+    }\n+\n+    @Test\n+    public void sortingOnIdTest() throws Exception {\n+        String graphQLRequest = document(\n+                selection(\n+                        field(\n+                                \"playerStats\",\n+                                arguments(\n+                                        argument(\"sort\", \"\\\"id\\\"\")\n+                                ),\n+                                selections(\n+                                        field(\"lowScore\"),\n+                                        field(\"id\")\n+                                )\n+                        )\n+                )\n+        ).toQuery();\n+\n+        String expected = \"\\\"Exception while fetching data (/playerStats) : Invalid operation: 'Sorting on id field is not permitted'\\\"\";\n+\n+        runQueryWithExpectedError(graphQLRequest, expected);\n+    }\n+\n+    @Test\n+    public void multipleColumnsSortingTest() throws Exception {\n+        String graphQLRequest = document(\n+                selection(\n+                        field(\n+                                \"playerStats\",\n+                                arguments(\n+                                        argument(\"sort\", \"\\\"overallRating,player.name\\\"\")\n+                                ),\n+                                selections(\n+                                        field(\"overallRating\"),\n+                                        field(\"lowScore\"),\n+                                        field(\n+                                                \"player\",\n+                                                selections(\n+                                                        field(\"name\")\n+                                                )\n+                                        )\n+                                )\n+                        )\n+                )\n+        ).toQuery();\n+\n+        String expected = document(\n+                selections(\n+                        field(\n+                                \"playerStats\",\n+                                selections(\n+                                        field(\"overallRating\", \"Good\"),\n+                                        field(\"lowScore\", 72),\n+                                        field(\n+                                                \"player\",\n+                                                selections(\n+                                                        field(\"name\", \"Han\")\n+                                                )\n+                                        )\n+                                ),\n+                                selections(\n+                                        field(\"overallRating\", \"Good\"),\n+                                        field(\"lowScore\", 35),\n+                                        field(\n+                                                \"player\",\n+                                                selections(\n+                                                        field(\"name\", \"Jon Doe\")\n+                                                )\n+                                        )\n+                                ),\n+                                selections(\n+                                        field(\"overallRating\", \"Great\"),\n+                                        field(\"lowScore\", 241),\n+                                        field(\n+                                                \"player\",\n+                                                selections(\n+                                                        field(\"name\", \"Jane Doe\")\n+                                                )\n+                                        )\n                                 )\n                         )\n-                )).toResponse();\n+                )\n+        ).toResponse();\n+\n+        runQueryWithExpectedResult(graphQLRequest, expected);\n+    }\n+\n+    @Test\n+    public void sortingOnMetricNotInQueryTest() throws Exception {\n+        String graphQLRequest = document(\n+                selection(\n+                        field(\n+                                \"playerStats\",\n+                                arguments(\n+                                        argument(\"sort\", \"\\\"highScore\\\"\")\n+                                ),\n+                                selections(\n+                                        field(\"lowScore\"),\n+                                        field(\n+                                                \"country\",\n+                                                selections(\n+                                                        field(\"name\")\n+                                                )\n+                                        )\n+                                )\n+                        )\n+                )\n+        ).toQuery();\n+\n+        String expected = \"\\\"Exception while fetching data (/playerStats) : Invalid operation: 'Can't sort on highScore as it is not present in query'\\\"\";\n+\n+        runQueryWithExpectedError(graphQLRequest, expected);\n+    }\n+\n+    @Test\n+    public void noMetricQueryTest() throws Exception {\n+        String graphQLRequest = document(\n+                selection(\n+                        field(\n+                                \"playerStats\",\n+                                selections(\n+                                        field(\n+                                                \"country\",\n+                                                selections(\n+                                                        field(\"name\")\n+                                                )\n+                                        )\n+                                )\n+                        )\n+                )\n+        ).toQuery();\n+\n+        String expected = \"\\\"Exception while fetching data (/playerStats) : Invalid operation: 'Must provide at least one metric in query'\\\"\";\n+\n+        runQueryWithExpectedError(graphQLRequest, expected);\n+    }\n+\n+    @Test\n+    public void sortingMultipleLevelNesting() throws Exception {\n+        String graphQLRequest = document(\n+                selection(\n+                        field(\n+                                \"playerStats\",\n+                                arguments(\n+                                        argument(\"sort\", \"\\\"country.continent.name\\\"\")\n+                                ),\n+                                selections(\n+                                        field(\"lowScore\"),\n+                                        field(\n+                                                \"country\",\n+                                                selections(\n+                                                        field(\"name\"),\n+                                                        field(\n+                                                                \"continent\",\n+                                                                selections(\n+                                                                        field(\"name\")\n+                                                                )\n+                                                        )\n+                                                )\n+                                        )\n+                                )\n+                        )\n+                )\n+        ).toQuery();\n+\n+        String expected = \"\\\"Exception while fetching data (/playerStats) : Currently sorting on double nested fields is not supported\\\"\";\n+\n+        runQueryWithExpectedError(graphQLRequest, expected);\n+    }\n+\n+    @Test\n+    public void ambiguousFieldTest() throws Exception {", "originalCommit": "84dfe53341f49df68f0af7de661c2d84338b0c5d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDMzMjM1MQ==", "url": "https://github.com/yahoo/elide/pull/1127#discussion_r364332351", "bodyText": "Previously, when we join to two different relationship fields which have the same type, the join would cause ambiguity as the two joined table share the same alias.", "author": "hellohanchen", "createdAt": "2020-01-08T16:46:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk3OTkzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ1OTI5OA==", "url": "https://github.com/yahoo/elide/pull/1127#discussion_r364459298", "bodyText": "This kind of test would be clearer as a Unit test that verifies the SQL that gets generated by the ambiguity.", "author": "aklish", "createdAt": "2020-01-08T21:47:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk3OTkzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ2NzE1NA==", "url": "https://github.com/yahoo/elide/pull/1127#discussion_r364467154", "bodyText": "\ud83d\udc4d", "author": "hellohanchen", "createdAt": "2020-01-08T22:07:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk3OTkzOQ=="}], "type": "inlineReview"}, {"oid": "3e6577d3575b10eadf902a215adc6b5576a9a626", "url": "https://github.com/yahoo/elide/commit/3e6577d3575b10eadf902a215adc6b5576a9a626", "message": "address comments", "committedDate": "2020-01-08T16:50:47Z", "type": "commit"}, {"oid": "2098cf8c16357a5af495bcc3223dd9b7c5427fe4", "url": "https://github.com/yahoo/elide/commit/2098cf8c16357a5af495bcc3223dd9b7c5427fe4", "message": "test cleanup", "committedDate": "2020-01-08T17:07:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ1NjAyOA==", "url": "https://github.com/yahoo/elide/pull/1127#discussion_r364456028", "bodyText": "This is still duplicating alias generation with the original Elide Code in FilterPredicate.  I think we should refactor so alias generation happens once across the board.", "author": "aklish", "createdAt": "2020-01-08T21:38:57Z", "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/queryengines/sql/SQLQueryEngine.java", "diffHunk": "@@ -289,12 +289,23 @@ public static String getClassAlias(Class<?> entityClass) {\n      */\n     public static String getJoinPathAlias(Path path) {\n         List<Path.PathElement> elements = path.getPathElements();\n-        StringBuilder result = new StringBuilder(getClassAlias(elements.get(0).getType()));\n+        String result = getClassAlias(elements.get(0).getType());\n \n         for (int i = 0; i < elements.size() - 1; i++) {\n-            result.append(\"_\").append(elements.get(i).getFieldName());\n+            result = appendAlias(result, elements.get(i).getFieldName());\n         }\n \n-        return result.toString();\n+        return result;\n+    }\n+\n+    /**\n+     * Append a new field to a parent alias to get new alias.\n+     *\n+     * @param parentAlias parent path alias\n+     * @param fieldName field name\n+     * @return alias for the field\n+     */\n+    public static String appendAlias(String parentAlias, String fieldName) {", "originalCommit": "3e6577d3575b10eadf902a215adc6b5576a9a626", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ4NjM5NQ==", "url": "https://github.com/yahoo/elide/pull/1127#discussion_r364486395", "bodyText": "Fixed.", "author": "hellohanchen", "createdAt": "2020-01-08T23:01:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ1NjAyOA=="}], "type": "inlineReview"}, {"oid": "e0599106c202e765fc71363b90791bd492f88904", "url": "https://github.com/yahoo/elide/commit/e0599106c202e765fc71363b90791bd492f88904", "message": "update unittest", "committedDate": "2020-01-08T22:06:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ3MzM0OA==", "url": "https://github.com/yahoo/elide/pull/1127#discussion_r364473348", "bodyText": "I think this function should take no functional arguments, and instead just return a list or a stream of Paths.", "author": "aklish", "createdAt": "2020-01-08T22:23:43Z", "path": "elide-core/src/main/java/com/yahoo/elide/utils/JoinTrieNode.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2019, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.utils;\n+\n+import com.yahoo.elide.core.EntityDictionary;\n+import com.yahoo.elide.core.Path;\n+\n+import javafx.util.Pair;\n+import lombok.Data;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.function.BiFunction;\n+\n+/**\n+ * This is a structure for storing and de-duplicating elide join paths.\n+ * Basically, it is a Trie which uses relationship field names to navigate through the path.\n+ */\n+@Data\n+public class JoinTrieNode {\n+    private final Class<?> type;\n+    private final Map<String, JoinTrieNode> fields = new HashMap<>();\n+\n+    public JoinTrieNode(Class<?> type) {\n+        this.type = type;\n+    }\n+\n+    public void addPaths(Set<Path> paths, EntityDictionary dictionary) {\n+        paths.forEach(path -> addPath(path, dictionary));\n+    }\n+\n+    /**\n+     * Add all path elements into this Trie, starting from the root.\n+     *\n+     * @param path full Elide join path, i.e. <code>foo.bar.baz</code>\n+     * @param dictionary dictionary to use.\n+     */\n+    public void addPath(Path path, EntityDictionary dictionary) {\n+        JoinTrieNode node = this;\n+\n+        for (Path.PathElement pathElement : path.getPathElements()) {\n+            Class<?> entityClass = pathElement.getType();\n+            String fieldName = pathElement.getFieldName();\n+\n+            if (!dictionary.isRelation(entityClass, fieldName)) {\n+                break;\n+            }\n+\n+            if (!fields.containsKey(fieldName)) {\n+                node.addField(fieldName, new JoinTrieNode(pathElement.getFieldType()));\n+\n+            }\n+\n+            node = fields.get(fieldName);\n+        }\n+    }\n+\n+    /**\n+     * Attach a field to this node.\n+     *\n+     * @param fieldName field name\n+     * @param node field node\n+     */\n+    private void addField(String fieldName, JoinTrieNode node) {\n+        fields.put(fieldName, node);\n+    }\n+\n+    /**\n+     * Traverse this Trie and project the result into a list in level-first-order.\n+     * This previous result-node pair would be carried through the traversal.\n+     *\n+     * @param generator function that generate new results from previous result-node pair and new trie field\n+     * @param traverser function that carry previous result for next level traversal\n+     * @param identity initial result value\n+     * @param <T> type of each individual result\n+     * @return resulted projected in a list in level-first-order.\n+     */\n+    public <T> List<T> levelOrderedTraverse(", "originalCommit": "2098cf8c16357a5af495bcc3223dd9b7c5427fe4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ4ODMwOA==", "url": "https://github.com/yahoo/elide/pull/1127#discussion_r364488308", "bodyText": "My opinion is that if we already have a list of Paths, then we don't need to use this Trie.\nThe purpose of this Trie is to deduplicate common path elements between multiple lists of Paths. So once it is deduplicated, the method can just provide function interfaces for Trie to traverse itself.", "author": "hellohanchen", "createdAt": "2020-01-08T23:06:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ3MzM0OA=="}], "type": "inlineReview"}, {"oid": "b26bf257fc856b382aeeea40785da37f890b0c93", "url": "https://github.com/yahoo/elide/commit/b26bf257fc856b382aeeea40785da37f890b0c93", "message": "fix elide core alias", "committedDate": "2020-01-08T23:00:34Z", "type": "commit"}, {"oid": "0dc607286ae6dc5437f9b8942bd3ec0d2bd0779d", "url": "https://github.com/yahoo/elide/commit/0dc607286ae6dc5437f9b8942bd3ec0d2bd0779d", "message": "QueryValidatorTest", "committedDate": "2020-01-09T16:43:12Z", "type": "commit"}, {"oid": "5c0503f01a3d39ca689277d947f5516a5035dcc8", "url": "https://github.com/yahoo/elide/commit/5c0503f01a3d39ca689277d947f5516a5035dcc8", "message": "EntityProjectionTranslatorTest", "committedDate": "2020-01-09T18:16:52Z", "type": "commit"}, {"oid": "221ff8ad785389fc72b7bf671bb857bc9f8a0379", "url": "https://github.com/yahoo/elide/commit/221ff8ad785389fc72b7bf671bb857bc9f8a0379", "message": "go joinFragment approach", "committedDate": "2020-01-09T21:51:23Z", "type": "commit"}, {"oid": "c05c595cfa0c87eddd79c7383e86afb53112a621", "url": "https://github.com/yahoo/elide/commit/c05c595cfa0c87eddd79c7383e86afb53112a621", "message": "delete jointrienode", "committedDate": "2020-01-09T22:55:12Z", "type": "commit"}]}