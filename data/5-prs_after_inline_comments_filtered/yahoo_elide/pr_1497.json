{"pr_number": 1497, "pr_title": "Support dynamic configuration for db connections", "pr_createdAt": "2020-08-11T13:57:35Z", "pr_url": "https://github.com/yahoo/elide/pull/1497", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODgzODQ1NA==", "url": "https://github.com/yahoo/elide/pull/1497#discussion_r468838454", "bodyText": "Please add a TODO comment here for the remaining work done in next PR.", "author": "moizarafat", "createdAt": "2020-08-11T20:15:28Z", "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/queryengines/sql/annotation/FromTable.java", "diffHunk": "@@ -25,4 +25,10 @@\n      * @return The table or view name.\n      */\n     String name();\n+\n+    /**\n+     * DB Connection Name for this table\n+     * @return String DB Connection Name\n+     */", "originalCommit": "c09baf3777f462dd8a13bc935d75c088746cbe2f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIxMTQ0OA==", "url": "https://github.com/yahoo/elide/pull/1497#discussion_r470211448", "bodyText": "Why is called type here and dbConnection name in the other annotation?  Can we be consistent?", "author": "aklish", "createdAt": "2020-08-13T19:57:06Z", "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/queryengines/sql/annotation/FromSubquery.java", "diffHunk": "@@ -25,4 +25,11 @@\n      * @return The SQL subquery.\n      */\n     String sql();\n+\n+    /**\n+     * DB Connection Name for this query\n+     * @return String DB Connection Name\n+     */\n+    // TO DO\n+    String type() default \"\";", "originalCommit": "e4e95e311293ad88547fe01b33d5c5da1cbb2e64", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDczNzczMg==", "url": "https://github.com/yahoo/elide/pull/1497#discussion_r470737732", "bodyText": "Typo, fixed.", "author": "rishi-aga", "createdAt": "2020-08-14T16:46:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIxMTQ0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIzOTAzMA==", "url": "https://github.com/yahoo/elide/pull/1497#discussion_r470239030", "bodyText": "I don't think we need to define this now.", "author": "aklish", "createdAt": "2020-08-13T20:48:00Z", "path": "elide-contrib/elide-dynamic-config-helpers/src/main/java/com/yahoo/elide/contrib/dynamicconfighelpers/model/ElideNonSQLDBConfig.java", "diffHunk": "@@ -0,0 +1,13 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.contrib.dynamicconfighelpers.model;\n+\n+/**\n+ * Elide SQL DB POJO.\n+ */\n+public class ElideNonSQLDBConfig extends ElideDBConfig {", "originalCommit": "e4e95e311293ad88547fe01b33d5c5da1cbb2e64", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDczNzg5MA==", "url": "https://github.com/yahoo/elide/pull/1497#discussion_r470737890", "bodyText": "Deleted", "author": "rishi-aga", "createdAt": "2020-08-14T16:47:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIzOTAzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY2MDU5OQ==", "url": "https://github.com/yahoo/elide/pull/1497#discussion_r470660599", "bodyText": "Should this be Config.VARIABLE.getConfigPath?", "author": "aklish", "createdAt": "2020-08-14T14:33:03Z", "path": "elide-contrib/elide-dynamic-config-helpers/src/main/java/com/yahoo/elide/contrib/dynamicconfighelpers/validator/DynamicConfigValidator.java", "diffHunk": "@@ -118,59 +132,108 @@ public void readAndValidateConfigs() throws IOException {\n     private void loadConfigMap() throws IOException {\n         PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver(\n                 this.getClass().getClassLoader());\n-        Resource[] modelResources = resolver.getResources(this.configDir);\n-        for (Resource resource : modelResources) {\n-            this.resourceMap.put(resource.getFilename(), resource);\n+        if (resolver.getResources(this.configDir).length == 0) {\n+            throw new IllegalStateException(this.configDir + \" : config path does not exist\");\n+        }\n+        int configDirURILength = resolver.getResources(this.configDir)[0].getURI().toString().length();\n+\n+        Resource[] hjsonResources = resolver.getResources(this.configDir + HJSON_EXTN);\n+        for (Resource resource : hjsonResources) {\n+            this.resourceMap.put(resource.getURI().toString().substring(configDirURILength), resource);\n         }\n     }\n \n     /**\n      * Read variable file config.\n-     * @return boolean true if variable config file exists else false\n-     * @throws IOException\n+     * @return Map<String, Object> A map containing all the variables if variable config exists else empty map\n      */\n-    private void readVariableConfig() throws IOException {\n-        String key = Config.VARIABLE.getConfigPath();\n-        if (this.resourceMap.containsKey(key)) {\n-            String content = IOUtils.toString(this.resourceMap.get(key).getInputStream(), StandardCharsets.UTF_8);\n-            this.setVariables(DynamicConfigHelpers.stringToVariablesPojo(content));\n-            this.resourceMap.remove(Config.VARIABLE.getConfigPath());\n-        }\n+    private Map<String, Object> readVariableConfig(Config config) {\n+\n+        return this.resourceMap\n+                        .entrySet()\n+                        .stream()\n+                        .filter(entry -> entry.getKey().startsWith(config.getConfigPath()))", "originalCommit": "e4e95e311293ad88547fe01b33d5c5da1cbb2e64", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDczODExNA==", "url": "https://github.com/yahoo/elide/pull/1497#discussion_r470738114", "bodyText": "No, Config.MODELVARIABLE / Config.DBVARIABLE are passed as parameter to this method.", "author": "rishi-aga", "createdAt": "2020-08-14T16:47:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY2MDU5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY2MTMxMg==", "url": "https://github.com/yahoo/elide/pull/1497#discussion_r470661312", "bodyText": "Again - can we use the static as before for the filter here?", "author": "aklish", "createdAt": "2020-08-14T14:34:19Z", "path": "elide-contrib/elide-dynamic-config-helpers/src/main/java/com/yahoo/elide/contrib/dynamicconfighelpers/validator/DynamicConfigValidator.java", "diffHunk": "@@ -118,59 +132,108 @@ public void readAndValidateConfigs() throws IOException {\n     private void loadConfigMap() throws IOException {\n         PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver(\n                 this.getClass().getClassLoader());\n-        Resource[] modelResources = resolver.getResources(this.configDir);\n-        for (Resource resource : modelResources) {\n-            this.resourceMap.put(resource.getFilename(), resource);\n+        if (resolver.getResources(this.configDir).length == 0) {\n+            throw new IllegalStateException(this.configDir + \" : config path does not exist\");\n+        }\n+        int configDirURILength = resolver.getResources(this.configDir)[0].getURI().toString().length();\n+\n+        Resource[] hjsonResources = resolver.getResources(this.configDir + HJSON_EXTN);\n+        for (Resource resource : hjsonResources) {\n+            this.resourceMap.put(resource.getURI().toString().substring(configDirURILength), resource);\n         }\n     }\n \n     /**\n      * Read variable file config.\n-     * @return boolean true if variable config file exists else false\n-     * @throws IOException\n+     * @return Map<String, Object> A map containing all the variables if variable config exists else empty map\n      */\n-    private void readVariableConfig() throws IOException {\n-        String key = Config.VARIABLE.getConfigPath();\n-        if (this.resourceMap.containsKey(key)) {\n-            String content = IOUtils.toString(this.resourceMap.get(key).getInputStream(), StandardCharsets.UTF_8);\n-            this.setVariables(DynamicConfigHelpers.stringToVariablesPojo(content));\n-            this.resourceMap.remove(Config.VARIABLE.getConfigPath());\n-        }\n+    private Map<String, Object> readVariableConfig(Config config) {\n+\n+        return this.resourceMap\n+                        .entrySet()\n+                        .stream()\n+                        .filter(entry -> entry.getKey().startsWith(config.getConfigPath()))\n+                        .map(entry -> {\n+                            try {\n+                                String content = IOUtils.toString(entry.getValue().getInputStream(), UTF_8);\n+                                return DynamicConfigHelpers.stringToVariablesPojo(content);\n+                            } catch (IOException e) {\n+                                throw new IllegalStateException(e);\n+                            }\n+                        })\n+                        .findFirst()\n+                        .orElse(new HashMap<>());\n     }\n \n     /**\n-     * Read security config file and checks for any missing Handlebar variables.\n-     * @return boolean true if security config file exists else false\n-     * @throws IOException\n+     * Read and validates security config file.\n      */\n-    private void readSecurityConfig() throws IOException {\n-        String key = Config.SECURITY.getConfigPath();\n-        if (this.resourceMap.containsKey(key)) {\n-            String content = IOUtils.toString(this.resourceMap.get(key).getInputStream(), StandardCharsets.UTF_8);\n-            validateConfigForMissingVariables(content, this.variables);\n-            this.setElideSecurityConfig(DynamicConfigHelpers.stringToElideSecurityPojo(content, this.variables));\n-            validateRoleInSecurityConfig(this.getElideSecurityConfig());\n-            this.resourceMap.remove(Config.SECURITY.getConfigPath());\n-        }\n+    private ElideSecurityConfig readSecurityConfig() {\n+\n+        return this.resourceMap\n+                        .entrySet()\n+                        .stream()\n+                        .filter(entry -> entry.getKey().startsWith(Config.SECURITY.getConfigPath()))\n+                        .map(entry -> {\n+                            try {\n+                                String content = IOUtils.toString(entry.getValue().getInputStream(), UTF_8);\n+                                validateConfigForMissingVariables(content, this.modelVariables);\n+                                return DynamicConfigHelpers.stringToElideSecurityPojo(content, this.modelVariables);\n+                            } catch (IOException e) {\n+                                throw new IllegalStateException(e);\n+                            }\n+                        })\n+                        .findAny()\n+                        .orElse(new ElideSecurityConfig());\n     }\n \n     /**\n-     * Read table config files and checks for any missing Handlebar variables.\n-     * @throws IOException\n+     * Read and validates db config files.\n+     * @return Set<DBConfig> Set of SQL DB Configs\n      */\n-    private void readTableConfig() throws IOException {\n-        Set<Table> tables = new HashSet<>();\n-        if (this.resourceMap.isEmpty()) {\n-            throw new IllegalStateException(\"No Table configs found at: \" + this.configDir);\n-        }\n-        for (Entry<String, Resource> entry : this.resourceMap.entrySet()) {\n-            String content = IOUtils.toString(entry.getValue().getInputStream(), StandardCharsets.UTF_8);\n-            validateConfigForMissingVariables(content, this.variables);\n-            ElideTableConfig table = DynamicConfigHelpers.stringToElideTablePojo(content, this.variables);\n-            tables.addAll(table.getTables());\n+    private Set<DBConfig> readDbConfig(Config config) {\n+\n+        return this.resourceMap\n+                        .entrySet()\n+                        .stream()\n+                        .filter(entry -> entry.getKey().startsWith(config.getConfigPath())).map(entry -> {", "originalCommit": "e4e95e311293ad88547fe01b33d5c5da1cbb2e64", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDczODU1Ng==", "url": "https://github.com/yahoo/elide/pull/1497#discussion_r470738556", "bodyText": "Changed to Config.SQLDBConfig.getConfigPath() as removing NonSql", "author": "rishi-aga", "createdAt": "2020-08-14T16:48:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY2MTMxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY2MTY4Nw==", "url": "https://github.com/yahoo/elide/pull/1497#discussion_r470661687", "bodyText": "map should go on its own line separate from filter.", "author": "aklish", "createdAt": "2020-08-14T14:34:55Z", "path": "elide-contrib/elide-dynamic-config-helpers/src/main/java/com/yahoo/elide/contrib/dynamicconfighelpers/validator/DynamicConfigValidator.java", "diffHunk": "@@ -118,59 +132,108 @@ public void readAndValidateConfigs() throws IOException {\n     private void loadConfigMap() throws IOException {\n         PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver(\n                 this.getClass().getClassLoader());\n-        Resource[] modelResources = resolver.getResources(this.configDir);\n-        for (Resource resource : modelResources) {\n-            this.resourceMap.put(resource.getFilename(), resource);\n+        if (resolver.getResources(this.configDir).length == 0) {\n+            throw new IllegalStateException(this.configDir + \" : config path does not exist\");\n+        }\n+        int configDirURILength = resolver.getResources(this.configDir)[0].getURI().toString().length();\n+\n+        Resource[] hjsonResources = resolver.getResources(this.configDir + HJSON_EXTN);\n+        for (Resource resource : hjsonResources) {\n+            this.resourceMap.put(resource.getURI().toString().substring(configDirURILength), resource);\n         }\n     }\n \n     /**\n      * Read variable file config.\n-     * @return boolean true if variable config file exists else false\n-     * @throws IOException\n+     * @return Map<String, Object> A map containing all the variables if variable config exists else empty map\n      */\n-    private void readVariableConfig() throws IOException {\n-        String key = Config.VARIABLE.getConfigPath();\n-        if (this.resourceMap.containsKey(key)) {\n-            String content = IOUtils.toString(this.resourceMap.get(key).getInputStream(), StandardCharsets.UTF_8);\n-            this.setVariables(DynamicConfigHelpers.stringToVariablesPojo(content));\n-            this.resourceMap.remove(Config.VARIABLE.getConfigPath());\n-        }\n+    private Map<String, Object> readVariableConfig(Config config) {\n+\n+        return this.resourceMap\n+                        .entrySet()\n+                        .stream()\n+                        .filter(entry -> entry.getKey().startsWith(config.getConfigPath()))\n+                        .map(entry -> {\n+                            try {\n+                                String content = IOUtils.toString(entry.getValue().getInputStream(), UTF_8);\n+                                return DynamicConfigHelpers.stringToVariablesPojo(content);\n+                            } catch (IOException e) {\n+                                throw new IllegalStateException(e);\n+                            }\n+                        })\n+                        .findFirst()\n+                        .orElse(new HashMap<>());\n     }\n \n     /**\n-     * Read security config file and checks for any missing Handlebar variables.\n-     * @return boolean true if security config file exists else false\n-     * @throws IOException\n+     * Read and validates security config file.\n      */\n-    private void readSecurityConfig() throws IOException {\n-        String key = Config.SECURITY.getConfigPath();\n-        if (this.resourceMap.containsKey(key)) {\n-            String content = IOUtils.toString(this.resourceMap.get(key).getInputStream(), StandardCharsets.UTF_8);\n-            validateConfigForMissingVariables(content, this.variables);\n-            this.setElideSecurityConfig(DynamicConfigHelpers.stringToElideSecurityPojo(content, this.variables));\n-            validateRoleInSecurityConfig(this.getElideSecurityConfig());\n-            this.resourceMap.remove(Config.SECURITY.getConfigPath());\n-        }\n+    private ElideSecurityConfig readSecurityConfig() {\n+\n+        return this.resourceMap\n+                        .entrySet()\n+                        .stream()\n+                        .filter(entry -> entry.getKey().startsWith(Config.SECURITY.getConfigPath()))\n+                        .map(entry -> {\n+                            try {\n+                                String content = IOUtils.toString(entry.getValue().getInputStream(), UTF_8);\n+                                validateConfigForMissingVariables(content, this.modelVariables);\n+                                return DynamicConfigHelpers.stringToElideSecurityPojo(content, this.modelVariables);\n+                            } catch (IOException e) {\n+                                throw new IllegalStateException(e);\n+                            }\n+                        })\n+                        .findAny()\n+                        .orElse(new ElideSecurityConfig());\n     }\n \n     /**\n-     * Read table config files and checks for any missing Handlebar variables.\n-     * @throws IOException\n+     * Read and validates db config files.\n+     * @return Set<DBConfig> Set of SQL DB Configs\n      */\n-    private void readTableConfig() throws IOException {\n-        Set<Table> tables = new HashSet<>();\n-        if (this.resourceMap.isEmpty()) {\n-            throw new IllegalStateException(\"No Table configs found at: \" + this.configDir);\n-        }\n-        for (Entry<String, Resource> entry : this.resourceMap.entrySet()) {\n-            String content = IOUtils.toString(entry.getValue().getInputStream(), StandardCharsets.UTF_8);\n-            validateConfigForMissingVariables(content, this.variables);\n-            ElideTableConfig table = DynamicConfigHelpers.stringToElideTablePojo(content, this.variables);\n-            tables.addAll(table.getTables());\n+    private Set<DBConfig> readDbConfig(Config config) {\n+\n+        return this.resourceMap\n+                        .entrySet()\n+                        .stream()\n+                        .filter(entry -> entry.getKey().startsWith(config.getConfigPath())).map(entry -> {\n+                            try {\n+                                String content = IOUtils.toString(entry.getValue().getInputStream(), UTF_8);\n+                                validateConfigForMissingVariables(content, this.dbVariables);\n+                                return DynamicConfigHelpers.stringToElideDBConfigPojo(content, this.dbVariables);\n+                            } catch (IOException e) {\n+                                throw new IllegalStateException(e);\n+                            }\n+                        })\n+                        .flatMap(dbconfig -> dbconfig.getDbconfigs().stream())\n+                        .collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * Read and validates table config files.\n+     */\n+    private Set<Table> readTableConfig() {\n+\n+        Set<Table> tables = this.resourceMap\n+                        .entrySet()\n+                        .stream()\n+                        .filter(entry -> entry.getKey().startsWith(Config.TABLE.getConfigPath())).map(entry -> {", "originalCommit": "e4e95e311293ad88547fe01b33d5c5da1cbb2e64", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDczOTQ3Nw==", "url": "https://github.com/yahoo/elide/pull/1497#discussion_r470739477", "bodyText": "updated", "author": "rishi-aga", "createdAt": "2020-08-14T16:50:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY2MTY4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY2MTgzNw==", "url": "https://github.com/yahoo/elide/pull/1497#discussion_r470661837", "bodyText": "map should go on its own line separate from filter.", "author": "aklish", "createdAt": "2020-08-14T14:35:11Z", "path": "elide-contrib/elide-dynamic-config-helpers/src/main/java/com/yahoo/elide/contrib/dynamicconfighelpers/validator/DynamicConfigValidator.java", "diffHunk": "@@ -118,59 +132,108 @@ public void readAndValidateConfigs() throws IOException {\n     private void loadConfigMap() throws IOException {\n         PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver(\n                 this.getClass().getClassLoader());\n-        Resource[] modelResources = resolver.getResources(this.configDir);\n-        for (Resource resource : modelResources) {\n-            this.resourceMap.put(resource.getFilename(), resource);\n+        if (resolver.getResources(this.configDir).length == 0) {\n+            throw new IllegalStateException(this.configDir + \" : config path does not exist\");\n+        }\n+        int configDirURILength = resolver.getResources(this.configDir)[0].getURI().toString().length();\n+\n+        Resource[] hjsonResources = resolver.getResources(this.configDir + HJSON_EXTN);\n+        for (Resource resource : hjsonResources) {\n+            this.resourceMap.put(resource.getURI().toString().substring(configDirURILength), resource);\n         }\n     }\n \n     /**\n      * Read variable file config.\n-     * @return boolean true if variable config file exists else false\n-     * @throws IOException\n+     * @return Map<String, Object> A map containing all the variables if variable config exists else empty map\n      */\n-    private void readVariableConfig() throws IOException {\n-        String key = Config.VARIABLE.getConfigPath();\n-        if (this.resourceMap.containsKey(key)) {\n-            String content = IOUtils.toString(this.resourceMap.get(key).getInputStream(), StandardCharsets.UTF_8);\n-            this.setVariables(DynamicConfigHelpers.stringToVariablesPojo(content));\n-            this.resourceMap.remove(Config.VARIABLE.getConfigPath());\n-        }\n+    private Map<String, Object> readVariableConfig(Config config) {\n+\n+        return this.resourceMap\n+                        .entrySet()\n+                        .stream()\n+                        .filter(entry -> entry.getKey().startsWith(config.getConfigPath()))\n+                        .map(entry -> {\n+                            try {\n+                                String content = IOUtils.toString(entry.getValue().getInputStream(), UTF_8);\n+                                return DynamicConfigHelpers.stringToVariablesPojo(content);\n+                            } catch (IOException e) {\n+                                throw new IllegalStateException(e);\n+                            }\n+                        })\n+                        .findFirst()\n+                        .orElse(new HashMap<>());\n     }\n \n     /**\n-     * Read security config file and checks for any missing Handlebar variables.\n-     * @return boolean true if security config file exists else false\n-     * @throws IOException\n+     * Read and validates security config file.\n      */\n-    private void readSecurityConfig() throws IOException {\n-        String key = Config.SECURITY.getConfigPath();\n-        if (this.resourceMap.containsKey(key)) {\n-            String content = IOUtils.toString(this.resourceMap.get(key).getInputStream(), StandardCharsets.UTF_8);\n-            validateConfigForMissingVariables(content, this.variables);\n-            this.setElideSecurityConfig(DynamicConfigHelpers.stringToElideSecurityPojo(content, this.variables));\n-            validateRoleInSecurityConfig(this.getElideSecurityConfig());\n-            this.resourceMap.remove(Config.SECURITY.getConfigPath());\n-        }\n+    private ElideSecurityConfig readSecurityConfig() {\n+\n+        return this.resourceMap\n+                        .entrySet()\n+                        .stream()\n+                        .filter(entry -> entry.getKey().startsWith(Config.SECURITY.getConfigPath()))\n+                        .map(entry -> {\n+                            try {\n+                                String content = IOUtils.toString(entry.getValue().getInputStream(), UTF_8);\n+                                validateConfigForMissingVariables(content, this.modelVariables);\n+                                return DynamicConfigHelpers.stringToElideSecurityPojo(content, this.modelVariables);\n+                            } catch (IOException e) {\n+                                throw new IllegalStateException(e);\n+                            }\n+                        })\n+                        .findAny()\n+                        .orElse(new ElideSecurityConfig());\n     }\n \n     /**\n-     * Read table config files and checks for any missing Handlebar variables.\n-     * @throws IOException\n+     * Read and validates db config files.\n+     * @return Set<DBConfig> Set of SQL DB Configs\n      */\n-    private void readTableConfig() throws IOException {\n-        Set<Table> tables = new HashSet<>();\n-        if (this.resourceMap.isEmpty()) {\n-            throw new IllegalStateException(\"No Table configs found at: \" + this.configDir);\n-        }\n-        for (Entry<String, Resource> entry : this.resourceMap.entrySet()) {\n-            String content = IOUtils.toString(entry.getValue().getInputStream(), StandardCharsets.UTF_8);\n-            validateConfigForMissingVariables(content, this.variables);\n-            ElideTableConfig table = DynamicConfigHelpers.stringToElideTablePojo(content, this.variables);\n-            tables.addAll(table.getTables());\n+    private Set<DBConfig> readDbConfig(Config config) {\n+\n+        return this.resourceMap\n+                        .entrySet()\n+                        .stream()\n+                        .filter(entry -> entry.getKey().startsWith(config.getConfigPath())).map(entry -> {", "originalCommit": "e4e95e311293ad88547fe01b33d5c5da1cbb2e64", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDczOTUzMg==", "url": "https://github.com/yahoo/elide/pull/1497#discussion_r470739532", "bodyText": "updated", "author": "rishi-aga", "createdAt": "2020-08-14T16:50:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY2MTgzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY2NzUyNQ==", "url": "https://github.com/yahoo/elide/pull/1497#discussion_r470667525", "bodyText": "Is it possible for DbConnectionName to be null?  I wonder if we should invert this comparison here.", "author": "aklish", "createdAt": "2020-08-14T14:43:30Z", "path": "elide-contrib/elide-dynamic-config-helpers/src/main/java/com/yahoo/elide/contrib/dynamicconfighelpers/validator/DynamicConfigValidator.java", "diffHunk": "@@ -211,6 +274,68 @@ private static boolean validateSqlInTableConfig(ElideTableConfig elideTableConfi\n         return true;\n     }\n \n+    /**\n+     * Validates join clause does not refer to a Table which is not in the same DBConnection.\n+     * If joined table is not part of dynamic configuration, then ignore\n+     */\n+    private static void validateJoinedTablesDBConnectionName(ElideTableConfig elideTableConfig) {\n+\n+        for (Table table : elideTableConfig.getTables()) {\n+            if (!table.getJoins().isEmpty()) {\n+\n+                Set<String> joinedTables = table.getJoins()\n+                        .stream()\n+                        .map(join -> join.getTo().toLowerCase(Locale.ENGLISH))\n+                        .collect(Collectors.toSet());\n+\n+                Set<String> connections = elideTableConfig.getTables()\n+                        .stream()\n+                        .filter(t -> joinedTables.contains(t.getName().toLowerCase(Locale.ENGLISH)))\n+                        .map(t -> t.getDbConnectionName())\n+                        .collect(Collectors.toSet());\n+\n+                if (connections.size() > 1 || (connections.size() == 1\n+                                && !table.getDbConnectionName().equals(connections.iterator().next()))) {", "originalCommit": "e4e95e311293ad88547fe01b33d5c5da1cbb2e64", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDc1MDg3OQ==", "url": "https://github.com/yahoo/elide/pull/1497#discussion_r470750879", "bodyText": "DbConnectionName  can not be null as Table schema doesn't allow and default value is Blank(\"\").", "author": "rishi-aga", "createdAt": "2020-08-14T17:13:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY2NzUyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY3MDU0Ng==", "url": "https://github.com/yahoo/elide/pull/1497#discussion_r470670546", "bodyText": "Do we have unit tests for this function?", "author": "aklish", "createdAt": "2020-08-14T14:46:10Z", "path": "elide-contrib/elide-dynamic-config-helpers/src/main/java/com/yahoo/elide/contrib/dynamicconfighelpers/validator/DynamicConfigValidator.java", "diffHunk": "@@ -296,8 +429,10 @@ private static void printHelp(Options options) {\n      * @return Path to model dir\n      */\n     private String formatClassPath(String filePath) {\n-        if (filePath.indexOf(RESOURCES) > -1) {\n-            return filePath.substring(filePath.indexOf(RESOURCES) + RESOURCE_LENGTH);\n+        if (filePath.indexOf(RESOURCES + File.separator) > -1) {", "originalCommit": "e4e95e311293ad88547fe01b33d5c5da1cbb2e64", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDczOTY1MQ==", "url": "https://github.com/yahoo/elide/pull/1497#discussion_r470739651", "bodyText": "Added.", "author": "rishi-aga", "createdAt": "2020-08-14T16:50:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY3MDU0Ng=="}], "type": "inlineReview"}, {"oid": "dea6658cd6b6c7648d0e63d1c2659cf3ed5826ee", "url": "https://github.com/yahoo/elide/commit/dea6658cd6b6c7648d0e63d1c2659cf3ed5826ee", "message": "Support dynamic configuration for db connections", "committedDate": "2020-08-24T17:16:03Z", "type": "commit"}, {"oid": "72a7946269ab31f6b37ce8b39246163b6b7dc9fc", "url": "https://github.com/yahoo/elide/commit/72a7946269ab31f6b37ce8b39246163b6b7dc9fc", "message": "Fixes for reading from JAR file", "committedDate": "2020-08-24T17:16:04Z", "type": "commit"}, {"oid": "30d4910602c8a8a99ae93e6be84e5804c57a22a9", "url": "https://github.com/yahoo/elide/commit/30d4910602c8a8a99ae93e6be84e5804c57a22a9", "message": "Create jar with dependencies for config validation", "committedDate": "2020-08-24T17:16:04Z", "type": "commit"}, {"oid": "4908a217d03c20e6e2621d81d6fd06cb61901b36", "url": "https://github.com/yahoo/elide/commit/4908a217d03c20e6e2621d81d6fd06cb61901b36", "message": "Review Comments", "committedDate": "2020-08-24T17:16:04Z", "type": "commit"}, {"oid": "ff9b3cf7f751f522d062a1971127b47ea6e10a50", "url": "https://github.com/yahoo/elide/commit/ff9b3cf7f751f522d062a1971127b47ea6e10a50", "message": "Codacy check", "committedDate": "2020-08-24T17:16:04Z", "type": "commit"}, {"oid": "ff9b3cf7f751f522d062a1971127b47ea6e10a50", "url": "https://github.com/yahoo/elide/commit/ff9b3cf7f751f522d062a1971127b47ea6e10a50", "message": "Codacy check", "committedDate": "2020-08-24T17:16:04Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzYxNjkxNw==", "url": "https://github.com/yahoo/elide/pull/1497#discussion_r477616917", "bodyText": "Maybe Table and DB should both leverage a common interface (Named or something) and use it to get the name without casting here.  This function could take a set of Named instead of a set of objects.", "author": "aklish", "createdAt": "2020-08-26T22:08:39Z", "path": "elide-contrib/elide-dynamic-config-helpers/src/main/java/com/yahoo/elide/contrib/dynamicconfighelpers/validator/DynamicConfigValidator.java", "diffHunk": "@@ -211,6 +274,51 @@ private static boolean validateSqlInTableConfig(ElideTableConfig elideTableConfi\n         return true;\n     }\n \n+    /**\n+     * Validates join clause does not refer to a Table which is not in the same DBConnection.\n+     * If joined table is not part of dynamic configuration, then ignore\n+     */\n+    private static void validateJoinedTablesDBConnectionName(ElideTableConfig elideTableConfig) {\n+\n+        for (Table table : elideTableConfig.getTables()) {\n+            if (!table.getJoins().isEmpty()) {\n+\n+                Set<String> joinedTables = table.getJoins()\n+                        .stream()\n+                        .map(join -> join.getTo().toLowerCase(Locale.ENGLISH))\n+                        .collect(Collectors.toSet());\n+\n+                Set<String> connections = elideTableConfig.getTables()\n+                        .stream()\n+                        .filter(t -> joinedTables.contains(t.getName().toLowerCase(Locale.ENGLISH)))\n+                        .map(t -> t.getDbConnectionName())\n+                        .collect(Collectors.toSet());\n+\n+                if (connections.size() > 1 || (connections.size() == 1\n+                                && !table.getDbConnectionName().equals(connections.iterator().next()))) {\n+                    throw new IllegalStateException(\"DBConnection name mismatch between table: \" + table.getName()\n+                                    + \" and tables in its Join Clause.\");\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Validates table (or db connection) name is unique across all the dynamic table (or db connection) configs.\n+     */\n+    private void validateNameUniqueness(Set<? extends Object> configs) {\n+\n+        Set<String> names = new HashSet<>();\n+\n+        configs.forEach(obj -> {\n+            if (obj instanceof Table && !names.add(((Table) obj).getName().toLowerCase(Locale.ENGLISH))) {", "originalCommit": "ff9b3cf7f751f522d062a1971127b47ea6e10a50", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODUwMTA3NA==", "url": "https://github.com/yahoo/elide/pull/1497#discussion_r478501074", "bodyText": "Updated", "author": "rishi-aga", "createdAt": "2020-08-27T15:21:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzYxNjkxNw=="}], "type": "inlineReview"}, {"oid": "0e5ac8fad9d01a2cf9828d10ff2dda0eaf76fc07", "url": "https://github.com/yahoo/elide/commit/0e5ac8fad9d01a2cf9828d10ff2dda0eaf76fc07", "message": "Review comment for using Named interface", "committedDate": "2020-08-26T23:06:01Z", "type": "commit"}, {"oid": "18a03169e8d8a9550825fa8b291ca083a0b93bc4", "url": "https://github.com/yahoo/elide/commit/18a03169e8d8a9550825fa8b291ca083a0b93bc4", "message": "Review comment for using Named interface", "committedDate": "2020-08-26T23:13:51Z", "type": "commit"}, {"oid": "572475b1a2d4ab3a8e2e623b061dbece15fc0525", "url": "https://github.com/yahoo/elide/commit/572475b1a2d4ab3a8e2e623b061dbece15fc0525", "message": "Review comment for using Named interface", "committedDate": "2020-08-26T23:23:01Z", "type": "commit"}, {"oid": "b679bceb20d896fcc196fdf920f9c32ed801a8ac", "url": "https://github.com/yahoo/elide/commit/b679bceb20d896fcc196fdf920f9c32ed801a8ac", "message": "Remove extra code", "committedDate": "2020-08-26T23:29:24Z", "type": "commit"}, {"oid": "198600d5a0ea578d5db536096b1dd9c80f85422f", "url": "https://github.com/yahoo/elide/commit/198600d5a0ea578d5db536096b1dd9c80f85422f", "message": "Review comment for using Named interface", "committedDate": "2020-08-26T23:38:01Z", "type": "commit"}, {"oid": "bef398d8fef8df6316e78beb796effc1afdeb92c", "url": "https://github.com/yahoo/elide/commit/bef398d8fef8df6316e78beb796effc1afdeb92c", "message": "Review comment for using Named interface", "committedDate": "2020-08-26T23:42:10Z", "type": "commit"}, {"oid": "163a26a57be17cd69e201492526d2980b70c26c6", "url": "https://github.com/yahoo/elide/commit/163a26a57be17cd69e201492526d2980b70c26c6", "message": "Review Comment", "committedDate": "2020-08-27T15:17:08Z", "type": "commit"}]}