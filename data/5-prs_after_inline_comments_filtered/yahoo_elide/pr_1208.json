{"pr_number": 1208, "pr_title": "Label Resolver for Dimension Formula", "pr_createdAt": "2020-03-02T20:56:56Z", "pr_url": "https://github.com/yahoo/elide/pull/1208", "timeline": [{"oid": "46682bc3c977e7788db8575f60f9c3fe22fb6d8a", "url": "https://github.com/yahoo/elide/commit/46682bc3c977e7788db8575f60f9c3fe22fb6d8a", "message": "sql expression to dimension formula", "committedDate": "2020-02-22T00:59:05Z", "type": "commit"}, {"oid": "6d70cd53bf013de220a06ed49d23f87029845ecc", "url": "https://github.com/yahoo/elide/commit/6d70cd53bf013de220a06ed49d23f87029845ecc", "message": "Metric formula", "committedDate": "2020-02-22T01:24:34Z", "type": "commit"}, {"oid": "166e4fd9939c10980d4751af7e3d0f32905e4b3b", "url": "https://github.com/yahoo/elide/commit/166e4fd9939c10980d4751af7e3d0f32905e4b3b", "message": "Add unit tests", "committedDate": "2020-02-22T01:31:18Z", "type": "commit"}, {"oid": "d20246fd3b52037821a35484a83691537f513f50", "url": "https://github.com/yahoo/elide/commit/d20246fd3b52037821a35484a83691537f513f50", "message": "refacot formula references", "committedDate": "2020-02-25T19:26:07Z", "type": "commit"}, {"oid": "698772b03d817a2e5cf68616df612d41264e1fc4", "url": "https://github.com/yahoo/elide/commit/698772b03d817a2e5cf68616df612d41264e1fc4", "message": "Merge remote-tracking branch 'yahoo/elide-5.x' into elide-5.x", "committedDate": "2020-02-25T19:30:05Z", "type": "commit"}, {"oid": "0da613240f35d0654301022151e2737971838bd8", "url": "https://github.com/yahoo/elide/commit/0da613240f35d0654301022151e2737971838bd8", "message": "fix comment", "committedDate": "2020-02-25T19:51:18Z", "type": "commit"}, {"oid": "4e67e096e57aa6868eee39632bc8e0dc8c972de3", "url": "https://github.com/yahoo/elide/commit/4e67e096e57aa6868eee39632bc8e0dc8c972de3", "message": "fix comment", "committedDate": "2020-02-25T20:41:50Z", "type": "commit"}, {"oid": "5d815bbf0423f8a702801b5e0df6118620f66de6", "url": "https://github.com/yahoo/elide/commit/5d815bbf0423f8a702801b5e0df6118620f66de6", "message": "resolve physical column", "committedDate": "2020-02-25T21:00:47Z", "type": "commit"}, {"oid": "74ada2c364f29187d263569df6bc220ffc1f6403", "url": "https://github.com/yahoo/elide/commit/74ada2c364f29187d263569df6bc220ffc1f6403", "message": "refactor dimensionFormula", "committedDate": "2020-02-26T16:54:58Z", "type": "commit"}, {"oid": "040ca62482cb5431275876c7f5edd33ce9f44eef", "url": "https://github.com/yahoo/elide/commit/040ca62482cb5431275876c7f5edd33ce9f44eef", "message": "cleanup", "committedDate": "2020-02-26T17:09:35Z", "type": "commit"}, {"oid": "a8ee284aef392068cf27defcadd6e82a5ed1daf4", "url": "https://github.com/yahoo/elide/commit/a8ee284aef392068cf27defcadd6e82a5ed1daf4", "message": "label resolver", "committedDate": "2020-03-02T20:53:49Z", "type": "commit"}, {"oid": "c677a726780e80993c1788163a2dce23f8793313", "url": "https://github.com/yahoo/elide/commit/c677a726780e80993c1788163a2dce23f8793313", "message": "cleanup", "committedDate": "2020-03-02T22:43:59Z", "type": "commit"}, {"oid": "b59cb59eb5e0f2a11e98dbd44359eff0f61ca8c0", "url": "https://github.com/yahoo/elide/commit/b59cb59eb5e0f2a11e98dbd44359eff0f61ca8c0", "message": "refactor", "committedDate": "2020-03-03T18:47:20Z", "type": "commit"}, {"oid": "a120f2c3824e147710ef55f665cd89a0d56cdf62", "url": "https://github.com/yahoo/elide/commit/a120f2c3824e147710ef55f665cd89a0d56cdf62", "message": "cleanup", "committedDate": "2020-03-03T18:59:20Z", "type": "commit"}, {"oid": "92759d2477627e8092084af3cd1d6320cf17ae5f", "url": "https://github.com/yahoo/elide/commit/92759d2477627e8092084af3cd1d6320cf17ae5f", "message": "move code", "committedDate": "2020-03-03T19:03:59Z", "type": "commit"}, {"oid": "1009207572c46f55808bf1d84b89cc8e82f56fd5", "url": "https://github.com/yahoo/elide/commit/1009207572c46f55808bf1d84b89cc8e82f56fd5", "message": "labelStore", "committedDate": "2020-03-03T21:50:35Z", "type": "commit"}, {"oid": "52052e14f7f9f2249244361091d597f07f53abbf", "url": "https://github.com/yahoo/elide/commit/52052e14f7f9f2249244361091d597f07f53abbf", "message": "labelStore 2", "committedDate": "2020-03-03T22:00:00Z", "type": "commit"}, {"oid": "74c058d7419b2d2ecc2d112d6aa6e9a68025d119", "url": "https://github.com/yahoo/elide/commit/74c058d7419b2d2ecc2d112d6aa6e9a68025d119", "message": "remove generator", "committedDate": "2020-03-04T19:45:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjY4NDgxMA==", "url": "https://github.com/yahoo/elide/pull/1208#discussion_r386684810", "bodyText": "Adding JoinPath here exposes the implementation as part of the interface.  The interface should be simple with the minimum amount of data needed.", "author": "aklish", "createdAt": "2020-03-02T22:17:43Z", "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/metadata/models/LabelResolver.java", "diffHunk": "@@ -0,0 +1,146 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.datastores.aggregation.metadata.models;\n+\n+import com.yahoo.elide.core.EntityDictionary;\n+import com.yahoo.elide.core.Path;\n+import com.yahoo.elide.datastores.aggregation.core.JoinPath;\n+import com.yahoo.elide.datastores.aggregation.metadata.MetaDataStore;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * LabelResolver is an interface for resolving column into some type of \"labels\" such as column reference, join\n+ * path and so on. It uses Depth-First-Search approach to traverse join path vertically. The resolved results would\n+ * be stored for quick access.\n+ */\n+public interface LabelResolver {\n+    /**\n+     * Resolve a label for a join path. This method need to be implemented for each column.\n+     *\n+     * @param fromPath path to be resolved\n+     * @param toResolve paths that are pending resolving\n+     * @param resolved resolved paths\n+     * @param generator generator to construct labels\n+     * @param metaDataStore meta data store\n+     * @param <T> label value type\n+     * @return resolved label\n+     */\n+    <T> T resolveLabel(JoinPath fromPath,\n+                       Set<JoinPath> toResolve,", "originalCommit": "a8ee284aef392068cf27defcadd6e82a5ed1daf4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk2MTIyNQ==", "url": "https://github.com/yahoo/elide/pull/1208#discussion_r387961225", "bodyText": "Typo?  toResolve?", "author": "aklish", "createdAt": "2020-03-04T22:02:22Z", "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/metadata/LabelResolver.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.datastores.aggregation.metadata;\n+\n+import com.yahoo.elide.datastores.aggregation.core.JoinPath;\n+import com.yahoo.elide.datastores.aggregation.metadata.models.Column;\n+\n+import java.util.Collections;\n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * LabelResolver is an interface for resolving column into some type of \"labels\" such as column reference, join\n+ * path and so on. It uses Depth-First-Search approach to traverse join path vertically. The resolved results would\n+ * be stored for quick access.\n+ */\n+public abstract class LabelResolver {\n+    private final Column roResolve;", "originalCommit": "74c058d7419b2d2ecc2d112d6aa6e9a68025d119", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk3MDM2Nw==", "url": "https://github.com/yahoo/elide/pull/1208#discussion_r387970367", "bodyText": "There should be a default constructor which does the class Scan and another constructor which allows a set of classes to be provided.", "author": "aklish", "createdAt": "2020-03-04T22:22:23Z", "path": "elide-datastore/elide-datastore-aggregation/src/test/java/com/yahoo/elide/datastores/aggregation/framework/AggregationDataStoreTestHarness.java", "diffHunk": "@@ -26,7 +29,7 @@ public AggregationDataStoreTestHarness(EntityManagerFactory entityManagerFactory\n \n     @Override\n     public DataStore getDataStore() {\n-        MetaDataStore metaDataStore = new MetaDataStore();\n+        MetaDataStore metaDataStore = new MetaDataStore(ClassScanner.getAnnotatedClasses(METADATA_STORE_ANNOTATIONS));", "originalCommit": "74c058d7419b2d2ecc2d112d6aa6e9a68025d119", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk3MDUyMQ==", "url": "https://github.com/yahoo/elide/pull/1208#discussion_r387970521", "bodyText": "There should be a default constructor which does the class Scan and another constructor which allows a set of classes to be provided.", "author": "aklish", "createdAt": "2020-03-04T22:22:41Z", "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/metadata/MetaDataStore.java", "diffHunk": "@@ -28,26 +29,30 @@\n import lombok.Getter;\n \n import java.lang.annotation.Annotation;\n+import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n import java.util.stream.Collectors;\n \n /**\n  * MetaDataStore is a in-memory data store that manage data models for an {@link AggregationDataStore}.\n  */\n-public class MetaDataStore extends HashMapDataStore {\n+public class MetaDataStore extends HashMapDataStore implements LabelStore {\n     private static final Package META_DATA_PACKAGE = Table.class.getPackage();\n+    private static final Pattern REFERENCE_PARENTHESES = Pattern.compile(\"\\\\{\\\\{(.+?)}}\");\n \n-    private static final List<Class<? extends Annotation>> METADATA_STORE_ANNOTATIONS =\n+    public static final List<Class<? extends Annotation>> METADATA_STORE_ANNOTATIONS =\n             Arrays.asList(FromTable.class, FromSubquery.class, Subselect.class, javax.persistence.Table.class);\n \n     @Getter\n     private final Set<Class<?>> modelsToBind;\n \n-    public MetaDataStore() {\n+    public MetaDataStore(Set<Class<?>> modelsToBind) {", "originalCommit": "74c058d7419b2d2ecc2d112d6aa6e9a68025d119", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk3MjA4Mg==", "url": "https://github.com/yahoo/elide/pull/1208#discussion_r387972082", "bodyText": "Do you need to escape the closing curly braces as well?", "author": "aklish", "createdAt": "2020-03-04T22:26:21Z", "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/metadata/MetaDataStore.java", "diffHunk": "@@ -28,26 +29,30 @@\n import lombok.Getter;\n \n import java.lang.annotation.Annotation;\n+import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n import java.util.stream.Collectors;\n \n /**\n  * MetaDataStore is a in-memory data store that manage data models for an {@link AggregationDataStore}.\n  */\n-public class MetaDataStore extends HashMapDataStore {\n+public class MetaDataStore extends HashMapDataStore implements LabelStore {\n     private static final Package META_DATA_PACKAGE = Table.class.getPackage();\n+    private static final Pattern REFERENCE_PARENTHESES = Pattern.compile(\"\\\\{\\\\{(.+?)}}\");", "originalCommit": "74c058d7419b2d2ecc2d112d6aa6e9a68025d119", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU1MzAzNw==", "url": "https://github.com/yahoo/elide/pull/1208#discussion_r388553037", "bodyText": "Intellij is complaining about that.", "author": "hellohanchen", "createdAt": "2020-03-05T20:41:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk3MjA4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk3MjcyOQ==", "url": "https://github.com/yahoo/elide/pull/1208#discussion_r387972729", "bodyText": "Maybe this should be moved to column?", "author": "aklish", "createdAt": "2020-03-04T22:27:46Z", "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/metadata/MetaDataStore.java", "diffHunk": "@@ -171,6 +184,45 @@ public static boolean isTableJoin(Class<?> cls, String fieldName, EntityDictiona\n         return dictionary.getAttributeOrRelationAnnotation(cls, Join.class, fieldName) != null;\n     }\n \n+    /**\n+     * Construct a column name as meta data\n+     *\n+     * @param tableClass table class\n+     * @param fieldName field name\n+     * @param dictionary entity dictionary to use\n+     * @return <code>tableAlias.fieldName</code>\n+     */\n+    public static String constructColumnName(Class<?> tableClass, String fieldName, EntityDictionary dictionary) {", "originalCommit": "74c058d7419b2d2ecc2d112d6aa6e9a68025d119", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk3NDc1OA==", "url": "https://github.com/yahoo/elide/pull/1208#discussion_r387974758", "bodyText": "Is there any reason not to do this in the constructor of the MetadataStore?", "author": "aklish", "createdAt": "2020-03-04T22:32:33Z", "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/metadata/MetaDataStore.java", "diffHunk": "@@ -190,4 +242,27 @@ public void resolveSourceColumn() {\n                 })\n         );\n     }\n+\n+    @Override\n+    public LabelResolver getLabelResolver(Path path) {\n+        Path.PathElement last = path.lastElement().get();\n+\n+        return ((Table) dataStore.get(Table.class).get(dictionary.getJsonAliasFor(last.getType())))\n+                .getColumnMap()\n+                .get(last.getFieldName())\n+                .getLabelResolver();\n+    }\n+\n+    /**\n+     * Resolve all column references in all tables.\n+     */\n+    public void resolveReference() {\n+        getMetaData(Table.class)", "originalCommit": "74c058d7419b2d2ecc2d112d6aa6e9a68025d119", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk3NzUxMA==", "url": "https://github.com/yahoo/elide/pull/1208#discussion_r387977510", "bodyText": "I don't understand what resolveReference is trying to do in general beyond the validation.", "author": "aklish", "createdAt": "2020-03-04T22:39:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk3NDc1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU1MzkxOQ==", "url": "https://github.com/yahoo/elide/pull/1208#discussion_r388553919", "bodyText": "The references are generated and stored", "author": "hellohanchen", "createdAt": "2020-03-05T20:43:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk3NDc1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk3NjY0NA==", "url": "https://github.com/yahoo/elide/pull/1208#discussion_r387976644", "bodyText": "I'm not sure why the QueryEngine needs to populate the metadata store.  The metadata store already knows (in its constructor) everything that needs to be resolved.  I feel like all of this logic belongs there.", "author": "aklish", "createdAt": "2020-03-04T22:37:11Z", "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/QueryEngine.java", "diffHunk": "@@ -112,6 +112,7 @@ private void populateMetaData(MetaDataStore metaDataStore) {\n                 .map(model -> constructTable(model, metadataDictionary))\n                 .forEach(metaDataStore::addTable);\n \n+        metaDataStore.resolveReference();", "originalCommit": "74c058d7419b2d2ecc2d112d6aa6e9a68025d119", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk3OTU0NA==", "url": "https://github.com/yahoo/elide/pull/1208#discussion_r387979544", "bodyText": "We should add some unit tests for these functions.", "author": "aklish", "createdAt": "2020-03-04T22:44:27Z", "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/core/JoinPath.java", "diffHunk": "@@ -23,4 +34,36 @@ protected boolean needNavigation(Class<?> entityClass, String fieldName, EntityD\n         return dictionary.isRelation(entityClass, fieldName)\n                 || MetaDataStore.isTableJoin(entityClass, fieldName, dictionary);\n     }\n+\n+    /**\n+     * Extend this path with a dotSeparatedPath.\n+     *\n+     * @param dictionary entity dictionary\n+     * @param dotSeparatedPath path e.g. \"bar.baz\", starting for the end of current path\n+     * @return extended path\n+     */\n+    public JoinPath extend(EntityDictionary dictionary, String dotSeparatedPath) {\n+        JoinPath extension = new JoinPath(lastElement().get().getType(), dictionary, dotSeparatedPath);\n+\n+        // append new path after original path\n+        JoinPath extended = extendJoinPath(this, extension);\n+\n+        return new JoinPath(extended);\n+    }\n+\n+    /**\n+     * Append an extension path to an original path, the last element of original path should be the same as the\n+     * first element of extension path.\n+     *\n+     * @param path original path, e.g. <code>[A.B]/[B.C]</code>\n+     * @param extension extension path, e.g. <code>[B.C]/[C.D]</code>\n+     * @param <P> path extension\n+     * @return extended path <code>[A.B]/[B.C]/[C.D]</code>\n+     */\n+    public static <P extends Path> JoinPath extendJoinPath(Path path, P extension) {", "originalCommit": "74c058d7419b2d2ecc2d112d6aa6e9a68025d119", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2bf9a7791e51a673d910e3e57c8c8eabbdde6fef", "url": "https://github.com/yahoo/elide/commit/2bf9a7791e51a673d910e3e57c8c8eabbdde6fef", "message": "refactor metric formula", "committedDate": "2020-03-05T20:36:16Z", "type": "commit"}, {"oid": "169e790e78a2d99da4b3a147bf4d176c8658f5b2", "url": "https://github.com/yahoo/elide/commit/169e790e78a2d99da4b3a147bf4d176c8658f5b2", "message": "address comments", "committedDate": "2020-03-05T20:48:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODk3NDMyOQ==", "url": "https://github.com/yahoo/elide/pull/1208#discussion_r388974329", "bodyText": "Rather than special case this, it might be simpler if physical references had resolvers that just return the column name.", "author": "aklish", "createdAt": "2020-03-06T15:37:36Z", "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/metadata/LabelResolver.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.datastores.aggregation.metadata;\n+\n+import static com.yahoo.elide.datastores.aggregation.core.JoinPath.extendJoinPath;\n+import static com.yahoo.elide.datastores.aggregation.metadata.MetaDataStore.isPhysicalReference;\n+import static com.yahoo.elide.datastores.aggregation.metadata.MetaDataStore.resolveFormulaReferences;\n+import static com.yahoo.elide.datastores.aggregation.metadata.MetaDataStore.toFormulaReference;\n+import static com.yahoo.elide.utils.TypeHelper.extendTypeAlias;\n+import static com.yahoo.elide.utils.TypeHelper.getFieldAlias;\n+\n+import com.yahoo.elide.datastores.aggregation.annotation.MetricFormula;\n+import com.yahoo.elide.datastores.aggregation.core.JoinPath;\n+import com.yahoo.elide.datastores.aggregation.metadata.models.Column;\n+import com.yahoo.elide.datastores.aggregation.queryengines.sql.annotation.DimensionFormula;\n+import com.yahoo.elide.datastores.aggregation.queryengines.sql.annotation.JoinTo;\n+\n+import java.util.Collections;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ * LabelResolver is an interface for resolving column into some type of \"labels\" such as column reference, join\n+ * path and so on. It uses Depth-First-Search approach to traverse join path vertically. The resolved results would\n+ * be stored for quick access.\n+ */\n+public abstract class LabelResolver {\n+    private final Column toResolve;\n+\n+    protected LabelResolver(Column toResolve) {\n+        this.toResolve = toResolve;\n+    }\n+\n+    /**\n+     * Resolve label for this column\n+     *\n+     * @param labelStore source-of-truth store\n+     * @param tableAlias label prefix to the table that contains this column\n+     * @return resolved label\n+     */\n+    public abstract String resolveLabel(LabelStore labelStore, String tableAlias);\n+\n+    /**\n+     * Get all joins needs for this column\n+     *\n+     * @param labelStore source-of-truth store\n+     * @param from root join path to this column\n+     * @return full join paths\n+     */\n+    public Set<JoinPath> resolveJoinPaths(LabelStore labelStore, JoinPath from) {\n+        return Collections.singleton(from);\n+    }\n+\n+    /**\n+     * Get all other resolvers that this resolver would involve when resolving label.\n+     *\n+     * @param labelStore table stores all resolvers\n+     * @return dependency resolvers\n+     */\n+    protected Set<LabelResolver> getDependencyResolvers(LabelStore labelStore) {\n+        return Collections.emptySet();\n+    }\n+\n+    /**\n+     * Check whether this resolver would cause reference loop\n+     *\n+     * @param metaDataStore meta data store\n+     */\n+    public void checkResolverLoop(MetaDataStore metaDataStore) {\n+        this.checkResolverLoop(new LinkedHashSet<>(), metaDataStore);\n+    }\n+\n+    /**\n+     * Check whether this resolver would cause reference loop\n+     *\n+     * @param visited visited label resolvers\n+     * @param metaDataStore meta data store\n+     */\n+    private void checkResolverLoop(LinkedHashSet<LabelResolver> visited, MetaDataStore metaDataStore) {\n+        if (visited.contains(this)) {\n+            throw new IllegalArgumentException(referenceLoopMessage(visited, this));\n+        } else {\n+            visited.add(this);\n+            this.getDependencyResolvers(metaDataStore)\n+                    .forEach(resolver -> resolver.checkResolverLoop(visited, metaDataStore));\n+            visited.remove(this);\n+        }\n+    }\n+\n+    /**\n+     * Construct reference loop message.\n+     */\n+    private static String referenceLoopMessage(LinkedHashSet<LabelResolver> visited, LabelResolver loop) {\n+        return \"Formula reference loop found: \"\n+                + visited.stream()\n+                        .map(labelResolver -> labelResolver.toResolve.getId())\n+                        .collect(Collectors.joining(\"->\"))\n+                + \"->\" + loop.toResolve.getId();\n+    }\n+\n+    /**\n+     * Get a {@link DimensionFormula} or {@link MetricFormula} reference resolver.\n+     *\n+     * @param column column that this resolver is built for\n+     * @param tableClass table class\n+     * @param expression formula expression contains physical column, logical column and {@link JoinTo} paths\n+     * @return a resolver\n+     */\n+    public static LabelResolver getFormulaResolver(Column column, Class<?> tableClass, String expression) {\n+        // dimension references are deduplicated\n+        List<String> references =\n+                resolveFormulaReferences(expression).stream().distinct().collect(Collectors.toList());\n+\n+        return new LabelResolver(column) {\n+            @Override\n+            public Set<JoinPath> resolveJoinPaths(LabelStore labelStore, JoinPath from) {\n+                return references.stream()\n+                        .map(reference -> {\n+                            // physical columns don't have dependency resolvers\n+                            if (isPhysicalReference(tableClass, reference, labelStore.getDictionary())) {\n+                                return Stream.<JoinPath>empty();\n+                            }\n+\n+                            JoinPath to = getJoinToPath(labelStore, reference);\n+\n+                            return labelStore.getLabelResolver(to)\n+                                    .resolveJoinPaths(labelStore, extendJoinPath(from, to)).stream();\n+                        })\n+                        .reduce(Stream.empty(), Stream::concat)\n+                        .collect(Collectors.toSet());\n+            }\n+\n+            @Override\n+            public Set<LabelResolver> getDependencyResolvers(LabelStore labelStore) {\n+                return references.stream()\n+                        .map(reference -> {\n+                            // physical columns don't have dependency resolvers\n+                            return isPhysicalReference(tableClass, reference, labelStore.getDictionary())", "originalCommit": "169e790e78a2d99da4b3a147bf4d176c8658f5b2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODk3ODc2Mw==", "url": "https://github.com/yahoo/elide/pull/1208#discussion_r388978763", "bodyText": "I wonder if we should move all the LabelResolver stuff to SQLColumn, SQLMetric, and SQLDimension.  Its not clear to me that we want to pollute the base metadata with this.\nI realize we may eventually want to expose a Metric/Dimension Formula to the UI - but that's about the only thing that seems like it properly belongs with the base metadata.", "author": "aklish", "createdAt": "2020-03-06T15:45:22Z", "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/metadata/models/Column.java", "diffHunk": "@@ -103,4 +133,27 @@ public Path getSourcePath(EntityDictionary metadataDictionary) {\n \n         return new Path(Collections.singletonList(new Path.PathElement(tableCls, columnCls, getName())));\n     }\n+\n+    /**\n+     * Construct a label resolver for this column.\n+     *\n+     * @return a label resolver\n+     */\n+    protected LabelResolver constructLabelResolver(EntityDictionary dictionary) {", "originalCommit": "169e790e78a2d99da4b3a147bf4d176c8658f5b2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTAxMTQ4Ng==", "url": "https://github.com/yahoo/elide/pull/1208#discussion_r389011486", "bodyText": "Let's make sure we have unit tests for all these functions.", "author": "aklish", "createdAt": "2020-03-06T16:39:34Z", "path": "elide-core/src/main/java/com/yahoo/elide/utils/TypeHelper.java", "diffHunk": "@@ -32,6 +32,23 @@ public static boolean isPrimitiveNumberType(Class<?> type) {\n         return PRIMITIVE_NUMBER_TYPES.contains(type);\n     }\n \n+    /**\n+     * Extend an type alias to the final type of an extension path\n+     *\n+     * @param alias type alias to be extended, e.g. <code>a_b</code>\n+     * @param extension path extension from aliased type, e.g. <code>[b.c]/[c.d]</code>\n+     * @return extended type alias, e.g. <code>a_b_c</code>\n+     */\n+    public static String extendTypeAlias(String alias, Path extension) {", "originalCommit": "169e790e78a2d99da4b3a147bf4d176c8658f5b2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTAxMjg0MA==", "url": "https://github.com/yahoo/elide/pull/1208#discussion_r389012840", "bodyText": "This could resolve to the column name by default - so everything can have a label resolver and we don't have to special case physical columns.", "author": "aklish", "createdAt": "2020-03-06T16:41:32Z", "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/metadata/LabelResolver.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.datastores.aggregation.metadata;\n+\n+import static com.yahoo.elide.datastores.aggregation.core.JoinPath.extendJoinPath;\n+import static com.yahoo.elide.datastores.aggregation.metadata.MetaDataStore.isPhysicalReference;\n+import static com.yahoo.elide.datastores.aggregation.metadata.MetaDataStore.resolveFormulaReferences;\n+import static com.yahoo.elide.datastores.aggregation.metadata.MetaDataStore.toFormulaReference;\n+import static com.yahoo.elide.utils.TypeHelper.extendTypeAlias;\n+import static com.yahoo.elide.utils.TypeHelper.getFieldAlias;\n+\n+import com.yahoo.elide.datastores.aggregation.annotation.MetricFormula;\n+import com.yahoo.elide.datastores.aggregation.core.JoinPath;\n+import com.yahoo.elide.datastores.aggregation.metadata.models.Column;\n+import com.yahoo.elide.datastores.aggregation.queryengines.sql.annotation.DimensionFormula;\n+import com.yahoo.elide.datastores.aggregation.queryengines.sql.annotation.JoinTo;\n+\n+import java.util.Collections;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ * LabelResolver is an interface for resolving column into some type of \"labels\" such as column reference, join\n+ * path and so on. It uses Depth-First-Search approach to traverse join path vertically. The resolved results would\n+ * be stored for quick access.\n+ */\n+public abstract class LabelResolver {\n+    private final Column toResolve;\n+\n+    protected LabelResolver(Column toResolve) {\n+        this.toResolve = toResolve;\n+    }\n+\n+    /**\n+     * Resolve label for this column\n+     *\n+     * @param labelStore source-of-truth store\n+     * @param tableAlias label prefix to the table that contains this column\n+     * @return resolved label\n+     */\n+    public abstract String resolveLabel(LabelStore labelStore, String tableAlias);", "originalCommit": "169e790e78a2d99da4b3a147bf4d176c8658f5b2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTAxNzYzMA==", "url": "https://github.com/yahoo/elide/pull/1208#discussion_r389017630", "bodyText": "This function probably belongs with the LabelStore", "author": "aklish", "createdAt": "2020-03-06T16:49:35Z", "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/metadata/MetaDataStore.java", "diffHunk": "@@ -190,4 +239,40 @@ public void resolveSourceColumn() {\n                 })\n         );\n     }\n+\n+    @Override\n+    public LabelResolver getLabelResolver(Path path) {\n+        Path.PathElement last = path.lastElement().get();\n+\n+        return ((Table) dataStore.get(Table.class).get(dictionary.getJsonAliasFor(last.getType())))\n+                .getColumnMap()\n+                .get(last.getFieldName())\n+                .getLabelResolver();\n+    }\n+\n+    /**\n+     * Resolve all column references in all tables.\n+     */\n+    public void resolveLabel() {\n+        getMetaData(Table.class)\n+                .forEach(table -> table.getColumns()\n+                        .forEach(column -> column.getLabelResolver().checkResolverLoop(this)));\n+\n+        getMetaData(Table.class)\n+                .forEach(table -> table.getColumns()\n+                        .forEach(column -> column.resolveLabel(this)));\n+    }\n+\n+    /**\n+     * Check whether a reference is not defined in the logical meta data table, which means it is physical.\n+     *\n+     * @param tableClass table class\n+     * @param reference reference\n+     * @param dictionary meta data dictionary\n+     * @return True if the reference is to a physical column\n+     */\n+    public static boolean isPhysicalReference(Class<?> tableClass, String reference, EntityDictionary dictionary) {", "originalCommit": "169e790e78a2d99da4b3a147bf4d176c8658f5b2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTAyMDY5NA==", "url": "https://github.com/yahoo/elide/pull/1208#discussion_r389020694", "bodyText": "Use flatmap instead", "author": "aklish", "createdAt": "2020-03-06T16:55:01Z", "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/metadata/LabelResolver.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.datastores.aggregation.metadata;\n+\n+import static com.yahoo.elide.datastores.aggregation.core.JoinPath.extendJoinPath;\n+import static com.yahoo.elide.datastores.aggregation.metadata.MetaDataStore.isPhysicalReference;\n+import static com.yahoo.elide.datastores.aggregation.metadata.MetaDataStore.resolveFormulaReferences;\n+import static com.yahoo.elide.datastores.aggregation.metadata.MetaDataStore.toFormulaReference;\n+import static com.yahoo.elide.utils.TypeHelper.extendTypeAlias;\n+import static com.yahoo.elide.utils.TypeHelper.getFieldAlias;\n+\n+import com.yahoo.elide.datastores.aggregation.annotation.MetricFormula;\n+import com.yahoo.elide.datastores.aggregation.core.JoinPath;\n+import com.yahoo.elide.datastores.aggregation.metadata.models.Column;\n+import com.yahoo.elide.datastores.aggregation.queryengines.sql.annotation.DimensionFormula;\n+import com.yahoo.elide.datastores.aggregation.queryengines.sql.annotation.JoinTo;\n+\n+import java.util.Collections;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ * LabelResolver is an interface for resolving column into some type of \"labels\" such as column reference, join\n+ * path and so on. It uses Depth-First-Search approach to traverse join path vertically. The resolved results would\n+ * be stored for quick access.\n+ */\n+public abstract class LabelResolver {\n+    private final Column toResolve;\n+\n+    protected LabelResolver(Column toResolve) {\n+        this.toResolve = toResolve;\n+    }\n+\n+    /**\n+     * Resolve label for this column\n+     *\n+     * @param labelStore source-of-truth store\n+     * @param tableAlias label prefix to the table that contains this column\n+     * @return resolved label\n+     */\n+    public abstract String resolveLabel(LabelStore labelStore, String tableAlias);\n+\n+    /**\n+     * Get all joins needs for this column\n+     *\n+     * @param labelStore source-of-truth store\n+     * @param from root join path to this column\n+     * @return full join paths\n+     */\n+    public Set<JoinPath> resolveJoinPaths(LabelStore labelStore, JoinPath from) {\n+        return Collections.singleton(from);\n+    }\n+\n+    /**\n+     * Get all other resolvers that this resolver would involve when resolving label.\n+     *\n+     * @param labelStore table stores all resolvers\n+     * @return dependency resolvers\n+     */\n+    protected Set<LabelResolver> getDependencyResolvers(LabelStore labelStore) {\n+        return Collections.emptySet();\n+    }\n+\n+    /**\n+     * Check whether this resolver would cause reference loop\n+     *\n+     * @param metaDataStore meta data store\n+     */\n+    public void checkResolverLoop(MetaDataStore metaDataStore) {\n+        this.checkResolverLoop(new LinkedHashSet<>(), metaDataStore);\n+    }\n+\n+    /**\n+     * Check whether this resolver would cause reference loop\n+     *\n+     * @param visited visited label resolvers\n+     * @param metaDataStore meta data store\n+     */\n+    private void checkResolverLoop(LinkedHashSet<LabelResolver> visited, MetaDataStore metaDataStore) {\n+        if (visited.contains(this)) {\n+            throw new IllegalArgumentException(referenceLoopMessage(visited, this));\n+        } else {\n+            visited.add(this);\n+            this.getDependencyResolvers(metaDataStore)\n+                    .forEach(resolver -> resolver.checkResolverLoop(visited, metaDataStore));\n+            visited.remove(this);\n+        }\n+    }\n+\n+    /**\n+     * Construct reference loop message.\n+     */\n+    private static String referenceLoopMessage(LinkedHashSet<LabelResolver> visited, LabelResolver loop) {\n+        return \"Formula reference loop found: \"\n+                + visited.stream()\n+                        .map(labelResolver -> labelResolver.toResolve.getId())\n+                        .collect(Collectors.joining(\"->\"))\n+                + \"->\" + loop.toResolve.getId();\n+    }\n+\n+    /**\n+     * Get a {@link DimensionFormula} or {@link MetricFormula} reference resolver.\n+     *\n+     * @param column column that this resolver is built for\n+     * @param tableClass table class\n+     * @param expression formula expression contains physical column, logical column and {@link JoinTo} paths\n+     * @return a resolver\n+     */\n+    public static LabelResolver getFormulaResolver(Column column, Class<?> tableClass, String expression) {\n+        // dimension references are deduplicated\n+        List<String> references =\n+                resolveFormulaReferences(expression).stream().distinct().collect(Collectors.toList());\n+\n+        return new LabelResolver(column) {\n+            @Override\n+            public Set<JoinPath> resolveJoinPaths(LabelStore labelStore, JoinPath from) {\n+                return references.stream()\n+                        .map(reference -> {\n+                            // physical columns don't have dependency resolvers\n+                            if (isPhysicalReference(tableClass, reference, labelStore.getDictionary())) {\n+                                return Stream.<JoinPath>empty();\n+                            }\n+\n+                            JoinPath to = getJoinToPath(labelStore, reference);\n+\n+                            return labelStore.getLabelResolver(to)\n+                                    .resolveJoinPaths(labelStore, extendJoinPath(from, to)).stream();\n+                        })\n+                        .reduce(Stream.empty(), Stream::concat)", "originalCommit": "169e790e78a2d99da4b3a147bf4d176c8658f5b2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTAyMzUxNg==", "url": "https://github.com/yahoo/elide/pull/1208#discussion_r389023516", "bodyText": "Rather than returning an entity dictionary, I wonder if the LabelStore should have the methods that require the entity dictionary.", "author": "aklish", "createdAt": "2020-03-06T16:58:49Z", "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/metadata/LabelStore.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.datastores.aggregation.metadata;\n+\n+import com.yahoo.elide.core.EntityDictionary;\n+import com.yahoo.elide.core.Path;\n+import com.yahoo.elide.datastores.aggregation.core.JoinPath;\n+\n+import java.util.Set;\n+\n+/**\n+ * LabelStore stores all label resolvers for all columns. It uses {@link JoinPath} as reference to each field.\n+ */\n+public interface LabelStore {\n+    /**\n+     * Get a dictionary with model definitions.\n+     *\n+     * @return dictionary\n+     */\n+    EntityDictionary getDictionary();", "originalCommit": "169e790e78a2d99da4b3a147bf4d176c8658f5b2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTAyNTM2Mg==", "url": "https://github.com/yahoo/elide/pull/1208#discussion_r389025362", "bodyText": "I don't think MetaDataStore should be resolving labels.", "author": "aklish", "createdAt": "2020-03-06T17:00:21Z", "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/metadata/MetaDataStore.java", "diffHunk": "@@ -28,18 +29,22 @@\n import lombok.Getter;\n \n import java.lang.annotation.Annotation;\n+import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n import java.util.stream.Collectors;\n \n /**\n  * MetaDataStore is a in-memory data store that manage data models for an {@link AggregationDataStore}.\n  */\n-public class MetaDataStore extends HashMapDataStore {\n+public class MetaDataStore extends HashMapDataStore implements LabelStore {", "originalCommit": "169e790e78a2d99da4b3a147bf4d176c8658f5b2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTAyNjQ2Mw==", "url": "https://github.com/yahoo/elide/pull/1208#discussion_r389026463", "bodyText": "Move to LabelStore", "author": "aklish", "createdAt": "2020-03-06T17:01:53Z", "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/metadata/MetaDataStore.java", "diffHunk": "@@ -171,6 +193,33 @@ public static boolean isTableJoin(Class<?> cls, String fieldName, EntityDictiona\n         return dictionary.getAttributeOrRelationAnnotation(cls, Join.class, fieldName) != null;\n     }\n \n+    /**\n+     * Use regex to get all references from a formula expression.\n+     *\n+     * @param formula formula expression\n+     * @return references appear in the formula.\n+     */\n+    public static List<String> resolveFormulaReferences(String formula) {\n+        Matcher matcher = REFERENCE_PARENTHESES.matcher(formula);\n+        List<String> references = new ArrayList<>();\n+\n+        while (matcher.find()) {\n+            references.add(matcher.group(1));\n+        }\n+\n+        return references;\n+    }\n+\n+    /**\n+     * Convert a resolved formula reference back to a reference presented in formula format.\n+     *\n+     * @param reference referenced field\n+     * @return formula reference, <code>{{reference}}</code>\n+     */\n+    public static String toFormulaReference(String reference) {", "originalCommit": "169e790e78a2d99da4b3a147bf4d176c8658f5b2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTAyNjUwOA==", "url": "https://github.com/yahoo/elide/pull/1208#discussion_r389026508", "bodyText": "Move to label Store", "author": "aklish", "createdAt": "2020-03-06T17:01:59Z", "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/metadata/MetaDataStore.java", "diffHunk": "@@ -171,6 +193,33 @@ public static boolean isTableJoin(Class<?> cls, String fieldName, EntityDictiona\n         return dictionary.getAttributeOrRelationAnnotation(cls, Join.class, fieldName) != null;\n     }\n \n+    /**\n+     * Use regex to get all references from a formula expression.\n+     *\n+     * @param formula formula expression\n+     * @return references appear in the formula.\n+     */\n+    public static List<String> resolveFormulaReferences(String formula) {", "originalCommit": "169e790e78a2d99da4b3a147bf4d176c8658f5b2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTAzNDgzOQ==", "url": "https://github.com/yahoo/elide/pull/1208#discussion_r389034839", "bodyText": "I think it is clearer to just call the constructor directly.  I would remove this function.", "author": "aklish", "createdAt": "2020-03-06T17:18:13Z", "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/metadata/models/Metric.java", "diffHunk": "@@ -45,27 +53,146 @@ public Metric(Table table, String fieldName, EntityDictionary dictionary) {\n                 Meta.class,\n                 fieldName);\n \n+        if (aggregation != null) {\n+            this.metricFunction = resolveAggregation(tableClass, fieldName, aggregation, meta, dictionary);\n+        } else {\n+            MetricFormula formula = dictionary.getAttributeOrRelationAnnotation(\n+                    tableClass,\n+                    MetricFormula.class,\n+                    fieldName);\n+\n+            if (formula != null) {\n+                this.metricFunction = constructMetricFunction(\n+                        constructColumnName(tableClass, fieldName, dictionary) + \"[\" + fieldName + \"]\",\n+                        meta == null ? null : meta.longName(),\n+                        meta == null ? null : meta.description(),\n+                        formula.value(),\n+                        new HashSet<>());\n+\n+            } else {\n+                throw new IllegalArgumentException(\"Trying to construct metric field \"\n+                        + getId() + \" without @MetricAggregation and @MetricFormula.\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Resolve aggregation function from {@link MetricAggregation} annotation.\n+     *\n+     * @param tableClass table class\n+     * @param fieldName metric field name\n+     * @param aggregation aggregation annotation on the field\n+     * @param meta meta annotation on the field\n+     * @param dictionary dictionary with entity information\n+     * @return resolved metric function instance\n+     */\n+    private static MetricFunction resolveAggregation(Class<?> tableClass,\n+                                                     String fieldName,\n+                                                     MetricAggregation aggregation,\n+                                                     Meta meta,\n+                                                     EntityDictionary dictionary) {\n+        String columnName = constructColumnName(tableClass, fieldName, dictionary);\n         try {\n-            this.metricFunction = metric.function().newInstance();\n-            metricFunction.setName(getId() + \"[\" + metricFunction.getName() + \"]\");\n-            metricFunction.setExpression(String.format(\n-                    metricFunction.getExpression(),\n-                    dictionary.getAnnotatedColumnName(tableClass, fieldName)));\n+            MetricFunction metricFunction = aggregation.function().newInstance();\n+            metricFunction.setName(columnName + \"[\" + metricFunction.getName() + \"]\");\n \n             if (meta != null) {\n                 metricFunction.setLongName(meta.longName());\n                 metricFunction.setDescription(meta.description());\n             }\n+\n+            return metricFunction;\n         } catch (InstantiationException | IllegalAccessException e) {\n-            throw new IllegalArgumentException(\"Can't initialize function for metric \" + getId());\n+            throw new IllegalArgumentException(\"Can't initialize function for metric \" + columnName);\n         }\n     }\n \n+    /**\n+     * Dynamically construct a metric function\n+     *\n+     * @param id metric function id\n+     * @param longName meta long name\n+     * @param description meta description\n+     * @param expression expression string\n+     * @param arguments function arguments\n+     * @return a metric function instance\n+     */", "originalCommit": "169e790e78a2d99da4b3a147bf4d176c8658f5b2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTAzNjgzNA==", "url": "https://github.com/yahoo/elide/pull/1208#discussion_r389036834", "bodyText": "I would move all this to SQLMetric", "author": "aklish", "createdAt": "2020-03-06T17:22:18Z", "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/metadata/models/Metric.java", "diffHunk": "@@ -45,27 +53,146 @@ public Metric(Table table, String fieldName, EntityDictionary dictionary) {\n                 Meta.class,\n                 fieldName);\n \n+        if (aggregation != null) {\n+            this.metricFunction = resolveAggregation(tableClass, fieldName, aggregation, meta, dictionary);\n+        } else {\n+            MetricFormula formula = dictionary.getAttributeOrRelationAnnotation(\n+                    tableClass,\n+                    MetricFormula.class,\n+                    fieldName);\n+\n+            if (formula != null) {\n+                this.metricFunction = constructMetricFunction(\n+                        constructColumnName(tableClass, fieldName, dictionary) + \"[\" + fieldName + \"]\",\n+                        meta == null ? null : meta.longName(),\n+                        meta == null ? null : meta.description(),\n+                        formula.value(),\n+                        new HashSet<>());\n+\n+            } else {\n+                throw new IllegalArgumentException(\"Trying to construct metric field \"\n+                        + getId() + \" without @MetricAggregation and @MetricFormula.\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Resolve aggregation function from {@link MetricAggregation} annotation.\n+     *\n+     * @param tableClass table class\n+     * @param fieldName metric field name\n+     * @param aggregation aggregation annotation on the field\n+     * @param meta meta annotation on the field\n+     * @param dictionary dictionary with entity information\n+     * @return resolved metric function instance\n+     */\n+    private static MetricFunction resolveAggregation(Class<?> tableClass,\n+                                                     String fieldName,\n+                                                     MetricAggregation aggregation,\n+                                                     Meta meta,\n+                                                     EntityDictionary dictionary) {\n+        String columnName = constructColumnName(tableClass, fieldName, dictionary);\n         try {\n-            this.metricFunction = metric.function().newInstance();\n-            metricFunction.setName(getId() + \"[\" + metricFunction.getName() + \"]\");\n-            metricFunction.setExpression(String.format(\n-                    metricFunction.getExpression(),\n-                    dictionary.getAnnotatedColumnName(tableClass, fieldName)));\n+            MetricFunction metricFunction = aggregation.function().newInstance();\n+            metricFunction.setName(columnName + \"[\" + metricFunction.getName() + \"]\");\n \n             if (meta != null) {\n                 metricFunction.setLongName(meta.longName());\n                 metricFunction.setDescription(meta.description());\n             }\n+\n+            return metricFunction;\n         } catch (InstantiationException | IllegalAccessException e) {\n-            throw new IllegalArgumentException(\"Can't initialize function for metric \" + getId());\n+            throw new IllegalArgumentException(\"Can't initialize function for metric \" + columnName);\n         }\n     }\n \n+    /**\n+     * Dynamically construct a metric function\n+     *\n+     * @param id metric function id\n+     * @param longName meta long name\n+     * @param description meta description\n+     * @param expression expression string\n+     * @param arguments function arguments\n+     * @return a metric function instance\n+     */\n     protected MetricFunction constructMetricFunction(String id,\n                                                      String longName,\n                                                      String description,\n                                                      String expression,\n                                                      Set<FunctionArgument> arguments) {\n         return new MetricFunction(id, longName, description, expression, arguments);\n     }\n+\n+    @Override\n+    protected LabelResolver constructLabelResolver(EntityDictionary dictionary) {", "originalCommit": "169e790e78a2d99da4b3a147bf4d176c8658f5b2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTAzODYyMw==", "url": "https://github.com/yahoo/elide/pull/1208#discussion_r389038623", "bodyText": "flatmap", "author": "aklish", "createdAt": "2020-03-06T17:25:44Z", "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/queryengines/sql/SQLQueryConstructor.java", "diffHunk": "@@ -395,11 +398,12 @@ private Path expandJoinToPath(Path path) {\n      * @param table queried table\n      * @return A set of path elements that capture a relationship traversal.\n      */\n-    private Set<Path> extractJoinPaths(Set<ColumnProjection> groupByDimensions,\n+    private Set<JoinPath> extractJoinPaths(Set<ColumnProjection> groupByDimensions,\n                                        SQLTable table) {\n         return resolveSQLColumns(groupByDimensions, table).stream()\n-                .filter((dim) -> dim.getJoinPath() != null)\n-                .map(SQLColumn::getJoinPath)\n+                .map(SQLColumn::getJoinPaths)\n+                .map(Collection::stream)\n+                .reduce(Stream.empty(), (s1, s2) -> Streams.concat(s1, s2))", "originalCommit": "169e790e78a2d99da4b3a147bf4d176c8658f5b2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA0MjE5MQ==", "url": "https://github.com/yahoo/elide/pull/1208#discussion_r389042191", "bodyText": "The code is harder to understand when we wrap constructors in one line functions.   I would remove these.", "author": "aklish", "createdAt": "2020-03-06T17:32:38Z", "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/queryengines/sql/metadata/SQLColumn.java", "diffHunk": "@@ -5,18 +5,131 @@\n  */\n package com.yahoo.elide.datastores.aggregation.queryengines.sql.metadata;\n \n+import static com.yahoo.elide.datastores.aggregation.core.JoinPath.extendJoinPath;\n+import static com.yahoo.elide.utils.TypeHelper.extendTypeAlias;\n+import static com.yahoo.elide.utils.TypeHelper.getFieldAlias;\n+\n+import com.yahoo.elide.core.EntityDictionary;\n import com.yahoo.elide.datastores.aggregation.core.JoinPath;\n-import com.yahoo.elide.datastores.aggregation.metadata.models.Table;\n+import com.yahoo.elide.datastores.aggregation.metadata.LabelResolver;\n+import com.yahoo.elide.datastores.aggregation.metadata.LabelStore;\n+import com.yahoo.elide.datastores.aggregation.metadata.models.Column;\n+import com.yahoo.elide.datastores.aggregation.queryengines.sql.SQLQueryEngine;\n+import com.yahoo.elide.datastores.aggregation.queryengines.sql.annotation.DimensionFormula;\n+import com.yahoo.elide.datastores.aggregation.queryengines.sql.annotation.JoinTo;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n \n /**\n- * Column with physical SQL information like reference and join to path.\n+ * SQLColumn is a wrapper for {@link Column} that contains physical information for {@link SQLQueryEngine}.\n  */\n public interface SQLColumn {\n-    Table getTable();\n-\n-    String getName();\n+    /**\n+     * Get wrapped column\n+     *\n+     * @return column\n+     */\n+    Column getColumn();\n \n+    /**\n+     * Get full sql reference\n+     *\n+     * @return physical reference\n+     */\n     String getReference();\n \n-    JoinPath getJoinPath();\n+    /**\n+     * Get join paths needed for this column\n+     *\n+     * @return all join paths to this column\n+     */\n+    List<JoinPath> getJoinPaths();\n+\n+    /**\n+     * SQL Column would resolve references in {@link DimensionFormula} when constructing physical reference.\n+     *\n+     * @return {@link LabelResolver} for sql columns\n+     */\n+    default LabelResolver constructSQLColumnLabelResolver(EntityDictionary dictionary) {\n+        Class<?> tableClass = dictionary.getEntityClass(getColumn().getTable().getId());\n+        String fieldName = getColumn().getName();\n+\n+        DimensionFormula formula = dictionary.getAttributeOrRelationAnnotation(\n+                tableClass, DimensionFormula.class, fieldName);\n+\n+        if (formula == null) {\n+            JoinTo joinTo = dictionary.getAttributeOrRelationAnnotation(tableClass, JoinTo.class, fieldName);\n+\n+            return joinTo == null || joinTo.path().equals(\"\")\n+                    ? getLogicalColumnResolver(tableClass, fieldName)\n+                    : getJoinToResolver(tableClass, joinTo);\n+        } else {\n+            return getFormulaResolver(tableClass, formula);\n+        }\n+    }\n+\n+    /**\n+     * Get a logical column reference resolver\n+     *\n+     * @param tableClass table class\n+     * @param fieldName field name\n+     * @return a resolver\n+     */\n+    default LabelResolver getLogicalColumnResolver(Class<?> tableClass, String fieldName) {\n+        return new LabelResolver(getColumn()) {\n+            @Override\n+            public String resolveLabel(LabelStore labelStore, String tableAlias) {\n+                return getFieldAlias(\n+                        tableAlias,\n+                        labelStore.getDictionary().getAnnotatedColumnName(tableClass, fieldName));\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Get a {@link JoinTo} reference resolver.\n+     *\n+     * @param tableClass table class\n+     * @param joinTo join to path\n+     * @return a resolver\n+     */\n+    default LabelResolver getJoinToResolver(Class<?> tableClass, JoinTo joinTo) {\n+        return new LabelResolver(getColumn()) {\n+            @Override\n+            public Set<JoinPath> resolveJoinPaths(LabelStore labelStore, JoinPath from) {\n+                JoinPath to = getJoinToPath(labelStore);\n+\n+                return labelStore.getLabelResolver(to).resolveJoinPaths(labelStore, extendJoinPath(from, to));\n+            }\n+\n+            @Override\n+            public Set<LabelResolver> getDependencyResolvers(LabelStore labelStore) {\n+                return Collections.singleton(labelStore.getLabelResolver(getJoinToPath(labelStore)));\n+            }\n+\n+            @Override\n+            public String resolveLabel(LabelStore labelStore, String tableAlias) {\n+                JoinPath joinToPath = getJoinToPath(labelStore);\n+\n+                return labelStore.resolveLabel(joinToPath, extendTypeAlias(tableAlias, joinToPath));\n+            }\n+\n+            private JoinPath getJoinToPath(LabelStore labelStore) {\n+                return new JoinPath(tableClass, labelStore.getDictionary(), joinTo.path());", "originalCommit": "169e790e78a2d99da4b3a147bf4d176c8658f5b2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA0Mjc5Nw==", "url": "https://github.com/yahoo/elide/pull/1208#discussion_r389042797", "bodyText": "I assume we can collapse this if we move Column level logic from column to SQLColumn", "author": "aklish", "createdAt": "2020-03-06T17:33:48Z", "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/queryengines/sql/metadata/SQLColumn.java", "diffHunk": "@@ -5,18 +5,131 @@\n  */\n package com.yahoo.elide.datastores.aggregation.queryengines.sql.metadata;\n \n+import static com.yahoo.elide.datastores.aggregation.core.JoinPath.extendJoinPath;\n+import static com.yahoo.elide.utils.TypeHelper.extendTypeAlias;\n+import static com.yahoo.elide.utils.TypeHelper.getFieldAlias;\n+\n+import com.yahoo.elide.core.EntityDictionary;\n import com.yahoo.elide.datastores.aggregation.core.JoinPath;\n-import com.yahoo.elide.datastores.aggregation.metadata.models.Table;\n+import com.yahoo.elide.datastores.aggregation.metadata.LabelResolver;\n+import com.yahoo.elide.datastores.aggregation.metadata.LabelStore;\n+import com.yahoo.elide.datastores.aggregation.metadata.models.Column;\n+import com.yahoo.elide.datastores.aggregation.queryengines.sql.SQLQueryEngine;\n+import com.yahoo.elide.datastores.aggregation.queryengines.sql.annotation.DimensionFormula;\n+import com.yahoo.elide.datastores.aggregation.queryengines.sql.annotation.JoinTo;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n \n /**\n- * Column with physical SQL information like reference and join to path.\n+ * SQLColumn is a wrapper for {@link Column} that contains physical information for {@link SQLQueryEngine}.\n  */\n public interface SQLColumn {\n-    Table getTable();\n-\n-    String getName();\n+    /**\n+     * Get wrapped column\n+     *\n+     * @return column\n+     */\n+    Column getColumn();\n \n+    /**\n+     * Get full sql reference\n+     *\n+     * @return physical reference\n+     */\n     String getReference();\n \n-    JoinPath getJoinPath();\n+    /**\n+     * Get join paths needed for this column\n+     *\n+     * @return all join paths to this column\n+     */\n+    List<JoinPath> getJoinPaths();\n+\n+    /**\n+     * SQL Column would resolve references in {@link DimensionFormula} when constructing physical reference.\n+     *\n+     * @return {@link LabelResolver} for sql columns\n+     */\n+    default LabelResolver constructSQLColumnLabelResolver(EntityDictionary dictionary) {\n+        Class<?> tableClass = dictionary.getEntityClass(getColumn().getTable().getId());\n+        String fieldName = getColumn().getName();\n+\n+        DimensionFormula formula = dictionary.getAttributeOrRelationAnnotation(\n+                tableClass, DimensionFormula.class, fieldName);\n+\n+        if (formula == null) {\n+            JoinTo joinTo = dictionary.getAttributeOrRelationAnnotation(tableClass, JoinTo.class, fieldName);\n+\n+            return joinTo == null || joinTo.path().equals(\"\")\n+                    ? getLogicalColumnResolver(tableClass, fieldName)\n+                    : getJoinToResolver(tableClass, joinTo);\n+        } else {\n+            return getFormulaResolver(tableClass, formula);\n+        }\n+    }\n+\n+    /**\n+     * Get a logical column reference resolver\n+     *\n+     * @param tableClass table class\n+     * @param fieldName field name\n+     * @return a resolver\n+     */\n+    default LabelResolver getLogicalColumnResolver(Class<?> tableClass, String fieldName) {\n+        return new LabelResolver(getColumn()) {\n+            @Override\n+            public String resolveLabel(LabelStore labelStore, String tableAlias) {\n+                return getFieldAlias(\n+                        tableAlias,\n+                        labelStore.getDictionary().getAnnotatedColumnName(tableClass, fieldName));\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Get a {@link JoinTo} reference resolver.\n+     *\n+     * @param tableClass table class\n+     * @param joinTo join to path\n+     * @return a resolver\n+     */\n+    default LabelResolver getJoinToResolver(Class<?> tableClass, JoinTo joinTo) {", "originalCommit": "169e790e78a2d99da4b3a147bf4d176c8658f5b2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA0NjMzNQ==", "url": "https://github.com/yahoo/elide/pull/1208#discussion_r389046335", "bodyText": "I believe sourcePath and sourceColumn are going away - based on our last discussion.", "author": "aklish", "createdAt": "2020-03-06T17:40:08Z", "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/queryengines/sql/metadata/SQLDimension.java", "diffHunk": "@@ -5,51 +5,59 @@\n  */\n package com.yahoo.elide.datastores.aggregation.queryengines.sql.metadata;\n \n-import static com.yahoo.elide.datastores.aggregation.queryengines.sql.SQLQueryEngine.generateColumnReference;\n import static com.yahoo.elide.datastores.aggregation.queryengines.sql.SQLQueryEngine.getClassAlias;\n \n import com.yahoo.elide.core.EntityDictionary;\n import com.yahoo.elide.core.Path;\n import com.yahoo.elide.datastores.aggregation.core.JoinPath;\n+import com.yahoo.elide.datastores.aggregation.metadata.LabelResolver;\n+import com.yahoo.elide.datastores.aggregation.metadata.LabelStore;\n+import com.yahoo.elide.datastores.aggregation.metadata.models.Column;\n import com.yahoo.elide.datastores.aggregation.metadata.models.Dimension;\n import com.yahoo.elide.datastores.aggregation.metadata.models.Table;\n-import com.yahoo.elide.datastores.aggregation.queryengines.sql.annotation.JoinTo;\n \n import lombok.Getter;\n \n+import java.util.ArrayList;\n+import java.util.List;\n+\n /**\n  * SQLDimension are dimension columns with extra physical information.\n  */\n public class SQLDimension extends Dimension implements SQLColumn {\n     @Getter\n-    private final String reference;\n-\n-    @Getter\n-    private final JoinPath joinPath;\n+    private String reference;\n \n     @Getter\n-    private EntityDictionary metadataDictionary;\n+    private List<JoinPath> joinPaths = new ArrayList<>();\n \n     public SQLDimension(Table table, String fieldName, EntityDictionary dictionary) {\n         super(table, fieldName, dictionary);\n-        Class<?> tableClass = dictionary.getEntityClass(table.getId());\n+    }\n+\n+    @Override\n+    public Path getSourcePath(EntityDictionary metadataDictionary) {", "originalCommit": "169e790e78a2d99da4b3a147bf4d176c8658f5b2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA0NzcxNg==", "url": "https://github.com/yahoo/elide/pull/1208#discussion_r389047716", "bodyText": "I'm wondering if it would be simpler to resolve the reference field at query time - rather than this approach of doing it up front.  Let's discuss.", "author": "aklish", "createdAt": "2020-03-06T17:42:41Z", "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/queryengines/sql/metadata/SQLDimension.java", "diffHunk": "@@ -5,51 +5,59 @@\n  */\n package com.yahoo.elide.datastores.aggregation.queryengines.sql.metadata;\n \n-import static com.yahoo.elide.datastores.aggregation.queryengines.sql.SQLQueryEngine.generateColumnReference;\n import static com.yahoo.elide.datastores.aggregation.queryengines.sql.SQLQueryEngine.getClassAlias;\n \n import com.yahoo.elide.core.EntityDictionary;\n import com.yahoo.elide.core.Path;\n import com.yahoo.elide.datastores.aggregation.core.JoinPath;\n+import com.yahoo.elide.datastores.aggregation.metadata.LabelResolver;\n+import com.yahoo.elide.datastores.aggregation.metadata.LabelStore;\n+import com.yahoo.elide.datastores.aggregation.metadata.models.Column;\n import com.yahoo.elide.datastores.aggregation.metadata.models.Dimension;\n import com.yahoo.elide.datastores.aggregation.metadata.models.Table;\n-import com.yahoo.elide.datastores.aggregation.queryengines.sql.annotation.JoinTo;\n \n import lombok.Getter;\n \n+import java.util.ArrayList;\n+import java.util.List;\n+\n /**\n  * SQLDimension are dimension columns with extra physical information.\n  */\n public class SQLDimension extends Dimension implements SQLColumn {\n     @Getter\n-    private final String reference;\n-\n-    @Getter\n-    private final JoinPath joinPath;\n+    private String reference;\n \n     @Getter\n-    private EntityDictionary metadataDictionary;\n+    private List<JoinPath> joinPaths = new ArrayList<>();\n \n     public SQLDimension(Table table, String fieldName, EntityDictionary dictionary) {\n         super(table, fieldName, dictionary);\n-        Class<?> tableClass = dictionary.getEntityClass(table.getId());\n+    }\n+\n+    @Override\n+    public Path getSourcePath(EntityDictionary metadataDictionary) {\n+        // As we are using DFS for resolving reference, the first resolved reference would be the deepest source\n+        return joinPaths.isEmpty() ? super.getSourcePath(metadataDictionary) : joinPaths.get(0);\n+    }\n \n-        JoinTo joinTo = dictionary.getAttributeOrRelationAnnotation(tableClass, JoinTo.class, fieldName);\n+    @Override\n+    public void resolveLabel(LabelStore labelStore) {", "originalCommit": "169e790e78a2d99da4b3a147bf4d176c8658f5b2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA1MjUxNA==", "url": "https://github.com/yahoo/elide/pull/1208#discussion_r389052514", "bodyText": "Using Path here is unnatural.  If you look at the code, we only use the Class (Table) and field to actually store and lookup the resolvers.   There is a lot of code that has to lookup the resolver - and that code is creating these paths again and again.   Looking up by Path I think is confusing - because the actual lookup keys are obfuscated by the Path data structure.", "author": "aklish", "createdAt": "2020-03-06T17:52:24Z", "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/metadata/LabelStore.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.datastores.aggregation.metadata;\n+\n+import com.yahoo.elide.core.EntityDictionary;\n+import com.yahoo.elide.core.Path;\n+import com.yahoo.elide.datastores.aggregation.core.JoinPath;\n+\n+import java.util.Set;\n+\n+/**\n+ * LabelStore stores all label resolvers for all columns. It uses {@link JoinPath} as reference to each field.\n+ */\n+public interface LabelStore {\n+    /**\n+     * Get a dictionary with model definitions.\n+     *\n+     * @return dictionary\n+     */\n+    EntityDictionary getDictionary();\n+\n+    /**\n+     * Get the label resolver for a path\n+     *\n+     * @param path path to a logical field\n+     * @return a label resolver\n+     */\n+    LabelResolver getLabelResolver(Path path);", "originalCommit": "169e790e78a2d99da4b3a147bf4d176c8658f5b2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA1Mjk2NQ==", "url": "https://github.com/yahoo/elide/pull/1208#discussion_r389052965", "bodyText": "Let's remove all the sourcePath and sourceColumn code for now.", "author": "aklish", "createdAt": "2020-03-06T17:53:27Z", "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/queryengines/sql/metadata/SQLTimeDimension.java", "diffHunk": "@@ -5,51 +5,58 @@\n  */\n package com.yahoo.elide.datastores.aggregation.queryengines.sql.metadata;\n \n-import static com.yahoo.elide.datastores.aggregation.queryengines.sql.SQLQueryEngine.generateColumnReference;\n import static com.yahoo.elide.datastores.aggregation.queryengines.sql.SQLQueryEngine.getClassAlias;\n \n import com.yahoo.elide.core.EntityDictionary;\n import com.yahoo.elide.core.Path;\n import com.yahoo.elide.datastores.aggregation.core.JoinPath;\n+import com.yahoo.elide.datastores.aggregation.metadata.LabelResolver;\n+import com.yahoo.elide.datastores.aggregation.metadata.LabelStore;\n+import com.yahoo.elide.datastores.aggregation.metadata.models.Column;\n import com.yahoo.elide.datastores.aggregation.metadata.models.Table;\n import com.yahoo.elide.datastores.aggregation.metadata.models.TimeDimension;\n-import com.yahoo.elide.datastores.aggregation.queryengines.sql.annotation.JoinTo;\n \n import lombok.Getter;\n \n+import java.util.ArrayList;\n+import java.util.List;\n+\n /**\n  * SQLTimeDimension are time dimension columns with extra physical information.\n  */\n public class SQLTimeDimension extends TimeDimension implements SQLColumn {\n     @Getter\n-    private final String reference;\n-\n-    @Getter\n-    private final JoinPath joinPath;\n+    private String reference;\n \n     @Getter\n-    private EntityDictionary metadataDictionary;\n+    private List<JoinPath> joinPaths = new ArrayList<>();\n \n     public SQLTimeDimension(Table table, String fieldName, EntityDictionary dictionary) {\n         super(table, fieldName, dictionary);\n-        Class<?> tableClass = dictionary.getEntityClass(table.getId());\n+    }\n+\n+    @Override\n+    public Path getSourcePath(EntityDictionary metadataDictionary) {", "originalCommit": "169e790e78a2d99da4b3a147bf4d176c8658f5b2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "412c05aa809079dc65fd6faa96c495ab7eea758d", "url": "https://github.com/yahoo/elide/commit/412c05aa809079dc65fd6faa96c495ab7eea758d", "message": "move symbol table into sql query engine", "committedDate": "2020-03-09T20:27:04Z", "type": "commit"}, {"oid": "b0f9d8d62f5c66492e7ac6a1956e1386615c1aac", "url": "https://github.com/yahoo/elide/commit/b0f9d8d62f5c66492e7ac6a1956e1386615c1aac", "message": "remove sourceColumn", "committedDate": "2020-03-10T16:22:31Z", "type": "commit"}, {"oid": "8f63ae24b2db6be54187fe0120cbcc8a20802b2b", "url": "https://github.com/yahoo/elide/commit/8f63ae24b2db6be54187fe0120cbcc8a20802b2b", "message": "update reference expression", "committedDate": "2020-03-10T16:30:03Z", "type": "commit"}, {"oid": "128dffea43828dcc79f2062a6c5534a8bfe04f49", "url": "https://github.com/yahoo/elide/commit/128dffea43828dcc79f2062a6c5534a8bfe04f49", "message": "visitor design", "committedDate": "2020-03-11T20:59:26Z", "type": "commit"}, {"oid": "7e60a000696e773c857365a00a952342c5cf0fa9", "url": "https://github.com/yahoo/elide/commit/7e60a000696e773c857365a00a952342c5cf0fa9", "message": "add comments", "committedDate": "2020-03-11T21:07:12Z", "type": "commit"}, {"oid": "fb1860652917b94ba44ffc17b0314da48fd50f9b", "url": "https://github.com/yahoo/elide/commit/fb1860652917b94ba44ffc17b0314da48fd50f9b", "message": "add unit join path test", "committedDate": "2020-03-12T19:03:52Z", "type": "commit"}, {"oid": "f31fab5588a5be0e2473d4d12f892b1deecebd35", "url": "https://github.com/yahoo/elide/commit/f31fab5588a5be0e2473d4d12f892b1deecebd35", "message": "fix timeDimensionProjection", "committedDate": "2020-03-16T18:46:23Z", "type": "commit"}, {"oid": "72eeb14b33a4b7b5654849f9ad30bb15808b73ea", "url": "https://github.com/yahoo/elide/commit/72eeb14b33a4b7b5654849f9ad30bb15808b73ea", "message": "fix null value number", "committedDate": "2020-03-17T18:10:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU2NDA3OA==", "url": "https://github.com/yahoo/elide/pull/1208#discussion_r390564078", "bodyText": "We are still using the old LabelResolver name in a few places.  This is one.", "author": "aklish", "createdAt": "2020-03-10T19:37:43Z", "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/queryengines/sql/metadata/SQLReferenceResolver.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.datastores.aggregation.queryengines.sql.metadata;\n+\n+import com.yahoo.elide.datastores.aggregation.core.JoinPath;\n+import com.yahoo.elide.datastores.aggregation.metadata.models.Column;\n+\n+import java.util.Collections;\n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * LabelResolver is an interface for resolving column into some type of \"labels\" such as column reference, join", "originalCommit": "8f63ae24b2db6be54187fe0120cbcc8a20802b2b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU2NDIwMQ==", "url": "https://github.com/yahoo/elide/pull/1208#discussion_r390564201", "bodyText": "Maybe call it referenceResolver", "author": "aklish", "createdAt": "2020-03-10T19:38:00Z", "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/queryengines/sql/metadata/SQLReferenceResolver.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.datastores.aggregation.queryengines.sql.metadata;\n+\n+import com.yahoo.elide.datastores.aggregation.core.JoinPath;\n+import com.yahoo.elide.datastores.aggregation.metadata.models.Column;\n+\n+import java.util.Collections;\n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * LabelResolver is an interface for resolving column into some type of \"labels\" such as column reference, join\n+ * path and so on. It uses Depth-First-Search approach to traverse join path vertically. The resolved results would\n+ * be stored for quick access.\n+ */\n+public abstract class SQLReferenceResolver {\n+    private final Column toResolve;\n+\n+    protected SQLReferenceResolver(Column toResolve) {\n+        this.toResolve = toResolve;\n+    }\n+\n+    /**\n+     * Resolve label for this column\n+     *\n+     * @param referenceTable source-of-truth store\n+     * @param tableAlias label prefix to the table that contains this column\n+     * @return resolved label\n+     */\n+    public abstract String resolveReference(SQLReferenceTable referenceTable, String tableAlias);\n+\n+    /**\n+     * Get all joins needs for this column\n+     *\n+     * @param referenceTable source-of-truth store\n+     * @param from root join path to this column\n+     * @return full join paths\n+     */\n+    public Set<JoinPath> resolveJoinPaths(SQLReferenceTable referenceTable, JoinPath from) {\n+        return Collections.singleton(from);\n+    }\n+\n+    /**\n+     * Get all other resolvers that this resolver would involve when resolving label.\n+     *\n+     * @param referenceTable table stores all resolvers\n+     * @return dependency resolvers\n+     */\n+    protected Set<SQLReferenceResolver> getDependencyResolvers(SQLReferenceTable referenceTable) {\n+        return Collections.emptySet();\n+    }\n+\n+    /**\n+     * Check whether this resolver would cause reference loop\n+     *\n+     * @param referenceTable table stores all SQL reference resolvers\n+     */\n+    public void checkResolverLoop(SQLReferenceTable referenceTable) {\n+        this.checkResolverLoop(new LinkedHashSet<>(), referenceTable);\n+    }\n+\n+    /**\n+     * Check whether this resolver would cause reference loop\n+     *\n+     * @param visited visited label resolvers\n+     * @param referenceTable table stores all SQL reference resolvers\n+     */\n+    private void checkResolverLoop(LinkedHashSet<SQLReferenceResolver> visited, SQLReferenceTable referenceTable) {\n+        if (visited.contains(this)) {\n+            throw new IllegalArgumentException(referenceLoopMessage(visited, this));\n+        } else {\n+            visited.add(this);\n+            this.getDependencyResolvers(referenceTable)\n+                    .forEach(resolver -> resolver.checkResolverLoop(visited, referenceTable));\n+            visited.remove(this);\n+        }\n+    }\n+\n+    /**\n+     * Construct reference loop message.\n+     */\n+    private static String referenceLoopMessage(LinkedHashSet<SQLReferenceResolver> visited, SQLReferenceResolver loop) {\n+        return \"Formula reference loop found: \"\n+                + visited.stream()\n+                        .map(labelResolver -> labelResolver.toResolve.getId())", "originalCommit": "8f63ae24b2db6be54187fe0120cbcc8a20802b2b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU2NTM3Nw==", "url": "https://github.com/yahoo/elide/pull/1208#discussion_r390565377", "bodyText": "Maybe rename as getDependentResolvers.", "author": "aklish", "createdAt": "2020-03-10T19:40:17Z", "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/queryengines/sql/metadata/SQLReferenceResolver.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.datastores.aggregation.queryengines.sql.metadata;\n+\n+import com.yahoo.elide.datastores.aggregation.core.JoinPath;\n+import com.yahoo.elide.datastores.aggregation.metadata.models.Column;\n+\n+import java.util.Collections;\n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * LabelResolver is an interface for resolving column into some type of \"labels\" such as column reference, join\n+ * path and so on. It uses Depth-First-Search approach to traverse join path vertically. The resolved results would\n+ * be stored for quick access.\n+ */\n+public abstract class SQLReferenceResolver {\n+    private final Column toResolve;\n+\n+    protected SQLReferenceResolver(Column toResolve) {\n+        this.toResolve = toResolve;\n+    }\n+\n+    /**\n+     * Resolve label for this column\n+     *\n+     * @param referenceTable source-of-truth store\n+     * @param tableAlias label prefix to the table that contains this column\n+     * @return resolved label\n+     */\n+    public abstract String resolveReference(SQLReferenceTable referenceTable, String tableAlias);\n+\n+    /**\n+     * Get all joins needs for this column\n+     *\n+     * @param referenceTable source-of-truth store\n+     * @param from root join path to this column\n+     * @return full join paths\n+     */\n+    public Set<JoinPath> resolveJoinPaths(SQLReferenceTable referenceTable, JoinPath from) {\n+        return Collections.singleton(from);\n+    }\n+\n+    /**\n+     * Get all other resolvers that this resolver would involve when resolving label.\n+     *\n+     * @param referenceTable table stores all resolvers\n+     * @return dependency resolvers\n+     */\n+    protected Set<SQLReferenceResolver> getDependencyResolvers(SQLReferenceTable referenceTable) {", "originalCommit": "8f63ae24b2db6be54187fe0120cbcc8a20802b2b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI1NjQzMw==", "url": "https://github.com/yahoo/elide/pull/1208#discussion_r397256433", "bodyText": "Is there any reason we just don't use class.newInstance here?", "author": "aklish", "createdAt": "2020-03-24T15:45:46Z", "path": "elide-core/src/main/java/com/yahoo/elide/utils/coerce/CoerceUtil.java", "diffHunk": "@@ -49,6 +51,12 @@\n     public static <T> T coerce(Object value, Class<T> cls) {\n         initializeCurrentClassLoaderIfNecessary();\n \n+        // null value of number type would be converted to 0, as 'null' would cause exception for primitive\n+        // number classes\n+        if (value == null && isNumberType(cls)) {\n+            return (T) Array.get(Array.newInstance(cls, 1), 0);", "originalCommit": "72eeb14b33a4b7b5654849f9ad30bb15808b73ea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQxNjA0Mg==", "url": "https://github.com/yahoo/elide/pull/1208#discussion_r397416042", "bodyText": "class.newInstance() wouldn't work for primitive number types.", "author": "hellohanchen", "createdAt": "2020-03-24T19:43:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI1NjQzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI1OTQwNw==", "url": "https://github.com/yahoo/elide/pull/1208#discussion_r397259407", "bodyText": "Maybe we should add a Precondition that the last element of path is equal to the first element of the extension.", "author": "aklish", "createdAt": "2020-03-24T15:49:20Z", "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/core/JoinPath.java", "diffHunk": "@@ -23,4 +34,31 @@ protected boolean needNavigation(Class<?> entityClass, String fieldName, EntityD\n         return dictionary.isRelation(entityClass, fieldName)\n                 || MetaDataStore.isTableJoin(entityClass, fieldName, dictionary);\n     }\n+\n+    /**\n+     * Extend this path with a extension dot separated path\n+     *\n+     * @param extensionPath extension path append to this join path\n+     * @param dictionary dictionary\n+     * @return expended join path e.g. <code>[A.B]/[B.C] + C.D = [A.B]/[B.C]/[C.D]</code>\n+     */\n+    public JoinPath extend(String extensionPath, EntityDictionary dictionary) {\n+        return extendJoinPath(this, new JoinPath(lastElement().get().getType(), dictionary, extensionPath));\n+    }\n+\n+    /**\n+     * Append an extension path to an original path, the last element of original path should be the same as the\n+     * first element of extension path.\n+     *\n+     * @param path original path, e.g. <code>[A.B]/[B.C]</code>\n+     * @param extension extension path, e.g. <code>[B.C]/[C.D]</code>\n+     * @param <P> path extension\n+     * @return extended path <code>[A.B]/[B.C]/[C.D]</code>\n+     */\n+    private static <P extends Path> JoinPath extendJoinPath(Path path, P extension) {\n+        List<Path.PathElement> toExtend = new ArrayList<>(path.getPathElements());", "originalCommit": "72eeb14b33a4b7b5654849f9ad30bb15808b73ea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQyMjg4NA==", "url": "https://github.com/yahoo/elide/pull/1208#discussion_r397422884", "bodyText": "This is a private static method, we don't need to check it here.", "author": "hellohanchen", "createdAt": "2020-03-24T19:56:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI1OTQwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI2Njc4NA==", "url": "https://github.com/yahoo/elide/pull/1208#discussion_r397266784", "bodyText": "Do we need to check here if visited already contains the dimension?", "author": "aklish", "createdAt": "2020-03-24T15:58:23Z", "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/metadata/FormulaValidator.java", "diffHunk": "@@ -0,0 +1,127 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.datastores.aggregation.metadata;\n+\n+import com.yahoo.elide.datastores.aggregation.annotation.DimensionFormula;\n+import com.yahoo.elide.datastores.aggregation.annotation.JoinTo;\n+import com.yahoo.elide.datastores.aggregation.annotation.MetricFormula;\n+import com.yahoo.elide.datastores.aggregation.core.JoinPath;\n+import com.yahoo.elide.datastores.aggregation.metadata.models.Column;\n+import com.yahoo.elide.datastores.aggregation.metadata.models.Dimension;\n+import com.yahoo.elide.datastores.aggregation.metadata.models.Metric;\n+\n+import java.util.LinkedHashSet;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * FormulaValidator check whether a column defined with {@link JoinTo}, {@link MetricFormula} or\n+ * {@link DimensionFormula} has reference loop. If so, throw out exception.\n+ */\n+public class FormulaValidator extends ColumnVisitor<Void> {\n+    private final LinkedHashSet<Column> visited = new LinkedHashSet<>();\n+\n+    public FormulaValidator(MetaDataStore metaDataStore) {\n+        super(metaDataStore);\n+    }\n+\n+    /**\n+     * For a FIELD column, don't need to check anything.\n+     *\n+     * @param metric a FIELD metric\n+     * @return null\n+     */\n+    @Override\n+    protected Void visitFieldMetric(Metric metric) {\n+        return null;\n+    }\n+\n+    @Override\n+    protected Void visitFormulaMetric(Metric metric) {\n+        return visitFormulaColumn(metric);\n+    }\n+\n+    /**\n+     * For a FIELD column, don't need to check anything.\n+     *\n+     * @param dimension a FIELD dimension\n+     * @return null\n+     */\n+    @Override\n+    protected Void visitFieldDimension(Dimension dimension) {\n+        return null;\n+    }\n+\n+    @Override\n+    protected Void visitFormulaDimension(Dimension dimension) {\n+        return visitFormulaColumn(dimension);\n+    }\n+\n+    /**\n+     * For a reference dimension column. We mark the column as visited and visit the source column.\n+     *\n+     * @param dimension dimension defined with {@link JoinTo}\n+     * @return null\n+     */\n+    @Override\n+    protected Void visitReferenceDimension(Dimension dimension) {\n+        Class<?> tableClass = dictionary.getEntityClass(dimension.getTable().getId());\n+\n+        JoinPath joinToPath = new JoinPath(\n+                tableClass,\n+                dictionary,\n+                dictionary.getAttributeOrRelationAnnotation(tableClass, JoinTo.class, dimension.getName()).path());\n+\n+        visited.add(dimension);", "originalCommit": "72eeb14b33a4b7b5654849f9ad30bb15808b73ea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQyMTQzMw==", "url": "https://github.com/yahoo/elide/pull/1208#discussion_r397421433", "bodyText": "\ud83d\udc4d", "author": "hellohanchen", "createdAt": "2020-03-24T19:53:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI2Njc4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI4MTU0MQ==", "url": "https://github.com/yahoo/elide/pull/1208#discussion_r397281541", "bodyText": "Given this has state, should we create a new one for each column?", "author": "aklish", "createdAt": "2020-03-24T16:17:09Z", "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/queryengines/sql/metadata/SQLReferenceTable.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.datastores.aggregation.queryengines.sql.metadata;\n+\n+import static com.yahoo.elide.datastores.aggregation.queryengines.sql.SQLQueryEngine.getClassAlias;\n+\n+import com.yahoo.elide.core.EntityDictionary;\n+import com.yahoo.elide.core.Path;\n+import com.yahoo.elide.datastores.aggregation.core.JoinPath;\n+import com.yahoo.elide.datastores.aggregation.metadata.FormulaValidator;\n+import com.yahoo.elide.datastores.aggregation.metadata.MetaDataStore;\n+import com.yahoo.elide.datastores.aggregation.metadata.models.Metric;\n+import com.yahoo.elide.datastores.aggregation.metadata.models.Table;\n+\n+import lombok.Getter;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * LabelStore stores all label resolvers, resolved physical reference, resolved join paths for all columns.\n+ */\n+public class SQLReferenceTable {\n+    private final MetaDataStore metaDataStore;\n+\n+    @Getter\n+    private final EntityDictionary dictionary;\n+\n+    private final Map<Class<?>, Map<String, String>> resolvedReferences = new HashMap<>();\n+    private final Map<Class<?>, Map<String, Set<JoinPath>>> resolvedJoinPaths = new HashMap<>();\n+\n+    public SQLReferenceTable(MetaDataStore metaDataStore) {\n+        this.metaDataStore = metaDataStore;\n+        this.dictionary = this.metaDataStore.getDictionary();\n+\n+        metaDataStore.getMetaData(Table.class).forEach(this::resolveAndStoreAllReferencesAndJoins);\n+    }\n+\n+    /**\n+     * Get the resolved physical SQL reference for a field from storage\n+     *\n+     * @param table table class\n+     * @param fieldName field name\n+     * @return resolved reference\n+     */\n+    public String getResolvedReference(Table table, String fieldName) {\n+        return resolvedReferences.get(dictionary.getEntityClass(table.getId())).get(fieldName);\n+    }\n+\n+    /**\n+     * Get the resolved physical SQL reference for a field from storage\n+     *\n+     * @param table table class\n+     * @param fieldName field name\n+     * @return resolved reference\n+     */\n+    public Set<JoinPath> getResolvedJoinPaths(Table table, String fieldName) {\n+        return resolvedJoinPaths.get(dictionary.getEntityClass(table.getId())).get(fieldName);\n+    }\n+\n+    /**\n+     * Resolve all references and joins for a table and store them in this reference table.\n+     *\n+     * @param table meta data table\n+     */\n+    private void resolveAndStoreAllReferencesAndJoins(Table table) {\n+        Class<?> tableClass = dictionary.getEntityClass(table.getId());\n+        if (!resolvedReferences.containsKey(tableClass)) {\n+            resolvedReferences.put(tableClass, new HashMap<>());\n+        }\n+        if (!resolvedJoinPaths.containsKey(tableClass)) {\n+            resolvedJoinPaths.put(tableClass, new HashMap<>());\n+        }\n+\n+        FormulaValidator validator = new FormulaValidator(metaDataStore);\n+        SQLJoinVisitor joinVisitor = new SQLJoinVisitor(metaDataStore);", "originalCommit": "72eeb14b33a4b7b5654849f9ad30bb15808b73ea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQyNDkyNA==", "url": "https://github.com/yahoo/elide/pull/1208#discussion_r397424924", "bodyText": "The state would be cleared automatically based on the code logic.", "author": "hellohanchen", "createdAt": "2020-03-24T19:59:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI4MTU0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI4MzE4Nw==", "url": "https://github.com/yahoo/elide/pull/1208#discussion_r397283187", "bodyText": "This looks unused.", "author": "aklish", "createdAt": "2020-03-24T16:19:13Z", "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/queryengines/sql/metadata/SQLReferenceTable.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.datastores.aggregation.queryengines.sql.metadata;\n+\n+import static com.yahoo.elide.datastores.aggregation.queryengines.sql.SQLQueryEngine.getClassAlias;\n+\n+import com.yahoo.elide.core.EntityDictionary;\n+import com.yahoo.elide.core.Path;\n+import com.yahoo.elide.datastores.aggregation.core.JoinPath;\n+import com.yahoo.elide.datastores.aggregation.metadata.FormulaValidator;\n+import com.yahoo.elide.datastores.aggregation.metadata.MetaDataStore;\n+import com.yahoo.elide.datastores.aggregation.metadata.models.Metric;\n+import com.yahoo.elide.datastores.aggregation.metadata.models.Table;\n+\n+import lombok.Getter;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * LabelStore stores all label resolvers, resolved physical reference, resolved join paths for all columns.\n+ */\n+public class SQLReferenceTable {\n+    private final MetaDataStore metaDataStore;\n+\n+    @Getter\n+    private final EntityDictionary dictionary;\n+\n+    private final Map<Class<?>, Map<String, String>> resolvedReferences = new HashMap<>();\n+    private final Map<Class<?>, Map<String, Set<JoinPath>>> resolvedJoinPaths = new HashMap<>();\n+\n+    public SQLReferenceTable(MetaDataStore metaDataStore) {\n+        this.metaDataStore = metaDataStore;\n+        this.dictionary = this.metaDataStore.getDictionary();\n+\n+        metaDataStore.getMetaData(Table.class).forEach(this::resolveAndStoreAllReferencesAndJoins);\n+    }\n+\n+    /**\n+     * Get the resolved physical SQL reference for a field from storage\n+     *\n+     * @param table table class\n+     * @param fieldName field name\n+     * @return resolved reference\n+     */\n+    public String getResolvedReference(Table table, String fieldName) {\n+        return resolvedReferences.get(dictionary.getEntityClass(table.getId())).get(fieldName);\n+    }\n+\n+    /**\n+     * Get the resolved physical SQL reference for a field from storage\n+     *\n+     * @param table table class\n+     * @param fieldName field name\n+     * @return resolved reference\n+     */\n+    public Set<JoinPath> getResolvedJoinPaths(Table table, String fieldName) {\n+        return resolvedJoinPaths.get(dictionary.getEntityClass(table.getId())).get(fieldName);\n+    }\n+\n+    /**\n+     * Resolve all references and joins for a table and store them in this reference table.\n+     *\n+     * @param table meta data table\n+     */\n+    private void resolveAndStoreAllReferencesAndJoins(Table table) {\n+        Class<?> tableClass = dictionary.getEntityClass(table.getId());\n+        if (!resolvedReferences.containsKey(tableClass)) {\n+            resolvedReferences.put(tableClass, new HashMap<>());\n+        }\n+        if (!resolvedJoinPaths.containsKey(tableClass)) {\n+            resolvedJoinPaths.put(tableClass, new HashMap<>());\n+        }\n+\n+        FormulaValidator validator = new FormulaValidator(metaDataStore);\n+        SQLJoinVisitor joinVisitor = new SQLJoinVisitor(metaDataStore);\n+\n+        table.getColumns().forEach(column -> {\n+            // validate that there is no reference loop\n+            validator.visitColumn(column);\n+\n+            String fieldName = column.getName();\n+\n+            resolvedReferences.get(tableClass).put(\n+                    fieldName,\n+                    new SQLReferenceVisitor(metaDataStore, getClassAlias(tableClass)).visitColumn(column));\n+\n+            resolvedJoinPaths.get(tableClass).put(fieldName, joinVisitor.visitColumn(column));\n+\n+            if (column instanceof Metric) {\n+                ((Metric) column).getMetricFunction().setExpression(getResolvedReference(table, fieldName));\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Get physical reference for a path.\n+     *\n+     * @param path path to a field\n+     * @param tableAlias table alias as prefix\n+     * @return resolved physical reference\n+     */\n+    public String resolveReference(Path path, String tableAlias) {", "originalCommit": "72eeb14b33a4b7b5654849f9ad30bb15808b73ea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQyNTE1Ng==", "url": "https://github.com/yahoo/elide/pull/1208#discussion_r397425156", "bodyText": "Used in SQLQueryConstructor.", "author": "hellohanchen", "createdAt": "2020-03-24T20:00:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI4MzE4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzM0NzgyOA==", "url": "https://github.com/yahoo/elide/pull/1208#discussion_r397347828", "bodyText": "Instead of special casing this in the query constructor, I think this might be cleaner if TimeDImension was something that can be visited in the visitor itself.  Let's discuss and see if this is possible", "author": "aklish", "createdAt": "2020-03-24T17:48:38Z", "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/queryengines/sql/query/SQLQueryConstructor.java", "diffHunk": "@@ -418,13 +420,33 @@ private String translateFilterExpression(FilterExpression expression,\n     }\n \n     /**\n-     * Converts a filter predicate into a SQL WHERE/HAVING clause column reference.\n+     * Converts a path into a SQL WHERE/HAVING clause column reference.\n      *\n-     * @param predicate The predicate to convert\n+     * @param path path to a field\n+     * @param template query template\n+     * @param table Elide logical table this query is querying\n      * @return A SQL fragment that references a database column\n      */\n-    private String generatePredicateReference(FilterPredicate predicate) {\n-        return generateColumnReference(predicate.getPath(), dictionary);\n+    private String generatePredicatePathReference(Path path, SQLQueryTemplate template, Table table) {\n+        // if the predicate is for a time dimension, it needs to be projected in the query with specified time grain\n+        if (path.getPathElements().size() == 1) {", "originalCommit": "72eeb14b33a4b7b5654849f9ad30bb15808b73ea", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzM2NTkyNA==", "url": "https://github.com/yahoo/elide/pull/1208#discussion_r397365924", "bodyText": "use flatmap", "author": "aklish", "createdAt": "2020-03-24T18:17:14Z", "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/queryengines/sql/query/SQLQueryConstructor.java", "diffHunk": "@@ -381,25 +382,26 @@ private Path expandJoinToPath(Path path) {\n      * @param sortClauses The list of sort columns and their sort order (ascending or descending).\n      * @return A set of path elements that capture a relationship traversal.\n      */\n-    private Set<Path> extractJoinPaths(Map<Path, Sorting.SortOrder> sortClauses) {\n+    private Set<JoinPath> extractJoinPaths(Map<Path, Sorting.SortOrder> sortClauses) {\n         return sortClauses.keySet().stream()\n-                .map(this::expandJoinToPath)\n+                .map(this::extendToJoinToPath)\n                 .collect(Collectors.toCollection(LinkedHashSet::new));\n     }\n \n     /**\n      * Given the set of group by dimensions, extract any entity relationship traversals that require joins.\n-     * This method takes in a {@link SQLTable} because the sql join path meta data is stored in it.\n+     * This method takes in a {@link Table} because the sql join path meta data is stored in it.\n      *\n      * @param groupByDimensions The list of dimensions we are grouping on.\n      * @param table queried table\n      * @return A set of path elements that capture a relationship traversal.\n      */\n-    private Set<Path> extractJoinPaths(Set<ColumnProjection> groupByDimensions,\n-                                       SQLTable table) {\n-        return resolveSQLColumns(groupByDimensions, table).stream()\n-                .filter((dim) -> dim.getJoinPath() != null)\n-                .map(SQLColumn::getJoinPath)\n+    private Set<JoinPath> extractJoinPaths(Set<ColumnProjection> groupByDimensions,\n+                                           Table table) {\n+        return resolveProjectedDimensions(groupByDimensions, table).stream()\n+                .map(column -> referenceTable.getResolvedJoinPaths(table, column.getName()))\n+                .map(Collection::stream)", "originalCommit": "72eeb14b33a4b7b5654849f9ad30bb15808b73ea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQyOTg2MQ==", "url": "https://github.com/yahoo/elide/pull/1208#discussion_r397429861", "bodyText": "\ud83d\udc4d", "author": "hellohanchen", "createdAt": "2020-03-24T20:09:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzM2NTkyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzM2ODU1NQ==", "url": "https://github.com/yahoo/elide/pull/1208#discussion_r397368555", "bodyText": "Where is this used?", "author": "aklish", "createdAt": "2020-03-24T18:21:28Z", "path": "elide-datastore/elide-datastore-aggregation/src/test/java/com/yahoo/elide/datastores/aggregation/annotation/DimensionReference.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.datastores.aggregation.annotation;\n+\n+import com.yahoo.elide.annotation.Include;\n+\n+import lombok.EqualsAndHashCode;\n+import lombok.Setter;\n+import lombok.ToString;\n+\n+import javax.persistence.Column;\n+\n+@Include(rootLevel = true)\n+@Cardinality(size = CardinalitySize.LARGE)\n+@EqualsAndHashCode\n+@ToString\n+public class DimensionReference {", "originalCommit": "72eeb14b33a4b7b5654849f9ad30bb15808b73ea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzM2ODY4Mg==", "url": "https://github.com/yahoo/elide/pull/1208#discussion_r397368682", "bodyText": "I don't see a dimension reference here.", "author": "aklish", "createdAt": "2020-03-24T18:21:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzM2ODU1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQzMDQyMg==", "url": "https://github.com/yahoo/elide/pull/1208#discussion_r397430422", "bodyText": "Removed. \ud83d\udc4d", "author": "hellohanchen", "createdAt": "2020-03-24T20:10:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzM2ODU1NQ=="}], "type": "inlineReview"}, {"oid": "541fd859fd1b39ad5297b55d22f36fc78776f79f", "url": "https://github.com/yahoo/elide/commit/541fd859fd1b39ad5297b55d22f36fc78776f79f", "message": "address comments", "committedDate": "2020-03-24T20:29:03Z", "type": "commit"}, {"oid": "f9c1d8f8a8bbbfb5459fab3a9754305d497ef4f1", "url": "https://github.com/yahoo/elide/commit/f9c1d8f8a8bbbfb5459fab3a9754305d497ef4f1", "message": "fix codacy", "committedDate": "2020-03-25T18:47:50Z", "type": "commit"}]}