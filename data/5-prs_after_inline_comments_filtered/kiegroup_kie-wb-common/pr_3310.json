{"pr_number": 3310, "pr_title": "KOGITO-1553: [DMN Designer] Open a DMN file with an included model - Included Models tab", "pr_createdAt": "2020-05-20T21:29:27Z", "pr_url": "https://github.com/kiegroup/kie-wb-common/pull/3310", "timeline": [{"oid": "12fd21075a8743079c629eb51ee636d3b5f148b7", "url": "https://github.com/kiegroup/kie-wb-common/commit/12fd21075a8743079c629eb51ee636d3b5f148b7", "message": "KOGITO-1553: [DMN Designer] Open a DMN file with an included model - Included Models tab\nKOGITO-1776: [DMN Designer] Create a \"Load Projects From Client\" button\nKOGITO-1552: [DMN Designer] Open a DMN file with an included model - DRG Elements", "committedDate": "2020-05-21T14:54:55Z", "type": "forcePushed"}, {"oid": "724a7298be7390b832ab2783e5d72a672d9f99d7", "url": "https://github.com/kiegroup/kie-wb-common/commit/724a7298be7390b832ab2783e5d72a672d9f99d7", "message": "Fixes an codestyle error and compatibility with Scesim.", "committedDate": "2020-05-22T19:01:14Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA3MDAyNg==", "url": "https://github.com/kiegroup/kie-wb-common/pull/3310#discussion_r430070026", "bodyText": "Should this block be removed? Considering: #3287.", "author": "karreiro", "createdAt": "2020-05-25T20:42:56Z", "path": "kie-wb-common-dmn/kie-wb-common-dmn-webapp-kogito-common/src/main/java/org/kie/workbench/common/dmn/webapp/kogito/common/client/converters/DMNMarshallerKogitoUnmarshaller.java", "diffHunk": "@@ -559,25 +567,27 @@ private Node getRequiredNode(final Map<String, Entry<JSITDRGElement, Node>> elem\n         final List<JSITDRGElement> importedDRGElements = dmnMarshallerImportsHelper.getImportedDRGElements(importDefinitions);\n \n         // Update IDs with the alias used in this file for the respective imports\n-        final Map<String, String> indexByUri = NameSpaceUtils.extractNamespacesKeyedByUri(dmnXml);\n-        updateIDsWithAlias(indexByUri, importedDRGElements);\n-\n-        return dmnShapes\n-                .stream()\n-                .map(shape -> {\n-                    final String dmnElementRef = getDmnElementRef(shape);\n-                    final Optional<JSITDRGElement> ref = getReference(importedDRGElements, dmnElementRef);\n-                    return ref.orElse(null);\n-                })\n-                .filter(Objects::nonNull)\n-                .collect(toList());\n+        //  final Map<String, String> indexByUri = NameSpaceUtils.extractNamespacesKeyedByUri(dmnXml);", "originalCommit": "385e8dc50ada79a8607d080d801e333cb1a27a4c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA3MDI3NA==", "url": "https://github.com/kiegroup/kie-wb-common/pull/3310#discussion_r430070274", "bodyText": "I believe we can remove the non-used updateIDsWithAlias method as well.", "author": "karreiro", "createdAt": "2020-05-25T20:44:29Z", "path": "kie-wb-common-dmn/kie-wb-common-dmn-webapp-kogito-common/src/main/java/org/kie/workbench/common/dmn/webapp/kogito/common/client/converters/DMNMarshallerKogitoUnmarshaller.java", "diffHunk": "@@ -559,25 +567,27 @@ private Node getRequiredNode(final Map<String, Entry<JSITDRGElement, Node>> elem\n         final List<JSITDRGElement> importedDRGElements = dmnMarshallerImportsHelper.getImportedDRGElements(importDefinitions);\n \n         // Update IDs with the alias used in this file for the respective imports\n-        final Map<String, String> indexByUri = NameSpaceUtils.extractNamespacesKeyedByUri(dmnXml);\n-        updateIDsWithAlias(indexByUri, importedDRGElements);\n-\n-        return dmnShapes\n-                .stream()\n-                .map(shape -> {\n-                    final String dmnElementRef = getDmnElementRef(shape);\n-                    final Optional<JSITDRGElement> ref = getReference(importedDRGElements, dmnElementRef);\n-                    return ref.orElse(null);\n-                })\n-                .filter(Objects::nonNull)\n-                .collect(toList());\n+        //  final Map<String, String> indexByUri = NameSpaceUtils.extractNamespacesKeyedByUri(dmnXml);\n+        // updateIDsWithAlias(indexByUri, importedDRGElements);", "originalCommit": "385e8dc50ada79a8607d080d801e333cb1a27a4c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAyODMyNQ==", "url": "https://github.com/kiegroup/kie-wb-common/pull/3310#discussion_r431028325", "bodyText": "Could we please add javadoc, especially the path, is it relative, absolute?", "author": "jomarko", "createdAt": "2020-05-27T10:50:38Z", "path": "kie-wb-common-dmn/kie-wb-common-dmn-webapp-kogito-common/src/main/java/org/kie/workbench/common/dmn/webapp/kogito/common/client/converters/DMNIncludedNodeFactory.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.workbench.common.dmn.webapp.kogito.common.client.converters;\n+\n+import org.kie.workbench.common.dmn.api.definition.HasVariable;\n+import org.kie.workbench.common.dmn.api.definition.model.DRGElement;\n+import org.kie.workbench.common.dmn.api.definition.model.InformationItemPrimary;\n+import org.kie.workbench.common.dmn.api.definition.model.IsInformationItem;\n+import org.kie.workbench.common.dmn.api.editors.included.DMNIncludedNode;\n+import org.kie.workbench.common.dmn.api.editors.included.IncludedModel;\n+import org.kie.workbench.common.dmn.api.property.dmn.Name;\n+import org.kie.workbench.common.dmn.api.property.dmn.QName;\n+import org.kie.workbench.common.stunner.core.util.FileUtils;\n+\n+import static org.kie.workbench.common.dmn.api.editors.types.BuiltInTypeUtils.isBuiltInType;\n+\n+public class DMNIncludedNodeFactory {\n+\n+    DMNIncludedNode makeDMNIncludeNode(final String path,\n+                                       final IncludedModel includeModel,\n+                                       final DRGElement drgElement) {\n+        return new DMNIncludedNode(FileUtils.getFileName(path), drgElementWithNamespace(drgElement, includeModel));\n+    }", "originalCommit": "385e8dc50ada79a8607d080d801e333cb1a27a4c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYyNjM5NQ==", "url": "https://github.com/kiegroup/kie-wb-common/pull/3310#discussion_r432626395", "bodyText": "It doesn't matter if it is relative or absolute. We just need the filename.", "author": "danielzhe", "createdAt": "2020-05-29T17:15:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAyODMyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAzODc2Mw==", "url": "https://github.com/kiegroup/kie-wb-common/pull/3310#discussion_r431038763", "bodyText": "Do I understand correctly all these methods works asynchronously?\nWhat is the difference between those suffixed \"Async\" and those not suffixed\nWhat is the reason somewhere we return Promise and somewhere we use Callback", "author": "jomarko", "createdAt": "2020-05-27T11:12:02Z", "path": "kie-wb-common-dmn/kie-wb-common-dmn-webapp-kogito-common/src/main/java/org/kie/workbench/common/dmn/webapp/kogito/common/client/converters/DMNMarshallerImportsHelperKogito.java", "diffHunk": "@@ -15,12 +15,33 @@\n  */\n package org.kie.workbench.common.dmn.webapp.kogito.common.client.converters;\n \n+import java.util.List;\n+import java.util.Map;\n+\n+import elemental2.promise.Promise;\n+import org.kie.workbench.common.dmn.api.definition.model.ItemDefinition;\n+import org.kie.workbench.common.dmn.api.editors.included.DMNIncludedModel;\n+import org.kie.workbench.common.dmn.api.editors.included.DMNIncludedNode;\n+import org.kie.workbench.common.dmn.api.editors.included.IncludedModel;\n import org.kie.workbench.common.dmn.api.marshalling.DMNMarshallerImportsHelper;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDRGElement;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDefinitions;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITImport;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITItemDefinition;\n+import org.kie.workbench.common.stunner.core.client.service.ServiceCallback;\n+import org.kie.workbench.common.stunner.core.diagram.Metadata;\n \n public interface DMNMarshallerImportsHelperKogito extends DMNMarshallerImportsHelper<JSITImport, JSITDefinitions, JSITDRGElement, JSITItemDefinition> {\n \n+    Promise<Map<JSITImport, JSITDefinitions>> getImportDefinitionsAsync(final Metadata metadata,\n+                                                                        final List<JSITImport> imports);\n+\n+    void getImportedItemDefinitionsByNamespaceAsync(final String modelName,\n+                                                    final String namespace,\n+                                                    final ServiceCallback<List<ItemDefinition>> callback);\n+\n+    void loadNodesFromModels(final List<DMNIncludedModel> includedModels,\n+                             final ServiceCallback<List<DMNIncludedNode>> callback);\n+\n+    void loadModels(final ServiceCallback<List<IncludedModel>> callback);", "originalCommit": "385e8dc50ada79a8607d080d801e333cb1a27a4c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYzMTA0Mw==", "url": "https://github.com/kiegroup/kie-wb-common/pull/3310#discussion_r432631043", "bodyText": "Yes, they are async. I didn't know exactly how to differentiate one method from other, so I used the same pattern that I see in some C# projects (using \"async\" prefix to differentiate async from sync methods). I don't know if this is the best name here. I'm open to suggestions.\n\n\nThe difference is that the methods without \"async\" run synchronously and are not supported in Kogito, specially VSCode, because VSCode is multithread which lead to some issues that we don't have in singlethread environments like in Business Central. The root of all this is in Content API, that is asynchronous. So the main issue is when loading imported models during unmarshalling: I'm running a thread and I can continue only when the threads that load all the imported models are done. Which bring us to the question about Promise and Callback:\n\n\nWe're using callback when is not required to wait for some thread to finish. But Promise gives us the ability to call some code and continue the main flow only when that called code are finished. In other hand, with callbacks, the main flow doesn't wait for it to be finished.", "author": "danielzhe", "createdAt": "2020-05-29T17:24:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAzODc2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAzOTgzNA==", "url": "https://github.com/kiegroup/kie-wb-common/pull/3310#discussion_r431039834", "bodyText": "Could you please explain combination of @dependent with @ApplicationScoped? For me the second one represnts singlotene per app while the first multiple instances available per app. I am not sure how we can combine them.", "author": "jomarko", "createdAt": "2020-05-27T11:14:22Z", "path": "kie-wb-common-dmn/kie-wb-common-dmn-webapp-kogito-common/src/main/java/org/kie/workbench/common/dmn/webapp/kogito/common/client/converters/DMNMarshallerImportsHelperKogitoImpl.java", "diffHunk": "@@ -16,29 +16,253 @@\n package org.kie.workbench.common.dmn.webapp.kogito.common.client.converters;\n \n import java.io.InputStream;\n+import java.util.ArrayList;\n import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.Objects;\n import java.util.Optional;\n+import java.util.Vector;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n \n import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.context.Dependent;\n+import javax.inject.Inject;\n+import javax.xml.namespace.QName;\n \n+import elemental2.promise.IThenable;\n+import elemental2.promise.Promise;\n+import jsinterop.base.Js;\n import org.guvnor.common.services.project.model.WorkspaceProject;\n+import org.kie.workbench.common.dmn.api.definition.model.ItemDefinition;\n+import org.kie.workbench.common.dmn.api.editors.included.DMNImportTypes;\n+import org.kie.workbench.common.dmn.api.editors.included.DMNIncludedModel;\n+import org.kie.workbench.common.dmn.api.editors.included.DMNIncludedNode;\n+import org.kie.workbench.common.dmn.api.editors.included.IncludedModel;\n import org.kie.workbench.common.dmn.api.editors.included.PMMLDocumentMetadata;\n+import org.kie.workbench.common.dmn.api.graph.DMNDiagramUtils;\n+import org.kie.workbench.common.dmn.webapp.kogito.common.client.converters.model.ImportedItemDefinitionPropertyConverter;\n+import org.kie.workbench.common.dmn.webapp.kogito.common.client.services.DMNClientDiagramServiceImpl;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDMNElement;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDRGElement;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDecision;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDefinitions;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITImport;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITInformationItem;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITInputData;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITInvocable;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITItemDefinition;\n+import org.kie.workbench.common.kogito.webapp.base.client.workarounds.KogitoResourceContentService;\n+import org.kie.workbench.common.stunner.core.client.service.ClientRuntimeError;\n+import org.kie.workbench.common.stunner.core.client.service.ServiceCallback;\n+import org.kie.workbench.common.stunner.core.diagram.Diagram;\n import org.kie.workbench.common.stunner.core.diagram.Metadata;\n+import org.kie.workbench.common.stunner.core.graph.Graph;\n+import org.kie.workbench.common.stunner.core.util.FileUtils;\n+import org.kie.workbench.common.stunner.core.util.StringUtils;\n import org.uberfire.backend.vfs.Path;\n+import org.uberfire.client.promise.Promises;\n+\n+import static org.kie.workbench.common.dmn.api.editors.types.BuiltInTypeUtils.isBuiltInType;\n+import static org.kie.workbench.common.dmn.webapp.kogito.common.client.converters.model.ImportedItemDefinitionPropertyConverter.withNamespace;\n \n @ApplicationScoped\n+@Dependent", "originalCommit": "385e8dc50ada79a8607d080d801e333cb1a27a4c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTA0Nzg0Mg==", "url": "https://github.com/kiegroup/kie-wb-common/pull/3310#discussion_r431047842", "bodyText": "Shouldn't we say the array size as we know it?\nreturn promises\n                    .all(fileLoadPromises.toArray(new Promise[fileLoadPromises.size()]))\n                    .then(v -> promises.resolve(otherDefinitions));", "author": "jomarko", "createdAt": "2020-05-27T11:30:23Z", "path": "kie-wb-common-dmn/kie-wb-common-dmn-webapp-kogito-common/src/main/java/org/kie/workbench/common/dmn/webapp/kogito/common/client/converters/DMNMarshallerImportsHelperKogitoImpl.java", "diffHunk": "@@ -16,29 +16,253 @@\n package org.kie.workbench.common.dmn.webapp.kogito.common.client.converters;\n \n import java.io.InputStream;\n+import java.util.ArrayList;\n import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.Objects;\n import java.util.Optional;\n+import java.util.Vector;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n \n import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.context.Dependent;\n+import javax.inject.Inject;\n+import javax.xml.namespace.QName;\n \n+import elemental2.promise.IThenable;\n+import elemental2.promise.Promise;\n+import jsinterop.base.Js;\n import org.guvnor.common.services.project.model.WorkspaceProject;\n+import org.kie.workbench.common.dmn.api.definition.model.ItemDefinition;\n+import org.kie.workbench.common.dmn.api.editors.included.DMNImportTypes;\n+import org.kie.workbench.common.dmn.api.editors.included.DMNIncludedModel;\n+import org.kie.workbench.common.dmn.api.editors.included.DMNIncludedNode;\n+import org.kie.workbench.common.dmn.api.editors.included.IncludedModel;\n import org.kie.workbench.common.dmn.api.editors.included.PMMLDocumentMetadata;\n+import org.kie.workbench.common.dmn.api.graph.DMNDiagramUtils;\n+import org.kie.workbench.common.dmn.webapp.kogito.common.client.converters.model.ImportedItemDefinitionPropertyConverter;\n+import org.kie.workbench.common.dmn.webapp.kogito.common.client.services.DMNClientDiagramServiceImpl;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDMNElement;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDRGElement;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDecision;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDefinitions;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITImport;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITInformationItem;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITInputData;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITInvocable;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITItemDefinition;\n+import org.kie.workbench.common.kogito.webapp.base.client.workarounds.KogitoResourceContentService;\n+import org.kie.workbench.common.stunner.core.client.service.ClientRuntimeError;\n+import org.kie.workbench.common.stunner.core.client.service.ServiceCallback;\n+import org.kie.workbench.common.stunner.core.diagram.Diagram;\n import org.kie.workbench.common.stunner.core.diagram.Metadata;\n+import org.kie.workbench.common.stunner.core.graph.Graph;\n+import org.kie.workbench.common.stunner.core.util.FileUtils;\n+import org.kie.workbench.common.stunner.core.util.StringUtils;\n import org.uberfire.backend.vfs.Path;\n+import org.uberfire.client.promise.Promises;\n+\n+import static org.kie.workbench.common.dmn.api.editors.types.BuiltInTypeUtils.isBuiltInType;\n+import static org.kie.workbench.common.dmn.webapp.kogito.common.client.converters.model.ImportedItemDefinitionPropertyConverter.withNamespace;\n \n @ApplicationScoped\n+@Dependent\n public class DMNMarshallerImportsHelperKogitoImpl implements DMNMarshallerImportsHelperKogito {\n \n+    private final KogitoResourceContentService contentService;\n+    private final DMNClientDiagramServiceImpl diagramService;\n+    private final Promises promises;\n+    private final DMNDiagramUtils diagramUtils;\n+    private final DMNIncludedNodeFactory includedModelFactory;\n+\n+    private static final Logger LOGGER = Logger.getLogger(DMNMarshallerImportsHelperKogitoImpl.class.getName());\n+    private static final String DMN_FILES_PATTERN = \"**/*.dmn\";\n+\n+    @Inject\n+    public DMNMarshallerImportsHelperKogitoImpl(final KogitoResourceContentService contentService,\n+                                                final DMNClientDiagramServiceImpl diagramService,\n+                                                final Promises promises,\n+                                                final DMNDiagramUtils diagramUtils,\n+                                                final DMNIncludedNodeFactory includedModelFactory) {\n+        this.contentService = contentService;\n+        this.diagramService = diagramService;\n+        this.promises = promises;\n+        this.diagramUtils = diagramUtils;\n+        this.includedModelFactory = includedModelFactory;\n+    }\n+\n+    @Override\n+    public Promise<Map<JSITImport, JSITDefinitions>> getImportDefinitionsAsync(final Metadata metadata,\n+                                                                               final List<JSITImport> imports) {\n+        if (!imports.isEmpty()) {\n+            return loadDMNDefinitions().then(otherDefinitions -> {\n+                final Map<JSITImport, JSITDefinitions> importDefinitions = new HashMap<>();\n+                for (int i = 0; i < otherDefinitions.size(); i++) {\n+                    final JSITDefinitions def = Js.uncheckedCast(otherDefinitions.get(i));\n+                    findImportByDefinitions(def, imports).ifPresent(anImport -> {\n+                        final JSITImport foundImported = Js.uncheckedCast(anImport);\n+                        importDefinitions.put(foundImported, def);\n+                    });\n+                }\n+                return promises.resolve(importDefinitions);\n+            });\n+        }\n+        return promises.resolve(new HashMap<>());\n+    }\n+\n+    Promise<List<JSITDefinitions>> loadDMNDefinitions() {\n+        final List<JSITDefinitions> otherDefinitions = new Vector<>();\n+        return contentService.getFilteredItems(DMN_FILES_PATTERN).then(list -> {\n+            final List<Promise<JSITDefinitions>> fileLoadPromises = new ArrayList<>();\n+            for (final String file : list) {\n+                final Promise<JSITDefinitions> promise = loadDefinitionFromFile(file, otherDefinitions);\n+                fileLoadPromises.add(promise);\n+            }\n+            return promises.all(fileLoadPromises.toArray(new Promise[]{})).then(v -> promises.resolve(otherDefinitions));", "originalCommit": "385e8dc50ada79a8607d080d801e333cb1a27a4c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTA1MjQ5OQ==", "url": "https://github.com/kiegroup/kie-wb-common/pull/3310#discussion_r431052499", "bodyText": "Here we can use .orElse(Collections.emptyList()) as we are not manipulating with nodes afterwards.", "author": "jomarko", "createdAt": "2020-05-27T11:40:30Z", "path": "kie-wb-common-dmn/kie-wb-common-dmn-webapp-kogito-common/src/main/java/org/kie/workbench/common/dmn/webapp/kogito/common/client/converters/DMNMarshallerImportsHelperKogitoImpl.java", "diffHunk": "@@ -16,29 +16,253 @@\n package org.kie.workbench.common.dmn.webapp.kogito.common.client.converters;\n \n import java.io.InputStream;\n+import java.util.ArrayList;\n import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.Objects;\n import java.util.Optional;\n+import java.util.Vector;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n \n import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.context.Dependent;\n+import javax.inject.Inject;\n+import javax.xml.namespace.QName;\n \n+import elemental2.promise.IThenable;\n+import elemental2.promise.Promise;\n+import jsinterop.base.Js;\n import org.guvnor.common.services.project.model.WorkspaceProject;\n+import org.kie.workbench.common.dmn.api.definition.model.ItemDefinition;\n+import org.kie.workbench.common.dmn.api.editors.included.DMNImportTypes;\n+import org.kie.workbench.common.dmn.api.editors.included.DMNIncludedModel;\n+import org.kie.workbench.common.dmn.api.editors.included.DMNIncludedNode;\n+import org.kie.workbench.common.dmn.api.editors.included.IncludedModel;\n import org.kie.workbench.common.dmn.api.editors.included.PMMLDocumentMetadata;\n+import org.kie.workbench.common.dmn.api.graph.DMNDiagramUtils;\n+import org.kie.workbench.common.dmn.webapp.kogito.common.client.converters.model.ImportedItemDefinitionPropertyConverter;\n+import org.kie.workbench.common.dmn.webapp.kogito.common.client.services.DMNClientDiagramServiceImpl;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDMNElement;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDRGElement;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDecision;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDefinitions;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITImport;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITInformationItem;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITInputData;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITInvocable;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITItemDefinition;\n+import org.kie.workbench.common.kogito.webapp.base.client.workarounds.KogitoResourceContentService;\n+import org.kie.workbench.common.stunner.core.client.service.ClientRuntimeError;\n+import org.kie.workbench.common.stunner.core.client.service.ServiceCallback;\n+import org.kie.workbench.common.stunner.core.diagram.Diagram;\n import org.kie.workbench.common.stunner.core.diagram.Metadata;\n+import org.kie.workbench.common.stunner.core.graph.Graph;\n+import org.kie.workbench.common.stunner.core.util.FileUtils;\n+import org.kie.workbench.common.stunner.core.util.StringUtils;\n import org.uberfire.backend.vfs.Path;\n+import org.uberfire.client.promise.Promises;\n+\n+import static org.kie.workbench.common.dmn.api.editors.types.BuiltInTypeUtils.isBuiltInType;\n+import static org.kie.workbench.common.dmn.webapp.kogito.common.client.converters.model.ImportedItemDefinitionPropertyConverter.withNamespace;\n \n @ApplicationScoped\n+@Dependent\n public class DMNMarshallerImportsHelperKogitoImpl implements DMNMarshallerImportsHelperKogito {\n \n+    private final KogitoResourceContentService contentService;\n+    private final DMNClientDiagramServiceImpl diagramService;\n+    private final Promises promises;\n+    private final DMNDiagramUtils diagramUtils;\n+    private final DMNIncludedNodeFactory includedModelFactory;\n+\n+    private static final Logger LOGGER = Logger.getLogger(DMNMarshallerImportsHelperKogitoImpl.class.getName());\n+    private static final String DMN_FILES_PATTERN = \"**/*.dmn\";\n+\n+    @Inject\n+    public DMNMarshallerImportsHelperKogitoImpl(final KogitoResourceContentService contentService,\n+                                                final DMNClientDiagramServiceImpl diagramService,\n+                                                final Promises promises,\n+                                                final DMNDiagramUtils diagramUtils,\n+                                                final DMNIncludedNodeFactory includedModelFactory) {\n+        this.contentService = contentService;\n+        this.diagramService = diagramService;\n+        this.promises = promises;\n+        this.diagramUtils = diagramUtils;\n+        this.includedModelFactory = includedModelFactory;\n+    }\n+\n+    @Override\n+    public Promise<Map<JSITImport, JSITDefinitions>> getImportDefinitionsAsync(final Metadata metadata,\n+                                                                               final List<JSITImport> imports) {\n+        if (!imports.isEmpty()) {\n+            return loadDMNDefinitions().then(otherDefinitions -> {\n+                final Map<JSITImport, JSITDefinitions> importDefinitions = new HashMap<>();\n+                for (int i = 0; i < otherDefinitions.size(); i++) {\n+                    final JSITDefinitions def = Js.uncheckedCast(otherDefinitions.get(i));\n+                    findImportByDefinitions(def, imports).ifPresent(anImport -> {\n+                        final JSITImport foundImported = Js.uncheckedCast(anImport);\n+                        importDefinitions.put(foundImported, def);\n+                    });\n+                }\n+                return promises.resolve(importDefinitions);\n+            });\n+        }\n+        return promises.resolve(new HashMap<>());\n+    }\n+\n+    Promise<List<JSITDefinitions>> loadDMNDefinitions() {\n+        final List<JSITDefinitions> otherDefinitions = new Vector<>();\n+        return contentService.getFilteredItems(DMN_FILES_PATTERN).then(list -> {\n+            final List<Promise<JSITDefinitions>> fileLoadPromises = new ArrayList<>();\n+            for (final String file : list) {\n+                final Promise<JSITDefinitions> promise = loadDefinitionFromFile(file, otherDefinitions);\n+                fileLoadPromises.add(promise);\n+            }\n+            return promises.all(fileLoadPromises.toArray(new Promise[]{})).then(v -> promises.resolve(otherDefinitions));\n+        });\n+    }\n+\n+    @Override\n+    public void loadNodesFromModels(final List<DMNIncludedModel> includedModels,\n+                                    final ServiceCallback<List<DMNIncludedNode>> callback) {\n+\n+        final List<DMNIncludedNode> result = new Vector<>();\n+        final List<Promise> fileLoadPromises = new ArrayList<>();\n+        for (final DMNIncludedModel model : includedModels) {\n+            final String path = model.getPath();\n+            final Promise promise = contentService.loadFile(path).then(content -> {\n+                                                                           diagramService.transform(content, new ServiceCallback<Diagram>() {\n+                                                                               @Override\n+                                                                               public void onSuccess(final Diagram item) {\n+                                                                                   final Optional<DMNIncludedModel> diagramImport = getDiagramImport(item, includedModels);\n+                                                                                   final List<DMNIncludedNode> nodes = diagramImport\n+                                                                                           .map(dmn -> diagramUtils\n+                                                                                                   .getDRGElements(item)\n+                                                                                                   .stream()\n+                                                                                                   .map(node -> includedModelFactory.makeDMNIncludeNode(path, dmn, node))\n+                                                                                                   .collect(Collectors.toList()))\n+                                                                                           .orElse(new ArrayList<>());", "originalCommit": "385e8dc50ada79a8607d080d801e333cb1a27a4c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTA1MjkwNg==", "url": "https://github.com/kiegroup/kie-wb-common/pull/3310#discussion_r431052906", "bodyText": "Similar question as above . shouldn't we leverage known size of fileLoadPromises during new array creation?", "author": "jomarko", "createdAt": "2020-05-27T11:41:23Z", "path": "kie-wb-common-dmn/kie-wb-common-dmn-webapp-kogito-common/src/main/java/org/kie/workbench/common/dmn/webapp/kogito/common/client/converters/DMNMarshallerImportsHelperKogitoImpl.java", "diffHunk": "@@ -16,29 +16,253 @@\n package org.kie.workbench.common.dmn.webapp.kogito.common.client.converters;\n \n import java.io.InputStream;\n+import java.util.ArrayList;\n import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.Objects;\n import java.util.Optional;\n+import java.util.Vector;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n \n import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.context.Dependent;\n+import javax.inject.Inject;\n+import javax.xml.namespace.QName;\n \n+import elemental2.promise.IThenable;\n+import elemental2.promise.Promise;\n+import jsinterop.base.Js;\n import org.guvnor.common.services.project.model.WorkspaceProject;\n+import org.kie.workbench.common.dmn.api.definition.model.ItemDefinition;\n+import org.kie.workbench.common.dmn.api.editors.included.DMNImportTypes;\n+import org.kie.workbench.common.dmn.api.editors.included.DMNIncludedModel;\n+import org.kie.workbench.common.dmn.api.editors.included.DMNIncludedNode;\n+import org.kie.workbench.common.dmn.api.editors.included.IncludedModel;\n import org.kie.workbench.common.dmn.api.editors.included.PMMLDocumentMetadata;\n+import org.kie.workbench.common.dmn.api.graph.DMNDiagramUtils;\n+import org.kie.workbench.common.dmn.webapp.kogito.common.client.converters.model.ImportedItemDefinitionPropertyConverter;\n+import org.kie.workbench.common.dmn.webapp.kogito.common.client.services.DMNClientDiagramServiceImpl;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDMNElement;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDRGElement;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDecision;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDefinitions;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITImport;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITInformationItem;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITInputData;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITInvocable;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITItemDefinition;\n+import org.kie.workbench.common.kogito.webapp.base.client.workarounds.KogitoResourceContentService;\n+import org.kie.workbench.common.stunner.core.client.service.ClientRuntimeError;\n+import org.kie.workbench.common.stunner.core.client.service.ServiceCallback;\n+import org.kie.workbench.common.stunner.core.diagram.Diagram;\n import org.kie.workbench.common.stunner.core.diagram.Metadata;\n+import org.kie.workbench.common.stunner.core.graph.Graph;\n+import org.kie.workbench.common.stunner.core.util.FileUtils;\n+import org.kie.workbench.common.stunner.core.util.StringUtils;\n import org.uberfire.backend.vfs.Path;\n+import org.uberfire.client.promise.Promises;\n+\n+import static org.kie.workbench.common.dmn.api.editors.types.BuiltInTypeUtils.isBuiltInType;\n+import static org.kie.workbench.common.dmn.webapp.kogito.common.client.converters.model.ImportedItemDefinitionPropertyConverter.withNamespace;\n \n @ApplicationScoped\n+@Dependent\n public class DMNMarshallerImportsHelperKogitoImpl implements DMNMarshallerImportsHelperKogito {\n \n+    private final KogitoResourceContentService contentService;\n+    private final DMNClientDiagramServiceImpl diagramService;\n+    private final Promises promises;\n+    private final DMNDiagramUtils diagramUtils;\n+    private final DMNIncludedNodeFactory includedModelFactory;\n+\n+    private static final Logger LOGGER = Logger.getLogger(DMNMarshallerImportsHelperKogitoImpl.class.getName());\n+    private static final String DMN_FILES_PATTERN = \"**/*.dmn\";\n+\n+    @Inject\n+    public DMNMarshallerImportsHelperKogitoImpl(final KogitoResourceContentService contentService,\n+                                                final DMNClientDiagramServiceImpl diagramService,\n+                                                final Promises promises,\n+                                                final DMNDiagramUtils diagramUtils,\n+                                                final DMNIncludedNodeFactory includedModelFactory) {\n+        this.contentService = contentService;\n+        this.diagramService = diagramService;\n+        this.promises = promises;\n+        this.diagramUtils = diagramUtils;\n+        this.includedModelFactory = includedModelFactory;\n+    }\n+\n+    @Override\n+    public Promise<Map<JSITImport, JSITDefinitions>> getImportDefinitionsAsync(final Metadata metadata,\n+                                                                               final List<JSITImport> imports) {\n+        if (!imports.isEmpty()) {\n+            return loadDMNDefinitions().then(otherDefinitions -> {\n+                final Map<JSITImport, JSITDefinitions> importDefinitions = new HashMap<>();\n+                for (int i = 0; i < otherDefinitions.size(); i++) {\n+                    final JSITDefinitions def = Js.uncheckedCast(otherDefinitions.get(i));\n+                    findImportByDefinitions(def, imports).ifPresent(anImport -> {\n+                        final JSITImport foundImported = Js.uncheckedCast(anImport);\n+                        importDefinitions.put(foundImported, def);\n+                    });\n+                }\n+                return promises.resolve(importDefinitions);\n+            });\n+        }\n+        return promises.resolve(new HashMap<>());\n+    }\n+\n+    Promise<List<JSITDefinitions>> loadDMNDefinitions() {\n+        final List<JSITDefinitions> otherDefinitions = new Vector<>();\n+        return contentService.getFilteredItems(DMN_FILES_PATTERN).then(list -> {\n+            final List<Promise<JSITDefinitions>> fileLoadPromises = new ArrayList<>();\n+            for (final String file : list) {\n+                final Promise<JSITDefinitions> promise = loadDefinitionFromFile(file, otherDefinitions);\n+                fileLoadPromises.add(promise);\n+            }\n+            return promises.all(fileLoadPromises.toArray(new Promise[]{})).then(v -> promises.resolve(otherDefinitions));\n+        });\n+    }\n+\n+    @Override\n+    public void loadNodesFromModels(final List<DMNIncludedModel> includedModels,\n+                                    final ServiceCallback<List<DMNIncludedNode>> callback) {\n+\n+        final List<DMNIncludedNode> result = new Vector<>();\n+        final List<Promise> fileLoadPromises = new ArrayList<>();\n+        for (final DMNIncludedModel model : includedModels) {\n+            final String path = model.getPath();\n+            final Promise promise = contentService.loadFile(path).then(content -> {\n+                                                                           diagramService.transform(content, new ServiceCallback<Diagram>() {\n+                                                                               @Override\n+                                                                               public void onSuccess(final Diagram item) {\n+                                                                                   final Optional<DMNIncludedModel> diagramImport = getDiagramImport(item, includedModels);\n+                                                                                   final List<DMNIncludedNode> nodes = diagramImport\n+                                                                                           .map(dmn -> diagramUtils\n+                                                                                                   .getDRGElements(item)\n+                                                                                                   .stream()\n+                                                                                                   .map(node -> includedModelFactory.makeDMNIncludeNode(path, dmn, node))\n+                                                                                                   .collect(Collectors.toList()))\n+                                                                                           .orElse(new ArrayList<>());\n+\n+                                                                                   result.addAll(nodes);\n+                                                                               }\n+\n+                                                                               @Override\n+                                                                               public void onError(final ClientRuntimeError error) {\n+                                                                                   LOGGER.log(Level.SEVERE, error.getMessage());\n+                                                                               }\n+                                                                           });\n+                                                                           return promises.resolve();\n+                                                                       }\n+            );\n+            fileLoadPromises.add(promise);\n+        }\n+\n+        promises.all(fileLoadPromises.toArray(new Promise[]{})).then(p -> {", "originalCommit": "385e8dc50ada79a8607d080d801e333cb1a27a4c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTA1MzczOQ==", "url": "https://github.com/kiegroup/kie-wb-common/pull/3310#discussion_r431053739", "bodyText": "Could we mentions this aslo in javadoc of the added public API?", "author": "jomarko", "createdAt": "2020-05-27T11:42:58Z", "path": "kie-wb-common-dmn/kie-wb-common-dmn-webapp-kogito-common/src/main/java/org/kie/workbench/common/dmn/webapp/kogito/common/client/converters/DMNMarshallerImportsHelperKogitoImpl.java", "diffHunk": "@@ -16,29 +16,253 @@\n package org.kie.workbench.common.dmn.webapp.kogito.common.client.converters;\n \n import java.io.InputStream;\n+import java.util.ArrayList;\n import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.Objects;\n import java.util.Optional;\n+import java.util.Vector;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n \n import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.context.Dependent;\n+import javax.inject.Inject;\n+import javax.xml.namespace.QName;\n \n+import elemental2.promise.IThenable;\n+import elemental2.promise.Promise;\n+import jsinterop.base.Js;\n import org.guvnor.common.services.project.model.WorkspaceProject;\n+import org.kie.workbench.common.dmn.api.definition.model.ItemDefinition;\n+import org.kie.workbench.common.dmn.api.editors.included.DMNImportTypes;\n+import org.kie.workbench.common.dmn.api.editors.included.DMNIncludedModel;\n+import org.kie.workbench.common.dmn.api.editors.included.DMNIncludedNode;\n+import org.kie.workbench.common.dmn.api.editors.included.IncludedModel;\n import org.kie.workbench.common.dmn.api.editors.included.PMMLDocumentMetadata;\n+import org.kie.workbench.common.dmn.api.graph.DMNDiagramUtils;\n+import org.kie.workbench.common.dmn.webapp.kogito.common.client.converters.model.ImportedItemDefinitionPropertyConverter;\n+import org.kie.workbench.common.dmn.webapp.kogito.common.client.services.DMNClientDiagramServiceImpl;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDMNElement;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDRGElement;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDecision;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDefinitions;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITImport;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITInformationItem;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITInputData;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITInvocable;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITItemDefinition;\n+import org.kie.workbench.common.kogito.webapp.base.client.workarounds.KogitoResourceContentService;\n+import org.kie.workbench.common.stunner.core.client.service.ClientRuntimeError;\n+import org.kie.workbench.common.stunner.core.client.service.ServiceCallback;\n+import org.kie.workbench.common.stunner.core.diagram.Diagram;\n import org.kie.workbench.common.stunner.core.diagram.Metadata;\n+import org.kie.workbench.common.stunner.core.graph.Graph;\n+import org.kie.workbench.common.stunner.core.util.FileUtils;\n+import org.kie.workbench.common.stunner.core.util.StringUtils;\n import org.uberfire.backend.vfs.Path;\n+import org.uberfire.client.promise.Promises;\n+\n+import static org.kie.workbench.common.dmn.api.editors.types.BuiltInTypeUtils.isBuiltInType;\n+import static org.kie.workbench.common.dmn.webapp.kogito.common.client.converters.model.ImportedItemDefinitionPropertyConverter.withNamespace;\n \n @ApplicationScoped\n+@Dependent\n public class DMNMarshallerImportsHelperKogitoImpl implements DMNMarshallerImportsHelperKogito {\n \n+    private final KogitoResourceContentService contentService;\n+    private final DMNClientDiagramServiceImpl diagramService;\n+    private final Promises promises;\n+    private final DMNDiagramUtils diagramUtils;\n+    private final DMNIncludedNodeFactory includedModelFactory;\n+\n+    private static final Logger LOGGER = Logger.getLogger(DMNMarshallerImportsHelperKogitoImpl.class.getName());\n+    private static final String DMN_FILES_PATTERN = \"**/*.dmn\";\n+\n+    @Inject\n+    public DMNMarshallerImportsHelperKogitoImpl(final KogitoResourceContentService contentService,\n+                                                final DMNClientDiagramServiceImpl diagramService,\n+                                                final Promises promises,\n+                                                final DMNDiagramUtils diagramUtils,\n+                                                final DMNIncludedNodeFactory includedModelFactory) {\n+        this.contentService = contentService;\n+        this.diagramService = diagramService;\n+        this.promises = promises;\n+        this.diagramUtils = diagramUtils;\n+        this.includedModelFactory = includedModelFactory;\n+    }\n+\n+    @Override\n+    public Promise<Map<JSITImport, JSITDefinitions>> getImportDefinitionsAsync(final Metadata metadata,\n+                                                                               final List<JSITImport> imports) {\n+        if (!imports.isEmpty()) {\n+            return loadDMNDefinitions().then(otherDefinitions -> {\n+                final Map<JSITImport, JSITDefinitions> importDefinitions = new HashMap<>();\n+                for (int i = 0; i < otherDefinitions.size(); i++) {\n+                    final JSITDefinitions def = Js.uncheckedCast(otherDefinitions.get(i));\n+                    findImportByDefinitions(def, imports).ifPresent(anImport -> {\n+                        final JSITImport foundImported = Js.uncheckedCast(anImport);\n+                        importDefinitions.put(foundImported, def);\n+                    });\n+                }\n+                return promises.resolve(importDefinitions);\n+            });\n+        }\n+        return promises.resolve(new HashMap<>());\n+    }\n+\n+    Promise<List<JSITDefinitions>> loadDMNDefinitions() {\n+        final List<JSITDefinitions> otherDefinitions = new Vector<>();\n+        return contentService.getFilteredItems(DMN_FILES_PATTERN).then(list -> {\n+            final List<Promise<JSITDefinitions>> fileLoadPromises = new ArrayList<>();\n+            for (final String file : list) {\n+                final Promise<JSITDefinitions> promise = loadDefinitionFromFile(file, otherDefinitions);\n+                fileLoadPromises.add(promise);\n+            }\n+            return promises.all(fileLoadPromises.toArray(new Promise[]{})).then(v -> promises.resolve(otherDefinitions));\n+        });\n+    }\n+\n+    @Override\n+    public void loadNodesFromModels(final List<DMNIncludedModel> includedModels,\n+                                    final ServiceCallback<List<DMNIncludedNode>> callback) {\n+\n+        final List<DMNIncludedNode> result = new Vector<>();\n+        final List<Promise> fileLoadPromises = new ArrayList<>();\n+        for (final DMNIncludedModel model : includedModels) {\n+            final String path = model.getPath();\n+            final Promise promise = contentService.loadFile(path).then(content -> {\n+                                                                           diagramService.transform(content, new ServiceCallback<Diagram>() {\n+                                                                               @Override\n+                                                                               public void onSuccess(final Diagram item) {\n+                                                                                   final Optional<DMNIncludedModel> diagramImport = getDiagramImport(item, includedModels);\n+                                                                                   final List<DMNIncludedNode> nodes = diagramImport\n+                                                                                           .map(dmn -> diagramUtils\n+                                                                                                   .getDRGElements(item)\n+                                                                                                   .stream()\n+                                                                                                   .map(node -> includedModelFactory.makeDMNIncludeNode(path, dmn, node))\n+                                                                                                   .collect(Collectors.toList()))\n+                                                                                           .orElse(new ArrayList<>());\n+\n+                                                                                   result.addAll(nodes);\n+                                                                               }\n+\n+                                                                               @Override\n+                                                                               public void onError(final ClientRuntimeError error) {\n+                                                                                   LOGGER.log(Level.SEVERE, error.getMessage());\n+                                                                               }\n+                                                                           });\n+                                                                           return promises.resolve();\n+                                                                       }\n+            );\n+            fileLoadPromises.add(promise);\n+        }\n+\n+        promises.all(fileLoadPromises.toArray(new Promise[]{})).then(p -> {\n+            callback.onSuccess(result);\n+            return promises.resolve();\n+        });\n+    }\n+\n+    @Override\n+    public void loadModels(final ServiceCallback<List<IncludedModel>> callback) {\n+\n+        final List<IncludedModel> models = new Vector<>();\n+        contentService.getFilteredItems(DMN_FILES_PATTERN).then(items -> {\n+            final List<Promise> fileLoadPromises = new ArrayList<>();\n+\n+            for (final String file : items) {\n+                final Promise<Object> fileLoad = contentService.loadFile(file).then(fileContent -> {\n+                    diagramService.transform(fileContent, new ServiceCallback<Diagram>() {\n+                        @Override\n+                        public void onSuccess(final Diagram item) {\n+                            final String modelPackage = \"\";\n+                            final Diagram<Graph, Metadata> diagram = (Diagram<Graph, Metadata>) item;\n+                            final String namespace = diagramUtils.getNamespace(diagram);\n+                            final String importType = DMNImportTypes.DMN.getDefaultNamespace();\n+                            final int drgElementCount = diagramUtils.getDRGElements(diagram).size();\n+                            final int itemDefinitionCount = diagramUtils.getDefinitions(diagram).getItemDefinition().size();\n+                            // We get files only from the same folder, so doesn't need relative or full path.", "originalCommit": "385e8dc50ada79a8607d080d801e333cb1a27a4c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTA1NDc4MQ==", "url": "https://github.com/kiegroup/kie-wb-common/pull/3310#discussion_r431054781", "bodyText": "Array instantiation question as above.", "author": "jomarko", "createdAt": "2020-05-27T11:45:02Z", "path": "kie-wb-common-dmn/kie-wb-common-dmn-webapp-kogito-common/src/main/java/org/kie/workbench/common/dmn/webapp/kogito/common/client/converters/DMNMarshallerImportsHelperKogitoImpl.java", "diffHunk": "@@ -16,29 +16,253 @@\n package org.kie.workbench.common.dmn.webapp.kogito.common.client.converters;\n \n import java.io.InputStream;\n+import java.util.ArrayList;\n import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.Objects;\n import java.util.Optional;\n+import java.util.Vector;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n \n import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.context.Dependent;\n+import javax.inject.Inject;\n+import javax.xml.namespace.QName;\n \n+import elemental2.promise.IThenable;\n+import elemental2.promise.Promise;\n+import jsinterop.base.Js;\n import org.guvnor.common.services.project.model.WorkspaceProject;\n+import org.kie.workbench.common.dmn.api.definition.model.ItemDefinition;\n+import org.kie.workbench.common.dmn.api.editors.included.DMNImportTypes;\n+import org.kie.workbench.common.dmn.api.editors.included.DMNIncludedModel;\n+import org.kie.workbench.common.dmn.api.editors.included.DMNIncludedNode;\n+import org.kie.workbench.common.dmn.api.editors.included.IncludedModel;\n import org.kie.workbench.common.dmn.api.editors.included.PMMLDocumentMetadata;\n+import org.kie.workbench.common.dmn.api.graph.DMNDiagramUtils;\n+import org.kie.workbench.common.dmn.webapp.kogito.common.client.converters.model.ImportedItemDefinitionPropertyConverter;\n+import org.kie.workbench.common.dmn.webapp.kogito.common.client.services.DMNClientDiagramServiceImpl;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDMNElement;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDRGElement;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDecision;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDefinitions;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITImport;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITInformationItem;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITInputData;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITInvocable;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITItemDefinition;\n+import org.kie.workbench.common.kogito.webapp.base.client.workarounds.KogitoResourceContentService;\n+import org.kie.workbench.common.stunner.core.client.service.ClientRuntimeError;\n+import org.kie.workbench.common.stunner.core.client.service.ServiceCallback;\n+import org.kie.workbench.common.stunner.core.diagram.Diagram;\n import org.kie.workbench.common.stunner.core.diagram.Metadata;\n+import org.kie.workbench.common.stunner.core.graph.Graph;\n+import org.kie.workbench.common.stunner.core.util.FileUtils;\n+import org.kie.workbench.common.stunner.core.util.StringUtils;\n import org.uberfire.backend.vfs.Path;\n+import org.uberfire.client.promise.Promises;\n+\n+import static org.kie.workbench.common.dmn.api.editors.types.BuiltInTypeUtils.isBuiltInType;\n+import static org.kie.workbench.common.dmn.webapp.kogito.common.client.converters.model.ImportedItemDefinitionPropertyConverter.withNamespace;\n \n @ApplicationScoped\n+@Dependent\n public class DMNMarshallerImportsHelperKogitoImpl implements DMNMarshallerImportsHelperKogito {\n \n+    private final KogitoResourceContentService contentService;\n+    private final DMNClientDiagramServiceImpl diagramService;\n+    private final Promises promises;\n+    private final DMNDiagramUtils diagramUtils;\n+    private final DMNIncludedNodeFactory includedModelFactory;\n+\n+    private static final Logger LOGGER = Logger.getLogger(DMNMarshallerImportsHelperKogitoImpl.class.getName());\n+    private static final String DMN_FILES_PATTERN = \"**/*.dmn\";\n+\n+    @Inject\n+    public DMNMarshallerImportsHelperKogitoImpl(final KogitoResourceContentService contentService,\n+                                                final DMNClientDiagramServiceImpl diagramService,\n+                                                final Promises promises,\n+                                                final DMNDiagramUtils diagramUtils,\n+                                                final DMNIncludedNodeFactory includedModelFactory) {\n+        this.contentService = contentService;\n+        this.diagramService = diagramService;\n+        this.promises = promises;\n+        this.diagramUtils = diagramUtils;\n+        this.includedModelFactory = includedModelFactory;\n+    }\n+\n+    @Override\n+    public Promise<Map<JSITImport, JSITDefinitions>> getImportDefinitionsAsync(final Metadata metadata,\n+                                                                               final List<JSITImport> imports) {\n+        if (!imports.isEmpty()) {\n+            return loadDMNDefinitions().then(otherDefinitions -> {\n+                final Map<JSITImport, JSITDefinitions> importDefinitions = new HashMap<>();\n+                for (int i = 0; i < otherDefinitions.size(); i++) {\n+                    final JSITDefinitions def = Js.uncheckedCast(otherDefinitions.get(i));\n+                    findImportByDefinitions(def, imports).ifPresent(anImport -> {\n+                        final JSITImport foundImported = Js.uncheckedCast(anImport);\n+                        importDefinitions.put(foundImported, def);\n+                    });\n+                }\n+                return promises.resolve(importDefinitions);\n+            });\n+        }\n+        return promises.resolve(new HashMap<>());\n+    }\n+\n+    Promise<List<JSITDefinitions>> loadDMNDefinitions() {\n+        final List<JSITDefinitions> otherDefinitions = new Vector<>();\n+        return contentService.getFilteredItems(DMN_FILES_PATTERN).then(list -> {\n+            final List<Promise<JSITDefinitions>> fileLoadPromises = new ArrayList<>();\n+            for (final String file : list) {\n+                final Promise<JSITDefinitions> promise = loadDefinitionFromFile(file, otherDefinitions);\n+                fileLoadPromises.add(promise);\n+            }\n+            return promises.all(fileLoadPromises.toArray(new Promise[]{})).then(v -> promises.resolve(otherDefinitions));\n+        });\n+    }\n+\n+    @Override\n+    public void loadNodesFromModels(final List<DMNIncludedModel> includedModels,\n+                                    final ServiceCallback<List<DMNIncludedNode>> callback) {\n+\n+        final List<DMNIncludedNode> result = new Vector<>();\n+        final List<Promise> fileLoadPromises = new ArrayList<>();\n+        for (final DMNIncludedModel model : includedModels) {\n+            final String path = model.getPath();\n+            final Promise promise = contentService.loadFile(path).then(content -> {\n+                                                                           diagramService.transform(content, new ServiceCallback<Diagram>() {\n+                                                                               @Override\n+                                                                               public void onSuccess(final Diagram item) {\n+                                                                                   final Optional<DMNIncludedModel> diagramImport = getDiagramImport(item, includedModels);\n+                                                                                   final List<DMNIncludedNode> nodes = diagramImport\n+                                                                                           .map(dmn -> diagramUtils\n+                                                                                                   .getDRGElements(item)\n+                                                                                                   .stream()\n+                                                                                                   .map(node -> includedModelFactory.makeDMNIncludeNode(path, dmn, node))\n+                                                                                                   .collect(Collectors.toList()))\n+                                                                                           .orElse(new ArrayList<>());\n+\n+                                                                                   result.addAll(nodes);\n+                                                                               }\n+\n+                                                                               @Override\n+                                                                               public void onError(final ClientRuntimeError error) {\n+                                                                                   LOGGER.log(Level.SEVERE, error.getMessage());\n+                                                                               }\n+                                                                           });\n+                                                                           return promises.resolve();\n+                                                                       }\n+            );\n+            fileLoadPromises.add(promise);\n+        }\n+\n+        promises.all(fileLoadPromises.toArray(new Promise[]{})).then(p -> {\n+            callback.onSuccess(result);\n+            return promises.resolve();\n+        });\n+    }\n+\n+    @Override\n+    public void loadModels(final ServiceCallback<List<IncludedModel>> callback) {\n+\n+        final List<IncludedModel> models = new Vector<>();\n+        contentService.getFilteredItems(DMN_FILES_PATTERN).then(items -> {\n+            final List<Promise> fileLoadPromises = new ArrayList<>();\n+\n+            for (final String file : items) {\n+                final Promise<Object> fileLoad = contentService.loadFile(file).then(fileContent -> {\n+                    diagramService.transform(fileContent, new ServiceCallback<Diagram>() {\n+                        @Override\n+                        public void onSuccess(final Diagram item) {\n+                            final String modelPackage = \"\";\n+                            final Diagram<Graph, Metadata> diagram = (Diagram<Graph, Metadata>) item;\n+                            final String namespace = diagramUtils.getNamespace(diagram);\n+                            final String importType = DMNImportTypes.DMN.getDefaultNamespace();\n+                            final int drgElementCount = diagramUtils.getDRGElements(diagram).size();\n+                            final int itemDefinitionCount = diagramUtils.getDefinitions(diagram).getItemDefinition().size();\n+                            // We get files only from the same folder, so doesn't need relative or full path.\n+                            final String filename = FileUtils.getFileName(file);\n+                            models.add(new DMNIncludedModel(filename,\n+                                                            modelPackage,\n+                                                            filename,\n+                                                            namespace,\n+                                                            importType,\n+                                                            drgElementCount,\n+                                                            itemDefinitionCount));\n+                        }\n+\n+                        @Override\n+                        public void onError(final ClientRuntimeError error) {\n+                            LOGGER.log(Level.SEVERE, error.getMessage());\n+                        }\n+                    });\n+                    return promises.resolve();\n+                });\n+\n+                fileLoadPromises.add(fileLoad);\n+            }\n+\n+            return promises.all(fileLoadPromises.toArray(new Promise[]{})).then(v -> promises.resolve());", "originalCommit": "385e8dc50ada79a8607d080d801e333cb1a27a4c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM0NjYwNA==", "url": "https://github.com/kiegroup/kie-wb-common/pull/3310#discussion_r431346604", "bodyText": "Could we please rename to sucessCallback or something more explicitely saying that is callback in case no issues during computation happened?", "author": "jomarko", "createdAt": "2020-05-27T18:12:50Z", "path": "kie-wb-common-dmn/kie-wb-common-dmn-webapp-kogito-testing/src/main/java/org/kie/workbench/common/dmn/showcase/client/alternatives/KogitoResourceContentService.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.workbench.common.dmn.showcase.client.alternatives;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import javax.enterprise.inject.Alternative;\n+import javax.inject.Inject;\n+\n+import elemental2.promise.Promise;\n+import org.appformer.kogito.bridge.client.resource.ResourceContentService;\n+import org.jboss.errai.common.client.api.ErrorCallback;\n+import org.jboss.errai.common.client.api.RemoteCallback;\n+import org.uberfire.client.promise.Promises;\n+\n+@Alternative\n+public class KogitoResourceContentService extends org.kie.workbench.common.kogito.webapp.base.client.workarounds.KogitoResourceContentService {\n+\n+    final static String BASE_MODEL = \"Base Model.dmn\";\n+    final static String MODEL_WITH_IMPORTS = \"Model With Imports.dmn\";\n+\n+    @Inject\n+    public KogitoResourceContentService(final ResourceContentService resourceContentService,\n+                                        final Promises promises) {\n+        super(resourceContentService, promises);\n+    }\n+\n+    @Override\n+    public void getFilteredItems(final String pattern,\n+                                 final RemoteCallback<List<String>> callback,", "originalCommit": "385e8dc50ada79a8607d080d801e333cb1a27a4c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM0ODA1Mw==", "url": "https://github.com/kiegroup/kie-wb-common/pull/3310#discussion_r431348053", "bodyText": "From my point of view in the default else branches it is more 'not supported' or 'illegal state'. because new comer can add his file into DMNClientModels class. In such case message about not found can be confusing. What do you think?", "author": "jomarko", "createdAt": "2020-05-27T18:15:10Z", "path": "kie-wb-common-dmn/kie-wb-common-dmn-webapp-kogito-testing/src/main/java/org/kie/workbench/common/dmn/showcase/client/alternatives/KogitoResourceContentService.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.workbench.common.dmn.showcase.client.alternatives;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import javax.enterprise.inject.Alternative;\n+import javax.inject.Inject;\n+\n+import elemental2.promise.Promise;\n+import org.appformer.kogito.bridge.client.resource.ResourceContentService;\n+import org.jboss.errai.common.client.api.ErrorCallback;\n+import org.jboss.errai.common.client.api.RemoteCallback;\n+import org.uberfire.client.promise.Promises;\n+\n+@Alternative\n+public class KogitoResourceContentService extends org.kie.workbench.common.kogito.webapp.base.client.workarounds.KogitoResourceContentService {\n+\n+    final static String BASE_MODEL = \"Base Model.dmn\";\n+    final static String MODEL_WITH_IMPORTS = \"Model With Imports.dmn\";\n+\n+    @Inject\n+    public KogitoResourceContentService(final ResourceContentService resourceContentService,\n+                                        final Promises promises) {\n+        super(resourceContentService, promises);\n+    }\n+\n+    @Override\n+    public void getFilteredItems(final String pattern,\n+                                 final RemoteCallback<List<String>> callback,\n+                                 final ErrorCallback<Object> errorCallback) {\n+\n+        callback.callback(Arrays.asList(BASE_MODEL, MODEL_WITH_IMPORTS));\n+    }\n+\n+    @Override\n+    public void loadFile(final String fileUri,\n+                         final RemoteCallback<String> callback,\n+                         final ErrorCallback<Object> errorCallback) {\n+        if (BASE_MODEL.equals(fileUri)) {\n+            callback.callback(DMNClientModels.BASE_FILE);\n+        } else if (MODEL_WITH_IMPORTS.equals(fileUri)) {\n+            callback.callback(DMNClientModels.MODEL_WITH_IMPORTS);\n+        } else {\n+            errorCallback.error(\"File '\" + fileUri + \"'not found\", new Throwable(\"File not found: '\" + fileUri + \"'\"));\n+        }\n+    }\n+\n+    @Override\n+    public Promise<String[]> getFilteredItems(final String pattern) {\n+        return Promise.resolve(new String[]{BASE_MODEL, MODEL_WITH_IMPORTS});\n+    }\n+\n+    @Override\n+    public Promise<String> loadFile(final String fileUri) {\n+        if (BASE_MODEL.equals(fileUri)) {\n+            return Promise.resolve(DMNClientModels.BASE_FILE);\n+        } else if (MODEL_WITH_IMPORTS.equals(fileUri)) {\n+            return Promise.resolve(DMNClientModels.MODEL_WITH_IMPORTS);\n+        } else {\n+            return Promise.resolve(\"NOT FOUND!\");\n+        }\n+    }", "originalCommit": "385e8dc50ada79a8607d080d801e333cb1a27a4c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM0OTc5Ng==", "url": "https://github.com/kiegroup/kie-wb-common/pull/3310#discussion_r431349796", "bodyText": "Could you please explain what effect has this 'something.dmn' value? I mean is that reflected somehow in UI or just the DMNClientModels.MODEL_WITH_IMPORTS is important?", "author": "jomarko", "createdAt": "2020-05-27T18:18:19Z", "path": "kie-wb-common-dmn/kie-wb-common-dmn-webapp-kogito-testing/src/main/java/org/kie/workbench/common/dmn/showcase/client/navigator/DMNDiagramsNavigatorScreen.java", "diffHunk": "@@ -86,6 +96,34 @@ public void edit() {\n         }\n     }\n \n+    @Override\n+    protected MenuFactory.TopLevelMenusBuilder<MenuFactory.MenuBuilder> createMenuBuilder() {\n+        final MenuFactory.TopLevelMenusBuilder<MenuFactory.MenuBuilder> builder = super.createMenuBuilder();\n+        builder.newTopLevelMenu(\"Load diagrams from client\")\n+                .respondsWith(this::loadFromClient)\n+                .order(-1)\n+                .endMenu();\n+        return builder;\n+    }\n+\n+    private void loadFromClient() {\n+        contentService.getFilteredItems(\"**/*.dmn\", getItems(), getErrorCallback());\n+    }\n+\n+    private ErrorCallback<Object> getErrorCallback() {\n+        return null;\n+    }\n+\n+    private RemoteCallback<List<String>> getItems() {\n+        return response -> {\n+            GWT.log(\"PATHS:\");\n+            for (final String s : response) {\n+                GWT.log(s);\n+            }\n+            vfsService.openFile(\"something.dmn\", DMNClientModels.MODEL_WITH_IMPORTS);", "originalCommit": "385e8dc50ada79a8607d080d801e333cb1a27a4c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYzMzA4Mg==", "url": "https://github.com/kiegroup/kie-wb-common/pull/3310#discussion_r432633082", "bodyText": "It can be anything. This method is just to load the test DMN models defined in DMNClientModels by the \"Load Models From Client\" button in our test project.", "author": "danielzhe", "createdAt": "2020-05-29T17:28:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM0OTc5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM1MTMwMQ==", "url": "https://github.com/kiegroup/kie-wb-common/pull/3310#discussion_r431351301", "bodyText": "to be consistent, we could add javadoc", "author": "jomarko", "createdAt": "2020-05-27T18:21:10Z", "path": "kie-wb-common-kogito/kie-wb-common-kogito-webapp-base/src/main/java/org/kie/workbench/common/kogito/webapp/base/client/workarounds/KogitoResourceContentService.java", "diffHunk": "@@ -104,4 +105,12 @@ public void getFilteredItems(final String pattern,\n                     return null;\n                 });\n     }\n+\n+    public Promise<String[]> getFilteredItems(final String pattern) {\n+        return resourceContentService.list(pattern);\n+    }\n+\n+    public Promise<String> loadFile(final String fileUri) {\n+        return resourceContentService.get(fileUri);", "originalCommit": "385e8dc50ada79a8607d080d801e333cb1a27a4c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM1MzAxOA==", "url": "https://github.com/kiegroup/kie-wb-common/pull/3310#discussion_r431353018", "bodyText": "Is 'Windows' correct in this javadoc?", "author": "jomarko", "createdAt": "2020-05-27T18:24:12Z", "path": "kie-wb-common-stunner/kie-wb-common-stunner-core/kie-wb-common-stunner-api/kie-wb-common-stunner-core-api/src/main/java/org/kie/workbench/common/stunner/core/util/FileUtils.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.workbench.common.stunner.core.util;\n+\n+public class FileUtils {\n+\n+    private static final char UNIX_SEPARATOR = '/';\n+    private static final char WINDOWS_SEPARATOR = '\\\\';\n+\n+    /**\n+     * Gets the file name without the Windows extension.", "originalCommit": "385e8dc50ada79a8607d080d801e333cb1a27a4c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYzMzY3Mg==", "url": "https://github.com/kiegroup/kie-wb-common/pull/3310#discussion_r432633672", "bodyText": "I thought it was, but by your question I think is not.", "author": "danielzhe", "createdAt": "2020-05-29T17:29:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM1MzAxOA=="}], "type": "inlineReview"}, {"oid": "4faa7d39f5c797c8af9fa7c0624aaffb1fb3a5f3", "url": "https://github.com/kiegroup/kie-wb-common/commit/4faa7d39f5c797c8af9fa7c0624aaffb1fb3a5f3", "message": "Fix issue related to DMN files path.", "committedDate": "2020-05-28T18:55:59Z", "type": "forcePushed"}, {"oid": "511c28d9e8df738452bdf5d7b4100d45a9d09dbb", "url": "https://github.com/kiegroup/kie-wb-common/commit/511c28d9e8df738452bdf5d7b4100d45a9d09dbb", "message": "Changes from code review and improvements in code.", "committedDate": "2020-05-29T17:31:30Z", "type": "forcePushed"}, {"oid": "4ce32e40687d2d15ab17585960d190a29ef2bc5a", "url": "https://github.com/kiegroup/kie-wb-common/commit/4ce32e40687d2d15ab17585960d190a29ef2bc5a", "message": "Changes from code review and improvements in code.", "committedDate": "2020-05-29T17:34:27Z", "type": "forcePushed"}, {"oid": "4c80913917c3d7eb9216e3f044e5e8a94d801896", "url": "https://github.com/kiegroup/kie-wb-common/commit/4c80913917c3d7eb9216e3f044e5e8a94d801896", "message": "Changes from code review and improvements in code.", "committedDate": "2020-05-29T17:37:04Z", "type": "forcePushed"}, {"oid": "6b1da773f53fdc05bf43f7ee18d1577d44cd34b8", "url": "https://github.com/kiegroup/kie-wb-common/commit/6b1da773f53fdc05bf43f7ee18d1577d44cd34b8", "message": "Changes from code review and improvements in code.", "committedDate": "2020-05-29T17:48:31Z", "type": "forcePushed"}, {"oid": "31bd5c8b0cd5c16b1354f5088f9e1cc6a8c4fc63", "url": "https://github.com/kiegroup/kie-wb-common/commit/31bd5c8b0cd5c16b1354f5088f9e1cc6a8c4fc63", "message": "Changes from code review and improvements in code.", "committedDate": "2020-05-29T20:42:32Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE3MDU1Ng==", "url": "https://github.com/kiegroup/kie-wb-common/pull/3310#discussion_r433170556", "bodyText": "Seems to me we can use Colelctions.emptyMap() as the resolved map is just iterated.", "author": "jomarko", "createdAt": "2020-06-01T11:01:04Z", "path": "kie-wb-common-dmn/kie-wb-common-dmn-webapp-kogito-common/src/main/java/org/kie/workbench/common/dmn/webapp/kogito/common/client/converters/DMNMarshallerImportsHelperKogitoImpl.java", "diffHunk": "@@ -16,29 +16,257 @@\n package org.kie.workbench.common.dmn.webapp.kogito.common.client.converters;\n \n import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.Objects;\n import java.util.Optional;\n+import java.util.Vector;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n \n import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Inject;\n+import javax.xml.namespace.QName;\n \n+import elemental2.promise.IThenable;\n+import elemental2.promise.Promise;\n+import jsinterop.base.Js;\n+import org.appformer.kogito.bridge.client.resource.interop.ResourceListOptions;\n import org.guvnor.common.services.project.model.WorkspaceProject;\n+import org.kie.workbench.common.dmn.api.definition.model.ItemDefinition;\n+import org.kie.workbench.common.dmn.api.editors.included.DMNImportTypes;\n+import org.kie.workbench.common.dmn.api.editors.included.DMNIncludedModel;\n+import org.kie.workbench.common.dmn.api.editors.included.DMNIncludedNode;\n+import org.kie.workbench.common.dmn.api.editors.included.IncludedModel;\n import org.kie.workbench.common.dmn.api.editors.included.PMMLDocumentMetadata;\n+import org.kie.workbench.common.dmn.api.graph.DMNDiagramUtils;\n+import org.kie.workbench.common.dmn.webapp.kogito.common.client.converters.model.ImportedItemDefinitionPropertyConverter;\n+import org.kie.workbench.common.dmn.webapp.kogito.common.client.services.DMNClientDiagramServiceImpl;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDMNElement;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDRGElement;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDecision;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDefinitions;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITImport;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITInformationItem;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITInputData;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITInvocable;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITItemDefinition;\n+import org.kie.workbench.common.kogito.webapp.base.client.workarounds.KogitoResourceContentService;\n+import org.kie.workbench.common.stunner.core.client.service.ClientRuntimeError;\n+import org.kie.workbench.common.stunner.core.client.service.ServiceCallback;\n+import org.kie.workbench.common.stunner.core.diagram.Diagram;\n import org.kie.workbench.common.stunner.core.diagram.Metadata;\n+import org.kie.workbench.common.stunner.core.graph.Graph;\n+import org.kie.workbench.common.stunner.core.util.FileUtils;\n+import org.kie.workbench.common.stunner.core.util.StringUtils;\n import org.uberfire.backend.vfs.Path;\n+import org.uberfire.client.promise.Promises;\n+\n+import static org.kie.workbench.common.dmn.api.editors.types.BuiltInTypeUtils.isBuiltInType;\n+import static org.kie.workbench.common.dmn.webapp.kogito.common.client.converters.model.ImportedItemDefinitionPropertyConverter.withNamespace;\n \n @ApplicationScoped\n public class DMNMarshallerImportsHelperKogitoImpl implements DMNMarshallerImportsHelperKogito {\n \n+    private final KogitoResourceContentService contentService;\n+    private final DMNClientDiagramServiceImpl diagramService;\n+    private final Promises promises;\n+    private final DMNDiagramUtils diagramUtils;\n+    private final DMNIncludedNodeFactory includedModelFactory;\n+\n+    private static final Logger LOGGER = Logger.getLogger(DMNMarshallerImportsHelperKogitoImpl.class.getName());\n+    private static final String DMN_FILES_PATTERN = \"*.dmn\";\n+\n+    @Inject\n+    public DMNMarshallerImportsHelperKogitoImpl(final KogitoResourceContentService contentService,\n+                                                final DMNClientDiagramServiceImpl diagramService,\n+                                                final Promises promises,\n+                                                final DMNDiagramUtils diagramUtils,\n+                                                final DMNIncludedNodeFactory includedModelFactory) {\n+        this.contentService = contentService;\n+        this.diagramService = diagramService;\n+        this.promises = promises;\n+        this.diagramUtils = diagramUtils;\n+        this.includedModelFactory = includedModelFactory;\n+    }\n+\n+    @Override\n+    public Promise<Map<JSITImport, JSITDefinitions>> getImportDefinitionsAsync(final Metadata metadata,\n+                                                                               final List<JSITImport> imports) {\n+        if (!imports.isEmpty()) {\n+            return loadDMNDefinitions().then(otherDefinitions -> {\n+                final Map<JSITImport, JSITDefinitions> importDefinitions = new HashMap<>();\n+                for (final Map.Entry<String, JSITDefinitions> entry : otherDefinitions.entrySet()) {\n+                    final JSITDefinitions def = Js.uncheckedCast(entry.getValue());\n+                    findImportByDefinitions(def, imports).ifPresent(anImport -> {\n+                        final JSITImport foundImported = Js.uncheckedCast(anImport);\n+                        importDefinitions.put(foundImported, def);\n+                    });\n+                }\n+                return promises.resolve(importDefinitions);\n+            });\n+        }\n+        return promises.resolve(new HashMap<>());", "originalCommit": "31bd5c8b0cd5c16b1354f5088f9e1cc6a8c4fc63", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE3MTA2MA==", "url": "https://github.com/kiegroup/kie-wb-common/pull/3310#discussion_r433171060", "bodyText": "maybe also here we could use Collections.emptyMap()", "author": "jomarko", "createdAt": "2020-06-01T11:02:13Z", "path": "kie-wb-common-dmn/kie-wb-common-dmn-webapp-kogito-common/src/main/java/org/kie/workbench/common/dmn/webapp/kogito/common/client/converters/DMNMarshallerImportsHelperKogitoImpl.java", "diffHunk": "@@ -16,29 +16,257 @@\n package org.kie.workbench.common.dmn.webapp.kogito.common.client.converters;\n \n import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.Objects;\n import java.util.Optional;\n+import java.util.Vector;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n \n import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Inject;\n+import javax.xml.namespace.QName;\n \n+import elemental2.promise.IThenable;\n+import elemental2.promise.Promise;\n+import jsinterop.base.Js;\n+import org.appformer.kogito.bridge.client.resource.interop.ResourceListOptions;\n import org.guvnor.common.services.project.model.WorkspaceProject;\n+import org.kie.workbench.common.dmn.api.definition.model.ItemDefinition;\n+import org.kie.workbench.common.dmn.api.editors.included.DMNImportTypes;\n+import org.kie.workbench.common.dmn.api.editors.included.DMNIncludedModel;\n+import org.kie.workbench.common.dmn.api.editors.included.DMNIncludedNode;\n+import org.kie.workbench.common.dmn.api.editors.included.IncludedModel;\n import org.kie.workbench.common.dmn.api.editors.included.PMMLDocumentMetadata;\n+import org.kie.workbench.common.dmn.api.graph.DMNDiagramUtils;\n+import org.kie.workbench.common.dmn.webapp.kogito.common.client.converters.model.ImportedItemDefinitionPropertyConverter;\n+import org.kie.workbench.common.dmn.webapp.kogito.common.client.services.DMNClientDiagramServiceImpl;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDMNElement;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDRGElement;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDecision;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDefinitions;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITImport;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITInformationItem;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITInputData;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITInvocable;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITItemDefinition;\n+import org.kie.workbench.common.kogito.webapp.base.client.workarounds.KogitoResourceContentService;\n+import org.kie.workbench.common.stunner.core.client.service.ClientRuntimeError;\n+import org.kie.workbench.common.stunner.core.client.service.ServiceCallback;\n+import org.kie.workbench.common.stunner.core.diagram.Diagram;\n import org.kie.workbench.common.stunner.core.diagram.Metadata;\n+import org.kie.workbench.common.stunner.core.graph.Graph;\n+import org.kie.workbench.common.stunner.core.util.FileUtils;\n+import org.kie.workbench.common.stunner.core.util.StringUtils;\n import org.uberfire.backend.vfs.Path;\n+import org.uberfire.client.promise.Promises;\n+\n+import static org.kie.workbench.common.dmn.api.editors.types.BuiltInTypeUtils.isBuiltInType;\n+import static org.kie.workbench.common.dmn.webapp.kogito.common.client.converters.model.ImportedItemDefinitionPropertyConverter.withNamespace;\n \n @ApplicationScoped\n public class DMNMarshallerImportsHelperKogitoImpl implements DMNMarshallerImportsHelperKogito {\n \n+    private final KogitoResourceContentService contentService;\n+    private final DMNClientDiagramServiceImpl diagramService;\n+    private final Promises promises;\n+    private final DMNDiagramUtils diagramUtils;\n+    private final DMNIncludedNodeFactory includedModelFactory;\n+\n+    private static final Logger LOGGER = Logger.getLogger(DMNMarshallerImportsHelperKogitoImpl.class.getName());\n+    private static final String DMN_FILES_PATTERN = \"*.dmn\";\n+\n+    @Inject\n+    public DMNMarshallerImportsHelperKogitoImpl(final KogitoResourceContentService contentService,\n+                                                final DMNClientDiagramServiceImpl diagramService,\n+                                                final Promises promises,\n+                                                final DMNDiagramUtils diagramUtils,\n+                                                final DMNIncludedNodeFactory includedModelFactory) {\n+        this.contentService = contentService;\n+        this.diagramService = diagramService;\n+        this.promises = promises;\n+        this.diagramUtils = diagramUtils;\n+        this.includedModelFactory = includedModelFactory;\n+    }\n+\n+    @Override\n+    public Promise<Map<JSITImport, JSITDefinitions>> getImportDefinitionsAsync(final Metadata metadata,\n+                                                                               final List<JSITImport> imports) {\n+        if (!imports.isEmpty()) {\n+            return loadDMNDefinitions().then(otherDefinitions -> {\n+                final Map<JSITImport, JSITDefinitions> importDefinitions = new HashMap<>();\n+                for (final Map.Entry<String, JSITDefinitions> entry : otherDefinitions.entrySet()) {\n+                    final JSITDefinitions def = Js.uncheckedCast(entry.getValue());\n+                    findImportByDefinitions(def, imports).ifPresent(anImport -> {\n+                        final JSITImport foundImported = Js.uncheckedCast(anImport);\n+                        importDefinitions.put(foundImported, def);\n+                    });\n+                }\n+                return promises.resolve(importDefinitions);\n+            });\n+        }\n+        return promises.resolve(new HashMap<>());\n+    }\n+\n+    Promise<Map<String, JSITDefinitions>> loadDMNDefinitions() {\n+\n+        return contentService.getFilteredItems(DMN_FILES_PATTERN, ResourceListOptions.assetFolder())\n+                .then(list -> {\n+                    if (list.length == 0) {\n+                        return promises.resolve(new HashMap<>());", "originalCommit": "31bd5c8b0cd5c16b1354f5088f9e1cc6a8c4fc63", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "dab9834cf95491f5a844f6f464bca4e64de177b8", "url": "https://github.com/kiegroup/kie-wb-common/commit/dab9834cf95491f5a844f6f464bca4e64de177b8", "message": "KOGITO-1553: [DMN Designer] Open a DMN file with an included model - Included Models tab\nKOGITO-1776: [DMN Designer] Create a \"Load Projects From Client\" button\nKOGITO-1552: [DMN Designer] Open a DMN file with an included model - DRG Elements", "committedDate": "2020-06-01T19:10:49Z", "type": "commit"}, {"oid": "ab32293b9a40a0e5346a95332364d9784250fd99", "url": "https://github.com/kiegroup/kie-wb-common/commit/ab32293b9a40a0e5346a95332364d9784250fd99", "message": "Fixes an codestyle error and compatibility with Scesim.", "committedDate": "2020-06-01T19:10:49Z", "type": "commit"}, {"oid": "1601d09bf50c03ecab2761c6e46243a16ad56ed6", "url": "https://github.com/kiegroup/kie-wb-common/commit/1601d09bf50c03ecab2761c6e46243a16ad56ed6", "message": "Fix condition not valid to DMN.", "committedDate": "2020-06-01T19:10:49Z", "type": "commit"}, {"oid": "6ba84cd5211959f68e193968d1dbb77684027966", "url": "https://github.com/kiegroup/kie-wb-common/commit/6ba84cd5211959f68e193968d1dbb77684027966", "message": "Fix issue related to DMN files path.", "committedDate": "2020-06-01T19:10:50Z", "type": "commit"}, {"oid": "9452f4efd5fbe590c0a5d8e2ba4125773620ba0b", "url": "https://github.com/kiegroup/kie-wb-common/commit/9452f4efd5fbe590c0a5d8e2ba4125773620ba0b", "message": "Changes from code review and improvements in code.", "committedDate": "2020-06-01T19:10:50Z", "type": "commit"}, {"oid": "2fd58226779cee3115a30a7ff6f9c7b1ef91a605", "url": "https://github.com/kiegroup/kie-wb-common/commit/2fd58226779cee3115a30a7ff6f9c7b1ef91a605", "message": "Fixed infinite load issue in some scenarios. Code review improvements.", "committedDate": "2020-06-02T18:48:56Z", "type": "commit"}, {"oid": "2fd58226779cee3115a30a7ff6f9c7b1ef91a605", "url": "https://github.com/kiegroup/kie-wb-common/commit/2fd58226779cee3115a30a7ff6f9c7b1ef91a605", "message": "Fixed infinite load issue in some scenarios. Code review improvements.", "committedDate": "2020-06-02T18:48:56Z", "type": "forcePushed"}, {"oid": "018a051611374836b26240c975d555ff275ab305", "url": "https://github.com/kiegroup/kie-wb-common/commit/018a051611374836b26240c975d555ff275ab305", "message": "- Order files in alphabetical order\n- Hide Included from other channels, except VSCode and Default (BC)", "committedDate": "2020-06-03T20:59:17Z", "type": "commit"}, {"oid": "87a45a256286505a43d3be92c60a66740c538740", "url": "https://github.com/kiegroup/kie-wb-common/commit/87a45a256286505a43d3be92c60a66740c538740", "message": "Fix failing test and added more tests.", "committedDate": "2020-06-04T15:04:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ2NzY0NQ==", "url": "https://github.com/kiegroup/kie-wb-common/pull/3310#discussion_r435467645", "bodyText": "Since we're not using the fallbackInput any more, can we do some clean-up KogitoKieAssetsDropdownView as well?", "author": "karreiro", "createdAt": "2020-06-04T18:34:04Z", "path": "kie-wb-common-widgets/kie-wb-common-ui/src/main/java/org/kie/workbench/common/widgets/client/assets/dropdown/KogitoKieAssetsDropdown.java", "diffHunk": "@@ -56,25 +31,11 @@ public void initializeDropdown() {\n         super.initializeDropdown();\n     }\n \n-    protected void initializeInput() {\n-        ((KogitoKieAssetsDropdown.View) view).enableInputMode();", "originalCommit": "87a45a256286505a43d3be92c60a66740c538740", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ3NzU1OQ==", "url": "https://github.com/kiegroup/kie-wb-common/pull/3310#discussion_r435477559", "bodyText": "I believe we need a condition here, similar to what we have here: https://github.com/kiegroup/kie-wb-common/pull/3310/files#diff-a1a7c2952428146fc4089821e2271475R216-R219", "author": "karreiro", "createdAt": "2020-06-04T18:47:06Z", "path": "kie-wb-common-dmn/kie-wb-common-dmn-webapp-kogito-runtime/src/main/java/org/kie/workbench/common/dmn/showcase/client/editor/DMNDiagramEditor.java", "diffHunk": "@@ -159,6 +168,7 @@ public void onDiagramLoad() {\n             expressionEditor.setToolbarStateHandler(new DMNProjectToolbarStateHandler(getMenuSessionItems()));\n             decisionNavigatorDock.setupCanvasHandler(c);\n             dataTypesPage.reload();\n+            includedModelsPage.setup(importsPageProvider.withDiagram(c.getDiagram()));", "originalCommit": "87a45a256286505a43d3be92c60a66740c538740", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ4NjAyMA==", "url": "https://github.com/kiegroup/kie-wb-common/pull/3310#discussion_r435486020", "bodyText": "IntelliJ is warning about this method, I think we can solve it by using:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Promise loadNodes(final Map<String, JSITDefinitions> existingDefinitions,\n          \n          \n            \n                private Promise<List<DMNIncludedNode>> loadNodes(final Map<String, JSITDefinitions> existingDefinitions,", "author": "karreiro", "createdAt": "2020-06-04T19:02:36Z", "path": "kie-wb-common-dmn/kie-wb-common-dmn-webapp-kogito-common/src/main/java/org/kie/workbench/common/dmn/webapp/kogito/common/client/converters/DMNMarshallerImportsHelperKogitoImpl.java", "diffHunk": "@@ -16,29 +16,256 @@\n package org.kie.workbench.common.dmn.webapp.kogito.common.client.converters;\n \n import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.Objects;\n import java.util.Optional;\n+import java.util.Vector;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n \n import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Inject;\n+import javax.xml.namespace.QName;\n \n+import elemental2.promise.IThenable;\n+import elemental2.promise.Promise;\n+import jsinterop.base.Js;\n+import org.appformer.kogito.bridge.client.resource.interop.ResourceListOptions;\n import org.guvnor.common.services.project.model.WorkspaceProject;\n+import org.kie.workbench.common.dmn.api.definition.model.ItemDefinition;\n+import org.kie.workbench.common.dmn.api.editors.included.DMNImportTypes;\n+import org.kie.workbench.common.dmn.api.editors.included.DMNIncludedModel;\n+import org.kie.workbench.common.dmn.api.editors.included.DMNIncludedNode;\n+import org.kie.workbench.common.dmn.api.editors.included.IncludedModel;\n import org.kie.workbench.common.dmn.api.editors.included.PMMLDocumentMetadata;\n+import org.kie.workbench.common.dmn.api.graph.DMNDiagramUtils;\n+import org.kie.workbench.common.dmn.webapp.kogito.common.client.converters.model.ImportedItemDefinitionPropertyConverter;\n+import org.kie.workbench.common.dmn.webapp.kogito.common.client.services.DMNClientDiagramServiceImpl;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDMNElement;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDRGElement;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDecision;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDefinitions;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITImport;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITInformationItem;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITInputData;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITInvocable;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITItemDefinition;\n+import org.kie.workbench.common.kogito.webapp.base.client.workarounds.KogitoResourceContentService;\n+import org.kie.workbench.common.stunner.core.client.service.ClientRuntimeError;\n+import org.kie.workbench.common.stunner.core.client.service.ServiceCallback;\n+import org.kie.workbench.common.stunner.core.diagram.Diagram;\n import org.kie.workbench.common.stunner.core.diagram.Metadata;\n+import org.kie.workbench.common.stunner.core.graph.Graph;\n+import org.kie.workbench.common.stunner.core.util.FileUtils;\n+import org.kie.workbench.common.stunner.core.util.StringUtils;\n import org.uberfire.backend.vfs.Path;\n+import org.uberfire.client.promise.Promises;\n+\n+import static org.kie.workbench.common.dmn.api.editors.types.BuiltInTypeUtils.isBuiltInType;\n+import static org.kie.workbench.common.dmn.webapp.kogito.common.client.converters.model.ImportedItemDefinitionPropertyConverter.withNamespace;\n \n @ApplicationScoped\n public class DMNMarshallerImportsHelperKogitoImpl implements DMNMarshallerImportsHelperKogito {\n \n+    private final KogitoResourceContentService contentService;\n+    private final DMNClientDiagramServiceImpl diagramService;\n+    private final Promises promises;\n+    private final DMNDiagramUtils diagramUtils;\n+    private final DMNIncludedNodeFactory includedModelFactory;\n+\n+    private static final Logger LOGGER = Logger.getLogger(DMNMarshallerImportsHelperKogitoImpl.class.getName());\n+    private static final String DMN_FILES_PATTERN = \"*.dmn\";\n+\n+    @Inject\n+    public DMNMarshallerImportsHelperKogitoImpl(final KogitoResourceContentService contentService,\n+                                                final DMNClientDiagramServiceImpl diagramService,\n+                                                final Promises promises,\n+                                                final DMNDiagramUtils diagramUtils,\n+                                                final DMNIncludedNodeFactory includedModelFactory) {\n+        this.contentService = contentService;\n+        this.diagramService = diagramService;\n+        this.promises = promises;\n+        this.diagramUtils = diagramUtils;\n+        this.includedModelFactory = includedModelFactory;\n+    }\n+\n+    @Override\n+    public Promise<Map<JSITImport, JSITDefinitions>> getImportDefinitionsAsync(final Metadata metadata,\n+                                                                               final List<JSITImport> imports) {\n+        if (!imports.isEmpty()) {\n+            return loadDMNDefinitions().then(otherDefinitions -> {\n+                final Map<JSITImport, JSITDefinitions> importDefinitions = new HashMap<>();\n+                for (final Map.Entry<String, JSITDefinitions> entry : otherDefinitions.entrySet()) {\n+                    final JSITDefinitions def = Js.uncheckedCast(entry.getValue());\n+                    findImportByDefinitions(def, imports).ifPresent(anImport -> {\n+                        final JSITImport foundImported = Js.uncheckedCast(anImport);\n+                        importDefinitions.put(foundImported, def);\n+                    });\n+                }\n+                return promises.resolve(importDefinitions);\n+            });\n+        }\n+        return promises.resolve(Collections.emptyMap());\n+    }\n+\n+    Promise<Map<String, JSITDefinitions>> loadDMNDefinitions() {\n+        return contentService.getFilteredItems(DMN_FILES_PATTERN, ResourceListOptions.assetFolder())\n+                .then(list -> {\n+                    if (list.length == 0) {\n+                        return promises.resolve(Collections.emptyMap());\n+                    } else {\n+                        final Map<String, JSITDefinitions> otherDefinitions = new ConcurrentHashMap<>();\n+                        return promises.all(Arrays.asList(list),\n+                                            (String file) -> loadDefinitionFromFile(file, otherDefinitions))\n+                                .then(v -> promises.resolve(otherDefinitions));\n+                    }\n+                });\n+    }\n+\n+    @Override\n+    public void loadNodesFromModels(final List<DMNIncludedModel> includedModels,\n+                                    final ServiceCallback<List<DMNIncludedNode>> callback) {\n+        final List<DMNIncludedNode> result = new Vector<>();\n+        if (includedModels.isEmpty()) {\n+            callback.onSuccess(result);\n+        } else {\n+            loadDMNDefinitions()\n+                    .then(existingDefinitions -> promises.all(includedModels, model -> loadNodes(existingDefinitions, model, result))\n+                            .then(p ->\n+                                  {\n+                                      callback.onSuccess(result);\n+                                      return promises.resolve();\n+                                  }));\n+        }\n+    }\n+\n+    private Promise loadNodes(final Map<String, JSITDefinitions> existingDefinitions,", "originalCommit": "87a45a256286505a43d3be92c60a66740c538740", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ4NjI0MA==", "url": "https://github.com/kiegroup/kie-wb-common/pull/3310#discussion_r435486240", "bodyText": "IntelliJ is warning about this method, I think we can solve it by using:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Promise loadDefinitionFromFile(final String file,\n          \n          \n            \n                Promise<Void> loadDefinitionFromFile(final String file,", "author": "karreiro", "createdAt": "2020-06-04T19:03:00Z", "path": "kie-wb-common-dmn/kie-wb-common-dmn-webapp-kogito-common/src/main/java/org/kie/workbench/common/dmn/webapp/kogito/common/client/converters/DMNMarshallerImportsHelperKogitoImpl.java", "diffHunk": "@@ -16,29 +16,256 @@\n package org.kie.workbench.common.dmn.webapp.kogito.common.client.converters;\n \n import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.Objects;\n import java.util.Optional;\n+import java.util.Vector;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n \n import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Inject;\n+import javax.xml.namespace.QName;\n \n+import elemental2.promise.IThenable;\n+import elemental2.promise.Promise;\n+import jsinterop.base.Js;\n+import org.appformer.kogito.bridge.client.resource.interop.ResourceListOptions;\n import org.guvnor.common.services.project.model.WorkspaceProject;\n+import org.kie.workbench.common.dmn.api.definition.model.ItemDefinition;\n+import org.kie.workbench.common.dmn.api.editors.included.DMNImportTypes;\n+import org.kie.workbench.common.dmn.api.editors.included.DMNIncludedModel;\n+import org.kie.workbench.common.dmn.api.editors.included.DMNIncludedNode;\n+import org.kie.workbench.common.dmn.api.editors.included.IncludedModel;\n import org.kie.workbench.common.dmn.api.editors.included.PMMLDocumentMetadata;\n+import org.kie.workbench.common.dmn.api.graph.DMNDiagramUtils;\n+import org.kie.workbench.common.dmn.webapp.kogito.common.client.converters.model.ImportedItemDefinitionPropertyConverter;\n+import org.kie.workbench.common.dmn.webapp.kogito.common.client.services.DMNClientDiagramServiceImpl;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDMNElement;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDRGElement;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDecision;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDefinitions;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITImport;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITInformationItem;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITInputData;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITInvocable;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITItemDefinition;\n+import org.kie.workbench.common.kogito.webapp.base.client.workarounds.KogitoResourceContentService;\n+import org.kie.workbench.common.stunner.core.client.service.ClientRuntimeError;\n+import org.kie.workbench.common.stunner.core.client.service.ServiceCallback;\n+import org.kie.workbench.common.stunner.core.diagram.Diagram;\n import org.kie.workbench.common.stunner.core.diagram.Metadata;\n+import org.kie.workbench.common.stunner.core.graph.Graph;\n+import org.kie.workbench.common.stunner.core.util.FileUtils;\n+import org.kie.workbench.common.stunner.core.util.StringUtils;\n import org.uberfire.backend.vfs.Path;\n+import org.uberfire.client.promise.Promises;\n+\n+import static org.kie.workbench.common.dmn.api.editors.types.BuiltInTypeUtils.isBuiltInType;\n+import static org.kie.workbench.common.dmn.webapp.kogito.common.client.converters.model.ImportedItemDefinitionPropertyConverter.withNamespace;\n \n @ApplicationScoped\n public class DMNMarshallerImportsHelperKogitoImpl implements DMNMarshallerImportsHelperKogito {\n \n+    private final KogitoResourceContentService contentService;\n+    private final DMNClientDiagramServiceImpl diagramService;\n+    private final Promises promises;\n+    private final DMNDiagramUtils diagramUtils;\n+    private final DMNIncludedNodeFactory includedModelFactory;\n+\n+    private static final Logger LOGGER = Logger.getLogger(DMNMarshallerImportsHelperKogitoImpl.class.getName());\n+    private static final String DMN_FILES_PATTERN = \"*.dmn\";\n+\n+    @Inject\n+    public DMNMarshallerImportsHelperKogitoImpl(final KogitoResourceContentService contentService,\n+                                                final DMNClientDiagramServiceImpl diagramService,\n+                                                final Promises promises,\n+                                                final DMNDiagramUtils diagramUtils,\n+                                                final DMNIncludedNodeFactory includedModelFactory) {\n+        this.contentService = contentService;\n+        this.diagramService = diagramService;\n+        this.promises = promises;\n+        this.diagramUtils = diagramUtils;\n+        this.includedModelFactory = includedModelFactory;\n+    }\n+\n+    @Override\n+    public Promise<Map<JSITImport, JSITDefinitions>> getImportDefinitionsAsync(final Metadata metadata,\n+                                                                               final List<JSITImport> imports) {\n+        if (!imports.isEmpty()) {\n+            return loadDMNDefinitions().then(otherDefinitions -> {\n+                final Map<JSITImport, JSITDefinitions> importDefinitions = new HashMap<>();\n+                for (final Map.Entry<String, JSITDefinitions> entry : otherDefinitions.entrySet()) {\n+                    final JSITDefinitions def = Js.uncheckedCast(entry.getValue());\n+                    findImportByDefinitions(def, imports).ifPresent(anImport -> {\n+                        final JSITImport foundImported = Js.uncheckedCast(anImport);\n+                        importDefinitions.put(foundImported, def);\n+                    });\n+                }\n+                return promises.resolve(importDefinitions);\n+            });\n+        }\n+        return promises.resolve(Collections.emptyMap());\n+    }\n+\n+    Promise<Map<String, JSITDefinitions>> loadDMNDefinitions() {\n+        return contentService.getFilteredItems(DMN_FILES_PATTERN, ResourceListOptions.assetFolder())\n+                .then(list -> {\n+                    if (list.length == 0) {\n+                        return promises.resolve(Collections.emptyMap());\n+                    } else {\n+                        final Map<String, JSITDefinitions> otherDefinitions = new ConcurrentHashMap<>();\n+                        return promises.all(Arrays.asList(list),\n+                                            (String file) -> loadDefinitionFromFile(file, otherDefinitions))\n+                                .then(v -> promises.resolve(otherDefinitions));\n+                    }\n+                });\n+    }\n+\n+    @Override\n+    public void loadNodesFromModels(final List<DMNIncludedModel> includedModels,\n+                                    final ServiceCallback<List<DMNIncludedNode>> callback) {\n+        final List<DMNIncludedNode> result = new Vector<>();\n+        if (includedModels.isEmpty()) {\n+            callback.onSuccess(result);\n+        } else {\n+            loadDMNDefinitions()\n+                    .then(existingDefinitions -> promises.all(includedModels, model -> loadNodes(existingDefinitions, model, result))\n+                            .then(p ->\n+                                  {\n+                                      callback.onSuccess(result);\n+                                      return promises.resolve();\n+                                  }));\n+        }\n+    }\n+\n+    private Promise loadNodes(final Map<String, JSITDefinitions> existingDefinitions,\n+                              final DMNIncludedModel model,\n+                              final List<DMNIncludedNode> result) {\n+        String filePath = \"\";\n+        for (final Map.Entry<String, JSITDefinitions> entry : existingDefinitions.entrySet()) {\n+            filePath = entry.getKey();\n+            final JSITDefinitions definitions = Js.uncheckedCast(entry.getValue());\n+            if (Objects.equals(model.getNamespace(), definitions.getNamespace())) {\n+                break;\n+            }\n+        }\n+        final String path = filePath;\n+        return contentService.loadFile(path)\n+                .then(content -> {\n+                    return promises.create((success, fail) -> {\n+                        diagramService.transform(content, new ServiceCallback<Diagram>() {\n+                            @Override\n+                            public void onSuccess(final Diagram item) {\n+                                final List<DMNIncludedNode> nodes = diagramUtils\n+                                        .getDRGElements(item)\n+                                        .stream()\n+                                        .map(node -> includedModelFactory.makeDMNIncludeNode(path, model, node))\n+                                        .collect(Collectors.toList());\n+                                result.addAll(nodes);\n+                                success.onInvoke(nodes);\n+                            }\n+\n+                            @Override\n+                            public void onError(final ClientRuntimeError error) {\n+                                LOGGER.log(Level.SEVERE, error.getMessage());\n+                                fail.onInvoke(error);\n+                            }\n+                        });\n+                    });\n+                });\n+    }\n+\n+    @Override\n+    public void loadModels(final ServiceCallback<List<IncludedModel>> callback) {\n+        final List<IncludedModel> models = new Vector<>();\n+        contentService.getFilteredItems(DMN_FILES_PATTERN, ResourceListOptions.assetFolder())\n+                .then(items -> promises.all(Arrays.asList(items), file -> contentService.loadFile(file).then(fileContent -> {\n+                    diagramService.transform(fileContent, new ServiceCallback<Diagram>() {\n+                        @Override\n+                        public void onSuccess(final Diagram item) {\n+                            final String modelPackage = \"\";\n+                            final Diagram<Graph, Metadata> diagram = (Diagram<Graph, Metadata>) item;\n+                            final String namespace = diagramUtils.getNamespace(diagram);\n+                            final String importType = DMNImportTypes.DMN.getDefaultNamespace();\n+                            final int drgElementCount = diagramUtils.getDRGElements(diagram).size();\n+                            final int itemDefinitionCount = diagramUtils.getDefinitions(diagram).getItemDefinition().size();\n+                            final String filename = FileUtils.getFileName(file);\n+                            models.add(new DMNIncludedModel(filename,\n+                                                            modelPackage,\n+                                                            filename,\n+                                                            namespace,\n+                                                            importType,\n+                                                            drgElementCount,\n+                                                            itemDefinitionCount));\n+                        }\n+\n+                        @Override\n+                        public void onError(final ClientRuntimeError error) {\n+                            LOGGER.log(Level.SEVERE, error.getMessage());\n+                        }\n+                    });\n+                    return promises.resolve();\n+                })).then(v -> {\n+                    callback.onSuccess(models);\n+                    return promises.resolve();\n+                }));\n+    }\n+\n+    Promise loadDefinitionFromFile(final String file,", "originalCommit": "87a45a256286505a43d3be92c60a66740c538740", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "79184b641a1fe162591f34809d717ff24b458823", "url": "https://github.com/kiegroup/kie-wb-common/commit/79184b641a1fe162591f34809d717ff24b458823", "message": "Tests.", "committedDate": "2020-06-04T20:26:01Z", "type": "commit"}, {"oid": "1b1db49415efff482c37eeb5b046cc120f5e4d6a", "url": "https://github.com/kiegroup/kie-wb-common/commit/1b1db49415efff482c37eeb5b046cc120f5e4d6a", "message": "Code review.", "committedDate": "2020-06-05T23:29:58Z", "type": "commit"}]}