{"pr_number": 8210, "pr_title": "Allow `git` material to honor a refSpec as the branch name", "pr_createdAt": "2020-06-03T02:08:24Z", "pr_url": "https://github.com/gocd/gocd/pull/8210", "timeline": [{"oid": "e469c5e79207d181edb5945556e51ffe57771f9d", "url": "https://github.com/gocd/gocd/commit/e469c5e79207d181edb5945556e51ffe57771f9d", "message": "wip", "committedDate": "2020-06-03T19:11:27Z", "type": "forcePushed"}, {"oid": "7b3589199cfab68b94331d6e6df5b6523a65d1d5", "url": "https://github.com/gocd/gocd/commit/7b3589199cfab68b94331d6e6df5b6523a65d1d5", "message": "wip", "committedDate": "2020-06-09T19:23:49Z", "type": "forcePushed"}, {"oid": "fa980050d35c252700226f05dc775e7035592220", "url": "https://github.com/gocd/gocd/commit/fa980050d35c252700226f05dc775e7035592220", "message": "wip", "committedDate": "2020-06-09T19:24:49Z", "type": "forcePushed"}, {"oid": "f379b8e4ee576ea880e3c8be807416badaa9cf02", "url": "https://github.com/gocd/gocd/commit/f379b8e4ee576ea880e3c8be807416badaa9cf02", "message": "wip2", "committedDate": "2020-06-11T01:30:44Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ5NTQ4Nw==", "url": "https://github.com/gocd/gocd/pull/8210#discussion_r438495487", "bodyText": "This is the heart of this change (adding convenience methods); the rest is IntelliJ IDEA regrouping private and protected methods together at the bottom.", "author": "marques-work", "createdAt": "2020-06-11T01:37:15Z", "path": "commandline/src/main/java/com/thoughtworks/go/util/command/CommandLine.java", "diffHunk": "@@ -319,6 +256,19 @@ public CommandLine withArgs(List<String> args) {\n         return this;\n     }\n \n+    public CommandLine when(boolean condition, Consumer<CommandLine> thenDo) {\n+        return this.tap((cmd) -> {\n+            if (condition) {\n+                thenDo.accept(cmd);\n+            }\n+        });\n+    }\n+\n+    public CommandLine tap(Consumer<CommandLine> thenDo) {\n+        thenDo.accept(this);\n+        return this;\n+    }\n+", "originalCommit": "f379b8e4ee576ea880e3c8be807416badaa9cf02", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA2NTg3Mw==", "url": "https://github.com/gocd/gocd/pull/8210#discussion_r453065873", "bodyText": "@marques-work thanks for adding comments around the actual changes. Another option to consider is having a separate commit only for things like regrouping/refactoring.", "author": "maheshp", "createdAt": "2020-07-10T20:37:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ5NTQ4Nw=="}], "type": "inlineReview"}, {"oid": "1772ef1fcc5ea380496e95b826081fa0ebcfd23d", "url": "https://github.com/gocd/gocd/commit/1772ef1fcc5ea380496e95b826081fa0ebcfd23d", "message": "wip2", "committedDate": "2020-06-11T01:38:25Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ5Njc4Ng==", "url": "https://github.com/gocd/gocd/pull/8210#discussion_r438496786", "bodyText": "Apologies for the messy diff;\nThe main bits here are adding the RefSpec and RefSpecIntegration @Nested tests. The rest is reorganizing the original tests under the @Nested class Integration {} tests.", "author": "marques-work", "createdAt": "2020-06-11T01:42:40Z", "path": "common/src/test/java/com/thoughtworks/go/domain/materials/git/GitCommandTest.java", "diffHunk": "@@ -25,777 +25,879 @@\n import com.thoughtworks.go.mail.SysOutStreamConsumer;\n import com.thoughtworks.go.util.DateUtils;\n import com.thoughtworks.go.util.FileUtil;\n+import com.thoughtworks.go.util.NamedProcessTag;\n import com.thoughtworks.go.util.command.*;\n import org.apache.commons.io.FileUtils;\n import org.apache.commons.io.IOUtils;\n import org.junit.Rule;\n import org.junit.contrib.java.lang.system.RestoreSystemProperties;\n import org.junit.jupiter.api.AfterEach;\n import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Nested;\n import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.io.TempDir;\n import org.junit.jupiter.migrationsupport.rules.EnableRuleMigrationSupport;\n-import org.junit.rules.ExpectedException;\n import org.junit.rules.TemporaryFolder;\n import org.junit.rules.TestRule;\n \n import java.io.File;\n import java.io.IOException;\n import java.io.InputStream;\n-import java.nio.charset.Charset;\n import java.util.*;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n \n import static com.thoughtworks.go.domain.materials.git.GitTestRepo.*;\n import static com.thoughtworks.go.util.DateUtils.parseRFC822;\n-import static com.thoughtworks.go.util.ReflectionUtil.getField;\n import static com.thoughtworks.go.util.command.ProcessOutputStreamConsumer.inMemoryConsumer;\n+import static java.lang.String.format;\n import static java.nio.charset.StandardCharsets.UTF_8;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.regex.Pattern.compile;\n+import static java.util.regex.Pattern.quote;\n import static org.apache.commons.io.filefilter.FileFilterUtils.*;\n import static org.apache.commons.lang3.time.DateUtils.addDays;\n import static org.apache.commons.lang3.time.DateUtils.setMilliseconds;\n-import static org.assertj.core.api.Assertions.*;\n-import static org.mockito.MockitoAnnotations.initMocks;\n+import static org.junit.jupiter.api.Assertions.*;\n \n-@EnableRuleMigrationSupport\n public class GitCommandTest {\n-    private static final String BRANCH = \"foo\";\n-    private static final String SUBMODULE = \"submodule-1\";\n-\n-    private GitCommand git;\n-    private String repoUrl;\n-    private File repoLocation;\n-    private static final Date THREE_DAYS_FROM_NOW = setMilliseconds(addDays(new Date(), 3), 0);\n-    private GitTestRepo gitRepo;\n-    private File gitLocalRepoDir;\n-    private GitTestRepo gitFooBranchBundle;\n-\n-    @Rule\n-    public final TemporaryFolder temporaryFolder = new TemporaryFolder();\n-\n-    @Rule\n-    public final TestRule restoreSystemProperties = new RestoreSystemProperties();\n-\n-    @Rule\n-    public final ExpectedException expectedException = ExpectedException.none();\n-\n-    @BeforeEach\n-    void setup() throws Exception {\n-        gitRepo = new GitTestRepo(temporaryFolder);\n-        gitLocalRepoDir = createTempWorkingDirectory();\n-        git = new GitCommand(null, gitLocalRepoDir, GitMaterialConfig.DEFAULT_BRANCH, false, null);\n-        repoLocation = gitRepo.gitRepository();\n-        repoUrl = gitRepo.projectRepositoryUrl();\n-        InMemoryStreamConsumer outputStreamConsumer = inMemoryConsumer();\n-        int returnCode = git.cloneWithNoCheckout(outputStreamConsumer, repoUrl);\n-        if (returnCode > 0) {\n-            fail(outputStreamConsumer.getAllOutput());\n-        }\n-        gitFooBranchBundle = GitTestRepo.testRepoAtBranch(GIT_FOO_BRANCH_BUNDLE, BRANCH, temporaryFolder);\n-        initMocks(this);\n-    }\n+    private static GitCommand withBranch(String branch) {\n+        return new GitCommand(null, null, branch, false, null);\n+    }\n+\n+    private static GitCommand withBranch(String branch, File cwd) {\n+        return new GitCommand(null, cwd, branch, false, null);\n+    }\n+\n+    @Nested\n+    class RefSpec {", "originalCommit": "1772ef1fcc5ea380496e95b826081fa0ebcfd23d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ5NzQxNw==", "url": "https://github.com/gocd/gocd/pull/8210#discussion_r438497417", "bodyText": "Most of the changes here are IntelliJ IDEA cleanup; grouping non-public methods at the bottom and inlining some unchanging parameters.\nKeep scrolling for the main bits; I'll call out what the essence of this file's changes are.", "author": "marques-work", "createdAt": "2020-06-11T01:44:58Z", "path": "domain/src/main/java/com/thoughtworks/go/config/materials/git/GitMaterial.java", "diffHunk": "@@ -199,95 +185,6 @@ public ValidationBean handleException(Exception e, GitVersion gitVersion) {\n         }\n     }\n \n-    private GitCommand getGit(File workingdir, int preferredCloneDepth, SubprocessExecutionContext executionContext) {", "originalCommit": "1772ef1fcc5ea380496e95b826081fa0ebcfd23d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ5ODA0MA==", "url": "https://github.com/gocd/gocd/pull/8210#discussion_r438498040", "bodyText": "Renamed only the field so it's clear what it really points to and how it should be interpreted/treated. Did not rename the getter for fear of changing serialization or something.", "author": "marques-work", "createdAt": "2020-06-11T01:47:33Z", "path": "domain/src/main/java/com/thoughtworks/go/config/materials/git/GitMaterial.java", "diffHunk": "@@ -50,20 +51,18 @@\n import static org.apache.commons.lang3.StringUtils.isBlank;\n \n public class GitMaterial extends ScmMaterial implements PasswordAwareMaterial {\n-    private static final Logger LOG = LoggerFactory.getLogger(GitMaterial.class);\n     public static final int UNSHALLOW_TRYOUT_STEP = 100;\n     public static final int DEFAULT_SHALLOW_CLONE_DEPTH = 2;\n     public static final String GO_MATERIAL_BRANCH = \"GO_MATERIAL_BRANCH\";\n-\n-    private UrlArgument url;\n-    private String branch = GitMaterialConfig.DEFAULT_BRANCH;\n-    private boolean shallowClone = false;\n-    private String submoduleFolder;\n-\n     //TODO: use iBatis to set the type for us, and we can get rid of this field.\n     public static final String TYPE = \"GitMaterial\";\n-    private static final String ERR_GIT_NOT_FOUND = \"Failed to find 'git' on your PATH. Please ensure 'git' is executable by the Go Server and on the Go Agents where this material will be used.\";\n     public static final String ERR_GIT_OLD_VERSION = \"Please install Git-core 1.6 or above. \";\n+    private static final Logger LOG = LoggerFactory.getLogger(GitMaterial.class);\n+    private static final String ERR_GIT_NOT_FOUND = \"Failed to find 'git' on your PATH. Please ensure 'git' is executable by the Go Server and on the Go Agents where this material will be used.\";\n+    private final UrlArgument url;\n+    private String refSpecOrBranch = GitMaterialConfig.DEFAULT_BRANCH;", "originalCommit": "1772ef1fcc5ea380496e95b826081fa0ebcfd23d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ5ODY5MQ==", "url": "https://github.com/gocd/gocd/pull/8210#discussion_r438498691", "bodyText": "One of the main bits changed here; it's important to return the local branch name and not the raw refspec. The comparison that references this expects this to be a real branch name.", "author": "marques-work", "createdAt": "2020-06-11T01:49:51Z", "path": "domain/src/main/java/com/thoughtworks/go/config/materials/git/GitMaterial.java", "diffHunk": "@@ -443,13 +314,136 @@ public GitMaterial withShallowClone(boolean value) {\n         return gitMaterial;\n     }\n \n-    public String branchWithDefault() {\n-        return isBlank(branch) ? GitMaterialConfig.DEFAULT_BRANCH : branch;\n+    public String effectiveLocalBranch() {\n+        return localBranch(isBlank(refSpecOrBranch) ? GitMaterialConfig.DEFAULT_BRANCH : refSpecOrBranch);\n+    }", "originalCommit": "1772ef1fcc5ea380496e95b826081fa0ebcfd23d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "15947872ae7ecd0e2db1ff30b861776551dc3cc8", "url": "https://github.com/gocd/gocd/commit/15947872ae7ecd0e2db1ff30b861776551dc3cc8", "message": "wip2", "committedDate": "2020-06-11T09:43:20Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODcxNDUzMA==", "url": "https://github.com/gocd/gocd/pull/8210#discussion_r438714530", "bodyText": "This is the last main bit (isRemoteFetchConfigEqual() \u261d\ud83c\udffc); essentially, we should verify that the fetch configuration is equivalent as well when testing isRepositoryChanged().", "author": "marques-work", "createdAt": "2020-06-11T11:21:04Z", "path": "domain/src/main/java/com/thoughtworks/go/config/materials/git/GitMaterial.java", "diffHunk": "@@ -443,13 +314,136 @@ public GitMaterial withShallowClone(boolean value) {\n         return gitMaterial;\n     }\n \n-    public String branchWithDefault() {\n-        return isBlank(branch) ? GitMaterialConfig.DEFAULT_BRANCH : branch;\n+    public String effectiveLocalBranch() {\n+        return localBranch(isBlank(refSpecOrBranch) ? GitMaterialConfig.DEFAULT_BRANCH : refSpecOrBranch);\n+    }\n+\n+    @Override\n+    protected void appendCriteria(Map<String, Object> parameters) {\n+        parameters.put(ScmMaterialConfig.URL, url.originalArgument());\n+        parameters.put(\"branch\", refSpecOrBranch);\n+    }\n+\n+    @Override\n+    protected void appendAttributes(Map<String, Object> parameters) {\n+        parameters.put(\"url\", url);\n+        parameters.put(\"branch\", refSpecOrBranch);\n+        parameters.put(\"shallowClone\", shallowClone);\n+    }\n+\n+    @Override\n+    protected String getLocation() {\n+        return url.forDisplay();\n     }\n \n     @Override\n     protected void setGoMaterialVariables(EnvironmentVariableContext environmentVariableContext) {\n         super.setGoMaterialVariables(environmentVariableContext);\n-        setVariableWithName(environmentVariableContext, branchWithDefault(), GO_MATERIAL_BRANCH);\n+        setVariableWithName(environmentVariableContext, effectiveLocalBranch(), GO_MATERIAL_BRANCH);\n+    }\n+\n+    private GitCommand getGit(File workingdir, SubprocessExecutionContext executionContext) {\n+        InMemoryStreamConsumer output = inMemoryConsumer();\n+        try {\n+            return git(output, workingdir, DEFAULT_SHALLOW_CLONE_DEPTH, executionContext);\n+        } catch (Exception e) {\n+            throw bomb(e.getMessage() + \" \" + output.getStdError(), e);\n+        }\n+    }\n+\n+    private GitCommand git(ConsoleOutputStreamConsumer outputStreamConsumer, final File workingFolder, int preferredCloneDepth, SubprocessExecutionContext executionContext) throws Exception {\n+        if (isSubmoduleFolder()) {\n+            return new GitCommand(getFingerprint(), new File(workingFolder.getPath()), GitMaterialConfig.DEFAULT_BRANCH, true, secrets());\n+        }\n+        System.out.printf(\"**** [%s] WorkingDir for %s: %s\\n\", executionContext.isServer() ? \"server\" : \"agent\", urlForCommandLine(), workingFolder.getPath());\n+        GitCommand gitCommand = new GitCommand(getFingerprint(), workingFolder, refSpecOrBranch, false, secrets());\n+        if (!isGitRepository(workingFolder) || isRepositoryChanged(gitCommand, workingFolder)) {\n+            LOG.debug(\"Invalid git working copy or repository changed. Delete folder: {}\", workingFolder);\n+            deleteDirectoryNoisily(workingFolder);\n+        }\n+        createParentFolderIfNotExist(workingFolder);\n+        if (!workingFolder.exists()) {\n+            TransactionSynchronizationManager txManager = new TransactionSynchronizationManager();\n+            if (txManager.isActualTransactionActive()) {\n+                txManager.registerSynchronization(new TransactionSynchronizationAdapter() {\n+                    @Override\n+                    public void afterCompletion(int status) {\n+                        if (status != TransactionSynchronization.STATUS_COMMITTED) {\n+                            FileUtils.deleteQuietly(workingFolder);\n+                        }\n+                    }\n+                });\n+            }\n+            int cloneDepth = shallowClone ? preferredCloneDepth : Integer.MAX_VALUE;\n+            int returnValue;\n+            if (executionContext.isServer()) {\n+                returnValue = gitCommand.cloneWithNoCheckout(outputStreamConsumer, urlForCommandLine());\n+            } else {\n+                returnValue = gitCommand.clone(outputStreamConsumer, urlForCommandLine(), cloneDepth);\n+            }\n+            bombIfFailedToRunCommandLine(returnValue, \"Failed to run git clone command\");\n+        }\n+        return gitCommand;\n+    }\n+\n+    private List<SecretString> secrets() {\n+        SecretString secretSubstitution = line -> line.replace(urlForCommandLine(), getUriForDisplay());\n+        return Collections.singletonList(secretSubstitution);\n+    }\n+\n+    // Unshallow local repo to include a revision operating on via two step process:\n+    // First try to fetch forward 100 level with \"git fetch -depth 100\". If revision still missing,\n+    // unshallow the whole repo with \"git fetch --2147483647\".\n+    private void unshallowIfNeeded(GitCommand gitCommand, ConsoleOutputStreamConsumer streamConsumer, Revision revision) {\n+        if (gitCommand.isShallow() && !gitCommand.containsRevisionInBranch(revision)) {\n+            gitCommand.unshallow(streamConsumer, UNSHALLOW_TRYOUT_STEP);\n+\n+            if (gitCommand.isShallow() && !gitCommand.containsRevisionInBranch(revision)) {\n+                fullyUnshallow(gitCommand, streamConsumer);\n+            }\n+        }\n+    }\n+\n+    private void fullyUnshallow(GitCommand gitCommand, ConsoleOutputStreamConsumer streamConsumer) {\n+        if (gitCommand.isShallow()) {\n+            gitCommand.unshallow(streamConsumer, Integer.MAX_VALUE);\n+        }\n+    }\n+\n+    private boolean isSubmoduleFolder() {\n+        return getSubmoduleFolder() != null;\n+    }\n+\n+    private boolean isGitRepository(File workingFolder) {\n+        return new File(workingFolder, \".git\").isDirectory();\n+    }\n+\n+    private boolean isRepositoryChanged(GitCommand command, File workingDirectory) {\n+        UrlArgument currentWorkingUrl = command.workingRepositoryUrl();\n+        LOG.trace(\"Current repository url of [{}]: {}\", workingDirectory, currentWorkingUrl);\n+        LOG.trace(\"Target repository url: {}\", url);\n+        return !MaterialUrl.sameUrl(url.forDisplay(), currentWorkingUrl.forDisplay())\n+                || !isRemoteFetchConfigEqual(command)\n+                || !isBranchEqual(command)\n+                || (!shallowClone && command.isShallow());\n+    }\n+\n+    private boolean isRemoteFetchConfigEqual(GitCommand command) {\n+        if (command.hasRefSpec()) {\n+            try {\n+                return (\"+\" + command.expandRefSpec()).equals(command.getConfigValue(\"remote.origin.fetch\"));\n+            } catch (Throwable ignored) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }", "originalCommit": "15947872ae7ecd0e2db1ff30b861776551dc3cc8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODcxNjAxOQ==", "url": "https://github.com/gocd/gocd/pull/8210#discussion_r438716019", "bodyText": "This is just some refactoring to get rid of GitCommand#pull(), which was a @TestOnly method. The rest is IDEA cleanup/method re-org. This is the only method I removed because I got too lazy to factor out the other @TestOnly methods. I also figured that effort is best saved for a separate PR.", "author": "marques-work", "createdAt": "2020-06-11T11:24:17Z", "path": "domain/src/test/java/com/thoughtworks/go/helper/GitRepoContainingSubmodule.java", "diffHunk": "@@ -131,7 +97,9 @@ public String projectRepositoryUrl() {\n         changeFile(remoteSubmoduleRepoLocation, fileName, newContentOfFile);\n         checkInOneFile(remoteSubmoduleRepoLocation, new File(fileName), comment);\n \n-        git(new File(remoteRepoDir, submoduleNameInRepo)).pull();\n+        CommandLine.createCommandLine(\"git\").withEncoding(\"UTF-8\").withArg(\"pull\").\n+                withWorkingDir(new File(remoteRepoDir, submoduleNameInRepo)).\n+                runOrBomb(new MaterialFingerprintTag(null));", "originalCommit": "15947872ae7ecd0e2db1ff30b861776551dc3cc8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODcxNzgwMw==", "url": "https://github.com/gocd/gocd/pull/8210#discussion_r438717803", "bodyText": "This and clone() are the main changes here (other parts are IDEA cleanup). Cloning to accommodate for refspecs is a multi-step process involving manually configuring fetch behavior and explicit branch creation and switching.", "author": "marques-work", "createdAt": "2020-06-11T11:28:13Z", "path": "domain/src/main/java/com/thoughtworks/go/domain/materials/git/GitCommand.java", "diffHunk": "@@ -56,95 +59,97 @@ public GitCommand(String materialFingerprint, File workingDir, String branch, bo\n         super(materialFingerprint);\n         this.workingDir = workingDir;\n         this.secrets = secrets != null ? secrets : new ArrayList<>();\n-        this.branch = StringUtils.isBlank(branch) ? GitMaterialConfig.DEFAULT_BRANCH : branch;\n+        this.branch = StringUtils.defaultIfBlank(branch, GitMaterialConfig.DEFAULT_BRANCH);\n         this.isSubmodule = isSubmodule;\n     }\n \n-    public int cloneWithNoCheckout(ConsoleOutputStreamConsumer outputStreamConsumer, String url) {\n-        CommandLine gitClone = cloneCommand().withArg(\"--no-checkout\");\n-\n-        gitClone.withArg(new UrlArgument(url)).withArg(workingDir.getAbsolutePath());\n+    private static boolean hasExactlyOneMatchingBranch(ConsoleResult branchList) {\n+        return branchList.output().size() == 1;\n+    }\n \n-        return run(gitClone, outputStreamConsumer);\n+    public String localBranch() {\n+        return RefSpecHelper.localBranch(branch);\n     }\n \n-    public int clone(ConsoleOutputStreamConsumer outputStreamConsumer, String url) {\n-        return clone(outputStreamConsumer, url, Integer.MAX_VALUE);\n+    public String remoteBranch() {\n+        return RefSpecHelper.remoteBranch(branch);\n     }\n \n-    // Clone repository from url with specified depth.\n-    // Special depth 2147483647 (Integer.MAX_VALUE) are treated as full clone\n-    public int clone(ConsoleOutputStreamConsumer outputStreamConsumer, String url, Integer depth) {\n-        CommandLine gitClone = cloneCommand();\n+    public String fullUpstreamRef() {\n+        return RefSpecHelper.fullUpstreamRef(branch);\n+    }\n \n-        if (depth < Integer.MAX_VALUE) {\n-            gitClone.withArg(String.format(\"--depth=%s\", depth));\n-        }\n-        gitClone.withArg(new UrlArgument(url)).withArg(workingDir.getAbsolutePath());\n+    public String expandRefSpec() {\n+        return RefSpecHelper.expandRefSpec(branch);\n+    }\n \n-        return run(gitClone, outputStreamConsumer);\n+    public boolean hasRefSpec() {\n+        return RefSpecHelper.hasRefSpec(branch);\n     }\n \n-    private CommandLine cloneCommand() {\n-        return git()\n-                .withArg(\"clone\")\n-                .withArg(String.format(\"--branch=%s\", branch));\n+    public String getConfigValue(String key) {\n+        return runOrBomb(git_C().withArgs(\"config\", \"--get-all\", key)).outputAsString();\n     }\n \n-    public List<Modification> latestModification() {\n-        return gitLog(\"-1\", \"--date=iso\", \"--no-decorate\", \"--pretty=medium\", \"--no-color\", remoteBranch());\n+    public int cloneWithNoCheckout(ConsoleOutputStreamConsumer outputStreamConsumer, String url) {\n+        CommandLine gitClone = cloneCommand().\n+                when(!hasRefSpec(), git -> git.withArgs(\"--branch\", branch)).\n+                withArg(\"--no-checkout\").\n+                withArg(new UrlArgument(url)).\n+                withArg(workingDir.getAbsolutePath());\n+\n+        if (!hasRefSpec()) {\n+            return run(gitClone, outputStreamConsumer);\n+        }\n+\n+        final String abbrevBranch = localBranch();\n+        final String fullLocalRef = abbrevBranch.startsWith(\"refs/\") ? abbrevBranch : REFS_HEADS + abbrevBranch;\n \n+        return runCascade(outputStreamConsumer,\n+                gitClone,\n+                git_C().withArgs(\"config\", \"--replace-all\", \"remote.origin.fetch\", \"+\" + expandRefSpec()),\n+                git_C().withArgs(\"fetch\", \"--prune\", \"--recurse-submodules=no\"),\n+                // Important to create a \"real\" local branch and not just use `symbolic-ref`\n+                // to update HEAD in order to ensure that GitMaterial#isBranchEqual() passes;\n+                // failing this check will cause the working directory to be obliterated and we\n+                // will re-clone the given repository every time. Yikes!\n+                git_C().withArgs(\"branch\", \"-f\", abbrevBranch, remoteBranch()),\n+                git_C().withArgs(\"symbolic-ref\", \"HEAD\", fullLocalRef)\n+        );", "originalCommit": "15947872ae7ecd0e2db1ff30b861776551dc3cc8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODcxNzkzMQ==", "url": "https://github.com/gocd/gocd/pull/8210#discussion_r438717931", "bodyText": "Main changes in clone()", "author": "marques-work", "createdAt": "2020-06-11T11:28:35Z", "path": "domain/src/main/java/com/thoughtworks/go/domain/materials/git/GitCommand.java", "diffHunk": "@@ -56,95 +59,97 @@ public GitCommand(String materialFingerprint, File workingDir, String branch, bo\n         super(materialFingerprint);\n         this.workingDir = workingDir;\n         this.secrets = secrets != null ? secrets : new ArrayList<>();\n-        this.branch = StringUtils.isBlank(branch) ? GitMaterialConfig.DEFAULT_BRANCH : branch;\n+        this.branch = StringUtils.defaultIfBlank(branch, GitMaterialConfig.DEFAULT_BRANCH);\n         this.isSubmodule = isSubmodule;\n     }\n \n-    public int cloneWithNoCheckout(ConsoleOutputStreamConsumer outputStreamConsumer, String url) {\n-        CommandLine gitClone = cloneCommand().withArg(\"--no-checkout\");\n-\n-        gitClone.withArg(new UrlArgument(url)).withArg(workingDir.getAbsolutePath());\n+    private static boolean hasExactlyOneMatchingBranch(ConsoleResult branchList) {\n+        return branchList.output().size() == 1;\n+    }\n \n-        return run(gitClone, outputStreamConsumer);\n+    public String localBranch() {\n+        return RefSpecHelper.localBranch(branch);\n     }\n \n-    public int clone(ConsoleOutputStreamConsumer outputStreamConsumer, String url) {\n-        return clone(outputStreamConsumer, url, Integer.MAX_VALUE);\n+    public String remoteBranch() {\n+        return RefSpecHelper.remoteBranch(branch);\n     }\n \n-    // Clone repository from url with specified depth.\n-    // Special depth 2147483647 (Integer.MAX_VALUE) are treated as full clone\n-    public int clone(ConsoleOutputStreamConsumer outputStreamConsumer, String url, Integer depth) {\n-        CommandLine gitClone = cloneCommand();\n+    public String fullUpstreamRef() {\n+        return RefSpecHelper.fullUpstreamRef(branch);\n+    }\n \n-        if (depth < Integer.MAX_VALUE) {\n-            gitClone.withArg(String.format(\"--depth=%s\", depth));\n-        }\n-        gitClone.withArg(new UrlArgument(url)).withArg(workingDir.getAbsolutePath());\n+    public String expandRefSpec() {\n+        return RefSpecHelper.expandRefSpec(branch);\n+    }\n \n-        return run(gitClone, outputStreamConsumer);\n+    public boolean hasRefSpec() {\n+        return RefSpecHelper.hasRefSpec(branch);\n     }\n \n-    private CommandLine cloneCommand() {\n-        return git()\n-                .withArg(\"clone\")\n-                .withArg(String.format(\"--branch=%s\", branch));\n+    public String getConfigValue(String key) {\n+        return runOrBomb(git_C().withArgs(\"config\", \"--get-all\", key)).outputAsString();\n     }\n \n-    public List<Modification> latestModification() {\n-        return gitLog(\"-1\", \"--date=iso\", \"--no-decorate\", \"--pretty=medium\", \"--no-color\", remoteBranch());\n+    public int cloneWithNoCheckout(ConsoleOutputStreamConsumer outputStreamConsumer, String url) {\n+        CommandLine gitClone = cloneCommand().\n+                when(!hasRefSpec(), git -> git.withArgs(\"--branch\", branch)).\n+                withArg(\"--no-checkout\").\n+                withArg(new UrlArgument(url)).\n+                withArg(workingDir.getAbsolutePath());\n+\n+        if (!hasRefSpec()) {\n+            return run(gitClone, outputStreamConsumer);\n+        }\n+\n+        final String abbrevBranch = localBranch();\n+        final String fullLocalRef = abbrevBranch.startsWith(\"refs/\") ? abbrevBranch : REFS_HEADS + abbrevBranch;\n \n+        return runCascade(outputStreamConsumer,\n+                gitClone,\n+                git_C().withArgs(\"config\", \"--replace-all\", \"remote.origin.fetch\", \"+\" + expandRefSpec()),\n+                git_C().withArgs(\"fetch\", \"--prune\", \"--recurse-submodules=no\"),\n+                // Important to create a \"real\" local branch and not just use `symbolic-ref`\n+                // to update HEAD in order to ensure that GitMaterial#isBranchEqual() passes;\n+                // failing this check will cause the working directory to be obliterated and we\n+                // will re-clone the given repository every time. Yikes!\n+                git_C().withArgs(\"branch\", \"-f\", abbrevBranch, remoteBranch()),\n+                git_C().withArgs(\"symbolic-ref\", \"HEAD\", fullLocalRef)\n+        );\n     }\n \n-    public List<Modification> modificationsSince(Revision revision) {\n-        return gitLog(\"--date=iso\", \"--pretty=medium\", \"--no-decorate\", \"--no-color\", String.format(\"%s..%s\", revision.getRevision(), remoteBranch()));\n+    @TestOnly\n+    public int clone(ConsoleOutputStreamConsumer outputStreamConsumer, String url) {\n+        return clone(outputStreamConsumer, url, Integer.MAX_VALUE);\n     }\n \n-    private List<Modification> gitLog(String... args) {\n-        // Git log will only show changes before the currently checked out revision\n-        InMemoryStreamConsumer outputStreamConsumer = inMemoryConsumer();\n+    // Clone repository from url with specified depth.\n+    // Special depth 2147483647 (Integer.MAX_VALUE) are treated as full clone\n+    public int clone(ConsoleOutputStreamConsumer outputStreamConsumer, String url, Integer depth) {\n+        CommandLine gitClone = cloneCommand().\n+                when(!hasRefSpec(), git -> git.withArgs(\"--branch\", branch)).\n+                when(depth < Integer.MAX_VALUE, git -> git.withArg(format(\"--depth=%s\", depth))).\n+                withArg(new UrlArgument(url)).withArg(workingDir.getAbsolutePath());\n \n-        try {\n-            if (!isSubmodule) {\n-                fetch(outputStreamConsumer);\n-            }\n-        } catch (Exception e) {\n-            throw new RuntimeException(String.format(\"Working directory: %s\\n%s\", workingDir, outputStreamConsumer.getStdError()), e);\n+        if (!hasRefSpec()) {\n+            return run(gitClone, outputStreamConsumer);\n         }\n \n-        CommandLine gitCmd = git().withArg(\"log\").withArgs(args).withWorkingDir(workingDir);\n-        ConsoleResult result = runOrBomb(gitCmd);\n-\n-        GitModificationParser parser = new GitModificationParser();\n-        List<Modification> mods = parser.parse(result.output());\n-        for (Modification mod : mods) {\n-            addModifiedFiles(mod);\n-        }\n-        return mods;\n+        return runCascade(outputStreamConsumer,\n+                gitClone,\n+                git_C().withArgs(\"config\", \"--replace-all\", \"remote.origin.fetch\", \"+\" + expandRefSpec()),\n+                git_C().withArgs(\"fetch\", \"--prune\", \"--recurse-submodules=no\"),\n+                git_C().withArgs(\"checkout\", \"-B\", localBranch(), remoteBranch())\n+        );", "originalCommit": "15947872ae7ecd0e2db1ff30b861776551dc3cc8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODcxODc0Mw==", "url": "https://github.com/gocd/gocd/pull/8210#discussion_r438718743", "bodyText": "Adding this just makes for concise multi-step command invocations.", "author": "marques-work", "createdAt": "2020-06-11T11:30:36Z", "path": "domain/src/main/java/com/thoughtworks/go/domain/materials/SCMCommand.java", "diffHunk": "@@ -30,15 +30,39 @@ public SCMCommand(String materialFingerprint) {\n         this.materialFingerprint = materialFingerprint;\n     }\n \n-    protected int run(CommandLine commandLine, ConsoleOutputStreamConsumer outputStreamConsumer, String... input) {\n-        return commandLine.run(outputStreamConsumer, new MaterialFingerprintTag(materialFingerprint), input);\n-    }\n-\n     public ConsoleResult runOrBomb(CommandLine commandLine, boolean failOnNonZeroReturn, String... input) {\n         return commandLine.runOrBomb(failOnNonZeroReturn, new MaterialFingerprintTag(materialFingerprint), input);\n     }\n \n     public ConsoleResult runOrBomb(CommandLine commandLine, String... input) {\n         return commandLine.runOrBomb(new MaterialFingerprintTag(materialFingerprint), input);\n     }\n+\n+    protected int run(CommandLine commandLine, ConsoleOutputStreamConsumer outputStreamConsumer, String... input) {\n+        return commandLine.run(outputStreamConsumer, new MaterialFingerprintTag(materialFingerprint), input);\n+    }\n+\n+    /**\n+     * Conveniently runs commands sequentially on a given console, aborting on the first failure.\n+     *\n+     * @param console  collects console output\n+     * @param commands the set of sequential commands\n+     * @return the exit status of the last executed command\n+     */\n+    protected int runCascade(ConsoleOutputStreamConsumer console, CommandLine... commands) {\n+        int code = 0;\n+\n+        // Doing this via streams is awkward; it's hard to *both* collect the return code\n+        // *AND* exit iteration early. Curse Java for only giving us fake closures!\n+        //\n+        // My un-amusement is \"effectively final\" \ud83d\ude12.\n+        for (CommandLine cmd : commands) {\n+            code = run(cmd, console);\n+            if (0 != code) {\n+                break;\n+            }\n+        }\n+\n+        return code;\n+    }", "originalCommit": "15947872ae7ecd0e2db1ff30b861776551dc3cc8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODcyMTE2Ng==", "url": "https://github.com/gocd/gocd/pull/8210#discussion_r438721166", "bodyText": "This util class handles all the logic to extract meaningful source and destination refs from refspecs, as well as defaulting to old behaviors when provided just a plain branch.\nThis util class exists because the logic is shared between GitMaterial and GitCommand.", "author": "marques-work", "createdAt": "2020-06-11T11:36:21Z", "path": "domain/src/main/java/com/thoughtworks/go/domain/materials/git/RefSpecHelper.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Copyright 2020 ThoughtWorks, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.thoughtworks.go.domain.materials.git;\n+\n+import com.thoughtworks.go.util.command.UrlArgument;\n+\n+public class RefSpecHelper {", "originalCommit": "15947872ae7ecd0e2db1ff30b861776551dc3cc8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "55fcb11c514f73dba198e8a8be9227ab1430d07e", "url": "https://github.com/gocd/gocd/commit/55fcb11c514f73dba198e8a8be9227ab1430d07e", "message": "Git materials can checkout arbitrary refs\n\n  - GoCD's `git` layer knows how to handle refspecs provided in the branch field.\n  - Refspecs are assumed to be a non-wildcard; wildcards have not been tested\n    and aren't meaningful to the intent of use (i.e., updating a local agent\n    workspace).\n  - The main motivation behind this is to allow GoCD to support pull request\n    refs as a pipeline material for the branch support work.\n\nImplementation notes\n--------------------\n\n`RefSpecHelper` handles detection and parsing of a given branch or refspec. Mainly,\nthis utility class extracts source and destination components of the refspec and\nbuilds sensible values for local branch names and remote branch names. Also notably,\nit infers a full destination ref from a shorthand refspec. The logic for this is\nstraightforward:\n\n1. When given a shorthand refspec in the form: `refs/namespace/foo:bar`\n    - the refspec destination is expanded under the `origin` remote as\n      `refs/namespace/foo:refs/remotes/origin/bar`.\n\n2. When given a full refspec in the form: `refs/namespace/foo:refs/anything/bar`\n    - the refspec is interpreted as-is.\n\n`GitCommand#clone()` and `GitCommand#cloneWithNoCheckout()` have been adapted to\naccommodate refspecs; when a refspec is detected, the clone behaviors configure\nthe `git-fetch` configurations with the refspec instead of the implicit/default\n`+refs/heads/*:refs/remotes/origin/*` so that future `git fetch` operations update\nthe correct refs. This ensures that flyweights and agent sandboxes receive new\ncommits. The local branch is also explicitly created before switching the local\nrepo `HEAD` pointer.\n\n`GitMaterial` is also refspec aware and knows how to report the local branch name\nfrom the given refspec. Additionally, `GitMaterial#isRepositoryChanged()` performs\nadditional validation on the fetch configuration before reusing (or re-cloning) a\nflyweight or agent sandbox for a given material.\n\n`GitCommand` and `GitMaterial` delegate to `RefSpecHelper` for the detection and\ninterpretation of refspecs.\n\nThere were also some convenience methods added to `SCMCommand` and `CommandLine`\nin addition to miscellaneous code formatting, cleanup, and reorganization.", "committedDate": "2020-06-12T02:24:54Z", "type": "forcePushed"}, {"oid": "cc15f6098806685d3dae7c97d0a4e4364b59009d", "url": "https://github.com/gocd/gocd/commit/cc15f6098806685d3dae7c97d0a4e4364b59009d", "message": "wip", "committedDate": "2020-07-01T22:13:11Z", "type": "forcePushed"}, {"oid": "e1d97eaa46f8f3006c922c7b257cc4c85323291e", "url": "https://github.com/gocd/gocd/commit/e1d97eaa46f8f3006c922c7b257cc4c85323291e", "message": "wip", "committedDate": "2020-07-01T23:12:29Z", "type": "forcePushed"}, {"oid": "22db5320e1cd398cc87a47438bb8525e572a6dc2", "url": "https://github.com/gocd/gocd/commit/22db5320e1cd398cc87a47438bb8525e572a6dc2", "message": "wip", "committedDate": "2020-07-01T23:18:46Z", "type": "forcePushed"}, {"oid": "33f1376933b88a8f148ccbdbeea3199cb2984367", "url": "https://github.com/gocd/gocd/commit/33f1376933b88a8f148ccbdbeea3199cb2984367", "message": "Git materials can checkout arbitrary refs\n\n  - GoCD's `git` layer knows how to handle refspecs provided in the branch field.\n  - Refspecs _**must NOT**_ contain wildcards; they are not meaningful to how GoCD\n    will use materials (i.e., updating a local agent workspace).\n  - The main motivation behind this is to allow GoCD to support pull request\n    refs as a pipeline material for the branch support work.\n\nImplementation notes\n--------------------\n\n`RefSpecHelper` handles detection and parsing of a given branch or refspec. Mainly,\nthis utility class extracts source and destination components of the refspec and\nbuilds sensible values for local branch names and remote branch names. Also notably,\nit infers a full destination ref from a shorthand refspec. The logic for this is\nstraightforward:\n\n1. When given a shorthand refspec in the form: `refs/namespace/foo:bar`\n    - the refspec destination is expanded under the `origin` remote as\n      `refs/namespace/foo:refs/remotes/origin/bar`.\n\n2. When given a full refspec in the form: `refs/namespace/foo:refs/anything/bar`\n    - the refspec is interpreted as-is.\n\n`GitCommand#clone()` and `GitCommand#cloneWithNoCheckout()` have been adapted to\naccommodate refspecs; when a refspec is detected, the clone behaviors configure\nthe `git-fetch` configurations with the refspec instead of the implicit/default\n`+refs/heads/*:refs/remotes/origin/*` so that future `git fetch` operations update\nthe correct refs. This ensures that flyweights and agent sandboxes receive new\ncommits. The local branch is also explicitly created before switching the local\nrepo `HEAD` pointer.\n\n`GitMaterial` is also refspec aware and knows how to report the local branch name\nfrom the given refspec. Additionally, `GitMaterial#isRepositoryChanged()` performs\nadditional validation on the fetch configuration before reusing (or re-cloning) a\nflyweight or agent sandbox for a given material.\n\n`GitCommand` and `GitMaterial` delegate to `RefSpecHelper` for the detection and\ninterpretation of refspecs.\n\nThere were also some convenience methods added to `SCMCommand` and `CommandLine`\nin addition to miscellaneous code formatting, cleanup, and reorganization.", "committedDate": "2020-07-02T22:19:47Z", "type": "forcePushed"}, {"oid": "e325885e47e8fefc197be987889e3e8fc5460ded", "url": "https://github.com/gocd/gocd/commit/e325885e47e8fefc197be987889e3e8fc5460ded", "message": "Git materials can checkout arbitrary refs\n\n  - GoCD's `git` layer knows how to handle refspecs provided in the branch field.\n  - Refspecs _**must NOT**_ contain wildcards; they are not meaningful to how GoCD\n    will use materials (i.e., updating a local agent workspace).\n  - The main motivation behind this is to allow GoCD to support pull request\n    refs as a pipeline material for the branch support work.\n\nImplementation notes\n--------------------\n\n`RefSpecHelper` handles detection and parsing of a given branch or refspec. Mainly,\nthis utility class extracts source and destination components of the refspec and\nbuilds sensible values for local branch names and remote branch names. Also notably,\nit infers a full destination ref from a shorthand refspec. The logic for this is\nstraightforward:\n\n1. When given a shorthand refspec in the form: `refs/namespace/foo:bar`\n    - the refspec destination is expanded under the `origin` remote as\n      `refs/namespace/foo:refs/remotes/origin/bar`.\n\n2. When given a full refspec in the form: `refs/namespace/foo:refs/anything/bar`\n    - the refspec is interpreted as-is.\n\n`GitCommand#clone()` and `GitCommand#cloneWithNoCheckout()` have been adapted to\naccommodate refspecs; when a refspec is detected, the clone behaviors configure\nthe `git-fetch` configurations with the refspec instead of the implicit/default\n`+refs/heads/*:refs/remotes/origin/*` so that future `git fetch` operations update\nthe correct refs. This ensures that flyweights and agent sandboxes receive new\ncommits. The local branch is also explicitly created before switching the local\nrepo `HEAD` pointer.\n\n`GitMaterial` is also refspec aware and knows how to report the local branch name\nfrom the given refspec. Additionally, `GitMaterial#isRepositoryChanged()` performs\nadditional validation on the fetch configuration before reusing (or re-cloning) a\nflyweight or agent sandbox for a given material.\n\n`GitCommand` and `GitMaterial` delegate to `RefSpecHelper` for the detection and\ninterpretation of refspecs.\n\nThere were also some convenience methods added to `SCMCommand` and `CommandLine`\nin addition to miscellaneous code formatting, cleanup, and reorganization.", "committedDate": "2020-07-03T00:18:02Z", "type": "forcePushed"}, {"oid": "cbca50d98d98b15a6581214cafc0e42674c1fa74", "url": "https://github.com/gocd/gocd/commit/cbca50d98d98b15a6581214cafc0e42674c1fa74", "message": "Regenerate GitMaterial and GitMaterialConfig equals(), hashCode(), toString()", "committedDate": "2020-07-03T11:29:02Z", "type": "commit"}, {"oid": "5e4c66a1db6f3945bc55fb850e5c6ff10cbaf6d8", "url": "https://github.com/gocd/gocd/commit/5e4c66a1db6f3945bc55fb850e5c6ff10cbaf6d8", "message": "Rearrange `GitCommand` and `SCMCommand` methods by visibility to make the public API clearer", "committedDate": "2020-07-03T11:29:02Z", "type": "commit"}, {"oid": "1661b8d88c33d9f55233d4c8c9befe022b2e4e0e", "url": "https://github.com/gocd/gocd/commit/1661b8d88c33d9f55233d4c8c9befe022b2e4e0e", "message": "Git materials can checkout arbitrary refs\n\n  - GoCD's `git` layer knows how to handle refspecs provided in the branch field.\n  - Refspecs _**must NOT**_ contain wildcards; they are not meaningful to how GoCD\n    will use materials (i.e., updating a local agent workspace).\n  - The main motivation behind this is to allow GoCD to support pull request\n    refs as a pipeline material for the branch support work.\n\nImplementation notes\n--------------------\n\n`RefSpecHelper` handles detection and parsing of a given branch or refspec. Mainly,\nthis utility class extracts source and destination components of the refspec and\nbuilds sensible values for local branch names and remote branch names. Also notably,\nit infers a full destination ref from a shorthand refspec. The logic for this is\nstraightforward:\n\n1. When given a shorthand refspec in the form: `refs/namespace/foo:bar`\n    - the refspec destination is expanded under the `origin` remote as\n      `refs/namespace/foo:refs/remotes/origin/bar`.\n\n2. When given a full refspec in the form: `refs/namespace/foo:refs/anything/bar`\n    - the refspec is interpreted as-is.\n\n`GitCommand#clone()` and `GitCommand#cloneWithNoCheckout()` have been adapted to\naccommodate refspecs; when a refspec is detected, the clone behaviors configure\nthe `git-fetch` configurations with the refspec instead of the implicit/default\n`+refs/heads/*:refs/remotes/origin/*` so that future `git fetch` operations update\nthe correct refs. This ensures that flyweights and agent sandboxes receive new\ncommits. The local branch is also explicitly created before switching the local\nrepo `HEAD` pointer.\n\n`GitMaterial` is also refspec aware and knows how to report the local branch name\nfrom the given refspec. Additionally, `GitMaterial#isRepositoryChanged()` performs\nadditional validation on the fetch configuration before reusing (or re-cloning) a\nflyweight or agent sandbox for a given material.\n\n`GitCommand` and `GitMaterial` delegate to `RefSpecHelper` for the detection and\ninterpretation of refspecs.\n\nThere were also some convenience methods added to `SCMCommand` and `CommandLine`\nin addition to miscellaneous code formatting, cleanup, and reorganization.", "committedDate": "2020-07-03T11:29:02Z", "type": "commit"}, {"oid": "1661b8d88c33d9f55233d4c8c9befe022b2e4e0e", "url": "https://github.com/gocd/gocd/commit/1661b8d88c33d9f55233d4c8c9befe022b2e4e0e", "message": "Git materials can checkout arbitrary refs\n\n  - GoCD's `git` layer knows how to handle refspecs provided in the branch field.\n  - Refspecs _**must NOT**_ contain wildcards; they are not meaningful to how GoCD\n    will use materials (i.e., updating a local agent workspace).\n  - The main motivation behind this is to allow GoCD to support pull request\n    refs as a pipeline material for the branch support work.\n\nImplementation notes\n--------------------\n\n`RefSpecHelper` handles detection and parsing of a given branch or refspec. Mainly,\nthis utility class extracts source and destination components of the refspec and\nbuilds sensible values for local branch names and remote branch names. Also notably,\nit infers a full destination ref from a shorthand refspec. The logic for this is\nstraightforward:\n\n1. When given a shorthand refspec in the form: `refs/namespace/foo:bar`\n    - the refspec destination is expanded under the `origin` remote as\n      `refs/namespace/foo:refs/remotes/origin/bar`.\n\n2. When given a full refspec in the form: `refs/namespace/foo:refs/anything/bar`\n    - the refspec is interpreted as-is.\n\n`GitCommand#clone()` and `GitCommand#cloneWithNoCheckout()` have been adapted to\naccommodate refspecs; when a refspec is detected, the clone behaviors configure\nthe `git-fetch` configurations with the refspec instead of the implicit/default\n`+refs/heads/*:refs/remotes/origin/*` so that future `git fetch` operations update\nthe correct refs. This ensures that flyweights and agent sandboxes receive new\ncommits. The local branch is also explicitly created before switching the local\nrepo `HEAD` pointer.\n\n`GitMaterial` is also refspec aware and knows how to report the local branch name\nfrom the given refspec. Additionally, `GitMaterial#isRepositoryChanged()` performs\nadditional validation on the fetch configuration before reusing (or re-cloning) a\nflyweight or agent sandbox for a given material.\n\n`GitCommand` and `GitMaterial` delegate to `RefSpecHelper` for the detection and\ninterpretation of refspecs.\n\nThere were also some convenience methods added to `SCMCommand` and `CommandLine`\nin addition to miscellaneous code formatting, cleanup, and reorganization.", "committedDate": "2020-07-03T11:29:02Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU0NjA3OQ==", "url": "https://github.com/gocd/gocd/pull/8210#discussion_r449546079", "bodyText": "Worth calling out this decision in expandRefSpec()", "author": "marques-work", "createdAt": "2020-07-03T11:58:59Z", "path": "config/config-api/src/main/java/com/thoughtworks/go/config/materials/git/RefSpecHelper.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/*\n+ * Copyright 2020 ThoughtWorks, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.thoughtworks.go.config.materials.git;\n+\n+public class RefSpecHelper {\n+    public static final String REFS_HEADS = \"refs/heads/\";\n+    public static final String REFS_REMOTES = \"refs/remotes/\";\n+\n+    private RefSpecHelper() {\n+    }\n+\n+    public static String localBranch(String branch) {\n+        final String local = findDest(branch);\n+\n+        if (null == local) {\n+            return branch;\n+        }\n+\n+        if (local.startsWith(REFS_HEADS)) {\n+            return local.substring(REFS_HEADS.length());\n+        }\n+\n+        if (local.startsWith(REFS_REMOTES)) {\n+            final int bound = local.indexOf(\"/\", REFS_REMOTES.length());\n+            // If the user does not specify a branch under the remote, this is likely\n+            // a user error. As a failsafe, allow the condition to fall through, which\n+            // effectively returns `refs/remotes/<remote-name>` as this will be\n+            // resolvable in git.\n+            if (-1 != bound) {\n+                return local.substring(bound + 1);\n+            }\n+        }\n+\n+        return local;\n+    }\n+\n+    public static String remoteBranch(String branch) {\n+        final String local = findDest(branch);\n+\n+        if (null == local) {\n+            return \"origin/\" + branch;\n+        }\n+\n+        if (!local.startsWith(\"refs/\")) {\n+            return REFS_HEADS + local;\n+        }\n+\n+        if (local.startsWith(REFS_REMOTES)) {\n+            // If the user does not specify a branch under the remote, this is likely\n+            // a user error. As a failsafe, allow the condition to fall through, which\n+            // effectively returns `refs/remotes/<remote-name>` as this will be\n+            // resolvable in git.\n+            if (-1 != local.indexOf(\"/\", REFS_REMOTES.length())) {\n+                return local.substring(REFS_REMOTES.length());\n+            }\n+        }\n+\n+        return local;\n+    }\n+\n+    /**\n+     * Finds the full ref of the upstream branch; for refSpecs, this returns the source fragment.\n+     * <p>\n+     * This is mainly used for {@code git ls-remote} during git connection check.\n+     *\n+     * @return the full ref of the upstream branch or source fragment of the refSpec\n+     */\n+    public static String fullUpstreamRef(String branch) {\n+        final String source = findSource(branch);\n+        return null == source ? REFS_HEADS + branch : source;\n+    }\n+\n+    public static boolean hasRefSpec(String branch) {\n+        return -1 != refSpecBoundary(branch);\n+    }\n+\n+    /**\n+     * Ensures that the refSpec destination has an absolute path\n+     *\n+     * @return the absolute refSpec\n+     */\n+    public static String expandRefSpec(String branch) {\n+        final String source = findSource(branch);\n+\n+        if (null == source) { // equiv to hasRefSpec()\n+            return branch;\n+        }\n+\n+        final String dest = findDest(branch);\n+\n+        if (null == dest || dest.startsWith(\"refs/\")) {\n+            return branch;\n+        }\n+\n+        // NOTE: This behavior differs from the `git fetch <remote> <refSpec>` implicit, default\n+        // expansion, which effectively interprets `refs/a/b:c` as `refs/a/b:refs/heads/c`.\n+        //\n+        // Expanding the destination to be under `refs/remotes/origin/<dest>` is a more sensible\n+        // default for how GoCD works. As we actually create and _switch_ to the branch named\n+        // by the destination, `git fetch` would *fail* if the refSpec destination were to be\n+        // `refs/heads/<branchName>`; fetching directly to the current branch is illegal in `git`\n+        // (HEAD actually points to `refs/heads/<branchName>`).\n+        //\n+        // Fetching to `refs/remotes/origin/<branchName>` (and then merging, \u00e0 la \"pull\") works\n+        // perfectly fine from the current branch.\n+        //\n+        //   -- In case you were wondering. \ud83d\udd96\ud83c\udffc\n+        return source + \":\" + REFS_REMOTES + \"origin/\" + dest;", "originalCommit": "1661b8d88c33d9f55233d4c8c9befe022b2e4e0e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE2MDE3Ng==", "url": "https://github.com/gocd/gocd/pull/8210#discussion_r450160176", "bodyText": "@marques-work - is this System.out.printf intentional?", "author": "GaneshSPatil", "createdAt": "2020-07-06T11:33:52Z", "path": "domain/src/main/java/com/thoughtworks/go/config/materials/git/GitMaterial.java", "diffHunk": "@@ -443,13 +314,136 @@ public GitMaterial withShallowClone(boolean value) {\n         return gitMaterial;\n     }\n \n-    public String branchWithDefault() {\n-        return isBlank(branch) ? GitMaterialConfig.DEFAULT_BRANCH : branch;\n+    public String effectiveLocalBranch() {\n+        return localBranch(isBlank(refSpecOrBranch) ? GitMaterialConfig.DEFAULT_BRANCH : refSpecOrBranch);\n+    }\n+\n+    @Override\n+    protected void appendCriteria(Map<String, Object> parameters) {\n+        parameters.put(ScmMaterialConfig.URL, url.originalArgument());\n+        parameters.put(\"branch\", refSpecOrBranch);\n+    }\n+\n+    @Override\n+    protected void appendAttributes(Map<String, Object> parameters) {\n+        parameters.put(\"url\", url);\n+        parameters.put(\"branch\", refSpecOrBranch);\n+        parameters.put(\"shallowClone\", shallowClone);\n+    }\n+\n+    @Override\n+    protected String getLocation() {\n+        return url.forDisplay();\n     }\n \n     @Override\n     protected void setGoMaterialVariables(EnvironmentVariableContext environmentVariableContext) {\n         super.setGoMaterialVariables(environmentVariableContext);\n-        setVariableWithName(environmentVariableContext, branchWithDefault(), GO_MATERIAL_BRANCH);\n+        setVariableWithName(environmentVariableContext, effectiveLocalBranch(), GO_MATERIAL_BRANCH);\n+    }\n+\n+    private GitCommand getGit(File workingdir, SubprocessExecutionContext executionContext) {\n+        InMemoryStreamConsumer output = inMemoryConsumer();\n+        try {\n+            return git(output, workingdir, DEFAULT_SHALLOW_CLONE_DEPTH, executionContext);\n+        } catch (Exception e) {\n+            throw bomb(e.getMessage() + \" \" + output.getStdError(), e);\n+        }\n+    }\n+\n+    private GitCommand git(ConsoleOutputStreamConsumer outputStreamConsumer, final File workingFolder, int preferredCloneDepth, SubprocessExecutionContext executionContext) throws Exception {\n+        if (isSubmoduleFolder()) {\n+            return new GitCommand(getFingerprint(), new File(workingFolder.getPath()), GitMaterialConfig.DEFAULT_BRANCH, true, secrets());\n+        }\n+        System.out.printf(\"**** [%s] WorkingDir for %s: %s\\n\", executionContext.isServer() ? \"server\" : \"agent\", urlForCommandLine(), workingFolder.getPath());", "originalCommit": "1661b8d88c33d9f55233d4c8c9befe022b2e4e0e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDYwNjQyMg==", "url": "https://github.com/gocd/gocd/pull/8210#discussion_r450606422", "bodyText": "@GaneshSPatil oops! no, it is not.", "author": "marques-work", "createdAt": "2020-07-07T04:38:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE2MDE3Ng=="}], "type": "inlineReview"}]}