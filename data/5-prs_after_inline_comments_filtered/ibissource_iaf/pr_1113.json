{"pr_number": 1113, "pr_title": "Frank!Doc: Fill data model", "pr_createdAt": "2020-09-30T15:23:55Z", "pr_url": "https://github.com/ibissource/iaf/pull/1113", "timeline": [{"oid": "8463259b4f192047fcc35184d789fc3e6f3d083e", "url": "https://github.com/ibissource/iaf/commit/8463259b4f192047fcc35184d789fc3e6f3d083e", "message": "Work in progress", "committedDate": "2020-09-29T12:01:37Z", "type": "commit"}, {"oid": "abdb9a7c018578f68c372a7a2a3ab5828d750ec7", "url": "https://github.com/ibissource/iaf/commit/abdb9a7c018578f68c372a7a2a3ab5828d750ec7", "message": "Merge branch 'master' into fillDataModel", "committedDate": "2020-09-30T07:23:28Z", "type": "commit"}, {"oid": "dab922ce4448c29616046936b3b7abf57adf3731", "url": "https://github.com/ibissource/iaf/commit/dab922ce4448c29616046936b3b7abf57adf3731", "message": "Make a start with filling the data model", "committedDate": "2020-09-30T11:03:26Z", "type": "commit"}, {"oid": "e6f1c6d5bd1065868537317f648b2e10f1881434", "url": "https://github.com/ibissource/iaf/commit/e6f1c6d5bd1065868537317f648b2e10f1881434", "message": "Move sorting SpringBeans to the test - sorting is not relevant outside the test", "committedDate": "2020-09-30T13:03:58Z", "type": "commit"}, {"oid": "2fc99fae1eaa68809d31597a5b686a18be6dcea2", "url": "https://github.com/ibissource/iaf/commit/2fc99fae1eaa68809d31597a5b686a18be6dcea2", "message": "Build a rudimentary FrankDocModel", "committedDate": "2020-09-30T15:22:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODAxODIzNQ==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r498018235", "bodyText": "Als je een exceptie gooit, dan altijd een concrete foutmelding, waar degene die hem ziet iets aan heeft om het probleem op te lossen", "author": "gvanbrakel", "createdAt": "2020-10-01T06:49:18Z", "path": "core/src/main/java/nl/nn/adapterframework/doc/ModelBuilder.java", "diffHunk": "@@ -0,0 +1,174 @@\n+package nl.nn.adapterframework.doc;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import nl.nn.adapterframework.doc.model.FrankAttribute;\n+import nl.nn.adapterframework.doc.model.FrankDocGroup;\n+import nl.nn.adapterframework.doc.model.FrankDocModel;\n+import nl.nn.adapterframework.doc.model.FrankElement;\n+import nl.nn.adapterframework.doc.objects.SpringBean;\n+\n+public class ModelBuilder {\n+\tprivate @Getter FrankDocModel model;\n+\n+\tstatic class AttributeSeed {\n+\t\tprivate @Getter String name;\n+\n+\t\tAttributeSeed(Method reflectMethod) {\n+\t\t\tname = reflectMethod.getName();\n+\t\t}\n+\n+\t\tAttributeSeed(String name) {\n+\t\t\tthis.name = name;\n+\t\t}\n+\t}\n+\n+\tstatic class ElementSeed {\n+\t\tprivate @Getter @Setter Map<String, AttributeSeed> methods;\n+\t\tprivate @Getter @Setter Map<String, AttributeSeed> methodsWithInherited;\n+\t\tprivate @Getter String fullName;\n+\t\tprivate @Getter @Setter String simpleName;\n+\n+\t\tElementSeed(Class<?> clazz) {\n+\t\t\tmethods = new HashMap<>();\n+\t\t\tfor(Method reflect: clazz.getDeclaredMethods()) {\n+\t\t\t\t// Jacoco is a tool for code coverage. To have predictible results,\n+\t\t\t\t// we omit methods introduced by Jacoco.\n+\t\t\t\tif(reflect.getName().contains(\"jacoco\")) {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t\tmethods.put(reflect.getName(), new AttributeSeed(reflect));\n+\t\t\t}\n+\t\t\tmethodsWithInherited = new HashMap<>();\n+\t\t\tmethodsWithInherited.putAll(methods);\n+\t\t\tfor(Method reflect: clazz.getMethods()) {\n+\t\t\t\tmethodsWithInherited.putIfAbsent(reflect.getName(), new AttributeSeed(reflect));\n+\t\t\t}\n+\t\t\tfullName = clazz.getName();\n+\t\t\tsimpleName = clazz.getSimpleName();\n+\t\t}\n+\n+\t\tElementSeed(final String fullName) {\n+\t\t\tthis.fullName = fullName;\n+\t\t}\n+\t}\n+\n+\tpublic ModelBuilder() {\n+\t\tmodel = new FrankDocModel();\n+\t\tmodel.setGroups(new ArrayList<>());\n+\t\tmodel.setAllElements(new HashMap<>());\n+\t}\n+\n+\t/**\n+\t * @param interfaceName The interface for which we want SpringBean objects.\n+\t * @return All classes implementing interfaceName, ordered by their full class name.\n+\t */\n+\tstatic List<SpringBean> getSpringBeans(final String interfaceName) {\n+\t\tClass<?> interfaze = InfoBuilderSource.getClass(interfaceName);\n+\t\tif(interfaze == null) {\n+\t\t\tthrow new NullPointerException();", "originalCommit": "2fc99fae1eaa68809d31597a5b686a18be6dcea2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkzOTcwNw==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r498939707", "bodyText": "Gedaan.", "author": "mhdirkse", "createdAt": "2020-10-02T16:57:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODAxODIzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODAxOTI1Ng==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r498019256", "bodyText": "Ik denk dat het duidelijker / inzichtelijker is als deze code een method asFrankElement() is van ElementSeed,", "author": "gvanbrakel", "createdAt": "2020-10-01T06:51:25Z", "path": "core/src/main/java/nl/nn/adapterframework/doc/ModelBuilder.java", "diffHunk": "@@ -0,0 +1,174 @@\n+package nl.nn.adapterframework.doc;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import nl.nn.adapterframework.doc.model.FrankAttribute;\n+import nl.nn.adapterframework.doc.model.FrankDocGroup;\n+import nl.nn.adapterframework.doc.model.FrankDocModel;\n+import nl.nn.adapterframework.doc.model.FrankElement;\n+import nl.nn.adapterframework.doc.objects.SpringBean;\n+\n+public class ModelBuilder {\n+\tprivate @Getter FrankDocModel model;\n+\n+\tstatic class AttributeSeed {\n+\t\tprivate @Getter String name;\n+\n+\t\tAttributeSeed(Method reflectMethod) {\n+\t\t\tname = reflectMethod.getName();\n+\t\t}\n+\n+\t\tAttributeSeed(String name) {\n+\t\t\tthis.name = name;\n+\t\t}\n+\t}\n+\n+\tstatic class ElementSeed {\n+\t\tprivate @Getter @Setter Map<String, AttributeSeed> methods;\n+\t\tprivate @Getter @Setter Map<String, AttributeSeed> methodsWithInherited;\n+\t\tprivate @Getter String fullName;\n+\t\tprivate @Getter @Setter String simpleName;\n+\n+\t\tElementSeed(Class<?> clazz) {\n+\t\t\tmethods = new HashMap<>();\n+\t\t\tfor(Method reflect: clazz.getDeclaredMethods()) {\n+\t\t\t\t// Jacoco is a tool for code coverage. To have predictible results,\n+\t\t\t\t// we omit methods introduced by Jacoco.\n+\t\t\t\tif(reflect.getName().contains(\"jacoco\")) {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t\tmethods.put(reflect.getName(), new AttributeSeed(reflect));\n+\t\t\t}\n+\t\t\tmethodsWithInherited = new HashMap<>();\n+\t\t\tmethodsWithInherited.putAll(methods);\n+\t\t\tfor(Method reflect: clazz.getMethods()) {\n+\t\t\t\tmethodsWithInherited.putIfAbsent(reflect.getName(), new AttributeSeed(reflect));\n+\t\t\t}\n+\t\t\tfullName = clazz.getName();\n+\t\t\tsimpleName = clazz.getSimpleName();\n+\t\t}\n+\n+\t\tElementSeed(final String fullName) {\n+\t\t\tthis.fullName = fullName;\n+\t\t}\n+\t}\n+\n+\tpublic ModelBuilder() {\n+\t\tmodel = new FrankDocModel();\n+\t\tmodel.setGroups(new ArrayList<>());\n+\t\tmodel.setAllElements(new HashMap<>());\n+\t}\n+\n+\t/**\n+\t * @param interfaceName The interface for which we want SpringBean objects.\n+\t * @return All classes implementing interfaceName, ordered by their full class name.\n+\t */\n+\tstatic List<SpringBean> getSpringBeans(final String interfaceName) {\n+\t\tClass<?> interfaze = InfoBuilderSource.getClass(interfaceName);\n+\t\tif(interfaze == null) {\n+\t\t\tthrow new NullPointerException();\n+\t\t}\n+\t\tif(!interfaze.isInterface()) {\n+\t\t\tthrow new IllegalArgumentException(\"Only retrieve Spring beans from an interface\");\n+\t\t}\n+\t\tSet<SpringBean> unfiltered = InfoBuilderSource.getSpringBeans(interfaze);\n+\t\tList<SpringBean> result = new ArrayList<SpringBean>();\n+\t\tfor(SpringBean b: unfiltered) {\n+\t\t\tif(interfaze.isAssignableFrom(b.getClazz())) {\n+\t\t\t\tresult.add(b);\n+\t\t\t}\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tstatic List<ElementSeed> getSelfAndAncestorSeeds(Class<?> clazz) {\n+\t\tList<ElementSeed> result = new ArrayList<>();\n+\t\tresult.add(new ElementSeed(clazz));\n+\t\tClass<?> superClass = clazz.getSuperclass();\n+\t\twhile(superClass != null) {\n+\t\t\tresult.add(new ElementSeed(superClass));\n+\t\t\tsuperClass = superClass.getSuperclass();\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tFrankDocGroup addGroup(String name) {\n+\t\tFrankDocGroup group = new FrankDocGroup(name);\n+\t\tgroup.setElements(new HashMap<>());\n+\t\tmodel.getGroups().add(group);\n+\t\treturn group;\n+\t}\n+\n+\tvoid addElementsToGroup(List<ElementSeed> elementHierarchy, FrankDocGroup group) {\n+\t\tList<ElementSeed> reversedSeeds = new ArrayList<>(elementHierarchy);\n+\t\tCollections.reverse(reversedSeeds);\n+\t\tFrankElement parent = null;\n+\t\tfor(ElementSeed seed: reversedSeeds) {\n+\t\t\tif(model.getAllElements().containsKey(seed.getFullName())) {\n+\t\t\t\tparent = model.getAllElements().get(seed.getFullName());\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tparent = createFrankElement(seed, parent);\n+\t\t\t\tmodel.getAllElements().put(parent.getFullName(), parent);\n+\t\t\t}\n+\t\t}\n+\t\tgroup.getElements().putIfAbsent(parent.getFullName(), parent);\n+\t}\n+\n+\tFrankElement createFrankElement(ElementSeed seed, FrankElement parent) {\n+\t\tFrankElement result = new FrankElement(seed.getFullName(), seed.getSimpleName());\n+\t\tresult.setParent(parent);\n+\t\tresult.setAttributes(createAttributes(seed));\n+\t\treturn result;\n+\t}", "originalCommit": "2fc99fae1eaa68809d31597a5b686a18be6dcea2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkzNjY1MQ==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r498936651", "bodyText": "De seeds zijn weg zoals je hebt gevraagd.", "author": "mhdirkse", "createdAt": "2020-10-02T16:51:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODAxOTI1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODAyMjQwMw==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r498022403", "bodyText": "Waarom haal je de inherited methods op? Dat moet de ElementSeed van de super class doen.\nElementSeed moet niets weten van inherited methods.", "author": "gvanbrakel", "createdAt": "2020-10-01T06:58:22Z", "path": "core/src/main/java/nl/nn/adapterframework/doc/ModelBuilder.java", "diffHunk": "@@ -0,0 +1,174 @@\n+package nl.nn.adapterframework.doc;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import nl.nn.adapterframework.doc.model.FrankAttribute;\n+import nl.nn.adapterframework.doc.model.FrankDocGroup;\n+import nl.nn.adapterframework.doc.model.FrankDocModel;\n+import nl.nn.adapterframework.doc.model.FrankElement;\n+import nl.nn.adapterframework.doc.objects.SpringBean;\n+\n+public class ModelBuilder {\n+\tprivate @Getter FrankDocModel model;\n+\n+\tstatic class AttributeSeed {\n+\t\tprivate @Getter String name;\n+\n+\t\tAttributeSeed(Method reflectMethod) {\n+\t\t\tname = reflectMethod.getName();\n+\t\t}\n+\n+\t\tAttributeSeed(String name) {\n+\t\t\tthis.name = name;\n+\t\t}\n+\t}\n+\n+\tstatic class ElementSeed {\n+\t\tprivate @Getter @Setter Map<String, AttributeSeed> methods;\n+\t\tprivate @Getter @Setter Map<String, AttributeSeed> methodsWithInherited;\n+\t\tprivate @Getter String fullName;\n+\t\tprivate @Getter @Setter String simpleName;\n+\n+\t\tElementSeed(Class<?> clazz) {\n+\t\t\tmethods = new HashMap<>();\n+\t\t\tfor(Method reflect: clazz.getDeclaredMethods()) {\n+\t\t\t\t// Jacoco is a tool for code coverage. To have predictible results,\n+\t\t\t\t// we omit methods introduced by Jacoco.\n+\t\t\t\tif(reflect.getName().contains(\"jacoco\")) {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t\tmethods.put(reflect.getName(), new AttributeSeed(reflect));\n+\t\t\t}\n+\t\t\tmethodsWithInherited = new HashMap<>();\n+\t\t\tmethodsWithInherited.putAll(methods);\n+\t\t\tfor(Method reflect: clazz.getMethods()) {\n+\t\t\t\tmethodsWithInherited.putIfAbsent(reflect.getName(), new AttributeSeed(reflect));\n+\t\t\t}", "originalCommit": "2fc99fae1eaa68809d31597a5b686a18be6dcea2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODMwOTkxOA==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r498309918", "bodyText": "Een class heeft pas een attribute x als je getX() en setX() methods hebt (afgezien van annotaties nog, die doe ik later). Het kan zijn dat de getter of de setter inherited is. Ik los dat nu half op door getters te zoeken over inherited methods, maar de setter alleen over de declared methods. Deze halve oplossing garandeert dat een attribute ontstaat in de class waar de setter method is gedefini\u00eberd. Maar dit is inderdaad extra complexiteit zonder dat dit corner case echt wordt opgelost. Ik zal je comment opvolgen door alleen de declared methods te gebruiken. Er zullen aan het eind van de rit toch wel van dit soort corner cases zijn waar we op moeten letten. Ben je het met mij eens?", "author": "mhdirkse", "createdAt": "2020-10-01T14:56:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODAyMjQwMw=="}], "type": "inlineReview"}, {"oid": "e7f73fd6e4fe3ac145947a5de607524f2cc15a6a", "url": "https://github.com/ibissource/iaf/commit/e7f73fd6e4fe3ac145947a5de607524f2cc15a6a", "message": "Attributes start with a lower-case letter", "committedDate": "2020-10-01T07:04:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODAzNDg2MQ==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r498034861", "bodyText": "Je moet niet 'altijd' de superclasses gaan verwerken. Als je dat doet, doe je het veel te vaak.\nJe moet zorgen dat je elke class maar \u00e9\u00e9n keer verwerkt.", "author": "gvanbrakel", "createdAt": "2020-10-01T07:23:47Z", "path": "core/src/main/java/nl/nn/adapterframework/doc/ModelBuilder.java", "diffHunk": "@@ -0,0 +1,174 @@\n+package nl.nn.adapterframework.doc;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import nl.nn.adapterframework.doc.model.FrankAttribute;\n+import nl.nn.adapterframework.doc.model.FrankDocGroup;\n+import nl.nn.adapterframework.doc.model.FrankDocModel;\n+import nl.nn.adapterframework.doc.model.FrankElement;\n+import nl.nn.adapterframework.doc.objects.SpringBean;\n+\n+public class ModelBuilder {\n+\tprivate @Getter FrankDocModel model;\n+\n+\tstatic class AttributeSeed {\n+\t\tprivate @Getter String name;\n+\n+\t\tAttributeSeed(Method reflectMethod) {\n+\t\t\tname = reflectMethod.getName();\n+\t\t}\n+\n+\t\tAttributeSeed(String name) {\n+\t\t\tthis.name = name;\n+\t\t}\n+\t}\n+\n+\tstatic class ElementSeed {\n+\t\tprivate @Getter @Setter Map<String, AttributeSeed> methods;\n+\t\tprivate @Getter @Setter Map<String, AttributeSeed> methodsWithInherited;\n+\t\tprivate @Getter String fullName;\n+\t\tprivate @Getter @Setter String simpleName;\n+\n+\t\tElementSeed(Class<?> clazz) {\n+\t\t\tmethods = new HashMap<>();\n+\t\t\tfor(Method reflect: clazz.getDeclaredMethods()) {\n+\t\t\t\t// Jacoco is a tool for code coverage. To have predictible results,\n+\t\t\t\t// we omit methods introduced by Jacoco.\n+\t\t\t\tif(reflect.getName().contains(\"jacoco\")) {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t\tmethods.put(reflect.getName(), new AttributeSeed(reflect));\n+\t\t\t}\n+\t\t\tmethodsWithInherited = new HashMap<>();\n+\t\t\tmethodsWithInherited.putAll(methods);\n+\t\t\tfor(Method reflect: clazz.getMethods()) {\n+\t\t\t\tmethodsWithInherited.putIfAbsent(reflect.getName(), new AttributeSeed(reflect));\n+\t\t\t}\n+\t\t\tfullName = clazz.getName();\n+\t\t\tsimpleName = clazz.getSimpleName();\n+\t\t}\n+\n+\t\tElementSeed(final String fullName) {\n+\t\t\tthis.fullName = fullName;\n+\t\t}\n+\t}\n+\n+\tpublic ModelBuilder() {\n+\t\tmodel = new FrankDocModel();\n+\t\tmodel.setGroups(new ArrayList<>());\n+\t\tmodel.setAllElements(new HashMap<>());\n+\t}\n+\n+\t/**\n+\t * @param interfaceName The interface for which we want SpringBean objects.\n+\t * @return All classes implementing interfaceName, ordered by their full class name.\n+\t */\n+\tstatic List<SpringBean> getSpringBeans(final String interfaceName) {\n+\t\tClass<?> interfaze = InfoBuilderSource.getClass(interfaceName);\n+\t\tif(interfaze == null) {\n+\t\t\tthrow new NullPointerException();\n+\t\t}\n+\t\tif(!interfaze.isInterface()) {\n+\t\t\tthrow new IllegalArgumentException(\"Only retrieve Spring beans from an interface\");\n+\t\t}\n+\t\tSet<SpringBean> unfiltered = InfoBuilderSource.getSpringBeans(interfaze);\n+\t\tList<SpringBean> result = new ArrayList<SpringBean>();\n+\t\tfor(SpringBean b: unfiltered) {\n+\t\t\tif(interfaze.isAssignableFrom(b.getClazz())) {\n+\t\t\t\tresult.add(b);\n+\t\t\t}\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tstatic List<ElementSeed> getSelfAndAncestorSeeds(Class<?> clazz) {\n+\t\tList<ElementSeed> result = new ArrayList<>();\n+\t\tresult.add(new ElementSeed(clazz));\n+\t\tClass<?> superClass = clazz.getSuperclass();\n+\t\twhile(superClass != null) {\n+\t\t\tresult.add(new ElementSeed(superClass));\n+\t\t\tsuperClass = superClass.getSuperclass();\n+\t\t}\n+\t\treturn result;", "originalCommit": "2fc99fae1eaa68809d31597a5b686a18be6dcea2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODMwNTE0OA==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r498305148", "bodyText": "Gedaan.", "author": "mhdirkse", "createdAt": "2020-10-01T14:50:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODAzNDg2MQ=="}], "type": "inlineReview"}, {"oid": "8a22264a1ee8184d834014ebedcb30c049781933", "url": "https://github.com/ibissource/iaf/commit/8a22264a1ee8184d834014ebedcb30c049781933", "message": "Attribute x exists if you have setX and isX", "committedDate": "2020-10-01T07:53:51Z", "type": "commit"}, {"oid": "6f6c2dd487ab5da45b2b7cc3334045a56257edff", "url": "https://github.com/ibissource/iaf/commit/6f6c2dd487ab5da45b2b7cc3334045a56257edff", "message": "Improve code quality", "committedDate": "2020-10-01T08:00:23Z", "type": "commit"}, {"oid": "040c09e5ed307c81b7f31877ee4854c0115cc68c", "url": "https://github.com/ibissource/iaf/commit/040c09e5ed307c81b7f31877ee4854c0115cc68c", "message": "Add type checks to finding attributes", "committedDate": "2020-10-01T11:49:24Z", "type": "commit"}, {"oid": "6725e41c1c322eee587c3f06423d6fef4a246b6e", "url": "https://github.com/ibissource/iaf/commit/6725e41c1c322eee587c3f06423d6fef4a246b6e", "message": "Process classes only once for creating FrankElement", "committedDate": "2020-10-01T14:48:46Z", "type": "commit"}, {"oid": "72f06d92421900e566d1c186efec59dff8d2131a", "url": "https://github.com/ibissource/iaf/commit/72f06d92421900e566d1c186efec59dff8d2131a", "message": "Do not work with inherited methods", "committedDate": "2020-10-01T15:26:59Z", "type": "commit"}, {"oid": "3c56c079b075854cca0d31e3fae55c1fd7ee545a", "url": "https://github.com/ibissource/iaf/commit/3c56c079b075854cca0d31e3fae55c1fd7ee545a", "message": "Remove the rejected seed classes", "committedDate": "2020-10-02T16:43:23Z", "type": "commit"}, {"oid": "e471d20f971b13a58cd32e656d59c7056edcb430", "url": "https://github.com/ibissource/iaf/commit/e471d20f971b13a58cd32e656d59c7056edcb430", "message": "Rename", "committedDate": "2020-10-02T16:49:13Z", "type": "commit"}, {"oid": "67112f84216f355029d684df1555af10d821032f", "url": "https://github.com/ibissource/iaf/commit/67112f84216f355029d684df1555af10d821032f", "message": "Follow up comment that thrown exceptions should be informative", "committedDate": "2020-10-02T16:57:16Z", "type": "commit"}, {"oid": "1609989cd66f838d92e67ede44ed39cee5af9f5e", "url": "https://github.com/ibissource/iaf/commit/1609989cd66f838d92e67ede44ed39cee5af9f5e", "message": "Merge branch 'master' into fillDataModel", "committedDate": "2020-10-05T07:28:42Z", "type": "commit"}, {"oid": "c219a723912ed9c46a66fbb406635cb6d47f694a", "url": "https://github.com/ibissource/iaf/commit/c219a723912ed9c46a66fbb406635cb6d47f694a", "message": "Set default AttributeReferenceGroup", "committedDate": "2020-10-05T09:27:29Z", "type": "commit"}, {"oid": "b13e446c3c957a0b3943ac1ea34ff6bd002cbfd1", "url": "https://github.com/ibissource/iaf/commit/b13e446c3c957a0b3943ac1ea34ff6bd002cbfd1", "message": "Revert \"Set default AttributeReferenceGroup\"\n\nThis reverts commit c219a723912ed9c46a66fbb406635cb6d47f694a.", "committedDate": "2020-10-05T09:47:21Z", "type": "commit"}, {"oid": "9f0ecd8a7006e28c77e8980d0b1a4eb6a0b0b7c3", "url": "https://github.com/ibissource/iaf/commit/9f0ecd8a7006e28c77e8980d0b1a4eb6a0b0b7c3", "message": "Add describingElement to FrankAttribute\n\nStill without parsing @IbisDocRef, so at this stage we assume that the\ndescribingElement equals the owning element.", "committedDate": "2020-10-05T10:04:09Z", "type": "commit"}, {"oid": "ea9e64275cfabef4d91dae12393b36d83bf6b800", "url": "https://github.com/ibissource/iaf/commit/ea9e64275cfabef4d91dae12393b36d83bf6b800", "message": "Parse @IbisDoc annotation", "committedDate": "2020-10-05T14:42:07Z", "type": "commit"}, {"oid": "2d03ccc5d5a35e27f7cd406f3928c18666a040ea", "url": "https://github.com/ibissource/iaf/commit/2d03ccc5d5a35e27f7cd406f3928c18666a040ea", "message": "Renames", "committedDate": "2020-10-05T15:20:48Z", "type": "commit"}, {"oid": "c44111ba60f9a587b0afe45f459da5f965ddf0c9", "url": "https://github.com/ibissource/iaf/commit/c44111ba60f9a587b0afe45f459da5f965ddf0c9", "message": "Finish parsing @IbisDoc and @IbisDocRef", "committedDate": "2020-10-05T17:28:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQwODkyMg==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r500408922", "bodyText": "Wat beschrijft dit?", "author": "gvanbrakel", "createdAt": "2020-10-06T15:50:05Z", "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankDocGroup.java", "diffHunk": "@@ -0,0 +1,16 @@\n+package nl.nn.adapterframework.doc.model;\n+\n+import java.util.Map;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+\n+public class FrankDocGroup {\n+\tprivate @Getter String name;\n+\tprivate @Getter @Setter String digesterRulesRef;", "originalCommit": "c44111ba60f9a587b0afe45f459da5f965ddf0c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ4MjQ3Ng==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r500482476", "bodyText": "Straks ga ik aggregatie toevoegen aan het model. Daarvoor moet de file digester-rules.xml worden geparsed. Een combinatie van een  en een  daarbinnen relateert een method naam aan de groep van de elementen die erin kunnen. Maar voordat er een match is moet er een kleine letter in een hoofdletter veranderen of omgekeerd. Ik wilde in het model een veld opnemen om de match tussen een  en een groep te maken.", "author": "mhdirkse", "createdAt": "2020-10-06T17:44:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQwODkyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ4MzMzNg==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r500483336", "bodyText": "Oh, < en > gingen niet goed. Not een keer...", "author": "mhdirkse", "createdAt": "2020-10-06T17:45:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQwODkyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ4NDM2Mg==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r500484362", "bodyText": "Straks ga ik aggregatie toevoegen aan het model. Daarvoor moet de file digester-rules.xml worden geparsed. Een combinatie van een <pattern> en een <set-next-rule> daarbinnen relateert een method naam aan de groep van de elementen die erin kunnen. Maar voordat er een match is moet er een kleine letter in een hoofdletter veranderen of omgekeerd. Ik wilde in het model een veld opnemen om de match tussen de groep en digester-rules.xml te maken.", "author": "mhdirkse", "createdAt": "2020-10-06T17:47:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQwODkyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc4MDM2MA==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r500780360", "bodyText": "Dat wat je af zou kunnen leiden uit digester-rules.xml is:\n\nuit het pattern: de element naam zoals gebruikt in configuratie 1.0\nmet behulp van de set-next-rule: het type sub elementen dat een class kan hebben.\nDat ga je niet redden met een String digesterRulesRef. Het lijkt me beter dat je velden voor bovenstaande pas in een volgende stap toevoegt", "author": "gvanbrakel", "createdAt": "2020-10-07T07:01:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQwODkyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc5MzcwMA==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r500793700", "bodyText": "Ik heb dit veld weggehaald.", "author": "mhdirkse", "createdAt": "2020-10-07T07:27:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQwODkyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQxNDc1Ng==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r500414756", "bodyText": "Dit moet een method van FrankDocModel zijn", "author": "gvanbrakel", "createdAt": "2020-10-06T15:58:13Z", "path": "core/src/main/java/nl/nn/adapterframework/doc/ModelBuilder.java", "diffHunk": "@@ -0,0 +1,265 @@\n+package nl.nn.adapterframework.doc;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n+import org.springframework.core.annotation.AnnotationUtils;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import nl.nn.adapterframework.doc.model.FrankAttribute;\n+import nl.nn.adapterframework.doc.model.FrankDocGroup;\n+import nl.nn.adapterframework.doc.model.FrankDocModel;\n+import nl.nn.adapterframework.doc.model.FrankElement;\n+import nl.nn.adapterframework.doc.objects.SpringBean;\n+import nl.nn.adapterframework.util.LogUtil;\n+\n+public class ModelBuilder {\n+\tprivate static final String JAVA_STRING = \"java.lang.String\";\n+\n+\tprivate static Logger log = LogUtil.getLogger(ModelBuilder.class);\n+\n+\tprivate @Getter FrankDocModel model;\n+\n+\tpublic ModelBuilder() {\n+\t\tmodel = new FrankDocModel();\n+\t\tmodel.setGroups(new ArrayList<>());\n+\t\tmodel.setAllElements(new HashMap<>());\n+\t}\n+\n+\t/**\n+\t * @param interfaceName The interface for which we want SpringBean objects.\n+\t * @return All classes implementing interfaceName, ordered by their full class name.\n+\t */\n+\tstatic List<SpringBean> getSpringBeans(final String interfaceName) {\n+\t\tClass<?> interfaze = InfoBuilderSource.getClass(interfaceName);\n+\t\tif(interfaze == null) {\n+\t\t\tthrow new NullPointerException(\"Class or interface is not available on the classpath: \" + interfaceName);\n+\t\t}\n+\t\tif(!interfaze.isInterface()) {\n+\t\t\tthrow new IllegalArgumentException(\"This exists on the classpath but is not an interface: \" + interfaceName);\n+\t\t}\n+\t\tSet<SpringBean> unfiltered = InfoBuilderSource.getSpringBeans(interfaze);\n+\t\tList<SpringBean> result = new ArrayList<SpringBean>();\n+\t\tfor(SpringBean b: unfiltered) {\n+\t\t\tif(interfaze.isAssignableFrom(b.getClazz())) {\n+\t\t\t\tresult.add(b);\n+\t\t\t}\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tFrankDocGroup addGroup(String name) {", "originalCommit": "c44111ba60f9a587b0afe45f459da5f965ddf0c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTg3MDA5NQ==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r501870095", "bodyText": "Gedaan", "author": "mhdirkse", "createdAt": "2020-10-08T16:55:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQxNDc1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQxNTExMw==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r500415113", "bodyText": "Dit moet onderdeel van de constructor van de FrankDocGroup zijn", "author": "gvanbrakel", "createdAt": "2020-10-06T15:58:42Z", "path": "core/src/main/java/nl/nn/adapterframework/doc/ModelBuilder.java", "diffHunk": "@@ -0,0 +1,265 @@\n+package nl.nn.adapterframework.doc;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n+import org.springframework.core.annotation.AnnotationUtils;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import nl.nn.adapterframework.doc.model.FrankAttribute;\n+import nl.nn.adapterframework.doc.model.FrankDocGroup;\n+import nl.nn.adapterframework.doc.model.FrankDocModel;\n+import nl.nn.adapterframework.doc.model.FrankElement;\n+import nl.nn.adapterframework.doc.objects.SpringBean;\n+import nl.nn.adapterframework.util.LogUtil;\n+\n+public class ModelBuilder {\n+\tprivate static final String JAVA_STRING = \"java.lang.String\";\n+\n+\tprivate static Logger log = LogUtil.getLogger(ModelBuilder.class);\n+\n+\tprivate @Getter FrankDocModel model;\n+\n+\tpublic ModelBuilder() {\n+\t\tmodel = new FrankDocModel();\n+\t\tmodel.setGroups(new ArrayList<>());\n+\t\tmodel.setAllElements(new HashMap<>());\n+\t}\n+\n+\t/**\n+\t * @param interfaceName The interface for which we want SpringBean objects.\n+\t * @return All classes implementing interfaceName, ordered by their full class name.\n+\t */\n+\tstatic List<SpringBean> getSpringBeans(final String interfaceName) {\n+\t\tClass<?> interfaze = InfoBuilderSource.getClass(interfaceName);\n+\t\tif(interfaze == null) {\n+\t\t\tthrow new NullPointerException(\"Class or interface is not available on the classpath: \" + interfaceName);\n+\t\t}\n+\t\tif(!interfaze.isInterface()) {\n+\t\t\tthrow new IllegalArgumentException(\"This exists on the classpath but is not an interface: \" + interfaceName);\n+\t\t}\n+\t\tSet<SpringBean> unfiltered = InfoBuilderSource.getSpringBeans(interfaze);\n+\t\tList<SpringBean> result = new ArrayList<SpringBean>();\n+\t\tfor(SpringBean b: unfiltered) {\n+\t\t\tif(interfaze.isAssignableFrom(b.getClazz())) {\n+\t\t\t\tresult.add(b);\n+\t\t\t}\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tFrankDocGroup addGroup(String name) {\n+\t\tFrankDocGroup group = new FrankDocGroup(name);\n+\t\tgroup.setElements(new HashMap<>());", "originalCommit": "c44111ba60f9a587b0afe45f459da5f965ddf0c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTg2NjMyNA==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r501866324", "bodyText": "Gedaan", "author": "mhdirkse", "createdAt": "2020-10-08T16:48:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQxNTExMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQxOTIwMQ==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r500419201", "bodyText": "Dit zou een method van FrankDocModel moeten zijn, en dan findOrCreateFrankElement() moeten heten", "author": "gvanbrakel", "createdAt": "2020-10-06T16:04:22Z", "path": "core/src/main/java/nl/nn/adapterframework/doc/ModelBuilder.java", "diffHunk": "@@ -0,0 +1,265 @@\n+package nl.nn.adapterframework.doc;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n+import org.springframework.core.annotation.AnnotationUtils;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import nl.nn.adapterframework.doc.model.FrankAttribute;\n+import nl.nn.adapterframework.doc.model.FrankDocGroup;\n+import nl.nn.adapterframework.doc.model.FrankDocModel;\n+import nl.nn.adapterframework.doc.model.FrankElement;\n+import nl.nn.adapterframework.doc.objects.SpringBean;\n+import nl.nn.adapterframework.util.LogUtil;\n+\n+public class ModelBuilder {\n+\tprivate static final String JAVA_STRING = \"java.lang.String\";\n+\n+\tprivate static Logger log = LogUtil.getLogger(ModelBuilder.class);\n+\n+\tprivate @Getter FrankDocModel model;\n+\n+\tpublic ModelBuilder() {\n+\t\tmodel = new FrankDocModel();\n+\t\tmodel.setGroups(new ArrayList<>());\n+\t\tmodel.setAllElements(new HashMap<>());\n+\t}\n+\n+\t/**\n+\t * @param interfaceName The interface for which we want SpringBean objects.\n+\t * @return All classes implementing interfaceName, ordered by their full class name.\n+\t */\n+\tstatic List<SpringBean> getSpringBeans(final String interfaceName) {\n+\t\tClass<?> interfaze = InfoBuilderSource.getClass(interfaceName);\n+\t\tif(interfaze == null) {\n+\t\t\tthrow new NullPointerException(\"Class or interface is not available on the classpath: \" + interfaceName);\n+\t\t}\n+\t\tif(!interfaze.isInterface()) {\n+\t\t\tthrow new IllegalArgumentException(\"This exists on the classpath but is not an interface: \" + interfaceName);\n+\t\t}\n+\t\tSet<SpringBean> unfiltered = InfoBuilderSource.getSpringBeans(interfaze);\n+\t\tList<SpringBean> result = new ArrayList<SpringBean>();\n+\t\tfor(SpringBean b: unfiltered) {\n+\t\t\tif(interfaze.isAssignableFrom(b.getClazz())) {\n+\t\t\t\tresult.add(b);\n+\t\t\t}\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tFrankDocGroup addGroup(String name) {\n+\t\tFrankDocGroup group = new FrankDocGroup(name);\n+\t\tgroup.setElements(new HashMap<>());\n+\t\tmodel.getGroups().add(group);\n+\t\treturn group;\n+\t}\n+\n+\tvoid addElementsToGroup(Class<?> clazz, FrankDocGroup group) {\n+\t\tgroup.getElements().put(clazz.getName(), frankElement(clazz));\n+\t}\n+\n+\tFrankElement frankElement(Class<?> clazz) {\n+\t\tif(model.getAllElements().containsKey(clazz.getName())) {\n+\t\t\treturn model.getAllElements().get(clazz.getName());\n+\t\t}", "originalCommit": "c44111ba60f9a587b0afe45f459da5f965ddf0c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTg2MjExNw==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r501862117", "bodyText": "Gedaan", "author": "mhdirkse", "createdAt": "2020-10-08T16:41:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQxOTIwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQyNDIxOA==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r500424218", "bodyText": "Volgens mij kan je hier volstaan met:\nClass<?> superClass = clazz.getSuperclass()\nFrankElement parent = superClass == null ? null : findOrCreateFrankElement(superClass);\nFrankElement current = createFrankElement(clazz, parent);\nmodel.getAllElements().put(clazz.getName(), current );", "author": "gvanbrakel", "createdAt": "2020-10-06T16:11:54Z", "path": "core/src/main/java/nl/nn/adapterframework/doc/ModelBuilder.java", "diffHunk": "@@ -0,0 +1,265 @@\n+package nl.nn.adapterframework.doc;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n+import org.springframework.core.annotation.AnnotationUtils;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import nl.nn.adapterframework.doc.model.FrankAttribute;\n+import nl.nn.adapterframework.doc.model.FrankDocGroup;\n+import nl.nn.adapterframework.doc.model.FrankDocModel;\n+import nl.nn.adapterframework.doc.model.FrankElement;\n+import nl.nn.adapterframework.doc.objects.SpringBean;\n+import nl.nn.adapterframework.util.LogUtil;\n+\n+public class ModelBuilder {\n+\tprivate static final String JAVA_STRING = \"java.lang.String\";\n+\n+\tprivate static Logger log = LogUtil.getLogger(ModelBuilder.class);\n+\n+\tprivate @Getter FrankDocModel model;\n+\n+\tpublic ModelBuilder() {\n+\t\tmodel = new FrankDocModel();\n+\t\tmodel.setGroups(new ArrayList<>());\n+\t\tmodel.setAllElements(new HashMap<>());\n+\t}\n+\n+\t/**\n+\t * @param interfaceName The interface for which we want SpringBean objects.\n+\t * @return All classes implementing interfaceName, ordered by their full class name.\n+\t */\n+\tstatic List<SpringBean> getSpringBeans(final String interfaceName) {\n+\t\tClass<?> interfaze = InfoBuilderSource.getClass(interfaceName);\n+\t\tif(interfaze == null) {\n+\t\t\tthrow new NullPointerException(\"Class or interface is not available on the classpath: \" + interfaceName);\n+\t\t}\n+\t\tif(!interfaze.isInterface()) {\n+\t\t\tthrow new IllegalArgumentException(\"This exists on the classpath but is not an interface: \" + interfaceName);\n+\t\t}\n+\t\tSet<SpringBean> unfiltered = InfoBuilderSource.getSpringBeans(interfaze);\n+\t\tList<SpringBean> result = new ArrayList<SpringBean>();\n+\t\tfor(SpringBean b: unfiltered) {\n+\t\t\tif(interfaze.isAssignableFrom(b.getClazz())) {\n+\t\t\t\tresult.add(b);\n+\t\t\t}\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tFrankDocGroup addGroup(String name) {\n+\t\tFrankDocGroup group = new FrankDocGroup(name);\n+\t\tgroup.setElements(new HashMap<>());\n+\t\tmodel.getGroups().add(group);\n+\t\treturn group;\n+\t}\n+\n+\tvoid addElementsToGroup(Class<?> clazz, FrankDocGroup group) {\n+\t\tgroup.getElements().put(clazz.getName(), frankElement(clazz));\n+\t}\n+\n+\tFrankElement frankElement(Class<?> clazz) {\n+\t\tif(model.getAllElements().containsKey(clazz.getName())) {\n+\t\t\treturn model.getAllElements().get(clazz.getName());\n+\t\t}\n+\t\tList<Class<?>> classesForNewElements = new ArrayList<>();\n+\t\tFrankElement parent = null;\n+\t\tClass<?> superClass = clazz;\n+\t\twhile(true) {\n+\t\t\tclassesForNewElements.add(superClass);\n+\t\t\tsuperClass = superClass.getSuperclass();\n+\t\t\tif(superClass == null) {\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tif(model.getAllElements().containsKey(superClass.getName())) {\n+\t\t\t\tparent = model.getAllElements().get(superClass.getName());\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\t\tCollections.reverse(classesForNewElements);\n+\t\tfor(Class<?> seed: classesForNewElements) {\n+\t\t\tparent = createFrankElement(seed, parent);\n+\t\t\tmodel.getAllElements().put(parent.getFullName(), parent);\n+\t\t}\n+\t\treturn parent;\t\t", "originalCommit": "c44111ba60f9a587b0afe45f459da5f965ddf0c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc4Njg1OA==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r500786858", "bodyText": "Ja, ik heb deze code overgenomen. De testen slagen nog steeds. Afgehandeld.", "author": "mhdirkse", "createdAt": "2020-10-07T07:14:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQyNDIxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQyOTMyMA==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r500429320", "bodyText": "Waarom test je of er ook een getter is bij de setter? Dat is toch niet nodig?\nJe zou hoogstens een warning kunnen geven als er een getter is van een ander type dan de setter, want dat geeft problemen bij het laden van de configuratie.\nEn ook nog: als je zo'n test doet zoals hier, dan moet je niet eerst je hele candidate opbouwen en daarna pas checken of je hem wilt hebben, maar eerst die check doen.", "author": "gvanbrakel", "createdAt": "2020-10-06T16:19:44Z", "path": "core/src/main/java/nl/nn/adapterframework/doc/ModelBuilder.java", "diffHunk": "@@ -0,0 +1,265 @@\n+package nl.nn.adapterframework.doc;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n+import org.springframework.core.annotation.AnnotationUtils;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import nl.nn.adapterframework.doc.model.FrankAttribute;\n+import nl.nn.adapterframework.doc.model.FrankDocGroup;\n+import nl.nn.adapterframework.doc.model.FrankDocModel;\n+import nl.nn.adapterframework.doc.model.FrankElement;\n+import nl.nn.adapterframework.doc.objects.SpringBean;\n+import nl.nn.adapterframework.util.LogUtil;\n+\n+public class ModelBuilder {\n+\tprivate static final String JAVA_STRING = \"java.lang.String\";\n+\n+\tprivate static Logger log = LogUtil.getLogger(ModelBuilder.class);\n+\n+\tprivate @Getter FrankDocModel model;\n+\n+\tpublic ModelBuilder() {\n+\t\tmodel = new FrankDocModel();\n+\t\tmodel.setGroups(new ArrayList<>());\n+\t\tmodel.setAllElements(new HashMap<>());\n+\t}\n+\n+\t/**\n+\t * @param interfaceName The interface for which we want SpringBean objects.\n+\t * @return All classes implementing interfaceName, ordered by their full class name.\n+\t */\n+\tstatic List<SpringBean> getSpringBeans(final String interfaceName) {\n+\t\tClass<?> interfaze = InfoBuilderSource.getClass(interfaceName);\n+\t\tif(interfaze == null) {\n+\t\t\tthrow new NullPointerException(\"Class or interface is not available on the classpath: \" + interfaceName);\n+\t\t}\n+\t\tif(!interfaze.isInterface()) {\n+\t\t\tthrow new IllegalArgumentException(\"This exists on the classpath but is not an interface: \" + interfaceName);\n+\t\t}\n+\t\tSet<SpringBean> unfiltered = InfoBuilderSource.getSpringBeans(interfaze);\n+\t\tList<SpringBean> result = new ArrayList<SpringBean>();\n+\t\tfor(SpringBean b: unfiltered) {\n+\t\t\tif(interfaze.isAssignableFrom(b.getClazz())) {\n+\t\t\t\tresult.add(b);\n+\t\t\t}\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tFrankDocGroup addGroup(String name) {\n+\t\tFrankDocGroup group = new FrankDocGroup(name);\n+\t\tgroup.setElements(new HashMap<>());\n+\t\tmodel.getGroups().add(group);\n+\t\treturn group;\n+\t}\n+\n+\tvoid addElementsToGroup(Class<?> clazz, FrankDocGroup group) {\n+\t\tgroup.getElements().put(clazz.getName(), frankElement(clazz));\n+\t}\n+\n+\tFrankElement frankElement(Class<?> clazz) {\n+\t\tif(model.getAllElements().containsKey(clazz.getName())) {\n+\t\t\treturn model.getAllElements().get(clazz.getName());\n+\t\t}\n+\t\tList<Class<?>> classesForNewElements = new ArrayList<>();\n+\t\tFrankElement parent = null;\n+\t\tClass<?> superClass = clazz;\n+\t\twhile(true) {\n+\t\t\tclassesForNewElements.add(superClass);\n+\t\t\tsuperClass = superClass.getSuperclass();\n+\t\t\tif(superClass == null) {\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tif(model.getAllElements().containsKey(superClass.getName())) {\n+\t\t\t\tparent = model.getAllElements().get(superClass.getName());\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\t\tCollections.reverse(classesForNewElements);\n+\t\tfor(Class<?> seed: classesForNewElements) {\n+\t\t\tparent = createFrankElement(seed, parent);\n+\t\t\tmodel.getAllElements().put(parent.getFullName(), parent);\n+\t\t}\n+\t\treturn parent;\t\t\n+\t}\n+\n+\tFrankElement createFrankElement(Class<?> clazz, FrankElement parent) {\n+\t\tFrankElement result = new FrankElement(clazz.getName(), clazz.getSimpleName());\n+\t\tresult.setParent(parent);\n+\t\tresult.setAttributes(createAttributes(result, clazz.getDeclaredMethods()));\n+\t\treturn result;\n+\t}\n+\n+\tList<FrankAttribute> createAttributes(FrankElement frankElement, Method[] methods) {\n+\t\tMap<String, String> setterAttributes = getAttributeToMethodNameMap(methods, \"set\");\n+\t\tMap<String, String> getterAttributes = getAttributeToMethodNameMap(methods, \"get\");\n+\t\tgetterAttributes.putAll(getAttributeToMethodNameMap(methods, \"is\"));\n+\t\tMap<String, String> setterToAttributeName = new HashMap<>();\n+\t\tfor(String candidateAttributeName: setterAttributes.keySet()) {\n+\t\t\tsetterToAttributeName.put(setterAttributes.get(candidateAttributeName), candidateAttributeName);\n+\t\t}\n+\t\tList<FrankAttribute> result = new ArrayList<>();\n+\t\tfor(Method method: methods) {\n+\t\t\tif(setterToAttributeName.containsKey(method.getName())) {\n+\t\t\t\tString candidateAttributeName = setterToAttributeName.get(method.getName());\n+\t\t\t\tFrankAttribute candidate = new FrankAttribute(candidateAttributeName);\n+\t\t\t\tcandidate.setDescribingElement(frankElement);\n+\t\t\t\tboolean isDocumented = documentAttribute(candidate, method);\n+\t\t\t\tif(getterAttributes.containsKey(candidateAttributeName) || isDocumented) {", "originalCommit": "c44111ba60f9a587b0afe45f459da5f965ddf0c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ3MDI4NQ==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r500470285", "bodyText": "De check of er een getter is neem ik over van de bestaande code. Ik heb aangenomen dat als er alleen een setter is zonder annotaties, dat die dan niet bedoeld is als attribute. Als ik deze check weglaat, dan krijgen we misschien meer attributes dan er in de huidige Frank!Doc zijn.", "author": "mhdirkse", "createdAt": "2020-10-06T17:24:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQyOTMyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ3ODAyMw==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r500478023", "bodyText": "Over het bestaan van candidates die geen attributes hoeven te worden. Ik ging ervan uit dat een setter alleen geen attribute wordt. Maar je hebt zeker een attribute als er een @IbisDoc of @IbisDocRef op staat. Die annotaties moeten geparsed voordat je beslist of er sprake is van een attribute. Maar de data in de @IbisDoc annotatie hoort in een FrankAttribute. Het is dus handig om al een FrankAttribute te vullen bij het parsen van @IbisDoc. Wat vind je daarvan?", "author": "mhdirkse", "createdAt": "2020-10-06T17:36:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQyOTMyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc4Njc0MA==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r500786740", "bodyText": "De check of er een getter is neem ik over van de bestaande code. Ik heb aangenomen dat als er alleen een setter is zonder annotaties, dat die dan niet bedoeld is als attribute. Als ik deze check weglaat, dan krijgen we misschien meer attributes dan er in de huidige Frank!Doc zijn.\n\nHet is het beste om het volgende te doen:\n\ncheck of de getter van het zelfde type is als het argument van de setter. Als dat niet zo is, geef dan een waarschuwing aan de Core developer\nals er een setter is met een primitive type (string, int, boolean, ...) argument, zonder @IbisDoc of @IbisDocRef, geef dan een waarschuwing aan de Core developer. Voor het geval dat we echt geen documentatie willen, kan er een @NoIbisDoc annotatie komen. Als en zolang die @NoIbisDoc er niet is komt het attribuut wel in de ibisdoc, zonder beschrijving.\n\n\nHet is dus handig om al een FrankAttribute te vullen bij het parsen van @IbisDoc.\n\nDat lijkt me inderdaad de goede manier", "author": "gvanbrakel", "createdAt": "2020-10-07T07:14:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQyOTMyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc5OTYxMw==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r501799613", "bodyText": "Gedaan.", "author": "mhdirkse", "createdAt": "2020-10-08T15:10:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQyOTMyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQyOTk4NA==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r500429984", "bodyText": "Dit moet een method van FrankElement zijn", "author": "gvanbrakel", "createdAt": "2020-10-06T16:20:39Z", "path": "core/src/main/java/nl/nn/adapterframework/doc/ModelBuilder.java", "diffHunk": "@@ -0,0 +1,265 @@\n+package nl.nn.adapterframework.doc;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n+import org.springframework.core.annotation.AnnotationUtils;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import nl.nn.adapterframework.doc.model.FrankAttribute;\n+import nl.nn.adapterframework.doc.model.FrankDocGroup;\n+import nl.nn.adapterframework.doc.model.FrankDocModel;\n+import nl.nn.adapterframework.doc.model.FrankElement;\n+import nl.nn.adapterframework.doc.objects.SpringBean;\n+import nl.nn.adapterframework.util.LogUtil;\n+\n+public class ModelBuilder {\n+\tprivate static final String JAVA_STRING = \"java.lang.String\";\n+\n+\tprivate static Logger log = LogUtil.getLogger(ModelBuilder.class);\n+\n+\tprivate @Getter FrankDocModel model;\n+\n+\tpublic ModelBuilder() {\n+\t\tmodel = new FrankDocModel();\n+\t\tmodel.setGroups(new ArrayList<>());\n+\t\tmodel.setAllElements(new HashMap<>());\n+\t}\n+\n+\t/**\n+\t * @param interfaceName The interface for which we want SpringBean objects.\n+\t * @return All classes implementing interfaceName, ordered by their full class name.\n+\t */\n+\tstatic List<SpringBean> getSpringBeans(final String interfaceName) {\n+\t\tClass<?> interfaze = InfoBuilderSource.getClass(interfaceName);\n+\t\tif(interfaze == null) {\n+\t\t\tthrow new NullPointerException(\"Class or interface is not available on the classpath: \" + interfaceName);\n+\t\t}\n+\t\tif(!interfaze.isInterface()) {\n+\t\t\tthrow new IllegalArgumentException(\"This exists on the classpath but is not an interface: \" + interfaceName);\n+\t\t}\n+\t\tSet<SpringBean> unfiltered = InfoBuilderSource.getSpringBeans(interfaze);\n+\t\tList<SpringBean> result = new ArrayList<SpringBean>();\n+\t\tfor(SpringBean b: unfiltered) {\n+\t\t\tif(interfaze.isAssignableFrom(b.getClazz())) {\n+\t\t\t\tresult.add(b);\n+\t\t\t}\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tFrankDocGroup addGroup(String name) {\n+\t\tFrankDocGroup group = new FrankDocGroup(name);\n+\t\tgroup.setElements(new HashMap<>());\n+\t\tmodel.getGroups().add(group);\n+\t\treturn group;\n+\t}\n+\n+\tvoid addElementsToGroup(Class<?> clazz, FrankDocGroup group) {\n+\t\tgroup.getElements().put(clazz.getName(), frankElement(clazz));\n+\t}\n+\n+\tFrankElement frankElement(Class<?> clazz) {\n+\t\tif(model.getAllElements().containsKey(clazz.getName())) {\n+\t\t\treturn model.getAllElements().get(clazz.getName());\n+\t\t}\n+\t\tList<Class<?>> classesForNewElements = new ArrayList<>();\n+\t\tFrankElement parent = null;\n+\t\tClass<?> superClass = clazz;\n+\t\twhile(true) {\n+\t\t\tclassesForNewElements.add(superClass);\n+\t\t\tsuperClass = superClass.getSuperclass();\n+\t\t\tif(superClass == null) {\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tif(model.getAllElements().containsKey(superClass.getName())) {\n+\t\t\t\tparent = model.getAllElements().get(superClass.getName());\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\t\tCollections.reverse(classesForNewElements);\n+\t\tfor(Class<?> seed: classesForNewElements) {\n+\t\t\tparent = createFrankElement(seed, parent);\n+\t\t\tmodel.getAllElements().put(parent.getFullName(), parent);\n+\t\t}\n+\t\treturn parent;\t\t\n+\t}\n+\n+\tFrankElement createFrankElement(Class<?> clazz, FrankElement parent) {\n+\t\tFrankElement result = new FrankElement(clazz.getName(), clazz.getSimpleName());\n+\t\tresult.setParent(parent);\n+\t\tresult.setAttributes(createAttributes(result, clazz.getDeclaredMethods()));\n+\t\treturn result;\n+\t}\n+\n+\tList<FrankAttribute> createAttributes(FrankElement frankElement, Method[] methods) {", "originalCommit": "c44111ba60f9a587b0afe45f459da5f965ddf0c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTg1NTIxOQ==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r501855219", "bodyText": "Gedaan", "author": "mhdirkse", "createdAt": "2020-10-08T16:30:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQyOTk4NA=="}], "type": "inlineReview"}, {"oid": "70222206d0c49546900f0330f4bbef0e8db9fc1a", "url": "https://github.com/ibissource/iaf/commit/70222206d0c49546900f0330f4bbef0e8db9fc1a", "message": "Fix the tests to check that the parent of a FrankElement is set", "committedDate": "2020-10-06T17:05:49Z", "type": "commit"}, {"oid": "d25b2217460e60b695ff6d1259f415da0e3325cc", "url": "https://github.com/ibissource/iaf/commit/d25b2217460e60b695ff6d1259f415da0e3325cc", "message": "Improve implementation of method frankElement()", "committedDate": "2020-10-07T07:13:52Z", "type": "commit"}, {"oid": "3fbb8b04a2c32a1f5cb72e4e1b53ce693ba85f23", "url": "https://github.com/ibissource/iaf/commit/3fbb8b04a2c32a1f5cb72e4e1b53ce693ba85f23", "message": "Remove field digesterRulesRef", "committedDate": "2020-10-07T07:26:57Z", "type": "commit"}, {"oid": "11e714107e7aa1c801fb41342a06ddafbaace195", "url": "https://github.com/ibissource/iaf/commit/11e714107e7aa1c801fb41342a06ddafbaace195", "message": "Add warnings to the log for irregularities in attribute methods", "committedDate": "2020-10-07T15:34:42Z", "type": "commit"}, {"oid": "9bdbfa8a2a5d74063e0d9734d171045188e74f7c", "url": "https://github.com/ibissource/iaf/commit/9bdbfa8a2a5d74063e0d9734d171045188e74f7c", "message": "Setter without getter is attribute, and fix logging", "committedDate": "2020-10-08T15:02:33Z", "type": "commit"}, {"oid": "37117d7bdc24b8f4c062a0b64293144b8faf16bd", "url": "https://github.com/ibissource/iaf/commit/37117d7bdc24b8f4c062a0b64293144b8faf16bd", "message": "Write a log message if an attribute has no getter", "committedDate": "2020-10-08T15:09:44Z", "type": "commit"}, {"oid": "e6c3e5d8c26335fb870f8624f49f13b2c561b8c4", "url": "https://github.com/ibissource/iaf/commit/e6c3e5d8c26335fb870f8624f49f13b2c561b8c4", "message": "Move construction logic of FrankElement to that class", "committedDate": "2020-10-08T16:22:18Z", "type": "commit"}, {"oid": "1c7191224c232b31e9f4bc28581877f539da289f", "url": "https://github.com/ibissource/iaf/commit/1c7191224c232b31e9f4bc28581877f539da289f", "message": "Remove setters from FrankElement", "committedDate": "2020-10-08T16:27:11Z", "type": "commit"}, {"oid": "c0d00be211e43cc1857a0369e4dc4f7b74e157fa", "url": "https://github.com/ibissource/iaf/commit/c0d00be211e43cc1857a0369e4dc4f7b74e157fa", "message": "Move frankElement() to FrankDocModel", "committedDate": "2020-10-08T16:41:16Z", "type": "commit"}, {"oid": "957c234780d27e630642b72eeb654d7ecbb2e74f", "url": "https://github.com/ibissource/iaf/commit/957c234780d27e630642b72eeb654d7ecbb2e74f", "message": "Improve constructors", "committedDate": "2020-10-08T16:47:09Z", "type": "commit"}, {"oid": "0f9c6bc6c9eec77c0673c8ce540e3a980fd75340", "url": "https://github.com/ibissource/iaf/commit/0f9c6bc6c9eec77c0673c8ce540e3a980fd75340", "message": "Move addGroup() to the model class", "committedDate": "2020-10-08T16:54:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjI1Njg4Mg==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r502256882", "bodyText": "Dit kan beter een method addAsElement() van FrankDocGroup zijn", "author": "gvanbrakel", "createdAt": "2020-10-09T08:04:31Z", "path": "core/src/main/java/nl/nn/adapterframework/doc/ModelBuilder.java", "diffHunk": "@@ -0,0 +1,48 @@\n+package nl.nn.adapterframework.doc;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+\n+import lombok.Getter;\n+import nl.nn.adapterframework.doc.model.FrankDocGroup;\n+import nl.nn.adapterframework.doc.model.FrankDocModel;\n+import nl.nn.adapterframework.doc.objects.SpringBean;\n+\n+public class ModelBuilder {\n+\tprivate @Getter FrankDocModel model;\n+\n+\tpublic ModelBuilder() {\n+\t\tmodel = new FrankDocModel();\n+\t}\n+\n+\t/**\n+\t * @param interfaceName The interface for which we want SpringBean objects.\n+\t * @return All classes implementing interfaceName, ordered by their full class name.\n+\t */\n+\tstatic List<SpringBean> getSpringBeans(final String interfaceName) {\n+\t\tClass<?> interfaze = getClass(interfaceName);\n+\t\tif(interfaze == null) {\n+\t\t\tthrow new NullPointerException(\"Class or interface is not available on the classpath: \" + interfaceName);\n+\t\t}\n+\t\tif(!interfaze.isInterface()) {\n+\t\t\tthrow new IllegalArgumentException(\"This exists on the classpath but is not an interface: \" + interfaceName);\n+\t\t}\n+\t\tSet<SpringBean> unfiltered = InfoBuilderSource.getSpringBeans(interfaze);\n+\t\tList<SpringBean> result = new ArrayList<SpringBean>();\n+\t\tfor(SpringBean b: unfiltered) {\n+\t\t\tif(interfaze.isAssignableFrom(b.getClazz())) {\n+\t\t\t\tresult.add(b);\n+\t\t\t}\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tvoid addElementsToGroup(Class<?> clazz, FrankDocGroup group) {\n+\t\tgroup.getElements().put(clazz.getName(), model.frankElement(clazz));\n+\t}", "originalCommit": "0f9c6bc6c9eec77c0673c8ce540e3a980fd75340", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjUwMzQwNA==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r502503404", "bodyText": "Gedaan.", "author": "mhdirkse", "createdAt": "2020-10-09T15:19:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjI1Njg4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjI2MjE4OA==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r502262188", "bodyText": "Dit moet een method van FrankDocModel zijn, en dan findOrCreateFrankElement() heten.\nJe hebt dan ook het FrankElementStore interface niet nodig.", "author": "gvanbrakel", "createdAt": "2020-10-09T08:13:31Z", "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankElement.java", "diffHunk": "@@ -0,0 +1,249 @@\n+package nl.nn.adapterframework.doc.model;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n+import org.springframework.core.annotation.AnnotationUtils;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import nl.nn.adapterframework.doc.IbisDoc;\n+import nl.nn.adapterframework.doc.IbisDocRef;\n+import nl.nn.adapterframework.util.LogUtil;\n+\n+public class FrankElement {\n+\tprivate static Logger log = LogUtil.getLogger(FrankElement.class);\n+\n+\tprivate static final String JAVA_STRING = \"java.lang.String\";\n+\n+\tprivate final @Getter String fullName;\n+\tprivate final @Getter String simpleName;\n+\tprivate @Getter FrankElement parent;\n+\tprivate @Getter List<FrankAttribute> attributes;\n+\n+\tpublic interface FrankElementStore {\n+\t\tboolean hasFrankElement(String name);\n+\t\tFrankElement getFrankElement(String name);\n+\t\tvoid addFrankElement(FrankElement frankElement);\n+\t\tint numFrankElements();\n+\t}\n+\n+\tpublic static FrankElement frankElement(Class<?> clazz, FrankElementStore store) {\n+\t\tif(store.hasFrankElement(clazz.getName())) {\n+\t\t\treturn store.getFrankElement(clazz.getName());\n+\t\t}\n+\t\tClass<?> superClass = clazz.getSuperclass();\n+\t\tFrankElement parent = superClass == null ? null : frankElement(superClass, store);\n+\t\tFrankElement current = new FrankElement(clazz, parent, store);\n+\t\tstore.addFrankElement(current);\n+\t\treturn current;\n+\t}", "originalCommit": "0f9c6bc6c9eec77c0673c8ce540e3a980fd75340", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjI5MDUzMg==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r502290532", "bodyText": "Hoe wil je dat er bij het parsen van @IbisDocRef annotaties FrankElement objecten gemaakt kunnen worden? Je zit in FrankElement of FrankAttribute en je wilt een FrankElement object maken voor de class waar @IbisDocRef naar wijst. Hoe wil je dat geregeld hebben?", "author": "mhdirkse", "createdAt": "2020-10-09T09:03:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjI2MjE4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQwNTU3NA==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r502405574", "bodyText": "Gedaan.", "author": "mhdirkse", "createdAt": "2020-10-09T12:52:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjI2MjE4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjI2NjIwMA==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r502266200", "bodyText": "Heb je deze constructor zonder parent nu al nodig?", "author": "gvanbrakel", "createdAt": "2020-10-09T08:20:27Z", "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankElement.java", "diffHunk": "@@ -0,0 +1,249 @@\n+package nl.nn.adapterframework.doc.model;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n+import org.springframework.core.annotation.AnnotationUtils;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import nl.nn.adapterframework.doc.IbisDoc;\n+import nl.nn.adapterframework.doc.IbisDocRef;\n+import nl.nn.adapterframework.util.LogUtil;\n+\n+public class FrankElement {\n+\tprivate static Logger log = LogUtil.getLogger(FrankElement.class);\n+\n+\tprivate static final String JAVA_STRING = \"java.lang.String\";\n+\n+\tprivate final @Getter String fullName;\n+\tprivate final @Getter String simpleName;\n+\tprivate @Getter FrankElement parent;\n+\tprivate @Getter List<FrankAttribute> attributes;\n+\n+\tpublic interface FrankElementStore {\n+\t\tboolean hasFrankElement(String name);\n+\t\tFrankElement getFrankElement(String name);\n+\t\tvoid addFrankElement(FrankElement frankElement);\n+\t\tint numFrankElements();\n+\t}\n+\n+\tpublic static FrankElement frankElement(Class<?> clazz, FrankElementStore store) {\n+\t\tif(store.hasFrankElement(clazz.getName())) {\n+\t\t\treturn store.getFrankElement(clazz.getName());\n+\t\t}\n+\t\tClass<?> superClass = clazz.getSuperclass();\n+\t\tFrankElement parent = superClass == null ? null : frankElement(superClass, store);\n+\t\tFrankElement current = new FrankElement(clazz, parent, store);\n+\t\tstore.addFrankElement(current);\n+\t\treturn current;\n+\t}\n+\n+\tFrankElement(Class<?> clazz, FrankElement parent, FrankElementStore store) {\n+\t\tthis(clazz.getName(), clazz.getSimpleName());\n+\t\tthis.parent = parent;\n+\t\tthis.attributes = createAttributes(clazz.getDeclaredMethods(), store);\n+\t}\n+\n+\tFrankElement(final String fullName, final String simpleName) {", "originalCommit": "0f9c6bc6c9eec77c0673c8ce540e3a980fd75340", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjI4OTM0Mg==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r502289342", "bodyText": "Ik gebruik hem in de tests. Heb je gezien dat hij niet public is?", "author": "mhdirkse", "createdAt": "2020-10-09T09:00:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjI2NjIwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjI2NzE3NQ==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r502267175", "bodyText": "Deze warning moet er niet zijn.", "author": "gvanbrakel", "createdAt": "2020-10-09T08:22:17Z", "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankElement.java", "diffHunk": "@@ -0,0 +1,249 @@\n+package nl.nn.adapterframework.doc.model;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n+import org.springframework.core.annotation.AnnotationUtils;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import nl.nn.adapterframework.doc.IbisDoc;\n+import nl.nn.adapterframework.doc.IbisDocRef;\n+import nl.nn.adapterframework.util.LogUtil;\n+\n+public class FrankElement {\n+\tprivate static Logger log = LogUtil.getLogger(FrankElement.class);\n+\n+\tprivate static final String JAVA_STRING = \"java.lang.String\";\n+\n+\tprivate final @Getter String fullName;\n+\tprivate final @Getter String simpleName;\n+\tprivate @Getter FrankElement parent;\n+\tprivate @Getter List<FrankAttribute> attributes;\n+\n+\tpublic interface FrankElementStore {\n+\t\tboolean hasFrankElement(String name);\n+\t\tFrankElement getFrankElement(String name);\n+\t\tvoid addFrankElement(FrankElement frankElement);\n+\t\tint numFrankElements();\n+\t}\n+\n+\tpublic static FrankElement frankElement(Class<?> clazz, FrankElementStore store) {\n+\t\tif(store.hasFrankElement(clazz.getName())) {\n+\t\t\treturn store.getFrankElement(clazz.getName());\n+\t\t}\n+\t\tClass<?> superClass = clazz.getSuperclass();\n+\t\tFrankElement parent = superClass == null ? null : frankElement(superClass, store);\n+\t\tFrankElement current = new FrankElement(clazz, parent, store);\n+\t\tstore.addFrankElement(current);\n+\t\treturn current;\n+\t}\n+\n+\tFrankElement(Class<?> clazz, FrankElement parent, FrankElementStore store) {\n+\t\tthis(clazz.getName(), clazz.getSimpleName());\n+\t\tthis.parent = parent;\n+\t\tthis.attributes = createAttributes(clazz.getDeclaredMethods(), store);\n+\t}\n+\n+\tFrankElement(final String fullName, final String simpleName) {\n+\t\tthis.fullName = fullName;\n+\t\tthis.simpleName = simpleName;\n+\t}\n+\n+\tList<FrankAttribute> createAttributes(Method[] methods, FrankElementStore store) {\n+\t\tMap<String, Method> setterAttributes = getAttributeToMethodMap(methods, \"set\");\n+\t\tMap<String, Method> getterAttributes = getGetterAndIsserAttributes(methods);\n+\t\tMap<String, String> setterToAttributeName = new HashMap<>();\n+\t\tfor(String attributeName: setterAttributes.keySet()) {\n+\t\t\tsetterToAttributeName.put(setterAttributes.get(attributeName).getName(), attributeName);\n+\t\t}\n+\t\tList<FrankAttribute> result = new ArrayList<>();\n+\t\tfor(Method method: methods) {\n+\t\t\tif(setterToAttributeName.containsKey(method.getName())) {\n+\t\t\t\tString attributeName = setterToAttributeName.get(method.getName());\n+\t\t\t\tif(getterAttributes.containsKey(attributeName)) {\n+\t\t\t\t\tcompareGetterWithSetter(method, getterAttributes.get(attributeName));\n+\t\t\t\t} else {\n+\t\t\t\t\tlog.warn(String.format(\"FrankElement %s and attribute %s: no getter method\",\n+\t\t\t\t\t\t\tsimpleName, attributeName));", "originalCommit": "0f9c6bc6c9eec77c0673c8ce540e3a980fd75340", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQwNTE4Nw==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r502405187", "bodyText": "Gedaan.", "author": "mhdirkse", "createdAt": "2020-10-09T12:51:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjI2NzE3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjI3NDU1Nw==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r502274557", "bodyText": "Deze method moet verhuizen naar FrankAttribute, en dan parseIbisDocAnnotation() heten.", "author": "gvanbrakel", "createdAt": "2020-10-09T08:35:50Z", "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankElement.java", "diffHunk": "@@ -0,0 +1,249 @@\n+package nl.nn.adapterframework.doc.model;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n+import org.springframework.core.annotation.AnnotationUtils;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import nl.nn.adapterframework.doc.IbisDoc;\n+import nl.nn.adapterframework.doc.IbisDocRef;\n+import nl.nn.adapterframework.util.LogUtil;\n+\n+public class FrankElement {\n+\tprivate static Logger log = LogUtil.getLogger(FrankElement.class);\n+\n+\tprivate static final String JAVA_STRING = \"java.lang.String\";\n+\n+\tprivate final @Getter String fullName;\n+\tprivate final @Getter String simpleName;\n+\tprivate @Getter FrankElement parent;\n+\tprivate @Getter List<FrankAttribute> attributes;\n+\n+\tpublic interface FrankElementStore {\n+\t\tboolean hasFrankElement(String name);\n+\t\tFrankElement getFrankElement(String name);\n+\t\tvoid addFrankElement(FrankElement frankElement);\n+\t\tint numFrankElements();\n+\t}\n+\n+\tpublic static FrankElement frankElement(Class<?> clazz, FrankElementStore store) {\n+\t\tif(store.hasFrankElement(clazz.getName())) {\n+\t\t\treturn store.getFrankElement(clazz.getName());\n+\t\t}\n+\t\tClass<?> superClass = clazz.getSuperclass();\n+\t\tFrankElement parent = superClass == null ? null : frankElement(superClass, store);\n+\t\tFrankElement current = new FrankElement(clazz, parent, store);\n+\t\tstore.addFrankElement(current);\n+\t\treturn current;\n+\t}\n+\n+\tFrankElement(Class<?> clazz, FrankElement parent, FrankElementStore store) {\n+\t\tthis(clazz.getName(), clazz.getSimpleName());\n+\t\tthis.parent = parent;\n+\t\tthis.attributes = createAttributes(clazz.getDeclaredMethods(), store);\n+\t}\n+\n+\tFrankElement(final String fullName, final String simpleName) {\n+\t\tthis.fullName = fullName;\n+\t\tthis.simpleName = simpleName;\n+\t}\n+\n+\tList<FrankAttribute> createAttributes(Method[] methods, FrankElementStore store) {\n+\t\tMap<String, Method> setterAttributes = getAttributeToMethodMap(methods, \"set\");\n+\t\tMap<String, Method> getterAttributes = getGetterAndIsserAttributes(methods);\n+\t\tMap<String, String> setterToAttributeName = new HashMap<>();\n+\t\tfor(String attributeName: setterAttributes.keySet()) {\n+\t\t\tsetterToAttributeName.put(setterAttributes.get(attributeName).getName(), attributeName);\n+\t\t}\n+\t\tList<FrankAttribute> result = new ArrayList<>();\n+\t\tfor(Method method: methods) {\n+\t\t\tif(setterToAttributeName.containsKey(method.getName())) {\n+\t\t\t\tString attributeName = setterToAttributeName.get(method.getName());\n+\t\t\t\tif(getterAttributes.containsKey(attributeName)) {\n+\t\t\t\t\tcompareGetterWithSetter(method, getterAttributes.get(attributeName));\n+\t\t\t\t} else {\n+\t\t\t\t\tlog.warn(String.format(\"FrankElement %s and attribute %s: no getter method\",\n+\t\t\t\t\t\t\tsimpleName, attributeName));\n+\t\t\t\t}\n+\t\t\t\tFrankAttribute attribute = new FrankAttribute(attributeName);\n+\t\t\t\tattribute.setDescribingElement(this);\n+\t\t\t\tdocumentAttribute(attribute, method, store);\n+\t\t\t\tresult.add(attribute);\n+\t\t\t}\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tprivate Map<String, Method> getGetterAndIsserAttributes(Method[] methods) {\n+\t\tMap<String, Method> getterAttributes = getAttributeToMethodMap(methods, \"get\");\n+\t\tMap<String, Method> isserAttributes = getAttributeToMethodMap(methods, \"is\");\n+\t\tfor(String isserAttributeName : isserAttributes.keySet()) {\n+\t\t\tif(getterAttributes.containsKey(isserAttributeName)) {\n+\t\t\t\tlog.warn(String.format(\"For FrankElement %s, attribute %s has both a getX and an isX method\",\n+\t\t\t\t\t\tsimpleName, isserAttributeName));\n+\t\t\t} else {\n+\t\t\t\tgetterAttributes.put(isserAttributeName, isserAttributes.get(isserAttributeName));\n+\t\t\t}\n+\t\t}\n+\t\treturn getterAttributes;\n+\t}\n+\n+\tstatic Map<String, Method> getAttributeToMethodMap(Method[] methods, String prefix) {\n+\t\tList<Method> methodList = Arrays.asList(methods);\n+\t\tmethodList = methodList.stream()\n+\t\t\t\t.filter(FrankElement::isGetterOrSetter)\n+\t\t\t\t.filter(m -> m.getName().startsWith(prefix) && (m.getName().length() > prefix.length()))\n+\t\t\t\t.collect(Collectors.toList());\t\t\n+\t\tMap<String, Method> result = new HashMap<>();\n+\t\tfor(Method method: methodList) {\n+\t\t\tString strippedName = method.getName().substring(prefix.length());\n+\t\t\tString attributeName = strippedName.substring(0, 1).toLowerCase() + strippedName.substring(1);\n+\t\t\tresult.put(attributeName, method);\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tstatic boolean isGetterOrSetter(Method method) {\n+\t\tboolean isSetter = method.getReturnType().isPrimitive()\n+\t\t\t\t&& method.getReturnType().getName().equals(\"void\")\n+\t\t\t\t&& (method.getParameterTypes().length == 1)\n+\t\t\t\t&& (method.getParameterTypes()[0].isPrimitive()\n+\t\t\t\t\t\t|| method.getParameterTypes()[0].getName().equals(JAVA_STRING));\n+\t\tboolean isGetter = (\n+\t\t\t\t\tmethod.getReturnType().isPrimitive()\n+\t\t\t\t\t|| method.getReturnType().getName().equals(JAVA_STRING)\n+\t\t\t\t) && (method.getParameterTypes().length == 0);\n+\t\treturn isSetter || isGetter;\n+\t}\n+\n+\tprivate void compareGetterWithSetter(Method setter, Method getter) {\n+\t\tString setterType = setter.getParameterTypes()[0].getName();\n+\t\tString getterType = getter.getReturnType().getName();\n+\t\tif(! getterType.equals(setterType)) {\n+\t\t\tlog.warn(String.format(\"In Frank element %s: setter %s has type %s while the getter has type %s\",\n+\t\t\t\t\tsimpleName, setter.getName(), setterType, getterType));\n+\t\t}\n+\t}\n+\n+\tprivate void documentAttribute(\n+\t\t\tFrankAttribute attribute,\n+\t\t\tMethod method,\n+\t\t\tFrankElementStore store) {\n+\t\tattribute.setDeprecated(AnnotationUtils.findAnnotation(method, Deprecated.class) != null);\n+\t\tIbisDocRef ibisDocRef = AnnotationUtils.findAnnotation(method, IbisDocRef.class);\n+\t\tif(ibisDocRef != null) {\n+\t\t\tParsedIbisDocRef parsed = parseIbisDocRef(ibisDocRef, method);\n+\t\t\tIbisDoc ibisDoc = AnnotationUtils.findAnnotation(parsed.getReferredMethod(), IbisDoc.class);\n+\t\t\tif(ibisDoc != null) {\n+\t\t\t\tattribute.setDescribingElement(frankElement(\n+\t\t\t\t\t\tparsed.getReferredMethod().getDeclaringClass(), store));\n+\t\t\t\tibisDocIntoFrankElement(ibisDoc, attribute);\n+\t\t\t\tif(parsed.hasOrder) {\n+\t\t\t\t\tattribute.setOrder(parsed.getOrder());\n+\t\t\t\t}\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t\tIbisDoc ibisDoc = AnnotationUtils.findAnnotation(method, IbisDoc.class);\n+\t\tif(ibisDoc != null) {\n+\t\t\tibisDocIntoFrankElement(ibisDoc, attribute);\n+\t\t}\n+\t\telse {\n+\t\t\tlog.warn(String.format(\"No documentation available for FrankElement %s, attribute %s\",\n+\t\t\t\t\tsimpleName, attribute.getName()));\n+\t\t}\n+\t}\n+\n+\tprivate class ParsedIbisDocRef {\n+\t\tprivate @Getter @Setter boolean hasOrder;\n+\t\tprivate @Getter @Setter int order;\n+\t\tprivate @Getter @Setter Method referredMethod;\n+\t}\n+\n+\tprivate ParsedIbisDocRef parseIbisDocRef(IbisDocRef ibisDocRef, Method originalMethod) {\n+\t\tParsedIbisDocRef result = new ParsedIbisDocRef();\n+\t\tresult.setHasOrder(false);\n+\t\tString[] values = ibisDocRef.value();\n+\t\tString methodString = null;\n+\t\tif (values.length == 1) {\n+\t\t\tmethodString = ibisDocRef.value()[0];\n+\t\t} else if (values.length == 2) {\n+\t\t\tmethodString = ibisDocRef.value()[1];\n+\t\t\ttry {\n+\t\t\t\tresult.setOrder(Integer.parseInt(ibisDocRef.value()[0]));\n+\t\t\t\tresult.setHasOrder(true);\n+\t\t\t} catch (Throwable t) {\n+\t\t\t\tlog.warn(String.format(\"Could not parse order in @IbisDocRef annotation: \"\n+\t\t\t\t\t\t+ Integer.parseInt(ibisDocRef.value()[0])));\n+\t\t\t}\n+\t\t}\n+\t\telse {\n+\t\t\tlog.warn(String.format(String.format(\"Invalid @IbisDocRef annotation on method: %s.%s\",\n+\t\t\t\t\toriginalMethod.getDeclaringClass().getName(), originalMethod.getName())));\n+\t\t\treturn null;\n+\t\t}\n+\t\tresult.setReferredMethod(getReferredMethod(methodString, originalMethod));\n+\t\treturn result;\n+\t}\n+\n+\tprivate static Method getReferredMethod(String methodString, Method originalMethod) {\n+\t\tString lastNameComponent = methodString.substring(methodString.lastIndexOf(\".\") + 1).trim();\n+\t\tchar firstLetter = lastNameComponent.toCharArray()[0];\n+\t\tString fullClassName = methodString;\n+\t\tString methodName = lastNameComponent;\n+\t\tif (Character.isLowerCase(firstLetter)) {\n+\t\t\tint index = methodString.lastIndexOf(\".\");\n+\t\t\tfullClassName = methodString.substring(0, index);\n+\t\t} else {\n+\t\t\tmethodName = originalMethod.getName();\n+\t\t}\n+\t\treturn getParentMethod(fullClassName, methodName);\n+\t}\n+\n+\tprivate static Method getParentMethod(String className, String methodName) {\n+\t\ttry {\n+\t\t\tClass<?> parentClass = Class.forName(className);\n+\t\t\tfor (Method parentMethod : parentClass.getMethods()) {\n+\t\t\t\tif (parentMethod.getName().equals(methodName)) {\n+\t\t\t\t\treturn parentMethod;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn null;\n+\t\t} catch (ClassNotFoundException e) {\n+\t\t\tlog.warn(String.format(\"Super class [\" + e + \"] was not found!\"));\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n+\tprivate void ibisDocIntoFrankElement(IbisDoc ibisDoc, FrankAttribute attribute) {", "originalCommit": "0f9c6bc6c9eec77c0673c8ce540e3a980fd75340", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQwNDA5OA==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r502404098", "bodyText": "Gedaan.", "author": "mhdirkse", "createdAt": "2020-10-09T12:50:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjI3NDU1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjI3NTk4NQ==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r502275985", "bodyText": "Het is niet 'e' die niet gevonden is, maar 'className'", "author": "gvanbrakel", "createdAt": "2020-10-09T08:38:24Z", "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankElement.java", "diffHunk": "@@ -0,0 +1,249 @@\n+package nl.nn.adapterframework.doc.model;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n+import org.springframework.core.annotation.AnnotationUtils;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import nl.nn.adapterframework.doc.IbisDoc;\n+import nl.nn.adapterframework.doc.IbisDocRef;\n+import nl.nn.adapterframework.util.LogUtil;\n+\n+public class FrankElement {\n+\tprivate static Logger log = LogUtil.getLogger(FrankElement.class);\n+\n+\tprivate static final String JAVA_STRING = \"java.lang.String\";\n+\n+\tprivate final @Getter String fullName;\n+\tprivate final @Getter String simpleName;\n+\tprivate @Getter FrankElement parent;\n+\tprivate @Getter List<FrankAttribute> attributes;\n+\n+\tpublic interface FrankElementStore {\n+\t\tboolean hasFrankElement(String name);\n+\t\tFrankElement getFrankElement(String name);\n+\t\tvoid addFrankElement(FrankElement frankElement);\n+\t\tint numFrankElements();\n+\t}\n+\n+\tpublic static FrankElement frankElement(Class<?> clazz, FrankElementStore store) {\n+\t\tif(store.hasFrankElement(clazz.getName())) {\n+\t\t\treturn store.getFrankElement(clazz.getName());\n+\t\t}\n+\t\tClass<?> superClass = clazz.getSuperclass();\n+\t\tFrankElement parent = superClass == null ? null : frankElement(superClass, store);\n+\t\tFrankElement current = new FrankElement(clazz, parent, store);\n+\t\tstore.addFrankElement(current);\n+\t\treturn current;\n+\t}\n+\n+\tFrankElement(Class<?> clazz, FrankElement parent, FrankElementStore store) {\n+\t\tthis(clazz.getName(), clazz.getSimpleName());\n+\t\tthis.parent = parent;\n+\t\tthis.attributes = createAttributes(clazz.getDeclaredMethods(), store);\n+\t}\n+\n+\tFrankElement(final String fullName, final String simpleName) {\n+\t\tthis.fullName = fullName;\n+\t\tthis.simpleName = simpleName;\n+\t}\n+\n+\tList<FrankAttribute> createAttributes(Method[] methods, FrankElementStore store) {\n+\t\tMap<String, Method> setterAttributes = getAttributeToMethodMap(methods, \"set\");\n+\t\tMap<String, Method> getterAttributes = getGetterAndIsserAttributes(methods);\n+\t\tMap<String, String> setterToAttributeName = new HashMap<>();\n+\t\tfor(String attributeName: setterAttributes.keySet()) {\n+\t\t\tsetterToAttributeName.put(setterAttributes.get(attributeName).getName(), attributeName);\n+\t\t}\n+\t\tList<FrankAttribute> result = new ArrayList<>();\n+\t\tfor(Method method: methods) {\n+\t\t\tif(setterToAttributeName.containsKey(method.getName())) {\n+\t\t\t\tString attributeName = setterToAttributeName.get(method.getName());\n+\t\t\t\tif(getterAttributes.containsKey(attributeName)) {\n+\t\t\t\t\tcompareGetterWithSetter(method, getterAttributes.get(attributeName));\n+\t\t\t\t} else {\n+\t\t\t\t\tlog.warn(String.format(\"FrankElement %s and attribute %s: no getter method\",\n+\t\t\t\t\t\t\tsimpleName, attributeName));\n+\t\t\t\t}\n+\t\t\t\tFrankAttribute attribute = new FrankAttribute(attributeName);\n+\t\t\t\tattribute.setDescribingElement(this);\n+\t\t\t\tdocumentAttribute(attribute, method, store);\n+\t\t\t\tresult.add(attribute);\n+\t\t\t}\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tprivate Map<String, Method> getGetterAndIsserAttributes(Method[] methods) {\n+\t\tMap<String, Method> getterAttributes = getAttributeToMethodMap(methods, \"get\");\n+\t\tMap<String, Method> isserAttributes = getAttributeToMethodMap(methods, \"is\");\n+\t\tfor(String isserAttributeName : isserAttributes.keySet()) {\n+\t\t\tif(getterAttributes.containsKey(isserAttributeName)) {\n+\t\t\t\tlog.warn(String.format(\"For FrankElement %s, attribute %s has both a getX and an isX method\",\n+\t\t\t\t\t\tsimpleName, isserAttributeName));\n+\t\t\t} else {\n+\t\t\t\tgetterAttributes.put(isserAttributeName, isserAttributes.get(isserAttributeName));\n+\t\t\t}\n+\t\t}\n+\t\treturn getterAttributes;\n+\t}\n+\n+\tstatic Map<String, Method> getAttributeToMethodMap(Method[] methods, String prefix) {\n+\t\tList<Method> methodList = Arrays.asList(methods);\n+\t\tmethodList = methodList.stream()\n+\t\t\t\t.filter(FrankElement::isGetterOrSetter)\n+\t\t\t\t.filter(m -> m.getName().startsWith(prefix) && (m.getName().length() > prefix.length()))\n+\t\t\t\t.collect(Collectors.toList());\t\t\n+\t\tMap<String, Method> result = new HashMap<>();\n+\t\tfor(Method method: methodList) {\n+\t\t\tString strippedName = method.getName().substring(prefix.length());\n+\t\t\tString attributeName = strippedName.substring(0, 1).toLowerCase() + strippedName.substring(1);\n+\t\t\tresult.put(attributeName, method);\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tstatic boolean isGetterOrSetter(Method method) {\n+\t\tboolean isSetter = method.getReturnType().isPrimitive()\n+\t\t\t\t&& method.getReturnType().getName().equals(\"void\")\n+\t\t\t\t&& (method.getParameterTypes().length == 1)\n+\t\t\t\t&& (method.getParameterTypes()[0].isPrimitive()\n+\t\t\t\t\t\t|| method.getParameterTypes()[0].getName().equals(JAVA_STRING));\n+\t\tboolean isGetter = (\n+\t\t\t\t\tmethod.getReturnType().isPrimitive()\n+\t\t\t\t\t|| method.getReturnType().getName().equals(JAVA_STRING)\n+\t\t\t\t) && (method.getParameterTypes().length == 0);\n+\t\treturn isSetter || isGetter;\n+\t}\n+\n+\tprivate void compareGetterWithSetter(Method setter, Method getter) {\n+\t\tString setterType = setter.getParameterTypes()[0].getName();\n+\t\tString getterType = getter.getReturnType().getName();\n+\t\tif(! getterType.equals(setterType)) {\n+\t\t\tlog.warn(String.format(\"In Frank element %s: setter %s has type %s while the getter has type %s\",\n+\t\t\t\t\tsimpleName, setter.getName(), setterType, getterType));\n+\t\t}\n+\t}\n+\n+\tprivate void documentAttribute(\n+\t\t\tFrankAttribute attribute,\n+\t\t\tMethod method,\n+\t\t\tFrankElementStore store) {\n+\t\tattribute.setDeprecated(AnnotationUtils.findAnnotation(method, Deprecated.class) != null);\n+\t\tIbisDocRef ibisDocRef = AnnotationUtils.findAnnotation(method, IbisDocRef.class);\n+\t\tif(ibisDocRef != null) {\n+\t\t\tParsedIbisDocRef parsed = parseIbisDocRef(ibisDocRef, method);\n+\t\t\tIbisDoc ibisDoc = AnnotationUtils.findAnnotation(parsed.getReferredMethod(), IbisDoc.class);\n+\t\t\tif(ibisDoc != null) {\n+\t\t\t\tattribute.setDescribingElement(frankElement(\n+\t\t\t\t\t\tparsed.getReferredMethod().getDeclaringClass(), store));\n+\t\t\t\tibisDocIntoFrankElement(ibisDoc, attribute);\n+\t\t\t\tif(parsed.hasOrder) {\n+\t\t\t\t\tattribute.setOrder(parsed.getOrder());\n+\t\t\t\t}\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t\tIbisDoc ibisDoc = AnnotationUtils.findAnnotation(method, IbisDoc.class);\n+\t\tif(ibisDoc != null) {\n+\t\t\tibisDocIntoFrankElement(ibisDoc, attribute);\n+\t\t}\n+\t\telse {\n+\t\t\tlog.warn(String.format(\"No documentation available for FrankElement %s, attribute %s\",\n+\t\t\t\t\tsimpleName, attribute.getName()));\n+\t\t}\n+\t}\n+\n+\tprivate class ParsedIbisDocRef {\n+\t\tprivate @Getter @Setter boolean hasOrder;\n+\t\tprivate @Getter @Setter int order;\n+\t\tprivate @Getter @Setter Method referredMethod;\n+\t}\n+\n+\tprivate ParsedIbisDocRef parseIbisDocRef(IbisDocRef ibisDocRef, Method originalMethod) {\n+\t\tParsedIbisDocRef result = new ParsedIbisDocRef();\n+\t\tresult.setHasOrder(false);\n+\t\tString[] values = ibisDocRef.value();\n+\t\tString methodString = null;\n+\t\tif (values.length == 1) {\n+\t\t\tmethodString = ibisDocRef.value()[0];\n+\t\t} else if (values.length == 2) {\n+\t\t\tmethodString = ibisDocRef.value()[1];\n+\t\t\ttry {\n+\t\t\t\tresult.setOrder(Integer.parseInt(ibisDocRef.value()[0]));\n+\t\t\t\tresult.setHasOrder(true);\n+\t\t\t} catch (Throwable t) {\n+\t\t\t\tlog.warn(String.format(\"Could not parse order in @IbisDocRef annotation: \"\n+\t\t\t\t\t\t+ Integer.parseInt(ibisDocRef.value()[0])));\n+\t\t\t}\n+\t\t}\n+\t\telse {\n+\t\t\tlog.warn(String.format(String.format(\"Invalid @IbisDocRef annotation on method: %s.%s\",\n+\t\t\t\t\toriginalMethod.getDeclaringClass().getName(), originalMethod.getName())));\n+\t\t\treturn null;\n+\t\t}\n+\t\tresult.setReferredMethod(getReferredMethod(methodString, originalMethod));\n+\t\treturn result;\n+\t}\n+\n+\tprivate static Method getReferredMethod(String methodString, Method originalMethod) {\n+\t\tString lastNameComponent = methodString.substring(methodString.lastIndexOf(\".\") + 1).trim();\n+\t\tchar firstLetter = lastNameComponent.toCharArray()[0];\n+\t\tString fullClassName = methodString;\n+\t\tString methodName = lastNameComponent;\n+\t\tif (Character.isLowerCase(firstLetter)) {\n+\t\t\tint index = methodString.lastIndexOf(\".\");\n+\t\t\tfullClassName = methodString.substring(0, index);\n+\t\t} else {\n+\t\t\tmethodName = originalMethod.getName();\n+\t\t}\n+\t\treturn getParentMethod(fullClassName, methodName);\n+\t}\n+\n+\tprivate static Method getParentMethod(String className, String methodName) {\n+\t\ttry {\n+\t\t\tClass<?> parentClass = Class.forName(className);\n+\t\t\tfor (Method parentMethod : parentClass.getMethods()) {\n+\t\t\t\tif (parentMethod.getName().equals(methodName)) {\n+\t\t\t\t\treturn parentMethod;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn null;\n+\t\t} catch (ClassNotFoundException e) {\n+\t\t\tlog.warn(String.format(\"Super class [\" + e + \"] was not found!\"));", "originalCommit": "0f9c6bc6c9eec77c0673c8ce540e3a980fd75340", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQwMzY3Mg==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r502403672", "bodyText": "Gedaan.", "author": "mhdirkse", "createdAt": "2020-10-09T12:49:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjI3NTk4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjI3NzkyMA==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r502277920", "bodyText": "Waarom is hij invalid? Laat dat weten in de foutmelding! Zoiets als: 'too many parameters in declaration'", "author": "gvanbrakel", "createdAt": "2020-10-09T08:41:39Z", "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankElement.java", "diffHunk": "@@ -0,0 +1,249 @@\n+package nl.nn.adapterframework.doc.model;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n+import org.springframework.core.annotation.AnnotationUtils;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import nl.nn.adapterframework.doc.IbisDoc;\n+import nl.nn.adapterframework.doc.IbisDocRef;\n+import nl.nn.adapterframework.util.LogUtil;\n+\n+public class FrankElement {\n+\tprivate static Logger log = LogUtil.getLogger(FrankElement.class);\n+\n+\tprivate static final String JAVA_STRING = \"java.lang.String\";\n+\n+\tprivate final @Getter String fullName;\n+\tprivate final @Getter String simpleName;\n+\tprivate @Getter FrankElement parent;\n+\tprivate @Getter List<FrankAttribute> attributes;\n+\n+\tpublic interface FrankElementStore {\n+\t\tboolean hasFrankElement(String name);\n+\t\tFrankElement getFrankElement(String name);\n+\t\tvoid addFrankElement(FrankElement frankElement);\n+\t\tint numFrankElements();\n+\t}\n+\n+\tpublic static FrankElement frankElement(Class<?> clazz, FrankElementStore store) {\n+\t\tif(store.hasFrankElement(clazz.getName())) {\n+\t\t\treturn store.getFrankElement(clazz.getName());\n+\t\t}\n+\t\tClass<?> superClass = clazz.getSuperclass();\n+\t\tFrankElement parent = superClass == null ? null : frankElement(superClass, store);\n+\t\tFrankElement current = new FrankElement(clazz, parent, store);\n+\t\tstore.addFrankElement(current);\n+\t\treturn current;\n+\t}\n+\n+\tFrankElement(Class<?> clazz, FrankElement parent, FrankElementStore store) {\n+\t\tthis(clazz.getName(), clazz.getSimpleName());\n+\t\tthis.parent = parent;\n+\t\tthis.attributes = createAttributes(clazz.getDeclaredMethods(), store);\n+\t}\n+\n+\tFrankElement(final String fullName, final String simpleName) {\n+\t\tthis.fullName = fullName;\n+\t\tthis.simpleName = simpleName;\n+\t}\n+\n+\tList<FrankAttribute> createAttributes(Method[] methods, FrankElementStore store) {\n+\t\tMap<String, Method> setterAttributes = getAttributeToMethodMap(methods, \"set\");\n+\t\tMap<String, Method> getterAttributes = getGetterAndIsserAttributes(methods);\n+\t\tMap<String, String> setterToAttributeName = new HashMap<>();\n+\t\tfor(String attributeName: setterAttributes.keySet()) {\n+\t\t\tsetterToAttributeName.put(setterAttributes.get(attributeName).getName(), attributeName);\n+\t\t}\n+\t\tList<FrankAttribute> result = new ArrayList<>();\n+\t\tfor(Method method: methods) {\n+\t\t\tif(setterToAttributeName.containsKey(method.getName())) {\n+\t\t\t\tString attributeName = setterToAttributeName.get(method.getName());\n+\t\t\t\tif(getterAttributes.containsKey(attributeName)) {\n+\t\t\t\t\tcompareGetterWithSetter(method, getterAttributes.get(attributeName));\n+\t\t\t\t} else {\n+\t\t\t\t\tlog.warn(String.format(\"FrankElement %s and attribute %s: no getter method\",\n+\t\t\t\t\t\t\tsimpleName, attributeName));\n+\t\t\t\t}\n+\t\t\t\tFrankAttribute attribute = new FrankAttribute(attributeName);\n+\t\t\t\tattribute.setDescribingElement(this);\n+\t\t\t\tdocumentAttribute(attribute, method, store);\n+\t\t\t\tresult.add(attribute);\n+\t\t\t}\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tprivate Map<String, Method> getGetterAndIsserAttributes(Method[] methods) {\n+\t\tMap<String, Method> getterAttributes = getAttributeToMethodMap(methods, \"get\");\n+\t\tMap<String, Method> isserAttributes = getAttributeToMethodMap(methods, \"is\");\n+\t\tfor(String isserAttributeName : isserAttributes.keySet()) {\n+\t\t\tif(getterAttributes.containsKey(isserAttributeName)) {\n+\t\t\t\tlog.warn(String.format(\"For FrankElement %s, attribute %s has both a getX and an isX method\",\n+\t\t\t\t\t\tsimpleName, isserAttributeName));\n+\t\t\t} else {\n+\t\t\t\tgetterAttributes.put(isserAttributeName, isserAttributes.get(isserAttributeName));\n+\t\t\t}\n+\t\t}\n+\t\treturn getterAttributes;\n+\t}\n+\n+\tstatic Map<String, Method> getAttributeToMethodMap(Method[] methods, String prefix) {\n+\t\tList<Method> methodList = Arrays.asList(methods);\n+\t\tmethodList = methodList.stream()\n+\t\t\t\t.filter(FrankElement::isGetterOrSetter)\n+\t\t\t\t.filter(m -> m.getName().startsWith(prefix) && (m.getName().length() > prefix.length()))\n+\t\t\t\t.collect(Collectors.toList());\t\t\n+\t\tMap<String, Method> result = new HashMap<>();\n+\t\tfor(Method method: methodList) {\n+\t\t\tString strippedName = method.getName().substring(prefix.length());\n+\t\t\tString attributeName = strippedName.substring(0, 1).toLowerCase() + strippedName.substring(1);\n+\t\t\tresult.put(attributeName, method);\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tstatic boolean isGetterOrSetter(Method method) {\n+\t\tboolean isSetter = method.getReturnType().isPrimitive()\n+\t\t\t\t&& method.getReturnType().getName().equals(\"void\")\n+\t\t\t\t&& (method.getParameterTypes().length == 1)\n+\t\t\t\t&& (method.getParameterTypes()[0].isPrimitive()\n+\t\t\t\t\t\t|| method.getParameterTypes()[0].getName().equals(JAVA_STRING));\n+\t\tboolean isGetter = (\n+\t\t\t\t\tmethod.getReturnType().isPrimitive()\n+\t\t\t\t\t|| method.getReturnType().getName().equals(JAVA_STRING)\n+\t\t\t\t) && (method.getParameterTypes().length == 0);\n+\t\treturn isSetter || isGetter;\n+\t}\n+\n+\tprivate void compareGetterWithSetter(Method setter, Method getter) {\n+\t\tString setterType = setter.getParameterTypes()[0].getName();\n+\t\tString getterType = getter.getReturnType().getName();\n+\t\tif(! getterType.equals(setterType)) {\n+\t\t\tlog.warn(String.format(\"In Frank element %s: setter %s has type %s while the getter has type %s\",\n+\t\t\t\t\tsimpleName, setter.getName(), setterType, getterType));\n+\t\t}\n+\t}\n+\n+\tprivate void documentAttribute(\n+\t\t\tFrankAttribute attribute,\n+\t\t\tMethod method,\n+\t\t\tFrankElementStore store) {\n+\t\tattribute.setDeprecated(AnnotationUtils.findAnnotation(method, Deprecated.class) != null);\n+\t\tIbisDocRef ibisDocRef = AnnotationUtils.findAnnotation(method, IbisDocRef.class);\n+\t\tif(ibisDocRef != null) {\n+\t\t\tParsedIbisDocRef parsed = parseIbisDocRef(ibisDocRef, method);\n+\t\t\tIbisDoc ibisDoc = AnnotationUtils.findAnnotation(parsed.getReferredMethod(), IbisDoc.class);\n+\t\t\tif(ibisDoc != null) {\n+\t\t\t\tattribute.setDescribingElement(frankElement(\n+\t\t\t\t\t\tparsed.getReferredMethod().getDeclaringClass(), store));\n+\t\t\t\tibisDocIntoFrankElement(ibisDoc, attribute);\n+\t\t\t\tif(parsed.hasOrder) {\n+\t\t\t\t\tattribute.setOrder(parsed.getOrder());\n+\t\t\t\t}\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t\tIbisDoc ibisDoc = AnnotationUtils.findAnnotation(method, IbisDoc.class);\n+\t\tif(ibisDoc != null) {\n+\t\t\tibisDocIntoFrankElement(ibisDoc, attribute);\n+\t\t}\n+\t\telse {\n+\t\t\tlog.warn(String.format(\"No documentation available for FrankElement %s, attribute %s\",\n+\t\t\t\t\tsimpleName, attribute.getName()));\n+\t\t}\n+\t}\n+\n+\tprivate class ParsedIbisDocRef {\n+\t\tprivate @Getter @Setter boolean hasOrder;\n+\t\tprivate @Getter @Setter int order;\n+\t\tprivate @Getter @Setter Method referredMethod;\n+\t}\n+\n+\tprivate ParsedIbisDocRef parseIbisDocRef(IbisDocRef ibisDocRef, Method originalMethod) {\n+\t\tParsedIbisDocRef result = new ParsedIbisDocRef();\n+\t\tresult.setHasOrder(false);\n+\t\tString[] values = ibisDocRef.value();\n+\t\tString methodString = null;\n+\t\tif (values.length == 1) {\n+\t\t\tmethodString = ibisDocRef.value()[0];\n+\t\t} else if (values.length == 2) {\n+\t\t\tmethodString = ibisDocRef.value()[1];\n+\t\t\ttry {\n+\t\t\t\tresult.setOrder(Integer.parseInt(ibisDocRef.value()[0]));\n+\t\t\t\tresult.setHasOrder(true);\n+\t\t\t} catch (Throwable t) {\n+\t\t\t\tlog.warn(String.format(\"Could not parse order in @IbisDocRef annotation: \"\n+\t\t\t\t\t\t+ Integer.parseInt(ibisDocRef.value()[0])));\n+\t\t\t}\n+\t\t}\n+\t\telse {\n+\t\t\tlog.warn(String.format(String.format(\"Invalid @IbisDocRef annotation on method: %s.%s\",\n+\t\t\t\t\toriginalMethod.getDeclaringClass().getName(), originalMethod.getName())));", "originalCommit": "0f9c6bc6c9eec77c0673c8ce540e3a980fd75340", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQwMjY4Ng==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r502402686", "bodyText": "Gedaan.", "author": "mhdirkse", "createdAt": "2020-10-09T12:47:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjI3NzkyMA=="}], "type": "inlineReview"}, {"oid": "b6914867e72e83b4abad9356720ee07f11b48478", "url": "https://github.com/ibissource/iaf/commit/b6914867e72e83b4abad9356720ee07f11b48478", "message": "Apply review comments.\n\nTODO: Reorganize tests to match the way classes were reorganized", "committedDate": "2020-10-09T11:37:00Z", "type": "commit"}, {"oid": "843e0f45448a6fef45bc990e53af525a1384cfbd", "url": "https://github.com/ibissource/iaf/commit/843e0f45448a6fef45bc990e53af525a1384cfbd", "message": "FrankElementTest to FrankModelTest, maybe more than Eclipse rename", "committedDate": "2020-10-09T12:39:48Z", "type": "commit"}, {"oid": "b4d3816722edebfbc592a2cd3ca3020892bb6b7e", "url": "https://github.com/ibissource/iaf/commit/b4d3816722edebfbc592a2cd3ca3020892bb6b7e", "message": "In FrankDocGroup, introduce addAsElement()", "committedDate": "2020-10-09T15:17:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzA3NzE1NA==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r503077154", "bodyText": "waarom itereer je hier niet over setterAttributes?", "author": "gvanbrakel", "createdAt": "2020-10-12T07:00:39Z", "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankDocModel.java", "diffHunk": "@@ -0,0 +1,213 @@\n+package nl.nn.adapterframework.doc.model;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n+import org.springframework.core.annotation.AnnotationUtils;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import nl.nn.adapterframework.doc.IbisDoc;\n+import nl.nn.adapterframework.doc.IbisDocRef;\n+import nl.nn.adapterframework.util.LogUtil;\n+\n+public class FrankDocModel {\n+\tprivate static final String JAVA_STRING = \"java.lang.String\";\n+\n+\tprivate static Logger log = LogUtil.getLogger(FrankDocModel.class);\n+\n+\tprivate @Getter List<FrankDocGroup> groups;\n+\tprivate @Getter Map<String, FrankElement> allElements = new HashMap<>();\n+\n+\tpublic FrankDocModel() {\n+\t\tgroups = new ArrayList<>();\n+\t}\n+\n+\tpublic FrankElement findOrCreateFrankElement(Class<?> clazz) {\n+\t\tif(allElements.containsKey(clazz.getName())) {\n+\t\t\treturn allElements.get(clazz.getName());\n+\t\t}\n+\t\tClass<?> superClass = clazz.getSuperclass();\n+\t\tFrankElement parent = superClass == null ? null : findOrCreateFrankElement(superClass);\n+\t\tFrankElement current = new FrankElement(clazz, parent);\n+\t\tcurrent.setAttributes(createAttributes(clazz.getDeclaredMethods(), current));\n+\t\tallElements.put(current.getFullName(), current);\n+\t\treturn current;\n+\t}\n+\n+\tList<FrankAttribute> createAttributes(Method[] methods, FrankElement attributeOwner) {\n+\t\tMap<String, Method> setterAttributes = getAttributeToMethodMap(methods, \"set\");\n+\t\tMap<String, Method> getterAttributes = getGetterAndIsserAttributes(methods, attributeOwner);\n+\t\tMap<String, String> setterToAttributeName = new HashMap<>();\n+\t\tfor(String attributeName: setterAttributes.keySet()) {\n+\t\t\tsetterToAttributeName.put(setterAttributes.get(attributeName).getName(), attributeName);\n+\t\t}\n+\t\tList<FrankAttribute> result = new ArrayList<>();\n+\t\tfor(Method method: methods) {\n+\t\t\tif(setterToAttributeName.containsKey(method.getName())) {", "originalCommit": "b4d3816722edebfbc592a2cd3ca3020892bb6b7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzIyOTQyNw==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r503229427", "bodyText": "Ik heb commentaar toegevoegd om dat uit te leggen.", "author": "mhdirkse", "createdAt": "2020-10-12T11:26:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzA3NzE1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI3OTA5NA==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r503279094", "bodyText": "Je kan dan beter op regel 88 een LinkedHashMap gebruiken. Die volgt bij itereren de volgorde van toevoegen aan de collectie.\nJe kan dan hier wel direct over setterAttributes iterereren. Dat maakt de code beter te begrijpen.\nsetterToAttributeName kan dan vervallen", "author": "gvanbrakel", "createdAt": "2020-10-12T12:59:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzA3NzE1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzM5NDk4Mg==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r503394982", "bodyText": "Gedaan. Zoals het nu is. Kan je voor de zekerheid checken dat ik zodanig itereer dat de volgorde bewaard blijft?", "author": "mhdirkse", "createdAt": "2020-10-12T16:06:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzA3NzE1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzA3ODIxNQ==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r503078215", "bodyText": "Deze method zou je kunnen hernoemen in 'checkForTypeConflict()', zodat je weet wat je kan verwachten.", "author": "gvanbrakel", "createdAt": "2020-10-12T07:03:14Z", "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankDocModel.java", "diffHunk": "@@ -0,0 +1,213 @@\n+package nl.nn.adapterframework.doc.model;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n+import org.springframework.core.annotation.AnnotationUtils;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import nl.nn.adapterframework.doc.IbisDoc;\n+import nl.nn.adapterframework.doc.IbisDocRef;\n+import nl.nn.adapterframework.util.LogUtil;\n+\n+public class FrankDocModel {\n+\tprivate static final String JAVA_STRING = \"java.lang.String\";\n+\n+\tprivate static Logger log = LogUtil.getLogger(FrankDocModel.class);\n+\n+\tprivate @Getter List<FrankDocGroup> groups;\n+\tprivate @Getter Map<String, FrankElement> allElements = new HashMap<>();\n+\n+\tpublic FrankDocModel() {\n+\t\tgroups = new ArrayList<>();\n+\t}\n+\n+\tpublic FrankElement findOrCreateFrankElement(Class<?> clazz) {\n+\t\tif(allElements.containsKey(clazz.getName())) {\n+\t\t\treturn allElements.get(clazz.getName());\n+\t\t}\n+\t\tClass<?> superClass = clazz.getSuperclass();\n+\t\tFrankElement parent = superClass == null ? null : findOrCreateFrankElement(superClass);\n+\t\tFrankElement current = new FrankElement(clazz, parent);\n+\t\tcurrent.setAttributes(createAttributes(clazz.getDeclaredMethods(), current));\n+\t\tallElements.put(current.getFullName(), current);\n+\t\treturn current;\n+\t}\n+\n+\tList<FrankAttribute> createAttributes(Method[] methods, FrankElement attributeOwner) {\n+\t\tMap<String, Method> setterAttributes = getAttributeToMethodMap(methods, \"set\");\n+\t\tMap<String, Method> getterAttributes = getGetterAndIsserAttributes(methods, attributeOwner);\n+\t\tMap<String, String> setterToAttributeName = new HashMap<>();\n+\t\tfor(String attributeName: setterAttributes.keySet()) {\n+\t\t\tsetterToAttributeName.put(setterAttributes.get(attributeName).getName(), attributeName);\n+\t\t}\n+\t\tList<FrankAttribute> result = new ArrayList<>();\n+\t\tfor(Method method: methods) {\n+\t\t\tif(setterToAttributeName.containsKey(method.getName())) {\n+\t\t\t\tString attributeName = setterToAttributeName.get(method.getName());\n+\t\t\t\tif(getterAttributes.containsKey(attributeName)) {\n+\t\t\t\t\tcompareGetterWithSetter(method, getterAttributes.get(attributeName), attributeOwner);\n+\t\t\t\t}\n+\t\t\t\tFrankAttribute attribute = new FrankAttribute(attributeName);\n+\t\t\t\tattribute.setDescribingElement(attributeOwner);\n+\t\t\t\tdocumentAttribute(attribute, method, attributeOwner);\n+\t\t\t\tresult.add(attribute);\n+\t\t\t}\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tprivate Map<String, Method> getGetterAndIsserAttributes(Method[] methods, FrankElement attributeOwner) {\n+\t\tMap<String, Method> getterAttributes = getAttributeToMethodMap(methods, \"get\");\n+\t\tMap<String, Method> isserAttributes = getAttributeToMethodMap(methods, \"is\");\n+\t\tfor(String isserAttributeName : isserAttributes.keySet()) {\n+\t\t\tif(getterAttributes.containsKey(isserAttributeName)) {\n+\t\t\t\tlog.warn(String.format(\"For FrankElement %s, attribute %s has both a getX and an isX method\",\n+\t\t\t\t\t\tattributeOwner.getSimpleName(), isserAttributeName));\n+\t\t\t} else {\n+\t\t\t\tgetterAttributes.put(isserAttributeName, isserAttributes.get(isserAttributeName));\n+\t\t\t}\n+\t\t}\n+\t\treturn getterAttributes;\n+\t}\n+\n+\tstatic Map<String, Method> getAttributeToMethodMap(Method[] methods, String prefix) {\n+\t\tList<Method> methodList = Arrays.asList(methods);\n+\t\tmethodList = methodList.stream()\n+\t\t\t\t.filter(FrankDocModel::isGetterOrSetter)\n+\t\t\t\t.filter(m -> m.getName().startsWith(prefix) && (m.getName().length() > prefix.length()))\n+\t\t\t\t.collect(Collectors.toList());\t\t\n+\t\tMap<String, Method> result = new HashMap<>();\n+\t\tfor(Method method: methodList) {\n+\t\t\tString strippedName = method.getName().substring(prefix.length());\n+\t\t\tString attributeName = strippedName.substring(0, 1).toLowerCase() + strippedName.substring(1);\n+\t\t\tresult.put(attributeName, method);\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tstatic boolean isGetterOrSetter(Method method) {\n+\t\tboolean isSetter = method.getReturnType().isPrimitive()\n+\t\t\t\t&& method.getReturnType().getName().equals(\"void\")\n+\t\t\t\t&& (method.getParameterTypes().length == 1)\n+\t\t\t\t&& (method.getParameterTypes()[0].isPrimitive()\n+\t\t\t\t\t\t|| method.getParameterTypes()[0].getName().equals(JAVA_STRING));\n+\t\tboolean isGetter = (\n+\t\t\t\t\tmethod.getReturnType().isPrimitive()\n+\t\t\t\t\t|| method.getReturnType().getName().equals(JAVA_STRING)\n+\t\t\t\t) && (method.getParameterTypes().length == 0);\n+\t\treturn isSetter || isGetter;\n+\t}\n+\n+\tprivate void compareGetterWithSetter(Method setter, Method getter, FrankElement attributeOwner) {", "originalCommit": "b4d3816722edebfbc592a2cd3ca3020892bb6b7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzIyOTIwOA==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r503229208", "bodyText": "Gedaan.", "author": "mhdirkse", "createdAt": "2020-10-12T11:26:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzA3ODIxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzA3OTE1Ng==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r503079156", "bodyText": "Ik denk dat het op z'n plaats is als attributeOwner als argument van de constructor wordt meegegeven.", "author": "gvanbrakel", "createdAt": "2020-10-12T07:05:10Z", "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankDocModel.java", "diffHunk": "@@ -0,0 +1,213 @@\n+package nl.nn.adapterframework.doc.model;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n+import org.springframework.core.annotation.AnnotationUtils;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import nl.nn.adapterframework.doc.IbisDoc;\n+import nl.nn.adapterframework.doc.IbisDocRef;\n+import nl.nn.adapterframework.util.LogUtil;\n+\n+public class FrankDocModel {\n+\tprivate static final String JAVA_STRING = \"java.lang.String\";\n+\n+\tprivate static Logger log = LogUtil.getLogger(FrankDocModel.class);\n+\n+\tprivate @Getter List<FrankDocGroup> groups;\n+\tprivate @Getter Map<String, FrankElement> allElements = new HashMap<>();\n+\n+\tpublic FrankDocModel() {\n+\t\tgroups = new ArrayList<>();\n+\t}\n+\n+\tpublic FrankElement findOrCreateFrankElement(Class<?> clazz) {\n+\t\tif(allElements.containsKey(clazz.getName())) {\n+\t\t\treturn allElements.get(clazz.getName());\n+\t\t}\n+\t\tClass<?> superClass = clazz.getSuperclass();\n+\t\tFrankElement parent = superClass == null ? null : findOrCreateFrankElement(superClass);\n+\t\tFrankElement current = new FrankElement(clazz, parent);\n+\t\tcurrent.setAttributes(createAttributes(clazz.getDeclaredMethods(), current));\n+\t\tallElements.put(current.getFullName(), current);\n+\t\treturn current;\n+\t}\n+\n+\tList<FrankAttribute> createAttributes(Method[] methods, FrankElement attributeOwner) {\n+\t\tMap<String, Method> setterAttributes = getAttributeToMethodMap(methods, \"set\");\n+\t\tMap<String, Method> getterAttributes = getGetterAndIsserAttributes(methods, attributeOwner);\n+\t\tMap<String, String> setterToAttributeName = new HashMap<>();\n+\t\tfor(String attributeName: setterAttributes.keySet()) {\n+\t\t\tsetterToAttributeName.put(setterAttributes.get(attributeName).getName(), attributeName);\n+\t\t}\n+\t\tList<FrankAttribute> result = new ArrayList<>();\n+\t\tfor(Method method: methods) {\n+\t\t\tif(setterToAttributeName.containsKey(method.getName())) {\n+\t\t\t\tString attributeName = setterToAttributeName.get(method.getName());\n+\t\t\t\tif(getterAttributes.containsKey(attributeName)) {\n+\t\t\t\t\tcompareGetterWithSetter(method, getterAttributes.get(attributeName), attributeOwner);\n+\t\t\t\t}\n+\t\t\t\tFrankAttribute attribute = new FrankAttribute(attributeName);\n+\t\t\t\tattribute.setDescribingElement(attributeOwner);", "originalCommit": "b4d3816722edebfbc592a2cd3ca3020892bb6b7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzIyOTA0NA==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r503229044", "bodyText": "Gedaan.", "author": "mhdirkse", "createdAt": "2020-10-12T11:25:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzA3OTE1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzA3OTgyOA==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r503079828", "bodyText": "Parameters in log regels zetten we in het framework altijd tussen vierkante haken", "author": "gvanbrakel", "createdAt": "2020-10-12T07:06:41Z", "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankDocModel.java", "diffHunk": "@@ -0,0 +1,213 @@\n+package nl.nn.adapterframework.doc.model;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n+import org.springframework.core.annotation.AnnotationUtils;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import nl.nn.adapterframework.doc.IbisDoc;\n+import nl.nn.adapterframework.doc.IbisDocRef;\n+import nl.nn.adapterframework.util.LogUtil;\n+\n+public class FrankDocModel {\n+\tprivate static final String JAVA_STRING = \"java.lang.String\";\n+\n+\tprivate static Logger log = LogUtil.getLogger(FrankDocModel.class);\n+\n+\tprivate @Getter List<FrankDocGroup> groups;\n+\tprivate @Getter Map<String, FrankElement> allElements = new HashMap<>();\n+\n+\tpublic FrankDocModel() {\n+\t\tgroups = new ArrayList<>();\n+\t}\n+\n+\tpublic FrankElement findOrCreateFrankElement(Class<?> clazz) {\n+\t\tif(allElements.containsKey(clazz.getName())) {\n+\t\t\treturn allElements.get(clazz.getName());\n+\t\t}\n+\t\tClass<?> superClass = clazz.getSuperclass();\n+\t\tFrankElement parent = superClass == null ? null : findOrCreateFrankElement(superClass);\n+\t\tFrankElement current = new FrankElement(clazz, parent);\n+\t\tcurrent.setAttributes(createAttributes(clazz.getDeclaredMethods(), current));\n+\t\tallElements.put(current.getFullName(), current);\n+\t\treturn current;\n+\t}\n+\n+\tList<FrankAttribute> createAttributes(Method[] methods, FrankElement attributeOwner) {\n+\t\tMap<String, Method> setterAttributes = getAttributeToMethodMap(methods, \"set\");\n+\t\tMap<String, Method> getterAttributes = getGetterAndIsserAttributes(methods, attributeOwner);\n+\t\tMap<String, String> setterToAttributeName = new HashMap<>();\n+\t\tfor(String attributeName: setterAttributes.keySet()) {\n+\t\t\tsetterToAttributeName.put(setterAttributes.get(attributeName).getName(), attributeName);\n+\t\t}\n+\t\tList<FrankAttribute> result = new ArrayList<>();\n+\t\tfor(Method method: methods) {\n+\t\t\tif(setterToAttributeName.containsKey(method.getName())) {\n+\t\t\t\tString attributeName = setterToAttributeName.get(method.getName());\n+\t\t\t\tif(getterAttributes.containsKey(attributeName)) {\n+\t\t\t\t\tcompareGetterWithSetter(method, getterAttributes.get(attributeName), attributeOwner);\n+\t\t\t\t}\n+\t\t\t\tFrankAttribute attribute = new FrankAttribute(attributeName);\n+\t\t\t\tattribute.setDescribingElement(attributeOwner);\n+\t\t\t\tdocumentAttribute(attribute, method, attributeOwner);\n+\t\t\t\tresult.add(attribute);\n+\t\t\t}\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tprivate Map<String, Method> getGetterAndIsserAttributes(Method[] methods, FrankElement attributeOwner) {\n+\t\tMap<String, Method> getterAttributes = getAttributeToMethodMap(methods, \"get\");\n+\t\tMap<String, Method> isserAttributes = getAttributeToMethodMap(methods, \"is\");\n+\t\tfor(String isserAttributeName : isserAttributes.keySet()) {\n+\t\t\tif(getterAttributes.containsKey(isserAttributeName)) {\n+\t\t\t\tlog.warn(String.format(\"For FrankElement %s, attribute %s has both a getX and an isX method\",", "originalCommit": "b4d3816722edebfbc592a2cd3ca3020892bb6b7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzIyODg2Ng==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r503228866", "bodyText": "Gedaan.", "author": "mhdirkse", "createdAt": "2020-10-12T11:25:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzA3OTgyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzA3OTkyOA==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r503079928", "bodyText": "Parameters in log regels zetten we in het framework altijd tussen vierkante haken", "author": "gvanbrakel", "createdAt": "2020-10-12T07:06:52Z", "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankDocModel.java", "diffHunk": "@@ -0,0 +1,213 @@\n+package nl.nn.adapterframework.doc.model;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n+import org.springframework.core.annotation.AnnotationUtils;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import nl.nn.adapterframework.doc.IbisDoc;\n+import nl.nn.adapterframework.doc.IbisDocRef;\n+import nl.nn.adapterframework.util.LogUtil;\n+\n+public class FrankDocModel {\n+\tprivate static final String JAVA_STRING = \"java.lang.String\";\n+\n+\tprivate static Logger log = LogUtil.getLogger(FrankDocModel.class);\n+\n+\tprivate @Getter List<FrankDocGroup> groups;\n+\tprivate @Getter Map<String, FrankElement> allElements = new HashMap<>();\n+\n+\tpublic FrankDocModel() {\n+\t\tgroups = new ArrayList<>();\n+\t}\n+\n+\tpublic FrankElement findOrCreateFrankElement(Class<?> clazz) {\n+\t\tif(allElements.containsKey(clazz.getName())) {\n+\t\t\treturn allElements.get(clazz.getName());\n+\t\t}\n+\t\tClass<?> superClass = clazz.getSuperclass();\n+\t\tFrankElement parent = superClass == null ? null : findOrCreateFrankElement(superClass);\n+\t\tFrankElement current = new FrankElement(clazz, parent);\n+\t\tcurrent.setAttributes(createAttributes(clazz.getDeclaredMethods(), current));\n+\t\tallElements.put(current.getFullName(), current);\n+\t\treturn current;\n+\t}\n+\n+\tList<FrankAttribute> createAttributes(Method[] methods, FrankElement attributeOwner) {\n+\t\tMap<String, Method> setterAttributes = getAttributeToMethodMap(methods, \"set\");\n+\t\tMap<String, Method> getterAttributes = getGetterAndIsserAttributes(methods, attributeOwner);\n+\t\tMap<String, String> setterToAttributeName = new HashMap<>();\n+\t\tfor(String attributeName: setterAttributes.keySet()) {\n+\t\t\tsetterToAttributeName.put(setterAttributes.get(attributeName).getName(), attributeName);\n+\t\t}\n+\t\tList<FrankAttribute> result = new ArrayList<>();\n+\t\tfor(Method method: methods) {\n+\t\t\tif(setterToAttributeName.containsKey(method.getName())) {\n+\t\t\t\tString attributeName = setterToAttributeName.get(method.getName());\n+\t\t\t\tif(getterAttributes.containsKey(attributeName)) {\n+\t\t\t\t\tcompareGetterWithSetter(method, getterAttributes.get(attributeName), attributeOwner);\n+\t\t\t\t}\n+\t\t\t\tFrankAttribute attribute = new FrankAttribute(attributeName);\n+\t\t\t\tattribute.setDescribingElement(attributeOwner);\n+\t\t\t\tdocumentAttribute(attribute, method, attributeOwner);\n+\t\t\t\tresult.add(attribute);\n+\t\t\t}\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tprivate Map<String, Method> getGetterAndIsserAttributes(Method[] methods, FrankElement attributeOwner) {\n+\t\tMap<String, Method> getterAttributes = getAttributeToMethodMap(methods, \"get\");\n+\t\tMap<String, Method> isserAttributes = getAttributeToMethodMap(methods, \"is\");\n+\t\tfor(String isserAttributeName : isserAttributes.keySet()) {\n+\t\t\tif(getterAttributes.containsKey(isserAttributeName)) {\n+\t\t\t\tlog.warn(String.format(\"For FrankElement %s, attribute %s has both a getX and an isX method\",\n+\t\t\t\t\t\tattributeOwner.getSimpleName(), isserAttributeName));\n+\t\t\t} else {\n+\t\t\t\tgetterAttributes.put(isserAttributeName, isserAttributes.get(isserAttributeName));\n+\t\t\t}\n+\t\t}\n+\t\treturn getterAttributes;\n+\t}\n+\n+\tstatic Map<String, Method> getAttributeToMethodMap(Method[] methods, String prefix) {\n+\t\tList<Method> methodList = Arrays.asList(methods);\n+\t\tmethodList = methodList.stream()\n+\t\t\t\t.filter(FrankDocModel::isGetterOrSetter)\n+\t\t\t\t.filter(m -> m.getName().startsWith(prefix) && (m.getName().length() > prefix.length()))\n+\t\t\t\t.collect(Collectors.toList());\t\t\n+\t\tMap<String, Method> result = new HashMap<>();\n+\t\tfor(Method method: methodList) {\n+\t\t\tString strippedName = method.getName().substring(prefix.length());\n+\t\t\tString attributeName = strippedName.substring(0, 1).toLowerCase() + strippedName.substring(1);\n+\t\t\tresult.put(attributeName, method);\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tstatic boolean isGetterOrSetter(Method method) {\n+\t\tboolean isSetter = method.getReturnType().isPrimitive()\n+\t\t\t\t&& method.getReturnType().getName().equals(\"void\")\n+\t\t\t\t&& (method.getParameterTypes().length == 1)\n+\t\t\t\t&& (method.getParameterTypes()[0].isPrimitive()\n+\t\t\t\t\t\t|| method.getParameterTypes()[0].getName().equals(JAVA_STRING));\n+\t\tboolean isGetter = (\n+\t\t\t\t\tmethod.getReturnType().isPrimitive()\n+\t\t\t\t\t|| method.getReturnType().getName().equals(JAVA_STRING)\n+\t\t\t\t) && (method.getParameterTypes().length == 0);\n+\t\treturn isSetter || isGetter;\n+\t}\n+\n+\tprivate void compareGetterWithSetter(Method setter, Method getter, FrankElement attributeOwner) {\n+\t\tString setterType = setter.getParameterTypes()[0].getName();\n+\t\tString getterType = getter.getReturnType().getName();\n+\t\tif(! getterType.equals(setterType)) {\n+\t\t\tlog.warn(String.format(\"In Frank element %s: setter %s has type %s while the getter has type %s\",", "originalCommit": "b4d3816722edebfbc592a2cd3ca3020892bb6b7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzIyODYwMw==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r503228603", "bodyText": "Gedaan.", "author": "mhdirkse", "createdAt": "2020-10-12T11:25:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzA3OTkyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzA4MDM1NQ==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r503080355", "bodyText": "Dit mag op \u00e9\u00e9n regel", "author": "gvanbrakel", "createdAt": "2020-10-12T07:07:39Z", "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankDocModel.java", "diffHunk": "@@ -0,0 +1,213 @@\n+package nl.nn.adapterframework.doc.model;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n+import org.springframework.core.annotation.AnnotationUtils;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import nl.nn.adapterframework.doc.IbisDoc;\n+import nl.nn.adapterframework.doc.IbisDocRef;\n+import nl.nn.adapterframework.util.LogUtil;\n+\n+public class FrankDocModel {\n+\tprivate static final String JAVA_STRING = \"java.lang.String\";\n+\n+\tprivate static Logger log = LogUtil.getLogger(FrankDocModel.class);\n+\n+\tprivate @Getter List<FrankDocGroup> groups;\n+\tprivate @Getter Map<String, FrankElement> allElements = new HashMap<>();\n+\n+\tpublic FrankDocModel() {\n+\t\tgroups = new ArrayList<>();\n+\t}\n+\n+\tpublic FrankElement findOrCreateFrankElement(Class<?> clazz) {\n+\t\tif(allElements.containsKey(clazz.getName())) {\n+\t\t\treturn allElements.get(clazz.getName());\n+\t\t}\n+\t\tClass<?> superClass = clazz.getSuperclass();\n+\t\tFrankElement parent = superClass == null ? null : findOrCreateFrankElement(superClass);\n+\t\tFrankElement current = new FrankElement(clazz, parent);\n+\t\tcurrent.setAttributes(createAttributes(clazz.getDeclaredMethods(), current));\n+\t\tallElements.put(current.getFullName(), current);\n+\t\treturn current;\n+\t}\n+\n+\tList<FrankAttribute> createAttributes(Method[] methods, FrankElement attributeOwner) {\n+\t\tMap<String, Method> setterAttributes = getAttributeToMethodMap(methods, \"set\");\n+\t\tMap<String, Method> getterAttributes = getGetterAndIsserAttributes(methods, attributeOwner);\n+\t\tMap<String, String> setterToAttributeName = new HashMap<>();\n+\t\tfor(String attributeName: setterAttributes.keySet()) {\n+\t\t\tsetterToAttributeName.put(setterAttributes.get(attributeName).getName(), attributeName);\n+\t\t}\n+\t\tList<FrankAttribute> result = new ArrayList<>();\n+\t\tfor(Method method: methods) {\n+\t\t\tif(setterToAttributeName.containsKey(method.getName())) {\n+\t\t\t\tString attributeName = setterToAttributeName.get(method.getName());\n+\t\t\t\tif(getterAttributes.containsKey(attributeName)) {\n+\t\t\t\t\tcompareGetterWithSetter(method, getterAttributes.get(attributeName), attributeOwner);\n+\t\t\t\t}\n+\t\t\t\tFrankAttribute attribute = new FrankAttribute(attributeName);\n+\t\t\t\tattribute.setDescribingElement(attributeOwner);\n+\t\t\t\tdocumentAttribute(attribute, method, attributeOwner);\n+\t\t\t\tresult.add(attribute);\n+\t\t\t}\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tprivate Map<String, Method> getGetterAndIsserAttributes(Method[] methods, FrankElement attributeOwner) {\n+\t\tMap<String, Method> getterAttributes = getAttributeToMethodMap(methods, \"get\");\n+\t\tMap<String, Method> isserAttributes = getAttributeToMethodMap(methods, \"is\");\n+\t\tfor(String isserAttributeName : isserAttributes.keySet()) {\n+\t\t\tif(getterAttributes.containsKey(isserAttributeName)) {\n+\t\t\t\tlog.warn(String.format(\"For FrankElement %s, attribute %s has both a getX and an isX method\",\n+\t\t\t\t\t\tattributeOwner.getSimpleName(), isserAttributeName));\n+\t\t\t} else {\n+\t\t\t\tgetterAttributes.put(isserAttributeName, isserAttributes.get(isserAttributeName));\n+\t\t\t}\n+\t\t}\n+\t\treturn getterAttributes;\n+\t}\n+\n+\tstatic Map<String, Method> getAttributeToMethodMap(Method[] methods, String prefix) {\n+\t\tList<Method> methodList = Arrays.asList(methods);\n+\t\tmethodList = methodList.stream()\n+\t\t\t\t.filter(FrankDocModel::isGetterOrSetter)\n+\t\t\t\t.filter(m -> m.getName().startsWith(prefix) && (m.getName().length() > prefix.length()))\n+\t\t\t\t.collect(Collectors.toList());\t\t\n+\t\tMap<String, Method> result = new HashMap<>();\n+\t\tfor(Method method: methodList) {\n+\t\t\tString strippedName = method.getName().substring(prefix.length());\n+\t\t\tString attributeName = strippedName.substring(0, 1).toLowerCase() + strippedName.substring(1);\n+\t\t\tresult.put(attributeName, method);\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tstatic boolean isGetterOrSetter(Method method) {\n+\t\tboolean isSetter = method.getReturnType().isPrimitive()\n+\t\t\t\t&& method.getReturnType().getName().equals(\"void\")\n+\t\t\t\t&& (method.getParameterTypes().length == 1)\n+\t\t\t\t&& (method.getParameterTypes()[0].isPrimitive()\n+\t\t\t\t\t\t|| method.getParameterTypes()[0].getName().equals(JAVA_STRING));\n+\t\tboolean isGetter = (\n+\t\t\t\t\tmethod.getReturnType().isPrimitive()\n+\t\t\t\t\t|| method.getReturnType().getName().equals(JAVA_STRING)\n+\t\t\t\t) && (method.getParameterTypes().length == 0);\n+\t\treturn isSetter || isGetter;\n+\t}\n+\n+\tprivate void compareGetterWithSetter(Method setter, Method getter, FrankElement attributeOwner) {\n+\t\tString setterType = setter.getParameterTypes()[0].getName();\n+\t\tString getterType = getter.getReturnType().getName();\n+\t\tif(! getterType.equals(setterType)) {\n+\t\t\tlog.warn(String.format(\"In Frank element %s: setter %s has type %s while the getter has type %s\",\n+\t\t\t\t\tattributeOwner.getSimpleName(), setter.getName(), setterType, getterType));\n+\t\t}\n+\t}\n+\n+\tprivate void documentAttribute(\n+\t\t\tFrankAttribute attribute,\n+\t\t\tMethod method,\n+\t\t\tFrankElement attributeOwner) {", "originalCommit": "b4d3816722edebfbc592a2cd3ca3020892bb6b7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzIyODM1OQ==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r503228359", "bodyText": "Gedaan.", "author": "mhdirkse", "createdAt": "2020-10-12T11:24:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzA4MDM1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzA4MDkxMw==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r503080913", "bodyText": "Dit mag op \u00e9\u00e9n regel", "author": "gvanbrakel", "createdAt": "2020-10-12T07:09:00Z", "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankDocModel.java", "diffHunk": "@@ -0,0 +1,213 @@\n+package nl.nn.adapterframework.doc.model;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n+import org.springframework.core.annotation.AnnotationUtils;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import nl.nn.adapterframework.doc.IbisDoc;\n+import nl.nn.adapterframework.doc.IbisDocRef;\n+import nl.nn.adapterframework.util.LogUtil;\n+\n+public class FrankDocModel {\n+\tprivate static final String JAVA_STRING = \"java.lang.String\";\n+\n+\tprivate static Logger log = LogUtil.getLogger(FrankDocModel.class);\n+\n+\tprivate @Getter List<FrankDocGroup> groups;\n+\tprivate @Getter Map<String, FrankElement> allElements = new HashMap<>();\n+\n+\tpublic FrankDocModel() {\n+\t\tgroups = new ArrayList<>();\n+\t}\n+\n+\tpublic FrankElement findOrCreateFrankElement(Class<?> clazz) {\n+\t\tif(allElements.containsKey(clazz.getName())) {\n+\t\t\treturn allElements.get(clazz.getName());\n+\t\t}\n+\t\tClass<?> superClass = clazz.getSuperclass();\n+\t\tFrankElement parent = superClass == null ? null : findOrCreateFrankElement(superClass);\n+\t\tFrankElement current = new FrankElement(clazz, parent);\n+\t\tcurrent.setAttributes(createAttributes(clazz.getDeclaredMethods(), current));\n+\t\tallElements.put(current.getFullName(), current);\n+\t\treturn current;\n+\t}\n+\n+\tList<FrankAttribute> createAttributes(Method[] methods, FrankElement attributeOwner) {\n+\t\tMap<String, Method> setterAttributes = getAttributeToMethodMap(methods, \"set\");\n+\t\tMap<String, Method> getterAttributes = getGetterAndIsserAttributes(methods, attributeOwner);\n+\t\tMap<String, String> setterToAttributeName = new HashMap<>();\n+\t\tfor(String attributeName: setterAttributes.keySet()) {\n+\t\t\tsetterToAttributeName.put(setterAttributes.get(attributeName).getName(), attributeName);\n+\t\t}\n+\t\tList<FrankAttribute> result = new ArrayList<>();\n+\t\tfor(Method method: methods) {\n+\t\t\tif(setterToAttributeName.containsKey(method.getName())) {\n+\t\t\t\tString attributeName = setterToAttributeName.get(method.getName());\n+\t\t\t\tif(getterAttributes.containsKey(attributeName)) {\n+\t\t\t\t\tcompareGetterWithSetter(method, getterAttributes.get(attributeName), attributeOwner);\n+\t\t\t\t}\n+\t\t\t\tFrankAttribute attribute = new FrankAttribute(attributeName);\n+\t\t\t\tattribute.setDescribingElement(attributeOwner);\n+\t\t\t\tdocumentAttribute(attribute, method, attributeOwner);\n+\t\t\t\tresult.add(attribute);\n+\t\t\t}\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tprivate Map<String, Method> getGetterAndIsserAttributes(Method[] methods, FrankElement attributeOwner) {\n+\t\tMap<String, Method> getterAttributes = getAttributeToMethodMap(methods, \"get\");\n+\t\tMap<String, Method> isserAttributes = getAttributeToMethodMap(methods, \"is\");\n+\t\tfor(String isserAttributeName : isserAttributes.keySet()) {\n+\t\t\tif(getterAttributes.containsKey(isserAttributeName)) {\n+\t\t\t\tlog.warn(String.format(\"For FrankElement %s, attribute %s has both a getX and an isX method\",\n+\t\t\t\t\t\tattributeOwner.getSimpleName(), isserAttributeName));\n+\t\t\t} else {\n+\t\t\t\tgetterAttributes.put(isserAttributeName, isserAttributes.get(isserAttributeName));\n+\t\t\t}\n+\t\t}\n+\t\treturn getterAttributes;\n+\t}\n+\n+\tstatic Map<String, Method> getAttributeToMethodMap(Method[] methods, String prefix) {\n+\t\tList<Method> methodList = Arrays.asList(methods);\n+\t\tmethodList = methodList.stream()\n+\t\t\t\t.filter(FrankDocModel::isGetterOrSetter)\n+\t\t\t\t.filter(m -> m.getName().startsWith(prefix) && (m.getName().length() > prefix.length()))\n+\t\t\t\t.collect(Collectors.toList());\t\t\n+\t\tMap<String, Method> result = new HashMap<>();\n+\t\tfor(Method method: methodList) {\n+\t\t\tString strippedName = method.getName().substring(prefix.length());\n+\t\t\tString attributeName = strippedName.substring(0, 1).toLowerCase() + strippedName.substring(1);\n+\t\t\tresult.put(attributeName, method);\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tstatic boolean isGetterOrSetter(Method method) {\n+\t\tboolean isSetter = method.getReturnType().isPrimitive()\n+\t\t\t\t&& method.getReturnType().getName().equals(\"void\")\n+\t\t\t\t&& (method.getParameterTypes().length == 1)\n+\t\t\t\t&& (method.getParameterTypes()[0].isPrimitive()\n+\t\t\t\t\t\t|| method.getParameterTypes()[0].getName().equals(JAVA_STRING));\n+\t\tboolean isGetter = (\n+\t\t\t\t\tmethod.getReturnType().isPrimitive()\n+\t\t\t\t\t|| method.getReturnType().getName().equals(JAVA_STRING)\n+\t\t\t\t) && (method.getParameterTypes().length == 0);\n+\t\treturn isSetter || isGetter;\n+\t}\n+\n+\tprivate void compareGetterWithSetter(Method setter, Method getter, FrankElement attributeOwner) {\n+\t\tString setterType = setter.getParameterTypes()[0].getName();\n+\t\tString getterType = getter.getReturnType().getName();\n+\t\tif(! getterType.equals(setterType)) {\n+\t\t\tlog.warn(String.format(\"In Frank element %s: setter %s has type %s while the getter has type %s\",\n+\t\t\t\t\tattributeOwner.getSimpleName(), setter.getName(), setterType, getterType));\n+\t\t}\n+\t}\n+\n+\tprivate void documentAttribute(\n+\t\t\tFrankAttribute attribute,\n+\t\t\tMethod method,\n+\t\t\tFrankElement attributeOwner) {\n+\t\tattribute.setDeprecated(AnnotationUtils.findAnnotation(method, Deprecated.class) != null);\n+\t\tIbisDocRef ibisDocRef = AnnotationUtils.findAnnotation(method, IbisDocRef.class);\n+\t\tif(ibisDocRef != null) {\n+\t\t\tParsedIbisDocRef parsed = parseIbisDocRef(ibisDocRef, method);\n+\t\t\tIbisDoc ibisDoc = AnnotationUtils.findAnnotation(parsed.getReferredMethod(), IbisDoc.class);\n+\t\t\tif(ibisDoc != null) {\n+\t\t\t\tattribute.setDescribingElement(findOrCreateFrankElement(\n+\t\t\t\t\t\tparsed.getReferredMethod().getDeclaringClass()));", "originalCommit": "b4d3816722edebfbc592a2cd3ca3020892bb6b7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzIyNzYyNA==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r503227624", "bodyText": "Gedaan.", "author": "mhdirkse", "createdAt": "2020-10-12T11:23:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzA4MDkxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzA4Mzk5MA==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r503083990", "bodyText": "Dit mag op \u00e9\u00e9n regel", "author": "gvanbrakel", "createdAt": "2020-10-12T07:15:29Z", "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankDocModel.java", "diffHunk": "@@ -0,0 +1,213 @@\n+package nl.nn.adapterframework.doc.model;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n+import org.springframework.core.annotation.AnnotationUtils;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import nl.nn.adapterframework.doc.IbisDoc;\n+import nl.nn.adapterframework.doc.IbisDocRef;\n+import nl.nn.adapterframework.util.LogUtil;\n+\n+public class FrankDocModel {\n+\tprivate static final String JAVA_STRING = \"java.lang.String\";\n+\n+\tprivate static Logger log = LogUtil.getLogger(FrankDocModel.class);\n+\n+\tprivate @Getter List<FrankDocGroup> groups;\n+\tprivate @Getter Map<String, FrankElement> allElements = new HashMap<>();\n+\n+\tpublic FrankDocModel() {\n+\t\tgroups = new ArrayList<>();\n+\t}\n+\n+\tpublic FrankElement findOrCreateFrankElement(Class<?> clazz) {\n+\t\tif(allElements.containsKey(clazz.getName())) {\n+\t\t\treturn allElements.get(clazz.getName());\n+\t\t}\n+\t\tClass<?> superClass = clazz.getSuperclass();\n+\t\tFrankElement parent = superClass == null ? null : findOrCreateFrankElement(superClass);\n+\t\tFrankElement current = new FrankElement(clazz, parent);\n+\t\tcurrent.setAttributes(createAttributes(clazz.getDeclaredMethods(), current));\n+\t\tallElements.put(current.getFullName(), current);\n+\t\treturn current;\n+\t}\n+\n+\tList<FrankAttribute> createAttributes(Method[] methods, FrankElement attributeOwner) {\n+\t\tMap<String, Method> setterAttributes = getAttributeToMethodMap(methods, \"set\");\n+\t\tMap<String, Method> getterAttributes = getGetterAndIsserAttributes(methods, attributeOwner);\n+\t\tMap<String, String> setterToAttributeName = new HashMap<>();\n+\t\tfor(String attributeName: setterAttributes.keySet()) {\n+\t\t\tsetterToAttributeName.put(setterAttributes.get(attributeName).getName(), attributeName);\n+\t\t}\n+\t\tList<FrankAttribute> result = new ArrayList<>();\n+\t\tfor(Method method: methods) {\n+\t\t\tif(setterToAttributeName.containsKey(method.getName())) {\n+\t\t\t\tString attributeName = setterToAttributeName.get(method.getName());\n+\t\t\t\tif(getterAttributes.containsKey(attributeName)) {\n+\t\t\t\t\tcompareGetterWithSetter(method, getterAttributes.get(attributeName), attributeOwner);\n+\t\t\t\t}\n+\t\t\t\tFrankAttribute attribute = new FrankAttribute(attributeName);\n+\t\t\t\tattribute.setDescribingElement(attributeOwner);\n+\t\t\t\tdocumentAttribute(attribute, method, attributeOwner);\n+\t\t\t\tresult.add(attribute);\n+\t\t\t}\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tprivate Map<String, Method> getGetterAndIsserAttributes(Method[] methods, FrankElement attributeOwner) {\n+\t\tMap<String, Method> getterAttributes = getAttributeToMethodMap(methods, \"get\");\n+\t\tMap<String, Method> isserAttributes = getAttributeToMethodMap(methods, \"is\");\n+\t\tfor(String isserAttributeName : isserAttributes.keySet()) {\n+\t\t\tif(getterAttributes.containsKey(isserAttributeName)) {\n+\t\t\t\tlog.warn(String.format(\"For FrankElement %s, attribute %s has both a getX and an isX method\",\n+\t\t\t\t\t\tattributeOwner.getSimpleName(), isserAttributeName));\n+\t\t\t} else {\n+\t\t\t\tgetterAttributes.put(isserAttributeName, isserAttributes.get(isserAttributeName));\n+\t\t\t}\n+\t\t}\n+\t\treturn getterAttributes;\n+\t}\n+\n+\tstatic Map<String, Method> getAttributeToMethodMap(Method[] methods, String prefix) {\n+\t\tList<Method> methodList = Arrays.asList(methods);\n+\t\tmethodList = methodList.stream()\n+\t\t\t\t.filter(FrankDocModel::isGetterOrSetter)\n+\t\t\t\t.filter(m -> m.getName().startsWith(prefix) && (m.getName().length() > prefix.length()))\n+\t\t\t\t.collect(Collectors.toList());\t\t\n+\t\tMap<String, Method> result = new HashMap<>();\n+\t\tfor(Method method: methodList) {\n+\t\t\tString strippedName = method.getName().substring(prefix.length());\n+\t\t\tString attributeName = strippedName.substring(0, 1).toLowerCase() + strippedName.substring(1);\n+\t\t\tresult.put(attributeName, method);\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tstatic boolean isGetterOrSetter(Method method) {\n+\t\tboolean isSetter = method.getReturnType().isPrimitive()\n+\t\t\t\t&& method.getReturnType().getName().equals(\"void\")\n+\t\t\t\t&& (method.getParameterTypes().length == 1)\n+\t\t\t\t&& (method.getParameterTypes()[0].isPrimitive()\n+\t\t\t\t\t\t|| method.getParameterTypes()[0].getName().equals(JAVA_STRING));\n+\t\tboolean isGetter = (\n+\t\t\t\t\tmethod.getReturnType().isPrimitive()\n+\t\t\t\t\t|| method.getReturnType().getName().equals(JAVA_STRING)\n+\t\t\t\t) && (method.getParameterTypes().length == 0);\n+\t\treturn isSetter || isGetter;\n+\t}\n+\n+\tprivate void compareGetterWithSetter(Method setter, Method getter, FrankElement attributeOwner) {\n+\t\tString setterType = setter.getParameterTypes()[0].getName();\n+\t\tString getterType = getter.getReturnType().getName();\n+\t\tif(! getterType.equals(setterType)) {\n+\t\t\tlog.warn(String.format(\"In Frank element %s: setter %s has type %s while the getter has type %s\",\n+\t\t\t\t\tattributeOwner.getSimpleName(), setter.getName(), setterType, getterType));\n+\t\t}\n+\t}\n+\n+\tprivate void documentAttribute(\n+\t\t\tFrankAttribute attribute,\n+\t\t\tMethod method,\n+\t\t\tFrankElement attributeOwner) {\n+\t\tattribute.setDeprecated(AnnotationUtils.findAnnotation(method, Deprecated.class) != null);\n+\t\tIbisDocRef ibisDocRef = AnnotationUtils.findAnnotation(method, IbisDocRef.class);\n+\t\tif(ibisDocRef != null) {\n+\t\t\tParsedIbisDocRef parsed = parseIbisDocRef(ibisDocRef, method);\n+\t\t\tIbisDoc ibisDoc = AnnotationUtils.findAnnotation(parsed.getReferredMethod(), IbisDoc.class);\n+\t\t\tif(ibisDoc != null) {\n+\t\t\t\tattribute.setDescribingElement(findOrCreateFrankElement(\n+\t\t\t\t\t\tparsed.getReferredMethod().getDeclaringClass()));\n+\t\t\t\tattribute.parseIbisDocAnnotation(ibisDoc);\n+\t\t\t\tif(parsed.hasOrder) {\n+\t\t\t\t\tattribute.setOrder(parsed.getOrder());\n+\t\t\t\t}\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t\tIbisDoc ibisDoc = AnnotationUtils.findAnnotation(method, IbisDoc.class);\n+\t\tif(ibisDoc != null) {\n+\t\t\tattribute.parseIbisDocAnnotation(ibisDoc);\n+\t\t}\n+\t\telse {\n+\t\t\tlog.warn(String.format(\"No documentation available for FrankElement %s, attribute %s\",\n+\t\t\t\t\tattributeOwner.getSimpleName(), attribute.getName()));\n+\t\t}\n+\t}\n+\n+\tprivate class ParsedIbisDocRef {\n+\t\tprivate @Getter @Setter boolean hasOrder;\n+\t\tprivate @Getter @Setter int order;\n+\t\tprivate @Getter @Setter Method referredMethod;\n+\t}\n+\n+\tprivate ParsedIbisDocRef parseIbisDocRef(IbisDocRef ibisDocRef, Method originalMethod) {\n+\t\tParsedIbisDocRef result = new ParsedIbisDocRef();\n+\t\tresult.setHasOrder(false);\n+\t\tString[] values = ibisDocRef.value();\n+\t\tString methodString = null;\n+\t\tif (values.length == 1) {\n+\t\t\tmethodString = ibisDocRef.value()[0];\n+\t\t} else if (values.length == 2) {\n+\t\t\tmethodString = ibisDocRef.value()[1];\n+\t\t\ttry {\n+\t\t\t\tresult.setOrder(Integer.parseInt(ibisDocRef.value()[0]));\n+\t\t\t\tresult.setHasOrder(true);\n+\t\t\t} catch (Throwable t) {\n+\t\t\t\tlog.warn(String.format(\"Could not parse order in @IbisDocRef annotation: \"\n+\t\t\t\t\t\t+ Integer.parseInt(ibisDocRef.value()[0])));", "originalCommit": "b4d3816722edebfbc592a2cd3ca3020892bb6b7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzIyNjkwMA==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r503226900", "bodyText": "Gedaan.", "author": "mhdirkse", "createdAt": "2020-10-12T11:22:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzA4Mzk5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzA4OTM0OA==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r503089348", "bodyText": "Ik zie deze method nog niet buiten de tests gebruikt worden. Is er logica of configuratie die bepaalt welke groepen er zijn?", "author": "gvanbrakel", "createdAt": "2020-10-12T07:26:30Z", "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankDocModel.java", "diffHunk": "@@ -0,0 +1,213 @@\n+package nl.nn.adapterframework.doc.model;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n+import org.springframework.core.annotation.AnnotationUtils;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import nl.nn.adapterframework.doc.IbisDoc;\n+import nl.nn.adapterframework.doc.IbisDocRef;\n+import nl.nn.adapterframework.util.LogUtil;\n+\n+public class FrankDocModel {\n+\tprivate static final String JAVA_STRING = \"java.lang.String\";\n+\n+\tprivate static Logger log = LogUtil.getLogger(FrankDocModel.class);\n+\n+\tprivate @Getter List<FrankDocGroup> groups;\n+\tprivate @Getter Map<String, FrankElement> allElements = new HashMap<>();\n+\n+\tpublic FrankDocModel() {\n+\t\tgroups = new ArrayList<>();\n+\t}\n+\n+\tpublic FrankElement findOrCreateFrankElement(Class<?> clazz) {\n+\t\tif(allElements.containsKey(clazz.getName())) {\n+\t\t\treturn allElements.get(clazz.getName());\n+\t\t}\n+\t\tClass<?> superClass = clazz.getSuperclass();\n+\t\tFrankElement parent = superClass == null ? null : findOrCreateFrankElement(superClass);\n+\t\tFrankElement current = new FrankElement(clazz, parent);\n+\t\tcurrent.setAttributes(createAttributes(clazz.getDeclaredMethods(), current));\n+\t\tallElements.put(current.getFullName(), current);\n+\t\treturn current;\n+\t}\n+\n+\tList<FrankAttribute> createAttributes(Method[] methods, FrankElement attributeOwner) {\n+\t\tMap<String, Method> setterAttributes = getAttributeToMethodMap(methods, \"set\");\n+\t\tMap<String, Method> getterAttributes = getGetterAndIsserAttributes(methods, attributeOwner);\n+\t\tMap<String, String> setterToAttributeName = new HashMap<>();\n+\t\tfor(String attributeName: setterAttributes.keySet()) {\n+\t\t\tsetterToAttributeName.put(setterAttributes.get(attributeName).getName(), attributeName);\n+\t\t}\n+\t\tList<FrankAttribute> result = new ArrayList<>();\n+\t\tfor(Method method: methods) {\n+\t\t\tif(setterToAttributeName.containsKey(method.getName())) {\n+\t\t\t\tString attributeName = setterToAttributeName.get(method.getName());\n+\t\t\t\tif(getterAttributes.containsKey(attributeName)) {\n+\t\t\t\t\tcompareGetterWithSetter(method, getterAttributes.get(attributeName), attributeOwner);\n+\t\t\t\t}\n+\t\t\t\tFrankAttribute attribute = new FrankAttribute(attributeName);\n+\t\t\t\tattribute.setDescribingElement(attributeOwner);\n+\t\t\t\tdocumentAttribute(attribute, method, attributeOwner);\n+\t\t\t\tresult.add(attribute);\n+\t\t\t}\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tprivate Map<String, Method> getGetterAndIsserAttributes(Method[] methods, FrankElement attributeOwner) {\n+\t\tMap<String, Method> getterAttributes = getAttributeToMethodMap(methods, \"get\");\n+\t\tMap<String, Method> isserAttributes = getAttributeToMethodMap(methods, \"is\");\n+\t\tfor(String isserAttributeName : isserAttributes.keySet()) {\n+\t\t\tif(getterAttributes.containsKey(isserAttributeName)) {\n+\t\t\t\tlog.warn(String.format(\"For FrankElement %s, attribute %s has both a getX and an isX method\",\n+\t\t\t\t\t\tattributeOwner.getSimpleName(), isserAttributeName));\n+\t\t\t} else {\n+\t\t\t\tgetterAttributes.put(isserAttributeName, isserAttributes.get(isserAttributeName));\n+\t\t\t}\n+\t\t}\n+\t\treturn getterAttributes;\n+\t}\n+\n+\tstatic Map<String, Method> getAttributeToMethodMap(Method[] methods, String prefix) {\n+\t\tList<Method> methodList = Arrays.asList(methods);\n+\t\tmethodList = methodList.stream()\n+\t\t\t\t.filter(FrankDocModel::isGetterOrSetter)\n+\t\t\t\t.filter(m -> m.getName().startsWith(prefix) && (m.getName().length() > prefix.length()))\n+\t\t\t\t.collect(Collectors.toList());\t\t\n+\t\tMap<String, Method> result = new HashMap<>();\n+\t\tfor(Method method: methodList) {\n+\t\t\tString strippedName = method.getName().substring(prefix.length());\n+\t\t\tString attributeName = strippedName.substring(0, 1).toLowerCase() + strippedName.substring(1);\n+\t\t\tresult.put(attributeName, method);\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tstatic boolean isGetterOrSetter(Method method) {\n+\t\tboolean isSetter = method.getReturnType().isPrimitive()\n+\t\t\t\t&& method.getReturnType().getName().equals(\"void\")\n+\t\t\t\t&& (method.getParameterTypes().length == 1)\n+\t\t\t\t&& (method.getParameterTypes()[0].isPrimitive()\n+\t\t\t\t\t\t|| method.getParameterTypes()[0].getName().equals(JAVA_STRING));\n+\t\tboolean isGetter = (\n+\t\t\t\t\tmethod.getReturnType().isPrimitive()\n+\t\t\t\t\t|| method.getReturnType().getName().equals(JAVA_STRING)\n+\t\t\t\t) && (method.getParameterTypes().length == 0);\n+\t\treturn isSetter || isGetter;\n+\t}\n+\n+\tprivate void compareGetterWithSetter(Method setter, Method getter, FrankElement attributeOwner) {\n+\t\tString setterType = setter.getParameterTypes()[0].getName();\n+\t\tString getterType = getter.getReturnType().getName();\n+\t\tif(! getterType.equals(setterType)) {\n+\t\t\tlog.warn(String.format(\"In Frank element %s: setter %s has type %s while the getter has type %s\",\n+\t\t\t\t\tattributeOwner.getSimpleName(), setter.getName(), setterType, getterType));\n+\t\t}\n+\t}\n+\n+\tprivate void documentAttribute(\n+\t\t\tFrankAttribute attribute,\n+\t\t\tMethod method,\n+\t\t\tFrankElement attributeOwner) {\n+\t\tattribute.setDeprecated(AnnotationUtils.findAnnotation(method, Deprecated.class) != null);\n+\t\tIbisDocRef ibisDocRef = AnnotationUtils.findAnnotation(method, IbisDocRef.class);\n+\t\tif(ibisDocRef != null) {\n+\t\t\tParsedIbisDocRef parsed = parseIbisDocRef(ibisDocRef, method);\n+\t\t\tIbisDoc ibisDoc = AnnotationUtils.findAnnotation(parsed.getReferredMethod(), IbisDoc.class);\n+\t\t\tif(ibisDoc != null) {\n+\t\t\t\tattribute.setDescribingElement(findOrCreateFrankElement(\n+\t\t\t\t\t\tparsed.getReferredMethod().getDeclaringClass()));\n+\t\t\t\tattribute.parseIbisDocAnnotation(ibisDoc);\n+\t\t\t\tif(parsed.hasOrder) {\n+\t\t\t\t\tattribute.setOrder(parsed.getOrder());\n+\t\t\t\t}\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t\tIbisDoc ibisDoc = AnnotationUtils.findAnnotation(method, IbisDoc.class);\n+\t\tif(ibisDoc != null) {\n+\t\t\tattribute.parseIbisDocAnnotation(ibisDoc);\n+\t\t}\n+\t\telse {\n+\t\t\tlog.warn(String.format(\"No documentation available for FrankElement %s, attribute %s\",\n+\t\t\t\t\tattributeOwner.getSimpleName(), attribute.getName()));\n+\t\t}\n+\t}\n+\n+\tprivate class ParsedIbisDocRef {\n+\t\tprivate @Getter @Setter boolean hasOrder;\n+\t\tprivate @Getter @Setter int order;\n+\t\tprivate @Getter @Setter Method referredMethod;\n+\t}\n+\n+\tprivate ParsedIbisDocRef parseIbisDocRef(IbisDocRef ibisDocRef, Method originalMethod) {\n+\t\tParsedIbisDocRef result = new ParsedIbisDocRef();\n+\t\tresult.setHasOrder(false);\n+\t\tString[] values = ibisDocRef.value();\n+\t\tString methodString = null;\n+\t\tif (values.length == 1) {\n+\t\t\tmethodString = ibisDocRef.value()[0];\n+\t\t} else if (values.length == 2) {\n+\t\t\tmethodString = ibisDocRef.value()[1];\n+\t\t\ttry {\n+\t\t\t\tresult.setOrder(Integer.parseInt(ibisDocRef.value()[0]));\n+\t\t\t\tresult.setHasOrder(true);\n+\t\t\t} catch (Throwable t) {\n+\t\t\t\tlog.warn(String.format(\"Could not parse order in @IbisDocRef annotation: \"\n+\t\t\t\t\t\t+ Integer.parseInt(ibisDocRef.value()[0])));\n+\t\t\t}\n+\t\t}\n+\t\telse {\n+\t\t\tlog.warn(String.format(String.format(\"Too many or zero parameters in @IbisDocRef annotation on method: %s.%s\",\n+\t\t\t\t\toriginalMethod.getDeclaringClass().getName(), originalMethod.getName())));\n+\t\t\treturn null;\n+\t\t}\n+\t\tresult.setReferredMethod(getReferredMethod(methodString, originalMethod));\n+\t\treturn result;\n+\t}\n+\n+\tprivate static Method getReferredMethod(String methodString, Method originalMethod) {\n+\t\tString lastNameComponent = methodString.substring(methodString.lastIndexOf(\".\") + 1).trim();\n+\t\tchar firstLetter = lastNameComponent.toCharArray()[0];\n+\t\tString fullClassName = methodString;\n+\t\tString methodName = lastNameComponent;\n+\t\tif (Character.isLowerCase(firstLetter)) {\n+\t\t\tint index = methodString.lastIndexOf(\".\");\n+\t\t\tfullClassName = methodString.substring(0, index);\n+\t\t} else {\n+\t\t\tmethodName = originalMethod.getName();\n+\t\t}\n+\t\treturn getParentMethod(fullClassName, methodName);\n+\t}\n+\n+\tprivate static Method getParentMethod(String className, String methodName) {\n+\t\ttry {\n+\t\t\tClass<?> parentClass = Class.forName(className);\n+\t\t\tfor (Method parentMethod : parentClass.getMethods()) {\n+\t\t\t\tif (parentMethod.getName().equals(methodName)) {\n+\t\t\t\t\treturn parentMethod;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn null;\n+\t\t} catch (ClassNotFoundException e) {\n+\t\t\tlog.warn(\"Super class [\" + className + \"] was not found!\");\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n+\tpublic FrankDocGroup addGroup(String name) {", "originalCommit": "b4d3816722edebfbc592a2cd3ca3020892bb6b7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzE0MDQ4OA==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r503140488", "bodyText": "Nog niet. De logica die bepaalt welke groepen er zijn moet nog komen, en dan gaat deze method gebruikt worden.", "author": "mhdirkse", "createdAt": "2020-10-12T08:54:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzA4OTM0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzA4OTY4MQ==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r503089681", "bodyText": "Ik zie deze method nog niet gebruikt worden buiten de tests. Is er logica of configuratie die bepaalt welke element er in een groep zitten?", "author": "gvanbrakel", "createdAt": "2020-10-12T07:27:11Z", "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankDocGroup.java", "diffHunk": "@@ -0,0 +1,20 @@\n+package nl.nn.adapterframework.doc.model;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import lombok.Getter;\n+\n+public class FrankDocGroup {\n+\tprivate @Getter String name;\n+\tprivate @Getter Map<String, FrankElement> elements;\n+\n+\tpublic FrankDocGroup(String name) {\n+\t\tthis.name = name;\n+\t\tthis.elements = new HashMap<>();\n+\t}\n+\n+\tpublic void addAsElement(Class<?> clazz, FrankDocModel model) {", "originalCommit": "b4d3816722edebfbc592a2cd3ca3020892bb6b7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzE0MTgxNA==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r503141814", "bodyText": "Nog niet. De logica die bepaalt welke groepen en welke elementen er zijn komt nog. We hebben wel al een functie die alle classes zoekt die een interface implementeren: ModelBuilder.getSpringBeans().", "author": "mhdirkse", "createdAt": "2020-10-12T08:56:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzA4OTY4MQ=="}], "type": "inlineReview"}, {"oid": "a98c33b865a6b8489b4d77b3e7f7048ce1d9f0ec", "url": "https://github.com/ibissource/iaf/commit/a98c33b865a6b8489b4d77b3e7f7048ce1d9f0ec", "message": "Work in progress: process review comments", "committedDate": "2020-10-12T09:06:59Z", "type": "commit"}, {"oid": "3a1c13e80a9fca05ada7b51c20e2ba8d75596626", "url": "https://github.com/ibissource/iaf/commit/3a1c13e80a9fca05ada7b51c20e2ba8d75596626", "message": "Fix ModelBuilderTest", "committedDate": "2020-10-12T09:22:46Z", "type": "commit"}, {"oid": "a6c5b1b5a768eb7d249827b92d7957fee5af54f2", "url": "https://github.com/ibissource/iaf/commit/a6c5b1b5a768eb7d249827b92d7957fee5af54f2", "message": "Fix FrankDocGroupTest", "committedDate": "2020-10-12T09:28:43Z", "type": "commit"}, {"oid": "97c6bccf97feca0bb184fc99de84fd71b48c0232", "url": "https://github.com/ibissource/iaf/commit/97c6bccf97feca0bb184fc99de84fd71b48c0232", "message": "Finish recreating the testtarget classes", "committedDate": "2020-10-12T10:57:21Z", "type": "commit"}, {"oid": "1ed3b79322b36ad019db49504436c8a696c37b8c", "url": "https://github.com/ibissource/iaf/commit/1ed3b79322b36ad019db49504436c8a696c37b8c", "message": "Merge branch 'fixTestTargetWasNotCheckedIn' into fillDataModel", "committedDate": "2020-10-12T10:59:10Z", "type": "commit"}, {"oid": "78a635b7f2d38f47fae0518a1ba081825a15930b", "url": "https://github.com/ibissource/iaf/commit/78a635b7f2d38f47fae0518a1ba081825a15930b", "message": "Fix bug.", "committedDate": "2020-10-12T11:19:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI4NDk4Nw==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r503284987", "bodyText": "voor assertEquals() en assertSame() kan je static imports maken:\nimport static org.junit.Assert.assertEquals;\n\nAls je in de editor assertEquals<Ctrl-Space> typet, komt dat vanzelf.\nIn de code is dat herkenbaarder, en daardoor beter leesbaar", "author": "gvanbrakel", "createdAt": "2020-10-12T13:09:47Z", "path": "core/src/test/java/nl/nn/adapterframework/doc/model/FrankDocGroupTest.java", "diffHunk": "@@ -0,0 +1,65 @@\n+package nl.nn.adapterframework.doc.model;\n+\n+import java.util.Map;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import nl.nn.adapterframework.doc.ModelBuilder;\n+\n+public class FrankDocGroupTest {\n+\tpublic static final String SIMPLE = \"nl.nn.adapterframework.doc.testtarget.simple\";\n+\tprivate static final String PARENT = SIMPLE + \".ListenerParent\";\n+\tprivate static final String CHILD = SIMPLE + \".ListenerChild\";\n+\n+\t@Test\n+\tpublic void whenChildElementAddedBeforeParentThenCorrectModel() {\n+\t\tModelBuilder builder = new ModelBuilder();\n+\t\tFrankDocGroup group = builder.getModel().addGroup(\"Listeners\");\n+\t\tgroup.addAsElement(ModelBuilder.getClass(CHILD), builder.getModel());\n+\t\tgroup.addAsElement(ModelBuilder.getClass(PARENT), builder.getModel());\n+\t\tcheckModelAfterChildAndParentAdded(builder.getModel());\n+\t}\n+\n+\t@Test\n+\tpublic void whenParentElementAddedBeforeChildThenCorrectModel() {\n+\t\tModelBuilder builder = new ModelBuilder();\n+\t\tFrankDocGroup group = builder.getModel().addGroup(\"Listeners\");\n+\t\tgroup.addAsElement(ModelBuilder.getClass(PARENT), builder.getModel());\n+\t\tgroup.addAsElement(ModelBuilder.getClass(CHILD), builder.getModel());\n+\t\tcheckModelAfterChildAndParentAdded(builder.getModel());\n+\t}\n+\n+\tprivate void checkModelAfterChildAndParentAdded(FrankDocModel model) {\n+\t\tAssert.assertEquals(1, model.getGroups().size());\n+\t\tFrankDocGroup actualGroup = model.getGroups().get(0);\n+\t\tMap<String, FrankElement> actualAllElements = model.getAllElements();\n+\t\tAssert.assertTrue(actualGroup.getElements().containsKey(PARENT));\n+\t\tAssert.assertTrue(actualGroup.getElements().containsKey(CHILD));\n+\t\tfor(String elementInGroup: actualGroup.getElements().keySet()) {\n+\t\t\tFrankElement groupElement = actualGroup.getElements().get(elementInGroup);\n+\t\t\tFrankElement allElement = actualAllElements.get(elementInGroup);\n+\t\t\tAssert.assertSame(\n+\t\t\t\t\t\"Different objects for group element and all element for element name: \" + elementInGroup,\n+\t\t\t\t\tgroupElement, allElement);\n+\t\t}\n+\t\tFrankElement actualObject = model.getAllElements().get(\"java.lang.Object\");\n+\t\tAssert.assertNull(actualObject.getParent());\n+\t\tFrankElement actualParent = actualGroup.getElements().get(PARENT);\n+\t\tAssert.assertSame(actualObject, actualParent.getParent());\n+\t\tAssert.assertEquals(PARENT, actualParent.getFullName());", "originalCommit": "78a635b7f2d38f47fae0518a1ba081825a15930b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzM5MjM5Mg==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r503392392", "bodyText": "Gedaan.", "author": "mhdirkse", "createdAt": "2020-10-12T16:02:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI4NDk4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI4NjgxNA==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r503286814", "bodyText": "Ik vind het prettiger om een javadoc te lezen die beschrijft wat de method doet, in plaats van dat te moeten reconstrueren uit de @param en @return tag", "author": "gvanbrakel", "createdAt": "2020-10-12T13:12:55Z", "path": "core/src/test/java/nl/nn/adapterframework/doc/model/FrankDocModelTest.java", "diffHunk": "@@ -0,0 +1,201 @@\n+package nl.nn.adapterframework.doc.model;\n+\n+import java.lang.reflect.Method;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import nl.nn.adapterframework.doc.ModelBuilder;\n+\n+public class FrankDocModelTest {\n+\tprivate static final String IBISDOCREF = \"nl.nn.adapterframework.doc.testtarget.ibisdocref\";\n+\tprivate static final String REFERRED_CHILD = IBISDOCREF + \".ChildTarget\";\n+\tprivate static final String REFERRED_PARENT = IBISDOCREF + \".ParentTarget\";\n+\n+\tprivate FrankDocModel instance;\n+\n+\t@Before\n+\tpublic void setUp() {\n+\t\tinstance = new FrankDocModel();\n+\t}\n+\n+\t@Test\n+\tpublic void whenSetterAndGetterThenAttribute() {\n+\t\tcheckReflectAttributeCreated(\"attributeSetterGetter\");\n+\t}\n+\n+\tprivate FrankAttribute checkReflectAttributeCreated(String attributeName) {\n+\t\tMap<String, FrankAttribute> actual = getReflectInvestigatedFrankAttributes();\n+\t\tAssert.assertTrue(actual.containsKey(attributeName));\n+\t\tAssert.assertEquals(attributeName, actual.get(attributeName).getName());\n+\t\treturn actual.get(attributeName);\n+\t}\n+\n+\tprivate Map<String, FrankAttribute> getReflectInvestigatedFrankAttributes() {\n+\t\treturn getAttributesOfClass(\"nl.nn.adapterframework.doc.testtarget.reflect.FrankAttributeTarget\");\n+\t}\n+\n+\t/**\n+\t * @param className The name of the Class<?> to get FrankAttribute objects for.\n+\t * @return The FrankAttributes that ModelBuilder can produce from a Class<?>. Note\n+\t * that the describingElement is not set, because we are not testing here in relation\n+\t * to creating the enclosing FrankElement of the attributes.", "originalCommit": "78a635b7f2d38f47fae0518a1ba081825a15930b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzM5MTk1MQ==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r503391951", "bodyText": "Gedaan, maar ik ben niet helemaal zeker of je nu tevreden bent.", "author": "mhdirkse", "createdAt": "2020-10-12T16:01:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI4NjgxNA=="}], "type": "inlineReview"}, {"oid": "491491975a96054bd4513b4429f1a3309409534f", "url": "https://github.com/ibissource/iaf/commit/491491975a96054bd4513b4429f1a3309409534f", "message": "Follow-up review comments", "committedDate": "2020-10-12T15:58:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzc0ODg0MA==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r503748840", "bodyText": "public/private ?", "author": "nielsm5", "createdAt": "2020-10-13T08:06:31Z", "path": "core/src/main/java/nl/nn/adapterframework/doc/ModelBuilder.java", "diffHunk": "@@ -0,0 +1,43 @@\n+package nl.nn.adapterframework.doc;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+\n+import lombok.Getter;\n+import nl.nn.adapterframework.doc.model.FrankDocModel;\n+import nl.nn.adapterframework.doc.objects.SpringBean;\n+\n+public class ModelBuilder {\n+\tprivate @Getter FrankDocModel model;\n+\n+\tpublic ModelBuilder() {\n+\t\tmodel = new FrankDocModel();\n+\t}\n+\n+\t/**\n+\t * @param interfaceName The interface for which we want SpringBean objects.\n+\t * @return All classes implementing interfaceName, ordered by their full class name.\n+\t */\n+\tstatic List<SpringBean> getSpringBeans(final String interfaceName) {", "originalCommit": "491491975a96054bd4513b4429f1a3309409534f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzgxMzQyNg==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r503813426", "bodyText": "Niet private, want dan kan ik hem niet unit testen. Ik denk dat ik in deze class uiteindelijk het productie FrankDocModel ga genereren, dus hier komt een method waarin alle groepen worden gemaakt en waarin alle FrankElement objecten worden gemaakt. Daarvoor heb ik waarschijnlijk een nieuwe method nodig die getSpringBeans() gaat gebruiken. Die nieuwe method wordt dan public, dus getSpringBeans() hoeft niet public te worden.", "author": "mhdirkse", "createdAt": "2020-10-13T09:42:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzc0ODg0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzc0OTMyMQ==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r503749321", "bodyText": "Wat doet dit? Ik zie 2 static methodes die hier niets mee (kunnen) doen.", "author": "nielsm5", "createdAt": "2020-10-13T08:07:16Z", "path": "core/src/main/java/nl/nn/adapterframework/doc/ModelBuilder.java", "diffHunk": "@@ -0,0 +1,43 @@\n+package nl.nn.adapterframework.doc;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+\n+import lombok.Getter;\n+import nl.nn.adapterframework.doc.model.FrankDocModel;\n+import nl.nn.adapterframework.doc.objects.SpringBean;\n+\n+public class ModelBuilder {\n+\tprivate @Getter FrankDocModel model;\n+\n+\tpublic ModelBuilder() {\n+\t\tmodel = new FrankDocModel();", "originalCommit": "491491975a96054bd4513b4429f1a3309409534f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzgwOTEzMw==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r503809133", "bodyText": "De code is nog niet af, dat zie je hier. Een FrankDocModel object gaat alle informatie bevatten die je nodig hebt om de Frank!Doc, ibisdoc.xsd, uglify_lookup.xsd en de JSON voor de nieuwe Frank!Doc te genereren. Voordat ik begon heb ik een datamodel getekend. Dat is niet perfect, maar het is goed genoeg als startpunt. Ik heb dit datamodel met je gedeeld onder vermelding van deze pull request.", "author": "mhdirkse", "createdAt": "2020-10-13T09:35:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzc0OTMyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzgxMTU3NQ==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r503811575", "bodyText": "Deze pull request bevat FrankDocModel, FrankDocGroup, FrankElement en FrankAttribute. De andere classes uit het model komen in een latere pull request. In deze pull request maken we alleen de logica waarmee de objecten worden gegenereerd, met unit tests. We gebruiken als testdata classes onder src/test/java met testtarget in de package naam. Het maken van het productie FrankDocModel, met alle groepen en elementen en attributes die we nodig hebben, komt later.", "author": "mhdirkse", "createdAt": "2020-10-13T09:39:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzc0OTMyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzc1NjU0OA==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r503756548", "bodyText": "De code ziet er vrij complex uit, is het niet een stuk handig als je Spring BeanUtils#getPropertyDescriptors() gebuikt om een lijst met alle PropertyDescriptors terug te krijgen waar je over kan itereren?", "author": "nielsm5", "createdAt": "2020-10-13T08:18:08Z", "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankDocModel.java", "diffHunk": "@@ -0,0 +1,209 @@\n+package nl.nn.adapterframework.doc.model;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n+import org.springframework.core.annotation.AnnotationUtils;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import nl.nn.adapterframework.doc.IbisDoc;\n+import nl.nn.adapterframework.doc.IbisDocRef;\n+import nl.nn.adapterframework.util.LogUtil;\n+\n+public class FrankDocModel {\n+\tprivate static final String JAVA_STRING = \"java.lang.String\";\n+\n+\tprivate static Logger log = LogUtil.getLogger(FrankDocModel.class);\n+\n+\tprivate @Getter List<FrankDocGroup> groups;\n+\tprivate @Getter Map<String, FrankElement> allElements = new HashMap<>();\n+\n+\tpublic FrankDocModel() {\n+\t\tgroups = new ArrayList<>();\n+\t}\n+\n+\tpublic FrankElement findOrCreateFrankElement(Class<?> clazz) {\n+\t\tif(allElements.containsKey(clazz.getName())) {\n+\t\t\treturn allElements.get(clazz.getName());\n+\t\t}\n+\t\tClass<?> superClass = clazz.getSuperclass();\n+\t\tFrankElement parent = superClass == null ? null : findOrCreateFrankElement(superClass);\n+\t\tFrankElement current = new FrankElement(clazz, parent);\n+\t\tcurrent.setAttributes(createAttributes(clazz.getDeclaredMethods(), current));\n+\t\tallElements.put(current.getFullName(), current);\n+\t\treturn current;\n+\t}\n+\n+\tList<FrankAttribute> createAttributes(Method[] methods, FrankElement attributeOwner) {", "originalCommit": "491491975a96054bd4513b4429f1a3309409534f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzgwMzg5Ng==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r503803896", "bodyText": "Op een gegeven moment willen we deze code compile-time draaien. We zullen dan geen Spring hebben. In plaats van Class<?> en Method objecten zullen we objecten uit de Doclet API hebben om de documentatie uit te genereren, zie https://docs.oracle.com/javase/8/docs/jdk/api/javadoc/doclet/index.html. Daarom lijkt het me beter om deze code te houden in plaats van dat we meer Spring te introduceren.", "author": "mhdirkse", "createdAt": "2020-10-13T09:28:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzc1NjU0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzgzMjg1NA==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r503832854", "bodyText": "Ik snap je punt! Java heeft ook een dergelijke methode Introspector#getBeanInfo(Class<?>\u00a0beanClass) waarna je getPropertyDescriptors() kan doen op het object dat de introspector teruggeeft.", "author": "nielsm5", "createdAt": "2020-10-13T10:13:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzc1NjU0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzg5Njc3OA==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r503896778", "bodyText": "Die method gebruikt weliswaar geen Spring, maar heeft wel een Class<?> nodig. Als we de complexe code je hier ziet vervangen door het gebruik van Introspector, dan kunnen we straks niet gemakkelijk toe naar compile-time documentatie. Introspector kan geen ClassDoc accepteren. De method die ik nu heb gemaakt kunnen we wel simpel omzetten naarList<FrankAttribute> createAttributes(MethodDoc[] methods, FrankElement attributeOwner). Ik heb nog even gezocht naar een Doclet API equivalent van Introspector, maar dat heb ik niet gevonden.", "author": "mhdirkse", "createdAt": "2020-10-13T12:07:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzc1NjU0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzc1ODQ0MA==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r503758440", "bodyText": "Kan je deze twee (lege) @param weghalen?", "author": "nielsm5", "createdAt": "2020-10-13T08:21:04Z", "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankElement.java", "diffHunk": "@@ -0,0 +1,30 @@\n+package nl.nn.adapterframework.doc.model;\n+\n+import java.util.List;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+\n+public class FrankElement {\n+\tprivate final @Getter String fullName;\n+\tprivate final @Getter String simpleName;\n+\tprivate @Getter FrankElement parent;\n+\tprivate @Getter @Setter List<FrankAttribute> attributes;\n+\n+\tFrankElement(Class<?> clazz, FrankElement parent) {\n+\t\tthis(clazz.getName(), clazz.getSimpleName());\n+\t\tthis.parent = parent;\n+\t}\n+\n+\t/**\n+\t * Constructor for testing purposes. We want to test attribute construction in isolation,\n+\t * in which case we do not have a parent.\n+\t *\n+\t * @param fullName\n+\t * @param simpleName", "originalCommit": "491491975a96054bd4513b4429f1a3309409534f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzgxNjYxNg==", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r503816616", "bodyText": "Gedaan.", "author": "mhdirkse", "createdAt": "2020-10-13T09:47:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzc1ODQ0MA=="}], "type": "inlineReview"}, {"oid": "8369bff4c3c3c39d08fd89c7b7da31bf0751d75b", "url": "https://github.com/ibissource/iaf/commit/8369bff4c3c3c39d08fd89c7b7da31bf0751d75b", "message": "Remove unnecessary @param tags found by Niels", "committedDate": "2020-10-13T09:46:21Z", "type": "commit"}]}