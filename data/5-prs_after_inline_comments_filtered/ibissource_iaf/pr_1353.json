{"pr_number": 1353, "pr_title": "Impl #1302 ability to sign xml messages", "pr_createdAt": "2020-12-22T14:06:55Z", "pr_url": "https://github.com/ibissource/iaf/pull/1353", "timeline": [{"oid": "b01ad06a3109d805c6e49a3e1f2a416549ddc093", "url": "https://github.com/ibissource/iaf/commit/b01ad06a3109d805c6e49a3e1f2a416549ddc093", "message": "Cleanup SSL context factories", "committedDate": "2020-12-21T13:37:42Z", "type": "commit"}, {"oid": "06d7fdf231237d7f8453f8ca845b888e27bf8b7b", "url": "https://github.com/ibissource/iaf/commit/06d7fdf231237d7f8453f8ca845b888e27bf8b7b", "message": "Add PkiUtil", "committedDate": "2020-12-21T13:38:17Z", "type": "commit"}, {"oid": "ba493d9ea9695ac3f35066e574441236c5fa9d29", "url": "https://github.com/ibissource/iaf/commit/ba493d9ea9695ac3f35066e574441236c5fa9d29", "message": "Further simplify SSLContext handling", "committedDate": "2020-12-21T14:51:44Z", "type": "commit"}, {"oid": "af2caccc339ed4b138e8258410086d537e73d4c7", "url": "https://github.com/ibissource/iaf/commit/af2caccc339ed4b138e8258410086d537e73d4c7", "message": "Add SignaturePipeTest and cleanup other pipe tests", "committedDate": "2020-12-22T14:06:17Z", "type": "commit"}, {"oid": "1bfc4fa23d585697809c54f6db2e89489b66056b", "url": "https://github.com/ibissource/iaf/commit/1bfc4fa23d585697809c54f6db2e89489b66056b", "message": "Introduce ITransactionAttributes and fix Validator marker interface", "committedDate": "2020-12-22T14:22:33Z", "type": "commit"}, {"oid": "cdf9006dea32be9712915f138d1506b4a4f44066", "url": "https://github.com/ibissource/iaf/commit/cdf9006dea32be9712915f138d1506b4a4f44066", "message": "Fix issues", "committedDate": "2020-12-22T14:37:40Z", "type": "commit"}, {"oid": "d061e12a0903ca00511d5a3ab5de013ac07e492c", "url": "https://github.com/ibissource/iaf/commit/d061e12a0903ca00511d5a3ab5de013ac07e492c", "message": "Fix issues", "committedDate": "2020-12-22T14:48:38Z", "type": "commit"}, {"oid": "83400484474d11a088ae3a5988585142280e5697", "url": "https://github.com/ibissource/iaf/commit/83400484474d11a088ae3a5988585142280e5697", "message": "Fix test", "committedDate": "2020-12-22T15:25:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM2OTg1Mw==", "url": "https://github.com/ibissource/iaf/pull/1353#discussion_r547369853", "bodyText": "Debug is genoeg..", "author": "nielsm5", "createdAt": "2020-12-22T16:19:31Z", "path": "core/src/main/java/nl/nn/adapterframework/pipes/SignaturePipe.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/*\n+   Copyright 2020 WeAreFrank!\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+package nl.nn.adapterframework.pipes;\n+\n+import java.io.BufferedInputStream;\n+import java.io.IOException;\n+import java.net.URL;\n+import java.security.InvalidKeyException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.NoSuchProviderException;\n+import java.security.PrivateKey;\n+import java.security.PublicKey;\n+import java.security.Signature;\n+import java.security.SignatureException;\n+import java.security.UnrecoverableKeyException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.Arrays;\n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+\n+import javax.net.ssl.KeyManager;\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.X509KeyManager;\n+import javax.net.ssl.X509TrustManager;\n+\n+import org.apache.commons.codec.binary.Base64;\n+import org.apache.commons.lang.StringUtils;\n+\n+import lombok.Getter;\n+import nl.nn.adapterframework.configuration.ConfigurationException;\n+import nl.nn.adapterframework.core.IPipeLineSession;\n+import nl.nn.adapterframework.core.ParameterException;\n+import nl.nn.adapterframework.core.PipeForward;\n+import nl.nn.adapterframework.core.PipeRunException;\n+import nl.nn.adapterframework.core.PipeRunResult;\n+import nl.nn.adapterframework.core.PipeStartException;\n+import nl.nn.adapterframework.doc.IbisDoc;\n+import nl.nn.adapterframework.parameters.ParameterValueList;\n+import nl.nn.adapterframework.stream.Message;\n+import nl.nn.adapterframework.util.ClassUtils;\n+import nl.nn.adapterframework.util.PkiUtil;\n+\n+public class SignaturePipe extends FixedForwardPipe {\n+\n+\tpublic final String ACTION_SIGN=\"sign\";\n+\tpublic final String ACTION_VERIFY=\"verify\";\n+\tpublic final String PARAMETER_SIGNATURE=\"signature\";\n+\t\n+\tpublic final String ALGORITHM_DEFAULT = \"SHA256withRSA\";\n+\n+\tpublic final String[] ACTIONS= {ACTION_SIGN, ACTION_VERIFY};\n+\tprivate Set<String> actions = new LinkedHashSet<String>(Arrays.asList(ACTIONS));\n+\n+\t/**\n+\t * Action to be taken by pipe.\n+\t * Available Actions:\n+\t * <ul>\n+\t *     <li>Sign: signs the given input</li>\n+\t *     <li>Verify: verifies the given input</li>\n+\t * </ul>\n+\t */\n+\tprivate @Getter String action = ACTION_SIGN;\n+\tprivate @Getter String algorithm;\n+\tprivate @Getter String provider;\n+\tprivate @Getter boolean signatureBase64 = true;\n+\n+\tprivate @Getter String keystore;\n+\tprivate @Getter String keystoreType=\"pkcs12\";\n+\tprivate @Getter String keystoreAlias;\n+\tprivate @Getter String keystoreAuthAlias;\n+\tprivate @Getter String keystorePassword;\n+\tprivate @Getter String keyManagerAlgorithm=null;\n+\n+\tprivate URL keystoreUrl = null;\n+\tprivate PrivateKey privateKey;\n+\tprivate PublicKey publicKey;\n+\tprivate PipeForward failureForward; // forward used when verification fails\n+\t\n+\t@Override\n+\tpublic void configure() throws ConfigurationException {\n+\t\tsuper.configure();\n+\t\tif (!actions.contains(getAction())) {\n+\t\t\tthrow new ConfigurationException(\"unknown or invalid action [\" + action + \"] supported actions are \" + actions.toString() + \"\");\n+\t\t}\n+\t\tif (StringUtils.isEmpty(getAlgorithm())) {\n+\t\t\tsetAlgorithm(ALGORITHM_DEFAULT);\n+\t\t}\n+\t\tif (StringUtils.isEmpty(getKeystore())) {\n+\t\t\tthrow new ConfigurationException(\"keystore must be specified\");\n+\t\t}\n+\t\tkeystoreUrl = ClassUtils.getResourceURL(getConfigurationClassLoader(), getKeystore());\n+\t\tif (keystoreUrl == null) {\n+\t\t\tthrow new ConfigurationException(\"cannot find URL for keystore resource [\"+getKeystore()+\"]\");\n+\t\t}\n+\t\tlog.info(\"resolved keystore-URL to [\"+keystoreUrl.toString()+\"]\");", "originalCommit": "83400484474d11a088ae3a5988585142280e5697", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM3MDQ3MA==", "url": "https://github.com/ibissource/iaf/pull/1353#discussion_r547370470", "bodyText": "No keymanager found (met keystore url er bij)", "author": "nielsm5", "createdAt": "2020-12-22T16:20:44Z", "path": "core/src/main/java/nl/nn/adapterframework/pipes/SignaturePipe.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/*\n+   Copyright 2020 WeAreFrank!\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+package nl.nn.adapterframework.pipes;\n+\n+import java.io.BufferedInputStream;\n+import java.io.IOException;\n+import java.net.URL;\n+import java.security.InvalidKeyException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.NoSuchProviderException;\n+import java.security.PrivateKey;\n+import java.security.PublicKey;\n+import java.security.Signature;\n+import java.security.SignatureException;\n+import java.security.UnrecoverableKeyException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.Arrays;\n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+\n+import javax.net.ssl.KeyManager;\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.X509KeyManager;\n+import javax.net.ssl.X509TrustManager;\n+\n+import org.apache.commons.codec.binary.Base64;\n+import org.apache.commons.lang.StringUtils;\n+\n+import lombok.Getter;\n+import nl.nn.adapterframework.configuration.ConfigurationException;\n+import nl.nn.adapterframework.core.IPipeLineSession;\n+import nl.nn.adapterframework.core.ParameterException;\n+import nl.nn.adapterframework.core.PipeForward;\n+import nl.nn.adapterframework.core.PipeRunException;\n+import nl.nn.adapterframework.core.PipeRunResult;\n+import nl.nn.adapterframework.core.PipeStartException;\n+import nl.nn.adapterframework.doc.IbisDoc;\n+import nl.nn.adapterframework.parameters.ParameterValueList;\n+import nl.nn.adapterframework.stream.Message;\n+import nl.nn.adapterframework.util.ClassUtils;\n+import nl.nn.adapterframework.util.PkiUtil;\n+\n+public class SignaturePipe extends FixedForwardPipe {\n+\n+\tpublic final String ACTION_SIGN=\"sign\";\n+\tpublic final String ACTION_VERIFY=\"verify\";\n+\tpublic final String PARAMETER_SIGNATURE=\"signature\";\n+\t\n+\tpublic final String ALGORITHM_DEFAULT = \"SHA256withRSA\";\n+\n+\tpublic final String[] ACTIONS= {ACTION_SIGN, ACTION_VERIFY};\n+\tprivate Set<String> actions = new LinkedHashSet<String>(Arrays.asList(ACTIONS));\n+\n+\t/**\n+\t * Action to be taken by pipe.\n+\t * Available Actions:\n+\t * <ul>\n+\t *     <li>Sign: signs the given input</li>\n+\t *     <li>Verify: verifies the given input</li>\n+\t * </ul>\n+\t */\n+\tprivate @Getter String action = ACTION_SIGN;\n+\tprivate @Getter String algorithm;\n+\tprivate @Getter String provider;\n+\tprivate @Getter boolean signatureBase64 = true;\n+\n+\tprivate @Getter String keystore;\n+\tprivate @Getter String keystoreType=\"pkcs12\";\n+\tprivate @Getter String keystoreAlias;\n+\tprivate @Getter String keystoreAuthAlias;\n+\tprivate @Getter String keystorePassword;\n+\tprivate @Getter String keyManagerAlgorithm=null;\n+\n+\tprivate URL keystoreUrl = null;\n+\tprivate PrivateKey privateKey;\n+\tprivate PublicKey publicKey;\n+\tprivate PipeForward failureForward; // forward used when verification fails\n+\t\n+\t@Override\n+\tpublic void configure() throws ConfigurationException {\n+\t\tsuper.configure();\n+\t\tif (!actions.contains(getAction())) {\n+\t\t\tthrow new ConfigurationException(\"unknown or invalid action [\" + action + \"] supported actions are \" + actions.toString() + \"\");\n+\t\t}\n+\t\tif (StringUtils.isEmpty(getAlgorithm())) {\n+\t\t\tsetAlgorithm(ALGORITHM_DEFAULT);\n+\t\t}\n+\t\tif (StringUtils.isEmpty(getKeystore())) {\n+\t\t\tthrow new ConfigurationException(\"keystore must be specified\");\n+\t\t}\n+\t\tkeystoreUrl = ClassUtils.getResourceURL(getConfigurationClassLoader(), getKeystore());\n+\t\tif (keystoreUrl == null) {\n+\t\t\tthrow new ConfigurationException(\"cannot find URL for keystore resource [\"+getKeystore()+\"]\");\n+\t\t}\n+\t\tlog.info(\"resolved keystore-URL to [\"+keystoreUrl.toString()+\"]\");\n+\t\tif (getAction().equals(ACTION_VERIFY)) {\n+\t\t\tif (getParameterList().findParameter(PARAMETER_SIGNATURE)==null) {\n+\t\t\t\tthrow new ConfigurationException(\"Parameter [\" + PARAMETER_SIGNATURE + \"] must be specfied for action [\" + action + \"]\");\n+\t\t\t}\n+\t\t\tfailureForward = findForward(\"failure\");\n+\t\t\tif (failureForward==null)  {\n+\t\t\t\tthrow new ConfigurationException(\"Forward [failure] must be specfied for action [\" + action + \"]\");\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void start() throws PipeStartException {\n+\t\tsuper.start();\n+\t\ttry {\n+\t\t\tif (getAction().equals(ACTION_SIGN)) {\n+\t\t\t\tif (\"pem\".equals(getKeystoreType())) {\n+\t\t\t\t\tprivateKey = PkiUtil.getPrivateKeyFromPem(keystoreUrl);\n+\t\t\t\t} else {\n+\t\t\t\t\tKeyStore keystore = PkiUtil.createKeyStore(keystoreUrl, keystorePassword, keystoreType, \"Keys for action [\"+getAction()+\"]\");\n+\t\t\t\t\tKeyManager[] keymanagers = PkiUtil.createKeyManagers(keystore, keystorePassword, keyManagerAlgorithm);\n+\t\t\t\t\tif (keymanagers==null || keymanagers.length==0) {\n+\t\t\t\t\t\tthrow new PipeStartException(\"No keymanager\");", "originalCommit": "83400484474d11a088ae3a5988585142280e5697", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM3MDgyNA==", "url": "https://github.com/ibissource/iaf/pull/1353#discussion_r547370824", "bodyText": "hier ook", "author": "nielsm5", "createdAt": "2020-12-22T16:21:23Z", "path": "core/src/main/java/nl/nn/adapterframework/pipes/SignaturePipe.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/*\n+   Copyright 2020 WeAreFrank!\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+package nl.nn.adapterframework.pipes;\n+\n+import java.io.BufferedInputStream;\n+import java.io.IOException;\n+import java.net.URL;\n+import java.security.InvalidKeyException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.NoSuchProviderException;\n+import java.security.PrivateKey;\n+import java.security.PublicKey;\n+import java.security.Signature;\n+import java.security.SignatureException;\n+import java.security.UnrecoverableKeyException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.Arrays;\n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+\n+import javax.net.ssl.KeyManager;\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.X509KeyManager;\n+import javax.net.ssl.X509TrustManager;\n+\n+import org.apache.commons.codec.binary.Base64;\n+import org.apache.commons.lang.StringUtils;\n+\n+import lombok.Getter;\n+import nl.nn.adapterframework.configuration.ConfigurationException;\n+import nl.nn.adapterframework.core.IPipeLineSession;\n+import nl.nn.adapterframework.core.ParameterException;\n+import nl.nn.adapterframework.core.PipeForward;\n+import nl.nn.adapterframework.core.PipeRunException;\n+import nl.nn.adapterframework.core.PipeRunResult;\n+import nl.nn.adapterframework.core.PipeStartException;\n+import nl.nn.adapterframework.doc.IbisDoc;\n+import nl.nn.adapterframework.parameters.ParameterValueList;\n+import nl.nn.adapterframework.stream.Message;\n+import nl.nn.adapterframework.util.ClassUtils;\n+import nl.nn.adapterframework.util.PkiUtil;\n+\n+public class SignaturePipe extends FixedForwardPipe {\n+\n+\tpublic final String ACTION_SIGN=\"sign\";\n+\tpublic final String ACTION_VERIFY=\"verify\";\n+\tpublic final String PARAMETER_SIGNATURE=\"signature\";\n+\t\n+\tpublic final String ALGORITHM_DEFAULT = \"SHA256withRSA\";\n+\n+\tpublic final String[] ACTIONS= {ACTION_SIGN, ACTION_VERIFY};\n+\tprivate Set<String> actions = new LinkedHashSet<String>(Arrays.asList(ACTIONS));\n+\n+\t/**\n+\t * Action to be taken by pipe.\n+\t * Available Actions:\n+\t * <ul>\n+\t *     <li>Sign: signs the given input</li>\n+\t *     <li>Verify: verifies the given input</li>\n+\t * </ul>\n+\t */\n+\tprivate @Getter String action = ACTION_SIGN;\n+\tprivate @Getter String algorithm;\n+\tprivate @Getter String provider;\n+\tprivate @Getter boolean signatureBase64 = true;\n+\n+\tprivate @Getter String keystore;\n+\tprivate @Getter String keystoreType=\"pkcs12\";\n+\tprivate @Getter String keystoreAlias;\n+\tprivate @Getter String keystoreAuthAlias;\n+\tprivate @Getter String keystorePassword;\n+\tprivate @Getter String keyManagerAlgorithm=null;\n+\n+\tprivate URL keystoreUrl = null;\n+\tprivate PrivateKey privateKey;\n+\tprivate PublicKey publicKey;\n+\tprivate PipeForward failureForward; // forward used when verification fails\n+\t\n+\t@Override\n+\tpublic void configure() throws ConfigurationException {\n+\t\tsuper.configure();\n+\t\tif (!actions.contains(getAction())) {\n+\t\t\tthrow new ConfigurationException(\"unknown or invalid action [\" + action + \"] supported actions are \" + actions.toString() + \"\");\n+\t\t}\n+\t\tif (StringUtils.isEmpty(getAlgorithm())) {\n+\t\t\tsetAlgorithm(ALGORITHM_DEFAULT);\n+\t\t}\n+\t\tif (StringUtils.isEmpty(getKeystore())) {\n+\t\t\tthrow new ConfigurationException(\"keystore must be specified\");\n+\t\t}\n+\t\tkeystoreUrl = ClassUtils.getResourceURL(getConfigurationClassLoader(), getKeystore());\n+\t\tif (keystoreUrl == null) {\n+\t\t\tthrow new ConfigurationException(\"cannot find URL for keystore resource [\"+getKeystore()+\"]\");\n+\t\t}\n+\t\tlog.info(\"resolved keystore-URL to [\"+keystoreUrl.toString()+\"]\");\n+\t\tif (getAction().equals(ACTION_VERIFY)) {\n+\t\t\tif (getParameterList().findParameter(PARAMETER_SIGNATURE)==null) {\n+\t\t\t\tthrow new ConfigurationException(\"Parameter [\" + PARAMETER_SIGNATURE + \"] must be specfied for action [\" + action + \"]\");\n+\t\t\t}\n+\t\t\tfailureForward = findForward(\"failure\");\n+\t\t\tif (failureForward==null)  {\n+\t\t\t\tthrow new ConfigurationException(\"Forward [failure] must be specfied for action [\" + action + \"]\");\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void start() throws PipeStartException {\n+\t\tsuper.start();\n+\t\ttry {\n+\t\t\tif (getAction().equals(ACTION_SIGN)) {\n+\t\t\t\tif (\"pem\".equals(getKeystoreType())) {\n+\t\t\t\t\tprivateKey = PkiUtil.getPrivateKeyFromPem(keystoreUrl);\n+\t\t\t\t} else {\n+\t\t\t\t\tKeyStore keystore = PkiUtil.createKeyStore(keystoreUrl, keystorePassword, keystoreType, \"Keys for action [\"+getAction()+\"]\");\n+\t\t\t\t\tKeyManager[] keymanagers = PkiUtil.createKeyManagers(keystore, keystorePassword, keyManagerAlgorithm);\n+\t\t\t\t\tif (keymanagers==null || keymanagers.length==0) {\n+\t\t\t\t\t\tthrow new PipeStartException(\"No keymanager\");\n+\t\t\t\t\t}\n+\t\t\t\t\tX509KeyManager keyManager = (X509KeyManager)keymanagers[0];\n+\t\t\t\t\tprivateKey = keyManager.getPrivateKey(getKeystoreAlias());\n+\t\t\t\t}\n+\t\t\t\tif (privateKey==null) {\n+\t\t\t\t\tthrow new PipeStartException(\"No Signing Key found in alias [\"+getKeystoreAlias()+\"]\");\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tCertificate certificate;\n+\t\t\t\tif (\"pem\".equals(getKeystoreType())) {\n+\t\t\t\t\tcertificate = PkiUtil.getCertificateFromPem(keystoreUrl);\n+\t\t\t\t} else {\n+\t\t\t\t\tKeyStore keystore = PkiUtil.createKeyStore(keystoreUrl, keystorePassword, keystoreType, \"Keys for action [\"+getAction()+\"]\");\n+\t\t\t\t\tTrustManager[] trustmanagers = PkiUtil.createTrustManagers(keystore, keyManagerAlgorithm);\n+\t\t\t\t\tif (trustmanagers==null || trustmanagers.length==0) {\n+\t\t\t\t\t\tthrow new PipeStartException(\"No trustmanager\");", "originalCommit": "83400484474d11a088ae3a5988585142280e5697", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM3MTExOA==", "url": "https://github.com/ibissource/iaf/pull/1353#discussion_r547371118", "bodyText": "private of public key?", "author": "nielsm5", "createdAt": "2020-12-22T16:22:00Z", "path": "core/src/main/java/nl/nn/adapterframework/pipes/SignaturePipe.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/*\n+   Copyright 2020 WeAreFrank!\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+package nl.nn.adapterframework.pipes;\n+\n+import java.io.BufferedInputStream;\n+import java.io.IOException;\n+import java.net.URL;\n+import java.security.InvalidKeyException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.NoSuchProviderException;\n+import java.security.PrivateKey;\n+import java.security.PublicKey;\n+import java.security.Signature;\n+import java.security.SignatureException;\n+import java.security.UnrecoverableKeyException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.Arrays;\n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+\n+import javax.net.ssl.KeyManager;\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.X509KeyManager;\n+import javax.net.ssl.X509TrustManager;\n+\n+import org.apache.commons.codec.binary.Base64;\n+import org.apache.commons.lang.StringUtils;\n+\n+import lombok.Getter;\n+import nl.nn.adapterframework.configuration.ConfigurationException;\n+import nl.nn.adapterframework.core.IPipeLineSession;\n+import nl.nn.adapterframework.core.ParameterException;\n+import nl.nn.adapterframework.core.PipeForward;\n+import nl.nn.adapterframework.core.PipeRunException;\n+import nl.nn.adapterframework.core.PipeRunResult;\n+import nl.nn.adapterframework.core.PipeStartException;\n+import nl.nn.adapterframework.doc.IbisDoc;\n+import nl.nn.adapterframework.parameters.ParameterValueList;\n+import nl.nn.adapterframework.stream.Message;\n+import nl.nn.adapterframework.util.ClassUtils;\n+import nl.nn.adapterframework.util.PkiUtil;\n+\n+public class SignaturePipe extends FixedForwardPipe {\n+\n+\tpublic final String ACTION_SIGN=\"sign\";\n+\tpublic final String ACTION_VERIFY=\"verify\";\n+\tpublic final String PARAMETER_SIGNATURE=\"signature\";\n+\t\n+\tpublic final String ALGORITHM_DEFAULT = \"SHA256withRSA\";\n+\n+\tpublic final String[] ACTIONS= {ACTION_SIGN, ACTION_VERIFY};\n+\tprivate Set<String> actions = new LinkedHashSet<String>(Arrays.asList(ACTIONS));\n+\n+\t/**\n+\t * Action to be taken by pipe.\n+\t * Available Actions:\n+\t * <ul>\n+\t *     <li>Sign: signs the given input</li>\n+\t *     <li>Verify: verifies the given input</li>\n+\t * </ul>\n+\t */\n+\tprivate @Getter String action = ACTION_SIGN;\n+\tprivate @Getter String algorithm;\n+\tprivate @Getter String provider;\n+\tprivate @Getter boolean signatureBase64 = true;\n+\n+\tprivate @Getter String keystore;\n+\tprivate @Getter String keystoreType=\"pkcs12\";\n+\tprivate @Getter String keystoreAlias;\n+\tprivate @Getter String keystoreAuthAlias;\n+\tprivate @Getter String keystorePassword;\n+\tprivate @Getter String keyManagerAlgorithm=null;\n+\n+\tprivate URL keystoreUrl = null;\n+\tprivate PrivateKey privateKey;\n+\tprivate PublicKey publicKey;\n+\tprivate PipeForward failureForward; // forward used when verification fails\n+\t\n+\t@Override\n+\tpublic void configure() throws ConfigurationException {\n+\t\tsuper.configure();\n+\t\tif (!actions.contains(getAction())) {\n+\t\t\tthrow new ConfigurationException(\"unknown or invalid action [\" + action + \"] supported actions are \" + actions.toString() + \"\");\n+\t\t}\n+\t\tif (StringUtils.isEmpty(getAlgorithm())) {\n+\t\t\tsetAlgorithm(ALGORITHM_DEFAULT);\n+\t\t}\n+\t\tif (StringUtils.isEmpty(getKeystore())) {\n+\t\t\tthrow new ConfigurationException(\"keystore must be specified\");\n+\t\t}\n+\t\tkeystoreUrl = ClassUtils.getResourceURL(getConfigurationClassLoader(), getKeystore());\n+\t\tif (keystoreUrl == null) {\n+\t\t\tthrow new ConfigurationException(\"cannot find URL for keystore resource [\"+getKeystore()+\"]\");\n+\t\t}\n+\t\tlog.info(\"resolved keystore-URL to [\"+keystoreUrl.toString()+\"]\");\n+\t\tif (getAction().equals(ACTION_VERIFY)) {\n+\t\t\tif (getParameterList().findParameter(PARAMETER_SIGNATURE)==null) {\n+\t\t\t\tthrow new ConfigurationException(\"Parameter [\" + PARAMETER_SIGNATURE + \"] must be specfied for action [\" + action + \"]\");\n+\t\t\t}\n+\t\t\tfailureForward = findForward(\"failure\");\n+\t\t\tif (failureForward==null)  {\n+\t\t\t\tthrow new ConfigurationException(\"Forward [failure] must be specfied for action [\" + action + \"]\");\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void start() throws PipeStartException {\n+\t\tsuper.start();\n+\t\ttry {\n+\t\t\tif (getAction().equals(ACTION_SIGN)) {\n+\t\t\t\tif (\"pem\".equals(getKeystoreType())) {\n+\t\t\t\t\tprivateKey = PkiUtil.getPrivateKeyFromPem(keystoreUrl);\n+\t\t\t\t} else {\n+\t\t\t\t\tKeyStore keystore = PkiUtil.createKeyStore(keystoreUrl, keystorePassword, keystoreType, \"Keys for action [\"+getAction()+\"]\");\n+\t\t\t\t\tKeyManager[] keymanagers = PkiUtil.createKeyManagers(keystore, keystorePassword, keyManagerAlgorithm);\n+\t\t\t\t\tif (keymanagers==null || keymanagers.length==0) {\n+\t\t\t\t\t\tthrow new PipeStartException(\"No keymanager\");\n+\t\t\t\t\t}\n+\t\t\t\t\tX509KeyManager keyManager = (X509KeyManager)keymanagers[0];\n+\t\t\t\t\tprivateKey = keyManager.getPrivateKey(getKeystoreAlias());\n+\t\t\t\t}\n+\t\t\t\tif (privateKey==null) {\n+\t\t\t\t\tthrow new PipeStartException(\"No Signing Key found in alias [\"+getKeystoreAlias()+\"]\");\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tCertificate certificate;\n+\t\t\t\tif (\"pem\".equals(getKeystoreType())) {\n+\t\t\t\t\tcertificate = PkiUtil.getCertificateFromPem(keystoreUrl);\n+\t\t\t\t} else {\n+\t\t\t\t\tKeyStore keystore = PkiUtil.createKeyStore(keystoreUrl, keystorePassword, keystoreType, \"Keys for action [\"+getAction()+\"]\");\n+\t\t\t\t\tTrustManager[] trustmanagers = PkiUtil.createTrustManagers(keystore, keyManagerAlgorithm);\n+\t\t\t\t\tif (trustmanagers==null || trustmanagers.length==0) {\n+\t\t\t\t\t\tthrow new PipeStartException(\"No trustmanager\");\n+\t\t\t\t\t}\n+\t\t\t\t\tX509TrustManager trustManager = (X509TrustManager)trustmanagers[0];\n+\t\t\t\t\tX509Certificate[] certificates = trustManager.getAcceptedIssuers();\n+\t\t\t\t\tif (certificates==null || certificates.length==0) {\n+\t\t\t\t\t\tthrow new PipeStartException(\"No Verfication Key found in alias [\"+getKeystoreAlias()+\"]\");\n+\t\t\t\t\t}\n+\t\t\t\t\tcertificate = certificates[0];\n+\t\t\t\t}\n+\t\t\t\tpublicKey = certificate.getPublicKey();\n+\t\t\t}\n+\t\t} catch (KeyStoreException | NoSuchAlgorithmException | CertificateException | IOException | UnrecoverableKeyException | InvalidKeySpecException e) {\n+\t\t\tthrow new PipeStartException(\"cannot get key for action [\"+getAction()+\"]\", e);", "originalCommit": "83400484474d11a088ae3a5988585142280e5697", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM3MzQ5OA==", "url": "https://github.com/ibissource/iaf/pull/1353#discussion_r547373498", "bodyText": "Kan je deze isSignatureBase64() ook zetten?", "author": "nielsm5", "createdAt": "2020-12-22T16:26:09Z", "path": "core/src/main/java/nl/nn/adapterframework/pipes/SignaturePipe.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/*\n+   Copyright 2020 WeAreFrank!\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+package nl.nn.adapterframework.pipes;\n+\n+import java.io.BufferedInputStream;\n+import java.io.IOException;\n+import java.net.URL;\n+import java.security.InvalidKeyException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.NoSuchProviderException;\n+import java.security.PrivateKey;\n+import java.security.PublicKey;\n+import java.security.Signature;\n+import java.security.SignatureException;\n+import java.security.UnrecoverableKeyException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.Arrays;\n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+\n+import javax.net.ssl.KeyManager;\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.X509KeyManager;\n+import javax.net.ssl.X509TrustManager;\n+\n+import org.apache.commons.codec.binary.Base64;\n+import org.apache.commons.lang.StringUtils;\n+\n+import lombok.Getter;\n+import nl.nn.adapterframework.configuration.ConfigurationException;\n+import nl.nn.adapterframework.core.IPipeLineSession;\n+import nl.nn.adapterframework.core.ParameterException;\n+import nl.nn.adapterframework.core.PipeForward;\n+import nl.nn.adapterframework.core.PipeRunException;\n+import nl.nn.adapterframework.core.PipeRunResult;\n+import nl.nn.adapterframework.core.PipeStartException;\n+import nl.nn.adapterframework.doc.IbisDoc;\n+import nl.nn.adapterframework.parameters.ParameterValueList;\n+import nl.nn.adapterframework.stream.Message;\n+import nl.nn.adapterframework.util.ClassUtils;\n+import nl.nn.adapterframework.util.PkiUtil;\n+\n+public class SignaturePipe extends FixedForwardPipe {\n+\n+\tpublic final String ACTION_SIGN=\"sign\";\n+\tpublic final String ACTION_VERIFY=\"verify\";\n+\tpublic final String PARAMETER_SIGNATURE=\"signature\";\n+\t\n+\tpublic final String ALGORITHM_DEFAULT = \"SHA256withRSA\";\n+\n+\tpublic final String[] ACTIONS= {ACTION_SIGN, ACTION_VERIFY};\n+\tprivate Set<String> actions = new LinkedHashSet<String>(Arrays.asList(ACTIONS));\n+\n+\t/**\n+\t * Action to be taken by pipe.\n+\t * Available Actions:\n+\t * <ul>\n+\t *     <li>Sign: signs the given input</li>\n+\t *     <li>Verify: verifies the given input</li>\n+\t * </ul>\n+\t */\n+\tprivate @Getter String action = ACTION_SIGN;\n+\tprivate @Getter String algorithm;\n+\tprivate @Getter String provider;\n+\tprivate @Getter boolean signatureBase64 = true;\n+\n+\tprivate @Getter String keystore;\n+\tprivate @Getter String keystoreType=\"pkcs12\";\n+\tprivate @Getter String keystoreAlias;\n+\tprivate @Getter String keystoreAuthAlias;\n+\tprivate @Getter String keystorePassword;\n+\tprivate @Getter String keyManagerAlgorithm=null;\n+\n+\tprivate URL keystoreUrl = null;\n+\tprivate PrivateKey privateKey;\n+\tprivate PublicKey publicKey;\n+\tprivate PipeForward failureForward; // forward used when verification fails\n+\t\n+\t@Override\n+\tpublic void configure() throws ConfigurationException {\n+\t\tsuper.configure();\n+\t\tif (!actions.contains(getAction())) {\n+\t\t\tthrow new ConfigurationException(\"unknown or invalid action [\" + action + \"] supported actions are \" + actions.toString() + \"\");\n+\t\t}\n+\t\tif (StringUtils.isEmpty(getAlgorithm())) {\n+\t\t\tsetAlgorithm(ALGORITHM_DEFAULT);\n+\t\t}\n+\t\tif (StringUtils.isEmpty(getKeystore())) {\n+\t\t\tthrow new ConfigurationException(\"keystore must be specified\");\n+\t\t}\n+\t\tkeystoreUrl = ClassUtils.getResourceURL(getConfigurationClassLoader(), getKeystore());\n+\t\tif (keystoreUrl == null) {\n+\t\t\tthrow new ConfigurationException(\"cannot find URL for keystore resource [\"+getKeystore()+\"]\");\n+\t\t}\n+\t\tlog.info(\"resolved keystore-URL to [\"+keystoreUrl.toString()+\"]\");\n+\t\tif (getAction().equals(ACTION_VERIFY)) {\n+\t\t\tif (getParameterList().findParameter(PARAMETER_SIGNATURE)==null) {\n+\t\t\t\tthrow new ConfigurationException(\"Parameter [\" + PARAMETER_SIGNATURE + \"] must be specfied for action [\" + action + \"]\");\n+\t\t\t}\n+\t\t\tfailureForward = findForward(\"failure\");\n+\t\t\tif (failureForward==null)  {\n+\t\t\t\tthrow new ConfigurationException(\"Forward [failure] must be specfied for action [\" + action + \"]\");\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void start() throws PipeStartException {\n+\t\tsuper.start();\n+\t\ttry {\n+\t\t\tif (getAction().equals(ACTION_SIGN)) {\n+\t\t\t\tif (\"pem\".equals(getKeystoreType())) {\n+\t\t\t\t\tprivateKey = PkiUtil.getPrivateKeyFromPem(keystoreUrl);\n+\t\t\t\t} else {\n+\t\t\t\t\tKeyStore keystore = PkiUtil.createKeyStore(keystoreUrl, keystorePassword, keystoreType, \"Keys for action [\"+getAction()+\"]\");\n+\t\t\t\t\tKeyManager[] keymanagers = PkiUtil.createKeyManagers(keystore, keystorePassword, keyManagerAlgorithm);\n+\t\t\t\t\tif (keymanagers==null || keymanagers.length==0) {\n+\t\t\t\t\t\tthrow new PipeStartException(\"No keymanager\");\n+\t\t\t\t\t}\n+\t\t\t\t\tX509KeyManager keyManager = (X509KeyManager)keymanagers[0];\n+\t\t\t\t\tprivateKey = keyManager.getPrivateKey(getKeystoreAlias());\n+\t\t\t\t}\n+\t\t\t\tif (privateKey==null) {\n+\t\t\t\t\tthrow new PipeStartException(\"No Signing Key found in alias [\"+getKeystoreAlias()+\"]\");\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tCertificate certificate;\n+\t\t\t\tif (\"pem\".equals(getKeystoreType())) {\n+\t\t\t\t\tcertificate = PkiUtil.getCertificateFromPem(keystoreUrl);\n+\t\t\t\t} else {\n+\t\t\t\t\tKeyStore keystore = PkiUtil.createKeyStore(keystoreUrl, keystorePassword, keystoreType, \"Keys for action [\"+getAction()+\"]\");\n+\t\t\t\t\tTrustManager[] trustmanagers = PkiUtil.createTrustManagers(keystore, keyManagerAlgorithm);\n+\t\t\t\t\tif (trustmanagers==null || trustmanagers.length==0) {\n+\t\t\t\t\t\tthrow new PipeStartException(\"No trustmanager\");\n+\t\t\t\t\t}\n+\t\t\t\t\tX509TrustManager trustManager = (X509TrustManager)trustmanagers[0];\n+\t\t\t\t\tX509Certificate[] certificates = trustManager.getAcceptedIssuers();\n+\t\t\t\t\tif (certificates==null || certificates.length==0) {\n+\t\t\t\t\t\tthrow new PipeStartException(\"No Verfication Key found in alias [\"+getKeystoreAlias()+\"]\");\n+\t\t\t\t\t}\n+\t\t\t\t\tcertificate = certificates[0];\n+\t\t\t\t}\n+\t\t\t\tpublicKey = certificate.getPublicKey();\n+\t\t\t}\n+\t\t} catch (KeyStoreException | NoSuchAlgorithmException | CertificateException | IOException | UnrecoverableKeyException | InvalidKeySpecException e) {\n+\t\t\tthrow new PipeStartException(\"cannot get key for action [\"+getAction()+\"]\", e);\n+\t\t}\n+\t}\n+\n+\n+\t@Override\n+\tpublic PipeRunResult doPipe(Message message, IPipeLineSession session) throws PipeRunException {\n+\t\ttry {\n+\t\t\tSignature dsa = StringUtils.isNotEmpty(getProvider()) ? Signature.getInstance(getAlgorithm(), getProvider()) : Signature.getInstance(getAlgorithm());\n+\t\t\tif (getAction().equals(ACTION_SIGN)) {\n+\t\t\t\tdsa.initSign(privateKey);\n+\t\t\t} else {\n+\t\t\t\tdsa.initVerify(publicKey);\n+\t\t\t\tmessage.preserve();\n+\t\t\t}\n+\t\t\ttry (BufferedInputStream bufin = new BufferedInputStream(message.asInputStream())) {\n+\t\t\t\tbyte[] buffer = new byte[1024];\n+\t\t\t\tint len;\n+\t\t\t\twhile ((len = bufin.read(buffer)) >= 0) {\n+\t\t\t\t\tdsa.update(buffer, 0, len);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif (getAction().equals(ACTION_SIGN)) {\n+\t\t\t\treturn new PipeRunResult(getForward(), isSignatureBase64() ? Base64.encodeBase64(dsa.sign()):dsa.sign());\n+\t\t\t} else {\n+\t\t\t\tParameterValueList pvl = getParameterList().getValues(message, session);\n+\t\t\t\tMessage signatureMsg = Message.asMessage(pvl.getValueMap().get(PARAMETER_SIGNATURE));\n+\t\t\t\tbyte[] signature = isSignatureBase64() ? Base64.decodeBase64(signatureMsg.asString()):signatureMsg.asByteArray();\n+\t\t\t\t", "originalCommit": "83400484474d11a088ae3a5988585142280e5697", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM3NzIzMw==", "url": "https://github.com/ibissource/iaf/pull/1353#discussion_r547377233", "bodyText": ";;", "author": "nielsm5", "createdAt": "2020-12-22T16:33:33Z", "path": "core/src/test/java/nl/nn/adapterframework/pipes/SignaturePipeTest.java", "diffHunk": "@@ -0,0 +1,115 @@\n+package nl.nn.adapterframework.pipes;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+import org.junit.Test;\n+\n+import nl.nn.adapterframework.core.PipeForward;\n+import nl.nn.adapterframework.core.PipeRunResult;\n+import nl.nn.adapterframework.parameters.Parameter;\n+import nl.nn.adapterframework.stream.Message;\n+\n+public class SignaturePipeTest extends PipeTestBase<SignaturePipe> {\n+\n+\tprivate String testMessage = \"xyz\";\n+\tprivate String testSignature = \"JBKjNltZoFlQTsBgstpnIB4itBxzAohRXGpIWuIQh51F64P4WdT+R/55v+cHrPsQ2B49GhROeFUyy7kafOKTfMTjm7DQ5yT/srImFTlZZZbHbvQns2NWBE8DoQKt6SOYowDNIJY5qDV+82k6xY2BcTcZoiAPB53F3rEkfzz/QkxcFiCKvtg2voG1WyVkyoue10404UXIkSXv0ySYnRBRugdPO1DKyUwL6FS5tP2p8toBVzeRT6rMkEwuU3A5riQpdnEOi0ckeFvSNU3Cdgdah4HWd+48gXzBE6Uwu/BMOrD/5mRUnS0wmPn7dajkjHNC2r9+C1jxlFy3NIim1rS2iA==\";;", "originalCommit": "83400484474d11a088ae3a5988585142280e5697", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "aa3220cadbf2bc18f2f24e7be6df08f3d24647fe", "url": "https://github.com/ibissource/iaf/commit/aa3220cadbf2bc18f2f24e7be6df08f3d24647fe", "message": "Fix issues", "committedDate": "2020-12-22T17:03:24Z", "type": "commit"}, {"oid": "4dbbc40572dd05093ccb820cdc94fa4aecf6ef17", "url": "https://github.com/ibissource/iaf/commit/4dbbc40572dd05093ccb820cdc94fa4aecf6ef17", "message": "Update IbisDoc", "committedDate": "2020-12-23T07:34:42Z", "type": "commit"}]}