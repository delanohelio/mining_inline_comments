{"pr_number": 2527, "pr_title": "Feature: allow @ meta commands from Console", "pr_createdAt": "2020-03-28T14:39:00Z", "pr_url": "https://github.com/h2database/h2database/pull/2527", "timeline": [{"oid": "8a27ea07a72830139b56f05f8bd85c3f2851d7dc", "url": "https://github.com/h2database/h2database/commit/8a27ea07a72830139b56f05f8bd85c3f2851d7dc", "message": "Use JdbcUtils.load() to load appropriate drivers\n\nDriver specification via -driver is usually redundant as JdbcUtils.load() properly caters to that.", "committedDate": "2020-03-23T05:43:19Z", "type": "commit"}, {"oid": "1268632e182c76952cb06a1d7426b54d898c1a1f", "url": "https://github.com/h2database/h2database/commit/1268632e182c76952cb06a1d7426b54d898c1a1f", "message": "Corrected driver name for derby", "committedDate": "2020-03-23T09:33:04Z", "type": "commit"}, {"oid": "f895a43189a41b24bb57f2e1132dd1b7199a3f94", "url": "https://github.com/h2database/h2database/commit/f895a43189a41b24bb57f2e1132dd1b7199a3f94", "message": "Allow @ meta commands in shell", "committedDate": "2020-03-27T10:49:56Z", "type": "commit"}, {"oid": "f6ecaab208f5bfde45257b3e0947968f4c3a1460", "url": "https://github.com/h2database/h2database/commit/f6ecaab208f5bfde45257b3e0947968f4c3a1460", "message": "Removed duplicate code", "committedDate": "2020-03-28T14:29:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTY3MTMyMQ==", "url": "https://github.com/h2database/h2database/pull/2527#discussion_r399671321", "bodyText": "This change is wrong. Each web session must use an own profiler as it was before your changes. You need to find some other way to deal with it.", "author": "katzyn", "createdAt": "2020-03-28T14:57:25Z", "path": "h2/src/main/org/h2/util/JdbcUtils.java", "diffHunk": "@@ -83,6 +88,7 @@\n \n     private static boolean allowAllClasses;\n     private static HashSet<String> allowedClassNames;\n+    private static Profiler profiler;", "originalCommit": "f6ecaab208f5bfde45257b3e0947968f4c3a1460", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTczNjY0Mw==", "url": "https://github.com/h2database/h2database/pull/2527#discussion_r399736643", "bodyText": "Can I add this to method param?", "author": "atamariya", "createdAt": "2020-03-29T02:52:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTY3MTMyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTczNzA0Mw==", "url": "https://github.com/h2database/h2database/pull/2527#discussion_r399737043", "bodyText": "That sounds reasonable.", "author": "katzyn", "createdAt": "2020-03-29T02:57:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTY3MTMyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTczNzQzMw==", "url": "https://github.com/h2database/h2database/pull/2527#discussion_r399737433", "bodyText": "But most likely you need a some reference to its owner, because this field is modified in the methods.", "author": "katzyn", "createdAt": "2020-03-29T03:03:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTY3MTMyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc0MjgxMw==", "url": "https://github.com/h2database/h2database/pull/2527#discussion_r399742813", "bodyText": "Changed in new commit.", "author": "atamariya", "createdAt": "2020-03-29T04:16:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTY3MTMyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTY3MTYzMg==", "url": "https://github.com/h2database/h2database/pull/2527#discussion_r399671632", "bodyText": "Do you really need them?", "author": "katzyn", "createdAt": "2020-03-28T15:00:03Z", "path": "h2/src/main/org/h2/util/JdbcUtils.java", "diffHunk": "@@ -600,4 +606,156 @@ private static void setLob(PreparedStatement prep, int parameterIndex, ValueLob\n         }\n     }\n \n+    public static ResultSet getMetaResultSet(Connection conn, String sql)\n+            throws SQLException {\n+        DatabaseMetaData meta = conn.getMetaData();\n+        if (isBuiltIn(sql, \"@best_row_identifier\")) {\n+            String[] p = split(sql);\n+            int scale = p[4] == null ? 0 : Integer.parseInt(p[4]);\n+            boolean nullable = Boolean.parseBoolean(p[5]);\n+            return meta.getBestRowIdentifier(p[1], p[2], p[3], scale, nullable);\n+        } else if (isBuiltIn(sql, \"@catalogs\")) {\n+            return meta.getCatalogs();\n+        } else if (isBuiltIn(sql, \"@columns\")) {\n+            String[] p = split(sql);\n+            return meta.getColumns(p[1], p[2], p[3], p[4]);\n+        } else if (isBuiltIn(sql, \"@column_privileges\")) {\n+            String[] p = split(sql);\n+            return meta.getColumnPrivileges(p[1], p[2], p[3], p[4]);\n+        } else if (isBuiltIn(sql, \"@cross_references\")) {\n+            String[] p = split(sql);\n+            return meta.getCrossReference(p[1], p[2], p[3], p[4], p[5], p[6]);\n+        } else if (isBuiltIn(sql, \"@exported_keys\")) {\n+            String[] p = split(sql);\n+            return meta.getExportedKeys(p[1], p[2], p[3]);\n+        } else if (isBuiltIn(sql, \"@imported_keys\")) {\n+            String[] p = split(sql);\n+            return meta.getImportedKeys(p[1], p[2], p[3]);\n+        } else if (isBuiltIn(sql, \"@index_info\")) {\n+            String[] p = split(sql);\n+            boolean unique = Boolean.parseBoolean(p[4]);\n+            boolean approx = Boolean.parseBoolean(p[5]);\n+            return meta.getIndexInfo(p[1], p[2], p[3], unique, approx);\n+        } else if (isBuiltIn(sql, \"@primary_keys\")) {\n+            String[] p = split(sql);\n+            return meta.getPrimaryKeys(p[1], p[2], p[3]);\n+        } else if (isBuiltIn(sql, \"@procedures\")) {\n+            String[] p = split(sql);\n+            return meta.getProcedures(p[1], p[2], p[3]);\n+        } else if (isBuiltIn(sql, \"@procedure_columns\")) {\n+            String[] p = split(sql);\n+            return meta.getProcedureColumns(p[1], p[2], p[3], p[4]);\n+        } else if (isBuiltIn(sql, \"@schemas\")) {\n+            return meta.getSchemas();\n+        } else if (isBuiltIn(sql, \"@tables\")) {\n+            String[] p = split(sql);\n+            String[] types = p[4] == null ? null : StringUtils.arraySplit(p[4], ',', false);\n+            return meta.getTables(p[1], p[2], p[3], types);\n+        } else if (isBuiltIn(sql, \"@table_privileges\")) {\n+            String[] p = split(sql);\n+            return meta.getTablePrivileges(p[1], p[2], p[3]);\n+        } else if (isBuiltIn(sql, \"@table_types\")) {\n+            return meta.getTableTypes();\n+        } else if (isBuiltIn(sql, \"@type_info\")) {\n+            return meta.getTypeInfo();\n+        } else if (isBuiltIn(sql, \"@udts\")) {\n+            String[] p = split(sql);\n+            int[] types;\n+            if (p[4] == null) {\n+                types = null;\n+            } else {\n+                String[] t = StringUtils.arraySplit(p[4], ',', false);\n+                types = new int[t.length];\n+                for (int i = 0; i < t.length; i++) {\n+                    types[i] = Integer.parseInt(t[i]);\n+                }\n+            }\n+            return meta.getUDTs(p[1], p[2], p[3], types);\n+        } else if (isBuiltIn(sql, \"@version_columns\")) {\n+            String[] p = split(sql);\n+            return meta.getVersionColumns(p[1], p[2], p[3]);\n+        } else if (isBuiltIn(sql, \"@memory\")) {\n+            SimpleResultSet rs = new SimpleResultSet();\n+            rs.addColumn(\"Type\", Types.VARCHAR, 0, 0);\n+            rs.addColumn(\"KB\", Types.VARCHAR, 0, 0);\n+            rs.addRow(\"Used Memory\", Integer.toString(Utils.getMemoryUsed()));\n+            rs.addRow(\"Free Memory\", Integer.toString(Utils.getMemoryFree()));\n+            return rs;\n+        } else if (isBuiltIn(sql, \"@info\")) {\n+            SimpleResultSet rs = new SimpleResultSet();\n+            rs.addColumn(\"KEY\", Types.VARCHAR, 0, 0);\n+            rs.addColumn(\"VALUE\", Types.VARCHAR, 0, 0);\n+            rs.addRow(\"conn.getCatalog\", conn.getCatalog());\n+            rs.addRow(\"conn.getAutoCommit\", Boolean.toString(conn.getAutoCommit()));\n+            rs.addRow(\"conn.storesUpperCaseIdentifiers\", Boolean.toString(meta.storesUpperCaseIdentifiers()));\n+            rs.addRow(\"conn.storesLowerCaseIdentifiers\", Boolean.toString(meta.storesLowerCaseIdentifiers()));\n+            rs.addRow(\"conn.storesMixedCaseIdentifiers\", Boolean.toString(meta.storesMixedCaseIdentifiers()));", "originalCommit": "f6ecaab208f5bfde45257b3e0947968f4c3a1460", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTczNTM5MA==", "url": "https://github.com/h2database/h2database/pull/2527#discussion_r399735390", "bodyText": "Useful from API completeness perspective.", "author": "atamariya", "createdAt": "2020-03-29T02:33:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTY3MTYzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTY3MTY2OQ==", "url": "https://github.com/h2database/h2database/pull/2527#discussion_r399671669", "bodyText": "Why this line was commented?", "author": "katzyn", "createdAt": "2020-03-28T15:00:23Z", "path": "h2/src/main/org/h2/util/JdbcUtils.java", "diffHunk": "@@ -600,4 +606,156 @@ private static void setLob(PreparedStatement prep, int parameterIndex, ValueLob\n         }\n     }\n \n+    public static ResultSet getMetaResultSet(Connection conn, String sql)\n+            throws SQLException {\n+        DatabaseMetaData meta = conn.getMetaData();\n+        if (isBuiltIn(sql, \"@best_row_identifier\")) {\n+            String[] p = split(sql);\n+            int scale = p[4] == null ? 0 : Integer.parseInt(p[4]);\n+            boolean nullable = Boolean.parseBoolean(p[5]);\n+            return meta.getBestRowIdentifier(p[1], p[2], p[3], scale, nullable);\n+        } else if (isBuiltIn(sql, \"@catalogs\")) {\n+            return meta.getCatalogs();\n+        } else if (isBuiltIn(sql, \"@columns\")) {\n+            String[] p = split(sql);\n+            return meta.getColumns(p[1], p[2], p[3], p[4]);\n+        } else if (isBuiltIn(sql, \"@column_privileges\")) {\n+            String[] p = split(sql);\n+            return meta.getColumnPrivileges(p[1], p[2], p[3], p[4]);\n+        } else if (isBuiltIn(sql, \"@cross_references\")) {\n+            String[] p = split(sql);\n+            return meta.getCrossReference(p[1], p[2], p[3], p[4], p[5], p[6]);\n+        } else if (isBuiltIn(sql, \"@exported_keys\")) {\n+            String[] p = split(sql);\n+            return meta.getExportedKeys(p[1], p[2], p[3]);\n+        } else if (isBuiltIn(sql, \"@imported_keys\")) {\n+            String[] p = split(sql);\n+            return meta.getImportedKeys(p[1], p[2], p[3]);\n+        } else if (isBuiltIn(sql, \"@index_info\")) {\n+            String[] p = split(sql);\n+            boolean unique = Boolean.parseBoolean(p[4]);\n+            boolean approx = Boolean.parseBoolean(p[5]);\n+            return meta.getIndexInfo(p[1], p[2], p[3], unique, approx);\n+        } else if (isBuiltIn(sql, \"@primary_keys\")) {\n+            String[] p = split(sql);\n+            return meta.getPrimaryKeys(p[1], p[2], p[3]);\n+        } else if (isBuiltIn(sql, \"@procedures\")) {\n+            String[] p = split(sql);\n+            return meta.getProcedures(p[1], p[2], p[3]);\n+        } else if (isBuiltIn(sql, \"@procedure_columns\")) {\n+            String[] p = split(sql);\n+            return meta.getProcedureColumns(p[1], p[2], p[3], p[4]);\n+        } else if (isBuiltIn(sql, \"@schemas\")) {\n+            return meta.getSchemas();\n+        } else if (isBuiltIn(sql, \"@tables\")) {\n+            String[] p = split(sql);\n+            String[] types = p[4] == null ? null : StringUtils.arraySplit(p[4], ',', false);\n+            return meta.getTables(p[1], p[2], p[3], types);\n+        } else if (isBuiltIn(sql, \"@table_privileges\")) {\n+            String[] p = split(sql);\n+            return meta.getTablePrivileges(p[1], p[2], p[3]);\n+        } else if (isBuiltIn(sql, \"@table_types\")) {\n+            return meta.getTableTypes();\n+        } else if (isBuiltIn(sql, \"@type_info\")) {\n+            return meta.getTypeInfo();\n+        } else if (isBuiltIn(sql, \"@udts\")) {\n+            String[] p = split(sql);\n+            int[] types;\n+            if (p[4] == null) {\n+                types = null;\n+            } else {\n+                String[] t = StringUtils.arraySplit(p[4], ',', false);\n+                types = new int[t.length];\n+                for (int i = 0; i < t.length; i++) {\n+                    types[i] = Integer.parseInt(t[i]);\n+                }\n+            }\n+            return meta.getUDTs(p[1], p[2], p[3], types);\n+        } else if (isBuiltIn(sql, \"@version_columns\")) {\n+            String[] p = split(sql);\n+            return meta.getVersionColumns(p[1], p[2], p[3]);\n+        } else if (isBuiltIn(sql, \"@memory\")) {\n+            SimpleResultSet rs = new SimpleResultSet();\n+            rs.addColumn(\"Type\", Types.VARCHAR, 0, 0);\n+            rs.addColumn(\"KB\", Types.VARCHAR, 0, 0);\n+            rs.addRow(\"Used Memory\", Integer.toString(Utils.getMemoryUsed()));\n+            rs.addRow(\"Free Memory\", Integer.toString(Utils.getMemoryFree()));\n+            return rs;\n+        } else if (isBuiltIn(sql, \"@info\")) {\n+            SimpleResultSet rs = new SimpleResultSet();\n+            rs.addColumn(\"KEY\", Types.VARCHAR, 0, 0);\n+            rs.addColumn(\"VALUE\", Types.VARCHAR, 0, 0);\n+            rs.addRow(\"conn.getCatalog\", conn.getCatalog());\n+            rs.addRow(\"conn.getAutoCommit\", Boolean.toString(conn.getAutoCommit()));\n+            rs.addRow(\"conn.storesUpperCaseIdentifiers\", Boolean.toString(meta.storesUpperCaseIdentifiers()));\n+            rs.addRow(\"conn.storesLowerCaseIdentifiers\", Boolean.toString(meta.storesLowerCaseIdentifiers()));\n+            rs.addRow(\"conn.storesMixedCaseIdentifiers\", Boolean.toString(meta.storesMixedCaseIdentifiers()));\n+            rs.addRow(\"conn.getTransactionIsolation\", Integer.toString(conn.getTransactionIsolation()));\n+            rs.addRow(\"conn.getWarnings\", String.valueOf(conn.getWarnings()));\n+            String map;\n+            try {\n+                map = String.valueOf(conn.getTypeMap());\n+            } catch (SQLException e) {\n+                map = e.toString();\n+            }\n+            rs.addRow(\"conn.getTypeMap\", map);\n+            rs.addRow(\"conn.isReadOnly\", Boolean.toString(conn.isReadOnly()));\n+            rs.addRow(\"conn.getHoldability\", Integer.toString(conn.getHoldability()));\n+            addDatabaseMetaData(rs, meta);\n+            return rs;\n+        } else if (isBuiltIn(sql, \"@attributes\")) {\n+            String[] p = split(sql);\n+            return meta.getAttributes(p[1], p[2], p[3], p[4]);\n+        } else if (isBuiltIn(sql, \"@super_tables\")) {\n+            String[] p = split(sql);\n+            return meta.getSuperTables(p[1], p[2], p[3]);\n+        } else if (isBuiltIn(sql, \"@super_types\")) {\n+            String[] p = split(sql);\n+            return meta.getSuperTypes(p[1], p[2], p[3]);\n+        } else if (isBuiltIn(sql, \"@prof_stop\")) {\n+            if (profiler != null) {\n+                profiler.stopCollecting();\n+                SimpleResultSet rs = new SimpleResultSet();\n+                rs.addColumn(\"Top Stack Trace(s)\", Types.VARCHAR, 0, 0);\n+                rs.addRow(profiler.getTop(3));\n+                profiler = null;\n+                return rs;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private static void addDatabaseMetaData(SimpleResultSet rs,\n+            DatabaseMetaData meta) {\n+        Method[] methods = DatabaseMetaData.class.getDeclaredMethods();\n+        //Arrays.sort(methods, Comparator.comparing(Method::toString));", "originalCommit": "f6ecaab208f5bfde45257b3e0947968f4c3a1460", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTczNTg0MQ==", "url": "https://github.com/h2database/h2database/pull/2527#discussion_r399735841", "bodyText": "This makes console more useful as it maintains backward compatibility. The only cost here is - we will miss out on sorted result.", "author": "atamariya", "createdAt": "2020-03-29T02:40:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTY3MTY2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTczNzIxMg==", "url": "https://github.com/h2database/h2database/pull/2527#discussion_r399737212", "bodyText": "Backward compatibility with what?", "author": "katzyn", "createdAt": "2020-03-29T02:59:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTY3MTY2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTczNzc2NQ==", "url": "https://github.com/h2database/h2database/pull/2527#discussion_r399737765", "bodyText": "Older JDKs.", "author": "atamariya", "createdAt": "2020-03-29T03:08:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTY3MTY2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTczODExMw==", "url": "https://github.com/h2database/h2database/pull/2527#discussion_r399738113", "bodyText": "Current H2 requires Java 8+.", "author": "katzyn", "createdAt": "2020-03-29T03:13:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTY3MTY2OQ=="}], "type": "inlineReview"}, {"oid": "0e4885c04001cee7b637054d16b6c3e54d510db1", "url": "https://github.com/h2database/h2database/commit/0e4885c04001cee7b637054d16b6c3e54d510db1", "message": "Movded Profiler to method param", "committedDate": "2020-03-29T02:56:18Z", "type": "commit"}, {"oid": "32708a6c3397d3f61265f3a788a5376a1c29bb0a", "url": "https://github.com/h2database/h2database/commit/32708a6c3397d3f61265f3a788a5376a1c29bb0a", "message": "Uncommented sort", "committedDate": "2020-03-29T03:19:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc0MzY5NA==", "url": "https://github.com/h2database/h2database/pull/2527#discussion_r399743694", "bodyText": "Old implementation also sets WebApp.profiler to null.\nI think you can move the whole condition for @prof_stop from this method into WebApp.getResult(), because there is no need in @prof_stop without @prof_start.", "author": "katzyn", "createdAt": "2020-03-29T04:28:32Z", "path": "h2/src/main/org/h2/util/JdbcUtils.java", "diffHunk": "@@ -600,4 +605,152 @@ private static void setLob(PreparedStatement prep, int parameterIndex, ValueLob\n         }\n     }\n \n+    public static ResultSet getMetaResultSet(Connection conn, String sql, Profiler profiler)\n+            throws SQLException {\n+        DatabaseMetaData meta = conn.getMetaData();\n+        if (isBuiltIn(sql, \"@best_row_identifier\")) {\n+            String[] p = split(sql);\n+            int scale = p[4] == null ? 0 : Integer.parseInt(p[4]);\n+            boolean nullable = Boolean.parseBoolean(p[5]);\n+            return meta.getBestRowIdentifier(p[1], p[2], p[3], scale, nullable);\n+        } else if (isBuiltIn(sql, \"@catalogs\")) {\n+            return meta.getCatalogs();\n+        } else if (isBuiltIn(sql, \"@columns\")) {\n+            String[] p = split(sql);\n+            return meta.getColumns(p[1], p[2], p[3], p[4]);\n+        } else if (isBuiltIn(sql, \"@column_privileges\")) {\n+            String[] p = split(sql);\n+            return meta.getColumnPrivileges(p[1], p[2], p[3], p[4]);\n+        } else if (isBuiltIn(sql, \"@cross_references\")) {\n+            String[] p = split(sql);\n+            return meta.getCrossReference(p[1], p[2], p[3], p[4], p[5], p[6]);\n+        } else if (isBuiltIn(sql, \"@exported_keys\")) {\n+            String[] p = split(sql);\n+            return meta.getExportedKeys(p[1], p[2], p[3]);\n+        } else if (isBuiltIn(sql, \"@imported_keys\")) {\n+            String[] p = split(sql);\n+            return meta.getImportedKeys(p[1], p[2], p[3]);\n+        } else if (isBuiltIn(sql, \"@index_info\")) {\n+            String[] p = split(sql);\n+            boolean unique = Boolean.parseBoolean(p[4]);\n+            boolean approx = Boolean.parseBoolean(p[5]);\n+            return meta.getIndexInfo(p[1], p[2], p[3], unique, approx);\n+        } else if (isBuiltIn(sql, \"@primary_keys\")) {\n+            String[] p = split(sql);\n+            return meta.getPrimaryKeys(p[1], p[2], p[3]);\n+        } else if (isBuiltIn(sql, \"@procedures\")) {\n+            String[] p = split(sql);\n+            return meta.getProcedures(p[1], p[2], p[3]);\n+        } else if (isBuiltIn(sql, \"@procedure_columns\")) {\n+            String[] p = split(sql);\n+            return meta.getProcedureColumns(p[1], p[2], p[3], p[4]);\n+        } else if (isBuiltIn(sql, \"@schemas\")) {\n+            return meta.getSchemas();\n+        } else if (isBuiltIn(sql, \"@tables\")) {\n+            String[] p = split(sql);\n+            String[] types = p[4] == null ? null : StringUtils.arraySplit(p[4], ',', false);\n+            return meta.getTables(p[1], p[2], p[3], types);\n+        } else if (isBuiltIn(sql, \"@table_privileges\")) {\n+            String[] p = split(sql);\n+            return meta.getTablePrivileges(p[1], p[2], p[3]);\n+        } else if (isBuiltIn(sql, \"@table_types\")) {\n+            return meta.getTableTypes();\n+        } else if (isBuiltIn(sql, \"@type_info\")) {\n+            return meta.getTypeInfo();\n+        } else if (isBuiltIn(sql, \"@udts\")) {\n+            String[] p = split(sql);\n+            int[] types;\n+            if (p[4] == null) {\n+                types = null;\n+            } else {\n+                String[] t = StringUtils.arraySplit(p[4], ',', false);\n+                types = new int[t.length];\n+                for (int i = 0; i < t.length; i++) {\n+                    types[i] = Integer.parseInt(t[i]);\n+                }\n+            }\n+            return meta.getUDTs(p[1], p[2], p[3], types);\n+        } else if (isBuiltIn(sql, \"@version_columns\")) {\n+            String[] p = split(sql);\n+            return meta.getVersionColumns(p[1], p[2], p[3]);\n+        } else if (isBuiltIn(sql, \"@memory\")) {\n+            SimpleResultSet rs = new SimpleResultSet();\n+            rs.addColumn(\"Type\", Types.VARCHAR, 0, 0);\n+            rs.addColumn(\"KB\", Types.VARCHAR, 0, 0);\n+            rs.addRow(\"Used Memory\", Integer.toString(Utils.getMemoryUsed()));\n+            rs.addRow(\"Free Memory\", Integer.toString(Utils.getMemoryFree()));\n+            return rs;\n+        } else if (isBuiltIn(sql, \"@info\")) {\n+            SimpleResultSet rs = new SimpleResultSet();\n+            rs.addColumn(\"KEY\", Types.VARCHAR, 0, 0);\n+            rs.addColumn(\"VALUE\", Types.VARCHAR, 0, 0);\n+            rs.addRow(\"conn.getCatalog\", conn.getCatalog());\n+            rs.addRow(\"conn.getAutoCommit\", Boolean.toString(conn.getAutoCommit()));\n+            rs.addRow(\"conn.getTransactionIsolation\", Integer.toString(conn.getTransactionIsolation()));\n+            rs.addRow(\"conn.getWarnings\", String.valueOf(conn.getWarnings()));\n+            String map;\n+            try {\n+                map = String.valueOf(conn.getTypeMap());\n+            } catch (SQLException e) {\n+                map = e.toString();\n+            }\n+            rs.addRow(\"conn.getTypeMap\", map);\n+            rs.addRow(\"conn.isReadOnly\", Boolean.toString(conn.isReadOnly()));\n+            rs.addRow(\"conn.getHoldability\", Integer.toString(conn.getHoldability()));\n+            addDatabaseMetaData(rs, meta);\n+            return rs;\n+        } else if (isBuiltIn(sql, \"@attributes\")) {\n+            String[] p = split(sql);\n+            return meta.getAttributes(p[1], p[2], p[3], p[4]);\n+        } else if (isBuiltIn(sql, \"@super_tables\")) {\n+            String[] p = split(sql);\n+            return meta.getSuperTables(p[1], p[2], p[3]);\n+        } else if (isBuiltIn(sql, \"@super_types\")) {\n+            String[] p = split(sql);\n+            return meta.getSuperTypes(p[1], p[2], p[3]);\n+        } else if (isBuiltIn(sql, \"@prof_stop\")) {\n+            if (profiler != null) {\n+                profiler.stopCollecting();\n+                SimpleResultSet rs = new SimpleResultSet();\n+                rs.addColumn(\"Top Stack Trace(s)\", Types.VARCHAR, 0, 0);\n+                rs.addRow(profiler.getTop(3));\n+                return rs;\n+            }", "originalCommit": "32708a6c3397d3f61265f3a788a5376a1c29bb0a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc0NTU3MQ==", "url": "https://github.com/h2database/h2database/pull/2527#discussion_r399745571", "bodyText": "Sounds right. Done.", "author": "atamariya", "createdAt": "2020-03-29T04:56:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc0MzY5NA=="}], "type": "inlineReview"}, {"oid": "7a13033d5e74f97e842e5659380d492131db8784", "url": "https://github.com/h2database/h2database/commit/7a13033d5e74f97e842e5659380d492131db8784", "message": "Moved @prof_stop to WebApp", "committedDate": "2020-03-29T04:55:27Z", "type": "commit"}, {"oid": "59ede052e532a4e6f011ae807a3fbc8374ceb1ce", "url": "https://github.com/h2database/h2database/commit/59ede052e532a4e6f011ae807a3fbc8374ceb1ce", "message": "Fix compilation error", "committedDate": "2020-03-29T12:20:27Z", "type": "commit"}, {"oid": "ee212e3d432b617a45d9ca769d7d009abe964e04", "url": "https://github.com/h2database/h2database/commit/ee212e3d432b617a45d9ca769d7d009abe964e04", "message": "Fix compilation error", "committedDate": "2020-03-29T12:40:42Z", "type": "commit"}, {"oid": "db7727d7602ca70aa824fc64ab248d6495c12b30", "url": "https://github.com/h2database/h2database/commit/db7727d7602ca70aa824fc64ab248d6495c12b30", "message": "Fix compilation error", "committedDate": "2020-03-29T14:15:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTkyOTkwMA==", "url": "https://github.com/h2database/h2database/pull/2527#discussion_r399929900", "bodyText": "Now you have two copies of this method, one of them needs to be removed.\nIt would be better to place this method in StringUtils class instead with some generic name, such as startsWithIgnoreCase(String string, String prefix).\nPlease also send a license statement as described here\nhttps://h2database.com/html/build.html#providing_patches\nto our mailing list:\nhttps://groups.google.com/forum/#!forum/h2-database", "author": "katzyn", "createdAt": "2020-03-30T05:08:17Z", "path": "h2/src/main/org/h2/util/JdbcUtils.java", "diffHunk": "@@ -600,4 +606,144 @@ private static void setLob(PreparedStatement prep, int parameterIndex, ValueLob\n         }\n     }\n \n+    public static ResultSet getMetaResultSet(Connection conn, String sql)\n+            throws SQLException {\n+        DatabaseMetaData meta = conn.getMetaData();\n+        if (isBuiltIn(sql, \"@best_row_identifier\")) {\n+            String[] p = split(sql);\n+            int scale = p[4] == null ? 0 : Integer.parseInt(p[4]);\n+            boolean nullable = Boolean.parseBoolean(p[5]);\n+            return meta.getBestRowIdentifier(p[1], p[2], p[3], scale, nullable);\n+        } else if (isBuiltIn(sql, \"@catalogs\")) {\n+            return meta.getCatalogs();\n+        } else if (isBuiltIn(sql, \"@columns\")) {\n+            String[] p = split(sql);\n+            return meta.getColumns(p[1], p[2], p[3], p[4]);\n+        } else if (isBuiltIn(sql, \"@column_privileges\")) {\n+            String[] p = split(sql);\n+            return meta.getColumnPrivileges(p[1], p[2], p[3], p[4]);\n+        } else if (isBuiltIn(sql, \"@cross_references\")) {\n+            String[] p = split(sql);\n+            return meta.getCrossReference(p[1], p[2], p[3], p[4], p[5], p[6]);\n+        } else if (isBuiltIn(sql, \"@exported_keys\")) {\n+            String[] p = split(sql);\n+            return meta.getExportedKeys(p[1], p[2], p[3]);\n+        } else if (isBuiltIn(sql, \"@imported_keys\")) {\n+            String[] p = split(sql);\n+            return meta.getImportedKeys(p[1], p[2], p[3]);\n+        } else if (isBuiltIn(sql, \"@index_info\")) {\n+            String[] p = split(sql);\n+            boolean unique = Boolean.parseBoolean(p[4]);\n+            boolean approx = Boolean.parseBoolean(p[5]);\n+            return meta.getIndexInfo(p[1], p[2], p[3], unique, approx);\n+        } else if (isBuiltIn(sql, \"@primary_keys\")) {\n+            String[] p = split(sql);\n+            return meta.getPrimaryKeys(p[1], p[2], p[3]);\n+        } else if (isBuiltIn(sql, \"@procedures\")) {\n+            String[] p = split(sql);\n+            return meta.getProcedures(p[1], p[2], p[3]);\n+        } else if (isBuiltIn(sql, \"@procedure_columns\")) {\n+            String[] p = split(sql);\n+            return meta.getProcedureColumns(p[1], p[2], p[3], p[4]);\n+        } else if (isBuiltIn(sql, \"@schemas\")) {\n+            return meta.getSchemas();\n+        } else if (isBuiltIn(sql, \"@tables\")) {\n+            String[] p = split(sql);\n+            String[] types = p[4] == null ? null : StringUtils.arraySplit(p[4], ',', false);\n+            return meta.getTables(p[1], p[2], p[3], types);\n+        } else if (isBuiltIn(sql, \"@table_privileges\")) {\n+            String[] p = split(sql);\n+            return meta.getTablePrivileges(p[1], p[2], p[3]);\n+        } else if (isBuiltIn(sql, \"@table_types\")) {\n+            return meta.getTableTypes();\n+        } else if (isBuiltIn(sql, \"@type_info\")) {\n+            return meta.getTypeInfo();\n+        } else if (isBuiltIn(sql, \"@udts\")) {\n+            String[] p = split(sql);\n+            int[] types;\n+            if (p[4] == null) {\n+                types = null;\n+            } else {\n+                String[] t = StringUtils.arraySplit(p[4], ',', false);\n+                types = new int[t.length];\n+                for (int i = 0; i < t.length; i++) {\n+                    types[i] = Integer.parseInt(t[i]);\n+                }\n+            }\n+            return meta.getUDTs(p[1], p[2], p[3], types);\n+        } else if (isBuiltIn(sql, \"@version_columns\")) {\n+            String[] p = split(sql);\n+            return meta.getVersionColumns(p[1], p[2], p[3]);\n+        } else if (isBuiltIn(sql, \"@memory\")) {\n+            SimpleResultSet rs = new SimpleResultSet();\n+            rs.addColumn(\"Type\", Types.VARCHAR, 0, 0);\n+            rs.addColumn(\"KB\", Types.VARCHAR, 0, 0);\n+            rs.addRow(\"Used Memory\", Integer.toString(Utils.getMemoryUsed()));\n+            rs.addRow(\"Free Memory\", Integer.toString(Utils.getMemoryFree()));\n+            return rs;\n+        } else if (isBuiltIn(sql, \"@info\")) {\n+            SimpleResultSet rs = new SimpleResultSet();\n+            rs.addColumn(\"KEY\", Types.VARCHAR, 0, 0);\n+            rs.addColumn(\"VALUE\", Types.VARCHAR, 0, 0);\n+            rs.addRow(\"conn.getCatalog\", conn.getCatalog());\n+            rs.addRow(\"conn.getAutoCommit\", Boolean.toString(conn.getAutoCommit()));\n+            rs.addRow(\"conn.getTransactionIsolation\", Integer.toString(conn.getTransactionIsolation()));\n+            rs.addRow(\"conn.getWarnings\", String.valueOf(conn.getWarnings()));\n+            String map;\n+            try {\n+                map = String.valueOf(conn.getTypeMap());\n+            } catch (SQLException e) {\n+                map = e.toString();\n+            }\n+            rs.addRow(\"conn.getTypeMap\", map);\n+            rs.addRow(\"conn.isReadOnly\", Boolean.toString(conn.isReadOnly()));\n+            rs.addRow(\"conn.getHoldability\", Integer.toString(conn.getHoldability()));\n+            addDatabaseMetaData(rs, meta);\n+            return rs;\n+        } else if (isBuiltIn(sql, \"@attributes\")) {\n+            String[] p = split(sql);\n+            return meta.getAttributes(p[1], p[2], p[3], p[4]);\n+        } else if (isBuiltIn(sql, \"@super_tables\")) {\n+            String[] p = split(sql);\n+            return meta.getSuperTables(p[1], p[2], p[3]);\n+        } else if (isBuiltIn(sql, \"@super_types\")) {\n+            String[] p = split(sql);\n+            return meta.getSuperTypes(p[1], p[2], p[3]);\n+        }\n+        return null;\n+    }\n+\n+    private static void addDatabaseMetaData(SimpleResultSet rs,\n+            DatabaseMetaData meta) {\n+        Method[] methods = DatabaseMetaData.class.getDeclaredMethods();\n+        Arrays.sort(methods, Comparator.comparing(Method::toString));\n+        for (Method m : methods) {\n+            if (m.getParameterTypes().length == 0) {\n+                try {\n+                    Object o = m.invoke(meta);\n+                    rs.addRow(\"meta.\" + m.getName(), String.valueOf(o));\n+                } catch (InvocationTargetException e) {\n+                    rs.addRow(\"meta.\" + m.getName(), e.getTargetException().toString());\n+                } catch (Exception e) {\n+                    rs.addRow(\"meta.\" + m.getName(), e.toString());\n+                }\n+            }\n+        }\n+    }\n+\n+    private static boolean isBuiltIn(String sql, String builtIn) {\n+        return sql.regionMatches(true, 0, builtIn, 0, builtIn.length());\n+    }", "originalCommit": "db7727d7602ca70aa824fc64ab248d6495c12b30", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk1NDYyMw==", "url": "https://github.com/h2database/h2database/pull/2527#discussion_r399954623", "bodyText": "Since this is not a generic method, let's maintain it as is in JdbcUtils.\nI've sent out the license agreement to the mailing list.", "author": "atamariya", "createdAt": "2020-03-30T06:32:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTkyOTkwMA=="}], "type": "inlineReview"}, {"oid": "acd79a6d1ec335a32466f1613a7a3f957ff4f303", "url": "https://github.com/h2database/h2database/commit/acd79a6d1ec335a32466f1613a7a3f957ff4f303", "message": "Removed redundant isBuiltin from WebApp", "committedDate": "2020-03-30T06:30:40Z", "type": "commit"}]}