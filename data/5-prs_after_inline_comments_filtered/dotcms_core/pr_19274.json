{"pr_number": 19274, "pr_title": "Merge release 5.3.8", "pr_createdAt": "2020-09-16T18:03:13Z", "pr_url": "https://github.com/dotCMS/core/pull/19274", "timeline": [{"oid": "e3b58b3694d7059cf3bdb1075634fb92d22dae67", "url": "https://github.com/dotCMS/core/commit/e3b58b3694d7059cf3bdb1075634fb92d22dae67", "message": "merge release to master", "committedDate": "2020-09-16T15:22:11Z", "type": "commit"}, {"oid": "a4327c1b9cf606e4b0fe93358f0eb0724a2c7733", "url": "https://github.com/dotCMS/core/commit/a4327c1b9cf606e4b0fe93358f0eb0724a2c7733", "message": "master properties", "committedDate": "2020-09-16T15:58:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTYyNzAxMw==", "url": "https://github.com/dotCMS/core/pull/19274#discussion_r489627013", "bodyText": "Codacy found an issue: Avoid catching generic exceptions such as NullPointerException, RuntimeException, Exception in try-catch block", "author": "dev-dotcms", "createdAt": "2020-09-16T18:09:32Z", "path": "dotCMS/src/main/java/com/dotmarketing/quartz/job/ResetPermissionsJob.java", "diffHunk": "@@ -70,35 +74,23 @@ public ResetPermissionsJob() {\n      *        Page, etc.\r\n      */\r\n \tpublic static void triggerJobImmediately (final Permissionable perm) {\r\n-\t\tfinal String randomID = UUID.randomUUID().toString();\r\n-\t\tfinal JobDataMap dataMap = new JobDataMap();\r\n-\r\n \t\tString userId = null;\r\n-\t\t\r\n-\t\tdataMap.put(\"permissionableId\", perm.getPermissionId());\r\n \r\n \t\t//TODO: For a major release, remove this logic and get userId as parameter\r\n \t\tif (UtilMethods.isSet(HttpServletRequestThreadLocal.INSTANCE.getRequest())) {\r\n \t\t\tuserId = WebAPILocator.getUserWebAPI()\r\n \t\t\t\t\t.getLoggedInUser(HttpServletRequestThreadLocal.INSTANCE.getRequest())\r\n \t\t\t\t\t.getUserId();\r\n \t\t}\r\n-\t\tdataMap.put(\"userId\", userId);\r\n-\r\n-\t\tfinal JobDetail jd = new JobDetail(\"ResetPermissionsJob-\" + randomID, \"dotcms_jobs\", ResetPermissionsJob.class);\r\n-\t\tjd.setJobDataMap(dataMap);\r\n-\t\tjd.setDurability(false);\r\n-\t\tjd.setVolatility(false);\r\n-\t\tjd.setRequestsRecovery(true);\r\n-\t\t\r\n-\t\tfinal long startTime = System.currentTimeMillis();\r\n-\t\tfinal SimpleTrigger trigger = new SimpleTrigger(\"permissionsResetTrigger-\"+randomID, \"dotcms_triggers\",  new Date(startTime));\r\n+\t\tfinal Map<String, Serializable> nextExecutionData = ImmutableMap\r\n+\t\t\t\t.of(\r\n+\t\t\t\t\t\t\"permissionableId\", perm.getPermissionId(),\r\n+\t\t\t\t\t\t\"userId\", userId);\r\n \t\t\r\n \t\ttry {\r\n+\t\t\tDotStatefulJob.enqueueTrigger(nextExecutionData, ResetPermissionsJob.class);\r\n \r\n-\t\t\tfinal Scheduler sched = QuartzUtils.getSequentialScheduler();\r\n-\t\t\tsched.scheduleJob(jd, trigger);\r\n-\t\t} catch (SchedulerException e) {\r\n+\t\t} catch (Exception e) {\r", "originalCommit": "a4327c1b9cf606e4b0fe93358f0eb0724a2c7733", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTYyNzAyNw==", "url": "https://github.com/dotCMS/core/pull/19274#discussion_r489627027", "bodyText": "Codacy found an issue: JUnit tests should include assert() or fail()", "author": "dev-dotcms", "createdAt": "2020-09-16T18:09:34Z", "path": "dotCMS/src/integration-test/java/com/dotmarketing/quartz/DotStatefulJobTest.java", "diffHunk": "@@ -0,0 +1,234 @@\n+package com.dotmarketing.quartz;\n+\n+import static com.dotmarketing.quartz.DotStatefulJob.getJobDescription;\n+import static com.dotmarketing.quartz.DotStatefulJob.getJobGroupName;\n+import static com.dotmarketing.quartz.DotStatefulJob.getJobName;\n+import static com.dotmarketing.quartz.DotStatefulJob.getTriggerGroupName;\n+import static com.dotmarketing.quartz.QuartzUtils.getSequentialScheduler;\n+import static java.util.Objects.requireNonNull;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import com.dotcms.IntegrationTestBase;\n+import com.dotcms.util.IntegrationTestInitService;\n+import com.dotmarketing.util.DateUtil;\n+import com.dotmarketing.util.Logger;\n+import com.google.common.collect.ImmutableMap;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.time.LocalTime;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.quartz.JobDetail;\n+import org.quartz.JobExecutionContext;\n+import org.quartz.Scheduler;\n+import org.quartz.SchedulerException;\n+import org.quartz.SimpleTrigger;\n+\n+public class DotStatefulJobTest extends IntegrationTestBase {\n+\n+    @BeforeClass\n+    public static void prepare() throws Exception {\n+        // Setting web app environment\n+        IntegrationTestInitService.getInstance().init();\n+        getSequentialScheduler().start();\n+    }\n+\n+    /**\n+     * clean up precaution\n+     * @throws SchedulerException\n+     */\n+    private void removeAnyExistingJob() throws SchedulerException {\n+        final String jobName = getJobName(MyStatefulJob.class);\n+        final String jobGroupName = getJobGroupName(MyStatefulJob.class);\n+        QuartzUtils.removeJob(jobName, jobGroupName);\n+    }\n+\n+    /**\n+     * Given scenario: We prep to trigger a bunch of tasks that must be executed sequentially (one at the time) never in parallel.\n+     * Expected Results: first all triggered tasks must be executed and completed. second their time mark must revel that none of theme overlapped.\n+     *\n+     * @throws SchedulerException\n+     * @throws ParseException\n+     * @throws ClassNotFoundException\n+     * @throws InterruptedException\n+     */\n+    @Test\n+    public void Test_Launch_Stateful_Jobs_Verify_They_Dont_Overlap_In_Time()\n+            throws SchedulerException, ParseException, ClassNotFoundException, InterruptedException {\n+\n+        //in order to avoid conflicts clean any reference that could have been left.\n+        removeAnyExistingJob();\n+\n+        //Now enqueue a few jos .. They will sleep randomly to simulate work.\n+        for (int i = 1; i <= MyStatefulJob.MAX_THREADS; i++) {\n+            MyStatefulJob.fireJob(ImmutableMap.of(\"index\", i));\n+            //Now verify the detail has been added for the present trigger we're introducing\n+            final Optional<Map<String, Object>> triggerJobDetail = DotStatefulJob\n+                    .getTriggerJobDetail(MyStatefulJob.class);\n+            assertNotNull(triggerJobDetail);\n+            assertTrue(triggerJobDetail.isPresent());\n+            final Map<String, Object> detail = triggerJobDetail.get();\n+            assertNotNull(detail);\n+            //The size of the detail should have grown as we insert new triggers.\n+            assertEquals(detail.size(), i);\n+        }\n+\n+        //Verify at least 1 job has been launched.\n+        final Optional<JobExecutionContext> jobExecutionContext = getJobExecutionContext();\n+        assertTrue(jobExecutionContext.isPresent());\n+\n+        //Now lets wait for the all the threads to complete.\n+        MyStatefulJob.countDownLatch.await();\n+\n+        //Now lets revise the execution times. Since they were supposed to run sequentially the should never overlap.\n+        final HashSet<MyStatefulJob> myStatefulJobs = new HashSet<>(MyStatefulJob.finishedJobs);\n+        final Iterator<MyStatefulJob> iterator = myStatefulJobs.iterator();\n+        while(iterator.hasNext()){\n+            final MyStatefulJob myStatefulJob = iterator.next();\n+            iterator.forEachRemaining(job -> {\n+                //They should never overlap.\n+                assertFalse(myStatefulJob.getTimeRange().overlaps(job.getTimeRange()));\n+            });\n+        }\n+    }\n+\n+    /**\n+     * This gets you the execution context for the given job-name.\n+     * @return\n+     */\n+    private Optional<JobExecutionContext> getJobExecutionContext(){\n+        final String jobName = getJobName(MyStatefulJob.class);\n+        try {\n+            final Scheduler sequentialScheduler = getSequentialScheduler();\n+            @SuppressWarnings(\"unchecked\")\n+            final List<JobExecutionContext> executingJobs = sequentialScheduler.getCurrentlyExecutingJobs();\n+            return executingJobs.stream().filter(jobExecutionContext -> {\n+                final JobDetail jobDetail = jobExecutionContext.getJobDetail();\n+                return jobDetail != null && jobName.equals(jobDetail.getName());\n+            }).findFirst();\n+        } catch (Exception e) {\n+            Logger.error(DotStatefulJobTest.class, \"Error retrieving execution context. \" , e);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * additional struct to follow execution time lapse.\n+     */\n+    public static class LocalTimeRange {\n+\n+        private final LocalTime from;\n+        private final LocalTime to;\n+\n+        LocalTimeRange(final LocalTime from, final LocalTime to) {\n+            requireNonNull(from, \"from must not be null\");\n+            requireNonNull(to, \"to must not be null\");\n+            this.from = from;\n+            this.to = to;\n+        }\n+\n+        boolean overlaps(final LocalTimeRange other) {\n+            requireNonNull(other, \"other must not be null\");\n+            return isBetween(other.from, this.from, this.to)\n+                    || isBetween(other.to, this.from, this.to)\n+                    || isBetween(this.from, other.from, other.to)\n+                    || isBetween(this.to, other.from, other.to);\n+        }\n+\n+        private static boolean isBetween(final LocalTime time, final LocalTime from, final LocalTime to) {\n+            if (from.isBefore(to)) { // same day\n+                return from.isBefore(time) && time.isBefore(to);\n+            } else { // spans to the next day.\n+                return from.isBefore(time) || time.isBefore(to);\n+            }\n+        }\n+\n+        public static LocalTimeRange of(final LocalTime from, final LocalTime to){\n+           return new LocalTimeRange(from, to);\n+        }\n+    }\n+\n+    /**\n+     * Given scenario: We test that the internal methods generate properly formed names\n+     * Expected Results: The call to the methods match the given patterns\n+     */\n+    @Test\n+    public void Test_Stateful_Job_Utility_Methods(){\n+        assertEquals(\"MyStatefulJob\", getJobName(MyStatefulJob.class));\n+        assertEquals(\"MyStatefulJob_Group\", getJobGroupName(MyStatefulJob.class));\n+        assertEquals(\"MyStatefulJob_Trigger_Group\", getTriggerGroupName(MyStatefulJob.class));\n+        assertTrue(DotStatefulJob.nextTriggerName(MyStatefulJob.class).startsWith(\"MyStatefulJob_Trigger_\"));\n+    }\n+\n+    /**\n+     * create a ScheduledTask\n+     * @param startDate\n+     * @return\n+     */\n+    private ScheduledTask scheduledTask(final Date startDate){\n+        final String jobName = getJobName(MyStatefulJob.class);\n+        final String groupName = getJobGroupName(MyStatefulJob.class);\n+        final String description = getJobDescription(MyStatefulJob.class);\n+        final String nextTriggerName = DotStatefulJob.nextTriggerName(MyStatefulJob.class);\n+        final String triggerGroup = getTriggerGroupName(MyStatefulJob.class);\n+\n+        final Map<String, Object> jobProperties = new HashMap<>();\n+        //get the job detail so we dont lose any data already saved for other triggers.\n+\n+        final Calendar calendar = Calendar.getInstance();\n+        final String cronString = new SimpleDateFormat(\"ss mm H d M ? yyyy\")\n+                .format(calendar.getTime());\n+        final ScheduledTask task = new CronScheduledTask(jobName,\n+                groupName, description,\n+                MyStatefulJob.class.getCanonicalName(), false,\n+                nextTriggerName, triggerGroup, startDate, null,\n+                SimpleTrigger.MISFIRE_INSTRUCTION_FIRE_NOW, 10, true, jobProperties,\n+                cronString);\n+        task.setDurability(true);\n+        return task;\n+    }\n+\n+    /**\n+     * Given scenario: The ScheduledTasks is build but then fired too late.\n+     * Expected Results: We expect SchedulerException `Based on configured schedule, the given trigger will never fire.`\n+     * @throws ParseException\n+     * @throws SchedulerException\n+     * @throws ClassNotFoundException\n+     */\n+    @Test(expected = SchedulerException.class)\n+    public void Test_Schedule_Task_Make_It_Start_Later_Expect_SchedulerException()\n+            throws ParseException, SchedulerException, ClassNotFoundException {\n+\n+        final ScheduledTask task = scheduledTask(null);\n+        DateUtil.sleep(10000);\n+        QuartzUtils.scheduleTask(task);\n+    }\n+\n+    /**\n+     * Given scenario: The ScheduledTasks is build but then fired too late. But this time we specify a startDate.\n+     * Expected Results: The jobs fired normally.\n+     * @throws ParseException\n+     * @throws SchedulerException\n+     * @throws ClassNotFoundException\n+     */\n+    @Test\n+    public void Test_Schedule_Task_Make_It_Start_Later_Expect_No_Exception()", "originalCommit": "a4327c1b9cf606e4b0fe93358f0eb0724a2c7733", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTYyNzAzNg==", "url": "https://github.com/dotCMS/core/pull/19274#discussion_r489627036", "bodyText": "Codacy found an issue: Avoid variables with short names like to", "author": "dev-dotcms", "createdAt": "2020-09-16T18:09:35Z", "path": "dotCMS/src/integration-test/java/com/dotmarketing/quartz/DotStatefulJobTest.java", "diffHunk": "@@ -0,0 +1,234 @@\n+package com.dotmarketing.quartz;\n+\n+import static com.dotmarketing.quartz.DotStatefulJob.getJobDescription;\n+import static com.dotmarketing.quartz.DotStatefulJob.getJobGroupName;\n+import static com.dotmarketing.quartz.DotStatefulJob.getJobName;\n+import static com.dotmarketing.quartz.DotStatefulJob.getTriggerGroupName;\n+import static com.dotmarketing.quartz.QuartzUtils.getSequentialScheduler;\n+import static java.util.Objects.requireNonNull;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import com.dotcms.IntegrationTestBase;\n+import com.dotcms.util.IntegrationTestInitService;\n+import com.dotmarketing.util.DateUtil;\n+import com.dotmarketing.util.Logger;\n+import com.google.common.collect.ImmutableMap;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.time.LocalTime;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.quartz.JobDetail;\n+import org.quartz.JobExecutionContext;\n+import org.quartz.Scheduler;\n+import org.quartz.SchedulerException;\n+import org.quartz.SimpleTrigger;\n+\n+public class DotStatefulJobTest extends IntegrationTestBase {\n+\n+    @BeforeClass\n+    public static void prepare() throws Exception {\n+        // Setting web app environment\n+        IntegrationTestInitService.getInstance().init();\n+        getSequentialScheduler().start();\n+    }\n+\n+    /**\n+     * clean up precaution\n+     * @throws SchedulerException\n+     */\n+    private void removeAnyExistingJob() throws SchedulerException {\n+        final String jobName = getJobName(MyStatefulJob.class);\n+        final String jobGroupName = getJobGroupName(MyStatefulJob.class);\n+        QuartzUtils.removeJob(jobName, jobGroupName);\n+    }\n+\n+    /**\n+     * Given scenario: We prep to trigger a bunch of tasks that must be executed sequentially (one at the time) never in parallel.\n+     * Expected Results: first all triggered tasks must be executed and completed. second their time mark must revel that none of theme overlapped.\n+     *\n+     * @throws SchedulerException\n+     * @throws ParseException\n+     * @throws ClassNotFoundException\n+     * @throws InterruptedException\n+     */\n+    @Test\n+    public void Test_Launch_Stateful_Jobs_Verify_They_Dont_Overlap_In_Time()\n+            throws SchedulerException, ParseException, ClassNotFoundException, InterruptedException {\n+\n+        //in order to avoid conflicts clean any reference that could have been left.\n+        removeAnyExistingJob();\n+\n+        //Now enqueue a few jos .. They will sleep randomly to simulate work.\n+        for (int i = 1; i <= MyStatefulJob.MAX_THREADS; i++) {\n+            MyStatefulJob.fireJob(ImmutableMap.of(\"index\", i));\n+            //Now verify the detail has been added for the present trigger we're introducing\n+            final Optional<Map<String, Object>> triggerJobDetail = DotStatefulJob\n+                    .getTriggerJobDetail(MyStatefulJob.class);\n+            assertNotNull(triggerJobDetail);\n+            assertTrue(triggerJobDetail.isPresent());\n+            final Map<String, Object> detail = triggerJobDetail.get();\n+            assertNotNull(detail);\n+            //The size of the detail should have grown as we insert new triggers.\n+            assertEquals(detail.size(), i);\n+        }\n+\n+        //Verify at least 1 job has been launched.\n+        final Optional<JobExecutionContext> jobExecutionContext = getJobExecutionContext();\n+        assertTrue(jobExecutionContext.isPresent());\n+\n+        //Now lets wait for the all the threads to complete.\n+        MyStatefulJob.countDownLatch.await();\n+\n+        //Now lets revise the execution times. Since they were supposed to run sequentially the should never overlap.\n+        final HashSet<MyStatefulJob> myStatefulJobs = new HashSet<>(MyStatefulJob.finishedJobs);\n+        final Iterator<MyStatefulJob> iterator = myStatefulJobs.iterator();\n+        while(iterator.hasNext()){\n+            final MyStatefulJob myStatefulJob = iterator.next();\n+            iterator.forEachRemaining(job -> {\n+                //They should never overlap.\n+                assertFalse(myStatefulJob.getTimeRange().overlaps(job.getTimeRange()));\n+            });\n+        }\n+    }\n+\n+    /**\n+     * This gets you the execution context for the given job-name.\n+     * @return\n+     */\n+    private Optional<JobExecutionContext> getJobExecutionContext(){\n+        final String jobName = getJobName(MyStatefulJob.class);\n+        try {\n+            final Scheduler sequentialScheduler = getSequentialScheduler();\n+            @SuppressWarnings(\"unchecked\")\n+            final List<JobExecutionContext> executingJobs = sequentialScheduler.getCurrentlyExecutingJobs();\n+            return executingJobs.stream().filter(jobExecutionContext -> {\n+                final JobDetail jobDetail = jobExecutionContext.getJobDetail();\n+                return jobDetail != null && jobName.equals(jobDetail.getName());\n+            }).findFirst();\n+        } catch (Exception e) {\n+            Logger.error(DotStatefulJobTest.class, \"Error retrieving execution context. \" , e);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * additional struct to follow execution time lapse.\n+     */\n+    public static class LocalTimeRange {\n+\n+        private final LocalTime from;\n+        private final LocalTime to;", "originalCommit": "a4327c1b9cf606e4b0fe93358f0eb0724a2c7733", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTYyNzA1MA==", "url": "https://github.com/dotCMS/core/pull/19274#discussion_r489627050", "bodyText": "Codacy found an issue: Avoid unused imports such as 'org.quartz.JobDataMap'", "author": "dev-dotcms", "createdAt": "2020-09-16T18:09:36Z", "path": "dotCMS/src/main/java/com/dotmarketing/quartz/job/DeleteUserJob.java", "diffHunk": "@@ -9,22 +11,26 @@\n import com.dotmarketing.exception.DotHibernateException;\n import com.dotmarketing.exception.DotRuntimeException;\n import com.dotmarketing.exception.DotSecurityException;\n-import com.dotmarketing.quartz.QuartzUtils;\n+import com.dotmarketing.quartz.DotStatefulJob;\n import com.dotmarketing.util.AdminLogger;\n import com.dotmarketing.util.Logger;\n+import com.google.common.collect.ImmutableMap;\n import com.liferay.portal.language.LanguageUtil;\n import com.liferay.portal.model.User;\n-\n-import org.quartz.*;\n-\n+import java.io.Serializable;\n import java.text.MessageFormat;\n-import java.util.Date;\n-import java.util.UUID;\n+import java.text.ParseException;\n+import java.util.Map;\n+import org.quartz.JobDataMap;", "originalCommit": "a4327c1b9cf606e4b0fe93358f0eb0724a2c7733", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTYyNzA3MQ==", "url": "https://github.com/dotCMS/core/pull/19274#discussion_r489627071", "bodyText": "Codacy found an issue: The String literal \"persona\" appears 5 times in this file; the first occurrence is on line 163", "author": "dev-dotcms", "createdAt": "2020-09-16T18:09:37Z", "path": "dotCMS/src/main/java/com/dotcms/graphql/business/PageAPIGraphQLTypesProvider.java", "diffHunk": "@@ -174,8 +175,12 @@\n         viewAsFields.put(\"mode\", new TypeFetcher(GraphQLString,\n                 PropertyDataFetcher.fetching((Function<ViewAsPageStatus, String>)\n                         (viewAs)->viewAs.getPageMode().name())));\n-        viewAsFields.put(\"persona\", new TypeFetcher(GraphQLTypeReference.typeRef(\"PersonaBaseType\"),\n-                new PropertyDataFetcher<ViewAsPageStatus>(\"persona\")));\n+        if(LicenseManager.getInstance().isEnterprise()) {\n+            viewAsFields\n+                    .put(\"persona\", new TypeFetcher(GraphQLTypeReference.typeRef(\"PersonaBaseType\"),", "originalCommit": "a4327c1b9cf606e4b0fe93358f0eb0724a2c7733", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTYyNzA4Mw==", "url": "https://github.com/dotCMS/core/pull/19274#discussion_r489627083", "bodyText": "Codacy found an issue: Useless parentheses.", "author": "dev-dotcms", "createdAt": "2020-09-16T18:09:38Z", "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/util/ESMappingUtilHelperTest.java", "diffHunk": "@@ -248,10 +249,27 @@ public void testAddMappingForFields(final String testCase, final Class fieldType\n                                             .toLowerCase()).get(field.toLowerCase());\n                     assertTrue(UtilMethods.isSet(mapping.get(\"type\")));\n                     assertEquals(expectedResult, mapping.get(\"type\"));\n+\n+                    //validate _dotraw fields\n+                    mapping = (Map<String, String>) esMappingAPI\n+                            .getFieldMappingAsMap(workingIndex,\n+                                    (contentType.variable() + StringPool.PERIOD + field)\n+                                            .toLowerCase() + \"_dotraw\").get(field.toLowerCase() + \"_dotraw\");\n+                    assertTrue(UtilMethods.isSet(mapping.get(\"type\")));\n+                    assertEquals(\"keyword\", mapping.get(\"type\"));\n+\n+                    //validate _text fields\n+                    mapping = (Map<String, String>) esMappingAPI\n+                            .getFieldMappingAsMap(workingIndex,\n+                                    (contentType.variable() + StringPool.PERIOD + field)", "originalCommit": "a4327c1b9cf606e4b0fe93358f0eb0724a2c7733", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTYyNzA5Mw==", "url": "https://github.com/dotCMS/core/pull/19274#discussion_r489627093", "bodyText": "Codacy found an issue: A method/constructor should not explicitly throw java.lang.Exception", "author": "dev-dotcms", "createdAt": "2020-09-16T18:09:40Z", "path": "dotCMS/src/test/java/com/dotmarketing/business/cache/provider/h22/H22CacheTest.java", "diffHunk": "@@ -268,4 +278,105 @@ public void run() {\n \n \t}\n \n+\tpublic H22Cache newCacheInstance(){\n+\t\tFile dir = Files.createTempDir();\n+\t\tdir.mkdirs();\n+\n+\t\tfinal H22Cache cache = new H22Cache(dir.getAbsolutePath());\n+\t\ttry {\n+\t\t\tcache.init();\n+\t\t} catch(Exception e) {\n+\t\t\tthrow new DotRuntimeException(e);\n+\t\t}\n+\t\treturn cache;\n+\t}\n+\n+\t/**\n+\t * Given scenario: We create a cache instance then we feed it with remove-task. The cache\n+\t * it-self internally decides whether or not (according to the capacity) if some task should be\n+\t * executed or not asynchronously\n+\t * Expected Results:  The test must match a criteria specified\n+\t * within the test-case. That helps to predict a behavior.\n+\t * In any case we should never ever get a RejectedExecutionException\n+\t */\n+\t@Test\n+\t@UseDataProvider(\"toleranceTestCases\")\n+\tpublic void Test_Exhaust_Thread_Pool(final ToleranceTestCase testCase) throws Exception {", "originalCommit": "a4327c1b9cf606e4b0fe93358f0eb0724a2c7733", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTYyNzEwMA==", "url": "https://github.com/dotCMS/core/pull/19274#discussion_r489627100", "bodyText": "Codacy found an issue: JUnit tests should include assert() or fail()", "author": "dev-dotcms", "createdAt": "2020-09-16T18:09:41Z", "path": "dotCMS/src/integration-test/java/com/dotmarketing/util/PageModeTest.java", "diffHunk": "@@ -111,6 +108,56 @@ public void test_page_mode_does_not_create_session() {\n \n     }\n \n+    /**\n+     * Back end users can have their page mode set to EDIT MODE\n+     */\n+    @Test\n+    public void test_back_end_user_can_be_set_to_LIVE() {", "originalCommit": "a4327c1b9cf606e4b0fe93358f0eb0724a2c7733", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTYyNzEyMA==", "url": "https://github.com/dotCMS/core/pull/19274#discussion_r489627120", "bodyText": "Codacy found an issue: Useless parentheses.", "author": "dev-dotcms", "createdAt": "2020-09-16T18:09:43Z", "path": "dotCMS/src/integration-test/java/com/dotmarketing/util/PageModeTest.java", "diffHunk": "@@ -83,7 +80,7 @@ public void test_back_end_user_can_be_set_to_EDIT() {\n \n         HttpServletRequest request = backEndRequest();\n \n-        assert (PageMode.get(request) == PageMode.LIVE);\n+        assert (PageMode.get(request) == PageMode.PREVIEW_MODE);", "originalCommit": "a4327c1b9cf606e4b0fe93358f0eb0724a2c7733", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTYyNzEyNg==", "url": "https://github.com/dotCMS/core/pull/19274#discussion_r489627126", "bodyText": "Codacy found an issue: Avoid unused local variables such as 'contentlet'.", "author": "dev-dotcms", "createdAt": "2020-09-16T18:09:44Z", "path": "dotCMS/src/integration-test/java/com/dotcms/rest/elasticsearch/ESContentResourcePortletTest.java", "diffHunk": "@@ -184,6 +193,82 @@ public void testSearch(final TestCase testCase) throws Exception {\n         }\n     }\n \n+    /**\n+     * Method to test: {@link ESContentResourcePortlet#search(HttpServletRequest, HttpServletResponse, String, String, boolean, boolean)}\n+     * Given scenario: Create a Category with 3 levels of depth:\n+     *          Parent Category\n+     *                  Child Category\n+     *                          Grand Child Category\n+     *\n+     *                  Create a Content Type with a Category field, and a contentlet of it. To\n+     *                  the contentlet add the Grand Child Category.\n+     * Expected result: json response must include the grand child category info\n+     */\n+    @Test\n+    public void test_search_includeGrandChildCategory_success()\n+            throws Exception {\n+        final long currentTime = System.currentTimeMillis();\n+        //Create Parent Category.\n+        final Category parentCategory = new CategoryDataGen()\n+                .setCategoryName(\"CT-Category-Parent\"+currentTime)\n+                .setKey(\"parent\"+currentTime)\n+                .setCategoryVelocityVarName(\"parent\"+currentTime)\n+                .nextPersisted();\n+\n+        //Create First Child Category.\n+        final Category childCategoryA = new CategoryDataGen()\n+                .setCategoryName(\"CT-Category-A\"+currentTime)\n+                .setKey(\"categoryA\"+currentTime)\n+                .setCategoryVelocityVarName(\"categoryA\"+currentTime)\n+                .next();\n+\n+        //Second Level Category.\n+        final Category childCategoryA_1 = new CategoryDataGen()\n+                .setCategoryName(\"CT-Category-A-1\"+currentTime)\n+                .setKey(\"categoryA-1\"+currentTime)\n+                .setCategoryVelocityVarName(\"categoryA-1\"+currentTime)\n+                .next();\n+\n+        APILocator.getCategoryAPI().save(parentCategory, childCategoryA, user, false);\n+        APILocator.getCategoryAPI().save(childCategoryA, childCategoryA_1, user, false);\n+\n+        // Content Type with category field\n+        final List<Field> fields = new ArrayList<>();\n+        fields.add(new FieldDataGen().name(\"Title\").velocityVarName(\"title\").next());\n+        fields.add(new FieldDataGen().type(CategoryField.class)\n+                .name(parentCategory.getCategoryName()).velocityVarName(parentCategory.getCategoryVelocityVarName())\n+                .values(parentCategory.getInode()).next());\n+        final ContentType contentType = new ContentTypeDataGen().fields(fields).nextPersisted();\n+\n+        // Save content with grand child category\n+        final Contentlet contentlet = new ContentletDataGen(contentType.id())", "originalCommit": "a4327c1b9cf606e4b0fe93358f0eb0724a2c7733", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTYyNzEzNg==", "url": "https://github.com/dotCMS/core/pull/19274#discussion_r489627136", "bodyText": "Codacy found an issue: Useless parentheses.", "author": "dev-dotcms", "createdAt": "2020-09-16T18:09:45Z", "path": "dotCMS/src/integration-test/java/com/dotmarketing/util/PageModeTest.java", "diffHunk": "@@ -111,6 +108,56 @@ public void test_page_mode_does_not_create_session() {\n \n     }\n \n+    /**\n+     * Back end users can have their page mode set to EDIT MODE\n+     */\n+    @Test\n+    public void test_back_end_user_can_be_set_to_LIVE() {\n+\n+        HttpServletRequest request = backEndRequest();\n+\n+        assert (PageMode.get(request) == PageMode.PREVIEW_MODE);\n+\n+        PageMode.setPageMode(request, PageMode.LIVE);\n+\n+        assert (PageMode.get(request) == PageMode.LIVE);\n+\n+    }\n+\n+\n+    /**\n+     * Testing order of reading PAGE_MODE for a backend user, It should be like this:\n+     * 1. request parameter\n+     * 2. request attribute\n+     * 3. session\n+     * 4. default = PREVIEW_MODE\n+     * we should respect the request parameter,\n+     * then the request attribute, then the session, and finally PREVIEW_MODE if we don't have anything\n+     */\n+    @Test\n+    public void test_order_of_reading_pagemode() {\n+\n+        // PREVIEW_MODE if there is no mode and back end user\n+        HttpServletRequest request = new MockSessionRequest(backEndRequest()).request();\n+        assert (PageMode.get(request) == PageMode.PREVIEW_MODE);\n+\n+        // session is last fallback\n+        request.getSession().setAttribute(com.dotmarketing.util.WebKeys.PAGE_MODE_SESSION,\n+                PageMode.ADMIN_MODE);\n+        assert (PageMode.get(request) == PageMode.ADMIN_MODE);", "originalCommit": "a4327c1b9cf606e4b0fe93358f0eb0724a2c7733", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTYyNzE0Ng==", "url": "https://github.com/dotCMS/core/pull/19274#discussion_r489627146", "bodyText": "Codacy found an issue: Avoid catching generic exceptions such as NullPointerException, RuntimeException, Exception in try-catch block", "author": "dev-dotcms", "createdAt": "2020-09-16T18:09:46Z", "path": "dotCMS/src/test/java/com/dotmarketing/business/cache/provider/h22/H22CacheTest.java", "diffHunk": "@@ -268,4 +278,105 @@ public void run() {\n \n \t}\n \n+\tpublic H22Cache newCacheInstance(){\n+\t\tFile dir = Files.createTempDir();\n+\t\tdir.mkdirs();\n+\n+\t\tfinal H22Cache cache = new H22Cache(dir.getAbsolutePath());\n+\t\ttry {\n+\t\t\tcache.init();\n+\t\t} catch(Exception e) {", "originalCommit": "a4327c1b9cf606e4b0fe93358f0eb0724a2c7733", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTYyNzE1MQ==", "url": "https://github.com/dotCMS/core/pull/19274#discussion_r489627151", "bodyText": "Codacy found an issue: Unnecessary use of fully qualified name 'com.dotmarketing.util.WebKeys.PAGE_MODE_PARAMETER' due to existing same package import 'com.dotmarketing.util.*'", "author": "dev-dotcms", "createdAt": "2020-09-16T18:09:48Z", "path": "dotCMS/src/integration-test/java/com/dotmarketing/util/PageModeTest.java", "diffHunk": "@@ -111,6 +108,56 @@ public void test_page_mode_does_not_create_session() {\n \n     }\n \n+    /**\n+     * Back end users can have their page mode set to EDIT MODE\n+     */\n+    @Test\n+    public void test_back_end_user_can_be_set_to_LIVE() {\n+\n+        HttpServletRequest request = backEndRequest();\n+\n+        assert (PageMode.get(request) == PageMode.PREVIEW_MODE);\n+\n+        PageMode.setPageMode(request, PageMode.LIVE);\n+\n+        assert (PageMode.get(request) == PageMode.LIVE);\n+\n+    }\n+\n+\n+    /**\n+     * Testing order of reading PAGE_MODE for a backend user, It should be like this:\n+     * 1. request parameter\n+     * 2. request attribute\n+     * 3. session\n+     * 4. default = PREVIEW_MODE\n+     * we should respect the request parameter,\n+     * then the request attribute, then the session, and finally PREVIEW_MODE if we don't have anything\n+     */\n+    @Test\n+    public void test_order_of_reading_pagemode() {\n+\n+        // PREVIEW_MODE if there is no mode and back end user\n+        HttpServletRequest request = new MockSessionRequest(backEndRequest()).request();\n+        assert (PageMode.get(request) == PageMode.PREVIEW_MODE);\n+\n+        // session is last fallback\n+        request.getSession().setAttribute(com.dotmarketing.util.WebKeys.PAGE_MODE_SESSION,\n+                PageMode.ADMIN_MODE);\n+        assert (PageMode.get(request) == PageMode.ADMIN_MODE);\n+\n+        // request.attribute overrides session\n+        request.setAttribute(com.dotmarketing.util.WebKeys.PAGE_MODE_PARAMETER, PageMode.EDIT_MODE);", "originalCommit": "a4327c1b9cf606e4b0fe93358f0eb0724a2c7733", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTYyNzE2Mw==", "url": "https://github.com/dotCMS/core/pull/19274#discussion_r489627163", "bodyText": "Codacy found an issue: Unnecessary use of fully qualified name 'Assert.assertTrue' due to existing static import 'org.junit.Assert.assertTrue'", "author": "dev-dotcms", "createdAt": "2020-09-16T18:09:49Z", "path": "dotCMS/src/integration-test/java/com/dotmarketing/portlets/categories/business/CategoryAPITest.java", "diffHunk": "@@ -1084,4 +1085,150 @@ private ContentType createContentTypeWithCatAndTextField(final Category parentCa\n \n         return APILocator.getContentTypeAPI(user).find(type.inode());\n     }\n+\n+    /**\n+     * Method to test: {@link CategoryAPI#isParent(Category, Category, User, boolean)}\n+     * Given scenario: Create a Category with 3 levels of depth:\n+     *          Parent Category\n+     *                  Child Category\n+     *                          Grand Child Category\n+     *\n+     *                  And check if the grand child category belongs to the parent category\n+     * Expected result: true, since the grand child category is a sub sub category\n+     */\n+    @Test\n+    public void test_isParent_givenGrandChildCategoryBelongsToParentCategory_returnTrue()\n+            throws DotSecurityException, DotDataException {\n+        final List<Category> categoriesToDelete = Lists.newArrayList();\n+        final CategoryAPI categoryAPI = APILocator.getCategoryAPI();\n+        try {\n+            //Create Parent Category.\n+            final Category parentCategory = new CategoryDataGen()\n+                    .setCategoryName(\"CT-Category-Parent\")\n+                    .setKey(\"parent\")\n+                    .setCategoryVelocityVarName(\"parent\")\n+                    .nextPersisted();\n+\n+            categoriesToDelete.add(parentCategory);\n+\n+            //Create First Child Category.\n+            final Category childCategoryA = new CategoryDataGen()\n+                    .setCategoryName(\"CT-Category-A\")\n+                    .setKey(\"categoryA\")\n+                    .setCategoryVelocityVarName(\"categoryA\")\n+                    .next();\n+\n+            categoriesToDelete.add(childCategoryA);\n+\n+            //Second Level Category.\n+            Category childCategoryA_1 = new CategoryDataGen()\n+                    .setCategoryName(\"CT-Category-A-1\")\n+                    .setKey(\"categoryA-1\")\n+                    .setCategoryVelocityVarName(\"categoryA-1\")\n+                    .next();\n+\n+            categoriesToDelete.add(childCategoryA_1);\n+\n+            categoryAPI.save(parentCategory, childCategoryA, user, false);\n+            categoryAPI.save(childCategoryA, childCategoryA_1, user, false);\n+\n+            Assert.assertTrue(categoryAPI.isParent(childCategoryA_1,parentCategory,user,true));", "originalCommit": "a4327c1b9cf606e4b0fe93358f0eb0724a2c7733", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTYyNzE3OQ==", "url": "https://github.com/dotCMS/core/pull/19274#discussion_r489627179", "bodyText": "Codacy found an issue: A catch statement should never catch throwable since it includes errors.", "author": "dev-dotcms", "createdAt": "2020-09-16T18:09:50Z", "path": "dotCMS/src/main/java/com/dotmarketing/quartz/job/DeleteUserJob.java", "diffHunk": "@@ -34,47 +40,41 @@ public DeleteUserJob() {\n         notfAPI = APILocator.getNotificationAPI();\n     }\n \n-    public static void triggerDeleteUserJob(User userToDelete, User replacementUser, User user,\n-                                            boolean respectFrontEndRoles) {\n-        JobDataMap dataMap = new JobDataMap();\n-        dataMap.put(\"userToDelete\", userToDelete);\n-        dataMap.put(\"replacementUser\", replacementUser);\n-        dataMap.put(\"user\", user);\n-        dataMap.put(\"respectFrontEndRoles\", respectFrontEndRoles);\n+    public static void triggerDeleteUserJob(final User userToDelete, final User replacementUser, final User user,\n+                                           final boolean respectFrontEndRoles) {\n \n-        String randomID = UUID.randomUUID().toString();\n+        final Map<String, Serializable> nextExecutionData = ImmutableMap\n+                .of(\"userToDelete\", userToDelete,\n+                        \"replacementUser\", replacementUser,\n+                        \"user\", user,\n+                        \"respectFrontEndRoles\", respectFrontEndRoles);\n \n-        JobDetail jd = new JobDetail(\"DeleteUserJob-\" + randomID, \"delete_user_jobs\", DeleteUserJob.class);\n-        jd.setJobDataMap(dataMap);\n-        jd.setDurability(false);\n-        jd.setVolatility(false);\n-        jd.setRequestsRecovery(true);\n-\n-        long startTime = System.currentTimeMillis();\n-        SimpleTrigger trigger = new SimpleTrigger(\"deleteUserTrigger-\" + randomID, \"delete_user_triggers\",\n-            new Date(startTime));\n \n         try {\n-            Scheduler sched = QuartzUtils.getSequentialScheduler();\n-            UserAPI userAPI = APILocator.getUserAPI();\n-            NotificationAPI notAPI = APILocator.getNotificationAPI();\n+            final UserAPI userAPI = APILocator.getUserAPI();\n+            final NotificationAPI notAPI = APILocator.getNotificationAPI();\n \n-            String deleteInProgress = MessageFormat.format(LanguageUtil.get(user,\n+            final String deleteInProgress = MessageFormat.format(LanguageUtil.get(user,\n                 \"com.dotmarketing.business.UserAPI.delete.inProgress\"),\n                 userToDelete.getUserId() + \"/\" + userToDelete.getFullName());\n \n-            synchronized (userToDelete.getUserId().intern()) {\n-                User freshUser = userAPI.loadUserById(userToDelete.getUserId());\n-                if(! freshUser.isDeleteInProgress()) {\n+            final IdentifierStripedLock lockManager = DotConcurrentFactory.getInstance().getIdentifierStripedLock();\n+            lockManager.tryLock(userToDelete.getUserId(), () -> {\n+                final User freshUser = userAPI.loadUserById(userToDelete.getUserId());\n+                if (!freshUser.isDeleteInProgress()) {\n                     userAPI.markToDelete(userToDelete);\n-                    sched.scheduleJob(jd, trigger);\n+                    try {\n+                        DotStatefulJob.enqueueTrigger(nextExecutionData, DeleteUserJob.class);\n+                    }catch (ParseException | SchedulerException | ClassNotFoundException e){\n+                        Logger.error(DeleteUserJob.class, \"Error scheduling DeleteUserJob\", e);\n+                        throw new DotRuntimeException(\"Error scheduling DeleteUserJob\", e);\n+                    }\n                 } else {\n                     notAPI.info(deleteInProgress, user.getUserId());\n                 }\n-            }\n+            });\n \n-\n-        } catch (SchedulerException e) {\n+        } catch (Throwable e) {", "originalCommit": "a4327c1b9cf606e4b0fe93358f0eb0724a2c7733", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTYyNzE4OA==", "url": "https://github.com/dotCMS/core/pull/19274#discussion_r489627188", "bodyText": "Codacy found an issue: Unnecessary use of fully qualified name 'Assert.assertFalse' due to existing static import 'org.junit.Assert.assertFalse'", "author": "dev-dotcms", "createdAt": "2020-09-16T18:09:51Z", "path": "dotCMS/src/integration-test/java/com/dotmarketing/portlets/categories/business/CategoryAPITest.java", "diffHunk": "@@ -1084,4 +1085,150 @@ private ContentType createContentTypeWithCatAndTextField(final Category parentCa\n \n         return APILocator.getContentTypeAPI(user).find(type.inode());\n     }\n+\n+    /**\n+     * Method to test: {@link CategoryAPI#isParent(Category, Category, User, boolean)}\n+     * Given scenario: Create a Category with 3 levels of depth:\n+     *          Parent Category\n+     *                  Child Category\n+     *                          Grand Child Category\n+     *\n+     *                  And check if the grand child category belongs to the parent category\n+     * Expected result: true, since the grand child category is a sub sub category\n+     */\n+    @Test\n+    public void test_isParent_givenGrandChildCategoryBelongsToParentCategory_returnTrue()\n+            throws DotSecurityException, DotDataException {\n+        final List<Category> categoriesToDelete = Lists.newArrayList();\n+        final CategoryAPI categoryAPI = APILocator.getCategoryAPI();\n+        try {\n+            //Create Parent Category.\n+            final Category parentCategory = new CategoryDataGen()\n+                    .setCategoryName(\"CT-Category-Parent\")\n+                    .setKey(\"parent\")\n+                    .setCategoryVelocityVarName(\"parent\")\n+                    .nextPersisted();\n+\n+            categoriesToDelete.add(parentCategory);\n+\n+            //Create First Child Category.\n+            final Category childCategoryA = new CategoryDataGen()\n+                    .setCategoryName(\"CT-Category-A\")\n+                    .setKey(\"categoryA\")\n+                    .setCategoryVelocityVarName(\"categoryA\")\n+                    .next();\n+\n+            categoriesToDelete.add(childCategoryA);\n+\n+            //Second Level Category.\n+            Category childCategoryA_1 = new CategoryDataGen()\n+                    .setCategoryName(\"CT-Category-A-1\")\n+                    .setKey(\"categoryA-1\")\n+                    .setCategoryVelocityVarName(\"categoryA-1\")\n+                    .next();\n+\n+            categoriesToDelete.add(childCategoryA_1);\n+\n+            categoryAPI.save(parentCategory, childCategoryA, user, false);\n+            categoryAPI.save(childCategoryA, childCategoryA_1, user, false);\n+\n+            Assert.assertTrue(categoryAPI.isParent(childCategoryA_1,parentCategory,user,true));\n+\n+\n+        }finally {\n+            for (final Category category : categoriesToDelete) {\n+                categoryAPI.delete(category, user, false);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method to test: {@link CategoryAPI#isParent(Category, Category, User, boolean)}\n+     * Given scenario: Create a Category with 3 levels of depth:\n+     *          Parent Category\n+     *                  Child Category\n+     *                          Grand Child Category\n+     *\n+     *           Parent Category 2\n+     *      *                  Child Category 2\n+     *      *                          Grand Child Category 2\n+     *\n+     *                  And check if the grand child category 2 belongs to the parent category\n+     * Expected result: false\n+     */\n+    @Test\n+    public void test_isParent_givenGrandChildCategoryThatNoBelongsToParentCategory_returnFalse()\n+            throws DotSecurityException, DotDataException {\n+        List<Category> categoriesToDelete = Lists.newArrayList();\n+        final CategoryAPI categoryAPI = APILocator.getCategoryAPI();\n+        try {\n+            //Create Parent Category.\n+            final Category parentCategory = new CategoryDataGen()\n+                    .setCategoryName(\"CT-Category-Parent\")\n+                    .setKey(\"parent\")\n+                    .setCategoryVelocityVarName(\"parent\")\n+                    .nextPersisted();\n+\n+            categoriesToDelete.add(parentCategory);\n+\n+            //Create First Child Category.\n+            final Category childCategoryA = new CategoryDataGen()\n+                    .setCategoryName(\"CT-Category-A\")\n+                    .setKey(\"categoryA\")\n+                    .setCategoryVelocityVarName(\"categoryA\")\n+                    .next();\n+\n+            categoriesToDelete.add(childCategoryA);\n+\n+            //Second Level Category.\n+            Category childCategoryA_1 = new CategoryDataGen()\n+                    .setCategoryName(\"CT-Category-A-1\")\n+                    .setKey(\"categoryA-1\")\n+                    .setCategoryVelocityVarName(\"categoryA-1\")\n+                    .next();\n+\n+            categoriesToDelete.add(childCategoryA_1);\n+\n+            categoryAPI.save(parentCategory, childCategoryA, user, false);\n+            categoryAPI.save(childCategoryA, childCategoryA_1, user, false);\n+\n+            //Create Parent Category 2.\n+            final Category parentCategory2 = new CategoryDataGen()\n+                    .setCategoryName(\"CT-Category-Parent2\")\n+                    .setKey(\"parent2\")\n+                    .setCategoryVelocityVarName(\"parent2\")\n+                    .nextPersisted();\n+\n+            categoriesToDelete.add(parentCategory2);\n+\n+            //Create First Child Category 2.\n+            final Category childCategoryA2 = new CategoryDataGen()\n+                    .setCategoryName(\"CT-Category-A2\")\n+                    .setKey(\"categoryA2\")\n+                    .setCategoryVelocityVarName(\"categoryA2\")\n+                    .next();\n+\n+            categoriesToDelete.add(childCategoryA2);\n+\n+            //Second Level Category 2.\n+            Category childCategoryA_2 = new CategoryDataGen()\n+                    .setCategoryName(\"CT-Category-A-2\")\n+                    .setKey(\"categoryA-2\")\n+                    .setCategoryVelocityVarName(\"categoryA-2\")\n+                    .next();\n+\n+            categoriesToDelete.add(childCategoryA_2);\n+\n+            categoryAPI.save(parentCategory2, childCategoryA2, user, false);\n+            categoryAPI.save(childCategoryA2, childCategoryA_2, user, false);\n+\n+            Assert.assertFalse(categoryAPI.isParent(childCategoryA_2,parentCategory,user,true));", "originalCommit": "a4327c1b9cf606e4b0fe93358f0eb0724a2c7733", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTYyNzE5NA==", "url": "https://github.com/dotCMS/core/pull/19274#discussion_r489627194", "bodyText": "Codacy found an issue: Useless parentheses.", "author": "dev-dotcms", "createdAt": "2020-09-16T18:09:52Z", "path": "dotCMS/src/integration-test/java/com/dotcms/vanityurl/business/VanityUrlAPITest.java", "diffHunk": "@@ -73,6 +72,65 @@ public static void prepare() throws Exception {\n     }\n \n     \n+    /**\n+     * tests that we correctly order the cached vanites.  This ordering is done\n+     * by the findInDb method, which should return a hosts' vanities in order asc\n+     * \n+     * It also tests that the vanityUrlAPI.resolveVanityUrl returns\n+     * the first matching vanity in the list\n+     * \n+     * @throws Exception\n+     */\n+    @Test\n+    public void testing_vanityurl_ordering() throws Exception {\n+        final String baseUri = '/' + UUIDGenerator.shorty();\n+        final String site = defaultHost.getIdentifier();\n+        final int action = 200;\n+        final int numberOfTestVanities = 10;\n+        \n+        \n+        for (int i = numberOfTestVanities; i > 0; i--) {\n+            final String title = \"VanityURLOrder\" + i;\n+            final int randomOrder = new Random().nextInt(100);\n+            Contentlet vanity = filtersUtil.createVanityUrl(title, site, baseUri, baseUri,\n+                            action, randomOrder, defaultLanguage.getId());\n+            filtersUtil.publishVanityUrl(vanity);\n+        }\n+\n+\n+        // this list of CachedVanityUrl is ordered based on the order of the vanities - asc\n+        List<CachedVanityUrl> cachedVanities = vanityUrlAPI.findInDb(defaultHost, defaultLanguage)\n+                        .stream()\n+                        .filter(v -> v.forwardTo.equals(baseUri))\n+                        .collect(Collectors.toList());\n+\n+        // testing we have all the vanities we just saved\n+        assert(cachedVanities.size() == numberOfTestVanities);", "originalCommit": "a4327c1b9cf606e4b0fe93358f0eb0724a2c7733", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTYyNzIwOQ==", "url": "https://github.com/dotCMS/core/pull/19274#discussion_r489627209", "bodyText": "Codacy found an issue: Useless parentheses.", "author": "dev-dotcms", "createdAt": "2020-09-16T18:09:53Z", "path": "dotCMS/src/integration-test/java/com/dotcms/vanityurl/business/VanityUrlAPITest.java", "diffHunk": "@@ -73,6 +72,65 @@ public static void prepare() throws Exception {\n     }\n \n     \n+    /**\n+     * tests that we correctly order the cached vanites.  This ordering is done\n+     * by the findInDb method, which should return a hosts' vanities in order asc\n+     * \n+     * It also tests that the vanityUrlAPI.resolveVanityUrl returns\n+     * the first matching vanity in the list\n+     * \n+     * @throws Exception\n+     */\n+    @Test\n+    public void testing_vanityurl_ordering() throws Exception {\n+        final String baseUri = '/' + UUIDGenerator.shorty();\n+        final String site = defaultHost.getIdentifier();\n+        final int action = 200;\n+        final int numberOfTestVanities = 10;\n+        \n+        \n+        for (int i = numberOfTestVanities; i > 0; i--) {\n+            final String title = \"VanityURLOrder\" + i;\n+            final int randomOrder = new Random().nextInt(100);\n+            Contentlet vanity = filtersUtil.createVanityUrl(title, site, baseUri, baseUri,\n+                            action, randomOrder, defaultLanguage.getId());\n+            filtersUtil.publishVanityUrl(vanity);\n+        }\n+\n+\n+        // this list of CachedVanityUrl is ordered based on the order of the vanities - asc\n+        List<CachedVanityUrl> cachedVanities = vanityUrlAPI.findInDb(defaultHost, defaultLanguage)\n+                        .stream()\n+                        .filter(v -> v.forwardTo.equals(baseUri))\n+                        .collect(Collectors.toList());\n+\n+        // testing we have all the vanities we just saved\n+        assert(cachedVanities.size() == numberOfTestVanities);\n+\n+        \n+        // testing they have different order\n+        assert(cachedVanities.get(0).order < cachedVanities.get(numberOfTestVanities-1).order);\n+        \n+\n+\n+        CachedVanityUrl previousCachedVanity = cachedVanities.get(0);\n+        \n+        // the vanities are in order, from lowest to highest\n+        for (final CachedVanityUrl cached : cachedVanities) {\n+            assert(cached.order >= previousCachedVanity.order);", "originalCommit": "a4327c1b9cf606e4b0fe93358f0eb0724a2c7733", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTYyNzIyNA==", "url": "https://github.com/dotCMS/core/pull/19274#discussion_r489627224", "bodyText": "Codacy found an issue: JUnit tests should include assert() or fail()", "author": "dev-dotcms", "createdAt": "2020-09-16T18:09:54Z", "path": "dotCMS/src/integration-test/java/com/dotcms/vanityurl/business/VanityUrlAPITest.java", "diffHunk": "@@ -73,6 +72,65 @@ public static void prepare() throws Exception {\n     }\n \n     \n+    /**\n+     * tests that we correctly order the cached vanites.  This ordering is done\n+     * by the findInDb method, which should return a hosts' vanities in order asc\n+     * \n+     * It also tests that the vanityUrlAPI.resolveVanityUrl returns\n+     * the first matching vanity in the list\n+     * \n+     * @throws Exception\n+     */\n+    @Test\n+    public void testing_vanityurl_ordering() throws Exception {", "originalCommit": "a4327c1b9cf606e4b0fe93358f0eb0724a2c7733", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTYyNzIzNQ==", "url": "https://github.com/dotCMS/core/pull/19274#discussion_r489627235", "bodyText": "Codacy found an issue: Useless parentheses.", "author": "dev-dotcms", "createdAt": "2020-09-16T18:09:55Z", "path": "dotCMS/src/integration-test/java/com/dotcms/vanityurl/business/VanityUrlAPITest.java", "diffHunk": "@@ -73,6 +72,65 @@ public static void prepare() throws Exception {\n     }\n \n     \n+    /**\n+     * tests that we correctly order the cached vanites.  This ordering is done\n+     * by the findInDb method, which should return a hosts' vanities in order asc\n+     * \n+     * It also tests that the vanityUrlAPI.resolveVanityUrl returns\n+     * the first matching vanity in the list\n+     * \n+     * @throws Exception\n+     */\n+    @Test\n+    public void testing_vanityurl_ordering() throws Exception {\n+        final String baseUri = '/' + UUIDGenerator.shorty();\n+        final String site = defaultHost.getIdentifier();\n+        final int action = 200;\n+        final int numberOfTestVanities = 10;\n+        \n+        \n+        for (int i = numberOfTestVanities; i > 0; i--) {\n+            final String title = \"VanityURLOrder\" + i;\n+            final int randomOrder = new Random().nextInt(100);\n+            Contentlet vanity = filtersUtil.createVanityUrl(title, site, baseUri, baseUri,\n+                            action, randomOrder, defaultLanguage.getId());\n+            filtersUtil.publishVanityUrl(vanity);\n+        }\n+\n+\n+        // this list of CachedVanityUrl is ordered based on the order of the vanities - asc\n+        List<CachedVanityUrl> cachedVanities = vanityUrlAPI.findInDb(defaultHost, defaultLanguage)\n+                        .stream()\n+                        .filter(v -> v.forwardTo.equals(baseUri))\n+                        .collect(Collectors.toList());\n+\n+        // testing we have all the vanities we just saved\n+        assert(cachedVanities.size() == numberOfTestVanities);\n+\n+        \n+        // testing they have different order\n+        assert(cachedVanities.get(0).order < cachedVanities.get(numberOfTestVanities-1).order);", "originalCommit": "a4327c1b9cf606e4b0fe93358f0eb0724a2c7733", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTYyNzI0Mg==", "url": "https://github.com/dotCMS/core/pull/19274#discussion_r489627242", "bodyText": "Codacy found an issue: Avoid catching generic exceptions such as NullPointerException, RuntimeException, Exception in try-catch block", "author": "dev-dotcms", "createdAt": "2020-09-16T18:09:56Z", "path": "dotCMS/src/integration-test/java/com/dotmarketing/quartz/DotStatefulJobTest.java", "diffHunk": "@@ -0,0 +1,234 @@\n+package com.dotmarketing.quartz;\n+\n+import static com.dotmarketing.quartz.DotStatefulJob.getJobDescription;\n+import static com.dotmarketing.quartz.DotStatefulJob.getJobGroupName;\n+import static com.dotmarketing.quartz.DotStatefulJob.getJobName;\n+import static com.dotmarketing.quartz.DotStatefulJob.getTriggerGroupName;\n+import static com.dotmarketing.quartz.QuartzUtils.getSequentialScheduler;\n+import static java.util.Objects.requireNonNull;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import com.dotcms.IntegrationTestBase;\n+import com.dotcms.util.IntegrationTestInitService;\n+import com.dotmarketing.util.DateUtil;\n+import com.dotmarketing.util.Logger;\n+import com.google.common.collect.ImmutableMap;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.time.LocalTime;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.quartz.JobDetail;\n+import org.quartz.JobExecutionContext;\n+import org.quartz.Scheduler;\n+import org.quartz.SchedulerException;\n+import org.quartz.SimpleTrigger;\n+\n+public class DotStatefulJobTest extends IntegrationTestBase {\n+\n+    @BeforeClass\n+    public static void prepare() throws Exception {\n+        // Setting web app environment\n+        IntegrationTestInitService.getInstance().init();\n+        getSequentialScheduler().start();\n+    }\n+\n+    /**\n+     * clean up precaution\n+     * @throws SchedulerException\n+     */\n+    private void removeAnyExistingJob() throws SchedulerException {\n+        final String jobName = getJobName(MyStatefulJob.class);\n+        final String jobGroupName = getJobGroupName(MyStatefulJob.class);\n+        QuartzUtils.removeJob(jobName, jobGroupName);\n+    }\n+\n+    /**\n+     * Given scenario: We prep to trigger a bunch of tasks that must be executed sequentially (one at the time) never in parallel.\n+     * Expected Results: first all triggered tasks must be executed and completed. second their time mark must revel that none of theme overlapped.\n+     *\n+     * @throws SchedulerException\n+     * @throws ParseException\n+     * @throws ClassNotFoundException\n+     * @throws InterruptedException\n+     */\n+    @Test\n+    public void Test_Launch_Stateful_Jobs_Verify_They_Dont_Overlap_In_Time()\n+            throws SchedulerException, ParseException, ClassNotFoundException, InterruptedException {\n+\n+        //in order to avoid conflicts clean any reference that could have been left.\n+        removeAnyExistingJob();\n+\n+        //Now enqueue a few jos .. They will sleep randomly to simulate work.\n+        for (int i = 1; i <= MyStatefulJob.MAX_THREADS; i++) {\n+            MyStatefulJob.fireJob(ImmutableMap.of(\"index\", i));\n+            //Now verify the detail has been added for the present trigger we're introducing\n+            final Optional<Map<String, Object>> triggerJobDetail = DotStatefulJob\n+                    .getTriggerJobDetail(MyStatefulJob.class);\n+            assertNotNull(triggerJobDetail);\n+            assertTrue(triggerJobDetail.isPresent());\n+            final Map<String, Object> detail = triggerJobDetail.get();\n+            assertNotNull(detail);\n+            //The size of the detail should have grown as we insert new triggers.\n+            assertEquals(detail.size(), i);\n+        }\n+\n+        //Verify at least 1 job has been launched.\n+        final Optional<JobExecutionContext> jobExecutionContext = getJobExecutionContext();\n+        assertTrue(jobExecutionContext.isPresent());\n+\n+        //Now lets wait for the all the threads to complete.\n+        MyStatefulJob.countDownLatch.await();\n+\n+        //Now lets revise the execution times. Since they were supposed to run sequentially the should never overlap.\n+        final HashSet<MyStatefulJob> myStatefulJobs = new HashSet<>(MyStatefulJob.finishedJobs);\n+        final Iterator<MyStatefulJob> iterator = myStatefulJobs.iterator();\n+        while(iterator.hasNext()){\n+            final MyStatefulJob myStatefulJob = iterator.next();\n+            iterator.forEachRemaining(job -> {\n+                //They should never overlap.\n+                assertFalse(myStatefulJob.getTimeRange().overlaps(job.getTimeRange()));\n+            });\n+        }\n+    }\n+\n+    /**\n+     * This gets you the execution context for the given job-name.\n+     * @return\n+     */\n+    private Optional<JobExecutionContext> getJobExecutionContext(){\n+        final String jobName = getJobName(MyStatefulJob.class);\n+        try {\n+            final Scheduler sequentialScheduler = getSequentialScheduler();\n+            @SuppressWarnings(\"unchecked\")\n+            final List<JobExecutionContext> executingJobs = sequentialScheduler.getCurrentlyExecutingJobs();\n+            return executingJobs.stream().filter(jobExecutionContext -> {\n+                final JobDetail jobDetail = jobExecutionContext.getJobDetail();\n+                return jobDetail != null && jobName.equals(jobDetail.getName());\n+            }).findFirst();\n+        } catch (Exception e) {", "originalCommit": "a4327c1b9cf606e4b0fe93358f0eb0724a2c7733", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTYyNzI1NQ==", "url": "https://github.com/dotCMS/core/pull/19274#discussion_r489627255", "bodyText": "Codacy found an issue: JUnit tests should include assert() or fail()", "author": "dev-dotcms", "createdAt": "2020-09-16T18:09:57Z", "path": "dotCMS/src/integration-test/java/com/dotmarketing/util/PageModeTest.java", "diffHunk": "@@ -111,6 +108,56 @@ public void test_page_mode_does_not_create_session() {\n \n     }\n \n+    /**\n+     * Back end users can have their page mode set to EDIT MODE\n+     */\n+    @Test\n+    public void test_back_end_user_can_be_set_to_LIVE() {\n+\n+        HttpServletRequest request = backEndRequest();\n+\n+        assert (PageMode.get(request) == PageMode.PREVIEW_MODE);\n+\n+        PageMode.setPageMode(request, PageMode.LIVE);\n+\n+        assert (PageMode.get(request) == PageMode.LIVE);\n+\n+    }\n+\n+\n+    /**\n+     * Testing order of reading PAGE_MODE for a backend user, It should be like this:\n+     * 1. request parameter\n+     * 2. request attribute\n+     * 3. session\n+     * 4. default = PREVIEW_MODE\n+     * we should respect the request parameter,\n+     * then the request attribute, then the session, and finally PREVIEW_MODE if we don't have anything\n+     */\n+    @Test\n+    public void test_order_of_reading_pagemode() {", "originalCommit": "a4327c1b9cf606e4b0fe93358f0eb0724a2c7733", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTYyNzI3Mw==", "url": "https://github.com/dotCMS/core/pull/19274#discussion_r489627273", "bodyText": "Codacy found an issue: Avoid variables with short names like to", "author": "dev-dotcms", "createdAt": "2020-09-16T18:09:59Z", "path": "dotCMS/src/integration-test/java/com/dotmarketing/quartz/DotStatefulJobTest.java", "diffHunk": "@@ -0,0 +1,234 @@\n+package com.dotmarketing.quartz;\n+\n+import static com.dotmarketing.quartz.DotStatefulJob.getJobDescription;\n+import static com.dotmarketing.quartz.DotStatefulJob.getJobGroupName;\n+import static com.dotmarketing.quartz.DotStatefulJob.getJobName;\n+import static com.dotmarketing.quartz.DotStatefulJob.getTriggerGroupName;\n+import static com.dotmarketing.quartz.QuartzUtils.getSequentialScheduler;\n+import static java.util.Objects.requireNonNull;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import com.dotcms.IntegrationTestBase;\n+import com.dotcms.util.IntegrationTestInitService;\n+import com.dotmarketing.util.DateUtil;\n+import com.dotmarketing.util.Logger;\n+import com.google.common.collect.ImmutableMap;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.time.LocalTime;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.quartz.JobDetail;\n+import org.quartz.JobExecutionContext;\n+import org.quartz.Scheduler;\n+import org.quartz.SchedulerException;\n+import org.quartz.SimpleTrigger;\n+\n+public class DotStatefulJobTest extends IntegrationTestBase {\n+\n+    @BeforeClass\n+    public static void prepare() throws Exception {\n+        // Setting web app environment\n+        IntegrationTestInitService.getInstance().init();\n+        getSequentialScheduler().start();\n+    }\n+\n+    /**\n+     * clean up precaution\n+     * @throws SchedulerException\n+     */\n+    private void removeAnyExistingJob() throws SchedulerException {\n+        final String jobName = getJobName(MyStatefulJob.class);\n+        final String jobGroupName = getJobGroupName(MyStatefulJob.class);\n+        QuartzUtils.removeJob(jobName, jobGroupName);\n+    }\n+\n+    /**\n+     * Given scenario: We prep to trigger a bunch of tasks that must be executed sequentially (one at the time) never in parallel.\n+     * Expected Results: first all triggered tasks must be executed and completed. second their time mark must revel that none of theme overlapped.\n+     *\n+     * @throws SchedulerException\n+     * @throws ParseException\n+     * @throws ClassNotFoundException\n+     * @throws InterruptedException\n+     */\n+    @Test\n+    public void Test_Launch_Stateful_Jobs_Verify_They_Dont_Overlap_In_Time()\n+            throws SchedulerException, ParseException, ClassNotFoundException, InterruptedException {\n+\n+        //in order to avoid conflicts clean any reference that could have been left.\n+        removeAnyExistingJob();\n+\n+        //Now enqueue a few jos .. They will sleep randomly to simulate work.\n+        for (int i = 1; i <= MyStatefulJob.MAX_THREADS; i++) {\n+            MyStatefulJob.fireJob(ImmutableMap.of(\"index\", i));\n+            //Now verify the detail has been added for the present trigger we're introducing\n+            final Optional<Map<String, Object>> triggerJobDetail = DotStatefulJob\n+                    .getTriggerJobDetail(MyStatefulJob.class);\n+            assertNotNull(triggerJobDetail);\n+            assertTrue(triggerJobDetail.isPresent());\n+            final Map<String, Object> detail = triggerJobDetail.get();\n+            assertNotNull(detail);\n+            //The size of the detail should have grown as we insert new triggers.\n+            assertEquals(detail.size(), i);\n+        }\n+\n+        //Verify at least 1 job has been launched.\n+        final Optional<JobExecutionContext> jobExecutionContext = getJobExecutionContext();\n+        assertTrue(jobExecutionContext.isPresent());\n+\n+        //Now lets wait for the all the threads to complete.\n+        MyStatefulJob.countDownLatch.await();\n+\n+        //Now lets revise the execution times. Since they were supposed to run sequentially the should never overlap.\n+        final HashSet<MyStatefulJob> myStatefulJobs = new HashSet<>(MyStatefulJob.finishedJobs);\n+        final Iterator<MyStatefulJob> iterator = myStatefulJobs.iterator();\n+        while(iterator.hasNext()){\n+            final MyStatefulJob myStatefulJob = iterator.next();\n+            iterator.forEachRemaining(job -> {\n+                //They should never overlap.\n+                assertFalse(myStatefulJob.getTimeRange().overlaps(job.getTimeRange()));\n+            });\n+        }\n+    }\n+\n+    /**\n+     * This gets you the execution context for the given job-name.\n+     * @return\n+     */\n+    private Optional<JobExecutionContext> getJobExecutionContext(){\n+        final String jobName = getJobName(MyStatefulJob.class);\n+        try {\n+            final Scheduler sequentialScheduler = getSequentialScheduler();\n+            @SuppressWarnings(\"unchecked\")\n+            final List<JobExecutionContext> executingJobs = sequentialScheduler.getCurrentlyExecutingJobs();\n+            return executingJobs.stream().filter(jobExecutionContext -> {\n+                final JobDetail jobDetail = jobExecutionContext.getJobDetail();\n+                return jobDetail != null && jobName.equals(jobDetail.getName());\n+            }).findFirst();\n+        } catch (Exception e) {\n+            Logger.error(DotStatefulJobTest.class, \"Error retrieving execution context. \" , e);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * additional struct to follow execution time lapse.\n+     */\n+    public static class LocalTimeRange {\n+\n+        private final LocalTime from;\n+        private final LocalTime to;\n+\n+        LocalTimeRange(final LocalTime from, final LocalTime to) {\n+            requireNonNull(from, \"from must not be null\");\n+            requireNonNull(to, \"to must not be null\");\n+            this.from = from;\n+            this.to = to;\n+        }\n+\n+        boolean overlaps(final LocalTimeRange other) {\n+            requireNonNull(other, \"other must not be null\");\n+            return isBetween(other.from, this.from, this.to)\n+                    || isBetween(other.to, this.from, this.to)\n+                    || isBetween(this.from, other.from, other.to)\n+                    || isBetween(this.to, other.from, other.to);\n+        }\n+\n+        private static boolean isBetween(final LocalTime time, final LocalTime from, final LocalTime to) {\n+            if (from.isBefore(to)) { // same day\n+                return from.isBefore(time) && time.isBefore(to);\n+            } else { // spans to the next day.\n+                return from.isBefore(time) || time.isBefore(to);\n+            }\n+        }\n+\n+        public static LocalTimeRange of(final LocalTime from, final LocalTime to){", "originalCommit": "a4327c1b9cf606e4b0fe93358f0eb0724a2c7733", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTYyNzI4Nw==", "url": "https://github.com/dotCMS/core/pull/19274#discussion_r489627287", "bodyText": "Codacy found an issue: Useless parentheses.", "author": "dev-dotcms", "createdAt": "2020-09-16T18:09:59Z", "path": "dotCMS/src/integration-test/java/com/dotmarketing/util/PageModeTest.java", "diffHunk": "@@ -111,6 +108,56 @@ public void test_page_mode_does_not_create_session() {\n \n     }\n \n+    /**\n+     * Back end users can have their page mode set to EDIT MODE\n+     */\n+    @Test\n+    public void test_back_end_user_can_be_set_to_LIVE() {\n+\n+        HttpServletRequest request = backEndRequest();\n+\n+        assert (PageMode.get(request) == PageMode.PREVIEW_MODE);\n+\n+        PageMode.setPageMode(request, PageMode.LIVE);\n+\n+        assert (PageMode.get(request) == PageMode.LIVE);\n+\n+    }\n+\n+\n+    /**\n+     * Testing order of reading PAGE_MODE for a backend user, It should be like this:\n+     * 1. request parameter\n+     * 2. request attribute\n+     * 3. session\n+     * 4. default = PREVIEW_MODE\n+     * we should respect the request parameter,\n+     * then the request attribute, then the session, and finally PREVIEW_MODE if we don't have anything\n+     */\n+    @Test\n+    public void test_order_of_reading_pagemode() {\n+\n+        // PREVIEW_MODE if there is no mode and back end user\n+        HttpServletRequest request = new MockSessionRequest(backEndRequest()).request();\n+        assert (PageMode.get(request) == PageMode.PREVIEW_MODE);\n+\n+        // session is last fallback\n+        request.getSession().setAttribute(com.dotmarketing.util.WebKeys.PAGE_MODE_SESSION,\n+                PageMode.ADMIN_MODE);\n+        assert (PageMode.get(request) == PageMode.ADMIN_MODE);\n+\n+        // request.attribute overrides session\n+        request.setAttribute(com.dotmarketing.util.WebKeys.PAGE_MODE_PARAMETER, PageMode.EDIT_MODE);\n+        assert (PageMode.get(request) == PageMode.EDIT_MODE);\n+\n+        // passed in parameter overrides everything\n+        HttpServletRequest parameterRequest =\n+                new MockParameterRequest(request, ImmutableMap.of(\"mode\", \"LIVE\")).request();\n+        assert (PageMode.get(parameterRequest) == PageMode.LIVE);", "originalCommit": "a4327c1b9cf606e4b0fe93358f0eb0724a2c7733", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}