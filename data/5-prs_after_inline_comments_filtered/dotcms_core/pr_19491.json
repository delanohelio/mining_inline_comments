{"pr_number": 19491, "pr_title": "#18236 import/export bugs fixed", "pr_createdAt": "2020-10-23T16:20:11Z", "pr_url": "https://github.com/dotCMS/core/pull/19491", "timeline": [{"oid": "7ef2fc978ff3b5de4b319eb7dc6a29a950485977", "url": "https://github.com/dotCMS/core/commit/7ef2fc978ff3b5de4b319eb7dc6a29a950485977", "message": "#18236 import/export bugs fixed", "committedDate": "2020-10-23T16:09:54Z", "type": "commit"}, {"oid": "1941f227ab70791f525b6ed5093a41d5b68fde36", "url": "https://github.com/dotCMS/core/commit/1941f227ab70791f525b6ed5093a41d5b68fde36", "message": "#18236 bug fix + import optimized", "committedDate": "2020-10-23T19:01:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTA5NjM3Ng==", "url": "https://github.com/dotCMS/core/pull/19491#discussion_r511096376", "bodyText": "This logic should have a test", "author": "nollymar", "createdAt": "2020-10-23T19:16:06Z", "path": "dotCMS/src/main/java/com/dotcms/security/apps/AppsAPIImpl.java", "diffHunk": "@@ -735,10 +731,10 @@ private AppsSecretsImportExport collectSecretsForExport(final Map<String, Set<St\n         }\n \n         for (final Entry<String, Set<String>> entry : paramAppKeysBySite.entrySet()) {\n-            final String siteId = entry.getKey();\n+            final String siteId = Host.SYSTEM_HOST.equalsIgnoreCase(entry.getKey()) ? Host.SYSTEM_HOST : entry.getKey();", "originalCommit": "1941f227ab70791f525b6ed5093a41d5b68fde36", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTA5NjQ5NQ==", "url": "https://github.com/dotCMS/core/pull/19491#discussion_r511096495", "bodyText": "This logic should have a test", "author": "nollymar", "createdAt": "2020-10-23T19:16:16Z", "path": "dotCMS/src/main/java/com/dotcms/rest/api/v1/apps/ExportSecretForm.java", "diffHunk": "@@ -46,10 +47,11 @@ public boolean isExportAll() {\n \n     @Override\n     public String toString() {\n-        final List<String> stringsList = appKeysBySite.entrySet().stream()\n-                .map(entry -> \"Site \" + entry.getKey() + \" keys: \" + String\n-                        .join(\",\", entry.getValue())).collect(\n-                        Collectors.toList());\n+        final List<String> stringsList =\n+                appKeysBySite == null ? ImmutableList.of() : appKeysBySite.entrySet().stream()", "originalCommit": "1941f227ab70791f525b6ed5093a41d5b68fde36", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTIwODk2Mw==", "url": "https://github.com/dotCMS/core/pull/19491#discussion_r511208963", "bodyText": "done", "author": "fabrizzio-dotCMS", "createdAt": "2020-10-24T00:22:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTA5NjQ5NQ=="}], "type": "inlineReview"}, {"oid": "1df7beb593f8610529feb10df86df435b0ae6eac", "url": "https://github.com/dotCMS/core/commit/1df7beb593f8610529feb10df86df435b0ae6eac", "message": "#18236 feedback", "committedDate": "2020-10-24T00:21:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTIxMTI3NA==", "url": "https://github.com/dotCMS/core/pull/19491#discussion_r511211274", "bodyText": "Codacy found an issue: A method/constructor should not explicitly throw java.lang.Exception", "author": "dev-dotcms", "createdAt": "2020-10-24T00:28:52Z", "path": "dotCMS/src/integration-test/java/com/dotcms/security/apps/AppsAPIImplTest.java", "diffHunk": "@@ -1030,106 +1051,131 @@ public void Test_File_Comparison_Is_Case_Sensitive()\n                 .withDescription(\"system-app\")\n                 .withExtraParameters(false);\n         final File file = dataGen.nextPersistedDescriptor();\n-\n-        //Move the file to the system folder and save it in upper case\n-        final Path systemAppsDescriptorDirectory = AppDescriptorHelper.getSystemAppsDescriptorDirectory();\n-        final boolean result = file.renameTo(new File(\n-                systemAppsDescriptorDirectory.toString() + File.separator + file.getName()\n-                        .toUpperCase().replace(\"YML\", \"yml\")));\n-        assertTrue(result);\n-        //Even though we just moved the file under apps-system-folder this should recreate the file again.\n-        //But before that.. lets make a small change so we can tell the difference between the two files.\n-        dataGen.withDescription(\"user-app\");\n-        final File newFile = dataGen.nextPersistedDescriptor();\n-        api.createAppDescriptor(newFile, admin);\n-\n-        //Invalidate cache so the new descriptors get picked\n-        appsCache.invalidateDescriptorsCache();\n-        final List<AppDescriptor> appDescriptors = api.getAppDescriptors(admin);\n-\n-        //Verify the file we just submitted is recognized as a system-app-file\n-        assertEquals(1, appDescriptors.stream()\n-                .filter(appDescriptor -> dataGen.getKey().equalsIgnoreCase(appDescriptor.getKey())).count());\n-        final Optional<AppDescriptor> optional = appDescriptors.stream()\n-                .filter(appDescriptor -> dataGen.getKey().equalsIgnoreCase(appDescriptor.getKey())).findFirst();\n-        assertTrue(optional.isPresent());\n-        //\n-        final AppDescriptor descriptor = optional.get();\n-        final AppDescriptorImpl impl = (AppDescriptorImpl)descriptor;\n-        assertTrue(impl.isSystemApp());\n-        //This proves that even though we had two files named the same. 1 in the user apps folder and another 1 in the system-apps folder.\n-        //The one from the system-folder takes precedence.\n-        assertEquals(\"system-app\", impl.getDescription());\n+        try {\n+            //Move the file to the system folder and save it in upper case\n+            final Path systemAppsDescriptorDirectory = AppDescriptorHelper\n+                    .getSystemAppsDescriptorDirectory();\n+            final boolean result = file.renameTo(new File(\n+                    systemAppsDescriptorDirectory.toString() + File.separator + file.getName()\n+                            .toUpperCase().replace(\"YML\", \"yml\")));\n+            assertTrue(result);\n+            //Even though we just moved the file under apps-system-folder this should recreate the file again.\n+            //But before that.. lets make a small change so we can tell the difference between the two files.\n+            dataGen.withDescription(\"user-app\");\n+            final File newFile = dataGen.nextPersistedDescriptor();\n+            try{\n+                api.createAppDescriptor(newFile, admin);\n+\n+                //Invalidate cache so the new descriptors get picked\n+                appsCache.invalidateDescriptorsCache();\n+                final List<AppDescriptor> appDescriptors = api.getAppDescriptors(admin);\n+\n+                //Verify the file we just submitted is recognized as a system-app-file\n+                assertEquals(1, appDescriptors.stream()\n+                        .filter(appDescriptor -> dataGen.getKey()\n+                                .equalsIgnoreCase(appDescriptor.getKey())).count());\n+                final Optional<AppDescriptor> optional = appDescriptors.stream()\n+                        .filter(appDescriptor -> dataGen.getKey()\n+                                .equalsIgnoreCase(appDescriptor.getKey())).findFirst();\n+                assertTrue(optional.isPresent());\n+                //\n+                final AppDescriptor descriptor = optional.get();\n+                final AppDescriptorImpl impl = (AppDescriptorImpl) descriptor;\n+                assertTrue(impl.isSystemApp());\n+                //This proves that even though we had two files named the same. 1 in the user apps folder and another 1 in the system-apps folder.\n+                //The one from the system-folder takes precedence.\n+                assertEquals(\"system-app\", impl.getDescription());\n+            }finally {\n+                newFile.delete();\n+            }\n+        } finally {\n+            file.delete();\n+        }\n     }\n \n     /**\n      * Method to test {@link AppsAPIImpl#exportSecrets(Key, boolean, Map, User)} and {@link AppsAPIImpl#importSecretsAndSave(Path, Key, User)}\n-     * Given Scenario: This test creates secrets then exports them Then re-imports the file with the generated secrets.\n-     * Expected Result: The test should be Able to recreate the secrets from the generated file.\n+     * Given Scenario: This test creates secrets then exports them Then re-imports the file with the generated secrets for different host.\n+     * Expected Result: The test should be Able to recreate the secrets from the generated file regardless of the host.\n      * @throws DotDataException\n      * @throws DotSecurityException\n      * @throws IOException\n      * @throws EncryptorException\n      * @throws ClassNotFoundException\n      */\n     @Test\n-    public void Test_Create_Secrets_Then_Export_Them_Then_Import_Then_Save()\n+    @UseDataProvider(\"getTargetSitesTestCases\")\n+    public void Test_Create_Secrets_Then_Export_Them_Then_Import_Then_Save(final Host site)\n             throws DotDataException, DotSecurityException, IOException, EncryptorException, AlreadyExistException {\n         final User admin = TestUserUtils.getAdminUser();\n-        final Host site = new SiteDataGen().nextPersisted();\n         final AppsAPI api = APILocator.getAppsAPI();\n         //generate a descriptor\n         final AppSecrets.Builder builder1 = new AppSecrets.Builder();\n         final AppDescriptorDataGen dataGen = new AppDescriptorDataGen()\n-                .stringParam(\"p1\", false,  true)\n-                .stringParam(\"p2\", false,  true)\n+                .stringParam(\"p1\", false, true)\n+                .stringParam(\"p2\", false, true)\n                 .withName(\"system-app-example\")\n                 .withDescription(\"system-app\")\n                 .withExtraParameters(false);\n         final File file = dataGen.nextPersistedDescriptor();\n-        api.createAppDescriptor(file, admin);\n-\n-        final String appKey = dataGen.getKey();\n-        //generate secrets\n-        AppSecrets secrets = builder1.withKey(appKey)\n-                .withHiddenSecret(\"p1\", \"secret-1\")\n-                .withHiddenSecret(\"p2\", \"secret-2\")\n-                .build();\n-        //Save it\n-        api.saveSecrets(secrets, site, admin);\n-        final Optional<AppSecrets> secretsOptional = api.getSecrets(appKey, site, admin);\n-        Assert.assertTrue(secretsOptional.isPresent());\n-        secrets = secretsOptional.get();\n-\n-        //AES only supports security Key of sizes of 16, 24 or 32 bytes.\n-        final String password = RandomStringUtils.randomAlphanumeric(32);\n-        final Key securityKey = AppsUtil.generateKey(password);\n-\n-        //Now that we have a valid key lets dump our selection of secrets\n-        final Map<String,Set<String>> appKeysBySite = ImmutableMap.of(site.getIdentifier(), ImmutableSet.of(appKey));\n-        final Path exportSecretsFile = api.exportSecrets(securityKey, false, appKeysBySite, admin);\n-        assertTrue(exportSecretsFile.toFile().exists());\n-\n-        //Remove the secret we dumped we can re import it.\n-        api.deleteSecrets(appKey, site, admin);\n-\n-        //import it\n-        api.importSecretsAndSave(exportSecretsFile, securityKey, admin);\n-\n-        //verify\n-        final Optional<AppSecrets> secretsOptionalPostImport = api.getSecrets(appKey, site, admin);\n-        assertTrue(secretsOptionalPostImport.isPresent());\n-        final AppSecrets restoredSecrets = secretsOptionalPostImport.get();\n-\n-        assertEquals(restoredSecrets.getKey(),secrets.getKey());\n-        assertEquals(restoredSecrets.getSecrets().size(),secrets.getSecrets().size());\n-        for (final Entry<String, Secret> entry : secrets.getSecrets().entrySet()) {\n-            final Secret originalSecret = entry.getValue();\n-            final Secret restoredSecret = restoredSecrets.getSecrets().get(entry.getKey());\n-            assertTrue(originalSecret.equals(restoredSecret));\n+        try {\n+            api.createAppDescriptor(file, admin);\n+\n+            final String appKey = dataGen.getKey();\n+            //generate secrets\n+            AppSecrets secrets = builder1.withKey(appKey)\n+                    .withHiddenSecret(\"p1\", \"secret-1\")\n+                    .withHiddenSecret(\"p2\", \"secret-2\")\n+                    .build();\n+            //Save it\n+            api.saveSecrets(secrets, site, admin);\n+            final Optional<AppSecrets> secretsOptional = api.getSecrets(appKey, site, admin);\n+            Assert.assertTrue(secretsOptional.isPresent());\n+            secrets = secretsOptional.get();\n+\n+            //AES only supports security Key of sizes of 16, 24 or 32 bytes.\n+            final String password = RandomStringUtils.randomAlphanumeric(32);\n+            final Key securityKey = AppsUtil.generateKey(password);\n+\n+            //Now that we have a valid key lets dump our selection of secrets\n+            final Map<String, Set<String>> appKeysBySite = ImmutableMap\n+                    .of(site.getIdentifier(), ImmutableSet.of(appKey));\n+            final Path exportSecretsFile = api\n+                    .exportSecrets(securityKey, false, appKeysBySite, admin);\n+            assertTrue(exportSecretsFile.toFile().exists());\n+\n+            //Remove the secret we dumped we can re import it.\n+            api.deleteSecrets(appKey, site, admin);\n+\n+            //import it\n+            api.importSecretsAndSave(exportSecretsFile, securityKey, admin);\n+\n+            //verify\n+            final Optional<AppSecrets> secretsOptionalPostImport = api\n+                    .getSecrets(appKey, site, admin);\n+            assertTrue(secretsOptionalPostImport.isPresent());\n+            final AppSecrets restoredSecrets = secretsOptionalPostImport.get();\n+\n+            assertEquals(restoredSecrets.getKey(), secrets.getKey());\n+            assertEquals(restoredSecrets.getSecrets().size(), secrets.getSecrets().size());\n+            for (final Entry<String, Secret> entry : secrets.getSecrets().entrySet()) {\n+                final Secret originalSecret = entry.getValue();\n+                final Secret restoredSecret = restoredSecrets.getSecrets().get(entry.getKey());\n+                assertTrue(originalSecret.equals(restoredSecret));\n+            }\n+        } finally {\n+            file.delete();\n         }\n     }\n \n+    @DataProvider\n+    public static Object[] getTargetSitesTestCases() throws Exception {", "originalCommit": "1df7beb593f8610529feb10df86df435b0ae6eac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTIxMTI4NA==", "url": "https://github.com/dotCMS/core/pull/19491#discussion_r511211284", "bodyText": "Codacy found an issue: Unnecessary use of fully qualified name 'ImmutableMap.of' due to existing static import 'com.google.common.collect.ImmutableMap.of'", "author": "dev-dotcms", "createdAt": "2020-10-24T00:28:53Z", "path": "dotCMS/src/integration-test/java/com/dotcms/security/apps/AppsAPIImplTest.java", "diffHunk": "@@ -1030,106 +1051,131 @@ public void Test_File_Comparison_Is_Case_Sensitive()\n                 .withDescription(\"system-app\")\n                 .withExtraParameters(false);\n         final File file = dataGen.nextPersistedDescriptor();\n-\n-        //Move the file to the system folder and save it in upper case\n-        final Path systemAppsDescriptorDirectory = AppDescriptorHelper.getSystemAppsDescriptorDirectory();\n-        final boolean result = file.renameTo(new File(\n-                systemAppsDescriptorDirectory.toString() + File.separator + file.getName()\n-                        .toUpperCase().replace(\"YML\", \"yml\")));\n-        assertTrue(result);\n-        //Even though we just moved the file under apps-system-folder this should recreate the file again.\n-        //But before that.. lets make a small change so we can tell the difference between the two files.\n-        dataGen.withDescription(\"user-app\");\n-        final File newFile = dataGen.nextPersistedDescriptor();\n-        api.createAppDescriptor(newFile, admin);\n-\n-        //Invalidate cache so the new descriptors get picked\n-        appsCache.invalidateDescriptorsCache();\n-        final List<AppDescriptor> appDescriptors = api.getAppDescriptors(admin);\n-\n-        //Verify the file we just submitted is recognized as a system-app-file\n-        assertEquals(1, appDescriptors.stream()\n-                .filter(appDescriptor -> dataGen.getKey().equalsIgnoreCase(appDescriptor.getKey())).count());\n-        final Optional<AppDescriptor> optional = appDescriptors.stream()\n-                .filter(appDescriptor -> dataGen.getKey().equalsIgnoreCase(appDescriptor.getKey())).findFirst();\n-        assertTrue(optional.isPresent());\n-        //\n-        final AppDescriptor descriptor = optional.get();\n-        final AppDescriptorImpl impl = (AppDescriptorImpl)descriptor;\n-        assertTrue(impl.isSystemApp());\n-        //This proves that even though we had two files named the same. 1 in the user apps folder and another 1 in the system-apps folder.\n-        //The one from the system-folder takes precedence.\n-        assertEquals(\"system-app\", impl.getDescription());\n+        try {\n+            //Move the file to the system folder and save it in upper case\n+            final Path systemAppsDescriptorDirectory = AppDescriptorHelper\n+                    .getSystemAppsDescriptorDirectory();\n+            final boolean result = file.renameTo(new File(\n+                    systemAppsDescriptorDirectory.toString() + File.separator + file.getName()\n+                            .toUpperCase().replace(\"YML\", \"yml\")));\n+            assertTrue(result);\n+            //Even though we just moved the file under apps-system-folder this should recreate the file again.\n+            //But before that.. lets make a small change so we can tell the difference between the two files.\n+            dataGen.withDescription(\"user-app\");\n+            final File newFile = dataGen.nextPersistedDescriptor();\n+            try{\n+                api.createAppDescriptor(newFile, admin);\n+\n+                //Invalidate cache so the new descriptors get picked\n+                appsCache.invalidateDescriptorsCache();\n+                final List<AppDescriptor> appDescriptors = api.getAppDescriptors(admin);\n+\n+                //Verify the file we just submitted is recognized as a system-app-file\n+                assertEquals(1, appDescriptors.stream()\n+                        .filter(appDescriptor -> dataGen.getKey()\n+                                .equalsIgnoreCase(appDescriptor.getKey())).count());\n+                final Optional<AppDescriptor> optional = appDescriptors.stream()\n+                        .filter(appDescriptor -> dataGen.getKey()\n+                                .equalsIgnoreCase(appDescriptor.getKey())).findFirst();\n+                assertTrue(optional.isPresent());\n+                //\n+                final AppDescriptor descriptor = optional.get();\n+                final AppDescriptorImpl impl = (AppDescriptorImpl) descriptor;\n+                assertTrue(impl.isSystemApp());\n+                //This proves that even though we had two files named the same. 1 in the user apps folder and another 1 in the system-apps folder.\n+                //The one from the system-folder takes precedence.\n+                assertEquals(\"system-app\", impl.getDescription());\n+            }finally {\n+                newFile.delete();\n+            }\n+        } finally {\n+            file.delete();\n+        }\n     }\n \n     /**\n      * Method to test {@link AppsAPIImpl#exportSecrets(Key, boolean, Map, User)} and {@link AppsAPIImpl#importSecretsAndSave(Path, Key, User)}\n-     * Given Scenario: This test creates secrets then exports them Then re-imports the file with the generated secrets.\n-     * Expected Result: The test should be Able to recreate the secrets from the generated file.\n+     * Given Scenario: This test creates secrets then exports them Then re-imports the file with the generated secrets for different host.\n+     * Expected Result: The test should be Able to recreate the secrets from the generated file regardless of the host.\n      * @throws DotDataException\n      * @throws DotSecurityException\n      * @throws IOException\n      * @throws EncryptorException\n      * @throws ClassNotFoundException\n      */\n     @Test\n-    public void Test_Create_Secrets_Then_Export_Them_Then_Import_Then_Save()\n+    @UseDataProvider(\"getTargetSitesTestCases\")\n+    public void Test_Create_Secrets_Then_Export_Them_Then_Import_Then_Save(final Host site)\n             throws DotDataException, DotSecurityException, IOException, EncryptorException, AlreadyExistException {\n         final User admin = TestUserUtils.getAdminUser();\n-        final Host site = new SiteDataGen().nextPersisted();\n         final AppsAPI api = APILocator.getAppsAPI();\n         //generate a descriptor\n         final AppSecrets.Builder builder1 = new AppSecrets.Builder();\n         final AppDescriptorDataGen dataGen = new AppDescriptorDataGen()\n-                .stringParam(\"p1\", false,  true)\n-                .stringParam(\"p2\", false,  true)\n+                .stringParam(\"p1\", false, true)\n+                .stringParam(\"p2\", false, true)\n                 .withName(\"system-app-example\")\n                 .withDescription(\"system-app\")\n                 .withExtraParameters(false);\n         final File file = dataGen.nextPersistedDescriptor();\n-        api.createAppDescriptor(file, admin);\n-\n-        final String appKey = dataGen.getKey();\n-        //generate secrets\n-        AppSecrets secrets = builder1.withKey(appKey)\n-                .withHiddenSecret(\"p1\", \"secret-1\")\n-                .withHiddenSecret(\"p2\", \"secret-2\")\n-                .build();\n-        //Save it\n-        api.saveSecrets(secrets, site, admin);\n-        final Optional<AppSecrets> secretsOptional = api.getSecrets(appKey, site, admin);\n-        Assert.assertTrue(secretsOptional.isPresent());\n-        secrets = secretsOptional.get();\n-\n-        //AES only supports security Key of sizes of 16, 24 or 32 bytes.\n-        final String password = RandomStringUtils.randomAlphanumeric(32);\n-        final Key securityKey = AppsUtil.generateKey(password);\n-\n-        //Now that we have a valid key lets dump our selection of secrets\n-        final Map<String,Set<String>> appKeysBySite = ImmutableMap.of(site.getIdentifier(), ImmutableSet.of(appKey));\n-        final Path exportSecretsFile = api.exportSecrets(securityKey, false, appKeysBySite, admin);\n-        assertTrue(exportSecretsFile.toFile().exists());\n-\n-        //Remove the secret we dumped we can re import it.\n-        api.deleteSecrets(appKey, site, admin);\n-\n-        //import it\n-        api.importSecretsAndSave(exportSecretsFile, securityKey, admin);\n-\n-        //verify\n-        final Optional<AppSecrets> secretsOptionalPostImport = api.getSecrets(appKey, site, admin);\n-        assertTrue(secretsOptionalPostImport.isPresent());\n-        final AppSecrets restoredSecrets = secretsOptionalPostImport.get();\n-\n-        assertEquals(restoredSecrets.getKey(),secrets.getKey());\n-        assertEquals(restoredSecrets.getSecrets().size(),secrets.getSecrets().size());\n-        for (final Entry<String, Secret> entry : secrets.getSecrets().entrySet()) {\n-            final Secret originalSecret = entry.getValue();\n-            final Secret restoredSecret = restoredSecrets.getSecrets().get(entry.getKey());\n-            assertTrue(originalSecret.equals(restoredSecret));\n+        try {\n+            api.createAppDescriptor(file, admin);\n+\n+            final String appKey = dataGen.getKey();\n+            //generate secrets\n+            AppSecrets secrets = builder1.withKey(appKey)\n+                    .withHiddenSecret(\"p1\", \"secret-1\")\n+                    .withHiddenSecret(\"p2\", \"secret-2\")\n+                    .build();\n+            //Save it\n+            api.saveSecrets(secrets, site, admin);\n+            final Optional<AppSecrets> secretsOptional = api.getSecrets(appKey, site, admin);\n+            Assert.assertTrue(secretsOptional.isPresent());\n+            secrets = secretsOptional.get();\n+\n+            //AES only supports security Key of sizes of 16, 24 or 32 bytes.\n+            final String password = RandomStringUtils.randomAlphanumeric(32);\n+            final Key securityKey = AppsUtil.generateKey(password);\n+\n+            //Now that we have a valid key lets dump our selection of secrets\n+            final Map<String, Set<String>> appKeysBySite = ImmutableMap", "originalCommit": "1df7beb593f8610529feb10df86df435b0ae6eac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTIxMTI4Ng==", "url": "https://github.com/dotCMS/core/pull/19491#discussion_r511211286", "bodyText": "Codacy found an issue: Avoid unused local variables such as 'systemHostSecretsOptional'.", "author": "dev-dotcms", "createdAt": "2020-10-24T00:28:54Z", "path": "dotCMS/src/integration-test/java/com/dotcms/security/apps/AppsAPIImplTest.java", "diffHunk": "@@ -1215,39 +1266,143 @@ public void Test_Create_Offending_Secrets_Missing_Site_Then_Export_Them_Then_Imp\n                 .withDescription(\"system-app\")\n                 .withExtraParameters(false);\n         final File file = dataGen.nextPersistedDescriptor();\n-        api.createAppDescriptor(file, admin);\n+        try {\n+            api.createAppDescriptor(file, admin);\n+\n+            final String appKey = dataGen.getKey();\n+            //generate secrets\n+            final AppSecrets secrets = builder1.withKey(appKey)\n+                    .withHiddenSecret(\"p1\", \"secret-1\")\n+                    .withHiddenSecret(\"p2\", \"secret-2\")\n+                    .build();\n+            //Save it\n+            api.saveSecrets(secrets, site, admin);\n+            final Optional<AppSecrets> secretsOptional = api.getSecrets(appKey, site, admin);\n+            Assert.assertTrue(secretsOptional.isPresent());\n+\n+            //AES only supports security Key of sizes of 16, 24 or 32 bytes.\n+            final String password = RandomStringUtils.randomAlphanumeric(32);\n+            final Key securityKey = AppsUtil.generateKey(password);\n+\n+            //Now that we have a valid key lets dump our selection of secrets\n+            final Map<String, Set<String>> appKeysBySite = ImmutableMap\n+                    .of(site.getIdentifier(), ImmutableSet.of(appKey));\n+            final Path exportSecretsFile = api\n+                    .exportSecrets(securityKey, false, appKeysBySite, admin);\n+            assertTrue(exportSecretsFile.toFile().exists());\n+\n+            //Remove the secret we dumped we can re import it.\n+            api.deleteSecrets(appKey, site, admin);\n+\n+            //Now we're gonna create an inconsistency removing the app descriptor and then try to import the secret.\n+            final HostAPI hostAPI = APILocator.getHostAPI();\n+            hostAPI.archive(site, admin, false);\n+            hostAPI.delete(site, admin, false);\n+\n+            //and finally import it\n+            api.importSecretsAndSave(exportSecretsFile, securityKey, admin);\n+        }finally {\n+            file.delete();\n+        }\n+    }\n \n-        final String appKey = dataGen.getKey();\n-        //generate secrets\n-        final AppSecrets secrets = builder1.withKey(appKey)\n-                .withHiddenSecret(\"p1\", \"secret-1\")\n-                .withHiddenSecret(\"p2\", \"secret-2\")\n-                .build();\n-        //Save it\n-        api.saveSecrets(secrets, site, admin);\n-        final Optional<AppSecrets> secretsOptional = api.getSecrets(appKey, site, admin);\n-        Assert.assertTrue(secretsOptional.isPresent());\n+    /**\n+     * Method to test {@link AppsAPIImpl#exportSecrets(Key, boolean, Map, User)} and {@link AppsAPIImpl#collectSecretsForExport(Map, User)}\n+     * Given scenario: We're testing exporting secrets generated for different sites (one being SYSTEM_HOST)\n+     * Expected results:  We should be able to recover everthing that initially got exported using the \"exportAll\" param regardless of site.\n+     * @throws DotDataException\n+     * @throws IOException\n+     * @throws AlreadyExistException\n+     * @throws DotSecurityException\n+     * @throws EncryptorException\n+     */\n+    @Test\n+    public void Test_Export_All_Secrets_For_System_Non_System_Sites()\n+            throws DotDataException, IOException, AlreadyExistException, DotSecurityException, EncryptorException {\n+        final User admin = TestUserUtils.getAdminUser();\n+        final AppsAPI api = APILocator.getAppsAPI();\n+        api.resetSecrets(admin);\n \n-        //AES only supports security Key of sizes of 16, 24 or 32 bytes.\n-        final String password = RandomStringUtils.randomAlphanumeric(32);\n-        final Key securityKey = AppsUtil.generateKey(password);\n+        final Host site = new SiteDataGen().nextPersisted();\n+        final Host systemHost = APILocator.getHostAPI().findSystemHost();\n+\n+        //generate a descriptor\n+        final AppSecrets.Builder builder1 = new AppSecrets.Builder();\n+        final AppDescriptorDataGen dataGen = new AppDescriptorDataGen()\n+                .stringParam(\"p1\", false,  true)\n+                .stringParam(\"p2\", false,  true)\n+                .withName(\"app-example\")\n+                .withDescription(\"app\")\n+                .withExtraParameters(false);\n+        final File file = dataGen.nextPersistedDescriptor();\n+        try {\n+            api.createAppDescriptor(file, admin);\n \n-        //Now that we have a valid key lets dump our selection of secrets\n-        final Map<String,Set<String>> appKeysBySite = ImmutableMap.of(site.getIdentifier(), ImmutableSet.of(appKey));\n-        final Path exportSecretsFile = api.exportSecrets(securityKey, false, appKeysBySite, admin);\n-        assertTrue(exportSecretsFile.toFile().exists());\n+            final String appKey = dataGen.getKey();\n+            //generate secrets\n+            final AppSecrets secrets = builder1.withKey(appKey)\n+                    .withHiddenSecret(\"p1\", \"secret-1\")\n+                    .withHiddenSecret(\"p2\", \"secret-2\")\n+                    .build();\n \n-        //Remove the secret we dumped we can re import it.\n-        api.deleteSecrets(appKey, site, admin);\n+            //Save it\n+            api.saveSecrets(secrets, site, admin);\n+            final Optional<AppSecrets> siteSecretsOptional = api.getSecrets(appKey, site, admin);\n \n-        //Now we're gonna create an inconsistency removing the app descriptor and then try to import the secret.\n-        final HostAPI hostAPI = APILocator.getHostAPI();\n-        hostAPI.archive(site, admin, false);\n-        hostAPI.delete(site, admin, false);\n+            api.saveSecrets(secrets, systemHost, admin);\n+            final Optional<AppSecrets> systemHostSecretsOptional = api", "originalCommit": "1df7beb593f8610529feb10df86df435b0ae6eac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTIxMTI4OQ==", "url": "https://github.com/dotCMS/core/pull/19491#discussion_r511211289", "bodyText": "Codacy found an issue: Avoid unused local variables such as 'siteSecretsOptional'.", "author": "dev-dotcms", "createdAt": "2020-10-24T00:28:55Z", "path": "dotCMS/src/integration-test/java/com/dotcms/security/apps/AppsAPIImplTest.java", "diffHunk": "@@ -1215,39 +1266,143 @@ public void Test_Create_Offending_Secrets_Missing_Site_Then_Export_Them_Then_Imp\n                 .withDescription(\"system-app\")\n                 .withExtraParameters(false);\n         final File file = dataGen.nextPersistedDescriptor();\n-        api.createAppDescriptor(file, admin);\n+        try {\n+            api.createAppDescriptor(file, admin);\n+\n+            final String appKey = dataGen.getKey();\n+            //generate secrets\n+            final AppSecrets secrets = builder1.withKey(appKey)\n+                    .withHiddenSecret(\"p1\", \"secret-1\")\n+                    .withHiddenSecret(\"p2\", \"secret-2\")\n+                    .build();\n+            //Save it\n+            api.saveSecrets(secrets, site, admin);\n+            final Optional<AppSecrets> secretsOptional = api.getSecrets(appKey, site, admin);\n+            Assert.assertTrue(secretsOptional.isPresent());\n+\n+            //AES only supports security Key of sizes of 16, 24 or 32 bytes.\n+            final String password = RandomStringUtils.randomAlphanumeric(32);\n+            final Key securityKey = AppsUtil.generateKey(password);\n+\n+            //Now that we have a valid key lets dump our selection of secrets\n+            final Map<String, Set<String>> appKeysBySite = ImmutableMap\n+                    .of(site.getIdentifier(), ImmutableSet.of(appKey));\n+            final Path exportSecretsFile = api\n+                    .exportSecrets(securityKey, false, appKeysBySite, admin);\n+            assertTrue(exportSecretsFile.toFile().exists());\n+\n+            //Remove the secret we dumped we can re import it.\n+            api.deleteSecrets(appKey, site, admin);\n+\n+            //Now we're gonna create an inconsistency removing the app descriptor and then try to import the secret.\n+            final HostAPI hostAPI = APILocator.getHostAPI();\n+            hostAPI.archive(site, admin, false);\n+            hostAPI.delete(site, admin, false);\n+\n+            //and finally import it\n+            api.importSecretsAndSave(exportSecretsFile, securityKey, admin);\n+        }finally {\n+            file.delete();\n+        }\n+    }\n \n-        final String appKey = dataGen.getKey();\n-        //generate secrets\n-        final AppSecrets secrets = builder1.withKey(appKey)\n-                .withHiddenSecret(\"p1\", \"secret-1\")\n-                .withHiddenSecret(\"p2\", \"secret-2\")\n-                .build();\n-        //Save it\n-        api.saveSecrets(secrets, site, admin);\n-        final Optional<AppSecrets> secretsOptional = api.getSecrets(appKey, site, admin);\n-        Assert.assertTrue(secretsOptional.isPresent());\n+    /**\n+     * Method to test {@link AppsAPIImpl#exportSecrets(Key, boolean, Map, User)} and {@link AppsAPIImpl#collectSecretsForExport(Map, User)}\n+     * Given scenario: We're testing exporting secrets generated for different sites (one being SYSTEM_HOST)\n+     * Expected results:  We should be able to recover everthing that initially got exported using the \"exportAll\" param regardless of site.\n+     * @throws DotDataException\n+     * @throws IOException\n+     * @throws AlreadyExistException\n+     * @throws DotSecurityException\n+     * @throws EncryptorException\n+     */\n+    @Test\n+    public void Test_Export_All_Secrets_For_System_Non_System_Sites()\n+            throws DotDataException, IOException, AlreadyExistException, DotSecurityException, EncryptorException {\n+        final User admin = TestUserUtils.getAdminUser();\n+        final AppsAPI api = APILocator.getAppsAPI();\n+        api.resetSecrets(admin);\n \n-        //AES only supports security Key of sizes of 16, 24 or 32 bytes.\n-        final String password = RandomStringUtils.randomAlphanumeric(32);\n-        final Key securityKey = AppsUtil.generateKey(password);\n+        final Host site = new SiteDataGen().nextPersisted();\n+        final Host systemHost = APILocator.getHostAPI().findSystemHost();\n+\n+        //generate a descriptor\n+        final AppSecrets.Builder builder1 = new AppSecrets.Builder();\n+        final AppDescriptorDataGen dataGen = new AppDescriptorDataGen()\n+                .stringParam(\"p1\", false,  true)\n+                .stringParam(\"p2\", false,  true)\n+                .withName(\"app-example\")\n+                .withDescription(\"app\")\n+                .withExtraParameters(false);\n+        final File file = dataGen.nextPersistedDescriptor();\n+        try {\n+            api.createAppDescriptor(file, admin);\n \n-        //Now that we have a valid key lets dump our selection of secrets\n-        final Map<String,Set<String>> appKeysBySite = ImmutableMap.of(site.getIdentifier(), ImmutableSet.of(appKey));\n-        final Path exportSecretsFile = api.exportSecrets(securityKey, false, appKeysBySite, admin);\n-        assertTrue(exportSecretsFile.toFile().exists());\n+            final String appKey = dataGen.getKey();\n+            //generate secrets\n+            final AppSecrets secrets = builder1.withKey(appKey)\n+                    .withHiddenSecret(\"p1\", \"secret-1\")\n+                    .withHiddenSecret(\"p2\", \"secret-2\")\n+                    .build();\n \n-        //Remove the secret we dumped we can re import it.\n-        api.deleteSecrets(appKey, site, admin);\n+            //Save it\n+            api.saveSecrets(secrets, site, admin);\n+            final Optional<AppSecrets> siteSecretsOptional = api.getSecrets(appKey, site, admin);", "originalCommit": "1df7beb593f8610529feb10df86df435b0ae6eac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTIxMTI5MQ==", "url": "https://github.com/dotCMS/core/pull/19491#discussion_r511211291", "bodyText": "Codacy found an issue: Unnecessary use of fully qualified name 'ImmutableMap.of' due to existing static import 'com.google.common.collect.ImmutableMap.of'", "author": "dev-dotcms", "createdAt": "2020-10-24T00:28:56Z", "path": "dotCMS/src/integration-test/java/com/dotcms/security/apps/AppsAPIImplTest.java", "diffHunk": "@@ -1215,39 +1266,143 @@ public void Test_Create_Offending_Secrets_Missing_Site_Then_Export_Them_Then_Imp\n                 .withDescription(\"system-app\")\n                 .withExtraParameters(false);\n         final File file = dataGen.nextPersistedDescriptor();\n-        api.createAppDescriptor(file, admin);\n+        try {\n+            api.createAppDescriptor(file, admin);\n+\n+            final String appKey = dataGen.getKey();\n+            //generate secrets\n+            final AppSecrets secrets = builder1.withKey(appKey)\n+                    .withHiddenSecret(\"p1\", \"secret-1\")\n+                    .withHiddenSecret(\"p2\", \"secret-2\")\n+                    .build();\n+            //Save it\n+            api.saveSecrets(secrets, site, admin);\n+            final Optional<AppSecrets> secretsOptional = api.getSecrets(appKey, site, admin);\n+            Assert.assertTrue(secretsOptional.isPresent());\n+\n+            //AES only supports security Key of sizes of 16, 24 or 32 bytes.\n+            final String password = RandomStringUtils.randomAlphanumeric(32);\n+            final Key securityKey = AppsUtil.generateKey(password);\n+\n+            //Now that we have a valid key lets dump our selection of secrets\n+            final Map<String, Set<String>> appKeysBySite = ImmutableMap\n+                    .of(site.getIdentifier(), ImmutableSet.of(appKey));\n+            final Path exportSecretsFile = api\n+                    .exportSecrets(securityKey, false, appKeysBySite, admin);\n+            assertTrue(exportSecretsFile.toFile().exists());\n+\n+            //Remove the secret we dumped we can re import it.\n+            api.deleteSecrets(appKey, site, admin);\n+\n+            //Now we're gonna create an inconsistency removing the app descriptor and then try to import the secret.\n+            final HostAPI hostAPI = APILocator.getHostAPI();\n+            hostAPI.archive(site, admin, false);\n+            hostAPI.delete(site, admin, false);\n+\n+            //and finally import it\n+            api.importSecretsAndSave(exportSecretsFile, securityKey, admin);\n+        }finally {\n+            file.delete();\n+        }\n+    }\n \n-        final String appKey = dataGen.getKey();\n-        //generate secrets\n-        final AppSecrets secrets = builder1.withKey(appKey)\n-                .withHiddenSecret(\"p1\", \"secret-1\")\n-                .withHiddenSecret(\"p2\", \"secret-2\")\n-                .build();\n-        //Save it\n-        api.saveSecrets(secrets, site, admin);\n-        final Optional<AppSecrets> secretsOptional = api.getSecrets(appKey, site, admin);\n-        Assert.assertTrue(secretsOptional.isPresent());\n+    /**\n+     * Method to test {@link AppsAPIImpl#exportSecrets(Key, boolean, Map, User)} and {@link AppsAPIImpl#collectSecretsForExport(Map, User)}\n+     * Given scenario: We're testing exporting secrets generated for different sites (one being SYSTEM_HOST)\n+     * Expected results:  We should be able to recover everthing that initially got exported using the \"exportAll\" param regardless of site.\n+     * @throws DotDataException\n+     * @throws IOException\n+     * @throws AlreadyExistException\n+     * @throws DotSecurityException\n+     * @throws EncryptorException\n+     */\n+    @Test\n+    public void Test_Export_All_Secrets_For_System_Non_System_Sites()\n+            throws DotDataException, IOException, AlreadyExistException, DotSecurityException, EncryptorException {\n+        final User admin = TestUserUtils.getAdminUser();\n+        final AppsAPI api = APILocator.getAppsAPI();\n+        api.resetSecrets(admin);\n \n-        //AES only supports security Key of sizes of 16, 24 or 32 bytes.\n-        final String password = RandomStringUtils.randomAlphanumeric(32);\n-        final Key securityKey = AppsUtil.generateKey(password);\n+        final Host site = new SiteDataGen().nextPersisted();\n+        final Host systemHost = APILocator.getHostAPI().findSystemHost();\n+\n+        //generate a descriptor\n+        final AppSecrets.Builder builder1 = new AppSecrets.Builder();\n+        final AppDescriptorDataGen dataGen = new AppDescriptorDataGen()\n+                .stringParam(\"p1\", false,  true)\n+                .stringParam(\"p2\", false,  true)\n+                .withName(\"app-example\")\n+                .withDescription(\"app\")\n+                .withExtraParameters(false);\n+        final File file = dataGen.nextPersistedDescriptor();\n+        try {\n+            api.createAppDescriptor(file, admin);\n \n-        //Now that we have a valid key lets dump our selection of secrets\n-        final Map<String,Set<String>> appKeysBySite = ImmutableMap.of(site.getIdentifier(), ImmutableSet.of(appKey));\n-        final Path exportSecretsFile = api.exportSecrets(securityKey, false, appKeysBySite, admin);\n-        assertTrue(exportSecretsFile.toFile().exists());\n+            final String appKey = dataGen.getKey();\n+            //generate secrets\n+            final AppSecrets secrets = builder1.withKey(appKey)\n+                    .withHiddenSecret(\"p1\", \"secret-1\")\n+                    .withHiddenSecret(\"p2\", \"secret-2\")\n+                    .build();\n \n-        //Remove the secret we dumped we can re import it.\n-        api.deleteSecrets(appKey, site, admin);\n+            //Save it\n+            api.saveSecrets(secrets, site, admin);\n+            final Optional<AppSecrets> siteSecretsOptional = api.getSecrets(appKey, site, admin);\n \n-        //Now we're gonna create an inconsistency removing the app descriptor and then try to import the secret.\n-        final HostAPI hostAPI = APILocator.getHostAPI();\n-        hostAPI.archive(site, admin, false);\n-        hostAPI.delete(site, admin, false);\n+            api.saveSecrets(secrets, systemHost, admin);\n+            final Optional<AppSecrets> systemHostSecretsOptional = api\n+                    .getSecrets(appKey, systemHost, admin);\n+\n+            //AES only supports security Key of sizes of 16, 24 or 32 bytes.\n+            final String password = RandomStringUtils.randomAlphanumeric(32);\n+            final Key securityKey = AppsUtil.generateKey(password);\n+\n+            //Now that we have a valid key lets dump all our secrets.\n+            final Path exportSecretsFile = api.exportSecrets(securityKey, true, null, admin);\n+            assertTrue(exportSecretsFile.toFile().exists());\n+\n+            assertTrue(exportSecretsFile.toFile().exists());\n+\n+            //Remove the secret we dumped we can re import it.\n+            api.deleteSecrets(appKey, site, admin);\n+            api.deleteSecrets(appKey, systemHost, admin);\n+\n+            //and finally import it\n+            api.importSecretsAndSave(exportSecretsFile, securityKey, admin);\n \n-        //and finally import it\n-        api.importSecretsAndSave(exportSecretsFile, securityKey, admin);\n+            //verify\n+            final Optional<AppSecrets> secretsOptionalPostImport1 = api.getSecrets(appKey, site, admin);\n+            assertTrue(secretsOptionalPostImport1.isPresent());\n+            final AppSecrets restoredSecrets1 = secretsOptionalPostImport1.get();\n+\n+            final Optional<AppSecrets> secretsOptionalPostImport2 = api.getSecrets(appKey, systemHost, admin);\n+            assertTrue(secretsOptionalPostImport2.isPresent());\n+            final AppSecrets restoredSecrets2 = secretsOptionalPostImport2.get();\n+\n+            assertEquals(restoredSecrets1.getKey(),appKey);\n+            assertEquals(restoredSecrets2.getKey(),appKey);\n+\n+            assertTrue(restoredSecrets1.getSecrets().containsKey(\"p1\"));\n+            assertTrue(restoredSecrets2.getSecrets().containsKey(\"p2\"));\n+\n+        }finally {\n+           file.delete();\n+        }\n+\n+    }\n+\n+    /**\n+     * Method to test {@link ExportSecretForm#toString()}\n+     * Given scenario: We feed the form with null and non null values\n+     * Expected results: We expect the form to behave NPE Free when calling toString\n+     */\n+    @Test\n+    public void Test_NPE_Free_ToString(){\n+        final ExportSecretForm formAllNull = new ExportSecretForm(null, false, null);\n+        assertNotNull(formAllNull.toString());\n \n+        final ExportSecretForm formNotAllNull = new ExportSecretForm(null, false, ImmutableMap.of(\"1\", ImmutableSet.of(\"1\",\"2\")));", "originalCommit": "1df7beb593f8610529feb10df86df435b0ae6eac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}