{"pr_number": 18604, "pr_title": "Issue 17842 show notification if es is read only", "pr_createdAt": "2020-06-04T20:06:34Z", "pr_url": "https://github.com/dotCMS/core/pull/18604", "timeline": [{"oid": "f8a37190b75b3b2146f12218b9be2a81806e55d1", "url": "https://github.com/dotCMS/core/commit/f8a37190b75b3b2146f12218b9be2a81806e55d1", "message": "#17842 Show Notification if ES is read-only", "committedDate": "2020-05-21T21:37:13Z", "type": "commit"}, {"oid": "848212aeb38c115e58188a366dd1fbc0dca3fead", "url": "https://github.com/dotCMS/core/commit/848212aeb38c115e58188a366dd1fbc0dca3fead", "message": "#17842 Show Notification if ES is read-only", "committedDate": "2020-05-26T16:03:26Z", "type": "commit"}, {"oid": "016df3d98fc2306584781385221e91b5519cf028", "url": "https://github.com/dotCMS/core/commit/016df3d98fc2306584781385221e91b5519cf028", "message": "#17842", "committedDate": "2020-05-27T18:14:09Z", "type": "commit"}, {"oid": "7ed082f856f94321eee397f6a8e59fac1b2587fc", "url": "https://github.com/dotCMS/core/commit/7ed082f856f94321eee397f6a8e59fac1b2587fc", "message": "merge", "committedDate": "2020-06-03T15:13:39Z", "type": "commit"}, {"oid": "8f8add6764dee9ca65d7bdcd74e8a53f0922c8be", "url": "https://github.com/dotCMS/core/commit/8f8add6764dee9ca65d7bdcd74e8a53f0922c8be", "message": "merge", "committedDate": "2020-06-03T15:16:11Z", "type": "commit"}, {"oid": "8fbb7a079df458b7457ab615b5e8fc04c0942e35", "url": "https://github.com/dotCMS/core/commit/8fbb7a079df458b7457ab615b5e8fc04c0942e35", "message": "#17842 Fixing and cleaning", "committedDate": "2020-06-04T15:31:34Z", "type": "commit"}, {"oid": "87c6f9705f910814eb87b1b13c49c773d6ad1edd", "url": "https://github.com/dotCMS/core/commit/87c6f9705f910814eb87b1b13c49c773d6ad1edd", "message": "#17842 Testing", "committedDate": "2020-06-04T19:15:28Z", "type": "commit"}, {"oid": "525111a7d3b1082c3bb069ed901498dd3317cda9", "url": "https://github.com/dotCMS/core/commit/525111a7d3b1082c3bb069ed901498dd3317cda9", "message": "#17842 Merge", "committedDate": "2020-06-04T19:19:33Z", "type": "commit"}, {"oid": "0bf0a53f796560307f7908e3992ac85bba031528", "url": "https://github.com/dotCMS/core/commit/0bf0a53f796560307f7908e3992ac85bba031528", "message": "#17842 Removing unnecessary logger", "committedDate": "2020-06-04T19:21:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUyMTkyNg==", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r435521926", "bodyText": "Use Try.of().getOrThrow(DotRuntimeException::new) instead", "author": "jdotcms", "createdAt": "2020-06-04T20:12:37Z", "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESIndexUtil.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.util.Logger;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.action.admin.indices.settings.get.GetSettingsRequest;\n+import org.elasticsearch.action.admin.indices.settings.get.GetSettingsResponse;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+public class ESIndexUtil {\n+    private final static String READ_ONLY_ALLOW_DELETE_SETTING = \"index.blocks.read_only_allow_delete\";\n+    private final static String READ_ONLY_SETTING = \"index.blocks.read_only\";\n+\n+    private ESIndexUtil(){}\n+\n+    public static  boolean isReadOnly(final String... indexNames) {\n+        final GetSettingsRequest request = new GetSettingsRequest().indices(indexNames);\n+\n+        Logger.info(ESIndexUtil.class, Thread.currentThread().getName() + \"- Checking if current index are read only\");\n+\n+        final GetSettingsResponse response = Sneaky.sneak(() ->", "originalCommit": "0bf0a53f796560307f7908e3992ac85bba031528", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwNzY4Ng==", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436207686", "bodyText": "done fc979e0#diff-63af77826d67a38fb99a8eccd3d5b770R37", "author": "freddyucv", "createdAt": "2020-06-05T23:40:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUyMTkyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUyMjYyNQ==", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r435522625", "bodyText": "rename to isAnyReadOnly", "author": "jdotcms", "createdAt": "2020-06-04T20:14:02Z", "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESIndexUtil.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.util.Logger;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.action.admin.indices.settings.get.GetSettingsRequest;\n+import org.elasticsearch.action.admin.indices.settings.get.GetSettingsResponse;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+public class ESIndexUtil {\n+    private final static String READ_ONLY_ALLOW_DELETE_SETTING = \"index.blocks.read_only_allow_delete\";\n+    private final static String READ_ONLY_SETTING = \"index.blocks.read_only\";\n+\n+    private ESIndexUtil(){}\n+\n+    public static  boolean isReadOnly(final String... indexNames) {", "originalCommit": "0bf0a53f796560307f7908e3992ac85bba031528", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEzOTIzNw==", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436139237", "bodyText": "yes we need to rename as @jdotcms said", "author": "dsilvam", "createdAt": "2020-06-05T20:04:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUyMjYyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwNzc4OA==", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436207788", "bodyText": "done fc979e0#diff-63af77826d67a38fb99a8eccd3d5b770R88", "author": "freddyucv", "createdAt": "2020-06-05T23:40:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUyMjYyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUyNDU1MA==", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r435524550", "bodyText": "I think you do not need to call the ESIndexUtil if you are already in there", "author": "jdotcms", "createdAt": "2020-06-04T20:17:58Z", "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESIndexUtil.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.util.Logger;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.action.admin.indices.settings.get.GetSettingsRequest;\n+import org.elasticsearch.action.admin.indices.settings.get.GetSettingsResponse;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+public class ESIndexUtil {\n+    private final static String READ_ONLY_ALLOW_DELETE_SETTING = \"index.blocks.read_only_allow_delete\";\n+    private final static String READ_ONLY_SETTING = \"index.blocks.read_only\";\n+\n+    private ESIndexUtil(){}\n+\n+    public static  boolean isReadOnly(final String... indexNames) {\n+        final GetSettingsRequest request = new GetSettingsRequest().indices(indexNames);\n+\n+        Logger.info(ESIndexUtil.class, Thread.currentThread().getName() + \"- Checking if current index are read only\");\n+\n+        final GetSettingsResponse response = Sneaky.sneak(() ->\n+                RestHighLevelClientProvider.getInstance().getClient().indices()\n+                        .getSettings(request, RequestOptions.DEFAULT));\n+\n+        Logger.info(ESIndexUtil.class, Thread.currentThread().getName() + \"- RESPONSE Checking if current index are read only\");\n+\n+        return Arrays.stream(indexNames).anyMatch((indexName) -> {\n+            final String readOnlyAllowDelete = response.getSetting(indexName, READ_ONLY_ALLOW_DELETE_SETTING);\n+            final String readOnly = response.getSetting(indexName, READ_ONLY_SETTING);\n+\n+            return Boolean.parseBoolean(readOnlyAllowDelete) || Boolean.parseBoolean(readOnly);\n+        });\n+    }\n+\n+    public static AcknowledgedResponse putReadOnlyToFalse(final String... indexName) {\n+        final UpdateSettingsRequest request = new UpdateSettingsRequest(indexName);\n+\n+        final Settings.Builder settingBuilder = Settings.builder()\n+                .put(READ_ONLY_ALLOW_DELETE_SETTING, false)\n+                .put(READ_ONLY_SETTING, false);\n+\n+        request.settings(settingBuilder);\n+\n+        return Sneaky.sneak(() ->\n+                RestHighLevelClientProvider.getInstance().getClient().indices()\n+                        .putSettings(request, RequestOptions.DEFAULT)\n+        );\n+    }\n+\n+    public static boolean isAnyCurrentIndicesReadOnly() {\n+        final IndiciesInfo indiciesInfo = loadIndicesInfo();\n+        return ESIndexUtil.isReadOnly(indiciesInfo.getLive(), indiciesInfo.getWorking());", "originalCommit": "0bf0a53f796560307f7908e3992ac85bba031528", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUyNTA4Ng==", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r435525086", "bodyText": "this should be final", "author": "jdotcms", "createdAt": "2020-06-04T20:19:02Z", "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESReadOnlyMonitor.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.api.system.event.message.MessageSeverity;\n+import com.dotcms.api.system.event.message.MessageType;\n+import com.dotcms.api.system.event.message.SystemMessageEventUtil;\n+import com.dotcms.api.system.event.message.builder.SystemMessageBuilder;\n+import com.dotcms.concurrent.DotConcurrentFactory;\n+import com.dotcms.enterprise.LicenseUtil;\n+import com.dotcms.repackage.com.google.common.annotations.VisibleForTesting;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.RoleAPI;\n+import com.dotmarketing.common.reindex.ReindexEntry;\n+import com.dotmarketing.common.reindex.ReindexThread;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.util.Logger;\n+import com.liferay.portal.language.LanguageException;\n+import com.liferay.portal.language.LanguageUtil;\n+\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import static com.dotcms.util.CollectionsUtils.list;\n+\n+/**\n+ * Run a Monitor If the current indices are in read only mode and try to set them to write mode again.\n+ * When the set write mode fail it try again after one minute.\n+ */\n+public class ESReadOnlyMonitor {\n+    private final RoleAPI roleAPI;\n+    private final SystemMessageEventUtil systemMessageEventUtil;\n+\n+    private AtomicBoolean started = new AtomicBoolean();", "originalCommit": "0bf0a53f796560307f7908e3992ac85bba031528", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwNzg3Nw==", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436207877", "bodyText": "done fc979e0#diff-8528ec811f60c9aae6301f9071d59872R34", "author": "freddyucv", "createdAt": "2020-06-05T23:41:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUyNTA4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUyNjM1Mg==", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r435526352", "bodyText": "remember use the supplier", "author": "jdotcms", "createdAt": "2020-06-04T20:21:32Z", "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESReadOnlyMonitor.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.api.system.event.message.MessageSeverity;\n+import com.dotcms.api.system.event.message.MessageType;\n+import com.dotcms.api.system.event.message.SystemMessageEventUtil;\n+import com.dotcms.api.system.event.message.builder.SystemMessageBuilder;\n+import com.dotcms.concurrent.DotConcurrentFactory;\n+import com.dotcms.enterprise.LicenseUtil;\n+import com.dotcms.repackage.com.google.common.annotations.VisibleForTesting;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.RoleAPI;\n+import com.dotmarketing.common.reindex.ReindexEntry;\n+import com.dotmarketing.common.reindex.ReindexThread;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.util.Logger;\n+import com.liferay.portal.language.LanguageException;\n+import com.liferay.portal.language.LanguageUtil;\n+\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import static com.dotcms.util.CollectionsUtils.list;\n+\n+/**\n+ * Run a Monitor If the current indices are in read only mode and try to set them to write mode again.\n+ * When the set write mode fail it try again after one minute.\n+ */\n+public class ESReadOnlyMonitor {\n+    private final RoleAPI roleAPI;\n+    private final SystemMessageEventUtil systemMessageEventUtil;\n+\n+    private AtomicBoolean started = new AtomicBoolean();\n+    private final ScheduledThreadPoolExecutor scheduledThreadPoolExecutor;\n+\n+    private Timer timer;\n+\n+    private ESReadOnlyMonitor(final SystemMessageEventUtil systemMessageEventUtil, final RoleAPI roleAPI) {\n+        this.systemMessageEventUtil = systemMessageEventUtil;\n+        this.roleAPI = roleAPI;\n+        started.set(false);\n+\n+        scheduledThreadPoolExecutor = new ScheduledThreadPoolExecutor(1);\n+        scheduledThreadPoolExecutor.setContinueExistingPeriodicTasksAfterShutdownPolicy(true);\n+    }\n+\n+    private ESReadOnlyMonitor() {\n+        this(SystemMessageEventUtil.getInstance(), APILocator.getRoleAPI());\n+    }\n+\n+    // Inner class to provide instance of class\n+    private static class Singleton\n+    {\n+        private static final ESReadOnlyMonitor INSTANCE = new ESReadOnlyMonitor();\n+    }\n+\n+    @VisibleForTesting\n+    public static ESReadOnlyMonitor getInstance(\n+            final SystemMessageEventUtil systemMessageEventUtil,\n+            final RoleAPI roleAPI)\n+    {\n+        return new ESReadOnlyMonitor(systemMessageEventUtil, roleAPI);\n+    }\n+    public static ESReadOnlyMonitor getInstance()\n+    {\n+        return Singleton.INSTANCE;\n+    }\n+\n+    public void start(final ReindexEntry reindexEntry, final String cause){\n+        if (started.compareAndSet(false, true)) {\n+            Logger.error(this.getClass(), Thread.currentThread().getName() + \" - Reindex failed for :\" + reindexEntry + \" because \" + cause);\n+\n+            if (ESIndexUtil.isAnyCurrentIndicesReadOnly()) {\n+                ReindexThread.setCurrentIndexReadOnly(true);\n+                sendMessage(\"es.index.read.only.message\");\n+                startMonitor();\n+            } else {\n+                started.set(false);\n+            }\n+        }\n+    }\n+\n+    private void sendMessage(final String messageKey) {\n+        try {\n+            final Role adminRole = roleAPI.loadCMSAdminRole();\n+            final List<String> usersId = roleAPI.findUsersForRole(adminRole)\n+                    .stream()\n+                    .map(user -> user.getUserId())\n+                    .collect(Collectors.toList());\n+\n+            final SystemMessageBuilder message = new SystemMessageBuilder()\n+                    .setMessage(LanguageUtil.get(messageKey))\n+                    .setSeverity(MessageSeverity.ERROR)\n+                    .setType(MessageType.SIMPLE_MESSAGE)\n+                    .setLife(TimeUnit.SECONDS.toMillis(5));\n+\n+            systemMessageEventUtil.pushMessage(message.create(), usersId);\n+        } catch (final LanguageException | DotDataException | DotSecurityException e) {\n+            Logger.warn(ESReadOnlyMonitor.class, () -> e.getMessage());\n+        }\n+    }\n+\n+    private void putCurrentIndicesToWriteMode() {\n+        try {\n+            Logger.debug(this.getClass(), \"Trying to set the current indices to Write mode\");", "originalCommit": "0bf0a53f796560307f7908e3992ac85bba031528", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwNzkzNQ==", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436207935", "bodyText": "done fc979e0#diff-8528ec811f60c9aae6301f9071d59872R102", "author": "freddyucv", "createdAt": "2020-06-05T23:41:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUyNjM1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUyNjc5NA==", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r435526794", "bodyText": "I am not sure if this is thread-safe", "author": "jdotcms", "createdAt": "2020-06-04T20:22:23Z", "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESReadOnlyMonitor.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.api.system.event.message.MessageSeverity;\n+import com.dotcms.api.system.event.message.MessageType;\n+import com.dotcms.api.system.event.message.SystemMessageEventUtil;\n+import com.dotcms.api.system.event.message.builder.SystemMessageBuilder;\n+import com.dotcms.concurrent.DotConcurrentFactory;\n+import com.dotcms.enterprise.LicenseUtil;\n+import com.dotcms.repackage.com.google.common.annotations.VisibleForTesting;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.RoleAPI;\n+import com.dotmarketing.common.reindex.ReindexEntry;\n+import com.dotmarketing.common.reindex.ReindexThread;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.util.Logger;\n+import com.liferay.portal.language.LanguageException;\n+import com.liferay.portal.language.LanguageUtil;\n+\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import static com.dotcms.util.CollectionsUtils.list;\n+\n+/**\n+ * Run a Monitor If the current indices are in read only mode and try to set them to write mode again.\n+ * When the set write mode fail it try again after one minute.\n+ */\n+public class ESReadOnlyMonitor {\n+    private final RoleAPI roleAPI;\n+    private final SystemMessageEventUtil systemMessageEventUtil;\n+\n+    private AtomicBoolean started = new AtomicBoolean();\n+    private final ScheduledThreadPoolExecutor scheduledThreadPoolExecutor;\n+\n+    private Timer timer;\n+\n+    private ESReadOnlyMonitor(final SystemMessageEventUtil systemMessageEventUtil, final RoleAPI roleAPI) {\n+        this.systemMessageEventUtil = systemMessageEventUtil;\n+        this.roleAPI = roleAPI;\n+        started.set(false);\n+\n+        scheduledThreadPoolExecutor = new ScheduledThreadPoolExecutor(1);\n+        scheduledThreadPoolExecutor.setContinueExistingPeriodicTasksAfterShutdownPolicy(true);\n+    }\n+\n+    private ESReadOnlyMonitor() {\n+        this(SystemMessageEventUtil.getInstance(), APILocator.getRoleAPI());\n+    }\n+\n+    // Inner class to provide instance of class\n+    private static class Singleton\n+    {\n+        private static final ESReadOnlyMonitor INSTANCE = new ESReadOnlyMonitor();\n+    }\n+\n+    @VisibleForTesting\n+    public static ESReadOnlyMonitor getInstance(\n+            final SystemMessageEventUtil systemMessageEventUtil,\n+            final RoleAPI roleAPI)\n+    {\n+        return new ESReadOnlyMonitor(systemMessageEventUtil, roleAPI);\n+    }\n+    public static ESReadOnlyMonitor getInstance()\n+    {\n+        return Singleton.INSTANCE;\n+    }\n+\n+    public void start(final ReindexEntry reindexEntry, final String cause){\n+        if (started.compareAndSet(false, true)) {\n+            Logger.error(this.getClass(), Thread.currentThread().getName() + \" - Reindex failed for :\" + reindexEntry + \" because \" + cause);\n+\n+            if (ESIndexUtil.isAnyCurrentIndicesReadOnly()) {\n+                ReindexThread.setCurrentIndexReadOnly(true);\n+                sendMessage(\"es.index.read.only.message\");\n+                startMonitor();\n+            } else {\n+                started.set(false);\n+            }\n+        }\n+    }\n+\n+    private void sendMessage(final String messageKey) {\n+        try {\n+            final Role adminRole = roleAPI.loadCMSAdminRole();\n+            final List<String> usersId = roleAPI.findUsersForRole(adminRole)\n+                    .stream()\n+                    .map(user -> user.getUserId())\n+                    .collect(Collectors.toList());\n+\n+            final SystemMessageBuilder message = new SystemMessageBuilder()\n+                    .setMessage(LanguageUtil.get(messageKey))\n+                    .setSeverity(MessageSeverity.ERROR)\n+                    .setType(MessageType.SIMPLE_MESSAGE)\n+                    .setLife(TimeUnit.SECONDS.toMillis(5));\n+\n+            systemMessageEventUtil.pushMessage(message.create(), usersId);\n+        } catch (final LanguageException | DotDataException | DotSecurityException e) {\n+            Logger.warn(ESReadOnlyMonitor.class, () -> e.getMessage());\n+        }\n+    }\n+\n+    private void putCurrentIndicesToWriteMode() {\n+        try {\n+            Logger.debug(this.getClass(), \"Trying to set the current indices to Write mode\");\n+            ESIndexUtil.putCurrentIndicesToWriteMode();\n+            sendMessage(\"es.index.write.allow.message\");\n+            ReindexThread.setCurrentIndexReadOnly(false);\n+\n+            this.stop();\n+        } catch (final ESResponseException e) {\n+            Logger.info(ESReadOnlyMonitor.class, ()  -> e.getMessage());\n+        }\n+    }\n+\n+    private void startMonitor() {\n+        timer = new Timer(true);", "originalCommit": "0bf0a53f796560307f7908e3992ac85bba031528", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwNzk5NQ==", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436207995", "bodyText": "done fc979e0#diff-8528ec811f60c9aae6301f9071d59872R113", "author": "freddyucv", "createdAt": "2020-06-05T23:41:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUyNjc5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUyNzM0Ng==", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r435527346", "bodyText": "Not sure if we should create thread, DotConcurrentFactory is your friend", "author": "jdotcms", "createdAt": "2020-06-04T20:23:32Z", "path": "dotCMS/src/main/java/com/dotmarketing/common/reindex/ReindexQueueAPIImpl.java", "diffHunk": "@@ -219,14 +222,14 @@ public void deleteReindexEntry(String identiferToDelete) throws DotDataException\n         reindexQueueFactory.deleteReindexEntry(identiferToDelete);\n     }\n \n-\n-\n     @Override\n     @WrapInTransaction\n     public void markAsFailed(final ReindexEntry idx, final String cause) throws DotDataException {\n-        Logger.warn(this.getClass(), \"Reindex failed for :\" + idx + \" because \" + cause);\n         reindexQueueFactory.markAsFailed(idx, UtilMethods.shortenString(cause, 300));\n \n+        new Thread(", "originalCommit": "0bf0a53f796560307f7908e3992ac85bba031528", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwODA1Ng==", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436208056", "bodyText": "done fc979e0#diff-25af5da06ceca449aa6c6a84fca39091R231", "author": "freddyucv", "createdAt": "2020-06-05T23:42:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUyNzM0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUyNzU4MA==", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r435527580", "bodyText": "set to final", "author": "jdotcms", "createdAt": "2020-06-04T20:23:58Z", "path": "dotCMS/src/main/java/com/dotmarketing/common/reindex/ReindexThread.java", "diffHunk": "@@ -323,4 +328,7 @@ protected void sendNotification(final String key, final Object[] msgParams, fina\n         systemUser.getLocale());\n   }\n \n+    public static void setCurrentIndexReadOnly(boolean currentIndexReadOnly) {", "originalCommit": "0bf0a53f796560307f7908e3992ac85bba031528", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwODExMw==", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436208113", "bodyText": "done fc979e0#diff-6aad54df22d1ffe94dc4adf9a1d98637R331", "author": "freddyucv", "createdAt": "2020-06-05T23:42:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUyNzU4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU2OTEyOA==", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r435569128", "bodyText": "\"is\" read only", "author": "nollymar", "createdAt": "2020-06-04T21:42:06Z", "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESIndexUtil.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.util.Logger;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.action.admin.indices.settings.get.GetSettingsRequest;\n+import org.elasticsearch.action.admin.indices.settings.get.GetSettingsResponse;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+public class ESIndexUtil {\n+    private final static String READ_ONLY_ALLOW_DELETE_SETTING = \"index.blocks.read_only_allow_delete\";\n+    private final static String READ_ONLY_SETTING = \"index.blocks.read_only\";\n+\n+    private ESIndexUtil(){}\n+\n+    public static  boolean isReadOnly(final String... indexNames) {\n+        final GetSettingsRequest request = new GetSettingsRequest().indices(indexNames);\n+\n+        Logger.info(ESIndexUtil.class, Thread.currentThread().getName() + \"- Checking if current index are read only\");", "originalCommit": "0bf0a53f796560307f7908e3992ac85bba031528", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEzOTQ4Mw==", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436139483", "bodyText": "\"Checking if any of the provided indices is ready only\"", "author": "dsilvam", "createdAt": "2020-06-05T20:04:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU2OTEyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEzOTkxMw==", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436139913", "bodyText": "maybe we can remove this Logger?", "author": "dsilvam", "createdAt": "2020-06-05T20:05:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU2OTEyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwODI0Mw==", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436208243", "bodyText": "done fc979e0#diff-63af77826d67a38fb99a8eccd3d5b770R35", "author": "freddyucv", "createdAt": "2020-06-05T23:43:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU2OTEyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU2OTk0OA==", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r435569948", "bodyText": "Shouldn't you log the reason of the exception?", "author": "nollymar", "createdAt": "2020-06-04T21:44:01Z", "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESIndexUtil.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.util.Logger;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.action.admin.indices.settings.get.GetSettingsRequest;\n+import org.elasticsearch.action.admin.indices.settings.get.GetSettingsResponse;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+public class ESIndexUtil {\n+    private final static String READ_ONLY_ALLOW_DELETE_SETTING = \"index.blocks.read_only_allow_delete\";\n+    private final static String READ_ONLY_SETTING = \"index.blocks.read_only\";\n+\n+    private ESIndexUtil(){}\n+\n+    public static  boolean isReadOnly(final String... indexNames) {\n+        final GetSettingsRequest request = new GetSettingsRequest().indices(indexNames);\n+\n+        Logger.info(ESIndexUtil.class, Thread.currentThread().getName() + \"- Checking if current index are read only\");\n+\n+        final GetSettingsResponse response = Sneaky.sneak(() ->\n+                RestHighLevelClientProvider.getInstance().getClient().indices()\n+                        .getSettings(request, RequestOptions.DEFAULT));\n+\n+        Logger.info(ESIndexUtil.class, Thread.currentThread().getName() + \"- RESPONSE Checking if current index are read only\");\n+\n+        return Arrays.stream(indexNames).anyMatch((indexName) -> {\n+            final String readOnlyAllowDelete = response.getSetting(indexName, READ_ONLY_ALLOW_DELETE_SETTING);\n+            final String readOnly = response.getSetting(indexName, READ_ONLY_SETTING);\n+\n+            return Boolean.parseBoolean(readOnlyAllowDelete) || Boolean.parseBoolean(readOnly);\n+        });\n+    }\n+\n+    public static AcknowledgedResponse putReadOnlyToFalse(final String... indexName) {\n+        final UpdateSettingsRequest request = new UpdateSettingsRequest(indexName);\n+\n+        final Settings.Builder settingBuilder = Settings.builder()\n+                .put(READ_ONLY_ALLOW_DELETE_SETTING, false)\n+                .put(READ_ONLY_SETTING, false);\n+\n+        request.settings(settingBuilder);\n+\n+        return Sneaky.sneak(() ->\n+                RestHighLevelClientProvider.getInstance().getClient().indices()\n+                        .putSettings(request, RequestOptions.DEFAULT)\n+        );\n+    }\n+\n+    public static boolean isAnyCurrentIndicesReadOnly() {\n+        final IndiciesInfo indiciesInfo = loadIndicesInfo();\n+        return ESIndexUtil.isReadOnly(indiciesInfo.getLive(), indiciesInfo.getWorking());\n+    }\n+\n+    public static void putCurrentIndicesToWriteMode() throws ESResponseException {\n+        final IndiciesInfo indiciesInfo = loadIndicesInfo();\n+        final AcknowledgedResponse response = ESIndexUtil.putReadOnlyToFalse(indiciesInfo.getLive(), indiciesInfo.getWorking());\n+\n+        if (!response.isAcknowledged()) {\n+            throw new ESResponseException(response);", "originalCommit": "0bf0a53f796560307f7908e3992ac85bba031528", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwODMwMg==", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436208302", "bodyText": "the response have the reason", "author": "freddyucv", "createdAt": "2020-06-05T23:43:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU2OTk0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU3MTkyOA==", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r435571928", "bodyText": "I think the test name should be changed because you are testing a not read only scenario", "author": "nollymar", "createdAt": "2020-06-04T21:48:32Z", "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESIndexUtilTest.java", "diffHunk": "@@ -0,0 +1,199 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.ElasticsearchStatusException;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.junit.BeforeClass;\n+import com.dotcms.util.IntegrationTestInitService;\n+import org.junit.Test;\n+\n+import static org.jgroups.util.Util.assertEquals;\n+\n+public class ESIndexUtilTest {\n+\n+    @BeforeClass\n+    public static void prepare () throws Exception {\n+        //Setting web app environment\n+        IntegrationTestInitService.getInstance().init();\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index is not read only\n+     * Should:return false\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldReturnFalseIfTheCurrentIndicesAreReadOnly() throws DotDataException {", "originalCommit": "0bf0a53f796560307f7908e3992ac85bba031528", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjExNDM1NQ==", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436114355", "bodyText": "exactly", "author": "dsilvam", "createdAt": "2020-06-05T19:11:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU3MTkyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwODM5NQ==", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436208395", "bodyText": "done fc979e0#diff-1e54965847e19cc0a77583c4dbd18afdR36", "author": "freddyucv", "createdAt": "2020-06-05T23:44:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU3MTkyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU3MjI5Ng==", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r435572296", "bodyText": "DoesNotExist", "author": "nollymar", "createdAt": "2020-06-04T21:49:24Z", "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESIndexUtilTest.java", "diffHunk": "@@ -0,0 +1,199 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.ElasticsearchStatusException;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.junit.BeforeClass;\n+import com.dotcms.util.IntegrationTestInitService;\n+import org.junit.Test;\n+\n+import static org.jgroups.util.Util.assertEquals;\n+\n+public class ESIndexUtilTest {\n+\n+    @BeforeClass\n+    public static void prepare () throws Exception {\n+        //Setting web app environment\n+        IntegrationTestInitService.getInstance().init();\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index is not read only\n+     * Should:return false\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldReturnFalseIfTheCurrentIndicesAreReadOnly() throws DotDataException {\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        try {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+\n+            final boolean readOnly = ESIndexUtil.isReadOnly(indiciesInfo.getWorking());\n+\n+            assertEquals(false, readOnly);\n+        } finally {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index is read only\n+     * Should:return true\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldReturnTrueIfTheCurrentIndicesAreReadOnly() throws DotDataException {\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        try {\n+            putReadOnly(indiciesInfo.getWorking(), true);\n+\n+            final boolean readOnly = ESIndexUtil.isReadOnly(indiciesInfo.getWorking());\n+\n+            assertEquals(true, readOnly);\n+        } finally {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index not exists\n+     * Should: throw a {@link org.elasticsearch.ElasticsearchStatusException}\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test (expected = ElasticsearchStatusException.class)\n+    public void whenTheIndexNotExistsShouldThrowException() {", "originalCommit": "0bf0a53f796560307f7908e3992ac85bba031528", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwODQ1Mg==", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436208452", "bodyText": "done fc979e0#diff-1e54965847e19cc0a77583c4dbd18afdR80", "author": "freddyucv", "createdAt": "2020-06-05T23:44:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU3MjI5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU3MzE4OQ==", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r435573189", "bodyText": "is read only", "author": "nollymar", "createdAt": "2020-06-04T21:51:20Z", "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESIndexUtilTest.java", "diffHunk": "@@ -0,0 +1,199 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.ElasticsearchStatusException;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.junit.BeforeClass;\n+import com.dotcms.util.IntegrationTestInitService;\n+import org.junit.Test;\n+\n+import static org.jgroups.util.Util.assertEquals;\n+\n+public class ESIndexUtilTest {\n+\n+    @BeforeClass\n+    public static void prepare () throws Exception {\n+        //Setting web app environment\n+        IntegrationTestInitService.getInstance().init();\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index is not read only\n+     * Should:return false\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldReturnFalseIfTheCurrentIndicesAreReadOnly() throws DotDataException {\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        try {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+\n+            final boolean readOnly = ESIndexUtil.isReadOnly(indiciesInfo.getWorking());\n+\n+            assertEquals(false, readOnly);\n+        } finally {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index is read only\n+     * Should:return true\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldReturnTrueIfTheCurrentIndicesAreReadOnly() throws DotDataException {\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        try {\n+            putReadOnly(indiciesInfo.getWorking(), true);\n+\n+            final boolean readOnly = ESIndexUtil.isReadOnly(indiciesInfo.getWorking());\n+\n+            assertEquals(true, readOnly);\n+        } finally {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index not exists\n+     * Should: throw a {@link org.elasticsearch.ElasticsearchStatusException}\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test (expected = ElasticsearchStatusException.class)\n+    public void whenTheIndexNotExistsShouldThrowException() {\n+        final boolean readOnly = ESIndexUtil.isReadOnly(\"not_Exists\");\n+        assertEquals(true, readOnly);\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#putReadOnlyToFalse(String...)}\n+     * When: The index exists\n+     * Should: should set it to read only\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldPutReadonlyInTrue() throws DotDataException {\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        try {\n+            ESIndexUtil.putReadOnlyToFalse(indiciesInfo.getWorking());\n+\n+            final boolean readOnly = ESIndexUtil.isReadOnly(indiciesInfo.getWorking());\n+\n+            assertEquals(true, !readOnly);\n+        } finally {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#putReadOnlyToFalse(String...)}\n+     * When: The index not exists\n+     * Should: throw a {@link org.elasticsearch.ElasticsearchStatusException}\n+     *\n+     */\n+    @Test(expected = ElasticsearchStatusException.class)\n+    public void shouldTryPutReadonlyInTrueAndTheIndexDoesNotExists()  {\n+        ESIndexUtil.putReadOnlyToFalse(\"index_not_exists\");\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isAnyCurrentIndicesReadOnly()}\n+     * When: If at least one of the current working index if read only\n+     * Should: return true\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test()\n+    public void shouldReturnTrueWhenWorkingIndexIsReadOnly() throws DotDataException {\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        try {\n+            putReadOnly(indiciesInfo.getLive(), false);\n+            putReadOnly(indiciesInfo.getWorking(), true);\n+\n+            final boolean anyCurrentIndicesReadOnly = ESIndexUtil.isAnyCurrentIndicesReadOnly();\n+            assertEquals(true, anyCurrentIndicesReadOnly);\n+        } finally {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isAnyCurrentIndicesReadOnly()}\n+     * When: If at least one of the current live index if read only", "originalCommit": "0bf0a53f796560307f7908e3992ac85bba031528", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwODUxNA==", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436208514", "bodyText": "done fc979e0#diff-1e54965847e19cc0a77583c4dbd18afdR142", "author": "freddyucv", "createdAt": "2020-06-05T23:45:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU3MzE4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU3MzI0Mw==", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r435573243", "bodyText": "is read only", "author": "nollymar", "createdAt": "2020-06-04T21:51:27Z", "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESIndexUtilTest.java", "diffHunk": "@@ -0,0 +1,199 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.ElasticsearchStatusException;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.junit.BeforeClass;\n+import com.dotcms.util.IntegrationTestInitService;\n+import org.junit.Test;\n+\n+import static org.jgroups.util.Util.assertEquals;\n+\n+public class ESIndexUtilTest {\n+\n+    @BeforeClass\n+    public static void prepare () throws Exception {\n+        //Setting web app environment\n+        IntegrationTestInitService.getInstance().init();\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index is not read only\n+     * Should:return false\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldReturnFalseIfTheCurrentIndicesAreReadOnly() throws DotDataException {\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        try {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+\n+            final boolean readOnly = ESIndexUtil.isReadOnly(indiciesInfo.getWorking());\n+\n+            assertEquals(false, readOnly);\n+        } finally {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index is read only\n+     * Should:return true\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldReturnTrueIfTheCurrentIndicesAreReadOnly() throws DotDataException {\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        try {\n+            putReadOnly(indiciesInfo.getWorking(), true);\n+\n+            final boolean readOnly = ESIndexUtil.isReadOnly(indiciesInfo.getWorking());\n+\n+            assertEquals(true, readOnly);\n+        } finally {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index not exists\n+     * Should: throw a {@link org.elasticsearch.ElasticsearchStatusException}\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test (expected = ElasticsearchStatusException.class)\n+    public void whenTheIndexNotExistsShouldThrowException() {\n+        final boolean readOnly = ESIndexUtil.isReadOnly(\"not_Exists\");\n+        assertEquals(true, readOnly);\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#putReadOnlyToFalse(String...)}\n+     * When: The index exists\n+     * Should: should set it to read only\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldPutReadonlyInTrue() throws DotDataException {\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        try {\n+            ESIndexUtil.putReadOnlyToFalse(indiciesInfo.getWorking());\n+\n+            final boolean readOnly = ESIndexUtil.isReadOnly(indiciesInfo.getWorking());\n+\n+            assertEquals(true, !readOnly);\n+        } finally {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#putReadOnlyToFalse(String...)}\n+     * When: The index not exists\n+     * Should: throw a {@link org.elasticsearch.ElasticsearchStatusException}\n+     *\n+     */\n+    @Test(expected = ElasticsearchStatusException.class)\n+    public void shouldTryPutReadonlyInTrueAndTheIndexDoesNotExists()  {\n+        ESIndexUtil.putReadOnlyToFalse(\"index_not_exists\");\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isAnyCurrentIndicesReadOnly()}\n+     * When: If at least one of the current working index if read only", "originalCommit": "0bf0a53f796560307f7908e3992ac85bba031528", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwODU3NQ==", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436208575", "bodyText": "done fc979e0#diff-1e54965847e19cc0a77583c4dbd18afdR120", "author": "freddyucv", "createdAt": "2020-06-05T23:45:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU3MzI0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU3NTIzOA==", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r435575238", "bodyText": "is there another way to know when the monitor is ready? this sleep might cause a race condition", "author": "nollymar", "createdAt": "2020-06-04T21:56:47Z", "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESReadOnlyMonitorTest.java", "diffHunk": "@@ -0,0 +1,191 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.api.system.event.message.MessageSeverity;\n+import com.dotcms.api.system.event.message.MessageType;\n+import com.dotcms.api.system.event.message.SystemMessageEventUtil;\n+import com.dotcms.api.system.event.message.builder.SystemMessageBuilder;\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotcms.util.IntegrationTestInitService;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.RoleAPI;\n+import com.dotmarketing.common.reindex.ReindexEntry;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.liferay.portal.language.LanguageUtil;\n+import com.liferay.portal.model.User;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.dotcms.util.CollectionsUtils.list;\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.Mockito.*;\n+\n+public class ESReadOnlyMonitorTest {\n+\n+    private static ESReadOnlyMonitor esReadOnlyMonitor;\n+    private SystemMessageEventUtil systemMessageEventUtilMock;\n+    private RoleAPI roleAPIMock;\n+\n+    @BeforeClass\n+    public static void prepare () throws Exception {\n+        //Setting web app environment\n+        IntegrationTestInitService.getInstance().init();\n+    }\n+\n+    @Before\n+    public void init () {\n+        systemMessageEventUtilMock = mock(SystemMessageEventUtil.class);\n+        roleAPIMock = mock(RoleAPI.class);\n+\n+        esReadOnlyMonitor = ESReadOnlyMonitor.getInstance(systemMessageEventUtilMock, roleAPIMock);\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESReadOnlyMonitor#start(ReindexEntry, String)}\n+     * When: If the LIVE and WORKING current index are not read only\n+     * Should: not sent large message\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldNotSendLargeMessage() throws DotDataException {\n+        final ReindexEntry reindexEntry = mock(ReindexEntry.class);\n+        final String cause = \"cause\";\n+\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        putReadOnly(indiciesInfo.getWorking(), false);\n+        putReadOnly(indiciesInfo.getLive(), false);\n+\n+        esReadOnlyMonitor.start(reindexEntry, cause);\n+\n+        verify(systemMessageEventUtilMock, never()).pushLargeMessage(any(), any());\n+\n+        assertEquals(false, ESIndexUtil.isReadOnly(indiciesInfo.getWorking(), indiciesInfo.getLive()));\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESReadOnlyMonitor#start(ReindexEntry, String)}\n+     * When: If any of LIVE and WORKING current index are read only\n+     * Should: sent large message\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldSendLargeMessage() throws DotDataException, DotSecurityException, InterruptedException {\n+        final ReindexEntry reindexEntry = mock(ReindexEntry.class);\n+        final String cause = \"cause\";\n+\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        final Role adminRole = mock(Role.class);\n+        when(roleAPIMock.loadCMSAdminRole()).thenReturn(adminRole);\n+\n+        final User user = mock(User.class);\n+        when(user.getUserId()).thenReturn(\"1\");\n+\n+        when(roleAPIMock.findUsersForRole(adminRole)).thenReturn(list(user));\n+\n+        try {\n+            putReadOnly(indiciesInfo.getWorking(), true);\n+            putReadOnly(indiciesInfo.getLive(), false);\n+\n+            esReadOnlyMonitor.start(reindexEntry, cause);\n+\n+            Thread.sleep(100);", "originalCommit": "0bf0a53f796560307f7908e3992ac85bba031528", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjExNTY2Mw==", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436115663", "bodyText": "I would rename to setReadOnly", "author": "dsilvam", "createdAt": "2020-06-05T19:14:41Z", "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESReadOnlyMonitorTest.java", "diffHunk": "@@ -0,0 +1,191 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.api.system.event.message.MessageSeverity;\n+import com.dotcms.api.system.event.message.MessageType;\n+import com.dotcms.api.system.event.message.SystemMessageEventUtil;\n+import com.dotcms.api.system.event.message.builder.SystemMessageBuilder;\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotcms.util.IntegrationTestInitService;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.RoleAPI;\n+import com.dotmarketing.common.reindex.ReindexEntry;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.liferay.portal.language.LanguageUtil;\n+import com.liferay.portal.model.User;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.dotcms.util.CollectionsUtils.list;\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.Mockito.*;\n+\n+public class ESReadOnlyMonitorTest {\n+\n+    private static ESReadOnlyMonitor esReadOnlyMonitor;\n+    private SystemMessageEventUtil systemMessageEventUtilMock;\n+    private RoleAPI roleAPIMock;\n+\n+    @BeforeClass\n+    public static void prepare () throws Exception {\n+        //Setting web app environment\n+        IntegrationTestInitService.getInstance().init();\n+    }\n+\n+    @Before\n+    public void init () {\n+        systemMessageEventUtilMock = mock(SystemMessageEventUtil.class);\n+        roleAPIMock = mock(RoleAPI.class);\n+\n+        esReadOnlyMonitor = ESReadOnlyMonitor.getInstance(systemMessageEventUtilMock, roleAPIMock);\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESReadOnlyMonitor#start(ReindexEntry, String)}\n+     * When: If the LIVE and WORKING current index are not read only\n+     * Should: not sent large message\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldNotSendLargeMessage() throws DotDataException {\n+        final ReindexEntry reindexEntry = mock(ReindexEntry.class);\n+        final String cause = \"cause\";\n+\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        putReadOnly(indiciesInfo.getWorking(), false);\n+        putReadOnly(indiciesInfo.getLive(), false);\n+\n+        esReadOnlyMonitor.start(reindexEntry, cause);\n+\n+        verify(systemMessageEventUtilMock, never()).pushLargeMessage(any(), any());\n+\n+        assertEquals(false, ESIndexUtil.isReadOnly(indiciesInfo.getWorking(), indiciesInfo.getLive()));\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESReadOnlyMonitor#start(ReindexEntry, String)}\n+     * When: If any of LIVE and WORKING current index are read only\n+     * Should: sent large message\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldSendLargeMessage() throws DotDataException, DotSecurityException, InterruptedException {\n+        final ReindexEntry reindexEntry = mock(ReindexEntry.class);\n+        final String cause = \"cause\";\n+\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        final Role adminRole = mock(Role.class);\n+        when(roleAPIMock.loadCMSAdminRole()).thenReturn(adminRole);\n+\n+        final User user = mock(User.class);\n+        when(user.getUserId()).thenReturn(\"1\");\n+\n+        when(roleAPIMock.findUsersForRole(adminRole)).thenReturn(list(user));\n+\n+        try {\n+            putReadOnly(indiciesInfo.getWorking(), true);\n+            putReadOnly(indiciesInfo.getLive(), false);\n+\n+            esReadOnlyMonitor.start(reindexEntry, cause);\n+\n+            Thread.sleep(100);\n+\n+            checkLargeMessageSent(indiciesInfo, user);\n+            assertEquals(false, ESIndexUtil.isReadOnly(indiciesInfo.getWorking(), indiciesInfo.getLive()));\n+        } finally {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESReadOnlyMonitor#start(ReindexEntry, String)}\n+     * When: If call start again after the first call is finished\n+     * Should: should sent the message again\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldSendLargeMessageTwice() throws DotDataException, DotSecurityException, InterruptedException {\n+        final ReindexEntry reindexEntry = mock(ReindexEntry.class);\n+        final String cause = \"cause\";\n+\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        final Role adminRole = mock(Role.class);\n+        when(roleAPIMock.loadCMSAdminRole()).thenReturn(adminRole);\n+\n+        final User user = mock(User.class);\n+        when(user.getUserId()).thenReturn(\"1\");\n+\n+        when(roleAPIMock.findUsersForRole(adminRole)).thenReturn(list(user));\n+\n+        try {\n+            putReadOnly(indiciesInfo.getWorking(), true);\n+            putReadOnly(indiciesInfo.getLive(), false);\n+\n+            esReadOnlyMonitor.start(reindexEntry, cause);\n+            checkLargeMessageSent(indiciesInfo, user);\n+\n+            esReadOnlyMonitor.start(reindexEntry, cause);\n+            checkLargeMessageSent(indiciesInfo, user);\n+            assertEquals(false, ESIndexUtil.isReadOnly(indiciesInfo.getWorking(), indiciesInfo.getLive()));\n+        } finally {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    private void checkLargeMessageSent(IndiciesInfo indiciesInfo, User user) throws InterruptedException {\n+        Thread.sleep(100);\n+\n+        final SystemMessageBuilder messageReadonly = new SystemMessageBuilder()\n+                .setMessage(\"At least one of the Elasticsearch current indices are in read only mode\")\n+                .setSeverity(MessageSeverity.ERROR)\n+                .setType(MessageType.SIMPLE_MESSAGE)\n+                .setLife(TimeUnit.SECONDS.toMillis(5));\n+\n+        verify(systemMessageEventUtilMock).pushMessage(\n+                messageReadonly.create(),\n+                list(user.getUserId())\n+        );\n+\n+        final SystemMessageBuilder messageWriteModeAgain = new SystemMessageBuilder()\n+                .setMessage(\"Elasticsearch current indices are in write mode again\")\n+                .setSeverity(MessageSeverity.ERROR)\n+                .setType(MessageType.SIMPLE_MESSAGE)\n+                .setLife(TimeUnit.SECONDS.toMillis(5));\n+\n+        verify(systemMessageEventUtilMock).pushMessage(\n+                messageWriteModeAgain.create(),\n+                list(user.getUserId())\n+        );\n+    }\n+\n+    private static AcknowledgedResponse putReadOnly(final String indexName, final boolean value) {", "originalCommit": "0bf0a53f796560307f7908e3992ac85bba031528", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwODY1NQ==", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436208655", "bodyText": "done fc979e0#diff-8d99314a049a8e40fb6783cfaf992d60R173", "author": "freddyucv", "createdAt": "2020-06-05T23:45:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjExNTY2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjExODQzMQ==", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436118431", "bodyText": "this line is not needed", "author": "dsilvam", "createdAt": "2020-06-05T19:21:21Z", "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESIndexUtilTest.java", "diffHunk": "@@ -0,0 +1,199 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.ElasticsearchStatusException;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.junit.BeforeClass;\n+import com.dotcms.util.IntegrationTestInitService;\n+import org.junit.Test;\n+\n+import static org.jgroups.util.Util.assertEquals;\n+\n+public class ESIndexUtilTest {\n+\n+    @BeforeClass\n+    public static void prepare () throws Exception {\n+        //Setting web app environment\n+        IntegrationTestInitService.getInstance().init();\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index is not read only\n+     * Should:return false\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldReturnFalseIfTheCurrentIndicesAreReadOnly() throws DotDataException {\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        try {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+\n+            final boolean readOnly = ESIndexUtil.isReadOnly(indiciesInfo.getWorking());\n+\n+            assertEquals(false, readOnly);\n+        } finally {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index is read only\n+     * Should:return true\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldReturnTrueIfTheCurrentIndicesAreReadOnly() throws DotDataException {\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        try {\n+            putReadOnly(indiciesInfo.getWorking(), true);\n+\n+            final boolean readOnly = ESIndexUtil.isReadOnly(indiciesInfo.getWorking());\n+\n+            assertEquals(true, readOnly);\n+        } finally {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index not exists\n+     * Should: throw a {@link org.elasticsearch.ElasticsearchStatusException}\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test (expected = ElasticsearchStatusException.class)\n+    public void whenTheIndexNotExistsShouldThrowException() {\n+        final boolean readOnly = ESIndexUtil.isReadOnly(\"not_Exists\");\n+        assertEquals(true, readOnly);", "originalCommit": "0bf0a53f796560307f7908e3992ac85bba031528", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwODcxNg==", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436208716", "bodyText": "done fc979e0#diff-1e54965847e19cc0a77583c4dbd18afdL81", "author": "freddyucv", "createdAt": "2020-06-05T23:46:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjExODQzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjExOTQ2MQ==", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436119461", "bodyText": "this doesn't seem a correct expected result based on the method's name...", "author": "dsilvam", "createdAt": "2020-06-05T19:23:38Z", "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESIndexUtilTest.java", "diffHunk": "@@ -0,0 +1,199 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.ElasticsearchStatusException;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.junit.BeforeClass;\n+import com.dotcms.util.IntegrationTestInitService;\n+import org.junit.Test;\n+\n+import static org.jgroups.util.Util.assertEquals;\n+\n+public class ESIndexUtilTest {\n+\n+    @BeforeClass\n+    public static void prepare () throws Exception {\n+        //Setting web app environment\n+        IntegrationTestInitService.getInstance().init();\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index is not read only\n+     * Should:return false\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldReturnFalseIfTheCurrentIndicesAreReadOnly() throws DotDataException {\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        try {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+\n+            final boolean readOnly = ESIndexUtil.isReadOnly(indiciesInfo.getWorking());\n+\n+            assertEquals(false, readOnly);\n+        } finally {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index is read only\n+     * Should:return true\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldReturnTrueIfTheCurrentIndicesAreReadOnly() throws DotDataException {\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        try {\n+            putReadOnly(indiciesInfo.getWorking(), true);\n+\n+            final boolean readOnly = ESIndexUtil.isReadOnly(indiciesInfo.getWorking());\n+\n+            assertEquals(true, readOnly);\n+        } finally {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index not exists\n+     * Should: throw a {@link org.elasticsearch.ElasticsearchStatusException}\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test (expected = ElasticsearchStatusException.class)\n+    public void whenTheIndexNotExistsShouldThrowException() {\n+        final boolean readOnly = ESIndexUtil.isReadOnly(\"not_Exists\");\n+        assertEquals(true, readOnly);\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#putReadOnlyToFalse(String...)}\n+     * When: The index exists\n+     * Should: should set it to read only", "originalCommit": "0bf0a53f796560307f7908e3992ac85bba031528", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwODc2NQ==", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436208765", "bodyText": "done fc979e0#diff-1e54965847e19cc0a77583c4dbd18afdR87", "author": "freddyucv", "createdAt": "2020-06-05T23:46:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjExOTQ2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjExOTU5OQ==", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436119599", "bodyText": "looks like the expected escenario is wrong..", "author": "dsilvam", "createdAt": "2020-06-05T19:24:00Z", "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESIndexUtilTest.java", "diffHunk": "@@ -0,0 +1,199 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.ElasticsearchStatusException;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.junit.BeforeClass;\n+import com.dotcms.util.IntegrationTestInitService;\n+import org.junit.Test;\n+\n+import static org.jgroups.util.Util.assertEquals;\n+\n+public class ESIndexUtilTest {\n+\n+    @BeforeClass\n+    public static void prepare () throws Exception {\n+        //Setting web app environment\n+        IntegrationTestInitService.getInstance().init();\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index is not read only\n+     * Should:return false\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldReturnFalseIfTheCurrentIndicesAreReadOnly() throws DotDataException {\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        try {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+\n+            final boolean readOnly = ESIndexUtil.isReadOnly(indiciesInfo.getWorking());\n+\n+            assertEquals(false, readOnly);\n+        } finally {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index is read only\n+     * Should:return true\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldReturnTrueIfTheCurrentIndicesAreReadOnly() throws DotDataException {\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        try {\n+            putReadOnly(indiciesInfo.getWorking(), true);\n+\n+            final boolean readOnly = ESIndexUtil.isReadOnly(indiciesInfo.getWorking());\n+\n+            assertEquals(true, readOnly);\n+        } finally {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index not exists\n+     * Should: throw a {@link org.elasticsearch.ElasticsearchStatusException}\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test (expected = ElasticsearchStatusException.class)\n+    public void whenTheIndexNotExistsShouldThrowException() {\n+        final boolean readOnly = ESIndexUtil.isReadOnly(\"not_Exists\");\n+        assertEquals(true, readOnly);\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#putReadOnlyToFalse(String...)}\n+     * When: The index exists\n+     * Should: should set it to read only\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldPutReadonlyInTrue() throws DotDataException {", "originalCommit": "0bf0a53f796560307f7908e3992ac85bba031528", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwODgzMQ==", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436208831", "bodyText": "done fc979e0#diff-1e54965847e19cc0a77583c4dbd18afdR87", "author": "freddyucv", "createdAt": "2020-06-05T23:46:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjExOTU5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjExOTc0MA==", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436119740", "bodyText": "assertFalse", "author": "dsilvam", "createdAt": "2020-06-05T19:24:20Z", "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESIndexUtilTest.java", "diffHunk": "@@ -0,0 +1,199 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.ElasticsearchStatusException;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.junit.BeforeClass;\n+import com.dotcms.util.IntegrationTestInitService;\n+import org.junit.Test;\n+\n+import static org.jgroups.util.Util.assertEquals;\n+\n+public class ESIndexUtilTest {\n+\n+    @BeforeClass\n+    public static void prepare () throws Exception {\n+        //Setting web app environment\n+        IntegrationTestInitService.getInstance().init();\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index is not read only\n+     * Should:return false\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldReturnFalseIfTheCurrentIndicesAreReadOnly() throws DotDataException {\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        try {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+\n+            final boolean readOnly = ESIndexUtil.isReadOnly(indiciesInfo.getWorking());\n+\n+            assertEquals(false, readOnly);\n+        } finally {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index is read only\n+     * Should:return true\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldReturnTrueIfTheCurrentIndicesAreReadOnly() throws DotDataException {\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        try {\n+            putReadOnly(indiciesInfo.getWorking(), true);\n+\n+            final boolean readOnly = ESIndexUtil.isReadOnly(indiciesInfo.getWorking());\n+\n+            assertEquals(true, readOnly);\n+        } finally {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index not exists\n+     * Should: throw a {@link org.elasticsearch.ElasticsearchStatusException}\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test (expected = ElasticsearchStatusException.class)\n+    public void whenTheIndexNotExistsShouldThrowException() {\n+        final boolean readOnly = ESIndexUtil.isReadOnly(\"not_Exists\");\n+        assertEquals(true, readOnly);\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#putReadOnlyToFalse(String...)}\n+     * When: The index exists\n+     * Should: should set it to read only\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldPutReadonlyInTrue() throws DotDataException {\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        try {\n+            ESIndexUtil.putReadOnlyToFalse(indiciesInfo.getWorking());\n+\n+            final boolean readOnly = ESIndexUtil.isReadOnly(indiciesInfo.getWorking());\n+\n+            assertEquals(true, !readOnly);", "originalCommit": "0bf0a53f796560307f7908e3992ac85bba031528", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwODg3Nw==", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436208877", "bodyText": "done fc979e0#diff-1e54965847e19cc0a77583c4dbd18afdR101", "author": "freddyucv", "createdAt": "2020-06-05T23:47:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjExOTc0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEzNzczOQ==", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436137739", "bodyText": "missing description", "author": "dsilvam", "createdAt": "2020-06-05T20:00:24Z", "path": "dotCMS/src/integration-test/java/com/dotmarketing/common/reindex/ReindexQueueAPITest.java", "diffHunk": "@@ -102,6 +106,61 @@ public void test_getFailedReindexRecords_shouldNotReturnAnyRecord() throws DotDa\n \n     }\n \n+    /**\n+     * Method to Test: {@link ReindexQueueAPIImpl#markAsFailed(ReindexEntry, String)}\n+     * When: Try to mark a reindex as fail\n+     * Should: Should call the {@link ReindexQueueFactory#markAsFailed(ReindexEntry, String)}\n+     *         and\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void markAsFailed() throws DotDataException {\n+\n+        final ReindexQueueFactory reindexQueueFactory = mock(ReindexQueueFactory.class);\n+        final ESReadOnlyMonitor esReadOnlyMonitor = mock(ESReadOnlyMonitor.class);\n+\n+        final ReindexQueueAPIImpl reindexQueueAPI = new ReindexQueueAPIImpl(reindexQueueFactory, esReadOnlyMonitor);\n+\n+        final ReindexEntry reindexEntry = mock(ReindexEntry.class);\n+        final String cause = \"Test Cause\";\n+\n+        reindexQueueAPI.markAsFailed(reindexEntry, cause);\n+\n+        verify(reindexQueueFactory).markAsFailed(reindexEntry, cause);\n+        verify(esReadOnlyMonitor).start(reindexEntry, cause);\n+    }\n+\n+    /**\n+     * Method to Test: {@link ReindexQueueAPIImpl#markAsFailed(ReindexEntry, String)}\n+     * When: Try to mark a reindex as fail and the", "originalCommit": "0bf0a53f796560307f7908e3992ac85bba031528", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwODk0MQ==", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436208941", "bodyText": "done fc979e0#diff-d92d85f1b28c94ca9fd49119521d8872R136", "author": "freddyucv", "createdAt": "2020-06-05T23:47:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEzNzczOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEzODA4MA==", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436138080", "bodyText": "incomplete description", "author": "dsilvam", "createdAt": "2020-06-05T20:01:12Z", "path": "dotCMS/src/integration-test/java/com/dotmarketing/common/reindex/ReindexQueueAPITest.java", "diffHunk": "@@ -102,6 +106,61 @@ public void test_getFailedReindexRecords_shouldNotReturnAnyRecord() throws DotDa\n \n     }\n \n+    /**\n+     * Method to Test: {@link ReindexQueueAPIImpl#markAsFailed(ReindexEntry, String)}\n+     * When: Try to mark a reindex as fail\n+     * Should: Should call the {@link ReindexQueueFactory#markAsFailed(ReindexEntry, String)}\n+     *         and\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void markAsFailed() throws DotDataException {\n+\n+        final ReindexQueueFactory reindexQueueFactory = mock(ReindexQueueFactory.class);\n+        final ESReadOnlyMonitor esReadOnlyMonitor = mock(ESReadOnlyMonitor.class);\n+\n+        final ReindexQueueAPIImpl reindexQueueAPI = new ReindexQueueAPIImpl(reindexQueueFactory, esReadOnlyMonitor);\n+\n+        final ReindexEntry reindexEntry = mock(ReindexEntry.class);\n+        final String cause = \"Test Cause\";\n+\n+        reindexQueueAPI.markAsFailed(reindexEntry, cause);\n+\n+        verify(reindexQueueFactory).markAsFailed(reindexEntry, cause);\n+        verify(esReadOnlyMonitor).start(reindexEntry, cause);\n+    }\n+\n+    /**\n+     * Method to Test: {@link ReindexQueueAPIImpl#markAsFailed(ReindexEntry, String)}\n+     * When: Try to mark a reindex as fail and the\n+     * Should: Should call the {@link ReindexQueueFactory#markAsFailed(ReindexEntry, String)}\n+     *         and", "originalCommit": "0bf0a53f796560307f7908e3992ac85bba031528", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwODk4Ng==", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436208986", "bodyText": "done fc979e0#diff-d92d85f1b28c94ca9fd49119521d8872R137", "author": "freddyucv", "createdAt": "2020-06-05T23:47:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEzODA4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEzOTk3NA==", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436139974", "bodyText": "Maybe we can remove this Logger", "author": "dsilvam", "createdAt": "2020-06-05T20:05:57Z", "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESIndexUtil.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.util.Logger;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.action.admin.indices.settings.get.GetSettingsRequest;\n+import org.elasticsearch.action.admin.indices.settings.get.GetSettingsResponse;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+public class ESIndexUtil {\n+    private final static String READ_ONLY_ALLOW_DELETE_SETTING = \"index.blocks.read_only_allow_delete\";\n+    private final static String READ_ONLY_SETTING = \"index.blocks.read_only\";\n+\n+    private ESIndexUtil(){}\n+\n+    public static  boolean isReadOnly(final String... indexNames) {\n+        final GetSettingsRequest request = new GetSettingsRequest().indices(indexNames);\n+\n+        Logger.info(ESIndexUtil.class, Thread.currentThread().getName() + \"- Checking if current index are read only\");\n+\n+        final GetSettingsResponse response = Sneaky.sneak(() ->\n+                RestHighLevelClientProvider.getInstance().getClient().indices()\n+                        .getSettings(request, RequestOptions.DEFAULT));\n+\n+        Logger.info(ESIndexUtil.class, Thread.currentThread().getName() + \"- RESPONSE Checking if current index are read only\");", "originalCommit": "0bf0a53f796560307f7908e3992ac85bba031528", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE0MDM4Ng==", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436140386", "bodyText": "If you want to leave it, change to \"Response received on checking if any of the provided indices is read only\"", "author": "dsilvam", "createdAt": "2020-06-05T20:07:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEzOTk3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwOTA0OQ==", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436209049", "bodyText": "done fc979e0#diff-63af77826d67a38fb99a8eccd3d5b770R45", "author": "freddyucv", "createdAt": "2020-06-05T23:48:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEzOTk3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE0MTc1MQ==", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436141751", "bodyText": "rename to setLiveAndWorkingIndicesToWriteMode", "author": "dsilvam", "createdAt": "2020-06-05T20:10:31Z", "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESIndexUtil.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.util.Logger;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.action.admin.indices.settings.get.GetSettingsRequest;\n+import org.elasticsearch.action.admin.indices.settings.get.GetSettingsResponse;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+public class ESIndexUtil {\n+    private final static String READ_ONLY_ALLOW_DELETE_SETTING = \"index.blocks.read_only_allow_delete\";\n+    private final static String READ_ONLY_SETTING = \"index.blocks.read_only\";\n+\n+    private ESIndexUtil(){}\n+\n+    public static  boolean isReadOnly(final String... indexNames) {\n+        final GetSettingsRequest request = new GetSettingsRequest().indices(indexNames);\n+\n+        Logger.info(ESIndexUtil.class, Thread.currentThread().getName() + \"- Checking if current index are read only\");\n+\n+        final GetSettingsResponse response = Sneaky.sneak(() ->\n+                RestHighLevelClientProvider.getInstance().getClient().indices()\n+                        .getSettings(request, RequestOptions.DEFAULT));\n+\n+        Logger.info(ESIndexUtil.class, Thread.currentThread().getName() + \"- RESPONSE Checking if current index are read only\");\n+\n+        return Arrays.stream(indexNames).anyMatch((indexName) -> {\n+            final String readOnlyAllowDelete = response.getSetting(indexName, READ_ONLY_ALLOW_DELETE_SETTING);\n+            final String readOnly = response.getSetting(indexName, READ_ONLY_SETTING);\n+\n+            return Boolean.parseBoolean(readOnlyAllowDelete) || Boolean.parseBoolean(readOnly);\n+        });\n+    }\n+\n+    public static AcknowledgedResponse putReadOnlyToFalse(final String... indexName) {\n+        final UpdateSettingsRequest request = new UpdateSettingsRequest(indexName);\n+\n+        final Settings.Builder settingBuilder = Settings.builder()\n+                .put(READ_ONLY_ALLOW_DELETE_SETTING, false)\n+                .put(READ_ONLY_SETTING, false);\n+\n+        request.settings(settingBuilder);\n+\n+        return Sneaky.sneak(() ->\n+                RestHighLevelClientProvider.getInstance().getClient().indices()\n+                        .putSettings(request, RequestOptions.DEFAULT)\n+        );\n+    }\n+\n+    public static boolean isAnyCurrentIndicesReadOnly() {\n+        final IndiciesInfo indiciesInfo = loadIndicesInfo();\n+        return ESIndexUtil.isReadOnly(indiciesInfo.getLive(), indiciesInfo.getWorking());\n+    }\n+\n+    public static void putCurrentIndicesToWriteMode() throws ESResponseException {", "originalCommit": "0bf0a53f796560307f7908e3992ac85bba031528", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwOTEwNg==", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436209106", "bodyText": "done fc979e0#diff-63af77826d67a38fb99a8eccd3d5b770R95", "author": "freddyucv", "createdAt": "2020-06-05T23:48:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE0MTc1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE0MzQwNg==", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436143406", "bodyText": "rename to isEitherLiveOrWokingIndicesReadOnly", "author": "dsilvam", "createdAt": "2020-06-05T20:14:44Z", "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESIndexUtil.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.util.Logger;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.action.admin.indices.settings.get.GetSettingsRequest;\n+import org.elasticsearch.action.admin.indices.settings.get.GetSettingsResponse;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+public class ESIndexUtil {\n+    private final static String READ_ONLY_ALLOW_DELETE_SETTING = \"index.blocks.read_only_allow_delete\";\n+    private final static String READ_ONLY_SETTING = \"index.blocks.read_only\";\n+\n+    private ESIndexUtil(){}\n+\n+    public static  boolean isReadOnly(final String... indexNames) {\n+        final GetSettingsRequest request = new GetSettingsRequest().indices(indexNames);\n+\n+        Logger.info(ESIndexUtil.class, Thread.currentThread().getName() + \"- Checking if current index are read only\");\n+\n+        final GetSettingsResponse response = Sneaky.sneak(() ->\n+                RestHighLevelClientProvider.getInstance().getClient().indices()\n+                        .getSettings(request, RequestOptions.DEFAULT));\n+\n+        Logger.info(ESIndexUtil.class, Thread.currentThread().getName() + \"- RESPONSE Checking if current index are read only\");\n+\n+        return Arrays.stream(indexNames).anyMatch((indexName) -> {\n+            final String readOnlyAllowDelete = response.getSetting(indexName, READ_ONLY_ALLOW_DELETE_SETTING);\n+            final String readOnly = response.getSetting(indexName, READ_ONLY_SETTING);\n+\n+            return Boolean.parseBoolean(readOnlyAllowDelete) || Boolean.parseBoolean(readOnly);\n+        });\n+    }\n+\n+    public static AcknowledgedResponse putReadOnlyToFalse(final String... indexName) {\n+        final UpdateSettingsRequest request = new UpdateSettingsRequest(indexName);\n+\n+        final Settings.Builder settingBuilder = Settings.builder()\n+                .put(READ_ONLY_ALLOW_DELETE_SETTING, false)\n+                .put(READ_ONLY_SETTING, false);\n+\n+        request.settings(settingBuilder);\n+\n+        return Sneaky.sneak(() ->\n+                RestHighLevelClientProvider.getInstance().getClient().indices()\n+                        .putSettings(request, RequestOptions.DEFAULT)\n+        );\n+    }\n+\n+    public static boolean isAnyCurrentIndicesReadOnly() {", "originalCommit": "0bf0a53f796560307f7908e3992ac85bba031528", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwOTE1OA==", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436209158", "bodyText": "done fc979e0#diff-63af77826d67a38fb99a8eccd3d5b770R86", "author": "freddyucv", "createdAt": "2020-06-05T23:48:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE0MzQwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE0NTAxOQ==", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436145019", "bodyText": "Please correct by using text from below:\n/**\n * This monitor is run when either the Live or Working indices are in read-only mode.  It attempts to set both Live and Working indices to write mode again.\n * When setting write-mode fails it will retry after one minute.\n */", "author": "dsilvam", "createdAt": "2020-06-05T20:18:50Z", "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESReadOnlyMonitor.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.api.system.event.message.MessageSeverity;\n+import com.dotcms.api.system.event.message.MessageType;\n+import com.dotcms.api.system.event.message.SystemMessageEventUtil;\n+import com.dotcms.api.system.event.message.builder.SystemMessageBuilder;\n+import com.dotcms.concurrent.DotConcurrentFactory;\n+import com.dotcms.enterprise.LicenseUtil;\n+import com.dotcms.repackage.com.google.common.annotations.VisibleForTesting;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.RoleAPI;\n+import com.dotmarketing.common.reindex.ReindexEntry;\n+import com.dotmarketing.common.reindex.ReindexThread;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.util.Logger;\n+import com.liferay.portal.language.LanguageException;\n+import com.liferay.portal.language.LanguageUtil;\n+\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import static com.dotcms.util.CollectionsUtils.list;\n+\n+/**\n+ * Run a Monitor If the current indices are in read only mode and try to set them to write mode again.\n+ * When the set write mode fail it try again after one minute.\n+ */\n+public class ESReadOnlyMonitor {", "originalCommit": "0bf0a53f796560307f7908e3992ac85bba031528", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwOTIwMg==", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436209202", "bodyText": "done fc979e0#diff-8528ec811f60c9aae6301f9071d59872R27", "author": "freddyucv", "createdAt": "2020-06-05T23:49:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE0NTAxOQ=="}], "type": "inlineReview"}, {"oid": "fc979e0e1d04475951dbb213b379b17022474a8e", "url": "https://github.com/dotCMS/core/commit/fc979e0e1d04475951dbb213b379b17022474a8e", "message": "#17842 Refactoring", "committedDate": "2020-06-05T23:33:55Z", "type": "commit"}, {"oid": "ced8270d9c33509b2d5000ddbdc7d4f6f91f6a59", "url": "https://github.com/dotCMS/core/commit/ced8270d9c33509b2d5000ddbdc7d4f6f91f6a59", "message": "removing vhange", "committedDate": "2020-06-08T14:23:04Z", "type": "commit"}, {"oid": "6f73efded56b7c4bc77957cf6dbbabce11fbac17", "url": "https://github.com/dotCMS/core/commit/6f73efded56b7c4bc77957cf6dbbabce11fbac17", "message": "#17842 Refactoring", "committedDate": "2020-06-08T20:22:21Z", "type": "commit"}, {"oid": "e2d22001f72149b37fbcdf76b852e1930d4e8084", "url": "https://github.com/dotCMS/core/commit/e2d22001f72149b37fbcdf76b852e1930d4e8084", "message": "#17842 Message", "committedDate": "2020-06-08T21:45:41Z", "type": "commit"}, {"oid": "f669c19d37c101e1742103f506edf0121f613125", "url": "https://github.com/dotCMS/core/commit/f669c19d37c101e1742103f506edf0121f613125", "message": "#17842 Fixing test", "committedDate": "2020-06-08T23:32:18Z", "type": "commit"}, {"oid": "9790a598c2ce5dadb7258f312a7360c571552437", "url": "https://github.com/dotCMS/core/commit/9790a598c2ce5dadb7258f312a7360c571552437", "message": "#17842 Fixing test", "committedDate": "2020-06-09T13:50:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ1MzMxNw==", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r437453317", "bodyText": "Issue found: Assigning an Object to null is a code smell.  Consider refactoring.", "author": "dev-dotcms", "createdAt": "2020-06-09T14:10:40Z", "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESReadOnlyMonitor.java", "diffHunk": "@@ -0,0 +1,192 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.api.system.event.message.MessageSeverity;\n+import com.dotcms.api.system.event.message.MessageType;\n+import com.dotcms.api.system.event.message.SystemMessageEventUtil;\n+import com.dotcms.api.system.event.message.builder.SystemMessageBuilder;\n+import com.dotcms.repackage.com.google.common.annotations.VisibleForTesting;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.RoleAPI;\n+import com.dotmarketing.common.reindex.ReindexEntry;\n+import com.dotmarketing.common.reindex.ReindexThread;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.util.Logger;\n+import com.liferay.portal.language.LanguageException;\n+import com.liferay.portal.language.LanguageUtil;\n+\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This monitor is run when either the Live or Working indices are in read-only mode.  It attempts to set both Live and Working indices to write mode again.\n+ * When setting write-mode fails it will retry after one minute.\n+ */\n+public class ESReadOnlyMonitor {\n+    private final RoleAPI roleAPI;\n+    private final SystemMessageEventUtil systemMessageEventUtil;\n+\n+    private final AtomicBoolean started = new AtomicBoolean();\n+    private Timer timer;\n+\n+    private ESReadOnlyMonitor(\n+            final SystemMessageEventUtil systemMessageEventUtil,\n+            final RoleAPI roleAPI) {\n+        super();\n+        this.systemMessageEventUtil = systemMessageEventUtil;\n+        this.roleAPI = roleAPI;\n+        started.set(false);\n+    }\n+\n+    private ESReadOnlyMonitor() {\n+        this(\n+                SystemMessageEventUtil.getInstance(),\n+                APILocator.getRoleAPI()\n+        );\n+    }\n+\n+    // Inner class to provide instance of class\n+    private static class Singleton\n+    {\n+        private static final ESReadOnlyMonitor INSTANCE = new ESReadOnlyMonitor();\n+    }\n+\n+    @VisibleForTesting\n+    public static ESReadOnlyMonitor getInstance(\n+            final SystemMessageEventUtil systemMessageEventUtil,\n+            final RoleAPI roleAPI)\n+    {\n+        return new ESReadOnlyMonitor(systemMessageEventUtil, roleAPI);\n+    }\n+    public static ESReadOnlyMonitor getInstance()\n+    {\n+        return Singleton.INSTANCE;\n+    }\n+\n+    public void start(final String message){\n+        if (this.start()) {\n+            Logger.error(this.getClass(), message);\n+        }\n+    }\n+\n+    /**\n+     * Start a {@link ESReadOnlyMonitor} is it is not started yet\n+     * @return false if a ESReadOnlyMonitor was started before\n+     */\n+    public boolean start(){\n+        if (started.compareAndSet(false, true)) {\n+            if (ElasticsearchUtil.isClusterInReadOnlyMode()) {\n+                ReindexThread.setCurrentIndexReadOnly(true);\n+                sendMessage(\"es.cluster.read.only.message\");\n+                startClusterMonitor();\n+            } else if (ElasticsearchUtil.isEitherLiveOrWorkingIndicesReadOnly()) {\n+                ReindexThread.setCurrentIndexReadOnly(true);\n+                sendMessage(\"es.index.read.only.message\");\n+                startIndexMonitor();\n+            } else {\n+                started.set(false);\n+            }\n+\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    private void sendMessage(final String messageKey) {\n+        try {\n+            final Role adminRole = roleAPI.loadCMSAdminRole();\n+            final List<String> usersId = roleAPI.findUsersForRole(adminRole)\n+                    .stream()\n+                    .map(user -> user.getUserId())\n+                    .collect(Collectors.toList());\n+\n+            final String message = LanguageUtil.get(messageKey);\n+\n+            final SystemMessageBuilder messageBuilder = new SystemMessageBuilder()\n+                    .setMessage(message)\n+                    .setSeverity(MessageSeverity.ERROR)\n+                    .setType(MessageType.SIMPLE_MESSAGE)\n+                    .setLife(TimeUnit.SECONDS.toMillis(5));\n+\n+            Logger.error(ESReadOnlyMonitor.class, message);\n+            systemMessageEventUtil.pushMessage(messageBuilder.create(), usersId);\n+        } catch (final LanguageException | DotDataException | DotSecurityException e) {\n+            Logger.warn(ESReadOnlyMonitor.class, () -> e.getMessage());\n+        }\n+    }\n+\n+    private void putCurrentIndicesToWriteMode() {\n+        try {\n+            Logger.debug(this.getClass(), () -> \"Trying to set the current indices to Write mode\");\n+            ElasticsearchUtil.setLiveAndWorkingIndicesToWriteMode();\n+            sendMessage(\"es.index.write.allow.message\");\n+            ReindexThread.setCurrentIndexReadOnly(false);\n+\n+            this.stop();\n+        } catch (final ElasticsearchResponseException e) {\n+            Logger.info(ESReadOnlyMonitor.class, ()  -> e.getMessage());\n+        }\n+    }\n+\n+    private void putClusterToWriteMode() {\n+        Logger.debug(this.getClass(), () -> \"Trying to set the current indices to Write mode\");\n+        ElasticsearchUtil.setClusterToWriteMode();\n+        sendMessage(\"es.cluster.write.allow.message\");\n+        ReindexThread.setCurrentIndexReadOnly(false);\n+\n+        this.stop();\n+    }\n+\n+    private void startIndexMonitor() {\n+         schedule(new IndexMonitorTimerTask(this));\n+    }\n+\n+    private synchronized void schedule(final TimerTask timerTask) {\n+        timer = new Timer(true);\n+        timer.schedule(timerTask, 0, TimeUnit.MINUTES.toMillis(1));\n+    }\n+\n+    private void startClusterMonitor() {\n+        schedule(new ClusterMonitorTimerTask(this));\n+    }\n+\n+    private synchronized void stop() {\n+        if (this.timer != null) {\n+            this.timer.cancel();\n+            this.timer = null;", "originalCommit": "9790a598c2ce5dadb7258f312a7360c571552437", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ1MzMzMw==", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r437453333", "bodyText": "Issue found: It is a good practice to call super() in a constructor", "author": "dev-dotcms", "createdAt": "2020-06-09T14:10:41Z", "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESReadOnlyMonitor.java", "diffHunk": "@@ -0,0 +1,192 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.api.system.event.message.MessageSeverity;\n+import com.dotcms.api.system.event.message.MessageType;\n+import com.dotcms.api.system.event.message.SystemMessageEventUtil;\n+import com.dotcms.api.system.event.message.builder.SystemMessageBuilder;\n+import com.dotcms.repackage.com.google.common.annotations.VisibleForTesting;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.RoleAPI;\n+import com.dotmarketing.common.reindex.ReindexEntry;\n+import com.dotmarketing.common.reindex.ReindexThread;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.util.Logger;\n+import com.liferay.portal.language.LanguageException;\n+import com.liferay.portal.language.LanguageUtil;\n+\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This monitor is run when either the Live or Working indices are in read-only mode.  It attempts to set both Live and Working indices to write mode again.\n+ * When setting write-mode fails it will retry after one minute.\n+ */\n+public class ESReadOnlyMonitor {\n+    private final RoleAPI roleAPI;\n+    private final SystemMessageEventUtil systemMessageEventUtil;\n+\n+    private final AtomicBoolean started = new AtomicBoolean();\n+    private Timer timer;\n+\n+    private ESReadOnlyMonitor(\n+            final SystemMessageEventUtil systemMessageEventUtil,\n+            final RoleAPI roleAPI) {\n+        super();\n+        this.systemMessageEventUtil = systemMessageEventUtil;\n+        this.roleAPI = roleAPI;\n+        started.set(false);\n+    }\n+\n+    private ESReadOnlyMonitor() {\n+        this(\n+                SystemMessageEventUtil.getInstance(),\n+                APILocator.getRoleAPI()\n+        );\n+    }\n+\n+    // Inner class to provide instance of class\n+    private static class Singleton\n+    {\n+        private static final ESReadOnlyMonitor INSTANCE = new ESReadOnlyMonitor();\n+    }\n+\n+    @VisibleForTesting\n+    public static ESReadOnlyMonitor getInstance(\n+            final SystemMessageEventUtil systemMessageEventUtil,\n+            final RoleAPI roleAPI)\n+    {\n+        return new ESReadOnlyMonitor(systemMessageEventUtil, roleAPI);\n+    }\n+    public static ESReadOnlyMonitor getInstance()\n+    {\n+        return Singleton.INSTANCE;\n+    }\n+\n+    public void start(final String message){\n+        if (this.start()) {\n+            Logger.error(this.getClass(), message);\n+        }\n+    }\n+\n+    /**\n+     * Start a {@link ESReadOnlyMonitor} is it is not started yet\n+     * @return false if a ESReadOnlyMonitor was started before\n+     */\n+    public boolean start(){\n+        if (started.compareAndSet(false, true)) {\n+            if (ElasticsearchUtil.isClusterInReadOnlyMode()) {\n+                ReindexThread.setCurrentIndexReadOnly(true);\n+                sendMessage(\"es.cluster.read.only.message\");\n+                startClusterMonitor();\n+            } else if (ElasticsearchUtil.isEitherLiveOrWorkingIndicesReadOnly()) {\n+                ReindexThread.setCurrentIndexReadOnly(true);\n+                sendMessage(\"es.index.read.only.message\");\n+                startIndexMonitor();\n+            } else {\n+                started.set(false);\n+            }\n+\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    private void sendMessage(final String messageKey) {\n+        try {\n+            final Role adminRole = roleAPI.loadCMSAdminRole();\n+            final List<String> usersId = roleAPI.findUsersForRole(adminRole)\n+                    .stream()\n+                    .map(user -> user.getUserId())\n+                    .collect(Collectors.toList());\n+\n+            final String message = LanguageUtil.get(messageKey);\n+\n+            final SystemMessageBuilder messageBuilder = new SystemMessageBuilder()\n+                    .setMessage(message)\n+                    .setSeverity(MessageSeverity.ERROR)\n+                    .setType(MessageType.SIMPLE_MESSAGE)\n+                    .setLife(TimeUnit.SECONDS.toMillis(5));\n+\n+            Logger.error(ESReadOnlyMonitor.class, message);\n+            systemMessageEventUtil.pushMessage(messageBuilder.create(), usersId);\n+        } catch (final LanguageException | DotDataException | DotSecurityException e) {\n+            Logger.warn(ESReadOnlyMonitor.class, () -> e.getMessage());\n+        }\n+    }\n+\n+    private void putCurrentIndicesToWriteMode() {\n+        try {\n+            Logger.debug(this.getClass(), () -> \"Trying to set the current indices to Write mode\");\n+            ElasticsearchUtil.setLiveAndWorkingIndicesToWriteMode();\n+            sendMessage(\"es.index.write.allow.message\");\n+            ReindexThread.setCurrentIndexReadOnly(false);\n+\n+            this.stop();\n+        } catch (final ElasticsearchResponseException e) {\n+            Logger.info(ESReadOnlyMonitor.class, ()  -> e.getMessage());\n+        }\n+    }\n+\n+    private void putClusterToWriteMode() {\n+        Logger.debug(this.getClass(), () -> \"Trying to set the current indices to Write mode\");\n+        ElasticsearchUtil.setClusterToWriteMode();\n+        sendMessage(\"es.cluster.write.allow.message\");\n+        ReindexThread.setCurrentIndexReadOnly(false);\n+\n+        this.stop();\n+    }\n+\n+    private void startIndexMonitor() {\n+         schedule(new IndexMonitorTimerTask(this));\n+    }\n+\n+    private synchronized void schedule(final TimerTask timerTask) {\n+        timer = new Timer(true);\n+        timer.schedule(timerTask, 0, TimeUnit.MINUTES.toMillis(1));\n+    }\n+\n+    private void startClusterMonitor() {\n+        schedule(new ClusterMonitorTimerTask(this));\n+    }\n+\n+    private synchronized void stop() {\n+        if (this.timer != null) {\n+            this.timer.cancel();\n+            this.timer = null;\n+            this.started.set(false);\n+        }\n+    }\n+\n+    private static class IndexMonitorTimerTask extends TimerTask{\n+        private final ESReadOnlyMonitor esReadOnlyMonitor;\n+\n+        IndexMonitorTimerTask(final ESReadOnlyMonitor esReadOnlyMonitor) {", "originalCommit": "9790a598c2ce5dadb7258f312a7360c571552437", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ1MzM0OA==", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r437453348", "bodyText": "Issue found: Avoid unused imports such as 'org.mockito.Mockito'", "author": "dev-dotcms", "createdAt": "2020-06-09T14:10:42Z", "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESReadOnlyMonitorTest.java", "diffHunk": "@@ -0,0 +1,317 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.api.system.event.message.MessageSeverity;\n+import com.dotcms.api.system.event.message.MessageType;\n+import com.dotcms.api.system.event.message.SystemMessageEventUtil;\n+import com.dotcms.api.system.event.message.builder.SystemMessageBuilder;\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotcms.util.IntegrationTestInitService;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.RoleAPI;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.liferay.portal.model.User;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.action.admin.cluster.settings.ClusterUpdateSettingsRequest;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.dotcms.util.CollectionsUtils.list;\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.Mockito.*;", "originalCommit": "9790a598c2ce5dadb7258f312a7360c571552437", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ1MzM1Mw==", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r437453353", "bodyText": "Issue found: Use block level rather than method level synchronization", "author": "dev-dotcms", "createdAt": "2020-06-09T14:10:43Z", "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESReadOnlyMonitor.java", "diffHunk": "@@ -0,0 +1,192 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.api.system.event.message.MessageSeverity;\n+import com.dotcms.api.system.event.message.MessageType;\n+import com.dotcms.api.system.event.message.SystemMessageEventUtil;\n+import com.dotcms.api.system.event.message.builder.SystemMessageBuilder;\n+import com.dotcms.repackage.com.google.common.annotations.VisibleForTesting;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.RoleAPI;\n+import com.dotmarketing.common.reindex.ReindexEntry;\n+import com.dotmarketing.common.reindex.ReindexThread;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.util.Logger;\n+import com.liferay.portal.language.LanguageException;\n+import com.liferay.portal.language.LanguageUtil;\n+\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This monitor is run when either the Live or Working indices are in read-only mode.  It attempts to set both Live and Working indices to write mode again.\n+ * When setting write-mode fails it will retry after one minute.\n+ */\n+public class ESReadOnlyMonitor {\n+    private final RoleAPI roleAPI;\n+    private final SystemMessageEventUtil systemMessageEventUtil;\n+\n+    private final AtomicBoolean started = new AtomicBoolean();\n+    private Timer timer;\n+\n+    private ESReadOnlyMonitor(\n+            final SystemMessageEventUtil systemMessageEventUtil,\n+            final RoleAPI roleAPI) {\n+        super();\n+        this.systemMessageEventUtil = systemMessageEventUtil;\n+        this.roleAPI = roleAPI;\n+        started.set(false);\n+    }\n+\n+    private ESReadOnlyMonitor() {\n+        this(\n+                SystemMessageEventUtil.getInstance(),\n+                APILocator.getRoleAPI()\n+        );\n+    }\n+\n+    // Inner class to provide instance of class\n+    private static class Singleton\n+    {\n+        private static final ESReadOnlyMonitor INSTANCE = new ESReadOnlyMonitor();\n+    }\n+\n+    @VisibleForTesting\n+    public static ESReadOnlyMonitor getInstance(\n+            final SystemMessageEventUtil systemMessageEventUtil,\n+            final RoleAPI roleAPI)\n+    {\n+        return new ESReadOnlyMonitor(systemMessageEventUtil, roleAPI);\n+    }\n+    public static ESReadOnlyMonitor getInstance()\n+    {\n+        return Singleton.INSTANCE;\n+    }\n+\n+    public void start(final String message){\n+        if (this.start()) {\n+            Logger.error(this.getClass(), message);\n+        }\n+    }\n+\n+    /**\n+     * Start a {@link ESReadOnlyMonitor} is it is not started yet\n+     * @return false if a ESReadOnlyMonitor was started before\n+     */\n+    public boolean start(){\n+        if (started.compareAndSet(false, true)) {\n+            if (ElasticsearchUtil.isClusterInReadOnlyMode()) {\n+                ReindexThread.setCurrentIndexReadOnly(true);\n+                sendMessage(\"es.cluster.read.only.message\");\n+                startClusterMonitor();\n+            } else if (ElasticsearchUtil.isEitherLiveOrWorkingIndicesReadOnly()) {\n+                ReindexThread.setCurrentIndexReadOnly(true);\n+                sendMessage(\"es.index.read.only.message\");\n+                startIndexMonitor();\n+            } else {\n+                started.set(false);\n+            }\n+\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    private void sendMessage(final String messageKey) {\n+        try {\n+            final Role adminRole = roleAPI.loadCMSAdminRole();\n+            final List<String> usersId = roleAPI.findUsersForRole(adminRole)\n+                    .stream()\n+                    .map(user -> user.getUserId())\n+                    .collect(Collectors.toList());\n+\n+            final String message = LanguageUtil.get(messageKey);\n+\n+            final SystemMessageBuilder messageBuilder = new SystemMessageBuilder()\n+                    .setMessage(message)\n+                    .setSeverity(MessageSeverity.ERROR)\n+                    .setType(MessageType.SIMPLE_MESSAGE)\n+                    .setLife(TimeUnit.SECONDS.toMillis(5));\n+\n+            Logger.error(ESReadOnlyMonitor.class, message);\n+            systemMessageEventUtil.pushMessage(messageBuilder.create(), usersId);\n+        } catch (final LanguageException | DotDataException | DotSecurityException e) {\n+            Logger.warn(ESReadOnlyMonitor.class, () -> e.getMessage());\n+        }\n+    }\n+\n+    private void putCurrentIndicesToWriteMode() {\n+        try {\n+            Logger.debug(this.getClass(), () -> \"Trying to set the current indices to Write mode\");\n+            ElasticsearchUtil.setLiveAndWorkingIndicesToWriteMode();\n+            sendMessage(\"es.index.write.allow.message\");\n+            ReindexThread.setCurrentIndexReadOnly(false);\n+\n+            this.stop();\n+        } catch (final ElasticsearchResponseException e) {\n+            Logger.info(ESReadOnlyMonitor.class, ()  -> e.getMessage());\n+        }\n+    }\n+\n+    private void putClusterToWriteMode() {\n+        Logger.debug(this.getClass(), () -> \"Trying to set the current indices to Write mode\");\n+        ElasticsearchUtil.setClusterToWriteMode();\n+        sendMessage(\"es.cluster.write.allow.message\");\n+        ReindexThread.setCurrentIndexReadOnly(false);\n+\n+        this.stop();\n+    }\n+\n+    private void startIndexMonitor() {\n+         schedule(new IndexMonitorTimerTask(this));\n+    }\n+\n+    private synchronized void schedule(final TimerTask timerTask) {", "originalCommit": "9790a598c2ce5dadb7258f312a7360c571552437", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ1MzM3NA==", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r437453374", "bodyText": "Issue found: Use block level rather than method level synchronization", "author": "dev-dotcms", "createdAt": "2020-06-09T14:10:44Z", "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESReadOnlyMonitor.java", "diffHunk": "@@ -0,0 +1,192 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.api.system.event.message.MessageSeverity;\n+import com.dotcms.api.system.event.message.MessageType;\n+import com.dotcms.api.system.event.message.SystemMessageEventUtil;\n+import com.dotcms.api.system.event.message.builder.SystemMessageBuilder;\n+import com.dotcms.repackage.com.google.common.annotations.VisibleForTesting;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.RoleAPI;\n+import com.dotmarketing.common.reindex.ReindexEntry;\n+import com.dotmarketing.common.reindex.ReindexThread;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.util.Logger;\n+import com.liferay.portal.language.LanguageException;\n+import com.liferay.portal.language.LanguageUtil;\n+\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This monitor is run when either the Live or Working indices are in read-only mode.  It attempts to set both Live and Working indices to write mode again.\n+ * When setting write-mode fails it will retry after one minute.\n+ */\n+public class ESReadOnlyMonitor {\n+    private final RoleAPI roleAPI;\n+    private final SystemMessageEventUtil systemMessageEventUtil;\n+\n+    private final AtomicBoolean started = new AtomicBoolean();\n+    private Timer timer;\n+\n+    private ESReadOnlyMonitor(\n+            final SystemMessageEventUtil systemMessageEventUtil,\n+            final RoleAPI roleAPI) {\n+        super();\n+        this.systemMessageEventUtil = systemMessageEventUtil;\n+        this.roleAPI = roleAPI;\n+        started.set(false);\n+    }\n+\n+    private ESReadOnlyMonitor() {\n+        this(\n+                SystemMessageEventUtil.getInstance(),\n+                APILocator.getRoleAPI()\n+        );\n+    }\n+\n+    // Inner class to provide instance of class\n+    private static class Singleton\n+    {\n+        private static final ESReadOnlyMonitor INSTANCE = new ESReadOnlyMonitor();\n+    }\n+\n+    @VisibleForTesting\n+    public static ESReadOnlyMonitor getInstance(\n+            final SystemMessageEventUtil systemMessageEventUtil,\n+            final RoleAPI roleAPI)\n+    {\n+        return new ESReadOnlyMonitor(systemMessageEventUtil, roleAPI);\n+    }\n+    public static ESReadOnlyMonitor getInstance()\n+    {\n+        return Singleton.INSTANCE;\n+    }\n+\n+    public void start(final String message){\n+        if (this.start()) {\n+            Logger.error(this.getClass(), message);\n+        }\n+    }\n+\n+    /**\n+     * Start a {@link ESReadOnlyMonitor} is it is not started yet\n+     * @return false if a ESReadOnlyMonitor was started before\n+     */\n+    public boolean start(){\n+        if (started.compareAndSet(false, true)) {\n+            if (ElasticsearchUtil.isClusterInReadOnlyMode()) {\n+                ReindexThread.setCurrentIndexReadOnly(true);\n+                sendMessage(\"es.cluster.read.only.message\");\n+                startClusterMonitor();\n+            } else if (ElasticsearchUtil.isEitherLiveOrWorkingIndicesReadOnly()) {\n+                ReindexThread.setCurrentIndexReadOnly(true);\n+                sendMessage(\"es.index.read.only.message\");\n+                startIndexMonitor();\n+            } else {\n+                started.set(false);\n+            }\n+\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    private void sendMessage(final String messageKey) {\n+        try {\n+            final Role adminRole = roleAPI.loadCMSAdminRole();\n+            final List<String> usersId = roleAPI.findUsersForRole(adminRole)\n+                    .stream()\n+                    .map(user -> user.getUserId())\n+                    .collect(Collectors.toList());\n+\n+            final String message = LanguageUtil.get(messageKey);\n+\n+            final SystemMessageBuilder messageBuilder = new SystemMessageBuilder()\n+                    .setMessage(message)\n+                    .setSeverity(MessageSeverity.ERROR)\n+                    .setType(MessageType.SIMPLE_MESSAGE)\n+                    .setLife(TimeUnit.SECONDS.toMillis(5));\n+\n+            Logger.error(ESReadOnlyMonitor.class, message);\n+            systemMessageEventUtil.pushMessage(messageBuilder.create(), usersId);\n+        } catch (final LanguageException | DotDataException | DotSecurityException e) {\n+            Logger.warn(ESReadOnlyMonitor.class, () -> e.getMessage());\n+        }\n+    }\n+\n+    private void putCurrentIndicesToWriteMode() {\n+        try {\n+            Logger.debug(this.getClass(), () -> \"Trying to set the current indices to Write mode\");\n+            ElasticsearchUtil.setLiveAndWorkingIndicesToWriteMode();\n+            sendMessage(\"es.index.write.allow.message\");\n+            ReindexThread.setCurrentIndexReadOnly(false);\n+\n+            this.stop();\n+        } catch (final ElasticsearchResponseException e) {\n+            Logger.info(ESReadOnlyMonitor.class, ()  -> e.getMessage());\n+        }\n+    }\n+\n+    private void putClusterToWriteMode() {\n+        Logger.debug(this.getClass(), () -> \"Trying to set the current indices to Write mode\");\n+        ElasticsearchUtil.setClusterToWriteMode();\n+        sendMessage(\"es.cluster.write.allow.message\");\n+        ReindexThread.setCurrentIndexReadOnly(false);\n+\n+        this.stop();\n+    }\n+\n+    private void startIndexMonitor() {\n+         schedule(new IndexMonitorTimerTask(this));\n+    }\n+\n+    private synchronized void schedule(final TimerTask timerTask) {\n+        timer = new Timer(true);\n+        timer.schedule(timerTask, 0, TimeUnit.MINUTES.toMillis(1));\n+    }\n+\n+    private void startClusterMonitor() {\n+        schedule(new ClusterMonitorTimerTask(this));\n+    }\n+\n+    private synchronized void stop() {", "originalCommit": "9790a598c2ce5dadb7258f312a7360c571552437", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ1MzM4OQ==", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r437453389", "bodyText": "Issue found: Avoid unused imports such as 'org.elasticsearch.ElasticsearchStatusException'", "author": "dev-dotcms", "createdAt": "2020-06-09T14:10:45Z", "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ElasticsearchUtil.java", "diffHunk": "@@ -0,0 +1,161 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.util.Logger;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import io.vavr.control.Try;\n+import org.elasticsearch.ElasticsearchStatusException;", "originalCommit": "9790a598c2ce5dadb7258f312a7360c571552437", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ1MzQwNw==", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r437453407", "bodyText": "Issue found: Classes implementing Serializable should set a serialVersionUID", "author": "dev-dotcms", "createdAt": "2020-06-09T14:10:46Z", "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ElasticsearchResponseException.java", "diffHunk": "@@ -0,0 +1,19 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+\n+/**\n+ * Throw when a Elasticsearch request fail\n+ */\n+public class ElasticsearchResponseException extends Exception {", "originalCommit": "9790a598c2ce5dadb7258f312a7360c571552437", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ1MzQxOQ==", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r437453419", "bodyText": "Issue found: Avoid unused imports such as 'com.dotmarketing.exception.DotRuntimeException'", "author": "dev-dotcms", "createdAt": "2020-06-09T14:10:47Z", "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESContentletAPIImplTest.java", "diffHunk": "@@ -27,6 +30,7 @@\n import com.dotmarketing.beans.Permission;\n import com.dotmarketing.business.*;\n import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;", "originalCommit": "9790a598c2ce5dadb7258f312a7360c571552437", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ1MzQzMw==", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r437453433", "bodyText": "Issue found: The String literal \"message\" appears 5 times in this file; the first occurrence is on line 61", "author": "dev-dotcms", "createdAt": "2020-06-09T14:10:48Z", "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESReadOnlyMonitorTest.java", "diffHunk": "@@ -0,0 +1,317 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.api.system.event.message.MessageSeverity;\n+import com.dotcms.api.system.event.message.MessageType;\n+import com.dotcms.api.system.event.message.SystemMessageEventUtil;\n+import com.dotcms.api.system.event.message.builder.SystemMessageBuilder;\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotcms.util.IntegrationTestInitService;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.RoleAPI;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.liferay.portal.model.User;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.action.admin.cluster.settings.ClusterUpdateSettingsRequest;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.dotcms.util.CollectionsUtils.list;\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.Mockito.*;\n+\n+public class ESReadOnlyMonitorTest {\n+\n+    private static ESReadOnlyMonitor esReadOnlyMonitor;\n+    private SystemMessageEventUtil systemMessageEventUtilMock;\n+    private RoleAPI roleAPIMock;\n+\n+    @BeforeClass\n+    public static void prepare () throws Exception {\n+        //Setting web app environment\n+        IntegrationTestInitService.getInstance().init();\n+    }\n+\n+    @Before\n+    public void init () {\n+        systemMessageEventUtilMock = mock(SystemMessageEventUtil.class);\n+        roleAPIMock = mock(RoleAPI.class);\n+\n+        esReadOnlyMonitor = ESReadOnlyMonitor.getInstance(systemMessageEventUtilMock, roleAPIMock);\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESReadOnlyMonitor#start(String)}\n+     * When: If the LIVE and WORKING current index are not read only\n+     * Should: not sent large message\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldNotSendLargeMessage() throws DotDataException, IOException {\n+        final String message = \"message\";", "originalCommit": "9790a598c2ce5dadb7258f312a7360c571552437", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ1MzQ0Mg==", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r437453442", "bodyText": "Issue found: This statement should have braces", "author": "dev-dotcms", "createdAt": "2020-06-09T14:10:49Z", "path": "dotCMS/src/main/java/com/dotcms/api/system/event/message/builder/SystemMessage.java", "diffHunk": "@@ -67,4 +69,23 @@ public String toString() {\n                 \", type=\" + type +\n                 '}';\n     }\n+\n+    @Override\n+    public boolean equals(final Object another) {\n+        if (this == another) return true;", "originalCommit": "9790a598c2ce5dadb7258f312a7360c571552437", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ1MzQ1Mg==", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r437453452", "bodyText": "Issue found: It is a good practice to call super() in a constructor", "author": "dev-dotcms", "createdAt": "2020-06-09T14:10:51Z", "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESReadOnlyMonitor.java", "diffHunk": "@@ -0,0 +1,192 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.api.system.event.message.MessageSeverity;\n+import com.dotcms.api.system.event.message.MessageType;\n+import com.dotcms.api.system.event.message.SystemMessageEventUtil;\n+import com.dotcms.api.system.event.message.builder.SystemMessageBuilder;\n+import com.dotcms.repackage.com.google.common.annotations.VisibleForTesting;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.RoleAPI;\n+import com.dotmarketing.common.reindex.ReindexEntry;\n+import com.dotmarketing.common.reindex.ReindexThread;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.util.Logger;\n+import com.liferay.portal.language.LanguageException;\n+import com.liferay.portal.language.LanguageUtil;\n+\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This monitor is run when either the Live or Working indices are in read-only mode.  It attempts to set both Live and Working indices to write mode again.\n+ * When setting write-mode fails it will retry after one minute.\n+ */\n+public class ESReadOnlyMonitor {\n+    private final RoleAPI roleAPI;\n+    private final SystemMessageEventUtil systemMessageEventUtil;\n+\n+    private final AtomicBoolean started = new AtomicBoolean();\n+    private Timer timer;\n+\n+    private ESReadOnlyMonitor(\n+            final SystemMessageEventUtil systemMessageEventUtil,\n+            final RoleAPI roleAPI) {\n+        super();\n+        this.systemMessageEventUtil = systemMessageEventUtil;\n+        this.roleAPI = roleAPI;\n+        started.set(false);\n+    }\n+\n+    private ESReadOnlyMonitor() {\n+        this(\n+                SystemMessageEventUtil.getInstance(),\n+                APILocator.getRoleAPI()\n+        );\n+    }\n+\n+    // Inner class to provide instance of class\n+    private static class Singleton\n+    {\n+        private static final ESReadOnlyMonitor INSTANCE = new ESReadOnlyMonitor();\n+    }\n+\n+    @VisibleForTesting\n+    public static ESReadOnlyMonitor getInstance(\n+            final SystemMessageEventUtil systemMessageEventUtil,\n+            final RoleAPI roleAPI)\n+    {\n+        return new ESReadOnlyMonitor(systemMessageEventUtil, roleAPI);\n+    }\n+    public static ESReadOnlyMonitor getInstance()\n+    {\n+        return Singleton.INSTANCE;\n+    }\n+\n+    public void start(final String message){\n+        if (this.start()) {\n+            Logger.error(this.getClass(), message);\n+        }\n+    }\n+\n+    /**\n+     * Start a {@link ESReadOnlyMonitor} is it is not started yet\n+     * @return false if a ESReadOnlyMonitor was started before\n+     */\n+    public boolean start(){\n+        if (started.compareAndSet(false, true)) {\n+            if (ElasticsearchUtil.isClusterInReadOnlyMode()) {\n+                ReindexThread.setCurrentIndexReadOnly(true);\n+                sendMessage(\"es.cluster.read.only.message\");\n+                startClusterMonitor();\n+            } else if (ElasticsearchUtil.isEitherLiveOrWorkingIndicesReadOnly()) {\n+                ReindexThread.setCurrentIndexReadOnly(true);\n+                sendMessage(\"es.index.read.only.message\");\n+                startIndexMonitor();\n+            } else {\n+                started.set(false);\n+            }\n+\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    private void sendMessage(final String messageKey) {\n+        try {\n+            final Role adminRole = roleAPI.loadCMSAdminRole();\n+            final List<String> usersId = roleAPI.findUsersForRole(adminRole)\n+                    .stream()\n+                    .map(user -> user.getUserId())\n+                    .collect(Collectors.toList());\n+\n+            final String message = LanguageUtil.get(messageKey);\n+\n+            final SystemMessageBuilder messageBuilder = new SystemMessageBuilder()\n+                    .setMessage(message)\n+                    .setSeverity(MessageSeverity.ERROR)\n+                    .setType(MessageType.SIMPLE_MESSAGE)\n+                    .setLife(TimeUnit.SECONDS.toMillis(5));\n+\n+            Logger.error(ESReadOnlyMonitor.class, message);\n+            systemMessageEventUtil.pushMessage(messageBuilder.create(), usersId);\n+        } catch (final LanguageException | DotDataException | DotSecurityException e) {\n+            Logger.warn(ESReadOnlyMonitor.class, () -> e.getMessage());\n+        }\n+    }\n+\n+    private void putCurrentIndicesToWriteMode() {\n+        try {\n+            Logger.debug(this.getClass(), () -> \"Trying to set the current indices to Write mode\");\n+            ElasticsearchUtil.setLiveAndWorkingIndicesToWriteMode();\n+            sendMessage(\"es.index.write.allow.message\");\n+            ReindexThread.setCurrentIndexReadOnly(false);\n+\n+            this.stop();\n+        } catch (final ElasticsearchResponseException e) {\n+            Logger.info(ESReadOnlyMonitor.class, ()  -> e.getMessage());\n+        }\n+    }\n+\n+    private void putClusterToWriteMode() {\n+        Logger.debug(this.getClass(), () -> \"Trying to set the current indices to Write mode\");\n+        ElasticsearchUtil.setClusterToWriteMode();\n+        sendMessage(\"es.cluster.write.allow.message\");\n+        ReindexThread.setCurrentIndexReadOnly(false);\n+\n+        this.stop();\n+    }\n+\n+    private void startIndexMonitor() {\n+         schedule(new IndexMonitorTimerTask(this));\n+    }\n+\n+    private synchronized void schedule(final TimerTask timerTask) {\n+        timer = new Timer(true);\n+        timer.schedule(timerTask, 0, TimeUnit.MINUTES.toMillis(1));\n+    }\n+\n+    private void startClusterMonitor() {\n+        schedule(new ClusterMonitorTimerTask(this));\n+    }\n+\n+    private synchronized void stop() {\n+        if (this.timer != null) {\n+            this.timer.cancel();\n+            this.timer = null;\n+            this.started.set(false);\n+        }\n+    }\n+\n+    private static class IndexMonitorTimerTask extends TimerTask{\n+        private final ESReadOnlyMonitor esReadOnlyMonitor;\n+\n+        IndexMonitorTimerTask(final ESReadOnlyMonitor esReadOnlyMonitor) {\n+            this.esReadOnlyMonitor = esReadOnlyMonitor;\n+        }\n+\n+        @Override\n+        public void run() {\n+            this.esReadOnlyMonitor.putCurrentIndicesToWriteMode();\n+        }\n+    }\n+\n+    private static class ClusterMonitorTimerTask extends TimerTask{\n+        private final ESReadOnlyMonitor esReadOnlyMonitor;\n+\n+        ClusterMonitorTimerTask(final ESReadOnlyMonitor esReadOnlyMonitor) {", "originalCommit": "9790a598c2ce5dadb7258f312a7360c571552437", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ1MzQ2NA==", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r437453464", "bodyText": "Issue found: Avoid unused imports such as 'org.jgroups.util.Util.assertEquals'", "author": "dev-dotcms", "createdAt": "2020-06-09T14:10:52Z", "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ElasticsearchUtilTest.java", "diffHunk": "@@ -0,0 +1,264 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.ElasticsearchStatusException;\n+import org.elasticsearch.action.admin.cluster.settings.ClusterUpdateSettingsRequest;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.junit.BeforeClass;\n+import com.dotcms.util.IntegrationTestInitService;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+\n+import static org.jgroups.util.Util.assertEquals;", "originalCommit": "9790a598c2ce5dadb7258f312a7360c571552437", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ1MzQ3NQ==", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r437453475", "bodyText": "Issue found: Avoid unused imports such as 'com.dotmarketing.common.reindex.ReindexEntry'", "author": "dev-dotcms", "createdAt": "2020-06-09T14:10:53Z", "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESReadOnlyMonitor.java", "diffHunk": "@@ -0,0 +1,192 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.api.system.event.message.MessageSeverity;\n+import com.dotcms.api.system.event.message.MessageType;\n+import com.dotcms.api.system.event.message.SystemMessageEventUtil;\n+import com.dotcms.api.system.event.message.builder.SystemMessageBuilder;\n+import com.dotcms.repackage.com.google.common.annotations.VisibleForTesting;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.RoleAPI;\n+import com.dotmarketing.common.reindex.ReindexEntry;", "originalCommit": "9790a598c2ce5dadb7258f312a7360c571552437", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ1MzQ4OQ==", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r437453489", "bodyText": "Issue found: Use assertTrue(x)/assertFalse(x) instead of assertEquals(true, x)/assertEquals(false, x) or assertEquals(Boolean.TRUE, x)/assertEquals(Boolean.FALSE, x).", "author": "dev-dotcms", "createdAt": "2020-06-09T14:10:54Z", "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESReadOnlyMonitorTest.java", "diffHunk": "@@ -0,0 +1,317 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.api.system.event.message.MessageSeverity;\n+import com.dotcms.api.system.event.message.MessageType;\n+import com.dotcms.api.system.event.message.SystemMessageEventUtil;\n+import com.dotcms.api.system.event.message.builder.SystemMessageBuilder;\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotcms.util.IntegrationTestInitService;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.RoleAPI;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.liferay.portal.model.User;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.action.admin.cluster.settings.ClusterUpdateSettingsRequest;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.dotcms.util.CollectionsUtils.list;\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.Mockito.*;\n+\n+public class ESReadOnlyMonitorTest {\n+\n+    private static ESReadOnlyMonitor esReadOnlyMonitor;\n+    private SystemMessageEventUtil systemMessageEventUtilMock;\n+    private RoleAPI roleAPIMock;\n+\n+    @BeforeClass\n+    public static void prepare () throws Exception {\n+        //Setting web app environment\n+        IntegrationTestInitService.getInstance().init();\n+    }\n+\n+    @Before\n+    public void init () {\n+        systemMessageEventUtilMock = mock(SystemMessageEventUtil.class);\n+        roleAPIMock = mock(RoleAPI.class);\n+\n+        esReadOnlyMonitor = ESReadOnlyMonitor.getInstance(systemMessageEventUtilMock, roleAPIMock);\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESReadOnlyMonitor#start(String)}\n+     * When: If the LIVE and WORKING current index are not read only\n+     * Should: not sent large message\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldNotSendLargeMessage() throws DotDataException, IOException {\n+        final String message = \"message\";\n+\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        setReadOnly(indiciesInfo.getWorking(), false);\n+        setReadOnly(indiciesInfo.getLive(), false);\n+\n+        esReadOnlyMonitor.start(message);\n+\n+        verify(systemMessageEventUtilMock, never()).pushLargeMessage(any(), any());\n+\n+        assertEquals(false, ElasticsearchUtil.isAnyReadOnly(indiciesInfo.getWorking(), indiciesInfo.getLive()));\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESReadOnlyMonitor#start(String)}\n+     * When: If any of LIVE and WORKING current index are read only\n+     * Should: sent large message\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldSendLargeMessage() throws DotDataException, DotSecurityException, InterruptedException, IOException {\n+        final String message = \"message\";\n+\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        final Role adminRole = mock(Role.class);\n+        when(roleAPIMock.loadCMSAdminRole()).thenReturn(adminRole);\n+\n+        final User user = mock(User.class);\n+        when(user.getUserId()).thenReturn(\"1\");\n+\n+        when(roleAPIMock.findUsersForRole(adminRole)).thenReturn(list(user));\n+\n+        try {\n+            setReadOnly(indiciesInfo.getWorking(), true);\n+            setReadOnly(indiciesInfo.getLive(), false);\n+\n+            esReadOnlyMonitor.start(message);\n+\n+            Thread.sleep(100);\n+\n+            checkLargeMessageSent(user);\n+            assertEquals(false, ElasticsearchUtil.isAnyReadOnly(indiciesInfo.getWorking(), indiciesInfo.getLive()));\n+        } finally {\n+            setReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESReadOnlyMonitor#start()}\n+     * When: If the cluster is read only\n+     * Should: sent message\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldSendLargeMessageIfTheClusterIsInReadOnly() throws DotDataException, DotSecurityException, InterruptedException, IOException {\n+        final String message = \"message\";\n+\n+        final Role adminRole = mock(Role.class);\n+        when(roleAPIMock.loadCMSAdminRole()).thenReturn(adminRole);\n+\n+        final User user = mock(User.class);\n+        when(user.getUserId()).thenReturn(\"1\");\n+\n+        when(roleAPIMock.findUsersForRole(adminRole)).thenReturn(list(user));\n+\n+        try {\n+            setClusterAsReadOnly(true);\n+\n+            esReadOnlyMonitor.start(message);\n+\n+            Thread.sleep(100);\n+\n+            checkClusterLargeMessageSent(user);\n+            assertEquals(false, ElasticsearchUtil.isClusterInReadOnlyMode());", "originalCommit": "9790a598c2ce5dadb7258f312a7360c571552437", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ1MzUwMw==", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r437453503", "bodyText": "Issue found: Avoid unused imports such as 'org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest'", "author": "dev-dotcms", "createdAt": "2020-06-09T14:10:55Z", "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESContentletAPIImplTest.java", "diffHunk": "@@ -48,6 +52,12 @@\n import java.util.Date;\n import java.util.List;\n \n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.action.admin.cluster.settings.ClusterUpdateSettingsRequest;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;", "originalCommit": "9790a598c2ce5dadb7258f312a7360c571552437", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ1MzUzMw==", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r437453533", "bodyText": "Issue found: Avoid unused imports such as 'org.mockito.Mockito'", "author": "dev-dotcms", "createdAt": "2020-06-09T14:10:56Z", "path": "dotCMS/src/integration-test/java/com/dotmarketing/common/reindex/ReindexQueueAPITest.java", "diffHunk": "@@ -5,7 +5,9 @@\n import static org.junit.Assert.assertFalse;\n import static org.junit.Assert.assertNotNull;\n import static org.junit.Assert.assertTrue;\n+import static org.mockito.Mockito.*;", "originalCommit": "9790a598c2ce5dadb7258f312a7360c571552437", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ1MzU0Nw==", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r437453547", "bodyText": "Issue found: A method/constructor should not explicitly throw java.lang.Exception", "author": "dev-dotcms", "createdAt": "2020-06-09T14:10:58Z", "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESReadOnlyMonitorTest.java", "diffHunk": "@@ -0,0 +1,317 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.api.system.event.message.MessageSeverity;\n+import com.dotcms.api.system.event.message.MessageType;\n+import com.dotcms.api.system.event.message.SystemMessageEventUtil;\n+import com.dotcms.api.system.event.message.builder.SystemMessageBuilder;\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotcms.util.IntegrationTestInitService;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.RoleAPI;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.liferay.portal.model.User;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.action.admin.cluster.settings.ClusterUpdateSettingsRequest;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.dotcms.util.CollectionsUtils.list;\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.Mockito.*;\n+\n+public class ESReadOnlyMonitorTest {\n+\n+    private static ESReadOnlyMonitor esReadOnlyMonitor;\n+    private SystemMessageEventUtil systemMessageEventUtilMock;\n+    private RoleAPI roleAPIMock;\n+\n+    @BeforeClass\n+    public static void prepare () throws Exception {", "originalCommit": "9790a598c2ce5dadb7258f312a7360c571552437", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ1MzU1OQ==", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r437453559", "bodyText": "Issue found: A method/constructor should not explicitly throw java.lang.Exception", "author": "dev-dotcms", "createdAt": "2020-06-09T14:10:58Z", "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ElasticsearchUtilTest.java", "diffHunk": "@@ -0,0 +1,264 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.ElasticsearchStatusException;\n+import org.elasticsearch.action.admin.cluster.settings.ClusterUpdateSettingsRequest;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.junit.BeforeClass;\n+import com.dotcms.util.IntegrationTestInitService;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+\n+import static org.jgroups.util.Util.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+public class ElasticsearchUtilTest {\n+\n+    @BeforeClass\n+    public static void prepare () throws Exception {", "originalCommit": "9790a598c2ce5dadb7258f312a7360c571552437", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ1MzU3Mw==", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r437453573", "bodyText": "Issue found: Use assertTrue(x)/assertFalse(x) instead of assertEquals(true, x)/assertEquals(false, x) or assertEquals(Boolean.TRUE, x)/assertEquals(Boolean.FALSE, x).", "author": "dev-dotcms", "createdAt": "2020-06-09T14:11:00Z", "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESReadOnlyMonitorTest.java", "diffHunk": "@@ -0,0 +1,317 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.api.system.event.message.MessageSeverity;\n+import com.dotcms.api.system.event.message.MessageType;\n+import com.dotcms.api.system.event.message.SystemMessageEventUtil;\n+import com.dotcms.api.system.event.message.builder.SystemMessageBuilder;\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotcms.util.IntegrationTestInitService;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.RoleAPI;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.liferay.portal.model.User;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.action.admin.cluster.settings.ClusterUpdateSettingsRequest;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.dotcms.util.CollectionsUtils.list;\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.Mockito.*;\n+\n+public class ESReadOnlyMonitorTest {\n+\n+    private static ESReadOnlyMonitor esReadOnlyMonitor;\n+    private SystemMessageEventUtil systemMessageEventUtilMock;\n+    private RoleAPI roleAPIMock;\n+\n+    @BeforeClass\n+    public static void prepare () throws Exception {\n+        //Setting web app environment\n+        IntegrationTestInitService.getInstance().init();\n+    }\n+\n+    @Before\n+    public void init () {\n+        systemMessageEventUtilMock = mock(SystemMessageEventUtil.class);\n+        roleAPIMock = mock(RoleAPI.class);\n+\n+        esReadOnlyMonitor = ESReadOnlyMonitor.getInstance(systemMessageEventUtilMock, roleAPIMock);\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESReadOnlyMonitor#start(String)}\n+     * When: If the LIVE and WORKING current index are not read only\n+     * Should: not sent large message\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldNotSendLargeMessage() throws DotDataException, IOException {\n+        final String message = \"message\";\n+\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        setReadOnly(indiciesInfo.getWorking(), false);\n+        setReadOnly(indiciesInfo.getLive(), false);\n+\n+        esReadOnlyMonitor.start(message);\n+\n+        verify(systemMessageEventUtilMock, never()).pushLargeMessage(any(), any());\n+\n+        assertEquals(false, ElasticsearchUtil.isAnyReadOnly(indiciesInfo.getWorking(), indiciesInfo.getLive()));", "originalCommit": "9790a598c2ce5dadb7258f312a7360c571552437", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ1MzU5NA==", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r437453594", "bodyText": "Issue found: Avoid unused imports such as 'io.vavr.control.Try'", "author": "dev-dotcms", "createdAt": "2020-06-09T14:11:01Z", "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ElasticsearchUtil.java", "diffHunk": "@@ -0,0 +1,161 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.util.Logger;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import io.vavr.control.Try;", "originalCommit": "9790a598c2ce5dadb7258f312a7360c571552437", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ1MzYwOA==", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r437453608", "bodyText": "Issue found: This statement should have braces", "author": "dev-dotcms", "createdAt": "2020-06-09T14:11:02Z", "path": "dotCMS/src/main/java/com/dotcms/api/system/event/message/builder/SystemMessage.java", "diffHunk": "@@ -67,4 +69,23 @@ public String toString() {\n                 \", type=\" + type +\n                 '}';\n     }\n+\n+    @Override\n+    public boolean equals(final Object another) {\n+        if (this == another) return true;\n+        if (another == null || getClass() != another.getClass()) return false;", "originalCommit": "9790a598c2ce5dadb7258f312a7360c571552437", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}