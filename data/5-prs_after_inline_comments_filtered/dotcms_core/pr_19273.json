{"pr_number": 19273, "pr_title": "Issue 16796 jwt pp auth 2", "pr_createdAt": "2020-09-16T16:06:31Z", "pr_url": "https://github.com/dotCMS/core/pull/19273", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI5Njc4MA==", "url": "https://github.com/dotCMS/core/pull/19273#discussion_r495296780", "bodyText": "Codacy found an issue: All methods are static.  Consider using a utility class instead. Alternatively, you could add a private constructor or make the class abstract to silence this warning.", "author": "dev-dotcms", "createdAt": "2020-09-25T22:52:41Z", "path": "dotCMS/src/main/java/com/dotcms/rest/RestEndPointIPUtil.java", "diffHunk": "@@ -0,0 +1,35 @@\n+package com.dotcms.rest;\n+\n+import com.dotcms.util.HttpRequestDataUtil;\n+import com.dotmarketing.util.UtilMethods;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.ws.rs.core.Context;\n+import java.util.Optional;\n+\n+/**\n+ * Provide util methods to get remote or local IP from {@link HttpServletRequest}\n+ */\n+public class RestEndPointIPUtil {", "originalCommit": "31011524a73fdfdaf924361ea51973388817610c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI5Njc4Ng==", "url": "https://github.com/dotCMS/core/pull/19273#discussion_r495296786", "bodyText": "Codacy found an issue: The String literal \"anyIP\" appears 5 times in this file; the first occurrence is on line 54", "author": "dev-dotcms", "createdAt": "2020-09-25T22:52:41Z", "path": "dotCMS/src/integration-test/java/com/dotmarketing/startup/runonce/Task05390RemoveEndpointIdForeignKeyInIntegrityResolverTablesIntegrationTest.java", "diffHunk": "@@ -0,0 +1,208 @@\n+package com.dotmarketing.startup.runonce;\n+\n+import com.dotcms.util.IntegrationTestInitService;\n+import com.dotmarketing.common.db.DotConnect;\n+import com.dotmarketing.common.db.DotDatabaseMetaData;\n+import com.dotmarketing.db.DbConnectionFactory;\n+import com.dotmarketing.exception.DotDataException;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.sql.Connection;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.dotcms.util.CollectionsUtils.list;\n+import static com.dotcms.util.CollectionsUtils.map;\n+import static org.junit.Assert.assertEquals;\n+\n+\n+public class Task05390RemoveEndpointIdForeignKeyInIntegrityResolverTablesIntegrationTest {\n+\n+    @BeforeClass\n+    public static void prepare() throws Exception {\n+        // Setting web app environment\n+        IntegrationTestInitService.getInstance().init();\n+    }\n+\n+    /**\n+     * Method to Test: {@link Task05390RemoveEndpointIdForeignKeyInIntegrityResolverTables#executeUpgrade()}\n+     * When: Run the Upgrade Task\n+     * Should: Should remove the foreign key to all the Integrity Resolver tables and rename the column endpoint_id\n+     * The Integrity Resolver tables are:\n+     * - cms_roles_ir\n+     * - folders_ir\n+     * - structures_ir\n+     * - htmlpages_ir\n+     * - fileassets_ir\n+     *\n+     * After remove the constraint you should be allow to insert register in this table without has any register in publishing_end_point\n+     */\n+    @Test\n+    public void constraintShouldNotExists() throws DotDataException, SQLException {\n+\n+        final String endpointId = insertPublishingEndPoint();\n+        insertFolderIntegrityResolver(endpointId);\n+        insertPageIntegrityResolver(endpointId);\n+        insertFileAssetIntegrityResolver(endpointId);\n+        insertRolesIntegrityResolver(endpointId);\n+        insertStructuresIntegrityResolver(endpointId);\n+\n+        final Task05390RemoveEndpointIdForeignKeyInIntegrityResolverTables task05390RemoveEndpointIdForeignKeyInIntegrityResolverTables =\n+                new Task05390RemoveEndpointIdForeignKeyInIntegrityResolverTables();\n+\n+        task05390RemoveEndpointIdForeignKeyInIntegrityResolverTables.executeUpgrade();\n+\n+        insertFolderIntegrityResolver(\"anyIP\");", "originalCommit": "31011524a73fdfdaf924361ea51973388817610c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI5Njc5NA==", "url": "https://github.com/dotCMS/core/pull/19273#discussion_r495296794", "bodyText": "Codacy found an issue: Avoid unused imports such as 'javax.ws.rs'", "author": "dev-dotcms", "createdAt": "2020-09-25T22:52:42Z", "path": "dotCMS/src/main/java/com/dotcms/rest/api/v1/system/ConfigurationResource.java", "diffHunk": "@@ -6,12 +6,15 @@\n \n import javax.servlet.http.HttpServletRequest;\n \n-import javax.ws.rs.GET;\n-import javax.ws.rs.Path;\n-import javax.ws.rs.Produces;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.ws.rs.*;", "originalCommit": "31011524a73fdfdaf924361ea51973388817610c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI5NjgwMA==", "url": "https://github.com/dotCMS/core/pull/19273#discussion_r495296800", "bodyText": "Codacy found an issue: Avoid unused imports such as 'com.dotmarketing.util.UtilMethods'", "author": "dev-dotcms", "createdAt": "2020-09-25T22:52:43Z", "path": "dotCMS/src/main/java/com/dotcms/rest/PushPublishResourceUtil.java", "diffHunk": "@@ -0,0 +1,88 @@\n+package com.dotcms.rest;\n+\n+import com.dotcms.publisher.pusher.AuthCredentialPushPublishUtil;\n+import com.dotcms.repackage.org.apache.http.HttpStatus;\n+import com.dotcms.util.CollectionsUtils;\n+import com.dotcms.util.HttpRequestDataUtil;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.UtilMethods;", "originalCommit": "31011524a73fdfdaf924361ea51973388817610c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI5NjgwMg==", "url": "https://github.com/dotCMS/core/pull/19273#discussion_r495296802", "bodyText": "Codacy found an issue: A method/constructor should not explicitly throw java.lang.Exception", "author": "dev-dotcms", "createdAt": "2020-09-25T22:52:45Z", "path": "dotCMS/src/main/java/com/dotcms/rest/BundlePublisherResource.java", "diffHunk": "@@ -37,148 +36,128 @@\n public class BundlePublisherResource {\n \n \tpublic static String MY_TEMP = \"\";\n-\tprivate PublishingEndPointAPI endpointAPI = APILocator.getPublisherEndPointAPI();\n-\n-    /**\n-     * Method that receives from a server a bundle with the intention of publish it.<br/>\n-     * When a Bundle file is received on this end point is required to validate if the sending server is an allowed<br/>\n-     * server on this end point and if the security tokens match. If all the validations are correct the bundle will be add it<br/>\n-     * to the {@link PublishThread Publish Thread}.\n-     *\n-     * @param fileName       File name to be published\n-     * @param auth_token_enc Authentication token\n-     * @param groupId        Group who sent the Bundle\n-     * @param endpointId     End-point who sent the Bundle\n-\t * @param type\t\t\t response type\n-\t * @param callback \t\t response callback\n-\t * @param bundleName\t The name for the Bundle to publish\n-\t * @param forcePush \t true/false to Force the push\n-     * @param req            HttpRequest\n-     * @return Returns a {@link Response} object with a 200 status code if success or a 500 error code if anything fails on the Publish process\n-     * @see PublishThread\n-     */\n-    @POST\n-    @Path (\"/publish\")\n-    @Consumes(MediaType.APPLICATION_OCTET_STREAM)\n+\n+\t/**\n+\t * Method that receives from a server a bundle with the intention of publish it.<br/>\n+\t * When a Bundle file is received on this end point is required to validate if the sending server is an allowed<br/>\n+\t * server on this end point and if the security tokens match. If all the validations are correct the bundle will be add it<br/>\n+\t * to the {@link PublishThread Publish Thread}.\n+\t *\n+\t * @param type\t\t\t  response type\n+\t * @param callback \t\t  response callback\n+\t * @param forcePush \t  true/false to Force the push\n+\t * @param request         {@link HttpServletRequest}\n+\t * @param response        {@link HttpServletResponse}\n+\t * @return Returns a {@link Response} object with a 200 status code if success or a 500 error code if anything fails on the Publish process\n+\t * @see PublishThread\n+\t */\n+\t@POST\n+\t@Path(\"/publish\")\n+\t@Consumes(MediaType.APPLICATION_OCTET_STREAM)\n+\t@Produces(MediaType.APPLICATION_JSON)\n \tpublic Response publish(\n-\t\t\t@QueryParam(\"FILE_NAME\") String fileName,\n-\t\t\t@QueryParam(\"AUTH_TOKEN\") String auth_token_digest,\n-\t\t\t@QueryParam(\"GROUP_ID\") String groupId,\n-\t\t\t@QueryParam(\"ENDPOINT_ID\") String endpointId,\n-\t\t\t@QueryParam(\"type\") String type,\n-\t\t\t@QueryParam(\"callback\") String callback,\n-\t\t\t@QueryParam(\"BUNDLE_NAME\") String bundleName,\n-\t\t\t@QueryParam(\"FORCE_PUSH\") final boolean forcePush,\n-\t\t\t@Context HttpServletRequest req\n-\t) {\n-    \ttry {\n-    \t\ttry (InputStream bundleStream = req.getInputStream()) {\n-\t\t        //Creating an utility response object\n-\t\t        Map<String, String> paramsMap = new HashMap<String, String>();\n-\t\t        paramsMap.put( \"type\", type );\n-\t\t        paramsMap.put( \"callback\", callback );\n-\t\t        ResourceResponse responseResource = new ResourceResponse( paramsMap );\n-\n-\t\t\t\tString remoteIP = \"\";\n-\t\t\t\ttry {\n-\n-\t\t\t\t\tremoteIP = req.getRemoteHost();\n-\t\t\t\t\tif(!UtilMethods.isSet(remoteIP))\n-\t\t\t\t\t\tremoteIP = req.getRemoteAddr();\n-\n-\t\t\t\t\tHibernateUtil.startTransaction();\n-\n-\t\t\t\t\tPublishingEndPoint mySelf = endpointAPI.findEnabledSendingEndPointByAddress(remoteIP);\n-\n-\t\t\t\t\tif(mySelf==null || !isValidToken(auth_token_digest, remoteIP, mySelf)) {\n-\t\t\t\t\t\tbundleStream.close();\n-\t\t\t\t\t\tLogger.error(this.getClass(), \"Push Publishing failed from \" + remoteIP + \" invalid endpoint or token\");\n-\t\t\t\t\t\t\n-\t\t        return responseResource.responseError( HttpStatus.SC_UNAUTHORIZED );\n-\t\t       }\n-\n-\t\t\t\t\tString bundlePath = ConfigUtils.getBundlePath()+File.separator+MY_TEMP;\n-\t\t\t\t\tString bundleFolder = fileName.substring(0, fileName.indexOf(\".tar.gz\"));\n-\n-\t\t            PublishAuditStatus status = PublishAuditAPI.getInstance().updateAuditTable( mySelf.getId(), mySelf.getId(), bundleFolder, true );\n-\n-\t\t            if(bundleName.trim().length()>0) {\n-\t\t\t\t\t    // save bundle if it doesn't exists\n-\t\t                Bundle foundBundle = APILocator.getBundleAPI().getBundleById( bundleFolder );\n-\t\t                if ( foundBundle == null || foundBundle.getId() == null ) {\n-\t\t                    Bundle bundle = new Bundle();\n-\t\t\t\t\t\t\tbundle.setId(bundleFolder);\n-\t\t\t\t\t\t\tbundle.setName(bundleName);\n-\t\t\t\t\t\t\tbundle.setPublishDate(Calendar.getInstance().getTime());\n-\t\t\t\t\t\t\tbundle.setOwner(APILocator.getUserAPI().getSystemUser().getUserId());\n-\t\t\t\t\t\t\tbundle.setForcePush(forcePush);\n-\t\t                    APILocator.getBundleAPI().saveBundle(bundle);\n-\t\t\t\t\t    }\n-\t\t\t\t\t}\n-\n-\t\t\t\t\t//Write file on FS\n-\t\t\t\t\tFileUtil.writeToFile(bundleStream, bundlePath+fileName);\n-\n-\t\t\t\t\t//Start thread\n-\t\t\t\t\tif(!status.getStatus().equals(Status.PUBLISHING_BUNDLE)) {\n-\t\t\t\t\t\tnew Thread(new PublishThread(fileName, groupId, endpointId, status)).start();\n-\t\t\t\t\t}\n-\n-\t\t\t\t\tHibernateUtil.commitTransaction();\n-\n-\t\t\t\t\treturn Response.status(HttpStatus.SC_OK).build();\n-\t\t\t\t} catch (NumberFormatException e) {\n-\t\t\t\t    try {\n-\t\t                HibernateUtil.rollbackTransaction();\n-\t\t            } catch (DotHibernateException e1) {\n-\t\t                Logger.error(this, \"error rollback\",e1);\n-\t\t            }\n-\t\t\t\t\tLogger.error(PublisherQueueJob.class,e.getMessage(),e);\n-\t\t\t\t} catch (Exception e) {\n-\t\t\t\t    try {\n-\t\t                HibernateUtil.rollbackTransaction();\n-\t\t            } catch (DotHibernateException e1) {\n-\t\t                Logger.error(this, \"error rollback\",e1);\n-\t\t            }\n-\t\t\t\t\tLogger.error(PublisherQueueJob.class, \"Error caused by remote call of: \"+remoteIP);\n-\t\t\t\t\tLogger.error(PublisherQueueJob.class,e.getMessage(),e);\n-\t\t\t\t}\n-\t\t\t\tfinally {\n-\t\t\t\t    try {\n-\t\t                HibernateUtil.closeSession();\n-\t\t            } catch (DotHibernateException e) {\n-\t\t                Logger.error(this, \"error close session\",e);\n-\t\t            }\n-\t\t\t\t}\n-    \t\t}\n-    \t} catch (IOException e) {\n-    \t\tLogger.error(PublisherQueueJob.class,e.getMessage(),e);\n-    \t}\n-\n-\t\treturn Response.status(HttpStatus.SC_INTERNAL_SERVER_ERROR).build();\n+\t\t\t@QueryParam(\"type\")        final String type,\n+\t\t\t@QueryParam(\"callback\")    final String callback,\n+\t\t\t@QueryParam(\"FORCE_PUSH\")  final boolean forcePush,\n+\t\t\t@Context final HttpServletRequest  request,\n+\t\t\t@Context final HttpServletResponse response\n+\t) throws Exception {\n+\t\tfinal ResourceResponse responseResource = new ResourceResponse(\n+\t\t\t\tCollectionsUtils.map(\"type\", type, \"callback\", callback));\n+\t\tfinal String remoteIP = UtilMethods.isSet(request.getRemoteHost())?\n+\t\t\t\trequest.getRemoteHost() : request.getRemoteAddr();\n+\n+\t\tif (request.getInputStream().isFinished()) {\n+\t\t\tLogger.error(this.getClass(), \"Push Publishing failed from \" + remoteIP + \" bundle expected\");\n+\t\t\treturn responseResource.responseError(HttpStatus.SC_BAD_REQUEST);\n+\t\t}\n+\n+\t\tfinal AuthCredentialPushPublishUtil.PushPublishAuthenticationToken pushPublishAuthenticationToken\n+\t\t\t\t= AuthCredentialPushPublishUtil.INSTANCE.processAuthHeader(request);\n+\n+\t\tfinal Optional<Response> failResponse = PushPublishResourceUtil.getFailResponse(request, pushPublishAuthenticationToken);\n+\n+\t\tif (failResponse.isPresent()) {\n+\t\t\treturn failResponse.get();\n+\t\t}\n+\n+\t\tfinal Bundle bundle = this.publishBundle(forcePush, request, remoteIP);\n+\n+\t\treturn Response.ok(bundle).build();\n \t}\n \n-    /**\n-     * Validates a received token\n-     *\n-     * @param token    Token to validate\n-     * @param remoteIP Sender IP\n-     * @param mySelf   Current end point\n-     * @return True if valid\n-     * @throws IOException If fails reading the security token\n-     */\n-    public static boolean isValidToken ( String token, String remoteIP, PublishingEndPoint mySelf ) throws IOException {\n+\t@WrapInTransaction\n+\tprivate Bundle publishBundle(final boolean forcePush,\n+\t\t\t\t\t\t\t\t final HttpServletRequest request,\n+\t\t\t\t\t\t\t\t final String remoteIP) throws Exception {", "originalCommit": "31011524a73fdfdaf924361ea51973388817610c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI5NjgwOA==", "url": "https://github.com/dotCMS/core/pull/19273#discussion_r495296808", "bodyText": "Codacy found an issue: A method/constructor should not explicitly throw java.lang.Exception", "author": "dev-dotcms", "createdAt": "2020-09-25T22:52:46Z", "path": "dotCMS/src/main/java/com/dotcms/rest/BundlePublisherResource.java", "diffHunk": "@@ -37,148 +36,128 @@\n public class BundlePublisherResource {\n \n \tpublic static String MY_TEMP = \"\";\n-\tprivate PublishingEndPointAPI endpointAPI = APILocator.getPublisherEndPointAPI();\n-\n-    /**\n-     * Method that receives from a server a bundle with the intention of publish it.<br/>\n-     * When a Bundle file is received on this end point is required to validate if the sending server is an allowed<br/>\n-     * server on this end point and if the security tokens match. If all the validations are correct the bundle will be add it<br/>\n-     * to the {@link PublishThread Publish Thread}.\n-     *\n-     * @param fileName       File name to be published\n-     * @param auth_token_enc Authentication token\n-     * @param groupId        Group who sent the Bundle\n-     * @param endpointId     End-point who sent the Bundle\n-\t * @param type\t\t\t response type\n-\t * @param callback \t\t response callback\n-\t * @param bundleName\t The name for the Bundle to publish\n-\t * @param forcePush \t true/false to Force the push\n-     * @param req            HttpRequest\n-     * @return Returns a {@link Response} object with a 200 status code if success or a 500 error code if anything fails on the Publish process\n-     * @see PublishThread\n-     */\n-    @POST\n-    @Path (\"/publish\")\n-    @Consumes(MediaType.APPLICATION_OCTET_STREAM)\n+\n+\t/**\n+\t * Method that receives from a server a bundle with the intention of publish it.<br/>\n+\t * When a Bundle file is received on this end point is required to validate if the sending server is an allowed<br/>\n+\t * server on this end point and if the security tokens match. If all the validations are correct the bundle will be add it<br/>\n+\t * to the {@link PublishThread Publish Thread}.\n+\t *\n+\t * @param type\t\t\t  response type\n+\t * @param callback \t\t  response callback\n+\t * @param forcePush \t  true/false to Force the push\n+\t * @param request         {@link HttpServletRequest}\n+\t * @param response        {@link HttpServletResponse}\n+\t * @return Returns a {@link Response} object with a 200 status code if success or a 500 error code if anything fails on the Publish process\n+\t * @see PublishThread\n+\t */\n+\t@POST\n+\t@Path(\"/publish\")\n+\t@Consumes(MediaType.APPLICATION_OCTET_STREAM)\n+\t@Produces(MediaType.APPLICATION_JSON)\n \tpublic Response publish(\n-\t\t\t@QueryParam(\"FILE_NAME\") String fileName,\n-\t\t\t@QueryParam(\"AUTH_TOKEN\") String auth_token_digest,\n-\t\t\t@QueryParam(\"GROUP_ID\") String groupId,\n-\t\t\t@QueryParam(\"ENDPOINT_ID\") String endpointId,\n-\t\t\t@QueryParam(\"type\") String type,\n-\t\t\t@QueryParam(\"callback\") String callback,\n-\t\t\t@QueryParam(\"BUNDLE_NAME\") String bundleName,\n-\t\t\t@QueryParam(\"FORCE_PUSH\") final boolean forcePush,\n-\t\t\t@Context HttpServletRequest req\n-\t) {\n-    \ttry {\n-    \t\ttry (InputStream bundleStream = req.getInputStream()) {\n-\t\t        //Creating an utility response object\n-\t\t        Map<String, String> paramsMap = new HashMap<String, String>();\n-\t\t        paramsMap.put( \"type\", type );\n-\t\t        paramsMap.put( \"callback\", callback );\n-\t\t        ResourceResponse responseResource = new ResourceResponse( paramsMap );\n-\n-\t\t\t\tString remoteIP = \"\";\n-\t\t\t\ttry {\n-\n-\t\t\t\t\tremoteIP = req.getRemoteHost();\n-\t\t\t\t\tif(!UtilMethods.isSet(remoteIP))\n-\t\t\t\t\t\tremoteIP = req.getRemoteAddr();\n-\n-\t\t\t\t\tHibernateUtil.startTransaction();\n-\n-\t\t\t\t\tPublishingEndPoint mySelf = endpointAPI.findEnabledSendingEndPointByAddress(remoteIP);\n-\n-\t\t\t\t\tif(mySelf==null || !isValidToken(auth_token_digest, remoteIP, mySelf)) {\n-\t\t\t\t\t\tbundleStream.close();\n-\t\t\t\t\t\tLogger.error(this.getClass(), \"Push Publishing failed from \" + remoteIP + \" invalid endpoint or token\");\n-\t\t\t\t\t\t\n-\t\t        return responseResource.responseError( HttpStatus.SC_UNAUTHORIZED );\n-\t\t       }\n-\n-\t\t\t\t\tString bundlePath = ConfigUtils.getBundlePath()+File.separator+MY_TEMP;\n-\t\t\t\t\tString bundleFolder = fileName.substring(0, fileName.indexOf(\".tar.gz\"));\n-\n-\t\t            PublishAuditStatus status = PublishAuditAPI.getInstance().updateAuditTable( mySelf.getId(), mySelf.getId(), bundleFolder, true );\n-\n-\t\t            if(bundleName.trim().length()>0) {\n-\t\t\t\t\t    // save bundle if it doesn't exists\n-\t\t                Bundle foundBundle = APILocator.getBundleAPI().getBundleById( bundleFolder );\n-\t\t                if ( foundBundle == null || foundBundle.getId() == null ) {\n-\t\t                    Bundle bundle = new Bundle();\n-\t\t\t\t\t\t\tbundle.setId(bundleFolder);\n-\t\t\t\t\t\t\tbundle.setName(bundleName);\n-\t\t\t\t\t\t\tbundle.setPublishDate(Calendar.getInstance().getTime());\n-\t\t\t\t\t\t\tbundle.setOwner(APILocator.getUserAPI().getSystemUser().getUserId());\n-\t\t\t\t\t\t\tbundle.setForcePush(forcePush);\n-\t\t                    APILocator.getBundleAPI().saveBundle(bundle);\n-\t\t\t\t\t    }\n-\t\t\t\t\t}\n-\n-\t\t\t\t\t//Write file on FS\n-\t\t\t\t\tFileUtil.writeToFile(bundleStream, bundlePath+fileName);\n-\n-\t\t\t\t\t//Start thread\n-\t\t\t\t\tif(!status.getStatus().equals(Status.PUBLISHING_BUNDLE)) {\n-\t\t\t\t\t\tnew Thread(new PublishThread(fileName, groupId, endpointId, status)).start();\n-\t\t\t\t\t}\n-\n-\t\t\t\t\tHibernateUtil.commitTransaction();\n-\n-\t\t\t\t\treturn Response.status(HttpStatus.SC_OK).build();\n-\t\t\t\t} catch (NumberFormatException e) {\n-\t\t\t\t    try {\n-\t\t                HibernateUtil.rollbackTransaction();\n-\t\t            } catch (DotHibernateException e1) {\n-\t\t                Logger.error(this, \"error rollback\",e1);\n-\t\t            }\n-\t\t\t\t\tLogger.error(PublisherQueueJob.class,e.getMessage(),e);\n-\t\t\t\t} catch (Exception e) {\n-\t\t\t\t    try {\n-\t\t                HibernateUtil.rollbackTransaction();\n-\t\t            } catch (DotHibernateException e1) {\n-\t\t                Logger.error(this, \"error rollback\",e1);\n-\t\t            }\n-\t\t\t\t\tLogger.error(PublisherQueueJob.class, \"Error caused by remote call of: \"+remoteIP);\n-\t\t\t\t\tLogger.error(PublisherQueueJob.class,e.getMessage(),e);\n-\t\t\t\t}\n-\t\t\t\tfinally {\n-\t\t\t\t    try {\n-\t\t                HibernateUtil.closeSession();\n-\t\t            } catch (DotHibernateException e) {\n-\t\t                Logger.error(this, \"error close session\",e);\n-\t\t            }\n-\t\t\t\t}\n-    \t\t}\n-    \t} catch (IOException e) {\n-    \t\tLogger.error(PublisherQueueJob.class,e.getMessage(),e);\n-    \t}\n-\n-\t\treturn Response.status(HttpStatus.SC_INTERNAL_SERVER_ERROR).build();\n+\t\t\t@QueryParam(\"type\")        final String type,\n+\t\t\t@QueryParam(\"callback\")    final String callback,\n+\t\t\t@QueryParam(\"FORCE_PUSH\")  final boolean forcePush,\n+\t\t\t@Context final HttpServletRequest  request,\n+\t\t\t@Context final HttpServletResponse response\n+\t) throws Exception {", "originalCommit": "31011524a73fdfdaf924361ea51973388817610c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI5NjgxOA==", "url": "https://github.com/dotCMS/core/pull/19273#discussion_r495296818", "bodyText": "Codacy found an issue: Avoid unused imports such as 'javax.ws.rs'", "author": "dev-dotcms", "createdAt": "2020-09-25T22:52:47Z", "path": "dotCMS/src/main/java/com/dotcms/rest/IntegrityResource.java", "diffHunk": "@@ -38,28 +39,20 @@\n import javax.servlet.http.HttpServletRequest;\n import javax.servlet.http.HttpServletResponse;\n import javax.servlet.http.HttpSession;\n-import javax.ws.rs.Consumes;\n-import javax.ws.rs.GET;\n-import javax.ws.rs.POST;\n-import javax.ws.rs.Path;\n-import javax.ws.rs.PathParam;\n-import javax.ws.rs.Produces;\n-import javax.ws.rs.WebApplicationException;\n-import javax.ws.rs.client.Client;\n+import javax.ws.rs.*;", "originalCommit": "31011524a73fdfdaf924361ea51973388817610c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI5NjgzMQ==", "url": "https://github.com/dotCMS/core/pull/19273#discussion_r495296831", "bodyText": "Codacy found an issue: All methods are static.  Consider using a utility class instead. Alternatively, you could add a private constructor or make the class abstract to silence this warning.", "author": "dev-dotcms", "createdAt": "2020-09-25T22:52:48Z", "path": "dotCMS/src/main/java/com/dotcms/rest/PushPublishResourceUtil.java", "diffHunk": "@@ -0,0 +1,88 @@\n+package com.dotcms.rest;\n+\n+import com.dotcms.publisher.pusher.AuthCredentialPushPublishUtil;\n+import com.dotcms.repackage.org.apache.http.HttpStatus;\n+import com.dotcms.util.CollectionsUtils;\n+import com.dotcms.util.HttpRequestDataUtil;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.UtilMethods;\n+import com.liferay.portal.model.User;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.Response;\n+import java.util.Optional;\n+\n+/**\n+ * Provide util method for {@link IntegrityResource} and {@link BundleResource} classes\n+ */\n+public class PushPublishResourceUtil {", "originalCommit": "31011524a73fdfdaf924361ea51973388817610c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI5Njg0Mg==", "url": "https://github.com/dotCMS/core/pull/19273#discussion_r495296842", "bodyText": "Codacy found an issue: Avoid unused imports such as 'java.util.Map'", "author": "dev-dotcms", "createdAt": "2020-09-25T22:52:49Z", "path": "dotCMS/src/integration-test/java/com/dotmarketing/startup/runonce/Task05390RemoveEndpointIdForeignKeyInIntegrityResolverTablesIntegrationTest.java", "diffHunk": "@@ -0,0 +1,208 @@\n+package com.dotmarketing.startup.runonce;\n+\n+import com.dotcms.util.IntegrationTestInitService;\n+import com.dotmarketing.common.db.DotConnect;\n+import com.dotmarketing.common.db.DotDatabaseMetaData;\n+import com.dotmarketing.db.DbConnectionFactory;\n+import com.dotmarketing.exception.DotDataException;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.sql.Connection;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.List;\n+import java.util.Map;", "originalCommit": "31011524a73fdfdaf924361ea51973388817610c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "435f564352e235d79f5a5fa753c32833bea9c80d", "url": "https://github.com/dotCMS/core/commit/435f564352e235d79f5a5fa753c32833bea9c80d", "message": "#16796 adding fixes and comments to support the jwt on pp", "committedDate": "2020-03-09T15:30:37Z", "type": "commit"}, {"oid": "53df03a0798348247b767f3b45da91c6ed66acea", "url": "https://github.com/dotCMS/core/commit/53df03a0798348247b767f3b45da91c6ed66acea", "message": "#16796 merge", "committedDate": "2020-06-09T19:19:17Z", "type": "commit"}, {"oid": "9b153c6a13d23f435d33b573b03053a5e5605afd", "url": "https://github.com/dotCMS/core/commit/9b153c6a13d23f435d33b573b03053a5e5605afd", "message": "#16796 Fixing error when some parameters not come in the request", "committedDate": "2020-06-12T17:14:11Z", "type": "commit"}, {"oid": "48e47307b1f9ddd707129e1997e7b487ce6539df", "url": "https://github.com/dotCMS/core/commit/48e47307b1f9ddd707129e1997e7b487ce6539df", "message": "#16796 Testing", "committedDate": "2020-06-15T15:24:07Z", "type": "commit"}, {"oid": "d06b4af1f1a182020a2e8f609075197dec983b78", "url": "https://github.com/dotCMS/core/commit/d06b4af1f1a182020a2e8f609075197dec983b78", "message": "#16796 refactoring/testing", "committedDate": "2020-06-15T16:23:03Z", "type": "commit"}, {"oid": "1d1727a7af57fc681541d9aa72fbddcbc4357de3", "url": "https://github.com/dotCMS/core/commit/1d1727a7af57fc681541d9aa72fbddcbc4357de3", "message": "#16796 testing", "committedDate": "2020-06-15T17:16:36Z", "type": "commit"}, {"oid": "1aa6ff79d0ee2e5d6131b4a519f93d43a955a497", "url": "https://github.com/dotCMS/core/commit/1aa6ff79d0ee2e5d6131b4a519f93d43a955a497", "message": "#16796 refactorign", "committedDate": "2020-06-16T19:50:46Z", "type": "commit"}, {"oid": "338fb56a9e05348444336cf781d6ad1a9bff14fa", "url": "https://github.com/dotCMS/core/commit/338fb56a9e05348444336cf781d6ad1a9bff14fa", "message": "#16796 Refactoring", "committedDate": "2020-06-16T19:56:49Z", "type": "commit"}, {"oid": "04ed1411c8303c584b14070c03ccf47b61c816b9", "url": "https://github.com/dotCMS/core/commit/04ed1411c8303c584b14070c03ccf47b61c816b9", "message": "Revert \"#16796 refactoring/testing\"\n\nThis reverts commit d06b4af1f1a182020a2e8f609075197dec983b78.", "committedDate": "2020-06-16T21:06:49Z", "type": "commit"}, {"oid": "1b4ae1be7fbd781a883b0bd67106527461881c24", "url": "https://github.com/dotCMS/core/commit/1b4ae1be7fbd781a883b0bd67106527461881c24", "message": "refactoring", "committedDate": "2020-06-16T21:27:07Z", "type": "commit"}, {"oid": "80f78a9461e29a8df741584afb11b0eaaaba0b84", "url": "https://github.com/dotCMS/core/commit/80f78a9461e29a8df741584afb11b0eaaaba0b84", "message": "#16796 Fixing Test", "committedDate": "2020-06-17T16:06:48Z", "type": "commit"}, {"oid": "029e9b312f8214dfefc90f0766b7b6397e3e97f6", "url": "https://github.com/dotCMS/core/commit/029e9b312f8214dfefc90f0766b7b6397e3e97f6", "message": "#16796 Fixing PP error", "committedDate": "2020-06-18T23:02:42Z", "type": "commit"}, {"oid": "f1d5ddfade631df1bb10b9d5c7e499e042cd3bf3", "url": "https://github.com/dotCMS/core/commit/f1d5ddfade631df1bb10b9d5c7e499e042cd3bf3", "message": "#16796 Sending JWT token in PP request", "committedDate": "2020-06-29T16:00:29Z", "type": "commit"}, {"oid": "6fc5875051dc03a6cb68e58af50da75aab046df5", "url": "https://github.com/dotCMS/core/commit/6fc5875051dc03a6cb68e58af50da75aab046df5", "message": "Merge remote-tracking branch 'origin/master' into issue-16796-jwt-pp-auth_2", "committedDate": "2020-06-29T16:41:23Z", "type": "commit"}, {"oid": "8ddfa854465edbfef702244f8037a8bb7e76e377", "url": "https://github.com/dotCMS/core/commit/8ddfa854465edbfef702244f8037a8bb7e76e377", "message": "#16796 Removing receiver configuration from jsp", "committedDate": "2020-06-29T16:42:16Z", "type": "commit"}, {"oid": "c57992eed03da13b667a38ed2112b9caea43f49e", "url": "https://github.com/dotCMS/core/commit/c57992eed03da13b667a38ed2112b9caea43f49e", "message": "#18690 Using JWT token in integrity checker", "committedDate": "2020-06-30T22:53:02Z", "type": "commit"}, {"oid": "29228904a24f40875bd66bd3d0e10ab4b5f78683", "url": "https://github.com/dotCMS/core/commit/29228904a24f40875bd66bd3d0e10ab4b5f78683", "message": "merge", "committedDate": "2020-08-26T21:38:42Z", "type": "commit"}, {"oid": "689c942357814259e44ad796f9146a2e1c5571e6", "url": "https://github.com/dotCMS/core/commit/689c942357814259e44ad796f9146a2e1c5571e6", "message": "#16796 Show invalid token message when IC fails with a invalid token", "committedDate": "2020-08-31T09:45:43Z", "type": "commit"}, {"oid": "4b5791ce3b3c8bd3ec67e1c83c2f7a4cd2c4f0f6", "url": "https://github.com/dotCMS/core/commit/4b5791ce3b3c8bd3ec67e1c83c2f7a4cd2c4f0f6", "message": "#16796 Removing end poitn id from fix conflicts end point", "committedDate": "2020-09-01T07:13:53Z", "type": "commit"}, {"oid": "676a7d00c17c8647a5252788b671f925d1d1a424", "url": "https://github.com/dotCMS/core/commit/676a7d00c17c8647a5252788b671f925d1d1a424", "message": "#16796 Adding Task Upgrade", "committedDate": "2020-09-01T07:22:51Z", "type": "commit"}, {"oid": "5cfcc6752d2c0ac38286e2e5a30f90114b730ebf", "url": "https://github.com/dotCMS/core/commit/5cfcc6752d2c0ac38286e2e5a30f90114b730ebf", "message": "#16796 Not show token when it is invalid or expired", "committedDate": "2020-09-01T08:10:03Z", "type": "commit"}, {"oid": "ccc5b3346a899306ccff38e597582696792729e6", "url": "https://github.com/dotCMS/core/commit/ccc5b3346a899306ccff38e597582696792729e6", "message": "merge", "committedDate": "2020-09-01T08:48:19Z", "type": "commit"}, {"oid": "3f04c74c8d4717742ebc5aa2b3cfb3d571af28bd", "url": "https://github.com/dotCMS/core/commit/3f04c74c8d4717742ebc5aa2b3cfb3d571af28bd", "message": "#16796 Allow switch between old way token and JWT token in Push Publish", "committedDate": "2020-09-08T18:41:30Z", "type": "commit"}, {"oid": "1ee66ac51b223c3d178d5fbc39e9745595b17332", "url": "https://github.com/dotCMS/core/commit/1ee66ac51b223c3d178d5fbc39e9745595b17332", "message": "#16796 Allow switch between old way token and JWT token in Push Publish", "committedDate": "2020-09-08T18:47:16Z", "type": "commit"}, {"oid": "0c0cdfc99e4cc2a1b709cdd35552bdc65166a999", "url": "https://github.com/dotCMS/core/commit/0c0cdfc99e4cc2a1b709cdd35552bdc65166a999", "message": "#16796 Postman Testing", "committedDate": "2020-09-08T18:48:58Z", "type": "commit"}, {"oid": "1a112867f54f5dbc6337cab8c2842f34879a37a3", "url": "https://github.com/dotCMS/core/commit/1a112867f54f5dbc6337cab8c2842f34879a37a3", "message": "#16796 Postman Testing", "committedDate": "2020-09-08T22:10:17Z", "type": "commit"}, {"oid": "1a49e318ccd7327a812edf1719fe5ae275d398d5", "url": "https://github.com/dotCMS/core/commit/1a49e318ccd7327a812edf1719fe5ae275d398d5", "message": "#16796 Testing", "committedDate": "2020-09-11T16:25:39Z", "type": "commit"}, {"oid": "5a605e4205b72be074a5fc9ec2c81ba0fb462e9f", "url": "https://github.com/dotCMS/core/commit/5a605e4205b72be074a5fc9ec2c81ba0fb462e9f", "message": "#16796", "committedDate": "2020-09-16T14:52:28Z", "type": "commit"}, {"oid": "5b529f8c3752271f8bb6593318c293192f31bc3f", "url": "https://github.com/dotCMS/core/commit/5b529f8c3752271f8bb6593318c293192f31bc3f", "message": "#16796 testing", "committedDate": "2020-09-16T15:31:05Z", "type": "commit"}, {"oid": "6e2780c28020e28c428ad9c2423db76fb4291a74", "url": "https://github.com/dotCMS/core/commit/6e2780c28020e28c428ad9c2423db76fb4291a74", "message": "#16796 merge", "committedDate": "2020-09-16T15:35:28Z", "type": "commit"}, {"oid": "b1c4fc2d53bf95de8486282900ea550394f81b48", "url": "https://github.com/dotCMS/core/commit/b1c4fc2d53bf95de8486282900ea550394f81b48", "message": "#16796 undo change", "committedDate": "2020-09-16T15:39:34Z", "type": "commit"}, {"oid": "ca3b0a72c5efb2ca1487254d363ca943853a4b10", "url": "https://github.com/dotCMS/core/commit/ca3b0a72c5efb2ca1487254d363ca943853a4b10", "message": "Revert \"#16796 undo change\"\n\nThis reverts commit b1c4fc2d53bf95de8486282900ea550394f81b48.", "committedDate": "2020-09-16T15:40:31Z", "type": "commit"}, {"oid": "b5f4088129d1795b6aedb3fd4e4a56c20d3d004f", "url": "https://github.com/dotCMS/core/commit/b5f4088129d1795b6aedb3fd4e4a56c20d3d004f", "message": "#16796 undo change", "committedDate": "2020-09-16T15:42:56Z", "type": "commit"}, {"oid": "a3c31aac145d8ea19c2116bb25d730bb36aebba5", "url": "https://github.com/dotCMS/core/commit/a3c31aac145d8ea19c2116bb25d730bb36aebba5", "message": "#16796 undo change", "committedDate": "2020-09-16T15:58:48Z", "type": "commit"}, {"oid": "2a76fc73d2c4f4c057a950c12d97977d1d5fb5fb", "url": "https://github.com/dotCMS/core/commit/2a76fc73d2c4f4c057a950c12d97977d1d5fb5fb", "message": "#16796 undo change", "committedDate": "2020-09-16T16:03:46Z", "type": "commit"}, {"oid": "9b59f9f38c9b9a0c4b50e8f09b81ce9f1d298fe8", "url": "https://github.com/dotCMS/core/commit/9b59f9f38c9b9a0c4b50e8f09b81ce9f1d298fe8", "message": "#16796 undo change", "committedDate": "2020-09-16T16:06:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTU3MjAxOA==", "url": "https://github.com/dotCMS/core/pull/19273#discussion_r489572018", "bodyText": "In all these cases, I think we should use the JWT fingerprint as the key for the fixes, not the remote IP - or we should use the clusterId of the two environments.  The remoteIp can be changeable and does not really represent a dotCMS installation.", "author": "wezell", "createdAt": "2020-09-16T16:33:49Z", "path": "dotCMS/src/main/java/com/dotcms/integritycheckers/ContentFileAssetIntegrityChecker.java", "diffHunk": "@@ -72,7 +72,7 @@ public boolean generateIntegrityResults(final String endpointId) throws Exceptio\n     }\n \n     @Override\n-    public void executeFix(final String endpointId) throws DotDataException, DotSecurityException {\n+    public void executeFix(final String remoteIP) throws DotDataException, DotSecurityException {", "originalCommit": "9b59f9f38c9b9a0c4b50e8f09b81ce9f1d298fe8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTU3NjcwMw==", "url": "https://github.com/dotCMS/core/pull/19273#discussion_r489576703", "bodyText": "Doc", "author": "jdotcms", "createdAt": "2020-09-16T16:41:32Z", "path": "dotCMS/src/main/java/com/dotcms/publisher/business/PublishAuditStatus.java", "diffHunk": "@@ -12,45 +12,47 @@\n  */\n public class PublishAuditStatus implements Serializable {", "originalCommit": "9b59f9f38c9b9a0c4b50e8f09b81ce9f1d298fe8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTU3NjczMw==", "url": "https://github.com/dotCMS/core/pull/19273#discussion_r489576733", "bodyText": "Doc", "author": "jdotcms", "createdAt": "2020-09-16T16:41:37Z", "path": "dotCMS/src/main/java/com/dotcms/publisher/business/PublishAuditStatus.java", "diffHunk": "@@ -12,45 +12,47 @@\n  */\n public class PublishAuditStatus implements Serializable {\n \tprivate static final long serialVersionUID = 1L;\n-\t\n+\n \tpublic static enum Status {", "originalCommit": "9b59f9f38c9b9a0c4b50e8f09b81ce9f1d298fe8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTU4MzkyNg==", "url": "https://github.com/dotCMS/core/pull/19273#discussion_r489583926", "bodyText": "set finals and rename p to publisher", "author": "jdotcms", "createdAt": "2020-09-16T16:53:55Z", "path": "dotCMS/src/main/java/com/dotcms/publisher/business/PublisherQueueJob.java", "diffHunk": "@@ -548,48 +554,48 @@ private PublishAuditHistory getRemoteHistoryFromEndpoint(final  PublishAuditStat\n \t *            - The Id of the generated bundle.\n \t * @return The {@link Publisher} classes for the specified bundle.\n \t */\n-    private Set<Class<?>> getPublishersForBundle(String bundleId){\n+\tprivate Set<Class<?>> getPublishersForBundle(String bundleId){\n \n-        Set<Class<?>> publishersClasses = new HashSet<>();\n+\t\tSet<Class<?>> publishersClasses = new HashSet<>();\n \n-\t    try{\n-            Map<String, Class<? extends IPublisher>> protocolPublisherMap = Maps.newConcurrentMap();\n-            //TODO: for OSGI we need to get this list from implementations of IPublisher or something else.\n-            final Set<Class<?>> publishers = Sets.newHashSet(\n-                    PushPublisher.class,\n-                    AWSS3Publisher.class,\n+\t\ttry{\n+\t\t\tMap<String, Class<? extends IPublisher>> protocolPublisherMap = Maps.newConcurrentMap();\n+\t\t\t//TODO: for OSGI we need to get this list from implementations of IPublisher or something else.\n+\t\t\tfinal Set<Class<?>> publishers = Sets.newHashSet(\n+\t\t\t\t\tPushPublisher.class,\n+\t\t\t\t\tAWSS3Publisher.class,\n \t\t\t\t\tStaticPublisher.class);\n \n-            //Fill protocolPublisherMap with protocol -> publisher.\n-            for (Class publisher : publishers) {\n-                Publisher p = (Publisher)publisher.newInstance();\n-                for (String protocol : p.getProtocols()) {\n-                    protocolPublisherMap.put(protocol, publisher);\n-                }\n-            }\n-\n-            //For each environment in the bundle we need to get the end-points.\n-            List<Environment> environments = this.environmentAPI.findEnvironmentsByBundleId(bundleId);\n-\n-            for (Environment environment : environments) {\n-                //For each end-point we choose if run static or dynamic process (Static = AWSS3Publisher, Dynamic = PushPublisher)\n-                List<PublishingEndPoint> endpoints = this.publisherEndPointAPI.findSendingEndPointsByEnvironment(environment.getId());\n-\n-                //For each end-point we need include the Publisher depending on the type.\n-                for (PublishingEndPoint endpoint : endpoints) {\n-                    //Only if the end-point is enabled.\n-                    if (endpoint.isEnabled() && protocolPublisherMap.containsKey(endpoint.getProtocol())){\n-                        publishersClasses.add(protocolPublisherMap.get(endpoint.getProtocol()));\n-\n-                    }\n-                }\n-            }\n-        } catch (Exception e){\n-\t        Logger.error(this, \"Error trying to get publishers from bundle id: \" + bundleId, e);\n-        }\n-\n-\t    return publishersClasses;\n-    }\n+\t\t\t//Fill protocolPublisherMap with protocol -> publisher.\n+\t\t\tfor (Class publisher : publishers) {", "originalCommit": "9b59f9f38c9b9a0c4b50e8f09b81ce9f1d298fe8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTU4NjMwNQ==", "url": "https://github.com/dotCMS/core/pull/19273#discussion_r489586305", "bodyText": "any toString is creating a new String everything it is being used, it would be better to save it into a value to avoid new creations", "author": "jdotcms", "createdAt": "2020-09-16T16:57:50Z", "path": "dotCMS/src/main/java/com/dotcms/publisher/endpoint/bean/PublishingEndPoint.java", "diffHunk": "@@ -145,4 +153,36 @@ public StringBuilder toURL() {\n      * translated in upper layer.\n      */\n     public abstract void validatePublishingEndPoint() throws PublishingEndPointValidationException;\n+\n+    public boolean hasAuthKey() {\n+        final StringBuilder authKey = getAuthKey();\n+\n+        if (UtilMethods.isEmpty(authKey.toString())) {\n+            return false;\n+        }\n+\n+        return !isTokenExpired() && !isTokenInvalid();\n+    }\n+\n+    public boolean isTokenExpired() {\n+        final StringBuilder authKey = getAuthKey();\n+\n+        if (UtilMethods.isEmpty(authKey.toString())) {", "originalCommit": "9b59f9f38c9b9a0c4b50e8f09b81ce9f1d298fe8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTU4NjUyMA==", "url": "https://github.com/dotCMS/core/pull/19273#discussion_r489586520", "bodyText": "doc", "author": "jdotcms", "createdAt": "2020-09-16T16:58:14Z", "path": "dotCMS/src/main/java/com/dotcms/publisher/pusher/AuthCredentialPushPublishUtil.java", "diffHunk": "@@ -0,0 +1,107 @@\n+package com.dotcms.publisher.pusher;\n+\n+import com.dotcms.auth.providers.jwt.JsonWebTokenAuthCredentialProcessor;\n+import com.dotcms.auth.providers.jwt.services.JsonWebTokenAuthCredentialProcessorImpl;\n+import com.dotcms.publisher.endpoint.bean.PublishingEndPoint;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.portlets.rules.parameter.display.DropdownInput;\n+import com.dotmarketing.util.Config;\n+import com.liferay.portal.model.User;\n+import io.jsonwebtoken.Claims;\n+import io.jsonwebtoken.IncorrectClaimException;\n+import org.apache.commons.lang.StringUtils;\n+import org.glassfish.jersey.server.ContainerRequest;\n+import org.jetbrains.annotations.NotNull;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Optional;\n+\n+public enum AuthCredentialPushPublishUtil {", "originalCommit": "9b59f9f38c9b9a0c4b50e8f09b81ce9f1d298fe8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTU5NTExNA==", "url": "https://github.com/dotCMS/core/pull/19273#discussion_r489595114", "bodyText": "user has a method isAdmin if want to use short way", "author": "jdotcms", "createdAt": "2020-09-16T17:13:03Z", "path": "dotCMS/src/main/java/com/dotcms/publisher/pusher/AuthCredentialPushPublishUtil.java", "diffHunk": "@@ -0,0 +1,107 @@\n+package com.dotcms.publisher.pusher;\n+\n+import com.dotcms.auth.providers.jwt.JsonWebTokenAuthCredentialProcessor;\n+import com.dotcms.auth.providers.jwt.services.JsonWebTokenAuthCredentialProcessorImpl;\n+import com.dotcms.publisher.endpoint.bean.PublishingEndPoint;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.portlets.rules.parameter.display.DropdownInput;\n+import com.dotmarketing.util.Config;\n+import com.liferay.portal.model.User;\n+import io.jsonwebtoken.Claims;\n+import io.jsonwebtoken.IncorrectClaimException;\n+import org.apache.commons.lang.StringUtils;\n+import org.glassfish.jersey.server.ContainerRequest;\n+import org.jetbrains.annotations.NotNull;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Optional;\n+\n+public enum AuthCredentialPushPublishUtil {\n+    INSTANCE;\n+\n+    private final String BEARER = \"Bearer \";\n+\n+    public static String EXPIRED_TOKEN_ERROR_KEY = \"__expired_token__\";\n+    public static String INVALID_TOKEN_ERROR_KEY = \"__invalid_token__\";\n+\n+    public Optional<String> getRequestToken(final PublishingEndPoint endpoint)  {\n+        try {\n+            final boolean useJWTToken = isJWTAvailable();\n+            final Optional<String> tokenOptional = useJWTToken ?\n+                    getJWTToken(endpoint) :\n+                    PushPublisher.retriveEndpointKeyDigest(endpoint);\n+\n+            if (!tokenOptional.isPresent()) {\n+                return tokenOptional;\n+            }\n+\n+            final String token = tokenOptional.get();\n+\n+            return Optional.of(JsonWebTokenAuthCredentialProcessor.BEARER + token);\n+        } catch (IOException e) {\n+            throw new DotRuntimeException(e);\n+        }\n+    }\n+\n+    public static boolean isJWTAvailable() {\n+        return Config.getBooleanProperty(\"USE_JWT_TOKEN_IN_PUSH_PUBLISH\", true);\n+    }\n+\n+    public boolean processAuthHeader(final HttpServletRequest request) throws DotSecurityException{\n+        final boolean useJWTToken = isJWTAvailable();\n+\n+        try {\n+            if (useJWTToken) {\n+                final User user = JsonWebTokenAuthCredentialProcessorImpl.getInstance().processAuthHeaderFromJWT(request);\n+\n+                if (!APILocator.getUserAPI().isCMSAdmin(user)){", "originalCommit": "9b59f9f38c9b9a0c4b50e8f09b81ce9f1d298fe8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTU5NTU4MA==", "url": "https://github.com/dotCMS/core/pull/19273#discussion_r489595580", "bodyText": "Log this \"\"Operation jus allow o admin user\"\" and return false, shouldn't use exception to handle this kind of flow", "author": "jdotcms", "createdAt": "2020-09-16T17:13:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTU5NTExNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTU5NTg0MA==", "url": "https://github.com/dotCMS/core/pull/19273#discussion_r489595840", "bodyText": "remove this", "author": "jdotcms", "createdAt": "2020-09-16T17:14:20Z", "path": "dotCMS/src/main/java/com/dotcms/publisher/pusher/AuthCredentialPushPublishUtil.java", "diffHunk": "@@ -0,0 +1,107 @@\n+package com.dotcms.publisher.pusher;\n+\n+import com.dotcms.auth.providers.jwt.JsonWebTokenAuthCredentialProcessor;\n+import com.dotcms.auth.providers.jwt.services.JsonWebTokenAuthCredentialProcessorImpl;\n+import com.dotcms.publisher.endpoint.bean.PublishingEndPoint;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.portlets.rules.parameter.display.DropdownInput;\n+import com.dotmarketing.util.Config;\n+import com.liferay.portal.model.User;\n+import io.jsonwebtoken.Claims;\n+import io.jsonwebtoken.IncorrectClaimException;\n+import org.apache.commons.lang.StringUtils;\n+import org.glassfish.jersey.server.ContainerRequest;\n+import org.jetbrains.annotations.NotNull;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Optional;\n+\n+public enum AuthCredentialPushPublishUtil {\n+    INSTANCE;\n+\n+    private final String BEARER = \"Bearer \";\n+\n+    public static String EXPIRED_TOKEN_ERROR_KEY = \"__expired_token__\";\n+    public static String INVALID_TOKEN_ERROR_KEY = \"__invalid_token__\";\n+\n+    public Optional<String> getRequestToken(final PublishingEndPoint endpoint)  {\n+        try {\n+            final boolean useJWTToken = isJWTAvailable();\n+            final Optional<String> tokenOptional = useJWTToken ?\n+                    getJWTToken(endpoint) :\n+                    PushPublisher.retriveEndpointKeyDigest(endpoint);\n+\n+            if (!tokenOptional.isPresent()) {\n+                return tokenOptional;\n+            }\n+\n+            final String token = tokenOptional.get();\n+\n+            return Optional.of(JsonWebTokenAuthCredentialProcessor.BEARER + token);\n+        } catch (IOException e) {\n+            throw new DotRuntimeException(e);\n+        }\n+    }\n+\n+    public static boolean isJWTAvailable() {\n+        return Config.getBooleanProperty(\"USE_JWT_TOKEN_IN_PUSH_PUBLISH\", true);\n+    }\n+\n+    public boolean processAuthHeader(final HttpServletRequest request) throws DotSecurityException{\n+        final boolean useJWTToken = isJWTAvailable();\n+\n+        try {\n+            if (useJWTToken) {\n+                final User user = JsonWebTokenAuthCredentialProcessorImpl.getInstance().processAuthHeaderFromJWT(request);\n+\n+                if (!APILocator.getUserAPI().isCMSAdmin(user)){\n+                    throw new DotSecurityException(\"Operation jus allow o admin user\");\n+                }\n+\n+                return true;\n+            } else {\n+                return isValidDotCMSToken(request);\n+            }\n+        }catch (DotDataException | IOException | DotSecurityException exception) {\n+            return false;\n+        }\n+    }\n+\n+    private boolean isValidDotCMSToken(final HttpServletRequest request) throws DotDataException, IOException {\n+        final String remoteIP = request.getRemoteHost();\n+        final PublishingEndPoint publishingEndPoint =\n+                APILocator.getPublisherEndPointAPI().findEnabledSendingEndPointByAddress(remoteIP);\n+\n+        Optional<String> key = PushPublisher.retriveEndpointKeyDigest(publishingEndPoint);\n+        if(!key.isPresent()) {\n+            return false;\n+        }\n+\n+        final String token = getTokenFromRequest(request);\n+\n+        return token.equals( key.get() );\n+    }\n+\n+    private String getTokenFromRequest(final HttpServletRequest request) {\n+        final String authorizationHeader = request.getHeader(ContainerRequest.AUTHORIZATION);\n+\n+        if (StringUtils.isNotEmpty(authorizationHeader) && authorizationHeader.trim()\n+                .startsWith(BEARER)) {\n+\n+            return authorizationHeader.substring(BEARER.length());\n+        } else {\n+            throw new IllegalArgumentException(\"Bearer Authorization header expected\");\n+        }\n+    }\n+\n+    @NotNull", "originalCommit": "9b59f9f38c9b9a0c4b50e8f09b81ce9f1d298fe8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTU5NjQ0MQ==", "url": "https://github.com/dotCMS/core/pull/19273#discussion_r489596441", "bodyText": "rename to bundle", "author": "jdotcms", "createdAt": "2020-09-16T17:15:16Z", "path": "dotCMS/src/main/java/com/dotcms/publisher/pusher/PushPublisher.java", "diffHunk": "@@ -218,71 +219,77 @@ public PublisherConfig process ( final PublishStatus status ) throws DotPublishi\n \n \t\t\t\t\tInputStream bundleStream = new BufferedInputStream(Files.newInputStream(bundle.toPath()));\n \n-\n-\n-\t        \t\ttry {\n-\t        \t\t\tBundle b=APILocator.getBundleAPI().getBundleById(this.config.getId());\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\tBundle b = APILocator.getBundleAPI().getBundleById(this.config.getId());", "originalCommit": "9b59f9f38c9b9a0c4b50e8f09b81ce9f1d298fe8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTU5Nzc2MA==", "url": "https://github.com/dotCMS/core/pull/19273#discussion_r489597760", "bodyText": "I am wondering if this process should be Admin only @wezell", "author": "jdotcms", "createdAt": "2020-09-16T17:17:40Z", "path": "dotCMS/src/main/java/com/dotcms/rest/BundlePublisherResource.java", "diffHunk": "@@ -37,148 +43,160 @@\n public class BundlePublisherResource {\n \n \tpublic static String MY_TEMP = \"\";\n-\tprivate PublishingEndPointAPI endpointAPI = APILocator.getPublisherEndPointAPI();\n-\n-    /**\n-     * Method that receives from a server a bundle with the intention of publish it.<br/>\n-     * When a Bundle file is received on this end point is required to validate if the sending server is an allowed<br/>\n-     * server on this end point and if the security tokens match. If all the validations are correct the bundle will be add it<br/>\n-     * to the {@link PublishThread Publish Thread}.\n-     *\n-     * @param fileName       File name to be published\n-     * @param auth_token_enc Authentication token\n-     * @param groupId        Group who sent the Bundle\n-     * @param endpointId     End-point who sent the Bundle\n-\t * @param type\t\t\t response type\n-\t * @param callback \t\t response callback\n-\t * @param bundleName\t The name for the Bundle to publish\n-\t * @param forcePush \t true/false to Force the push\n-     * @param req            HttpRequest\n-     * @return Returns a {@link Response} object with a 200 status code if success or a 500 error code if anything fails on the Publish process\n-     * @see PublishThread\n-     */\n-    @POST\n-    @Path (\"/publish\")\n-    @Consumes(MediaType.APPLICATION_OCTET_STREAM)\n+\n+\t/**\n+\t * Method that receives from a server a bundle with the intention of publish it.<br/>\n+\t * When a Bundle file is received on this end point is required to validate if the sending server is an allowed<br/>\n+\t * server on this end point and if the security tokens match. If all the validations are correct the bundle will be add it<br/>\n+\t * to the {@link PublishThread Publish Thread}.\n+\t *\n+\t * @param type\t\t\t  response type\n+\t * @param callback \t\t  response callback\n+\t * @param forcePush \t  true/false to Force the push\n+\t * @param request         {@link HttpServletRequest}\n+\t * @param response        {@link HttpServletResponse}\n+\t * @return Returns a {@link Response} object with a 200 status code if success or a 500 error code if anything fails on the Publish process\n+\t * @see PublishThread\n+\t */\n+\t@POST\n+\t@Path (\"/publish\")\n+\t@Consumes(MediaType.APPLICATION_OCTET_STREAM)\n+\t@Produces(MediaType.APPLICATION_JSON)\n \tpublic Response publish(\n-\t\t\t@QueryParam(\"FILE_NAME\") String fileName,\n-\t\t\t@QueryParam(\"AUTH_TOKEN\") String auth_token_digest,\n-\t\t\t@QueryParam(\"GROUP_ID\") String groupId,\n-\t\t\t@QueryParam(\"ENDPOINT_ID\") String endpointId,\n-\t\t\t@QueryParam(\"type\") String type,\n-\t\t\t@QueryParam(\"callback\") String callback,\n-\t\t\t@QueryParam(\"BUNDLE_NAME\") String bundleName,\n-\t\t\t@QueryParam(\"FORCE_PUSH\") final boolean forcePush,\n-\t\t\t@Context HttpServletRequest req\n-\t) {\n-    \ttry {\n-    \t\ttry (InputStream bundleStream = req.getInputStream()) {\n-\t\t        //Creating an utility response object\n-\t\t        Map<String, String> paramsMap = new HashMap<String, String>();\n-\t\t        paramsMap.put( \"type\", type );\n-\t\t        paramsMap.put( \"callback\", callback );\n-\t\t        ResourceResponse responseResource = new ResourceResponse( paramsMap );\n-\n-\t\t\t\tString remoteIP = \"\";\n-\t\t\t\ttry {\n-\n-\t\t\t\t\tremoteIP = req.getRemoteHost();\n-\t\t\t\t\tif(!UtilMethods.isSet(remoteIP))\n-\t\t\t\t\t\tremoteIP = req.getRemoteAddr();\n-\n-\t\t\t\t\tHibernateUtil.startTransaction();\n-\n-\t\t\t\t\tPublishingEndPoint mySelf = endpointAPI.findEnabledSendingEndPointByAddress(remoteIP);\n-\n-\t\t\t\t\tif(mySelf==null || !isValidToken(auth_token_digest, remoteIP, mySelf)) {\n-\t\t\t\t\t\tbundleStream.close();\n-\t\t\t\t\t\tLogger.error(this.getClass(), \"Push Publishing failed from \" + remoteIP + \" invalid endpoint or token\");\n-\t\t\t\t\t\t\n-\t\t        return responseResource.responseError( HttpStatus.SC_UNAUTHORIZED );\n-\t\t       }\n-\n-\t\t\t\t\tString bundlePath = ConfigUtils.getBundlePath()+File.separator+MY_TEMP;\n-\t\t\t\t\tString bundleFolder = fileName.substring(0, fileName.indexOf(\".tar.gz\"));\n-\n-\t\t            PublishAuditStatus status = PublishAuditAPI.getInstance().updateAuditTable( mySelf.getId(), mySelf.getId(), bundleFolder, true );\n-\n-\t\t            if(bundleName.trim().length()>0) {\n-\t\t\t\t\t    // save bundle if it doesn't exists\n-\t\t                Bundle foundBundle = APILocator.getBundleAPI().getBundleById( bundleFolder );\n-\t\t                if ( foundBundle == null || foundBundle.getId() == null ) {\n-\t\t                    Bundle bundle = new Bundle();\n-\t\t\t\t\t\t\tbundle.setId(bundleFolder);\n-\t\t\t\t\t\t\tbundle.setName(bundleName);\n-\t\t\t\t\t\t\tbundle.setPublishDate(Calendar.getInstance().getTime());\n-\t\t\t\t\t\t\tbundle.setOwner(APILocator.getUserAPI().getSystemUser().getUserId());\n-\t\t\t\t\t\t\tbundle.setForcePush(forcePush);\n-\t\t                    APILocator.getBundleAPI().saveBundle(bundle);\n-\t\t\t\t\t    }\n-\t\t\t\t\t}\n-\n-\t\t\t\t\t//Write file on FS\n-\t\t\t\t\tFileUtil.writeToFile(bundleStream, bundlePath+fileName);\n-\n-\t\t\t\t\t//Start thread\n-\t\t\t\t\tif(!status.getStatus().equals(Status.PUBLISHING_BUNDLE)) {\n-\t\t\t\t\t\tnew Thread(new PublishThread(fileName, groupId, endpointId, status)).start();\n-\t\t\t\t\t}\n-\n-\t\t\t\t\tHibernateUtil.commitTransaction();\n-\n-\t\t\t\t\treturn Response.status(HttpStatus.SC_OK).build();\n-\t\t\t\t} catch (NumberFormatException e) {\n-\t\t\t\t    try {\n-\t\t                HibernateUtil.rollbackTransaction();\n-\t\t            } catch (DotHibernateException e1) {\n-\t\t                Logger.error(this, \"error rollback\",e1);\n-\t\t            }\n-\t\t\t\t\tLogger.error(PublisherQueueJob.class,e.getMessage(),e);\n-\t\t\t\t} catch (Exception e) {\n-\t\t\t\t    try {\n-\t\t                HibernateUtil.rollbackTransaction();\n-\t\t            } catch (DotHibernateException e1) {\n-\t\t                Logger.error(this, \"error rollback\",e1);\n-\t\t            }\n-\t\t\t\t\tLogger.error(PublisherQueueJob.class, \"Error caused by remote call of: \"+remoteIP);\n-\t\t\t\t\tLogger.error(PublisherQueueJob.class,e.getMessage(),e);\n-\t\t\t\t}\n-\t\t\t\tfinally {\n-\t\t\t\t    try {\n-\t\t                HibernateUtil.closeSession();\n-\t\t            } catch (DotHibernateException e) {\n-\t\t                Logger.error(this, \"error close session\",e);\n-\t\t            }\n-\t\t\t\t}\n-    \t\t}\n-    \t} catch (IOException e) {\n-    \t\tLogger.error(PublisherQueueJob.class,e.getMessage(),e);\n-    \t}\n-\n-\t\treturn Response.status(HttpStatus.SC_INTERNAL_SERVER_ERROR).build();\n+\t\t\t@QueryParam(\"type\")        final String type,\n+\t\t\t@QueryParam(\"callback\")    final String callback,\n+\t\t\t@QueryParam(\"FORCE_PUSH\")  final boolean forcePush,\n+\t\t\t@Context final HttpServletRequest  request,\n+\t\t\t@Context final HttpServletResponse response\n+\t) throws Exception {\n+\t\tfinal ResourceResponse responseResource = new ResourceResponse(\n+\t\t\t\tCollectionsUtils.map(\"type\", type, \"callback\", callback));\n+\t\tfinal String remoteIP = UtilMethods.isSet(request.getRemoteHost())?\n+\t\t\t\trequest.getRemoteHost() : request.getRemoteAddr();\n+\n+\n+\t\tif (request.getInputStream().isFinished()) {\n+\t\t\tLogger.error(this.getClass(), \"Push Publishing failed from \" + remoteIP + \" bundle expected\");\n+\t\t\treturn responseResource.responseError(HttpStatus.SC_BAD_REQUEST);\n+\t\t}\n+\n+\t\ttry {\n+\t\t\tfinal boolean isTokenValid = AuthCredentialPushPublishUtil.INSTANCE.processAuthHeader(request);\n+\n+\t\t\tif (!isTokenValid) {\n+\t\t\t\tLogger.error(this.getClass(), \"Invalid token from \" + remoteIP + \" not permission\");\n+\t\t\t\treturn responseResource.responseAuthenticateError(\"invalid_token\",\n+\t\t\t\t\t\tAuthCredentialPushPublishUtil.INVALID_TOKEN_ERROR_KEY);\n+\t\t\t}\n+\n+\t\t\tfinal Bundle bundle = this.publishBundle(forcePush, request, remoteIP);\n+\n+\t\t\treturn Response.ok(bundle).build();\n+\t\t} catch (DotSecurityException e) {\n+\t\t\tLogger.error(this.getClass(), \"Not Admin user \" + remoteIP + \" not permission\");\n+\t\t\treturn responseResource.responseUnauthorizedError(\"admin_scope\");\n+\t\t} catch(IncorrectClaimException e){\n+\t\t\tfinal String claimName = e.getClaimName();\n+\n+\t\t\tif (Claims.EXPIRATION.equals(claimName)) {\n+\t\t\t\treturn responseResource.responseAuthenticateError(\"invalid_token\",\n+\t\t\t\t\t\tAuthCredentialPushPublishUtil.EXPIRED_TOKEN_ERROR_KEY);\n+\t\t\t} else {\n+\t\t\t\treturn responseResource.responseAuthenticateError(\"invalid_token\",\n+\t\t\t\t\t\tAuthCredentialPushPublishUtil.INVALID_TOKEN_ERROR_KEY);\n+\t\t\t}\n+\t\t}\n \t}\n \n-    /**\n-     * Validates a received token\n-     *\n-     * @param token    Token to validate\n-     * @param remoteIP Sender IP\n-     * @param mySelf   Current end point\n-     * @return True if valid\n-     * @throws IOException If fails reading the security token\n-     */\n-    public static boolean isValidToken ( String token, String remoteIP, PublishingEndPoint mySelf ) throws IOException {\n+\t@WrapInTransaction\n+\tprivate Bundle publishBundle(final boolean forcePush,", "originalCommit": "9b59f9f38c9b9a0c4b50e8f09b81ce9f1d298fe8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTYwOTIwOQ==", "url": "https://github.com/dotCMS/core/pull/19273#discussion_r489609209", "bodyText": "remove this", "author": "jdotcms", "createdAt": "2020-09-16T17:37:57Z", "path": "dotCMS/src/main/java/com/dotcms/rest/IntegrityResource.java", "diffHunk": "@@ -662,43 +549,48 @@ public Response cancelIntegrityProcess ( @Context HttpServletRequest httpServlet\n                 throw new ForbiddenException(e);\n             }\n             return response( \"Error checking the integrity process status for End Point server: [\" + endpointId + \"]\", true );\n+        } catch (NotEndPointTokenFoundException e) {\n+            return Response.status( HttpStatus.SC_BAD_REQUEST )\n+                        .entity( responseMessage.append( \"Error: endpoint requires an authorization key\" ) ).build();\n         }\n \n         return response( responseMessage.toString(), false );\n     }\n \n+    @NotNull", "originalCommit": "9b59f9f38c9b9a0c4b50e8f09b81ce9f1d298fe8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTYwOTMwNg==", "url": "https://github.com/dotCMS/core/pull/19273#discussion_r489609306", "bodyText": "set final", "author": "jdotcms", "createdAt": "2020-09-16T17:38:05Z", "path": "dotCMS/src/main/java/com/dotcms/rest/IntegrityResource.java", "diffHunk": "@@ -662,43 +549,48 @@ public Response cancelIntegrityProcess ( @Context HttpServletRequest httpServlet\n                 throw new ForbiddenException(e);\n             }\n             return response( \"Error checking the integrity process status for End Point server: [\" + endpointId + \"]\", true );\n+        } catch (NotEndPointTokenFoundException e) {\n+            return Response.status( HttpStatus.SC_BAD_REQUEST )\n+                        .entity( responseMessage.append( \"Error: endpoint requires an authorization key\" ) ).build();\n         }\n \n         return response( responseMessage.toString(), false );\n     }\n \n+    @NotNull\n+    private Response cancelIntegrityRequest(String integrityDataRequestId, PublishingEndPoint endpoint)\n+            throws NotEndPointTokenFoundException {\n+        //Prepare the connection\n+        String url = String.format(\"%s/api/integrity/%s/\", endpoint.toURL(), integrityDataRequestId);", "originalCommit": "9b59f9f38c9b9a0c4b50e8f09b81ce9f1d298fe8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTYxMDU5Mw==", "url": "https://github.com/dotCMS/core/pull/19273#discussion_r489610593", "bodyText": "I think this should be handle by annotations", "author": "jdotcms", "createdAt": "2020-09-16T17:40:29Z", "path": "dotCMS/src/main/java/com/dotcms/rest/IntegrityResource.java", "diffHunk": "@@ -1046,43 +933,82 @@ public Response fixConflictsFromRemote ( @Context final HttpServletRequest reque\n             Logger.error( this.getClass(), \"Error fixing \"+type+\" conflicts from remote\", e );\n             return response( \"Error fixing \"+type+\" conflicts from remote\" , true );\n         } finally {\n-\t\t\ttry {\n-\t\t\t\tif (requesterEndPoint != null) {\n-\t\t\t\t\t// Discard conflicts if successful or failed\n-\t\t\t\t\tintegrityUtil.discardConflicts(requesterEndPoint.getId(),\n-\t\t\t\t\t\t\tIntegrityType.valueOf(type.toUpperCase()));\n-\t\t\t\t}\n-\t\t\t} catch (DotDataException e) {\n-\t\t\t\tLogger.error(this.getClass(), \"ERROR: Table \"\n-\t\t\t\t\t\t+ IntegrityType.valueOf(type.toUpperCase()).getResultsTableName()\n-\t\t\t\t\t\t+ \" could not be cleared on end-point [\" + requesterEndPoint.getId()\n-\t\t\t\t\t\t+ \"]. Please truncate the table data manually.\", e);\n-\t\t\t}\n-\n-\t\t\tHibernateUtil.closeSessionSilently();\n-\t\t}\n+            try {\n+                if (remoteIP != null) {\n+                    // Discard conflicts if successful or failed\n+                    integrityUtil.discardConflicts(remoteIP,\n+                            IntegrityType.valueOf(type.toUpperCase()));\n+                }\n+            } catch (DotDataException e) {\n+                Logger.error(this.getClass(), \"ERROR: Table \"\n+                        + IntegrityType.valueOf(type.toUpperCase()).getResultsTableName()\n+                        + \" could not be cleared on request id [\" + remoteIP\n+                        + \"]. Please truncate the table data manually.\", e);\n+            }\n+\n+            HibernateUtil.closeSessionSilently();", "originalCommit": "9b59f9f38c9b9a0c4b50e8f09b81ce9f1d298fe8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE0MjMzOQ==", "url": "https://github.com/dotCMS/core/pull/19273#discussion_r491142339", "bodyText": "done 303cd0b#diff-1c1ba904ed03287c1c0b48a6f3971449L949", "author": "freddyucv", "createdAt": "2020-09-18T19:13:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTYxMDU5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTYxMTUwNQ==", "url": "https://github.com/dotCMS/core/pull/19273#discussion_r489611505", "bodyText": "remove this", "author": "jdotcms", "createdAt": "2020-09-16T17:41:59Z", "path": "dotCMS/src/main/java/com/dotcms/rest/IntegrityResource.java", "diffHunk": "@@ -1188,29 +1098,47 @@ public Response fixConflicts ( @Context final HttpServletRequest httpServletRequ\n         } catch (DotSecurityException e) {\n             throw new ForbiddenException(e);\n         } catch ( Exception e ) {\n-        \ttry {\n+            try {\n                 HibernateUtil.rollbackTransaction();\n             } catch (DotHibernateException e1) {\n                 Logger.error(IntegrityResource.class, \"Error while rolling back transaction\", e);\n             }\n \n             Logger.error( this.getClass(), \"Error fixing \"+type+\" conflicts for End Point server: [\" + endpointId + \"]\", e );\n             return response( \"Error fixing conflicts for endpoint: \" + endpointId , true );\n-\t\t} finally {\n-\t\t\ttry {\n-\t\t\t\t// Discard conflicts if successful or failed\n-\t\t\t\tintegrityUtil.discardConflicts(endpointId, integrityTypeToFix);\n-\t\t\t} catch (DotDataException e) {\n-\t\t\t\tLogger.error(this.getClass(), \"ERROR: Table \" + integrityTypeToFix.getResultsTableName()\n-\t\t\t\t\t\t+ \" could not be cleared on end-point [\" + endpointId\n-\t\t\t\t\t\t+ \"]. Please truncate the table data manually.\", e);\n-\t\t\t}\n-\t\t\tHibernateUtil.closeSessionSilently();\n-\t\t}\n+        } catch (NotEndPointTokenFoundException e) {\n+            return Response.status( HttpStatus.SC_BAD_REQUEST ).entity( \"Error: 'auth key' is a required param.\" ).build();\n+        } finally {\n+            try {\n+                // Discard conflicts if successful or failed\n+                integrityUtil.discardConflicts(endpointId, integrityTypeToFix);\n+            } catch (DotDataException e) {\n+                Logger.error(this.getClass(), \"ERROR: Table \" + integrityTypeToFix.getResultsTableName()\n+                        + \" could not be cleared on end-point [\" + endpointId\n+                        + \"]. Please truncate the table data manually.\", e);\n+            }\n+            HibernateUtil.closeSessionSilently();\n+        }\n \n         return response( jsonResponse.toString(), false );\n     }\n \n+    @NotNull", "originalCommit": "9b59f9f38c9b9a0c4b50e8f09b81ce9f1d298fe8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE0MjU0OQ==", "url": "https://github.com/dotCMS/core/pull/19273#discussion_r491142549", "bodyText": "done 303cd0b#diff-1c1ba904ed03287c1c0b48a6f3971449L458", "author": "freddyucv", "createdAt": "2020-09-18T19:13:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTYxMTUwNQ=="}], "type": "inlineReview"}, {"oid": "2350ea3a99c4281344421c32e8525f695a3ef0c5", "url": "https://github.com/dotCMS/core/commit/2350ea3a99c4281344421c32e8525f695a3ef0c5", "message": "Adding doc", "committedDate": "2020-09-16T21:19:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDM4NjQyNg==", "url": "https://github.com/dotCMS/core/pull/19273#discussion_r490386426", "bodyText": "rename to doesAnyEndpointHaveInvalidTokenStatus", "author": "dsilvam", "createdAt": "2020-09-17T16:19:26Z", "path": "dotCMS/src/main/java/com/dotcms/publisher/business/PublishAuditStatus.java", "diffHunk": "@@ -75,56 +77,71 @@ public PublishAuditStatus(PublishAuditStatus origin, Status status) {\n \t\tthis.createDate = origin.createDate;\n \t\tthis.statusPojo = origin.getStatusPojo(); //TODO manage status POJO\n \t}\n-\t\n+\n+\t/**\n+\t * Return true if  any of the endpoint has the {@link Status#INVALID_TOKEN}\n+\t * @return\n+\t */\n+\tpublic boolean isAnyEndPointInvalidTokenStatus() {", "originalCommit": "9b59f9f38c9b9a0c4b50e8f09b81ce9f1d298fe8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE0Mjc3Ng==", "url": "https://github.com/dotCMS/core/pull/19273#discussion_r491142776", "bodyText": "really this method is not used\n303cd0b#diff-470260e643cc175a1a0c76a8e25eb171L85", "author": "freddyucv", "createdAt": "2020-09-18T19:14:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDM4NjQyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDM5MTY4MA==", "url": "https://github.com/dotCMS/core/pull/19273#discussion_r490391680", "bodyText": "javadoc", "author": "dsilvam", "createdAt": "2020-09-17T16:23:03Z", "path": "dotCMS/src/main/java/com/dotcms/publisher/pusher/AuthCredentialPushPublishUtil.java", "diffHunk": "@@ -0,0 +1,107 @@\n+package com.dotcms.publisher.pusher;\n+\n+import com.dotcms.auth.providers.jwt.JsonWebTokenAuthCredentialProcessor;\n+import com.dotcms.auth.providers.jwt.services.JsonWebTokenAuthCredentialProcessorImpl;\n+import com.dotcms.publisher.endpoint.bean.PublishingEndPoint;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.portlets.rules.parameter.display.DropdownInput;\n+import com.dotmarketing.util.Config;\n+import com.liferay.portal.model.User;\n+import io.jsonwebtoken.Claims;\n+import io.jsonwebtoken.IncorrectClaimException;\n+import org.apache.commons.lang.StringUtils;\n+import org.glassfish.jersey.server.ContainerRequest;\n+import org.jetbrains.annotations.NotNull;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Optional;\n+\n+public enum AuthCredentialPushPublishUtil {\n+    INSTANCE;\n+\n+    private final String BEARER = \"Bearer \";\n+\n+    public static String EXPIRED_TOKEN_ERROR_KEY = \"__expired_token__\";\n+    public static String INVALID_TOKEN_ERROR_KEY = \"__invalid_token__\";\n+\n+    public Optional<String> getRequestToken(final PublishingEndPoint endpoint)  {\n+        try {\n+            final boolean useJWTToken = isJWTAvailable();\n+            final Optional<String> tokenOptional = useJWTToken ?\n+                    getJWTToken(endpoint) :\n+                    PushPublisher.retriveEndpointKeyDigest(endpoint);\n+\n+            if (!tokenOptional.isPresent()) {\n+                return tokenOptional;\n+            }\n+\n+            final String token = tokenOptional.get();\n+\n+            return Optional.of(JsonWebTokenAuthCredentialProcessor.BEARER + token);\n+        } catch (IOException e) {\n+            throw new DotRuntimeException(e);\n+        }\n+    }\n+\n+    public static boolean isJWTAvailable() {\n+        return Config.getBooleanProperty(\"USE_JWT_TOKEN_IN_PUSH_PUBLISH\", true);\n+    }\n+\n+    public boolean processAuthHeader(final HttpServletRequest request) throws DotSecurityException{", "originalCommit": "9b59f9f38c9b9a0c4b50e8f09b81ce9f1d298fe8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE0Mjk3NA==", "url": "https://github.com/dotCMS/core/pull/19273#discussion_r491142974", "bodyText": "done 303cd0b#diff-9ed7c6f6002209611b614ed1bafc1b91R58", "author": "freddyucv", "createdAt": "2020-09-18T19:14:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDM5MTY4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQwMzIzOQ==", "url": "https://github.com/dotCMS/core/pull/19273#discussion_r490403239", "bodyText": "Let's be explicit here: _generateintegritydata", "author": "dsilvam", "createdAt": "2020-09-17T16:37:05Z", "path": "dotCMS/src/main/java/com/dotcms/rest/IntegrityResource.java", "diffHunk": "@@ -162,48 +185,35 @@ private Response postWithEndpointState(String endpointId, String url, MediaType\n      */\n \n     @POST\n-    @Path(\"/generateintegritydata/{params:.*}\")\n-    @Consumes(MediaType.MULTIPART_FORM_DATA)\n+    @Path(\"/_generate\")", "originalCommit": "9b59f9f38c9b9a0c4b50e8f09b81ce9f1d298fe8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE0MzMzNA==", "url": "https://github.com/dotCMS/core/pull/19273#discussion_r491143334", "bodyText": "303cd0b#diff-1c1ba904ed03287c1c0b48a6f3971449R182", "author": "freddyucv", "createdAt": "2020-09-18T19:15:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQwMzIzOQ=="}], "type": "inlineReview"}, {"oid": "303cd0bf044e9265865287ea596719a4346e2895", "url": "https://github.com/dotCMS/core/commit/303cd0bf044e9265865287ea596719a4346e2895", "message": "#16796 Refactoring", "committedDate": "2020-09-18T16:57:59Z", "type": "commit"}, {"oid": "d949dcc5827d1ebe750533b7c72a65d6a195e37f", "url": "https://github.com/dotCMS/core/commit/d949dcc5827d1ebe750533b7c72a65d6a195e37f", "message": "refactoring", "committedDate": "2020-09-18T19:23:09Z", "type": "commit"}, {"oid": "036305201b8231f175b89caa6d7e107f72499e31", "url": "https://github.com/dotCMS/core/commit/036305201b8231f175b89caa6d7e107f72499e31", "message": "Revert \"refactoring\"\n\nThis reverts commit d949dcc5827d1ebe750533b7c72a65d6a195e37f.", "committedDate": "2020-09-18T19:24:03Z", "type": "commit"}, {"oid": "5b19f502aa4193bc9677aafdc562162273209d16", "url": "https://github.com/dotCMS/core/commit/5b19f502aa4193bc9677aafdc562162273209d16", "message": "#16796 Using PP ols way as fallback", "committedDate": "2020-09-21T16:20:54Z", "type": "commit"}, {"oid": "88a559c6370b08be1fd5476a4ddf557e29678b00", "url": "https://github.com/dotCMS/core/commit/88a559c6370b08be1fd5476a4ddf557e29678b00", "message": "#18780 Fixing Push publish fallback", "committedDate": "2020-09-21T18:00:08Z", "type": "commit"}, {"oid": "218e2c216ccf0a21ac967e7ce5a55649001fb486", "url": "https://github.com/dotCMS/core/commit/218e2c216ccf0a21ac967e7ce5a55649001fb486", "message": "Merge remote-tracking branch 'origin/master' into issue-16796-jwt-pp-auth_2", "committedDate": "2020-09-21T21:37:36Z", "type": "commit"}, {"oid": "e98cfc00399347f7486d4b1be252836fb47f74ef", "url": "https://github.com/dotCMS/core/commit/e98cfc00399347f7486d4b1be252836fb47f74ef", "message": "Fixing test", "committedDate": "2020-09-21T22:23:27Z", "type": "commit"}, {"oid": "fdfd22bf32792d7e5bfc7ab0ffe747f326cfb4ac", "url": "https://github.com/dotCMS/core/commit/fdfd22bf32792d7e5bfc7ab0ffe747f326cfb4ac", "message": "fixing test", "committedDate": "2020-09-22T16:18:17Z", "type": "commit"}, {"oid": "7389d093bd9dbfe727d7bf8204e08aeaf13ef22f", "url": "https://github.com/dotCMS/core/commit/7389d093bd9dbfe727d7bf8204e08aeaf13ef22f", "message": "Testing", "committedDate": "2020-09-22T20:09:47Z", "type": "commit"}, {"oid": "bef0801b5b0c3bc4eca0b56cfb40ab9b4fdb52e3", "url": "https://github.com/dotCMS/core/commit/bef0801b5b0c3bc4eca0b56cfb40ab9b4fdb52e3", "message": "#16796 merge", "committedDate": "2020-09-23T16:56:45Z", "type": "commit"}, {"oid": "4c1cf77e1465152b7c27658effb51f84c5742a2a", "url": "https://github.com/dotCMS/core/commit/4c1cf77e1465152b7c27658effb51f84c5742a2a", "message": "fixing test", "committedDate": "2020-09-23T17:16:20Z", "type": "commit"}, {"oid": "338e48d78564229caf948f5eb6790554d61def0b", "url": "https://github.com/dotCMS/core/commit/338e48d78564229caf948f5eb6790554d61def0b", "message": "Fixing test", "committedDate": "2020-09-23T19:41:44Z", "type": "commit"}, {"oid": "51cfa823bd29b2cffe0c0a67404583054c673e90", "url": "https://github.com/dotCMS/core/commit/51cfa823bd29b2cffe0c0a67404583054c673e90", "message": "fixing test", "committedDate": "2020-09-23T21:30:04Z", "type": "commit"}, {"oid": "c54caa01a17acbf1d63de34285064f692fb3af5c", "url": "https://github.com/dotCMS/core/commit/c54caa01a17acbf1d63de34285064f692fb3af5c", "message": "fixing test", "committedDate": "2020-09-23T22:41:59Z", "type": "commit"}, {"oid": "ffbe2a858dc76ec456aa89626eee9d5ece529e6b", "url": "https://github.com/dotCMS/core/commit/ffbe2a858dc76ec456aa89626eee9d5ece529e6b", "message": "Fixing testing", "committedDate": "2020-09-24T16:13:11Z", "type": "commit"}, {"oid": "08510b95ab9e594b00f636862f6d4c789f738ab6", "url": "https://github.com/dotCMS/core/commit/08510b95ab9e594b00f636862f6d4c789f738ab6", "message": "fixing testing", "committedDate": "2020-09-24T18:45:28Z", "type": "commit"}, {"oid": "9282e45a4d42e87be427b1212be17a6ce0c95d6c", "url": "https://github.com/dotCMS/core/commit/9282e45a4d42e87be427b1212be17a6ce0c95d6c", "message": "Fixing integration test", "committedDate": "2020-09-24T18:53:31Z", "type": "commit"}, {"oid": "132d462447267ccefc1bc42893a01ae495aa8569", "url": "https://github.com/dotCMS/core/commit/132d462447267ccefc1bc42893a01ae495aa8569", "message": "Fixing test", "committedDate": "2020-09-24T20:47:00Z", "type": "commit"}, {"oid": "72f5ae9de200a653a7ab295fb34521ac63ca1edf", "url": "https://github.com/dotCMS/core/commit/72f5ae9de200a653a7ab295fb34521ac63ca1edf", "message": "Fix testing", "committedDate": "2020-09-24T21:46:37Z", "type": "commit"}, {"oid": "3168caad2d31312801458e2ac07e648458a4e99d", "url": "https://github.com/dotCMS/core/commit/3168caad2d31312801458e2ac07e648458a4e99d", "message": "Fixing test", "committedDate": "2020-09-24T22:51:47Z", "type": "commit"}, {"oid": "d76e76d7c60499e1b420a2c0cde097b8a56d2689", "url": "https://github.com/dotCMS/core/commit/d76e76d7c60499e1b420a2c0cde097b8a56d2689", "message": "Fixing testing", "committedDate": "2020-09-25T13:33:30Z", "type": "commit"}, {"oid": "19db7f7f8b8d431cfa81e08fd63ccc284ac83c4c", "url": "https://github.com/dotCMS/core/commit/19db7f7f8b8d431cfa81e08fd63ccc284ac83c4c", "message": "Fixing test", "committedDate": "2020-09-25T14:54:42Z", "type": "commit"}, {"oid": "704c8c6ebe7d5c3cc85438796c12b4b95b69461b", "url": "https://github.com/dotCMS/core/commit/704c8c6ebe7d5c3cc85438796c12b4b95b69461b", "message": "#16796: Chaging Quartz 'isJobRunning' implementation", "committedDate": "2020-09-25T16:56:52Z", "type": "commit"}, {"oid": "c39743198080cb0c5cadba0c8f79ab2c7c05cd60", "url": "https://github.com/dotCMS/core/commit/c39743198080cb0c5cadba0c8f79ab2c7c05cd60", "message": "Merge branch 'issue-16796-jwt-pp-auth_2' of github.com:dotCMS/core into issue-16796-jwt-pp-auth_2", "committedDate": "2020-09-25T16:58:42Z", "type": "commit"}, {"oid": "0c54707ba722a58cf3c2be3fa76d354f57a7549a", "url": "https://github.com/dotCMS/core/commit/0c54707ba722a58cf3c2be3fa76d354f57a7549a", "message": "Fixing testing", "committedDate": "2020-09-25T18:00:53Z", "type": "commit"}, {"oid": "a3bdafd968420b6be2cc56dc71c3664645f6edeb", "url": "https://github.com/dotCMS/core/commit/a3bdafd968420b6be2cc56dc71c3664645f6edeb", "message": "Merge branch 'issue-16796-jwt-pp-auth_2' of https://github.com/dotCMS/core into issue-16796-jwt-pp-auth_2", "committedDate": "2020-09-25T18:01:07Z", "type": "commit"}, {"oid": "5ca3f9ba731c02802057f1871c0370690174c154", "url": "https://github.com/dotCMS/core/commit/5ca3f9ba731c02802057f1871c0370690174c154", "message": "Fixing test", "committedDate": "2020-09-25T19:46:32Z", "type": "commit"}, {"oid": "1ab51de7096695202eb916d59c8d5674c5e3c4a9", "url": "https://github.com/dotCMS/core/commit/1ab51de7096695202eb916d59c8d5674c5e3c4a9", "message": "Testing", "committedDate": "2020-09-25T19:55:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI4NDM2MA==", "url": "https://github.com/dotCMS/core/pull/19273#discussion_r495284360", "bodyText": "javadoc", "author": "dsilvam", "createdAt": "2020-09-25T22:30:48Z", "path": "dotCMS/src/main/java/com/dotcms/rest/RestEndPointIPUtil.java", "diffHunk": "@@ -0,0 +1,32 @@\n+package com.dotcms.rest;\n+\n+import com.dotcms.util.HttpRequestDataUtil;\n+import com.dotmarketing.util.UtilMethods;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.ws.rs.core.Context;\n+import java.util.Optional;\n+\n+public class RestEndPointIPUtil {", "originalCommit": "1ab51de7096695202eb916d59c8d5674c5e3c4a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "31011524a73fdfdaf924361ea51973388817610c", "url": "https://github.com/dotCMS/core/commit/31011524a73fdfdaf924361ea51973388817610c", "message": "Java doc", "committedDate": "2020-09-25T22:45:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI5NjYwMA==", "url": "https://github.com/dotCMS/core/pull/19273#discussion_r495296600", "bodyText": "Codacy found an issue: Ensure that resources like this ResultSet object are closed after use", "author": "dev-dotcms", "createdAt": "2020-09-25T22:52:22Z", "path": "dotCMS/src/integration-test/java/com/dotmarketing/startup/runonce/Task05390RemoveEndpointIdForeignKeyInIntegrityResolverTablesIntegrationTest.java", "diffHunk": "@@ -0,0 +1,208 @@\n+package com.dotmarketing.startup.runonce;\n+\n+import com.dotcms.util.IntegrationTestInitService;\n+import com.dotmarketing.common.db.DotConnect;\n+import com.dotmarketing.common.db.DotDatabaseMetaData;\n+import com.dotmarketing.db.DbConnectionFactory;\n+import com.dotmarketing.exception.DotDataException;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.sql.Connection;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.dotcms.util.CollectionsUtils.list;\n+import static com.dotcms.util.CollectionsUtils.map;\n+import static org.junit.Assert.assertEquals;\n+\n+\n+public class Task05390RemoveEndpointIdForeignKeyInIntegrityResolverTablesIntegrationTest {\n+\n+    @BeforeClass\n+    public static void prepare() throws Exception {\n+        // Setting web app environment\n+        IntegrationTestInitService.getInstance().init();\n+    }\n+\n+    /**\n+     * Method to Test: {@link Task05390RemoveEndpointIdForeignKeyInIntegrityResolverTables#executeUpgrade()}\n+     * When: Run the Upgrade Task\n+     * Should: Should remove the foreign key to all the Integrity Resolver tables and rename the column endpoint_id\n+     * The Integrity Resolver tables are:\n+     * - cms_roles_ir\n+     * - folders_ir\n+     * - structures_ir\n+     * - htmlpages_ir\n+     * - fileassets_ir\n+     *\n+     * After remove the constraint you should be allow to insert register in this table without has any register in publishing_end_point\n+     */\n+    @Test\n+    public void constraintShouldNotExists() throws DotDataException, SQLException {\n+\n+        final String endpointId = insertPublishingEndPoint();\n+        insertFolderIntegrityResolver(endpointId);\n+        insertPageIntegrityResolver(endpointId);\n+        insertFileAssetIntegrityResolver(endpointId);\n+        insertRolesIntegrityResolver(endpointId);\n+        insertStructuresIntegrityResolver(endpointId);\n+\n+        final Task05390RemoveEndpointIdForeignKeyInIntegrityResolverTables task05390RemoveEndpointIdForeignKeyInIntegrityResolverTables =\n+                new Task05390RemoveEndpointIdForeignKeyInIntegrityResolverTables();\n+\n+        task05390RemoveEndpointIdForeignKeyInIntegrityResolverTables.executeUpgrade();\n+\n+        insertFolderIntegrityResolver(\"anyIP\");\n+        insertPageIntegrityResolver(\"anyIP\");\n+        insertFileAssetIntegrityResolver(\"anyIP\");\n+        insertRolesIntegrityResolver(\"anyIP\");\n+        insertStructuresIntegrityResolver(\"anyIP\");\n+\n+        checkColumnsSize();\n+    }\n+\n+    private void checkColumnsSize() throws SQLException {\n+        final List<String> tables = list(\n+                \"folders_ir\",\n+                \"structures_ir\",\n+                \"htmlpages_ir\",\n+                \"fileassets_ir\",\n+                \"cms_roles_ir\"\n+        );\n+\n+        for (String table : tables) {\n+            checkColumnSize(table);\n+        }\n+    }\n+\n+    private void checkColumnSize(final String tableName) throws SQLException {\n+        final Connection connection = DbConnectionFactory.getConnection();\n+        final ResultSet resultSet = DotDatabaseMetaData.getColumnsMetaData(connection, tableName);", "originalCommit": "31011524a73fdfdaf924361ea51973388817610c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI5NjYxMA==", "url": "https://github.com/dotCMS/core/pull/19273#discussion_r495296610", "bodyText": "Codacy found an issue: Avoid variables with short names like dc", "author": "dev-dotcms", "createdAt": "2020-09-25T22:52:23Z", "path": "dotCMS/src/main/java/com/dotmarketing/startup/runonce/Task05390RemoveEndpointIdForeignKeyInIntegrityResolverTables.java", "diffHunk": "@@ -0,0 +1,65 @@\n+package com.dotmarketing.startup.runonce;\n+\n+import com.dotmarketing.common.db.DotConnect;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.startup.StartupTask;\n+\n+import java.util.Map;\n+\n+import static com.dotcms.util.CollectionsUtils.map;\n+\n+/**\n+ * Remove the foreign key with the publishing_end_point table to all the Integrity Resolver tables and rename the column\n+ * endpoint_id to remote IP, Also change the endpoint_id column size.\n+ *\n+ * The Integrity Resolver tables are:\n+ *\n+ * - cms_roles_ir\n+ * - folder_ir\n+ * - structures_ir\n+ * - htmlpages_ir\n+ * - fileassets_ir\n+ */\n+public class Task05390RemoveEndpointIdForeignKeyInIntegrityResolverTables implements StartupTask {\n+    @Override\n+    public boolean forceRun() {\n+        return true;\n+    }\n+\n+    @Override\n+    public void executeUpgrade() throws DotDataException, DotRuntimeException {\n+\n+        final Map<String, String> tables = map(\n+                \"folders_ir\", \"fk_folder_ir_ep\",\n+                \"structures_ir\", \"fk_structure_ir_ep\",\n+                \"htmlpages_ir\", \"fk_page_ir_ep\",\n+                \"fileassets_ir\", \"fk_file_ir_ep\",\n+                \"cms_roles_ir\", \"fk_cms_roles_ir_ep\"\n+        );\n+\n+        for (Map.Entry<String, String> entry : tables.entrySet()) {\n+            try {\n+                dropConstraint(entry.getKey(), entry.getValue());\n+                alterColumn(entry.getKey());\n+            }catch (DotDataException e) {\n+                continue;\n+            }\n+        }\n+\n+    }\n+\n+    private void dropConstraint(final String tableName, final String constraintName) throws DotDataException {\n+        DotConnect dc = new DotConnect();", "originalCommit": "31011524a73fdfdaf924361ea51973388817610c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI5NjYyNg==", "url": "https://github.com/dotCMS/core/pull/19273#discussion_r495296626", "bodyText": "Codacy found an issue: Avoid unused imports such as 'javax.ws.rs'", "author": "dev-dotcms", "createdAt": "2020-09-25T22:52:24Z", "path": "dotCMS/src/main/java/com/dotcms/rest/BundlePublisherResource.java", "diffHunk": "@@ -1,34 +1,33 @@\n package com.dotcms.rest;\n \n+\n+import com.dotcms.business.WrapInTransaction;\n+import com.dotcms.concurrent.DotConcurrentFactory;\n+\n import com.dotcms.publisher.bundle.bean.Bundle;\n import com.dotcms.publisher.business.PublishAuditAPI;\n import com.dotcms.publisher.business.PublishAuditStatus;\n import com.dotcms.publisher.business.PublishAuditStatus.Status;\n import com.dotcms.publisher.business.PublisherQueueJob;\n-import com.dotcms.publisher.endpoint.bean.PublishingEndPoint;\n-import com.dotcms.publisher.endpoint.business.PublishingEndPointAPI;\n-import com.dotcms.publisher.pusher.PushPublisher;\n-import javax.ws.rs.Consumes;\n-import javax.ws.rs.POST;\n-import javax.ws.rs.Path;\n-import javax.ws.rs.QueryParam;\n+import com.dotcms.publisher.pusher.AuthCredentialPushPublishUtil;\n+\n+import javax.servlet.http.HttpServletResponse;\n+import javax.ws.rs.*;", "originalCommit": "31011524a73fdfdaf924361ea51973388817610c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI5NjYzNQ==", "url": "https://github.com/dotCMS/core/pull/19273#discussion_r495296635", "bodyText": "Codacy found an issue: Avoid unused imports such as 'java.util.Set'", "author": "dev-dotcms", "createdAt": "2020-09-25T22:52:26Z", "path": "dotCMS/src/integration-test/java/com/dotmarketing/startup/runonce/Task05390RemoveEndpointIdForeignKeyInIntegrityResolverTablesIntegrationTest.java", "diffHunk": "@@ -0,0 +1,208 @@\n+package com.dotmarketing.startup.runonce;\n+\n+import com.dotcms.util.IntegrationTestInitService;\n+import com.dotmarketing.common.db.DotConnect;\n+import com.dotmarketing.common.db.DotDatabaseMetaData;\n+import com.dotmarketing.db.DbConnectionFactory;\n+import com.dotmarketing.exception.DotDataException;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.sql.Connection;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;", "originalCommit": "31011524a73fdfdaf924361ea51973388817610c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI5NjY1Mg==", "url": "https://github.com/dotCMS/core/pull/19273#discussion_r495296652", "bodyText": "Codacy found an issue: Avoid unused imports such as 'com.dotcms.util.CollectionsUtils.map'", "author": "dev-dotcms", "createdAt": "2020-09-25T22:52:27Z", "path": "dotCMS/src/integration-test/java/com/dotmarketing/startup/runonce/Task05390RemoveEndpointIdForeignKeyInIntegrityResolverTablesIntegrationTest.java", "diffHunk": "@@ -0,0 +1,208 @@\n+package com.dotmarketing.startup.runonce;\n+\n+import com.dotcms.util.IntegrationTestInitService;\n+import com.dotmarketing.common.db.DotConnect;\n+import com.dotmarketing.common.db.DotDatabaseMetaData;\n+import com.dotmarketing.db.DbConnectionFactory;\n+import com.dotmarketing.exception.DotDataException;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.sql.Connection;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.dotcms.util.CollectionsUtils.list;\n+import static com.dotcms.util.CollectionsUtils.map;", "originalCommit": "31011524a73fdfdaf924361ea51973388817610c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI5NjY2Mg==", "url": "https://github.com/dotCMS/core/pull/19273#discussion_r495296662", "bodyText": "Codacy found an issue: Unnecessary modifier 'public' on method 'executeFix': the method is declared in an interface type", "author": "dev-dotcms", "createdAt": "2020-09-25T22:52:28Z", "path": "dotCMS/src/main/java/com/dotcms/integritycheckers/IntegrityChecker.java", "diffHunk": "@@ -68,12 +68,13 @@\n      * When there is conflicts, this method will fix them depending of the\n      * implementation of every checker\n      * \n-     * @param endpointId\n-     *            Server identifier were we need to fix conflicts\n+     * @param key\n+     *            JWT Token key when using JWT token in Push Publish or\n+     *            Server identifier were we need to fix conflicts when not using JWT token\n      * @throws DotDataException\n      * @throws DotSecurityException\n      */\n-    public void executeFix(final String endpointId) throws DotDataException, DotSecurityException;\n+    public void executeFix(final String key) throws DotDataException, DotSecurityException;", "originalCommit": "31011524a73fdfdaf924361ea51973388817610c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI5NjY3Mg==", "url": "https://github.com/dotCMS/core/pull/19273#discussion_r495296672", "bodyText": "Codacy found an issue: Avoid unused private methods such as 'isAdmin(User)'.", "author": "dev-dotcms", "createdAt": "2020-09-25T22:52:29Z", "path": "dotCMS/src/main/java/com/dotcms/rest/BundlePublisherResource.java", "diffHunk": "@@ -37,148 +36,128 @@\n public class BundlePublisherResource {\n \n \tpublic static String MY_TEMP = \"\";\n-\tprivate PublishingEndPointAPI endpointAPI = APILocator.getPublisherEndPointAPI();\n-\n-    /**\n-     * Method that receives from a server a bundle with the intention of publish it.<br/>\n-     * When a Bundle file is received on this end point is required to validate if the sending server is an allowed<br/>\n-     * server on this end point and if the security tokens match. If all the validations are correct the bundle will be add it<br/>\n-     * to the {@link PublishThread Publish Thread}.\n-     *\n-     * @param fileName       File name to be published\n-     * @param auth_token_enc Authentication token\n-     * @param groupId        Group who sent the Bundle\n-     * @param endpointId     End-point who sent the Bundle\n-\t * @param type\t\t\t response type\n-\t * @param callback \t\t response callback\n-\t * @param bundleName\t The name for the Bundle to publish\n-\t * @param forcePush \t true/false to Force the push\n-     * @param req            HttpRequest\n-     * @return Returns a {@link Response} object with a 200 status code if success or a 500 error code if anything fails on the Publish process\n-     * @see PublishThread\n-     */\n-    @POST\n-    @Path (\"/publish\")\n-    @Consumes(MediaType.APPLICATION_OCTET_STREAM)\n+\n+\t/**\n+\t * Method that receives from a server a bundle with the intention of publish it.<br/>\n+\t * When a Bundle file is received on this end point is required to validate if the sending server is an allowed<br/>\n+\t * server on this end point and if the security tokens match. If all the validations are correct the bundle will be add it<br/>\n+\t * to the {@link PublishThread Publish Thread}.\n+\t *\n+\t * @param type\t\t\t  response type\n+\t * @param callback \t\t  response callback\n+\t * @param forcePush \t  true/false to Force the push\n+\t * @param request         {@link HttpServletRequest}\n+\t * @param response        {@link HttpServletResponse}\n+\t * @return Returns a {@link Response} object with a 200 status code if success or a 500 error code if anything fails on the Publish process\n+\t * @see PublishThread\n+\t */\n+\t@POST\n+\t@Path(\"/publish\")\n+\t@Consumes(MediaType.APPLICATION_OCTET_STREAM)\n+\t@Produces(MediaType.APPLICATION_JSON)\n \tpublic Response publish(\n-\t\t\t@QueryParam(\"FILE_NAME\") String fileName,\n-\t\t\t@QueryParam(\"AUTH_TOKEN\") String auth_token_digest,\n-\t\t\t@QueryParam(\"GROUP_ID\") String groupId,\n-\t\t\t@QueryParam(\"ENDPOINT_ID\") String endpointId,\n-\t\t\t@QueryParam(\"type\") String type,\n-\t\t\t@QueryParam(\"callback\") String callback,\n-\t\t\t@QueryParam(\"BUNDLE_NAME\") String bundleName,\n-\t\t\t@QueryParam(\"FORCE_PUSH\") final boolean forcePush,\n-\t\t\t@Context HttpServletRequest req\n-\t) {\n-    \ttry {\n-    \t\ttry (InputStream bundleStream = req.getInputStream()) {\n-\t\t        //Creating an utility response object\n-\t\t        Map<String, String> paramsMap = new HashMap<String, String>();\n-\t\t        paramsMap.put( \"type\", type );\n-\t\t        paramsMap.put( \"callback\", callback );\n-\t\t        ResourceResponse responseResource = new ResourceResponse( paramsMap );\n-\n-\t\t\t\tString remoteIP = \"\";\n-\t\t\t\ttry {\n-\n-\t\t\t\t\tremoteIP = req.getRemoteHost();\n-\t\t\t\t\tif(!UtilMethods.isSet(remoteIP))\n-\t\t\t\t\t\tremoteIP = req.getRemoteAddr();\n-\n-\t\t\t\t\tHibernateUtil.startTransaction();\n-\n-\t\t\t\t\tPublishingEndPoint mySelf = endpointAPI.findEnabledSendingEndPointByAddress(remoteIP);\n-\n-\t\t\t\t\tif(mySelf==null || !isValidToken(auth_token_digest, remoteIP, mySelf)) {\n-\t\t\t\t\t\tbundleStream.close();\n-\t\t\t\t\t\tLogger.error(this.getClass(), \"Push Publishing failed from \" + remoteIP + \" invalid endpoint or token\");\n-\t\t\t\t\t\t\n-\t\t        return responseResource.responseError( HttpStatus.SC_UNAUTHORIZED );\n-\t\t       }\n-\n-\t\t\t\t\tString bundlePath = ConfigUtils.getBundlePath()+File.separator+MY_TEMP;\n-\t\t\t\t\tString bundleFolder = fileName.substring(0, fileName.indexOf(\".tar.gz\"));\n-\n-\t\t            PublishAuditStatus status = PublishAuditAPI.getInstance().updateAuditTable( mySelf.getId(), mySelf.getId(), bundleFolder, true );\n-\n-\t\t            if(bundleName.trim().length()>0) {\n-\t\t\t\t\t    // save bundle if it doesn't exists\n-\t\t                Bundle foundBundle = APILocator.getBundleAPI().getBundleById( bundleFolder );\n-\t\t                if ( foundBundle == null || foundBundle.getId() == null ) {\n-\t\t                    Bundle bundle = new Bundle();\n-\t\t\t\t\t\t\tbundle.setId(bundleFolder);\n-\t\t\t\t\t\t\tbundle.setName(bundleName);\n-\t\t\t\t\t\t\tbundle.setPublishDate(Calendar.getInstance().getTime());\n-\t\t\t\t\t\t\tbundle.setOwner(APILocator.getUserAPI().getSystemUser().getUserId());\n-\t\t\t\t\t\t\tbundle.setForcePush(forcePush);\n-\t\t                    APILocator.getBundleAPI().saveBundle(bundle);\n-\t\t\t\t\t    }\n-\t\t\t\t\t}\n-\n-\t\t\t\t\t//Write file on FS\n-\t\t\t\t\tFileUtil.writeToFile(bundleStream, bundlePath+fileName);\n-\n-\t\t\t\t\t//Start thread\n-\t\t\t\t\tif(!status.getStatus().equals(Status.PUBLISHING_BUNDLE)) {\n-\t\t\t\t\t\tnew Thread(new PublishThread(fileName, groupId, endpointId, status)).start();\n-\t\t\t\t\t}\n-\n-\t\t\t\t\tHibernateUtil.commitTransaction();\n-\n-\t\t\t\t\treturn Response.status(HttpStatus.SC_OK).build();\n-\t\t\t\t} catch (NumberFormatException e) {\n-\t\t\t\t    try {\n-\t\t                HibernateUtil.rollbackTransaction();\n-\t\t            } catch (DotHibernateException e1) {\n-\t\t                Logger.error(this, \"error rollback\",e1);\n-\t\t            }\n-\t\t\t\t\tLogger.error(PublisherQueueJob.class,e.getMessage(),e);\n-\t\t\t\t} catch (Exception e) {\n-\t\t\t\t    try {\n-\t\t                HibernateUtil.rollbackTransaction();\n-\t\t            } catch (DotHibernateException e1) {\n-\t\t                Logger.error(this, \"error rollback\",e1);\n-\t\t            }\n-\t\t\t\t\tLogger.error(PublisherQueueJob.class, \"Error caused by remote call of: \"+remoteIP);\n-\t\t\t\t\tLogger.error(PublisherQueueJob.class,e.getMessage(),e);\n-\t\t\t\t}\n-\t\t\t\tfinally {\n-\t\t\t\t    try {\n-\t\t                HibernateUtil.closeSession();\n-\t\t            } catch (DotHibernateException e) {\n-\t\t                Logger.error(this, \"error close session\",e);\n-\t\t            }\n-\t\t\t\t}\n-    \t\t}\n-    \t} catch (IOException e) {\n-    \t\tLogger.error(PublisherQueueJob.class,e.getMessage(),e);\n-    \t}\n-\n-\t\treturn Response.status(HttpStatus.SC_INTERNAL_SERVER_ERROR).build();\n+\t\t\t@QueryParam(\"type\")        final String type,\n+\t\t\t@QueryParam(\"callback\")    final String callback,\n+\t\t\t@QueryParam(\"FORCE_PUSH\")  final boolean forcePush,\n+\t\t\t@Context final HttpServletRequest  request,\n+\t\t\t@Context final HttpServletResponse response\n+\t) throws Exception {\n+\t\tfinal ResourceResponse responseResource = new ResourceResponse(\n+\t\t\t\tCollectionsUtils.map(\"type\", type, \"callback\", callback));\n+\t\tfinal String remoteIP = UtilMethods.isSet(request.getRemoteHost())?\n+\t\t\t\trequest.getRemoteHost() : request.getRemoteAddr();\n+\n+\t\tif (request.getInputStream().isFinished()) {\n+\t\t\tLogger.error(this.getClass(), \"Push Publishing failed from \" + remoteIP + \" bundle expected\");\n+\t\t\treturn responseResource.responseError(HttpStatus.SC_BAD_REQUEST);\n+\t\t}\n+\n+\t\tfinal AuthCredentialPushPublishUtil.PushPublishAuthenticationToken pushPublishAuthenticationToken\n+\t\t\t\t= AuthCredentialPushPublishUtil.INSTANCE.processAuthHeader(request);\n+\n+\t\tfinal Optional<Response> failResponse = PushPublishResourceUtil.getFailResponse(request, pushPublishAuthenticationToken);\n+\n+\t\tif (failResponse.isPresent()) {\n+\t\t\treturn failResponse.get();\n+\t\t}\n+\n+\t\tfinal Bundle bundle = this.publishBundle(forcePush, request, remoteIP);\n+\n+\t\treturn Response.ok(bundle).build();\n \t}\n \n-    /**\n-     * Validates a received token\n-     *\n-     * @param token    Token to validate\n-     * @param remoteIP Sender IP\n-     * @param mySelf   Current end point\n-     * @return True if valid\n-     * @throws IOException If fails reading the security token\n-     */\n-    public static boolean isValidToken ( String token, String remoteIP, PublishingEndPoint mySelf ) throws IOException {\n+\t@WrapInTransaction\n+\tprivate Bundle publishBundle(final boolean forcePush,\n+\t\t\t\t\t\t\t\t final HttpServletRequest request,\n+\t\t\t\t\t\t\t\t final String remoteIP) throws Exception {\n+\n+\t\tfinal String fileNameSent = getFileNameFromRequest(request);\n+\t\tfinal String fileName = UtilMethods.isSet(fileNameSent) ? fileNameSent : generatedBundleFileName();\n+\n+\t\tBundle bundle = null;\n+\n+\t\ttry (InputStream bundleStream = request.getInputStream()) {\n+\n+\t\t\tfinal String bundlePath         = ConfigUtils.getBundlePath()+ File.separator + MY_TEMP;\n+\t\t\tfinal String bundleFolder       = fileName.substring(0, fileName.indexOf(\".tar.gz\"));\n+\t\t\tfinal PublishAuditStatus status = PublishAuditAPI.getInstance().updateAuditTable(\n+\t\t\t\t\tremoteIP, remoteIP, bundleFolder, true);\n+\n+\t\t\t// save bundle if it doesn't exists\n+\t\t\tbundle = APILocator.getBundleAPI().getBundleById(bundleFolder);\n+\t\t\tif (bundle == null || bundle.getId() == null) {\n \n-        //My key\n-        Optional<String> myKey=PushPublisher.retriveEndpointKeyDigest(mySelf);\n-        if(!myKey.isPresent()) {\n-          return false;\n-        }\n+\t\t\t\tbundle = new Bundle();\n+\t\t\t\tbundle.setId(bundleFolder);\n+\t\t\t\tbundle.setName(fileName.replace(\".tar.gz\", \"\"));\n+\t\t\t\tbundle.setPublishDate(Calendar.getInstance().getTime());\n+\t\t\t\tbundle.setOwner(APILocator.getUserAPI().getSystemUser().getUserId());\n+\t\t\t\tbundle.setForcePush(forcePush);\n+\t\t\t\tAPILocator.getBundleAPI().saveBundle(bundle);\n+\t\t\t}\n \n+\t\t\t//Write file on FS\n+\t\t\tFileUtil.writeToFile(bundleStream, bundlePath + fileName);\n \n-        return token.equals( myKey.get() );\n-    }\n+\t\t\t//Start thread\n \n+\t\t\tif(!status.getStatus().equals(Status.PUBLISHING_BUNDLE)) {\n \n+\t\t\t\tDotConcurrentFactory.getInstance()\n+\t\t\t\t\t\t.getSubmitter()\n+\t\t\t\t\t\t.submit(new PublishThread(fileName, null, null, status));\n+\t\t\t}\n \n+\t\t\treturn bundle;\n+\t\t} catch (Exception e) {\n+\n+\t\t\tLogger.error(\n+\t\t\t\t\tPublisherQueueJob.class,\n+\t\t\t\t\tString.format(\"Error caused by remote call of: Remote IP - %s, bundle file name - %s, end point- %s\",\n+\t\t\t\t\t\t\tremoteIP, fileName,  remoteIP));\n+\t\t\tLogger.error(PublisherQueueJob.class,e.getMessage(),e);\n+\t\t\tthrow e;\n+\t\t}\n+\t}\n+\n+\tprivate String getFileNameFromRequest(HttpServletRequest request) {\n+\t\ttry {\n+\t\t\tfinal String fileNameValue = request.getHeader(\"Content-Disposition\")\n+\t\t\t\t\t.split(\";\")[1]\n+\t\t\t\t\t.trim()\n+\t\t\t\t\t.split(\"=\")[1];\n+\t\t\treturn fileNameValue.substring(1, fileNameValue.length() - 1);\n+\t\t} catch (Exception e) {\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n+\tprivate String generatedBundleFileName() {\n+\t\treturn String.format(\"bundle_%d.tar.gz\", System.currentTimeMillis());\n+\t}\n+\n+\tprivate boolean isAdmin(final User user) {", "originalCommit": "31011524a73fdfdaf924361ea51973388817610c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI5NjY4NA==", "url": "https://github.com/dotCMS/core/pull/19273#discussion_r495296684", "bodyText": "Codacy found an issue: Ensure that resources like this InputStream object are closed after use", "author": "dev-dotcms", "createdAt": "2020-09-25T22:52:31Z", "path": "dotCMS/src/main/java/com/dotcms/rest/IntegrityResource.java", "diffHunk": "@@ -1305,10 +1285,139 @@ private Response response ( String response, Boolean error ) {\n      */\n     private Response response ( String response, Boolean error, String contentType ) {\n         if ( error ) {\n-            return Response.status( HttpStatus.SC_INTERNAL_SERVER_ERROR ).entity( response ).build();\n+            return response(response, HttpStatus.SC_INTERNAL_SERVER_ERROR);\n         } else {\n             return Response.ok( response, contentType ).build();\n         }\n     }\n \n+    private Response response ( String response, int status ) {\n+        return Response.status( status ).entity( response ).build();\n+    }\n+\n+    private class IntegrityDataRequestChecker implements Runnable{\n+\n+        private final User loggedUser;\n+        private final HttpSession session;\n+        private final PublishingEndPoint endpoint;\n+        private final String integrityDataRequestID;\n+\n+        public IntegrityDataRequestChecker(\n+                final User loggedUser,\n+                final HttpSession session,\n+                final PublishingEndPoint endpoint,\n+                final String integrityDataRequestID) {\n+\n+            this.loggedUser = loggedUser;\n+            this.session = session;\n+            this.endpoint = endpoint;\n+            this.integrityDataRequestID = integrityDataRequestID;\n+        }\n+\n+        @CloseDBIfOpened\n+        public void run(){\n+\n+            boolean processing = true;\n+\n+            while(processing) {\n+\n+                Response response = null;\n+\n+                response = statusIntegrityCheckerRequest();\n+\n+                if (response.getStatus() == HttpStatus.SC_OK) {\n+\n+                    processing = false;\n+\n+                    InputStream zipFile = response.readEntity(InputStream.class);", "originalCommit": "31011524a73fdfdaf924361ea51973388817610c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI5NjcwMQ==", "url": "https://github.com/dotCMS/core/pull/19273#discussion_r495296701", "bodyText": "Codacy found an issue: Avoid unused private methods such as 'getRemoteIP(HttpServletRequest)'.", "author": "dev-dotcms", "createdAt": "2020-09-25T22:52:32Z", "path": "dotCMS/src/main/java/com/dotcms/rest/IntegrityResource.java", "diffHunk": "@@ -985,83 +969,87 @@ public Response discardConflicts ( @Context final HttpServletRequest request, @C\n      *\n      * @param request\n      * @param dataToFix\n-     * @param auth_token_digest\n      * @param type\n      * @return\n      * @throws JSONException\n      */\n     @POST\n-    @Path(\"/fixconflictsfromremote/{params:.*}\")\n+    @Path(\"/_fixconflictsfromremote\")\n     @Consumes(MediaType.MULTIPART_FORM_DATA)\n     @Produces(\"text/plain\")\n-    public Response fixConflictsFromRemote (@Context final HttpServletRequest request,\n-                                            @FormDataParam(\"DATA_TO_FIX\") final InputStream dataToFix,\n-                                            @FormDataParam(\"AUTH_TOKEN\") final String auth_token_digest,\n-                                            @FormDataParam(\"TYPE\") final String type ) throws JSONException {\n-        final String remoteIp = resolveRemoteIp(request);\n+    public Response fixConflictsFromRemote ( @Context final HttpServletRequest request,\n+                                             @FormDataParam(\"DATA_TO_FIX\") InputStream dataToFix,\n+                                             @FormDataParam(\"TYPE\") String type ) throws JSONException {\n+\n+        final AuthCredentialPushPublishUtil.PushPublishAuthenticationToken pushPublishAuthenticationToken\n+                = AuthCredentialPushPublishUtil.INSTANCE.processAuthHeader(request);\n+\n+        final Optional<Response> failResponse = PushPublishResourceUtil.getFailResponse(request, pushPublishAuthenticationToken);\n+\n+        if (failResponse.isPresent()) {\n+            return failResponse.get();\n+        }\n+\n         JSONObject jsonResponse = new JSONObject();\n         IntegrityUtil integrityUtil = new IntegrityUtil();\n-        PublishingEndPointAPI endpointAPI = APILocator.getPublisherEndPointAPI();\n-        PublishingEndPoint requesterEndPoint = null;\n-        try {\n-            requesterEndPoint = endpointAPI.findEnabledSendingEndPointByAddress(remoteIp);\n \n-            if (!BundlePublisherResource.isValidToken(auth_token_digest, remoteIp, requesterEndPoint)) {\n-                return Response.status(HttpStatus.SC_UNAUTHORIZED).build();\n-            }\n-\n-            HibernateUtil.startTransaction();\n-            integrityUtil.fixConflicts(dataToFix, requesterEndPoint.getId(),\n+        try {\n+            final String key = pushPublishAuthenticationToken.isJWTTokenWay() ?\n+                    pushPublishAuthenticationToken.getToken().getId() :\n+                    pushPublishAuthenticationToken.getPublishingEndPoint().getId();\n+            integrityUtil.fixConflicts(dataToFix, key,\n                     IntegrityType.valueOf(type.toUpperCase()));\n-            HibernateUtil.commitTransaction();\n         } catch (DotSecurityException e) {\n             throw new ForbiddenException(e);\n         } catch ( Exception e ) {\n-            try {\n-                HibernateUtil.rollbackTransaction();\n-            } catch (DotHibernateException e1) {\n-                Logger.error(IntegrityResource.class, \"Error while rolling back transaction\", e);\n-            }\n             Logger.error( this.getClass(), \"Error fixing \"+type+\" conflicts from remote\", e );\n             return response( \"Error fixing \"+type+\" conflicts from remote\" , true );\n         } finally {\n-\t\t\ttry {\n-\t\t\t\tif (requesterEndPoint != null) {\n-\t\t\t\t\t// Discard conflicts if successful or failed\n-\t\t\t\t\tintegrityUtil.discardConflicts(requesterEndPoint.getId(),\n-\t\t\t\t\t\t\tIntegrityType.valueOf(type.toUpperCase()));\n-\t\t\t\t}\n-\t\t\t} catch (DotDataException e) {\n-\t\t\t\tLogger.error(this.getClass(), \"ERROR: Table \"\n-\t\t\t\t\t\t+ IntegrityType.valueOf(type.toUpperCase()).getResultsTableName()\n-\t\t\t\t\t\t+ \" could not be cleared on end-point [\" + requesterEndPoint.getId()\n-\t\t\t\t\t\t+ \"]. Please truncate the table data manually.\", e);\n-\t\t\t}\n-\n-\t\t\tHibernateUtil.closeSessionSilently();\n-\t\t}\n+            final String remoteIp = RestEndPointIPUtil.resolveRemoteIp(request);\n+\n+            try {\n+                if (remoteIp != null) {\n+                    // Discard conflicts if successful or failed\n+                    integrityUtil.discardConflicts(remoteIp,\n+                            IntegrityType.valueOf(type.toUpperCase()));\n+                }\n+            } catch (DotDataException e) {\n+                Logger.error(this.getClass(), \"ERROR: Table \"\n+                        + IntegrityType.valueOf(type.toUpperCase()).getResultsTableName()\n+                        + \" could not be cleared on request id [\" + remoteIp\n+                        + \"]. Please truncate the table data manually.\", e);\n+            }\n+        }\n \n         jsonResponse.put( \"success\", true );\n         jsonResponse.put( \"message\", \"Conflicts fixed in Remote Endpoint\" );\n         return response( jsonResponse.toString(), false );\n     }\n \n-\t/**\n-\t * Fixes the data conflicts between the local and remote servers. If the\n-\t * request parameter called <code>whereToFix</code> equals\n-\t * <code>\"local\"</code>, the data correction will take place in local\n-\t * server. If the parameter equals <code>\"remote\"</code>, the fix will take\n-\t * place in remote server.\n-\t *\n-\t * @param httpServletRequest\n-\t *            - The {@link HttpServletRequest} that started the process.\n-\t * @param params\n-\t *            - The execution parameters for running the process: The\n-\t *            end-point ID.\n-\t * @return The REST {@link Response} with the status of the operation.\n-\t * @throws JSONException\n-\t *             An error occurred when generating the JSON response.\n-\t */\n+    private String getRemoteIP(@Context HttpServletRequest request) {", "originalCommit": "31011524a73fdfdaf924361ea51973388817610c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI5NjcxNQ==", "url": "https://github.com/dotCMS/core/pull/19273#discussion_r495296715", "bodyText": "Codacy found an issue: Avoid unused imports such as 'com.dotcms.publisher.pusher.PushPublisher'", "author": "dev-dotcms", "createdAt": "2020-09-25T22:52:33Z", "path": "dotCMS/src/main/java/com/dotcms/auth/providers/jwt/factories/ApiTokenAPI.java", "diffHunk": "@@ -5,6 +5,7 @@\n import com.dotcms.business.CloseDBIfOpened;\n import com.dotcms.business.WrapInTransaction;\n import com.dotcms.enterprise.cluster.ClusterFactory;\n+import com.dotcms.publisher.pusher.PushPublisher;", "originalCommit": "31011524a73fdfdaf924361ea51973388817610c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI5NjcyMg==", "url": "https://github.com/dotCMS/core/pull/19273#discussion_r495296722", "bodyText": "Codacy found an issue: Avoid throwing raw exception types.", "author": "dev-dotcms", "createdAt": "2020-09-25T22:52:34Z", "path": "dotCMS/src/main/java/com/dotcms/rest/IntegrityResource.java", "diffHunk": "@@ -1305,10 +1285,139 @@ private Response response ( String response, Boolean error ) {\n      */\n     private Response response ( String response, Boolean error, String contentType ) {\n         if ( error ) {\n-            return Response.status( HttpStatus.SC_INTERNAL_SERVER_ERROR ).entity( response ).build();\n+            return response(response, HttpStatus.SC_INTERNAL_SERVER_ERROR);\n         } else {\n             return Response.ok( response, contentType ).build();\n         }\n     }\n \n+    private Response response ( String response, int status ) {\n+        return Response.status( status ).entity( response ).build();\n+    }\n+\n+    private class IntegrityDataRequestChecker implements Runnable{\n+\n+        private final User loggedUser;\n+        private final HttpSession session;\n+        private final PublishingEndPoint endpoint;\n+        private final String integrityDataRequestID;\n+\n+        public IntegrityDataRequestChecker(\n+                final User loggedUser,\n+                final HttpSession session,\n+                final PublishingEndPoint endpoint,\n+                final String integrityDataRequestID) {\n+\n+            this.loggedUser = loggedUser;\n+            this.session = session;\n+            this.endpoint = endpoint;\n+            this.integrityDataRequestID = integrityDataRequestID;\n+        }\n+\n+        @CloseDBIfOpened\n+        public void run(){\n+\n+            boolean processing = true;\n+\n+            while(processing) {\n+\n+                Response response = null;\n+\n+                response = statusIntegrityCheckerRequest();\n+\n+                if (response.getStatus() == HttpStatus.SC_OK) {\n+\n+                    processing = false;\n+\n+                    InputStream zipFile = response.readEntity(InputStream.class);\n+                    String outputDir = ConfigUtils.getIntegrityPath() + File.separator + endpoint.getId();\n+\n+                    try {\n+\n+                        IntegrityUtil.unzipFile(zipFile, outputDir);\n+\n+                    } catch (Exception e) {\n+\n+                        //Special handling if the thread was interrupted\n+                        if (e instanceof InterruptedException) {\n+                            //Setting the process status\n+                            setStatus(session, endpoint.getId(), ProcessStatus.CANCELLED, null);\n+                            Logger.debug(IntegrityResource.class, \"Requested interruption of the integrity checking process [unzipping Integrity Data] by the user.\", e);\n+                            throw new RuntimeException(\"Requested interruption of the integrity checking process [unzipping Integrity Data] by the user.\", e);\n+                        }\n+\n+                        //Setting the process status\n+                        setStatus(session, endpoint.getId(), ProcessStatus.ERROR, null);\n+                        Logger.error(IntegrityResource.class, \"Error while unzipping Integrity Data\", e);\n+                        throw new RuntimeException(\"Error while unzipping Integrity Data\", e);\n+                    }\n+\n+                    // set session variable\n+                    // call IntegrityChecker\n+                    boolean conflictPresent = false;\n+\n+                    IntegrityUtil integrityUtil = new IntegrityUtil();\n+                    try {\n+                        integrityUtil.completeDiscardConflicts(endpoint.getId());\n+                        conflictPresent = integrityUtil.completeCheckIntegrity(endpoint.getId());\n+                    } catch (Exception e) {\n+                        //Special handling if the thread was interrupted\n+                        if (e instanceof InterruptedException) {\n+                            //Setting the process status\n+                            setStatus(session, endpoint.getId(), ProcessStatus.CANCELLED, null);\n+                            Logger.debug(IntegrityResource.class, \"Requested interruption of the integrity checking process by the user.\", e);\n+                            throw new RuntimeException(\"Requested interruption of the integrity checking process by the user.\", e);", "originalCommit": "31011524a73fdfdaf924361ea51973388817610c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI5NjcyNg==", "url": "https://github.com/dotCMS/core/pull/19273#discussion_r495296726", "bodyText": "Codacy found an issue: An instanceof check is being performed on the caught exception.  Create a separate catch clause for this exception type.", "author": "dev-dotcms", "createdAt": "2020-09-25T22:52:36Z", "path": "dotCMS/src/main/java/com/dotcms/rest/IntegrityResource.java", "diffHunk": "@@ -1305,10 +1285,139 @@ private Response response ( String response, Boolean error ) {\n      */\n     private Response response ( String response, Boolean error, String contentType ) {\n         if ( error ) {\n-            return Response.status( HttpStatus.SC_INTERNAL_SERVER_ERROR ).entity( response ).build();\n+            return response(response, HttpStatus.SC_INTERNAL_SERVER_ERROR);\n         } else {\n             return Response.ok( response, contentType ).build();\n         }\n     }\n \n+    private Response response ( String response, int status ) {\n+        return Response.status( status ).entity( response ).build();\n+    }\n+\n+    private class IntegrityDataRequestChecker implements Runnable{\n+\n+        private final User loggedUser;\n+        private final HttpSession session;\n+        private final PublishingEndPoint endpoint;\n+        private final String integrityDataRequestID;\n+\n+        public IntegrityDataRequestChecker(\n+                final User loggedUser,\n+                final HttpSession session,\n+                final PublishingEndPoint endpoint,\n+                final String integrityDataRequestID) {\n+\n+            this.loggedUser = loggedUser;\n+            this.session = session;\n+            this.endpoint = endpoint;\n+            this.integrityDataRequestID = integrityDataRequestID;\n+        }\n+\n+        @CloseDBIfOpened\n+        public void run(){\n+\n+            boolean processing = true;\n+\n+            while(processing) {\n+\n+                Response response = null;\n+\n+                response = statusIntegrityCheckerRequest();\n+\n+                if (response.getStatus() == HttpStatus.SC_OK) {\n+\n+                    processing = false;\n+\n+                    InputStream zipFile = response.readEntity(InputStream.class);\n+                    String outputDir = ConfigUtils.getIntegrityPath() + File.separator + endpoint.getId();\n+\n+                    try {\n+\n+                        IntegrityUtil.unzipFile(zipFile, outputDir);\n+\n+                    } catch (Exception e) {\n+\n+                        //Special handling if the thread was interrupted\n+                        if (e instanceof InterruptedException) {", "originalCommit": "31011524a73fdfdaf924361ea51973388817610c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI5NjczNw==", "url": "https://github.com/dotCMS/core/pull/19273#discussion_r495296737", "bodyText": "Codacy found an issue: Avoid instantiating Long objects.Call Long.valueOf() instead", "author": "dev-dotcms", "createdAt": "2020-09-25T22:52:37Z", "path": "dotCMS/src/integration-test/java/com/dotmarketing/startup/runonce/Task05390RemoveEndpointIdForeignKeyInIntegrityResolverTablesIntegrationTest.java", "diffHunk": "@@ -0,0 +1,208 @@\n+package com.dotmarketing.startup.runonce;\n+\n+import com.dotcms.util.IntegrationTestInitService;\n+import com.dotmarketing.common.db.DotConnect;\n+import com.dotmarketing.common.db.DotDatabaseMetaData;\n+import com.dotmarketing.db.DbConnectionFactory;\n+import com.dotmarketing.exception.DotDataException;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.sql.Connection;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.dotcms.util.CollectionsUtils.list;\n+import static com.dotcms.util.CollectionsUtils.map;\n+import static org.junit.Assert.assertEquals;\n+\n+\n+public class Task05390RemoveEndpointIdForeignKeyInIntegrityResolverTablesIntegrationTest {\n+\n+    @BeforeClass\n+    public static void prepare() throws Exception {\n+        // Setting web app environment\n+        IntegrationTestInitService.getInstance().init();\n+    }\n+\n+    /**\n+     * Method to Test: {@link Task05390RemoveEndpointIdForeignKeyInIntegrityResolverTables#executeUpgrade()}\n+     * When: Run the Upgrade Task\n+     * Should: Should remove the foreign key to all the Integrity Resolver tables and rename the column endpoint_id\n+     * The Integrity Resolver tables are:\n+     * - cms_roles_ir\n+     * - folders_ir\n+     * - structures_ir\n+     * - htmlpages_ir\n+     * - fileassets_ir\n+     *\n+     * After remove the constraint you should be allow to insert register in this table without has any register in publishing_end_point\n+     */\n+    @Test\n+    public void constraintShouldNotExists() throws DotDataException, SQLException {\n+\n+        final String endpointId = insertPublishingEndPoint();\n+        insertFolderIntegrityResolver(endpointId);\n+        insertPageIntegrityResolver(endpointId);\n+        insertFileAssetIntegrityResolver(endpointId);\n+        insertRolesIntegrityResolver(endpointId);\n+        insertStructuresIntegrityResolver(endpointId);\n+\n+        final Task05390RemoveEndpointIdForeignKeyInIntegrityResolverTables task05390RemoveEndpointIdForeignKeyInIntegrityResolverTables =\n+                new Task05390RemoveEndpointIdForeignKeyInIntegrityResolverTables();\n+\n+        task05390RemoveEndpointIdForeignKeyInIntegrityResolverTables.executeUpgrade();\n+\n+        insertFolderIntegrityResolver(\"anyIP\");\n+        insertPageIntegrityResolver(\"anyIP\");\n+        insertFileAssetIntegrityResolver(\"anyIP\");\n+        insertRolesIntegrityResolver(\"anyIP\");\n+        insertStructuresIntegrityResolver(\"anyIP\");\n+\n+        checkColumnsSize();\n+    }\n+\n+    private void checkColumnsSize() throws SQLException {\n+        final List<String> tables = list(\n+                \"folders_ir\",\n+                \"structures_ir\",\n+                \"htmlpages_ir\",\n+                \"fileassets_ir\",\n+                \"cms_roles_ir\"\n+        );\n+\n+        for (String table : tables) {\n+            checkColumnSize(table);\n+        }\n+    }\n+\n+    private void checkColumnSize(final String tableName) throws SQLException {\n+        final Connection connection = DbConnectionFactory.getConnection();\n+        final ResultSet resultSet = DotDatabaseMetaData.getColumnsMetaData(connection, tableName);\n+\n+        while (resultSet.next()) {\n+\n+            final String columnName = resultSet.getString(\"COLUMN_NAME\");\n+\n+            if (columnName.equals(\"endpoint_Id\")) {\n+                final int columnSize = resultSet.getInt(\"COLUMN_SIZE\");\n+                assertEquals(columnSize, 40);\n+            }\n+\n+        }\n+    }\n+\n+    private String insertPublishingEndPoint() throws DotDataException {\n+\n+        DotConnect dc = new DotConnect();\n+        dc.setSQL(\"INSERT INTO publishing_end_point \" +\n+                \"(id, group_id, server_name, address, port, protocol, enabled, auth_key, sending) \" +\n+                \"values(?,?,?,?,?,?,?,?,?)\"\n+        );\n+\n+        final String id = String.valueOf(System.currentTimeMillis());\n+\n+        dc.addParam(id);\n+        dc.addParam(\"group_id\");\n+        dc.addParam(\"server_name\");\n+        dc.addParam(\"address\");\n+        dc.addParam(\"port\");\n+        dc.addParam(\"protocol\");\n+        dc.addParam(true);\n+        dc.addParam(\"auth_key\");\n+        dc.addParam(true);\n+\n+        dc.loadResult();\n+\n+        return id;\n+    }\n+\n+    private void insertFolderIntegrityResolver(final String remoteIP) throws DotDataException {\n+\n+        DotConnect dc = new DotConnect();\n+        dc.setSQL(\n+                \"INSERT INTO folders_ir (local_inode, remote_inode, local_identifier, remote_identifier, endpoint_id) values(?,?,?,?,?)\"\n+        );\n+\n+        dc.addParam(\"localInode\" + System.currentTimeMillis());\n+        dc.addParam(\"remoteInode\" + System.currentTimeMillis());\n+        dc.addParam(\"localIdentifier\" + System.currentTimeMillis());\n+        dc.addParam(\"remoteIdentifier\" + System.currentTimeMillis());\n+        dc.addParam(remoteIP);\n+\n+        dc.loadResult();\n+    }\n+\n+    private void insertPageIntegrityResolver(final String remoteIP) throws DotDataException {\n+\n+        DotConnect dc = new DotConnect();\n+        dc.setSQL(\"INSERT INTO htmlpages_ir \" +\n+                \"(local_working_inode, remote_working_inode, local_live_inode, remote_live_inode, local_identifier, remote_identifier, html_page, endpoint_id, language_id) \" +\n+                \"values(?,?,?,?,?,?,?,?,?)\");\n+\n+        dc.addParam(\"local_working_inode\" + System.currentTimeMillis());\n+        dc.addParam(\"remote_working_inode\" + System.currentTimeMillis());\n+        dc.addParam(\"local_live_inode\" + System.currentTimeMillis());\n+        dc.addParam(\"remote_live_inode\" + System.currentTimeMillis());\n+        dc.addParam(\"local_identifier\" + System.currentTimeMillis());\n+        dc.addParam(\"remote_identifier\" + System.currentTimeMillis());\n+        dc.addParam(\"html_page\" + System.currentTimeMillis());\n+        dc.addParam(remoteIP);\n+        dc.addParam(new Long(\"1\"));", "originalCommit": "31011524a73fdfdaf924361ea51973388817610c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI5Njc1Ng==", "url": "https://github.com/dotCMS/core/pull/19273#discussion_r495296756", "bodyText": "Codacy found an issue: Avoid variables with short names like dc", "author": "dev-dotcms", "createdAt": "2020-09-25T22:52:38Z", "path": "dotCMS/src/integration-test/java/com/dotmarketing/startup/runonce/Task05390RemoveEndpointIdForeignKeyInIntegrityResolverTablesIntegrationTest.java", "diffHunk": "@@ -0,0 +1,208 @@\n+package com.dotmarketing.startup.runonce;\n+\n+import com.dotcms.util.IntegrationTestInitService;\n+import com.dotmarketing.common.db.DotConnect;\n+import com.dotmarketing.common.db.DotDatabaseMetaData;\n+import com.dotmarketing.db.DbConnectionFactory;\n+import com.dotmarketing.exception.DotDataException;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.sql.Connection;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.dotcms.util.CollectionsUtils.list;\n+import static com.dotcms.util.CollectionsUtils.map;\n+import static org.junit.Assert.assertEquals;\n+\n+\n+public class Task05390RemoveEndpointIdForeignKeyInIntegrityResolverTablesIntegrationTest {\n+\n+    @BeforeClass\n+    public static void prepare() throws Exception {\n+        // Setting web app environment\n+        IntegrationTestInitService.getInstance().init();\n+    }\n+\n+    /**\n+     * Method to Test: {@link Task05390RemoveEndpointIdForeignKeyInIntegrityResolverTables#executeUpgrade()}\n+     * When: Run the Upgrade Task\n+     * Should: Should remove the foreign key to all the Integrity Resolver tables and rename the column endpoint_id\n+     * The Integrity Resolver tables are:\n+     * - cms_roles_ir\n+     * - folders_ir\n+     * - structures_ir\n+     * - htmlpages_ir\n+     * - fileassets_ir\n+     *\n+     * After remove the constraint you should be allow to insert register in this table without has any register in publishing_end_point\n+     */\n+    @Test\n+    public void constraintShouldNotExists() throws DotDataException, SQLException {\n+\n+        final String endpointId = insertPublishingEndPoint();\n+        insertFolderIntegrityResolver(endpointId);\n+        insertPageIntegrityResolver(endpointId);\n+        insertFileAssetIntegrityResolver(endpointId);\n+        insertRolesIntegrityResolver(endpointId);\n+        insertStructuresIntegrityResolver(endpointId);\n+\n+        final Task05390RemoveEndpointIdForeignKeyInIntegrityResolverTables task05390RemoveEndpointIdForeignKeyInIntegrityResolverTables =\n+                new Task05390RemoveEndpointIdForeignKeyInIntegrityResolverTables();\n+\n+        task05390RemoveEndpointIdForeignKeyInIntegrityResolverTables.executeUpgrade();\n+\n+        insertFolderIntegrityResolver(\"anyIP\");\n+        insertPageIntegrityResolver(\"anyIP\");\n+        insertFileAssetIntegrityResolver(\"anyIP\");\n+        insertRolesIntegrityResolver(\"anyIP\");\n+        insertStructuresIntegrityResolver(\"anyIP\");\n+\n+        checkColumnsSize();\n+    }\n+\n+    private void checkColumnsSize() throws SQLException {\n+        final List<String> tables = list(\n+                \"folders_ir\",\n+                \"structures_ir\",\n+                \"htmlpages_ir\",\n+                \"fileassets_ir\",\n+                \"cms_roles_ir\"\n+        );\n+\n+        for (String table : tables) {\n+            checkColumnSize(table);\n+        }\n+    }\n+\n+    private void checkColumnSize(final String tableName) throws SQLException {\n+        final Connection connection = DbConnectionFactory.getConnection();\n+        final ResultSet resultSet = DotDatabaseMetaData.getColumnsMetaData(connection, tableName);\n+\n+        while (resultSet.next()) {\n+\n+            final String columnName = resultSet.getString(\"COLUMN_NAME\");\n+\n+            if (columnName.equals(\"endpoint_Id\")) {\n+                final int columnSize = resultSet.getInt(\"COLUMN_SIZE\");\n+                assertEquals(columnSize, 40);\n+            }\n+\n+        }\n+    }\n+\n+    private String insertPublishingEndPoint() throws DotDataException {\n+\n+        DotConnect dc = new DotConnect();", "originalCommit": "31011524a73fdfdaf924361ea51973388817610c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI5Njc2Mg==", "url": "https://github.com/dotCMS/core/pull/19273#discussion_r495296762", "bodyText": "Codacy found an issue: This final field could be made static", "author": "dev-dotcms", "createdAt": "2020-09-25T22:52:39Z", "path": "dotCMS/src/main/java/com/dotcms/publisher/pusher/AuthCredentialPushPublishUtil.java", "diffHunk": "@@ -0,0 +1,208 @@\n+package com.dotcms.publisher.pusher;\n+\n+import com.dotcms.auth.providers.jwt.JsonWebTokenAuthCredentialProcessor;\n+import com.dotcms.auth.providers.jwt.beans.JWToken;\n+import com.dotcms.auth.providers.jwt.services.JsonWebTokenAuthCredentialProcessorImpl;\n+import com.dotcms.publisher.endpoint.bean.PublishingEndPoint;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.cms.factories.PublicEncryptionFactory;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.util.Config;\n+import com.liferay.portal.model.User;\n+import io.jsonwebtoken.*;\n+import org.apache.commons.lang.StringUtils;\n+import org.glassfish.jersey.server.ContainerRequest;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import java.io.IOException;\n+import java.util.Optional;\n+\n+/**\n+ * Singleton class to provide util method to Push Publish authentication, it support two authentication methods:\n+ * JWToken and Auth key set in the {@link com.dotcms.publisher.endpoint.bean.impl.PushPublishingEndPoint},\n+ * if the config property 'USE_JWT_TOKEN_IN_PUSH_PUBLISH' is set to true (default value)\n+ * it is going to use JWT token, but if the config property is set to false or the JWT token fails then auth key is going to use\n+ * */\n+public enum AuthCredentialPushPublishUtil {\n+    INSTANCE;\n+\n+    private final String BEARER = \"Bearer \";", "originalCommit": "31011524a73fdfdaf924361ea51973388817610c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI5Njc3NA==", "url": "https://github.com/dotCMS/core/pull/19273#discussion_r495296774", "bodyText": "Codacy found an issue: Avoid unused imports such as 'javax.servlet.http.HttpServletResponse'", "author": "dev-dotcms", "createdAt": "2020-09-25T22:52:40Z", "path": "dotCMS/src/main/java/com/dotcms/rest/PushPublishResourceUtil.java", "diffHunk": "@@ -0,0 +1,88 @@\n+package com.dotcms.rest;\n+\n+import com.dotcms.publisher.pusher.AuthCredentialPushPublishUtil;\n+import com.dotcms.repackage.org.apache.http.HttpStatus;\n+import com.dotcms.util.CollectionsUtils;\n+import com.dotcms.util.HttpRequestDataUtil;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.UtilMethods;\n+import com.liferay.portal.model.User;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;", "originalCommit": "31011524a73fdfdaf924361ea51973388817610c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}