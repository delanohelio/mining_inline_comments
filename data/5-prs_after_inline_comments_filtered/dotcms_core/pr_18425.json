{"pr_number": 18425, "pr_title": "#18424 : Content Types from very old customer datasets present lots o\u2026", "pr_createdAt": "2020-05-01T21:12:09Z", "pr_url": "https://github.com/dotCMS/core/pull/18425", "timeline": [{"oid": "50b2d4e566d04d2060da6b51f729c060e4a8df68", "url": "https://github.com/dotCMS/core/commit/50b2d4e566d04d2060da6b51f729c060e4a8df68", "message": "#18424 : Content Types from very old customer datasets present lots of data arrangements and values that are no longer valid. This is causing the reindex to fail and get stuck. The code changes in this PR are the following:\n\n1. The `ContentletIndexAPIImpl` correctly catches any error during the indexation of a contentlet. Therefore, a failing contentlet will be flagged as failed now, instead of keeping the reindex running endlessly.\n2. More useful logging in the `ImplClassFieldTransformer` class.\n3. Handling NPE situations where the `index_val` column in the `dist_reindex_journal` table might contain null values.\n4. Fixing code to declare failed records as the ones whose `priority` is GREATER than 300, not GREATER OR EQUAL.", "committedDate": "2020-05-01T21:11:14Z", "type": "commit"}, {"oid": "5178bc1c886eec003abe5c068ee5c163d16a0ff8", "url": "https://github.com/dotCMS/core/commit/5178bc1c886eec003abe5c068ee5c163d16a0ff8", "message": "#18424 Unifying the way failed records are fetched. Besides, a couple of ITs were implemented", "committedDate": "2020-05-15T20:54:56Z", "type": "commit"}, {"oid": "d5d7299b3d79ce4cd23c8e335ce48bfe15f4cf94", "url": "https://github.com/dotCMS/core/commit/d5d7299b3d79ce4cd23c8e335ce48bfe15f4cf94", "message": "Merge branch 'master' of https://github.com/dotCMS/core into issue-reindex-gets-stuck-on-specific-failure-scenarios", "committedDate": "2020-05-15T22:09:42Z", "type": "commit"}, {"oid": "0be79330c709263c21998581b8f5024d51dc9963", "url": "https://github.com/dotCMS/core/commit/0be79330c709263c21998581b8f5024d51dc9963", "message": "#18424 Applying code review suggestions", "committedDate": "2020-05-15T23:02:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA4MzE3MQ==", "url": "https://github.com/dotCMS/core/pull/18425#discussion_r426083171", "bodyText": "Issue found: Avoid catching generic exceptions such as NullPointerException, RuntimeException, Exception in try-catch block", "author": "dev-dotcms", "createdAt": "2020-05-15T23:08:41Z", "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ContentletIndexAPIImpl.java", "diffHunk": "@@ -758,37 +758,43 @@ public BulkRequest appendBulkRequest(BulkRequest bulkRequest, final ReindexEntry\n         return bulkIndexWrapper.getRequestBuilder();\n     }\n \n+    /**\n+     * Generates an ES bulk request that adds the specified {@link ReindexEntry} to the ElasticSearch index.\n+     *\n+     * @param bulk The {@link BulkIndexWrapper} object containing the Bulk Index Request.\n+     * @param idx  The entry containing the information of the Contentlet that will be indexed.\n+     *\n+     * @throws DotDataException An error occurred when processing this request.\n+     */\n     @CloseDBIfOpened\n-    public void appendBulkRequest(BulkIndexWrapper bulk, final ReindexEntry idx) throws DotDataException {\n-        List<ContentletVersionInfo> versions = APILocator.getVersionableAPI().findContentletVersionInfos(idx.getIdentToIndex());\n-\n+    public void appendBulkRequest(final BulkIndexWrapper bulk, final ReindexEntry idx) throws DotDataException {\n+        final List<ContentletVersionInfo> versions = APILocator.getVersionableAPI().findContentletVersionInfos(idx.getIdentToIndex());\n         final Map<String, Contentlet> inodes = new HashMap<>();\n-\n-        for (ContentletVersionInfo cvi : versions) {\n-            final String workingInode = cvi.getWorkingInode();\n-            final String liveInode = cvi.getLiveInode();\n-            inodes.put(workingInode, APILocator.getContentletAPI().findInDb(workingInode).orElse(null));\n-            if (UtilMethods.isSet(liveInode) && !inodes.containsKey(liveInode)) {\n-                inodes.put(liveInode, APILocator.getContentletAPI().findInDb(liveInode).orElse(null));\n+        try {\n+            for (final ContentletVersionInfo cvi : versions) {\n+                final String workingInode = cvi.getWorkingInode();\n+                final String liveInode = cvi.getLiveInode();\n+                inodes.put(workingInode, APILocator.getContentletAPI().findInDb(workingInode).orElse(null));\n+                if (UtilMethods.isSet(liveInode) && !inodes.containsKey(liveInode)) {\n+                    inodes.put(liveInode, APILocator.getContentletAPI().findInDb(liveInode).orElse(null));\n+                }\n             }\n-        }\n-        inodes.values().removeIf(Objects::isNull);\n-        if (inodes.isEmpty()) {\n-            //If there is no content for this entry, it should be deleted to avoid future attempts that will fail also\n-            APILocator.getReindexQueueAPI().deleteReindexEntry(idx);\n-            Logger.debug(this, \"unable to find versions for content id:\" + idx.getIdentToIndex());\n-        }\n-        for (Contentlet contentlet : inodes.values()) {\n-            Logger.debug(this, \"indexing: id:\" + contentlet.getInode() + \" priority: \" + idx.getPriority());\n-            contentlet.setIndexPolicy(IndexPolicy.DEFER);\n-\n-            try {\n+            inodes.values().removeIf(Objects::isNull);\n+            if (inodes.isEmpty()) {\n+                // If there is no content for this entry, it should be deleted to avoid future attempts that will fail also\n+                APILocator.getReindexQueueAPI().deleteReindexEntry(idx);\n+                Logger.debug(this, String.format(\"Unable to find versions for content id: '%s'. Deleting content \" +\n+                        \"reindex entry.\", idx.getIdentToIndex()));\n+            }\n+            for (final Contentlet contentlet : inodes.values()) {\n+                Logger.debug(this, String.format(\"Indexing id: '%s', priority: '%s'\", contentlet.getInode(), idx\n+                        .getPriority()));\n+                contentlet.setIndexPolicy(IndexPolicy.DEFER);\n                 addBulkRequest(bulk, ImmutableList.of(contentlet), idx.isReindex());\n-\n-            } catch (Exception e) {\n-                APILocator.getReindexQueueAPI().markAsFailed(idx, e.getMessage());\n-\n             }\n+        } catch (final Exception e) {", "originalCommit": "0be79330c709263c21998581b8f5024d51dc9963", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA4MzE3NA==", "url": "https://github.com/dotCMS/core/pull/18425#discussion_r426083174", "bodyText": "Issue found: A method/constructor should not explicitly throw java.lang.Exception", "author": "dev-dotcms", "createdAt": "2020-05-15T23:08:42Z", "path": "dotCMS/src/integration-test/java/com/dotmarketing/common/reindex/ReindexQueueAPITest.java", "diffHunk": "@@ -0,0 +1,121 @@\n+package com.dotmarketing.common.reindex;\n+\n+import static com.dotmarketing.common.reindex.ReindexQueueFactory.REINDEX_MAX_FAILURE_ATTEMPTS;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import com.dotcms.util.IntegrationTestInitService;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.common.reindex.ReindexQueueFactory.Priority;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.util.UUIDGenerator;\n+import com.dotmarketing.util.UtilMethods;\n+import java.util.List;\n+import java.util.Map;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+public class ReindexQueueAPITest {\n+\n+    private static ReindexQueueAPI reindexQueueAPI;\n+\n+    @BeforeClass\n+    public static void prepare() throws Exception {", "originalCommit": "0be79330c709263c21998581b8f5024d51dc9963", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA4MzE4Mg==", "url": "https://github.com/dotCMS/core/pull/18425#discussion_r426083182", "bodyText": "Issue found: Avoid catching generic exceptions such as NullPointerException, RuntimeException, Exception in try-catch block", "author": "dev-dotcms", "createdAt": "2020-05-15T23:08:43Z", "path": "dotCMS/src/main/java/com/dotcms/contenttype/transform/field/ImplClassFieldTransformer.java", "diffHunk": "@@ -23,28 +25,39 @@ public ImplClassFieldTransformer(final List<Field> fields) {\n \n   @Override\n   public Field from() throws DotStateException {\n-    if (this.genericFields.size() == 0)\n-      throw new DotStateException(\"0 results\");\n-    Field field = impleClass(this.genericFields.get(0));\n+    if (this.genericFields.size() == 0) {\n+        throw new DotStateException(\"There are no fields to transform!\");\n+    }\n+    final Field field = impleClass(this.genericFields.get(0));\n     return field;\n \n   }\n \n   private static Field impleClass(final Field genericField) {\n-    FieldBuilder builder = null;\n+    FieldBuilder builder;\n     try {\n       builder = FieldBuilder.builder(genericField);\n       return builder.build();\n-    } catch (Exception e) {\n-      throw new DotStateException(e.getMessage(), e);\n+    } catch (final Exception e) {", "originalCommit": "0be79330c709263c21998581b8f5024d51dc9963", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}