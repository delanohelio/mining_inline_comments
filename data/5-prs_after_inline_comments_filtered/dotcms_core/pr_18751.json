{"pr_number": 18751, "pr_title": "Issue 18689 move index dynamic mappings from json to code", "pr_createdAt": "2020-06-22T23:16:35Z", "pr_url": "https://github.com/dotCMS/core/pull/18751", "timeline": [{"oid": "0bc3e5f319b0cdbc08a1bb75ed9c64439dab1e6c", "url": "https://github.com/dotCMS/core/commit/0bc3e5f319b0cdbc08a1bb75ed9c64439dab1e6c", "message": "#18689 Moving logic that adds ES custom mappings to a helper class", "committedDate": "2020-06-22T23:08:35Z", "type": "commit"}, {"oid": "50a841fe2aeb63334560a2b0215e0c678fc74e8c", "url": "https://github.com/dotCMS/core/commit/50a841fe2aeb63334560a2b0215e0c678fc74e8c", "message": "#18689 Moving logic that adds ES custom mappings to a helper class", "committedDate": "2020-06-22T23:09:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDI1NDYzMw==", "url": "https://github.com/dotCMS/core/pull/18751#discussion_r444254633", "bodyText": "doc", "author": "freddyucv", "createdAt": "2020-06-23T14:11:03Z", "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/util/ESMappingUtilHelper.java", "diffHunk": "@@ -0,0 +1,268 @@\n+package com.dotcms.content.elasticsearch.util;\n+\n+import com.dotcms.api.system.event.message.MessageSeverity;\n+import com.dotcms.api.system.event.message.MessageType;\n+import com.dotcms.api.system.event.message.SystemMessageEventUtil;\n+import com.dotcms.api.system.event.message.builder.SystemMessageBuilder;\n+import com.dotcms.content.elasticsearch.business.ESMappingAPIImpl;\n+import com.dotcms.contenttype.business.ContentTypeAPI;\n+import com.dotcms.contenttype.business.FieldFactory;\n+import com.dotcms.contenttype.model.field.DataTypes;\n+import com.dotcms.contenttype.model.field.DateField;\n+import com.dotcms.contenttype.model.field.DateTimeField;\n+import com.dotcms.contenttype.model.field.Field;\n+import com.dotcms.contenttype.model.field.FieldVariable;\n+import com.dotcms.contenttype.model.field.RadioField;\n+import com.dotcms.contenttype.model.field.SelectField;\n+import com.dotcms.contenttype.model.field.TextField;\n+import com.dotcms.contenttype.model.field.TimeField;\n+import com.dotcms.contenttype.model.type.ContentType;\n+import com.dotcms.repackage.com.google.common.annotations.VisibleForTesting;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.FactoryLocator;\n+import com.dotmarketing.business.RelationshipAPI;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.portlets.structure.model.Relationship;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.json.JSONObject;\n+import com.liferay.portal.language.LanguageException;\n+import com.liferay.portal.language.LanguageUtil;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+\n+public class ESMappingUtilHelper {", "originalCommit": "50a841fe2aeb63334560a2b0215e0c678fc74e8c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQxOTgyOA==", "url": "https://github.com/dotCMS/core/pull/18751#discussion_r450419828", "bodyText": "Done", "author": "nollymar", "createdAt": "2020-07-06T18:57:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDI1NDYzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDI1ODcyOQ==", "url": "https://github.com/dotCMS/core/pull/18751#discussion_r444258729", "bodyText": "there is a class for ES util methods\nhttps://github.com/dotCMS/core/blob/4b32284db0ea826ef6cff4e6afe857593635f1a8/dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ElasticsearchUtil.java\nI don't know if we need both class", "author": "freddyucv", "createdAt": "2020-06-23T14:16:31Z", "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/util/ESMappingUtilHelper.java", "diffHunk": "@@ -0,0 +1,268 @@\n+package com.dotcms.content.elasticsearch.util;", "originalCommit": "50a841fe2aeb63334560a2b0215e0c678fc74e8c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQxODc1NQ==", "url": "https://github.com/dotCMS/core/pull/18751#discussion_r450418755", "bodyText": "I prefer to keep them separate, because this new helper is focused on fields mappings only", "author": "nollymar", "createdAt": "2020-07-06T18:55:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDI1ODcyOQ=="}], "type": "inlineReview"}, {"oid": "d976368765d1b8f8d01236c71001769188ffb6e2", "url": "https://github.com/dotCMS/core/commit/d976368765d1b8f8d01236c71001769188ffb6e2", "message": "Merge branch 'master' of https://github.com/dotCMS/core into issue-18689-move-index-dynamic-mappings-from-JSON-to-code", "committedDate": "2020-07-01T15:41:22Z", "type": "commit"}, {"oid": "69e8fc1c3189859310a05f008ce0f725abb6f107", "url": "https://github.com/dotCMS/core/commit/69e8fc1c3189859310a05f008ce0f725abb6f107", "message": "#18689 New ITs", "committedDate": "2020-07-06T18:51:18Z", "type": "commit"}, {"oid": "bf91d2aa505397a61d9e62eb8fe741540cf859d6", "url": "https://github.com/dotCMS/core/commit/bf91d2aa505397a61d9e62eb8fe741540cf859d6", "message": "#18689 Javadocs", "committedDate": "2020-07-06T18:56:58Z", "type": "commit"}, {"oid": "c682aabf55afb9d6766acc5a3ce6dea8c52ff3b7", "url": "https://github.com/dotCMS/core/commit/c682aabf55afb9d6766acc5a3ce6dea8c52ff3b7", "message": "Merge branch 'master' of https://github.com/dotCMS/core into issue-18689-move-index-dynamic-mappings-from-JSON-to-code", "committedDate": "2020-07-07T16:06:14Z", "type": "commit"}, {"oid": "59a73303fa307b46f828711aef9bdbe5789c4821", "url": "https://github.com/dotCMS/core/commit/59a73303fa307b46f828711aef9bdbe5789c4821", "message": "#18689 Changing logic to consider es-content.mapping.json when a  mapping is set for a field", "committedDate": "2020-07-08T19:07:24Z", "type": "commit"}, {"oid": "f745a7c8bba59627882329a9cd35639b37132e94", "url": "https://github.com/dotCMS/core/commit/f745a7c8bba59627882329a9cd35639b37132e94", "message": "#18689 Removing duplicate", "committedDate": "2020-07-08T19:07:49Z", "type": "commit"}, {"oid": "b32523515110764a727ef968031e953d53fc981e", "url": "https://github.com/dotCMS/core/commit/b32523515110764a727ef968031e953d53fc981e", "message": "#18689 Moving test to ESMappingUtilHelperTest class", "committedDate": "2020-07-08T19:08:23Z", "type": "commit"}, {"oid": "7b6d8baa0129cb219d9238e647c5d61dc42f4a90", "url": "https://github.com/dotCMS/core/commit/7b6d8baa0129cb219d9238e647c5d61dc42f4a90", "message": "#18689 Including useful library to filter data from JSON objects", "committedDate": "2020-07-08T19:09:58Z", "type": "commit"}, {"oid": "bcfa64f12d7f9a0e23bfb087922f7e5cbe025b1e", "url": "https://github.com/dotCMS/core/commit/bcfa64f12d7f9a0e23bfb087922f7e5cbe025b1e", "message": "#18689 Removing unused property", "committedDate": "2020-07-08T19:10:18Z", "type": "commit"}, {"oid": "eea7d5311e4560938664ee74e1e95ff242bfa58f", "url": "https://github.com/dotCMS/core/commit/eea7d5311e4560938664ee74e1e95ff242bfa58f", "message": "Merge branch 'master' of https://github.com/dotCMS/core into issue-18689-move-index-dynamic-mappings-from-JSON-to-code", "committedDate": "2020-07-08T19:10:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ2MDM5MQ==", "url": "https://github.com/dotCMS/core/pull/18751#discussion_r452460391", "bodyText": "why static? they should be just final. Since it is a singleton you will keep just one reference anyhow", "author": "jdotcms", "createdAt": "2020-07-09T20:06:35Z", "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/util/ESMappingUtilHelper.java", "diffHunk": "@@ -0,0 +1,329 @@\n+package com.dotcms.content.elasticsearch.util;\n+\n+import com.dotcms.api.system.event.message.MessageSeverity;\n+import com.dotcms.api.system.event.message.MessageType;\n+import com.dotcms.api.system.event.message.SystemMessageEventUtil;\n+import com.dotcms.api.system.event.message.builder.SystemMessageBuilder;\n+import com.dotcms.content.elasticsearch.business.ESIndexAPI;\n+import com.dotcms.content.elasticsearch.business.ESMappingAPIImpl;\n+import com.dotcms.contenttype.business.ContentTypeAPI;\n+import com.dotcms.contenttype.business.FieldFactory;\n+import com.dotcms.contenttype.model.field.DataTypes;\n+import com.dotcms.contenttype.model.field.DateField;\n+import com.dotcms.contenttype.model.field.DateTimeField;\n+import com.dotcms.contenttype.model.field.Field;\n+import com.dotcms.contenttype.model.field.FieldVariable;\n+import com.dotcms.contenttype.model.field.RadioField;\n+import com.dotcms.contenttype.model.field.SelectField;\n+import com.dotcms.contenttype.model.field.TextAreaField;\n+import com.dotcms.contenttype.model.field.TextField;\n+import com.dotcms.contenttype.model.field.TimeField;\n+import com.dotcms.contenttype.model.field.WysiwygField;\n+import com.dotcms.contenttype.model.type.ContentType;\n+import com.dotcms.repackage.com.google.common.annotations.VisibleForTesting;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.FactoryLocator;\n+import com.dotmarketing.business.RelationshipAPI;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.portlets.structure.model.Relationship;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.json.JSONObject;\n+import com.jayway.jsonpath.JsonPath;\n+import com.liferay.portal.language.LanguageException;\n+import com.liferay.portal.language.LanguageUtil;\n+import com.liferay.util.StringPool;\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.URL;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper class responsible of setting Elasticsearch mapping for content type fields\n+ * @author nollymar\n+ */\n+public class ESMappingUtilHelper {\n+\n+    private static ContentTypeAPI contentTypeAPI;", "originalCommit": "eea7d5311e4560938664ee74e1e95ff242bfa58f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ2MzA4Mw==", "url": "https://github.com/dotCMS/core/pull/18751#discussion_r452463083", "bodyText": "The same for the methods, since the singleton is a self instance, methods should be instance not static", "author": "jdotcms", "createdAt": "2020-07-09T20:12:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ2MDM5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ3NDk5Nw==", "url": "https://github.com/dotCMS/core/pull/18751#discussion_r452474997", "bodyText": "Done", "author": "nollymar", "createdAt": "2020-07-09T20:36:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ2MDM5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ2MTM3MA==", "url": "https://github.com/dotCMS/core/pull/18751#discussion_r452461370", "bodyText": "missing db closed here annotation", "author": "jdotcms", "createdAt": "2020-07-09T20:08:40Z", "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/util/ESMappingUtilHelper.java", "diffHunk": "@@ -0,0 +1,329 @@\n+package com.dotcms.content.elasticsearch.util;\n+\n+import com.dotcms.api.system.event.message.MessageSeverity;\n+import com.dotcms.api.system.event.message.MessageType;\n+import com.dotcms.api.system.event.message.SystemMessageEventUtil;\n+import com.dotcms.api.system.event.message.builder.SystemMessageBuilder;\n+import com.dotcms.content.elasticsearch.business.ESIndexAPI;\n+import com.dotcms.content.elasticsearch.business.ESMappingAPIImpl;\n+import com.dotcms.contenttype.business.ContentTypeAPI;\n+import com.dotcms.contenttype.business.FieldFactory;\n+import com.dotcms.contenttype.model.field.DataTypes;\n+import com.dotcms.contenttype.model.field.DateField;\n+import com.dotcms.contenttype.model.field.DateTimeField;\n+import com.dotcms.contenttype.model.field.Field;\n+import com.dotcms.contenttype.model.field.FieldVariable;\n+import com.dotcms.contenttype.model.field.RadioField;\n+import com.dotcms.contenttype.model.field.SelectField;\n+import com.dotcms.contenttype.model.field.TextAreaField;\n+import com.dotcms.contenttype.model.field.TextField;\n+import com.dotcms.contenttype.model.field.TimeField;\n+import com.dotcms.contenttype.model.field.WysiwygField;\n+import com.dotcms.contenttype.model.type.ContentType;\n+import com.dotcms.repackage.com.google.common.annotations.VisibleForTesting;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.FactoryLocator;\n+import com.dotmarketing.business.RelationshipAPI;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.portlets.structure.model.Relationship;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.json.JSONObject;\n+import com.jayway.jsonpath.JsonPath;\n+import com.liferay.portal.language.LanguageException;\n+import com.liferay.portal.language.LanguageUtil;\n+import com.liferay.util.StringPool;\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.URL;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper class responsible of setting Elasticsearch mapping for content type fields\n+ * @author nollymar\n+ */\n+public class ESMappingUtilHelper {\n+\n+    private static ContentTypeAPI contentTypeAPI;\n+    private static ESMappingAPIImpl esMappingAPI;\n+    private static RelationshipAPI relationshipAPI;\n+\n+    private static class SingletonHolder {\n+\n+        private static final ESMappingUtilHelper INSTANCE = new ESMappingUtilHelper();\n+    }\n+\n+    public static ESMappingUtilHelper getInstance() {\n+        return ESMappingUtilHelper.SingletonHolder.INSTANCE;\n+    }\n+\n+    private ESMappingUtilHelper() {\n+        contentTypeAPI = APILocator.getContentTypeAPI(APILocator.systemUser());\n+        esMappingAPI = new ESMappingAPIImpl();\n+        relationshipAPI = APILocator.getRelationshipAPI();\n+    }\n+\n+    @VisibleForTesting\n+    ESMappingUtilHelper(final ContentTypeAPI contentTypeAPI, final ESMappingAPIImpl esMappingAPI,\n+            final RelationshipAPI relationshipAPI) {\n+        this.contentTypeAPI = contentTypeAPI;\n+        this.esMappingAPI = esMappingAPI;\n+        this.relationshipAPI = relationshipAPI;\n+    }\n+\n+    /**\n+     * Sets a custom index mapping for relationships and also for mapping defined on field variables\n+     * using `esCustomMapping` property\n+     *\n+     * @param indexName - Index where mapping will be updated\n+     */\n+    public static void addCustomMapping(final String indexName) {\n+\n+        final Set<String> mappedFields = addCustomMappingFromFieldVariables(indexName);\n+\n+        addCustomMappingForRelationships(indexName, mappedFields);\n+\n+        addMappingForRemainingFields(indexName, mappedFields);\n+    }\n+\n+    /**\n+     * Sets a mapping for all relationships except for those that contains its custom mapping using\n+     * field variables\n+     *\n+     * @param indexName - Index where mapping will be updated\n+     * @param mappedFields - Collection that contains the fields with a specific mapping until now.\n+     * </br> When a put mapping request is sent to Elasticsearch for each relationship (if needed),\n+     * a new entry is added to the <b>mappedFields</b> collection\n+     */\n+    private static void addCustomMappingForRelationships(final String indexName,\n+            final Set<String> mappedFields) {\n+        final List<Relationship> relationships = relationshipAPI.dbAll();", "originalCommit": "eea7d5311e4560938664ee74e1e95ff242bfa58f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ3NTA2MQ==", "url": "https://github.com/dotCMS/core/pull/18751#discussion_r452475061", "bodyText": "done", "author": "nollymar", "createdAt": "2020-07-09T20:36:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ2MTM3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ2MzYxMg==", "url": "https://github.com/dotCMS/core/pull/18751#discussion_r452463612", "bodyText": "I think you could shallow this exception and just report as a debug", "author": "jdotcms", "createdAt": "2020-07-09T20:13:07Z", "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/util/ESMappingUtilHelper.java", "diffHunk": "@@ -0,0 +1,329 @@\n+package com.dotcms.content.elasticsearch.util;\n+\n+import com.dotcms.api.system.event.message.MessageSeverity;\n+import com.dotcms.api.system.event.message.MessageType;\n+import com.dotcms.api.system.event.message.SystemMessageEventUtil;\n+import com.dotcms.api.system.event.message.builder.SystemMessageBuilder;\n+import com.dotcms.content.elasticsearch.business.ESIndexAPI;\n+import com.dotcms.content.elasticsearch.business.ESMappingAPIImpl;\n+import com.dotcms.contenttype.business.ContentTypeAPI;\n+import com.dotcms.contenttype.business.FieldFactory;\n+import com.dotcms.contenttype.model.field.DataTypes;\n+import com.dotcms.contenttype.model.field.DateField;\n+import com.dotcms.contenttype.model.field.DateTimeField;\n+import com.dotcms.contenttype.model.field.Field;\n+import com.dotcms.contenttype.model.field.FieldVariable;\n+import com.dotcms.contenttype.model.field.RadioField;\n+import com.dotcms.contenttype.model.field.SelectField;\n+import com.dotcms.contenttype.model.field.TextAreaField;\n+import com.dotcms.contenttype.model.field.TextField;\n+import com.dotcms.contenttype.model.field.TimeField;\n+import com.dotcms.contenttype.model.field.WysiwygField;\n+import com.dotcms.contenttype.model.type.ContentType;\n+import com.dotcms.repackage.com.google.common.annotations.VisibleForTesting;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.FactoryLocator;\n+import com.dotmarketing.business.RelationshipAPI;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.portlets.structure.model.Relationship;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.json.JSONObject;\n+import com.jayway.jsonpath.JsonPath;\n+import com.liferay.portal.language.LanguageException;\n+import com.liferay.portal.language.LanguageUtil;\n+import com.liferay.util.StringPool;\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.URL;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper class responsible of setting Elasticsearch mapping for content type fields\n+ * @author nollymar\n+ */\n+public class ESMappingUtilHelper {\n+\n+    private static ContentTypeAPI contentTypeAPI;\n+    private static ESMappingAPIImpl esMappingAPI;\n+    private static RelationshipAPI relationshipAPI;\n+\n+    private static class SingletonHolder {\n+\n+        private static final ESMappingUtilHelper INSTANCE = new ESMappingUtilHelper();\n+    }\n+\n+    public static ESMappingUtilHelper getInstance() {\n+        return ESMappingUtilHelper.SingletonHolder.INSTANCE;\n+    }\n+\n+    private ESMappingUtilHelper() {\n+        contentTypeAPI = APILocator.getContentTypeAPI(APILocator.systemUser());\n+        esMappingAPI = new ESMappingAPIImpl();\n+        relationshipAPI = APILocator.getRelationshipAPI();\n+    }\n+\n+    @VisibleForTesting\n+    ESMappingUtilHelper(final ContentTypeAPI contentTypeAPI, final ESMappingAPIImpl esMappingAPI,\n+            final RelationshipAPI relationshipAPI) {\n+        this.contentTypeAPI = contentTypeAPI;\n+        this.esMappingAPI = esMappingAPI;\n+        this.relationshipAPI = relationshipAPI;\n+    }\n+\n+    /**\n+     * Sets a custom index mapping for relationships and also for mapping defined on field variables\n+     * using `esCustomMapping` property\n+     *\n+     * @param indexName - Index where mapping will be updated\n+     */\n+    public static void addCustomMapping(final String indexName) {\n+\n+        final Set<String> mappedFields = addCustomMappingFromFieldVariables(indexName);\n+\n+        addCustomMappingForRelationships(indexName, mappedFields);\n+\n+        addMappingForRemainingFields(indexName, mappedFields);\n+    }\n+\n+    /**\n+     * Sets a mapping for all relationships except for those that contains its custom mapping using\n+     * field variables\n+     *\n+     * @param indexName - Index where mapping will be updated\n+     * @param mappedFields - Collection that contains the fields with a specific mapping until now.\n+     * </br> When a put mapping request is sent to Elasticsearch for each relationship (if needed),\n+     * a new entry is added to the <b>mappedFields</b> collection\n+     */\n+    private static void addCustomMappingForRelationships(final String indexName,\n+            final Set<String> mappedFields) {\n+        final List<Relationship> relationships = relationshipAPI.dbAll();\n+\n+        for (final Relationship relationship : relationships) {\n+            final String relationshipName = relationship.getRelationTypeValue().toLowerCase();\n+            if (!mappedFields.contains(relationshipName)) {\n+                final JSONObject properties = new JSONObject();\n+                try {\n+                    properties.put(\"properties\", new JSONObject()\n+                            .put(relationshipName,\n+                                    new JSONObject(\"{\\n\"\n+                                            + \"\\\"type\\\":  \\\"keyword\\\",\\n\"\n+                                            + \"\\\"ignore_above\\\": 8191\\n\"\n+                                            + \"}\")));\n+                    esMappingAPI.putMapping(indexName, properties.toString());\n+\n+                    //Adds to the set the mapped already set for this field\n+                    mappedFields.add(relationshipName);\n+                } catch (Exception e) {\n+                    handleInvalidCustomMappingError(indexName, relationshipName);\n+                    final String message =\n+                            \"Error updating index mapping for relationship \" + relationshipName\n+                                    + \". This custom mapping will be ignored for index: \"\n+                                    + indexName;\n+                    Logger.warn(ESMappingUtilHelper.class, message, e);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Creates a system message event with an error in case a field mapping fails\n+     * @param indexName - Index where the mapping is trying to be applied\n+     * @param fieldName - Field whose mapping is trying to be applied to\n+     */\n+    private static void handleInvalidCustomMappingError(final String indexName,\n+            final String fieldName) {\n+\n+        final SystemMessageEventUtil systemMessageEventUtil = SystemMessageEventUtil.getInstance();\n+\n+        try {\n+            systemMessageEventUtil.pushMessage(\n+                    new SystemMessageBuilder()\n+                            .setMessage(LanguageUtil.format(Locale.getDefault(),\n+                                    \"notification.reindexing.custom.mapping.error\",\n+                                    new String[]{fieldName, indexName}, false))\n+                            .setSeverity(MessageSeverity.ERROR)\n+                            .setType(MessageType.SIMPLE_MESSAGE)\n+                            .setLife(6000)\n+                            .create(), null);\n+        } catch (LanguageException ex) {\n+            throw new RuntimeException(ex);", "originalCommit": "eea7d5311e4560938664ee74e1e95ff242bfa58f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ2NDUxMw==", "url": "https://github.com/dotCMS/core/pull/18751#discussion_r452464513", "bodyText": "this method needs close db if open", "author": "jdotcms", "createdAt": "2020-07-09T20:14:56Z", "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/util/ESMappingUtilHelper.java", "diffHunk": "@@ -0,0 +1,329 @@\n+package com.dotcms.content.elasticsearch.util;\n+\n+import com.dotcms.api.system.event.message.MessageSeverity;\n+import com.dotcms.api.system.event.message.MessageType;\n+import com.dotcms.api.system.event.message.SystemMessageEventUtil;\n+import com.dotcms.api.system.event.message.builder.SystemMessageBuilder;\n+import com.dotcms.content.elasticsearch.business.ESIndexAPI;\n+import com.dotcms.content.elasticsearch.business.ESMappingAPIImpl;\n+import com.dotcms.contenttype.business.ContentTypeAPI;\n+import com.dotcms.contenttype.business.FieldFactory;\n+import com.dotcms.contenttype.model.field.DataTypes;\n+import com.dotcms.contenttype.model.field.DateField;\n+import com.dotcms.contenttype.model.field.DateTimeField;\n+import com.dotcms.contenttype.model.field.Field;\n+import com.dotcms.contenttype.model.field.FieldVariable;\n+import com.dotcms.contenttype.model.field.RadioField;\n+import com.dotcms.contenttype.model.field.SelectField;\n+import com.dotcms.contenttype.model.field.TextAreaField;\n+import com.dotcms.contenttype.model.field.TextField;\n+import com.dotcms.contenttype.model.field.TimeField;\n+import com.dotcms.contenttype.model.field.WysiwygField;\n+import com.dotcms.contenttype.model.type.ContentType;\n+import com.dotcms.repackage.com.google.common.annotations.VisibleForTesting;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.FactoryLocator;\n+import com.dotmarketing.business.RelationshipAPI;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.portlets.structure.model.Relationship;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.json.JSONObject;\n+import com.jayway.jsonpath.JsonPath;\n+import com.liferay.portal.language.LanguageException;\n+import com.liferay.portal.language.LanguageUtil;\n+import com.liferay.util.StringPool;\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.URL;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper class responsible of setting Elasticsearch mapping for content type fields\n+ * @author nollymar\n+ */\n+public class ESMappingUtilHelper {\n+\n+    private static ContentTypeAPI contentTypeAPI;\n+    private static ESMappingAPIImpl esMappingAPI;\n+    private static RelationshipAPI relationshipAPI;\n+\n+    private static class SingletonHolder {\n+\n+        private static final ESMappingUtilHelper INSTANCE = new ESMappingUtilHelper();\n+    }\n+\n+    public static ESMappingUtilHelper getInstance() {\n+        return ESMappingUtilHelper.SingletonHolder.INSTANCE;\n+    }\n+\n+    private ESMappingUtilHelper() {\n+        contentTypeAPI = APILocator.getContentTypeAPI(APILocator.systemUser());\n+        esMappingAPI = new ESMappingAPIImpl();\n+        relationshipAPI = APILocator.getRelationshipAPI();\n+    }\n+\n+    @VisibleForTesting\n+    ESMappingUtilHelper(final ContentTypeAPI contentTypeAPI, final ESMappingAPIImpl esMappingAPI,\n+            final RelationshipAPI relationshipAPI) {\n+        this.contentTypeAPI = contentTypeAPI;\n+        this.esMappingAPI = esMappingAPI;\n+        this.relationshipAPI = relationshipAPI;\n+    }\n+\n+    /**\n+     * Sets a custom index mapping for relationships and also for mapping defined on field variables\n+     * using `esCustomMapping` property\n+     *\n+     * @param indexName - Index where mapping will be updated\n+     */\n+    public static void addCustomMapping(final String indexName) {", "originalCommit": "eea7d5311e4560938664ee74e1e95ff242bfa58f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ3NTYxNQ==", "url": "https://github.com/dotCMS/core/pull/18751#discussion_r452475615", "bodyText": "done", "author": "nollymar", "createdAt": "2020-07-09T20:37:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ2NDUxMw=="}], "type": "inlineReview"}, {"oid": "3b2ec82e222bbdf55f40530d0c19d65f10b9f563", "url": "https://github.com/dotCMS/core/commit/3b2ec82e222bbdf55f40530d0c19d65f10b9f563", "message": "#18689 Adding closeDBIfOpened annotation. Also, methods in the helper class were declared as instance methods", "committedDate": "2020-07-09T20:30:11Z", "type": "commit"}, {"oid": "e3dda7b1674f5d1df06e36689e6c3093d7c36969", "url": "https://github.com/dotCMS/core/commit/e3dda7b1674f5d1df06e36689e6c3093d7c36969", "message": "#18689 Setting right mapping for dates and metadata", "committedDate": "2020-07-09T20:31:19Z", "type": "commit"}, {"oid": "261d3932d5cc48ce7b56f49dc2ffc90e8ef6e320", "url": "https://github.com/dotCMS/core/commit/261d3932d5cc48ce7b56f49dc2ffc90e8ef6e320", "message": "#18689 New ITs were implemented to validate es-content-mapping.json settings are applied correctly", "committedDate": "2020-07-10T19:05:39Z", "type": "commit"}, {"oid": "5ac0f1652b08746feee2ecc9d03da808b8d7c762", "url": "https://github.com/dotCMS/core/commit/5ac0f1652b08746feee2ecc9d03da808b8d7c762", "message": "#18689 Fixing failing test", "committedDate": "2020-07-10T23:05:53Z", "type": "commit"}, {"oid": "d5f323a746e31fee58037e4611ca8fa73d4e8582", "url": "https://github.com/dotCMS/core/commit/d5f323a746e31fee58037e4611ca8fa73d4e8582", "message": "Merge branch 'master' of https://github.com/dotCMS/core into issue-18689-move-index-dynamic-mappings-from-JSON-to-code", "committedDate": "2020-07-10T23:07:43Z", "type": "commit"}, {"oid": "54b6f00217102b9b978a5b2e8ccc2663b0771bff", "url": "https://github.com/dotCMS/core/commit/54b6f00217102b9b978a5b2e8ccc2663b0771bff", "message": "#18689 Fixing failing test", "committedDate": "2020-07-13T17:08:00Z", "type": "commit"}, {"oid": "e6002906f706b0ec3e63bfb87e15bd5a0102b506", "url": "https://github.com/dotCMS/core/commit/e6002906f706b0ec3e63bfb87e15bd5a0102b506", "message": "#18689 Fixing failing test", "committedDate": "2020-07-13T22:37:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk4OTM3Mw==", "url": "https://github.com/dotCMS/core/pull/18751#discussion_r453989373", "bodyText": "Codacy found an issue: Prefer StringBuilder (non-synchronized) or StringBuffer (synchronized) over += for concatenating strings", "author": "dev-dotcms", "createdAt": "2020-07-13T22:44:41Z", "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/util/ESMappingUtilHelper.java", "diffHunk": "@@ -0,0 +1,331 @@\n+package com.dotcms.content.elasticsearch.util;\n+\n+import com.dotcms.api.system.event.message.MessageSeverity;\n+import com.dotcms.api.system.event.message.MessageType;\n+import com.dotcms.api.system.event.message.SystemMessageEventUtil;\n+import com.dotcms.api.system.event.message.builder.SystemMessageBuilder;\n+import com.dotcms.business.CloseDBIfOpened;\n+import com.dotcms.content.elasticsearch.business.ESIndexAPI;\n+import com.dotcms.content.elasticsearch.business.ESMappingAPIImpl;\n+import com.dotcms.contenttype.business.ContentTypeAPI;\n+import com.dotcms.contenttype.business.FieldFactory;\n+import com.dotcms.contenttype.model.field.DataTypes;\n+import com.dotcms.contenttype.model.field.DateField;\n+import com.dotcms.contenttype.model.field.DateTimeField;\n+import com.dotcms.contenttype.model.field.Field;\n+import com.dotcms.contenttype.model.field.FieldVariable;\n+import com.dotcms.contenttype.model.field.RadioField;\n+import com.dotcms.contenttype.model.field.SelectField;\n+import com.dotcms.contenttype.model.field.TextAreaField;\n+import com.dotcms.contenttype.model.field.TextField;\n+import com.dotcms.contenttype.model.field.TimeField;\n+import com.dotcms.contenttype.model.field.WysiwygField;\n+import com.dotcms.contenttype.model.type.ContentType;\n+import com.dotcms.repackage.com.google.common.annotations.VisibleForTesting;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.FactoryLocator;\n+import com.dotmarketing.business.RelationshipAPI;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.portlets.structure.model.Relationship;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.json.JSONObject;\n+import com.jayway.jsonpath.JsonPath;\n+import com.liferay.portal.language.LanguageException;\n+import com.liferay.portal.language.LanguageUtil;\n+import com.liferay.util.StringPool;\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.URL;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper class responsible of setting Elasticsearch mapping for content type fields\n+ * @author nollymar\n+ */\n+public class ESMappingUtilHelper {\n+\n+    private ContentTypeAPI contentTypeAPI;\n+    private ESMappingAPIImpl esMappingAPI;\n+    private RelationshipAPI relationshipAPI;\n+\n+    private static class SingletonHolder {\n+\n+        private static final ESMappingUtilHelper INSTANCE = new ESMappingUtilHelper();\n+    }\n+\n+    public static ESMappingUtilHelper getInstance() {\n+        return ESMappingUtilHelper.SingletonHolder.INSTANCE;\n+    }\n+\n+    private ESMappingUtilHelper() {\n+        contentTypeAPI = APILocator.getContentTypeAPI(APILocator.systemUser());\n+        esMappingAPI = new ESMappingAPIImpl();\n+        relationshipAPI = APILocator.getRelationshipAPI();\n+    }\n+\n+    @VisibleForTesting\n+    ESMappingUtilHelper(final ContentTypeAPI contentTypeAPI, final ESMappingAPIImpl esMappingAPI,\n+            final RelationshipAPI relationshipAPI) {\n+        this.contentTypeAPI = contentTypeAPI;\n+        this.esMappingAPI = esMappingAPI;\n+        this.relationshipAPI = relationshipAPI;\n+    }\n+\n+    /**\n+     * Sets a custom index mapping for relationships and also for mapping defined on field variables\n+     * using `esCustomMapping` property\n+     *\n+     * @param indexName - Index where mapping will be updated\n+     */\n+    @CloseDBIfOpened\n+    public void addCustomMapping(final String indexName) {\n+\n+        final Set<String> mappedFields = addCustomMappingFromFieldVariables(indexName);\n+\n+        addCustomMappingForRelationships(indexName, mappedFields);\n+\n+        addMappingForRemainingFields(indexName, mappedFields);\n+    }\n+\n+    /**\n+     * Sets a mapping for all relationships except for those that contains its custom mapping using\n+     * field variables\n+     *\n+     * @param indexName - Index where mapping will be updated\n+     * @param mappedFields - Collection that contains the fields with a specific mapping until now.\n+     * </br> When a put mapping request is sent to Elasticsearch for each relationship (if needed),\n+     * a new entry is added to the <b>mappedFields</b> collection\n+     */\n+    private void addCustomMappingForRelationships(final String indexName,\n+            final Set<String> mappedFields) {\n+        final List<Relationship> relationships = relationshipAPI.dbAll();\n+\n+        for (final Relationship relationship : relationships) {\n+            final String relationshipName = relationship.getRelationTypeValue().toLowerCase();\n+            if (!mappedFields.contains(relationshipName)) {\n+                final JSONObject properties = new JSONObject();\n+                try {\n+                    properties.put(\"properties\", new JSONObject()\n+                            .put(relationshipName,\n+                                    new JSONObject(\"{\\n\"\n+                                            + \"\\\"type\\\":  \\\"keyword\\\",\\n\"\n+                                            + \"\\\"ignore_above\\\": 8191\\n\"\n+                                            + \"}\")));\n+                    esMappingAPI.putMapping(indexName, properties.toString());\n+\n+                    //Adds to the set the mapped already set for this field\n+                    mappedFields.add(relationshipName);\n+                } catch (Exception e) {\n+                    handleInvalidCustomMappingError(indexName, relationshipName);\n+                    final String message =\n+                            \"Error updating index mapping for relationship \" + relationshipName\n+                                    + \". This custom mapping will be ignored for index: \"\n+                                    + indexName;\n+                    Logger.warn(ESMappingUtilHelper.class, message, e);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Creates a system message event with an error in case a field mapping fails\n+     * @param indexName - Index where the mapping is trying to be applied\n+     * @param fieldName - Field whose mapping is trying to be applied to\n+     */\n+    private void handleInvalidCustomMappingError(final String indexName,\n+            final String fieldName) {\n+\n+        final SystemMessageEventUtil systemMessageEventUtil = SystemMessageEventUtil.getInstance();\n+\n+        try {\n+            systemMessageEventUtil.pushMessage(\n+                    new SystemMessageBuilder()\n+                            .setMessage(LanguageUtil.format(Locale.getDefault(),\n+                                    \"notification.reindexing.custom.mapping.error\",\n+                                    new String[]{fieldName, indexName}, false))\n+                            .setSeverity(MessageSeverity.ERROR)\n+                            .setType(MessageType.SIMPLE_MESSAGE)\n+                            .setLife(6000)\n+                            .create(), null);\n+        } catch (LanguageException ex) {\n+            throw new RuntimeException(ex);\n+        }\n+    }\n+\n+    /**\n+     * Sets a mapping defined on field variables\n+     *\n+     * @param indexName - Index where mapping will be updated\n+     * @return Collection of fields names whose mapping was set\n+     */\n+    private Set<String> addCustomMappingFromFieldVariables(final String indexName) {\n+        final FieldFactory fieldFactory = FactoryLocator.getFieldFactory();\n+        final Set<String> mappedFields = new HashSet<>();\n+\n+        try {\n+            //Find field variables\n+            final List<FieldVariable> fieldVariables = fieldFactory\n+                    .byFieldVariableKey(FieldVariable.ES_CUSTOM_MAPPING_KEY);\n+\n+            for (final FieldVariable fieldVariable : fieldVariables) {\n+                Field field = null;\n+                ContentType type = null;\n+                try {\n+                    field = fieldFactory.byId(fieldVariable.fieldId());\n+                    type = contentTypeAPI.find(field.contentTypeId());\n+                    final JSONObject jsonObject = new JSONObject();\n+                    final JSONObject properties = new JSONObject();\n+\n+                    jsonObject.put(type.variable().toLowerCase(),\n+                            new JSONObject()\n+                                    .put(\"properties\", new JSONObject()\n+                                            .put(field.variable()\n+                                                            .toLowerCase(),\n+                                                    new JSONObject(fieldVariable.value()))));\n+                    properties.put(\"properties\", jsonObject);\n+                    esMappingAPI.putMapping(indexName, properties.toString());\n+\n+                    //Adds to the set the mapped already set for this field\n+                    mappedFields.add((type.variable() + StringPool.PERIOD + field.variable())\n+                            .toLowerCase());\n+\n+                } catch (Exception e) {\n+                    handleInvalidCustomMappingError(indexName,\n+                            type != null ? type.variable() + \".\" + field.variable() : \"[]\");\n+                    String message = \"Error setting custom index mapping from field variable \"\n+                            + fieldVariable.key();\n+\n+                    if (field != null) {\n+                        message += \". Field: \" + field.name();\n+                    }\n+\n+                    if (type != null) {\n+                        message += \". Content Type: \" + type.name();\n+                    }\n+\n+                    message += \". Custom mapping will be ignored for index: \" + indexName;", "originalCommit": "e6002906f706b0ec3e63bfb87e15bd5a0102b506", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk4OTM4MQ==", "url": "https://github.com/dotCMS/core/pull/18751#discussion_r453989381", "bodyText": "Codacy found an issue: Prefer StringBuilder (non-synchronized) or StringBuffer (synchronized) over += for concatenating strings", "author": "dev-dotcms", "createdAt": "2020-07-13T22:44:42Z", "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/util/ESMappingUtilHelper.java", "diffHunk": "@@ -0,0 +1,331 @@\n+package com.dotcms.content.elasticsearch.util;\n+\n+import com.dotcms.api.system.event.message.MessageSeverity;\n+import com.dotcms.api.system.event.message.MessageType;\n+import com.dotcms.api.system.event.message.SystemMessageEventUtil;\n+import com.dotcms.api.system.event.message.builder.SystemMessageBuilder;\n+import com.dotcms.business.CloseDBIfOpened;\n+import com.dotcms.content.elasticsearch.business.ESIndexAPI;\n+import com.dotcms.content.elasticsearch.business.ESMappingAPIImpl;\n+import com.dotcms.contenttype.business.ContentTypeAPI;\n+import com.dotcms.contenttype.business.FieldFactory;\n+import com.dotcms.contenttype.model.field.DataTypes;\n+import com.dotcms.contenttype.model.field.DateField;\n+import com.dotcms.contenttype.model.field.DateTimeField;\n+import com.dotcms.contenttype.model.field.Field;\n+import com.dotcms.contenttype.model.field.FieldVariable;\n+import com.dotcms.contenttype.model.field.RadioField;\n+import com.dotcms.contenttype.model.field.SelectField;\n+import com.dotcms.contenttype.model.field.TextAreaField;\n+import com.dotcms.contenttype.model.field.TextField;\n+import com.dotcms.contenttype.model.field.TimeField;\n+import com.dotcms.contenttype.model.field.WysiwygField;\n+import com.dotcms.contenttype.model.type.ContentType;\n+import com.dotcms.repackage.com.google.common.annotations.VisibleForTesting;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.FactoryLocator;\n+import com.dotmarketing.business.RelationshipAPI;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.portlets.structure.model.Relationship;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.json.JSONObject;\n+import com.jayway.jsonpath.JsonPath;\n+import com.liferay.portal.language.LanguageException;\n+import com.liferay.portal.language.LanguageUtil;\n+import com.liferay.util.StringPool;\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.URL;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper class responsible of setting Elasticsearch mapping for content type fields\n+ * @author nollymar\n+ */\n+public class ESMappingUtilHelper {\n+\n+    private ContentTypeAPI contentTypeAPI;\n+    private ESMappingAPIImpl esMappingAPI;\n+    private RelationshipAPI relationshipAPI;\n+\n+    private static class SingletonHolder {\n+\n+        private static final ESMappingUtilHelper INSTANCE = new ESMappingUtilHelper();\n+    }\n+\n+    public static ESMappingUtilHelper getInstance() {\n+        return ESMappingUtilHelper.SingletonHolder.INSTANCE;\n+    }\n+\n+    private ESMappingUtilHelper() {\n+        contentTypeAPI = APILocator.getContentTypeAPI(APILocator.systemUser());\n+        esMappingAPI = new ESMappingAPIImpl();\n+        relationshipAPI = APILocator.getRelationshipAPI();\n+    }\n+\n+    @VisibleForTesting\n+    ESMappingUtilHelper(final ContentTypeAPI contentTypeAPI, final ESMappingAPIImpl esMappingAPI,\n+            final RelationshipAPI relationshipAPI) {\n+        this.contentTypeAPI = contentTypeAPI;\n+        this.esMappingAPI = esMappingAPI;\n+        this.relationshipAPI = relationshipAPI;\n+    }\n+\n+    /**\n+     * Sets a custom index mapping for relationships and also for mapping defined on field variables\n+     * using `esCustomMapping` property\n+     *\n+     * @param indexName - Index where mapping will be updated\n+     */\n+    @CloseDBIfOpened\n+    public void addCustomMapping(final String indexName) {\n+\n+        final Set<String> mappedFields = addCustomMappingFromFieldVariables(indexName);\n+\n+        addCustomMappingForRelationships(indexName, mappedFields);\n+\n+        addMappingForRemainingFields(indexName, mappedFields);\n+    }\n+\n+    /**\n+     * Sets a mapping for all relationships except for those that contains its custom mapping using\n+     * field variables\n+     *\n+     * @param indexName - Index where mapping will be updated\n+     * @param mappedFields - Collection that contains the fields with a specific mapping until now.\n+     * </br> When a put mapping request is sent to Elasticsearch for each relationship (if needed),\n+     * a new entry is added to the <b>mappedFields</b> collection\n+     */\n+    private void addCustomMappingForRelationships(final String indexName,\n+            final Set<String> mappedFields) {\n+        final List<Relationship> relationships = relationshipAPI.dbAll();\n+\n+        for (final Relationship relationship : relationships) {\n+            final String relationshipName = relationship.getRelationTypeValue().toLowerCase();\n+            if (!mappedFields.contains(relationshipName)) {\n+                final JSONObject properties = new JSONObject();\n+                try {\n+                    properties.put(\"properties\", new JSONObject()\n+                            .put(relationshipName,\n+                                    new JSONObject(\"{\\n\"\n+                                            + \"\\\"type\\\":  \\\"keyword\\\",\\n\"\n+                                            + \"\\\"ignore_above\\\": 8191\\n\"\n+                                            + \"}\")));\n+                    esMappingAPI.putMapping(indexName, properties.toString());\n+\n+                    //Adds to the set the mapped already set for this field\n+                    mappedFields.add(relationshipName);\n+                } catch (Exception e) {\n+                    handleInvalidCustomMappingError(indexName, relationshipName);\n+                    final String message =\n+                            \"Error updating index mapping for relationship \" + relationshipName\n+                                    + \". This custom mapping will be ignored for index: \"\n+                                    + indexName;\n+                    Logger.warn(ESMappingUtilHelper.class, message, e);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Creates a system message event with an error in case a field mapping fails\n+     * @param indexName - Index where the mapping is trying to be applied\n+     * @param fieldName - Field whose mapping is trying to be applied to\n+     */\n+    private void handleInvalidCustomMappingError(final String indexName,\n+            final String fieldName) {\n+\n+        final SystemMessageEventUtil systemMessageEventUtil = SystemMessageEventUtil.getInstance();\n+\n+        try {\n+            systemMessageEventUtil.pushMessage(\n+                    new SystemMessageBuilder()\n+                            .setMessage(LanguageUtil.format(Locale.getDefault(),\n+                                    \"notification.reindexing.custom.mapping.error\",\n+                                    new String[]{fieldName, indexName}, false))\n+                            .setSeverity(MessageSeverity.ERROR)\n+                            .setType(MessageType.SIMPLE_MESSAGE)\n+                            .setLife(6000)\n+                            .create(), null);\n+        } catch (LanguageException ex) {\n+            throw new RuntimeException(ex);\n+        }\n+    }\n+\n+    /**\n+     * Sets a mapping defined on field variables\n+     *\n+     * @param indexName - Index where mapping will be updated\n+     * @return Collection of fields names whose mapping was set\n+     */\n+    private Set<String> addCustomMappingFromFieldVariables(final String indexName) {\n+        final FieldFactory fieldFactory = FactoryLocator.getFieldFactory();\n+        final Set<String> mappedFields = new HashSet<>();\n+\n+        try {\n+            //Find field variables\n+            final List<FieldVariable> fieldVariables = fieldFactory\n+                    .byFieldVariableKey(FieldVariable.ES_CUSTOM_MAPPING_KEY);\n+\n+            for (final FieldVariable fieldVariable : fieldVariables) {\n+                Field field = null;\n+                ContentType type = null;\n+                try {\n+                    field = fieldFactory.byId(fieldVariable.fieldId());\n+                    type = contentTypeAPI.find(field.contentTypeId());\n+                    final JSONObject jsonObject = new JSONObject();\n+                    final JSONObject properties = new JSONObject();\n+\n+                    jsonObject.put(type.variable().toLowerCase(),\n+                            new JSONObject()\n+                                    .put(\"properties\", new JSONObject()\n+                                            .put(field.variable()\n+                                                            .toLowerCase(),\n+                                                    new JSONObject(fieldVariable.value()))));\n+                    properties.put(\"properties\", jsonObject);\n+                    esMappingAPI.putMapping(indexName, properties.toString());\n+\n+                    //Adds to the set the mapped already set for this field\n+                    mappedFields.add((type.variable() + StringPool.PERIOD + field.variable())\n+                            .toLowerCase());\n+\n+                } catch (Exception e) {\n+                    handleInvalidCustomMappingError(indexName,\n+                            type != null ? type.variable() + \".\" + field.variable() : \"[]\");\n+                    String message = \"Error setting custom index mapping from field variable \"\n+                            + fieldVariable.key();\n+\n+                    if (field != null) {\n+                        message += \". Field: \" + field.name();\n+                    }\n+\n+                    if (type != null) {\n+                        message += \". Content Type: \" + type.name();", "originalCommit": "e6002906f706b0ec3e63bfb87e15bd5a0102b506", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk4OTM4NQ==", "url": "https://github.com/dotCMS/core/pull/18751#discussion_r453989385", "bodyText": "Codacy found an issue: Avoid catching generic exceptions such as NullPointerException, RuntimeException, Exception in try-catch block", "author": "dev-dotcms", "createdAt": "2020-07-13T22:44:43Z", "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/util/ESMappingUtilHelper.java", "diffHunk": "@@ -0,0 +1,331 @@\n+package com.dotcms.content.elasticsearch.util;\n+\n+import com.dotcms.api.system.event.message.MessageSeverity;\n+import com.dotcms.api.system.event.message.MessageType;\n+import com.dotcms.api.system.event.message.SystemMessageEventUtil;\n+import com.dotcms.api.system.event.message.builder.SystemMessageBuilder;\n+import com.dotcms.business.CloseDBIfOpened;\n+import com.dotcms.content.elasticsearch.business.ESIndexAPI;\n+import com.dotcms.content.elasticsearch.business.ESMappingAPIImpl;\n+import com.dotcms.contenttype.business.ContentTypeAPI;\n+import com.dotcms.contenttype.business.FieldFactory;\n+import com.dotcms.contenttype.model.field.DataTypes;\n+import com.dotcms.contenttype.model.field.DateField;\n+import com.dotcms.contenttype.model.field.DateTimeField;\n+import com.dotcms.contenttype.model.field.Field;\n+import com.dotcms.contenttype.model.field.FieldVariable;\n+import com.dotcms.contenttype.model.field.RadioField;\n+import com.dotcms.contenttype.model.field.SelectField;\n+import com.dotcms.contenttype.model.field.TextAreaField;\n+import com.dotcms.contenttype.model.field.TextField;\n+import com.dotcms.contenttype.model.field.TimeField;\n+import com.dotcms.contenttype.model.field.WysiwygField;\n+import com.dotcms.contenttype.model.type.ContentType;\n+import com.dotcms.repackage.com.google.common.annotations.VisibleForTesting;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.FactoryLocator;\n+import com.dotmarketing.business.RelationshipAPI;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.portlets.structure.model.Relationship;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.json.JSONObject;\n+import com.jayway.jsonpath.JsonPath;\n+import com.liferay.portal.language.LanguageException;\n+import com.liferay.portal.language.LanguageUtil;\n+import com.liferay.util.StringPool;\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.URL;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper class responsible of setting Elasticsearch mapping for content type fields\n+ * @author nollymar\n+ */\n+public class ESMappingUtilHelper {\n+\n+    private ContentTypeAPI contentTypeAPI;\n+    private ESMappingAPIImpl esMappingAPI;\n+    private RelationshipAPI relationshipAPI;\n+\n+    private static class SingletonHolder {\n+\n+        private static final ESMappingUtilHelper INSTANCE = new ESMappingUtilHelper();\n+    }\n+\n+    public static ESMappingUtilHelper getInstance() {\n+        return ESMappingUtilHelper.SingletonHolder.INSTANCE;\n+    }\n+\n+    private ESMappingUtilHelper() {\n+        contentTypeAPI = APILocator.getContentTypeAPI(APILocator.systemUser());\n+        esMappingAPI = new ESMappingAPIImpl();\n+        relationshipAPI = APILocator.getRelationshipAPI();\n+    }\n+\n+    @VisibleForTesting\n+    ESMappingUtilHelper(final ContentTypeAPI contentTypeAPI, final ESMappingAPIImpl esMappingAPI,\n+            final RelationshipAPI relationshipAPI) {\n+        this.contentTypeAPI = contentTypeAPI;\n+        this.esMappingAPI = esMappingAPI;\n+        this.relationshipAPI = relationshipAPI;\n+    }\n+\n+    /**\n+     * Sets a custom index mapping for relationships and also for mapping defined on field variables\n+     * using `esCustomMapping` property\n+     *\n+     * @param indexName - Index where mapping will be updated\n+     */\n+    @CloseDBIfOpened\n+    public void addCustomMapping(final String indexName) {\n+\n+        final Set<String> mappedFields = addCustomMappingFromFieldVariables(indexName);\n+\n+        addCustomMappingForRelationships(indexName, mappedFields);\n+\n+        addMappingForRemainingFields(indexName, mappedFields);\n+    }\n+\n+    /**\n+     * Sets a mapping for all relationships except for those that contains its custom mapping using\n+     * field variables\n+     *\n+     * @param indexName - Index where mapping will be updated\n+     * @param mappedFields - Collection that contains the fields with a specific mapping until now.\n+     * </br> When a put mapping request is sent to Elasticsearch for each relationship (if needed),\n+     * a new entry is added to the <b>mappedFields</b> collection\n+     */\n+    private void addCustomMappingForRelationships(final String indexName,\n+            final Set<String> mappedFields) {\n+        final List<Relationship> relationships = relationshipAPI.dbAll();\n+\n+        for (final Relationship relationship : relationships) {\n+            final String relationshipName = relationship.getRelationTypeValue().toLowerCase();\n+            if (!mappedFields.contains(relationshipName)) {\n+                final JSONObject properties = new JSONObject();\n+                try {\n+                    properties.put(\"properties\", new JSONObject()\n+                            .put(relationshipName,\n+                                    new JSONObject(\"{\\n\"\n+                                            + \"\\\"type\\\":  \\\"keyword\\\",\\n\"\n+                                            + \"\\\"ignore_above\\\": 8191\\n\"\n+                                            + \"}\")));\n+                    esMappingAPI.putMapping(indexName, properties.toString());\n+\n+                    //Adds to the set the mapped already set for this field\n+                    mappedFields.add(relationshipName);\n+                } catch (Exception e) {", "originalCommit": "e6002906f706b0ec3e63bfb87e15bd5a0102b506", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk4OTM5Mg==", "url": "https://github.com/dotCMS/core/pull/18751#discussion_r453989392", "bodyText": "Codacy found an issue: Avoid catching generic exceptions such as NullPointerException, RuntimeException, Exception in try-catch block", "author": "dev-dotcms", "createdAt": "2020-07-13T22:44:44Z", "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/util/ESMappingUtilHelperTest.java", "diffHunk": "@@ -0,0 +1,570 @@\n+package com.dotcms.content.elasticsearch.util;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import com.dotcms.content.elasticsearch.business.ContentletIndexAPI;\n+import com.dotcms.content.elasticsearch.business.DotIndexException;\n+import com.dotcms.content.elasticsearch.business.ESIndexAPI;\n+import com.dotcms.content.elasticsearch.business.ESMappingAPIImpl;\n+import com.dotcms.content.elasticsearch.business.IndexType;\n+import com.dotcms.contenttype.business.ContentTypeAPI;\n+import com.dotcms.contenttype.business.FieldAPI;\n+import com.dotcms.contenttype.exception.NotFoundInDbException;\n+import com.dotcms.contenttype.model.field.DataTypes;\n+import com.dotcms.contenttype.model.field.DateField;\n+import com.dotcms.contenttype.model.field.DateTimeField;\n+import com.dotcms.contenttype.model.field.Field;\n+import com.dotcms.contenttype.model.field.FieldBuilder;\n+import com.dotcms.contenttype.model.field.FieldVariable;\n+import com.dotcms.contenttype.model.field.ImmutableFieldVariable;\n+import com.dotcms.contenttype.model.field.RadioField;\n+import com.dotcms.contenttype.model.field.RelationshipField;\n+import com.dotcms.contenttype.model.field.SelectField;\n+import com.dotcms.contenttype.model.field.TextField;\n+import com.dotcms.contenttype.model.type.ContentType;\n+import com.dotcms.datagen.ContentTypeDataGen;\n+import com.dotcms.datagen.ContentletDataGen;\n+import com.dotcms.datagen.FieldDataGen;\n+import com.dotcms.datagen.TestDataUtils;\n+import com.dotcms.util.CollectionsUtils;\n+import com.dotcms.util.IntegrationTestInitService;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.RelationshipAPI;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.portlets.categories.business.CategoryAPI;\n+import com.dotmarketing.portlets.categories.model.Category;\n+import com.dotmarketing.portlets.contentlet.business.ContentletAPI;\n+import com.dotmarketing.portlets.contentlet.model.Contentlet;\n+import com.dotmarketing.portlets.languagesmanager.model.Language;\n+import com.dotmarketing.portlets.structure.model.Relationship;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.UtilMethods;\n+import com.dotmarketing.util.WebKeys.Relationship.RELATIONSHIP_CARDINALITY;\n+import com.dotmarketing.util.json.JSONObject;\n+import com.liferay.portal.model.User;\n+import com.liferay.util.StringPool;\n+import com.tngtech.java.junit.dataprovider.DataProvider;\n+import com.tngtech.java.junit.dataprovider.DataProviderRunner;\n+import com.tngtech.java.junit.dataprovider.UseDataProvider;\n+import com.tngtech.junit.dataprovider.format.DataProviderTestNameFormatter;\n+import java.io.IOException;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+/**\n+ * Class used to validate ES mapping for fields is applied correctly considering fields types and dynamic mapping defined in `es-content-mapping.json`\n+ * @author nollymar\n+ */\n+@RunWith(DataProviderRunner.class)\n+public class ESMappingUtilHelperTest {\n+\n+    private static User user;\n+    private static CategoryAPI categoryAPI;\n+    private static ContentletAPI contentletAPI;\n+    private static ContentletIndexAPI contentletIndexAPI;\n+    private static ContentTypeAPI contentTypeAPI;\n+    private static ESMappingAPIImpl esMappingAPI;\n+    private static FieldAPI fieldAPI;\n+    private static RelationshipAPI relationshipAPI;\n+    private static Language language;\n+\n+    @BeforeClass\n+    public static void prepare() throws Exception {\n+        //Setting web app environment\n+        IntegrationTestInitService.getInstance().init();\n+\n+        user = APILocator.systemUser();\n+        categoryAPI = APILocator.getCategoryAPI();\n+        contentletAPI = APILocator.getContentletAPI();\n+        contentletIndexAPI = APILocator.getContentletIndexAPI();\n+        contentTypeAPI = APILocator.getContentTypeAPI(user);\n+        esMappingAPI = new ESMappingAPIImpl();\n+        fieldAPI = APILocator.getContentTypeFieldAPI();\n+        relationshipAPI = APILocator.getRelationshipAPI();\n+        language = APILocator.getLanguageAPI().getDefaultLanguage();\n+    }\n+\n+    public static class PlusTestNameFormatter implements DataProviderTestNameFormatter {\n+        @Override\n+        public String format(Method testMethod, int invocationIndex, List<Object> arguments) {\n+            return String.format(\"Test Name: %s. Mapping Name: %s\", testMethod.getName(), arguments.get(0));\n+        }\n+    }\n+\n+    @DataProvider(formatter = PlusTestNameFormatter.class)\n+    public static Object[][] dataProviderValidateEventMapping(){\n+        return new Object[][] {\n+                {\"template_1\", new String[]{\"host.hostname_dotraw\"}, \"keyword\"},\n+                {\"textmapping\", new String[]{\"host.hostname\"}, \"keyword\"},\n+                {\"strings_as_dates\", new String[]{\"calendarevent.originalstartdate\",\n+                        \"calendarevent.recurrencestart\", \"calendarevent.recurrenceend\"}, \"date\"},\n+                {\"permissions\", new String[]{\"permissions\"}, \"text\"},\n+                {\"hostname\", new String[]{\"host.hostname_text\"}, \"text\"}\n+        };\n+    }\n+\n+    @DataProvider(formatter = PlusTestNameFormatter.class)\n+    public static Object[][] dataProviderValidateFileAssetMapping(){\n+        return new Object[][] {\n+                {\"longmapping\", new String[]{ \"metadata.height\", \"metadata.width\"}, \"long\"},\n+                {\"keywordmapping\", new String[]{\"metadata.contenttype\"}, \"keyword\"}\n+        };\n+    }\n+\n+    @DataProvider(formatter = PlusTestNameFormatter.class)\n+    public static Object[][] dataProviderValidateNewsLikeMapping() {\n+        return new Object[][]{\n+                {\"geomapping\", new String[]{\"mylatlon\"}, \"geo_point\"},\n+                {\"geomapping_2\", new String[]{\"latlong\"}, \"geo_point\"},\n+                {\"keywordmapping\", new String[]{\"categories\", \"tags\", \"conhost\", \"conhostname\",\n+                        \"wfstep\", \"structurename\", \"contenttype\", \"parentpath\", \"path\", \"urlmap\",\n+                        \"moduser\", \"owner\"}, \"keyword\"}\n+        };\n+    }\n+\n+    /*Data provider used to verify that the ES mapping is applied correctly and considers exclusions in the `es-content-mapping` file\n+        For each scenario we define:\n+            1) testCase name\n+            2) Field(s) type\n+            3) Field(s) variable name(s)\n+            4) Expected ES mapping\n+     */\n+    @DataProvider(formatter = PlusTestNameFormatter.class)\n+    public static Object[][] dataProviderAddMappingForFields() {\n+        return new Object[][] {\n+                {  \"strings_as_dates\", DateField.class, DataTypes.DATE,\n+                        new String[] {\"originalstartdate\", \"recurrencestart\", \"recurrenceend\"},  \"date\" },\n+\n+                {  \"strings_as_date_times\", DateTimeField.class, DataTypes.DATE,\n+                        new String[] {\"originalstartdate\", \"recurrencestart\", \"recurrenceend\"},  \"date\" },\n+\n+                {  \"dates_as_text\", TextField.class, DataTypes.TEXT,\n+                        new String[] {\"originalstartdate\", \"recurrencestart\", \"recurrenceend\"},  \"text\" },\n+\n+                {  \"keywordmapping\", TextField.class, DataTypes.TEXT,\n+                        new String[] {\"categories\", \"tags\", \"conhost\",\n+                                \"wfstep\", \"structurename\", \"contenttype\", \"parentpath\",\n+                                \"path\", \"urlmap\", \"moduser\", \"owner\"},  \"text\" },\n+\n+                {  \"geomapping\", TextField.class, DataTypes.TEXT,\n+                        new String[] {\"mylatlong\", \"mylatlon\"},  null },\n+\n+                {  \"permissions\", TextField.class, DataTypes.TEXT, new String[] {\"permissions\"},  \"text\" },\n+\n+                {  \"radio_as_boolean\", RadioField.class, DataTypes.BOOL,\n+                        new String[] {\"MyRadioAsBoolean\"},  \"boolean\" },\n+\n+                {  \"radio_as_float\", RadioField.class, DataTypes.FLOAT,\n+                        new String[] {\"MyRadioAsFloat\"},  \"float\" },\n+\n+                {  \"radio_as_integer\", RadioField.class, DataTypes.INTEGER,\n+                        new String[] {\"MyRadioAsInteger\"},  \"integer\" },\n+\n+                {  \"select_as_boolean\", SelectField.class, DataTypes.BOOL,\n+                        new String[] {\"MySelectAsBoolean\"},  \"boolean\" },\n+\n+                {  \"select_as_float\", SelectField.class, DataTypes.FLOAT,\n+                        new String[] {\"MySelectAsFloat\"},  \"float\" },\n+\n+                {  \"select_as_integer\", SelectField.class, DataTypes.INTEGER,\n+                        new String[] {\"MySelectAsInteger\"},  \"integer\" },\n+\n+                {  \"text_as_float\", TextField.class, DataTypes.FLOAT,\n+                        new String[] {\"MyTextAsFloat\"},  \"float\" },\n+\n+                {  \"text_as_integer\", TextField.class, DataTypes.INTEGER,\n+                        new String[] {\"MyTextAsInteger\"},  \"integer\" }\n+        };\n+    }\n+\n+    /**\n+     * <b>Method to test:</b> Internally, it tests the method ESMappingUtilHelper.addMappingForFieldIfNeeded<p></p>\n+     * <b>Test Case:</b> Given a field or an array of fields, the right ES mapping should be set, considering exclusions in the `es-content-mapping` file<p></p>\n+     * <b>Expected Results:</b> Each test case should match the `expectedResult` value, which is a string with the correct datatype in ES\n+     * @param testCase\n+     * @param fieldType\n+     * @param type\n+     * @param fields\n+     * @param expectedResult\n+     * @throws IOException\n+     * @throws DotIndexException\n+     * @throws DotSecurityException\n+     * @throws DotDataException\n+     */\n+    @UseDataProvider\n+    @Test\n+    public void testAddMappingForFields(final String testCase, final Class fieldType,\n+            final DataTypes type,\n+            final String[] fields, final String expectedResult)\n+            throws IOException, DotIndexException, DotSecurityException, DotDataException {\n+\n+        Logger.info(ESMappingUtilHelperTest.class,\n+                String.format(\"Testing Add Mapping for fields defined in %s template\", testCase));\n+\n+        final ContentType contentType = new ContentTypeDataGen().nextPersisted();\n+\n+        String workingIndex = null;\n+        //Build the index name\n+        String timestamp = String.valueOf(new Date().getTime());\n+        try {\n+            //Adding fields\n+            for (final String field : fields) {\n+                final Field newField = FieldBuilder.builder(fieldType)\n+                        .name(field).variable(field).dataType(type).contentTypeId(contentType.id())\n+                        .indexed(true).build();\n+                fieldAPI.save(newField, user);\n+            }\n+\n+            workingIndex = new ESIndexAPI().getNameWithClusterIDPrefix(\n+                    IndexType.WORKING.getPrefix() + \"_\" + timestamp);\n+\n+            //Create a working index\n+            boolean result = contentletIndexAPI.createContentIndex(workingIndex);\n+            //Validate\n+            assertTrue(result);\n+\n+            for (final String field : fields) {\n+\n+                if (expectedResult == null) {\n+                    assertFalse(UtilMethods.isSet(esMappingAPI.getFieldMappingAsMap(workingIndex,\n+                            (contentType.variable() + StringPool.PERIOD + field).toLowerCase())));\n+                } else {\n+                    Map<String, String> mapping = (Map<String, String>) esMappingAPI\n+                            .getFieldMappingAsMap(workingIndex,\n+                                    (contentType.variable() + StringPool.PERIOD + field)\n+                                            .toLowerCase()).get(field.toLowerCase());\n+                    assertTrue(UtilMethods.isSet(mapping.get(\"type\")));\n+                    assertEquals(expectedResult, mapping.get(\"type\"));\n+                }\n+            }\n+\n+        } finally {\n+            if (workingIndex != null) {\n+                contentletIndexAPI.delete(workingIndex);\n+            }\n+\n+            if (contentType != null) {\n+                contentTypeAPI.delete(contentType);\n+            }\n+        }\n+    }\n+\n+\n+    /**\n+     * <b>Method to test:</b> Internally, it tests the methods ESMappingUtilHelper.addCustomMappingForRelationships and </p>\n+     * ESMappingUtilHelper.addCustomMappingFromFieldVariables<p></p>\n+     * </p><b>Test Case:</b> This test creates an index with two custom mapped fields: a text field and a relationship field.\n+     * Additionally, it creates a legacy relationship without a custom mapping in order to verify that\n+     * relationships in general are mapped as keywords by default, unless a custom mapping is defined for a specific case <p></p>\n+     * <b>Expected Results:</b> Custom mappings should take precedence always if exists. In case of relationships, </p>\n+     * they should be mapped as keywords, unless a custom mapping is defined\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testCreateContentIndexWithCustomMappings() throws Exception {\n+\n+        String workingIndex = null;\n+        ContentType parentContentType = null;\n+        ContentType childContentType = null;\n+        try {\n+            parentContentType = new ContentTypeDataGen().nextPersisted();\n+            childContentType = new ContentTypeDataGen().nextPersisted();\n+\n+            //Adding fields\n+            Field ageField = FieldBuilder.builder(TextField.class)\n+                    .name(\"age\").contentTypeId(parentContentType.id()).indexed(false).build();\n+            ageField = fieldAPI.save(ageField, user);\n+\n+            Field relationshipField = FieldBuilder.builder(RelationshipField.class)\n+                    .name(\"relationshipField\")\n+                    .contentTypeId(parentContentType.id())\n+                    .values(String.valueOf(RELATIONSHIP_CARDINALITY.ONE_TO_MANY.ordinal()))\n+                    .relationType(parentContentType.variable()).build();\n+\n+            relationshipField = fieldAPI.save(relationshipField, user);\n+\n+            //Create legacy relationship\n+            final Relationship legacyRelationship = createLegacyRelationship(parentContentType,\n+                    childContentType);\n+\n+            //Adding field variables\n+            final FieldVariable ageVariable = ImmutableFieldVariable.builder()\n+                    .fieldId(ageField.inode())\n+                    .name(\"ageMapping\").key(FieldVariable.ES_CUSTOM_MAPPING_KEY).value(\"{\\n\"\n+                            + \"                \\\"type\\\": \\\"long\\\"\\n\"\n+                            + \"              }\").userId(user.getUserId())\n+                    .build();\n+\n+            fieldAPI.save(ageVariable, user);\n+\n+            FieldVariable relVariable = ImmutableFieldVariable.builder()\n+                    .fieldId(relationshipField.inode())\n+                    .name(\"relMapping\").key(FieldVariable.ES_CUSTOM_MAPPING_KEY).value(\"{\\n\"\n+                            + \"                \\\"type\\\": \\\"text\\\"\\n\"\n+                            + \"              }\").userId(user.getUserId())\n+                    .build();\n+\n+            relVariable = fieldAPI.save(relVariable, user);\n+\n+            final Field updatedField = fieldAPI.find(relVariable.fieldId());\n+\n+            //Verify ageField is updated as System Indexed\n+            assertTrue(updatedField.indexed());\n+\n+            //Build the index name\n+            String timestamp = String.valueOf(new Date().getTime());\n+            workingIndex = new ESIndexAPI().getNameWithClusterIDPrefix(IndexType.WORKING.getPrefix() + \"_\" + timestamp);\n+\n+            //Create a working index\n+            boolean result = contentletIndexAPI.createContentIndex(workingIndex);\n+            //Validate\n+            assertTrue(result);\n+\n+            //verify mapping\n+            final String mapping = esMappingAPI.getMapping(workingIndex);\n+\n+            //parse json mapping and validate\n+            assertNotNull(mapping);\n+\n+            final JSONObject propertiesJSON = (JSONObject) (new JSONObject(mapping)).get(\"properties\");\n+            final JSONObject contentTypeJSON = (JSONObject) ((JSONObject) propertiesJSON\n+                    .get(parentContentType.variable().toLowerCase())).get(\"properties\");\n+\n+            //validate age mapping results\n+            final Map ageMapping = ((JSONObject) contentTypeJSON\n+                    .get(ageField.variable().toLowerCase())).getAsMap();\n+            assertNotNull(ageMapping);\n+            assertEquals(1, ageMapping.size());\n+            assertEquals(\"long\", ageMapping.get(\"type\"));\n+\n+            //validate relationship field mapping results\n+            final Map relationshipMapping = ((JSONObject) contentTypeJSON\n+                    .get(relationshipField.variable().toLowerCase())).getAsMap();\n+            assertNotNull(relationshipMapping);\n+            assertEquals(1, relationshipMapping.size());\n+            assertEquals(\"text\", relationshipMapping.get(\"type\"));\n+\n+            //validate legacy relationship\n+            final Map legacyRelationshipMapping = ((JSONObject) propertiesJSON\n+                    .get(legacyRelationship.getRelationTypeValue().toLowerCase())).getAsMap();\n+            assertNotNull(ageMapping);\n+            assertEquals(2, legacyRelationshipMapping.size());\n+            assertEquals(\"keyword\", legacyRelationshipMapping.get(\"type\"));\n+            assertEquals(8191, legacyRelationshipMapping.get(\"ignore_above\"));\n+\n+        } finally {\n+            if (workingIndex != null) {\n+                contentletIndexAPI.delete(workingIndex);\n+            }\n+\n+            if (parentContentType != null && parentContentType.inode() != null) {\n+                ContentTypeDataGen.remove(parentContentType);\n+            }\n+\n+            if (childContentType != null && childContentType.inode() != null) {\n+                ContentTypeDataGen.remove(childContentType);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * <b>Test Case:</b> Validates dynamic mappings defined in the `es-content-mapping` file are applied correctly<p></p>\n+     * <b>Expected Results:</b> Each test case should match the `expectedResult` value, which is a string with the correct datatype in ES\n+     * @param testCase\n+     * @param fields\n+     * @param expectedResult\n+     * @throws DotDataException\n+     * @throws IOException\n+     * @throws DotSecurityException\n+     */\n+    @UseDataProvider\n+    @Test\n+    public void testValidateNewsLikeMapping(final String testCase, final String[] fields, final String expectedResult)\n+            throws DotDataException, IOException, DotSecurityException {\n+        final ContentType newsContentType = TestDataUtils.getNewsLikeContentType();\n+        fieldAPI.save( FieldBuilder.builder(TextField.class).contentTypeId(newsContentType.id()).name(\"mylatlon\").variable(\"mylatlon\").indexed(true).build(), user);\n+        Contentlet newsContent = null;\n+        try {\n+            final String categoryName = \"myCategory\" + System.currentTimeMillis();\n+            Category category = new Category();\n+            category.setCategoryName(categoryName);\n+            category.setKey(categoryName);\n+            category.setCategoryVelocityVarName(categoryName);\n+            category.setSortOrder(2);\n+            category.setKeywords(null);\n+            categoryAPI.save(null, category, user, false);\n+            newsContent = new ContentletDataGen(newsContentType.id()).languageId(language.getId())\n+                    .host(APILocator.getHostAPI()\n+                            .findDefaultHost(APILocator.systemUser(), false))\n+                    .setProperty(\"title\", \"newsContent Title\" + System.currentTimeMillis())\n+                    .setProperty(\"urlTitle\", \"myUrlTitle\")\n+                    .setProperty(\"urlMap\", \"myUrlMap\")\n+                    .setProperty(\"byline\", \"byline\")\n+                    .setProperty(\"sysPublishDate\", new Date())\n+                    .setProperty(\"story\", \"newsStory\")\n+                    .setProperty(\"latlong\", \"[90, -90]\")\n+                    .setProperty(\"mylatlon\", \"[90, -90]\")\n+                    .setProperty(\"tags\", \"test\").next();\n+\n+            newsContent = contentletAPI.checkin(newsContent, CollectionsUtils.list(category), null, user, false);\n+            validateMappingForFields(testCase, newsContentType.variable().toLowerCase(), fields, expectedResult);\n+        }finally{\n+            if (newsContent != null) {\n+                ContentletDataGen.destroy(newsContent);\n+            }\n+        }\n+\n+    }\n+\n+    /**\n+     * <b>Test Case:</b> Validates dynamic mappings defined in the `es-content-mapping` file are applied correctly<p></p>\n+     * <b>Expected Results:</b> Each test case should match the `expectedResult` value, which is a string with the correct datatype in ES\n+     * @param testCase\n+     * @param fields\n+     * @param expectedResult\n+     * @throws DotDataException\n+     * @throws IOException\n+     */\n+    @UseDataProvider\n+    @Test\n+    public void testValidateFileAssetMapping(final String testCase, final String[] fields, final String expectedResult)\n+            throws DotDataException, IOException {\n+        Contentlet fileAsset = null;\n+\n+        try{\n+            fileAsset = TestDataUtils.getFileAssetContent(true, language.getId());\n+            validateMappingForFields(testCase, null, fields, expectedResult);\n+        } finally {\n+            if (fileAsset != null) {\n+                ContentletDataGen.destroy(fileAsset);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * <b>Test Case:</b> Validates dynamic mappings defined in the `es-content-mapping` file are applied correctly<p></p>\n+     * <b>Expected Results:</b> Each test case should match the `expectedResult` value, which is a string with the correct datatype in ES\n+     * @param testCase\n+     * @param fields\n+     * @param expectedResult\n+     * @throws DotDataException\n+     * @throws DotSecurityException\n+     * @throws IOException\n+     */\n+    @UseDataProvider\n+    @Test\n+    public void testValidateEventMapping(final String testCase, final String[] fields, final String expectedResult)\n+            throws DotDataException, DotSecurityException, IOException {\n+\n+        ContentType eventContentType;\n+        Contentlet event = null;\n+        try {\n+            try {\n+                eventContentType = contentTypeAPI.find(\"calendarEvent\");\n+\n+            } catch(NotFoundInDbException e){\n+                final List<Field> eventFields = new ArrayList<>();\n+                eventFields\n+                        .add(new FieldDataGen().name(\"Title\").velocityVarName(\"title\").indexed(true)\n+                                .next());\n+                eventFields.add(new FieldDataGen().type(DateField.class).name(\"StartDate\").defaultValue(null)\n+                        .velocityVarName(\"startDate\").indexed(true).next());\n+                eventFields.add(new FieldDataGen().type(DateField.class).name(\"EndDate\").defaultValue(null)\n+                        .velocityVarName(\"endDate\").indexed(true).next());\n+                eventFields.add(new FieldDataGen().type(DateField.class).name(\"OriginalStartDate\")\n+                        .defaultValue(null).defaultValue(null).velocityVarName(\"originalStartDate\")\n+                        .indexed(true).next());\n+                eventFields.add(new FieldDataGen().type(DateField.class).name(\"RecurrenceStart\")\n+                        .defaultValue(null).velocityVarName(\"recurrenceStart\").indexed(true).next());\n+                eventFields.add(new FieldDataGen().type(DateField.class).name(\"RecurrenceEnd\")\n+                        .defaultValue(null).velocityVarName(\"recurrenceEnd\").indexed(true).next());\n+                eventContentType = new ContentTypeDataGen().velocityVarName(\"calendarEvent\").fields(eventFields).nextPersisted();\n+            }\n+            event = new ContentletDataGen(eventContentType.id())\n+                    .setProperty(\"title\", \"MyEvent\" + System.currentTimeMillis())\n+                    .setProperty(\"startDate\", new Date())\n+                    .setProperty(\"endDate\", new Date())\n+                    .setProperty(\"originalStartDate\", new Date())\n+                    .setProperty(\"recurrenceStart\", new Date())\n+                    .setProperty(\"recurrenceEnd\", new Date()).nextPersisted();\n+\n+            validateMappingForFields(testCase, null, fields, expectedResult);\n+        }finally {\n+            if (event != null){\n+                ContentletDataGen.destroy(event);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Validates asserts for tests: testValidateNewsLikeMapping, testValidateFileAssetMapping and testValidateEventMapping\n+     * @param testCase\n+     * @param contentTypeVarName\n+     * @param fields\n+     * @param expectedResult\n+     * @throws IOException\n+     * @throws DotDataException\n+     */\n+    private void validateMappingForFields(final String testCase, final String contentTypeVarName,  final String[] fields, final String expectedResult)\n+            throws IOException, DotDataException {\n+        Map<String, String> mapping;\n+\n+        for (final String field : fields) {\n+            Logger.info(this,\n+                    \"Validating mapping for case: \" + testCase + \". Field Name: \" + field);\n+            mapping = (Map<String, String>) esMappingAPI\n+                    .getFieldMappingAsMap(APILocator.getIndiciesAPI().loadIndicies().getWorking(),\n+                            expectedResult.equals(\"geo_point\") ? contentTypeVarName\n+                                    + StringPool.PERIOD + field : field).entrySet().iterator()\n+                    .next().getValue();\n+            assertTrue(UtilMethods.isSet(mapping.get(\"type\")));\n+            assertEquals(expectedResult, mapping.get(\"type\"));\n+            Logger.info(this,\n+                    \"Case: \" + testCase + \". Field Name: \" + field + \" validated successfully\");\n+        }\n+    }\n+\n+\n+    /**\n+     * Creates a new Legacy Relationship object\n+     * @param parentContentType\n+     * @param childContentType\n+     * @return\n+     */\n+    private Relationship createLegacyRelationship(final ContentType parentContentType,\n+            final ContentType childContentType) {\n+        final String relationTypeValue = parentContentType.name() + \"-\" + childContentType.name();\n+\n+        Relationship relationship;\n+        relationship = relationshipAPI.byTypeValue(relationTypeValue);\n+        if (null != relationship) {\n+            return relationship;\n+        } else {\n+            relationship = new Relationship();\n+            relationship.setParentRelationName(parentContentType.name());\n+            relationship.setChildRelationName(childContentType.name());\n+            relationship.setCardinality(0);\n+            relationship.setRelationTypeValue(relationTypeValue);\n+            relationship.setParentStructureInode(parentContentType.inode());\n+            relationship.setChildStructureInode(childContentType.id());\n+            try {\n+                relationshipAPI.create(relationship);\n+            } catch (Exception e) {", "originalCommit": "e6002906f706b0ec3e63bfb87e15bd5a0102b506", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk4OTQwMQ==", "url": "https://github.com/dotCMS/core/pull/18751#discussion_r453989401", "bodyText": "Codacy found an issue: Prefer StringBuilder (non-synchronized) or StringBuffer (synchronized) over += for concatenating strings", "author": "dev-dotcms", "createdAt": "2020-07-13T22:44:46Z", "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/util/ESMappingUtilHelper.java", "diffHunk": "@@ -0,0 +1,331 @@\n+package com.dotcms.content.elasticsearch.util;\n+\n+import com.dotcms.api.system.event.message.MessageSeverity;\n+import com.dotcms.api.system.event.message.MessageType;\n+import com.dotcms.api.system.event.message.SystemMessageEventUtil;\n+import com.dotcms.api.system.event.message.builder.SystemMessageBuilder;\n+import com.dotcms.business.CloseDBIfOpened;\n+import com.dotcms.content.elasticsearch.business.ESIndexAPI;\n+import com.dotcms.content.elasticsearch.business.ESMappingAPIImpl;\n+import com.dotcms.contenttype.business.ContentTypeAPI;\n+import com.dotcms.contenttype.business.FieldFactory;\n+import com.dotcms.contenttype.model.field.DataTypes;\n+import com.dotcms.contenttype.model.field.DateField;\n+import com.dotcms.contenttype.model.field.DateTimeField;\n+import com.dotcms.contenttype.model.field.Field;\n+import com.dotcms.contenttype.model.field.FieldVariable;\n+import com.dotcms.contenttype.model.field.RadioField;\n+import com.dotcms.contenttype.model.field.SelectField;\n+import com.dotcms.contenttype.model.field.TextAreaField;\n+import com.dotcms.contenttype.model.field.TextField;\n+import com.dotcms.contenttype.model.field.TimeField;\n+import com.dotcms.contenttype.model.field.WysiwygField;\n+import com.dotcms.contenttype.model.type.ContentType;\n+import com.dotcms.repackage.com.google.common.annotations.VisibleForTesting;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.FactoryLocator;\n+import com.dotmarketing.business.RelationshipAPI;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.portlets.structure.model.Relationship;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.json.JSONObject;\n+import com.jayway.jsonpath.JsonPath;\n+import com.liferay.portal.language.LanguageException;\n+import com.liferay.portal.language.LanguageUtil;\n+import com.liferay.util.StringPool;\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.URL;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper class responsible of setting Elasticsearch mapping for content type fields\n+ * @author nollymar\n+ */\n+public class ESMappingUtilHelper {\n+\n+    private ContentTypeAPI contentTypeAPI;\n+    private ESMappingAPIImpl esMappingAPI;\n+    private RelationshipAPI relationshipAPI;\n+\n+    private static class SingletonHolder {\n+\n+        private static final ESMappingUtilHelper INSTANCE = new ESMappingUtilHelper();\n+    }\n+\n+    public static ESMappingUtilHelper getInstance() {\n+        return ESMappingUtilHelper.SingletonHolder.INSTANCE;\n+    }\n+\n+    private ESMappingUtilHelper() {\n+        contentTypeAPI = APILocator.getContentTypeAPI(APILocator.systemUser());\n+        esMappingAPI = new ESMappingAPIImpl();\n+        relationshipAPI = APILocator.getRelationshipAPI();\n+    }\n+\n+    @VisibleForTesting\n+    ESMappingUtilHelper(final ContentTypeAPI contentTypeAPI, final ESMappingAPIImpl esMappingAPI,\n+            final RelationshipAPI relationshipAPI) {\n+        this.contentTypeAPI = contentTypeAPI;\n+        this.esMappingAPI = esMappingAPI;\n+        this.relationshipAPI = relationshipAPI;\n+    }\n+\n+    /**\n+     * Sets a custom index mapping for relationships and also for mapping defined on field variables\n+     * using `esCustomMapping` property\n+     *\n+     * @param indexName - Index where mapping will be updated\n+     */\n+    @CloseDBIfOpened\n+    public void addCustomMapping(final String indexName) {\n+\n+        final Set<String> mappedFields = addCustomMappingFromFieldVariables(indexName);\n+\n+        addCustomMappingForRelationships(indexName, mappedFields);\n+\n+        addMappingForRemainingFields(indexName, mappedFields);\n+    }\n+\n+    /**\n+     * Sets a mapping for all relationships except for those that contains its custom mapping using\n+     * field variables\n+     *\n+     * @param indexName - Index where mapping will be updated\n+     * @param mappedFields - Collection that contains the fields with a specific mapping until now.\n+     * </br> When a put mapping request is sent to Elasticsearch for each relationship (if needed),\n+     * a new entry is added to the <b>mappedFields</b> collection\n+     */\n+    private void addCustomMappingForRelationships(final String indexName,\n+            final Set<String> mappedFields) {\n+        final List<Relationship> relationships = relationshipAPI.dbAll();\n+\n+        for (final Relationship relationship : relationships) {\n+            final String relationshipName = relationship.getRelationTypeValue().toLowerCase();\n+            if (!mappedFields.contains(relationshipName)) {\n+                final JSONObject properties = new JSONObject();\n+                try {\n+                    properties.put(\"properties\", new JSONObject()\n+                            .put(relationshipName,\n+                                    new JSONObject(\"{\\n\"\n+                                            + \"\\\"type\\\":  \\\"keyword\\\",\\n\"\n+                                            + \"\\\"ignore_above\\\": 8191\\n\"\n+                                            + \"}\")));\n+                    esMappingAPI.putMapping(indexName, properties.toString());\n+\n+                    //Adds to the set the mapped already set for this field\n+                    mappedFields.add(relationshipName);\n+                } catch (Exception e) {\n+                    handleInvalidCustomMappingError(indexName, relationshipName);\n+                    final String message =\n+                            \"Error updating index mapping for relationship \" + relationshipName\n+                                    + \". This custom mapping will be ignored for index: \"\n+                                    + indexName;\n+                    Logger.warn(ESMappingUtilHelper.class, message, e);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Creates a system message event with an error in case a field mapping fails\n+     * @param indexName - Index where the mapping is trying to be applied\n+     * @param fieldName - Field whose mapping is trying to be applied to\n+     */\n+    private void handleInvalidCustomMappingError(final String indexName,\n+            final String fieldName) {\n+\n+        final SystemMessageEventUtil systemMessageEventUtil = SystemMessageEventUtil.getInstance();\n+\n+        try {\n+            systemMessageEventUtil.pushMessage(\n+                    new SystemMessageBuilder()\n+                            .setMessage(LanguageUtil.format(Locale.getDefault(),\n+                                    \"notification.reindexing.custom.mapping.error\",\n+                                    new String[]{fieldName, indexName}, false))\n+                            .setSeverity(MessageSeverity.ERROR)\n+                            .setType(MessageType.SIMPLE_MESSAGE)\n+                            .setLife(6000)\n+                            .create(), null);\n+        } catch (LanguageException ex) {\n+            throw new RuntimeException(ex);\n+        }\n+    }\n+\n+    /**\n+     * Sets a mapping defined on field variables\n+     *\n+     * @param indexName - Index where mapping will be updated\n+     * @return Collection of fields names whose mapping was set\n+     */\n+    private Set<String> addCustomMappingFromFieldVariables(final String indexName) {\n+        final FieldFactory fieldFactory = FactoryLocator.getFieldFactory();\n+        final Set<String> mappedFields = new HashSet<>();\n+\n+        try {\n+            //Find field variables\n+            final List<FieldVariable> fieldVariables = fieldFactory\n+                    .byFieldVariableKey(FieldVariable.ES_CUSTOM_MAPPING_KEY);\n+\n+            for (final FieldVariable fieldVariable : fieldVariables) {\n+                Field field = null;\n+                ContentType type = null;\n+                try {\n+                    field = fieldFactory.byId(fieldVariable.fieldId());\n+                    type = contentTypeAPI.find(field.contentTypeId());\n+                    final JSONObject jsonObject = new JSONObject();\n+                    final JSONObject properties = new JSONObject();\n+\n+                    jsonObject.put(type.variable().toLowerCase(),\n+                            new JSONObject()\n+                                    .put(\"properties\", new JSONObject()\n+                                            .put(field.variable()\n+                                                            .toLowerCase(),\n+                                                    new JSONObject(fieldVariable.value()))));\n+                    properties.put(\"properties\", jsonObject);\n+                    esMappingAPI.putMapping(indexName, properties.toString());\n+\n+                    //Adds to the set the mapped already set for this field\n+                    mappedFields.add((type.variable() + StringPool.PERIOD + field.variable())\n+                            .toLowerCase());\n+\n+                } catch (Exception e) {\n+                    handleInvalidCustomMappingError(indexName,\n+                            type != null ? type.variable() + \".\" + field.variable() : \"[]\");\n+                    String message = \"Error setting custom index mapping from field variable \"\n+                            + fieldVariable.key();\n+\n+                    if (field != null) {\n+                        message += \". Field: \" + field.name();\n+                    }\n+\n+                    if (type != null) {\n+                        message += \". Content Type: \" + type.name();\n+                    }\n+\n+                    message += \". Custom mapping will be ignored for index: \" + indexName;\n+                    Logger.warn(ESMappingUtilHelper.class, message, e);\n+                }\n+            }\n+        } catch (DotDataException e) {\n+            Logger.warn(ESMappingUtilHelper.class,\n+                    \"Error setting custom index mapping for index \" + indexName, e);\n+        }\n+        return mappedFields;\n+    }\n+\n+    /**\n+     *\n+     * @param indexName Index where the mapping will be applied\n+     * @param mappedFields Collection of fields already mapped in the index. This collection is used to avoid duplicate mappings for fields, which could cause an explosion\n+     */\n+    private void addMappingForRemainingFields(final String indexName,\n+            final Set<String> mappedFields) {\n+        try {\n+            final List<ContentType> contentTypes = contentTypeAPI.findAll();\n+            contentTypes.forEach(contentType -> contentType.fields().forEach(\n+                    field -> addMappingForFieldIfNeeded(indexName, contentType, field,\n+                            mappedFields)));\n+        } catch (DotDataException e) {\n+            Logger.warnAndDebug(ESMappingUtilHelper.class,\n+                    \"It was not possible to get content types to map field types in Elasticsearch\"\n+                            + indexName, e);\n+        }\n+    }\n+\n+    /**\n+     * Defines an ES custom mapping for dates, numbers and text fields, excluding those that match the mapping defined in the `es-content.mapping.json` file\n+     * @param indexName Index where the mapping will be applied\n+     * @param contentType Content type's whose field will be mapped\n+     * @param field Field to be mapped\n+     * @param mappedFields Collection of fields already mapped in the index. This collection is used to avoid duplicate mappings for fields, which could cause an explosion\n+     */\n+    private void addMappingForFieldIfNeeded(final String indexName,\n+            final ContentType contentType, final Field field, final Set<String> mappedFields) {\n+        final String fieldVariableName = (contentType.variable() + StringPool.PERIOD + field.variable())\n+                        .toLowerCase();\n+        if (!mappedFields.contains(fieldVariableName)) {\n+            String mappingForField = null;\n+            if (field instanceof DateField || field instanceof DateTimeField\n+                    || field instanceof TimeField) {\n+                mappingForField = \"\\\"type\\\":\\\"date\\\",\\n\";\n+                mappingForField += \"\\\"format\\\": \\\"yyyy-MM-dd't'HH:mm:ss||MMM d, yyyy h:mm:ss a||yyyy-MM-dd HH:mm:ss||yyyy-MM-dd||epoch_millis\\\"\\n\";", "originalCommit": "e6002906f706b0ec3e63bfb87e15bd5a0102b506", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk4OTQxMQ==", "url": "https://github.com/dotCMS/core/pull/18751#discussion_r453989411", "bodyText": "Codacy found an issue: JUnit tests should include assert() or fail()", "author": "dev-dotcms", "createdAt": "2020-07-13T22:44:47Z", "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/util/ESMappingUtilHelperTest.java", "diffHunk": "@@ -0,0 +1,570 @@\n+package com.dotcms.content.elasticsearch.util;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import com.dotcms.content.elasticsearch.business.ContentletIndexAPI;\n+import com.dotcms.content.elasticsearch.business.DotIndexException;\n+import com.dotcms.content.elasticsearch.business.ESIndexAPI;\n+import com.dotcms.content.elasticsearch.business.ESMappingAPIImpl;\n+import com.dotcms.content.elasticsearch.business.IndexType;\n+import com.dotcms.contenttype.business.ContentTypeAPI;\n+import com.dotcms.contenttype.business.FieldAPI;\n+import com.dotcms.contenttype.exception.NotFoundInDbException;\n+import com.dotcms.contenttype.model.field.DataTypes;\n+import com.dotcms.contenttype.model.field.DateField;\n+import com.dotcms.contenttype.model.field.DateTimeField;\n+import com.dotcms.contenttype.model.field.Field;\n+import com.dotcms.contenttype.model.field.FieldBuilder;\n+import com.dotcms.contenttype.model.field.FieldVariable;\n+import com.dotcms.contenttype.model.field.ImmutableFieldVariable;\n+import com.dotcms.contenttype.model.field.RadioField;\n+import com.dotcms.contenttype.model.field.RelationshipField;\n+import com.dotcms.contenttype.model.field.SelectField;\n+import com.dotcms.contenttype.model.field.TextField;\n+import com.dotcms.contenttype.model.type.ContentType;\n+import com.dotcms.datagen.ContentTypeDataGen;\n+import com.dotcms.datagen.ContentletDataGen;\n+import com.dotcms.datagen.FieldDataGen;\n+import com.dotcms.datagen.TestDataUtils;\n+import com.dotcms.util.CollectionsUtils;\n+import com.dotcms.util.IntegrationTestInitService;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.RelationshipAPI;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.portlets.categories.business.CategoryAPI;\n+import com.dotmarketing.portlets.categories.model.Category;\n+import com.dotmarketing.portlets.contentlet.business.ContentletAPI;\n+import com.dotmarketing.portlets.contentlet.model.Contentlet;\n+import com.dotmarketing.portlets.languagesmanager.model.Language;\n+import com.dotmarketing.portlets.structure.model.Relationship;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.UtilMethods;\n+import com.dotmarketing.util.WebKeys.Relationship.RELATIONSHIP_CARDINALITY;\n+import com.dotmarketing.util.json.JSONObject;\n+import com.liferay.portal.model.User;\n+import com.liferay.util.StringPool;\n+import com.tngtech.java.junit.dataprovider.DataProvider;\n+import com.tngtech.java.junit.dataprovider.DataProviderRunner;\n+import com.tngtech.java.junit.dataprovider.UseDataProvider;\n+import com.tngtech.junit.dataprovider.format.DataProviderTestNameFormatter;\n+import java.io.IOException;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+/**\n+ * Class used to validate ES mapping for fields is applied correctly considering fields types and dynamic mapping defined in `es-content-mapping.json`\n+ * @author nollymar\n+ */\n+@RunWith(DataProviderRunner.class)\n+public class ESMappingUtilHelperTest {\n+\n+    private static User user;\n+    private static CategoryAPI categoryAPI;\n+    private static ContentletAPI contentletAPI;\n+    private static ContentletIndexAPI contentletIndexAPI;\n+    private static ContentTypeAPI contentTypeAPI;\n+    private static ESMappingAPIImpl esMappingAPI;\n+    private static FieldAPI fieldAPI;\n+    private static RelationshipAPI relationshipAPI;\n+    private static Language language;\n+\n+    @BeforeClass\n+    public static void prepare() throws Exception {\n+        //Setting web app environment\n+        IntegrationTestInitService.getInstance().init();\n+\n+        user = APILocator.systemUser();\n+        categoryAPI = APILocator.getCategoryAPI();\n+        contentletAPI = APILocator.getContentletAPI();\n+        contentletIndexAPI = APILocator.getContentletIndexAPI();\n+        contentTypeAPI = APILocator.getContentTypeAPI(user);\n+        esMappingAPI = new ESMappingAPIImpl();\n+        fieldAPI = APILocator.getContentTypeFieldAPI();\n+        relationshipAPI = APILocator.getRelationshipAPI();\n+        language = APILocator.getLanguageAPI().getDefaultLanguage();\n+    }\n+\n+    public static class PlusTestNameFormatter implements DataProviderTestNameFormatter {\n+        @Override\n+        public String format(Method testMethod, int invocationIndex, List<Object> arguments) {\n+            return String.format(\"Test Name: %s. Mapping Name: %s\", testMethod.getName(), arguments.get(0));\n+        }\n+    }\n+\n+    @DataProvider(formatter = PlusTestNameFormatter.class)\n+    public static Object[][] dataProviderValidateEventMapping(){\n+        return new Object[][] {\n+                {\"template_1\", new String[]{\"host.hostname_dotraw\"}, \"keyword\"},\n+                {\"textmapping\", new String[]{\"host.hostname\"}, \"keyword\"},\n+                {\"strings_as_dates\", new String[]{\"calendarevent.originalstartdate\",\n+                        \"calendarevent.recurrencestart\", \"calendarevent.recurrenceend\"}, \"date\"},\n+                {\"permissions\", new String[]{\"permissions\"}, \"text\"},\n+                {\"hostname\", new String[]{\"host.hostname_text\"}, \"text\"}\n+        };\n+    }\n+\n+    @DataProvider(formatter = PlusTestNameFormatter.class)\n+    public static Object[][] dataProviderValidateFileAssetMapping(){\n+        return new Object[][] {\n+                {\"longmapping\", new String[]{ \"metadata.height\", \"metadata.width\"}, \"long\"},\n+                {\"keywordmapping\", new String[]{\"metadata.contenttype\"}, \"keyword\"}\n+        };\n+    }\n+\n+    @DataProvider(formatter = PlusTestNameFormatter.class)\n+    public static Object[][] dataProviderValidateNewsLikeMapping() {\n+        return new Object[][]{\n+                {\"geomapping\", new String[]{\"mylatlon\"}, \"geo_point\"},\n+                {\"geomapping_2\", new String[]{\"latlong\"}, \"geo_point\"},\n+                {\"keywordmapping\", new String[]{\"categories\", \"tags\", \"conhost\", \"conhostname\",\n+                        \"wfstep\", \"structurename\", \"contenttype\", \"parentpath\", \"path\", \"urlmap\",\n+                        \"moduser\", \"owner\"}, \"keyword\"}\n+        };\n+    }\n+\n+    /*Data provider used to verify that the ES mapping is applied correctly and considers exclusions in the `es-content-mapping` file\n+        For each scenario we define:\n+            1) testCase name\n+            2) Field(s) type\n+            3) Field(s) variable name(s)\n+            4) Expected ES mapping\n+     */\n+    @DataProvider(formatter = PlusTestNameFormatter.class)\n+    public static Object[][] dataProviderAddMappingForFields() {\n+        return new Object[][] {\n+                {  \"strings_as_dates\", DateField.class, DataTypes.DATE,\n+                        new String[] {\"originalstartdate\", \"recurrencestart\", \"recurrenceend\"},  \"date\" },\n+\n+                {  \"strings_as_date_times\", DateTimeField.class, DataTypes.DATE,\n+                        new String[] {\"originalstartdate\", \"recurrencestart\", \"recurrenceend\"},  \"date\" },\n+\n+                {  \"dates_as_text\", TextField.class, DataTypes.TEXT,\n+                        new String[] {\"originalstartdate\", \"recurrencestart\", \"recurrenceend\"},  \"text\" },\n+\n+                {  \"keywordmapping\", TextField.class, DataTypes.TEXT,\n+                        new String[] {\"categories\", \"tags\", \"conhost\",\n+                                \"wfstep\", \"structurename\", \"contenttype\", \"parentpath\",\n+                                \"path\", \"urlmap\", \"moduser\", \"owner\"},  \"text\" },\n+\n+                {  \"geomapping\", TextField.class, DataTypes.TEXT,\n+                        new String[] {\"mylatlong\", \"mylatlon\"},  null },\n+\n+                {  \"permissions\", TextField.class, DataTypes.TEXT, new String[] {\"permissions\"},  \"text\" },\n+\n+                {  \"radio_as_boolean\", RadioField.class, DataTypes.BOOL,\n+                        new String[] {\"MyRadioAsBoolean\"},  \"boolean\" },\n+\n+                {  \"radio_as_float\", RadioField.class, DataTypes.FLOAT,\n+                        new String[] {\"MyRadioAsFloat\"},  \"float\" },\n+\n+                {  \"radio_as_integer\", RadioField.class, DataTypes.INTEGER,\n+                        new String[] {\"MyRadioAsInteger\"},  \"integer\" },\n+\n+                {  \"select_as_boolean\", SelectField.class, DataTypes.BOOL,\n+                        new String[] {\"MySelectAsBoolean\"},  \"boolean\" },\n+\n+                {  \"select_as_float\", SelectField.class, DataTypes.FLOAT,\n+                        new String[] {\"MySelectAsFloat\"},  \"float\" },\n+\n+                {  \"select_as_integer\", SelectField.class, DataTypes.INTEGER,\n+                        new String[] {\"MySelectAsInteger\"},  \"integer\" },\n+\n+                {  \"text_as_float\", TextField.class, DataTypes.FLOAT,\n+                        new String[] {\"MyTextAsFloat\"},  \"float\" },\n+\n+                {  \"text_as_integer\", TextField.class, DataTypes.INTEGER,\n+                        new String[] {\"MyTextAsInteger\"},  \"integer\" }\n+        };\n+    }\n+\n+    /**\n+     * <b>Method to test:</b> Internally, it tests the method ESMappingUtilHelper.addMappingForFieldIfNeeded<p></p>\n+     * <b>Test Case:</b> Given a field or an array of fields, the right ES mapping should be set, considering exclusions in the `es-content-mapping` file<p></p>\n+     * <b>Expected Results:</b> Each test case should match the `expectedResult` value, which is a string with the correct datatype in ES\n+     * @param testCase\n+     * @param fieldType\n+     * @param type\n+     * @param fields\n+     * @param expectedResult\n+     * @throws IOException\n+     * @throws DotIndexException\n+     * @throws DotSecurityException\n+     * @throws DotDataException\n+     */\n+    @UseDataProvider\n+    @Test\n+    public void testAddMappingForFields(final String testCase, final Class fieldType,\n+            final DataTypes type,\n+            final String[] fields, final String expectedResult)\n+            throws IOException, DotIndexException, DotSecurityException, DotDataException {\n+\n+        Logger.info(ESMappingUtilHelperTest.class,\n+                String.format(\"Testing Add Mapping for fields defined in %s template\", testCase));\n+\n+        final ContentType contentType = new ContentTypeDataGen().nextPersisted();\n+\n+        String workingIndex = null;\n+        //Build the index name\n+        String timestamp = String.valueOf(new Date().getTime());\n+        try {\n+            //Adding fields\n+            for (final String field : fields) {\n+                final Field newField = FieldBuilder.builder(fieldType)\n+                        .name(field).variable(field).dataType(type).contentTypeId(contentType.id())\n+                        .indexed(true).build();\n+                fieldAPI.save(newField, user);\n+            }\n+\n+            workingIndex = new ESIndexAPI().getNameWithClusterIDPrefix(\n+                    IndexType.WORKING.getPrefix() + \"_\" + timestamp);\n+\n+            //Create a working index\n+            boolean result = contentletIndexAPI.createContentIndex(workingIndex);\n+            //Validate\n+            assertTrue(result);\n+\n+            for (final String field : fields) {\n+\n+                if (expectedResult == null) {\n+                    assertFalse(UtilMethods.isSet(esMappingAPI.getFieldMappingAsMap(workingIndex,\n+                            (contentType.variable() + StringPool.PERIOD + field).toLowerCase())));\n+                } else {\n+                    Map<String, String> mapping = (Map<String, String>) esMappingAPI\n+                            .getFieldMappingAsMap(workingIndex,\n+                                    (contentType.variable() + StringPool.PERIOD + field)\n+                                            .toLowerCase()).get(field.toLowerCase());\n+                    assertTrue(UtilMethods.isSet(mapping.get(\"type\")));\n+                    assertEquals(expectedResult, mapping.get(\"type\"));\n+                }\n+            }\n+\n+        } finally {\n+            if (workingIndex != null) {\n+                contentletIndexAPI.delete(workingIndex);\n+            }\n+\n+            if (contentType != null) {\n+                contentTypeAPI.delete(contentType);\n+            }\n+        }\n+    }\n+\n+\n+    /**\n+     * <b>Method to test:</b> Internally, it tests the methods ESMappingUtilHelper.addCustomMappingForRelationships and </p>\n+     * ESMappingUtilHelper.addCustomMappingFromFieldVariables<p></p>\n+     * </p><b>Test Case:</b> This test creates an index with two custom mapped fields: a text field and a relationship field.\n+     * Additionally, it creates a legacy relationship without a custom mapping in order to verify that\n+     * relationships in general are mapped as keywords by default, unless a custom mapping is defined for a specific case <p></p>\n+     * <b>Expected Results:</b> Custom mappings should take precedence always if exists. In case of relationships, </p>\n+     * they should be mapped as keywords, unless a custom mapping is defined\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testCreateContentIndexWithCustomMappings() throws Exception {\n+\n+        String workingIndex = null;\n+        ContentType parentContentType = null;\n+        ContentType childContentType = null;\n+        try {\n+            parentContentType = new ContentTypeDataGen().nextPersisted();\n+            childContentType = new ContentTypeDataGen().nextPersisted();\n+\n+            //Adding fields\n+            Field ageField = FieldBuilder.builder(TextField.class)\n+                    .name(\"age\").contentTypeId(parentContentType.id()).indexed(false).build();\n+            ageField = fieldAPI.save(ageField, user);\n+\n+            Field relationshipField = FieldBuilder.builder(RelationshipField.class)\n+                    .name(\"relationshipField\")\n+                    .contentTypeId(parentContentType.id())\n+                    .values(String.valueOf(RELATIONSHIP_CARDINALITY.ONE_TO_MANY.ordinal()))\n+                    .relationType(parentContentType.variable()).build();\n+\n+            relationshipField = fieldAPI.save(relationshipField, user);\n+\n+            //Create legacy relationship\n+            final Relationship legacyRelationship = createLegacyRelationship(parentContentType,\n+                    childContentType);\n+\n+            //Adding field variables\n+            final FieldVariable ageVariable = ImmutableFieldVariable.builder()\n+                    .fieldId(ageField.inode())\n+                    .name(\"ageMapping\").key(FieldVariable.ES_CUSTOM_MAPPING_KEY).value(\"{\\n\"\n+                            + \"                \\\"type\\\": \\\"long\\\"\\n\"\n+                            + \"              }\").userId(user.getUserId())\n+                    .build();\n+\n+            fieldAPI.save(ageVariable, user);\n+\n+            FieldVariable relVariable = ImmutableFieldVariable.builder()\n+                    .fieldId(relationshipField.inode())\n+                    .name(\"relMapping\").key(FieldVariable.ES_CUSTOM_MAPPING_KEY).value(\"{\\n\"\n+                            + \"                \\\"type\\\": \\\"text\\\"\\n\"\n+                            + \"              }\").userId(user.getUserId())\n+                    .build();\n+\n+            relVariable = fieldAPI.save(relVariable, user);\n+\n+            final Field updatedField = fieldAPI.find(relVariable.fieldId());\n+\n+            //Verify ageField is updated as System Indexed\n+            assertTrue(updatedField.indexed());\n+\n+            //Build the index name\n+            String timestamp = String.valueOf(new Date().getTime());\n+            workingIndex = new ESIndexAPI().getNameWithClusterIDPrefix(IndexType.WORKING.getPrefix() + \"_\" + timestamp);\n+\n+            //Create a working index\n+            boolean result = contentletIndexAPI.createContentIndex(workingIndex);\n+            //Validate\n+            assertTrue(result);\n+\n+            //verify mapping\n+            final String mapping = esMappingAPI.getMapping(workingIndex);\n+\n+            //parse json mapping and validate\n+            assertNotNull(mapping);\n+\n+            final JSONObject propertiesJSON = (JSONObject) (new JSONObject(mapping)).get(\"properties\");\n+            final JSONObject contentTypeJSON = (JSONObject) ((JSONObject) propertiesJSON\n+                    .get(parentContentType.variable().toLowerCase())).get(\"properties\");\n+\n+            //validate age mapping results\n+            final Map ageMapping = ((JSONObject) contentTypeJSON\n+                    .get(ageField.variable().toLowerCase())).getAsMap();\n+            assertNotNull(ageMapping);\n+            assertEquals(1, ageMapping.size());\n+            assertEquals(\"long\", ageMapping.get(\"type\"));\n+\n+            //validate relationship field mapping results\n+            final Map relationshipMapping = ((JSONObject) contentTypeJSON\n+                    .get(relationshipField.variable().toLowerCase())).getAsMap();\n+            assertNotNull(relationshipMapping);\n+            assertEquals(1, relationshipMapping.size());\n+            assertEquals(\"text\", relationshipMapping.get(\"type\"));\n+\n+            //validate legacy relationship\n+            final Map legacyRelationshipMapping = ((JSONObject) propertiesJSON\n+                    .get(legacyRelationship.getRelationTypeValue().toLowerCase())).getAsMap();\n+            assertNotNull(ageMapping);\n+            assertEquals(2, legacyRelationshipMapping.size());\n+            assertEquals(\"keyword\", legacyRelationshipMapping.get(\"type\"));\n+            assertEquals(8191, legacyRelationshipMapping.get(\"ignore_above\"));\n+\n+        } finally {\n+            if (workingIndex != null) {\n+                contentletIndexAPI.delete(workingIndex);\n+            }\n+\n+            if (parentContentType != null && parentContentType.inode() != null) {\n+                ContentTypeDataGen.remove(parentContentType);\n+            }\n+\n+            if (childContentType != null && childContentType.inode() != null) {\n+                ContentTypeDataGen.remove(childContentType);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * <b>Test Case:</b> Validates dynamic mappings defined in the `es-content-mapping` file are applied correctly<p></p>\n+     * <b>Expected Results:</b> Each test case should match the `expectedResult` value, which is a string with the correct datatype in ES\n+     * @param testCase\n+     * @param fields\n+     * @param expectedResult\n+     * @throws DotDataException\n+     * @throws IOException\n+     * @throws DotSecurityException\n+     */\n+    @UseDataProvider\n+    @Test\n+    public void testValidateNewsLikeMapping(final String testCase, final String[] fields, final String expectedResult)", "originalCommit": "e6002906f706b0ec3e63bfb87e15bd5a0102b506", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk4OTQxNA==", "url": "https://github.com/dotCMS/core/pull/18751#discussion_r453989414", "bodyText": "Codacy found an issue: The String literal \"mylatlon\" appears 5 times in this file; the first occurrence is on line 125", "author": "dev-dotcms", "createdAt": "2020-07-13T22:44:48Z", "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/util/ESMappingUtilHelperTest.java", "diffHunk": "@@ -0,0 +1,570 @@\n+package com.dotcms.content.elasticsearch.util;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import com.dotcms.content.elasticsearch.business.ContentletIndexAPI;\n+import com.dotcms.content.elasticsearch.business.DotIndexException;\n+import com.dotcms.content.elasticsearch.business.ESIndexAPI;\n+import com.dotcms.content.elasticsearch.business.ESMappingAPIImpl;\n+import com.dotcms.content.elasticsearch.business.IndexType;\n+import com.dotcms.contenttype.business.ContentTypeAPI;\n+import com.dotcms.contenttype.business.FieldAPI;\n+import com.dotcms.contenttype.exception.NotFoundInDbException;\n+import com.dotcms.contenttype.model.field.DataTypes;\n+import com.dotcms.contenttype.model.field.DateField;\n+import com.dotcms.contenttype.model.field.DateTimeField;\n+import com.dotcms.contenttype.model.field.Field;\n+import com.dotcms.contenttype.model.field.FieldBuilder;\n+import com.dotcms.contenttype.model.field.FieldVariable;\n+import com.dotcms.contenttype.model.field.ImmutableFieldVariable;\n+import com.dotcms.contenttype.model.field.RadioField;\n+import com.dotcms.contenttype.model.field.RelationshipField;\n+import com.dotcms.contenttype.model.field.SelectField;\n+import com.dotcms.contenttype.model.field.TextField;\n+import com.dotcms.contenttype.model.type.ContentType;\n+import com.dotcms.datagen.ContentTypeDataGen;\n+import com.dotcms.datagen.ContentletDataGen;\n+import com.dotcms.datagen.FieldDataGen;\n+import com.dotcms.datagen.TestDataUtils;\n+import com.dotcms.util.CollectionsUtils;\n+import com.dotcms.util.IntegrationTestInitService;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.RelationshipAPI;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.portlets.categories.business.CategoryAPI;\n+import com.dotmarketing.portlets.categories.model.Category;\n+import com.dotmarketing.portlets.contentlet.business.ContentletAPI;\n+import com.dotmarketing.portlets.contentlet.model.Contentlet;\n+import com.dotmarketing.portlets.languagesmanager.model.Language;\n+import com.dotmarketing.portlets.structure.model.Relationship;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.UtilMethods;\n+import com.dotmarketing.util.WebKeys.Relationship.RELATIONSHIP_CARDINALITY;\n+import com.dotmarketing.util.json.JSONObject;\n+import com.liferay.portal.model.User;\n+import com.liferay.util.StringPool;\n+import com.tngtech.java.junit.dataprovider.DataProvider;\n+import com.tngtech.java.junit.dataprovider.DataProviderRunner;\n+import com.tngtech.java.junit.dataprovider.UseDataProvider;\n+import com.tngtech.junit.dataprovider.format.DataProviderTestNameFormatter;\n+import java.io.IOException;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+/**\n+ * Class used to validate ES mapping for fields is applied correctly considering fields types and dynamic mapping defined in `es-content-mapping.json`\n+ * @author nollymar\n+ */\n+@RunWith(DataProviderRunner.class)\n+public class ESMappingUtilHelperTest {\n+\n+    private static User user;\n+    private static CategoryAPI categoryAPI;\n+    private static ContentletAPI contentletAPI;\n+    private static ContentletIndexAPI contentletIndexAPI;\n+    private static ContentTypeAPI contentTypeAPI;\n+    private static ESMappingAPIImpl esMappingAPI;\n+    private static FieldAPI fieldAPI;\n+    private static RelationshipAPI relationshipAPI;\n+    private static Language language;\n+\n+    @BeforeClass\n+    public static void prepare() throws Exception {\n+        //Setting web app environment\n+        IntegrationTestInitService.getInstance().init();\n+\n+        user = APILocator.systemUser();\n+        categoryAPI = APILocator.getCategoryAPI();\n+        contentletAPI = APILocator.getContentletAPI();\n+        contentletIndexAPI = APILocator.getContentletIndexAPI();\n+        contentTypeAPI = APILocator.getContentTypeAPI(user);\n+        esMappingAPI = new ESMappingAPIImpl();\n+        fieldAPI = APILocator.getContentTypeFieldAPI();\n+        relationshipAPI = APILocator.getRelationshipAPI();\n+        language = APILocator.getLanguageAPI().getDefaultLanguage();\n+    }\n+\n+    public static class PlusTestNameFormatter implements DataProviderTestNameFormatter {\n+        @Override\n+        public String format(Method testMethod, int invocationIndex, List<Object> arguments) {\n+            return String.format(\"Test Name: %s. Mapping Name: %s\", testMethod.getName(), arguments.get(0));\n+        }\n+    }\n+\n+    @DataProvider(formatter = PlusTestNameFormatter.class)\n+    public static Object[][] dataProviderValidateEventMapping(){\n+        return new Object[][] {\n+                {\"template_1\", new String[]{\"host.hostname_dotraw\"}, \"keyword\"},\n+                {\"textmapping\", new String[]{\"host.hostname\"}, \"keyword\"},\n+                {\"strings_as_dates\", new String[]{\"calendarevent.originalstartdate\",\n+                        \"calendarevent.recurrencestart\", \"calendarevent.recurrenceend\"}, \"date\"},\n+                {\"permissions\", new String[]{\"permissions\"}, \"text\"},\n+                {\"hostname\", new String[]{\"host.hostname_text\"}, \"text\"}\n+        };\n+    }\n+\n+    @DataProvider(formatter = PlusTestNameFormatter.class)\n+    public static Object[][] dataProviderValidateFileAssetMapping(){\n+        return new Object[][] {\n+                {\"longmapping\", new String[]{ \"metadata.height\", \"metadata.width\"}, \"long\"},\n+                {\"keywordmapping\", new String[]{\"metadata.contenttype\"}, \"keyword\"}\n+        };\n+    }\n+\n+    @DataProvider(formatter = PlusTestNameFormatter.class)\n+    public static Object[][] dataProviderValidateNewsLikeMapping() {\n+        return new Object[][]{\n+                {\"geomapping\", new String[]{\"mylatlon\"}, \"geo_point\"},", "originalCommit": "e6002906f706b0ec3e63bfb87e15bd5a0102b506", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk4OTQyMA==", "url": "https://github.com/dotCMS/core/pull/18751#discussion_r453989420", "bodyText": "Codacy found an issue: Prefer StringBuilder (non-synchronized) or StringBuffer (synchronized) over += for concatenating strings", "author": "dev-dotcms", "createdAt": "2020-07-13T22:44:49Z", "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/util/ESMappingUtilHelper.java", "diffHunk": "@@ -0,0 +1,331 @@\n+package com.dotcms.content.elasticsearch.util;\n+\n+import com.dotcms.api.system.event.message.MessageSeverity;\n+import com.dotcms.api.system.event.message.MessageType;\n+import com.dotcms.api.system.event.message.SystemMessageEventUtil;\n+import com.dotcms.api.system.event.message.builder.SystemMessageBuilder;\n+import com.dotcms.business.CloseDBIfOpened;\n+import com.dotcms.content.elasticsearch.business.ESIndexAPI;\n+import com.dotcms.content.elasticsearch.business.ESMappingAPIImpl;\n+import com.dotcms.contenttype.business.ContentTypeAPI;\n+import com.dotcms.contenttype.business.FieldFactory;\n+import com.dotcms.contenttype.model.field.DataTypes;\n+import com.dotcms.contenttype.model.field.DateField;\n+import com.dotcms.contenttype.model.field.DateTimeField;\n+import com.dotcms.contenttype.model.field.Field;\n+import com.dotcms.contenttype.model.field.FieldVariable;\n+import com.dotcms.contenttype.model.field.RadioField;\n+import com.dotcms.contenttype.model.field.SelectField;\n+import com.dotcms.contenttype.model.field.TextAreaField;\n+import com.dotcms.contenttype.model.field.TextField;\n+import com.dotcms.contenttype.model.field.TimeField;\n+import com.dotcms.contenttype.model.field.WysiwygField;\n+import com.dotcms.contenttype.model.type.ContentType;\n+import com.dotcms.repackage.com.google.common.annotations.VisibleForTesting;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.FactoryLocator;\n+import com.dotmarketing.business.RelationshipAPI;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.portlets.structure.model.Relationship;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.json.JSONObject;\n+import com.jayway.jsonpath.JsonPath;\n+import com.liferay.portal.language.LanguageException;\n+import com.liferay.portal.language.LanguageUtil;\n+import com.liferay.util.StringPool;\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.URL;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper class responsible of setting Elasticsearch mapping for content type fields\n+ * @author nollymar\n+ */\n+public class ESMappingUtilHelper {\n+\n+    private ContentTypeAPI contentTypeAPI;\n+    private ESMappingAPIImpl esMappingAPI;\n+    private RelationshipAPI relationshipAPI;\n+\n+    private static class SingletonHolder {\n+\n+        private static final ESMappingUtilHelper INSTANCE = new ESMappingUtilHelper();\n+    }\n+\n+    public static ESMappingUtilHelper getInstance() {\n+        return ESMappingUtilHelper.SingletonHolder.INSTANCE;\n+    }\n+\n+    private ESMappingUtilHelper() {\n+        contentTypeAPI = APILocator.getContentTypeAPI(APILocator.systemUser());\n+        esMappingAPI = new ESMappingAPIImpl();\n+        relationshipAPI = APILocator.getRelationshipAPI();\n+    }\n+\n+    @VisibleForTesting\n+    ESMappingUtilHelper(final ContentTypeAPI contentTypeAPI, final ESMappingAPIImpl esMappingAPI,\n+            final RelationshipAPI relationshipAPI) {\n+        this.contentTypeAPI = contentTypeAPI;\n+        this.esMappingAPI = esMappingAPI;\n+        this.relationshipAPI = relationshipAPI;\n+    }\n+\n+    /**\n+     * Sets a custom index mapping for relationships and also for mapping defined on field variables\n+     * using `esCustomMapping` property\n+     *\n+     * @param indexName - Index where mapping will be updated\n+     */\n+    @CloseDBIfOpened\n+    public void addCustomMapping(final String indexName) {\n+\n+        final Set<String> mappedFields = addCustomMappingFromFieldVariables(indexName);\n+\n+        addCustomMappingForRelationships(indexName, mappedFields);\n+\n+        addMappingForRemainingFields(indexName, mappedFields);\n+    }\n+\n+    /**\n+     * Sets a mapping for all relationships except for those that contains its custom mapping using\n+     * field variables\n+     *\n+     * @param indexName - Index where mapping will be updated\n+     * @param mappedFields - Collection that contains the fields with a specific mapping until now.\n+     * </br> When a put mapping request is sent to Elasticsearch for each relationship (if needed),\n+     * a new entry is added to the <b>mappedFields</b> collection\n+     */\n+    private void addCustomMappingForRelationships(final String indexName,\n+            final Set<String> mappedFields) {\n+        final List<Relationship> relationships = relationshipAPI.dbAll();\n+\n+        for (final Relationship relationship : relationships) {\n+            final String relationshipName = relationship.getRelationTypeValue().toLowerCase();\n+            if (!mappedFields.contains(relationshipName)) {\n+                final JSONObject properties = new JSONObject();\n+                try {\n+                    properties.put(\"properties\", new JSONObject()\n+                            .put(relationshipName,\n+                                    new JSONObject(\"{\\n\"\n+                                            + \"\\\"type\\\":  \\\"keyword\\\",\\n\"\n+                                            + \"\\\"ignore_above\\\": 8191\\n\"\n+                                            + \"}\")));\n+                    esMappingAPI.putMapping(indexName, properties.toString());\n+\n+                    //Adds to the set the mapped already set for this field\n+                    mappedFields.add(relationshipName);\n+                } catch (Exception e) {\n+                    handleInvalidCustomMappingError(indexName, relationshipName);\n+                    final String message =\n+                            \"Error updating index mapping for relationship \" + relationshipName\n+                                    + \". This custom mapping will be ignored for index: \"\n+                                    + indexName;\n+                    Logger.warn(ESMappingUtilHelper.class, message, e);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Creates a system message event with an error in case a field mapping fails\n+     * @param indexName - Index where the mapping is trying to be applied\n+     * @param fieldName - Field whose mapping is trying to be applied to\n+     */\n+    private void handleInvalidCustomMappingError(final String indexName,\n+            final String fieldName) {\n+\n+        final SystemMessageEventUtil systemMessageEventUtil = SystemMessageEventUtil.getInstance();\n+\n+        try {\n+            systemMessageEventUtil.pushMessage(\n+                    new SystemMessageBuilder()\n+                            .setMessage(LanguageUtil.format(Locale.getDefault(),\n+                                    \"notification.reindexing.custom.mapping.error\",\n+                                    new String[]{fieldName, indexName}, false))\n+                            .setSeverity(MessageSeverity.ERROR)\n+                            .setType(MessageType.SIMPLE_MESSAGE)\n+                            .setLife(6000)\n+                            .create(), null);\n+        } catch (LanguageException ex) {\n+            throw new RuntimeException(ex);\n+        }\n+    }\n+\n+    /**\n+     * Sets a mapping defined on field variables\n+     *\n+     * @param indexName - Index where mapping will be updated\n+     * @return Collection of fields names whose mapping was set\n+     */\n+    private Set<String> addCustomMappingFromFieldVariables(final String indexName) {\n+        final FieldFactory fieldFactory = FactoryLocator.getFieldFactory();\n+        final Set<String> mappedFields = new HashSet<>();\n+\n+        try {\n+            //Find field variables\n+            final List<FieldVariable> fieldVariables = fieldFactory\n+                    .byFieldVariableKey(FieldVariable.ES_CUSTOM_MAPPING_KEY);\n+\n+            for (final FieldVariable fieldVariable : fieldVariables) {\n+                Field field = null;\n+                ContentType type = null;\n+                try {\n+                    field = fieldFactory.byId(fieldVariable.fieldId());\n+                    type = contentTypeAPI.find(field.contentTypeId());\n+                    final JSONObject jsonObject = new JSONObject();\n+                    final JSONObject properties = new JSONObject();\n+\n+                    jsonObject.put(type.variable().toLowerCase(),\n+                            new JSONObject()\n+                                    .put(\"properties\", new JSONObject()\n+                                            .put(field.variable()\n+                                                            .toLowerCase(),\n+                                                    new JSONObject(fieldVariable.value()))));\n+                    properties.put(\"properties\", jsonObject);\n+                    esMappingAPI.putMapping(indexName, properties.toString());\n+\n+                    //Adds to the set the mapped already set for this field\n+                    mappedFields.add((type.variable() + StringPool.PERIOD + field.variable())\n+                            .toLowerCase());\n+\n+                } catch (Exception e) {\n+                    handleInvalidCustomMappingError(indexName,\n+                            type != null ? type.variable() + \".\" + field.variable() : \"[]\");\n+                    String message = \"Error setting custom index mapping from field variable \"\n+                            + fieldVariable.key();\n+\n+                    if (field != null) {\n+                        message += \". Field: \" + field.name();", "originalCommit": "e6002906f706b0ec3e63bfb87e15bd5a0102b506", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk4OTQyMg==", "url": "https://github.com/dotCMS/core/pull/18751#discussion_r453989422", "bodyText": "Codacy found an issue: Avoid unused imports such as 'com.dotcms.content.elasticsearch.business.ESIndexAPI'", "author": "dev-dotcms", "createdAt": "2020-07-13T22:44:49Z", "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/util/ESMappingUtilHelper.java", "diffHunk": "@@ -0,0 +1,331 @@\n+package com.dotcms.content.elasticsearch.util;\n+\n+import com.dotcms.api.system.event.message.MessageSeverity;\n+import com.dotcms.api.system.event.message.MessageType;\n+import com.dotcms.api.system.event.message.SystemMessageEventUtil;\n+import com.dotcms.api.system.event.message.builder.SystemMessageBuilder;\n+import com.dotcms.business.CloseDBIfOpened;\n+import com.dotcms.content.elasticsearch.business.ESIndexAPI;", "originalCommit": "e6002906f706b0ec3e63bfb87e15bd5a0102b506", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk4OTQyOQ==", "url": "https://github.com/dotCMS/core/pull/18751#discussion_r453989429", "bodyText": "Codacy found an issue: Private field 'relationshipAPI' could be made final; it is only initialized in the declaration or constructor.", "author": "dev-dotcms", "createdAt": "2020-07-13T22:44:51Z", "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/util/ESMappingUtilHelper.java", "diffHunk": "@@ -0,0 +1,331 @@\n+package com.dotcms.content.elasticsearch.util;\n+\n+import com.dotcms.api.system.event.message.MessageSeverity;\n+import com.dotcms.api.system.event.message.MessageType;\n+import com.dotcms.api.system.event.message.SystemMessageEventUtil;\n+import com.dotcms.api.system.event.message.builder.SystemMessageBuilder;\n+import com.dotcms.business.CloseDBIfOpened;\n+import com.dotcms.content.elasticsearch.business.ESIndexAPI;\n+import com.dotcms.content.elasticsearch.business.ESMappingAPIImpl;\n+import com.dotcms.contenttype.business.ContentTypeAPI;\n+import com.dotcms.contenttype.business.FieldFactory;\n+import com.dotcms.contenttype.model.field.DataTypes;\n+import com.dotcms.contenttype.model.field.DateField;\n+import com.dotcms.contenttype.model.field.DateTimeField;\n+import com.dotcms.contenttype.model.field.Field;\n+import com.dotcms.contenttype.model.field.FieldVariable;\n+import com.dotcms.contenttype.model.field.RadioField;\n+import com.dotcms.contenttype.model.field.SelectField;\n+import com.dotcms.contenttype.model.field.TextAreaField;\n+import com.dotcms.contenttype.model.field.TextField;\n+import com.dotcms.contenttype.model.field.TimeField;\n+import com.dotcms.contenttype.model.field.WysiwygField;\n+import com.dotcms.contenttype.model.type.ContentType;\n+import com.dotcms.repackage.com.google.common.annotations.VisibleForTesting;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.FactoryLocator;\n+import com.dotmarketing.business.RelationshipAPI;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.portlets.structure.model.Relationship;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.json.JSONObject;\n+import com.jayway.jsonpath.JsonPath;\n+import com.liferay.portal.language.LanguageException;\n+import com.liferay.portal.language.LanguageUtil;\n+import com.liferay.util.StringPool;\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.URL;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper class responsible of setting Elasticsearch mapping for content type fields\n+ * @author nollymar\n+ */\n+public class ESMappingUtilHelper {\n+\n+    private ContentTypeAPI contentTypeAPI;\n+    private ESMappingAPIImpl esMappingAPI;\n+    private RelationshipAPI relationshipAPI;", "originalCommit": "e6002906f706b0ec3e63bfb87e15bd5a0102b506", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk4OTQzNA==", "url": "https://github.com/dotCMS/core/pull/18751#discussion_r453989434", "bodyText": "Codacy found an issue: JUnit tests should include assert() or fail()", "author": "dev-dotcms", "createdAt": "2020-07-13T22:44:52Z", "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/util/ESMappingUtilHelperTest.java", "diffHunk": "@@ -0,0 +1,570 @@\n+package com.dotcms.content.elasticsearch.util;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import com.dotcms.content.elasticsearch.business.ContentletIndexAPI;\n+import com.dotcms.content.elasticsearch.business.DotIndexException;\n+import com.dotcms.content.elasticsearch.business.ESIndexAPI;\n+import com.dotcms.content.elasticsearch.business.ESMappingAPIImpl;\n+import com.dotcms.content.elasticsearch.business.IndexType;\n+import com.dotcms.contenttype.business.ContentTypeAPI;\n+import com.dotcms.contenttype.business.FieldAPI;\n+import com.dotcms.contenttype.exception.NotFoundInDbException;\n+import com.dotcms.contenttype.model.field.DataTypes;\n+import com.dotcms.contenttype.model.field.DateField;\n+import com.dotcms.contenttype.model.field.DateTimeField;\n+import com.dotcms.contenttype.model.field.Field;\n+import com.dotcms.contenttype.model.field.FieldBuilder;\n+import com.dotcms.contenttype.model.field.FieldVariable;\n+import com.dotcms.contenttype.model.field.ImmutableFieldVariable;\n+import com.dotcms.contenttype.model.field.RadioField;\n+import com.dotcms.contenttype.model.field.RelationshipField;\n+import com.dotcms.contenttype.model.field.SelectField;\n+import com.dotcms.contenttype.model.field.TextField;\n+import com.dotcms.contenttype.model.type.ContentType;\n+import com.dotcms.datagen.ContentTypeDataGen;\n+import com.dotcms.datagen.ContentletDataGen;\n+import com.dotcms.datagen.FieldDataGen;\n+import com.dotcms.datagen.TestDataUtils;\n+import com.dotcms.util.CollectionsUtils;\n+import com.dotcms.util.IntegrationTestInitService;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.RelationshipAPI;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.portlets.categories.business.CategoryAPI;\n+import com.dotmarketing.portlets.categories.model.Category;\n+import com.dotmarketing.portlets.contentlet.business.ContentletAPI;\n+import com.dotmarketing.portlets.contentlet.model.Contentlet;\n+import com.dotmarketing.portlets.languagesmanager.model.Language;\n+import com.dotmarketing.portlets.structure.model.Relationship;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.UtilMethods;\n+import com.dotmarketing.util.WebKeys.Relationship.RELATIONSHIP_CARDINALITY;\n+import com.dotmarketing.util.json.JSONObject;\n+import com.liferay.portal.model.User;\n+import com.liferay.util.StringPool;\n+import com.tngtech.java.junit.dataprovider.DataProvider;\n+import com.tngtech.java.junit.dataprovider.DataProviderRunner;\n+import com.tngtech.java.junit.dataprovider.UseDataProvider;\n+import com.tngtech.junit.dataprovider.format.DataProviderTestNameFormatter;\n+import java.io.IOException;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+/**\n+ * Class used to validate ES mapping for fields is applied correctly considering fields types and dynamic mapping defined in `es-content-mapping.json`\n+ * @author nollymar\n+ */\n+@RunWith(DataProviderRunner.class)\n+public class ESMappingUtilHelperTest {\n+\n+    private static User user;\n+    private static CategoryAPI categoryAPI;\n+    private static ContentletAPI contentletAPI;\n+    private static ContentletIndexAPI contentletIndexAPI;\n+    private static ContentTypeAPI contentTypeAPI;\n+    private static ESMappingAPIImpl esMappingAPI;\n+    private static FieldAPI fieldAPI;\n+    private static RelationshipAPI relationshipAPI;\n+    private static Language language;\n+\n+    @BeforeClass\n+    public static void prepare() throws Exception {\n+        //Setting web app environment\n+        IntegrationTestInitService.getInstance().init();\n+\n+        user = APILocator.systemUser();\n+        categoryAPI = APILocator.getCategoryAPI();\n+        contentletAPI = APILocator.getContentletAPI();\n+        contentletIndexAPI = APILocator.getContentletIndexAPI();\n+        contentTypeAPI = APILocator.getContentTypeAPI(user);\n+        esMappingAPI = new ESMappingAPIImpl();\n+        fieldAPI = APILocator.getContentTypeFieldAPI();\n+        relationshipAPI = APILocator.getRelationshipAPI();\n+        language = APILocator.getLanguageAPI().getDefaultLanguage();\n+    }\n+\n+    public static class PlusTestNameFormatter implements DataProviderTestNameFormatter {\n+        @Override\n+        public String format(Method testMethod, int invocationIndex, List<Object> arguments) {\n+            return String.format(\"Test Name: %s. Mapping Name: %s\", testMethod.getName(), arguments.get(0));\n+        }\n+    }\n+\n+    @DataProvider(formatter = PlusTestNameFormatter.class)\n+    public static Object[][] dataProviderValidateEventMapping(){\n+        return new Object[][] {\n+                {\"template_1\", new String[]{\"host.hostname_dotraw\"}, \"keyword\"},\n+                {\"textmapping\", new String[]{\"host.hostname\"}, \"keyword\"},\n+                {\"strings_as_dates\", new String[]{\"calendarevent.originalstartdate\",\n+                        \"calendarevent.recurrencestart\", \"calendarevent.recurrenceend\"}, \"date\"},\n+                {\"permissions\", new String[]{\"permissions\"}, \"text\"},\n+                {\"hostname\", new String[]{\"host.hostname_text\"}, \"text\"}\n+        };\n+    }\n+\n+    @DataProvider(formatter = PlusTestNameFormatter.class)\n+    public static Object[][] dataProviderValidateFileAssetMapping(){\n+        return new Object[][] {\n+                {\"longmapping\", new String[]{ \"metadata.height\", \"metadata.width\"}, \"long\"},\n+                {\"keywordmapping\", new String[]{\"metadata.contenttype\"}, \"keyword\"}\n+        };\n+    }\n+\n+    @DataProvider(formatter = PlusTestNameFormatter.class)\n+    public static Object[][] dataProviderValidateNewsLikeMapping() {\n+        return new Object[][]{\n+                {\"geomapping\", new String[]{\"mylatlon\"}, \"geo_point\"},\n+                {\"geomapping_2\", new String[]{\"latlong\"}, \"geo_point\"},\n+                {\"keywordmapping\", new String[]{\"categories\", \"tags\", \"conhost\", \"conhostname\",\n+                        \"wfstep\", \"structurename\", \"contenttype\", \"parentpath\", \"path\", \"urlmap\",\n+                        \"moduser\", \"owner\"}, \"keyword\"}\n+        };\n+    }\n+\n+    /*Data provider used to verify that the ES mapping is applied correctly and considers exclusions in the `es-content-mapping` file\n+        For each scenario we define:\n+            1) testCase name\n+            2) Field(s) type\n+            3) Field(s) variable name(s)\n+            4) Expected ES mapping\n+     */\n+    @DataProvider(formatter = PlusTestNameFormatter.class)\n+    public static Object[][] dataProviderAddMappingForFields() {\n+        return new Object[][] {\n+                {  \"strings_as_dates\", DateField.class, DataTypes.DATE,\n+                        new String[] {\"originalstartdate\", \"recurrencestart\", \"recurrenceend\"},  \"date\" },\n+\n+                {  \"strings_as_date_times\", DateTimeField.class, DataTypes.DATE,\n+                        new String[] {\"originalstartdate\", \"recurrencestart\", \"recurrenceend\"},  \"date\" },\n+\n+                {  \"dates_as_text\", TextField.class, DataTypes.TEXT,\n+                        new String[] {\"originalstartdate\", \"recurrencestart\", \"recurrenceend\"},  \"text\" },\n+\n+                {  \"keywordmapping\", TextField.class, DataTypes.TEXT,\n+                        new String[] {\"categories\", \"tags\", \"conhost\",\n+                                \"wfstep\", \"structurename\", \"contenttype\", \"parentpath\",\n+                                \"path\", \"urlmap\", \"moduser\", \"owner\"},  \"text\" },\n+\n+                {  \"geomapping\", TextField.class, DataTypes.TEXT,\n+                        new String[] {\"mylatlong\", \"mylatlon\"},  null },\n+\n+                {  \"permissions\", TextField.class, DataTypes.TEXT, new String[] {\"permissions\"},  \"text\" },\n+\n+                {  \"radio_as_boolean\", RadioField.class, DataTypes.BOOL,\n+                        new String[] {\"MyRadioAsBoolean\"},  \"boolean\" },\n+\n+                {  \"radio_as_float\", RadioField.class, DataTypes.FLOAT,\n+                        new String[] {\"MyRadioAsFloat\"},  \"float\" },\n+\n+                {  \"radio_as_integer\", RadioField.class, DataTypes.INTEGER,\n+                        new String[] {\"MyRadioAsInteger\"},  \"integer\" },\n+\n+                {  \"select_as_boolean\", SelectField.class, DataTypes.BOOL,\n+                        new String[] {\"MySelectAsBoolean\"},  \"boolean\" },\n+\n+                {  \"select_as_float\", SelectField.class, DataTypes.FLOAT,\n+                        new String[] {\"MySelectAsFloat\"},  \"float\" },\n+\n+                {  \"select_as_integer\", SelectField.class, DataTypes.INTEGER,\n+                        new String[] {\"MySelectAsInteger\"},  \"integer\" },\n+\n+                {  \"text_as_float\", TextField.class, DataTypes.FLOAT,\n+                        new String[] {\"MyTextAsFloat\"},  \"float\" },\n+\n+                {  \"text_as_integer\", TextField.class, DataTypes.INTEGER,\n+                        new String[] {\"MyTextAsInteger\"},  \"integer\" }\n+        };\n+    }\n+\n+    /**\n+     * <b>Method to test:</b> Internally, it tests the method ESMappingUtilHelper.addMappingForFieldIfNeeded<p></p>\n+     * <b>Test Case:</b> Given a field or an array of fields, the right ES mapping should be set, considering exclusions in the `es-content-mapping` file<p></p>\n+     * <b>Expected Results:</b> Each test case should match the `expectedResult` value, which is a string with the correct datatype in ES\n+     * @param testCase\n+     * @param fieldType\n+     * @param type\n+     * @param fields\n+     * @param expectedResult\n+     * @throws IOException\n+     * @throws DotIndexException\n+     * @throws DotSecurityException\n+     * @throws DotDataException\n+     */\n+    @UseDataProvider\n+    @Test\n+    public void testAddMappingForFields(final String testCase, final Class fieldType,\n+            final DataTypes type,\n+            final String[] fields, final String expectedResult)\n+            throws IOException, DotIndexException, DotSecurityException, DotDataException {\n+\n+        Logger.info(ESMappingUtilHelperTest.class,\n+                String.format(\"Testing Add Mapping for fields defined in %s template\", testCase));\n+\n+        final ContentType contentType = new ContentTypeDataGen().nextPersisted();\n+\n+        String workingIndex = null;\n+        //Build the index name\n+        String timestamp = String.valueOf(new Date().getTime());\n+        try {\n+            //Adding fields\n+            for (final String field : fields) {\n+                final Field newField = FieldBuilder.builder(fieldType)\n+                        .name(field).variable(field).dataType(type).contentTypeId(contentType.id())\n+                        .indexed(true).build();\n+                fieldAPI.save(newField, user);\n+            }\n+\n+            workingIndex = new ESIndexAPI().getNameWithClusterIDPrefix(\n+                    IndexType.WORKING.getPrefix() + \"_\" + timestamp);\n+\n+            //Create a working index\n+            boolean result = contentletIndexAPI.createContentIndex(workingIndex);\n+            //Validate\n+            assertTrue(result);\n+\n+            for (final String field : fields) {\n+\n+                if (expectedResult == null) {\n+                    assertFalse(UtilMethods.isSet(esMappingAPI.getFieldMappingAsMap(workingIndex,\n+                            (contentType.variable() + StringPool.PERIOD + field).toLowerCase())));\n+                } else {\n+                    Map<String, String> mapping = (Map<String, String>) esMappingAPI\n+                            .getFieldMappingAsMap(workingIndex,\n+                                    (contentType.variable() + StringPool.PERIOD + field)\n+                                            .toLowerCase()).get(field.toLowerCase());\n+                    assertTrue(UtilMethods.isSet(mapping.get(\"type\")));\n+                    assertEquals(expectedResult, mapping.get(\"type\"));\n+                }\n+            }\n+\n+        } finally {\n+            if (workingIndex != null) {\n+                contentletIndexAPI.delete(workingIndex);\n+            }\n+\n+            if (contentType != null) {\n+                contentTypeAPI.delete(contentType);\n+            }\n+        }\n+    }\n+\n+\n+    /**\n+     * <b>Method to test:</b> Internally, it tests the methods ESMappingUtilHelper.addCustomMappingForRelationships and </p>\n+     * ESMappingUtilHelper.addCustomMappingFromFieldVariables<p></p>\n+     * </p><b>Test Case:</b> This test creates an index with two custom mapped fields: a text field and a relationship field.\n+     * Additionally, it creates a legacy relationship without a custom mapping in order to verify that\n+     * relationships in general are mapped as keywords by default, unless a custom mapping is defined for a specific case <p></p>\n+     * <b>Expected Results:</b> Custom mappings should take precedence always if exists. In case of relationships, </p>\n+     * they should be mapped as keywords, unless a custom mapping is defined\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testCreateContentIndexWithCustomMappings() throws Exception {\n+\n+        String workingIndex = null;\n+        ContentType parentContentType = null;\n+        ContentType childContentType = null;\n+        try {\n+            parentContentType = new ContentTypeDataGen().nextPersisted();\n+            childContentType = new ContentTypeDataGen().nextPersisted();\n+\n+            //Adding fields\n+            Field ageField = FieldBuilder.builder(TextField.class)\n+                    .name(\"age\").contentTypeId(parentContentType.id()).indexed(false).build();\n+            ageField = fieldAPI.save(ageField, user);\n+\n+            Field relationshipField = FieldBuilder.builder(RelationshipField.class)\n+                    .name(\"relationshipField\")\n+                    .contentTypeId(parentContentType.id())\n+                    .values(String.valueOf(RELATIONSHIP_CARDINALITY.ONE_TO_MANY.ordinal()))\n+                    .relationType(parentContentType.variable()).build();\n+\n+            relationshipField = fieldAPI.save(relationshipField, user);\n+\n+            //Create legacy relationship\n+            final Relationship legacyRelationship = createLegacyRelationship(parentContentType,\n+                    childContentType);\n+\n+            //Adding field variables\n+            final FieldVariable ageVariable = ImmutableFieldVariable.builder()\n+                    .fieldId(ageField.inode())\n+                    .name(\"ageMapping\").key(FieldVariable.ES_CUSTOM_MAPPING_KEY).value(\"{\\n\"\n+                            + \"                \\\"type\\\": \\\"long\\\"\\n\"\n+                            + \"              }\").userId(user.getUserId())\n+                    .build();\n+\n+            fieldAPI.save(ageVariable, user);\n+\n+            FieldVariable relVariable = ImmutableFieldVariable.builder()\n+                    .fieldId(relationshipField.inode())\n+                    .name(\"relMapping\").key(FieldVariable.ES_CUSTOM_MAPPING_KEY).value(\"{\\n\"\n+                            + \"                \\\"type\\\": \\\"text\\\"\\n\"\n+                            + \"              }\").userId(user.getUserId())\n+                    .build();\n+\n+            relVariable = fieldAPI.save(relVariable, user);\n+\n+            final Field updatedField = fieldAPI.find(relVariable.fieldId());\n+\n+            //Verify ageField is updated as System Indexed\n+            assertTrue(updatedField.indexed());\n+\n+            //Build the index name\n+            String timestamp = String.valueOf(new Date().getTime());\n+            workingIndex = new ESIndexAPI().getNameWithClusterIDPrefix(IndexType.WORKING.getPrefix() + \"_\" + timestamp);\n+\n+            //Create a working index\n+            boolean result = contentletIndexAPI.createContentIndex(workingIndex);\n+            //Validate\n+            assertTrue(result);\n+\n+            //verify mapping\n+            final String mapping = esMappingAPI.getMapping(workingIndex);\n+\n+            //parse json mapping and validate\n+            assertNotNull(mapping);\n+\n+            final JSONObject propertiesJSON = (JSONObject) (new JSONObject(mapping)).get(\"properties\");\n+            final JSONObject contentTypeJSON = (JSONObject) ((JSONObject) propertiesJSON\n+                    .get(parentContentType.variable().toLowerCase())).get(\"properties\");\n+\n+            //validate age mapping results\n+            final Map ageMapping = ((JSONObject) contentTypeJSON\n+                    .get(ageField.variable().toLowerCase())).getAsMap();\n+            assertNotNull(ageMapping);\n+            assertEquals(1, ageMapping.size());\n+            assertEquals(\"long\", ageMapping.get(\"type\"));\n+\n+            //validate relationship field mapping results\n+            final Map relationshipMapping = ((JSONObject) contentTypeJSON\n+                    .get(relationshipField.variable().toLowerCase())).getAsMap();\n+            assertNotNull(relationshipMapping);\n+            assertEquals(1, relationshipMapping.size());\n+            assertEquals(\"text\", relationshipMapping.get(\"type\"));\n+\n+            //validate legacy relationship\n+            final Map legacyRelationshipMapping = ((JSONObject) propertiesJSON\n+                    .get(legacyRelationship.getRelationTypeValue().toLowerCase())).getAsMap();\n+            assertNotNull(ageMapping);\n+            assertEquals(2, legacyRelationshipMapping.size());\n+            assertEquals(\"keyword\", legacyRelationshipMapping.get(\"type\"));\n+            assertEquals(8191, legacyRelationshipMapping.get(\"ignore_above\"));\n+\n+        } finally {\n+            if (workingIndex != null) {\n+                contentletIndexAPI.delete(workingIndex);\n+            }\n+\n+            if (parentContentType != null && parentContentType.inode() != null) {\n+                ContentTypeDataGen.remove(parentContentType);\n+            }\n+\n+            if (childContentType != null && childContentType.inode() != null) {\n+                ContentTypeDataGen.remove(childContentType);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * <b>Test Case:</b> Validates dynamic mappings defined in the `es-content-mapping` file are applied correctly<p></p>\n+     * <b>Expected Results:</b> Each test case should match the `expectedResult` value, which is a string with the correct datatype in ES\n+     * @param testCase\n+     * @param fields\n+     * @param expectedResult\n+     * @throws DotDataException\n+     * @throws IOException\n+     * @throws DotSecurityException\n+     */\n+    @UseDataProvider\n+    @Test\n+    public void testValidateNewsLikeMapping(final String testCase, final String[] fields, final String expectedResult)\n+            throws DotDataException, IOException, DotSecurityException {\n+        final ContentType newsContentType = TestDataUtils.getNewsLikeContentType();\n+        fieldAPI.save( FieldBuilder.builder(TextField.class).contentTypeId(newsContentType.id()).name(\"mylatlon\").variable(\"mylatlon\").indexed(true).build(), user);\n+        Contentlet newsContent = null;\n+        try {\n+            final String categoryName = \"myCategory\" + System.currentTimeMillis();\n+            Category category = new Category();\n+            category.setCategoryName(categoryName);\n+            category.setKey(categoryName);\n+            category.setCategoryVelocityVarName(categoryName);\n+            category.setSortOrder(2);\n+            category.setKeywords(null);\n+            categoryAPI.save(null, category, user, false);\n+            newsContent = new ContentletDataGen(newsContentType.id()).languageId(language.getId())\n+                    .host(APILocator.getHostAPI()\n+                            .findDefaultHost(APILocator.systemUser(), false))\n+                    .setProperty(\"title\", \"newsContent Title\" + System.currentTimeMillis())\n+                    .setProperty(\"urlTitle\", \"myUrlTitle\")\n+                    .setProperty(\"urlMap\", \"myUrlMap\")\n+                    .setProperty(\"byline\", \"byline\")\n+                    .setProperty(\"sysPublishDate\", new Date())\n+                    .setProperty(\"story\", \"newsStory\")\n+                    .setProperty(\"latlong\", \"[90, -90]\")\n+                    .setProperty(\"mylatlon\", \"[90, -90]\")\n+                    .setProperty(\"tags\", \"test\").next();\n+\n+            newsContent = contentletAPI.checkin(newsContent, CollectionsUtils.list(category), null, user, false);\n+            validateMappingForFields(testCase, newsContentType.variable().toLowerCase(), fields, expectedResult);\n+        }finally{\n+            if (newsContent != null) {\n+                ContentletDataGen.destroy(newsContent);\n+            }\n+        }\n+\n+    }\n+\n+    /**\n+     * <b>Test Case:</b> Validates dynamic mappings defined in the `es-content-mapping` file are applied correctly<p></p>\n+     * <b>Expected Results:</b> Each test case should match the `expectedResult` value, which is a string with the correct datatype in ES\n+     * @param testCase\n+     * @param fields\n+     * @param expectedResult\n+     * @throws DotDataException\n+     * @throws IOException\n+     */\n+    @UseDataProvider\n+    @Test\n+    public void testValidateFileAssetMapping(final String testCase, final String[] fields, final String expectedResult)", "originalCommit": "e6002906f706b0ec3e63bfb87e15bd5a0102b506", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk4OTQzOA==", "url": "https://github.com/dotCMS/core/pull/18751#discussion_r453989438", "bodyText": "Codacy found an issue: The String literal \"permissions\" appears 4 times in this file; the first occurrence is on line 109", "author": "dev-dotcms", "createdAt": "2020-07-13T22:44:53Z", "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/util/ESMappingUtilHelperTest.java", "diffHunk": "@@ -0,0 +1,570 @@\n+package com.dotcms.content.elasticsearch.util;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import com.dotcms.content.elasticsearch.business.ContentletIndexAPI;\n+import com.dotcms.content.elasticsearch.business.DotIndexException;\n+import com.dotcms.content.elasticsearch.business.ESIndexAPI;\n+import com.dotcms.content.elasticsearch.business.ESMappingAPIImpl;\n+import com.dotcms.content.elasticsearch.business.IndexType;\n+import com.dotcms.contenttype.business.ContentTypeAPI;\n+import com.dotcms.contenttype.business.FieldAPI;\n+import com.dotcms.contenttype.exception.NotFoundInDbException;\n+import com.dotcms.contenttype.model.field.DataTypes;\n+import com.dotcms.contenttype.model.field.DateField;\n+import com.dotcms.contenttype.model.field.DateTimeField;\n+import com.dotcms.contenttype.model.field.Field;\n+import com.dotcms.contenttype.model.field.FieldBuilder;\n+import com.dotcms.contenttype.model.field.FieldVariable;\n+import com.dotcms.contenttype.model.field.ImmutableFieldVariable;\n+import com.dotcms.contenttype.model.field.RadioField;\n+import com.dotcms.contenttype.model.field.RelationshipField;\n+import com.dotcms.contenttype.model.field.SelectField;\n+import com.dotcms.contenttype.model.field.TextField;\n+import com.dotcms.contenttype.model.type.ContentType;\n+import com.dotcms.datagen.ContentTypeDataGen;\n+import com.dotcms.datagen.ContentletDataGen;\n+import com.dotcms.datagen.FieldDataGen;\n+import com.dotcms.datagen.TestDataUtils;\n+import com.dotcms.util.CollectionsUtils;\n+import com.dotcms.util.IntegrationTestInitService;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.RelationshipAPI;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.portlets.categories.business.CategoryAPI;\n+import com.dotmarketing.portlets.categories.model.Category;\n+import com.dotmarketing.portlets.contentlet.business.ContentletAPI;\n+import com.dotmarketing.portlets.contentlet.model.Contentlet;\n+import com.dotmarketing.portlets.languagesmanager.model.Language;\n+import com.dotmarketing.portlets.structure.model.Relationship;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.UtilMethods;\n+import com.dotmarketing.util.WebKeys.Relationship.RELATIONSHIP_CARDINALITY;\n+import com.dotmarketing.util.json.JSONObject;\n+import com.liferay.portal.model.User;\n+import com.liferay.util.StringPool;\n+import com.tngtech.java.junit.dataprovider.DataProvider;\n+import com.tngtech.java.junit.dataprovider.DataProviderRunner;\n+import com.tngtech.java.junit.dataprovider.UseDataProvider;\n+import com.tngtech.junit.dataprovider.format.DataProviderTestNameFormatter;\n+import java.io.IOException;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+/**\n+ * Class used to validate ES mapping for fields is applied correctly considering fields types and dynamic mapping defined in `es-content-mapping.json`\n+ * @author nollymar\n+ */\n+@RunWith(DataProviderRunner.class)\n+public class ESMappingUtilHelperTest {\n+\n+    private static User user;\n+    private static CategoryAPI categoryAPI;\n+    private static ContentletAPI contentletAPI;\n+    private static ContentletIndexAPI contentletIndexAPI;\n+    private static ContentTypeAPI contentTypeAPI;\n+    private static ESMappingAPIImpl esMappingAPI;\n+    private static FieldAPI fieldAPI;\n+    private static RelationshipAPI relationshipAPI;\n+    private static Language language;\n+\n+    @BeforeClass\n+    public static void prepare() throws Exception {\n+        //Setting web app environment\n+        IntegrationTestInitService.getInstance().init();\n+\n+        user = APILocator.systemUser();\n+        categoryAPI = APILocator.getCategoryAPI();\n+        contentletAPI = APILocator.getContentletAPI();\n+        contentletIndexAPI = APILocator.getContentletIndexAPI();\n+        contentTypeAPI = APILocator.getContentTypeAPI(user);\n+        esMappingAPI = new ESMappingAPIImpl();\n+        fieldAPI = APILocator.getContentTypeFieldAPI();\n+        relationshipAPI = APILocator.getRelationshipAPI();\n+        language = APILocator.getLanguageAPI().getDefaultLanguage();\n+    }\n+\n+    public static class PlusTestNameFormatter implements DataProviderTestNameFormatter {\n+        @Override\n+        public String format(Method testMethod, int invocationIndex, List<Object> arguments) {\n+            return String.format(\"Test Name: %s. Mapping Name: %s\", testMethod.getName(), arguments.get(0));\n+        }\n+    }\n+\n+    @DataProvider(formatter = PlusTestNameFormatter.class)\n+    public static Object[][] dataProviderValidateEventMapping(){\n+        return new Object[][] {\n+                {\"template_1\", new String[]{\"host.hostname_dotraw\"}, \"keyword\"},\n+                {\"textmapping\", new String[]{\"host.hostname\"}, \"keyword\"},\n+                {\"strings_as_dates\", new String[]{\"calendarevent.originalstartdate\",\n+                        \"calendarevent.recurrencestart\", \"calendarevent.recurrenceend\"}, \"date\"},\n+                {\"permissions\", new String[]{\"permissions\"}, \"text\"},", "originalCommit": "e6002906f706b0ec3e63bfb87e15bd5a0102b506", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk4OTQ0Nw==", "url": "https://github.com/dotCMS/core/pull/18751#discussion_r453989447", "bodyText": "Codacy found an issue: A method/constructor should not explicitly throw java.lang.Exception", "author": "dev-dotcms", "createdAt": "2020-07-13T22:44:53Z", "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/util/ESMappingUtilHelperTest.java", "diffHunk": "@@ -0,0 +1,570 @@\n+package com.dotcms.content.elasticsearch.util;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import com.dotcms.content.elasticsearch.business.ContentletIndexAPI;\n+import com.dotcms.content.elasticsearch.business.DotIndexException;\n+import com.dotcms.content.elasticsearch.business.ESIndexAPI;\n+import com.dotcms.content.elasticsearch.business.ESMappingAPIImpl;\n+import com.dotcms.content.elasticsearch.business.IndexType;\n+import com.dotcms.contenttype.business.ContentTypeAPI;\n+import com.dotcms.contenttype.business.FieldAPI;\n+import com.dotcms.contenttype.exception.NotFoundInDbException;\n+import com.dotcms.contenttype.model.field.DataTypes;\n+import com.dotcms.contenttype.model.field.DateField;\n+import com.dotcms.contenttype.model.field.DateTimeField;\n+import com.dotcms.contenttype.model.field.Field;\n+import com.dotcms.contenttype.model.field.FieldBuilder;\n+import com.dotcms.contenttype.model.field.FieldVariable;\n+import com.dotcms.contenttype.model.field.ImmutableFieldVariable;\n+import com.dotcms.contenttype.model.field.RadioField;\n+import com.dotcms.contenttype.model.field.RelationshipField;\n+import com.dotcms.contenttype.model.field.SelectField;\n+import com.dotcms.contenttype.model.field.TextField;\n+import com.dotcms.contenttype.model.type.ContentType;\n+import com.dotcms.datagen.ContentTypeDataGen;\n+import com.dotcms.datagen.ContentletDataGen;\n+import com.dotcms.datagen.FieldDataGen;\n+import com.dotcms.datagen.TestDataUtils;\n+import com.dotcms.util.CollectionsUtils;\n+import com.dotcms.util.IntegrationTestInitService;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.RelationshipAPI;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.portlets.categories.business.CategoryAPI;\n+import com.dotmarketing.portlets.categories.model.Category;\n+import com.dotmarketing.portlets.contentlet.business.ContentletAPI;\n+import com.dotmarketing.portlets.contentlet.model.Contentlet;\n+import com.dotmarketing.portlets.languagesmanager.model.Language;\n+import com.dotmarketing.portlets.structure.model.Relationship;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.UtilMethods;\n+import com.dotmarketing.util.WebKeys.Relationship.RELATIONSHIP_CARDINALITY;\n+import com.dotmarketing.util.json.JSONObject;\n+import com.liferay.portal.model.User;\n+import com.liferay.util.StringPool;\n+import com.tngtech.java.junit.dataprovider.DataProvider;\n+import com.tngtech.java.junit.dataprovider.DataProviderRunner;\n+import com.tngtech.java.junit.dataprovider.UseDataProvider;\n+import com.tngtech.junit.dataprovider.format.DataProviderTestNameFormatter;\n+import java.io.IOException;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+/**\n+ * Class used to validate ES mapping for fields is applied correctly considering fields types and dynamic mapping defined in `es-content-mapping.json`\n+ * @author nollymar\n+ */\n+@RunWith(DataProviderRunner.class)\n+public class ESMappingUtilHelperTest {\n+\n+    private static User user;\n+    private static CategoryAPI categoryAPI;\n+    private static ContentletAPI contentletAPI;\n+    private static ContentletIndexAPI contentletIndexAPI;\n+    private static ContentTypeAPI contentTypeAPI;\n+    private static ESMappingAPIImpl esMappingAPI;\n+    private static FieldAPI fieldAPI;\n+    private static RelationshipAPI relationshipAPI;\n+    private static Language language;\n+\n+    @BeforeClass\n+    public static void prepare() throws Exception {", "originalCommit": "e6002906f706b0ec3e63bfb87e15bd5a0102b506", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk4OTQ1Mw==", "url": "https://github.com/dotCMS/core/pull/18751#discussion_r453989453", "bodyText": "Codacy found an issue: The String literal \"properties\" appears 5 times in this file; the first occurrence is on line 97", "author": "dev-dotcms", "createdAt": "2020-07-13T22:44:54Z", "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/util/ESMappingUtilHelper.java", "diffHunk": "@@ -0,0 +1,331 @@\n+package com.dotcms.content.elasticsearch.util;\n+\n+import com.dotcms.api.system.event.message.MessageSeverity;\n+import com.dotcms.api.system.event.message.MessageType;\n+import com.dotcms.api.system.event.message.SystemMessageEventUtil;\n+import com.dotcms.api.system.event.message.builder.SystemMessageBuilder;\n+import com.dotcms.business.CloseDBIfOpened;\n+import com.dotcms.content.elasticsearch.business.ESIndexAPI;\n+import com.dotcms.content.elasticsearch.business.ESMappingAPIImpl;\n+import com.dotcms.contenttype.business.ContentTypeAPI;\n+import com.dotcms.contenttype.business.FieldFactory;\n+import com.dotcms.contenttype.model.field.DataTypes;\n+import com.dotcms.contenttype.model.field.DateField;\n+import com.dotcms.contenttype.model.field.DateTimeField;\n+import com.dotcms.contenttype.model.field.Field;\n+import com.dotcms.contenttype.model.field.FieldVariable;\n+import com.dotcms.contenttype.model.field.RadioField;\n+import com.dotcms.contenttype.model.field.SelectField;\n+import com.dotcms.contenttype.model.field.TextAreaField;\n+import com.dotcms.contenttype.model.field.TextField;\n+import com.dotcms.contenttype.model.field.TimeField;\n+import com.dotcms.contenttype.model.field.WysiwygField;\n+import com.dotcms.contenttype.model.type.ContentType;\n+import com.dotcms.repackage.com.google.common.annotations.VisibleForTesting;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.FactoryLocator;\n+import com.dotmarketing.business.RelationshipAPI;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.portlets.structure.model.Relationship;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.json.JSONObject;\n+import com.jayway.jsonpath.JsonPath;\n+import com.liferay.portal.language.LanguageException;\n+import com.liferay.portal.language.LanguageUtil;\n+import com.liferay.util.StringPool;\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.URL;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper class responsible of setting Elasticsearch mapping for content type fields\n+ * @author nollymar\n+ */\n+public class ESMappingUtilHelper {\n+\n+    private ContentTypeAPI contentTypeAPI;\n+    private ESMappingAPIImpl esMappingAPI;\n+    private RelationshipAPI relationshipAPI;\n+\n+    private static class SingletonHolder {\n+\n+        private static final ESMappingUtilHelper INSTANCE = new ESMappingUtilHelper();\n+    }\n+\n+    public static ESMappingUtilHelper getInstance() {\n+        return ESMappingUtilHelper.SingletonHolder.INSTANCE;\n+    }\n+\n+    private ESMappingUtilHelper() {\n+        contentTypeAPI = APILocator.getContentTypeAPI(APILocator.systemUser());\n+        esMappingAPI = new ESMappingAPIImpl();\n+        relationshipAPI = APILocator.getRelationshipAPI();\n+    }\n+\n+    @VisibleForTesting\n+    ESMappingUtilHelper(final ContentTypeAPI contentTypeAPI, final ESMappingAPIImpl esMappingAPI,\n+            final RelationshipAPI relationshipAPI) {\n+        this.contentTypeAPI = contentTypeAPI;\n+        this.esMappingAPI = esMappingAPI;\n+        this.relationshipAPI = relationshipAPI;\n+    }\n+\n+    /**\n+     * Sets a custom index mapping for relationships and also for mapping defined on field variables\n+     * using `esCustomMapping` property\n+     *\n+     * @param indexName - Index where mapping will be updated\n+     */\n+    @CloseDBIfOpened\n+    public void addCustomMapping(final String indexName) {\n+\n+        final Set<String> mappedFields = addCustomMappingFromFieldVariables(indexName);\n+\n+        addCustomMappingForRelationships(indexName, mappedFields);\n+\n+        addMappingForRemainingFields(indexName, mappedFields);\n+    }\n+\n+    /**\n+     * Sets a mapping for all relationships except for those that contains its custom mapping using\n+     * field variables\n+     *\n+     * @param indexName - Index where mapping will be updated\n+     * @param mappedFields - Collection that contains the fields with a specific mapping until now.\n+     * </br> When a put mapping request is sent to Elasticsearch for each relationship (if needed),\n+     * a new entry is added to the <b>mappedFields</b> collection\n+     */\n+    private void addCustomMappingForRelationships(final String indexName,\n+            final Set<String> mappedFields) {\n+        final List<Relationship> relationships = relationshipAPI.dbAll();\n+\n+        for (final Relationship relationship : relationships) {\n+            final String relationshipName = relationship.getRelationTypeValue().toLowerCase();\n+            if (!mappedFields.contains(relationshipName)) {\n+                final JSONObject properties = new JSONObject();\n+                try {\n+                    properties.put(\"properties\", new JSONObject()", "originalCommit": "e6002906f706b0ec3e63bfb87e15bd5a0102b506", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk4OTQ2Mw==", "url": "https://github.com/dotCMS/core/pull/18751#discussion_r453989463", "bodyText": "Codacy found an issue: The String literal \"type\" appears 5 times in this file; the first occurrence is on line 184", "author": "dev-dotcms", "createdAt": "2020-07-13T22:44:55Z", "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/util/ESMappingUtilHelperTest.java", "diffHunk": "@@ -0,0 +1,570 @@\n+package com.dotcms.content.elasticsearch.util;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import com.dotcms.content.elasticsearch.business.ContentletIndexAPI;\n+import com.dotcms.content.elasticsearch.business.DotIndexException;\n+import com.dotcms.content.elasticsearch.business.ESIndexAPI;\n+import com.dotcms.content.elasticsearch.business.ESMappingAPIImpl;\n+import com.dotcms.content.elasticsearch.business.IndexType;\n+import com.dotcms.contenttype.business.ContentTypeAPI;\n+import com.dotcms.contenttype.business.FieldAPI;\n+import com.dotcms.contenttype.exception.NotFoundInDbException;\n+import com.dotcms.contenttype.model.field.DataTypes;\n+import com.dotcms.contenttype.model.field.DateField;\n+import com.dotcms.contenttype.model.field.DateTimeField;\n+import com.dotcms.contenttype.model.field.Field;\n+import com.dotcms.contenttype.model.field.FieldBuilder;\n+import com.dotcms.contenttype.model.field.FieldVariable;\n+import com.dotcms.contenttype.model.field.ImmutableFieldVariable;\n+import com.dotcms.contenttype.model.field.RadioField;\n+import com.dotcms.contenttype.model.field.RelationshipField;\n+import com.dotcms.contenttype.model.field.SelectField;\n+import com.dotcms.contenttype.model.field.TextField;\n+import com.dotcms.contenttype.model.type.ContentType;\n+import com.dotcms.datagen.ContentTypeDataGen;\n+import com.dotcms.datagen.ContentletDataGen;\n+import com.dotcms.datagen.FieldDataGen;\n+import com.dotcms.datagen.TestDataUtils;\n+import com.dotcms.util.CollectionsUtils;\n+import com.dotcms.util.IntegrationTestInitService;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.RelationshipAPI;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.portlets.categories.business.CategoryAPI;\n+import com.dotmarketing.portlets.categories.model.Category;\n+import com.dotmarketing.portlets.contentlet.business.ContentletAPI;\n+import com.dotmarketing.portlets.contentlet.model.Contentlet;\n+import com.dotmarketing.portlets.languagesmanager.model.Language;\n+import com.dotmarketing.portlets.structure.model.Relationship;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.UtilMethods;\n+import com.dotmarketing.util.WebKeys.Relationship.RELATIONSHIP_CARDINALITY;\n+import com.dotmarketing.util.json.JSONObject;\n+import com.liferay.portal.model.User;\n+import com.liferay.util.StringPool;\n+import com.tngtech.java.junit.dataprovider.DataProvider;\n+import com.tngtech.java.junit.dataprovider.DataProviderRunner;\n+import com.tngtech.java.junit.dataprovider.UseDataProvider;\n+import com.tngtech.junit.dataprovider.format.DataProviderTestNameFormatter;\n+import java.io.IOException;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+/**\n+ * Class used to validate ES mapping for fields is applied correctly considering fields types and dynamic mapping defined in `es-content-mapping.json`\n+ * @author nollymar\n+ */\n+@RunWith(DataProviderRunner.class)\n+public class ESMappingUtilHelperTest {\n+\n+    private static User user;\n+    private static CategoryAPI categoryAPI;\n+    private static ContentletAPI contentletAPI;\n+    private static ContentletIndexAPI contentletIndexAPI;\n+    private static ContentTypeAPI contentTypeAPI;\n+    private static ESMappingAPIImpl esMappingAPI;\n+    private static FieldAPI fieldAPI;\n+    private static RelationshipAPI relationshipAPI;\n+    private static Language language;\n+\n+    @BeforeClass\n+    public static void prepare() throws Exception {\n+        //Setting web app environment\n+        IntegrationTestInitService.getInstance().init();\n+\n+        user = APILocator.systemUser();\n+        categoryAPI = APILocator.getCategoryAPI();\n+        contentletAPI = APILocator.getContentletAPI();\n+        contentletIndexAPI = APILocator.getContentletIndexAPI();\n+        contentTypeAPI = APILocator.getContentTypeAPI(user);\n+        esMappingAPI = new ESMappingAPIImpl();\n+        fieldAPI = APILocator.getContentTypeFieldAPI();\n+        relationshipAPI = APILocator.getRelationshipAPI();\n+        language = APILocator.getLanguageAPI().getDefaultLanguage();\n+    }\n+\n+    public static class PlusTestNameFormatter implements DataProviderTestNameFormatter {\n+        @Override\n+        public String format(Method testMethod, int invocationIndex, List<Object> arguments) {\n+            return String.format(\"Test Name: %s. Mapping Name: %s\", testMethod.getName(), arguments.get(0));\n+        }\n+    }\n+\n+    @DataProvider(formatter = PlusTestNameFormatter.class)\n+    public static Object[][] dataProviderValidateEventMapping(){\n+        return new Object[][] {\n+                {\"template_1\", new String[]{\"host.hostname_dotraw\"}, \"keyword\"},\n+                {\"textmapping\", new String[]{\"host.hostname\"}, \"keyword\"},\n+                {\"strings_as_dates\", new String[]{\"calendarevent.originalstartdate\",\n+                        \"calendarevent.recurrencestart\", \"calendarevent.recurrenceend\"}, \"date\"},\n+                {\"permissions\", new String[]{\"permissions\"}, \"text\"},\n+                {\"hostname\", new String[]{\"host.hostname_text\"}, \"text\"}\n+        };\n+    }\n+\n+    @DataProvider(formatter = PlusTestNameFormatter.class)\n+    public static Object[][] dataProviderValidateFileAssetMapping(){\n+        return new Object[][] {\n+                {\"longmapping\", new String[]{ \"metadata.height\", \"metadata.width\"}, \"long\"},\n+                {\"keywordmapping\", new String[]{\"metadata.contenttype\"}, \"keyword\"}\n+        };\n+    }\n+\n+    @DataProvider(formatter = PlusTestNameFormatter.class)\n+    public static Object[][] dataProviderValidateNewsLikeMapping() {\n+        return new Object[][]{\n+                {\"geomapping\", new String[]{\"mylatlon\"}, \"geo_point\"},\n+                {\"geomapping_2\", new String[]{\"latlong\"}, \"geo_point\"},\n+                {\"keywordmapping\", new String[]{\"categories\", \"tags\", \"conhost\", \"conhostname\",\n+                        \"wfstep\", \"structurename\", \"contenttype\", \"parentpath\", \"path\", \"urlmap\",\n+                        \"moduser\", \"owner\"}, \"keyword\"}\n+        };\n+    }\n+\n+    /*Data provider used to verify that the ES mapping is applied correctly and considers exclusions in the `es-content-mapping` file\n+        For each scenario we define:\n+            1) testCase name\n+            2) Field(s) type\n+            3) Field(s) variable name(s)\n+            4) Expected ES mapping\n+     */\n+    @DataProvider(formatter = PlusTestNameFormatter.class)\n+    public static Object[][] dataProviderAddMappingForFields() {\n+        return new Object[][] {\n+                {  \"strings_as_dates\", DateField.class, DataTypes.DATE,\n+                        new String[] {\"originalstartdate\", \"recurrencestart\", \"recurrenceend\"},  \"date\" },\n+\n+                {  \"strings_as_date_times\", DateTimeField.class, DataTypes.DATE,\n+                        new String[] {\"originalstartdate\", \"recurrencestart\", \"recurrenceend\"},  \"date\" },\n+\n+                {  \"dates_as_text\", TextField.class, DataTypes.TEXT,\n+                        new String[] {\"originalstartdate\", \"recurrencestart\", \"recurrenceend\"},  \"text\" },\n+\n+                {  \"keywordmapping\", TextField.class, DataTypes.TEXT,\n+                        new String[] {\"categories\", \"tags\", \"conhost\",\n+                                \"wfstep\", \"structurename\", \"contenttype\", \"parentpath\",\n+                                \"path\", \"urlmap\", \"moduser\", \"owner\"},  \"text\" },\n+\n+                {  \"geomapping\", TextField.class, DataTypes.TEXT,\n+                        new String[] {\"mylatlong\", \"mylatlon\"},  null },\n+\n+                {  \"permissions\", TextField.class, DataTypes.TEXT, new String[] {\"permissions\"},  \"text\" },\n+\n+                {  \"radio_as_boolean\", RadioField.class, DataTypes.BOOL,\n+                        new String[] {\"MyRadioAsBoolean\"},  \"boolean\" },\n+\n+                {  \"radio_as_float\", RadioField.class, DataTypes.FLOAT,\n+                        new String[] {\"MyRadioAsFloat\"},  \"float\" },\n+\n+                {  \"radio_as_integer\", RadioField.class, DataTypes.INTEGER,\n+                        new String[] {\"MyRadioAsInteger\"},  \"integer\" },\n+\n+                {  \"select_as_boolean\", SelectField.class, DataTypes.BOOL,\n+                        new String[] {\"MySelectAsBoolean\"},  \"boolean\" },\n+\n+                {  \"select_as_float\", SelectField.class, DataTypes.FLOAT,\n+                        new String[] {\"MySelectAsFloat\"},  \"float\" },\n+\n+                {  \"select_as_integer\", SelectField.class, DataTypes.INTEGER,\n+                        new String[] {\"MySelectAsInteger\"},  \"integer\" },\n+\n+                {  \"text_as_float\", TextField.class, DataTypes.FLOAT,\n+                        new String[] {\"MyTextAsFloat\"},  \"float\" },\n+\n+                {  \"text_as_integer\", TextField.class, DataTypes.INTEGER,\n+                        new String[] {\"MyTextAsInteger\"},  \"integer\" }\n+        };\n+    }\n+\n+    /**\n+     * <b>Method to test:</b> Internally, it tests the method ESMappingUtilHelper.addMappingForFieldIfNeeded<p></p>\n+     * <b>Test Case:</b> Given a field or an array of fields, the right ES mapping should be set, considering exclusions in the `es-content-mapping` file<p></p>\n+     * <b>Expected Results:</b> Each test case should match the `expectedResult` value, which is a string with the correct datatype in ES\n+     * @param testCase\n+     * @param fieldType\n+     * @param type\n+     * @param fields\n+     * @param expectedResult\n+     * @throws IOException\n+     * @throws DotIndexException\n+     * @throws DotSecurityException\n+     * @throws DotDataException\n+     */\n+    @UseDataProvider\n+    @Test\n+    public void testAddMappingForFields(final String testCase, final Class fieldType,\n+            final DataTypes type,\n+            final String[] fields, final String expectedResult)\n+            throws IOException, DotIndexException, DotSecurityException, DotDataException {\n+\n+        Logger.info(ESMappingUtilHelperTest.class,\n+                String.format(\"Testing Add Mapping for fields defined in %s template\", testCase));\n+\n+        final ContentType contentType = new ContentTypeDataGen().nextPersisted();\n+\n+        String workingIndex = null;\n+        //Build the index name\n+        String timestamp = String.valueOf(new Date().getTime());\n+        try {\n+            //Adding fields\n+            for (final String field : fields) {\n+                final Field newField = FieldBuilder.builder(fieldType)\n+                        .name(field).variable(field).dataType(type).contentTypeId(contentType.id())\n+                        .indexed(true).build();\n+                fieldAPI.save(newField, user);\n+            }\n+\n+            workingIndex = new ESIndexAPI().getNameWithClusterIDPrefix(\n+                    IndexType.WORKING.getPrefix() + \"_\" + timestamp);\n+\n+            //Create a working index\n+            boolean result = contentletIndexAPI.createContentIndex(workingIndex);\n+            //Validate\n+            assertTrue(result);\n+\n+            for (final String field : fields) {\n+\n+                if (expectedResult == null) {\n+                    assertFalse(UtilMethods.isSet(esMappingAPI.getFieldMappingAsMap(workingIndex,\n+                            (contentType.variable() + StringPool.PERIOD + field).toLowerCase())));\n+                } else {\n+                    Map<String, String> mapping = (Map<String, String>) esMappingAPI\n+                            .getFieldMappingAsMap(workingIndex,\n+                                    (contentType.variable() + StringPool.PERIOD + field)\n+                                            .toLowerCase()).get(field.toLowerCase());\n+                    assertTrue(UtilMethods.isSet(mapping.get(\"type\")));", "originalCommit": "e6002906f706b0ec3e63bfb87e15bd5a0102b506", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk4OTQ3MQ==", "url": "https://github.com/dotCMS/core/pull/18751#discussion_r453989471", "bodyText": "Codacy found an issue: Avoid throwing raw exception types.", "author": "dev-dotcms", "createdAt": "2020-07-13T22:44:57Z", "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/util/ESMappingUtilHelper.java", "diffHunk": "@@ -0,0 +1,331 @@\n+package com.dotcms.content.elasticsearch.util;\n+\n+import com.dotcms.api.system.event.message.MessageSeverity;\n+import com.dotcms.api.system.event.message.MessageType;\n+import com.dotcms.api.system.event.message.SystemMessageEventUtil;\n+import com.dotcms.api.system.event.message.builder.SystemMessageBuilder;\n+import com.dotcms.business.CloseDBIfOpened;\n+import com.dotcms.content.elasticsearch.business.ESIndexAPI;\n+import com.dotcms.content.elasticsearch.business.ESMappingAPIImpl;\n+import com.dotcms.contenttype.business.ContentTypeAPI;\n+import com.dotcms.contenttype.business.FieldFactory;\n+import com.dotcms.contenttype.model.field.DataTypes;\n+import com.dotcms.contenttype.model.field.DateField;\n+import com.dotcms.contenttype.model.field.DateTimeField;\n+import com.dotcms.contenttype.model.field.Field;\n+import com.dotcms.contenttype.model.field.FieldVariable;\n+import com.dotcms.contenttype.model.field.RadioField;\n+import com.dotcms.contenttype.model.field.SelectField;\n+import com.dotcms.contenttype.model.field.TextAreaField;\n+import com.dotcms.contenttype.model.field.TextField;\n+import com.dotcms.contenttype.model.field.TimeField;\n+import com.dotcms.contenttype.model.field.WysiwygField;\n+import com.dotcms.contenttype.model.type.ContentType;\n+import com.dotcms.repackage.com.google.common.annotations.VisibleForTesting;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.FactoryLocator;\n+import com.dotmarketing.business.RelationshipAPI;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.portlets.structure.model.Relationship;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.json.JSONObject;\n+import com.jayway.jsonpath.JsonPath;\n+import com.liferay.portal.language.LanguageException;\n+import com.liferay.portal.language.LanguageUtil;\n+import com.liferay.util.StringPool;\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.URL;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper class responsible of setting Elasticsearch mapping for content type fields\n+ * @author nollymar\n+ */\n+public class ESMappingUtilHelper {\n+\n+    private ContentTypeAPI contentTypeAPI;\n+    private ESMappingAPIImpl esMappingAPI;\n+    private RelationshipAPI relationshipAPI;\n+\n+    private static class SingletonHolder {\n+\n+        private static final ESMappingUtilHelper INSTANCE = new ESMappingUtilHelper();\n+    }\n+\n+    public static ESMappingUtilHelper getInstance() {\n+        return ESMappingUtilHelper.SingletonHolder.INSTANCE;\n+    }\n+\n+    private ESMappingUtilHelper() {\n+        contentTypeAPI = APILocator.getContentTypeAPI(APILocator.systemUser());\n+        esMappingAPI = new ESMappingAPIImpl();\n+        relationshipAPI = APILocator.getRelationshipAPI();\n+    }\n+\n+    @VisibleForTesting\n+    ESMappingUtilHelper(final ContentTypeAPI contentTypeAPI, final ESMappingAPIImpl esMappingAPI,\n+            final RelationshipAPI relationshipAPI) {\n+        this.contentTypeAPI = contentTypeAPI;\n+        this.esMappingAPI = esMappingAPI;\n+        this.relationshipAPI = relationshipAPI;\n+    }\n+\n+    /**\n+     * Sets a custom index mapping for relationships and also for mapping defined on field variables\n+     * using `esCustomMapping` property\n+     *\n+     * @param indexName - Index where mapping will be updated\n+     */\n+    @CloseDBIfOpened\n+    public void addCustomMapping(final String indexName) {\n+\n+        final Set<String> mappedFields = addCustomMappingFromFieldVariables(indexName);\n+\n+        addCustomMappingForRelationships(indexName, mappedFields);\n+\n+        addMappingForRemainingFields(indexName, mappedFields);\n+    }\n+\n+    /**\n+     * Sets a mapping for all relationships except for those that contains its custom mapping using\n+     * field variables\n+     *\n+     * @param indexName - Index where mapping will be updated\n+     * @param mappedFields - Collection that contains the fields with a specific mapping until now.\n+     * </br> When a put mapping request is sent to Elasticsearch for each relationship (if needed),\n+     * a new entry is added to the <b>mappedFields</b> collection\n+     */\n+    private void addCustomMappingForRelationships(final String indexName,\n+            final Set<String> mappedFields) {\n+        final List<Relationship> relationships = relationshipAPI.dbAll();\n+\n+        for (final Relationship relationship : relationships) {\n+            final String relationshipName = relationship.getRelationTypeValue().toLowerCase();\n+            if (!mappedFields.contains(relationshipName)) {\n+                final JSONObject properties = new JSONObject();\n+                try {\n+                    properties.put(\"properties\", new JSONObject()\n+                            .put(relationshipName,\n+                                    new JSONObject(\"{\\n\"\n+                                            + \"\\\"type\\\":  \\\"keyword\\\",\\n\"\n+                                            + \"\\\"ignore_above\\\": 8191\\n\"\n+                                            + \"}\")));\n+                    esMappingAPI.putMapping(indexName, properties.toString());\n+\n+                    //Adds to the set the mapped already set for this field\n+                    mappedFields.add(relationshipName);\n+                } catch (Exception e) {\n+                    handleInvalidCustomMappingError(indexName, relationshipName);\n+                    final String message =\n+                            \"Error updating index mapping for relationship \" + relationshipName\n+                                    + \". This custom mapping will be ignored for index: \"\n+                                    + indexName;\n+                    Logger.warn(ESMappingUtilHelper.class, message, e);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Creates a system message event with an error in case a field mapping fails\n+     * @param indexName - Index where the mapping is trying to be applied\n+     * @param fieldName - Field whose mapping is trying to be applied to\n+     */\n+    private void handleInvalidCustomMappingError(final String indexName,\n+            final String fieldName) {\n+\n+        final SystemMessageEventUtil systemMessageEventUtil = SystemMessageEventUtil.getInstance();\n+\n+        try {\n+            systemMessageEventUtil.pushMessage(\n+                    new SystemMessageBuilder()\n+                            .setMessage(LanguageUtil.format(Locale.getDefault(),\n+                                    \"notification.reindexing.custom.mapping.error\",\n+                                    new String[]{fieldName, indexName}, false))\n+                            .setSeverity(MessageSeverity.ERROR)\n+                            .setType(MessageType.SIMPLE_MESSAGE)\n+                            .setLife(6000)\n+                            .create(), null);\n+        } catch (LanguageException ex) {\n+            throw new RuntimeException(ex);", "originalCommit": "e6002906f706b0ec3e63bfb87e15bd5a0102b506", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk4OTQ3Ng==", "url": "https://github.com/dotCMS/core/pull/18751#discussion_r453989476", "bodyText": "Codacy found an issue: JUnit tests should include assert() or fail()", "author": "dev-dotcms", "createdAt": "2020-07-13T22:44:58Z", "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/util/ESMappingUtilHelperTest.java", "diffHunk": "@@ -0,0 +1,570 @@\n+package com.dotcms.content.elasticsearch.util;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import com.dotcms.content.elasticsearch.business.ContentletIndexAPI;\n+import com.dotcms.content.elasticsearch.business.DotIndexException;\n+import com.dotcms.content.elasticsearch.business.ESIndexAPI;\n+import com.dotcms.content.elasticsearch.business.ESMappingAPIImpl;\n+import com.dotcms.content.elasticsearch.business.IndexType;\n+import com.dotcms.contenttype.business.ContentTypeAPI;\n+import com.dotcms.contenttype.business.FieldAPI;\n+import com.dotcms.contenttype.exception.NotFoundInDbException;\n+import com.dotcms.contenttype.model.field.DataTypes;\n+import com.dotcms.contenttype.model.field.DateField;\n+import com.dotcms.contenttype.model.field.DateTimeField;\n+import com.dotcms.contenttype.model.field.Field;\n+import com.dotcms.contenttype.model.field.FieldBuilder;\n+import com.dotcms.contenttype.model.field.FieldVariable;\n+import com.dotcms.contenttype.model.field.ImmutableFieldVariable;\n+import com.dotcms.contenttype.model.field.RadioField;\n+import com.dotcms.contenttype.model.field.RelationshipField;\n+import com.dotcms.contenttype.model.field.SelectField;\n+import com.dotcms.contenttype.model.field.TextField;\n+import com.dotcms.contenttype.model.type.ContentType;\n+import com.dotcms.datagen.ContentTypeDataGen;\n+import com.dotcms.datagen.ContentletDataGen;\n+import com.dotcms.datagen.FieldDataGen;\n+import com.dotcms.datagen.TestDataUtils;\n+import com.dotcms.util.CollectionsUtils;\n+import com.dotcms.util.IntegrationTestInitService;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.RelationshipAPI;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.portlets.categories.business.CategoryAPI;\n+import com.dotmarketing.portlets.categories.model.Category;\n+import com.dotmarketing.portlets.contentlet.business.ContentletAPI;\n+import com.dotmarketing.portlets.contentlet.model.Contentlet;\n+import com.dotmarketing.portlets.languagesmanager.model.Language;\n+import com.dotmarketing.portlets.structure.model.Relationship;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.UtilMethods;\n+import com.dotmarketing.util.WebKeys.Relationship.RELATIONSHIP_CARDINALITY;\n+import com.dotmarketing.util.json.JSONObject;\n+import com.liferay.portal.model.User;\n+import com.liferay.util.StringPool;\n+import com.tngtech.java.junit.dataprovider.DataProvider;\n+import com.tngtech.java.junit.dataprovider.DataProviderRunner;\n+import com.tngtech.java.junit.dataprovider.UseDataProvider;\n+import com.tngtech.junit.dataprovider.format.DataProviderTestNameFormatter;\n+import java.io.IOException;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+/**\n+ * Class used to validate ES mapping for fields is applied correctly considering fields types and dynamic mapping defined in `es-content-mapping.json`\n+ * @author nollymar\n+ */\n+@RunWith(DataProviderRunner.class)\n+public class ESMappingUtilHelperTest {\n+\n+    private static User user;\n+    private static CategoryAPI categoryAPI;\n+    private static ContentletAPI contentletAPI;\n+    private static ContentletIndexAPI contentletIndexAPI;\n+    private static ContentTypeAPI contentTypeAPI;\n+    private static ESMappingAPIImpl esMappingAPI;\n+    private static FieldAPI fieldAPI;\n+    private static RelationshipAPI relationshipAPI;\n+    private static Language language;\n+\n+    @BeforeClass\n+    public static void prepare() throws Exception {\n+        //Setting web app environment\n+        IntegrationTestInitService.getInstance().init();\n+\n+        user = APILocator.systemUser();\n+        categoryAPI = APILocator.getCategoryAPI();\n+        contentletAPI = APILocator.getContentletAPI();\n+        contentletIndexAPI = APILocator.getContentletIndexAPI();\n+        contentTypeAPI = APILocator.getContentTypeAPI(user);\n+        esMappingAPI = new ESMappingAPIImpl();\n+        fieldAPI = APILocator.getContentTypeFieldAPI();\n+        relationshipAPI = APILocator.getRelationshipAPI();\n+        language = APILocator.getLanguageAPI().getDefaultLanguage();\n+    }\n+\n+    public static class PlusTestNameFormatter implements DataProviderTestNameFormatter {\n+        @Override\n+        public String format(Method testMethod, int invocationIndex, List<Object> arguments) {\n+            return String.format(\"Test Name: %s. Mapping Name: %s\", testMethod.getName(), arguments.get(0));\n+        }\n+    }\n+\n+    @DataProvider(formatter = PlusTestNameFormatter.class)\n+    public static Object[][] dataProviderValidateEventMapping(){\n+        return new Object[][] {\n+                {\"template_1\", new String[]{\"host.hostname_dotraw\"}, \"keyword\"},\n+                {\"textmapping\", new String[]{\"host.hostname\"}, \"keyword\"},\n+                {\"strings_as_dates\", new String[]{\"calendarevent.originalstartdate\",\n+                        \"calendarevent.recurrencestart\", \"calendarevent.recurrenceend\"}, \"date\"},\n+                {\"permissions\", new String[]{\"permissions\"}, \"text\"},\n+                {\"hostname\", new String[]{\"host.hostname_text\"}, \"text\"}\n+        };\n+    }\n+\n+    @DataProvider(formatter = PlusTestNameFormatter.class)\n+    public static Object[][] dataProviderValidateFileAssetMapping(){\n+        return new Object[][] {\n+                {\"longmapping\", new String[]{ \"metadata.height\", \"metadata.width\"}, \"long\"},\n+                {\"keywordmapping\", new String[]{\"metadata.contenttype\"}, \"keyword\"}\n+        };\n+    }\n+\n+    @DataProvider(formatter = PlusTestNameFormatter.class)\n+    public static Object[][] dataProviderValidateNewsLikeMapping() {\n+        return new Object[][]{\n+                {\"geomapping\", new String[]{\"mylatlon\"}, \"geo_point\"},\n+                {\"geomapping_2\", new String[]{\"latlong\"}, \"geo_point\"},\n+                {\"keywordmapping\", new String[]{\"categories\", \"tags\", \"conhost\", \"conhostname\",\n+                        \"wfstep\", \"structurename\", \"contenttype\", \"parentpath\", \"path\", \"urlmap\",\n+                        \"moduser\", \"owner\"}, \"keyword\"}\n+        };\n+    }\n+\n+    /*Data provider used to verify that the ES mapping is applied correctly and considers exclusions in the `es-content-mapping` file\n+        For each scenario we define:\n+            1) testCase name\n+            2) Field(s) type\n+            3) Field(s) variable name(s)\n+            4) Expected ES mapping\n+     */\n+    @DataProvider(formatter = PlusTestNameFormatter.class)\n+    public static Object[][] dataProviderAddMappingForFields() {\n+        return new Object[][] {\n+                {  \"strings_as_dates\", DateField.class, DataTypes.DATE,\n+                        new String[] {\"originalstartdate\", \"recurrencestart\", \"recurrenceend\"},  \"date\" },\n+\n+                {  \"strings_as_date_times\", DateTimeField.class, DataTypes.DATE,\n+                        new String[] {\"originalstartdate\", \"recurrencestart\", \"recurrenceend\"},  \"date\" },\n+\n+                {  \"dates_as_text\", TextField.class, DataTypes.TEXT,\n+                        new String[] {\"originalstartdate\", \"recurrencestart\", \"recurrenceend\"},  \"text\" },\n+\n+                {  \"keywordmapping\", TextField.class, DataTypes.TEXT,\n+                        new String[] {\"categories\", \"tags\", \"conhost\",\n+                                \"wfstep\", \"structurename\", \"contenttype\", \"parentpath\",\n+                                \"path\", \"urlmap\", \"moduser\", \"owner\"},  \"text\" },\n+\n+                {  \"geomapping\", TextField.class, DataTypes.TEXT,\n+                        new String[] {\"mylatlong\", \"mylatlon\"},  null },\n+\n+                {  \"permissions\", TextField.class, DataTypes.TEXT, new String[] {\"permissions\"},  \"text\" },\n+\n+                {  \"radio_as_boolean\", RadioField.class, DataTypes.BOOL,\n+                        new String[] {\"MyRadioAsBoolean\"},  \"boolean\" },\n+\n+                {  \"radio_as_float\", RadioField.class, DataTypes.FLOAT,\n+                        new String[] {\"MyRadioAsFloat\"},  \"float\" },\n+\n+                {  \"radio_as_integer\", RadioField.class, DataTypes.INTEGER,\n+                        new String[] {\"MyRadioAsInteger\"},  \"integer\" },\n+\n+                {  \"select_as_boolean\", SelectField.class, DataTypes.BOOL,\n+                        new String[] {\"MySelectAsBoolean\"},  \"boolean\" },\n+\n+                {  \"select_as_float\", SelectField.class, DataTypes.FLOAT,\n+                        new String[] {\"MySelectAsFloat\"},  \"float\" },\n+\n+                {  \"select_as_integer\", SelectField.class, DataTypes.INTEGER,\n+                        new String[] {\"MySelectAsInteger\"},  \"integer\" },\n+\n+                {  \"text_as_float\", TextField.class, DataTypes.FLOAT,\n+                        new String[] {\"MyTextAsFloat\"},  \"float\" },\n+\n+                {  \"text_as_integer\", TextField.class, DataTypes.INTEGER,\n+                        new String[] {\"MyTextAsInteger\"},  \"integer\" }\n+        };\n+    }\n+\n+    /**\n+     * <b>Method to test:</b> Internally, it tests the method ESMappingUtilHelper.addMappingForFieldIfNeeded<p></p>\n+     * <b>Test Case:</b> Given a field or an array of fields, the right ES mapping should be set, considering exclusions in the `es-content-mapping` file<p></p>\n+     * <b>Expected Results:</b> Each test case should match the `expectedResult` value, which is a string with the correct datatype in ES\n+     * @param testCase\n+     * @param fieldType\n+     * @param type\n+     * @param fields\n+     * @param expectedResult\n+     * @throws IOException\n+     * @throws DotIndexException\n+     * @throws DotSecurityException\n+     * @throws DotDataException\n+     */\n+    @UseDataProvider\n+    @Test\n+    public void testAddMappingForFields(final String testCase, final Class fieldType,\n+            final DataTypes type,\n+            final String[] fields, final String expectedResult)\n+            throws IOException, DotIndexException, DotSecurityException, DotDataException {\n+\n+        Logger.info(ESMappingUtilHelperTest.class,\n+                String.format(\"Testing Add Mapping for fields defined in %s template\", testCase));\n+\n+        final ContentType contentType = new ContentTypeDataGen().nextPersisted();\n+\n+        String workingIndex = null;\n+        //Build the index name\n+        String timestamp = String.valueOf(new Date().getTime());\n+        try {\n+            //Adding fields\n+            for (final String field : fields) {\n+                final Field newField = FieldBuilder.builder(fieldType)\n+                        .name(field).variable(field).dataType(type).contentTypeId(contentType.id())\n+                        .indexed(true).build();\n+                fieldAPI.save(newField, user);\n+            }\n+\n+            workingIndex = new ESIndexAPI().getNameWithClusterIDPrefix(\n+                    IndexType.WORKING.getPrefix() + \"_\" + timestamp);\n+\n+            //Create a working index\n+            boolean result = contentletIndexAPI.createContentIndex(workingIndex);\n+            //Validate\n+            assertTrue(result);\n+\n+            for (final String field : fields) {\n+\n+                if (expectedResult == null) {\n+                    assertFalse(UtilMethods.isSet(esMappingAPI.getFieldMappingAsMap(workingIndex,\n+                            (contentType.variable() + StringPool.PERIOD + field).toLowerCase())));\n+                } else {\n+                    Map<String, String> mapping = (Map<String, String>) esMappingAPI\n+                            .getFieldMappingAsMap(workingIndex,\n+                                    (contentType.variable() + StringPool.PERIOD + field)\n+                                            .toLowerCase()).get(field.toLowerCase());\n+                    assertTrue(UtilMethods.isSet(mapping.get(\"type\")));\n+                    assertEquals(expectedResult, mapping.get(\"type\"));\n+                }\n+            }\n+\n+        } finally {\n+            if (workingIndex != null) {\n+                contentletIndexAPI.delete(workingIndex);\n+            }\n+\n+            if (contentType != null) {\n+                contentTypeAPI.delete(contentType);\n+            }\n+        }\n+    }\n+\n+\n+    /**\n+     * <b>Method to test:</b> Internally, it tests the methods ESMappingUtilHelper.addCustomMappingForRelationships and </p>\n+     * ESMappingUtilHelper.addCustomMappingFromFieldVariables<p></p>\n+     * </p><b>Test Case:</b> This test creates an index with two custom mapped fields: a text field and a relationship field.\n+     * Additionally, it creates a legacy relationship without a custom mapping in order to verify that\n+     * relationships in general are mapped as keywords by default, unless a custom mapping is defined for a specific case <p></p>\n+     * <b>Expected Results:</b> Custom mappings should take precedence always if exists. In case of relationships, </p>\n+     * they should be mapped as keywords, unless a custom mapping is defined\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testCreateContentIndexWithCustomMappings() throws Exception {\n+\n+        String workingIndex = null;\n+        ContentType parentContentType = null;\n+        ContentType childContentType = null;\n+        try {\n+            parentContentType = new ContentTypeDataGen().nextPersisted();\n+            childContentType = new ContentTypeDataGen().nextPersisted();\n+\n+            //Adding fields\n+            Field ageField = FieldBuilder.builder(TextField.class)\n+                    .name(\"age\").contentTypeId(parentContentType.id()).indexed(false).build();\n+            ageField = fieldAPI.save(ageField, user);\n+\n+            Field relationshipField = FieldBuilder.builder(RelationshipField.class)\n+                    .name(\"relationshipField\")\n+                    .contentTypeId(parentContentType.id())\n+                    .values(String.valueOf(RELATIONSHIP_CARDINALITY.ONE_TO_MANY.ordinal()))\n+                    .relationType(parentContentType.variable()).build();\n+\n+            relationshipField = fieldAPI.save(relationshipField, user);\n+\n+            //Create legacy relationship\n+            final Relationship legacyRelationship = createLegacyRelationship(parentContentType,\n+                    childContentType);\n+\n+            //Adding field variables\n+            final FieldVariable ageVariable = ImmutableFieldVariable.builder()\n+                    .fieldId(ageField.inode())\n+                    .name(\"ageMapping\").key(FieldVariable.ES_CUSTOM_MAPPING_KEY).value(\"{\\n\"\n+                            + \"                \\\"type\\\": \\\"long\\\"\\n\"\n+                            + \"              }\").userId(user.getUserId())\n+                    .build();\n+\n+            fieldAPI.save(ageVariable, user);\n+\n+            FieldVariable relVariable = ImmutableFieldVariable.builder()\n+                    .fieldId(relationshipField.inode())\n+                    .name(\"relMapping\").key(FieldVariable.ES_CUSTOM_MAPPING_KEY).value(\"{\\n\"\n+                            + \"                \\\"type\\\": \\\"text\\\"\\n\"\n+                            + \"              }\").userId(user.getUserId())\n+                    .build();\n+\n+            relVariable = fieldAPI.save(relVariable, user);\n+\n+            final Field updatedField = fieldAPI.find(relVariable.fieldId());\n+\n+            //Verify ageField is updated as System Indexed\n+            assertTrue(updatedField.indexed());\n+\n+            //Build the index name\n+            String timestamp = String.valueOf(new Date().getTime());\n+            workingIndex = new ESIndexAPI().getNameWithClusterIDPrefix(IndexType.WORKING.getPrefix() + \"_\" + timestamp);\n+\n+            //Create a working index\n+            boolean result = contentletIndexAPI.createContentIndex(workingIndex);\n+            //Validate\n+            assertTrue(result);\n+\n+            //verify mapping\n+            final String mapping = esMappingAPI.getMapping(workingIndex);\n+\n+            //parse json mapping and validate\n+            assertNotNull(mapping);\n+\n+            final JSONObject propertiesJSON = (JSONObject) (new JSONObject(mapping)).get(\"properties\");\n+            final JSONObject contentTypeJSON = (JSONObject) ((JSONObject) propertiesJSON\n+                    .get(parentContentType.variable().toLowerCase())).get(\"properties\");\n+\n+            //validate age mapping results\n+            final Map ageMapping = ((JSONObject) contentTypeJSON\n+                    .get(ageField.variable().toLowerCase())).getAsMap();\n+            assertNotNull(ageMapping);\n+            assertEquals(1, ageMapping.size());\n+            assertEquals(\"long\", ageMapping.get(\"type\"));\n+\n+            //validate relationship field mapping results\n+            final Map relationshipMapping = ((JSONObject) contentTypeJSON\n+                    .get(relationshipField.variable().toLowerCase())).getAsMap();\n+            assertNotNull(relationshipMapping);\n+            assertEquals(1, relationshipMapping.size());\n+            assertEquals(\"text\", relationshipMapping.get(\"type\"));\n+\n+            //validate legacy relationship\n+            final Map legacyRelationshipMapping = ((JSONObject) propertiesJSON\n+                    .get(legacyRelationship.getRelationTypeValue().toLowerCase())).getAsMap();\n+            assertNotNull(ageMapping);\n+            assertEquals(2, legacyRelationshipMapping.size());\n+            assertEquals(\"keyword\", legacyRelationshipMapping.get(\"type\"));\n+            assertEquals(8191, legacyRelationshipMapping.get(\"ignore_above\"));\n+\n+        } finally {\n+            if (workingIndex != null) {\n+                contentletIndexAPI.delete(workingIndex);\n+            }\n+\n+            if (parentContentType != null && parentContentType.inode() != null) {\n+                ContentTypeDataGen.remove(parentContentType);\n+            }\n+\n+            if (childContentType != null && childContentType.inode() != null) {\n+                ContentTypeDataGen.remove(childContentType);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * <b>Test Case:</b> Validates dynamic mappings defined in the `es-content-mapping` file are applied correctly<p></p>\n+     * <b>Expected Results:</b> Each test case should match the `expectedResult` value, which is a string with the correct datatype in ES\n+     * @param testCase\n+     * @param fields\n+     * @param expectedResult\n+     * @throws DotDataException\n+     * @throws IOException\n+     * @throws DotSecurityException\n+     */\n+    @UseDataProvider\n+    @Test\n+    public void testValidateNewsLikeMapping(final String testCase, final String[] fields, final String expectedResult)\n+            throws DotDataException, IOException, DotSecurityException {\n+        final ContentType newsContentType = TestDataUtils.getNewsLikeContentType();\n+        fieldAPI.save( FieldBuilder.builder(TextField.class).contentTypeId(newsContentType.id()).name(\"mylatlon\").variable(\"mylatlon\").indexed(true).build(), user);\n+        Contentlet newsContent = null;\n+        try {\n+            final String categoryName = \"myCategory\" + System.currentTimeMillis();\n+            Category category = new Category();\n+            category.setCategoryName(categoryName);\n+            category.setKey(categoryName);\n+            category.setCategoryVelocityVarName(categoryName);\n+            category.setSortOrder(2);\n+            category.setKeywords(null);\n+            categoryAPI.save(null, category, user, false);\n+            newsContent = new ContentletDataGen(newsContentType.id()).languageId(language.getId())\n+                    .host(APILocator.getHostAPI()\n+                            .findDefaultHost(APILocator.systemUser(), false))\n+                    .setProperty(\"title\", \"newsContent Title\" + System.currentTimeMillis())\n+                    .setProperty(\"urlTitle\", \"myUrlTitle\")\n+                    .setProperty(\"urlMap\", \"myUrlMap\")\n+                    .setProperty(\"byline\", \"byline\")\n+                    .setProperty(\"sysPublishDate\", new Date())\n+                    .setProperty(\"story\", \"newsStory\")\n+                    .setProperty(\"latlong\", \"[90, -90]\")\n+                    .setProperty(\"mylatlon\", \"[90, -90]\")\n+                    .setProperty(\"tags\", \"test\").next();\n+\n+            newsContent = contentletAPI.checkin(newsContent, CollectionsUtils.list(category), null, user, false);\n+            validateMappingForFields(testCase, newsContentType.variable().toLowerCase(), fields, expectedResult);\n+        }finally{\n+            if (newsContent != null) {\n+                ContentletDataGen.destroy(newsContent);\n+            }\n+        }\n+\n+    }\n+\n+    /**\n+     * <b>Test Case:</b> Validates dynamic mappings defined in the `es-content-mapping` file are applied correctly<p></p>\n+     * <b>Expected Results:</b> Each test case should match the `expectedResult` value, which is a string with the correct datatype in ES\n+     * @param testCase\n+     * @param fields\n+     * @param expectedResult\n+     * @throws DotDataException\n+     * @throws IOException\n+     */\n+    @UseDataProvider\n+    @Test\n+    public void testValidateFileAssetMapping(final String testCase, final String[] fields, final String expectedResult)\n+            throws DotDataException, IOException {\n+        Contentlet fileAsset = null;\n+\n+        try{\n+            fileAsset = TestDataUtils.getFileAssetContent(true, language.getId());\n+            validateMappingForFields(testCase, null, fields, expectedResult);\n+        } finally {\n+            if (fileAsset != null) {\n+                ContentletDataGen.destroy(fileAsset);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * <b>Test Case:</b> Validates dynamic mappings defined in the `es-content-mapping` file are applied correctly<p></p>\n+     * <b>Expected Results:</b> Each test case should match the `expectedResult` value, which is a string with the correct datatype in ES\n+     * @param testCase\n+     * @param fields\n+     * @param expectedResult\n+     * @throws DotDataException\n+     * @throws DotSecurityException\n+     * @throws IOException\n+     */\n+    @UseDataProvider\n+    @Test\n+    public void testValidateEventMapping(final String testCase, final String[] fields, final String expectedResult)", "originalCommit": "e6002906f706b0ec3e63bfb87e15bd5a0102b506", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk4OTQ4Mg==", "url": "https://github.com/dotCMS/core/pull/18751#discussion_r453989482", "bodyText": "Codacy found an issue: Private field 'esMappingAPI' could be made final; it is only initialized in the declaration or constructor.", "author": "dev-dotcms", "createdAt": "2020-07-13T22:44:59Z", "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/util/ESMappingUtilHelper.java", "diffHunk": "@@ -0,0 +1,331 @@\n+package com.dotcms.content.elasticsearch.util;\n+\n+import com.dotcms.api.system.event.message.MessageSeverity;\n+import com.dotcms.api.system.event.message.MessageType;\n+import com.dotcms.api.system.event.message.SystemMessageEventUtil;\n+import com.dotcms.api.system.event.message.builder.SystemMessageBuilder;\n+import com.dotcms.business.CloseDBIfOpened;\n+import com.dotcms.content.elasticsearch.business.ESIndexAPI;\n+import com.dotcms.content.elasticsearch.business.ESMappingAPIImpl;\n+import com.dotcms.contenttype.business.ContentTypeAPI;\n+import com.dotcms.contenttype.business.FieldFactory;\n+import com.dotcms.contenttype.model.field.DataTypes;\n+import com.dotcms.contenttype.model.field.DateField;\n+import com.dotcms.contenttype.model.field.DateTimeField;\n+import com.dotcms.contenttype.model.field.Field;\n+import com.dotcms.contenttype.model.field.FieldVariable;\n+import com.dotcms.contenttype.model.field.RadioField;\n+import com.dotcms.contenttype.model.field.SelectField;\n+import com.dotcms.contenttype.model.field.TextAreaField;\n+import com.dotcms.contenttype.model.field.TextField;\n+import com.dotcms.contenttype.model.field.TimeField;\n+import com.dotcms.contenttype.model.field.WysiwygField;\n+import com.dotcms.contenttype.model.type.ContentType;\n+import com.dotcms.repackage.com.google.common.annotations.VisibleForTesting;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.FactoryLocator;\n+import com.dotmarketing.business.RelationshipAPI;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.portlets.structure.model.Relationship;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.json.JSONObject;\n+import com.jayway.jsonpath.JsonPath;\n+import com.liferay.portal.language.LanguageException;\n+import com.liferay.portal.language.LanguageUtil;\n+import com.liferay.util.StringPool;\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.URL;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper class responsible of setting Elasticsearch mapping for content type fields\n+ * @author nollymar\n+ */\n+public class ESMappingUtilHelper {\n+\n+    private ContentTypeAPI contentTypeAPI;\n+    private ESMappingAPIImpl esMappingAPI;", "originalCommit": "e6002906f706b0ec3e63bfb87e15bd5a0102b506", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk4OTQ4Nw==", "url": "https://github.com/dotCMS/core/pull/18751#discussion_r453989487", "bodyText": "Codacy found an issue: The String literal \"keyword\" appears 5 times in this file; the first occurrence is on line 105", "author": "dev-dotcms", "createdAt": "2020-07-13T22:44:59Z", "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/util/ESMappingUtilHelperTest.java", "diffHunk": "@@ -0,0 +1,570 @@\n+package com.dotcms.content.elasticsearch.util;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import com.dotcms.content.elasticsearch.business.ContentletIndexAPI;\n+import com.dotcms.content.elasticsearch.business.DotIndexException;\n+import com.dotcms.content.elasticsearch.business.ESIndexAPI;\n+import com.dotcms.content.elasticsearch.business.ESMappingAPIImpl;\n+import com.dotcms.content.elasticsearch.business.IndexType;\n+import com.dotcms.contenttype.business.ContentTypeAPI;\n+import com.dotcms.contenttype.business.FieldAPI;\n+import com.dotcms.contenttype.exception.NotFoundInDbException;\n+import com.dotcms.contenttype.model.field.DataTypes;\n+import com.dotcms.contenttype.model.field.DateField;\n+import com.dotcms.contenttype.model.field.DateTimeField;\n+import com.dotcms.contenttype.model.field.Field;\n+import com.dotcms.contenttype.model.field.FieldBuilder;\n+import com.dotcms.contenttype.model.field.FieldVariable;\n+import com.dotcms.contenttype.model.field.ImmutableFieldVariable;\n+import com.dotcms.contenttype.model.field.RadioField;\n+import com.dotcms.contenttype.model.field.RelationshipField;\n+import com.dotcms.contenttype.model.field.SelectField;\n+import com.dotcms.contenttype.model.field.TextField;\n+import com.dotcms.contenttype.model.type.ContentType;\n+import com.dotcms.datagen.ContentTypeDataGen;\n+import com.dotcms.datagen.ContentletDataGen;\n+import com.dotcms.datagen.FieldDataGen;\n+import com.dotcms.datagen.TestDataUtils;\n+import com.dotcms.util.CollectionsUtils;\n+import com.dotcms.util.IntegrationTestInitService;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.RelationshipAPI;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.portlets.categories.business.CategoryAPI;\n+import com.dotmarketing.portlets.categories.model.Category;\n+import com.dotmarketing.portlets.contentlet.business.ContentletAPI;\n+import com.dotmarketing.portlets.contentlet.model.Contentlet;\n+import com.dotmarketing.portlets.languagesmanager.model.Language;\n+import com.dotmarketing.portlets.structure.model.Relationship;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.UtilMethods;\n+import com.dotmarketing.util.WebKeys.Relationship.RELATIONSHIP_CARDINALITY;\n+import com.dotmarketing.util.json.JSONObject;\n+import com.liferay.portal.model.User;\n+import com.liferay.util.StringPool;\n+import com.tngtech.java.junit.dataprovider.DataProvider;\n+import com.tngtech.java.junit.dataprovider.DataProviderRunner;\n+import com.tngtech.java.junit.dataprovider.UseDataProvider;\n+import com.tngtech.junit.dataprovider.format.DataProviderTestNameFormatter;\n+import java.io.IOException;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+/**\n+ * Class used to validate ES mapping for fields is applied correctly considering fields types and dynamic mapping defined in `es-content-mapping.json`\n+ * @author nollymar\n+ */\n+@RunWith(DataProviderRunner.class)\n+public class ESMappingUtilHelperTest {\n+\n+    private static User user;\n+    private static CategoryAPI categoryAPI;\n+    private static ContentletAPI contentletAPI;\n+    private static ContentletIndexAPI contentletIndexAPI;\n+    private static ContentTypeAPI contentTypeAPI;\n+    private static ESMappingAPIImpl esMappingAPI;\n+    private static FieldAPI fieldAPI;\n+    private static RelationshipAPI relationshipAPI;\n+    private static Language language;\n+\n+    @BeforeClass\n+    public static void prepare() throws Exception {\n+        //Setting web app environment\n+        IntegrationTestInitService.getInstance().init();\n+\n+        user = APILocator.systemUser();\n+        categoryAPI = APILocator.getCategoryAPI();\n+        contentletAPI = APILocator.getContentletAPI();\n+        contentletIndexAPI = APILocator.getContentletIndexAPI();\n+        contentTypeAPI = APILocator.getContentTypeAPI(user);\n+        esMappingAPI = new ESMappingAPIImpl();\n+        fieldAPI = APILocator.getContentTypeFieldAPI();\n+        relationshipAPI = APILocator.getRelationshipAPI();\n+        language = APILocator.getLanguageAPI().getDefaultLanguage();\n+    }\n+\n+    public static class PlusTestNameFormatter implements DataProviderTestNameFormatter {\n+        @Override\n+        public String format(Method testMethod, int invocationIndex, List<Object> arguments) {\n+            return String.format(\"Test Name: %s. Mapping Name: %s\", testMethod.getName(), arguments.get(0));\n+        }\n+    }\n+\n+    @DataProvider(formatter = PlusTestNameFormatter.class)\n+    public static Object[][] dataProviderValidateEventMapping(){\n+        return new Object[][] {\n+                {\"template_1\", new String[]{\"host.hostname_dotraw\"}, \"keyword\"},", "originalCommit": "e6002906f706b0ec3e63bfb87e15bd5a0102b506", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk4OTQ5Mw==", "url": "https://github.com/dotCMS/core/pull/18751#discussion_r453989493", "bodyText": "Codacy found an issue: Private field 'contentTypeAPI' could be made final; it is only initialized in the declaration or constructor.", "author": "dev-dotcms", "createdAt": "2020-07-13T22:45:00Z", "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/util/ESMappingUtilHelper.java", "diffHunk": "@@ -0,0 +1,331 @@\n+package com.dotcms.content.elasticsearch.util;\n+\n+import com.dotcms.api.system.event.message.MessageSeverity;\n+import com.dotcms.api.system.event.message.MessageType;\n+import com.dotcms.api.system.event.message.SystemMessageEventUtil;\n+import com.dotcms.api.system.event.message.builder.SystemMessageBuilder;\n+import com.dotcms.business.CloseDBIfOpened;\n+import com.dotcms.content.elasticsearch.business.ESIndexAPI;\n+import com.dotcms.content.elasticsearch.business.ESMappingAPIImpl;\n+import com.dotcms.contenttype.business.ContentTypeAPI;\n+import com.dotcms.contenttype.business.FieldFactory;\n+import com.dotcms.contenttype.model.field.DataTypes;\n+import com.dotcms.contenttype.model.field.DateField;\n+import com.dotcms.contenttype.model.field.DateTimeField;\n+import com.dotcms.contenttype.model.field.Field;\n+import com.dotcms.contenttype.model.field.FieldVariable;\n+import com.dotcms.contenttype.model.field.RadioField;\n+import com.dotcms.contenttype.model.field.SelectField;\n+import com.dotcms.contenttype.model.field.TextAreaField;\n+import com.dotcms.contenttype.model.field.TextField;\n+import com.dotcms.contenttype.model.field.TimeField;\n+import com.dotcms.contenttype.model.field.WysiwygField;\n+import com.dotcms.contenttype.model.type.ContentType;\n+import com.dotcms.repackage.com.google.common.annotations.VisibleForTesting;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.FactoryLocator;\n+import com.dotmarketing.business.RelationshipAPI;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.portlets.structure.model.Relationship;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.json.JSONObject;\n+import com.jayway.jsonpath.JsonPath;\n+import com.liferay.portal.language.LanguageException;\n+import com.liferay.portal.language.LanguageUtil;\n+import com.liferay.util.StringPool;\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.URL;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper class responsible of setting Elasticsearch mapping for content type fields\n+ * @author nollymar\n+ */\n+public class ESMappingUtilHelper {\n+\n+    private ContentTypeAPI contentTypeAPI;", "originalCommit": "e6002906f706b0ec3e63bfb87e15bd5a0102b506", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}