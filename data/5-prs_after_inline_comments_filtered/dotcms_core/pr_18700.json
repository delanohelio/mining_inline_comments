{"pr_number": 18700, "pr_title": "Revert \"#16796 adding fixes and comments to support the jwt on pp\"", "pr_createdAt": "2020-06-18T18:32:48Z", "pr_url": "https://github.com/dotCMS/core/pull/18700", "timeline": [{"oid": "99d95ae2ee5081fc4f83aebc8659d17fd8e0852e", "url": "https://github.com/dotCMS/core/commit/99d95ae2ee5081fc4f83aebc8659d17fd8e0852e", "message": "Revert \"#16796 adding fixes and comments to support the jwt on pp (#18555)\"\n\nThis reverts commit 3171a2c11d6c3b2afdf999ae362d1594480a3b02.", "committedDate": "2020-06-18T18:31:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQyNzE4OQ==", "url": "https://github.com/dotCMS/core/pull/18700#discussion_r442427189", "bodyText": "Codacy found an issue: This statement should have braces", "author": "dev-dotcms", "createdAt": "2020-06-18T18:38:59Z", "path": "dotCMS/src/main/java/com/dotcms/rest/BundlePublisherResource.java", "diffHunk": "@@ -47,182 +45,140 @@\n      * server on this end point and if the security tokens match. If all the validations are correct the bundle will be add it<br/>\n      * to the {@link PublishThread Publish Thread}.\n      *\n-     * @param fileName        File name to be published\n-     * @param authTokenDigest Authentication token\n-     * @param groupId         Group who sent the Bundle\n-     * @param endpointId      End-point who sent the Bundle\n-\t * @param type\t\t\t  response type\n-\t * @param callback \t\t  response callback\n-\t * @param bundleName\t  The name for the Bundle to publish\n-\t * @param forcePush \t  true/false to Force the push\n-     * @param request         {@link HttpServletRequest}\n-\t * @param response        {@link HttpServletResponse}\n+     * @param fileName       File name to be published\n+     * @param auth_token_enc Authentication token\n+     * @param groupId        Group who sent the Bundle\n+     * @param endpointId     End-point who sent the Bundle\n+\t * @param type\t\t\t response type\n+\t * @param callback \t\t response callback\n+\t * @param bundleName\t The name for the Bundle to publish\n+\t * @param forcePush \t true/false to Force the push\n+     * @param req            HttpRequest\n      * @return Returns a {@link Response} object with a 200 status code if success or a 500 error code if anything fails on the Publish process\n      * @see PublishThread\n      */\n     @POST\n     @Path (\"/publish\")\n     @Consumes(MediaType.APPLICATION_OCTET_STREAM)\n-\t@Produces(MediaType.APPLICATION_JSON)\n \tpublic Response publish(\n-\t\t\t@QueryParam(\"FILE_NAME\")   final String fileName,\n-\t\t\t@QueryParam(\"AUTH_TOKEN\")  final String authTokenDigest,\n-\t\t\t@QueryParam(\"GROUP_ID\")    final String groupId,\n-\t\t\t@QueryParam(\"ENDPOINT_ID\") final String endpointId,\n-\t\t\t@QueryParam(\"type\")        final String type,\n-\t\t\t@QueryParam(\"callback\")    final String callback,\n-\t\t\t@QueryParam(\"BUNDLE_NAME\") final String bundleName,\n-\t\t\t@QueryParam(\"FORCE_PUSH\")  final boolean forcePush,\n-\t\t\t@Context final HttpServletRequest  request,\n-\t\t\t@Context final HttpServletResponse response\n-\t) throws Exception {\n-\t\tfinal ResourceResponse responseResource = new ResourceResponse(\n-\t\t\t\tCollectionsUtils.map(\"type\", type, \"callback\", callback));\n-\t\tfinal String remoteIP = UtilMethods.isSet(request.getRemoteHost())?\n-\t\t\t\trequest.getRemoteHost() : request.getRemoteAddr();\n-\t\tfinal PublishingEndPoint sendingEndPointByAddress =\n-\t\t\t\tthis.endpointAPI.findEnabledSendingEndPointByAddress(remoteIP);\n-\n-\t\tfinal boolean isPPByToken = sendingEndPointByAddress == null;\n-\n-\t\tif (isPPByToken && authTokenDigest == null) {\n-\t\t\tLogger.error(this.getClass(), \"Push Publishing failed from \" + remoteIP + \" JWT token expected\");\n-\t\t\treturn responseResource.responseError(HttpStatus.SC_UNAUTHORIZED);\n-\t\t}\n-\n-\t\tif (request.getInputStream().isFinished()) {\n-\t\t\tLogger.error(this.getClass(), \"Push Publishing failed from \" + remoteIP + \" bundle expected\");\n-\t\t\treturn responseResource.responseError(HttpStatus.SC_BAD_REQUEST);\n-\t\t}\n-\n-\t\tfinal InitDataObject initDataObject = this.init(authTokenDigest, request, response);\n-\n-\t\tif (isPPByToken && null == initDataObject || !this.isAdmin(initDataObject.getUser())) {\n-\t\t\tLogger.error(this.getClass(), \"Push Publishing failed from \" + remoteIP + \" not permission\");\n-\t\t\treturn responseResource.responseError(HttpStatus.SC_UNAUTHORIZED);\n-\t\t} else if (!isPPByToken &&\n-\t\t\t\t(sendingEndPointByAddress == null || !isValidToken(authTokenDigest, remoteIP, sendingEndPointByAddress))) {\n-\t\t\tLogger.error(this.getClass(), \"Push Publishing failed from \" + remoteIP + \" invalid endpoint or token\");\n-\t\t\treturn responseResource.responseError(HttpStatus.SC_UNAUTHORIZED);\n-\t\t}\n-\n-\t\tfinal Bundle bundle = this.publishBundle(fileName, groupId, endpointId, bundleName,\n-\t\t\t\tforcePush, request, remoteIP, sendingEndPointByAddress);\n-\n-\t\tif (isPPByToken && bundle != null) {\n-\t\t\treturn Response.ok(bundle).build();\n-\t\t} else {\n-\t\t\treturn Response.ok().build();\n-\t\t}\n-\t}\n-\n-\n-\tfinal InitDataObject init (final String authTokenDigest, final HttpServletRequest  request,\n-\t\t\t\t\t\t\t   final HttpServletResponse response) {\n-\n+\t\t\t@QueryParam(\"FILE_NAME\") String fileName,\n+\t\t\t@QueryParam(\"AUTH_TOKEN\") String auth_token_digest,\n+\t\t\t@QueryParam(\"GROUP_ID\") String groupId,\n+\t\t\t@QueryParam(\"ENDPOINT_ID\") String endpointId,\n+\t\t\t@QueryParam(\"type\") String type,\n+\t\t\t@QueryParam(\"callback\") String callback,\n+\t\t\t@QueryParam(\"BUNDLE_NAME\") String bundleName,\n+\t\t\t@QueryParam(\"FORCE_PUSH\") final boolean forcePush,\n+\t\t\t@Context HttpServletRequest req\n+\t) {\n     \ttry {\n-\t\t\treturn new WebResource.InitBuilder().\n-\t\t\t\t\trejectWhenNoUser(false). // it would be a soft validation so not reject\n-\t\t\t\t\trequestAndResponse(\n-\t\t\t\t\tnew HttpHeaderHandlerHttpServletRequestWrapper(request,\n-\t\t\t\t\t\t\tCollectionsUtils.map(\n-\t\t\t\t\t\t\t\t\t\"Authorization\", (name, value) -> // if the authorization is set, uses it, otherwise try with the secret (could be a jwt)\n-\t\t\t\t\t\t\t\t\t\t\tUtilMethods.isSet(value) ? value : JsonWebTokenAuthCredentialProcessor.BEARER + authTokenDigest\n-\t\t\t\t\t\t\t)), response).init();\n-\t\t}catch (Exception e) {\n-    \t\treturn null;\n-\t\t}\n-\n-\t}\n-\n-\n-\t@WrapInTransaction\n-\tprivate Bundle publishBundle(final String fileNameSent,\n-\t\t\t\t\t\t\t\t  final String groupId,\n-\t\t\t\t\t\t\t\t  final String endpointId,\n-\t\t\t\t\t\t\t\t  final String bundleNameSent,\n-\t\t\t\t\t\t\t\t  final boolean forcePush,\n-\t\t\t\t\t\t\t\t  final HttpServletRequest request,\n-\t\t\t\t\t\t\t\t  final String remoteIP,\n-\t\t\t\t\t\t\t\t  final PublishingEndPoint sendingEndPointByAddress) throws Exception {\n-\n-    \tfinal String fileName = UtilMethods.isSet(fileNameSent) ? fileNameSent : generatedBundleFileName();\n-\t\tfinal String bundleName =  UtilMethods.isSet(bundleNameSent) ? bundleNameSent : fileName;\n-\n-\t\tBundle bundle = null;\n-\n-\t\ttry (InputStream bundleStream = request.getInputStream()) {\n-\n-\t\t\tfinal String bundlePath         = ConfigUtils.getBundlePath()+ File.separator + MY_TEMP;\n-\t\t\tfinal String bundleFolder       = fileName.substring(0, fileName.indexOf(\".tar.gz\"));\n-\t\t\tfinal String sendingEndPoint = sendingEndPointByAddress != null ? sendingEndPointByAddress.getId() : remoteIP;\n-\t\t\tfinal PublishAuditStatus status = PublishAuditAPI.getInstance().updateAuditTable(\n-\t\t\t\t\tsendingEndPoint, sendingEndPoint, bundleFolder, true);\n-\n-\t\t\tif(bundleName.trim().length() > 0) {\n-\t\t\t\t// save bundle if it doesn't exists\n-\t\t\t\tbundle = APILocator.getBundleAPI().getBundleById(bundleFolder);\n-\t\t\t\tif (bundle == null || bundle.getId() == null) {\n-\n-\t\t\t\t\tbundle = new Bundle();\n-\t\t\t\t\tbundle.setId(bundleFolder);\n-\t\t\t\t\tbundle.setName(bundleName);\n-\t\t\t\t\tbundle.setPublishDate(Calendar.getInstance().getTime());\n-\t\t\t\t\tbundle.setOwner(APILocator.getUserAPI().getSystemUser().getUserId());\n-\t\t\t\t\tbundle.setForcePush(forcePush);\n-\t\t\t\t\tAPILocator.getBundleAPI().saveBundle(bundle);\n+    \t\ttry (InputStream bundleStream = req.getInputStream()) {\n+\t\t        //Creating an utility response object\n+\t\t        Map<String, String> paramsMap = new HashMap<String, String>();\n+\t\t        paramsMap.put( \"type\", type );\n+\t\t        paramsMap.put( \"callback\", callback );\n+\t\t        ResourceResponse responseResource = new ResourceResponse( paramsMap );\n+\n+\t\t\t\tString remoteIP = \"\";\n+\t\t\t\ttry {\n+\n+\t\t\t\t\tremoteIP = req.getRemoteHost();\n+\t\t\t\t\tif(!UtilMethods.isSet(remoteIP))\n+\t\t\t\t\t\tremoteIP = req.getRemoteAddr();", "originalCommit": "99d95ae2ee5081fc4f83aebc8659d17fd8e0852e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}