{"pr_number": 18507, "pr_title": "#18494 : Refactors and improves the performance in the Drop Old Asset\u2026", "pr_createdAt": "2020-05-15T21:01:37Z", "pr_url": "https://github.com/dotCMS/core/pull/18507", "timeline": [{"oid": "886a8bfa5eca55deffeaf98234a5c2e73d758f4e", "url": "https://github.com/dotCMS/core/commit/886a8bfa5eca55deffeaf98234a5c2e73d758f4e", "message": "#18494 : Refactors and improves the performance in the Drop Old Asset Versions tool.\n\nIn the `CMSMaintenanceFactory` class:\n1. Narrows the potential list of Inodes to delete down by selecting the oldest Inode out of the list of objects that are actually versionable in dotCMS. Also, used the `MIN()` function to get the oldest date, not the previous approach. This means faster execution as there are less records to traverse.\n2. Improves the task progress logging so users can keep track of of it.\n3. Usual code refactoring.\n\nIn the `ESContentFactoryImpl` class:\n1. Code attempted to solve ALL data inconsistencies in the Inode table along the way. This was carried out every time and caused the connection socket to close as that is an extremely heavy operation.\n2. Now, we get the actual list of Inodes that need to be deleted. If there's any, then delete them. If not, just move on.\n3. If there are Inodes, do a batch delete instead of deleting them all.\n4. For some reason, this method takes care of deleting orphaned physical assets in the \"/assets/\" folder. It was doing it every time it was called even if no Inode records were deleted. Performance was improved by only executing this task when files are deleted. NOTE: R&D might consider removing this specific part of the code.\n\nUsing data from customer, the tool went from getting a \"socket closed\" exception after 5 minutes, to cleaning up almost 60,000 records in around 4.5 minutes in a local environment.", "committedDate": "2020-05-15T21:01:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY3MTEzNg==", "url": "https://github.com/dotCMS/core/pull/18507#discussion_r426671136", "bodyText": "here you can do\nfinal List inodeList = result.stream().map(row -> row.get(\"inode\")).collect(Collectors.toList());", "author": "freddyucv", "createdAt": "2020-05-18T14:33:13Z", "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESContentFactoryImpl.java", "diffHunk": "@@ -679,64 +681,87 @@ private void deleteTreesForInodes(List<String> inodes) throws DotDataException {\n     }\n \n \t@Override\n-\tprotected int deleteOldContent(Date deleteFrom) throws DotDataException {\n-\t    ContentletCache cc = CacheLocator.getContentletCache();\n-        Calendar calendar = Calendar.getInstance();\n+    protected int deleteOldContent(final Date deleteFrom) throws DotDataException {\n+        final Calendar calendar = Calendar.getInstance();\n         calendar.setTime(deleteFrom);\n         calendar.set(Calendar.HOUR_OF_DAY, 0);\n         calendar.set(Calendar.MINUTE, 0);\n         calendar.set(Calendar.SECOND, 0);\n         calendar.set(Calendar.MILLISECOND, 0);\n-        Date date = calendar.getTime();\n-        //Because of the way Oracle databases handle dates,\n-        //this string is converted to Uppercase.This does\n-        //not cause a problem with the other databases\n-        DotConnect dc = new DotConnect();\n+        final Date date = calendar.getTime();\n \n-        String countSQL = (\"select count(*) as count from contentlet\");\n+        DotConnect dc = new DotConnect();\n+        final String countSQL = \"select count(*) as count from contentlet\";\n         dc.setSQL(countSQL);\n         List<Map<String, String>> result = dc.loadResults();\n-        int before = Integer.parseInt(result.get(0).get(\"count\"));\n-\n-        String deleteContentletSQL = \"delete from contentlet where identifier<>'SYSTEM_HOST' and mod_date < ? \" +\n-        \"and not exists (select * from contentlet_version_info where working_inode=contentlet.inode or live_inode=contentlet.inode)\";\n-        dc.setSQL(deleteContentletSQL);\n-        dc.addParam(date);\n-        dc.loadResult();\n-\n-        String deleteOrphanInodes=\"delete from inode where type='contentlet' and idate < ? and inode not in (select inode from contentlet)\";\n-        dc.setSQL(deleteOrphanInodes);\n+        final int before = Integer.parseInt(result.get(0).get(\"count\"));\n+        dc = new DotConnect();\n+        dc.setSQL(\"SELECT inode FROM contentlet WHERE identifier <> 'SYSTEM_HOST' AND mod_date < ? AND NOT EXISTS \" +\n+                \"(SELECT working_inode, live_inode FROM contentlet_version_info WHERE working_inode = contentlet.inode OR \" +\n+                \"live_inode = contentlet.inode)\");\n         dc.addParam(date);\n-        dc.loadResult();\n-\n+        result = dc.loadResults();\n+        int oldInodesCount = result.size();\n+        if (oldInodesCount > 0) {\n+            final List<String> inodeList = new ArrayList<>();\n+            for (final Map<String, String> row : result) {\n+                inodeList.add(row.get(\"inode\").toString());\n+            }", "originalCommit": "886a8bfa5eca55deffeaf98234a5c2e73d758f4e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUyMzgyNQ==", "url": "https://github.com/dotCMS/core/pull/18507#discussion_r427523825", "bodyText": "Fixed.", "author": "jcastro-dotcms", "createdAt": "2020-05-19T18:47:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY3MTEzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY3MzE2MA==", "url": "https://github.com/dotCMS/core/pull/18507#discussion_r426673160", "bodyText": "I think all this logic should go into a private method\nhttps://github.com/dotCMS/core/pull/18507/files#diff-0d54bf61089532e67d512211809b7a69R710-R727", "author": "freddyucv", "createdAt": "2020-05-18T14:36:10Z", "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESContentFactoryImpl.java", "diffHunk": "@@ -679,64 +681,87 @@ private void deleteTreesForInodes(List<String> inodes) throws DotDataException {\n     }\n \n \t@Override\n-\tprotected int deleteOldContent(Date deleteFrom) throws DotDataException {\n-\t    ContentletCache cc = CacheLocator.getContentletCache();\n-        Calendar calendar = Calendar.getInstance();\n+    protected int deleteOldContent(final Date deleteFrom) throws DotDataException {\n+        final Calendar calendar = Calendar.getInstance();\n         calendar.setTime(deleteFrom);\n         calendar.set(Calendar.HOUR_OF_DAY, 0);\n         calendar.set(Calendar.MINUTE, 0);\n         calendar.set(Calendar.SECOND, 0);\n         calendar.set(Calendar.MILLISECOND, 0);\n-        Date date = calendar.getTime();\n-        //Because of the way Oracle databases handle dates,\n-        //this string is converted to Uppercase.This does\n-        //not cause a problem with the other databases\n-        DotConnect dc = new DotConnect();\n+        final Date date = calendar.getTime();\n \n-        String countSQL = (\"select count(*) as count from contentlet\");\n+        DotConnect dc = new DotConnect();\n+        final String countSQL = \"select count(*) as count from contentlet\";\n         dc.setSQL(countSQL);\n         List<Map<String, String>> result = dc.loadResults();\n-        int before = Integer.parseInt(result.get(0).get(\"count\"));\n-\n-        String deleteContentletSQL = \"delete from contentlet where identifier<>'SYSTEM_HOST' and mod_date < ? \" +\n-        \"and not exists (select * from contentlet_version_info where working_inode=contentlet.inode or live_inode=contentlet.inode)\";\n-        dc.setSQL(deleteContentletSQL);\n-        dc.addParam(date);\n-        dc.loadResult();\n-\n-        String deleteOrphanInodes=\"delete from inode where type='contentlet' and idate < ? and inode not in (select inode from contentlet)\";\n-        dc.setSQL(deleteOrphanInodes);\n+        final int before = Integer.parseInt(result.get(0).get(\"count\"));\n+        dc = new DotConnect();\n+        dc.setSQL(\"SELECT inode FROM contentlet WHERE identifier <> 'SYSTEM_HOST' AND mod_date < ? AND NOT EXISTS \" +\n+                \"(SELECT working_inode, live_inode FROM contentlet_version_info WHERE working_inode = contentlet.inode OR \" +\n+                \"live_inode = contentlet.inode)\");\n         dc.addParam(date);\n-        dc.loadResult();\n-\n+        result = dc.loadResults();\n+        int oldInodesCount = result.size();\n+        if (oldInodesCount > 0) {\n+            final List<String> inodeList = new ArrayList<>();\n+            for (final Map<String, String> row : result) {\n+                inodeList.add(row.get(\"inode\").toString());\n+            }\n+            final int splitAt = 100;\n+            // Split all records into lists of size 'truncateAt'\n+            final List<List<String>> inodesToDelete = Lists.partition(inodeList, splitAt);\n+            final List<String> queries = Lists.newArrayList(\"DELETE FROM contentlet WHERE inode IN (?)\",\n+                    \"DELETE FROM inode WHERE inode IN (?)\");\n+            for (final String query : queries) {\n+                for (final List<String> inodes : inodesToDelete) {\n+                    dc = new DotConnect();\n+                    // Generate the \"(?,?,?...)\" string depending of the number of inodes\n+                    final String parameterPlaceholders = DotConnect.createParametersPlaceholder(inodes.size());\n+                    dc.setSQL(query.replace(\"?\", parameterPlaceholders));\n+                    for (final String inode : inodes) {\n+                        dc.addParam(inode);\n+                    }\n+                    dc.loadResult();\n+                }\n+            }\n+        }", "originalCommit": "886a8bfa5eca55deffeaf98234a5c2e73d758f4e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUyMzg3Mw==", "url": "https://github.com/dotCMS/core/pull/18507#discussion_r427523873", "bodyText": "Fixed.", "author": "jcastro-dotcms", "createdAt": "2020-05-19T18:47:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY3MzE2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY3NDg3OA==", "url": "https://github.com/dotCMS/core/pull/18507#discussion_r426674878", "bodyText": "All this logic should go into a method too\nhttps://github.com/dotCMS/core/pull/18507/files#diff-0d54bf61089532e67d512211809b7a69R731-R755", "author": "freddyucv", "createdAt": "2020-05-18T14:38:33Z", "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESContentFactoryImpl.java", "diffHunk": "@@ -679,64 +681,87 @@ private void deleteTreesForInodes(List<String> inodes) throws DotDataException {\n     }\n \n \t@Override\n-\tprotected int deleteOldContent(Date deleteFrom) throws DotDataException {\n-\t    ContentletCache cc = CacheLocator.getContentletCache();\n-        Calendar calendar = Calendar.getInstance();\n+    protected int deleteOldContent(final Date deleteFrom) throws DotDataException {\n+        final Calendar calendar = Calendar.getInstance();\n         calendar.setTime(deleteFrom);\n         calendar.set(Calendar.HOUR_OF_DAY, 0);\n         calendar.set(Calendar.MINUTE, 0);\n         calendar.set(Calendar.SECOND, 0);\n         calendar.set(Calendar.MILLISECOND, 0);\n-        Date date = calendar.getTime();\n-        //Because of the way Oracle databases handle dates,\n-        //this string is converted to Uppercase.This does\n-        //not cause a problem with the other databases\n-        DotConnect dc = new DotConnect();\n+        final Date date = calendar.getTime();\n \n-        String countSQL = (\"select count(*) as count from contentlet\");\n+        DotConnect dc = new DotConnect();\n+        final String countSQL = \"select count(*) as count from contentlet\";\n         dc.setSQL(countSQL);\n         List<Map<String, String>> result = dc.loadResults();\n-        int before = Integer.parseInt(result.get(0).get(\"count\"));\n-\n-        String deleteContentletSQL = \"delete from contentlet where identifier<>'SYSTEM_HOST' and mod_date < ? \" +\n-        \"and not exists (select * from contentlet_version_info where working_inode=contentlet.inode or live_inode=contentlet.inode)\";\n-        dc.setSQL(deleteContentletSQL);\n-        dc.addParam(date);\n-        dc.loadResult();\n-\n-        String deleteOrphanInodes=\"delete from inode where type='contentlet' and idate < ? and inode not in (select inode from contentlet)\";\n-        dc.setSQL(deleteOrphanInodes);\n+        final int before = Integer.parseInt(result.get(0).get(\"count\"));\n+        dc = new DotConnect();\n+        dc.setSQL(\"SELECT inode FROM contentlet WHERE identifier <> 'SYSTEM_HOST' AND mod_date < ? AND NOT EXISTS \" +\n+                \"(SELECT working_inode, live_inode FROM contentlet_version_info WHERE working_inode = contentlet.inode OR \" +\n+                \"live_inode = contentlet.inode)\");\n         dc.addParam(date);\n-        dc.loadResult();\n-\n+        result = dc.loadResults();\n+        int oldInodesCount = result.size();\n+        if (oldInodesCount > 0) {\n+            final List<String> inodeList = new ArrayList<>();\n+            for (final Map<String, String> row : result) {\n+                inodeList.add(row.get(\"inode\").toString());\n+            }\n+            final int splitAt = 100;\n+            // Split all records into lists of size 'truncateAt'\n+            final List<List<String>> inodesToDelete = Lists.partition(inodeList, splitAt);\n+            final List<String> queries = Lists.newArrayList(\"DELETE FROM contentlet WHERE inode IN (?)\",\n+                    \"DELETE FROM inode WHERE inode IN (?)\");\n+            for (final String query : queries) {\n+                for (final List<String> inodes : inodesToDelete) {\n+                    dc = new DotConnect();\n+                    // Generate the \"(?,?,?...)\" string depending of the number of inodes\n+                    final String parameterPlaceholders = DotConnect.createParametersPlaceholder(inodes.size());\n+                    dc.setSQL(query.replace(\"?\", parameterPlaceholders));\n+                    for (final String inode : inodes) {\n+                        dc.addParam(inode);\n+                    }\n+                    dc.loadResult();\n+                }\n+            }\n+        }\n+        dc = new DotConnect();\n         dc.setSQL(countSQL);\n         result = dc.loadResults();\n-        int after = Integer.parseInt(result.get(0).get(\"count\"));\n-\n-        int deleted=before - after;\n-\n-        // deleting orphan binary files\n-        java.io.File assets=new java.io.File(APILocator.getFileAssetAPI().getRealAssetsRootPath());\n-        for(java.io.File ff1 : assets.listFiles())\n-            if(ff1.isDirectory() && ff1.getName().length()==1 && ff1.getName().matches(\"^[a-f0-9]$\"))\n-                for(java.io.File ff2 : ff1.listFiles())\n-                    if(ff2.isDirectory() && ff2.getName().length()==1 && ff2.getName().matches(\"^[a-f0-9]$\"))\n-                        for(java.io.File ff3 : ff2.listFiles())\n-                            try {\n-                                if(ff3.isDirectory()) {\n-                                    Contentlet con=find(ff3.getName());\n-                                    if(con==null || !UtilMethods.isSet(con.getIdentifier()))\n-                                        if(!FileUtils.deleteQuietly(ff3))\n-                                            Logger.warn(this, \"can't delete \"+ff3.getAbsolutePath());\n+        final int after = Integer.parseInt(result.get(0).get(\"count\"));\n+        final int deleted = before - after;\n+        if (deleted > 0) {\n+            // Deleting orphaned binary files\n+            final java.io.File assets = new java.io.File(APILocator.getFileAssetAPI().getRealAssetsRootPath());\n+            for (final java.io.File firstLevelFolder : assets.listFiles()) {\n+                if (firstLevelFolder.isDirectory() && firstLevelFolder.getName().length() == 1 && firstLevelFolder\n+                        .getName().matches(\"^[a-f0-9]$\")) {\n+                    for (final java.io.File secondLevelFolder : firstLevelFolder.listFiles()) {\n+                        if (secondLevelFolder.isDirectory() && secondLevelFolder.getName().length() == 1 &&\n+                                secondLevelFolder.getName().matches(\"^[a-f0-9]$\")) {\n+                            for (final java.io.File asset : secondLevelFolder.listFiles()) {\n+                                try {\n+                                    if (asset.isDirectory()) {\n+                                        final Contentlet contentlet = find(asset.getName());\n+                                        if (null == contentlet || !UtilMethods.isSet(contentlet.getIdentifier())) {\n+                                            if (!FileUtils.deleteQuietly(asset)) {\n+                                                Logger.warn(this, \"Asset '\" + asset.getAbsolutePath() + \"' could \" +\n+                                                        \"not be deleted.\");\n+                                            }\n+                                        }\n+                                    }\n+                                } catch (final Exception ex) {\n+                                    Logger.warn(this, String.format(\"An error occurred when deleting asset '%s': %s\",\n+                                            asset.getAbsolutePath(), ex.getMessage()));\n                                 }", "originalCommit": "886a8bfa5eca55deffeaf98234a5c2e73d758f4e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUyMzkxMw==", "url": "https://github.com/dotCMS/core/pull/18507#discussion_r427523913", "bodyText": "Fixed.", "author": "jcastro-dotcms", "createdAt": "2020-05-19T18:47:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY3NDg3OA=="}], "type": "inlineReview"}, {"oid": "baab02a866740a2b99cc3aecd5cca4e0f233779d", "url": "https://github.com/dotCMS/core/commit/baab02a866740a2b99cc3aecd5cca4e0f233779d", "message": "#18494 : Adding code review changes from Freddy Rodriguez and Codacy.", "committedDate": "2020-05-19T18:46:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUyNjIyNw==", "url": "https://github.com/dotCMS/core/pull/18507#discussion_r427526227", "bodyText": "Just by separating this into two queries and using UNION on them you will probably get a high performance gain:\nOriginal query\nEXPLAIN ANALYSE SELECT inode FROM contentlet WHERE identifier <> 'SYSTEM_HOST' AND mod_date < now() AND NOT EXISTS\n(SELECT working_inode, live_inode FROM contentlet_version_info WHERE working_inode = contentlet.inode OR\n                live_inode = contentlet.inode)\n\nProposed query - One query for live, one for working and INTERSECT. That way you don't have an OR.\nEXPLAIN ANALYSE SELECT inode FROM contentlet WHERE identifier <> 'SYSTEM_HOST' AND mod_date < now() AND NOT EXISTS\n    (SELECT working_inode FROM contentlet_version_info WHERE working_inode = contentlet.inode)\nINTERSECT\n        SELECT inode FROM contentlet WHERE identifier <> 'SYSTEM_HOST' AND mod_date < now() AND NOT EXISTS\n    (SELECT live_inode FROM contentlet_version_info WHERE live_inode = contentlet.inode)```", "author": "dsilvam", "createdAt": "2020-05-19T18:51:14Z", "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESContentFactoryImpl.java", "diffHunk": "@@ -679,64 +681,87 @@ private void deleteTreesForInodes(List<String> inodes) throws DotDataException {\n     }\n \n \t@Override\n-\tprotected int deleteOldContent(Date deleteFrom) throws DotDataException {\n-\t    ContentletCache cc = CacheLocator.getContentletCache();\n-        Calendar calendar = Calendar.getInstance();\n+    protected int deleteOldContent(final Date deleteFrom) throws DotDataException {\n+        final Calendar calendar = Calendar.getInstance();\n         calendar.setTime(deleteFrom);\n         calendar.set(Calendar.HOUR_OF_DAY, 0);\n         calendar.set(Calendar.MINUTE, 0);\n         calendar.set(Calendar.SECOND, 0);\n         calendar.set(Calendar.MILLISECOND, 0);\n-        Date date = calendar.getTime();\n-        //Because of the way Oracle databases handle dates,\n-        //this string is converted to Uppercase.This does\n-        //not cause a problem with the other databases\n-        DotConnect dc = new DotConnect();\n+        final Date date = calendar.getTime();\n \n-        String countSQL = (\"select count(*) as count from contentlet\");\n+        DotConnect dc = new DotConnect();\n+        final String countSQL = \"select count(*) as count from contentlet\";\n         dc.setSQL(countSQL);\n         List<Map<String, String>> result = dc.loadResults();\n-        int before = Integer.parseInt(result.get(0).get(\"count\"));\n-\n-        String deleteContentletSQL = \"delete from contentlet where identifier<>'SYSTEM_HOST' and mod_date < ? \" +\n-        \"and not exists (select * from contentlet_version_info where working_inode=contentlet.inode or live_inode=contentlet.inode)\";\n-        dc.setSQL(deleteContentletSQL);\n-        dc.addParam(date);\n-        dc.loadResult();\n-\n-        String deleteOrphanInodes=\"delete from inode where type='contentlet' and idate < ? and inode not in (select inode from contentlet)\";\n-        dc.setSQL(deleteOrphanInodes);\n+        final int before = Integer.parseInt(result.get(0).get(\"count\"));\n+        dc = new DotConnect();\n+        dc.setSQL(\"SELECT inode FROM contentlet WHERE identifier <> 'SYSTEM_HOST' AND mod_date < ? AND NOT EXISTS \" +\n+                \"(SELECT working_inode, live_inode FROM contentlet_version_info WHERE working_inode = contentlet.inode OR \" +\n+                \"live_inode = contentlet.inode)\");", "originalCommit": "886a8bfa5eca55deffeaf98234a5c2e73d758f4e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUzNTk4Ng==", "url": "https://github.com/dotCMS/core/pull/18507#discussion_r427535986", "bodyText": "You can use a temp table instead and do a DELETE JOIN instead of having to use an IN.\nBasically insert results of the previous suggested query (INTERSECT) into a temp table, and join against that temp table for doing the two DELETEs", "author": "dsilvam", "createdAt": "2020-05-19T19:08:22Z", "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESContentFactoryImpl.java", "diffHunk": "@@ -678,65 +680,113 @@ private void deleteTreesForInodes(List<String> inodes) throws DotDataException {\n         }\n     }\n \n-\t@Override\n-\tprotected int deleteOldContent(Date deleteFrom) throws DotDataException {\n-\t    ContentletCache cc = CacheLocator.getContentletCache();\n-        Calendar calendar = Calendar.getInstance();\n+    /**\n+     * Deletes all the Contentlet versions that are older than the specified date.\n+     *\n+     * @param deleteFrom The date as of which all contents older than that will be deleted.\n+     *\n+     * @return The number of records deleted by this operation.\n+     *\n+     * @throws DotDataException An error occurred when interacting with the data source.\n+     */\n+    @Override\n+    protected int deleteOldContent(final Date deleteFrom) throws DotDataException {\n+        final Calendar calendar = Calendar.getInstance();\n         calendar.setTime(deleteFrom);\n         calendar.set(Calendar.HOUR_OF_DAY, 0);\n         calendar.set(Calendar.MINUTE, 0);\n         calendar.set(Calendar.SECOND, 0);\n         calendar.set(Calendar.MILLISECOND, 0);\n-        Date date = calendar.getTime();\n-        //Because of the way Oracle databases handle dates,\n-        //this string is converted to Uppercase.This does\n-        //not cause a problem with the other databases\n+        final Date date = calendar.getTime();\n         DotConnect dc = new DotConnect();\n-\n-        String countSQL = (\"select count(*) as count from contentlet\");\n+        final String countSQL = \"select count(*) as count from contentlet\";\n         dc.setSQL(countSQL);\n         List<Map<String, String>> result = dc.loadResults();\n-        int before = Integer.parseInt(result.get(0).get(\"count\"));\n-\n-        String deleteContentletSQL = \"delete from contentlet where identifier<>'SYSTEM_HOST' and mod_date < ? \" +\n-        \"and not exists (select * from contentlet_version_info where working_inode=contentlet.inode or live_inode=contentlet.inode)\";\n-        dc.setSQL(deleteContentletSQL);\n+        final int before = Integer.parseInt(result.get(0).get(\"count\"));\n+        dc = new DotConnect();\n+        dc.setSQL(\"SELECT inode FROM contentlet WHERE identifier <> 'SYSTEM_HOST' AND mod_date < ? AND NOT EXISTS \" +\n+                \"(SELECT working_inode, live_inode FROM contentlet_version_info WHERE working_inode = contentlet.inode OR \" +\n+                \"live_inode = contentlet.inode)\");\n         dc.addParam(date);\n-        dc.loadResult();\n-\n-        String deleteOrphanInodes=\"delete from inode where type='contentlet' and idate < ? and inode not in (select inode from contentlet)\";\n-        dc.setSQL(deleteOrphanInodes);\n-        dc.addParam(date);\n-        dc.loadResult();\n-\n+        result = dc.loadResults();\n+        int oldInodesCount = result.size();\n+        if (oldInodesCount > 0) {\n+            final List<String> inodeList = result.stream().map(row -> row.get(\"inode\")).collect(Collectors.toList());\n+            deleteContentData(inodeList);\n+        }\n+        dc = new DotConnect();\n         dc.setSQL(countSQL);\n         result = dc.loadResults();\n-        int after = Integer.parseInt(result.get(0).get(\"count\"));\n+        final int after = Integer.parseInt(result.get(0).get(\"count\"));\n+        final int deleted = before - after;\n+        if (deleted > 0) {\n+            deleteOrphanedBinaryFiles();\n+        }\n+        return deleted;\n+    }\n \n-        int deleted=before - after;\n+    /**\n+     * Deletes the content data associated to the specified list of Inodes. Based on such a list, the {@code contentlet}\n+     * will be cleaned up as well.\n+     *\n+     * @param inodeList The list of Inodes that will be deleted.\n+     *\n+     * @throws DotDataException An error occurred when interacting with the data source.\n+     */\n+    private void deleteContentData(final List<String> inodeList) throws DotDataException {\n+        final int splitAt = 100;\n+        // Split all records into lists of size 'truncateAt'\n+        final List<List<String>> inodesToDelete = Lists.partition(inodeList, splitAt);\n+        final List<String> queries = Lists.newArrayList(\"DELETE FROM contentlet WHERE inode IN (?)\",", "originalCommit": "baab02a866740a2b99cc3aecd5cca4e0f233779d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "07c48b26fd47d00d334b4dc5bbc1f3696c0a5e97", "url": "https://github.com/dotCMS/core/commit/07c48b26fd47d00d334b4dc5bbc1f3696c0a5e97", "message": "Merge branch 'master' of github.com:dotCMS/core into issue-18494-drop-old-assets-versions-tool-fails", "committedDate": "2020-06-02T17:24:52Z", "type": "commit"}, {"oid": "792ec2f8711576416f226230de26f6b3014dc3cc", "url": "https://github.com/dotCMS/core/commit/792ec2f8711576416f226230de26f6b3014dc3cc", "message": "Merge branch 'master' of github.com:dotCMS/core into issue-18494-drop-old-assets-versions-tool-fails", "committedDate": "2020-06-03T18:07:31Z", "type": "commit"}, {"oid": "22db7971ee7ed654c86eca59cf80a42bfc8fd630", "url": "https://github.com/dotCMS/core/commit/22db7971ee7ed654c86eca59cf80a42bfc8fd630", "message": "#18494 IT and feedback", "committedDate": "2020-06-04T00:02:59Z", "type": "commit"}, {"oid": "9ec8a0a27abd08522669d22b7f6dcac60dd8e707", "url": "https://github.com/dotCMS/core/commit/9ec8a0a27abd08522669d22b7f6dcac60dd8e707", "message": "#18494 missing add test to suite", "committedDate": "2020-06-04T15:12:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM0MTY0MQ==", "url": "https://github.com/dotCMS/core/pull/18507#discussion_r435341641", "bodyText": "Issue found: Avoid catching generic exceptions such as NullPointerException, RuntimeException, Exception in try-catch block", "author": "dev-dotcms", "createdAt": "2020-06-04T15:20:19Z", "path": "dotCMS/src/main/java/com/dotmarketing/portlets/cmsmaintenance/factories/CMSMaintenanceFactory.java", "diffHunk": "@@ -17,138 +18,176 @@\n import java.util.Map;\r\n \r\n /**\r\n- * This class is use to fix identifiers inconsistencies in db,\r\n- * solving the problem of identifiers without a working or live asset\r\n- * @author Oswaldo\r\n+ * This tool allows CMS users to delete entries of versionable dotCMS objects\r\n+ * that are older than a specified date. These versions can be accessed through\r\n+ * the <b>History</b> tab of such objects. The list of elements that are\r\n+ * versionable in the system are:\r\n+ * <ul>\r\n+ * <li>Contentlets - including HTML Pages as Content, Files as Content, Sites,\r\n+ * etc.</li>\r\n+ * <li>Containers.</li>\r\n+ * <li>Templates.</li>\r\n+ * <li>Links.</li>\r\n+ * <li>Workflow History.</li>\r\n+ * </ul>\r\n  *\r\n+ * @author root\r\n+ * @since Mar 22, 2012\r\n  */\r\n public class CMSMaintenanceFactory {\r\n \r\n-\tpublic static int deleteOldAssetVersions (Date assetsOlderThan) {\r\n-\t\tint counter = 0;\r\n-\t\tint auxCount = 0;\r\n-\r\n+    /**\r\n+     * Deletes dotCMS object versions that are older than the specified date. Such a\r\n+     * date is compared to the date in which a version of an object was created. The\r\n+     * list of objects may include:\r\n+     * <ul>\r\n+     * <li>Contentlets - including HTML Pages as Content, Files as Content, Sites,\r\n+     * etc.</li>\r\n+     * <li>Containers.</li>\r\n+     * <li>Templates.</li>\r\n+     * <li>Links.</li>\r\n+     * <li>Workflow History.</li>\r\n+     * </ul>\r\n+     *\r\n+     * @param assetsOlderThan\r\n+     *            The user-specified date up to which object versions will be\r\n+     *            deleted.\r\n+     * @return The total number of versions that were deleted.\r\n+     */\r\n+    public static int deleteOldAssetVersions(final Date assetsOlderThan) {\r\n+        Logger.info(CMSMaintenanceFactory.class, \"------------------------------------------------------------\");\r\n+        Logger.info(CMSMaintenanceFactory.class, \" Executing the Drop Old Assets Versions tool\");\r\n+        Calendar startDate = Calendar.getInstance();\r\n+        startDate.setTime(assetsOlderThan);\r\n+        startDate.add(Calendar.YEAR, -2);\r\n+        startDate.set(Calendar.HOUR_OF_DAY, 0);\r\n+        startDate.set(Calendar.MINUTE, 0);\r\n+        startDate.set(Calendar.SECOND, 0);\r\n+        startDate.set(Calendar.MILLISECOND, 0);\r\n+        final Calendar oldestInodeDate = getOldestInodeDate();\r\n+        startDate = null != oldestInodeDate ? oldestInodeDate : startDate;\r\n+        Logger.info(CMSMaintenanceFactory.class, String.format(\"- Deleting versions older than '%s'\",\r\n+                UtilMethods.dateToHTMLDate(assetsOlderThan, \"yyyy-MM-dd\")));\r\n+        Logger.info(CMSMaintenanceFactory.class, \" \");\r\n+        int totalRecords = 0;\r\n+        while (startDate.getTime().before(assetsOlderThan) || startDate.getTime().equals(assetsOlderThan)) {\r\n+            try {\r\n+                HibernateUtil.startTransaction();\r\n+                final int deletedRecords = removeOldVersions(startDate);\r\n+                // Run the drop tasks iteratively, moving forward in time\r\n+                // DROP_OLD_ASSET_ITERATE_BY_SECONDS controls how many seconds to move forward\r\n+                // in time for each iteration - default is to iterate by 30 days\r\n+                startDate.add(Calendar.SECOND,\r\n+                        Config.getIntProperty(\"DROP_OLD_ASSET_ITERATE_BY_SECONDS\", 60 * 60 * 24 * 30));\r\n+                // We should never go past the date the user entered\r\n+                if (startDate.getTime().after(assetsOlderThan)) {\r\n+                    break;\r\n+                }\r\n+                totalRecords += deletedRecords;\r\n+                HibernateUtil.commitTransaction();\r\n+            } catch (final Exception ex) {\r", "originalCommit": "9ec8a0a27abd08522669d22b7f6dcac60dd8e707", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM0MTY2MQ==", "url": "https://github.com/dotCMS/core/pull/18507#discussion_r435341661", "bodyText": "Issue found: Avoid variables with short names like dc", "author": "dev-dotcms", "createdAt": "2020-06-04T15:20:20Z", "path": "dotCMS/src/main/java/com/dotmarketing/portlets/cmsmaintenance/factories/CMSMaintenanceFactory.java", "diffHunk": "@@ -17,138 +18,176 @@\n import java.util.Map;\r\n \r\n /**\r\n- * This class is use to fix identifiers inconsistencies in db,\r\n- * solving the problem of identifiers without a working or live asset\r\n- * @author Oswaldo\r\n+ * This tool allows CMS users to delete entries of versionable dotCMS objects\r\n+ * that are older than a specified date. These versions can be accessed through\r\n+ * the <b>History</b> tab of such objects. The list of elements that are\r\n+ * versionable in the system are:\r\n+ * <ul>\r\n+ * <li>Contentlets - including HTML Pages as Content, Files as Content, Sites,\r\n+ * etc.</li>\r\n+ * <li>Containers.</li>\r\n+ * <li>Templates.</li>\r\n+ * <li>Links.</li>\r\n+ * <li>Workflow History.</li>\r\n+ * </ul>\r\n  *\r\n+ * @author root\r\n+ * @since Mar 22, 2012\r\n  */\r\n public class CMSMaintenanceFactory {\r\n \r\n-\tpublic static int deleteOldAssetVersions (Date assetsOlderThan) {\r\n-\t\tint counter = 0;\r\n-\t\tint auxCount = 0;\r\n-\r\n+    /**\r\n+     * Deletes dotCMS object versions that are older than the specified date. Such a\r\n+     * date is compared to the date in which a version of an object was created. The\r\n+     * list of objects may include:\r\n+     * <ul>\r\n+     * <li>Contentlets - including HTML Pages as Content, Files as Content, Sites,\r\n+     * etc.</li>\r\n+     * <li>Containers.</li>\r\n+     * <li>Templates.</li>\r\n+     * <li>Links.</li>\r\n+     * <li>Workflow History.</li>\r\n+     * </ul>\r\n+     *\r\n+     * @param assetsOlderThan\r\n+     *            The user-specified date up to which object versions will be\r\n+     *            deleted.\r\n+     * @return The total number of versions that were deleted.\r\n+     */\r\n+    public static int deleteOldAssetVersions(final Date assetsOlderThan) {\r\n+        Logger.info(CMSMaintenanceFactory.class, \"------------------------------------------------------------\");\r\n+        Logger.info(CMSMaintenanceFactory.class, \" Executing the Drop Old Assets Versions tool\");\r\n+        Calendar startDate = Calendar.getInstance();\r\n+        startDate.setTime(assetsOlderThan);\r\n+        startDate.add(Calendar.YEAR, -2);\r\n+        startDate.set(Calendar.HOUR_OF_DAY, 0);\r\n+        startDate.set(Calendar.MINUTE, 0);\r\n+        startDate.set(Calendar.SECOND, 0);\r\n+        startDate.set(Calendar.MILLISECOND, 0);\r\n+        final Calendar oldestInodeDate = getOldestInodeDate();\r\n+        startDate = null != oldestInodeDate ? oldestInodeDate : startDate;\r\n+        Logger.info(CMSMaintenanceFactory.class, String.format(\"- Deleting versions older than '%s'\",\r\n+                UtilMethods.dateToHTMLDate(assetsOlderThan, \"yyyy-MM-dd\")));\r\n+        Logger.info(CMSMaintenanceFactory.class, \" \");\r\n+        int totalRecords = 0;\r\n+        while (startDate.getTime().before(assetsOlderThan) || startDate.getTime().equals(assetsOlderThan)) {\r\n+            try {\r\n+                HibernateUtil.startTransaction();\r\n+                final int deletedRecords = removeOldVersions(startDate);\r\n+                // Run the drop tasks iteratively, moving forward in time\r\n+                // DROP_OLD_ASSET_ITERATE_BY_SECONDS controls how many seconds to move forward\r\n+                // in time for each iteration - default is to iterate by 30 days\r\n+                startDate.add(Calendar.SECOND,\r\n+                        Config.getIntProperty(\"DROP_OLD_ASSET_ITERATE_BY_SECONDS\", 60 * 60 * 24 * 30));\r\n+                // We should never go past the date the user entered\r\n+                if (startDate.getTime().after(assetsOlderThan)) {\r\n+                    break;\r\n+                }\r\n+                totalRecords += deletedRecords;\r\n+                HibernateUtil.commitTransaction();\r\n+            } catch (final Exception ex) {\r\n+                Logger.error(CMSMaintenanceFactory.class,\r\n+                        String.format(\"An error occurred when deleting old asset versions: %s\", ex.getMessage()), ex);\r\n+                try {\r\n+                    HibernateUtil.rollbackTransaction();\r\n+                } catch (final DotHibernateException e) {\r\n+                    Logger.error(CMSMaintenanceFactory.class,\r\n+                            String.format(\"An error occurred when rolling the transaction back: %s\", e.getMessage()),\r\n+                            e);\r\n+                }\r\n+                return -1;\r\n+            }\r\n+        }\r\n+        if (totalRecords > 0) {\r\n+            CacheLocator.getCacheAdministrator().flushAll();\r\n+        }\r\n+        Logger.info(CMSMaintenanceFactory.class, String.format(\r\n+                \" The Drop Old Assets Versions tool has run. A total of %d records were deleted!\", totalRecords));\r\n+        return totalRecords;\r\n+    }\r\n \r\n+    /**\r\n+     * Looks for the oldest last modified date of versionable objects in the system.\r\n+     * Such a date will allow the tool to start deleting from the oldest to the\r\n+     * newest version. If no date is found, the current date will be returned.\r\n+     *\r\n+     * @return The oldest modification date from a versionable object.\r\n+     */\r\n+    private static Calendar getOldestInodeDate() {\r\n+        Calendar startDate = null;\r\n+        final DotConnect dc = new DotConnect();\r", "originalCommit": "9ec8a0a27abd08522669d22b7f6dcac60dd8e707", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM0MTY3OA==", "url": "https://github.com/dotCMS/core/pull/18507#discussion_r435341678", "bodyText": "Issue found: A method/constructor should not explicitly throw java.lang.Exception", "author": "dev-dotcms", "createdAt": "2020-06-04T15:20:21Z", "path": "dotCMS/src/integration-test/java/com/dotmarketing/portlets/cmsmaintenance/factories/CMSMaintenanceFactoryTest.java", "diffHunk": "@@ -0,0 +1,77 @@\n+package com.dotmarketing.portlets.cmsmaintenance.factories;\n+\n+import com.dotcms.datagen.SiteDataGen;\n+import com.dotcms.datagen.TestDataUtils;\n+import com.dotcms.datagen.TestUserUtils;\n+import com.dotcms.util.IntegrationTestInitService;\n+import com.dotmarketing.beans.Host;\n+import com.dotmarketing.beans.Identifier;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.portlets.contentlet.business.ContentletAPI;\n+import com.dotmarketing.portlets.contentlet.model.Contentlet;\n+import com.dotmarketing.util.DateUtil;\n+import com.dotmarketing.util.UUIDGenerator;\n+import com.liferay.portal.model.User;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.List;\n+import org.junit.Assert;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+public class CMSMaintenanceFactoryTest {\n+\n+    private static User adminUser;\n+    private static ContentletAPI contentletAPI;\n+\n+    @BeforeClass\n+    public static void prepare() throws Exception {", "originalCommit": "9ec8a0a27abd08522669d22b7f6dcac60dd8e707", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}