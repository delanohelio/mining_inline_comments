{"pr_number": 19425, "pr_title": "Issue 19379 show cache sizes", "pr_createdAt": "2020-10-09T21:20:39Z", "pr_url": "https://github.com/dotCMS/core/pull/19425", "timeline": [{"oid": "f52c7f542a14fabedb99c602e64eb49812f5ec9d", "url": "https://github.com/dotCMS/core/commit/f52c7f542a14fabedb99c602e64eb49812f5ec9d", "message": "#19379 show rough region sizing", "committedDate": "2020-10-05T19:57:27Z", "type": "commit"}, {"oid": "56ee263250acbd5b3fc94d04dd0e67ed366f7120", "url": "https://github.com/dotCMS/core/commit/56ee263250acbd5b3fc94d04dd0e67ed366f7120", "message": "#19379 trying unsafe first, falling back to serializer", "committedDate": "2020-10-07T16:58:58Z", "type": "commit"}, {"oid": "77858513871178e766c1a2fd880e02d22b242153", "url": "https://github.com/dotCMS/core/commit/77858513871178e766c1a2fd880e02d22b242153", "message": "#19379 commented out", "committedDate": "2020-10-07T16:59:29Z", "type": "commit"}, {"oid": "7ed119a88ae7f2da422ece85d867636a37b78e3b", "url": "https://github.com/dotCMS/core/commit/7ed119a88ae7f2da422ece85d867636a37b78e3b", "message": "#19379 with small test", "committedDate": "2020-10-07T23:04:05Z", "type": "commit"}, {"oid": "0ed5e9e7a806807f00fd8d0756258b58695f5286", "url": "https://github.com/dotCMS/core/commit/0ed5e9e7a806807f00fd8d0756258b58695f5286", "message": "#19379 tests optional", "committedDate": "2020-10-07T23:06:47Z", "type": "commit"}, {"oid": "2676808a21f5642ebbef204e5ed51b31b4af1698", "url": "https://github.com/dotCMS/core/commit/2676808a21f5642ebbef204e5ed51b31b4af1698", "message": "#19379 tests optional", "committedDate": "2020-10-07T23:10:56Z", "type": "commit"}, {"oid": "7d366de5273b870297aa090034b22796bf87d6a2", "url": "https://github.com/dotCMS/core/commit/7d366de5273b870297aa090034b22796bf87d6a2", "message": "Merge remote-tracking branch 'origin/master' into issue-19379-show-cache-sizes", "committedDate": "2020-10-26T13:27:09Z", "type": "commit"}, {"oid": "22536eba00d5cb138f2335516af3ae87aa99f743", "url": "https://github.com/dotCMS/core/commit/22536eba00d5cb138f2335516af3ae87aa99f743", "message": "#19379 catching the error", "committedDate": "2020-10-26T14:04:28Z", "type": "commit"}, {"oid": "dd39bb67b49e1d58d531efbacea849b1c799416f", "url": "https://github.com/dotCMS/core/commit/dd39bb67b49e1d58d531efbacea849b1c799416f", "message": "#19379 minor cleanup", "committedDate": "2020-10-26T14:21:46Z", "type": "commit"}, {"oid": "4db5eca96565f1e816270dc4d0be802b80429ac3", "url": "https://github.com/dotCMS/core/commit/4db5eca96565f1e816270dc4d0be802b80429ac3", "message": "#19379 removing unneeded methods", "committedDate": "2020-10-26T16:12:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA5MDk2Mg==", "url": "https://github.com/dotCMS/core/pull/19425#discussion_r512090962", "bodyText": "Codacy found an issue: Avoid using implementation types like 'HashMap'; use the interface instead", "author": "dev-dotcms", "createdAt": "2020-10-26T16:21:27Z", "path": "dotCMS/src/main/java/com/dotmarketing/business/cache/provider/CacheSizingUtil.java", "diffHunk": "@@ -0,0 +1,276 @@\n+package com.dotmarketing.business.cache.provider;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.lang.reflect.Array;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Random;\n+import com.dotmarketing.util.Config;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.UtilMethods;\n+import com.github.benmanes.caffeine.base.UnsafeAccess;\n+\n+\n+public class CacheSizingUtil {\n+\n+\n+    final int standardSampleSize = Config.getIntProperty(\"CACHE_SIZER_SAMPLE_SIZE\", 20);\n+    \n+    final int maxRecusionDepth = 10;\n+    \n+    final boolean useCompressedOops = true;\n+    \n+    public String averageSizePretty(final Map<String, Object> cacheMap) {\n+\n+        return UtilMethods.prettyByteify(averageSize(cacheMap));\n+\n+    }\n+\n+    /**\n+     * Takes a map and pulls random values from it to calculate an average object size\n+     * \n+     * @param cacheMap\n+     * @return\n+     */\n+    public long averageSize(final Map<String, Object> cacheMap) {\n+\n+        if (cacheMap.size() == 0) {\n+            return 0;\n+        }\n+\n+        long totalSize = 0;\n+\n+        final int numberToSample = Math.min(cacheMap.size(), standardSampleSize);\n+\n+\n+        for (int i = 0; i < numberToSample; i++) {\n+            List<String> keysAsArray = new ArrayList<String>(cacheMap.keySet());\n+            Random r = new Random();\n+            Object object = cacheMap.get(keysAsArray.get(r.nextInt(keysAsArray.size())));\n+            if (object instanceof Optional && ((Optional) object).isPresent()) {\n+                object = ((Optional) object).get();\n+            }\n+            if (object instanceof Optional && !((Optional) object).isPresent()) {\n+                return 0;\n+            }\n+            totalSize += sizeOf(object);\n+        }\n+        return totalSize / numberToSample;\n+\n+    }\n+\n+    /**\n+     * Tries to use the Unsafe class to calculate an objects size. If this does not work, it will fall\n+     * back on the serialzied size (which less than accurate).\n+     * \n+     * @param cacheMap\n+     * @return\n+     */\n+    public long sizeOf(Object object) {\n+        long retainedSize = 0;\n+        try {\n+            retainedSize = retainedSize(object);\n+        } catch (Throwable t) {\n+            Logger.infoEvery(this.getClass(),\n+                            \"Unable to use the Unsafe.class to size cache objects, falling back to serialization:\"\n+                                            + t.getMessage(),\n+                            60000);\n+        }\n+\n+        return retainedSize > 0 ? retainedSize : sizeOfSerialized(object);\n+\n+    }\n+\n+\n+    final ByteArrayOutputStream byteOutputStream = new ByteArrayOutputStream();\n+\n+    /**\n+     * Serializes an object to attempt to find an object's size\n+     * \n+     * @param object\n+     * @return\n+     */\n+    long sizeOfSerialized(Object object) {\n+\n+        if (object == null) {\n+            return 0;\n+        }\n+\n+        if (!(object instanceof Serializable)) {\n+            Logger.warn(this.getClass(), object.getClass() + \" not serializable: \" + object);\n+            return -1;\n+        }\n+\n+        if (object instanceof String) {\n+            return ((String) object).length() * 8;\n+\n+        }\n+\n+        byteOutputStream.reset();\n+        try (ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteOutputStream)) {\n+            objectOutputStream.writeObject(object);\n+            objectOutputStream.close();\n+\n+            return byteOutputStream.toByteArray().length;\n+        } catch (Exception e) {\n+            Logger.warnAndDebug(this.getClass(), \"failed writing:\" + object.getClass() + \" : \" + e.getMessage(), e);\n+            return 0;\n+        }\n+\n+    }\n+\n+\n+\n+\n+    public int retainedSize(Object obj) {\n+        return retainedSize(obj, new HashMap<>(), 0);\n+    }\n+\n+\n+\n+\n+    @SuppressWarnings(\"restriction\")\n+    private int retainedSize(Object obj, HashMap<Object, Object> calculated, final int depth) {\n+        Object ref = null;\n+        try {\n+            if (obj == null)\n+                throw new NullPointerException();\n+            calculated.put(obj, obj);\n+            Class<?> cls = obj.getClass();\n+            if (cls.isArray()) {\n+                int arraysize = UnsafeAccess.UNSAFE.arrayBaseOffset(cls)\n+                                + UnsafeAccess.UNSAFE.arrayIndexScale(cls) * Array.getLength(obj);\n+                if (!cls.getComponentType().isPrimitive()) {\n+                    Object[] arr = (Object[]) obj;\n+                    for (Object comp : arr) {\n+                        if (comp != null && !isCalculated(calculated, comp) && depth < maxRecusionDepth) {\n+                            arraysize += retainedSize(comp, calculated, depth + 1);\n+                        }\n+                    }\n+                }\n+                return arraysize;\n+            } else {\n+                int objectsize = sizeof(cls);\n+                for (Field f : getAllNonStaticFields(obj.getClass())) {\n+                    Class<?> fcls = f.getType();\n+                    if (fcls.isPrimitive())\n+                        continue;\n+                    f.setAccessible(true);\n+                    ref = f.get(obj);\n+                    if (ref != null && !isCalculated(calculated, ref) && depth < maxRecusionDepth) {\n+                        calculated.put(ref, ref);\n+                        int referentSize = retainedSize(ref, calculated, depth + 1);\n+                        objectsize += referentSize;\n+                    }\n+                }\n+                return objectsize;\n+            }\n+        } catch (Throwable e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"restriction\")\n+    public int sizeof(Class<?> cls) {\n+\n+        if (cls == null) {\n+            throw new NullPointerException();\n+        }\n+\n+        if (cls.isArray()) {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        if (cls.isPrimitive()) {\n+            return primsize(cls);\n+        }\n+\n+        int lastOffset = Integer.MIN_VALUE;\n+        Class<?> lastClass = null;\n+\n+        for (Field f : getAllNonStaticFields(cls)) {\n+            if (Modifier.isStatic(f.getModifiers())) {\n+                continue;\n+            }\n+\n+            int offset = (int) UnsafeAccess.UNSAFE.objectFieldOffset(f);\n+            if (offset > lastOffset) {\n+                lastOffset = offset;\n+                lastClass = f.getClass();\n+            }\n+        }\n+        if (lastOffset > 0) {\n+            return modulo8(lastOffset + primsize(lastClass));\n+        }\n+\n+        return 16;\n+    }\n+\n+    private Field[] getAllNonStaticFields(Class<?> cls) {\n+        if (cls == null) {\n+            throw new NullPointerException();\n+        }\n+\n+        List<Field> fieldList = new ArrayList<Field>();\n+        while (cls != Object.class) {\n+            for (Field f : cls.getDeclaredFields()) {\n+                if (!Modifier.isStatic(f.getModifiers())) {\n+                    fieldList.add(f);\n+                }\n+            }\n+            cls = cls.getSuperclass();\n+        }\n+        Field[] fs = new Field[fieldList.size()];\n+        fieldList.toArray(fs);\n+        return fs;\n+    }\n+\n+    private boolean isCalculated(HashMap<Object, Object> calculated, Object test) {", "originalCommit": "4db5eca96565f1e816270dc4d0be802b80429ac3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA5MDk2OQ==", "url": "https://github.com/dotCMS/core/pull/19425#discussion_r512090969", "bodyText": "Codacy found an issue: Avoid catching generic exceptions such as NullPointerException, RuntimeException, Exception in try-catch block", "author": "dev-dotcms", "createdAt": "2020-10-26T16:21:28Z", "path": "dotCMS/src/main/java/com/dotmarketing/business/cache/provider/CacheSizingUtil.java", "diffHunk": "@@ -0,0 +1,276 @@\n+package com.dotmarketing.business.cache.provider;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.lang.reflect.Array;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Random;\n+import com.dotmarketing.util.Config;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.UtilMethods;\n+import com.github.benmanes.caffeine.base.UnsafeAccess;\n+\n+\n+public class CacheSizingUtil {\n+\n+\n+    final int standardSampleSize = Config.getIntProperty(\"CACHE_SIZER_SAMPLE_SIZE\", 20);\n+    \n+    final int maxRecusionDepth = 10;\n+    \n+    final boolean useCompressedOops = true;\n+    \n+    public String averageSizePretty(final Map<String, Object> cacheMap) {\n+\n+        return UtilMethods.prettyByteify(averageSize(cacheMap));\n+\n+    }\n+\n+    /**\n+     * Takes a map and pulls random values from it to calculate an average object size\n+     * \n+     * @param cacheMap\n+     * @return\n+     */\n+    public long averageSize(final Map<String, Object> cacheMap) {\n+\n+        if (cacheMap.size() == 0) {\n+            return 0;\n+        }\n+\n+        long totalSize = 0;\n+\n+        final int numberToSample = Math.min(cacheMap.size(), standardSampleSize);\n+\n+\n+        for (int i = 0; i < numberToSample; i++) {\n+            List<String> keysAsArray = new ArrayList<String>(cacheMap.keySet());\n+            Random r = new Random();\n+            Object object = cacheMap.get(keysAsArray.get(r.nextInt(keysAsArray.size())));\n+            if (object instanceof Optional && ((Optional) object).isPresent()) {\n+                object = ((Optional) object).get();\n+            }\n+            if (object instanceof Optional && !((Optional) object).isPresent()) {\n+                return 0;\n+            }\n+            totalSize += sizeOf(object);\n+        }\n+        return totalSize / numberToSample;\n+\n+    }\n+\n+    /**\n+     * Tries to use the Unsafe class to calculate an objects size. If this does not work, it will fall\n+     * back on the serialzied size (which less than accurate).\n+     * \n+     * @param cacheMap\n+     * @return\n+     */\n+    public long sizeOf(Object object) {\n+        long retainedSize = 0;\n+        try {\n+            retainedSize = retainedSize(object);\n+        } catch (Throwable t) {\n+            Logger.infoEvery(this.getClass(),\n+                            \"Unable to use the Unsafe.class to size cache objects, falling back to serialization:\"\n+                                            + t.getMessage(),\n+                            60000);\n+        }\n+\n+        return retainedSize > 0 ? retainedSize : sizeOfSerialized(object);\n+\n+    }\n+\n+\n+    final ByteArrayOutputStream byteOutputStream = new ByteArrayOutputStream();\n+\n+    /**\n+     * Serializes an object to attempt to find an object's size\n+     * \n+     * @param object\n+     * @return\n+     */\n+    long sizeOfSerialized(Object object) {\n+\n+        if (object == null) {\n+            return 0;\n+        }\n+\n+        if (!(object instanceof Serializable)) {\n+            Logger.warn(this.getClass(), object.getClass() + \" not serializable: \" + object);\n+            return -1;\n+        }\n+\n+        if (object instanceof String) {\n+            return ((String) object).length() * 8;\n+\n+        }\n+\n+        byteOutputStream.reset();\n+        try (ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteOutputStream)) {\n+            objectOutputStream.writeObject(object);\n+            objectOutputStream.close();\n+\n+            return byteOutputStream.toByteArray().length;\n+        } catch (Exception e) {", "originalCommit": "4db5eca96565f1e816270dc4d0be802b80429ac3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA5MDk3Ng==", "url": "https://github.com/dotCMS/core/pull/19425#discussion_r512090976", "bodyText": "Codacy found an issue: Useless parentheses.", "author": "dev-dotcms", "createdAt": "2020-10-26T16:21:29Z", "path": "dotCMS/src/main/java/com/dotmarketing/business/cache/provider/caffine/CaffineCache.java", "diffHunk": "@@ -170,19 +173,23 @@ public CacheProviderStats getStats() {\n \n         Set<String> currentGroups = new HashSet<>();\n         currentGroups.addAll(getGroups());\n-        Cache<String, Object> defaultCache = getCache(DEFAULT_CACHE);\n         NumberFormat nf = DecimalFormat.getInstance();\n         DecimalFormat pf = new DecimalFormat(\"##.##%\");\n+        \n+        CacheSizingUtil sizer = new CacheSizingUtil();\n+        \n+        \n+        \n         for (String group : currentGroups) {\n-            CacheStats stats = new CacheStats();\n+            final CacheStats stats = new CacheStats();\n \n-            Cache<String, Object> foundCache = getCache(group);\n+            final Cache<String, Object> foundCache = getCache(group);\n \n \n-            boolean isDefault = (Config.getIntProperty(\"cache.\" + group + \".size\", -1) == -1);\n+            final boolean isDefault = (Config.getIntProperty(\"cache.\" + group + \".size\", -1) == -1);", "originalCommit": "4db5eca96565f1e816270dc4d0be802b80429ac3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA5MDk4Nw==", "url": "https://github.com/dotCMS/core/pull/19425#discussion_r512090987", "bodyText": "Codacy found an issue: This final field could be made static", "author": "dev-dotcms", "createdAt": "2020-10-26T16:21:30Z", "path": "dotCMS/src/test/java/com/dotmarketing/business/cache/provider/CacheSizingUtilTest.java", "diffHunk": "@@ -0,0 +1,57 @@\n+package com.dotmarketing.business.cache.provider;\n+\n+import org.junit.Test;\n+import com.dotcms.repackage.com.google.common.base.Optional;\n+import com.dotmarketing.portlets.contentlet.business.Contentlet;\n+\n+public class CacheSizingUtilTest {\n+\n+    \n+    final String fourLetters = \"CRAP\";", "originalCommit": "4db5eca96565f1e816270dc4d0be802b80429ac3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA5MDk5Ng==", "url": "https://github.com/dotCMS/core/pull/19425#discussion_r512090996", "bodyText": "Codacy found an issue: Substitute calls to size() == 0 (or size() != 0, size() > 0, size() < 1) with calls to isEmpty()", "author": "dev-dotcms", "createdAt": "2020-10-26T16:21:31Z", "path": "dotCMS/src/main/java/com/dotmarketing/business/cache/provider/CacheSizingUtil.java", "diffHunk": "@@ -0,0 +1,276 @@\n+package com.dotmarketing.business.cache.provider;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.lang.reflect.Array;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Random;\n+import com.dotmarketing.util.Config;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.UtilMethods;\n+import com.github.benmanes.caffeine.base.UnsafeAccess;\n+\n+\n+public class CacheSizingUtil {\n+\n+\n+    final int standardSampleSize = Config.getIntProperty(\"CACHE_SIZER_SAMPLE_SIZE\", 20);\n+    \n+    final int maxRecusionDepth = 10;\n+    \n+    final boolean useCompressedOops = true;\n+    \n+    public String averageSizePretty(final Map<String, Object> cacheMap) {\n+\n+        return UtilMethods.prettyByteify(averageSize(cacheMap));\n+\n+    }\n+\n+    /**\n+     * Takes a map and pulls random values from it to calculate an average object size\n+     * \n+     * @param cacheMap\n+     * @return\n+     */\n+    public long averageSize(final Map<String, Object> cacheMap) {\n+\n+        if (cacheMap.size() == 0) {", "originalCommit": "4db5eca96565f1e816270dc4d0be802b80429ac3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA5MTAwNw==", "url": "https://github.com/dotCMS/core/pull/19425#discussion_r512091007", "bodyText": "Codacy found an issue: Avoid reassigning parameters such as 'cls'", "author": "dev-dotcms", "createdAt": "2020-10-26T16:21:32Z", "path": "dotCMS/src/main/java/com/dotmarketing/business/cache/provider/CacheSizingUtil.java", "diffHunk": "@@ -0,0 +1,276 @@\n+package com.dotmarketing.business.cache.provider;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.lang.reflect.Array;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Random;\n+import com.dotmarketing.util.Config;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.UtilMethods;\n+import com.github.benmanes.caffeine.base.UnsafeAccess;\n+\n+\n+public class CacheSizingUtil {\n+\n+\n+    final int standardSampleSize = Config.getIntProperty(\"CACHE_SIZER_SAMPLE_SIZE\", 20);\n+    \n+    final int maxRecusionDepth = 10;\n+    \n+    final boolean useCompressedOops = true;\n+    \n+    public String averageSizePretty(final Map<String, Object> cacheMap) {\n+\n+        return UtilMethods.prettyByteify(averageSize(cacheMap));\n+\n+    }\n+\n+    /**\n+     * Takes a map and pulls random values from it to calculate an average object size\n+     * \n+     * @param cacheMap\n+     * @return\n+     */\n+    public long averageSize(final Map<String, Object> cacheMap) {\n+\n+        if (cacheMap.size() == 0) {\n+            return 0;\n+        }\n+\n+        long totalSize = 0;\n+\n+        final int numberToSample = Math.min(cacheMap.size(), standardSampleSize);\n+\n+\n+        for (int i = 0; i < numberToSample; i++) {\n+            List<String> keysAsArray = new ArrayList<String>(cacheMap.keySet());\n+            Random r = new Random();\n+            Object object = cacheMap.get(keysAsArray.get(r.nextInt(keysAsArray.size())));\n+            if (object instanceof Optional && ((Optional) object).isPresent()) {\n+                object = ((Optional) object).get();\n+            }\n+            if (object instanceof Optional && !((Optional) object).isPresent()) {\n+                return 0;\n+            }\n+            totalSize += sizeOf(object);\n+        }\n+        return totalSize / numberToSample;\n+\n+    }\n+\n+    /**\n+     * Tries to use the Unsafe class to calculate an objects size. If this does not work, it will fall\n+     * back on the serialzied size (which less than accurate).\n+     * \n+     * @param cacheMap\n+     * @return\n+     */\n+    public long sizeOf(Object object) {\n+        long retainedSize = 0;\n+        try {\n+            retainedSize = retainedSize(object);\n+        } catch (Throwable t) {\n+            Logger.infoEvery(this.getClass(),\n+                            \"Unable to use the Unsafe.class to size cache objects, falling back to serialization:\"\n+                                            + t.getMessage(),\n+                            60000);\n+        }\n+\n+        return retainedSize > 0 ? retainedSize : sizeOfSerialized(object);\n+\n+    }\n+\n+\n+    final ByteArrayOutputStream byteOutputStream = new ByteArrayOutputStream();\n+\n+    /**\n+     * Serializes an object to attempt to find an object's size\n+     * \n+     * @param object\n+     * @return\n+     */\n+    long sizeOfSerialized(Object object) {\n+\n+        if (object == null) {\n+            return 0;\n+        }\n+\n+        if (!(object instanceof Serializable)) {\n+            Logger.warn(this.getClass(), object.getClass() + \" not serializable: \" + object);\n+            return -1;\n+        }\n+\n+        if (object instanceof String) {\n+            return ((String) object).length() * 8;\n+\n+        }\n+\n+        byteOutputStream.reset();\n+        try (ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteOutputStream)) {\n+            objectOutputStream.writeObject(object);\n+            objectOutputStream.close();\n+\n+            return byteOutputStream.toByteArray().length;\n+        } catch (Exception e) {\n+            Logger.warnAndDebug(this.getClass(), \"failed writing:\" + object.getClass() + \" : \" + e.getMessage(), e);\n+            return 0;\n+        }\n+\n+    }\n+\n+\n+\n+\n+    public int retainedSize(Object obj) {\n+        return retainedSize(obj, new HashMap<>(), 0);\n+    }\n+\n+\n+\n+\n+    @SuppressWarnings(\"restriction\")\n+    private int retainedSize(Object obj, HashMap<Object, Object> calculated, final int depth) {\n+        Object ref = null;\n+        try {\n+            if (obj == null)\n+                throw new NullPointerException();\n+            calculated.put(obj, obj);\n+            Class<?> cls = obj.getClass();\n+            if (cls.isArray()) {\n+                int arraysize = UnsafeAccess.UNSAFE.arrayBaseOffset(cls)\n+                                + UnsafeAccess.UNSAFE.arrayIndexScale(cls) * Array.getLength(obj);\n+                if (!cls.getComponentType().isPrimitive()) {\n+                    Object[] arr = (Object[]) obj;\n+                    for (Object comp : arr) {\n+                        if (comp != null && !isCalculated(calculated, comp) && depth < maxRecusionDepth) {\n+                            arraysize += retainedSize(comp, calculated, depth + 1);\n+                        }\n+                    }\n+                }\n+                return arraysize;\n+            } else {\n+                int objectsize = sizeof(cls);\n+                for (Field f : getAllNonStaticFields(obj.getClass())) {\n+                    Class<?> fcls = f.getType();\n+                    if (fcls.isPrimitive())\n+                        continue;\n+                    f.setAccessible(true);\n+                    ref = f.get(obj);\n+                    if (ref != null && !isCalculated(calculated, ref) && depth < maxRecusionDepth) {\n+                        calculated.put(ref, ref);\n+                        int referentSize = retainedSize(ref, calculated, depth + 1);\n+                        objectsize += referentSize;\n+                    }\n+                }\n+                return objectsize;\n+            }\n+        } catch (Throwable e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"restriction\")\n+    public int sizeof(Class<?> cls) {\n+\n+        if (cls == null) {\n+            throw new NullPointerException();\n+        }\n+\n+        if (cls.isArray()) {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        if (cls.isPrimitive()) {\n+            return primsize(cls);\n+        }\n+\n+        int lastOffset = Integer.MIN_VALUE;\n+        Class<?> lastClass = null;\n+\n+        for (Field f : getAllNonStaticFields(cls)) {\n+            if (Modifier.isStatic(f.getModifiers())) {\n+                continue;\n+            }\n+\n+            int offset = (int) UnsafeAccess.UNSAFE.objectFieldOffset(f);\n+            if (offset > lastOffset) {\n+                lastOffset = offset;\n+                lastClass = f.getClass();\n+            }\n+        }\n+        if (lastOffset > 0) {\n+            return modulo8(lastOffset + primsize(lastClass));\n+        }\n+\n+        return 16;\n+    }\n+\n+    private Field[] getAllNonStaticFields(Class<?> cls) {", "originalCommit": "4db5eca96565f1e816270dc4d0be802b80429ac3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA5MTAxMQ==", "url": "https://github.com/dotCMS/core/pull/19425#discussion_r512091011", "bodyText": "Codacy found an issue: Avoid variables with short names like fs", "author": "dev-dotcms", "createdAt": "2020-10-26T16:21:33Z", "path": "dotCMS/src/main/java/com/dotmarketing/business/cache/provider/CacheSizingUtil.java", "diffHunk": "@@ -0,0 +1,276 @@\n+package com.dotmarketing.business.cache.provider;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.lang.reflect.Array;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Random;\n+import com.dotmarketing.util.Config;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.UtilMethods;\n+import com.github.benmanes.caffeine.base.UnsafeAccess;\n+\n+\n+public class CacheSizingUtil {\n+\n+\n+    final int standardSampleSize = Config.getIntProperty(\"CACHE_SIZER_SAMPLE_SIZE\", 20);\n+    \n+    final int maxRecusionDepth = 10;\n+    \n+    final boolean useCompressedOops = true;\n+    \n+    public String averageSizePretty(final Map<String, Object> cacheMap) {\n+\n+        return UtilMethods.prettyByteify(averageSize(cacheMap));\n+\n+    }\n+\n+    /**\n+     * Takes a map and pulls random values from it to calculate an average object size\n+     * \n+     * @param cacheMap\n+     * @return\n+     */\n+    public long averageSize(final Map<String, Object> cacheMap) {\n+\n+        if (cacheMap.size() == 0) {\n+            return 0;\n+        }\n+\n+        long totalSize = 0;\n+\n+        final int numberToSample = Math.min(cacheMap.size(), standardSampleSize);\n+\n+\n+        for (int i = 0; i < numberToSample; i++) {\n+            List<String> keysAsArray = new ArrayList<String>(cacheMap.keySet());\n+            Random r = new Random();\n+            Object object = cacheMap.get(keysAsArray.get(r.nextInt(keysAsArray.size())));\n+            if (object instanceof Optional && ((Optional) object).isPresent()) {\n+                object = ((Optional) object).get();\n+            }\n+            if (object instanceof Optional && !((Optional) object).isPresent()) {\n+                return 0;\n+            }\n+            totalSize += sizeOf(object);\n+        }\n+        return totalSize / numberToSample;\n+\n+    }\n+\n+    /**\n+     * Tries to use the Unsafe class to calculate an objects size. If this does not work, it will fall\n+     * back on the serialzied size (which less than accurate).\n+     * \n+     * @param cacheMap\n+     * @return\n+     */\n+    public long sizeOf(Object object) {\n+        long retainedSize = 0;\n+        try {\n+            retainedSize = retainedSize(object);\n+        } catch (Throwable t) {\n+            Logger.infoEvery(this.getClass(),\n+                            \"Unable to use the Unsafe.class to size cache objects, falling back to serialization:\"\n+                                            + t.getMessage(),\n+                            60000);\n+        }\n+\n+        return retainedSize > 0 ? retainedSize : sizeOfSerialized(object);\n+\n+    }\n+\n+\n+    final ByteArrayOutputStream byteOutputStream = new ByteArrayOutputStream();\n+\n+    /**\n+     * Serializes an object to attempt to find an object's size\n+     * \n+     * @param object\n+     * @return\n+     */\n+    long sizeOfSerialized(Object object) {\n+\n+        if (object == null) {\n+            return 0;\n+        }\n+\n+        if (!(object instanceof Serializable)) {\n+            Logger.warn(this.getClass(), object.getClass() + \" not serializable: \" + object);\n+            return -1;\n+        }\n+\n+        if (object instanceof String) {\n+            return ((String) object).length() * 8;\n+\n+        }\n+\n+        byteOutputStream.reset();\n+        try (ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteOutputStream)) {\n+            objectOutputStream.writeObject(object);\n+            objectOutputStream.close();\n+\n+            return byteOutputStream.toByteArray().length;\n+        } catch (Exception e) {\n+            Logger.warnAndDebug(this.getClass(), \"failed writing:\" + object.getClass() + \" : \" + e.getMessage(), e);\n+            return 0;\n+        }\n+\n+    }\n+\n+\n+\n+\n+    public int retainedSize(Object obj) {\n+        return retainedSize(obj, new HashMap<>(), 0);\n+    }\n+\n+\n+\n+\n+    @SuppressWarnings(\"restriction\")\n+    private int retainedSize(Object obj, HashMap<Object, Object> calculated, final int depth) {\n+        Object ref = null;\n+        try {\n+            if (obj == null)\n+                throw new NullPointerException();\n+            calculated.put(obj, obj);\n+            Class<?> cls = obj.getClass();\n+            if (cls.isArray()) {\n+                int arraysize = UnsafeAccess.UNSAFE.arrayBaseOffset(cls)\n+                                + UnsafeAccess.UNSAFE.arrayIndexScale(cls) * Array.getLength(obj);\n+                if (!cls.getComponentType().isPrimitive()) {\n+                    Object[] arr = (Object[]) obj;\n+                    for (Object comp : arr) {\n+                        if (comp != null && !isCalculated(calculated, comp) && depth < maxRecusionDepth) {\n+                            arraysize += retainedSize(comp, calculated, depth + 1);\n+                        }\n+                    }\n+                }\n+                return arraysize;\n+            } else {\n+                int objectsize = sizeof(cls);\n+                for (Field f : getAllNonStaticFields(obj.getClass())) {\n+                    Class<?> fcls = f.getType();\n+                    if (fcls.isPrimitive())\n+                        continue;\n+                    f.setAccessible(true);\n+                    ref = f.get(obj);\n+                    if (ref != null && !isCalculated(calculated, ref) && depth < maxRecusionDepth) {\n+                        calculated.put(ref, ref);\n+                        int referentSize = retainedSize(ref, calculated, depth + 1);\n+                        objectsize += referentSize;\n+                    }\n+                }\n+                return objectsize;\n+            }\n+        } catch (Throwable e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"restriction\")\n+    public int sizeof(Class<?> cls) {\n+\n+        if (cls == null) {\n+            throw new NullPointerException();\n+        }\n+\n+        if (cls.isArray()) {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        if (cls.isPrimitive()) {\n+            return primsize(cls);\n+        }\n+\n+        int lastOffset = Integer.MIN_VALUE;\n+        Class<?> lastClass = null;\n+\n+        for (Field f : getAllNonStaticFields(cls)) {\n+            if (Modifier.isStatic(f.getModifiers())) {\n+                continue;\n+            }\n+\n+            int offset = (int) UnsafeAccess.UNSAFE.objectFieldOffset(f);\n+            if (offset > lastOffset) {\n+                lastOffset = offset;\n+                lastClass = f.getClass();\n+            }\n+        }\n+        if (lastOffset > 0) {\n+            return modulo8(lastOffset + primsize(lastClass));\n+        }\n+\n+        return 16;\n+    }\n+\n+    private Field[] getAllNonStaticFields(Class<?> cls) {\n+        if (cls == null) {\n+            throw new NullPointerException();\n+        }\n+\n+        List<Field> fieldList = new ArrayList<Field>();\n+        while (cls != Object.class) {\n+            for (Field f : cls.getDeclaredFields()) {\n+                if (!Modifier.isStatic(f.getModifiers())) {\n+                    fieldList.add(f);\n+                }\n+            }\n+            cls = cls.getSuperclass();\n+        }\n+        Field[] fs = new Field[fieldList.size()];", "originalCommit": "4db5eca96565f1e816270dc4d0be802b80429ac3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA5MTAyNA==", "url": "https://github.com/dotCMS/core/pull/19425#discussion_r512091024", "bodyText": "Codacy found an issue: JUnit tests should include assert() or fail()", "author": "dev-dotcms", "createdAt": "2020-10-26T16:21:34Z", "path": "dotCMS/src/test/java/com/dotmarketing/business/cache/provider/CacheSizingUtilTest.java", "diffHunk": "@@ -0,0 +1,57 @@\n+package com.dotmarketing.business.cache.provider;\n+\n+import org.junit.Test;\n+import com.dotcms.repackage.com.google.common.base.Optional;\n+import com.dotmarketing.portlets.contentlet.business.Contentlet;\n+\n+public class CacheSizingUtilTest {\n+\n+    \n+    final String fourLetters = \"CRAP\";\n+\n+    \n+    CacheSizingUtil cacheSizer = new CacheSizingUtil();\n+    \n+    @Test\n+    public void test_sizeof_works() {\n+       \n+        final Contentlet con = new Contentlet();\n+        \n+        long contentletSize = cacheSizer.sizeOf(con);\n+        assert(contentletSize>0);\n+        \n+        \n+\n+        \n+        long fourLettersSize = cacheSizer.sizeOf(fourLetters);\n+        assert(fourLettersSize==48);\n+        \n+        \n+    }\n+    \n+    @Test\n+    public void test_sizeof_null_works() {", "originalCommit": "4db5eca96565f1e816270dc4d0be802b80429ac3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA5MTAzOA==", "url": "https://github.com/dotCMS/core/pull/19425#discussion_r512091038", "bodyText": "Codacy found an issue: Classes implementing Serializable should set a serialVersionUID", "author": "dev-dotcms", "createdAt": "2020-10-26T16:21:35Z", "path": "dotCMS/src/main/java/com/dotmarketing/factories/PersonalizedContentlet.java", "diffHunk": "@@ -9,7 +10,7 @@\n  * @see com.google.common.collect.Table\n  * @author jsanca\n  */\n-public class PersonalizedContentlet {\n+public class PersonalizedContentlet implements Serializable{", "originalCommit": "4db5eca96565f1e816270dc4d0be802b80429ac3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA5MTA1MQ==", "url": "https://github.com/dotCMS/core/pull/19425#discussion_r512091051", "bodyText": "Codacy found an issue: A catch statement should never catch throwable since it includes errors.", "author": "dev-dotcms", "createdAt": "2020-10-26T16:21:36Z", "path": "dotCMS/src/main/java/com/dotmarketing/business/cache/provider/CacheSizingUtil.java", "diffHunk": "@@ -0,0 +1,276 @@\n+package com.dotmarketing.business.cache.provider;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.lang.reflect.Array;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Random;\n+import com.dotmarketing.util.Config;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.UtilMethods;\n+import com.github.benmanes.caffeine.base.UnsafeAccess;\n+\n+\n+public class CacheSizingUtil {\n+\n+\n+    final int standardSampleSize = Config.getIntProperty(\"CACHE_SIZER_SAMPLE_SIZE\", 20);\n+    \n+    final int maxRecusionDepth = 10;\n+    \n+    final boolean useCompressedOops = true;\n+    \n+    public String averageSizePretty(final Map<String, Object> cacheMap) {\n+\n+        return UtilMethods.prettyByteify(averageSize(cacheMap));\n+\n+    }\n+\n+    /**\n+     * Takes a map and pulls random values from it to calculate an average object size\n+     * \n+     * @param cacheMap\n+     * @return\n+     */\n+    public long averageSize(final Map<String, Object> cacheMap) {\n+\n+        if (cacheMap.size() == 0) {\n+            return 0;\n+        }\n+\n+        long totalSize = 0;\n+\n+        final int numberToSample = Math.min(cacheMap.size(), standardSampleSize);\n+\n+\n+        for (int i = 0; i < numberToSample; i++) {\n+            List<String> keysAsArray = new ArrayList<String>(cacheMap.keySet());\n+            Random r = new Random();\n+            Object object = cacheMap.get(keysAsArray.get(r.nextInt(keysAsArray.size())));\n+            if (object instanceof Optional && ((Optional) object).isPresent()) {\n+                object = ((Optional) object).get();\n+            }\n+            if (object instanceof Optional && !((Optional) object).isPresent()) {\n+                return 0;\n+            }\n+            totalSize += sizeOf(object);\n+        }\n+        return totalSize / numberToSample;\n+\n+    }\n+\n+    /**\n+     * Tries to use the Unsafe class to calculate an objects size. If this does not work, it will fall\n+     * back on the serialzied size (which less than accurate).\n+     * \n+     * @param cacheMap\n+     * @return\n+     */\n+    public long sizeOf(Object object) {\n+        long retainedSize = 0;\n+        try {\n+            retainedSize = retainedSize(object);\n+        } catch (Throwable t) {\n+            Logger.infoEvery(this.getClass(),\n+                            \"Unable to use the Unsafe.class to size cache objects, falling back to serialization:\"\n+                                            + t.getMessage(),\n+                            60000);\n+        }\n+\n+        return retainedSize > 0 ? retainedSize : sizeOfSerialized(object);\n+\n+    }\n+\n+\n+    final ByteArrayOutputStream byteOutputStream = new ByteArrayOutputStream();\n+\n+    /**\n+     * Serializes an object to attempt to find an object's size\n+     * \n+     * @param object\n+     * @return\n+     */\n+    long sizeOfSerialized(Object object) {\n+\n+        if (object == null) {\n+            return 0;\n+        }\n+\n+        if (!(object instanceof Serializable)) {\n+            Logger.warn(this.getClass(), object.getClass() + \" not serializable: \" + object);\n+            return -1;\n+        }\n+\n+        if (object instanceof String) {\n+            return ((String) object).length() * 8;\n+\n+        }\n+\n+        byteOutputStream.reset();\n+        try (ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteOutputStream)) {\n+            objectOutputStream.writeObject(object);\n+            objectOutputStream.close();\n+\n+            return byteOutputStream.toByteArray().length;\n+        } catch (Exception e) {\n+            Logger.warnAndDebug(this.getClass(), \"failed writing:\" + object.getClass() + \" : \" + e.getMessage(), e);\n+            return 0;\n+        }\n+\n+    }\n+\n+\n+\n+\n+    public int retainedSize(Object obj) {\n+        return retainedSize(obj, new HashMap<>(), 0);\n+    }\n+\n+\n+\n+\n+    @SuppressWarnings(\"restriction\")\n+    private int retainedSize(Object obj, HashMap<Object, Object> calculated, final int depth) {\n+        Object ref = null;\n+        try {\n+            if (obj == null)\n+                throw new NullPointerException();\n+            calculated.put(obj, obj);\n+            Class<?> cls = obj.getClass();\n+            if (cls.isArray()) {\n+                int arraysize = UnsafeAccess.UNSAFE.arrayBaseOffset(cls)\n+                                + UnsafeAccess.UNSAFE.arrayIndexScale(cls) * Array.getLength(obj);\n+                if (!cls.getComponentType().isPrimitive()) {\n+                    Object[] arr = (Object[]) obj;\n+                    for (Object comp : arr) {\n+                        if (comp != null && !isCalculated(calculated, comp) && depth < maxRecusionDepth) {\n+                            arraysize += retainedSize(comp, calculated, depth + 1);\n+                        }\n+                    }\n+                }\n+                return arraysize;\n+            } else {\n+                int objectsize = sizeof(cls);\n+                for (Field f : getAllNonStaticFields(obj.getClass())) {\n+                    Class<?> fcls = f.getType();\n+                    if (fcls.isPrimitive())\n+                        continue;\n+                    f.setAccessible(true);\n+                    ref = f.get(obj);\n+                    if (ref != null && !isCalculated(calculated, ref) && depth < maxRecusionDepth) {\n+                        calculated.put(ref, ref);\n+                        int referentSize = retainedSize(ref, calculated, depth + 1);\n+                        objectsize += referentSize;\n+                    }\n+                }\n+                return objectsize;\n+            }\n+        } catch (Throwable e) {", "originalCommit": "4db5eca96565f1e816270dc4d0be802b80429ac3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA5MTA2NA==", "url": "https://github.com/dotCMS/core/pull/19425#discussion_r512091064", "bodyText": "Codacy found an issue: Use equals() to compare object references.", "author": "dev-dotcms", "createdAt": "2020-10-26T16:21:37Z", "path": "dotCMS/src/main/java/com/dotmarketing/business/cache/provider/CacheSizingUtil.java", "diffHunk": "@@ -0,0 +1,276 @@\n+package com.dotmarketing.business.cache.provider;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.lang.reflect.Array;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Random;\n+import com.dotmarketing.util.Config;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.UtilMethods;\n+import com.github.benmanes.caffeine.base.UnsafeAccess;\n+\n+\n+public class CacheSizingUtil {\n+\n+\n+    final int standardSampleSize = Config.getIntProperty(\"CACHE_SIZER_SAMPLE_SIZE\", 20);\n+    \n+    final int maxRecusionDepth = 10;\n+    \n+    final boolean useCompressedOops = true;\n+    \n+    public String averageSizePretty(final Map<String, Object> cacheMap) {\n+\n+        return UtilMethods.prettyByteify(averageSize(cacheMap));\n+\n+    }\n+\n+    /**\n+     * Takes a map and pulls random values from it to calculate an average object size\n+     * \n+     * @param cacheMap\n+     * @return\n+     */\n+    public long averageSize(final Map<String, Object> cacheMap) {\n+\n+        if (cacheMap.size() == 0) {\n+            return 0;\n+        }\n+\n+        long totalSize = 0;\n+\n+        final int numberToSample = Math.min(cacheMap.size(), standardSampleSize);\n+\n+\n+        for (int i = 0; i < numberToSample; i++) {\n+            List<String> keysAsArray = new ArrayList<String>(cacheMap.keySet());\n+            Random r = new Random();\n+            Object object = cacheMap.get(keysAsArray.get(r.nextInt(keysAsArray.size())));\n+            if (object instanceof Optional && ((Optional) object).isPresent()) {\n+                object = ((Optional) object).get();\n+            }\n+            if (object instanceof Optional && !((Optional) object).isPresent()) {\n+                return 0;\n+            }\n+            totalSize += sizeOf(object);\n+        }\n+        return totalSize / numberToSample;\n+\n+    }\n+\n+    /**\n+     * Tries to use the Unsafe class to calculate an objects size. If this does not work, it will fall\n+     * back on the serialzied size (which less than accurate).\n+     * \n+     * @param cacheMap\n+     * @return\n+     */\n+    public long sizeOf(Object object) {\n+        long retainedSize = 0;\n+        try {\n+            retainedSize = retainedSize(object);\n+        } catch (Throwable t) {\n+            Logger.infoEvery(this.getClass(),\n+                            \"Unable to use the Unsafe.class to size cache objects, falling back to serialization:\"\n+                                            + t.getMessage(),\n+                            60000);\n+        }\n+\n+        return retainedSize > 0 ? retainedSize : sizeOfSerialized(object);\n+\n+    }\n+\n+\n+    final ByteArrayOutputStream byteOutputStream = new ByteArrayOutputStream();\n+\n+    /**\n+     * Serializes an object to attempt to find an object's size\n+     * \n+     * @param object\n+     * @return\n+     */\n+    long sizeOfSerialized(Object object) {\n+\n+        if (object == null) {\n+            return 0;\n+        }\n+\n+        if (!(object instanceof Serializable)) {\n+            Logger.warn(this.getClass(), object.getClass() + \" not serializable: \" + object);\n+            return -1;\n+        }\n+\n+        if (object instanceof String) {\n+            return ((String) object).length() * 8;\n+\n+        }\n+\n+        byteOutputStream.reset();\n+        try (ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteOutputStream)) {\n+            objectOutputStream.writeObject(object);\n+            objectOutputStream.close();\n+\n+            return byteOutputStream.toByteArray().length;\n+        } catch (Exception e) {\n+            Logger.warnAndDebug(this.getClass(), \"failed writing:\" + object.getClass() + \" : \" + e.getMessage(), e);\n+            return 0;\n+        }\n+\n+    }\n+\n+\n+\n+\n+    public int retainedSize(Object obj) {\n+        return retainedSize(obj, new HashMap<>(), 0);\n+    }\n+\n+\n+\n+\n+    @SuppressWarnings(\"restriction\")\n+    private int retainedSize(Object obj, HashMap<Object, Object> calculated, final int depth) {\n+        Object ref = null;\n+        try {\n+            if (obj == null)\n+                throw new NullPointerException();\n+            calculated.put(obj, obj);\n+            Class<?> cls = obj.getClass();\n+            if (cls.isArray()) {\n+                int arraysize = UnsafeAccess.UNSAFE.arrayBaseOffset(cls)\n+                                + UnsafeAccess.UNSAFE.arrayIndexScale(cls) * Array.getLength(obj);\n+                if (!cls.getComponentType().isPrimitive()) {\n+                    Object[] arr = (Object[]) obj;\n+                    for (Object comp : arr) {\n+                        if (comp != null && !isCalculated(calculated, comp) && depth < maxRecusionDepth) {\n+                            arraysize += retainedSize(comp, calculated, depth + 1);\n+                        }\n+                    }\n+                }\n+                return arraysize;\n+            } else {\n+                int objectsize = sizeof(cls);\n+                for (Field f : getAllNonStaticFields(obj.getClass())) {\n+                    Class<?> fcls = f.getType();\n+                    if (fcls.isPrimitive())\n+                        continue;\n+                    f.setAccessible(true);\n+                    ref = f.get(obj);\n+                    if (ref != null && !isCalculated(calculated, ref) && depth < maxRecusionDepth) {\n+                        calculated.put(ref, ref);\n+                        int referentSize = retainedSize(ref, calculated, depth + 1);\n+                        objectsize += referentSize;\n+                    }\n+                }\n+                return objectsize;\n+            }\n+        } catch (Throwable e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"restriction\")\n+    public int sizeof(Class<?> cls) {\n+\n+        if (cls == null) {\n+            throw new NullPointerException();\n+        }\n+\n+        if (cls.isArray()) {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        if (cls.isPrimitive()) {\n+            return primsize(cls);\n+        }\n+\n+        int lastOffset = Integer.MIN_VALUE;\n+        Class<?> lastClass = null;\n+\n+        for (Field f : getAllNonStaticFields(cls)) {\n+            if (Modifier.isStatic(f.getModifiers())) {\n+                continue;\n+            }\n+\n+            int offset = (int) UnsafeAccess.UNSAFE.objectFieldOffset(f);\n+            if (offset > lastOffset) {\n+                lastOffset = offset;\n+                lastClass = f.getClass();\n+            }\n+        }\n+        if (lastOffset > 0) {\n+            return modulo8(lastOffset + primsize(lastClass));\n+        }\n+\n+        return 16;\n+    }\n+\n+    private Field[] getAllNonStaticFields(Class<?> cls) {\n+        if (cls == null) {\n+            throw new NullPointerException();\n+        }\n+\n+        List<Field> fieldList = new ArrayList<Field>();\n+        while (cls != Object.class) {\n+            for (Field f : cls.getDeclaredFields()) {\n+                if (!Modifier.isStatic(f.getModifiers())) {\n+                    fieldList.add(f);\n+                }\n+            }\n+            cls = cls.getSuperclass();\n+        }\n+        Field[] fs = new Field[fieldList.size()];\n+        fieldList.toArray(fs);\n+        return fs;\n+    }\n+\n+    private boolean isCalculated(HashMap<Object, Object> calculated, Object test) {\n+        Object that = calculated.get(test);\n+        return that != null && that == test;", "originalCommit": "4db5eca96565f1e816270dc4d0be802b80429ac3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA5MTA3OQ==", "url": "https://github.com/dotCMS/core/pull/19425#discussion_r512091079", "bodyText": "Codacy found an issue: JUnit tests should include assert() or fail()", "author": "dev-dotcms", "createdAt": "2020-10-26T16:21:38Z", "path": "dotCMS/src/test/java/com/dotmarketing/business/cache/provider/CacheSizingUtilTest.java", "diffHunk": "@@ -0,0 +1,57 @@\n+package com.dotmarketing.business.cache.provider;\n+\n+import org.junit.Test;\n+import com.dotcms.repackage.com.google.common.base.Optional;\n+import com.dotmarketing.portlets.contentlet.business.Contentlet;\n+\n+public class CacheSizingUtilTest {\n+\n+    \n+    final String fourLetters = \"CRAP\";\n+\n+    \n+    CacheSizingUtil cacheSizer = new CacheSizingUtil();\n+    \n+    @Test\n+    public void test_sizeof_works() {\n+       \n+        final Contentlet con = new Contentlet();\n+        \n+        long contentletSize = cacheSizer.sizeOf(con);\n+        assert(contentletSize>0);\n+        \n+        \n+\n+        \n+        long fourLettersSize = cacheSizer.sizeOf(fourLetters);\n+        assert(fourLettersSize==48);\n+        \n+        \n+    }\n+    \n+    @Test\n+    public void test_sizeof_null_works() {\n+\n+        long cacheSize = cacheSizer.sizeOf(null);\n+        assert(cacheSize==0);\n+\n+        \n+    }\n+    \n+    \n+    @Test\n+    public void test_sizeof_optional_works() {", "originalCommit": "4db5eca96565f1e816270dc4d0be802b80429ac3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA5MTA4Nw==", "url": "https://github.com/dotCMS/core/pull/19425#discussion_r512091087", "bodyText": "Codacy found an issue: Avoid throwing null pointer exceptions.", "author": "dev-dotcms", "createdAt": "2020-10-26T16:21:39Z", "path": "dotCMS/src/main/java/com/dotmarketing/business/cache/provider/CacheSizingUtil.java", "diffHunk": "@@ -0,0 +1,276 @@\n+package com.dotmarketing.business.cache.provider;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.lang.reflect.Array;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Random;\n+import com.dotmarketing.util.Config;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.UtilMethods;\n+import com.github.benmanes.caffeine.base.UnsafeAccess;\n+\n+\n+public class CacheSizingUtil {\n+\n+\n+    final int standardSampleSize = Config.getIntProperty(\"CACHE_SIZER_SAMPLE_SIZE\", 20);\n+    \n+    final int maxRecusionDepth = 10;\n+    \n+    final boolean useCompressedOops = true;\n+    \n+    public String averageSizePretty(final Map<String, Object> cacheMap) {\n+\n+        return UtilMethods.prettyByteify(averageSize(cacheMap));\n+\n+    }\n+\n+    /**\n+     * Takes a map and pulls random values from it to calculate an average object size\n+     * \n+     * @param cacheMap\n+     * @return\n+     */\n+    public long averageSize(final Map<String, Object> cacheMap) {\n+\n+        if (cacheMap.size() == 0) {\n+            return 0;\n+        }\n+\n+        long totalSize = 0;\n+\n+        final int numberToSample = Math.min(cacheMap.size(), standardSampleSize);\n+\n+\n+        for (int i = 0; i < numberToSample; i++) {\n+            List<String> keysAsArray = new ArrayList<String>(cacheMap.keySet());\n+            Random r = new Random();\n+            Object object = cacheMap.get(keysAsArray.get(r.nextInt(keysAsArray.size())));\n+            if (object instanceof Optional && ((Optional) object).isPresent()) {\n+                object = ((Optional) object).get();\n+            }\n+            if (object instanceof Optional && !((Optional) object).isPresent()) {\n+                return 0;\n+            }\n+            totalSize += sizeOf(object);\n+        }\n+        return totalSize / numberToSample;\n+\n+    }\n+\n+    /**\n+     * Tries to use the Unsafe class to calculate an objects size. If this does not work, it will fall\n+     * back on the serialzied size (which less than accurate).\n+     * \n+     * @param cacheMap\n+     * @return\n+     */\n+    public long sizeOf(Object object) {\n+        long retainedSize = 0;\n+        try {\n+            retainedSize = retainedSize(object);\n+        } catch (Throwable t) {\n+            Logger.infoEvery(this.getClass(),\n+                            \"Unable to use the Unsafe.class to size cache objects, falling back to serialization:\"\n+                                            + t.getMessage(),\n+                            60000);\n+        }\n+\n+        return retainedSize > 0 ? retainedSize : sizeOfSerialized(object);\n+\n+    }\n+\n+\n+    final ByteArrayOutputStream byteOutputStream = new ByteArrayOutputStream();\n+\n+    /**\n+     * Serializes an object to attempt to find an object's size\n+     * \n+     * @param object\n+     * @return\n+     */\n+    long sizeOfSerialized(Object object) {\n+\n+        if (object == null) {\n+            return 0;\n+        }\n+\n+        if (!(object instanceof Serializable)) {\n+            Logger.warn(this.getClass(), object.getClass() + \" not serializable: \" + object);\n+            return -1;\n+        }\n+\n+        if (object instanceof String) {\n+            return ((String) object).length() * 8;\n+\n+        }\n+\n+        byteOutputStream.reset();\n+        try (ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteOutputStream)) {\n+            objectOutputStream.writeObject(object);\n+            objectOutputStream.close();\n+\n+            return byteOutputStream.toByteArray().length;\n+        } catch (Exception e) {\n+            Logger.warnAndDebug(this.getClass(), \"failed writing:\" + object.getClass() + \" : \" + e.getMessage(), e);\n+            return 0;\n+        }\n+\n+    }\n+\n+\n+\n+\n+    public int retainedSize(Object obj) {\n+        return retainedSize(obj, new HashMap<>(), 0);\n+    }\n+\n+\n+\n+\n+    @SuppressWarnings(\"restriction\")\n+    private int retainedSize(Object obj, HashMap<Object, Object> calculated, final int depth) {\n+        Object ref = null;\n+        try {\n+            if (obj == null)\n+                throw new NullPointerException();", "originalCommit": "4db5eca96565f1e816270dc4d0be802b80429ac3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA5MTA5Mw==", "url": "https://github.com/dotCMS/core/pull/19425#discussion_r512091093", "bodyText": "Codacy found an issue: This final field could be made static", "author": "dev-dotcms", "createdAt": "2020-10-26T16:21:40Z", "path": "dotCMS/src/main/java/com/dotmarketing/business/cache/provider/CacheSizingUtil.java", "diffHunk": "@@ -0,0 +1,276 @@\n+package com.dotmarketing.business.cache.provider;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.lang.reflect.Array;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Random;\n+import com.dotmarketing.util.Config;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.UtilMethods;\n+import com.github.benmanes.caffeine.base.UnsafeAccess;\n+\n+\n+public class CacheSizingUtil {\n+\n+\n+    final int standardSampleSize = Config.getIntProperty(\"CACHE_SIZER_SAMPLE_SIZE\", 20);\n+    \n+    final int maxRecusionDepth = 10;", "originalCommit": "4db5eca96565f1e816270dc4d0be802b80429ac3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA5MTEwNg==", "url": "https://github.com/dotCMS/core/pull/19425#discussion_r512091106", "bodyText": "Codacy found an issue: Classes implementing Serializable should set a serialVersionUID", "author": "dev-dotcms", "createdAt": "2020-10-26T16:21:40Z", "path": "dotCMS/src/main/java/com/dotmarketing/portlets/structure/business/FieldAPIImpl.java", "diffHunk": "@@ -24,7 +25,7 @@\n  *             interact with Content Type fields.\n  */\n @Deprecated\n-public class FieldAPIImpl implements FieldAPI {\n+public class FieldAPIImpl implements FieldAPI, Serializable {", "originalCommit": "4db5eca96565f1e816270dc4d0be802b80429ac3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA5MTExOQ==", "url": "https://github.com/dotCMS/core/pull/19425#discussion_r512091119", "bodyText": "Codacy found an issue: Useless parentheses.", "author": "dev-dotcms", "createdAt": "2020-10-26T16:21:41Z", "path": "dotCMS/src/test/java/com/dotmarketing/business/cache/provider/CacheSizingUtilTest.java", "diffHunk": "@@ -0,0 +1,57 @@\n+package com.dotmarketing.business.cache.provider;\n+\n+import org.junit.Test;\n+import com.dotcms.repackage.com.google.common.base.Optional;\n+import com.dotmarketing.portlets.contentlet.business.Contentlet;\n+\n+public class CacheSizingUtilTest {\n+\n+    \n+    final String fourLetters = \"CRAP\";\n+\n+    \n+    CacheSizingUtil cacheSizer = new CacheSizingUtil();\n+    \n+    @Test\n+    public void test_sizeof_works() {\n+       \n+        final Contentlet con = new Contentlet();\n+        \n+        long contentletSize = cacheSizer.sizeOf(con);\n+        assert(contentletSize>0);\n+        \n+        \n+\n+        \n+        long fourLettersSize = cacheSizer.sizeOf(fourLetters);\n+        assert(fourLettersSize==48);", "originalCommit": "4db5eca96565f1e816270dc4d0be802b80429ac3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA5MTEyOA==", "url": "https://github.com/dotCMS/core/pull/19425#discussion_r512091128", "bodyText": "Codacy found an issue: Useless parentheses.", "author": "dev-dotcms", "createdAt": "2020-10-26T16:21:42Z", "path": "dotCMS/src/test/java/com/dotmarketing/business/cache/provider/CacheSizingUtilTest.java", "diffHunk": "@@ -0,0 +1,57 @@\n+package com.dotmarketing.business.cache.provider;\n+\n+import org.junit.Test;\n+import com.dotcms.repackage.com.google.common.base.Optional;\n+import com.dotmarketing.portlets.contentlet.business.Contentlet;\n+\n+public class CacheSizingUtilTest {\n+\n+    \n+    final String fourLetters = \"CRAP\";\n+\n+    \n+    CacheSizingUtil cacheSizer = new CacheSizingUtil();\n+    \n+    @Test\n+    public void test_sizeof_works() {\n+       \n+        final Contentlet con = new Contentlet();\n+        \n+        long contentletSize = cacheSizer.sizeOf(con);\n+        assert(contentletSize>0);\n+        \n+        \n+\n+        \n+        long fourLettersSize = cacheSizer.sizeOf(fourLetters);\n+        assert(fourLettersSize==48);\n+        \n+        \n+    }\n+    \n+    @Test\n+    public void test_sizeof_null_works() {\n+\n+        long cacheSize = cacheSizer.sizeOf(null);\n+        assert(cacheSize==0);", "originalCommit": "4db5eca96565f1e816270dc4d0be802b80429ac3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA5MTE0NA==", "url": "https://github.com/dotCMS/core/pull/19425#discussion_r512091144", "bodyText": "Codacy found an issue: Avoid throwing raw exception types.", "author": "dev-dotcms", "createdAt": "2020-10-26T16:21:43Z", "path": "dotCMS/src/main/java/com/dotmarketing/business/cache/provider/CacheSizingUtil.java", "diffHunk": "@@ -0,0 +1,276 @@\n+package com.dotmarketing.business.cache.provider;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.lang.reflect.Array;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Random;\n+import com.dotmarketing.util.Config;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.UtilMethods;\n+import com.github.benmanes.caffeine.base.UnsafeAccess;\n+\n+\n+public class CacheSizingUtil {\n+\n+\n+    final int standardSampleSize = Config.getIntProperty(\"CACHE_SIZER_SAMPLE_SIZE\", 20);\n+    \n+    final int maxRecusionDepth = 10;\n+    \n+    final boolean useCompressedOops = true;\n+    \n+    public String averageSizePretty(final Map<String, Object> cacheMap) {\n+\n+        return UtilMethods.prettyByteify(averageSize(cacheMap));\n+\n+    }\n+\n+    /**\n+     * Takes a map and pulls random values from it to calculate an average object size\n+     * \n+     * @param cacheMap\n+     * @return\n+     */\n+    public long averageSize(final Map<String, Object> cacheMap) {\n+\n+        if (cacheMap.size() == 0) {\n+            return 0;\n+        }\n+\n+        long totalSize = 0;\n+\n+        final int numberToSample = Math.min(cacheMap.size(), standardSampleSize);\n+\n+\n+        for (int i = 0; i < numberToSample; i++) {\n+            List<String> keysAsArray = new ArrayList<String>(cacheMap.keySet());\n+            Random r = new Random();\n+            Object object = cacheMap.get(keysAsArray.get(r.nextInt(keysAsArray.size())));\n+            if (object instanceof Optional && ((Optional) object).isPresent()) {\n+                object = ((Optional) object).get();\n+            }\n+            if (object instanceof Optional && !((Optional) object).isPresent()) {\n+                return 0;\n+            }\n+            totalSize += sizeOf(object);\n+        }\n+        return totalSize / numberToSample;\n+\n+    }\n+\n+    /**\n+     * Tries to use the Unsafe class to calculate an objects size. If this does not work, it will fall\n+     * back on the serialzied size (which less than accurate).\n+     * \n+     * @param cacheMap\n+     * @return\n+     */\n+    public long sizeOf(Object object) {\n+        long retainedSize = 0;\n+        try {\n+            retainedSize = retainedSize(object);\n+        } catch (Throwable t) {\n+            Logger.infoEvery(this.getClass(),\n+                            \"Unable to use the Unsafe.class to size cache objects, falling back to serialization:\"\n+                                            + t.getMessage(),\n+                            60000);\n+        }\n+\n+        return retainedSize > 0 ? retainedSize : sizeOfSerialized(object);\n+\n+    }\n+\n+\n+    final ByteArrayOutputStream byteOutputStream = new ByteArrayOutputStream();\n+\n+    /**\n+     * Serializes an object to attempt to find an object's size\n+     * \n+     * @param object\n+     * @return\n+     */\n+    long sizeOfSerialized(Object object) {\n+\n+        if (object == null) {\n+            return 0;\n+        }\n+\n+        if (!(object instanceof Serializable)) {\n+            Logger.warn(this.getClass(), object.getClass() + \" not serializable: \" + object);\n+            return -1;\n+        }\n+\n+        if (object instanceof String) {\n+            return ((String) object).length() * 8;\n+\n+        }\n+\n+        byteOutputStream.reset();\n+        try (ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteOutputStream)) {\n+            objectOutputStream.writeObject(object);\n+            objectOutputStream.close();\n+\n+            return byteOutputStream.toByteArray().length;\n+        } catch (Exception e) {\n+            Logger.warnAndDebug(this.getClass(), \"failed writing:\" + object.getClass() + \" : \" + e.getMessage(), e);\n+            return 0;\n+        }\n+\n+    }\n+\n+\n+\n+\n+    public int retainedSize(Object obj) {\n+        return retainedSize(obj, new HashMap<>(), 0);\n+    }\n+\n+\n+\n+\n+    @SuppressWarnings(\"restriction\")\n+    private int retainedSize(Object obj, HashMap<Object, Object> calculated, final int depth) {\n+        Object ref = null;\n+        try {\n+            if (obj == null)\n+                throw new NullPointerException();\n+            calculated.put(obj, obj);\n+            Class<?> cls = obj.getClass();\n+            if (cls.isArray()) {\n+                int arraysize = UnsafeAccess.UNSAFE.arrayBaseOffset(cls)\n+                                + UnsafeAccess.UNSAFE.arrayIndexScale(cls) * Array.getLength(obj);\n+                if (!cls.getComponentType().isPrimitive()) {\n+                    Object[] arr = (Object[]) obj;\n+                    for (Object comp : arr) {\n+                        if (comp != null && !isCalculated(calculated, comp) && depth < maxRecusionDepth) {\n+                            arraysize += retainedSize(comp, calculated, depth + 1);\n+                        }\n+                    }\n+                }\n+                return arraysize;\n+            } else {\n+                int objectsize = sizeof(cls);\n+                for (Field f : getAllNonStaticFields(obj.getClass())) {\n+                    Class<?> fcls = f.getType();\n+                    if (fcls.isPrimitive())\n+                        continue;\n+                    f.setAccessible(true);\n+                    ref = f.get(obj);\n+                    if (ref != null && !isCalculated(calculated, ref) && depth < maxRecusionDepth) {\n+                        calculated.put(ref, ref);\n+                        int referentSize = retainedSize(ref, calculated, depth + 1);\n+                        objectsize += referentSize;\n+                    }\n+                }\n+                return objectsize;\n+            }\n+        } catch (Throwable e) {\n+            throw new RuntimeException(e);", "originalCommit": "4db5eca96565f1e816270dc4d0be802b80429ac3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA5MTE2MA==", "url": "https://github.com/dotCMS/core/pull/19425#discussion_r512091160", "bodyText": "Codacy found an issue: Useless parentheses.", "author": "dev-dotcms", "createdAt": "2020-10-26T16:21:44Z", "path": "dotCMS/src/test/java/com/dotmarketing/business/cache/provider/CacheSizingUtilTest.java", "diffHunk": "@@ -0,0 +1,57 @@\n+package com.dotmarketing.business.cache.provider;\n+\n+import org.junit.Test;\n+import com.dotcms.repackage.com.google.common.base.Optional;\n+import com.dotmarketing.portlets.contentlet.business.Contentlet;\n+\n+public class CacheSizingUtilTest {\n+\n+    \n+    final String fourLetters = \"CRAP\";\n+\n+    \n+    CacheSizingUtil cacheSizer = new CacheSizingUtil();\n+    \n+    @Test\n+    public void test_sizeof_works() {\n+       \n+        final Contentlet con = new Contentlet();\n+        \n+        long contentletSize = cacheSizer.sizeOf(con);\n+        assert(contentletSize>0);\n+        \n+        \n+\n+        \n+        long fourLettersSize = cacheSizer.sizeOf(fourLetters);\n+        assert(fourLettersSize==48);\n+        \n+        \n+    }\n+    \n+    @Test\n+    public void test_sizeof_null_works() {\n+\n+        long cacheSize = cacheSizer.sizeOf(null);\n+        assert(cacheSize==0);\n+\n+        \n+    }\n+    \n+    \n+    @Test\n+    public void test_sizeof_optional_works() {\n+\n+        \n+        \n+        \n+        long cacheSize = cacheSizer.sizeOf(Optional.fromNullable(null));\n+        assert(cacheSize==16);", "originalCommit": "4db5eca96565f1e816270dc4d0be802b80429ac3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA5MTE3MQ==", "url": "https://github.com/dotCMS/core/pull/19425#discussion_r512091171", "bodyText": "Codacy found an issue: Useless parentheses.", "author": "dev-dotcms", "createdAt": "2020-10-26T16:21:45Z", "path": "dotCMS/src/test/java/com/dotmarketing/business/cache/provider/CacheSizingUtilTest.java", "diffHunk": "@@ -0,0 +1,57 @@\n+package com.dotmarketing.business.cache.provider;\n+\n+import org.junit.Test;\n+import com.dotcms.repackage.com.google.common.base.Optional;\n+import com.dotmarketing.portlets.contentlet.business.Contentlet;\n+\n+public class CacheSizingUtilTest {\n+\n+    \n+    final String fourLetters = \"CRAP\";\n+\n+    \n+    CacheSizingUtil cacheSizer = new CacheSizingUtil();\n+    \n+    @Test\n+    public void test_sizeof_works() {\n+       \n+        final Contentlet con = new Contentlet();\n+        \n+        long contentletSize = cacheSizer.sizeOf(con);\n+        assert(contentletSize>0);", "originalCommit": "4db5eca96565f1e816270dc4d0be802b80429ac3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA5MTE3OQ==", "url": "https://github.com/dotCMS/core/pull/19425#discussion_r512091179", "bodyText": "Codacy found an issue: JUnit tests should include assert() or fail()", "author": "dev-dotcms", "createdAt": "2020-10-26T16:21:46Z", "path": "dotCMS/src/test/java/com/dotmarketing/business/cache/provider/CacheSizingUtilTest.java", "diffHunk": "@@ -0,0 +1,57 @@\n+package com.dotmarketing.business.cache.provider;\n+\n+import org.junit.Test;\n+import com.dotcms.repackage.com.google.common.base.Optional;\n+import com.dotmarketing.portlets.contentlet.business.Contentlet;\n+\n+public class CacheSizingUtilTest {\n+\n+    \n+    final String fourLetters = \"CRAP\";\n+\n+    \n+    CacheSizingUtil cacheSizer = new CacheSizingUtil();\n+    \n+    @Test\n+    public void test_sizeof_works() {", "originalCommit": "4db5eca96565f1e816270dc4d0be802b80429ac3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA5MTE5Mg==", "url": "https://github.com/dotCMS/core/pull/19425#discussion_r512091192", "bodyText": "Codacy found an issue: A catch statement should never catch throwable since it includes errors.", "author": "dev-dotcms", "createdAt": "2020-10-26T16:21:47Z", "path": "dotCMS/src/main/java/com/dotmarketing/business/cache/provider/CacheSizingUtil.java", "diffHunk": "@@ -0,0 +1,276 @@\n+package com.dotmarketing.business.cache.provider;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.lang.reflect.Array;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Random;\n+import com.dotmarketing.util.Config;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.UtilMethods;\n+import com.github.benmanes.caffeine.base.UnsafeAccess;\n+\n+\n+public class CacheSizingUtil {\n+\n+\n+    final int standardSampleSize = Config.getIntProperty(\"CACHE_SIZER_SAMPLE_SIZE\", 20);\n+    \n+    final int maxRecusionDepth = 10;\n+    \n+    final boolean useCompressedOops = true;\n+    \n+    public String averageSizePretty(final Map<String, Object> cacheMap) {\n+\n+        return UtilMethods.prettyByteify(averageSize(cacheMap));\n+\n+    }\n+\n+    /**\n+     * Takes a map and pulls random values from it to calculate an average object size\n+     * \n+     * @param cacheMap\n+     * @return\n+     */\n+    public long averageSize(final Map<String, Object> cacheMap) {\n+\n+        if (cacheMap.size() == 0) {\n+            return 0;\n+        }\n+\n+        long totalSize = 0;\n+\n+        final int numberToSample = Math.min(cacheMap.size(), standardSampleSize);\n+\n+\n+        for (int i = 0; i < numberToSample; i++) {\n+            List<String> keysAsArray = new ArrayList<String>(cacheMap.keySet());\n+            Random r = new Random();\n+            Object object = cacheMap.get(keysAsArray.get(r.nextInt(keysAsArray.size())));\n+            if (object instanceof Optional && ((Optional) object).isPresent()) {\n+                object = ((Optional) object).get();\n+            }\n+            if (object instanceof Optional && !((Optional) object).isPresent()) {\n+                return 0;\n+            }\n+            totalSize += sizeOf(object);\n+        }\n+        return totalSize / numberToSample;\n+\n+    }\n+\n+    /**\n+     * Tries to use the Unsafe class to calculate an objects size. If this does not work, it will fall\n+     * back on the serialzied size (which less than accurate).\n+     * \n+     * @param cacheMap\n+     * @return\n+     */\n+    public long sizeOf(Object object) {\n+        long retainedSize = 0;\n+        try {\n+            retainedSize = retainedSize(object);\n+        } catch (Throwable t) {", "originalCommit": "4db5eca96565f1e816270dc4d0be802b80429ac3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA5MTIwNQ==", "url": "https://github.com/dotCMS/core/pull/19425#discussion_r512091205", "bodyText": "Codacy found an issue: Useless parentheses.", "author": "dev-dotcms", "createdAt": "2020-10-26T16:21:48Z", "path": "dotCMS/src/test/java/com/dotmarketing/business/cache/provider/CacheSizingUtilTest.java", "diffHunk": "@@ -0,0 +1,57 @@\n+package com.dotmarketing.business.cache.provider;\n+\n+import org.junit.Test;\n+import com.dotcms.repackage.com.google.common.base.Optional;\n+import com.dotmarketing.portlets.contentlet.business.Contentlet;\n+\n+public class CacheSizingUtilTest {\n+\n+    \n+    final String fourLetters = \"CRAP\";\n+\n+    \n+    CacheSizingUtil cacheSizer = new CacheSizingUtil();\n+    \n+    @Test\n+    public void test_sizeof_works() {\n+       \n+        final Contentlet con = new Contentlet();\n+        \n+        long contentletSize = cacheSizer.sizeOf(con);\n+        assert(contentletSize>0);\n+        \n+        \n+\n+        \n+        long fourLettersSize = cacheSizer.sizeOf(fourLetters);\n+        assert(fourLettersSize==48);\n+        \n+        \n+    }\n+    \n+    @Test\n+    public void test_sizeof_null_works() {\n+\n+        long cacheSize = cacheSizer.sizeOf(null);\n+        assert(cacheSize==0);\n+\n+        \n+    }\n+    \n+    \n+    @Test\n+    public void test_sizeof_optional_works() {\n+\n+        \n+        \n+        \n+        long cacheSize = cacheSizer.sizeOf(Optional.fromNullable(null));\n+        assert(cacheSize==16);\n+        \n+        cacheSize = cacheSizer.sizeOf(Optional.of(fourLetters));\n+        assert(cacheSize==64);", "originalCommit": "4db5eca96565f1e816270dc4d0be802b80429ac3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA5MTIxMw==", "url": "https://github.com/dotCMS/core/pull/19425#discussion_r512091213", "bodyText": "Codacy found an issue: This statement should have braces", "author": "dev-dotcms", "createdAt": "2020-10-26T16:21:49Z", "path": "dotCMS/src/main/java/com/dotmarketing/business/cache/provider/CacheSizingUtil.java", "diffHunk": "@@ -0,0 +1,276 @@\n+package com.dotmarketing.business.cache.provider;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.lang.reflect.Array;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Random;\n+import com.dotmarketing.util.Config;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.UtilMethods;\n+import com.github.benmanes.caffeine.base.UnsafeAccess;\n+\n+\n+public class CacheSizingUtil {\n+\n+\n+    final int standardSampleSize = Config.getIntProperty(\"CACHE_SIZER_SAMPLE_SIZE\", 20);\n+    \n+    final int maxRecusionDepth = 10;\n+    \n+    final boolean useCompressedOops = true;\n+    \n+    public String averageSizePretty(final Map<String, Object> cacheMap) {\n+\n+        return UtilMethods.prettyByteify(averageSize(cacheMap));\n+\n+    }\n+\n+    /**\n+     * Takes a map and pulls random values from it to calculate an average object size\n+     * \n+     * @param cacheMap\n+     * @return\n+     */\n+    public long averageSize(final Map<String, Object> cacheMap) {\n+\n+        if (cacheMap.size() == 0) {\n+            return 0;\n+        }\n+\n+        long totalSize = 0;\n+\n+        final int numberToSample = Math.min(cacheMap.size(), standardSampleSize);\n+\n+\n+        for (int i = 0; i < numberToSample; i++) {\n+            List<String> keysAsArray = new ArrayList<String>(cacheMap.keySet());\n+            Random r = new Random();\n+            Object object = cacheMap.get(keysAsArray.get(r.nextInt(keysAsArray.size())));\n+            if (object instanceof Optional && ((Optional) object).isPresent()) {\n+                object = ((Optional) object).get();\n+            }\n+            if (object instanceof Optional && !((Optional) object).isPresent()) {\n+                return 0;\n+            }\n+            totalSize += sizeOf(object);\n+        }\n+        return totalSize / numberToSample;\n+\n+    }\n+\n+    /**\n+     * Tries to use the Unsafe class to calculate an objects size. If this does not work, it will fall\n+     * back on the serialzied size (which less than accurate).\n+     * \n+     * @param cacheMap\n+     * @return\n+     */\n+    public long sizeOf(Object object) {\n+        long retainedSize = 0;\n+        try {\n+            retainedSize = retainedSize(object);\n+        } catch (Throwable t) {\n+            Logger.infoEvery(this.getClass(),\n+                            \"Unable to use the Unsafe.class to size cache objects, falling back to serialization:\"\n+                                            + t.getMessage(),\n+                            60000);\n+        }\n+\n+        return retainedSize > 0 ? retainedSize : sizeOfSerialized(object);\n+\n+    }\n+\n+\n+    final ByteArrayOutputStream byteOutputStream = new ByteArrayOutputStream();\n+\n+    /**\n+     * Serializes an object to attempt to find an object's size\n+     * \n+     * @param object\n+     * @return\n+     */\n+    long sizeOfSerialized(Object object) {\n+\n+        if (object == null) {\n+            return 0;\n+        }\n+\n+        if (!(object instanceof Serializable)) {\n+            Logger.warn(this.getClass(), object.getClass() + \" not serializable: \" + object);\n+            return -1;\n+        }\n+\n+        if (object instanceof String) {\n+            return ((String) object).length() * 8;\n+\n+        }\n+\n+        byteOutputStream.reset();\n+        try (ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteOutputStream)) {\n+            objectOutputStream.writeObject(object);\n+            objectOutputStream.close();\n+\n+            return byteOutputStream.toByteArray().length;\n+        } catch (Exception e) {\n+            Logger.warnAndDebug(this.getClass(), \"failed writing:\" + object.getClass() + \" : \" + e.getMessage(), e);\n+            return 0;\n+        }\n+\n+    }\n+\n+\n+\n+\n+    public int retainedSize(Object obj) {\n+        return retainedSize(obj, new HashMap<>(), 0);\n+    }\n+\n+\n+\n+\n+    @SuppressWarnings(\"restriction\")\n+    private int retainedSize(Object obj, HashMap<Object, Object> calculated, final int depth) {\n+        Object ref = null;\n+        try {\n+            if (obj == null)\n+                throw new NullPointerException();", "originalCommit": "4db5eca96565f1e816270dc4d0be802b80429ac3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA5MTIzMw==", "url": "https://github.com/dotCMS/core/pull/19425#discussion_r512091233", "bodyText": "Codacy found an issue: This final field could be made static", "author": "dev-dotcms", "createdAt": "2020-10-26T16:21:50Z", "path": "dotCMS/src/main/java/com/dotmarketing/business/cache/provider/CacheSizingUtil.java", "diffHunk": "@@ -0,0 +1,276 @@\n+package com.dotmarketing.business.cache.provider;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.lang.reflect.Array;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Random;\n+import com.dotmarketing.util.Config;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.UtilMethods;\n+import com.github.benmanes.caffeine.base.UnsafeAccess;\n+\n+\n+public class CacheSizingUtil {\n+\n+\n+    final int standardSampleSize = Config.getIntProperty(\"CACHE_SIZER_SAMPLE_SIZE\", 20);\n+    \n+    final int maxRecusionDepth = 10;\n+    \n+    final boolean useCompressedOops = true;", "originalCommit": "4db5eca96565f1e816270dc4d0be802b80429ac3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}