{"pr_number": 19384, "pr_title": "Issue 18236 secrets exporter", "pr_createdAt": "2020-10-05T17:41:39Z", "pr_url": "https://github.com/dotCMS/core/pull/19384", "timeline": [{"oid": "4ab0c716ea94fd31a5e580042079488cb3e3f5b3", "url": "https://github.com/dotCMS/core/commit/4ab0c716ea94fd31a5e580042079488cb3e3f5b3", "message": "Update dotcmsReleaseVersion and coreWebReleasion version", "committedDate": "2020-09-22T17:58:49Z", "type": "commit"}, {"oid": "093c19127405bdc927bc05834a66c27ee213deaf", "url": "https://github.com/dotCMS/core/commit/093c19127405bdc927bc05834a66c27ee213deaf", "message": "update release version", "committedDate": "2020-09-22T19:06:37Z", "type": "commit"}, {"oid": "b65bf9585030ead35ac59992bfcb2622476ba916", "url": "https://github.com/dotCMS/core/commit/b65bf9585030ead35ac59992bfcb2622476ba916", "message": "update release version", "committedDate": "2020-09-22T19:13:45Z", "type": "commit"}, {"oid": "698ec87cdde251ca0fe1cebd571219487fd6b350", "url": "https://github.com/dotCMS/core/commit/698ec87cdde251ca0fe1cebd571219487fd6b350", "message": "update release version", "committedDate": "2020-09-22T19:13:59Z", "type": "commit"}, {"oid": "043e273b8391d4b1929896ab176205d8338ecfaf", "url": "https://github.com/dotCMS/core/commit/043e273b8391d4b1929896ab176205d8338ecfaf", "message": "dotCMS/core#18990 Key/Value field back as string in the page API", "committedDate": "2020-09-22T22:53:40Z", "type": "commit"}, {"oid": "0d9fab8f0285d667d5822b918bcc4a818792b501", "url": "https://github.com/dotCMS/core/commit/0d9fab8f0285d667d5822b918bcc4a818792b501", "message": "dotCMS/core#19267 Limited User can not edit Categories", "committedDate": "2020-09-23T16:03:48Z", "type": "commit"}, {"oid": "2691ee86dde23e2a4fbe4e8f07a71c53756e7b74", "url": "https://github.com/dotCMS/core/commit/2691ee86dde23e2a4fbe4e8f07a71c53756e7b74", "message": "dotCMS/core#19304 Edit Mode: Adding Content on Page missing pagination", "committedDate": "2020-09-24T15:11:51Z", "type": "commit"}, {"oid": "861d122b71316f953d48a7d390577b3756a98611", "url": "https://github.com/dotCMS/core/commit/861d122b71316f953d48a7d390577b3756a98611", "message": "dotCMS/core#19181 UPLOAD NEW FILE button does not work in Image/File fields (#19324)", "committedDate": "2020-09-24T16:54:17Z", "type": "commit"}, {"oid": "f20c423a3f3b18ad594da1aa092b8f298497c60d", "url": "https://github.com/dotCMS/core/commit/f20c423a3f3b18ad594da1aa092b8f298497c60d", "message": "dotCMS/core#19300 Starter export for personalized pages exports them all", "committedDate": "2020-09-24T20:29:59Z", "type": "commit"}, {"oid": "8430ea47fac7c0e9b444dee4b63663b5c847969b", "url": "https://github.com/dotCMS/core/commit/8430ea47fac7c0e9b444dee4b63663b5c847969b", "message": "dotCMS/core#19310 Handle Runtime Exception on Jersey", "committedDate": "2020-09-24T20:30:36Z", "type": "commit"}, {"oid": "c94caeae40776d5f331e82f0dbc5f307879955ad", "url": "https://github.com/dotCMS/core/commit/c94caeae40776d5f331e82f0dbc5f307879955ad", "message": "Fixing oracle test (#19336)", "committedDate": "2020-09-25T15:53:05Z", "type": "commit"}, {"oid": "8ea0dcb2878d81862ab3bdd084d0a20a65496064", "url": "https://github.com/dotCMS/core/commit/8ea0dcb2878d81862ab3bdd084d0a20a65496064", "message": "dotCMS/core#8538 | 19267 Limited User cannot add (edit) categories\n\n* #8538 #19267 set parents when editing\r\n\r\n* #8538 #19267 fix permissions when add/edit category\r\n\r\n* #8538 #19267 doc\r\n\r\n* #8538 #19267 tests\r\n\r\n* #8538 #19267 feedback", "committedDate": "2020-09-25T17:03:40Z", "type": "commit"}, {"oid": "1ffeb09dc5508d0d546aef4704a21462faa1cd10", "url": "https://github.com/dotCMS/core/commit/1ffeb09dc5508d0d546aef4704a21462faa1cd10", "message": "#19289 new starter (#19340)", "committedDate": "2020-09-28T15:45:13Z", "type": "commit"}, {"oid": "d033b557e859fb0e310423ebbca5dc58d42d98a5", "url": "https://github.com/dotCMS/core/commit/d033b557e859fb0e310423ebbca5dc58d42d98a5", "message": "#18236  save point", "committedDate": "2020-09-29T01:28:33Z", "type": "commit"}, {"oid": "0e5aaf72c2d1d0d03f1eadbba9edf294eca3cc85", "url": "https://github.com/dotCMS/core/commit/0e5aaf72c2d1d0d03f1eadbba9edf294eca3cc85", "message": "#19314 upgrade task to alter table job detail tables on mysql to use \u2026 (#19325)\n\n* #19314 upgrade task to alter table job detail tables on mysql to use wider job_data col\r\n\r\n* #19314 changes job_data fields from  blob  to longblob for mySQL", "committedDate": "2020-09-29T14:52:37Z", "type": "commit"}, {"oid": "30108b22be54911a614461722982b10713a84ea9", "url": "https://github.com/dotCMS/core/commit/30108b22be54911a614461722982b10713a84ea9", "message": "#18236 import  start task", "committedDate": "2020-09-29T14:52:37Z", "type": "commit"}, {"oid": "5d968ef829ac9259bb4a9335e002a1edea9cbba1", "url": "https://github.com/dotCMS/core/commit/5d968ef829ac9259bb4a9335e002a1edea9cbba1", "message": "#19302 restore secret key store on password changed  prevents exception from breaking apps (#19328)", "committedDate": "2020-09-29T15:07:10Z", "type": "commit"}, {"oid": "f99c727c9b12652b13816b19ae832c62d017c28c", "url": "https://github.com/dotCMS/core/commit/f99c727c9b12652b13816b19ae832c62d017c28c", "message": "#19278 fixing a graphql unit test (#19330)\n\n* #19278 fixing a graphql unit test\r\n\r\n* #19278 making some validations to avoid NPE and other errors", "committedDate": "2020-09-29T15:42:11Z", "type": "commit"}, {"oid": "e4783eec3118759ca6d7e37af3837c39001d1ca4", "url": "https://github.com/dotCMS/core/commit/e4783eec3118759ca6d7e37af3837c39001d1ca4", "message": "#18236  apps export feedback", "committedDate": "2020-10-01T19:19:48Z", "type": "commit"}, {"oid": "f733957d672af3bcc0bb1480d408d9db4364c854", "url": "https://github.com/dotCMS/core/commit/f733957d672af3bcc0bb1480d408d9db4364c854", "message": "#18236 bug fixing", "committedDate": "2020-10-05T16:15:45Z", "type": "commit"}, {"oid": "e0236a391b6ee261c72c40625560021c7845d62f", "url": "https://github.com/dotCMS/core/commit/e0236a391b6ee261c72c40625560021c7845d62f", "message": "#18236 app-import/export default password", "committedDate": "2020-10-05T16:19:23Z", "type": "commit"}, {"oid": "f0ad33de16bfa06cd4bc618dc479658b9d2de5e0", "url": "https://github.com/dotCMS/core/commit/f0ad33de16bfa06cd4bc618dc479658b9d2de5e0", "message": "#18236 fixes to compliy with requirements", "committedDate": "2020-10-05T17:38:51Z", "type": "commit"}, {"oid": "ca25d6642c9f1bfe295cd028569ef300be1a536a", "url": "https://github.com/dotCMS/core/commit/ca25d6642c9f1bfe295cd028569ef300be1a536a", "message": "#18236 fixes test", "committedDate": "2020-10-05T19:43:11Z", "type": "commit"}, {"oid": "054a1f58927fb353141eb66a26d8ae18b03ecc92", "url": "https://github.com/dotCMS/core/commit/054a1f58927fb353141eb66a26d8ae18b03ecc92", "message": "#18236 code improvements", "committedDate": "2020-10-05T20:46:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQwNzYwOQ==", "url": "https://github.com/dotCMS/core/pull/19384#discussion_r500407609", "bodyText": "We should not use API in the Upgrade Task, because cache and API can change between versions.", "author": "erickgonzalez", "createdAt": "2020-10-06T15:48:20Z", "path": "dotCMS/src/main/java/com/dotmarketing/startup/runonce/Task05400LoadAppsSecrets.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package com.dotmarketing.startup.runonce;\n+\n+import com.dotcms.security.apps.AppSecrets;\n+import com.dotcms.security.apps.AppsAPI;\n+import com.dotcms.security.apps.AppsAPIImpl;\n+import com.dotcms.security.apps.AppsUtil;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.startup.StartupTask;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.liferay.portal.model.User;\n+import io.vavr.control.Try;\n+import java.io.File;\n+import java.nio.file.DirectoryStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.security.Key;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+public class Task05400LoadAppsSecrets implements StartupTask {\n+\n+    private static final Pattern importFilePattern = Pattern.compile(\"^dotSecrets-import\\\\.([a-zA-Z0-9-_]+)\", Pattern.CASE_INSENSITIVE);\n+\n+    static boolean matchesFileName(final String input) {\n+        final Matcher matcher = importFilePattern.matcher(input);\n+        return matcher.find();\n+    }\n+\n+    final AppsAPI appsAPI = APILocator.getAppsAPI();", "originalCommit": "054a1f58927fb353141eb66a26d8ae18b03ecc92", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQzMDY5Mw==", "url": "https://github.com/dotCMS/core/pull/19384#discussion_r500430693", "bodyText": "I don't think we have another option here. This API writes directly into a file. it doesn't do any db hits or anything else. I removed all that so it could be used from here safely.", "author": "fabrizzio-dotCMS", "createdAt": "2020-10-06T16:21:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQwNzYwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQzNTM4Mw==", "url": "https://github.com/dotCMS/core/pull/19384#discussion_r500435383", "bodyText": "agree", "author": "jdotcms", "createdAt": "2020-10-06T16:28:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQwNzYwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTk5NTY4Mg==", "url": "https://github.com/dotCMS/core/pull/19384#discussion_r501995682", "bodyText": "I refactored my code so it could do the import without having to use the APi  @erickgonzalez", "author": "fabrizzio-dotCMS", "createdAt": "2020-10-08T20:33:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQwNzYwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQxMDM1NQ==", "url": "https://github.com/dotCMS/core/pull/19384#discussion_r500410355", "bodyText": "maybe it should go into a private method", "author": "freddyucv", "createdAt": "2020-10-06T15:52:05Z", "path": "dotCMS/src/main/java/com/dotcms/rest/api/v1/apps/AppsHelper.java", "diffHunk": "@@ -671,9 +618,16 @@ private void validateFormForDelete(final Set<String> inputParamNames, final AppD\n             throw new DotDataException(\"Unable to extract any files from multi-part request.\");\n         }\n         final List<AppView> appViews = new ArrayList<>(files.size());\n-        for (final File file : files) {\n-            final AppDescriptor appDescriptor = appsAPI.createAppDescriptor(file, user);\n-            appViews.add(new AppView(appDescriptor, 0, 0));\n+        try {\n+            for (final File file : files) {\n+                if(0 == file.length()){\n+                    throw new IllegalArgumentException(\"Zero length file.\");\n+                }\n+                final AppDescriptor appDescriptor = appsAPI.createAppDescriptor(file, user);\n+                appViews.add(new AppView(appDescriptor, 0, 0));\n+            }\n+        }finally {\n+            removeTempFolder(files.get(0).getParentFile());", "originalCommit": "054a1f58927fb353141eb66a26d8ae18b03ecc92", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQxMjE2OQ==", "url": "https://github.com/dotCMS/core/pull/19384#discussion_r500412169", "bodyText": "this code look same than before one so, a util method would help to not repeat the code", "author": "freddyucv", "createdAt": "2020-10-06T15:54:38Z", "path": "dotCMS/src/main/java/com/dotcms/rest/api/v1/apps/AppsHelper.java", "diffHunk": "@@ -739,38 +688,50 @@ InputStream exportSecrets(final ExportSecretForm form, final User user)\n      * @throws JSONException\n      * @throws DotSecurityException\n      * @throws EncryptorException\n-     * @throws ClassNotFoundException\n      */\n     void importSecrets(final FormDataMultiPart multipart, final User user)\n-            throws IOException, DotDataException, JSONException, DotSecurityException, EncryptorException, ClassNotFoundException {\n+            throws IOException, DotDataException, JSONException, DotSecurityException, EncryptorException {\n         final MultiPartUtils multiPartUtils = new MultiPartUtils();\n         final List<File> files = multiPartUtils.getBinariesFromMultipart(multipart);\n-        if(!UtilMethods.isSet(files)){\n-            throw new DotDataException(\"Unable to extract any files from multi-part request.\");\n-        }\n-\n-        final Map<String, Object> bodyMapFromMultipart = multiPartUtils\n-                .getBodyMapFromMultipart(multipart);\n-        final Object object = bodyMapFromMultipart.get(\"password\");\n-\n-        if(null == object){\n-            throw new DotDataException(\"Unable to locate password param.\");\n+        try {\n+            if (!UtilMethods.isSet(files)) {\n+                throw new DotDataException(\n+                        \"Unable to extract any files from multi-part request.\");\n+            }\n+            final Map<String, Object> bodyMapFromMultipart = multiPartUtils\n+                    .getBodyMapFromMultipart(multipart);\n+            final String password = (String) bodyMapFromMultipart.get(\"password\");\n+            final Key key = AppsUtil.generateKey(AppsUtil.loadPass(() -> password));\n+            for (final File file : files) {\n+                try {\n+                    if (0 == file.length()) {\n+                        throw new IllegalArgumentException(\"Zero length file.\");\n+                    }\n+                    appsAPI.importSecretsAndSave(file.toPath(), key, user);\n+                } finally {\n+                    file.delete();\n+                }\n+            }\n+        } finally {\n+            removeTempFolder(files.get(0).getParentFile());", "originalCommit": "054a1f58927fb353141eb66a26d8ae18b03ecc92", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDU5NzU4NA==", "url": "https://github.com/dotCMS/core/pull/19384#discussion_r500597584", "bodyText": "Look what you made me do. look for processMultipart", "author": "fabrizzio-dotCMS", "createdAt": "2020-10-06T21:10:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQxMjE2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQxMzA5NQ==", "url": "https://github.com/dotCMS/core/pull/19384#discussion_r500413095", "bodyText": "are you sure that we need this imports here?", "author": "freddyucv", "createdAt": "2020-10-06T15:55:52Z", "path": "dotCMS/src/main/java/com/dotcms/rest/api/v1/apps/SecretForm.java", "diffHunk": "@@ -5,6 +5,9 @@\n import com.dotmarketing.util.UtilMethods;\n import com.fasterxml.jackson.annotation.JsonCreator;\n import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.Collectors;", "originalCommit": "054a1f58927fb353141eb66a26d8ae18b03ecc92", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQxMzM5Mg==", "url": "https://github.com/dotCMS/core/pull/19384#discussion_r500413392", "bodyText": "why not get the Identifier from the host?", "author": "freddyucv", "createdAt": "2020-10-06T15:56:15Z", "path": "dotCMS/src/main/java/com/dotcms/security/apps/AppSecretSavedEvent.java", "diffHunk": "@@ -12,18 +12,18 @@\n \n    private final AppSecrets appSecrets;\n \n-   private final Host host;\n+   private final String hostIdentifier;\n \n    private final String userId;\n \n     /**\n      * Event constructor\n      * @param appSecrets\n-     * @param host\n+     * @param hostIdentifier\n      */\n-   AppSecretSavedEvent(final AppSecrets appSecrets, final Host host, final String userId) {\n+   AppSecretSavedEvent(final AppSecrets appSecrets, final String hostIdentifier, final String userId) {\n         this.appSecrets = appSecrets;\n-        this.host = host;\n+        this.hostIdentifier = hostIdentifier;", "originalCommit": "054a1f58927fb353141eb66a26d8ae18b03ecc92", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQzNDc5NQ==", "url": "https://github.com/dotCMS/core/pull/19384#discussion_r500434795", "bodyText": "I am overloading that method so it can be used from an upgrade-task without having to get through our host-API", "author": "fabrizzio-dotCMS", "createdAt": "2020-10-06T16:27:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQxMzM5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQxMzYwMQ==", "url": "https://github.com/dotCMS/core/pull/19384#discussion_r500413601", "bodyText": "are you sure that we need this import here?", "author": "freddyucv", "createdAt": "2020-10-06T15:56:33Z", "path": "dotCMS/src/main/java/com/dotcms/security/apps/AppSecrets.java", "diffHunk": "@@ -7,7 +7,9 @@\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.Map.Entry;\n import java.util.Objects;\n+import java.util.Optional;", "originalCommit": "054a1f58927fb353141eb66a26d8ae18b03ecc92", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQxNjY1Mw==", "url": "https://github.com/dotCMS/core/pull/19384#discussion_r500416653", "bodyText": "use Optional like method arguments is not a goos practice\nhttps://stackoverflow.com/questions/31922866/why-should-java-8s-optional-not-be-used-in-arguments", "author": "freddyucv", "createdAt": "2020-10-06T16:00:48Z", "path": "dotCMS/src/main/java/com/dotcms/security/apps/AppsAPI.java", "diffHunk": "@@ -201,6 +221,19 @@ void removeSecretsForSite(Host host, User user)\n     void resetSecrets(User user)\n                     throws DotDataException, IOException;\n \n+    /**\n+     * Validate the incoming params and match them with the params described by the respective appDescriptor yml.\n+     * This method takes a Map of Optional<char[]> As this is a middle ground object representation\n+     * that can be mapped from a saved  AppSecrets or an incoming SecretForm\n+     * if the param isn't included in the map it means it wasn't sent..\n+     * if the param was sent empty that would be represented as an empty optional.\n+     * I'm using optional since null vales on map triggers warnings\n+     * @param params\n+     * @param appDescriptor\n+     */\n+    void validateForSave(final Map<String, Optional<char[]>> params,", "originalCommit": "054a1f58927fb353141eb66a26d8ae18b03ecc92", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQzMjYxNg==", "url": "https://github.com/dotCMS/core/pull/19384#discussion_r500432616", "bodyText": "This is  NOT an optional argument. It's a map with optional values and right there in the java doc is the reason why I choose to do that. Beside I once pointed the same case in our code base and everyone decided they were fine with such a thing.  if you set your IDE to a high inspection level and then open  FileAssetContainerUtil line 339. You'll see the IDE warns you about that bad practice you're talking about. Such a warning isn't present in the validateForSave method", "author": "fabrizzio-dotCMS", "createdAt": "2020-10-06T16:24:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQxNjY1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQyMDA5NA==", "url": "https://github.com/dotCMS/core/pull/19384#discussion_r500420094", "bodyText": "I'm not sure if we have all the tests for method importSecretsAndSave covered here", "author": "freddyucv", "createdAt": "2020-10-06T16:05:38Z", "path": "dotCMS/src/integration-test/java/com/dotcms/security/apps/AppsAPIImplTest.java", "diffHunk": "@@ -33,6 +33,7 @@\n import com.dotmarketing.exception.DotSecurityException;", "originalCommit": "054a1f58927fb353141eb66a26d8ae18b03ecc92", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ1ODEyNw==", "url": "https://github.com/dotCMS/core/pull/19384#discussion_r500458127", "bodyText": "covered here: Test_Create_Secrets_Then_Export_Them_Then_Import_Then_Save line 1116", "author": "fabrizzio-dotCMS", "createdAt": "2020-10-06T17:04:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQyMDA5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQyMDkzNA==", "url": "https://github.com/dotCMS/core/pull/19384#discussion_r500420934", "bodyText": "I'm not sure if we have all the tests for method validateForSave covered here", "author": "freddyucv", "createdAt": "2020-10-06T16:06:46Z", "path": "dotCMS/src/integration-test/java/com/dotcms/security/apps/AppsAPIImplTest.java", "diffHunk": "@@ -33,6 +33,7 @@\n import com.dotmarketing.exception.DotSecurityException;\n import com.dotmarketing.exception.InvalidLicenseException;", "originalCommit": "054a1f58927fb353141eb66a26d8ae18b03ecc92", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ1ODYzOA==", "url": "https://github.com/dotCMS/core/pull/19384#discussion_r500458638", "bodyText": "validateForSave is already covered here Test_Create_Secrets_Then_Export_Them_Then_Import_Then_Save but it is also covered from many other calls from AppsResourceTest", "author": "fabrizzio-dotCMS", "createdAt": "2020-10-06T17:05:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQyMDkzNA=="}], "type": "inlineReview"}, {"oid": "89a677ef1258e101ec583ab847e946f2d9934d43", "url": "https://github.com/dotCMS/core/commit/89a677ef1258e101ec583ab847e946f2d9934d43", "message": "#18236 feedback", "committedDate": "2020-10-06T21:04:56Z", "type": "commit"}, {"oid": "c03de2eeb7c6a91025551ebf89e353f83bdc8620", "url": "https://github.com/dotCMS/core/commit/c03de2eeb7c6a91025551ebf89e353f83bdc8620", "message": "#18236 refactoriing to extract code needed to perforn import from upgrade task", "committedDate": "2020-10-08T20:18:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTk5NzIxNw==", "url": "https://github.com/dotCMS/core/pull/19384#discussion_r501997217", "bodyText": "is it safe to return null here?", "author": "nollymar", "createdAt": "2020-10-08T20:36:39Z", "path": "dotCMS/src/main/java/com/dotcms/security/apps/SecretsKeyStoreHelper.java", "diffHunk": "@@ -224,41 +200,36 @@ public boolean containsKey(final String variableKey){\n         try {\n            final KeyStore keyStore = getSecretsStore();\n             if (keyStore.containsAlias(variableKey)) {\n-                final PasswordProtection keyStorePP = new PasswordProtection(loadStorePassword());\n+                final PasswordProtection keyStorePP = new PasswordProtection(passwordSupplier.get());\n                 final SecretKeyFactory factory = SecretKeyFactory.getInstance(SECRETS_STORE_SECRET_KEY_FACTORY_TYPE);\n                 final SecretKeyEntry secretKeyEntry = (SecretKeyEntry) keyStore.getEntry(variableKey, keyStorePP);\n                 return ((PBEKeySpec) factory.getKeySpec(secretKeyEntry.getSecretKey(), PBEKeySpec.class)).getPassword();\n             } else {\n-                return CACHE_404;\n+                return null;", "originalCommit": "c03de2eeb7c6a91025551ebf89e353f83bdc8620", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjAyNTI4NQ==", "url": "https://github.com/dotCMS/core/pull/19384#discussion_r502025285", "bodyText": "yeah, pretty sure. it is handled in an upper layer. where if it is null I return the CACHE_404", "author": "fabrizzio-dotCMS", "createdAt": "2020-10-08T21:33:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTk5NzIxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjAyMjUyMQ==", "url": "https://github.com/dotCMS/core/pull/19384#discussion_r502022521", "bodyText": "\"from starter\"", "author": "nollymar", "createdAt": "2020-10-08T21:27:32Z", "path": "dotCMS/src/main/java/com/dotmarketing/startup/runonce/Task201008LoadAppsSecrets.java", "diffHunk": "@@ -0,0 +1,143 @@\n+package com.dotmarketing.startup.runonce;\n+\n+import static com.dotcms.security.apps.AppsUtil.generateKey;\n+import static com.dotcms.security.apps.AppsUtil.importSecrets;\n+import static com.dotcms.security.apps.AppsUtil.internalKey;\n+import static com.dotcms.security.apps.AppsUtil.loadPass;\n+import static com.dotcms.security.apps.AppsUtil.mapForValidation;\n+import static com.dotcms.security.apps.AppsUtil.toJsonAsChars;\n+import static com.dotcms.security.apps.AppsUtil.validateForSave;\n+\n+import com.dotcms.security.apps.AppDescriptor;\n+import com.dotcms.security.apps.AppDescriptorHelper;\n+import com.dotcms.security.apps.AppSecrets;\n+import com.dotcms.security.apps.AppsAPIImpl;\n+import com.dotcms.security.apps.SecretsKeyStoreHelper;\n+import com.dotmarketing.beans.Host;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.common.db.DotConnect;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.startup.StartupTask;\n+import com.google.common.annotations.VisibleForTesting;\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+import java.nio.file.DirectoryStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.security.Key;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.function.Function;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+public class Task201008LoadAppsSecrets implements StartupTask {\n+\n+    private static final Pattern importFilePattern = Pattern\n+            .compile(\"^dotSecrets-import\\\\.([a-zA-Z0-9-_]+)\", Pattern.CASE_INSENSITIVE);\n+\n+    private static final String SITE_LOOKUP_SQL =\n+            \"select count(*) as x from contentlet_version_info clvi, contentlet c, structure s  \\n\"\n+                    + \" where c.structure_inode = s.inode and  s.name = 'Host' and clvi.working_inode = c.inode and c.identifier = ? \";\n+\n+    static boolean matchesFileName(final String input) {\n+        final Matcher matcher = importFilePattern.matcher(input);\n+        return matcher.find();\n+    }\n+\n+    final SecretsKeyStoreHelper keyStoreHelper = new SecretsKeyStoreHelper();\n+\n+    final AppDescriptorHelper appDescriptorHelper = new AppDescriptorHelper();\n+\n+    private Map<String, AppDescriptor> getAppDescriptors() throws DotDataException {\n+        try {\n+            return appDescriptorHelper.loadAppDescriptors().stream().collect(Collectors\n+                    .toMap(appDescriptor -> appDescriptor.getKey().toLowerCase(),\n+                            Function.identity()));\n+        } catch (URISyntaxException | IOException e) {\n+            throw new DotDataException(e);\n+        }\n+    }\n+\n+    private boolean findSite(final String siteId, final DotConnect dotConnect) {\n+        dotConnect.setSQL(SITE_LOOKUP_SQL);\n+        dotConnect.addParam(siteId);\n+        return dotConnect.getInt(\"x\") == 1;\n+    }\n+\n+\n+    private int importCount;\n+\n+    @Override\n+    public boolean forceRun() {\n+        return keyStoreHelper.size() == 0;\n+    }\n+\n+    @Override\n+    public void executeUpgrade() throws DotDataException, DotRuntimeException {\n+        final DotConnect dotConnect = new DotConnect();\n+        final Map<String, AppDescriptor> descriptorsMap = getAppDescriptors();\n+\n+        final Path serverDir = Paths.get(APILocator.getFileAssetAPI().getRealAssetsRootPath()\n+                + File.separator + AppsAPIImpl.SERVER_DIR_NAME).normalize();\n+        final Key key = generateKey(loadPass(null));\n+        try {\n+            try (DirectoryStream<Path> stream = Files.newDirectoryStream(serverDir,\n+                    entry -> matchesFileName(entry.getFileName().toString()))) {\n+                for (final Path path : stream) {\n+                    try {\n+                        final Map<String, List<AppSecrets>> secretsBySiteId = importSecrets(\n+                                path, key);\n+                        for (final Entry<String, List<AppSecrets>> importEntry : secretsBySiteId\n+                                .entrySet()) {\n+                            final String siteId = importEntry.getKey();\n+                            if (Host.SYSTEM_HOST.equalsIgnoreCase(siteId) || findSite(siteId,\n+                                    dotConnect)) {\n+                                final List<AppSecrets> appSecrets = importEntry.getValue();\n+                                for (final AppSecrets secrets : appSecrets) {\n+                                    if (!secrets.getSecrets().isEmpty()) {\n+                                        final AppDescriptor descriptor = descriptorsMap\n+                                                .get(secrets.getKey().toLowerCase());\n+                                        if (null != descriptor) {\n+                                            validateForSave(mapForValidation(secrets), descriptor);\n+                                            final char[] chars = toJsonAsChars(secrets);\n+                                            final String internalKey = internalKey(secrets.getKey(),\n+                                                    siteId);\n+                                            keyStoreHelper.saveValue(internalKey, chars);\n+                                            importCount++;\n+                                        } else {\n+                                            throw new DotDataException(String.format(\n+                                                    \"I cant't import a secret meant for a descriptor `%s` that doesn't exist locally.\",\n+                                                    secrets.getKey()));\n+                                        }\n+                                    } else {\n+                                        throw new DotDataException(\n+                                                \"I cant't import a secret that was generated empty.\");\n+                                    }\n+                                }\n+                            } else {\n+                                throw new DotDataException(String.format(\n+                                        \"I cant't import a secret that belongs into a unknown site `%s`.\",\n+                                        siteId));\n+                            }\n+                        }\n+                    } finally {\n+                        path.toFile().delete();\n+                    }\n+                }\n+            }\n+        } catch (Exception e) {\n+            throw new DotDataException(\"Error Importing AppSecret from starer \", e);", "originalCommit": "c03de2eeb7c6a91025551ebf89e353f83bdc8620", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "27e528de9715ceb71264af88e63a97a604df34d6", "url": "https://github.com/dotCMS/core/commit/27e528de9715ceb71264af88e63a97a604df34d6", "message": "#18236 merge with master", "committedDate": "2020-10-09T15:28:57Z", "type": "commit"}, {"oid": "d11caa31ca2a61bed0f54ff50ef43ac7d1505794", "url": "https://github.com/dotCMS/core/commit/d11caa31ca2a61bed0f54ff50ef43ac7d1505794", "message": "#18236 merge with master", "committedDate": "2020-10-09T15:41:27Z", "type": "commit"}, {"oid": "9ef5ee583a85dc22b6cff52fc9766bbeea5da4f2", "url": "https://github.com/dotCMS/core/commit/9ef5ee583a85dc22b6cff52fc9766bbeea5da4f2", "message": "#18236 solve conflicts", "committedDate": "2020-10-19T16:36:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzg5OTY1MQ==", "url": "https://github.com/dotCMS/core/pull/19384#discussion_r507899651", "bodyText": "Codacy found an issue: Useless parentheses.", "author": "dev-dotcms", "createdAt": "2020-10-19T16:44:39Z", "path": "dotCMS/src/main/java/com/dotcms/security/apps/AppDescriptorHelper.java", "diffHunk": "@@ -0,0 +1,384 @@\n+package com.dotcms.security.apps;\n+\n+import static com.dotcms.security.apps.AppsAPI.APPS_DIR_NAME;\n+import static com.dotcms.security.apps.AppsAPI.APPS_DIR_PATH_KEY;\n+import static com.dotcms.security.apps.AppsAPI.DESCRIPTOR_NAME_MAX_LENGTH;\n+import static com.dotcms.security.apps.AppsAPI.SERVER_DIR_NAME;\n+import static com.dotmarketing.util.UtilMethods.isNotSet;\n+import static com.dotmarketing.util.UtilMethods.isSet;\n+\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotDataValidationException;\n+import com.dotmarketing.util.Config;\n+import com.dotmarketing.util.Logger;\n+import com.fasterxml.jackson.core.JsonParser.Feature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import com.google.common.collect.ImmutableList;\n+import com.liferay.util.StringPool;\n+import io.vavr.Tuple;\n+import io.vavr.Tuple2;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.URISyntaxException;\n+import java.net.URL;\n+import java.nio.file.DirectoryStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+public class AppDescriptorHelper {\n+\n+    private final ObjectMapper ymlMapper = new ObjectMapper(new YAMLFactory())\n+            .enable(Feature.STRICT_DUPLICATE_DETECTION)\n+            //.enable(SerializationFeature.INDENT_OUTPUT)\n+            .findAndRegisterModules();\n+\n+    /**\n+     * There's a version of the method readValue on the ymlMapper which takes a file and internally creates directly a FileInputStream\n+     * According to https://dzone.com/articles/fileinputstream-fileoutputstream-considered-harmful\n+     * that's very harmful\n+     * @param file\n+     * @return\n+     * @throws DotDataException\n+     */\n+    AppSchema readAppFile(final Path file) throws DotDataException {\n+        try (InputStream inputStream = Files.newInputStream(file)) {\n+            return ymlMapper.readValue(inputStream, AppSchema.class);\n+        }catch (Exception e){\n+            throw new DotDataException(e.getMessage(), e);\n+        }\n+    }\n+\n+    /**\n+     * There's a version of the method writeValue on the ymlMapper which takes a file and internally creates directly a FileOutputStream\n+     * According to https://dzone.com/articles/fileinputstream-fileoutputstream-considered-harmful\n+     * that's very harmful\n+     * @param file\n+     * @return\n+     * @throws DotDataException\n+     */\n+    void writeAppFile(final File file, final AppSchema appSchema) throws DotDataException {\n+        try (OutputStream outputStream = Files.newOutputStream(Paths.get(file.getPath()))) {\n+            ymlMapper.writeValue(outputStream, appSchema);\n+        }catch (Exception e){\n+            throw new DotDataException(e.getMessage(), e);\n+        }\n+    }\n+\n+    /**\n+     * AppDescriptors loading entry point\n+     * None of this use cache.\n+     * @return\n+     * @throws IOException\n+     * @throws URISyntaxException\n+     */\n+     public List<AppDescriptor> loadAppDescriptors()\n+            throws IOException, URISyntaxException {\n+\n+        final ImmutableList.Builder<AppDescriptor> builder = new ImmutableList.Builder<>();\n+        final Set<Tuple2<Path, Boolean>> filePaths = listAvailableYamlFiles();\n+        for (final Tuple2<Path, Boolean> filePath : filePaths) {\n+            try {\n+                final Path path = filePath._1;\n+                final boolean systemApp = filePath._2;\n+                final AppSchema appSchema = readAppFile(path);\n+                if (validateAppDescriptor(appSchema)) {\n+                    builder.add(new AppDescriptorImpl(path.getFileName().toString(), systemApp, appSchema));\n+                }\n+            } catch (Exception e) {\n+                Logger.error(AppsAPIImpl.class,\n+                        String.format(\"Error reading yml file `%s`.\", filePath), e);\n+            }\n+        }\n+\n+        return builder.build();\n+    }\n+\n+    /**\n+     * internal descriptor validator\n+     * @param appDescriptor\n+     * @return\n+     * @throws DotDataValidationException\n+     */\n+     boolean validateAppDescriptor(final AppSchema appDescriptor)\n+            throws DotDataValidationException {\n+\n+        final List<String> errors = new ArrayList<>();\n+\n+        if(isNotSet(appDescriptor.getName())){\n+            errors.add(\"The required field `name` isn't set on the incoming file.\");\n+        }\n+\n+        if(isNotSet(appDescriptor.getDescription())){\n+            errors.add(\"The required field `description` isn't set on the incoming file.\");\n+        }\n+\n+        if(isNotSet(appDescriptor.getIconUrl())){\n+            errors.add(\"The required field `iconUrl` isn't set on the incoming file.\");\n+        }\n+\n+        if(!isSet(appDescriptor.getAllowExtraParameters())){\n+            errors.add(\"The required boolean field `allowExtraParameters` isn't set on the incoming file.\");\n+        }\n+\n+        if(!isSet(appDescriptor.getParams())){\n+            errors.add(\"The required field `params` isn't set on the incoming file.\");\n+        }\n+\n+        for (final Map.Entry<String, ParamDescriptor> entry : appDescriptor.getParams().entrySet()) {\n+            errors.addAll(validateParamDescriptor(entry.getKey(), entry.getValue()));\n+        }\n+\n+        if(!errors.isEmpty()){\n+            throw new DotDataValidationException(String.join(\" \\n\", errors));\n+        }\n+\n+        return true;\n+\n+    }\n+\n+    /**\n+     * internal param validator\n+     * @param name\n+     * @param descriptor\n+     * @return\n+     */\n+    private List<String> validateParamDescriptor(final String name,\n+            final ParamDescriptor descriptor) {\n+\n+        final List<String> errors = new LinkedList<>();\n+\n+        if (isNotSet(name)) {\n+            errors.add(\"Param descriptor is missing required  field `name` .\");\n+        }\n+\n+        if (DESCRIPTOR_NAME_MAX_LENGTH < name.length()) {\n+            errors.add(String.format(\"`%s`: exceeds %d chars length.\", name,\n+                    DESCRIPTOR_NAME_MAX_LENGTH));\n+        }\n+\n+        if (null == descriptor.getValue()) {\n+            errors.add(String.format(\n+                    \"`%s`: is missing required field `value` or a value hasn't been set. Value is mandatory. \",\n+                    name));\n+        }\n+\n+        if (isNotSet(descriptor.getHint())) {\n+            errors.add(String.format(\"Param `%s`: is missing required field `hint` .\", name));\n+        }\n+\n+        if (isNotSet(descriptor.getLabel())) {\n+            errors.add(String.format(\"Param `%s`: is missing required field `hint` .\", name));\n+        }\n+\n+        if (null == descriptor.getType()) {\n+            errors.add(String.format(\n+                    \"Param `%s`: is missing required field `type` (STRING|BOOL|SELECT) .\",\n+                    name));\n+        }\n+\n+        if (!isSet(descriptor.getRequired())) {\n+            errors.add(\n+                    String.format(\"Param `%s`: is missing required field `required` (true|false) .\",\n+                            name));\n+        }\n+\n+        if (!isSet(descriptor.getHidden())) {\n+            errors.add(\n+                    String.format(\"Param `%s`: is missing required field `hidden` (true|false) .\",\n+                            name));\n+        }\n+\n+        if (isSet(descriptor.getValue()) && StringPool.NULL\n+                .equalsIgnoreCase(descriptor.getValue().toString()) && descriptor.isRequired()) {\n+            errors.add(String.format(\n+                    \"Null isn't allowed as the default value on required params see `%s`. \",\n+                    name)\n+            );\n+        }\n+\n+        if (Type.BOOL.equals(descriptor.getType())) {\n+            if (isSet(descriptor.getHidden())\n+                    && descriptor.isHidden()) {\n+                errors.add(String.format(\n+                        \"Param `%s`: Bool params can not be marked hidden. The combination (Bool + Hidden) isn't allowed.\",\n+                        name));\n+            }\n+\n+            if (isSet(descriptor.getValue())\n+                    && !isBoolString(descriptor.getValue().toString())) {\n+                errors.add(String.format(\n+                        \"Boolean Param `%s` has a default value `%s` that can not be parsed to bool (true|false).\",\n+                        name, descriptor.getValue()));\n+            }\n+        }\n+\n+        if(Type.STRING.equals(descriptor.getType()) && !(descriptor.getValue() instanceof String)){\n+            errors.add(String.format(\n+                    \"Value Param `%s` has a default value `%s` that isn't a string .\",\n+                    name, descriptor.getValue()));\n+        }\n+\n+        if (Type.SELECT.equals(descriptor.getType())) {\n+\n+            if (isSet(descriptor.getHidden()) && descriptor.isHidden()) {\n+                errors.add(String.format(\n+                        \"Param `%s`: List params can not be marked hidden. The combination (List + Hidden) isn't allowed.\",\n+                        name));\n+            }\n+\n+            if (!(descriptor.getValue() instanceof List)) {\n+                errors.add(String.format(\n+                        \" As param `%s`:  is marked as `List` the field value is expected to hold a list of objects. \",\n+                        name));\n+            } else {\n+                final int minSelectedElements = 1;\n+                int selectedCount = 0;\n+                final List list = (List) descriptor.getValue();\n+                for (final Object object : list) {\n+                    if (!(object instanceof Map)) {\n+                        errors.add(String.format(\n+                                \"Malformed list. Param: `%s` is marked as `List` therefore field `value` is expected to have a list of objects. \",\n+                                name));\n+                    } else {\n+                        final Map map = (Map) object;\n+                        if (!map.containsKey(\"label\") || !map.containsKey(\"value\") ) {\n+                            errors.add(String.format(\"Malformed list. Param: `%s`. Every entry of the `List` has to have the following fields (`label`,`value`). \", name));\n+                        }\n+                        if(map.containsKey(\"selected\")){\n+                            selectedCount++;\n+                        }\n+                    }\n+                }\n+                if(selectedCount > minSelectedElements ){\n+                    errors.add(String.format(\"Malformed list. Param: `%s`. There must be only 1 item marked as selected \", name));\n+                }\n+            }\n+        }\n+\n+        return errors;\n+    }\n+\n+    /**\n+     * Verifies if a string can be parsed to boolean safely.\n+     * @param value\n+     * @return\n+     */\n+    private boolean isBoolString(final String value){\n+        return Boolean.TRUE.toString().equalsIgnoreCase(value) || Boolean.FALSE.toString().equalsIgnoreCase(value);\n+    }\n+\n+\n+    /**\n+     * This is the Apps-System-Folder which is meant to hold system apps.\n+     * Those that can not be override and are always available.\n+     * @return\n+     */\n+    static Path getSystemAppsDescriptorDirectory() throws URISyntaxException, IOException {\n+        final URL res = Thread.currentThread().getContextClassLoader().getResource(\"apps\");\n+        if(res == null) {\n+            throw new IOException(\"Unable to find Apps System folder. It should be at /WEB-INF/classes/apps \");\n+        } else {\n+            return Paths.get(res.toURI()).toAbsolutePath();\n+        }\n+    }\n+\n+    /**\n+     * returns DotCMS server folder\n+     * @return\n+     */\n+    public static Path getServerDirectory() {\n+        return Paths.get(APILocator.getFileAssetAPI().getRealAssetsRootPath()\n+                + File.separator + SERVER_DIR_NAME + File.separator).normalize();\n+    }\n+\n+    /**\n+     * This is the directory intended for customers use\n+     * @return\n+     */\n+    static Path getAppsDefaultDirectory() {\n+        return Paths.get(getServerDirectory() + File.separator + APPS_DIR_NAME + File.separator).normalize();\n+    }\n+\n+    /**\n+     * This is the directory intended for customers use.\n+     * with the option to read an override property from the config\n+     * @return\n+     */\n+    static Path getUserAppsDescriptorDirectory() {\n+        final Supplier<String> supplier = ()-> getAppsDefaultDirectory().toString();\n+        final String dirPath = Config\n+                .getStringProperty(APPS_DIR_PATH_KEY, supplier.get());\n+        return Paths.get(dirPath).normalize();\n+    }\n+\n+    private static DirectoryStream.Filter<Path> filter = new DirectoryStream.Filter<Path>() {\n+\n+        private static final String ignorePrefix = \"_ignore_\";\n+        private static final String yml = \"yml\";\n+        private static final String yaml = \"yaml\";\n+\n+        @Override\n+        public boolean accept(final Path path) {\n+            if (Files.isDirectory(path)) {\n+                return false;\n+            }\n+            final String fileName = path.getFileName().toString();\n+            return !fileName.startsWith(ignorePrefix) && (fileName.endsWith(yaml) || fileName.endsWith(yml)) ;\n+        }\n+    };\n+\n+    private Set<Path> listFiles(final Path dir) throws IOException {\n+        final Set<Path> fileList = new HashSet<>();\n+        try (DirectoryStream<Path> stream = Files.newDirectoryStream(dir, filter)) {\n+            stream.forEach(fileList::add);\n+        }\n+        return fileList;\n+    }\n+\n+    /**\n+     *  This will get you a list with all the available app-yml files registered in the system.\n+     *\n+     * @return\n+     * @throws IOException\n+     * @throws URISyntaxException\n+     */\n+    private Set<Tuple2<Path, Boolean>> listAvailableYamlFiles() throws IOException, URISyntaxException {\n+        final Path systemAppsDescriptorDirectory = getSystemAppsDescriptorDirectory();\n+        final Set<Path> systemFiles = listFiles(systemAppsDescriptorDirectory);\n+\n+        final Path appsDescriptorDirectory = getUserAppsDescriptorDirectory();\n+        final File basePath = appsDescriptorDirectory.toFile();\n+        if (!basePath.exists()) {\n+            basePath.mkdirs();\n+        }\n+        Logger.debug(AppsAPIImpl.class,\n+                () -> \" ymlFiles are set under:  \" + basePath.toString());\n+        final Set<Path> userFiles = listFiles(appsDescriptorDirectory);\n+\n+        final Set<Path> systemFileNames = systemFiles.stream().map(Path::getFileName)\n+                .collect(Collectors.toSet());\n+        final Set<Path> filteredUserFiles = userFiles.stream()\n+                .filter(path -> systemFileNames.stream().noneMatch(\n+                        systemPath -> systemPath.toString()\n+                                .equalsIgnoreCase((path.getFileName().toString().toLowerCase()))))", "originalCommit": "9ef5ee583a85dc22b6cff52fc9766bbeea5da4f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzg5OTY2NA==", "url": "https://github.com/dotCMS/core/pull/19384#discussion_r507899664", "bodyText": "Codacy found an issue: Unnecessary use of fully qualified name 'ImmutableMap.of' due to existing static import 'com.google.common.collect.ImmutableMap.of'", "author": "dev-dotcms", "createdAt": "2020-10-19T16:44:41Z", "path": "dotCMS/src/integration-test/java/com/dotcms/security/apps/AppsAPIImplTest.java", "diffHunk": "@@ -794,6 +796,42 @@ public void Test_Get_Secret_fallbackOnSystemHost_With_Non_Valid_License()\n         nonValidLicenseAppsAPI.getSecrets(\"anyKey\", true, systemHost, admin);\n     }\n \n+    /**\n+     * Given scenario: We simulate a non valid license situation then we call  AppsAPI#exportSecrets\n+     * Expected Results: we should get an InvalidLicenseException\n+     * @throws DotDataException\n+     * @throws DotSecurityException\n+     */\n+    @Test(expected = InvalidLicenseException.class)\n+    public void Test_Export_With_Non_Valid_License()\n+            throws DotDataException, DotSecurityException, IOException {\n+\n+        final User admin = TestUserUtils.getAdminUser();\n+        //AES only supports key sizes of 16, 24 or 32 bytes.\n+        final String password = RandomStringUtils.randomAlphanumeric(32);\n+        final Key key = AppsUtil.generateKey(password);\n+        nonValidLicenseAppsAPI.exportSecrets(key,true,ImmutableMap.of(),admin);", "originalCommit": "9ef5ee583a85dc22b6cff52fc9766bbeea5da4f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzg5OTY3OA==", "url": "https://github.com/dotCMS/core/pull/19384#discussion_r507899678", "bodyText": "Codacy found an issue: Avoid catching generic exceptions such as NullPointerException, RuntimeException, Exception in try-catch block", "author": "dev-dotcms", "createdAt": "2020-10-19T16:44:41Z", "path": "dotCMS/src/main/java/com/dotcms/security/apps/AppDescriptorHelper.java", "diffHunk": "@@ -0,0 +1,384 @@\n+package com.dotcms.security.apps;\n+\n+import static com.dotcms.security.apps.AppsAPI.APPS_DIR_NAME;\n+import static com.dotcms.security.apps.AppsAPI.APPS_DIR_PATH_KEY;\n+import static com.dotcms.security.apps.AppsAPI.DESCRIPTOR_NAME_MAX_LENGTH;\n+import static com.dotcms.security.apps.AppsAPI.SERVER_DIR_NAME;\n+import static com.dotmarketing.util.UtilMethods.isNotSet;\n+import static com.dotmarketing.util.UtilMethods.isSet;\n+\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotDataValidationException;\n+import com.dotmarketing.util.Config;\n+import com.dotmarketing.util.Logger;\n+import com.fasterxml.jackson.core.JsonParser.Feature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import com.google.common.collect.ImmutableList;\n+import com.liferay.util.StringPool;\n+import io.vavr.Tuple;\n+import io.vavr.Tuple2;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.URISyntaxException;\n+import java.net.URL;\n+import java.nio.file.DirectoryStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+public class AppDescriptorHelper {\n+\n+    private final ObjectMapper ymlMapper = new ObjectMapper(new YAMLFactory())\n+            .enable(Feature.STRICT_DUPLICATE_DETECTION)\n+            //.enable(SerializationFeature.INDENT_OUTPUT)\n+            .findAndRegisterModules();\n+\n+    /**\n+     * There's a version of the method readValue on the ymlMapper which takes a file and internally creates directly a FileInputStream\n+     * According to https://dzone.com/articles/fileinputstream-fileoutputstream-considered-harmful\n+     * that's very harmful\n+     * @param file\n+     * @return\n+     * @throws DotDataException\n+     */\n+    AppSchema readAppFile(final Path file) throws DotDataException {\n+        try (InputStream inputStream = Files.newInputStream(file)) {\n+            return ymlMapper.readValue(inputStream, AppSchema.class);\n+        }catch (Exception e){", "originalCommit": "9ef5ee583a85dc22b6cff52fc9766bbeea5da4f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzg5OTY4OA==", "url": "https://github.com/dotCMS/core/pull/19384#discussion_r507899688", "bodyText": "Codacy found an issue: Unnecessary use of fully qualified name 'ImmutableMap.of' due to existing static import 'com.google.common.collect.ImmutableMap.of'", "author": "dev-dotcms", "createdAt": "2020-10-19T16:44:42Z", "path": "dotCMS/src/integration-test/java/com/dotcms/security/apps/AppsAPIImplTest.java", "diffHunk": "@@ -1035,43 +1074,180 @@ public void Test_File_Comparison_Is_Case_Sensitive()\n      */\n     @Test\n     public void Test_Create_Secrets_Then_Export_Them_Then_Import_Then_Save()\n-            throws DotDataException, DotSecurityException, IOException, EncryptorException, ClassNotFoundException {\n+            throws DotDataException, DotSecurityException, IOException, EncryptorException, AlreadyExistException {\n         final User admin = TestUserUtils.getAdminUser();\n         final Host site = new SiteDataGen().nextPersisted();\n         final AppsAPI api = APILocator.getAppsAPI();\n+        //generate a descriptor\n         final AppSecrets.Builder builder1 = new AppSecrets.Builder();\n-        final String appKey = \"appKey-1-Host-1\";\n-        final AppSecrets secrets = builder1.withKey(appKey)\n-                .withHiddenSecret(\"test:secret1\", \"secret-1\")\n-                .withHiddenSecret(\"test:secret2\", \"secret-2\")\n-                .withHiddenSecret(\"test:secret3\", \"secret3\")\n-                .withHiddenSecret(\"test:secret4\", \"secret-4\")\n+        final AppDescriptorDataGen dataGen = new AppDescriptorDataGen()\n+                .stringParam(\"p1\", false,  true)\n+                .stringParam(\"p2\", false,  true)\n+                .withName(\"system-app-example\")\n+                .withDescription(\"system-app\")\n+                .withExtraParameters(false);\n+        final File file = dataGen.nextPersistedDescriptor();\n+        api.createAppDescriptor(file, admin);\n+\n+        final String appKey = dataGen.getKey();\n+        //generate secrets\n+        AppSecrets secrets = builder1.withKey(appKey)\n+                .withHiddenSecret(\"p1\", \"secret-1\")\n+                .withHiddenSecret(\"p2\", \"secret-2\")\n                 .build();\n         //Save it\n         api.saveSecrets(secrets, site, admin);\n         final Optional<AppSecrets> secretsOptional = api.getSecrets(appKey, site, admin);\n-        final AppSecrets appSecretsPostSave = secretsOptional.get();\n+        Assert.assertTrue(secretsOptional.isPresent());\n+        secrets = secretsOptional.get();\n \n-        //AES only supports key sizes of 16, 24 or 32 bytes.\n+        //AES only supports security Key of sizes of 16, 24 or 32 bytes.\n         final String password = RandomStringUtils.randomAlphanumeric(32);\n-        final Key key = AppsUtil.generateKey(password);\n-        final Path exportSecretsFile = api.exportSecrets(key, true, null, admin);\n+        final Key securityKey = AppsUtil.generateKey(password);\n+\n+        //Now that we have a valid key lets dump our selection of secrets\n+        final Map<String,Set<String>> appKeysBySite = ImmutableMap.of(site.getIdentifier(), ImmutableSet.of(appKey));", "originalCommit": "9ef5ee583a85dc22b6cff52fc9766bbeea5da4f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzg5OTcwNA==", "url": "https://github.com/dotCMS/core/pull/19384#discussion_r507899704", "bodyText": "Codacy found an issue: Avoid catching generic exceptions such as NullPointerException, RuntimeException, Exception in try-catch block", "author": "dev-dotcms", "createdAt": "2020-10-19T16:44:43Z", "path": "dotCMS/src/main/java/com/dotcms/security/apps/SecretCachedKeyStoreImpl.java", "diffHunk": "@@ -0,0 +1,204 @@\n+package com.dotcms.security.apps;\n+\n+import static com.dotcms.security.apps.AppsCache.CACHE_404;\n+import static com.dotcms.security.apps.AppsUtil.digest;\n+import static com.dotcms.security.apps.SecretsKeyStoreHelper.SECRETS_KEYSTORE_PASSWORD_KEY;\n+\n+import com.dotcms.enterprise.cluster.ClusterFactory;\n+import com.dotmarketing.business.CacheLocator;\n+import com.dotmarketing.business.DotCacheException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.util.Config;\n+import com.dotmarketing.util.Logger;\n+import com.google.common.collect.ImmutableList;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import java.io.IOException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Supplier;\n+\n+/**\n+ * This is basically a safe repository implemented using java.security.KeyStore\n+ * Which according to the official Java documentation Represents a storage facility for cryptographic keys and certificates.\n+ * This Class serves as the entry point to the repository whose implantation really resides in SecretsKeyStoreHelper\n+ * This class adds caching\n+ */\n+public class SecretCachedKeyStoreImpl implements SecretsStore {\n+\n+    private final SecretsKeyStoreHelper secretsKeyStore;\n+    private final AppsCache cache;\n+\n+    SecretCachedKeyStoreImpl(final AppsCache cache) {\n+        this.secretsKeyStore = new SecretsKeyStoreHelper(() -> cache\n+                .getFromCache(SECRETS_KEYSTORE_PASSWORD_KEY, () -> Config\n+                        .getStringProperty(SECRETS_KEYSTORE_PASSWORD_KEY,\n+                                digest(ClusterFactory.getClusterSalt())).toCharArray()),\n+                ImmutableList.of(this::flushCache));\n+        this.cache = cache;\n+    }\n+\n+    public SecretCachedKeyStoreImpl() {\n+       this(CacheLocator.getAppsCache());\n+    }\n+\n+    /**\n+     * Verifies if the key exists in the store\n+     * @param variableKey\n+     * @return\n+     */\n+    @Override\n+    public boolean containsKey(final String variableKey) {\n+        try {\n+            return getKeysFromCache().contains(variableKey);\n+        } catch (Exception e) {", "originalCommit": "9ef5ee583a85dc22b6cff52fc9766bbeea5da4f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzg5OTcyNQ==", "url": "https://github.com/dotCMS/core/pull/19384#discussion_r507899725", "bodyText": "Codacy found an issue: A method/constructor should not explicitly throw java.lang.Exception", "author": "dev-dotcms", "createdAt": "2020-10-19T16:44:44Z", "path": "dotCMS/src/integration-test/java/com/dotmarketing/startup/runonce/Task201008LoadAppsSecretsTest.java", "diffHunk": "@@ -0,0 +1,180 @@\n+package com.dotmarketing.startup.runonce;\n+\n+import com.dotcms.datagen.AppDescriptorDataGen;\n+import com.dotcms.datagen.SiteDataGen;\n+import com.dotcms.datagen.TestUserUtils;\n+import com.dotcms.security.apps.AppDescriptor;\n+import com.dotcms.security.apps.AppDescriptorHelper;\n+import com.dotcms.security.apps.AppSecrets;\n+import com.dotcms.security.apps.AppsAPI;\n+import com.dotcms.security.apps.AppsCache;\n+import com.dotcms.security.apps.AppsUtil;\n+import com.dotcms.security.apps.SecretsKeyStoreHelper;\n+import com.dotcms.util.IntegrationTestInitService;\n+import com.dotmarketing.beans.Host;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.CacheLocator;\n+import com.dotmarketing.exception.AlreadyExistException;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.portlets.contentlet.business.HostAPI;\n+import com.google.common.collect.ImmutableSet;\n+import com.liferay.portal.model.User;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.security.Key;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import org.junit.Assert;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+public class Task201008LoadAppsSecretsTest {\n+\n+    static AppsAPI api;\n+    static User admin;\n+\n+    @BeforeClass\n+    public static void prepare() throws Exception {", "originalCommit": "9ef5ee583a85dc22b6cff52fc9766bbeea5da4f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzg5OTczOA==", "url": "https://github.com/dotCMS/core/pull/19384#discussion_r507899738", "bodyText": "Codacy found an issue: Use assertEquals(x, y) instead of assertTrue(x.equals(y))", "author": "dev-dotcms", "createdAt": "2020-10-19T16:44:45Z", "path": "dotCMS/src/integration-test/java/com/dotcms/security/apps/AppsAPIImplTest.java", "diffHunk": "@@ -1035,43 +1074,180 @@ public void Test_File_Comparison_Is_Case_Sensitive()\n      */\n     @Test\n     public void Test_Create_Secrets_Then_Export_Them_Then_Import_Then_Save()\n-            throws DotDataException, DotSecurityException, IOException, EncryptorException, ClassNotFoundException {\n+            throws DotDataException, DotSecurityException, IOException, EncryptorException, AlreadyExistException {\n         final User admin = TestUserUtils.getAdminUser();\n         final Host site = new SiteDataGen().nextPersisted();\n         final AppsAPI api = APILocator.getAppsAPI();\n+        //generate a descriptor\n         final AppSecrets.Builder builder1 = new AppSecrets.Builder();\n-        final String appKey = \"appKey-1-Host-1\";\n-        final AppSecrets secrets = builder1.withKey(appKey)\n-                .withHiddenSecret(\"test:secret1\", \"secret-1\")\n-                .withHiddenSecret(\"test:secret2\", \"secret-2\")\n-                .withHiddenSecret(\"test:secret3\", \"secret3\")\n-                .withHiddenSecret(\"test:secret4\", \"secret-4\")\n+        final AppDescriptorDataGen dataGen = new AppDescriptorDataGen()\n+                .stringParam(\"p1\", false,  true)\n+                .stringParam(\"p2\", false,  true)\n+                .withName(\"system-app-example\")\n+                .withDescription(\"system-app\")\n+                .withExtraParameters(false);\n+        final File file = dataGen.nextPersistedDescriptor();\n+        api.createAppDescriptor(file, admin);\n+\n+        final String appKey = dataGen.getKey();\n+        //generate secrets\n+        AppSecrets secrets = builder1.withKey(appKey)\n+                .withHiddenSecret(\"p1\", \"secret-1\")\n+                .withHiddenSecret(\"p2\", \"secret-2\")\n                 .build();\n         //Save it\n         api.saveSecrets(secrets, site, admin);\n         final Optional<AppSecrets> secretsOptional = api.getSecrets(appKey, site, admin);\n-        final AppSecrets appSecretsPostSave = secretsOptional.get();\n+        Assert.assertTrue(secretsOptional.isPresent());\n+        secrets = secretsOptional.get();\n \n-        //AES only supports key sizes of 16, 24 or 32 bytes.\n+        //AES only supports security Key of sizes of 16, 24 or 32 bytes.\n         final String password = RandomStringUtils.randomAlphanumeric(32);\n-        final Key key = AppsUtil.generateKey(password);\n-        final Path exportSecretsFile = api.exportSecrets(key, true, null, admin);\n+        final Key securityKey = AppsUtil.generateKey(password);\n+\n+        //Now that we have a valid key lets dump our selection of secrets\n+        final Map<String,Set<String>> appKeysBySite = ImmutableMap.of(site.getIdentifier(), ImmutableSet.of(appKey));\n+        final Path exportSecretsFile = api.exportSecrets(securityKey, false, appKeysBySite, admin);\n         assertTrue(exportSecretsFile.toFile().exists());\n \n-        //Remove so we can re import them.\n+        //Remove the secret we dumped we can re import it.\n         api.deleteSecrets(appKey, site, admin);\n \n-        final Map<String, List<AppSecrets>> secretAppsBySiteId = api.importSecrets(exportSecretsFile, key, admin);\n-        assertFalse(secretAppsBySiteId.isEmpty());\n-        assertTrue(secretAppsBySiteId.containsKey(site.getIdentifier()));\n-        final List<AppSecrets> appSecretsBySite = secretAppsBySiteId.get(site.getIdentifier());\n-        assertFalse(appSecretsBySite.isEmpty());\n-        final AppSecrets importedSecrets = appSecretsBySite.get(0);\n-        assertEquals(importedSecrets, appSecretsPostSave);\n+        //import it\n+        api.importSecretsAndSave(exportSecretsFile, securityKey, admin);\n \n-        api.saveSecrets(importedSecrets, site, admin);\n+        //verify\n         final Optional<AppSecrets> secretsOptionalPostImport = api.getSecrets(appKey, site, admin);\n         assertTrue(secretsOptionalPostImport.isPresent());\n+        final AppSecrets restoredSecrets = secretsOptionalPostImport.get();\n+\n+        assertEquals(restoredSecrets.getKey(),secrets.getKey());\n+        assertEquals(restoredSecrets.getSecrets().size(),secrets.getSecrets().size());\n+        for (final Entry<String, Secret> entry : secrets.getSecrets().entrySet()) {\n+            final Secret originalSecret = entry.getValue();\n+            final Secret restoredSecret = restoredSecrets.getSecrets().get(entry.getKey());\n+            assertTrue(originalSecret.equals(restoredSecret));", "originalCommit": "9ef5ee583a85dc22b6cff52fc9766bbeea5da4f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzg5OTc1NA==", "url": "https://github.com/dotCMS/core/pull/19384#discussion_r507899754", "bodyText": "Codacy found an issue: Avoid catching generic exceptions such as NullPointerException, RuntimeException, Exception in try-catch block", "author": "dev-dotcms", "createdAt": "2020-10-19T16:44:46Z", "path": "dotCMS/src/main/java/com/dotmarketing/startup/runonce/Task201008LoadAppsSecrets.java", "diffHunk": "@@ -0,0 +1,143 @@\n+package com.dotmarketing.startup.runonce;\n+\n+import static com.dotcms.security.apps.AppsUtil.generateKey;\n+import static com.dotcms.security.apps.AppsUtil.importSecrets;\n+import static com.dotcms.security.apps.AppsUtil.internalKey;\n+import static com.dotcms.security.apps.AppsUtil.loadPass;\n+import static com.dotcms.security.apps.AppsUtil.mapForValidation;\n+import static com.dotcms.security.apps.AppsUtil.toJsonAsChars;\n+import static com.dotcms.security.apps.AppsUtil.validateForSave;\n+\n+import com.dotcms.security.apps.AppDescriptor;\n+import com.dotcms.security.apps.AppDescriptorHelper;\n+import com.dotcms.security.apps.AppSecrets;\n+import com.dotcms.security.apps.AppsAPIImpl;\n+import com.dotcms.security.apps.SecretsKeyStoreHelper;\n+import com.dotmarketing.beans.Host;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.common.db.DotConnect;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.startup.StartupTask;\n+import com.google.common.annotations.VisibleForTesting;\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+import java.nio.file.DirectoryStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.security.Key;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.function.Function;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+public class Task201008LoadAppsSecrets implements StartupTask {\n+\n+    private static final Pattern importFilePattern = Pattern\n+            .compile(\"^dotSecrets-import\\\\.([a-zA-Z0-9-_]+)\", Pattern.CASE_INSENSITIVE);\n+\n+    private static final String SITE_LOOKUP_SQL =\n+            \"select count(*) as x from contentlet_version_info clvi, contentlet c, structure s  \\n\"\n+                    + \" where c.structure_inode = s.inode and  s.name = 'Host' and clvi.working_inode = c.inode and c.identifier = ? \";\n+\n+    static boolean matchesFileName(final String input) {\n+        final Matcher matcher = importFilePattern.matcher(input);\n+        return matcher.find();\n+    }\n+\n+    final SecretsKeyStoreHelper keyStoreHelper = new SecretsKeyStoreHelper();\n+\n+    final AppDescriptorHelper appDescriptorHelper = new AppDescriptorHelper();\n+\n+    private Map<String, AppDescriptor> getAppDescriptors() throws DotDataException {\n+        try {\n+            return appDescriptorHelper.loadAppDescriptors().stream().collect(Collectors\n+                    .toMap(appDescriptor -> appDescriptor.getKey().toLowerCase(),\n+                            Function.identity()));\n+        } catch (URISyntaxException | IOException e) {\n+            throw new DotDataException(e);\n+        }\n+    }\n+\n+    private boolean findSite(final String siteId, final DotConnect dotConnect) {\n+        dotConnect.setSQL(SITE_LOOKUP_SQL);\n+        dotConnect.addParam(siteId);\n+        return dotConnect.getInt(\"x\") == 1;\n+    }\n+\n+\n+    private int importCount;\n+\n+    @Override\n+    public boolean forceRun() {\n+        return keyStoreHelper.size() == 0;\n+    }\n+\n+    @Override\n+    public void executeUpgrade() throws DotDataException, DotRuntimeException {\n+        final DotConnect dotConnect = new DotConnect();\n+        final Map<String, AppDescriptor> descriptorsMap = getAppDescriptors();\n+\n+        final Path serverDir = Paths.get(APILocator.getFileAssetAPI().getRealAssetsRootPath()\n+                + File.separator + AppsAPIImpl.SERVER_DIR_NAME).normalize();\n+        final Key key = generateKey(loadPass(null));\n+        try {\n+            try (DirectoryStream<Path> stream = Files.newDirectoryStream(serverDir,\n+                    entry -> matchesFileName(entry.getFileName().toString()))) {\n+                for (final Path path : stream) {\n+                    try {\n+                        final Map<String, List<AppSecrets>> secretsBySiteId = importSecrets(\n+                                path, key);\n+                        for (final Entry<String, List<AppSecrets>> importEntry : secretsBySiteId\n+                                .entrySet()) {\n+                            final String siteId = importEntry.getKey();\n+                            if (Host.SYSTEM_HOST.equalsIgnoreCase(siteId) || findSite(siteId,\n+                                    dotConnect)) {\n+                                final List<AppSecrets> appSecrets = importEntry.getValue();\n+                                for (final AppSecrets secrets : appSecrets) {\n+                                    if (!secrets.getSecrets().isEmpty()) {\n+                                        final AppDescriptor descriptor = descriptorsMap\n+                                                .get(secrets.getKey().toLowerCase());\n+                                        if (null != descriptor) {\n+                                            validateForSave(mapForValidation(secrets), descriptor);\n+                                            final char[] chars = toJsonAsChars(secrets);\n+                                            final String internalKey = internalKey(secrets.getKey(),\n+                                                    siteId);\n+                                            keyStoreHelper.saveValue(internalKey, chars);\n+                                            importCount++;\n+                                        } else {\n+                                            throw new DotDataException(String.format(\n+                                                    \"I cant't import a secret meant for a descriptor `%s` that doesn't exist locally.\",\n+                                                    secrets.getKey()));\n+                                        }\n+                                    } else {\n+                                        throw new DotDataException(\n+                                                \"I cant't import a secret that was generated empty.\");\n+                                    }\n+                                }\n+                            } else {\n+                                throw new DotDataException(String.format(\n+                                        \"I cant't import a secret that belongs into a unknown site `%s`.\",\n+                                        siteId));\n+                            }\n+                        }\n+                    } finally {\n+                        path.toFile().delete();\n+                    }\n+                }\n+            }\n+        } catch (Exception e) {", "originalCommit": "9ef5ee583a85dc22b6cff52fc9766bbeea5da4f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzg5OTc1Nw==", "url": "https://github.com/dotCMS/core/pull/19384#discussion_r507899757", "bodyText": "Codacy found an issue: Use block level rather than method level synchronization", "author": "dev-dotcms", "createdAt": "2020-10-19T16:44:47Z", "path": "dotCMS/src/main/java/com/dotcms/security/apps/SecretsKeyStoreHelper.java", "diffHunk": "@@ -224,41 +200,36 @@ public boolean containsKey(final String variableKey){\n         try {\n            final KeyStore keyStore = getSecretsStore();\n             if (keyStore.containsAlias(variableKey)) {\n-                final PasswordProtection keyStorePP = new PasswordProtection(loadStorePassword());\n+                final PasswordProtection keyStorePP = new PasswordProtection(passwordSupplier.get());\n                 final SecretKeyFactory factory = SecretKeyFactory.getInstance(SECRETS_STORE_SECRET_KEY_FACTORY_TYPE);\n                 final SecretKeyEntry secretKeyEntry = (SecretKeyEntry) keyStore.getEntry(variableKey, keyStorePP);\n                 return ((PBEKeySpec) factory.getKeySpec(secretKeyEntry.getSecretKey(), PBEKeySpec.class)).getPassword();\n             } else {\n-                return CACHE_404;\n+                return null;\n             }\n \n         } catch (Exception e) {\n-            Logger.error(SecretsStoreKeyStoreImpl.class,e);\n+            Logger.error(SecretsKeyStoreHelper.class,e);\n             throw new DotRuntimeException(e);\n         }\n     }\n \n     /**\n-     * Lists all keys.\n-     * Keys will be loaded from cache if available otherwise they will be loaded from disk\n+     * Use this to destroy the secrets repo\n      * @return\n      */\n-    @Override\n-    public Set<String> listKeys() {\n-        return Sneaky.sneak(this::getKeysFromCache);\n+    \n+    public synchronized void destroy(){", "originalCommit": "9ef5ee583a85dc22b6cff52fc9766bbeea5da4f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzg5OTc2Mw==", "url": "https://github.com/dotCMS/core/pull/19384#discussion_r507899763", "bodyText": "Codacy found an issue: Unnecessary use of fully qualified name 'UtilMethods.isSet' due to existing static import 'com.dotmarketing.util.UtilMethods.isSet'", "author": "dev-dotcms", "createdAt": "2020-10-19T16:44:48Z", "path": "dotCMS/src/main/java/com/dotcms/security/apps/AppsUtil.java", "diffHunk": "@@ -217,6 +272,219 @@ public static String digest(final String text) {\n     }\n \n \n+    /**\n+     * Loads the default password stored in the properties\n+     */\n+    public static String loadPass(final Supplier<String> passwordOverride) {\n+        String password = null;\n+        if (null != passwordOverride) {\n+            Logger.info(AppsUtil.class,\"Apps Password Override supplier has been provided.\");\n+            password = passwordOverride.get();\n+        }\n+        if(isNotSet(password)) {\n+            Logger.info(AppsUtil.class,\"Apps Password default will be used.\");\n+            password = Config.getStringProperty(APPS_IMPORT_EXPORT_DEFAULT_PASSWORD);\n+        }\n+        return password;\n+    }\n+\n+    /**\n+     * Ths will return a list of AppSecrets arranged in a map whose key is the site-id\n+     * Therefore we have a Secrets by site\n+     * @param incomingFile\n+     * @param key\n+     * @return\n+     * @throws DotDataException\n+     * @throws IOException\n+     * @throws EncryptorException\n+     */\n+\n+     public static Map<String, List<AppSecrets>> importSecrets(final Path incomingFile, final Key key)\n+            throws DotDataException, IOException {\n+\n+        final byte[] encryptedBytes = Files.readAllBytes(incomingFile);\n+        final byte[] decryptedBytes;\n+        try {\n+            decryptedBytes = AppsUtil.decrypt(key, encryptedBytes);\n+        }catch (EncryptorException e){\n+            throw new IllegalArgumentException(\"An error occurred while decrypting file contents. \",e.getCause());\n+        }\n+        final File importFile = File.createTempFile(\"secrets\", \"export\");\n+        try (OutputStream outputStream = Files.newOutputStream(importFile.toPath())) {\n+            outputStream.write(decryptedBytes);\n+        }\n+        final AppsSecretsImportExport importExport;\n+        try {\n+            importExport = readObject(importFile.toPath());\n+            return importExport.getSecrets();\n+        } catch (ClassNotFoundException e) {\n+            throw new DotDataException(e);\n+        }\n+    }\n+\n+    /**\n+     * Reads the exported file stream\n+     * and returns a wrapper that contains all entries.\n+     * @param importFile\n+     * @return\n+     * @throws IOException\n+     * @throws ClassNotFoundException\n+     */\n+    private static AppsSecretsImportExport readObject(final Path importFile)\n+            throws IOException, ClassNotFoundException {\n+        try(InputStream inputStream = Files.newInputStream(importFile)){\n+            return (AppsSecretsImportExport)new ObjectInputStream(inputStream).readObject();\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @param exportedSecrets\n+     * @param key\n+     * @return\n+     * @throws IOException\n+     * @throws DotDataException\n+     */\n+    static Path exportSecret(final AppsSecretsImportExport exportedSecrets,final Key key)\n+            throws IOException, DotDataException {\n+        final File tempFile = File.createTempFile(\"secretsExport\", \".tmp\");\n+        try {\n+            writeObject(exportedSecrets, tempFile.toPath());\n+            final byte[] bytes = Files.readAllBytes(tempFile.toPath());\n+            try {\n+                final File file = File.createTempFile(\"secrets\", \".export\");\n+                file.deleteOnExit();\n+                final byte[] encrypted = AppsUtil.encrypt(key, bytes);\n+                final Path path = file.toPath();\n+                try (OutputStream outputStream = Files.newOutputStream(path)) {\n+                    outputStream.write(encrypted);\n+                    return path;\n+                }\n+            } catch (EncryptorException e) {\n+                throw new DotDataException(e);\n+            }\n+        } finally {\n+            tempFile.delete();\n+        }\n+    }\n+\n+    /**\n+     * Takes a wrapping object that encapsulates all entries an write'em out ino a stream\n+     * @param bean\n+     * @param file\n+     * @throws IOException\n+     */\n+    private static void writeObject(final AppsSecretsImportExport bean, final Path file)\n+            throws IOException {\n+        try (OutputStream outputStream = Files.newOutputStream(file)) {\n+            try (ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream)) {\n+                objectOutputStream.writeObject(bean);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Map of optionals. Common portable format\n+     */\n+    public static  Map<String, Optional<char[]>> mapForValidation(final AppSecrets appSecrets) {\n+        return appSecrets.getSecrets().entrySet().stream()\n+                .collect(Collectors\n+                        .toMap(Entry::getKey,\n+                                secretEntry -> {\n+                                    final Secret value = secretEntry.getValue();\n+                                    return value == null ? Optional.empty()\n+                                            : Optional.of(value.getValue());\n+                                })\n+                );\n+    }\n+\n+    /**\n+     * Validate the incoming params and match them with the params described by the respective appDescriptor yml.\n+     * This method takes a Map of Optional<char[]> As this is a middle ground object representation\n+     * that can be mapped from a saved  AppSecrets or an incoming SecretForm\n+     * if the param isn't included in the map it means it wasn't sent..\n+     * if the param was sent empty that would be represented as an empty optional.\n+     * I'm using optional since null vales on map triggers warnings\n+     * @param params\n+     * @param appDescriptor\n+     */\n+    public static void validateForSave(final Map<String, Optional<char[]>> params,\n+            final AppDescriptor appDescriptor) {\n+\n+        //Param/Property names are case sensitive.\n+        final Map<String, ParamDescriptor> appDescriptorParams = appDescriptor.getParams();\n+\n+        for (final Entry<String, ParamDescriptor> descriptorParam : appDescriptorParams.entrySet()) {\n+            final String describedParamName = descriptorParam.getKey();\n+            //initialize to null so it is not found in the params map it means it wasn't sent.\n+            char[] input = null;\n+            if (params.containsKey(describedParamName)) {\n+                // if the key is found then verify if there's an actual value or else null\n+                final Optional<char[]> optionalChars = params.get(describedParamName);\n+                input = optionalChars.orElse(null);\n+            }\n+            if (descriptorParam.getValue().isRequired() && (input == null || isNotSet(input))) {\n+                throw new IllegalArgumentException(\n+                        String.format(\n+                                \"Param `%s` is marked required in the descriptor but does not come with a value.\",\n+                                describedParamName\n+                        )\n+                );\n+            }\n+\n+            if (null == input) {\n+                //Param wasn't sent but it doesn't matter since it isn't required.\n+                Logger.debug(AppsAPIImpl.class, () -> String\n+                        .format(\"Non required param `%s` was set.\",\n+                                describedParamName));\n+                continue;\n+            }\n+\n+            if (Type.BOOL.equals(descriptorParam.getValue().getType()) && UtilMethods", "originalCommit": "9ef5ee583a85dc22b6cff52fc9766bbeea5da4f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzg5OTc3NA==", "url": "https://github.com/dotCMS/core/pull/19384#discussion_r507899774", "bodyText": "Codacy found an issue: Unnecessary use of fully qualified name 'Assert.assertTrue' due to existing static import 'org.junit.Assert.assertTrue'", "author": "dev-dotcms", "createdAt": "2020-10-19T16:44:49Z", "path": "dotCMS/src/integration-test/java/com/dotcms/security/apps/AppsAPIImplTest.java", "diffHunk": "@@ -1035,43 +1074,180 @@ public void Test_File_Comparison_Is_Case_Sensitive()\n      */\n     @Test\n     public void Test_Create_Secrets_Then_Export_Them_Then_Import_Then_Save()\n-            throws DotDataException, DotSecurityException, IOException, EncryptorException, ClassNotFoundException {\n+            throws DotDataException, DotSecurityException, IOException, EncryptorException, AlreadyExistException {\n         final User admin = TestUserUtils.getAdminUser();\n         final Host site = new SiteDataGen().nextPersisted();\n         final AppsAPI api = APILocator.getAppsAPI();\n+        //generate a descriptor\n         final AppSecrets.Builder builder1 = new AppSecrets.Builder();\n-        final String appKey = \"appKey-1-Host-1\";\n-        final AppSecrets secrets = builder1.withKey(appKey)\n-                .withHiddenSecret(\"test:secret1\", \"secret-1\")\n-                .withHiddenSecret(\"test:secret2\", \"secret-2\")\n-                .withHiddenSecret(\"test:secret3\", \"secret3\")\n-                .withHiddenSecret(\"test:secret4\", \"secret-4\")\n+        final AppDescriptorDataGen dataGen = new AppDescriptorDataGen()\n+                .stringParam(\"p1\", false,  true)\n+                .stringParam(\"p2\", false,  true)\n+                .withName(\"system-app-example\")\n+                .withDescription(\"system-app\")\n+                .withExtraParameters(false);\n+        final File file = dataGen.nextPersistedDescriptor();\n+        api.createAppDescriptor(file, admin);\n+\n+        final String appKey = dataGen.getKey();\n+        //generate secrets\n+        AppSecrets secrets = builder1.withKey(appKey)\n+                .withHiddenSecret(\"p1\", \"secret-1\")\n+                .withHiddenSecret(\"p2\", \"secret-2\")\n                 .build();\n         //Save it\n         api.saveSecrets(secrets, site, admin);\n         final Optional<AppSecrets> secretsOptional = api.getSecrets(appKey, site, admin);\n-        final AppSecrets appSecretsPostSave = secretsOptional.get();\n+        Assert.assertTrue(secretsOptional.isPresent());", "originalCommit": "9ef5ee583a85dc22b6cff52fc9766bbeea5da4f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzg5OTc4OA==", "url": "https://github.com/dotCMS/core/pull/19384#discussion_r507899788", "bodyText": "Codacy found an issue: Consider using varargs for methods or constructors which take an array the last parameter.", "author": "dev-dotcms", "createdAt": "2020-10-19T16:44:50Z", "path": "dotCMS/src/main/java/com/dotcms/security/apps/SecretsKeyStoreHelper.java", "diffHunk": "@@ -274,35 +245,33 @@ public synchronized boolean deleteAll(){\n      * @throws KeyStoreException\n      * @throws Exception\n      */\n-    @Override\n-    public boolean saveValue(final String variableKey, final char[] variableValue) {\n+\n+    public char [] saveValue(final String variableKey, final char[] variableValue) {", "originalCommit": "9ef5ee583a85dc22b6cff52fc9766bbeea5da4f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzg5OTc5OQ==", "url": "https://github.com/dotCMS/core/pull/19384#discussion_r507899799", "bodyText": "Codacy found an issue: Avoid using Literals in Conditional Statements", "author": "dev-dotcms", "createdAt": "2020-10-19T16:44:51Z", "path": "dotCMS/src/main/java/com/dotcms/security/apps/AppsAPIImpl.java", "diffHunk": "@@ -1064,95 +729,133 @@ private AppsSecretsImportExport collectSecretsForExport(final Map<String, Set<St\n             throws DotDataException, DotSecurityException {\n         final Map<String, List<AppSecrets>> exportedSecrets = new HashMap<>();\n         final Map<String, Set<String>> keysByHost = appKeysByHost();\n-        keysByHost.forEach((siteId, appKeys) -> {\n-            try {\n-                final Host site = hostAPI.find(siteId, user, false);\n-                if (null != site) {\n-\n-                    final Set<String> appKeysBySiteId = paramAppKeysBySite.get(siteId);\n-                    if (isSet(appKeysBySiteId)) {\n-                        for (final String appKey : appKeysBySiteId) {\n-                            final Optional<AppSecrets> optional = getSecrets(appKey, site, user);\n-                            if (optional.isPresent()) {\n-                                final AppSecrets appSecrets = optional.get();\n-                                exportedSecrets\n-                                        .computeIfAbsent(siteId, list -> new LinkedList<>())\n-                                        .add(appSecrets);\n-                            }\n+\n+        if(keysByHost.isEmpty()){\n+           throw new IllegalArgumentException(\"There are no secrets in storage to export. File would be empty. \");\n+        }\n+\n+        for (final Entry<String, Set<String>> entry : paramAppKeysBySite.entrySet()) {\n+            final String siteId = entry.getKey();\n+            final Host site = hostAPI.find(siteId, user, false);\n+            if (null != site) {\n+                final Set<String> appKeysBySiteId = paramAppKeysBySite.get(siteId);\n+                if (isSet(appKeysBySiteId)) {\n+                    for (final String appKey : appKeysBySiteId) {\n+                        final Optional<AppSecrets> optional = getSecrets(appKey, site, user);\n+                        if (optional.isPresent()) {\n+                            final AppSecrets appSecrets = optional.get();\n+                            exportedSecrets\n+                                    .computeIfAbsent(siteId, list -> new LinkedList<>())\n+                                    .add(appSecrets);\n+                        } else {\n+                            throw new IllegalArgumentException(String.format(\"Unable to find secret identified by key `%s` under site `%s` \",appKey, site.getIdentifier()));\n                         }\n                     }\n-                } else {\n-                    Logger.warn(AppsAPIImpl.class,\n-                            String.format(\"Unable to find site `%s` \", siteId));\n                 }\n-            } catch (DotDataException | DotSecurityException e) {\n-                Logger.warn(AppsAPIImpl.class, \"An exception occurred collecting the secrets for export\", e);\n-            }\n-        });\n-        return new AppsSecretsImportExport(\n-                exportedSecrets);\n-    }\n-\n-    /**\n-     * Takes a wrapping object that encapsulates all entries an write'em out ino a stream\n-     * @param bean\n-     * @param file\n-     * @throws IOException\n-     */\n-    private void writeObject(final AppsSecretsImportExport bean, final Path file)\n-            throws IOException {\n-        try (OutputStream outputStream = Files.newOutputStream(file)) {\n-            try (ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream)) {\n-                objectOutputStream.writeObject(bean);\n+            } else {\n+                throw new IllegalArgumentException(String.format(\"Unable to find site `%s` \", siteId));\n             }\n         }\n+        if(exportedSecrets.isEmpty()){\n+            throw new IllegalArgumentException(String.format(\"Unable to collect any secrets for export with the given params `%s` \", paramAppKeysBySite));\n+        }\n+        return new AppsSecretsImportExport(exportedSecrets);\n     }\n \n+\n+\n     /**\n      * {@inheritDoc}\n-     * @param incomingFile\n-     * @param key\n+     * @param incomingFile encrypted file\n+     * @param key security key\n      * @param user\n      * @return\n      * @throws DotDataException\n      * @throws DotSecurityException\n      * @throws IOException\n-     * @throws EncryptorException\n      */\n-   public Map<String, List<AppSecrets>> importSecrets(final Path incomingFile, final Key key, final User user)\n-            throws DotDataException, DotSecurityException, IOException, EncryptorException {\n+    public int importSecretsAndSave(final Path incomingFile, final Key key, final User user)\n+            throws DotDataException, DotSecurityException, IOException {\n+\n         if(!user.isAdmin()){\n             throw new DotSecurityException(\"Only Admins are allowed to perform an export operation.\");\n         }\n \n-        final byte[] encryptedBytes = Files.readAllBytes(incomingFile);\n-        final byte[] decryptedBytes = AppsUtil.decrypt(key, encryptedBytes);\n-        final File importFile = File.createTempFile(\"secrets\", \"export\");\n-        try (OutputStream outputStream = Files.newOutputStream(importFile.toPath())) {\n-            outputStream.write(decryptedBytes);\n+        if(!licenseValiditySupplier.hasValidLicense()){\n+            throw new InvalidLicenseException(\"Apps requires of an enterprise level license.\");\n         }\n-       final AppsSecretsImportExport importExport;\n-       try {\n-           importExport = readObject(importFile.toPath());\n-           return importExport.getSecrets();\n-       } catch (ClassNotFoundException e) {\n-           throw new DotDataException(e);\n-       }\n-    }\n \n-    /**\n-     * Reads the exported file stream\n-     * and returns a wrapper that contains all entries.\n-     * @param importFile\n-     * @return\n-     * @throws IOException\n-     * @throws ClassNotFoundException\n-     */\n-    private AppsSecretsImportExport readObject(final Path importFile)\n-            throws IOException, ClassNotFoundException {\n-        try(InputStream inputStream = Files.newInputStream(importFile)){\n-            return (AppsSecretsImportExport)new ObjectInputStream(inputStream).readObject();\n+        final String failSilentlyMessage = \"These exceptions can be ignored by setting the property `APPS_IMPORT_FAIL_SILENTLY` to true.\";\n+        final boolean failSilently = Config.getBooleanProperty(APPS_IMPORT_FAIL_SILENTLY, false);\n+        int count = 0;\n+        final Map<String, List<AppSecrets>> importedSecretsBySiteId = importSecrets(incomingFile, key);\n+        Logger.info(AppsAPIImpl.class,\n+                \"Number of secrets found: \" + importedSecretsBySiteId.size());\n+        for (final Entry<String, List<AppSecrets>> importEntry : importedSecretsBySiteId\n+                .entrySet()) {\n+            final String siteId = importEntry.getKey();\n+            final Host site = hostAPI.find(siteId, user, false);\n+            if (null == site) {\n+                if (failSilently) {\n+                    Logger.warn(AppsAPIImpl.class, () -> String\n+                            .format(\"No site identified by `%s` was found locally.\", siteId));\n+                    continue;\n+                }\n+                throw new IllegalArgumentException(\n+                        String.format(\"No site identified by `%s` was found locally.\\n %s\", siteId,\n+                                failSilentlyMessage));\n+            }\n+\n+            for (final AppSecrets appSecrets : importEntry.getValue()) {\n+                final Optional<AppDescriptor> appDescriptor = getAppDescriptor(appSecrets.getKey(),\n+                        user);\n+                if (!appDescriptor.isPresent()) {\n+                    if (failSilently) {\n+                        Logger.warn(AppsAPIImpl.class, () -> String\n+                                .format(\"No App Descriptor `%s` was found locally.\",\n+                                        appSecrets.getKey()));\n+                        continue;\n+                    }\n+                    throw new IllegalArgumentException(\n+                            String.format(\"No App Descriptor `%s` was found locally.\\n %s\",\n+                                    appSecrets.getKey(), failSilentlyMessage));\n+                }\n+\n+                if (appSecrets.getSecrets().isEmpty()) {\n+                    if (failSilently) {\n+                        Logger.warn(AppsAPIImpl.class, () -> String\n+                                .format(\"Incoming empty secret `%s` will be skipped.\",\n+                                        appSecrets.getKey()));\n+                        continue;\n+                    }\n+                    throw new IllegalArgumentException(\n+                            String.format(\"Incoming empty secret `%s` could replace local copy.\\n %s \",\n+                                    appSecrets.getKey(), failSilentlyMessage));\n+                }\n+                try {\n+                    validateForSave(mapForValidation(appSecrets), appDescriptor.get());\n+                } catch (IllegalArgumentException ae) {\n+                    if (failSilently) {\n+                        Logger.warn(AppsAPIImpl.class, () -> String\n+                                .format(\"Incoming secret `%s` has validation issues with local descriptor will be skipped.\",\n+                                        appSecrets.getKey()));\n+                        continue;\n+                    }\n+                    throw new IllegalArgumentException(\n+                            String.format(\n+                                    \"Incoming secret `%s` has validation issues with local descriptor.\\n %s \",\n+                                    appSecrets.getKey(), failSilentlyMessage),\n+                            ae);\n+                }\n+                Logger.info(AppsAPIImpl.class, String.format(\"Imported secret `%s` \", appSecrets));\n+                saveSecrets(appSecrets, site, user);\n+                count++;\n+            }\n+        }\n+        if(count >= 1){", "originalCommit": "9ef5ee583a85dc22b6cff52fc9766bbeea5da4f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzg5OTgxMA==", "url": "https://github.com/dotCMS/core/pull/19384#discussion_r507899810", "bodyText": "Codacy found an issue: Useless parentheses.", "author": "dev-dotcms", "createdAt": "2020-10-19T16:44:52Z", "path": "dotCMS/src/main/java/com/dotcms/security/apps/AppsUtil.java", "diffHunk": "@@ -217,6 +272,219 @@ public static String digest(final String text) {\n     }\n \n \n+    /**\n+     * Loads the default password stored in the properties\n+     */\n+    public static String loadPass(final Supplier<String> passwordOverride) {\n+        String password = null;\n+        if (null != passwordOverride) {\n+            Logger.info(AppsUtil.class,\"Apps Password Override supplier has been provided.\");\n+            password = passwordOverride.get();\n+        }\n+        if(isNotSet(password)) {\n+            Logger.info(AppsUtil.class,\"Apps Password default will be used.\");\n+            password = Config.getStringProperty(APPS_IMPORT_EXPORT_DEFAULT_PASSWORD);\n+        }\n+        return password;\n+    }\n+\n+    /**\n+     * Ths will return a list of AppSecrets arranged in a map whose key is the site-id\n+     * Therefore we have a Secrets by site\n+     * @param incomingFile\n+     * @param key\n+     * @return\n+     * @throws DotDataException\n+     * @throws IOException\n+     * @throws EncryptorException\n+     */\n+\n+     public static Map<String, List<AppSecrets>> importSecrets(final Path incomingFile, final Key key)\n+            throws DotDataException, IOException {\n+\n+        final byte[] encryptedBytes = Files.readAllBytes(incomingFile);\n+        final byte[] decryptedBytes;\n+        try {\n+            decryptedBytes = AppsUtil.decrypt(key, encryptedBytes);\n+        }catch (EncryptorException e){\n+            throw new IllegalArgumentException(\"An error occurred while decrypting file contents. \",e.getCause());\n+        }\n+        final File importFile = File.createTempFile(\"secrets\", \"export\");\n+        try (OutputStream outputStream = Files.newOutputStream(importFile.toPath())) {\n+            outputStream.write(decryptedBytes);\n+        }\n+        final AppsSecretsImportExport importExport;\n+        try {\n+            importExport = readObject(importFile.toPath());\n+            return importExport.getSecrets();\n+        } catch (ClassNotFoundException e) {\n+            throw new DotDataException(e);\n+        }\n+    }\n+\n+    /**\n+     * Reads the exported file stream\n+     * and returns a wrapper that contains all entries.\n+     * @param importFile\n+     * @return\n+     * @throws IOException\n+     * @throws ClassNotFoundException\n+     */\n+    private static AppsSecretsImportExport readObject(final Path importFile)\n+            throws IOException, ClassNotFoundException {\n+        try(InputStream inputStream = Files.newInputStream(importFile)){\n+            return (AppsSecretsImportExport)new ObjectInputStream(inputStream).readObject();\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @param exportedSecrets\n+     * @param key\n+     * @return\n+     * @throws IOException\n+     * @throws DotDataException\n+     */\n+    static Path exportSecret(final AppsSecretsImportExport exportedSecrets,final Key key)\n+            throws IOException, DotDataException {\n+        final File tempFile = File.createTempFile(\"secretsExport\", \".tmp\");\n+        try {\n+            writeObject(exportedSecrets, tempFile.toPath());\n+            final byte[] bytes = Files.readAllBytes(tempFile.toPath());\n+            try {\n+                final File file = File.createTempFile(\"secrets\", \".export\");\n+                file.deleteOnExit();\n+                final byte[] encrypted = AppsUtil.encrypt(key, bytes);\n+                final Path path = file.toPath();\n+                try (OutputStream outputStream = Files.newOutputStream(path)) {\n+                    outputStream.write(encrypted);\n+                    return path;\n+                }\n+            } catch (EncryptorException e) {\n+                throw new DotDataException(e);\n+            }\n+        } finally {\n+            tempFile.delete();\n+        }\n+    }\n+\n+    /**\n+     * Takes a wrapping object that encapsulates all entries an write'em out ino a stream\n+     * @param bean\n+     * @param file\n+     * @throws IOException\n+     */\n+    private static void writeObject(final AppsSecretsImportExport bean, final Path file)\n+            throws IOException {\n+        try (OutputStream outputStream = Files.newOutputStream(file)) {\n+            try (ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream)) {\n+                objectOutputStream.writeObject(bean);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Map of optionals. Common portable format\n+     */\n+    public static  Map<String, Optional<char[]>> mapForValidation(final AppSecrets appSecrets) {\n+        return appSecrets.getSecrets().entrySet().stream()\n+                .collect(Collectors\n+                        .toMap(Entry::getKey,\n+                                secretEntry -> {\n+                                    final Secret value = secretEntry.getValue();\n+                                    return value == null ? Optional.empty()\n+                                            : Optional.of(value.getValue());\n+                                })\n+                );\n+    }\n+\n+    /**\n+     * Validate the incoming params and match them with the params described by the respective appDescriptor yml.\n+     * This method takes a Map of Optional<char[]> As this is a middle ground object representation\n+     * that can be mapped from a saved  AppSecrets or an incoming SecretForm\n+     * if the param isn't included in the map it means it wasn't sent..\n+     * if the param was sent empty that would be represented as an empty optional.\n+     * I'm using optional since null vales on map triggers warnings\n+     * @param params\n+     * @param appDescriptor\n+     */\n+    public static void validateForSave(final Map<String, Optional<char[]>> params,\n+            final AppDescriptor appDescriptor) {\n+\n+        //Param/Property names are case sensitive.\n+        final Map<String, ParamDescriptor> appDescriptorParams = appDescriptor.getParams();\n+\n+        for (final Entry<String, ParamDescriptor> descriptorParam : appDescriptorParams.entrySet()) {\n+            final String describedParamName = descriptorParam.getKey();\n+            //initialize to null so it is not found in the params map it means it wasn't sent.\n+            char[] input = null;\n+            if (params.containsKey(describedParamName)) {\n+                // if the key is found then verify if there's an actual value or else null\n+                final Optional<char[]> optionalChars = params.get(describedParamName);\n+                input = optionalChars.orElse(null);\n+            }\n+            if (descriptorParam.getValue().isRequired() && (input == null || isNotSet(input))) {\n+                throw new IllegalArgumentException(\n+                        String.format(\n+                                \"Param `%s` is marked required in the descriptor but does not come with a value.\",\n+                                describedParamName\n+                        )\n+                );\n+            }\n+\n+            if (null == input) {\n+                //Param wasn't sent but it doesn't matter since it isn't required.\n+                Logger.debug(AppsAPIImpl.class, () -> String\n+                        .format(\"Non required param `%s` was set.\",\n+                                describedParamName));\n+                continue;\n+            }\n+\n+            if (Type.BOOL.equals(descriptorParam.getValue().getType()) && UtilMethods\n+                    .isSet(input)) {\n+                final String asString = new String(input);\n+                final boolean bool = (asString.equalsIgnoreCase(Boolean.TRUE.toString())", "originalCommit": "9ef5ee583a85dc22b6cff52fc9766bbeea5da4f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzg5OTgxNw==", "url": "https://github.com/dotCMS/core/pull/19384#discussion_r507899817", "bodyText": "Codacy found an issue: Consider using varargs for methods or constructors which take an array the last parameter.", "author": "dev-dotcms", "createdAt": "2020-10-19T16:44:53Z", "path": "dotCMS/src/main/java/com/dotcms/security/apps/SecretCachedKeyStoreImpl.java", "diffHunk": "@@ -0,0 +1,204 @@\n+package com.dotcms.security.apps;\n+\n+import static com.dotcms.security.apps.AppsCache.CACHE_404;\n+import static com.dotcms.security.apps.AppsUtil.digest;\n+import static com.dotcms.security.apps.SecretsKeyStoreHelper.SECRETS_KEYSTORE_PASSWORD_KEY;\n+\n+import com.dotcms.enterprise.cluster.ClusterFactory;\n+import com.dotmarketing.business.CacheLocator;\n+import com.dotmarketing.business.DotCacheException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.util.Config;\n+import com.dotmarketing.util.Logger;\n+import com.google.common.collect.ImmutableList;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import java.io.IOException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Supplier;\n+\n+/**\n+ * This is basically a safe repository implemented using java.security.KeyStore\n+ * Which according to the official Java documentation Represents a storage facility for cryptographic keys and certificates.\n+ * This Class serves as the entry point to the repository whose implantation really resides in SecretsKeyStoreHelper\n+ * This class adds caching\n+ */\n+public class SecretCachedKeyStoreImpl implements SecretsStore {\n+\n+    private final SecretsKeyStoreHelper secretsKeyStore;\n+    private final AppsCache cache;\n+\n+    SecretCachedKeyStoreImpl(final AppsCache cache) {\n+        this.secretsKeyStore = new SecretsKeyStoreHelper(() -> cache\n+                .getFromCache(SECRETS_KEYSTORE_PASSWORD_KEY, () -> Config\n+                        .getStringProperty(SECRETS_KEYSTORE_PASSWORD_KEY,\n+                                digest(ClusterFactory.getClusterSalt())).toCharArray()),\n+                ImmutableList.of(this::flushCache));\n+        this.cache = cache;\n+    }\n+\n+    public SecretCachedKeyStoreImpl() {\n+       this(CacheLocator.getAppsCache());\n+    }\n+\n+    /**\n+     * Verifies if the key exists in the store\n+     * @param variableKey\n+     * @return\n+     */\n+    @Override\n+    public boolean containsKey(final String variableKey) {\n+        try {\n+            return getKeysFromCache().contains(variableKey);\n+        } catch (Exception e) {\n+            Logger.debug(SecretCachedKeyStoreImpl.class,e.getMessage());\n+            throw new DotRuntimeException(e);\n+        }\n+    }\n+\n+    /**\n+     * while in cache it must be encrypted!\n+     * once returned from this method it should get decrypted\n+     * @param variableKey\n+     * @return\n+     */\n+    @Override\n+    public Optional<char[]> getValue(final String variableKey) {\n+        final char[] fromCache = getFromCache(variableKey,\n+                () -> secretsKeyStore.getValue(variableKey));\n+        return Arrays.equals(fromCache, CACHE_404) ? Optional.empty()\n+                : Optional.ofNullable(secretsKeyStore.decrypt(fromCache));\n+    }\n+\n+    /**\n+     * Lists all keys.\n+     * Keys will be loaded from cache if available otherwise they will be loaded from disk\n+     * @return\n+     */\n+    @Override\n+    public Set<String> listKeys() {\n+        return Sneaky.sneak(this::getKeysFromCache);\n+    }\n+\n+    @Override\n+    public boolean deleteAll() throws Exception {\n+        secretsKeyStore.destroy();\n+        flushCache();\n+        return true;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param variableKey\n+     * @param variableValue\n+     * @return\n+     */\n+    @Override\n+    public boolean saveValue(final String variableKey, final char[] variableValue) {\n+        try {\n+            putInCache(variableKey, secretsKeyStore.saveValue(variableKey, variableValue));\n+        } catch (DotCacheException e) {\n+            Logger.warn(SecretCachedKeyStoreImpl.class, \"Unable to save secret in cache \" ,e);\n+            throw new DotRuntimeException(e.getMessage(), e);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param secretKey\n+     */\n+    @Override\n+    public void deleteValue(final String secretKey) {\n+        secretsKeyStore.deleteValue(secretKey);\n+        try{\n+            flushCache(secretKey);\n+        } catch (DotCacheException e) {\n+            Logger.warn(SecretCachedKeyStoreImpl.class, \"Error flushing cache while removing value from secrets store \", e);\n+            throw new DotRuntimeException(e);\n+        }\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void backupAndRemoveKeyStore() throws IOException {\n+        secretsKeyStore.backupAndRemoveKeyStore();\n+    }\n+\n+    /**\n+     * Short hand accessor to get values from cache impl\n+     * @param key\n+     * @param defaultValue\n+     * @return\n+     */\n+    private char[] getFromCache(final String key, final Supplier<char[]> defaultValue) {\n+        return cache.getFromCache(key, defaultValue);\n+    }\n+\n+    /**\n+     * Short hand accessor to put values in cache impl\n+     * @param key\n+     * @param val\n+     * @throws DotCacheException\n+     */\n+    private void putInCache(final String key, final char[] val)", "originalCommit": "9ef5ee583a85dc22b6cff52fc9766bbeea5da4f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzg5OTgzMQ==", "url": "https://github.com/dotCMS/core/pull/19384#discussion_r507899831", "bodyText": "Codacy found an issue: Useless parentheses.", "author": "dev-dotcms", "createdAt": "2020-10-19T16:44:54Z", "path": "dotCMS/src/integration-test/java/com/dotcms/security/apps/SecretsStoreKeyStoreImplTest.java", "diffHunk": "@@ -208,9 +206,9 @@ public void Test_Value_List() {\n     @Test\n     public void Test_Encryption() {\n         final String uuid = UUIDGenerator.generateUuid();\n-        final SecretsStore secretsStore = SecretsStore.INSTANCE.get();\n-        final char[] encrypted = ((SecretsStoreKeyStoreImpl) secretsStore).encrypt(uuid.toCharArray());\n-        assertEquals(uuid,new String(((SecretsStoreKeyStoreImpl) secretsStore).decrypt(encrypted)));\n+        SecretsKeyStoreHelper secretsStore = new SecretsKeyStoreHelper();\n+        final char[] encrypted = secretsStore.encrypt(uuid.toCharArray());\n+        assertEquals(uuid,new String((secretsStore).decrypt(encrypted)));", "originalCommit": "9ef5ee583a85dc22b6cff52fc9766bbeea5da4f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzg5OTg0Nw==", "url": "https://github.com/dotCMS/core/pull/19384#discussion_r507899847", "bodyText": "Codacy found an issue: Avoid using redundant field initializer for 'key'", "author": "dev-dotcms", "createdAt": "2020-10-19T16:44:55Z", "path": "dotCMS/src/main/java/com/dotcms/rest/api/v1/apps/AppsHelper.java", "diffHunk": "@@ -737,40 +680,99 @@ InputStream exportSecrets(final ExportSecretForm form, final User user)\n      * @throws IOException\n      * @throws DotDataException\n      * @throws JSONException\n-     * @throws DotSecurityException\n-     * @throws EncryptorException\n-     * @throws ClassNotFoundException\n      */\n     void importSecrets(final FormDataMultiPart multipart, final User user)\n-            throws IOException, DotDataException, JSONException, DotSecurityException, EncryptorException, ClassNotFoundException {\n+            throws IOException, DotDataException, JSONException {\n+\n+        processMultipart(multipart, new FileConsumer<Void>() {\n+            private Key key = null;", "originalCommit": "9ef5ee583a85dc22b6cff52fc9766bbeea5da4f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzg5OTg2NA==", "url": "https://github.com/dotCMS/core/pull/19384#discussion_r507899864", "bodyText": "Codacy found an issue: New exception is thrown in catch block, original stack trace may be lost", "author": "dev-dotcms", "createdAt": "2020-10-19T16:44:56Z", "path": "dotCMS/src/main/java/com/dotcms/security/apps/AppsUtil.java", "diffHunk": "@@ -217,6 +272,219 @@ public static String digest(final String text) {\n     }\n \n \n+    /**\n+     * Loads the default password stored in the properties\n+     */\n+    public static String loadPass(final Supplier<String> passwordOverride) {\n+        String password = null;\n+        if (null != passwordOverride) {\n+            Logger.info(AppsUtil.class,\"Apps Password Override supplier has been provided.\");\n+            password = passwordOverride.get();\n+        }\n+        if(isNotSet(password)) {\n+            Logger.info(AppsUtil.class,\"Apps Password default will be used.\");\n+            password = Config.getStringProperty(APPS_IMPORT_EXPORT_DEFAULT_PASSWORD);\n+        }\n+        return password;\n+    }\n+\n+    /**\n+     * Ths will return a list of AppSecrets arranged in a map whose key is the site-id\n+     * Therefore we have a Secrets by site\n+     * @param incomingFile\n+     * @param key\n+     * @return\n+     * @throws DotDataException\n+     * @throws IOException\n+     * @throws EncryptorException\n+     */\n+\n+     public static Map<String, List<AppSecrets>> importSecrets(final Path incomingFile, final Key key)\n+            throws DotDataException, IOException {\n+\n+        final byte[] encryptedBytes = Files.readAllBytes(incomingFile);\n+        final byte[] decryptedBytes;\n+        try {\n+            decryptedBytes = AppsUtil.decrypt(key, encryptedBytes);\n+        }catch (EncryptorException e){\n+            throw new IllegalArgumentException(\"An error occurred while decrypting file contents. \",e.getCause());", "originalCommit": "9ef5ee583a85dc22b6cff52fc9766bbeea5da4f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzg5OTg3Ng==", "url": "https://github.com/dotCMS/core/pull/19384#discussion_r507899876", "bodyText": "Codacy found an issue: Unnecessary use of fully qualified name 'UtilMethods.isSet' due to existing static import 'com.dotmarketing.util.UtilMethods.isSet'", "author": "dev-dotcms", "createdAt": "2020-10-19T16:44:57Z", "path": "dotCMS/src/main/java/com/dotcms/security/apps/AppsUtil.java", "diffHunk": "@@ -217,6 +272,219 @@ public static String digest(final String text) {\n     }\n \n \n+    /**\n+     * Loads the default password stored in the properties\n+     */\n+    public static String loadPass(final Supplier<String> passwordOverride) {\n+        String password = null;\n+        if (null != passwordOverride) {\n+            Logger.info(AppsUtil.class,\"Apps Password Override supplier has been provided.\");\n+            password = passwordOverride.get();\n+        }\n+        if(isNotSet(password)) {\n+            Logger.info(AppsUtil.class,\"Apps Password default will be used.\");\n+            password = Config.getStringProperty(APPS_IMPORT_EXPORT_DEFAULT_PASSWORD);\n+        }\n+        return password;\n+    }\n+\n+    /**\n+     * Ths will return a list of AppSecrets arranged in a map whose key is the site-id\n+     * Therefore we have a Secrets by site\n+     * @param incomingFile\n+     * @param key\n+     * @return\n+     * @throws DotDataException\n+     * @throws IOException\n+     * @throws EncryptorException\n+     */\n+\n+     public static Map<String, List<AppSecrets>> importSecrets(final Path incomingFile, final Key key)\n+            throws DotDataException, IOException {\n+\n+        final byte[] encryptedBytes = Files.readAllBytes(incomingFile);\n+        final byte[] decryptedBytes;\n+        try {\n+            decryptedBytes = AppsUtil.decrypt(key, encryptedBytes);\n+        }catch (EncryptorException e){\n+            throw new IllegalArgumentException(\"An error occurred while decrypting file contents. \",e.getCause());\n+        }\n+        final File importFile = File.createTempFile(\"secrets\", \"export\");\n+        try (OutputStream outputStream = Files.newOutputStream(importFile.toPath())) {\n+            outputStream.write(decryptedBytes);\n+        }\n+        final AppsSecretsImportExport importExport;\n+        try {\n+            importExport = readObject(importFile.toPath());\n+            return importExport.getSecrets();\n+        } catch (ClassNotFoundException e) {\n+            throw new DotDataException(e);\n+        }\n+    }\n+\n+    /**\n+     * Reads the exported file stream\n+     * and returns a wrapper that contains all entries.\n+     * @param importFile\n+     * @return\n+     * @throws IOException\n+     * @throws ClassNotFoundException\n+     */\n+    private static AppsSecretsImportExport readObject(final Path importFile)\n+            throws IOException, ClassNotFoundException {\n+        try(InputStream inputStream = Files.newInputStream(importFile)){\n+            return (AppsSecretsImportExport)new ObjectInputStream(inputStream).readObject();\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @param exportedSecrets\n+     * @param key\n+     * @return\n+     * @throws IOException\n+     * @throws DotDataException\n+     */\n+    static Path exportSecret(final AppsSecretsImportExport exportedSecrets,final Key key)\n+            throws IOException, DotDataException {\n+        final File tempFile = File.createTempFile(\"secretsExport\", \".tmp\");\n+        try {\n+            writeObject(exportedSecrets, tempFile.toPath());\n+            final byte[] bytes = Files.readAllBytes(tempFile.toPath());\n+            try {\n+                final File file = File.createTempFile(\"secrets\", \".export\");\n+                file.deleteOnExit();\n+                final byte[] encrypted = AppsUtil.encrypt(key, bytes);\n+                final Path path = file.toPath();\n+                try (OutputStream outputStream = Files.newOutputStream(path)) {\n+                    outputStream.write(encrypted);\n+                    return path;\n+                }\n+            } catch (EncryptorException e) {\n+                throw new DotDataException(e);\n+            }\n+        } finally {\n+            tempFile.delete();\n+        }\n+    }\n+\n+    /**\n+     * Takes a wrapping object that encapsulates all entries an write'em out ino a stream\n+     * @param bean\n+     * @param file\n+     * @throws IOException\n+     */\n+    private static void writeObject(final AppsSecretsImportExport bean, final Path file)\n+            throws IOException {\n+        try (OutputStream outputStream = Files.newOutputStream(file)) {\n+            try (ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream)) {\n+                objectOutputStream.writeObject(bean);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Map of optionals. Common portable format\n+     */\n+    public static  Map<String, Optional<char[]>> mapForValidation(final AppSecrets appSecrets) {\n+        return appSecrets.getSecrets().entrySet().stream()\n+                .collect(Collectors\n+                        .toMap(Entry::getKey,\n+                                secretEntry -> {\n+                                    final Secret value = secretEntry.getValue();\n+                                    return value == null ? Optional.empty()\n+                                            : Optional.of(value.getValue());\n+                                })\n+                );\n+    }\n+\n+    /**\n+     * Validate the incoming params and match them with the params described by the respective appDescriptor yml.\n+     * This method takes a Map of Optional<char[]> As this is a middle ground object representation\n+     * that can be mapped from a saved  AppSecrets or an incoming SecretForm\n+     * if the param isn't included in the map it means it wasn't sent..\n+     * if the param was sent empty that would be represented as an empty optional.\n+     * I'm using optional since null vales on map triggers warnings\n+     * @param params\n+     * @param appDescriptor\n+     */\n+    public static void validateForSave(final Map<String, Optional<char[]>> params,\n+            final AppDescriptor appDescriptor) {\n+\n+        //Param/Property names are case sensitive.\n+        final Map<String, ParamDescriptor> appDescriptorParams = appDescriptor.getParams();\n+\n+        for (final Entry<String, ParamDescriptor> descriptorParam : appDescriptorParams.entrySet()) {\n+            final String describedParamName = descriptorParam.getKey();\n+            //initialize to null so it is not found in the params map it means it wasn't sent.\n+            char[] input = null;\n+            if (params.containsKey(describedParamName)) {\n+                // if the key is found then verify if there's an actual value or else null\n+                final Optional<char[]> optionalChars = params.get(describedParamName);\n+                input = optionalChars.orElse(null);\n+            }\n+            if (descriptorParam.getValue().isRequired() && (input == null || isNotSet(input))) {\n+                throw new IllegalArgumentException(\n+                        String.format(\n+                                \"Param `%s` is marked required in the descriptor but does not come with a value.\",\n+                                describedParamName\n+                        )\n+                );\n+            }\n+\n+            if (null == input) {\n+                //Param wasn't sent but it doesn't matter since it isn't required.\n+                Logger.debug(AppsAPIImpl.class, () -> String\n+                        .format(\"Non required param `%s` was set.\",\n+                                describedParamName));\n+                continue;\n+            }\n+\n+            if (Type.BOOL.equals(descriptorParam.getValue().getType()) && UtilMethods\n+                    .isSet(input)) {\n+                final String asString = new String(input);\n+                final boolean bool = (asString.equalsIgnoreCase(Boolean.TRUE.toString())\n+                        || asString.equalsIgnoreCase(Boolean.FALSE.toString()));\n+                if (!bool) {\n+                    throw new IllegalArgumentException(\n+                            String.format(\n+                                    \"Can not convert value `%s` to type BOOL for param `%s`.\",\n+                                    asString, describedParamName\n+                            )\n+                    );\n+                }\n+            }\n+\n+            if (Type.SELECT.equals(descriptorParam.getValue().getType()) && UtilMethods", "originalCommit": "9ef5ee583a85dc22b6cff52fc9766bbeea5da4f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzg5OTg4Ng==", "url": "https://github.com/dotCMS/core/pull/19384#discussion_r507899886", "bodyText": "Codacy found an issue: Consider using varargs for methods or constructors which take an array the last parameter.", "author": "dev-dotcms", "createdAt": "2020-10-19T16:44:58Z", "path": "dotCMS/src/main/java/com/dotcms/security/apps/SecretsKeyStoreHelper.java", "diffHunk": "@@ -341,27 +311,17 @@ private String getCustomKeyProvider() {\n      * @return\n      */\n     @VisibleForTesting\n-    protected char[] encrypt(final char[] val) {\n+    char[] encrypt(final char[] val) {", "originalCommit": "9ef5ee583a85dc22b6cff52fc9766bbeea5da4f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzg5OTg5NA==", "url": "https://github.com/dotCMS/core/pull/19384#discussion_r507899894", "bodyText": "Codacy found an issue: Consider using varargs for methods or constructors which take an array the last parameter.", "author": "dev-dotcms", "createdAt": "2020-10-19T16:44:59Z", "path": "dotCMS/src/main/java/com/dotcms/security/apps/SecretsKeyStoreHelper.java", "diffHunk": "@@ -374,89 +334,20 @@ protected String digest(final String val) {\n      * @return\n      */\n     @VisibleForTesting\n-    protected char[] decrypt(final char[] encryptedString) {\n+    char[] decrypt(final char[] encryptedString) {", "originalCommit": "9ef5ee583a85dc22b6cff52fc9766bbeea5da4f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}