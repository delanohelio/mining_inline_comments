{"pr_number": 55, "pr_title": "Lifecycle IPC service implementation", "pr_createdAt": "2020-02-06T23:42:55Z", "pr_url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/55", "timeline": [{"oid": "ab6f8dfec7edcc9949b5e055a759540b3e6787d4", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ab6f8dfec7edcc9949b5e055a759540b3e6787d4", "message": "Lifecycle IPC", "committedDate": "2020-02-07T00:00:32Z", "type": "forcePushed"}, {"oid": "ee259a9514a37081b4ae473210785b65cee3c906", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ee259a9514a37081b4ae473210785b65cee3c906", "message": "Lifecycle IPC", "committedDate": "2020-02-10T21:22:53Z", "type": "forcePushed"}, {"oid": "b8271568a10bbeb2c2761a16302c5f9a62e7233d", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/b8271568a10bbeb2c2761a16302c5f9a62e7233d", "message": "Lifecycle IPC", "committedDate": "2020-02-10T22:39:16Z", "type": "forcePushed"}, {"oid": "0b91ab0008d725d223aeecc83009bd21aa72697e", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/0b91ab0008d725d223aeecc83009bd21aa72697e", "message": "Lifecycle IPC", "committedDate": "2020-02-11T00:41:05Z", "type": "forcePushed"}, {"oid": "0206eb5c791c46b96dea20fef8a6a6f7377692ab", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/0206eb5c791c46b96dea20fef8a6a6f7377692ab", "message": "Lifecycle IPC", "committedDate": "2020-02-13T00:11:50Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTExMjkwMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/55#discussion_r379112903", "bodyText": "Also add super.postInject();", "author": "leaf94", "createdAt": "2020-02-13T20:54:34Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/LifecycleIPCAgent.java", "diffHunk": "@@ -0,0 +1,149 @@\n+package com.aws.iot.evergreen.builtin.services.lifecycle;\n+\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.ipc.ConnectionHandle;\n+import com.aws.iot.evergreen.ipc.IPCRouter;\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+import com.aws.iot.evergreen.ipc.common.RequestContext;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralRequest;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralResponse;\n+import com.aws.iot.evergreen.ipc.services.common.IPCUtil;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleListenRequest;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleRequestTypes;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleResponseStatus;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.StateChangeRequest;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.StateTransitionEvent;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.function.BiConsumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.ipc.services.lifecycle.Lifecycle.LIFECYCLE_SERVICE_NAME;\n+\n+/**\n+ * Class to handle business logic for all Lifecycle requests over IPC.\n+ */\n+public class LifecycleIPCAgent implements InjectionActions {\n+    private static final Map<String, Map<RequestContext, BiConsumer<State, State>>> listeners =\n+            new ConcurrentHashMap<>();\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private IPCRouter router;\n+\n+    @Inject\n+    private ExecutorService executor;\n+\n+    private EvergreenService.GlobalStateChangeListener onServiceChange = (service, prev) -> {\n+        Map<RequestContext, BiConsumer<State, State>> callbacks = listeners.get(service.getName());\n+        if (callbacks != null) {\n+            callbacks.values().forEach(x -> x.accept(prev, service.getState()));\n+        }\n+    };\n+\n+    public LifecycleIPCAgent() {\n+    }\n+\n+    @Override\n+    public void postInject() {\n+        kernel.context.addGlobalStateChangeListener(onServiceChange);", "originalCommit": "0206eb5c791c46b96dea20fef8a6a6f7377692ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTExOTcxMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/55#discussion_r379119712", "bodyText": "Can do, although the super doesn't do anything.", "author": "MikeDombo", "createdAt": "2020-02-13T21:09:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTExMjkwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTEzMTI5Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/55#discussion_r379131296", "bodyText": "Oh my bad. I thought this extends EvergreenService, the that is essential. No need to do it here", "author": "leaf94", "createdAt": "2020-02-13T21:34:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTExMjkwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTExNzgwMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/55#discussion_r379117802", "bodyText": "Any specific reason for using context here as key, instead of sourceServiceName?", "author": "leaf94", "createdAt": "2020-02-13T21:05:29Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/LifecycleIPCAgent.java", "diffHunk": "@@ -0,0 +1,149 @@\n+package com.aws.iot.evergreen.builtin.services.lifecycle;\n+\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.ipc.ConnectionHandle;\n+import com.aws.iot.evergreen.ipc.IPCRouter;\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+import com.aws.iot.evergreen.ipc.common.RequestContext;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralRequest;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralResponse;\n+import com.aws.iot.evergreen.ipc.services.common.IPCUtil;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleListenRequest;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleRequestTypes;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleResponseStatus;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.StateChangeRequest;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.StateTransitionEvent;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.function.BiConsumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.ipc.services.lifecycle.Lifecycle.LIFECYCLE_SERVICE_NAME;\n+\n+/**\n+ * Class to handle business logic for all Lifecycle requests over IPC.\n+ */\n+public class LifecycleIPCAgent implements InjectionActions {\n+    private static final Map<String, Map<RequestContext, BiConsumer<State, State>>> listeners =\n+            new ConcurrentHashMap<>();\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private IPCRouter router;\n+\n+    @Inject\n+    private ExecutorService executor;\n+\n+    private EvergreenService.GlobalStateChangeListener onServiceChange = (service, prev) -> {\n+        Map<RequestContext, BiConsumer<State, State>> callbacks = listeners.get(service.getName());\n+        if (callbacks != null) {\n+            callbacks.values().forEach(x -> x.accept(prev, service.getState()));\n+        }\n+    };\n+\n+    public LifecycleIPCAgent() {\n+    }\n+\n+    @Override\n+    public void postInject() {\n+        kernel.context.addGlobalStateChangeListener(onServiceChange);\n+    }\n+\n+    /**\n+     * Report the state of the service which the request is coming from.\n+     *\n+     * @param req incoming request\n+     * @param context caller context\n+     * @return response for setting state\n+     */\n+    public GeneralResponse<Void, LifecycleResponseStatus> reportState(StateChangeRequest req, RequestContext context) {\n+        State s = State.valueOf(req.getState());\n+        Optional<EvergreenService> service =\n+                Optional.ofNullable(kernel.context.get(EvergreenService.class, context.getServiceName()));\n+\n+        GeneralResponse<Void, LifecycleResponseStatus> resp = new GeneralResponse<>();\n+        if (service.isPresent()) {\n+            service.get().setState(s);\n+            resp.setError(LifecycleResponseStatus.Success);\n+        } else {\n+            resp.setError(LifecycleResponseStatus.InvalidRequest);\n+            resp.setErrorMessage(\"Service could not be found\");\n+        }\n+\n+        return resp;\n+    }\n+\n+    /**\n+     * Set up a listener for state changes for a requested service. (Currently any service can listen to any other\n+     * service's lifecyle changes).\n+     *\n+     * @param listenRequest incoming listen request\n+     * @param context caller context\n+     * @return response\n+     */\n+    public GeneralResponse<Void, LifecycleResponseStatus> listen(LifecycleListenRequest listenRequest,\n+                                                                 RequestContext context) {\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        listeners.compute(listenRequest.getServiceName(), (key, old) -> {\n+            if (old == null) {\n+                old = new ConcurrentHashMap<>();\n+            }\n+            old.put(context, sendStateUpdateToListener(listenRequest, context));", "originalCommit": "0206eb5c791c46b96dea20fef8a6a6f7377692ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTEyMDAxNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/55#discussion_r379120014", "bodyText": "Yes, because the source service could have created multiple IPC clients. The context is unique to a single connection, whereas the service name is not.", "author": "MikeDombo", "createdAt": "2020-02-13T21:10:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTExNzgwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTEyNzUzMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/55#discussion_r379127532", "bodyText": "I'd prefer renaming RequestContext into something like IPCClientConnectionContext", "author": "ShirleyZheng92", "createdAt": "2020-02-13T21:26:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTExNzgwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTEzMzAyNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/55#discussion_r379133025", "bodyText": "Makes sense. So RequestContext always 1 to 1 maps to a IPC Connection? I feel a connection may have multiple request context... Maybe just naming... We can leave it for now...", "author": "leaf94", "createdAt": "2020-02-13T21:38:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTExNzgwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTEzNTQ2OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/55#discussion_r379135468", "bodyText": "Yes, Ethan, it is 1:1. Shirley's suggested name may be a better idea. I'd probably go with just ConnectionContext.", "author": "MikeDombo", "createdAt": "2020-02-13T21:43:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTExNzgwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTExODA0Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/55#discussion_r379118042", "bodyText": "[Minor] maybe ConnectionHandler?", "author": "leaf94", "createdAt": "2020-02-13T21:05:59Z", "path": "src/main/java/com/aws/iot/evergreen/ipc/ConnectionHandle.java", "diffHunk": "@@ -0,0 +1,10 @@\n+package com.aws.iot.evergreen.ipc;\n+\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+\n+import java.util.concurrent.Future;\n+\n+@FunctionalInterface\n+public interface ConnectionHandle {", "originalCommit": "0206eb5c791c46b96dea20fef8a6a6f7377692ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTEyMDI3Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/55#discussion_r379120276", "bodyText": "It isn't a handler though, it is a handle to a connection, or perhaps some other phrasing. But definitely not a connection handler.", "author": "MikeDombo", "createdAt": "2020-02-13T21:10:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTExODA0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIwODQyMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/55#discussion_r379208420", "bodyText": "I feel ConnectionHandle can be merged with ClientContext , sendAndReceive() is a method of ClientContext", "author": "ShirleyZheng92", "createdAt": "2020-02-14T01:21:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTExODA0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTExODUxNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/55#discussion_r379118516", "bodyText": "super.postInject", "author": "leaf94", "createdAt": "2020-02-13T21:07:03Z", "path": "src/main/java/com/aws/iot/evergreen/ipc/modules/LifecycleIPCService.java", "diffHunk": "@@ -0,0 +1,114 @@\n+package com.aws.iot.evergreen.ipc.modules;\n+\n+\n+import com.aws.iot.evergreen.builtin.services.lifecycle.LifecycleIPCAgent;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.ipc.IPCRouter;\n+import com.aws.iot.evergreen.ipc.common.FrameReader.Message;\n+import com.aws.iot.evergreen.ipc.common.RequestContext;\n+import com.aws.iot.evergreen.ipc.exceptions.IPCException;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralRequest;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralResponse;\n+import com.aws.iot.evergreen.ipc.services.common.IPCUtil;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleListenRequest;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleRequestTypes;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleResponseStatus;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.StateChangeRequest;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.util.Log;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.cbor.databind.CBORMapper;\n+\n+import java.io.IOException;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Future;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.ipc.services.lifecycle.Lifecycle.LIFECYCLE_SERVICE_NAME;\n+import static com.aws.iot.evergreen.util.Log.Level;\n+\n+\n+//TODO: see if this needs to be a GGService\n+@ImplementsService(name = \"lifecycleipc\", autostart = true)\n+public class LifecycleIPCService extends EvergreenService {\n+    private ObjectMapper mapper = new CBORMapper();\n+\n+    @Inject\n+    private IPCRouter router;\n+\n+    @Inject\n+    Log log;\n+\n+    @Inject\n+    private LifecycleIPCAgent agent;\n+\n+    public LifecycleIPCService(Topics c) {\n+        super(c);\n+    }\n+\n+    @Override\n+    public void postInject() {\n+        try {\n+            router.registerServiceCallback(LIFECYCLE_SERVICE_NAME, this::handleMessage);\n+        } catch (IPCException e) {\n+            log.log(Level.Error, \"Error registering callback for service \" + LIFECYCLE_SERVICE_NAME);\n+        }\n+    }", "originalCommit": "0206eb5c791c46b96dea20fef8a6a6f7377692ab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTExOTI1OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/55#discussion_r379119258", "bodyText": "[Minor] Any reason for not using: https://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/tuple/Pair.html ?", "author": "leaf94", "createdAt": "2020-02-13T21:08:40Z", "path": "src/main/java/com/aws/iot/evergreen/util/Pair.java", "diffHunk": "@@ -0,0 +1,11 @@\n+package com.aws.iot.evergreen.util;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+\n+@Data\n+@AllArgsConstructor\n+public class Pair<L, R> {", "originalCommit": "0206eb5c791c46b96dea20fef8a6a6f7377692ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTEyMDUwMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/55#discussion_r379120503", "bodyText": "No need for more dependencies for such a simple class.", "author": "MikeDombo", "createdAt": "2020-02-13T21:11:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTExOTI1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTEzMzYzNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/55#discussion_r379133636", "bodyText": "Got it. But I think we will definitely need the lang3 lib one day...", "author": "leaf94", "createdAt": "2020-02-13T21:40:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTExOTI1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTEyNjk1MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/55#discussion_r379126950", "bodyText": "Why the value of this map needs to be a map?", "author": "ShirleyZheng92", "createdAt": "2020-02-13T21:25:07Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/LifecycleIPCAgent.java", "diffHunk": "@@ -0,0 +1,149 @@\n+package com.aws.iot.evergreen.builtin.services.lifecycle;\n+\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.ipc.ConnectionHandle;\n+import com.aws.iot.evergreen.ipc.IPCRouter;\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+import com.aws.iot.evergreen.ipc.common.RequestContext;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralRequest;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralResponse;\n+import com.aws.iot.evergreen.ipc.services.common.IPCUtil;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleListenRequest;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleRequestTypes;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleResponseStatus;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.StateChangeRequest;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.StateTransitionEvent;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.function.BiConsumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.ipc.services.lifecycle.Lifecycle.LIFECYCLE_SERVICE_NAME;\n+\n+/**\n+ * Class to handle business logic for all Lifecycle requests over IPC.\n+ */\n+public class LifecycleIPCAgent implements InjectionActions {\n+    private static final Map<String, Map<RequestContext, BiConsumer<State, State>>> listeners =", "originalCommit": "0206eb5c791c46b96dea20fef8a6a6f7377692ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTEzNDc2Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/55#discussion_r379134762", "bodyText": "nvm", "author": "ShirleyZheng92", "createdAt": "2020-02-13T21:42:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTEyNjk1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTEzNDg4OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/55#discussion_r379134889", "bodyText": "I'll add a comment. This is mapping from service we're listening to --> connection --> function to call when the service changes.", "author": "MikeDombo", "createdAt": "2020-02-13T21:42:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTEyNjk1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTEyODUyNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/55#discussion_r379128526", "bodyText": "I feel this should be a method of RequestContext , like Future<> requestContext.sendMessage, and you can do synchronize on the object inside the method", "author": "ShirleyZheng92", "createdAt": "2020-02-13T21:28:33Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/LifecycleIPCAgent.java", "diffHunk": "@@ -0,0 +1,149 @@\n+package com.aws.iot.evergreen.builtin.services.lifecycle;\n+\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.ipc.ConnectionHandle;\n+import com.aws.iot.evergreen.ipc.IPCRouter;\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+import com.aws.iot.evergreen.ipc.common.RequestContext;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralRequest;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralResponse;\n+import com.aws.iot.evergreen.ipc.services.common.IPCUtil;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleListenRequest;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleRequestTypes;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleResponseStatus;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.StateChangeRequest;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.StateTransitionEvent;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.function.BiConsumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.ipc.services.lifecycle.Lifecycle.LIFECYCLE_SERVICE_NAME;\n+\n+/**\n+ * Class to handle business logic for all Lifecycle requests over IPC.\n+ */\n+public class LifecycleIPCAgent implements InjectionActions {\n+    private static final Map<String, Map<RequestContext, BiConsumer<State, State>>> listeners =\n+            new ConcurrentHashMap<>();\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private IPCRouter router;\n+\n+    @Inject\n+    private ExecutorService executor;\n+\n+    private EvergreenService.GlobalStateChangeListener onServiceChange = (service, prev) -> {\n+        Map<RequestContext, BiConsumer<State, State>> callbacks = listeners.get(service.getName());\n+        if (callbacks != null) {\n+            callbacks.values().forEach(x -> x.accept(prev, service.getState()));\n+        }\n+    };\n+\n+    public LifecycleIPCAgent() {\n+    }\n+\n+    @Override\n+    public void postInject() {\n+        kernel.context.addGlobalStateChangeListener(onServiceChange);\n+    }\n+\n+    /**\n+     * Report the state of the service which the request is coming from.\n+     *\n+     * @param req incoming request\n+     * @param context caller context\n+     * @return response for setting state\n+     */\n+    public GeneralResponse<Void, LifecycleResponseStatus> reportState(StateChangeRequest req, RequestContext context) {\n+        State s = State.valueOf(req.getState());\n+        Optional<EvergreenService> service =\n+                Optional.ofNullable(kernel.context.get(EvergreenService.class, context.getServiceName()));\n+\n+        GeneralResponse<Void, LifecycleResponseStatus> resp = new GeneralResponse<>();\n+        if (service.isPresent()) {\n+            service.get().setState(s);\n+            resp.setError(LifecycleResponseStatus.Success);\n+        } else {\n+            resp.setError(LifecycleResponseStatus.InvalidRequest);\n+            resp.setErrorMessage(\"Service could not be found\");\n+        }\n+\n+        return resp;\n+    }\n+\n+    /**\n+     * Set up a listener for state changes for a requested service. (Currently any service can listen to any other\n+     * service's lifecyle changes).\n+     *\n+     * @param listenRequest incoming listen request\n+     * @param context caller context\n+     * @return response\n+     */\n+    public GeneralResponse<Void, LifecycleResponseStatus> listen(LifecycleListenRequest listenRequest,\n+                                                                 RequestContext context) {\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        listeners.compute(listenRequest.getServiceName(), (key, old) -> {\n+            if (old == null) {\n+                old = new ConcurrentHashMap<>();\n+            }\n+            old.put(context, sendStateUpdateToListener(listenRequest, context));\n+            return old;\n+        });\n+\n+        return GeneralResponse.<Void, LifecycleResponseStatus>builder().error(LifecycleResponseStatus.Success).build();\n+    }\n+\n+    private BiConsumer<State, State> sendStateUpdateToListener(LifecycleListenRequest listenRequest,\n+                                                               RequestContext context) {\n+        return (oldState, newState) -> {\n+            executor.submit(() -> {\n+                // Synchronize on context so that we only try to send 1 update at a time to a given client\n+                synchronized (context) {\n+                    StateTransitionEvent trans =\n+                            StateTransitionEvent.builder().newState(newState.toString()).oldState(oldState.toString())\n+                                    .service(listenRequest.getServiceName()).build();\n+\n+                    GeneralRequest<StateTransitionEvent, LifecycleRequestTypes> req =\n+                            GeneralRequest.<StateTransitionEvent, LifecycleRequestTypes>builder()\n+                                    .type(LifecycleRequestTypes.transition).request(trans).build();\n+\n+                    try {\n+                        // TODO: Add timeout and retry to make sure the client got the request. https://sim.amazon.com/issues/P32541289\n+                        ConnectionHandle connectionHandle =\n+                                router.getConnectionHandle(context, this::handleConnectionClosed);\n+                        if (connectionHandle != null) {\n+                            connectionHandle.sendAndReceive(LIFECYCLE_SERVICE_NAME,\n+                                    new FrameReader.Message(IPCUtil.encode(req))).get();\n+                        }\n+                        // TODO: Check the response message and make sure it was successful. https://sim.amazon.com/issues/P32541289", "originalCommit": "0206eb5c791c46b96dea20fef8a6a6f7377692ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE0MTQ1Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/55#discussion_r379141453", "bodyText": "I'll talk to you soon about this, I'm not sure exactly what part you think would be abstracted since all this is entirely specific to lifecycle.", "author": "MikeDombo", "createdAt": "2020-02-13T21:56:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTEyODUyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTEzNDUxNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/55#discussion_r379134517", "bodyText": "Haven't look too detailed into the code. I feel having both IPCRouter and MessageRouter is confusing", "author": "ShirleyZheng92", "createdAt": "2020-02-13T21:41:50Z", "path": "src/main/java/com/aws/iot/evergreen/ipc/handler/MessageRouter.java", "diffHunk": "@@ -57,7 +57,7 @@ public void channelRegistered(ChannelHandlerContext ctx) throws Exception {\n     @Override\n     public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {\n         super.channelUnregistered(ctx);\n-        // TODO: Handle de-registration of any listeners such as Lifecycle https://issues.amazon.com/issues/P32808717\n+        router.clientDisconnected(ctx.channel().attr(CONNECTION_CONTEXT_KEY).get());", "originalCommit": "0206eb5c791c46b96dea20fef8a6a6f7377692ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE0MTU4Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/55#discussion_r379141586", "bodyText": "Renamed MessageRouter to IPCChannelHandler", "author": "MikeDombo", "createdAt": "2020-02-13T21:56:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTEzNDUxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE1MDI0NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/55#discussion_r379150244", "bodyText": "Actually I feel that IPCRouter can be removed. registerCallback(dest, callback) can be put into LifecycleService, the new functions you added like connect/disconnect/sendResponseMessage can be methods in RequestContext", "author": "ShirleyZheng92", "createdAt": "2020-02-13T22:16:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTEzNDUxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE0NzY0Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/55#discussion_r379147642", "bodyText": "The naming is a little confusing to me. reportState() ( and listen() below) , both means 'handleReportStateFromClient' and 'handlListenFromClient' .", "author": "ShirleyZheng92", "createdAt": "2020-02-13T22:10:10Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/LifecycleIPCAgent.java", "diffHunk": "@@ -0,0 +1,149 @@\n+package com.aws.iot.evergreen.builtin.services.lifecycle;\n+\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.ipc.ConnectionHandle;\n+import com.aws.iot.evergreen.ipc.IPCRouter;\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+import com.aws.iot.evergreen.ipc.common.RequestContext;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralRequest;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralResponse;\n+import com.aws.iot.evergreen.ipc.services.common.IPCUtil;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleListenRequest;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleRequestTypes;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleResponseStatus;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.StateChangeRequest;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.StateTransitionEvent;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.function.BiConsumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.ipc.services.lifecycle.Lifecycle.LIFECYCLE_SERVICE_NAME;\n+\n+/**\n+ * Class to handle business logic for all Lifecycle requests over IPC.\n+ */\n+public class LifecycleIPCAgent implements InjectionActions {\n+    private static final Map<String, Map<RequestContext, BiConsumer<State, State>>> listeners =\n+            new ConcurrentHashMap<>();\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private IPCRouter router;\n+\n+    @Inject\n+    private ExecutorService executor;\n+\n+    private EvergreenService.GlobalStateChangeListener onServiceChange = (service, prev) -> {\n+        Map<RequestContext, BiConsumer<State, State>> callbacks = listeners.get(service.getName());\n+        if (callbacks != null) {\n+            callbacks.values().forEach(x -> x.accept(prev, service.getState()));\n+        }\n+    };\n+\n+    public LifecycleIPCAgent() {\n+    }\n+\n+    @Override\n+    public void postInject() {\n+        kernel.context.addGlobalStateChangeListener(onServiceChange);\n+    }\n+\n+    /**\n+     * Report the state of the service which the request is coming from.\n+     *\n+     * @param req incoming request\n+     * @param context caller context\n+     * @return response for setting state\n+     */\n+    public GeneralResponse<Void, LifecycleResponseStatus> reportState(StateChangeRequest req, RequestContext context) {", "originalCommit": "0206eb5c791c46b96dea20fef8a6a6f7377692ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE1MTUwMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/55#discussion_r379151502", "bodyText": "These are named to match the client API names. (except for listen which need to be updated to listenToStateChanges.)", "author": "MikeDombo", "createdAt": "2020-02-13T22:19:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE0NzY0Mg=="}], "type": "inlineReview"}, {"oid": "cc7fc181166e9c0e95c17a12ffe720a496193cb1", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/cc7fc181166e9c0e95c17a12ffe720a496193cb1", "message": "Lifecycle IPC", "committedDate": "2020-02-13T23:00:23Z", "type": "forcePushed"}, {"oid": "baaf591f729be7db0fec921787b0bba4b6e6e805", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/baaf591f729be7db0fec921787b0bba4b6e6e805", "message": "Lifecycle IPC", "committedDate": "2020-02-13T23:15:17Z", "type": "commit"}, {"oid": "baaf591f729be7db0fec921787b0bba4b6e6e805", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/baaf591f729be7db0fec921787b0bba4b6e6e805", "message": "Lifecycle IPC", "committedDate": "2020-02-13T23:15:17Z", "type": "forcePushed"}, {"oid": "fade2a9fcf5726b66f1e8cdddbfbc18854bf33cf", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/fade2a9fcf5726b66f1e8cdddbfbc18854bf33cf", "message": "Merge branch 'master' into lifecycle", "committedDate": "2020-02-14T01:02:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIwODU3NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/55#discussion_r379208574", "bodyText": "I feel add disconnect handler doesn't fit in the function name getConnectionHandle()", "author": "ShirleyZheng92", "createdAt": "2020-02-14T01:22:26Z", "path": "src/main/java/com/aws/iot/evergreen/ipc/IPCRouter.java", "diffHunk": "@@ -50,4 +66,103 @@ public void registerServiceCallback(String destination, IPCCallback callback) th\n     public IPCCallback getCallbackForDestination(String destination) {\n         return destinationCallbackMap.get(destination);\n     }\n+\n+    /**\n+     * Tries to get a connection handle from a context. The connection handle can be used to send\n+     * requests to the client and then wait for a response.\n+     *\n+     * @param connectionContext  The request context of the client that you want the handle to.\n+     * @param disconnectCallback Function to be called when the client disconnects. Use for cleaning up\n+     *                           extra listeners.\n+     * @return\n+     */\n+    @Nullable\n+    public ConnectionHandle getConnectionHandle(ConnectionContext connectionContext,\n+                                                Consumer<ConnectionContext> disconnectCallback) {\n+        Channel channel = clientToChannelMap.get(connectionContext);\n+        if (channel == null) {\n+            return null;\n+        }\n+\n+        clientToDisconnectorsMap.compute(connectionContext, (key, value) -> {", "originalCommit": "fade2a9fcf5726b66f1e8cdddbfbc18854bf33cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIwOTMyNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/55#discussion_r379209327", "bodyText": "The idea is to force the user to register what happens on disconnection. Without it, the user could forget that they need to do cleanup when the client disconnects.", "author": "MikeDombo", "createdAt": "2020-02-14T01:25:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIwODU3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTI4MDAwOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/55#discussion_r379280008", "bodyText": "why so we need to store Client and SequenceNumber instead of just the sequence number and future", "author": "fahadmohammed01", "createdAt": "2020-02-14T07:16:08Z", "path": "src/main/java/com/aws/iot/evergreen/ipc/IPCRouter.java", "diffHunk": "@@ -50,4 +66,103 @@ public void registerServiceCallback(String destination, IPCCallback callback) th\n     public IPCCallback getCallbackForDestination(String destination) {\n         return destinationCallbackMap.get(destination);\n     }\n+\n+    /**\n+     * Tries to get a connection handle from a context. The connection handle can be used to send\n+     * requests to the client and then wait for a response.\n+     *\n+     * @param connectionContext  The request context of the client that you want the handle to.\n+     * @param disconnectCallback Function to be called when the client disconnects. Use for cleaning up\n+     *                           extra listeners.\n+     * @return\n+     */\n+    @Nullable\n+    public ConnectionHandle getConnectionHandle(ConnectionContext connectionContext,\n+                                                Consumer<ConnectionContext> disconnectCallback) {\n+        Channel channel = clientToChannelMap.get(connectionContext);\n+        if (channel == null) {\n+            return null;\n+        }\n+\n+        clientToDisconnectorsMap.compute(connectionContext, (key, value) -> {\n+            if (value == null) {\n+                value = new ArrayList<>();\n+            }\n+            value.add(disconnectCallback);\n+            return value;\n+        });\n+\n+        return (destination, message) -> {\n+            FrameReader.MessageFrame requestFrame =\n+                    new FrameReader.MessageFrame(destination, message, FrameReader.FrameType.REQUEST);\n+\n+            CompletableFuture<FrameReader.Message> fut = new CompletableFuture<>();\n+            sequenceNumberToCallbackMap\n+                    .put(new ClientAndSequenceNumber(requestFrame.sequenceNumber, connectionContext), fut);", "originalCommit": "baaf591f729be7db0fec921787b0bba4b6e6e805", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTUzNDk1Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/55#discussion_r379534956", "bodyText": "Since the sequence number may not be unique. The sequence number should be unique per-connection, but not necessarily across multiple connections.", "author": "MikeDombo", "createdAt": "2020-02-14T16:46:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTI4MDAwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTYxODM0Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/55#discussion_r379618347", "bodyText": "I agree that having sequencenumber:clientId is stronger but is there a use case where we need to do that. Having a unique sequencenumber(as implemented ) should be strong enough for our uses cases.", "author": "fahadmohammed01", "createdAt": "2020-02-14T19:58:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTI4MDAwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTI4MDQ2Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/55#discussion_r379280463", "bodyText": "lets first remove the context from clientToChannelMap before going through the list of call backs", "author": "fahadmohammed01", "createdAt": "2020-02-14T07:17:43Z", "path": "src/main/java/com/aws/iot/evergreen/ipc/IPCRouter.java", "diffHunk": "@@ -50,4 +66,103 @@ public void registerServiceCallback(String destination, IPCCallback callback) th\n     public IPCCallback getCallbackForDestination(String destination) {\n         return destinationCallbackMap.get(destination);\n     }\n+\n+    /**\n+     * Tries to get a connection handle from a context. The connection handle can be used to send\n+     * requests to the client and then wait for a response.\n+     *\n+     * @param connectionContext  The request context of the client that you want the handle to.\n+     * @param disconnectCallback Function to be called when the client disconnects. Use for cleaning up\n+     *                           extra listeners.\n+     * @return\n+     */\n+    @Nullable\n+    public ConnectionHandle getConnectionHandle(ConnectionContext connectionContext,\n+                                                Consumer<ConnectionContext> disconnectCallback) {\n+        Channel channel = clientToChannelMap.get(connectionContext);\n+        if (channel == null) {\n+            return null;\n+        }\n+\n+        clientToDisconnectorsMap.compute(connectionContext, (key, value) -> {\n+            if (value == null) {\n+                value = new ArrayList<>();\n+            }\n+            value.add(disconnectCallback);\n+            return value;\n+        });\n+\n+        return (destination, message) -> {\n+            FrameReader.MessageFrame requestFrame =\n+                    new FrameReader.MessageFrame(destination, message, FrameReader.FrameType.REQUEST);\n+\n+            CompletableFuture<FrameReader.Message> fut = new CompletableFuture<>();\n+            sequenceNumberToCallbackMap\n+                    .put(new ClientAndSequenceNumber(requestFrame.sequenceNumber, connectionContext), fut);\n+\n+            channel.writeAndFlush(requestFrame);\n+\n+            return fut;\n+        };\n+    }\n+\n+    /**\n+     * Only called by MessageRouter, do not call in any other place.\n+     * Called when a client disconnects from the server.\n+     *\n+     * @param context client which disconnected's context\n+     */\n+    public void clientDisconnected(ConnectionContext context) {\n+        List<Consumer<ConnectionContext>> disconnectors = clientToDisconnectorsMap.get(context);\n+        if (disconnectors != null) {\n+            disconnectors.forEach(d -> d.accept(context));\n+        }\n+\n+        clientToChannelMap.remove(context);", "originalCommit": "baaf591f729be7db0fec921787b0bba4b6e6e805", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTUzNTg2OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/55#discussion_r379535869", "bodyText": "Sure.", "author": "MikeDombo", "createdAt": "2020-02-14T16:48:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTI4MDQ2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTI5MDU0Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/55#discussion_r379290542", "bodyText": "We need to uniquely identify each connection at-least for logging and debugging purposes. May be a client Id?\nAlso add equals() and hashcode(), relying on the object itself for uniqueness is fragile.", "author": "fahadmohammed01", "createdAt": "2020-02-14T07:52:57Z", "path": "src/main/java/com/aws/iot/evergreen/ipc/common/ConnectionContext.java", "diffHunk": "@@ -7,6 +7,6 @@\n @AllArgsConstructor\n @Data\n @ToString\n-public class RequestContext {\n+public class ConnectionContext {\n     private String serviceName;", "originalCommit": "baaf591f729be7db0fec921787b0bba4b6e6e805", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTUzNTgwNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/55#discussion_r379535805", "bodyText": "For logging, we don't need any of that. The service name along with the connection itself (the remote ip address and port) is enough to identify a single connection.", "author": "MikeDombo", "createdAt": "2020-02-14T16:48:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTI5MDU0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTYxNzU2OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/55#discussion_r379617568", "bodyText": "We need a unique way to identify each client, to track request from client to server and back. A unique client id would serve that purpose and the client id should be shared with the client on initial hand shake.\nremote ip and port does not cut it as the client might see a different ip/port from what the server sees, if they are behind a nat gateway (wifi router in the M1 example)", "author": "fahadmohammed01", "createdAt": "2020-02-14T19:56:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTI5MDU0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTI5OTMwMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/55#discussion_r379299303", "bodyText": "do we need this synchronization? even if we limit this here, there would be another service trying to send a message to the client at the same time. IPCService should be support multiple code paths sending message to a client concurrently.", "author": "fahadmohammed01", "createdAt": "2020-02-14T08:20:29Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/LifecycleIPCAgent.java", "diffHunk": "@@ -0,0 +1,151 @@\n+package com.aws.iot.evergreen.builtin.services.lifecycle;\n+\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.ipc.ConnectionHandle;\n+import com.aws.iot.evergreen.ipc.IPCRouter;\n+import com.aws.iot.evergreen.ipc.common.ConnectionContext;\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralRequest;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralResponse;\n+import com.aws.iot.evergreen.ipc.services.common.IPCUtil;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleListenRequest;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleRequestTypes;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleResponseStatus;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.StateChangeRequest;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.StateTransitionEvent;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.function.BiConsumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.ipc.services.lifecycle.Lifecycle.LIFECYCLE_SERVICE_NAME;\n+\n+/**\n+ * Class to handle business logic for all Lifecycle requests over IPC.\n+ */\n+public class LifecycleIPCAgent implements InjectionActions {\n+    // Map from service that is listened to --> Map of connection --> Function to call when service state changes\n+    private static final Map<String, Map<ConnectionContext, BiConsumer<State, State>>> listeners =\n+            new ConcurrentHashMap<>();\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private IPCRouter router;\n+\n+    @Inject\n+    private ExecutorService executor;\n+\n+    private EvergreenService.GlobalStateChangeListener onServiceChange = (service, prev) -> {\n+        Map<ConnectionContext, BiConsumer<State, State>> callbacks = listeners.get(service.getName());\n+        if (callbacks != null) {\n+            callbacks.values().forEach(x -> x.accept(prev, service.getState()));\n+        }\n+    };\n+\n+    public LifecycleIPCAgent() {\n+    }\n+\n+    @Override\n+    public void postInject() {\n+        kernel.context.addGlobalStateChangeListener(onServiceChange);\n+    }\n+\n+    /**\n+     * Report the state of the service which the request is coming from.\n+     *\n+     * @param req     incoming request\n+     * @param context caller context\n+     * @return response for setting state\n+     */\n+    public GeneralResponse<Void, LifecycleResponseStatus> reportState(StateChangeRequest req,\n+                                                                      ConnectionContext context) {\n+        State s = State.valueOf(req.getState());\n+        Optional<EvergreenService> service =\n+                Optional.ofNullable(kernel.context.get(EvergreenService.class, context.getServiceName()));\n+\n+        GeneralResponse<Void, LifecycleResponseStatus> resp = new GeneralResponse<>();\n+        if (service.isPresent()) {\n+            service.get().setState(s);\n+            resp.setError(LifecycleResponseStatus.Success);\n+        } else {\n+            resp.setError(LifecycleResponseStatus.InvalidRequest);\n+            resp.setErrorMessage(\"Service could not be found\");\n+        }\n+\n+        return resp;\n+    }\n+\n+    /**\n+     * Set up a listener for state changes for a requested service. (Currently any service can listen to any other\n+     * service's lifecyle changes).\n+     *\n+     * @param listenRequest incoming listen request\n+     * @param context       caller context\n+     * @return response\n+     */\n+    public GeneralResponse<Void, LifecycleResponseStatus> listenToStateChanges(LifecycleListenRequest listenRequest,\n+                                                                               ConnectionContext context) {\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        listeners.compute(listenRequest.getServiceName(), (key, old) -> {\n+            if (old == null) {\n+                old = new ConcurrentHashMap<>();\n+            }\n+            old.put(context, sendStateUpdateToListener(listenRequest, context));\n+            return old;\n+        });\n+\n+        return GeneralResponse.<Void, LifecycleResponseStatus>builder().error(LifecycleResponseStatus.Success).build();\n+    }\n+\n+    private BiConsumer<State, State> sendStateUpdateToListener(LifecycleListenRequest listenRequest,\n+                                                               ConnectionContext context) {\n+        return (oldState, newState) -> {\n+            executor.submit(() -> {\n+                // Synchronize on context so that we only try to send 1 update at a time to a given client\n+                synchronized (context) {", "originalCommit": "baaf591f729be7db0fec921787b0bba4b6e6e805", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTUzNzA0Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/55#discussion_r379537043", "bodyText": "This locking is not for threadsafety, it is already safe. The purpose is so that we only send a single state transition at a time and wait for the response to come back before sending the next state transition. This emulates the kernel's publish queue where it is blocking and strictly ordered.", "author": "MikeDombo", "createdAt": "2020-02-14T16:51:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTI5OTMwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTYyMDgxNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/55#discussion_r379620814", "bodyText": "Agreed", "author": "fahadmohammed01", "createdAt": "2020-02-14T20:04:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTI5OTMwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMwMDI4OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/55#discussion_r379300288", "bodyText": "if the same connections listens to state changes for the same service n times, do we need to send n state change messages?", "author": "fahadmohammed01", "createdAt": "2020-02-14T08:23:03Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/LifecycleIPCAgent.java", "diffHunk": "@@ -0,0 +1,151 @@\n+package com.aws.iot.evergreen.builtin.services.lifecycle;\n+\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.ipc.ConnectionHandle;\n+import com.aws.iot.evergreen.ipc.IPCRouter;\n+import com.aws.iot.evergreen.ipc.common.ConnectionContext;\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralRequest;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralResponse;\n+import com.aws.iot.evergreen.ipc.services.common.IPCUtil;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleListenRequest;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleRequestTypes;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleResponseStatus;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.StateChangeRequest;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.StateTransitionEvent;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.function.BiConsumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.ipc.services.lifecycle.Lifecycle.LIFECYCLE_SERVICE_NAME;\n+\n+/**\n+ * Class to handle business logic for all Lifecycle requests over IPC.\n+ */\n+public class LifecycleIPCAgent implements InjectionActions {\n+    // Map from service that is listened to --> Map of connection --> Function to call when service state changes\n+    private static final Map<String, Map<ConnectionContext, BiConsumer<State, State>>> listeners =\n+            new ConcurrentHashMap<>();\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private IPCRouter router;\n+\n+    @Inject\n+    private ExecutorService executor;\n+\n+    private EvergreenService.GlobalStateChangeListener onServiceChange = (service, prev) -> {\n+        Map<ConnectionContext, BiConsumer<State, State>> callbacks = listeners.get(service.getName());\n+        if (callbacks != null) {\n+            callbacks.values().forEach(x -> x.accept(prev, service.getState()));\n+        }\n+    };\n+\n+    public LifecycleIPCAgent() {\n+    }\n+\n+    @Override\n+    public void postInject() {\n+        kernel.context.addGlobalStateChangeListener(onServiceChange);\n+    }\n+\n+    /**\n+     * Report the state of the service which the request is coming from.\n+     *\n+     * @param req     incoming request\n+     * @param context caller context\n+     * @return response for setting state\n+     */\n+    public GeneralResponse<Void, LifecycleResponseStatus> reportState(StateChangeRequest req,\n+                                                                      ConnectionContext context) {\n+        State s = State.valueOf(req.getState());\n+        Optional<EvergreenService> service =\n+                Optional.ofNullable(kernel.context.get(EvergreenService.class, context.getServiceName()));\n+\n+        GeneralResponse<Void, LifecycleResponseStatus> resp = new GeneralResponse<>();\n+        if (service.isPresent()) {\n+            service.get().setState(s);\n+            resp.setError(LifecycleResponseStatus.Success);\n+        } else {\n+            resp.setError(LifecycleResponseStatus.InvalidRequest);\n+            resp.setErrorMessage(\"Service could not be found\");\n+        }\n+\n+        return resp;\n+    }\n+\n+    /**\n+     * Set up a listener for state changes for a requested service. (Currently any service can listen to any other\n+     * service's lifecyle changes).\n+     *\n+     * @param listenRequest incoming listen request\n+     * @param context       caller context\n+     * @return response\n+     */\n+    public GeneralResponse<Void, LifecycleResponseStatus> listenToStateChanges(LifecycleListenRequest listenRequest,\n+                                                                               ConnectionContext context) {\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        listeners.compute(listenRequest.getServiceName(), (key, old) -> {", "originalCommit": "baaf591f729be7db0fec921787b0bba4b6e6e805", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTUzNzg3OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/55#discussion_r379537878", "bodyText": "No, since the client would receive the exact same message if it was multiply registered. The client keeps a list of callbacks for each service it is listening to, but the server does not need that since the request that it sends to the server is just saying that some service changed into some state.", "author": "MikeDombo", "createdAt": "2020-02-14T16:52:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMwMDI4OA=="}], "type": "inlineReview"}]}