{"pr_number": 255, "pr_title": "Deflake MQTT reconnection test", "pr_createdAt": "2020-05-22T17:57:34Z", "pr_url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/255", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM4Mzg5OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/255#discussion_r429383898", "bodyText": "nit: I don't think we capitalize these most of the time.", "author": "MikeDombo", "createdAt": "2020-05-22T18:00:01Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/IotJobsHelper.java", "diffHunk": "@@ -388,7 +388,7 @@ private Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n         } catch (ExecutionException e) {\n             if (e.getCause() instanceof MqttException) {\n                 //caused due to connectivity issue\n-                logger.atWarn().setCause(e).log(UPDATE_DEPLOYMENT_STATUS_MQTT_ERROR_LOG);\n+                logger.atWarn().setCause(e).kv(\"Status\", status).log(UPDATE_DEPLOYMENT_STATUS_MQTT_ERROR_LOG);", "originalCommit": "a5f65ac253bd23dc95fd0401973e401ae3f9f2da", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d86f365ca47c6cef84468de01d3ea64a2838e069", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/d86f365ca47c6cef84468de01d3ea64a2838e069", "message": "Deflake MQTT reconnection test", "committedDate": "2020-05-22T20:19:34Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ2OTM4NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/255#discussion_r429469384", "bodyText": "if there are multiple updates for same deployment id, and if one of the update was not published then shouldnt we skip the rest to make sure the updates are not send out of order?", "author": "fahadmohammed01", "createdAt": "2020-05-22T21:56:39Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentStatusKeeper.java", "diffHunk": "@@ -92,43 +90,40 @@ public void persistAndPublishDeploymentStatus(String jobId, DeploymentType deplo\n      * all deployments the device performed when offline\n      * @param type deployment type\n      */\n-    public void publishPersistedStatusUpdates(DeploymentType type) {\n+    public synchronized void publishPersistedStatusUpdates(DeploymentType type) {\n         Topics processedDeployments = getProcessedDeployments();\n-        //TODO: better sync approach.\n-        synchronized (processedDeployments) {\n-            ArrayList<Topic> deployments = new ArrayList<>();\n-            processedDeployments.forEach(topic -> {\n-\n-                Map<String, Object> deploymentDetails = (HashMap) ((Topic) topic).getOnce();\n-                DeploymentType deploymentType = (DeploymentType)\n-                        deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_TYPE);\n-                if (deploymentType.equals(type)) {\n-                    deployments.add((Topic) topic);\n-                }\n-            });\n-            // Topics are stored as ConcurrentHashMaps which do not guarantee ordering of elements\n-            // We want the statuses to be updated in the cloud in the order in which they were processed on the device.\n-            // This will be accurate representation of what happened on the device, especially when deployment service\n-            // processes multiple deployments in the order in which they come. Additionally, a customer workflow can\n-            // depend on this order. If Group2 gets successfully updated before Group1 then customer workflow may\n-            // error out.\n-            List<Topic> sortedByTimestamp = deployments.stream().sorted((o1, o2) -> {\n-                if (Long.valueOf(o1.getModtime()) > Long.valueOf(o2.getModtime())) {\n-                    return 1;\n-                }\n-                return -1;\n-            }).collect(Collectors.toList());\n-\n-            Iterator iterator = sortedByTimestamp.iterator();\n-            while (iterator.hasNext()) {\n-                Topic topic = (Topic) iterator.next();\n-                Map<String, Object> deploymentDetails = (HashMap) topic.getOnce();\n-                DeploymentType deploymentType = (DeploymentType)\n-                        deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_TYPE);\n-\n-                if (getConsumerForDeploymentType(deploymentType).apply(deploymentDetails)) {\n-                    processedDeployments.remove(topic);\n-                }\n+        ArrayList<Topic> deployments = new ArrayList<>();\n+        processedDeployments.forEach(topic -> {\n+\n+            Map<String, Object> deploymentDetails = (HashMap) ((Topic) topic).getOnce();\n+            DeploymentType deploymentType = (DeploymentType)\n+                    deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_TYPE);\n+            if (deploymentType.equals(type)) {\n+                deployments.add((Topic) topic);\n+            }\n+        });\n+        // Topics are stored as ConcurrentHashMaps which do not guarantee ordering of elements\n+        // We want the statuses to be updated in the cloud in the order in which they were processed on the device.\n+        // This will be accurate representation of what happened on the device, especially when deployment service\n+        // processes multiple deployments in the order in which they come. Additionally, a customer workflow can\n+        // depend on this order. If Group2 gets successfully updated before Group1 then customer workflow may\n+        // error out.\n+        List<Topic> sortedByTimestamp = deployments.stream().sorted((o1, o2) -> {\n+            if (Long.valueOf(o1.getModtime()) > Long.valueOf(o2.getModtime())) {\n+                return 1;\n+            }\n+            return -1;\n+        }).collect(Collectors.toList());\n+\n+        Iterator iterator = sortedByTimestamp.iterator();\n+        while (iterator.hasNext()) {\n+            Topic topic = (Topic) iterator.next();\n+            Map<String, Object> deploymentDetails = (HashMap) topic.getOnce();\n+            DeploymentType deploymentType = (DeploymentType)\n+                    deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_TYPE);\n+\n+            if (getConsumerForDeploymentType(deploymentType).apply(deploymentDetails)) {", "originalCommit": "d86f365ca47c6cef84468de01d3ea64a2838e069", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3NDk0NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/255#discussion_r429474945", "bodyText": "Not sure if I understand. I only changed the synchronized scope here, but didn't change any logic. I can take a closer look.", "author": "hui-yang", "createdAt": "2020-05-22T22:09:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ2OTM4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3NjUxNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/255#discussion_r429476516", "bodyText": "say there are 3 status updates for the same deployment, update1 update2 and update3 in chronological order. If pushing update2 to cloud fails then update3 should not be send to preserve the order.", "author": "fahadmohammed01", "createdAt": "2020-05-22T22:17:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ2OTM4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3MTgyNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/255#discussion_r429471824", "bodyText": "Can we only publish updates of the deployment id at hand and not publish status for the type. maybe publish can take deployment id along with type?", "author": "fahadmohammed01", "createdAt": "2020-05-22T21:59:58Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentStatusKeeper.java", "diffHunk": "@@ -66,24 +66,22 @@ public void persistAndPublishDeploymentStatus(String jobId, DeploymentType deplo\n             return;\n         }\n \n-        Topics processedDeployments = getProcessedDeployments();\n-        //While this method is being run, another thread could be running the publishPersistedStatusUpdates\n-        // method which consumes the data in config from the same topics. These two thread needs to be synchronized\n-        synchronized (processedDeployments) {\n+        synchronized (this) {\n+            //While this method is being run, another thread could be running the publishPersistedStatusUpdates\n+            // method which consumes the data in config from the same topics. These two thread needs to be synchronized\n             logger.atDebug().kv(JOB_ID_LOG_KEY_NAME, jobId).kv(\"JobStatus\", status).log(\"Storing job status\");\n             Map<String, Object> deploymentDetails = new HashMap<>();\n             deploymentDetails.put(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID, jobId);\n             deploymentDetails.put(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS, status);\n             deploymentDetails.put(PERSISTED_DEPLOYMENT_STATUS_KEY_STATUS_DETAILS, statusDetails);\n             deploymentDetails.put(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_TYPE, deploymentType);\n             //Each status update is uniquely stored\n+            Topics processedDeployments = getProcessedDeployments();\n             Topic thisJob = processedDeployments.createLeafChild(String.valueOf(System.currentTimeMillis()));\n             thisJob.withValue(deploymentDetails);\n-\n-            if (getConsumerForDeploymentType(deploymentType).apply(deploymentDetails)) {\n-                processedDeployments.remove(thisJob);\n-            }\n         }\n+\n+        publishPersistedStatusUpdates(deploymentType);", "originalCommit": "d86f365ca47c6cef84468de01d3ea64a2838e069", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3NDY2OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/255#discussion_r429474668", "bodyText": "This is the main change I'm trying to get in. If we just publish the current deployment, then other earlier persisted deployments will not be published before the current one.\nIn the failed test logs, on reconnect, DS called publishPersistedStatusUpdates to publish status IN_PROGRESS, but here we might already updated the status to SUCCEEDED", "author": "hui-yang", "createdAt": "2020-05-22T22:08:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3MTgyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3NzAzMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/255#discussion_r429477033", "bodyText": "I agree that we should publish all the updates for the same deployment in order, but to do that should we retry all deployments with the same type?", "author": "fahadmohammed01", "createdAt": "2020-05-22T22:20:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3MTgyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ4NjU3MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/255#discussion_r429486571", "bodyText": "Discussed with @abanthiy as well. Consolidating the status updates and/or grouping by deployments adds overhead. For now, I'm just going to retry all in order. Also we don't support parallel deployments, so the ordered status updates are most likely for deployments one by one.", "author": "hui-yang", "createdAt": "2020-05-22T23:17:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3MTgyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3MzUwMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/255#discussion_r429473503", "bodyText": "synchronize on type to enable better parallelization?", "author": "fahadmohammed01", "createdAt": "2020-05-22T22:02:52Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentStatusKeeper.java", "diffHunk": "@@ -92,43 +90,40 @@ public void persistAndPublishDeploymentStatus(String jobId, DeploymentType deplo\n      * all deployments the device performed when offline\n      * @param type deployment type\n      */\n-    public void publishPersistedStatusUpdates(DeploymentType type) {\n+    public synchronized void publishPersistedStatusUpdates(DeploymentType type) {\n         Topics processedDeployments = getProcessedDeployments();", "originalCommit": "d86f365ca47c6cef84468de01d3ea64a2838e069", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3NDc0Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/255#discussion_r429474747", "bodyText": "I can try that.", "author": "hui-yang", "createdAt": "2020-05-22T22:08:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3MzUwMw=="}], "type": "inlineReview"}, {"oid": "af68be3993588d611443443c1747db8bb7cc99c8", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/af68be3993588d611443443c1747db8bb7cc99c8", "message": "Deflake MQTT reconnection test", "committedDate": "2020-05-23T00:56:26Z", "type": "commit"}, {"oid": "af68be3993588d611443443c1747db8bb7cc99c8", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/af68be3993588d611443443c1747db8bb7cc99c8", "message": "Deflake MQTT reconnection test", "committedDate": "2020-05-23T00:56:26Z", "type": "forcePushed"}, {"oid": "cbbeba99c682b1474f5583c32051bfac6c1e297c", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/cbbeba99c682b1474f5583c32051bfac6c1e297c", "message": "Merge branch 'master' into mqtt-fix", "committedDate": "2020-05-26T18:12:14Z", "type": "commit"}, {"oid": "b27e18a57c44252b764df393d2885debe06618d6", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/b27e18a57c44252b764df393d2885debe06618d6", "message": "Merge branch 'master' into mqtt-fix", "committedDate": "2020-05-26T19:20:50Z", "type": "commit"}, {"oid": "d4e243af8ae5350f11bd6d132f4d499d9a228ba0", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/d4e243af8ae5350f11bd6d132f4d499d9a228ba0", "message": "Merge branch 'master' into mqtt-fix", "committedDate": "2020-05-26T23:08:59Z", "type": "commit"}]}