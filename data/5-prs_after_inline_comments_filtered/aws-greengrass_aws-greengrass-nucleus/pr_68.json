{"pr_number": 68, "pr_title": "Add Local Package Provider and tests", "pr_createdAt": "2020-02-21T18:43:11Z", "pr_url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/68", "timeline": [{"oid": "d3db4fd376476ea57ddb446a533f259f007583d1", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/d3db4fd376476ea57ddb446a533f259f007583d1", "message": "Add package manager initial code", "committedDate": "2020-02-21T19:58:39Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg1MzE1OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/68#discussion_r382853159", "bodyText": "just set this in the field declaration.", "author": "MikeDombo", "createdAt": "2020-02-21T23:30:44Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -0,0 +1,253 @@\n+package com.aws.iot.evergreen.packagemanager;\n+\n+\n+import com.aws.iot.evergreen.packagemanager.config.Constants;\n+import com.aws.iot.evergreen.packagemanager.exceptions.NoValidDependencyTreeException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageNotFoundException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnexpectedPackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRecipe;\n+import com.aws.iot.evergreen.packagemanager.plugins.PackageStore;\n+import com.aws.iot.evergreen.packagemanager.plugins.impl.LocalPackageStore;\n+import com.vdurmont.semver4j.Semver;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Queue;\n+import java.util.stream.Collectors;\n+\n+\n+public class PackageManager {\n+\n+    private static final Path CACHE_DIRECTORY = Paths.get(System.getProperty(\"user.dir\")).resolve(\"artifact_cache\");\n+    private static final Path MOCK_PACKAGE_SOURCE = Paths.get(System.getProperty(\"user.dir\")).resolve(\n+            \"mock_artifact_source\");\n+\n+    private PackageStore localPackageCache;\n+\n+    private List<PackageStore> packageSources;\n+\n+    /**\n+     * Constructor with custom path for mock respository.\n+     * Currently only used for testing.\n+     * TODO: Should be replaced with a proper config object\n+     *\n+     * @param mockPackageSourcePath PackageRecipe Package to copy\n+     */\n+    public PackageManager(final Path packageCachePath, final Path mockPackageSourcePath) {\n+        this.localPackageCache = new LocalPackageStore(packageCachePath);\n+        this.packageSources = new ArrayList<>();", "originalCommit": "d3db4fd376476ea57ddb446a533f259f007583d1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg2NjA3Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/68#discussion_r382866072", "bodyText": "updating", "author": "chaurah", "createdAt": "2020-02-22T00:37:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg1MzE1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg1MzYyNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/68#discussion_r382853625", "bodyText": "Shouldn't this combine all the versions from all package stores?\nSet<Semver> response = new HashSet<>();\nfor (...) {\n    response.addAll(pkgStore.get....)\n}", "author": "MikeDombo", "createdAt": "2020-02-21T23:32:34Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -0,0 +1,253 @@\n+package com.aws.iot.evergreen.packagemanager;\n+\n+\n+import com.aws.iot.evergreen.packagemanager.config.Constants;\n+import com.aws.iot.evergreen.packagemanager.exceptions.NoValidDependencyTreeException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageNotFoundException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnexpectedPackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRecipe;\n+import com.aws.iot.evergreen.packagemanager.plugins.PackageStore;\n+import com.aws.iot.evergreen.packagemanager.plugins.impl.LocalPackageStore;\n+import com.vdurmont.semver4j.Semver;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Queue;\n+import java.util.stream.Collectors;\n+\n+\n+public class PackageManager {\n+\n+    private static final Path CACHE_DIRECTORY = Paths.get(System.getProperty(\"user.dir\")).resolve(\"artifact_cache\");\n+    private static final Path MOCK_PACKAGE_SOURCE = Paths.get(System.getProperty(\"user.dir\")).resolve(\n+            \"mock_artifact_source\");\n+\n+    private PackageStore localPackageCache;\n+\n+    private List<PackageStore> packageSources;\n+\n+    /**\n+     * Constructor with custom path for mock respository.\n+     * Currently only used for testing.\n+     * TODO: Should be replaced with a proper config object\n+     *\n+     * @param mockPackageSourcePath PackageRecipe Package to copy\n+     */\n+    public PackageManager(final Path packageCachePath, final Path mockPackageSourcePath) {\n+        this.localPackageCache = new LocalPackageStore(packageCachePath);\n+        this.packageSources = new ArrayList<>();\n+        packageSources.add(new LocalPackageStore(mockPackageSourcePath));\n+        // Add other sources (EPMS etc)\n+    }\n+\n+    /*\n+        TODO: Move to README.md Current working flows are as below:\n+        For ONLY ONE PACKAGE, ignores dependencies:\n+        1) Cache specific package from specific local directory using one of the cachePackage functions\n+           1.1) If you want to use only name and version, mock_artifact_source directory must be present in user.dir\n+        2) Call copyPackageArtifactsToPath, provide package object returned in 1 and destination path\n+\n+        For ONLY ONE PACKAGE, also get dependencies:\n+        1) Cache specific package from specific local directory using one of the cachePackageAndDependencies functions\n+           1.1) Perform dependency resolution, get full dependency tree\n+           1.2) If you want to use only name and version, mock_artifact_source directory must be present in user.dir\n+           1.3) Returns list of all resolved packages with specific package versions\n+        2) Call copyPackageArtifactsToPath, provide package objects returned in 1 and destination path\n+\n+        For list of packages, perform full dependency resolution if needed (WIP):\n+        1) Call\n+           1.1) This will Cache packages where specific versions are provided\n+           1.2) Dependency resolution will be performed and a full list of required packages will be generated\n+           1.3) All identified specific versions of will be cached\n+           1.3) Response will include all packages as PackageRecipe objects. The CALLING CODE must call\n+           getDependency API for each package to get the names of the dependencies and pick the corresponding package\n+            object from the list\n+        2) For each returned object, call copyPackageArtifactsToPath, provide package object returned in 1\n+        and destination path\n+     */\n+\n+    /**\n+     * Cache all artifacts to a path.\n+     *\n+     * @param curPackage PackageRecipe Package to copy\n+     * @param destPath Path object describing the destination path\n+     */\n+    public void copyPackageArtifactsToPath(PackageRecipe curPackage, Path destPath) throws PackagingException {\n+        localPackageCache.copyPackageArtifactsToPath(curPackage, destPath);\n+    }\n+\n+    /**\n+     * Get all available versions for a package.\n+     *\n+     * @param pkgName PackageRecipe Package to query for\n+     * @return List of Semver objects containing the discovered package versions\n+     */\n+    public List<Semver> getAvailablePackageVersions(String pkgName)\n+            throws UnexpectedPackagingException {\n+        List<Semver> response = null;\n+\n+        // Defaults to first source where a response is found\n+        for (PackageStore pkgStore : packageSources) {\n+            response = pkgStore.getPackageVersionsIfExists(pkgName);", "originalCommit": "d3db4fd376476ea57ddb446a533f259f007583d1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg2NTk4Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/68#discussion_r382865982", "bodyText": "Ideally yes, but to do that, I would also need to keep a track of the source of each version and probably build some sort of conflict resolution around that. This seemed simple to start with and keep the initial PR small. As we build more package sources, we can do further iterations to improve this bit.", "author": "chaurah", "createdAt": "2020-02-22T00:36:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg1MzYyNQ=="}], "type": "inlineReview"}, {"oid": "d166948a563c49d2ae44d6e4f22c9823f8ceb7f2", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/d166948a563c49d2ae44d6e4f22c9823f8ceb7f2", "message": "Add package manager initial code", "committedDate": "2020-02-22T01:11:05Z", "type": "forcePushed"}, {"oid": "ee82bfd132fb4b7f18dfd57fb4c3947d91740b46", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ee82bfd132fb4b7f18dfd57fb4c3947d91740b46", "message": "Add package manager initial code", "committedDate": "2020-02-22T01:16:55Z", "type": "forcePushed"}, {"oid": "f9c167b9d50347c9279889e97d8c5e3792f379ea", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/f9c167b9d50347c9279889e97d8c5e3792f379ea", "message": "Add package manager initial code", "committedDate": "2020-02-22T01:55:27Z", "type": "forcePushed"}, {"oid": "a5e84fa654cbd8832232b90936ef6250f4c6ea79", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/a5e84fa654cbd8832232b90936ef6250f4c6ea79", "message": "Add package manager initial code", "committedDate": "2020-02-22T02:08:05Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg3Nzk5Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/68#discussion_r382877993", "bodyText": "Ideally these should be the same for all implementations of PackageStore no?", "author": "shaguptashaikh", "createdAt": "2020-02-22T02:24:52Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/plugins/LocalPackageStore.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package com.aws.iot.evergreen.packagemanager.plugins;\n+\n+import com.aws.iot.evergreen.packagemanager.config.Constants;\n+import com.aws.iot.evergreen.packagemanager.exceptions.DirectoryCreationFailedForPackageException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnexpectedPackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRecipe;\n+import com.vdurmont.semver4j.Semver;\n+import com.vdurmont.semver4j.SemverException;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n+\n+/**\n+ * Local Store Implementation for Evergreen Packages.\n+ */\n+public class LocalPackageStore implements PackageStore {\n+    private final Path cacheFolder;\n+\n+    private static Path getPackageStorageRoot(final String packageName,\n+                                             final Path cacheFolder) {\n+        return cacheFolder.resolve(packageName);\n+    }\n+\n+    private static Path getPackageVersionStorageRoot(final PackageRecipe curPackage, final Path cacheFolder) {\n+        return getPackageVersionStorageRoot(curPackage.getPackageName(), curPackage.getPackageVersion().toString(),\n+                                            cacheFolder);\n+    }\n+\n+    private static Path getPackageVersionStorageRoot(final String packageName, final String packageVersion,\n+                                              final Path cacheFolder) {\n+        return getPackageStorageRoot(packageName, cacheFolder).resolve(packageVersion);\n+    }\n+", "originalCommit": "a5e84fa654cbd8832232b90936ef6250f4c6ea79", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg4OTQ4Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/68#discussion_r382889486", "bodyText": "If the package store is a network location then maybe not. Carrying over from my comment in the other PR, this is likely the base class for all package stores. Same proposal as the other PR, let's refactor this when we add more Package Stores and see there's a need for an abstract/common base class.", "author": "chaurah", "createdAt": "2020-02-22T05:57:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg3Nzk5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg3ODAxMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/68#discussion_r382878010", "bodyText": "Lombok?", "author": "shaguptashaikh", "createdAt": "2020-02-22T02:25:02Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/plugins/LocalPackageStore.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package com.aws.iot.evergreen.packagemanager.plugins;\n+\n+import com.aws.iot.evergreen.packagemanager.config.Constants;\n+import com.aws.iot.evergreen.packagemanager.exceptions.DirectoryCreationFailedForPackageException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnexpectedPackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRecipe;\n+import com.vdurmont.semver4j.Semver;\n+import com.vdurmont.semver4j.SemverException;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n+\n+/**\n+ * Local Store Implementation for Evergreen Packages.\n+ */\n+public class LocalPackageStore implements PackageStore {\n+    private final Path cacheFolder;\n+\n+    private static Path getPackageStorageRoot(final String packageName,\n+                                             final Path cacheFolder) {\n+        return cacheFolder.resolve(packageName);\n+    }\n+\n+    private static Path getPackageVersionStorageRoot(final PackageRecipe curPackage, final Path cacheFolder) {\n+        return getPackageVersionStorageRoot(curPackage.getPackageName(), curPackage.getPackageVersion().toString(),\n+                                            cacheFolder);\n+    }\n+\n+    private static Path getPackageVersionStorageRoot(final String packageName, final String packageVersion,\n+                                              final Path cacheFolder) {\n+        return getPackageStorageRoot(packageName, cacheFolder).resolve(packageVersion);\n+    }\n+\n+    public LocalPackageStore(Path cacheFolder) {\n+        this.cacheFolder = cacheFolder;\n+    }", "originalCommit": "a5e84fa654cbd8832232b90936ef6250f4c6ea79", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAzMDM3OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/68#discussion_r383030379", "bodyText": "Updated", "author": "chaurah", "createdAt": "2020-02-23T19:11:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg3ODAxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg3ODEwNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/68#discussion_r382878104", "bodyText": "Combine these?", "author": "shaguptashaikh", "createdAt": "2020-02-22T02:26:07Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/plugins/LocalPackageStore.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package com.aws.iot.evergreen.packagemanager.plugins;\n+\n+import com.aws.iot.evergreen.packagemanager.config.Constants;\n+import com.aws.iot.evergreen.packagemanager.exceptions.DirectoryCreationFailedForPackageException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnexpectedPackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRecipe;\n+import com.vdurmont.semver4j.Semver;\n+import com.vdurmont.semver4j.SemverException;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n+\n+/**\n+ * Local Store Implementation for Evergreen Packages.\n+ */\n+public class LocalPackageStore implements PackageStore {\n+    private final Path cacheFolder;\n+\n+    private static Path getPackageStorageRoot(final String packageName,\n+                                             final Path cacheFolder) {\n+        return cacheFolder.resolve(packageName);\n+    }\n+\n+    private static Path getPackageVersionStorageRoot(final PackageRecipe curPackage, final Path cacheFolder) {\n+        return getPackageVersionStorageRoot(curPackage.getPackageName(), curPackage.getPackageVersion().toString(),\n+                                            cacheFolder);\n+    }\n+\n+    private static Path getPackageVersionStorageRoot(final String packageName, final String packageVersion,\n+                                              final Path cacheFolder) {\n+        return getPackageStorageRoot(packageName, cacheFolder).resolve(packageVersion);\n+    }\n+\n+    public LocalPackageStore(Path cacheFolder) {\n+        this.cacheFolder = cacheFolder;\n+    }\n+\n+    /**\n+     * Get package from cache if it exists.\n+     * @return\n+     */\n+    @Override\n+    public Optional<String> getPackageRecipeIfExists(final String packageName,\n+                                                     final Semver packageVersion) {\n+        Path srcPkgRoot = getPackageVersionStorageRoot(packageName, packageVersion.toString(),\n+                                                       cacheFolder);\n+\n+        if (!Files.exists(srcPkgRoot) || !Files.isDirectory(srcPkgRoot)) {\n+            return Optional.empty();\n+        }\n+        // TODO: Move to a Common list of Constants\n+        Path recipePath = srcPkgRoot.resolve(Constants.RECIPE_FILE_NAME);\n+\n+        if (!Files.exists(recipePath) && Files.isRegularFile(recipePath)) {\n+            throw new RuntimeException(\"Package manager cache is corrupt\");\n+            // TODO Take some corrective actions before throwing\n+        }\n+\n+        try {\n+            return Optional.of(new String(Files.readAllBytes(recipePath), StandardCharsets.UTF_8));\n+        } catch (IOException e) {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    /**\n+     * Get package from cache if it exists.\n+     */\n+    @Override\n+    public List<Semver> getPackageVersionsIfExists(final String packageName)\n+            throws UnexpectedPackagingException {\n+        Path srcPkgRoot = getPackageStorageRoot(packageName, cacheFolder);\n+        List<Semver> versions = new ArrayList<>();\n+\n+        if (!Files.exists(srcPkgRoot) || !Files.isDirectory(srcPkgRoot)) {\n+            return versions;\n+        }\n+\n+        File[] versionDirs = srcPkgRoot.toFile().listFiles();\n+        if (versionDirs == null || versionDirs.length == 0) {\n+            return versions;\n+        }\n+\n+        try {\n+            for (File versionDir : versionDirs) {\n+                versions.add(new Semver(versionDir.getName(), Semver.SemverType.NPM));\n+            }\n+        } catch (SemverException e) {\n+            throw new UnexpectedPackagingException(\"Package Cache is corrupted! \" + e.toString());\n+        }\n+\n+        return versions;\n+    }\n+\n+    /**\n+     * Get package from cache if it exists.\n+     */\n+    @Override\n+    public Optional<Semver> getLatestPackageVersionIfExists(final String packageName) {\n+        // Add check for package override\n+\n+        try {\n+            List<Semver> versions = getPackageVersionsIfExists(packageName);\n+            versions.sort(null);\n+\n+            return Optional.ofNullable(versions.get(0));\n+        } catch (UnexpectedPackagingException e) {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    /**\n+     * Cache all artifacts for a given Package.\n+     */\n+    @Override\n+    public void cachePackageArtifacts(final PackageRecipe curPackage) throws PackagingException {\n+        if (curPackage == null) {\n+            // TODO: Check and handle correctly\n+            throw new NullPointerException(\"Package cannot be null\");\n+        }\n+\n+        Path destRootPkgPath = getPackageVersionStorageRoot(curPackage, cacheFolder);\n+\n+        try {\n+            if (Files.notExists(destRootPkgPath)) {\n+                Files.createDirectories(destRootPkgPath);\n+            }\n+            Set<ArtifactProvider> artifacts = curPackage.getArtifactProviders();\n+            for (ArtifactProvider artifactUrl : artifacts) {\n+                artifactUrl.downloadArtifactToPath(destRootPkgPath);\n+            }\n+        } catch (IOException e) {\n+            throw new PackagingException(\"Failed to download artifacts for \" + curPackage.getPackageName());\n+        }\n+    }\n+\n+    /**\n+     * Cache all artifacts for a given Package.\n+     */\n+    @Override\n+    public void cachePackageRecipeAndArtifacts(final PackageRecipe curPackage, final String recipeContents)\n+            throws PackagingException {\n+        if (curPackage == null) {\n+            // TODO: Check and handle correctly\n+            throw new NullPointerException(\"Package cannot be null\");\n+        }\n+\n+        Path destRootPkgPath = getPackageVersionStorageRoot(curPackage, cacheFolder);\n+        Path pkgRecipePath = destRootPkgPath.resolve(Constants.RECIPE_FILE_NAME);\n+\n+        try {\n+            Files.createDirectories(destRootPkgPath);\n+        } catch (IOException e) {\n+            throw new DirectoryCreationFailedForPackageException(\"Failed to create folder for \"\n+                                                                         + destRootPkgPath.toString());\n+        }\n+\n+        try {\n+            Files.write(pkgRecipePath, recipeContents.getBytes(StandardCharsets.UTF_8));\n+        } catch (IOException e) {\n+            throw new PackagingException(\"Failed to cache recipe for \" + destRootPkgPath.toString());\n+        }\n+\n+        cachePackageArtifacts(curPackage);\n+    }\n+\n+    /**\n+     * Cache all artifacts to a path.\n+     */\n+    @Override\n+    public void copyPackageArtifactsToPath(final PackageRecipe curPackage, final Path destPath)\n+            throws PackagingException {\n+        if (curPackage == null) {\n+            // TODO: Check and handle correctly\n+            throw new NullPointerException(\"Package cannot be null\");\n+        }\n+\n+        Path srcRootPkgPath = getPackageVersionStorageRoot(curPackage, cacheFolder);\n+        Path destRootPkgPath = getPackageVersionStorageRoot(curPackage, destPath);\n+\n+        copyPackageArtifactsToPath(curPackage, srcRootPkgPath, destRootPkgPath);\n+    }\n+\n+    /**\n+     * Copy all artifacts to a path.\n+     */\n+    private void copyPackageArtifactsToPath(PackageRecipe curPackage, Path srcRootPkgPath,\n+                                            Path destRootPkgPath) throws PackagingException {\n+        if (!Files.exists(srcRootPkgPath) || !Files.isDirectory(srcRootPkgPath)) {\n+            // TODO: This is may not be the best choice? Maybe throw an exception and die?\n+            cachePackageArtifacts(curPackage);\n+        }\n+\n+        try {\n+            Files.createDirectories(destRootPkgPath);\n+        } catch (IOException e) {\n+            throw new PackagingException(\"Failed to create folder for \" + destRootPkgPath);\n+        }\n+\n+        try {\n+            Files.walk(srcRootPkgPath)\n+                 .forEach(source -> {\n+                     try {\n+                         if (Files.isDirectory(source)) {\n+                             if (Files.notExists(source)) {", "originalCommit": "a5e84fa654cbd8832232b90936ef6250f4c6ea79", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAzMDQyMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/68#discussion_r383030420", "bodyText": "Done", "author": "chaurah", "createdAt": "2020-02-23T19:12:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg3ODEwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg3ODQyMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/68#discussion_r382878422", "bodyText": "Nit- Could do Objects.requireNonNull if you want to validate and error out", "author": "shaguptashaikh", "createdAt": "2020-02-22T02:31:04Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/plugins/LocalPackageStore.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package com.aws.iot.evergreen.packagemanager.plugins;\n+\n+import com.aws.iot.evergreen.packagemanager.config.Constants;\n+import com.aws.iot.evergreen.packagemanager.exceptions.DirectoryCreationFailedForPackageException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnexpectedPackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRecipe;\n+import com.vdurmont.semver4j.Semver;\n+import com.vdurmont.semver4j.SemverException;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n+\n+/**\n+ * Local Store Implementation for Evergreen Packages.\n+ */\n+public class LocalPackageStore implements PackageStore {\n+    private final Path cacheFolder;\n+\n+    private static Path getPackageStorageRoot(final String packageName,\n+                                             final Path cacheFolder) {\n+        return cacheFolder.resolve(packageName);\n+    }\n+\n+    private static Path getPackageVersionStorageRoot(final PackageRecipe curPackage, final Path cacheFolder) {\n+        return getPackageVersionStorageRoot(curPackage.getPackageName(), curPackage.getPackageVersion().toString(),\n+                                            cacheFolder);\n+    }\n+\n+    private static Path getPackageVersionStorageRoot(final String packageName, final String packageVersion,\n+                                              final Path cacheFolder) {\n+        return getPackageStorageRoot(packageName, cacheFolder).resolve(packageVersion);\n+    }\n+\n+    public LocalPackageStore(Path cacheFolder) {\n+        this.cacheFolder = cacheFolder;\n+    }\n+\n+    /**\n+     * Get package from cache if it exists.\n+     * @return\n+     */\n+    @Override\n+    public Optional<String> getPackageRecipeIfExists(final String packageName,\n+                                                     final Semver packageVersion) {\n+        Path srcPkgRoot = getPackageVersionStorageRoot(packageName, packageVersion.toString(),\n+                                                       cacheFolder);\n+\n+        if (!Files.exists(srcPkgRoot) || !Files.isDirectory(srcPkgRoot)) {\n+            return Optional.empty();\n+        }\n+        // TODO: Move to a Common list of Constants\n+        Path recipePath = srcPkgRoot.resolve(Constants.RECIPE_FILE_NAME);\n+\n+        if (!Files.exists(recipePath) && Files.isRegularFile(recipePath)) {\n+            throw new RuntimeException(\"Package manager cache is corrupt\");\n+            // TODO Take some corrective actions before throwing\n+        }\n+\n+        try {\n+            return Optional.of(new String(Files.readAllBytes(recipePath), StandardCharsets.UTF_8));\n+        } catch (IOException e) {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    /**\n+     * Get package from cache if it exists.\n+     */\n+    @Override\n+    public List<Semver> getPackageVersionsIfExists(final String packageName)\n+            throws UnexpectedPackagingException {\n+        Path srcPkgRoot = getPackageStorageRoot(packageName, cacheFolder);\n+        List<Semver> versions = new ArrayList<>();\n+\n+        if (!Files.exists(srcPkgRoot) || !Files.isDirectory(srcPkgRoot)) {\n+            return versions;\n+        }\n+\n+        File[] versionDirs = srcPkgRoot.toFile().listFiles();\n+        if (versionDirs == null || versionDirs.length == 0) {\n+            return versions;\n+        }\n+\n+        try {\n+            for (File versionDir : versionDirs) {\n+                versions.add(new Semver(versionDir.getName(), Semver.SemverType.NPM));\n+            }\n+        } catch (SemverException e) {\n+            throw new UnexpectedPackagingException(\"Package Cache is corrupted! \" + e.toString());\n+        }\n+\n+        return versions;\n+    }\n+\n+    /**\n+     * Get package from cache if it exists.\n+     */\n+    @Override\n+    public Optional<Semver> getLatestPackageVersionIfExists(final String packageName) {\n+        // Add check for package override\n+\n+        try {\n+            List<Semver> versions = getPackageVersionsIfExists(packageName);\n+            versions.sort(null);\n+\n+            return Optional.ofNullable(versions.get(0));\n+        } catch (UnexpectedPackagingException e) {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    /**\n+     * Cache all artifacts for a given Package.\n+     */\n+    @Override\n+    public void cachePackageArtifacts(final PackageRecipe curPackage) throws PackagingException {\n+        if (curPackage == null) {\n+            // TODO: Check and handle correctly\n+            throw new NullPointerException(\"Package cannot be null\");\n+        }\n+\n+        Path destRootPkgPath = getPackageVersionStorageRoot(curPackage, cacheFolder);\n+\n+        try {\n+            if (Files.notExists(destRootPkgPath)) {\n+                Files.createDirectories(destRootPkgPath);\n+            }\n+            Set<ArtifactProvider> artifacts = curPackage.getArtifactProviders();\n+            for (ArtifactProvider artifactUrl : artifacts) {\n+                artifactUrl.downloadArtifactToPath(destRootPkgPath);\n+            }\n+        } catch (IOException e) {\n+            throw new PackagingException(\"Failed to download artifacts for \" + curPackage.getPackageName());\n+        }\n+    }\n+\n+    /**\n+     * Cache all artifacts for a given Package.\n+     */\n+    @Override\n+    public void cachePackageRecipeAndArtifacts(final PackageRecipe curPackage, final String recipeContents)\n+            throws PackagingException {\n+        if (curPackage == null) {\n+            // TODO: Check and handle correctly\n+            throw new NullPointerException(\"Package cannot be null\");\n+        }\n+\n+        Path destRootPkgPath = getPackageVersionStorageRoot(curPackage, cacheFolder);\n+        Path pkgRecipePath = destRootPkgPath.resolve(Constants.RECIPE_FILE_NAME);\n+\n+        try {\n+            Files.createDirectories(destRootPkgPath);\n+        } catch (IOException e) {\n+            throw new DirectoryCreationFailedForPackageException(\"Failed to create folder for \"\n+                                                                         + destRootPkgPath.toString());\n+        }\n+\n+        try {\n+            Files.write(pkgRecipePath, recipeContents.getBytes(StandardCharsets.UTF_8));\n+        } catch (IOException e) {\n+            throw new PackagingException(\"Failed to cache recipe for \" + destRootPkgPath.toString());\n+        }\n+\n+        cachePackageArtifacts(curPackage);\n+    }\n+\n+    /**\n+     * Cache all artifacts to a path.\n+     */\n+    @Override\n+    public void copyPackageArtifactsToPath(final PackageRecipe curPackage, final Path destPath)\n+            throws PackagingException {\n+        if (curPackage == null) {\n+            // TODO: Check and handle correctly\n+            throw new NullPointerException(\"Package cannot be null\");\n+        }", "originalCommit": "a5e84fa654cbd8832232b90936ef6250f4c6ea79", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAzMDcyMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/68#discussion_r383030721", "bodyText": "Updated everywhere", "author": "chaurah", "createdAt": "2020-02-23T19:17:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg3ODQyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg3ODg2MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/68#discussion_r382878861", "bodyText": "Why empty?", "author": "shaguptashaikh", "createdAt": "2020-02-22T02:37:41Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/config/PackagingServiceConfig.java", "diffHunk": "@@ -0,0 +1,5 @@\n+package com.aws.iot.evergreen.packagemanager.config;\n+\n+public class PackagingServiceConfig {\n+\n+}", "originalCommit": "a5e84fa654cbd8832232b90936ef6250f4c6ea79", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg4OTM4Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/68#discussion_r382889383", "bodyText": "Removed.", "author": "chaurah", "createdAt": "2020-02-22T05:55:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg3ODg2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg3OTYyNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/68#discussion_r382879625", "bodyText": "Is silent failure okay here? In the above method where you throw UnexpectedPackagingException it says that the cache is corrupt", "author": "shaguptashaikh", "createdAt": "2020-02-22T02:49:51Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/plugins/LocalPackageStore.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package com.aws.iot.evergreen.packagemanager.plugins;\n+\n+import com.aws.iot.evergreen.packagemanager.config.Constants;\n+import com.aws.iot.evergreen.packagemanager.exceptions.DirectoryCreationFailedForPackageException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnexpectedPackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRecipe;\n+import com.vdurmont.semver4j.Semver;\n+import com.vdurmont.semver4j.SemverException;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n+\n+/**\n+ * Local Store Implementation for Evergreen Packages.\n+ */\n+public class LocalPackageStore implements PackageStore {\n+    private final Path cacheFolder;\n+\n+    private static Path getPackageStorageRoot(final String packageName,\n+                                             final Path cacheFolder) {\n+        return cacheFolder.resolve(packageName);\n+    }\n+\n+    private static Path getPackageVersionStorageRoot(final PackageRecipe curPackage, final Path cacheFolder) {\n+        return getPackageVersionStorageRoot(curPackage.getPackageName(), curPackage.getPackageVersion().toString(),\n+                                            cacheFolder);\n+    }\n+\n+    private static Path getPackageVersionStorageRoot(final String packageName, final String packageVersion,\n+                                              final Path cacheFolder) {\n+        return getPackageStorageRoot(packageName, cacheFolder).resolve(packageVersion);\n+    }\n+\n+    public LocalPackageStore(Path cacheFolder) {\n+        this.cacheFolder = cacheFolder;\n+    }\n+\n+    /**\n+     * Get package from cache if it exists.\n+     * @return\n+     */\n+    @Override\n+    public Optional<String> getPackageRecipeIfExists(final String packageName,\n+                                                     final Semver packageVersion) {\n+        Path srcPkgRoot = getPackageVersionStorageRoot(packageName, packageVersion.toString(),\n+                                                       cacheFolder);\n+\n+        if (!Files.exists(srcPkgRoot) || !Files.isDirectory(srcPkgRoot)) {\n+            return Optional.empty();\n+        }\n+        // TODO: Move to a Common list of Constants\n+        Path recipePath = srcPkgRoot.resolve(Constants.RECIPE_FILE_NAME);\n+\n+        if (!Files.exists(recipePath) && Files.isRegularFile(recipePath)) {\n+            throw new RuntimeException(\"Package manager cache is corrupt\");\n+            // TODO Take some corrective actions before throwing\n+        }\n+\n+        try {\n+            return Optional.of(new String(Files.readAllBytes(recipePath), StandardCharsets.UTF_8));\n+        } catch (IOException e) {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    /**\n+     * Get package from cache if it exists.\n+     */\n+    @Override\n+    public List<Semver> getPackageVersionsIfExists(final String packageName)\n+            throws UnexpectedPackagingException {\n+        Path srcPkgRoot = getPackageStorageRoot(packageName, cacheFolder);\n+        List<Semver> versions = new ArrayList<>();\n+\n+        if (!Files.exists(srcPkgRoot) || !Files.isDirectory(srcPkgRoot)) {\n+            return versions;\n+        }\n+\n+        File[] versionDirs = srcPkgRoot.toFile().listFiles();\n+        if (versionDirs == null || versionDirs.length == 0) {\n+            return versions;\n+        }\n+\n+        try {\n+            for (File versionDir : versionDirs) {\n+                versions.add(new Semver(versionDir.getName(), Semver.SemverType.NPM));\n+            }\n+        } catch (SemverException e) {\n+            throw new UnexpectedPackagingException(\"Package Cache is corrupted! \" + e.toString());\n+        }\n+\n+        return versions;\n+    }\n+\n+    /**\n+     * Get package from cache if it exists.\n+     */\n+    @Override\n+    public Optional<Semver> getLatestPackageVersionIfExists(final String packageName) {\n+        // Add check for package override\n+\n+        try {\n+            List<Semver> versions = getPackageVersionsIfExists(packageName);\n+            versions.sort(null);\n+\n+            return Optional.ofNullable(versions.get(0));\n+        } catch (UnexpectedPackagingException e) {\n+            return Optional.empty();", "originalCommit": "a5e84fa654cbd8832232b90936ef6250f4c6ea79", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAzMTAyMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/68#discussion_r383031020", "bodyText": "Good catch, updated", "author": "chaurah", "createdAt": "2020-02-23T19:22:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg3OTYyNQ=="}], "type": "inlineReview"}, {"oid": "4e68d7c6e4ed303010cf053fa5b953ac955debad", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/4e68d7c6e4ed303010cf053fa5b953ac955debad", "message": "Removed unused Config file, General cleanup", "committedDate": "2020-02-23T19:35:14Z", "type": "forcePushed"}, {"oid": "9ab461c1a2475d385a109269eff0757aa7ee453a", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/9ab461c1a2475d385a109269eff0757aa7ee453a", "message": "Removed unused Config file, General cleanup", "committedDate": "2020-02-23T19:51:45Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA0NDUxMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/68#discussion_r383044510", "bodyText": "Why is this method static?", "author": "shaguptashaikh", "createdAt": "2020-02-23T22:24:51Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -0,0 +1,280 @@\n+package com.aws.iot.evergreen.packagemanager;\n+\n+import com.aws.iot.evergreen.packagemanager.config.Constants;\n+import com.aws.iot.evergreen.packagemanager.exceptions.NoValidDependencyTreeException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageNotFoundException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnexpectedPackagingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnsupportedRecipeFormatException;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRecipe;\n+import com.aws.iot.evergreen.packagemanager.plugins.LocalPackageStore;\n+import com.aws.iot.evergreen.packagemanager.plugins.PackageStore;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import com.vdurmont.semver4j.Semver;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Queue;\n+import java.util.stream.Collectors;\n+\n+\n+public class PackageManager {\n+\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper(new YAMLFactory());\n+\n+    static {\n+        OBJECT_MAPPER.configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true);\n+    }\n+\n+\n+    private static final Path CACHE_DIRECTORY = Paths.get(System.getProperty(\"user.dir\")).resolve(\"artifact_cache\");\n+    private static final Path MOCK_PACKAGE_SOURCE = Paths.get(System.getProperty(\"user.dir\")).resolve(\n+            \"mock_artifact_source\");\n+\n+    private PackageStore localPackageCache;\n+\n+    private List<PackageStore> packageSources = new ArrayList<>();\n+\n+    /**\n+     * Constructor with custom path for mock respository.\n+     * Currently only used for testing.\n+     * TODO: Should be replaced with a proper config object\n+     *\n+     * @param mockPackageSourcePath PackageRecipe Package to copy\n+     */\n+    public PackageManager(final Path packageCachePath, final Path mockPackageSourcePath) {\n+        this.localPackageCache = new LocalPackageStore(packageCachePath);\n+        packageSources.add(new LocalPackageStore(mockPackageSourcePath));\n+        // Add other sources (EPMS etc)\n+    }\n+\n+    /**\n+     * Build package object from Recipe file and register it to the package database.\n+     *\n+     * @param recipe Recipe contents\n+     * @return Package described by the input recipe file\n+     */\n+    public static PackageRecipe getPackageObject(String recipe)", "originalCommit": "9ab461c1a2475d385a109269eff0757aa7ee453a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA4Nzk0OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/68#discussion_r383087948", "bodyText": "Object mapper is static. In theory there will always be only one PM instance but this can be revisited if needed.", "author": "chaurah", "createdAt": "2020-02-24T05:11:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA0NDUxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA0NjMxMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/68#discussion_r383046313", "bodyText": "I cannot clearly establish the interface between deployment orchestrator and package manager by looking at this class since all methods are public. Is the DA going to call all of these?", "author": "shaguptashaikh", "createdAt": "2020-02-23T22:47:46Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -0,0 +1,280 @@\n+package com.aws.iot.evergreen.packagemanager;\n+\n+import com.aws.iot.evergreen.packagemanager.config.Constants;\n+import com.aws.iot.evergreen.packagemanager.exceptions.NoValidDependencyTreeException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageNotFoundException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnexpectedPackagingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnsupportedRecipeFormatException;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRecipe;\n+import com.aws.iot.evergreen.packagemanager.plugins.LocalPackageStore;\n+import com.aws.iot.evergreen.packagemanager.plugins.PackageStore;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import com.vdurmont.semver4j.Semver;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Queue;\n+import java.util.stream.Collectors;\n+\n+\n+public class PackageManager {", "originalCommit": "9ab461c1a2475d385a109269eff0757aa7ee453a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA4ODQ3NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/68#discussion_r383088474", "bodyText": "This was written before last week's discussions, the DA/PM interface has changed now. Let's discuss in person tomorrow but at this point the only reason this interface is still here is for reference to implement dependency resolution in the new interface. I think we can remove this file completely and just use Jason's PR with the new interface.\nThe Local provider etc are still relevant and I can just have those merged with this PR.\nThe alternative is just merge and modify, the dependency resolution code is not going to change much.", "author": "chaurah", "createdAt": "2020-02-24T05:15:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA0NjMxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA0NzEyOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/68#discussion_r383047129", "bodyText": "Why is the dependency tree flattened out to a list? I understand this might have to do with the fact that cloud will send a partially resolved dependency list but shouldn't package manager send a tree in response per root package? In the next stage where we want to generate service config I expect a tree, which also IMO is cleaner than a flat list. I know it can partially be addressed by using the getDependencies method on PackageRecipe objects but it won't distinguish top level packages from the others so it won't be possible to form the new main service dependencies. PR for the code I'm talking about for context https://github.com/aws/aws-greengrass-kernel/pull/70/files", "author": "shaguptashaikh", "createdAt": "2020-02-23T22:56:52Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -0,0 +1,280 @@\n+package com.aws.iot.evergreen.packagemanager;\n+\n+import com.aws.iot.evergreen.packagemanager.config.Constants;\n+import com.aws.iot.evergreen.packagemanager.exceptions.NoValidDependencyTreeException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageNotFoundException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnexpectedPackagingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnsupportedRecipeFormatException;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRecipe;\n+import com.aws.iot.evergreen.packagemanager.plugins.LocalPackageStore;\n+import com.aws.iot.evergreen.packagemanager.plugins.PackageStore;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import com.vdurmont.semver4j.Semver;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Queue;\n+import java.util.stream.Collectors;\n+\n+\n+public class PackageManager {\n+\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper(new YAMLFactory());\n+\n+    static {\n+        OBJECT_MAPPER.configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true);\n+    }\n+\n+\n+    private static final Path CACHE_DIRECTORY = Paths.get(System.getProperty(\"user.dir\")).resolve(\"artifact_cache\");\n+    private static final Path MOCK_PACKAGE_SOURCE = Paths.get(System.getProperty(\"user.dir\")).resolve(\n+            \"mock_artifact_source\");\n+\n+    private PackageStore localPackageCache;\n+\n+    private List<PackageStore> packageSources = new ArrayList<>();\n+\n+    /**\n+     * Constructor with custom path for mock respository.\n+     * Currently only used for testing.\n+     * TODO: Should be replaced with a proper config object\n+     *\n+     * @param mockPackageSourcePath PackageRecipe Package to copy\n+     */\n+    public PackageManager(final Path packageCachePath, final Path mockPackageSourcePath) {\n+        this.localPackageCache = new LocalPackageStore(packageCachePath);\n+        packageSources.add(new LocalPackageStore(mockPackageSourcePath));\n+        // Add other sources (EPMS etc)\n+    }\n+\n+    /**\n+     * Build package object from Recipe file and register it to the package database.\n+     *\n+     * @param recipe Recipe contents\n+     * @return Package described by the input recipe file\n+     */\n+    public static PackageRecipe getPackageObject(String recipe)\n+            throws UnsupportedRecipeFormatException {\n+        PackageRecipe pkg = null;\n+        try {\n+            pkg = OBJECT_MAPPER.readValue(recipe, PackageRecipe.class);\n+        } catch (IOException e) {\n+            throw new UnsupportedRecipeFormatException(Constants.UNABLE_TO_PARSE_RECIPE_EXCEPTION_MSG, e);\n+        }\n+\n+        return pkg;\n+    }\n+\n+    /*\n+        TODO: Move to README.md Current working flows are as below:\n+        For ONLY ONE PACKAGE, ignores dependencies:\n+        1) Cache specific package from specific local directory using one of the cachePackage functions\n+           1.1) If you want to use only name and version, mock_artifact_source directory must be present in user.dir\n+        2) Call copyPackageArtifactsToPath, provide package object returned in 1 and destination path\n+\n+        For ONLY ONE PACKAGE, also get dependencies:\n+        1) Cache specific package from specific local directory using one of the cachePackageAndDependencies functions\n+           1.1) Perform dependency resolution, get full dependency tree\n+           1.2) If you want to use only name and version, mock_artifact_source directory must be present in user.dir\n+           1.3) Returns list of all resolved packages with specific package versions\n+        2) Call copyPackageArtifactsToPath, provide package objects returned in 1 and destination path\n+\n+        For list of packages, perform full dependency resolution if needed (WIP):\n+        1) Call\n+           1.1) This will Cache packages where specific versions are provided\n+           1.2) Dependency resolution will be performed and a full list of required packages will be generated\n+           1.3) All identified specific versions of will be cached\n+           1.3) Response will include all packages as PackageRecipe objects. The CALLING CODE must call\n+           getDependency API for each package to get the names of the dependencies and pick the corresponding package\n+            object from the list\n+        2) For each returned object, call copyPackageArtifactsToPath, provide package object returned in 1\n+        and destination path\n+     */\n+\n+    /**\n+     * Cache all artifacts to a path.\n+     *\n+     * @param curPackage PackageRecipe Package to copy\n+     * @param destPath Path object describing the destination path\n+     */\n+    public void copyPackageArtifactsToPath(PackageRecipe curPackage, Path destPath) throws PackagingException {\n+        localPackageCache.copyPackageArtifactsToPath(curPackage, destPath);\n+    }\n+\n+    /**\n+     * Get all available versions for a package.\n+     *\n+     * @param pkgName PackageRecipe Package to query for\n+     * @return List of Semver objects containing the discovered package versions\n+     */\n+    public List<Semver> getAvailablePackageVersions(String pkgName)\n+            throws UnexpectedPackagingException {\n+        List<Semver> response = null;\n+\n+        // Defaults to first source where a response is found\n+        for (PackageStore pkgStore : packageSources) {\n+            response = pkgStore.getPackageVersionsIfExists(pkgName);\n+            if (!response.isEmpty()) {\n+                break;\n+            }\n+        }\n+\n+        return response;\n+    }\n+\n+    /**\n+     * Cache a package from the recipe Contents. This will resolve and cache dependencies as well.\n+     *\n+     * @param recipeContents contents of a recipe file\n+     * @return Package described by above path\n+     */\n+    public ArrayList<PackageRecipe> cachePackageAndDependencies(final String recipeContents)\n+            throws PackagingException {\n+        HashMap<String, List<Semver>> pkgValidRangeMap = new HashMap<>();\n+\n+        PackageRecipe rootPackage = getPackageObject(recipeContents);\n+        this.localPackageCache.cachePackageRecipeAndArtifacts(rootPackage, recipeContents);\n+        List<Semver> rootVersions = new ArrayList<>();\n+        rootVersions.add(rootPackage.getPackageVersion());\n+        pkgValidRangeMap.put(rootPackage.getPackageName(), rootVersions);\n+\n+        HashMap<String, PackageRecipe> pkgObjectMap = new HashMap<>();\n+        pkgObjectMap.put(rootPackage.getPackageName(), rootPackage);\n+\n+        Queue<PackageRecipe> packageQueue = new LinkedList<>();\n+        if (!packageQueue.offer(rootPackage)) {\n+            // TODO needs better handling\n+            throw new UnexpectedPackagingException(\"Unexpected error\");\n+        }\n+        Comparator<Semver> descendingComparator = Collections.reverseOrder();\n+\n+        while (!packageQueue.isEmpty()) {\n+            PackageRecipe pkg = packageQueue.poll();\n+            Map<String, String> dependencyMap = pkg.getDependencies();\n+            for (Map.Entry dependencyEntry : dependencyMap.entrySet()) {\n+                String pkgName = (String)dependencyEntry.getKey();\n+                String pkgRange = (String)dependencyEntry.getValue();\n+                List<Semver> validVersions\n+                        = pkgValidRangeMap.containsKey(pkgName) ? pkgValidRangeMap.get(pkgName)\n+                                                                : getAvailablePackageVersions(pkgName);\n+\n+                //Semver.applyRangeToInput(validVersions, pkgRange);\n+                validVersions = validVersions.stream().filter(x -> x.satisfies(pkgRange)).collect(Collectors.toList());\n+                if (validVersions.isEmpty()) {\n+                    throw new NoValidDependencyTreeException(\"Dependency resolution couldn't identify a valid version\"\n+                                                                     + \" for \" + pkgName);\n+                }\n+\n+                validVersions.sort(descendingComparator);\n+                Semver newPkgVersion = validVersions.get(0);\n+                if (pkgObjectMap.containsKey(pkgName)) {\n+                    // Always get the latest possible version\n+                    PackageRecipe dpkg = pkgObjectMap.get(pkgName);\n+                    if (dpkg.getPackageVersion().compareTo(newPkgVersion) < 0) {\n+                        PackageRecipe newPkg = cachePackage(pkgName, newPkgVersion);\n+                        if (!packageQueue.offer(rootPackage)) {\n+                            // TODO needs better handling\n+                            throw new UnexpectedPackagingException(\"Unexpected error\");\n+                        }\n+                        pkgObjectMap.put(pkgName, newPkg);\n+                    }\n+                } else {\n+                    PackageRecipe newPkg = cachePackage(pkgName, newPkgVersion);\n+                    if (!packageQueue.offer(rootPackage)) {\n+                        // TODO needs better handling\n+                        throw new UnexpectedPackagingException(\"Unexpected error\");\n+                    }\n+                    pkgObjectMap.put(pkgName, newPkg);\n+                }\n+            }\n+        }\n+        return new ArrayList<>(pkgObjectMap.values());\n+    }\n+\n+    /**\n+     * Cache a package from the given package path. The path should be to the root folder where recipe.yaml is located.\n+     * This will resolve and cache dependencies as well.\n+     *\n+     * @param packagePath Path to package root\n+     * @return Package described by above path\n+     */\n+    public List<PackageRecipe> cachePackageAndDependencies(final Path packagePath)", "originalCommit": "9ab461c1a2475d385a109269eff0757aa7ee453a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA4ODA4MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/68#discussion_r383088080", "bodyText": "See comment above", "author": "chaurah", "createdAt": "2020-02-24T05:12:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA0NzEyOQ=="}], "type": "inlineReview"}, {"oid": "08e4fdf3cd33fe3f45cae67716c53b09d873bfdc", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/08e4fdf3cd33fe3f45cae67716c53b09d873bfdc", "message": "Add Local Artifact Store and tests", "committedDate": "2020-02-24T19:26:56Z", "type": "forcePushed"}, {"oid": "4ae3f1a65a66e01e13087dbc8929be7fb6789b35", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/4ae3f1a65a66e01e13087dbc8929be7fb6789b35", "message": "Add Local Artifact Store and tests", "committedDate": "2020-02-24T19:39:09Z", "type": "forcePushed"}, {"oid": "6f82b8a1c24a55fe04b395dc3179d6dc3907bfa4", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/6f82b8a1c24a55fe04b395dc3179d6dc3907bfa4", "message": "Add Local Artifact Store and tests", "committedDate": "2020-02-24T22:20:45Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDAxODA3NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/68#discussion_r384018074", "bodyText": "For errors like this, potentially just an IOException would be fine. I'm not saying to remove it since others may disagree, but I feel like this isn't especially necessary.", "author": "MikeDombo", "createdAt": "2020-02-25T17:25:43Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/exceptions/DirectoryCreationFailedForPackageException.java", "diffHunk": "@@ -0,0 +1,11 @@\n+package com.aws.iot.evergreen.packagemanager.exceptions;\n+\n+public class DirectoryCreationFailedForPackageException extends PackagingException {", "originalCommit": "6f82b8a1c24a55fe04b395dc3179d6dc3907bfa4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA1MzUwNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/68#discussion_r384053505", "bodyText": "I felt this is one of the use cases where some corrective action might be warranted. Keeping it for now but going to revisit this in a future PR with your comment in mind.", "author": "chaurah", "createdAt": "2020-02-25T18:45:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDAxODA3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDAzMTczMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/68#discussion_r384031731", "bodyText": "Can we not have a runtime exception here please.\nAlso, looks like this method should be using exceptions more than the optional so that we can pass information about what went wrong up the call stack.", "author": "MikeDombo", "createdAt": "2020-02-25T18:00:21Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/plugins/LocalPackageStore.java", "diffHunk": "@@ -0,0 +1,219 @@\n+package com.aws.iot.evergreen.packagemanager.plugins;\n+\n+import com.aws.iot.evergreen.packagemanager.config.Constants;\n+import com.aws.iot.evergreen.packagemanager.exceptions.DirectoryCreationFailedForPackageException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnexpectedPackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRecipe;\n+import com.vdurmont.semver4j.Semver;\n+import com.vdurmont.semver4j.SemverException;\n+import lombok.AllArgsConstructor;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n+\n+/**\n+ * Local Store Implementation for Evergreen Packages.\n+ */\n+@AllArgsConstructor\n+public class LocalPackageStore implements PackageStore {\n+    private final Path cacheFolder;\n+\n+    private static Path getPackageStorageRoot(final String packageName,\n+                                             final Path cacheFolder) {\n+        return cacheFolder.resolve(packageName);\n+    }\n+\n+    private static Path getPackageVersionStorageRoot(final PackageRecipe curPackageRecipe, final Path cacheFolder) {\n+        return getPackageVersionStorageRoot(curPackageRecipe.getPackageName(),\n+                                            curPackageRecipe.getPackageVersion().toString(),\n+                                            cacheFolder);\n+    }\n+\n+    private static Path getPackageVersionStorageRoot(final String packageName, final String packageVersion,\n+                                              final Path cacheFolder) {\n+        return getPackageStorageRoot(packageName, cacheFolder).resolve(packageVersion);\n+    }\n+\n+    /**\n+     * Get package from cache if it exists.\n+     * @return\n+     */\n+    @Override\n+    public Optional<String> getPackageRecipeIfExists(final String packageName,\n+                                                     final Semver packageVersion) {\n+        Path srcPkgRoot = getPackageVersionStorageRoot(packageName, packageVersion.toString(),\n+                                                       cacheFolder);\n+\n+        if (!Files.exists(srcPkgRoot) || !Files.isDirectory(srcPkgRoot)) {\n+            return Optional.empty();\n+        }\n+        // TODO: Move to a Common list of Constants\n+        Path recipePath = srcPkgRoot.resolve(Constants.RECIPE_FILE_NAME);\n+\n+        if (!Files.exists(recipePath) && Files.isRegularFile(recipePath)) {\n+            throw new RuntimeException(\"Package manager cache is corrupt\");", "originalCommit": "6f82b8a1c24a55fe04b395dc3179d6dc3907bfa4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA1MjE3Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/68#discussion_r384052173", "bodyText": "Switching to Packaging Exception for now.\nOptional is because it's possible the package doesn't exist in the local source, the API is Get if Exists.", "author": "chaurah", "createdAt": "2020-02-25T18:42:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDAzMTczMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDAzMzcxNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/68#discussion_r384033716", "bodyText": "We should never lose the original exception (unless it is totally unhelpful), but in this case, I think we'd want to know what the actual cause was.", "author": "MikeDombo", "createdAt": "2020-02-25T18:06:01Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/plugins/LocalPackageStore.java", "diffHunk": "@@ -0,0 +1,219 @@\n+package com.aws.iot.evergreen.packagemanager.plugins;\n+\n+import com.aws.iot.evergreen.packagemanager.config.Constants;\n+import com.aws.iot.evergreen.packagemanager.exceptions.DirectoryCreationFailedForPackageException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnexpectedPackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRecipe;\n+import com.vdurmont.semver4j.Semver;\n+import com.vdurmont.semver4j.SemverException;\n+import lombok.AllArgsConstructor;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n+\n+/**\n+ * Local Store Implementation for Evergreen Packages.\n+ */\n+@AllArgsConstructor\n+public class LocalPackageStore implements PackageStore {\n+    private final Path cacheFolder;\n+\n+    private static Path getPackageStorageRoot(final String packageName,\n+                                             final Path cacheFolder) {\n+        return cacheFolder.resolve(packageName);\n+    }\n+\n+    private static Path getPackageVersionStorageRoot(final PackageRecipe curPackageRecipe, final Path cacheFolder) {\n+        return getPackageVersionStorageRoot(curPackageRecipe.getPackageName(),\n+                                            curPackageRecipe.getPackageVersion().toString(),\n+                                            cacheFolder);\n+    }\n+\n+    private static Path getPackageVersionStorageRoot(final String packageName, final String packageVersion,\n+                                              final Path cacheFolder) {\n+        return getPackageStorageRoot(packageName, cacheFolder).resolve(packageVersion);\n+    }\n+\n+    /**\n+     * Get package from cache if it exists.\n+     * @return\n+     */\n+    @Override\n+    public Optional<String> getPackageRecipeIfExists(final String packageName,\n+                                                     final Semver packageVersion) {\n+        Path srcPkgRoot = getPackageVersionStorageRoot(packageName, packageVersion.toString(),\n+                                                       cacheFolder);\n+\n+        if (!Files.exists(srcPkgRoot) || !Files.isDirectory(srcPkgRoot)) {\n+            return Optional.empty();\n+        }\n+        // TODO: Move to a Common list of Constants\n+        Path recipePath = srcPkgRoot.resolve(Constants.RECIPE_FILE_NAME);\n+\n+        if (!Files.exists(recipePath) && Files.isRegularFile(recipePath)) {\n+            throw new RuntimeException(\"Package manager cache is corrupt\");\n+            // TODO Take some corrective actions before throwing\n+        }\n+\n+        try {\n+            return Optional.of(new String(Files.readAllBytes(recipePath), StandardCharsets.UTF_8));\n+        } catch (IOException e) {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    /**\n+     * Get package from cache if it exists.\n+     */\n+    @Override\n+    public List<Semver> getPackageVersionsIfExists(final String packageName)\n+            throws UnexpectedPackagingException {\n+        Path srcPkgRoot = getPackageStorageRoot(packageName, cacheFolder);\n+        List<Semver> versions = new ArrayList<>();\n+\n+        if (!Files.exists(srcPkgRoot) || !Files.isDirectory(srcPkgRoot)) {\n+            return versions;\n+        }\n+\n+        File[] versionDirs = srcPkgRoot.toFile().listFiles(File::isDirectory);\n+        if (versionDirs == null || versionDirs.length == 0) {\n+            return versions;\n+        }\n+\n+        try {\n+            for (File versionDir : versionDirs) {\n+                // TODO: Depending on platform, this may need to avoid failures on other things\n+                versions.add(new Semver(versionDir.getName(), Semver.SemverType.NPM));\n+            }\n+        } catch (SemverException e) {\n+            throw new UnexpectedPackagingException(\"Package Cache is corrupted! \" + e.toString());\n+        }\n+\n+        return versions;\n+    }\n+\n+    /**\n+     * Get package from cache if it exists.\n+     */\n+    @Override\n+    public Optional<Semver> getLatestPackageVersionIfExists(final String packageName)\n+            throws UnexpectedPackagingException {\n+        // Add check for package override\n+        return Optional.ofNullable(Collections.max(getPackageVersionsIfExists(packageName)));\n+    }\n+\n+    /**\n+     * Cache all artifacts for a given Package.\n+     */\n+    @Override\n+    public void cachePackageArtifacts(final PackageRecipe curPackageRecipe) throws PackagingException {\n+        Objects.requireNonNull(curPackageRecipe, \"Package Recipe cannot be null\");\n+\n+        Path destRootPkgPath = getPackageVersionStorageRoot(curPackageRecipe, cacheFolder);\n+\n+        try {\n+            if (Files.notExists(destRootPkgPath)) {\n+                Files.createDirectories(destRootPkgPath);\n+            }\n+            Set<ArtifactProvider> artifacts = curPackageRecipe.getArtifactProviders();\n+            for (ArtifactProvider artifactUrl : artifacts) {\n+                artifactUrl.downloadArtifactToPath(destRootPkgPath);\n+            }\n+        } catch (IOException e) {\n+            throw new PackagingException(\"Failed to download artifacts for \" + curPackageRecipe.getPackageName());\n+        }\n+    }\n+\n+    /**\n+     * Cache all artifacts for a given Package.\n+     */\n+    @Override\n+    public void cachePackageRecipeAndArtifacts(final PackageRecipe curPackageRecipe, final String recipeContents)\n+            throws PackagingException {\n+        Objects.requireNonNull(curPackageRecipe, \"Package Recipe cannot be null\");\n+        Objects.requireNonNull(curPackageRecipe, \"Package Recipe raw string cannot be null\");\n+\n+        Path destRootPkgPath = getPackageVersionStorageRoot(curPackageRecipe, cacheFolder);\n+        Path pkgRecipePath = destRootPkgPath.resolve(Constants.RECIPE_FILE_NAME);\n+\n+        try {\n+            Files.createDirectories(destRootPkgPath);\n+        } catch (IOException e) {\n+            throw new DirectoryCreationFailedForPackageException(\"Failed to create folder for \"\n+                                                                         + destRootPkgPath.toString());\n+        }\n+\n+        try {\n+            Files.write(pkgRecipePath, recipeContents.getBytes(StandardCharsets.UTF_8));\n+        } catch (IOException e) {\n+            throw new PackagingException(\"Failed to cache recipe for \" + destRootPkgPath.toString());", "originalCommit": "6f82b8a1c24a55fe04b395dc3179d6dc3907bfa4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA3NTMwNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/68#discussion_r384075304", "bodyText": "Adding the throwable to exception", "author": "chaurah", "createdAt": "2020-02-25T19:25:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDAzMzcxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDAzNDQ3OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/68#discussion_r384034478", "bodyText": "I know you have to throw as a runtime exception if you're using the forEach, but in that case I think you should wrap the whole thing with a try-catch and then re-throw it as a checked exception since we're the ones who originally threw the exception.", "author": "MikeDombo", "createdAt": "2020-02-25T18:08:05Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/plugins/LocalPackageStore.java", "diffHunk": "@@ -0,0 +1,219 @@\n+package com.aws.iot.evergreen.packagemanager.plugins;\n+\n+import com.aws.iot.evergreen.packagemanager.config.Constants;\n+import com.aws.iot.evergreen.packagemanager.exceptions.DirectoryCreationFailedForPackageException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnexpectedPackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRecipe;\n+import com.vdurmont.semver4j.Semver;\n+import com.vdurmont.semver4j.SemverException;\n+import lombok.AllArgsConstructor;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n+\n+/**\n+ * Local Store Implementation for Evergreen Packages.\n+ */\n+@AllArgsConstructor\n+public class LocalPackageStore implements PackageStore {\n+    private final Path cacheFolder;\n+\n+    private static Path getPackageStorageRoot(final String packageName,\n+                                             final Path cacheFolder) {\n+        return cacheFolder.resolve(packageName);\n+    }\n+\n+    private static Path getPackageVersionStorageRoot(final PackageRecipe curPackageRecipe, final Path cacheFolder) {\n+        return getPackageVersionStorageRoot(curPackageRecipe.getPackageName(),\n+                                            curPackageRecipe.getPackageVersion().toString(),\n+                                            cacheFolder);\n+    }\n+\n+    private static Path getPackageVersionStorageRoot(final String packageName, final String packageVersion,\n+                                              final Path cacheFolder) {\n+        return getPackageStorageRoot(packageName, cacheFolder).resolve(packageVersion);\n+    }\n+\n+    /**\n+     * Get package from cache if it exists.\n+     * @return\n+     */\n+    @Override\n+    public Optional<String> getPackageRecipeIfExists(final String packageName,\n+                                                     final Semver packageVersion) {\n+        Path srcPkgRoot = getPackageVersionStorageRoot(packageName, packageVersion.toString(),\n+                                                       cacheFolder);\n+\n+        if (!Files.exists(srcPkgRoot) || !Files.isDirectory(srcPkgRoot)) {\n+            return Optional.empty();\n+        }\n+        // TODO: Move to a Common list of Constants\n+        Path recipePath = srcPkgRoot.resolve(Constants.RECIPE_FILE_NAME);\n+\n+        if (!Files.exists(recipePath) && Files.isRegularFile(recipePath)) {\n+            throw new RuntimeException(\"Package manager cache is corrupt\");\n+            // TODO Take some corrective actions before throwing\n+        }\n+\n+        try {\n+            return Optional.of(new String(Files.readAllBytes(recipePath), StandardCharsets.UTF_8));\n+        } catch (IOException e) {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    /**\n+     * Get package from cache if it exists.\n+     */\n+    @Override\n+    public List<Semver> getPackageVersionsIfExists(final String packageName)\n+            throws UnexpectedPackagingException {\n+        Path srcPkgRoot = getPackageStorageRoot(packageName, cacheFolder);\n+        List<Semver> versions = new ArrayList<>();\n+\n+        if (!Files.exists(srcPkgRoot) || !Files.isDirectory(srcPkgRoot)) {\n+            return versions;\n+        }\n+\n+        File[] versionDirs = srcPkgRoot.toFile().listFiles(File::isDirectory);\n+        if (versionDirs == null || versionDirs.length == 0) {\n+            return versions;\n+        }\n+\n+        try {\n+            for (File versionDir : versionDirs) {\n+                // TODO: Depending on platform, this may need to avoid failures on other things\n+                versions.add(new Semver(versionDir.getName(), Semver.SemverType.NPM));\n+            }\n+        } catch (SemverException e) {\n+            throw new UnexpectedPackagingException(\"Package Cache is corrupted! \" + e.toString());\n+        }\n+\n+        return versions;\n+    }\n+\n+    /**\n+     * Get package from cache if it exists.\n+     */\n+    @Override\n+    public Optional<Semver> getLatestPackageVersionIfExists(final String packageName)\n+            throws UnexpectedPackagingException {\n+        // Add check for package override\n+        return Optional.ofNullable(Collections.max(getPackageVersionsIfExists(packageName)));\n+    }\n+\n+    /**\n+     * Cache all artifacts for a given Package.\n+     */\n+    @Override\n+    public void cachePackageArtifacts(final PackageRecipe curPackageRecipe) throws PackagingException {\n+        Objects.requireNonNull(curPackageRecipe, \"Package Recipe cannot be null\");\n+\n+        Path destRootPkgPath = getPackageVersionStorageRoot(curPackageRecipe, cacheFolder);\n+\n+        try {\n+            if (Files.notExists(destRootPkgPath)) {\n+                Files.createDirectories(destRootPkgPath);\n+            }\n+            Set<ArtifactProvider> artifacts = curPackageRecipe.getArtifactProviders();\n+            for (ArtifactProvider artifactUrl : artifacts) {\n+                artifactUrl.downloadArtifactToPath(destRootPkgPath);\n+            }\n+        } catch (IOException e) {\n+            throw new PackagingException(\"Failed to download artifacts for \" + curPackageRecipe.getPackageName());\n+        }\n+    }\n+\n+    /**\n+     * Cache all artifacts for a given Package.\n+     */\n+    @Override\n+    public void cachePackageRecipeAndArtifacts(final PackageRecipe curPackageRecipe, final String recipeContents)\n+            throws PackagingException {\n+        Objects.requireNonNull(curPackageRecipe, \"Package Recipe cannot be null\");\n+        Objects.requireNonNull(curPackageRecipe, \"Package Recipe raw string cannot be null\");\n+\n+        Path destRootPkgPath = getPackageVersionStorageRoot(curPackageRecipe, cacheFolder);\n+        Path pkgRecipePath = destRootPkgPath.resolve(Constants.RECIPE_FILE_NAME);\n+\n+        try {\n+            Files.createDirectories(destRootPkgPath);\n+        } catch (IOException e) {\n+            throw new DirectoryCreationFailedForPackageException(\"Failed to create folder for \"\n+                                                                         + destRootPkgPath.toString());\n+        }\n+\n+        try {\n+            Files.write(pkgRecipePath, recipeContents.getBytes(StandardCharsets.UTF_8));\n+        } catch (IOException e) {\n+            throw new PackagingException(\"Failed to cache recipe for \" + destRootPkgPath.toString());\n+        }\n+\n+        cachePackageArtifacts(curPackageRecipe);\n+    }\n+\n+    /**\n+     * Cache all artifacts to a path.\n+     */\n+    @Override\n+    public void copyPackageArtifactsToPath(final PackageRecipe curPackageRecipe, final Path destPath)\n+            throws PackagingException {\n+        Objects.requireNonNull(curPackageRecipe, \"Package Recipe cannot be null\");\n+\n+        Path srcRootPkgPath = getPackageVersionStorageRoot(curPackageRecipe, cacheFolder);\n+        Path destRootPkgPath = getPackageVersionStorageRoot(curPackageRecipe, destPath);\n+\n+        copyPackageArtifactsToPath(curPackageRecipe, srcRootPkgPath, destRootPkgPath);\n+    }\n+\n+    /**\n+     * Copy all artifacts to a path.\n+     */\n+    private void copyPackageArtifactsToPath(PackageRecipe curPackageRecipe, Path srcRootPkgPath,\n+                                            Path destRootPkgPath) throws PackagingException {\n+        if (!Files.exists(srcRootPkgPath) || !Files.isDirectory(srcRootPkgPath)) {\n+            // TODO: This is may not be the best choice? Maybe throw an exception and die?\n+            cachePackageArtifacts(curPackageRecipe);\n+        }\n+\n+        try {\n+            Files.createDirectories(destRootPkgPath);\n+        } catch (IOException e) {\n+            throw new PackagingException(\"Failed to create folder for \" + destRootPkgPath);\n+        }\n+\n+        try {\n+            Files.walk(srcRootPkgPath)\n+                 .forEach(source -> {\n+                     try {\n+                         if (Files.isDirectory(source) && Files.notExists(source)) {\n+                             Files.copy(source,\n+                                        destRootPkgPath.resolve(source.getFileName()));\n+                         } else {\n+                             Files.copy(source,\n+                                        destRootPkgPath.resolve(source.getFileName()),\n+                                        REPLACE_EXISTING);\n+                         }\n+                     } catch (IOException e) {\n+                         // TODO: Needs better handling\n+                         throw new RuntimeException(\"Failed to copy artifacts for \"", "originalCommit": "6f82b8a1c24a55fe04b395dc3179d6dc3907bfa4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA4ODM2Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/68#discussion_r384088362", "bodyText": "Done, also added a TODO to revisit this", "author": "chaurah", "createdAt": "2020-02-25T19:48:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDAzNDQ3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDAzMTQ4Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/68#discussion_r384031482", "bodyText": "Why do you need have IfExists in the method name? If it doesn't exist, you return empty optional. It seems redundant to append IfExists in the method name. Same for the below methods.", "author": "fengwang666", "createdAt": "2020-02-25T17:59:11Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/plugins/LocalPackageStore.java", "diffHunk": "@@ -0,0 +1,219 @@\n+package com.aws.iot.evergreen.packagemanager.plugins;\n+\n+import com.aws.iot.evergreen.packagemanager.config.Constants;\n+import com.aws.iot.evergreen.packagemanager.exceptions.DirectoryCreationFailedForPackageException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnexpectedPackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRecipe;\n+import com.vdurmont.semver4j.Semver;\n+import com.vdurmont.semver4j.SemverException;\n+import lombok.AllArgsConstructor;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n+\n+/**\n+ * Local Store Implementation for Evergreen Packages.\n+ */\n+@AllArgsConstructor\n+public class LocalPackageStore implements PackageStore {\n+    private final Path cacheFolder;\n+\n+    private static Path getPackageStorageRoot(final String packageName,\n+                                             final Path cacheFolder) {\n+        return cacheFolder.resolve(packageName);\n+    }\n+\n+    private static Path getPackageVersionStorageRoot(final PackageRecipe curPackageRecipe, final Path cacheFolder) {\n+        return getPackageVersionStorageRoot(curPackageRecipe.getPackageName(),\n+                                            curPackageRecipe.getPackageVersion().toString(),\n+                                            cacheFolder);\n+    }\n+\n+    private static Path getPackageVersionStorageRoot(final String packageName, final String packageVersion,\n+                                              final Path cacheFolder) {\n+        return getPackageStorageRoot(packageName, cacheFolder).resolve(packageVersion);\n+    }\n+\n+    /**\n+     * Get package from cache if it exists.\n+     * @return\n+     */\n+    @Override\n+    public Optional<String> getPackageRecipeIfExists(final String packageName,", "originalCommit": "6f82b8a1c24a55fe04b395dc3179d6dc3907bfa4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA1MTgwMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/68#discussion_r384051802", "bodyText": "Also why returning a string instead of the Java object?", "author": "fengwang666", "createdAt": "2020-02-25T18:42:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDAzMTQ4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA4ODU0OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/68#discussion_r384088549", "bodyText": "Updating", "author": "chaurah", "createdAt": "2020-02-25T19:49:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDAzMTQ4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA0MTgwNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/68#discussion_r384041807", "bodyText": "Probably don't want to swallow the IOException here.", "author": "fengwang666", "createdAt": "2020-02-25T18:23:49Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/plugins/LocalPackageStore.java", "diffHunk": "@@ -0,0 +1,219 @@\n+package com.aws.iot.evergreen.packagemanager.plugins;\n+\n+import com.aws.iot.evergreen.packagemanager.config.Constants;\n+import com.aws.iot.evergreen.packagemanager.exceptions.DirectoryCreationFailedForPackageException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnexpectedPackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRecipe;\n+import com.vdurmont.semver4j.Semver;\n+import com.vdurmont.semver4j.SemverException;\n+import lombok.AllArgsConstructor;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n+\n+/**\n+ * Local Store Implementation for Evergreen Packages.\n+ */\n+@AllArgsConstructor\n+public class LocalPackageStore implements PackageStore {\n+    private final Path cacheFolder;\n+\n+    private static Path getPackageStorageRoot(final String packageName,\n+                                             final Path cacheFolder) {\n+        return cacheFolder.resolve(packageName);\n+    }\n+\n+    private static Path getPackageVersionStorageRoot(final PackageRecipe curPackageRecipe, final Path cacheFolder) {\n+        return getPackageVersionStorageRoot(curPackageRecipe.getPackageName(),\n+                                            curPackageRecipe.getPackageVersion().toString(),\n+                                            cacheFolder);\n+    }\n+\n+    private static Path getPackageVersionStorageRoot(final String packageName, final String packageVersion,\n+                                              final Path cacheFolder) {\n+        return getPackageStorageRoot(packageName, cacheFolder).resolve(packageVersion);\n+    }\n+\n+    /**\n+     * Get package from cache if it exists.\n+     * @return\n+     */\n+    @Override\n+    public Optional<String> getPackageRecipeIfExists(final String packageName,\n+                                                     final Semver packageVersion) {\n+        Path srcPkgRoot = getPackageVersionStorageRoot(packageName, packageVersion.toString(),\n+                                                       cacheFolder);\n+\n+        if (!Files.exists(srcPkgRoot) || !Files.isDirectory(srcPkgRoot)) {\n+            return Optional.empty();\n+        }\n+        // TODO: Move to a Common list of Constants\n+        Path recipePath = srcPkgRoot.resolve(Constants.RECIPE_FILE_NAME);\n+\n+        if (!Files.exists(recipePath) && Files.isRegularFile(recipePath)) {\n+            throw new RuntimeException(\"Package manager cache is corrupt\");\n+            // TODO Take some corrective actions before throwing\n+        }\n+\n+        try {\n+            return Optional.of(new String(Files.readAllBytes(recipePath), StandardCharsets.UTF_8));\n+        } catch (IOException e) {\n+            return Optional.empty();", "originalCommit": "6f82b8a1c24a55fe04b395dc3179d6dc3907bfa4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA4ODYxMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/68#discussion_r384088612", "bodyText": "Fixed", "author": "chaurah", "createdAt": "2020-02-25T19:49:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA0MTgwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA0MzQ4MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/68#discussion_r384043480", "bodyText": "Include the original exception in the new exception", "author": "fengwang666", "createdAt": "2020-02-25T18:27:00Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/plugins/LocalPackageStore.java", "diffHunk": "@@ -0,0 +1,219 @@\n+package com.aws.iot.evergreen.packagemanager.plugins;\n+\n+import com.aws.iot.evergreen.packagemanager.config.Constants;\n+import com.aws.iot.evergreen.packagemanager.exceptions.DirectoryCreationFailedForPackageException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnexpectedPackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRecipe;\n+import com.vdurmont.semver4j.Semver;\n+import com.vdurmont.semver4j.SemverException;\n+import lombok.AllArgsConstructor;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n+\n+/**\n+ * Local Store Implementation for Evergreen Packages.\n+ */\n+@AllArgsConstructor\n+public class LocalPackageStore implements PackageStore {\n+    private final Path cacheFolder;\n+\n+    private static Path getPackageStorageRoot(final String packageName,\n+                                             final Path cacheFolder) {\n+        return cacheFolder.resolve(packageName);\n+    }\n+\n+    private static Path getPackageVersionStorageRoot(final PackageRecipe curPackageRecipe, final Path cacheFolder) {\n+        return getPackageVersionStorageRoot(curPackageRecipe.getPackageName(),\n+                                            curPackageRecipe.getPackageVersion().toString(),\n+                                            cacheFolder);\n+    }\n+\n+    private static Path getPackageVersionStorageRoot(final String packageName, final String packageVersion,\n+                                              final Path cacheFolder) {\n+        return getPackageStorageRoot(packageName, cacheFolder).resolve(packageVersion);\n+    }\n+\n+    /**\n+     * Get package from cache if it exists.\n+     * @return\n+     */\n+    @Override\n+    public Optional<String> getPackageRecipeIfExists(final String packageName,\n+                                                     final Semver packageVersion) {\n+        Path srcPkgRoot = getPackageVersionStorageRoot(packageName, packageVersion.toString(),\n+                                                       cacheFolder);\n+\n+        if (!Files.exists(srcPkgRoot) || !Files.isDirectory(srcPkgRoot)) {\n+            return Optional.empty();\n+        }\n+        // TODO: Move to a Common list of Constants\n+        Path recipePath = srcPkgRoot.resolve(Constants.RECIPE_FILE_NAME);\n+\n+        if (!Files.exists(recipePath) && Files.isRegularFile(recipePath)) {\n+            throw new RuntimeException(\"Package manager cache is corrupt\");\n+            // TODO Take some corrective actions before throwing\n+        }\n+\n+        try {\n+            return Optional.of(new String(Files.readAllBytes(recipePath), StandardCharsets.UTF_8));\n+        } catch (IOException e) {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    /**\n+     * Get package from cache if it exists.\n+     */\n+    @Override\n+    public List<Semver> getPackageVersionsIfExists(final String packageName)\n+            throws UnexpectedPackagingException {\n+        Path srcPkgRoot = getPackageStorageRoot(packageName, cacheFolder);\n+        List<Semver> versions = new ArrayList<>();\n+\n+        if (!Files.exists(srcPkgRoot) || !Files.isDirectory(srcPkgRoot)) {\n+            return versions;\n+        }\n+\n+        File[] versionDirs = srcPkgRoot.toFile().listFiles(File::isDirectory);\n+        if (versionDirs == null || versionDirs.length == 0) {\n+            return versions;\n+        }\n+\n+        try {\n+            for (File versionDir : versionDirs) {\n+                // TODO: Depending on platform, this may need to avoid failures on other things\n+                versions.add(new Semver(versionDir.getName(), Semver.SemverType.NPM));\n+            }\n+        } catch (SemverException e) {\n+            throw new UnexpectedPackagingException(\"Package Cache is corrupted! \" + e.toString());\n+        }\n+\n+        return versions;\n+    }\n+\n+    /**\n+     * Get package from cache if it exists.\n+     */\n+    @Override\n+    public Optional<Semver> getLatestPackageVersionIfExists(final String packageName)\n+            throws UnexpectedPackagingException {\n+        // Add check for package override\n+        return Optional.ofNullable(Collections.max(getPackageVersionsIfExists(packageName)));\n+    }\n+\n+    /**\n+     * Cache all artifacts for a given Package.\n+     */\n+    @Override\n+    public void cachePackageArtifacts(final PackageRecipe curPackageRecipe) throws PackagingException {\n+        Objects.requireNonNull(curPackageRecipe, \"Package Recipe cannot be null\");\n+\n+        Path destRootPkgPath = getPackageVersionStorageRoot(curPackageRecipe, cacheFolder);\n+\n+        try {\n+            if (Files.notExists(destRootPkgPath)) {\n+                Files.createDirectories(destRootPkgPath);\n+            }\n+            Set<ArtifactProvider> artifacts = curPackageRecipe.getArtifactProviders();\n+            for (ArtifactProvider artifactUrl : artifacts) {\n+                artifactUrl.downloadArtifactToPath(destRootPkgPath);\n+            }\n+        } catch (IOException e) {\n+            throw new PackagingException(\"Failed to download artifacts for \" + curPackageRecipe.getPackageName());", "originalCommit": "6f82b8a1c24a55fe04b395dc3179d6dc3907bfa4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA3ODQ1MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/68#discussion_r384078450", "bodyText": "Adding", "author": "chaurah", "createdAt": "2020-02-25T19:30:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA0MzQ4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA4ODEzOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/68#discussion_r384088138", "bodyText": "Done", "author": "chaurah", "createdAt": "2020-02-25T19:48:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA0MzQ4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA1MjY3OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/68#discussion_r384052678", "bodyText": "What's the method for? Who is going to call this method? Why do you need both cachePackageArtifacts and cachePackageRecipeAndArtifacts?", "author": "fengwang666", "createdAt": "2020-02-25T18:43:42Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/plugins/LocalPackageStore.java", "diffHunk": "@@ -0,0 +1,219 @@\n+package com.aws.iot.evergreen.packagemanager.plugins;\n+\n+import com.aws.iot.evergreen.packagemanager.config.Constants;\n+import com.aws.iot.evergreen.packagemanager.exceptions.DirectoryCreationFailedForPackageException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnexpectedPackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRecipe;\n+import com.vdurmont.semver4j.Semver;\n+import com.vdurmont.semver4j.SemverException;\n+import lombok.AllArgsConstructor;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n+\n+/**\n+ * Local Store Implementation for Evergreen Packages.\n+ */\n+@AllArgsConstructor\n+public class LocalPackageStore implements PackageStore {\n+    private final Path cacheFolder;\n+\n+    private static Path getPackageStorageRoot(final String packageName,\n+                                             final Path cacheFolder) {\n+        return cacheFolder.resolve(packageName);\n+    }\n+\n+    private static Path getPackageVersionStorageRoot(final PackageRecipe curPackageRecipe, final Path cacheFolder) {\n+        return getPackageVersionStorageRoot(curPackageRecipe.getPackageName(),\n+                                            curPackageRecipe.getPackageVersion().toString(),\n+                                            cacheFolder);\n+    }\n+\n+    private static Path getPackageVersionStorageRoot(final String packageName, final String packageVersion,\n+                                              final Path cacheFolder) {\n+        return getPackageStorageRoot(packageName, cacheFolder).resolve(packageVersion);\n+    }\n+\n+    /**\n+     * Get package from cache if it exists.\n+     * @return\n+     */\n+    @Override\n+    public Optional<String> getPackageRecipeIfExists(final String packageName,\n+                                                     final Semver packageVersion) {\n+        Path srcPkgRoot = getPackageVersionStorageRoot(packageName, packageVersion.toString(),\n+                                                       cacheFolder);\n+\n+        if (!Files.exists(srcPkgRoot) || !Files.isDirectory(srcPkgRoot)) {\n+            return Optional.empty();\n+        }\n+        // TODO: Move to a Common list of Constants\n+        Path recipePath = srcPkgRoot.resolve(Constants.RECIPE_FILE_NAME);\n+\n+        if (!Files.exists(recipePath) && Files.isRegularFile(recipePath)) {\n+            throw new RuntimeException(\"Package manager cache is corrupt\");\n+            // TODO Take some corrective actions before throwing\n+        }\n+\n+        try {\n+            return Optional.of(new String(Files.readAllBytes(recipePath), StandardCharsets.UTF_8));\n+        } catch (IOException e) {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    /**\n+     * Get package from cache if it exists.\n+     */\n+    @Override\n+    public List<Semver> getPackageVersionsIfExists(final String packageName)\n+            throws UnexpectedPackagingException {\n+        Path srcPkgRoot = getPackageStorageRoot(packageName, cacheFolder);\n+        List<Semver> versions = new ArrayList<>();\n+\n+        if (!Files.exists(srcPkgRoot) || !Files.isDirectory(srcPkgRoot)) {\n+            return versions;\n+        }\n+\n+        File[] versionDirs = srcPkgRoot.toFile().listFiles(File::isDirectory);\n+        if (versionDirs == null || versionDirs.length == 0) {\n+            return versions;\n+        }\n+\n+        try {\n+            for (File versionDir : versionDirs) {\n+                // TODO: Depending on platform, this may need to avoid failures on other things\n+                versions.add(new Semver(versionDir.getName(), Semver.SemverType.NPM));\n+            }\n+        } catch (SemverException e) {\n+            throw new UnexpectedPackagingException(\"Package Cache is corrupted! \" + e.toString());\n+        }\n+\n+        return versions;\n+    }\n+\n+    /**\n+     * Get package from cache if it exists.\n+     */\n+    @Override\n+    public Optional<Semver> getLatestPackageVersionIfExists(final String packageName)\n+            throws UnexpectedPackagingException {\n+        // Add check for package override\n+        return Optional.ofNullable(Collections.max(getPackageVersionsIfExists(packageName)));\n+    }\n+\n+    /**\n+     * Cache all artifacts for a given Package.\n+     */\n+    @Override\n+    public void cachePackageArtifacts(final PackageRecipe curPackageRecipe) throws PackagingException {", "originalCommit": "6f82b8a1c24a55fe04b395dc3179d6dc3907bfa4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA3ODM2Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/68#discussion_r384078363", "bodyText": "Caching artifacts will likely need to support pause and resume features among other things. We may need to cache Recipe first, then separately cache the artifacts individually.\nThis will be updated further in future PRs.", "author": "chaurah", "createdAt": "2020-02-25T19:30:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA1MjY3OA=="}], "type": "inlineReview"}, {"oid": "bdf9d544290a47834ab583ba6d6d22bdc8eb017a", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/bdf9d544290a47834ab583ba6d6d22bdc8eb017a", "message": "Add Local Artifact Store and tests", "committedDate": "2020-02-25T20:06:25Z", "type": "forcePushed"}, {"oid": "011e3cc3b7c071260e86a3f7f95bc6572790d312", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/011e3cc3b7c071260e86a3f7f95bc6572790d312", "message": "Add Local Artifact Store and tests", "committedDate": "2020-02-25T23:20:19Z", "type": "commit"}, {"oid": "011e3cc3b7c071260e86a3f7f95bc6572790d312", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/011e3cc3b7c071260e86a3f7f95bc6572790d312", "message": "Add Local Artifact Store and tests", "committedDate": "2020-02-25T23:20:19Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE4OTQ5OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/68#discussion_r384189498", "bodyText": "This message seems wrong, shouldn't it be saying that the version is improper? Also, I don't think you should include the original error message. Just including it as the cause is good enough.", "author": "MikeDombo", "createdAt": "2020-02-25T23:27:42Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/plugins/LocalPackageStore.java", "diffHunk": "@@ -0,0 +1,234 @@\n+package com.aws.iot.evergreen.packagemanager.plugins;\n+\n+import com.aws.iot.evergreen.packagemanager.config.Constants;\n+import com.aws.iot.evergreen.packagemanager.exceptions.DirectoryCreationFailedForPackageException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnexpectedPackagingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnsupportedRecipeFormatException;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import com.vdurmont.semver4j.Semver;\n+import com.vdurmont.semver4j.SemverException;\n+import lombok.AllArgsConstructor;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n+\n+/**\n+ * Local Store Implementation for Evergreen Packages.\n+ */\n+@AllArgsConstructor\n+public class LocalPackageStore implements PackageStore {\n+\n+    // TODO: This is temporary. Once all the separate PRs for Package Manager are merged in, this needs to move\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper(new YAMLFactory());\n+\n+    static {\n+        OBJECT_MAPPER.configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true);\n+    }\n+\n+    private final Path cacheFolder;\n+\n+    private static Path getPackageStorageRoot(final String packageName,\n+                                             final Path cacheFolder) {\n+        return cacheFolder.resolve(packageName);\n+    }\n+\n+    private static Path getPackageVersionStorageRoot(final Package curPackageRecipe, final Path cacheFolder) {\n+        return getPackageVersionStorageRoot(curPackageRecipe.getPackageName(),\n+                                            curPackageRecipe.getPackageVersion().toString(),\n+                                            cacheFolder);\n+    }\n+\n+    private static Path getPackageVersionStorageRoot(final String packageName, final String packageVersion,\n+                                              final Path cacheFolder) {\n+        return getPackageStorageRoot(packageName, cacheFolder).resolve(packageVersion);\n+    }\n+\n+    /**\n+     * Get package from cache if it exists.\n+     * @return Optional containing package recipe as a String\n+     */\n+    @Override\n+    public Optional<Package> getPackage(final String packageName, final Semver packageVersion)\n+            throws PackagingException, IOException {\n+        Path srcPkgRoot = getPackageVersionStorageRoot(packageName, packageVersion.toString(),\n+                                                       cacheFolder);\n+\n+        if (!Files.exists(srcPkgRoot) || !Files.isDirectory(srcPkgRoot)) {\n+            return Optional.empty();\n+        }\n+        // TODO: Move to a Common list of Constants\n+        Path recipePath = srcPkgRoot.resolve(Constants.RECIPE_FILE_NAME);\n+\n+        if (!Files.exists(recipePath) && Files.isRegularFile(recipePath)) {\n+            throw new PackagingException(\"Package manager cache is corrupt\");\n+            // TODO Take some corrective actions before throwing\n+        }\n+\n+        String packageRecipeContent = new String(Files.readAllBytes(recipePath), StandardCharsets.UTF_8);\n+        try {\n+            Package pkgRecipe = OBJECT_MAPPER.readValue(packageRecipeContent, Package.class);\n+            return Optional.ofNullable(pkgRecipe);\n+        } catch (IOException e) {\n+            throw new UnsupportedRecipeFormatException(Constants.UNABLE_TO_PARSE_RECIPE_EXCEPTION_MSG, e);\n+        }\n+    }\n+\n+    /**\n+     * Get package from cache if it exists.\n+     */\n+    @Override\n+    public List<Semver> getPackageVersionsIfExists(final String packageName)\n+            throws UnexpectedPackagingException {\n+        Path srcPkgRoot = getPackageStorageRoot(packageName, cacheFolder);\n+        List<Semver> versions = new ArrayList<>();\n+\n+        if (!Files.exists(srcPkgRoot) || !Files.isDirectory(srcPkgRoot)) {\n+            return versions;\n+        }\n+\n+        File[] versionDirs = srcPkgRoot.toFile().listFiles(File::isDirectory);\n+        if (versionDirs == null || versionDirs.length == 0) {\n+            return versions;\n+        }\n+\n+        try {\n+            for (File versionDir : versionDirs) {\n+                // TODO: Depending on platform, this may need to avoid failures on other things\n+                versions.add(new Semver(versionDir.getName(), Semver.SemverType.NPM));\n+            }\n+        } catch (SemverException e) {\n+            throw new UnexpectedPackagingException(\"Package Cache is corrupted! \" + e.toString(), e);", "originalCommit": "011e3cc3b7c071260e86a3f7f95bc6572790d312", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE5MjU0NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/68#discussion_r384192544", "bodyText": "Will update this in follow up PR. The way this is set up at the moment, there shouldn't be any other directories in the path at all. Hence the corrupt cache message.", "author": "chaurah", "createdAt": "2020-02-25T23:35:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE4OTQ5OA=="}], "type": "inlineReview"}]}