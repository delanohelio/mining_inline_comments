{"pr_number": 64, "pr_title": "State machine refactor", "pr_createdAt": "2020-02-19T02:59:32Z", "pr_url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA4ODA2Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381088062", "bodyText": "Use our logger if possible, and if not, this may well be fine to ignore. This is using the actual hostname as a platform (which we may not want to be supporting anyway).", "author": "MikeDombo", "createdAt": "2020-02-19T05:45:14Z", "path": "src/main/java/com/aws/iot/evergreen/config/PlatformResolver.java", "diffHunk": "@@ -71,6 +71,7 @@\n         try {\n             ranks.put(InetAddress.getLocalHost().getHostName(), 99);\n         } catch (UnknownHostException ex) {\n+            ex.printStackTrace();", "originalCommit": "7ee25d34a650229a91879e35befec8209bedcc8d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQ4ODU2OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381488569", "bodyText": "This is in platform resolving logic, which probably will be in both Kernel and PM/DA . I'd like to keep printstackTrace for now", "author": "ShirleyZheng92", "createdAt": "2020-02-19T19:16:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA4ODA2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA4ODE2Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381088167", "bodyText": "I believe this should be started up in the constructor without needing to be explicitly called.", "author": "MikeDombo", "createdAt": "2020-02-19T05:45:43Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -60,8 +59,21 @@ public EvergreenService(Topics topics) {\n         this.state = initStateTopic(topics);\n     }\n \n-    public static State getState(EvergreenService evergreenService) {\n-        return evergreenService.getState();\n+    /**\n+     * Start the Lifecycle in a separate thread.\n+     */\n+    public void startLifecycle() {", "originalCommit": "7ee25d34a650229a91879e35befec8209bedcc8d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQ4ODc4Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381488782", "bodyText": "Findbug complains about starting a thread in constructor", "author": "ShirleyZheng92", "createdAt": "2020-02-19T19:16:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA4ODE2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTYwMTE3Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381601172", "bodyText": "+1. If that's what we need to do, then it's fine. I did it in the postInject after it figures out the dependency.", "author": "leaf94", "createdAt": "2020-02-19T23:11:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA4ODE2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTY2NTg2Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381665867", "bodyText": "Just ignore the findbugs issue and start it up in the constructor, or use Ethan's idea and do it in the postInject.", "author": "MikeDombo", "createdAt": "2020-02-20T02:02:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA4ODE2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA4ODMyMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381088320", "bodyText": "I think this may need to catch Throwable and have some strong error handling, since if the state machine thread dies, that's a big problem for the service. Probably it should auto-restart the thread.", "author": "MikeDombo", "createdAt": "2020-02-19T05:46:25Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -60,8 +59,21 @@ public EvergreenService(Topics topics) {\n         this.state = initStateTopic(topics);\n     }\n \n-    public static State getState(EvergreenService evergreenService) {\n-        return evergreenService.getState();\n+    /**\n+     * Start the Lifecycle in a separate thread.\n+     */\n+    public void startLifecycle() {\n+        new Thread(() -> {\n+            try {\n+                startStateTransition();\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+        }).start();", "originalCommit": "7ee25d34a650229a91879e35befec8209bedcc8d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQ4ODg3Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381488872", "bodyText": "Ok", "author": "ShirleyZheng92", "createdAt": "2020-02-19T19:17:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA4ODMyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA4ODQ4MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381088480", "bodyText": "Use your getState function here.", "author": "MikeDombo", "createdAt": "2020-02-19T05:47:06Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -70,11 +82,32 @@ static void setState(Object o, State state) {\n         }\n     }\n \n+    /**\n+     * Set the state of the service. Should only be called by service or through IPC.\n+     * @param newState\n+     */\n+    public void setState(State newState) {\n+        final State currentState = (State) this.state.getOnce();", "originalCommit": "7ee25d34a650229a91879e35befec8209bedcc8d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQ4ODk0Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381488943", "bodyText": "Ah sure", "author": "ShirleyZheng92", "createdAt": "2020-02-19T19:17:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA4ODQ4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA4ODUyMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381088521", "bodyText": "Prefer .equals()", "author": "MikeDombo", "createdAt": "2020-02-19T05:47:19Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -70,11 +82,32 @@ static void setState(Object o, State state) {\n         }\n     }\n \n+    /**\n+     * Set the state of the service. Should only be called by service or through IPC.\n+     * @param newState\n+     */\n+    public void setState(State newState) {\n+        final State currentState = (State) this.state.getOnce();\n+\n+        if (newState != currentState) {", "originalCommit": "7ee25d34a650229a91879e35befec8209bedcc8d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQ4OTAwOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381489009", "bodyText": "Sure", "author": "ShirleyZheng92", "createdAt": "2020-02-19T19:17:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA4ODUyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA4ODY1MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381088651", "bodyText": "Why long max? Shouldn't it get the current timestamp, since that is the proper time that the change is happening.", "author": "MikeDombo", "createdAt": "2020-02-19T05:48:02Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -70,11 +82,32 @@ static void setState(Object o, State state) {\n         }\n     }\n \n+    /**\n+     * Set the state of the service. Should only be called by service or through IPC.\n+     * @param newState\n+     */\n+    public void setState(State newState) {\n+        final State currentState = (State) this.state.getOnce();\n+\n+        if (newState != currentState) {\n+            context.getLog().note(getName(), currentState, \"=>\", newState);\n+            prevState = currentState;\n+            // Make sure the order of setValue() invocation is same as order of global state notification\n+            synchronized (this.state) {\n+                this.state.setValue(Long.MAX_VALUE, newState);", "originalCommit": "7ee25d34a650229a91879e35befec8209bedcc8d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQ4OTM4Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381489383", "bodyText": "I just copy-pasted the function here. Will fix it.", "author": "ShirleyZheng92", "createdAt": "2020-02-19T19:18:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA4ODY1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA4ODkzMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381088932", "bodyText": "Why 100? If we think it can only have up to 2 or 3 entries, let's just force it to that size (at least for now until we find we need more room).", "author": "MikeDombo", "createdAt": "2020-02-19T05:49:09Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -198,144 +216,227 @@ public Topic getStateTopic() {\n         return state;\n     }\n \n-    public boolean isRunningInternally() {\n-        Future b = backingTask;\n-        return b != null && !b.isDone();\n-    }\n-\n     public boolean isPeriodic() {\n         return periodicityInformation != null;\n     }\n \n-    @Override // for listening to state changes\n-    public void published(final WhatHappened what, final Topic topic) {\n-        final State newState = (State) topic.getOnce();\n-        if (activeState == newState) {\n-            return;\n+    private final List<State> desiredStateList = new ArrayList<>(100);", "originalCommit": "7ee25d34a650229a91879e35befec8209bedcc8d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA4OTI3MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381089271", "bodyText": "Rename the input state. I think it has the meaning of currentState or activeState, but I'm unsure, so best to rename it to what it actually is.", "author": "MikeDombo", "createdAt": "2020-02-19T05:50:40Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -198,144 +216,227 @@ public Topic getStateTopic() {\n         return state;\n     }\n \n-    public boolean isRunningInternally() {\n-        Future b = backingTask;\n-        return b != null && !b.isDone();\n-    }\n-\n     public boolean isPeriodic() {\n         return periodicityInformation != null;\n     }\n \n-    @Override // for listening to state changes\n-    public void published(final WhatHappened what, final Topic topic) {\n-        final State newState = (State) topic.getOnce();\n-        if (activeState == newState) {\n-            return;\n+    private final List<State> desiredStateList = new ArrayList<>(100);\n+\n+    //Used to notify when state has changed Or a desiredState is set.\n+    private final Object stateChangeEvent = new Object();\n+\n+    private State peekOrRemoveFirstDesiredState(State state) {", "originalCommit": "7ee25d34a650229a91879e35befec8209bedcc8d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQ4OTU5OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381489598", "bodyText": "ok", "author": "ShirleyZheng92", "createdAt": "2020-02-19T19:18:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA4OTI3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA4OTg4OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381089888", "bodyText": "These methods seem a little odd since they don't start, stop, restart, or reinstall; they request that that happens. I would expect methods like these to block until the task is completed and then return the success. If you want to keep these methods as-is, which I think would be ok except for the return value, then I would rename them to requestX or something like that.", "author": "MikeDombo", "createdAt": "2020-02-19T05:53:23Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -198,144 +216,227 @@ public Topic getStateTopic() {\n         return state;\n     }\n \n-    public boolean isRunningInternally() {\n-        Future b = backingTask;\n-        return b != null && !b.isDone();\n-    }\n-\n     public boolean isPeriodic() {\n         return periodicityInformation != null;\n     }\n \n-    @Override // for listening to state changes\n-    public void published(final WhatHappened what, final Topic topic) {\n-        final State newState = (State) topic.getOnce();\n-        if (activeState == newState) {\n-            return;\n+    private final List<State> desiredStateList = new ArrayList<>(100);\n+\n+    //Used to notify when state has changed Or a desiredState is set.\n+    private final Object stateChangeEvent = new Object();\n+\n+    private State peekOrRemoveFirstDesiredState(State state) {\n+        synchronized (desiredStateList) {\n+            if (desiredStateList.isEmpty()) {\n+                return null;\n+            }\n+            State first = desiredStateList.get(0);\n+            if (first == state) {\n+                return desiredStateList.remove(0);\n+            } else {\n+                return first;\n+            }\n         }\n-        if (activeState.isRunning() && !newState.isRunning()) { // transition from running to not running\n-            shutdownLatch = new CountDownLatch(1);\n-            // Assume that shutdown task won't be cancelled. Following states (installing/awaitingStartup) wait until\n-            // shutdown task complete.\n-            // May consider just merge shutdown() into other state's handling.\n-            State oldState = activeState;\n-            setBackingTask(() -> {\n-                try {\n-                    shutdown();\n-                } catch (Throwable t) {\n-                    if (oldState != State.Errored) {\n-                        errored(\"Failed shutting down\", t);\n-                    } else {\n-                        context.getLog().error(this, \"Failed shutting down\", t);\n-                    }\n-                } finally {\n-                    shutdownLatch.countDown();\n-                }\n-                backingTask = null;\n-            }, getName() + \"=>\" + newState);\n+    }\n \n-            // Since shutdown() is modeled as part of state transition, I initially tried waiting on shutdownLatch()\n-            // here.\n-            // However, this caused the global configuration publish queue being blocked.\n+    private void setDesiredState(State... state) {\n+        synchronized (desiredStateList) {\n+            List<State> newStateList = Arrays.asList(state);\n+            if (newStateList.equals(desiredStateList)) {\n+                return;\n+            }\n+            desiredStateList.clear();\n+            desiredStateList.addAll(newStateList);\n+            synchronized (stateChangeEvent) {\n+                stateChangeEvent.notifyAll();\n+            }\n         }\n+    }\n \n-        try {\n-            switch (newState) {\n-                case Installing:\n-                    new Thread(() -> {\n-                        // wait until shutdown finished.\n-                        // not using setBackTask() here to avoid cancelling the ongoing shutdown task\n-                        try {\n-                            shutdownLatch.await();\n-                        } catch (InterruptedException e) {\n-                            errored(\"waiting for shutdown complete\", e);\n-                            return;\n-                        }\n-                        // TODO: wait until all install dependency ready.\n-                        if (!errored() && getState() == State.Installing) {\n+    /**\n+     * Start Service.\n+     * @return successful\n+     */\n+    public boolean startService() {\n+        setDesiredState(State.Running);\n+        return true;\n+    }\n+\n+    /**\n+     * Stop Service.\n+     * @return successful\n+     */\n+    public boolean stopService() {\n+        setDesiredState(State.Finished);\n+        return true;\n+    }\n+\n+    /**\n+     * Restart Service.\n+     * @return successful\n+     */\n+    public boolean restartService() {", "originalCommit": "7ee25d34a650229a91879e35befec8209bedcc8d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQ4OTgzMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381489830", "bodyText": "ok", "author": "ShirleyZheng92", "createdAt": "2020-02-19T19:18:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA4OTg4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA4OTk4MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381089981", "bodyText": "I think this should be protected so only subclasses can claim they are in an errored state", "author": "MikeDombo", "createdAt": "2020-02-19T05:53:51Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -198,144 +216,227 @@ public Topic getStateTopic() {\n         return state;\n     }\n \n-    public boolean isRunningInternally() {\n-        Future b = backingTask;\n-        return b != null && !b.isDone();\n-    }\n-\n     public boolean isPeriodic() {\n         return periodicityInformation != null;\n     }\n \n-    @Override // for listening to state changes\n-    public void published(final WhatHappened what, final Topic topic) {\n-        final State newState = (State) topic.getOnce();\n-        if (activeState == newState) {\n-            return;\n+    private final List<State> desiredStateList = new ArrayList<>(100);\n+\n+    //Used to notify when state has changed Or a desiredState is set.\n+    private final Object stateChangeEvent = new Object();\n+\n+    private State peekOrRemoveFirstDesiredState(State state) {\n+        synchronized (desiredStateList) {\n+            if (desiredStateList.isEmpty()) {\n+                return null;\n+            }\n+            State first = desiredStateList.get(0);\n+            if (first == state) {\n+                return desiredStateList.remove(0);\n+            } else {\n+                return first;\n+            }\n         }\n-        if (activeState.isRunning() && !newState.isRunning()) { // transition from running to not running\n-            shutdownLatch = new CountDownLatch(1);\n-            // Assume that shutdown task won't be cancelled. Following states (installing/awaitingStartup) wait until\n-            // shutdown task complete.\n-            // May consider just merge shutdown() into other state's handling.\n-            State oldState = activeState;\n-            setBackingTask(() -> {\n-                try {\n-                    shutdown();\n-                } catch (Throwable t) {\n-                    if (oldState != State.Errored) {\n-                        errored(\"Failed shutting down\", t);\n-                    } else {\n-                        context.getLog().error(this, \"Failed shutting down\", t);\n-                    }\n-                } finally {\n-                    shutdownLatch.countDown();\n-                }\n-                backingTask = null;\n-            }, getName() + \"=>\" + newState);\n+    }\n \n-            // Since shutdown() is modeled as part of state transition, I initially tried waiting on shutdownLatch()\n-            // here.\n-            // However, this caused the global configuration publish queue being blocked.\n+    private void setDesiredState(State... state) {\n+        synchronized (desiredStateList) {\n+            List<State> newStateList = Arrays.asList(state);\n+            if (newStateList.equals(desiredStateList)) {\n+                return;\n+            }\n+            desiredStateList.clear();\n+            desiredStateList.addAll(newStateList);\n+            synchronized (stateChangeEvent) {\n+                stateChangeEvent.notifyAll();\n+            }\n         }\n+    }\n \n-        try {\n-            switch (newState) {\n-                case Installing:\n-                    new Thread(() -> {\n-                        // wait until shutdown finished.\n-                        // not using setBackTask() here to avoid cancelling the ongoing shutdown task\n-                        try {\n-                            shutdownLatch.await();\n-                        } catch (InterruptedException e) {\n-                            errored(\"waiting for shutdown complete\", e);\n-                            return;\n-                        }\n-                        // TODO: wait until all install dependency ready.\n-                        if (!errored() && getState() == State.Installing) {\n+    /**\n+     * Start Service.\n+     * @return successful\n+     */\n+    public boolean startService() {\n+        setDesiredState(State.Running);\n+        return true;\n+    }\n+\n+    /**\n+     * Stop Service.\n+     * @return successful\n+     */\n+    public boolean stopService() {\n+        setDesiredState(State.Finished);\n+        return true;\n+    }\n+\n+    /**\n+     * Restart Service.\n+     * @return successful\n+     */\n+    public boolean restartService() {\n+        setDesiredState(State.Finished, State.Running);\n+        return true;\n+    }\n+\n+    /**\n+     * ReInstall Service.\n+     * @return successful\n+     */\n+    public boolean reInstallService() {\n+        setDesiredState(State.Finished, State.New, State.Running);\n+        return true;\n+    }\n+\n+    /**\n+     * Error out a service.\n+     */\n+    public void errorService() {", "originalCommit": "7ee25d34a650229a91879e35befec8209bedcc8d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA5MDIwNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381090207", "bodyText": "There's no way to escape from broken?", "author": "MikeDombo", "createdAt": "2020-02-19T05:54:59Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -198,144 +216,227 @@ public Topic getStateTopic() {\n         return state;\n     }\n \n-    public boolean isRunningInternally() {\n-        Future b = backingTask;\n-        return b != null && !b.isDone();\n-    }\n-\n     public boolean isPeriodic() {\n         return periodicityInformation != null;\n     }\n \n-    @Override // for listening to state changes\n-    public void published(final WhatHappened what, final Topic topic) {\n-        final State newState = (State) topic.getOnce();\n-        if (activeState == newState) {\n-            return;\n+    private final List<State> desiredStateList = new ArrayList<>(100);\n+\n+    //Used to notify when state has changed Or a desiredState is set.\n+    private final Object stateChangeEvent = new Object();\n+\n+    private State peekOrRemoveFirstDesiredState(State state) {\n+        synchronized (desiredStateList) {\n+            if (desiredStateList.isEmpty()) {\n+                return null;\n+            }\n+            State first = desiredStateList.get(0);\n+            if (first == state) {\n+                return desiredStateList.remove(0);\n+            } else {\n+                return first;\n+            }\n         }\n-        if (activeState.isRunning() && !newState.isRunning()) { // transition from running to not running\n-            shutdownLatch = new CountDownLatch(1);\n-            // Assume that shutdown task won't be cancelled. Following states (installing/awaitingStartup) wait until\n-            // shutdown task complete.\n-            // May consider just merge shutdown() into other state's handling.\n-            State oldState = activeState;\n-            setBackingTask(() -> {\n-                try {\n-                    shutdown();\n-                } catch (Throwable t) {\n-                    if (oldState != State.Errored) {\n-                        errored(\"Failed shutting down\", t);\n-                    } else {\n-                        context.getLog().error(this, \"Failed shutting down\", t);\n-                    }\n-                } finally {\n-                    shutdownLatch.countDown();\n-                }\n-                backingTask = null;\n-            }, getName() + \"=>\" + newState);\n+    }\n \n-            // Since shutdown() is modeled as part of state transition, I initially tried waiting on shutdownLatch()\n-            // here.\n-            // However, this caused the global configuration publish queue being blocked.\n+    private void setDesiredState(State... state) {\n+        synchronized (desiredStateList) {\n+            List<State> newStateList = Arrays.asList(state);\n+            if (newStateList.equals(desiredStateList)) {\n+                return;\n+            }\n+            desiredStateList.clear();\n+            desiredStateList.addAll(newStateList);\n+            synchronized (stateChangeEvent) {\n+                stateChangeEvent.notifyAll();\n+            }\n         }\n+    }\n \n-        try {\n-            switch (newState) {\n-                case Installing:\n-                    new Thread(() -> {\n-                        // wait until shutdown finished.\n-                        // not using setBackTask() here to avoid cancelling the ongoing shutdown task\n-                        try {\n-                            shutdownLatch.await();\n-                        } catch (InterruptedException e) {\n-                            errored(\"waiting for shutdown complete\", e);\n-                            return;\n-                        }\n-                        // TODO: wait until all install dependency ready.\n-                        if (!errored() && getState() == State.Installing) {\n+    /**\n+     * Start Service.\n+     * @return successful\n+     */\n+    public boolean startService() {\n+        setDesiredState(State.Running);\n+        return true;\n+    }\n+\n+    /**\n+     * Stop Service.\n+     * @return successful\n+     */\n+    public boolean stopService() {\n+        setDesiredState(State.Finished);\n+        return true;\n+    }\n+\n+    /**\n+     * Restart Service.\n+     * @return successful\n+     */\n+    public boolean restartService() {\n+        setDesiredState(State.Finished, State.Running);\n+        return true;\n+    }\n+\n+    /**\n+     * ReInstall Service.\n+     * @return successful\n+     */\n+    public boolean reInstallService() {\n+        setDesiredState(State.Finished, State.New, State.Running);\n+        return true;\n+    }\n+\n+    /**\n+     * Error out a service.\n+     */\n+    public void errorService() {\n+        setState(State.Errored);\n+    }\n+\n+    private void waitOnStateChangeEvent(State currentState) throws InterruptedException {\n+        synchronized (stateChangeEvent) {\n+            while (desiredStateList.isEmpty() && getState() == currentState) {\n+                stateChangeEvent.wait();\n+            }\n+        }\n+    }\n+\n+    private void startStateTransition() throws InterruptedException {\n+        periodicityInformation = Periodicity.of(this);\n+        while (true) {\n+            State desiredState = null;\n+            switch (this.getState()) {\n+                case Broken:\n+                    context.getLog().significant(getName(), \"Broken\");", "originalCommit": "7ee25d34a650229a91879e35befec8209bedcc8d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQ5MDQ1MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381490450", "bodyText": "Right. Unless restart kernel. Broken is when service error too often that only a deployment can fix", "author": "ShirleyZheng92", "createdAt": "2020-02-19T19:20:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA5MDIwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA5MDg0Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381090846", "bodyText": "These should all be break to break the switch, not continue to continue the loop. If we added logic after the switch it would never be executed with these continues.", "author": "MikeDombo", "createdAt": "2020-02-19T05:57:36Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -198,144 +216,227 @@ public Topic getStateTopic() {\n         return state;\n     }\n \n-    public boolean isRunningInternally() {\n-        Future b = backingTask;\n-        return b != null && !b.isDone();\n-    }\n-\n     public boolean isPeriodic() {\n         return periodicityInformation != null;\n     }\n \n-    @Override // for listening to state changes\n-    public void published(final WhatHappened what, final Topic topic) {\n-        final State newState = (State) topic.getOnce();\n-        if (activeState == newState) {\n-            return;\n+    private final List<State> desiredStateList = new ArrayList<>(100);\n+\n+    //Used to notify when state has changed Or a desiredState is set.\n+    private final Object stateChangeEvent = new Object();\n+\n+    private State peekOrRemoveFirstDesiredState(State state) {\n+        synchronized (desiredStateList) {\n+            if (desiredStateList.isEmpty()) {\n+                return null;\n+            }\n+            State first = desiredStateList.get(0);\n+            if (first == state) {\n+                return desiredStateList.remove(0);\n+            } else {\n+                return first;\n+            }\n         }\n-        if (activeState.isRunning() && !newState.isRunning()) { // transition from running to not running\n-            shutdownLatch = new CountDownLatch(1);\n-            // Assume that shutdown task won't be cancelled. Following states (installing/awaitingStartup) wait until\n-            // shutdown task complete.\n-            // May consider just merge shutdown() into other state's handling.\n-            State oldState = activeState;\n-            setBackingTask(() -> {\n-                try {\n-                    shutdown();\n-                } catch (Throwable t) {\n-                    if (oldState != State.Errored) {\n-                        errored(\"Failed shutting down\", t);\n-                    } else {\n-                        context.getLog().error(this, \"Failed shutting down\", t);\n-                    }\n-                } finally {\n-                    shutdownLatch.countDown();\n-                }\n-                backingTask = null;\n-            }, getName() + \"=>\" + newState);\n+    }\n \n-            // Since shutdown() is modeled as part of state transition, I initially tried waiting on shutdownLatch()\n-            // here.\n-            // However, this caused the global configuration publish queue being blocked.\n+    private void setDesiredState(State... state) {\n+        synchronized (desiredStateList) {\n+            List<State> newStateList = Arrays.asList(state);\n+            if (newStateList.equals(desiredStateList)) {\n+                return;\n+            }\n+            desiredStateList.clear();\n+            desiredStateList.addAll(newStateList);\n+            synchronized (stateChangeEvent) {\n+                stateChangeEvent.notifyAll();\n+            }\n         }\n+    }\n \n-        try {\n-            switch (newState) {\n-                case Installing:\n-                    new Thread(() -> {\n-                        // wait until shutdown finished.\n-                        // not using setBackTask() here to avoid cancelling the ongoing shutdown task\n-                        try {\n-                            shutdownLatch.await();\n-                        } catch (InterruptedException e) {\n-                            errored(\"waiting for shutdown complete\", e);\n-                            return;\n-                        }\n-                        // TODO: wait until all install dependency ready.\n-                        if (!errored() && getState() == State.Installing) {\n+    /**\n+     * Start Service.\n+     * @return successful\n+     */\n+    public boolean startService() {\n+        setDesiredState(State.Running);\n+        return true;\n+    }\n+\n+    /**\n+     * Stop Service.\n+     * @return successful\n+     */\n+    public boolean stopService() {\n+        setDesiredState(State.Finished);\n+        return true;\n+    }\n+\n+    /**\n+     * Restart Service.\n+     * @return successful\n+     */\n+    public boolean restartService() {\n+        setDesiredState(State.Finished, State.Running);\n+        return true;\n+    }\n+\n+    /**\n+     * ReInstall Service.\n+     * @return successful\n+     */\n+    public boolean reInstallService() {\n+        setDesiredState(State.Finished, State.New, State.Running);\n+        return true;\n+    }\n+\n+    /**\n+     * Error out a service.\n+     */\n+    public void errorService() {\n+        setState(State.Errored);\n+    }\n+\n+    private void waitOnStateChangeEvent(State currentState) throws InterruptedException {\n+        synchronized (stateChangeEvent) {\n+            while (desiredStateList.isEmpty() && getState() == currentState) {\n+                stateChangeEvent.wait();\n+            }\n+        }\n+    }\n+\n+    private void startStateTransition() throws InterruptedException {\n+        periodicityInformation = Periodicity.of(this);\n+        while (true) {\n+            State desiredState = null;\n+            switch (this.getState()) {\n+                case Broken:\n+                    context.getLog().significant(getName(), \"Broken\");\n+                    return;\n+                case New:\n+                    desiredState = peekOrRemoveFirstDesiredState(State.New);\n+                    if (desiredState == null || desiredState == State.New) {\n+                        waitOnStateChangeEvent(State.New);\n+                        continue;", "originalCommit": "7ee25d34a650229a91879e35befec8209bedcc8d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQ5MDU0OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381490549", "bodyText": "ok", "author": "ShirleyZheng92", "createdAt": "2020-02-19T19:20:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA5MDg0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA5MTAyOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381091029", "bodyText": "Why isn't this running in the backing task too? If we wanted to have timeouts and cancellation, then it would need to be, right? And I think that we do want those abilities.", "author": "MikeDombo", "createdAt": "2020-02-19T05:58:27Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -198,144 +216,227 @@ public Topic getStateTopic() {\n         return state;\n     }\n \n-    public boolean isRunningInternally() {\n-        Future b = backingTask;\n-        return b != null && !b.isDone();\n-    }\n-\n     public boolean isPeriodic() {\n         return periodicityInformation != null;\n     }\n \n-    @Override // for listening to state changes\n-    public void published(final WhatHappened what, final Topic topic) {\n-        final State newState = (State) topic.getOnce();\n-        if (activeState == newState) {\n-            return;\n+    private final List<State> desiredStateList = new ArrayList<>(100);\n+\n+    //Used to notify when state has changed Or a desiredState is set.\n+    private final Object stateChangeEvent = new Object();\n+\n+    private State peekOrRemoveFirstDesiredState(State state) {\n+        synchronized (desiredStateList) {\n+            if (desiredStateList.isEmpty()) {\n+                return null;\n+            }\n+            State first = desiredStateList.get(0);\n+            if (first == state) {\n+                return desiredStateList.remove(0);\n+            } else {\n+                return first;\n+            }\n         }\n-        if (activeState.isRunning() && !newState.isRunning()) { // transition from running to not running\n-            shutdownLatch = new CountDownLatch(1);\n-            // Assume that shutdown task won't be cancelled. Following states (installing/awaitingStartup) wait until\n-            // shutdown task complete.\n-            // May consider just merge shutdown() into other state's handling.\n-            State oldState = activeState;\n-            setBackingTask(() -> {\n-                try {\n-                    shutdown();\n-                } catch (Throwable t) {\n-                    if (oldState != State.Errored) {\n-                        errored(\"Failed shutting down\", t);\n-                    } else {\n-                        context.getLog().error(this, \"Failed shutting down\", t);\n-                    }\n-                } finally {\n-                    shutdownLatch.countDown();\n-                }\n-                backingTask = null;\n-            }, getName() + \"=>\" + newState);\n+    }\n \n-            // Since shutdown() is modeled as part of state transition, I initially tried waiting on shutdownLatch()\n-            // here.\n-            // However, this caused the global configuration publish queue being blocked.\n+    private void setDesiredState(State... state) {\n+        synchronized (desiredStateList) {\n+            List<State> newStateList = Arrays.asList(state);\n+            if (newStateList.equals(desiredStateList)) {\n+                return;\n+            }\n+            desiredStateList.clear();\n+            desiredStateList.addAll(newStateList);\n+            synchronized (stateChangeEvent) {\n+                stateChangeEvent.notifyAll();\n+            }\n         }\n+    }\n \n-        try {\n-            switch (newState) {\n-                case Installing:\n-                    new Thread(() -> {\n-                        // wait until shutdown finished.\n-                        // not using setBackTask() here to avoid cancelling the ongoing shutdown task\n-                        try {\n-                            shutdownLatch.await();\n-                        } catch (InterruptedException e) {\n-                            errored(\"waiting for shutdown complete\", e);\n-                            return;\n-                        }\n-                        // TODO: wait until all install dependency ready.\n-                        if (!errored() && getState() == State.Installing) {\n+    /**\n+     * Start Service.\n+     * @return successful\n+     */\n+    public boolean startService() {\n+        setDesiredState(State.Running);\n+        return true;\n+    }\n+\n+    /**\n+     * Stop Service.\n+     * @return successful\n+     */\n+    public boolean stopService() {\n+        setDesiredState(State.Finished);\n+        return true;\n+    }\n+\n+    /**\n+     * Restart Service.\n+     * @return successful\n+     */\n+    public boolean restartService() {\n+        setDesiredState(State.Finished, State.Running);\n+        return true;\n+    }\n+\n+    /**\n+     * ReInstall Service.\n+     * @return successful\n+     */\n+    public boolean reInstallService() {\n+        setDesiredState(State.Finished, State.New, State.Running);\n+        return true;\n+    }\n+\n+    /**\n+     * Error out a service.\n+     */\n+    public void errorService() {\n+        setState(State.Errored);\n+    }\n+\n+    private void waitOnStateChangeEvent(State currentState) throws InterruptedException {\n+        synchronized (stateChangeEvent) {\n+            while (desiredStateList.isEmpty() && getState() == currentState) {\n+                stateChangeEvent.wait();\n+            }\n+        }\n+    }\n+\n+    private void startStateTransition() throws InterruptedException {\n+        periodicityInformation = Periodicity.of(this);\n+        while (true) {\n+            State desiredState = null;\n+            switch (this.getState()) {\n+                case Broken:\n+                    context.getLog().significant(getName(), \"Broken\");\n+                    return;\n+                case New:\n+                    desiredState = peekOrRemoveFirstDesiredState(State.New);\n+                    if (desiredState == null || desiredState == State.New) {\n+                        waitOnStateChangeEvent(State.New);\n+                        continue;\n+                    }\n+                    try {\n+                        install();", "originalCommit": "7ee25d34a650229a91879e35befec8209bedcc8d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTYxMTYzNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381611635", "bodyText": "Added TODO.", "author": "ShirleyZheng92", "createdAt": "2020-02-19T23:42:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA5MTAyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA5MTMxNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381091314", "bodyText": "This should be enforced when setting the desired state list. At least the states which are never allowed to be desired should be filtered out at that point.", "author": "MikeDombo", "createdAt": "2020-02-19T05:59:50Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -198,144 +216,227 @@ public Topic getStateTopic() {\n         return state;\n     }\n \n-    public boolean isRunningInternally() {\n-        Future b = backingTask;\n-        return b != null && !b.isDone();\n-    }\n-\n     public boolean isPeriodic() {\n         return periodicityInformation != null;\n     }\n \n-    @Override // for listening to state changes\n-    public void published(final WhatHappened what, final Topic topic) {\n-        final State newState = (State) topic.getOnce();\n-        if (activeState == newState) {\n-            return;\n+    private final List<State> desiredStateList = new ArrayList<>(100);\n+\n+    //Used to notify when state has changed Or a desiredState is set.\n+    private final Object stateChangeEvent = new Object();\n+\n+    private State peekOrRemoveFirstDesiredState(State state) {\n+        synchronized (desiredStateList) {\n+            if (desiredStateList.isEmpty()) {\n+                return null;\n+            }\n+            State first = desiredStateList.get(0);\n+            if (first == state) {\n+                return desiredStateList.remove(0);\n+            } else {\n+                return first;\n+            }\n         }\n-        if (activeState.isRunning() && !newState.isRunning()) { // transition from running to not running\n-            shutdownLatch = new CountDownLatch(1);\n-            // Assume that shutdown task won't be cancelled. Following states (installing/awaitingStartup) wait until\n-            // shutdown task complete.\n-            // May consider just merge shutdown() into other state's handling.\n-            State oldState = activeState;\n-            setBackingTask(() -> {\n-                try {\n-                    shutdown();\n-                } catch (Throwable t) {\n-                    if (oldState != State.Errored) {\n-                        errored(\"Failed shutting down\", t);\n-                    } else {\n-                        context.getLog().error(this, \"Failed shutting down\", t);\n-                    }\n-                } finally {\n-                    shutdownLatch.countDown();\n-                }\n-                backingTask = null;\n-            }, getName() + \"=>\" + newState);\n+    }\n \n-            // Since shutdown() is modeled as part of state transition, I initially tried waiting on shutdownLatch()\n-            // here.\n-            // However, this caused the global configuration publish queue being blocked.\n+    private void setDesiredState(State... state) {\n+        synchronized (desiredStateList) {\n+            List<State> newStateList = Arrays.asList(state);\n+            if (newStateList.equals(desiredStateList)) {\n+                return;\n+            }\n+            desiredStateList.clear();\n+            desiredStateList.addAll(newStateList);\n+            synchronized (stateChangeEvent) {\n+                stateChangeEvent.notifyAll();\n+            }\n         }\n+    }\n \n-        try {\n-            switch (newState) {\n-                case Installing:\n-                    new Thread(() -> {\n-                        // wait until shutdown finished.\n-                        // not using setBackTask() here to avoid cancelling the ongoing shutdown task\n-                        try {\n-                            shutdownLatch.await();\n-                        } catch (InterruptedException e) {\n-                            errored(\"waiting for shutdown complete\", e);\n-                            return;\n-                        }\n-                        // TODO: wait until all install dependency ready.\n-                        if (!errored() && getState() == State.Installing) {\n+    /**\n+     * Start Service.\n+     * @return successful\n+     */\n+    public boolean startService() {\n+        setDesiredState(State.Running);\n+        return true;\n+    }\n+\n+    /**\n+     * Stop Service.\n+     * @return successful\n+     */\n+    public boolean stopService() {\n+        setDesiredState(State.Finished);\n+        return true;\n+    }\n+\n+    /**\n+     * Restart Service.\n+     * @return successful\n+     */\n+    public boolean restartService() {\n+        setDesiredState(State.Finished, State.Running);\n+        return true;\n+    }\n+\n+    /**\n+     * ReInstall Service.\n+     * @return successful\n+     */\n+    public boolean reInstallService() {\n+        setDesiredState(State.Finished, State.New, State.Running);\n+        return true;\n+    }\n+\n+    /**\n+     * Error out a service.\n+     */\n+    public void errorService() {\n+        setState(State.Errored);\n+    }\n+\n+    private void waitOnStateChangeEvent(State currentState) throws InterruptedException {\n+        synchronized (stateChangeEvent) {\n+            while (desiredStateList.isEmpty() && getState() == currentState) {\n+                stateChangeEvent.wait();\n+            }\n+        }\n+    }\n+\n+    private void startStateTransition() throws InterruptedException {\n+        periodicityInformation = Periodicity.of(this);\n+        while (true) {\n+            State desiredState = null;\n+            switch (this.getState()) {\n+                case Broken:\n+                    context.getLog().significant(getName(), \"Broken\");\n+                    return;\n+                case New:\n+                    desiredState = peekOrRemoveFirstDesiredState(State.New);\n+                    if (desiredState == null || desiredState == State.New) {\n+                        waitOnStateChangeEvent(State.New);\n+                        continue;\n+                    }\n+                    try {\n+                        install();\n+                    } catch (Throwable t) {\n+                        errored(\"Error in install\", t);\n+                    }\n+                    if (getState() != State.Errored) {\n+                        setState(State.Installed);\n+                    }\n+                    continue;\n+                case Installed:\n+                    desiredState = peekOrRemoveFirstDesiredState(State.Installed);\n+                    if (desiredState == null || desiredState == State.Installed) {\n+                        waitOnStateChangeEvent(State.Installed);\n+                        continue;\n+                    }\n+\n+                    switch (desiredState) {\n+                        case Finished:\n+                            setBackingTask(null, null);\n+                            setState(State.Finished);\n+                            break;\n+                        case Running:\n+                            //TODO: use backing task\n                             setBackingTask(() -> {\n                                 try {\n-                                    install();\n-                                    if (!errored()) {\n-                                        setState(State.AwaitingStartup);\n-                                    }\n-                                } catch (Throwable t) {\n-                                    errored(\"Failed installing\", t);\n+                                    waitForDependencyReady();\n+                                    context.getLog().error(getName(), \"starting\");\n+                                    startup();// TODO: rename to  initiateStartup. Service need to report state to Running.\n+                                    setBackingTask(null, null);\n+                                } catch (InterruptedException e) {\n+                                    return;\n                                 }\n-                                backingTask = null;\n-                            }, getName() + \" => \" + newState);\n-                        }\n-                    }).start();\n+                            }, \"start\");\n \n-                    break;\n-                case AwaitingStartup:\n-                    awaitingStartup();\n-                    new Thread(() -> {\n-                        // wait until shutdown finished.\n-                        try {\n-                            shutdownLatch.await();\n-                        } catch (InterruptedException e) {\n-                            errored(\"waiting for shutdown complete\", e);\n-                            return;\n-                        }\n-                        if (dependencies != null) {\n-                            try {\n-                                waitForDependencyReady();\n-                            } catch (InterruptedException e) {\n-                                errored(\"waiting for dependency ready\", e);\n+                            synchronized (stateChangeEvent) {\n+                                if (getState() == State.Installed) {\n+                                    stateChangeEvent.wait();\n+                                }\n                             }\n-                        }\n-                        // if no other state change happened in between\n-                        if (!errored() && getState() == State.AwaitingStartup) {\n-                            setState(State.Starting);\n-                        }\n-                    }).start();\n \n-                    break;\n-                case Starting:\n-                    setBackingTask(() -> {\n-                        try {\n-                            periodicityInformation = Periodicity.of(this);\n-                            startup();\n-                            if (!errored()) {\n-                                setState(isPeriodic()  // Let timer do the transition to Running==null\n-                                        ? State.Finished : State.Running);\n-                            }\n-                        } catch (Throwable t) {\n-                            errored(\"Failed starting up\", t);\n-                        }\n-                        backingTask = null;\n-                    }, getName() + \" => \" + newState);\n-                    break;\n+                            break;\n+                        default:\n+                            context.getLog().error(\"Unexpected desired state\", desiredState);\n+                            // not allowed for New, Stopping, Errored, Broken", "originalCommit": "7ee25d34a650229a91879e35befec8209bedcc8d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTYxMTgyOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381611828", "bodyText": "setDesiredState is only called in EvergreenService so far", "author": "ShirleyZheng92", "createdAt": "2020-02-19T23:43:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA5MTMxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA5MTc1OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381091758", "bodyText": "Why setting it to null is needed? Shouldn't the backing task finish up once startup is done, and then there shouldn't be anything else to do.", "author": "MikeDombo", "createdAt": "2020-02-19T06:01:48Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -198,144 +216,227 @@ public Topic getStateTopic() {\n         return state;\n     }\n \n-    public boolean isRunningInternally() {\n-        Future b = backingTask;\n-        return b != null && !b.isDone();\n-    }\n-\n     public boolean isPeriodic() {\n         return periodicityInformation != null;\n     }\n \n-    @Override // for listening to state changes\n-    public void published(final WhatHappened what, final Topic topic) {\n-        final State newState = (State) topic.getOnce();\n-        if (activeState == newState) {\n-            return;\n+    private final List<State> desiredStateList = new ArrayList<>(100);\n+\n+    //Used to notify when state has changed Or a desiredState is set.\n+    private final Object stateChangeEvent = new Object();\n+\n+    private State peekOrRemoveFirstDesiredState(State state) {\n+        synchronized (desiredStateList) {\n+            if (desiredStateList.isEmpty()) {\n+                return null;\n+            }\n+            State first = desiredStateList.get(0);\n+            if (first == state) {\n+                return desiredStateList.remove(0);\n+            } else {\n+                return first;\n+            }\n         }\n-        if (activeState.isRunning() && !newState.isRunning()) { // transition from running to not running\n-            shutdownLatch = new CountDownLatch(1);\n-            // Assume that shutdown task won't be cancelled. Following states (installing/awaitingStartup) wait until\n-            // shutdown task complete.\n-            // May consider just merge shutdown() into other state's handling.\n-            State oldState = activeState;\n-            setBackingTask(() -> {\n-                try {\n-                    shutdown();\n-                } catch (Throwable t) {\n-                    if (oldState != State.Errored) {\n-                        errored(\"Failed shutting down\", t);\n-                    } else {\n-                        context.getLog().error(this, \"Failed shutting down\", t);\n-                    }\n-                } finally {\n-                    shutdownLatch.countDown();\n-                }\n-                backingTask = null;\n-            }, getName() + \"=>\" + newState);\n+    }\n \n-            // Since shutdown() is modeled as part of state transition, I initially tried waiting on shutdownLatch()\n-            // here.\n-            // However, this caused the global configuration publish queue being blocked.\n+    private void setDesiredState(State... state) {\n+        synchronized (desiredStateList) {\n+            List<State> newStateList = Arrays.asList(state);\n+            if (newStateList.equals(desiredStateList)) {\n+                return;\n+            }\n+            desiredStateList.clear();\n+            desiredStateList.addAll(newStateList);\n+            synchronized (stateChangeEvent) {\n+                stateChangeEvent.notifyAll();\n+            }\n         }\n+    }\n \n-        try {\n-            switch (newState) {\n-                case Installing:\n-                    new Thread(() -> {\n-                        // wait until shutdown finished.\n-                        // not using setBackTask() here to avoid cancelling the ongoing shutdown task\n-                        try {\n-                            shutdownLatch.await();\n-                        } catch (InterruptedException e) {\n-                            errored(\"waiting for shutdown complete\", e);\n-                            return;\n-                        }\n-                        // TODO: wait until all install dependency ready.\n-                        if (!errored() && getState() == State.Installing) {\n+    /**\n+     * Start Service.\n+     * @return successful\n+     */\n+    public boolean startService() {\n+        setDesiredState(State.Running);\n+        return true;\n+    }\n+\n+    /**\n+     * Stop Service.\n+     * @return successful\n+     */\n+    public boolean stopService() {\n+        setDesiredState(State.Finished);\n+        return true;\n+    }\n+\n+    /**\n+     * Restart Service.\n+     * @return successful\n+     */\n+    public boolean restartService() {\n+        setDesiredState(State.Finished, State.Running);\n+        return true;\n+    }\n+\n+    /**\n+     * ReInstall Service.\n+     * @return successful\n+     */\n+    public boolean reInstallService() {\n+        setDesiredState(State.Finished, State.New, State.Running);\n+        return true;\n+    }\n+\n+    /**\n+     * Error out a service.\n+     */\n+    public void errorService() {\n+        setState(State.Errored);\n+    }\n+\n+    private void waitOnStateChangeEvent(State currentState) throws InterruptedException {\n+        synchronized (stateChangeEvent) {\n+            while (desiredStateList.isEmpty() && getState() == currentState) {\n+                stateChangeEvent.wait();\n+            }\n+        }\n+    }\n+\n+    private void startStateTransition() throws InterruptedException {\n+        periodicityInformation = Periodicity.of(this);\n+        while (true) {\n+            State desiredState = null;\n+            switch (this.getState()) {\n+                case Broken:\n+                    context.getLog().significant(getName(), \"Broken\");\n+                    return;\n+                case New:\n+                    desiredState = peekOrRemoveFirstDesiredState(State.New);\n+                    if (desiredState == null || desiredState == State.New) {\n+                        waitOnStateChangeEvent(State.New);\n+                        continue;\n+                    }\n+                    try {\n+                        install();\n+                    } catch (Throwable t) {\n+                        errored(\"Error in install\", t);\n+                    }\n+                    if (getState() != State.Errored) {\n+                        setState(State.Installed);\n+                    }\n+                    continue;\n+                case Installed:\n+                    desiredState = peekOrRemoveFirstDesiredState(State.Installed);\n+                    if (desiredState == null || desiredState == State.Installed) {\n+                        waitOnStateChangeEvent(State.Installed);\n+                        continue;\n+                    }\n+\n+                    switch (desiredState) {\n+                        case Finished:\n+                            setBackingTask(null, null);\n+                            setState(State.Finished);\n+                            break;\n+                        case Running:\n+                            //TODO: use backing task\n                             setBackingTask(() -> {\n                                 try {\n-                                    install();\n-                                    if (!errored()) {\n-                                        setState(State.AwaitingStartup);\n-                                    }\n-                                } catch (Throwable t) {\n-                                    errored(\"Failed installing\", t);\n+                                    waitForDependencyReady();\n+                                    context.getLog().error(getName(), \"starting\");\n+                                    startup();// TODO: rename to  initiateStartup. Service need to report state to Running.\n+                                    setBackingTask(null, null);", "originalCommit": "7ee25d34a650229a91879e35befec8209bedcc8d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA5MTk5Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381091996", "bodyText": "instead of setting the backing task to null, should we have a function to kill the task and then set it to null? That may be a nicer API. stopBackingTask().", "author": "MikeDombo", "createdAt": "2020-02-19T06:02:50Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -198,144 +216,227 @@ public Topic getStateTopic() {\n         return state;\n     }\n \n-    public boolean isRunningInternally() {\n-        Future b = backingTask;\n-        return b != null && !b.isDone();\n-    }\n-\n     public boolean isPeriodic() {\n         return periodicityInformation != null;\n     }\n \n-    @Override // for listening to state changes\n-    public void published(final WhatHappened what, final Topic topic) {\n-        final State newState = (State) topic.getOnce();\n-        if (activeState == newState) {\n-            return;\n+    private final List<State> desiredStateList = new ArrayList<>(100);\n+\n+    //Used to notify when state has changed Or a desiredState is set.\n+    private final Object stateChangeEvent = new Object();\n+\n+    private State peekOrRemoveFirstDesiredState(State state) {\n+        synchronized (desiredStateList) {\n+            if (desiredStateList.isEmpty()) {\n+                return null;\n+            }\n+            State first = desiredStateList.get(0);\n+            if (first == state) {\n+                return desiredStateList.remove(0);\n+            } else {\n+                return first;\n+            }\n         }\n-        if (activeState.isRunning() && !newState.isRunning()) { // transition from running to not running\n-            shutdownLatch = new CountDownLatch(1);\n-            // Assume that shutdown task won't be cancelled. Following states (installing/awaitingStartup) wait until\n-            // shutdown task complete.\n-            // May consider just merge shutdown() into other state's handling.\n-            State oldState = activeState;\n-            setBackingTask(() -> {\n-                try {\n-                    shutdown();\n-                } catch (Throwable t) {\n-                    if (oldState != State.Errored) {\n-                        errored(\"Failed shutting down\", t);\n-                    } else {\n-                        context.getLog().error(this, \"Failed shutting down\", t);\n-                    }\n-                } finally {\n-                    shutdownLatch.countDown();\n-                }\n-                backingTask = null;\n-            }, getName() + \"=>\" + newState);\n+    }\n \n-            // Since shutdown() is modeled as part of state transition, I initially tried waiting on shutdownLatch()\n-            // here.\n-            // However, this caused the global configuration publish queue being blocked.\n+    private void setDesiredState(State... state) {\n+        synchronized (desiredStateList) {\n+            List<State> newStateList = Arrays.asList(state);\n+            if (newStateList.equals(desiredStateList)) {\n+                return;\n+            }\n+            desiredStateList.clear();\n+            desiredStateList.addAll(newStateList);\n+            synchronized (stateChangeEvent) {\n+                stateChangeEvent.notifyAll();\n+            }\n         }\n+    }\n \n-        try {\n-            switch (newState) {\n-                case Installing:\n-                    new Thread(() -> {\n-                        // wait until shutdown finished.\n-                        // not using setBackTask() here to avoid cancelling the ongoing shutdown task\n-                        try {\n-                            shutdownLatch.await();\n-                        } catch (InterruptedException e) {\n-                            errored(\"waiting for shutdown complete\", e);\n-                            return;\n-                        }\n-                        // TODO: wait until all install dependency ready.\n-                        if (!errored() && getState() == State.Installing) {\n+    /**\n+     * Start Service.\n+     * @return successful\n+     */\n+    public boolean startService() {\n+        setDesiredState(State.Running);\n+        return true;\n+    }\n+\n+    /**\n+     * Stop Service.\n+     * @return successful\n+     */\n+    public boolean stopService() {\n+        setDesiredState(State.Finished);\n+        return true;\n+    }\n+\n+    /**\n+     * Restart Service.\n+     * @return successful\n+     */\n+    public boolean restartService() {\n+        setDesiredState(State.Finished, State.Running);\n+        return true;\n+    }\n+\n+    /**\n+     * ReInstall Service.\n+     * @return successful\n+     */\n+    public boolean reInstallService() {\n+        setDesiredState(State.Finished, State.New, State.Running);\n+        return true;\n+    }\n+\n+    /**\n+     * Error out a service.\n+     */\n+    public void errorService() {\n+        setState(State.Errored);\n+    }\n+\n+    private void waitOnStateChangeEvent(State currentState) throws InterruptedException {\n+        synchronized (stateChangeEvent) {\n+            while (desiredStateList.isEmpty() && getState() == currentState) {\n+                stateChangeEvent.wait();\n+            }\n+        }\n+    }\n+\n+    private void startStateTransition() throws InterruptedException {\n+        periodicityInformation = Periodicity.of(this);\n+        while (true) {\n+            State desiredState = null;\n+            switch (this.getState()) {\n+                case Broken:\n+                    context.getLog().significant(getName(), \"Broken\");\n+                    return;\n+                case New:\n+                    desiredState = peekOrRemoveFirstDesiredState(State.New);\n+                    if (desiredState == null || desiredState == State.New) {\n+                        waitOnStateChangeEvent(State.New);\n+                        continue;\n+                    }\n+                    try {\n+                        install();\n+                    } catch (Throwable t) {\n+                        errored(\"Error in install\", t);\n+                    }\n+                    if (getState() != State.Errored) {\n+                        setState(State.Installed);\n+                    }\n+                    continue;\n+                case Installed:\n+                    desiredState = peekOrRemoveFirstDesiredState(State.Installed);\n+                    if (desiredState == null || desiredState == State.Installed) {\n+                        waitOnStateChangeEvent(State.Installed);\n+                        continue;\n+                    }\n+\n+                    switch (desiredState) {\n+                        case Finished:\n+                            setBackingTask(null, null);", "originalCommit": "7ee25d34a650229a91879e35befec8209bedcc8d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA5MjIyOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381092229", "bodyText": "Since we're reusing this pattern a lot it should be extractable to a function that just takes the current state.", "author": "MikeDombo", "createdAt": "2020-02-19T06:03:51Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -198,144 +216,227 @@ public Topic getStateTopic() {\n         return state;\n     }\n \n-    public boolean isRunningInternally() {\n-        Future b = backingTask;\n-        return b != null && !b.isDone();\n-    }\n-\n     public boolean isPeriodic() {\n         return periodicityInformation != null;\n     }\n \n-    @Override // for listening to state changes\n-    public void published(final WhatHappened what, final Topic topic) {\n-        final State newState = (State) topic.getOnce();\n-        if (activeState == newState) {\n-            return;\n+    private final List<State> desiredStateList = new ArrayList<>(100);\n+\n+    //Used to notify when state has changed Or a desiredState is set.\n+    private final Object stateChangeEvent = new Object();\n+\n+    private State peekOrRemoveFirstDesiredState(State state) {\n+        synchronized (desiredStateList) {\n+            if (desiredStateList.isEmpty()) {\n+                return null;\n+            }\n+            State first = desiredStateList.get(0);\n+            if (first == state) {\n+                return desiredStateList.remove(0);\n+            } else {\n+                return first;\n+            }\n         }\n-        if (activeState.isRunning() && !newState.isRunning()) { // transition from running to not running\n-            shutdownLatch = new CountDownLatch(1);\n-            // Assume that shutdown task won't be cancelled. Following states (installing/awaitingStartup) wait until\n-            // shutdown task complete.\n-            // May consider just merge shutdown() into other state's handling.\n-            State oldState = activeState;\n-            setBackingTask(() -> {\n-                try {\n-                    shutdown();\n-                } catch (Throwable t) {\n-                    if (oldState != State.Errored) {\n-                        errored(\"Failed shutting down\", t);\n-                    } else {\n-                        context.getLog().error(this, \"Failed shutting down\", t);\n-                    }\n-                } finally {\n-                    shutdownLatch.countDown();\n-                }\n-                backingTask = null;\n-            }, getName() + \"=>\" + newState);\n+    }\n \n-            // Since shutdown() is modeled as part of state transition, I initially tried waiting on shutdownLatch()\n-            // here.\n-            // However, this caused the global configuration publish queue being blocked.\n+    private void setDesiredState(State... state) {\n+        synchronized (desiredStateList) {\n+            List<State> newStateList = Arrays.asList(state);\n+            if (newStateList.equals(desiredStateList)) {\n+                return;\n+            }\n+            desiredStateList.clear();\n+            desiredStateList.addAll(newStateList);\n+            synchronized (stateChangeEvent) {\n+                stateChangeEvent.notifyAll();\n+            }\n         }\n+    }\n \n-        try {\n-            switch (newState) {\n-                case Installing:\n-                    new Thread(() -> {\n-                        // wait until shutdown finished.\n-                        // not using setBackTask() here to avoid cancelling the ongoing shutdown task\n-                        try {\n-                            shutdownLatch.await();\n-                        } catch (InterruptedException e) {\n-                            errored(\"waiting for shutdown complete\", e);\n-                            return;\n-                        }\n-                        // TODO: wait until all install dependency ready.\n-                        if (!errored() && getState() == State.Installing) {\n+    /**\n+     * Start Service.\n+     * @return successful\n+     */\n+    public boolean startService() {\n+        setDesiredState(State.Running);\n+        return true;\n+    }\n+\n+    /**\n+     * Stop Service.\n+     * @return successful\n+     */\n+    public boolean stopService() {\n+        setDesiredState(State.Finished);\n+        return true;\n+    }\n+\n+    /**\n+     * Restart Service.\n+     * @return successful\n+     */\n+    public boolean restartService() {\n+        setDesiredState(State.Finished, State.Running);\n+        return true;\n+    }\n+\n+    /**\n+     * ReInstall Service.\n+     * @return successful\n+     */\n+    public boolean reInstallService() {\n+        setDesiredState(State.Finished, State.New, State.Running);\n+        return true;\n+    }\n+\n+    /**\n+     * Error out a service.\n+     */\n+    public void errorService() {\n+        setState(State.Errored);\n+    }\n+\n+    private void waitOnStateChangeEvent(State currentState) throws InterruptedException {\n+        synchronized (stateChangeEvent) {\n+            while (desiredStateList.isEmpty() && getState() == currentState) {\n+                stateChangeEvent.wait();\n+            }\n+        }\n+    }\n+\n+    private void startStateTransition() throws InterruptedException {\n+        periodicityInformation = Periodicity.of(this);\n+        while (true) {\n+            State desiredState = null;\n+            switch (this.getState()) {\n+                case Broken:\n+                    context.getLog().significant(getName(), \"Broken\");\n+                    return;\n+                case New:\n+                    desiredState = peekOrRemoveFirstDesiredState(State.New);\n+                    if (desiredState == null || desiredState == State.New) {\n+                        waitOnStateChangeEvent(State.New);\n+                        continue;\n+                    }\n+                    try {\n+                        install();\n+                    } catch (Throwable t) {\n+                        errored(\"Error in install\", t);\n+                    }\n+                    if (getState() != State.Errored) {\n+                        setState(State.Installed);\n+                    }\n+                    continue;\n+                case Installed:\n+                    desiredState = peekOrRemoveFirstDesiredState(State.Installed);\n+                    if (desiredState == null || desiredState == State.Installed) {\n+                        waitOnStateChangeEvent(State.Installed);\n+                        continue;\n+                    }\n+\n+                    switch (desiredState) {\n+                        case Finished:\n+                            setBackingTask(null, null);\n+                            setState(State.Finished);\n+                            break;\n+                        case Running:\n+                            //TODO: use backing task\n                             setBackingTask(() -> {\n                                 try {\n-                                    install();\n-                                    if (!errored()) {\n-                                        setState(State.AwaitingStartup);\n-                                    }\n-                                } catch (Throwable t) {\n-                                    errored(\"Failed installing\", t);\n+                                    waitForDependencyReady();\n+                                    context.getLog().error(getName(), \"starting\");\n+                                    startup();// TODO: rename to  initiateStartup. Service need to report state to Running.\n+                                    setBackingTask(null, null);\n+                                } catch (InterruptedException e) {\n+                                    return;\n                                 }\n-                                backingTask = null;\n-                            }, getName() + \" => \" + newState);\n-                        }\n-                    }).start();\n+                            }, \"start\");\n \n-                    break;\n-                case AwaitingStartup:\n-                    awaitingStartup();\n-                    new Thread(() -> {\n-                        // wait until shutdown finished.\n-                        try {\n-                            shutdownLatch.await();\n-                        } catch (InterruptedException e) {\n-                            errored(\"waiting for shutdown complete\", e);\n-                            return;\n-                        }\n-                        if (dependencies != null) {\n-                            try {\n-                                waitForDependencyReady();\n-                            } catch (InterruptedException e) {\n-                                errored(\"waiting for dependency ready\", e);\n+                            synchronized (stateChangeEvent) {\n+                                if (getState() == State.Installed) {\n+                                    stateChangeEvent.wait();\n+                                }\n                             }\n-                        }\n-                        // if no other state change happened in between\n-                        if (!errored() && getState() == State.AwaitingStartup) {\n-                            setState(State.Starting);\n-                        }\n-                    }).start();\n \n-                    break;\n-                case Starting:\n-                    setBackingTask(() -> {\n-                        try {\n-                            periodicityInformation = Periodicity.of(this);\n-                            startup();\n-                            if (!errored()) {\n-                                setState(isPeriodic()  // Let timer do the transition to Running==null\n-                                        ? State.Finished : State.Running);\n-                            }\n-                        } catch (Throwable t) {\n-                            errored(\"Failed starting up\", t);\n-                        }\n-                        backingTask = null;\n-                    }, getName() + \" => \" + newState);\n-                    break;\n+                            break;\n+                        default:\n+                            context.getLog().error(\"Unexpected desired state\", desiredState);\n+                            // not allowed for New, Stopping, Errored, Broken\n+                            break;\n+                    }\n+                    continue;\n                 case Running:\n-                    if (!activeState.isRunning()) {\n-                        setBackingTask(() -> {\n-                            try {\n-                                run();\n-                                // subclasses implementing run() should handle state transition;\n-                            } catch (Throwable t) {\n-                                errored(\"Failed starting up\", t);\n-                            }\n-                            backingTask = null;\n-                        }, getName() + \" => \" + newState);\n+                    desiredState = peekOrRemoveFirstDesiredState(State.Running);\n+                    if (desiredState == null || desiredState == State.Running) {\n+                        waitOnStateChangeEvent(State.Running);\n+                        continue;\n                     }\n-                    break;\n+                    setState(State.Stopping);\n+                    continue;\n+                case Stopping:\n+                    // doesn't handle desiredState in Stopping.\n+                    shutdown();\n+                    if (this.getState() != State.Errored) {\n+                        setState(State.Finished);\n+                    }\n+                    continue;\n+                case Finished:\n+                    desiredState = peekOrRemoveFirstDesiredState(State.Finished);\n+                    if (desiredState == null || desiredState == State.Finished) {\n+                        waitOnStateChangeEvent(State.Finished);\n+                        continue;\n+                    }", "originalCommit": "7ee25d34a650229a91879e35befec8209bedcc8d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTYxMTIwOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381611209", "bodyText": "+1", "author": "leaf94", "createdAt": "2020-02-19T23:41:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA5MjIyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA5MjQ3Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381092477", "bodyText": "Right now there's no way for a service to get into the broken state it seems. Am I right in saying that?", "author": "MikeDombo", "createdAt": "2020-02-19T06:04:54Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -198,144 +216,227 @@ public Topic getStateTopic() {\n         return state;\n     }\n \n-    public boolean isRunningInternally() {\n-        Future b = backingTask;\n-        return b != null && !b.isDone();\n-    }\n-\n     public boolean isPeriodic() {\n         return periodicityInformation != null;\n     }\n \n-    @Override // for listening to state changes\n-    public void published(final WhatHappened what, final Topic topic) {\n-        final State newState = (State) topic.getOnce();\n-        if (activeState == newState) {\n-            return;\n+    private final List<State> desiredStateList = new ArrayList<>(100);\n+\n+    //Used to notify when state has changed Or a desiredState is set.\n+    private final Object stateChangeEvent = new Object();\n+\n+    private State peekOrRemoveFirstDesiredState(State state) {\n+        synchronized (desiredStateList) {\n+            if (desiredStateList.isEmpty()) {\n+                return null;\n+            }\n+            State first = desiredStateList.get(0);\n+            if (first == state) {\n+                return desiredStateList.remove(0);\n+            } else {\n+                return first;\n+            }\n         }\n-        if (activeState.isRunning() && !newState.isRunning()) { // transition from running to not running\n-            shutdownLatch = new CountDownLatch(1);\n-            // Assume that shutdown task won't be cancelled. Following states (installing/awaitingStartup) wait until\n-            // shutdown task complete.\n-            // May consider just merge shutdown() into other state's handling.\n-            State oldState = activeState;\n-            setBackingTask(() -> {\n-                try {\n-                    shutdown();\n-                } catch (Throwable t) {\n-                    if (oldState != State.Errored) {\n-                        errored(\"Failed shutting down\", t);\n-                    } else {\n-                        context.getLog().error(this, \"Failed shutting down\", t);\n-                    }\n-                } finally {\n-                    shutdownLatch.countDown();\n-                }\n-                backingTask = null;\n-            }, getName() + \"=>\" + newState);\n+    }\n \n-            // Since shutdown() is modeled as part of state transition, I initially tried waiting on shutdownLatch()\n-            // here.\n-            // However, this caused the global configuration publish queue being blocked.\n+    private void setDesiredState(State... state) {\n+        synchronized (desiredStateList) {\n+            List<State> newStateList = Arrays.asList(state);\n+            if (newStateList.equals(desiredStateList)) {\n+                return;\n+            }\n+            desiredStateList.clear();\n+            desiredStateList.addAll(newStateList);\n+            synchronized (stateChangeEvent) {\n+                stateChangeEvent.notifyAll();\n+            }\n         }\n+    }\n \n-        try {\n-            switch (newState) {\n-                case Installing:\n-                    new Thread(() -> {\n-                        // wait until shutdown finished.\n-                        // not using setBackTask() here to avoid cancelling the ongoing shutdown task\n-                        try {\n-                            shutdownLatch.await();\n-                        } catch (InterruptedException e) {\n-                            errored(\"waiting for shutdown complete\", e);\n-                            return;\n-                        }\n-                        // TODO: wait until all install dependency ready.\n-                        if (!errored() && getState() == State.Installing) {\n+    /**\n+     * Start Service.\n+     * @return successful\n+     */\n+    public boolean startService() {\n+        setDesiredState(State.Running);\n+        return true;\n+    }\n+\n+    /**\n+     * Stop Service.\n+     * @return successful\n+     */\n+    public boolean stopService() {\n+        setDesiredState(State.Finished);\n+        return true;\n+    }\n+\n+    /**\n+     * Restart Service.\n+     * @return successful\n+     */\n+    public boolean restartService() {\n+        setDesiredState(State.Finished, State.Running);\n+        return true;\n+    }\n+\n+    /**\n+     * ReInstall Service.\n+     * @return successful\n+     */\n+    public boolean reInstallService() {\n+        setDesiredState(State.Finished, State.New, State.Running);\n+        return true;\n+    }\n+\n+    /**\n+     * Error out a service.\n+     */\n+    public void errorService() {\n+        setState(State.Errored);\n+    }\n+\n+    private void waitOnStateChangeEvent(State currentState) throws InterruptedException {\n+        synchronized (stateChangeEvent) {\n+            while (desiredStateList.isEmpty() && getState() == currentState) {\n+                stateChangeEvent.wait();\n+            }\n+        }\n+    }\n+\n+    private void startStateTransition() throws InterruptedException {\n+        periodicityInformation = Periodicity.of(this);\n+        while (true) {\n+            State desiredState = null;\n+            switch (this.getState()) {\n+                case Broken:\n+                    context.getLog().significant(getName(), \"Broken\");\n+                    return;\n+                case New:\n+                    desiredState = peekOrRemoveFirstDesiredState(State.New);\n+                    if (desiredState == null || desiredState == State.New) {\n+                        waitOnStateChangeEvent(State.New);\n+                        continue;\n+                    }\n+                    try {\n+                        install();\n+                    } catch (Throwable t) {\n+                        errored(\"Error in install\", t);\n+                    }\n+                    if (getState() != State.Errored) {\n+                        setState(State.Installed);\n+                    }\n+                    continue;\n+                case Installed:\n+                    desiredState = peekOrRemoveFirstDesiredState(State.Installed);\n+                    if (desiredState == null || desiredState == State.Installed) {\n+                        waitOnStateChangeEvent(State.Installed);\n+                        continue;\n+                    }\n+\n+                    switch (desiredState) {\n+                        case Finished:\n+                            setBackingTask(null, null);\n+                            setState(State.Finished);\n+                            break;\n+                        case Running:\n+                            //TODO: use backing task\n                             setBackingTask(() -> {\n                                 try {\n-                                    install();\n-                                    if (!errored()) {\n-                                        setState(State.AwaitingStartup);\n-                                    }\n-                                } catch (Throwable t) {\n-                                    errored(\"Failed installing\", t);\n+                                    waitForDependencyReady();\n+                                    context.getLog().error(getName(), \"starting\");\n+                                    startup();// TODO: rename to  initiateStartup. Service need to report state to Running.\n+                                    setBackingTask(null, null);\n+                                } catch (InterruptedException e) {\n+                                    return;\n                                 }\n-                                backingTask = null;\n-                            }, getName() + \" => \" + newState);\n-                        }\n-                    }).start();\n+                            }, \"start\");\n \n-                    break;\n-                case AwaitingStartup:\n-                    awaitingStartup();\n-                    new Thread(() -> {\n-                        // wait until shutdown finished.\n-                        try {\n-                            shutdownLatch.await();\n-                        } catch (InterruptedException e) {\n-                            errored(\"waiting for shutdown complete\", e);\n-                            return;\n-                        }\n-                        if (dependencies != null) {\n-                            try {\n-                                waitForDependencyReady();\n-                            } catch (InterruptedException e) {\n-                                errored(\"waiting for dependency ready\", e);\n+                            synchronized (stateChangeEvent) {\n+                                if (getState() == State.Installed) {\n+                                    stateChangeEvent.wait();\n+                                }\n                             }\n-                        }\n-                        // if no other state change happened in between\n-                        if (!errored() && getState() == State.AwaitingStartup) {\n-                            setState(State.Starting);\n-                        }\n-                    }).start();\n \n-                    break;\n-                case Starting:\n-                    setBackingTask(() -> {\n-                        try {\n-                            periodicityInformation = Periodicity.of(this);\n-                            startup();\n-                            if (!errored()) {\n-                                setState(isPeriodic()  // Let timer do the transition to Running==null\n-                                        ? State.Finished : State.Running);\n-                            }\n-                        } catch (Throwable t) {\n-                            errored(\"Failed starting up\", t);\n-                        }\n-                        backingTask = null;\n-                    }, getName() + \" => \" + newState);\n-                    break;\n+                            break;\n+                        default:\n+                            context.getLog().error(\"Unexpected desired state\", desiredState);\n+                            // not allowed for New, Stopping, Errored, Broken\n+                            break;\n+                    }\n+                    continue;\n                 case Running:\n-                    if (!activeState.isRunning()) {\n-                        setBackingTask(() -> {\n-                            try {\n-                                run();\n-                                // subclasses implementing run() should handle state transition;\n-                            } catch (Throwable t) {\n-                                errored(\"Failed starting up\", t);\n-                            }\n-                            backingTask = null;\n-                        }, getName() + \" => \" + newState);\n+                    desiredState = peekOrRemoveFirstDesiredState(State.Running);\n+                    if (desiredState == null || desiredState == State.Running) {\n+                        waitOnStateChangeEvent(State.Running);\n+                        continue;\n                     }\n-                    break;\n+                    setState(State.Stopping);\n+                    continue;\n+                case Stopping:\n+                    // doesn't handle desiredState in Stopping.\n+                    shutdown();\n+                    if (this.getState() != State.Errored) {\n+                        setState(State.Finished);\n+                    }\n+                    continue;\n+                case Finished:\n+                    desiredState = peekOrRemoveFirstDesiredState(State.Finished);\n+                    if (desiredState == null || desiredState == State.Finished) {\n+                        waitOnStateChangeEvent(State.Finished);\n+                        continue;\n+                    }\n+                    context.getLog().note(getName(), getState(), \"desiredState\", desiredState);\n+                    switch (desiredState) {\n+                        case New:\n+                        case Installed:\n+                            setState(State.New);\n+                            break;\n+                        case Running:\n+                            setState(State.Installed);\n+                            break;\n+                        default:\n+                            context.getLog().error(\"Unexpected desired state\", desiredState);\n+                            // not allowed to set desired state to Stopping, Errored, Broken\n+                    }\n+\n+                    continue;\n                 case Errored:\n-                    if (activeState != State.Errored) {\n-                        // already in the process of error handling\n-                        try {\n-                            handleError();\n-                        } catch (Throwable t) {\n-                            // TODO: handle the case where error happens in error recovery.\n-                            errored(\"Error handler failed\", t);\n-                        }\n+                    handleError();", "originalCommit": "7ee25d34a650229a91879e35befec8209bedcc8d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU1NzYxOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381557619", "bodyText": "Right", "author": "ShirleyZheng92", "createdAt": "2020-02-19T21:34:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA5MjQ3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA5MjY4NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381092684", "bodyText": "Should be made private and then expose only a couple options for the implementing service such as reportRunning(), reportError() and whatever else you think we need.", "author": "MikeDombo", "createdAt": "2020-02-19T06:05:53Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -70,11 +82,32 @@ static void setState(Object o, State state) {\n         }\n     }\n \n+    /**\n+     * Set the state of the service. Should only be called by service or through IPC.\n+     * @param newState\n+     */\n+    public void setState(State newState) {", "originalCommit": "7ee25d34a650229a91879e35befec8209bedcc8d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTYwMjY0NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381602644", "bodyText": "Agree.", "author": "leaf94", "createdAt": "2020-02-19T23:15:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA5MjY4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA5Mjg0Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381092847", "bodyText": "This won't help checkstyle since you need to provide a comment for the parameter.", "author": "MikeDombo", "createdAt": "2020-02-19T06:06:37Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -512,13 +589,20 @@ private boolean dependencyReady(EvergreenService v) {\n     }\n \n     private void waitForDependencyReady() throws InterruptedException {\n+        if (dependencyReady()) {\n+            return;\n+        }\n+        context.getLog().error(getName(), \"waiting for dependency ready\");\n         synchronized (dependencyReadyLock) {\n             while (!dependencyReady()) {\n                 dependencyReadyLock.wait();\n             }\n         }\n     }\n \n+    /**\n+     * @param f", "originalCommit": "7ee25d34a650229a91879e35befec8209bedcc8d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA5MzA0MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381093040", "bodyText": "This seems like it should be replaced with our log, not sure why it is using stderr.", "author": "MikeDombo", "createdAt": "2020-02-19T06:07:13Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -552,7 +636,8 @@ public void postInject() {\n         } else if (d == null) {\n             return;\n         } else {\n-            String errMsg = String.format(\"Unrecognized dependency configuration for service %s, config content: %s\", getName(), d.toString());\n+            String errMsg = String.format(\"Unrecognized dependency configuration for service %s, config content: %s\",\n+                    getName(), d.toString());\n             System.err.println(errMsg);", "originalCommit": "7ee25d34a650229a91879e35befec8209bedcc8d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA5MzIyOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381093229", "bodyText": "Can you add a comment for what is going on here and why?", "author": "MikeDombo", "createdAt": "2020-02-19T06:08:02Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/GenericExternalService.java", "diffHunk": "@@ -39,7 +39,11 @@ public GenericExternalService(Topics c) {\n         c.subscribe((what, child) -> {\n             if (c.parentNeedsToKnow() && !child.childOf(\"shutdown\")) {", "originalCommit": "7ee25d34a650229a91879e35befec8209bedcc8d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU1MTE2NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381551164", "bodyText": "This is EGService responding to config file change, when config merge happens", "author": "ShirleyZheng92", "createdAt": "2020-02-19T21:20:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA5MzIyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA5MzYwMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381093600", "bodyText": "Why is the service checking its own state during the running of startup? Nothing should be changing it except for the service itself. Or more importantly, what does it mean if he state isn't installed and how should it be handled?", "author": "MikeDombo", "createdAt": "2020-02-19T06:09:45Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/GenericExternalService.java", "diffHunk": "@@ -67,10 +71,37 @@ public void awaitingStartup() {\n \n     @Override\n     public void startup() {\n-        if (run(\"startup\", null) == RunStatus.Errored) {\n+        RunStatus result = run(\"startup\", exit -> {\n+            if (getState() == State.Installed) {", "originalCommit": "7ee25d34a650229a91879e35befec8209bedcc8d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU1MDk4Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381550983", "bodyText": "this is the callback when startup script exit. It's possible that service is not in this state when script exits", "author": "ShirleyZheng92", "createdAt": "2020-02-19T21:20:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA5MzYwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA5NDE4MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381094181", "bodyText": "No call to super? This is confusing that some implementations call the super, but others don't.", "author": "MikeDombo", "createdAt": "2020-02-19T06:12:18Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/UpdateSystemSafelyService.java", "diffHunk": "@@ -116,7 +117,7 @@ public void run() {\n                 log.note(getName(), \"Back on run Q safe-time update\");\n             }\n         }\n-        super.run();\n+        this.stopService();", "originalCommit": "7ee25d34a650229a91879e35befec8209bedcc8d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU1MTM0OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381551348", "bodyText": "super doesn't have run() function anymore", "author": "ShirleyZheng92", "createdAt": "2020-02-19T21:21:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA5NDE4MQ=="}], "type": "inlineReview"}, {"oid": "11dc2d4f8e06c9d5366c50a2541d82b742d84ed6", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/11dc2d4f8e06c9d5366c50a2541d82b742d84ed6", "message": "State machine refactor\n\nRefactor the state machine:\n1. Not use published() in EvergreenService. Use state transition thread\ninstead.\n2. Use desiredStateList for external entities to start/stop evergreen\nservice. Every start/stop/restart request will override the\ndesiredStateList.\n3. Remove run() method in EvergreenService. startup() should report\nRunning instead.", "committedDate": "2020-02-19T23:10:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTYwMDYyNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381600625", "bodyText": "I think we can remove all Service from the requestXxx as we are in the EvergreenService class", "author": "leaf94", "createdAt": "2020-02-19T23:09:56Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/UpdateSystemSafelyService.java", "diffHunk": "@@ -116,7 +117,7 @@ public void run() {\n                 log.note(getName(), \"Back on run Q safe-time update\");\n             }\n         }\n-        super.run();\n+        this.requestStopService();", "originalCommit": "d2cc50fcde78ba82eef97a63f97c79355fc81aa6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "11dc2d4f8e06c9d5366c50a2541d82b742d84ed6", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/11dc2d4f8e06c9d5366c50a2541d82b742d84ed6", "message": "State machine refactor\n\nRefactor the state machine:\n1. Not use published() in EvergreenService. Use state transition thread\ninstead.\n2. Use desiredStateList for external entities to start/stop evergreen\nservice. Every start/stop/restart request will override the\ndesiredStateList.\n3. Remove run() method in EvergreenService. startup() should report\nRunning instead.", "committedDate": "2020-02-19T23:10:37Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTYwMjgxOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381602819", "bodyText": "move to the top?", "author": "leaf94", "createdAt": "2020-02-19T23:16:16Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -198,144 +223,229 @@ public Topic getStateTopic() {\n         return state;\n     }\n \n-    public boolean isRunningInternally() {\n-        Future b = backingTask;\n-        return b != null && !b.isDone();\n-    }\n-\n     public boolean isPeriodic() {\n         return periodicityInformation != null;\n     }\n \n-    @Override // for listening to state changes\n-    public void published(final WhatHappened what, final Topic topic) {\n-        final State newState = (State) topic.getOnce();\n-        if (activeState == newState) {\n-            return;\n+    private final List<State> desiredStateList = new ArrayList<>(3);\n+\n+    //Used to notify when state has changed Or a desiredState is set.\n+    private final Object stateChangeEvent = new Object();", "originalCommit": "d2cc50fcde78ba82eef97a63f97c79355fc81aa6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTYxMjIwOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381612209", "bodyText": "I guess it is not at error level", "author": "leaf94", "createdAt": "2020-02-19T23:44:28Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -512,6 +598,10 @@ private boolean dependencyReady(EvergreenService v) {\n     }\n \n     private void waitForDependencyReady() throws InterruptedException {\n+        if (dependencyReady()) {\n+            return;\n+        }\n+        context.getLog().error(getName(), \"waiting for dependency ready\");", "originalCommit": "11dc2d4f8e06c9d5366c50a2541d82b742d84ed6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c3b970ebaa816c2c336f2c8ee7784bc091571a7b", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/c3b970ebaa816c2c336f2c8ee7784bc091571a7b", "message": "Add reportState", "committedDate": "2020-02-20T01:38:16Z", "type": "commit"}, {"oid": "c3b970ebaa816c2c336f2c8ee7784bc091571a7b", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/c3b970ebaa816c2c336f2c8ee7784bc091571a7b", "message": "Add reportState", "committedDate": "2020-02-20T01:38:16Z", "type": "forcePushed"}, {"oid": "0ca1a7ec0a7cc472681bb95524ca6572bb58dd3c", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/0ca1a7ec0a7cc472681bb95524ca6572bb58dd3c", "message": "Use blocking queue to ensure state transition events are processed in order.", "committedDate": "2020-02-20T05:59:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc4ODE1Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381788153", "bodyText": "As discussed today at the whiteboard, will you change this so that it never sets the state directly? Instead it should use some signaling mechanism which the state machine can use to set the appropriate state. That way, only the state machine thread ever calls setState.", "author": "MikeDombo", "createdAt": "2020-02-20T06:06:25Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -51,30 +50,75 @@\n     private Throwable error;\n     private Future backingTask;\n     private Periodicity periodicityInformation;\n-    private State activeState = State.New;\n+    private State prevState = State.New;\n     private String status;\n \n+    private final List<State> desiredStateList = new ArrayList<>(3);\n+\n+    //Used to notify when state has changed Or a desiredState is set.\n+    private final Object stateChangeEvent = new Object();\n+\n     @SuppressWarnings(\"LeakingThisInConstructor\")\n     public EvergreenService(Topics topics) {\n         this.config = topics;\n         this.state = initStateTopic(topics);\n     }\n \n-    public static State getState(EvergreenService evergreenService) {\n-        return evergreenService.getState();\n+    /**\n+     * Start the Lifecycle in a separate thread.\n+     */\n+    public void startLifecycle() {\n+        new Thread(() -> {\n+            try {\n+                startStateTransition();\n+            } catch (Throwable e) {\n+                context.getLog().error(\"Error in state transition\", e);\n+                System.err.println(\"Error in state transition\");\n+                e.printStackTrace(System.err);\n+                context.getLog().note(\"restarting service\", getName());\n+                startLifecycle();\n+            }\n+        }).start();\n+    }\n+\n+    public State getState() {\n+        return (State) state.getOnce();\n+    }\n+\n+    /**\n+     * Set the state of the service. Should only be called by service or through IPC.\n+     * @param newState\n+     */\n+    private void setState(State newState) {\n+        final State currentState = getState();\n+\n+        // TODO: Add validation\n+        if (!newState.equals(currentState)) {\n+            context.getLog().note(getName(), currentState, \"=>\", newState);\n+            prevState = currentState;\n+            // Make sure the order of setValue() invocation is same as order of global state notification\n+            synchronized (this.state) {\n+                this.state.setValue(newState);\n+                context.globalNotifyStateChanged(this, currentState);\n+                synchronized (this.stateChangeEvent) {\n+                    stateChangeEvent.notifyAll();\n+                }\n+            }\n+        }\n     }\n \n-    static void setState(Object o, State state) {\n-        if (o instanceof EvergreenService) {\n-            ((EvergreenService) o).setState(state);\n+    public void reportState(State newState) {\n+        if (newState.equals(State.Installed) || newState.equals(State.Broken) || newState.equals(State.Finished)) {\n+            throw new IllegalArgumentException(\"Invalid state: \" + newState);\n         }\n+        setState(newState);", "originalCommit": "c3b970ebaa816c2c336f2c8ee7784bc091571a7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTgyNTQ2NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381825465", "bodyText": "I tried never set state directly and found it's kind of hard, especially not able to verify state transition when invoking reportState(). In this commit (0ca1a7e) I use a queue for setState() event, in a separate branch (https://github.com/aws/aws-greengrass-kernel/tree/reportStateQueue) I have the queue for reportState() events. We can compare the diff", "author": "ShirleyZheng92", "createdAt": "2020-02-20T07:34:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc4ODE1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc5Njk3MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381796970", "bodyText": "Since you're only using this as a lock right now as far as I can tell, ie you don't do anything with the stored data, maybe it should be a ReentrantLock and you create a Condition from the lock and notify waiters.\nActually you are doing a bit more I guess, so this may be appropriate.", "author": "MikeDombo", "createdAt": "2020-02-20T06:23:54Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -51,30 +52,83 @@\n     private Throwable error;\n     private Future backingTask;\n     private Periodicity periodicityInformation;\n-    private State activeState = State.New;\n+    private State prevState = State.New;\n     private String status;\n \n+    // A state event can be a state transition event, or a desired state updated notification.\n+    private final BlockingQueue<Object> stateEventQueue = new ArrayBlockingQueue<>(1);", "originalCommit": "0ca1a7ec0a7cc472681bb95524ca6572bb58dd3c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc5NzcyNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381797725", "bodyText": "[nit]\nImport as just SuppressFBWarnings, no need to have the whole path.", "author": "MikeDombo", "createdAt": "2020-02-20T06:25:29Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -164,178 +218,258 @@ public static EvergreenService errNode(Context context, String name, String mess\n     private Topic initStateTopic(final Topics topics) {\n         Topic state = topics.createLeafChild(STATE_TOPIC_NAME);\n         state.setParentNeedsToKnow(false);\n-        state.setValue(Long.MAX_VALUE, State.New);\n+        state.setValue(State.New);\n         state.validate((newStateObj, oldStateObj) -> {\n             State newState = Coerce.toEnum(State.class, newStateObj);\n             return newState == null ? oldStateObj : newStateObj;\n         });\n-        state.subscribe(this);\n+\n         return state;\n     }\n \n-    public State getState() {\n-        return (State) state.getOnce();\n+    public boolean inState(State s) {\n+        return s == state.getOnce();\n     }\n \n-    public void setState(State newState) {\n-        final State currentState = (State) this.state.getOnce();\n+    public Topic getStateTopic() {\n+        return state;\n+    }\n \n-        if (newState != currentState) {\n-            context.getLog().note(getName(), currentState, \"=>\", newState);\n-            // Make sure the order of setValue() invocation is same as order of global state notification\n-            synchronized (this.state) {\n-                this.state.setValue(Long.MAX_VALUE, newState);\n-                context.globalNotifyStateChanged(this, currentState);\n+    public boolean isPeriodic() {\n+        return periodicityInformation != null;\n+    }\n+\n+    private State peekOrRemoveFirstDesiredState(State activeState) {\n+        synchronized (desiredStateList) {\n+            if (desiredStateList.isEmpty()) {\n+                return null;\n+            }\n+            State first = desiredStateList.get(0);\n+            if (first == activeState) {\n+                return desiredStateList.remove(0);\n+            } else {\n+                return first;\n             }\n         }\n     }\n \n-    public boolean inState(State s) {\n-        return s == state.getOnce();\n+    private void setDesiredState(State... state) {\n+        synchronized (desiredStateList) {\n+            List<State> newStateList = Arrays.asList(state);\n+            if (newStateList.equals(desiredStateList)) {\n+                return;\n+            }\n+            desiredStateList.clear();\n+            desiredStateList.addAll(newStateList);\n+            // try insert to the queue, if queue full doesn't block.\n+            enqueueStateEvent(\"DesiredStateUpdated\");\n+        }\n     }\n \n-    public Topic getStateTopic() {\n-        return state;\n+    // Enqueue a state event.\n+    // If the event is state transition, the enqueue is blocking on existing state transition event to be processed.\n+    // If the event is desired state changed notification, the enqueue is not blocking.\n+    @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(", "originalCommit": "0ca1a7ec0a7cc472681bb95524ca6572bb58dd3c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4MDY1MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382280651", "bodyText": "I like this idea. But I think we should have a better way than using an arbitrary  Object event and sometimes it is a State and sometimes it is a String, or anything.", "author": "leaf94", "createdAt": "2020-02-20T21:57:42Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -164,178 +218,258 @@ public static EvergreenService errNode(Context context, String name, String mess\n     private Topic initStateTopic(final Topics topics) {\n         Topic state = topics.createLeafChild(STATE_TOPIC_NAME);\n         state.setParentNeedsToKnow(false);\n-        state.setValue(Long.MAX_VALUE, State.New);\n+        state.setValue(State.New);\n         state.validate((newStateObj, oldStateObj) -> {\n             State newState = Coerce.toEnum(State.class, newStateObj);\n             return newState == null ? oldStateObj : newStateObj;\n         });\n-        state.subscribe(this);\n+\n         return state;\n     }\n \n-    public State getState() {\n-        return (State) state.getOnce();\n+    public boolean inState(State s) {\n+        return s == state.getOnce();\n     }\n \n-    public void setState(State newState) {\n-        final State currentState = (State) this.state.getOnce();\n+    public Topic getStateTopic() {\n+        return state;\n+    }\n \n-        if (newState != currentState) {\n-            context.getLog().note(getName(), currentState, \"=>\", newState);\n-            // Make sure the order of setValue() invocation is same as order of global state notification\n-            synchronized (this.state) {\n-                this.state.setValue(Long.MAX_VALUE, newState);\n-                context.globalNotifyStateChanged(this, currentState);\n+    public boolean isPeriodic() {\n+        return periodicityInformation != null;\n+    }\n+\n+    private State peekOrRemoveFirstDesiredState(State activeState) {\n+        synchronized (desiredStateList) {\n+            if (desiredStateList.isEmpty()) {\n+                return null;\n+            }\n+            State first = desiredStateList.get(0);\n+            if (first == activeState) {\n+                return desiredStateList.remove(0);\n+            } else {\n+                return first;\n             }\n         }\n     }\n \n-    public boolean inState(State s) {\n-        return s == state.getOnce();\n+    private void setDesiredState(State... state) {\n+        synchronized (desiredStateList) {\n+            List<State> newStateList = Arrays.asList(state);\n+            if (newStateList.equals(desiredStateList)) {\n+                return;\n+            }\n+            desiredStateList.clear();\n+            desiredStateList.addAll(newStateList);\n+            // try insert to the queue, if queue full doesn't block.\n+            enqueueStateEvent(\"DesiredStateUpdated\");\n+        }\n     }\n \n-    public Topic getStateTopic() {\n-        return state;\n+    // Enqueue a state event.\n+    // If the event is state transition, the enqueue is blocking on existing state transition event to be processed.\n+    // If the event is desired state changed notification, the enqueue is not blocking.\n+    @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(\n+            value = \"RV_RETURN_VALUE_IGNORED_BAD_PRACTICE\")\n+    private synchronized void enqueueStateEvent(Object event) {\n+        if (event instanceof State) {\n+            if (!(stateEventQueue.peek() instanceof State)) {\n+                stateEventQueue.clear();\n+            }\n+            try {\n+                stateEventQueue.put(event);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+        } else {\n+            // Ignore returned value of offer().\n+            // If enqueue isn't successful, the event queue has contents and there is no need to send another\n+            // trigger to process state transition.", "originalCommit": "0ca1a7ec0a7cc472681bb95524ca6572bb58dd3c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI5OTM3Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382299377", "bodyText": "Added TODO", "author": "ShirleyZheng92", "createdAt": "2020-02-20T22:41:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4MDY1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMwNDkxNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382304914", "bodyText": "Thanks! Let's also make sure we have a plan for TODO!", "author": "leaf94", "createdAt": "2020-02-20T22:55:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4MDY1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4Njk0OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382286948", "bodyText": "The comment could be more helpful here. I guess what we are trying to do is: Conditionally update the active state. The state will only get updated if the active state is condition state, and the newState is different from active state.\nHowever, is it correct to say that we don't really need this method to ensure we are actually in the state we thought, if only one thread is updating state?\nAlso this could be a synchronized method?", "author": "leaf94", "createdAt": "2020-02-20T22:11:50Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -51,30 +52,83 @@\n     private Throwable error;\n     private Future backingTask;\n     private Periodicity periodicityInformation;\n-    private State activeState = State.New;\n+    private State prevState = State.New;\n     private String status;\n \n+    // A state event can be a state transition event, or a desired state updated notification.\n+    private final BlockingQueue<Object> stateEventQueue = new ArrayBlockingQueue<>(1);\n+\n+    private final List<State> desiredStateList = new ArrayList<>(3);\n+\n     @SuppressWarnings(\"LeakingThisInConstructor\")\n     public EvergreenService(Topics topics) {\n         this.config = topics;\n         this.state = initStateTopic(topics);\n     }\n \n-    public static State getState(EvergreenService evergreenService) {\n-        return evergreenService.getState();\n+    /**\n+     * Start the Lifecycle in a separate thread.\n+     */\n+    public void startLifecycle() {\n+        new Thread(() -> {\n+            try {\n+                startStateTransition();\n+            } catch (Throwable e) {\n+                context.getLog().error(\"Error in state transition\", e);\n+                System.err.println(\"Error in state transition\");\n+                e.printStackTrace(System.err);\n+                context.getLog().note(\"restarting service\", getName());\n+                startLifecycle();\n+            }\n+        }).start();\n+    }\n+\n+    public State getState() {\n+        return (State) state.getOnce();\n+    }\n+\n+    /**\n+     * Set the state of the service. Should only be called by service or through IPC.\n+     * @param newState\n+     */", "originalCommit": "0ca1a7ec0a7cc472681bb95524ca6572bb58dd3c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMwNjQ2OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382306468", "bodyText": "Removed in next commit", "author": "ShirleyZheng92", "createdAt": "2020-02-20T22:59:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4Njk0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI5MzYyMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382293623", "bodyText": "This would eventually call the blockingQueue.put() and it means the caller thread (ex. IPCLifeCycleAgent) will hang there. Is that what we expected?\nOne loop hole I see is that at least IPCLifeCycleAgent should not be waiting to report \"Running\" for one service service.", "author": "leaf94", "createdAt": "2020-02-20T22:27:26Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -51,30 +52,83 @@\n     private Throwable error;\n     private Future backingTask;\n     private Periodicity periodicityInformation;\n-    private State activeState = State.New;\n+    private State prevState = State.New;\n     private String status;\n \n+    // A state event can be a state transition event, or a desired state updated notification.\n+    private final BlockingQueue<Object> stateEventQueue = new ArrayBlockingQueue<>(1);\n+\n+    private final List<State> desiredStateList = new ArrayList<>(3);\n+\n     @SuppressWarnings(\"LeakingThisInConstructor\")\n     public EvergreenService(Topics topics) {\n         this.config = topics;\n         this.state = initStateTopic(topics);\n     }\n \n-    public static State getState(EvergreenService evergreenService) {\n-        return evergreenService.getState();\n+    /**\n+     * Start the Lifecycle in a separate thread.\n+     */\n+    public void startLifecycle() {\n+        new Thread(() -> {\n+            try {\n+                startStateTransition();\n+            } catch (Throwable e) {\n+                context.getLog().error(\"Error in state transition\", e);\n+                System.err.println(\"Error in state transition\");\n+                e.printStackTrace(System.err);\n+                context.getLog().note(\"restarting service\", getName());\n+                startLifecycle();\n+            }\n+        }).start();\n+    }\n+\n+    public State getState() {\n+        return (State) state.getOnce();\n+    }\n+\n+    /**\n+     * Set the state of the service. Should only be called by service or through IPC.\n+     * @param newState\n+     */\n+    private void conditionalSetState(State condition, State newState) {\n+        synchronized (this.state) {\n+            final State currentState = getState();\n+            if (condition != null && !currentState.equals(condition)) {\n+                return;\n+            }\n+            if (newState.equals(currentState)) {\n+                return;\n+            }\n+\n+            // TODO: Add validation\n+            context.getLog().note(getName(), currentState, \"=>\", newState);\n+            prevState = currentState;\n+            this.state.setValue(newState);\n+            context.globalNotifyStateChanged(this, currentState);\n+\n+            // push to queue\n+            enqueueStateEvent(newState);\n+        }\n+    }\n+\n+    private void setState(State newState) {\n+        conditionalSetState(null, newState);\n     }\n \n-    static void setState(Object o, State state) {\n-        if (o instanceof EvergreenService) {\n-            ((EvergreenService) o).setState(state);\n+    public void reportState(State newState) {\n+        if (newState.equals(State.Installed) || newState.equals(State.Broken) || newState.equals(State.Finished)) {\n+            throw new IllegalArgumentException(\"Invalid state: \" + newState);\n         }\n+        // TODO: add more validation. Eg. Not allow to reportState when current state is Errored or Finished.\n+        setState(newState);", "originalCommit": "0ca1a7ec0a7cc472681bb95524ca6572bb58dd3c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "04b19a0888a86938d4f15acb8d8ac907bac87089", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/04b19a0888a86938d4f15acb8d8ac907bac87089", "message": "Modify stateEventQueue to handle reportState() events. Test not fixed yet.\n\nCompare to previous commit, this one use stateEventQueue to handle\nreportState() events instead of setState() events.\n\nPro is all setState() is called in the same thread.\nCon is state transition validation can only do best-effort.\n\nTest not fixed yet.", "committedDate": "2020-02-20T22:55:38Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMwODU5MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382308590", "bodyText": "Why introducing this change?", "author": "leaf94", "createdAt": "2020-02-20T23:05:14Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -334,12 +329,9 @@ void errorService() {\n \n     private void startStateTransition() throws InterruptedException {\n         periodicityInformation = Periodicity.of(this);\n-        while (true) {\n+        while (!closed) {", "originalCommit": "04b19a0888a86938d4f15acb8d8ac907bac87089", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM0Njk4Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382346982", "bodyText": "This is a dummy way to stop the lifcycle thread once close() is called. I noticed in integ test that after test finished StdError is still outputting 'not able to submit Executor job'", "author": "ShirleyZheng92", "createdAt": "2020-02-21T01:08:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMwODU5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMwOTAxMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382309010", "bodyText": "As Michael mentioned before, swtich case should always have break, instead of continue", "author": "leaf94", "createdAt": "2020-02-20T23:06:33Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -398,35 +410,53 @@ private void startStateTransition() throws InterruptedException {\n                     break;\n                 case Running:\n                     if (desiredState == null) {\n-                        continue;\n+                        break;\n                     }\n \n-                    conditionalSetState(State.Running, State.Stopping);\n-                    break;\n+                    setState(State.Stopping);\n+                    continue;\n                 case Stopping:\n                     // doesn't handle desiredState in Stopping.\n-                    try {\n-                        shutdown();\n-                    } catch (Throwable t) {\n-                        errored(\"Shutting down\", t);\n+                    // Not use setBackingTask because it will cancel the existing task.\n+                    CountDownLatch stopping = new CountDownLatch(1);\n+                    new Thread(() -> {\n+                        try {\n+                            shutdown();\n+                        } catch (Throwable t) {\n+                            getContext().getLog().error(getName(), \"Error in shutting down\", t);\n+                            reportState(State.Errored);\n+                        } finally {\n+                            stopping.countDown();\n+                        }\n+\n+                    }).start();\n+\n+                    boolean stopSucceed = stopping.await(30, TimeUnit.SECONDS);\n+                    if (getReportState() == State.Errored) {\n+                        setState(State.Errored);\n                         continue;\n                     }\n-                    conditionalSetState(State.Stopping, State.Finished);\n-                    break;\n+                    if (!stopSucceed) {\n+                        setState(State.Errored);\n+                    } else {\n+                        setState(State.Finished);\n+                    }\n+                    continue;\n+\n                 case Finished:\n                     if (desiredState == null) {\n-                        continue;\n+                        break;\n                     }\n \n                     context.getLog().note(getName(), getState(), \"desiredState\", desiredState);\n                     switch (desiredState) {\n                         case New:\n                         case Installed:\n                             setState(State.New);\n-                            break;\n+                            continue;", "originalCommit": "04b19a0888a86938d4f15acb8d8ac907bac87089", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyODc1Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382328757", "bodyText": "Discussed offline. Every setState() should go to 'continue;' for next state transition handling. Still haven't figure out a better way to do this.", "author": "ShirleyZheng92", "createdAt": "2020-02-21T00:04:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMwOTAxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMxNzEzNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382317137", "bodyText": "Should this be using setState and not report?", "author": "MikeDombo", "createdAt": "2020-02-20T23:30:22Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -164,178 +218,297 @@ public static EvergreenService errNode(Context context, String name, String mess\n     private Topic initStateTopic(final Topics topics) {\n         Topic state = topics.createLeafChild(STATE_TOPIC_NAME);\n         state.setParentNeedsToKnow(false);\n-        state.setValue(Long.MAX_VALUE, State.New);\n+        state.setValue(State.New);\n         state.validate((newStateObj, oldStateObj) -> {\n             State newState = Coerce.toEnum(State.class, newStateObj);\n             return newState == null ? oldStateObj : newStateObj;\n         });\n-        state.subscribe(this);\n+\n         return state;\n     }\n \n-    public State getState() {\n-        return (State) state.getOnce();\n+    public boolean inState(State s) {\n+        return s == state.getOnce();\n+    }\n+\n+    public Topic getStateTopic() {\n+        return state;\n     }\n \n-    public void setState(State newState) {\n-        final State currentState = (State) this.state.getOnce();\n+    public boolean isPeriodic() {\n+        return periodicityInformation != null;\n+    }\n \n-        if (newState != currentState) {\n-            context.getLog().note(getName(), currentState, \"=>\", newState);\n-            // Make sure the order of setValue() invocation is same as order of global state notification\n-            synchronized (this.state) {\n-                this.state.setValue(Long.MAX_VALUE, newState);\n-                context.globalNotifyStateChanged(this, currentState);\n+    private State peekOrRemoveFirstDesiredState(State activeState) {\n+        synchronized (desiredStateList) {\n+            if (desiredStateList.isEmpty()) {\n+                return null;\n+            }\n+            State first = desiredStateList.get(0);\n+            if (first == activeState) {\n+                return desiredStateList.remove(0);\n+            } else {\n+                return first;\n             }\n         }\n     }\n \n-    public boolean inState(State s) {\n-        return s == state.getOnce();\n+    private void setDesiredState(State... state) {\n+        synchronized (desiredStateList) {\n+            List<State> newStateList = Arrays.asList(state);\n+            if (newStateList.equals(desiredStateList)) {\n+                return;\n+            }\n+            desiredStateList.clear();\n+            desiredStateList.addAll(newStateList);\n+            // try insert to the queue, if queue full doesn't block.\n+            enqueueStateEvent(\"DesiredStateUpdated\");\n+        }\n     }\n \n-    public Topic getStateTopic() {\n-        return state;\n+    // Enqueue a state event.\n+    @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(\n+            value = \"RV_RETURN_VALUE_IGNORED_BAD_PRACTICE\")\n+    private synchronized boolean enqueueStateEvent(Object event) {\n+        if (event instanceof State) {\n+            // override existing reportState\n+            stateEventQueue.clear();\n+            return stateEventQueue.offer(event);\n+        } else {\n+            stateEventQueue.offer(event);\n+\n+            // Ignore returned value of offer().\n+            // If enqueue isn't successful, the event queue has contents and there is no need to send another\n+            // trigger to process state transition.\n+            return true;\n+        }\n     }\n \n-    public boolean isRunningInternally() {\n-        Future b = backingTask;\n-        return b != null && !b.isDone();\n+    /**\n+     * Start Service.\n+     * @return successful\n+     */\n+    public boolean requestStart() {\n+        setDesiredState(State.Running);\n+        return true;\n     }\n \n-    public boolean isPeriodic() {\n-        return periodicityInformation != null;\n+    /**\n+     * Stop Service.\n+     * @return successful\n+     */\n+    public boolean requestStop() {\n+        setDesiredState(State.Finished);\n+        return true;\n     }\n \n-    @Override // for listening to state changes\n-    public void published(final WhatHappened what, final Topic topic) {\n-        final State newState = (State) topic.getOnce();\n-        if (activeState == newState) {\n-            return;\n-        }\n-        if (activeState.isRunning() && !newState.isRunning()) { // transition from running to not running\n-            shutdownLatch = new CountDownLatch(1);\n-            // Assume that shutdown task won't be cancelled. Following states (installing/awaitingStartup) wait until\n-            // shutdown task complete.\n-            // May consider just merge shutdown() into other state's handling.\n-            State oldState = activeState;\n-            setBackingTask(() -> {\n-                try {\n-                    shutdown();\n-                } catch (Throwable t) {\n-                    if (oldState != State.Errored) {\n-                        errored(\"Failed shutting down\", t);\n-                    } else {\n-                        context.getLog().error(this, \"Failed shutting down\", t);\n-                    }\n-                } finally {\n-                    shutdownLatch.countDown();\n-                }\n-                backingTask = null;\n-            }, getName() + \"=>\" + newState);\n+    /**\n+     * Restart Service.\n+     * @return successful\n+     */\n+    public boolean requestRestart() {\n+        setDesiredState(State.Finished, State.Running);\n+        return true;\n+    }\n \n-            // Since shutdown() is modeled as part of state transition, I initially tried waiting on shutdownLatch()\n-            // here.\n-            // However, this caused the global configuration publish queue being blocked.\n-        }\n+    /**\n+     * ReInstall Service.\n+     * @return successful\n+     */\n+    public boolean requestReinstall() {\n+        setDesiredState(State.Finished, State.New, State.Running);\n+        return true;\n+    }\n \n-        try {\n-            switch (newState) {\n-                case Installing:\n-                    new Thread(() -> {\n-                        // wait until shutdown finished.\n-                        // not using setBackTask() here to avoid cancelling the ongoing shutdown task\n+    /**\n+     * Error out a service.\n+     */\n+    void errorService() {\n+        setState(State.Errored);\n+    }", "originalCommit": "04b19a0888a86938d4f15acb8d8ac907bac87089", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyNzk3Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382327976", "bodyText": "Will update", "author": "ShirleyZheng92", "createdAt": "2020-02-21T00:01:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMxNzEzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMxNzg0OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382317848", "bodyText": "Just do getReportState().equals(State.Errored) || !ok", "author": "MikeDombo", "createdAt": "2020-02-20T23:32:30Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -164,178 +218,297 @@ public static EvergreenService errNode(Context context, String name, String mess\n     private Topic initStateTopic(final Topics topics) {\n         Topic state = topics.createLeafChild(STATE_TOPIC_NAME);\n         state.setParentNeedsToKnow(false);\n-        state.setValue(Long.MAX_VALUE, State.New);\n+        state.setValue(State.New);\n         state.validate((newStateObj, oldStateObj) -> {\n             State newState = Coerce.toEnum(State.class, newStateObj);\n             return newState == null ? oldStateObj : newStateObj;\n         });\n-        state.subscribe(this);\n+\n         return state;\n     }\n \n-    public State getState() {\n-        return (State) state.getOnce();\n+    public boolean inState(State s) {\n+        return s == state.getOnce();\n+    }\n+\n+    public Topic getStateTopic() {\n+        return state;\n     }\n \n-    public void setState(State newState) {\n-        final State currentState = (State) this.state.getOnce();\n+    public boolean isPeriodic() {\n+        return periodicityInformation != null;\n+    }\n \n-        if (newState != currentState) {\n-            context.getLog().note(getName(), currentState, \"=>\", newState);\n-            // Make sure the order of setValue() invocation is same as order of global state notification\n-            synchronized (this.state) {\n-                this.state.setValue(Long.MAX_VALUE, newState);\n-                context.globalNotifyStateChanged(this, currentState);\n+    private State peekOrRemoveFirstDesiredState(State activeState) {\n+        synchronized (desiredStateList) {\n+            if (desiredStateList.isEmpty()) {\n+                return null;\n+            }\n+            State first = desiredStateList.get(0);\n+            if (first == activeState) {\n+                return desiredStateList.remove(0);\n+            } else {\n+                return first;\n             }\n         }\n     }\n \n-    public boolean inState(State s) {\n-        return s == state.getOnce();\n+    private void setDesiredState(State... state) {\n+        synchronized (desiredStateList) {\n+            List<State> newStateList = Arrays.asList(state);\n+            if (newStateList.equals(desiredStateList)) {\n+                return;\n+            }\n+            desiredStateList.clear();\n+            desiredStateList.addAll(newStateList);\n+            // try insert to the queue, if queue full doesn't block.\n+            enqueueStateEvent(\"DesiredStateUpdated\");\n+        }\n     }\n \n-    public Topic getStateTopic() {\n-        return state;\n+    // Enqueue a state event.\n+    @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(\n+            value = \"RV_RETURN_VALUE_IGNORED_BAD_PRACTICE\")\n+    private synchronized boolean enqueueStateEvent(Object event) {\n+        if (event instanceof State) {\n+            // override existing reportState\n+            stateEventQueue.clear();\n+            return stateEventQueue.offer(event);\n+        } else {\n+            stateEventQueue.offer(event);\n+\n+            // Ignore returned value of offer().\n+            // If enqueue isn't successful, the event queue has contents and there is no need to send another\n+            // trigger to process state transition.\n+            return true;\n+        }\n     }\n \n-    public boolean isRunningInternally() {\n-        Future b = backingTask;\n-        return b != null && !b.isDone();\n+    /**\n+     * Start Service.\n+     * @return successful\n+     */\n+    public boolean requestStart() {\n+        setDesiredState(State.Running);\n+        return true;\n     }\n \n-    public boolean isPeriodic() {\n-        return periodicityInformation != null;\n+    /**\n+     * Stop Service.\n+     * @return successful\n+     */\n+    public boolean requestStop() {\n+        setDesiredState(State.Finished);\n+        return true;\n     }\n \n-    @Override // for listening to state changes\n-    public void published(final WhatHappened what, final Topic topic) {\n-        final State newState = (State) topic.getOnce();\n-        if (activeState == newState) {\n-            return;\n-        }\n-        if (activeState.isRunning() && !newState.isRunning()) { // transition from running to not running\n-            shutdownLatch = new CountDownLatch(1);\n-            // Assume that shutdown task won't be cancelled. Following states (installing/awaitingStartup) wait until\n-            // shutdown task complete.\n-            // May consider just merge shutdown() into other state's handling.\n-            State oldState = activeState;\n-            setBackingTask(() -> {\n-                try {\n-                    shutdown();\n-                } catch (Throwable t) {\n-                    if (oldState != State.Errored) {\n-                        errored(\"Failed shutting down\", t);\n-                    } else {\n-                        context.getLog().error(this, \"Failed shutting down\", t);\n-                    }\n-                } finally {\n-                    shutdownLatch.countDown();\n-                }\n-                backingTask = null;\n-            }, getName() + \"=>\" + newState);\n+    /**\n+     * Restart Service.\n+     * @return successful\n+     */\n+    public boolean requestRestart() {\n+        setDesiredState(State.Finished, State.Running);\n+        return true;\n+    }\n \n-            // Since shutdown() is modeled as part of state transition, I initially tried waiting on shutdownLatch()\n-            // here.\n-            // However, this caused the global configuration publish queue being blocked.\n-        }\n+    /**\n+     * ReInstall Service.\n+     * @return successful\n+     */\n+    public boolean requestReinstall() {\n+        setDesiredState(State.Finished, State.New, State.Running);\n+        return true;\n+    }\n \n-        try {\n-            switch (newState) {\n-                case Installing:\n-                    new Thread(() -> {\n-                        // wait until shutdown finished.\n-                        // not using setBackTask() here to avoid cancelling the ongoing shutdown task\n+    /**\n+     * Error out a service.\n+     */\n+    void errorService() {\n+        setState(State.Errored);\n+    }\n+\n+    private void startStateTransition() throws InterruptedException {\n+        periodicityInformation = Periodicity.of(this);\n+        while (!closed) {\n+            State desiredState;\n+\n+            State current = getState();\n+            context.getLog().note(\"Processing state\", getName(), getState());\n+\n+            // if already in desired state, remove the head of desired state list.\n+            desiredState = peekOrRemoveFirstDesiredState(current);\n+            while (desiredState == current) {\n+                desiredState = peekOrRemoveFirstDesiredState(current);\n+            }\n+\n+            switch (current) {\n+                case Broken:\n+                    context.getLog().significant(getName(), \"Broken\");\n+                    return;\n+                case New:\n+                    // if no desired state is set, don't do anything.\n+                    if (desiredState == null) {\n+                        break;\n+                    }\n+                    CountDownLatch installLatch = new CountDownLatch(1);\n+                    setBackingTask(() -> {\n                         try {\n-                            shutdownLatch.await();\n-                        } catch (InterruptedException e) {\n-                            errored(\"waiting for shutdown complete\", e);\n-                            return;\n+                            install();\n+                        } catch (Throwable t) {\n+                            reportState(State.Errored);\n+                            getContext().getLog().error(getName(), \"Error in install\", t);\n+                        } finally {\n+                            installLatch.countDown();\n                         }\n-                        // TODO: wait until all install dependency ready.\n-                        if (!errored() && getState() == State.Installing) {\n+                    }, \"install\");\n+\n+                    // TODO: Configurable timeout logic.\n+                    boolean ok = installLatch.await(30, TimeUnit.SECONDS);\n+                    if (getReportState() == State.Errored) {", "originalCommit": "04b19a0888a86938d4f15acb8d8ac907bac87089", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMxODYyNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382318624", "bodyText": "Return isn't good here I think because then there's no trigger to unlock the loop again.", "author": "MikeDombo", "createdAt": "2020-02-20T23:35:03Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -164,178 +218,297 @@ public static EvergreenService errNode(Context context, String name, String mess\n     private Topic initStateTopic(final Topics topics) {\n         Topic state = topics.createLeafChild(STATE_TOPIC_NAME);\n         state.setParentNeedsToKnow(false);\n-        state.setValue(Long.MAX_VALUE, State.New);\n+        state.setValue(State.New);\n         state.validate((newStateObj, oldStateObj) -> {\n             State newState = Coerce.toEnum(State.class, newStateObj);\n             return newState == null ? oldStateObj : newStateObj;\n         });\n-        state.subscribe(this);\n+\n         return state;\n     }\n \n-    public State getState() {\n-        return (State) state.getOnce();\n+    public boolean inState(State s) {\n+        return s == state.getOnce();\n+    }\n+\n+    public Topic getStateTopic() {\n+        return state;\n     }\n \n-    public void setState(State newState) {\n-        final State currentState = (State) this.state.getOnce();\n+    public boolean isPeriodic() {\n+        return periodicityInformation != null;\n+    }\n \n-        if (newState != currentState) {\n-            context.getLog().note(getName(), currentState, \"=>\", newState);\n-            // Make sure the order of setValue() invocation is same as order of global state notification\n-            synchronized (this.state) {\n-                this.state.setValue(Long.MAX_VALUE, newState);\n-                context.globalNotifyStateChanged(this, currentState);\n+    private State peekOrRemoveFirstDesiredState(State activeState) {\n+        synchronized (desiredStateList) {\n+            if (desiredStateList.isEmpty()) {\n+                return null;\n+            }\n+            State first = desiredStateList.get(0);\n+            if (first == activeState) {\n+                return desiredStateList.remove(0);\n+            } else {\n+                return first;\n             }\n         }\n     }\n \n-    public boolean inState(State s) {\n-        return s == state.getOnce();\n+    private void setDesiredState(State... state) {\n+        synchronized (desiredStateList) {\n+            List<State> newStateList = Arrays.asList(state);\n+            if (newStateList.equals(desiredStateList)) {\n+                return;\n+            }\n+            desiredStateList.clear();\n+            desiredStateList.addAll(newStateList);\n+            // try insert to the queue, if queue full doesn't block.\n+            enqueueStateEvent(\"DesiredStateUpdated\");\n+        }\n     }\n \n-    public Topic getStateTopic() {\n-        return state;\n+    // Enqueue a state event.\n+    @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(\n+            value = \"RV_RETURN_VALUE_IGNORED_BAD_PRACTICE\")\n+    private synchronized boolean enqueueStateEvent(Object event) {\n+        if (event instanceof State) {\n+            // override existing reportState\n+            stateEventQueue.clear();\n+            return stateEventQueue.offer(event);\n+        } else {\n+            stateEventQueue.offer(event);\n+\n+            // Ignore returned value of offer().\n+            // If enqueue isn't successful, the event queue has contents and there is no need to send another\n+            // trigger to process state transition.\n+            return true;\n+        }\n     }\n \n-    public boolean isRunningInternally() {\n-        Future b = backingTask;\n-        return b != null && !b.isDone();\n+    /**\n+     * Start Service.\n+     * @return successful\n+     */\n+    public boolean requestStart() {\n+        setDesiredState(State.Running);\n+        return true;\n     }\n \n-    public boolean isPeriodic() {\n-        return periodicityInformation != null;\n+    /**\n+     * Stop Service.\n+     * @return successful\n+     */\n+    public boolean requestStop() {\n+        setDesiredState(State.Finished);\n+        return true;\n     }\n \n-    @Override // for listening to state changes\n-    public void published(final WhatHappened what, final Topic topic) {\n-        final State newState = (State) topic.getOnce();\n-        if (activeState == newState) {\n-            return;\n-        }\n-        if (activeState.isRunning() && !newState.isRunning()) { // transition from running to not running\n-            shutdownLatch = new CountDownLatch(1);\n-            // Assume that shutdown task won't be cancelled. Following states (installing/awaitingStartup) wait until\n-            // shutdown task complete.\n-            // May consider just merge shutdown() into other state's handling.\n-            State oldState = activeState;\n-            setBackingTask(() -> {\n-                try {\n-                    shutdown();\n-                } catch (Throwable t) {\n-                    if (oldState != State.Errored) {\n-                        errored(\"Failed shutting down\", t);\n-                    } else {\n-                        context.getLog().error(this, \"Failed shutting down\", t);\n-                    }\n-                } finally {\n-                    shutdownLatch.countDown();\n-                }\n-                backingTask = null;\n-            }, getName() + \"=>\" + newState);\n+    /**\n+     * Restart Service.\n+     * @return successful\n+     */\n+    public boolean requestRestart() {\n+        setDesiredState(State.Finished, State.Running);\n+        return true;\n+    }\n \n-            // Since shutdown() is modeled as part of state transition, I initially tried waiting on shutdownLatch()\n-            // here.\n-            // However, this caused the global configuration publish queue being blocked.\n-        }\n+    /**\n+     * ReInstall Service.\n+     * @return successful\n+     */\n+    public boolean requestReinstall() {\n+        setDesiredState(State.Finished, State.New, State.Running);\n+        return true;\n+    }\n \n-        try {\n-            switch (newState) {\n-                case Installing:\n-                    new Thread(() -> {\n-                        // wait until shutdown finished.\n-                        // not using setBackTask() here to avoid cancelling the ongoing shutdown task\n+    /**\n+     * Error out a service.\n+     */\n+    void errorService() {\n+        setState(State.Errored);\n+    }\n+\n+    private void startStateTransition() throws InterruptedException {\n+        periodicityInformation = Periodicity.of(this);\n+        while (!closed) {\n+            State desiredState;\n+\n+            State current = getState();\n+            context.getLog().note(\"Processing state\", getName(), getState());\n+\n+            // if already in desired state, remove the head of desired state list.\n+            desiredState = peekOrRemoveFirstDesiredState(current);\n+            while (desiredState == current) {\n+                desiredState = peekOrRemoveFirstDesiredState(current);\n+            }\n+\n+            switch (current) {\n+                case Broken:\n+                    context.getLog().significant(getName(), \"Broken\");\n+                    return;\n+                case New:\n+                    // if no desired state is set, don't do anything.\n+                    if (desiredState == null) {\n+                        break;\n+                    }\n+                    CountDownLatch installLatch = new CountDownLatch(1);\n+                    setBackingTask(() -> {\n                         try {\n-                            shutdownLatch.await();\n-                        } catch (InterruptedException e) {\n-                            errored(\"waiting for shutdown complete\", e);\n-                            return;\n+                            install();\n+                        } catch (Throwable t) {\n+                            reportState(State.Errored);\n+                            getContext().getLog().error(getName(), \"Error in install\", t);\n+                        } finally {\n+                            installLatch.countDown();\n                         }\n-                        // TODO: wait until all install dependency ready.\n-                        if (!errored() && getState() == State.Installing) {\n+                    }, \"install\");\n+\n+                    // TODO: Configurable timeout logic.\n+                    boolean ok = installLatch.await(30, TimeUnit.SECONDS);\n+                    if (getReportState() == State.Errored) {\n+                        setState(State.Errored);\n+                        continue;\n+                    }\n+                    if (ok) {\n+                        setState(State.Installed);\n+                    } else {\n+                        setState(State.Errored);\n+                    }\n+                    continue;\n+                case Installed:\n+                    if (desiredState == null) {\n+                        break;\n+                    }\n+\n+                    switch (desiredState) {\n+                        case Finished:\n+                            stopBackingTask();\n+                            setState(State.Finished);\n+                            continue;\n+                        case Running:\n                             setBackingTask(() -> {\n                                 try {\n-                                    install();\n-                                    if (!errored()) {\n-                                        setState(State.AwaitingStartup);\n-                                    }\n+                                    waitForDependencyReady();\n+                                    context.getLog().note(getName(), \"starting\");\n+                                } catch (InterruptedException e) {\n+                                    return;", "originalCommit": "04b19a0888a86938d4f15acb8d8ac907bac87089", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMzMDg3Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382330873", "bodyText": "it's returning from setBackingTask(). This is expected because if user calls requestStop() when service is waitForDependencyReady() , it will cancel backing task and goes into the InterruptedException.", "author": "ShirleyZheng92", "createdAt": "2020-02-21T00:11:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMxODYyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMxOTExNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382319116", "bodyText": "Don't we want it to cancel whatever is running? That's the point of shutdown.", "author": "MikeDombo", "createdAt": "2020-02-20T23:36:12Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -164,178 +218,297 @@ public static EvergreenService errNode(Context context, String name, String mess\n     private Topic initStateTopic(final Topics topics) {\n         Topic state = topics.createLeafChild(STATE_TOPIC_NAME);\n         state.setParentNeedsToKnow(false);\n-        state.setValue(Long.MAX_VALUE, State.New);\n+        state.setValue(State.New);\n         state.validate((newStateObj, oldStateObj) -> {\n             State newState = Coerce.toEnum(State.class, newStateObj);\n             return newState == null ? oldStateObj : newStateObj;\n         });\n-        state.subscribe(this);\n+\n         return state;\n     }\n \n-    public State getState() {\n-        return (State) state.getOnce();\n+    public boolean inState(State s) {\n+        return s == state.getOnce();\n+    }\n+\n+    public Topic getStateTopic() {\n+        return state;\n     }\n \n-    public void setState(State newState) {\n-        final State currentState = (State) this.state.getOnce();\n+    public boolean isPeriodic() {\n+        return periodicityInformation != null;\n+    }\n \n-        if (newState != currentState) {\n-            context.getLog().note(getName(), currentState, \"=>\", newState);\n-            // Make sure the order of setValue() invocation is same as order of global state notification\n-            synchronized (this.state) {\n-                this.state.setValue(Long.MAX_VALUE, newState);\n-                context.globalNotifyStateChanged(this, currentState);\n+    private State peekOrRemoveFirstDesiredState(State activeState) {\n+        synchronized (desiredStateList) {\n+            if (desiredStateList.isEmpty()) {\n+                return null;\n+            }\n+            State first = desiredStateList.get(0);\n+            if (first == activeState) {\n+                return desiredStateList.remove(0);\n+            } else {\n+                return first;\n             }\n         }\n     }\n \n-    public boolean inState(State s) {\n-        return s == state.getOnce();\n+    private void setDesiredState(State... state) {\n+        synchronized (desiredStateList) {\n+            List<State> newStateList = Arrays.asList(state);\n+            if (newStateList.equals(desiredStateList)) {\n+                return;\n+            }\n+            desiredStateList.clear();\n+            desiredStateList.addAll(newStateList);\n+            // try insert to the queue, if queue full doesn't block.\n+            enqueueStateEvent(\"DesiredStateUpdated\");\n+        }\n     }\n \n-    public Topic getStateTopic() {\n-        return state;\n+    // Enqueue a state event.\n+    @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(\n+            value = \"RV_RETURN_VALUE_IGNORED_BAD_PRACTICE\")\n+    private synchronized boolean enqueueStateEvent(Object event) {\n+        if (event instanceof State) {\n+            // override existing reportState\n+            stateEventQueue.clear();\n+            return stateEventQueue.offer(event);\n+        } else {\n+            stateEventQueue.offer(event);\n+\n+            // Ignore returned value of offer().\n+            // If enqueue isn't successful, the event queue has contents and there is no need to send another\n+            // trigger to process state transition.\n+            return true;\n+        }\n     }\n \n-    public boolean isRunningInternally() {\n-        Future b = backingTask;\n-        return b != null && !b.isDone();\n+    /**\n+     * Start Service.\n+     * @return successful\n+     */\n+    public boolean requestStart() {\n+        setDesiredState(State.Running);\n+        return true;\n     }\n \n-    public boolean isPeriodic() {\n-        return periodicityInformation != null;\n+    /**\n+     * Stop Service.\n+     * @return successful\n+     */\n+    public boolean requestStop() {\n+        setDesiredState(State.Finished);\n+        return true;\n     }\n \n-    @Override // for listening to state changes\n-    public void published(final WhatHappened what, final Topic topic) {\n-        final State newState = (State) topic.getOnce();\n-        if (activeState == newState) {\n-            return;\n-        }\n-        if (activeState.isRunning() && !newState.isRunning()) { // transition from running to not running\n-            shutdownLatch = new CountDownLatch(1);\n-            // Assume that shutdown task won't be cancelled. Following states (installing/awaitingStartup) wait until\n-            // shutdown task complete.\n-            // May consider just merge shutdown() into other state's handling.\n-            State oldState = activeState;\n-            setBackingTask(() -> {\n-                try {\n-                    shutdown();\n-                } catch (Throwable t) {\n-                    if (oldState != State.Errored) {\n-                        errored(\"Failed shutting down\", t);\n-                    } else {\n-                        context.getLog().error(this, \"Failed shutting down\", t);\n-                    }\n-                } finally {\n-                    shutdownLatch.countDown();\n-                }\n-                backingTask = null;\n-            }, getName() + \"=>\" + newState);\n+    /**\n+     * Restart Service.\n+     * @return successful\n+     */\n+    public boolean requestRestart() {\n+        setDesiredState(State.Finished, State.Running);\n+        return true;\n+    }\n \n-            // Since shutdown() is modeled as part of state transition, I initially tried waiting on shutdownLatch()\n-            // here.\n-            // However, this caused the global configuration publish queue being blocked.\n-        }\n+    /**\n+     * ReInstall Service.\n+     * @return successful\n+     */\n+    public boolean requestReinstall() {\n+        setDesiredState(State.Finished, State.New, State.Running);\n+        return true;\n+    }\n \n-        try {\n-            switch (newState) {\n-                case Installing:\n-                    new Thread(() -> {\n-                        // wait until shutdown finished.\n-                        // not using setBackTask() here to avoid cancelling the ongoing shutdown task\n+    /**\n+     * Error out a service.\n+     */\n+    void errorService() {\n+        setState(State.Errored);\n+    }\n+\n+    private void startStateTransition() throws InterruptedException {\n+        periodicityInformation = Periodicity.of(this);\n+        while (!closed) {\n+            State desiredState;\n+\n+            State current = getState();\n+            context.getLog().note(\"Processing state\", getName(), getState());\n+\n+            // if already in desired state, remove the head of desired state list.\n+            desiredState = peekOrRemoveFirstDesiredState(current);\n+            while (desiredState == current) {\n+                desiredState = peekOrRemoveFirstDesiredState(current);\n+            }\n+\n+            switch (current) {\n+                case Broken:\n+                    context.getLog().significant(getName(), \"Broken\");\n+                    return;\n+                case New:\n+                    // if no desired state is set, don't do anything.\n+                    if (desiredState == null) {\n+                        break;\n+                    }\n+                    CountDownLatch installLatch = new CountDownLatch(1);\n+                    setBackingTask(() -> {\n                         try {\n-                            shutdownLatch.await();\n-                        } catch (InterruptedException e) {\n-                            errored(\"waiting for shutdown complete\", e);\n-                            return;\n+                            install();\n+                        } catch (Throwable t) {\n+                            reportState(State.Errored);\n+                            getContext().getLog().error(getName(), \"Error in install\", t);\n+                        } finally {\n+                            installLatch.countDown();\n                         }\n-                        // TODO: wait until all install dependency ready.\n-                        if (!errored() && getState() == State.Installing) {\n+                    }, \"install\");\n+\n+                    // TODO: Configurable timeout logic.\n+                    boolean ok = installLatch.await(30, TimeUnit.SECONDS);\n+                    if (getReportState() == State.Errored) {\n+                        setState(State.Errored);\n+                        continue;\n+                    }\n+                    if (ok) {\n+                        setState(State.Installed);\n+                    } else {\n+                        setState(State.Errored);\n+                    }\n+                    continue;\n+                case Installed:\n+                    if (desiredState == null) {\n+                        break;\n+                    }\n+\n+                    switch (desiredState) {\n+                        case Finished:\n+                            stopBackingTask();\n+                            setState(State.Finished);\n+                            continue;\n+                        case Running:\n                             setBackingTask(() -> {\n                                 try {\n-                                    install();\n-                                    if (!errored()) {\n-                                        setState(State.AwaitingStartup);\n-                                    }\n+                                    waitForDependencyReady();\n+                                    context.getLog().note(getName(), \"starting\");\n+                                } catch (InterruptedException e) {\n+                                    return;\n+                                }\n+\n+                                try {\n+                                    startup();// TODO: rename to  initiateStartup. Service need to report state to Running.\n                                 } catch (Throwable t) {\n-                                    errored(\"Failed installing\", t);\n+                                    reportState(State.Errored);\n+                                    getContext().getLog().error(getName(), \"Error in running\", t);\n                                 }\n-                                backingTask = null;\n-                            }, getName() + \" => \" + newState);\n-                        }\n-                    }).start();\n+                            }, \"start\");\n \n+                            break;\n+                        default:\n+                            context.getLog().error(\"Unexpected desired state\", desiredState);\n+                            // not allowed for New, Stopping, Errored, Broken\n+                            break;\n+                    }\n                     break;\n-                case AwaitingStartup:\n-                    awaitingStartup();\n+                case Running:\n+                    if (desiredState == null) {\n+                        break;\n+                    }\n+\n+                    setState(State.Stopping);\n+                    continue;\n+                case Stopping:\n+                    // doesn't handle desiredState in Stopping.\n+                    // Not use setBackingTask because it will cancel the existing task.", "originalCommit": "04b19a0888a86938d4f15acb8d8ac907bac87089", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyODM2Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382328362", "bodyText": "It's possible that the shutdown() is handling the running task gracefully and we don't want to interrupt it.", "author": "ShirleyZheng92", "createdAt": "2020-02-21T00:02:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMxOTExNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyMDA5MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382320091", "bodyText": "Same here, you can check the state and if await in the same line.", "author": "MikeDombo", "createdAt": "2020-02-20T23:37:41Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -164,178 +218,297 @@ public static EvergreenService errNode(Context context, String name, String mess\n     private Topic initStateTopic(final Topics topics) {\n         Topic state = topics.createLeafChild(STATE_TOPIC_NAME);\n         state.setParentNeedsToKnow(false);\n-        state.setValue(Long.MAX_VALUE, State.New);\n+        state.setValue(State.New);\n         state.validate((newStateObj, oldStateObj) -> {\n             State newState = Coerce.toEnum(State.class, newStateObj);\n             return newState == null ? oldStateObj : newStateObj;\n         });\n-        state.subscribe(this);\n+\n         return state;\n     }\n \n-    public State getState() {\n-        return (State) state.getOnce();\n+    public boolean inState(State s) {\n+        return s == state.getOnce();\n+    }\n+\n+    public Topic getStateTopic() {\n+        return state;\n     }\n \n-    public void setState(State newState) {\n-        final State currentState = (State) this.state.getOnce();\n+    public boolean isPeriodic() {\n+        return periodicityInformation != null;\n+    }\n \n-        if (newState != currentState) {\n-            context.getLog().note(getName(), currentState, \"=>\", newState);\n-            // Make sure the order of setValue() invocation is same as order of global state notification\n-            synchronized (this.state) {\n-                this.state.setValue(Long.MAX_VALUE, newState);\n-                context.globalNotifyStateChanged(this, currentState);\n+    private State peekOrRemoveFirstDesiredState(State activeState) {\n+        synchronized (desiredStateList) {\n+            if (desiredStateList.isEmpty()) {\n+                return null;\n+            }\n+            State first = desiredStateList.get(0);\n+            if (first == activeState) {\n+                return desiredStateList.remove(0);\n+            } else {\n+                return first;\n             }\n         }\n     }\n \n-    public boolean inState(State s) {\n-        return s == state.getOnce();\n+    private void setDesiredState(State... state) {\n+        synchronized (desiredStateList) {\n+            List<State> newStateList = Arrays.asList(state);\n+            if (newStateList.equals(desiredStateList)) {\n+                return;\n+            }\n+            desiredStateList.clear();\n+            desiredStateList.addAll(newStateList);\n+            // try insert to the queue, if queue full doesn't block.\n+            enqueueStateEvent(\"DesiredStateUpdated\");\n+        }\n     }\n \n-    public Topic getStateTopic() {\n-        return state;\n+    // Enqueue a state event.\n+    @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(\n+            value = \"RV_RETURN_VALUE_IGNORED_BAD_PRACTICE\")\n+    private synchronized boolean enqueueStateEvent(Object event) {\n+        if (event instanceof State) {\n+            // override existing reportState\n+            stateEventQueue.clear();\n+            return stateEventQueue.offer(event);\n+        } else {\n+            stateEventQueue.offer(event);\n+\n+            // Ignore returned value of offer().\n+            // If enqueue isn't successful, the event queue has contents and there is no need to send another\n+            // trigger to process state transition.\n+            return true;\n+        }\n     }\n \n-    public boolean isRunningInternally() {\n-        Future b = backingTask;\n-        return b != null && !b.isDone();\n+    /**\n+     * Start Service.\n+     * @return successful\n+     */\n+    public boolean requestStart() {\n+        setDesiredState(State.Running);\n+        return true;\n     }\n \n-    public boolean isPeriodic() {\n-        return periodicityInformation != null;\n+    /**\n+     * Stop Service.\n+     * @return successful\n+     */\n+    public boolean requestStop() {\n+        setDesiredState(State.Finished);\n+        return true;\n     }\n \n-    @Override // for listening to state changes\n-    public void published(final WhatHappened what, final Topic topic) {\n-        final State newState = (State) topic.getOnce();\n-        if (activeState == newState) {\n-            return;\n-        }\n-        if (activeState.isRunning() && !newState.isRunning()) { // transition from running to not running\n-            shutdownLatch = new CountDownLatch(1);\n-            // Assume that shutdown task won't be cancelled. Following states (installing/awaitingStartup) wait until\n-            // shutdown task complete.\n-            // May consider just merge shutdown() into other state's handling.\n-            State oldState = activeState;\n-            setBackingTask(() -> {\n-                try {\n-                    shutdown();\n-                } catch (Throwable t) {\n-                    if (oldState != State.Errored) {\n-                        errored(\"Failed shutting down\", t);\n-                    } else {\n-                        context.getLog().error(this, \"Failed shutting down\", t);\n-                    }\n-                } finally {\n-                    shutdownLatch.countDown();\n-                }\n-                backingTask = null;\n-            }, getName() + \"=>\" + newState);\n+    /**\n+     * Restart Service.\n+     * @return successful\n+     */\n+    public boolean requestRestart() {\n+        setDesiredState(State.Finished, State.Running);\n+        return true;\n+    }\n \n-            // Since shutdown() is modeled as part of state transition, I initially tried waiting on shutdownLatch()\n-            // here.\n-            // However, this caused the global configuration publish queue being blocked.\n-        }\n+    /**\n+     * ReInstall Service.\n+     * @return successful\n+     */\n+    public boolean requestReinstall() {\n+        setDesiredState(State.Finished, State.New, State.Running);\n+        return true;\n+    }\n \n-        try {\n-            switch (newState) {\n-                case Installing:\n-                    new Thread(() -> {\n-                        // wait until shutdown finished.\n-                        // not using setBackTask() here to avoid cancelling the ongoing shutdown task\n+    /**\n+     * Error out a service.\n+     */\n+    void errorService() {\n+        setState(State.Errored);\n+    }\n+\n+    private void startStateTransition() throws InterruptedException {\n+        periodicityInformation = Periodicity.of(this);\n+        while (!closed) {\n+            State desiredState;\n+\n+            State current = getState();\n+            context.getLog().note(\"Processing state\", getName(), getState());\n+\n+            // if already in desired state, remove the head of desired state list.\n+            desiredState = peekOrRemoveFirstDesiredState(current);\n+            while (desiredState == current) {\n+                desiredState = peekOrRemoveFirstDesiredState(current);\n+            }\n+\n+            switch (current) {\n+                case Broken:\n+                    context.getLog().significant(getName(), \"Broken\");\n+                    return;\n+                case New:\n+                    // if no desired state is set, don't do anything.\n+                    if (desiredState == null) {\n+                        break;\n+                    }\n+                    CountDownLatch installLatch = new CountDownLatch(1);\n+                    setBackingTask(() -> {\n                         try {\n-                            shutdownLatch.await();\n-                        } catch (InterruptedException e) {\n-                            errored(\"waiting for shutdown complete\", e);\n-                            return;\n+                            install();\n+                        } catch (Throwable t) {\n+                            reportState(State.Errored);\n+                            getContext().getLog().error(getName(), \"Error in install\", t);\n+                        } finally {\n+                            installLatch.countDown();\n                         }\n-                        // TODO: wait until all install dependency ready.\n-                        if (!errored() && getState() == State.Installing) {\n+                    }, \"install\");\n+\n+                    // TODO: Configurable timeout logic.\n+                    boolean ok = installLatch.await(30, TimeUnit.SECONDS);\n+                    if (getReportState() == State.Errored) {\n+                        setState(State.Errored);\n+                        continue;\n+                    }\n+                    if (ok) {\n+                        setState(State.Installed);\n+                    } else {\n+                        setState(State.Errored);\n+                    }\n+                    continue;\n+                case Installed:\n+                    if (desiredState == null) {\n+                        break;\n+                    }\n+\n+                    switch (desiredState) {\n+                        case Finished:\n+                            stopBackingTask();\n+                            setState(State.Finished);\n+                            continue;\n+                        case Running:\n                             setBackingTask(() -> {\n                                 try {\n-                                    install();\n-                                    if (!errored()) {\n-                                        setState(State.AwaitingStartup);\n-                                    }\n+                                    waitForDependencyReady();\n+                                    context.getLog().note(getName(), \"starting\");\n+                                } catch (InterruptedException e) {\n+                                    return;\n+                                }\n+\n+                                try {\n+                                    startup();// TODO: rename to  initiateStartup. Service need to report state to Running.\n                                 } catch (Throwable t) {\n-                                    errored(\"Failed installing\", t);\n+                                    reportState(State.Errored);\n+                                    getContext().getLog().error(getName(), \"Error in running\", t);\n                                 }\n-                                backingTask = null;\n-                            }, getName() + \" => \" + newState);\n-                        }\n-                    }).start();\n+                            }, \"start\");\n \n+                            break;\n+                        default:\n+                            context.getLog().error(\"Unexpected desired state\", desiredState);\n+                            // not allowed for New, Stopping, Errored, Broken\n+                            break;\n+                    }\n                     break;\n-                case AwaitingStartup:\n-                    awaitingStartup();\n+                case Running:\n+                    if (desiredState == null) {\n+                        break;\n+                    }\n+\n+                    setState(State.Stopping);\n+                    continue;\n+                case Stopping:\n+                    // doesn't handle desiredState in Stopping.\n+                    // Not use setBackingTask because it will cancel the existing task.\n+                    CountDownLatch stopping = new CountDownLatch(1);\n                     new Thread(() -> {\n-                        // wait until shutdown finished.\n                         try {\n-                            shutdownLatch.await();\n-                        } catch (InterruptedException e) {\n-                            errored(\"waiting for shutdown complete\", e);\n-                            return;\n-                        }\n-                        if (dependencies != null) {\n-                            try {\n-                                waitForDependencyReady();\n-                            } catch (InterruptedException e) {\n-                                errored(\"waiting for dependency ready\", e);\n-                            }\n-                        }\n-                        // if no other state change happened in between\n-                        if (!errored() && getState() == State.AwaitingStartup) {\n-                            setState(State.Starting);\n+                            shutdown();\n+                        } catch (Throwable t) {\n+                            getContext().getLog().error(getName(), \"Error in shutting down\", t);\n+                            reportState(State.Errored);\n+                        } finally {\n+                            stopping.countDown();\n                         }\n+\n                     }).start();\n \n-                    break;\n-                case Starting:\n-                    setBackingTask(() -> {\n-                        try {\n-                            periodicityInformation = Periodicity.of(this);\n-                            startup();\n-                            if (!errored()) {\n-                                setState(isPeriodic()  // Let timer do the transition to Running==null\n-                                        ? State.Finished : State.Running);\n-                            }\n-                        } catch (Throwable t) {\n-                            errored(\"Failed starting up\", t);\n-                        }\n-                        backingTask = null;\n-                    }, getName() + \" => \" + newState);\n-                    break;\n-                case Running:\n-                    if (!activeState.isRunning()) {\n-                        setBackingTask(() -> {\n-                            try {\n-                                run();\n-                                // subclasses implementing run() should handle state transition;\n-                            } catch (Throwable t) {\n-                                errored(\"Failed starting up\", t);\n-                            }\n-                            backingTask = null;\n-                        }, getName() + \" => \" + newState);\n+                    boolean stopSucceed = stopping.await(30, TimeUnit.SECONDS);\n+                    if (getReportState() == State.Errored) {", "originalCommit": "04b19a0888a86938d4f15acb8d8ac907bac87089", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "85b254795b5b05259c530d522953c5ac42504108", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/85b254795b5b05259c530d522953c5ac42504108", "message": "Modify stateEventQueue to handle reportState() events. Test not fixed yet.\n\nCompare to previous commit, this one use stateEventQueue to handle\nreportState() events instead of setState() events.\n\nPro is all setState() is called in the same thread.\nCon is state transition validation can only do best-effort.\n\nTest not fixed yet.", "committedDate": "2020-02-21T00:50:28Z", "type": "forcePushed"}, {"oid": "a0a05f9aa367e5d29ecfb9172fda0601ce4bf2b5", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/a0a05f9aa367e5d29ecfb9172fda0601ce4bf2b5", "message": "Modify stateEventQueue to handle reportState() events. Test not fixed yet.\n\nCompare to previous commit, this one use stateEventQueue to handle\nreportState() events instead of setState() events.\n\nPro is all setState() is called in the same thread.\nCon is state transition validation can only do best-effort.\n\nTest not fixed yet.", "committedDate": "2020-02-21T01:01:42Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM0NjU3Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382346576", "bodyText": "Not needed now, but this doesn't need to be a function, it can be a static member.", "author": "MikeDombo", "createdAt": "2020-02-21T01:06:42Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -51,30 +54,85 @@\n     private Throwable error;\n     private Future backingTask;\n     private Periodicity periodicityInformation;\n-    private State activeState = State.New;\n+    private State prevState = State.New;\n     private String status;\n+    private boolean closed = false;\n+\n+    // A state event can be a state transition event, or a desired state updated notification.\n+    // TODO: make class of StateEvent instead of generic object.\n+    private final BlockingQueue<Object> stateEventQueue = new ArrayBlockingQueue<>(1);\n+\n+    private final List<State> desiredStateList = new ArrayList<>(3);\n+    private static final Set<State> validReportState = getValidReportState();\n+\n+    private static Set<State> getValidReportState() {", "originalCommit": "a0a05f9aa367e5d29ecfb9172fda0601ce4bf2b5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM2NjM3MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382366370", "bodyText": "This function doesn't do anything with the queue. It is creating a set of allowable states.", "author": "MikeDombo", "createdAt": "2020-02-21T02:28:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM0NjU3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM3MjA1Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382372057", "bodyText": "Oh , I thought you were commenting on another function. Sure", "author": "ShirleyZheng92", "createdAt": "2020-02-21T02:51:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM0NjU3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyMjA0MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382322041", "bodyText": "Why size of 3? Probably don't want to use a magic number.", "author": "fengwang666", "createdAt": "2020-02-20T23:43:01Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -51,30 +53,82 @@\n     private Throwable error;\n     private Future backingTask;\n     private Periodicity periodicityInformation;\n-    private State activeState = State.New;\n+    private State prevState = State.New;\n     private String status;\n+    private boolean closed = false;\n+\n+    // A state event can be a state transition event, or a desired state updated notification.\n+    // TODO: make class of StateEvent instead of generic object.\n+    private final BlockingQueue<Object> stateEventQueue = new ArrayBlockingQueue<>(1);\n+\n+    private final List<State> desiredStateList = new ArrayList<>(3);", "originalCommit": "04b19a0888a86938d4f15acb8d8ac907bac87089", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM2NTc0NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382365745", "bodyText": "Will add a comment. 3 is the longest desiredState list we may have now, which is reInstall (Finished-> New-> Running)", "author": "ShirleyZheng92", "createdAt": "2020-02-21T02:25:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyMjA0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQwMDU0MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382400540", "bodyText": "Shouldn't desiredStateList be thread-safe?", "author": "fengwang666", "createdAt": "2020-02-21T05:12:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyMjA0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc3NDIxMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382774213", "bodyText": "Updated they to be CopyOnWriteArrayList", "author": "ShirleyZheng92", "createdAt": "2020-02-21T19:49:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyMjA0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyMjgzOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382322838", "bodyText": "Why is there four different log lines?", "author": "fengwang666", "createdAt": "2020-02-20T23:45:25Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -51,30 +53,82 @@\n     private Throwable error;\n     private Future backingTask;\n     private Periodicity periodicityInformation;\n-    private State activeState = State.New;\n+    private State prevState = State.New;\n     private String status;\n+    private boolean closed = false;\n+\n+    // A state event can be a state transition event, or a desired state updated notification.\n+    // TODO: make class of StateEvent instead of generic object.\n+    private final BlockingQueue<Object> stateEventQueue = new ArrayBlockingQueue<>(1);\n+\n+    private final List<State> desiredStateList = new ArrayList<>(3);\n \n     @SuppressWarnings(\"LeakingThisInConstructor\")\n     public EvergreenService(Topics topics) {\n         this.config = topics;\n         this.state = initStateTopic(topics);\n     }\n \n-    public static State getState(EvergreenService evergreenService) {\n-        return evergreenService.getState();\n+    /**\n+     * Start the Lifecycle in a separate thread.\n+     */\n+    public void startLifecycle() {\n+        new Thread(() -> {\n+            try {\n+                startStateTransition();\n+            } catch (Throwable e) {\n+                context.getLog().error(\"Error in state transition\", e);\n+                System.err.println(\"Error in state transition\");\n+                e.printStackTrace(System.err);\n+                context.getLog().note(\"restarting service\", getName());", "originalCommit": "04b19a0888a86938d4f15acb8d8ac907bac87089", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM2NTc1OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382365759", "bodyText": "These are my debugging lines.  Will update", "author": "ShirleyZheng92", "createdAt": "2020-02-21T02:25:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyMjgzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM0NDk5OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382344999", "bodyText": "Why do you print 4 log lines in different way? I would at least leave a comment to explain this odd behavior.", "author": "fengwang666", "createdAt": "2020-02-21T01:00:47Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -539,6 +682,20 @@ public String getName() {\n \n     @Override\n     public void postInject() {\n+        new Thread(() -> {\n+            while (!closed) {\n+                try {\n+                    startStateTransition();\n+                    return;\n+                } catch (Throwable e) {\n+                    context.getLog().error(\"Error in state transition\", e);", "originalCommit": "85b254795b5b05259c530d522953c5ac42504108", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM0NjQ5Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382346493", "bodyText": "Why are we returning null? Can we avoid this? Even using Optional is better than returning null.", "author": "fengwang666", "createdAt": "2020-02-21T01:06:21Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -51,30 +54,85 @@\n     private Throwable error;\n     private Future backingTask;\n     private Periodicity periodicityInformation;\n-    private State activeState = State.New;\n+    private State prevState = State.New;\n     private String status;\n+    private boolean closed = false;\n+\n+    // A state event can be a state transition event, or a desired state updated notification.\n+    // TODO: make class of StateEvent instead of generic object.\n+    private final BlockingQueue<Object> stateEventQueue = new ArrayBlockingQueue<>(1);\n+\n+    private final List<State> desiredStateList = new ArrayList<>(3);\n+    private static final Set<State> validReportState = getValidReportState();\n+\n+    private static Set<State> getValidReportState() {\n+        Set<State> result = new HashSet<>();\n+        result.add(State.Running);\n+        result.add(State.Errored);\n+        result.add(State.Finished);\n+        return result;\n+    }\n \n     @SuppressWarnings(\"LeakingThisInConstructor\")\n     public EvergreenService(Topics topics) {\n         this.config = topics;\n         this.state = initStateTopic(topics);\n     }\n \n-    public static State getState(EvergreenService evergreenService) {\n-        return evergreenService.getState();\n+    public State getState() {\n+        return (State) state.getOnce();\n+    }\n+\n+    private void setState(State newState) {\n+        synchronized (this.state) {\n+            final State currentState = getState();\n+\n+            if (newState.equals(currentState)) {\n+                return;\n+            }\n+\n+            // TODO: Add validation\n+            context.getLog().note(getName(), currentState, \"=>\", newState);\n+            prevState = currentState;\n+            this.state.setValue(newState);\n+            context.globalNotifyStateChanged(this, currentState);\n+        }\n+    }\n+\n+    /**\n+     * public API for service to report state. Allowed state are Running, Finished, Errored.\n+     * @param newState\n+     * @return\n+     */\n+    public synchronized boolean reportState(State newState) {\n+        context.getLog().note(getName(), \"reporting state\", newState);\n+        if (!validReportState.contains(newState)) {\n+            throw new IllegalArgumentException(\"Invalid state: \" + newState);\n+        }\n+        // TODO: Add more validations\n+\n+        if (getState().equals(State.Starting) && newState.equals(State.Finished)) {\n+            // if a service doesn't have any run logic, request stop on service to clean up DesiredStateList\n+            requestStop();\n+        }\n+\n+        return enqueueStateEvent(newState);\n     }\n \n-    static void setState(Object o, State state) {\n-        if (o instanceof EvergreenService) {\n-            ((EvergreenService) o).setState(state);\n+    private State getReportState() {\n+        Object top = stateEventQueue.poll();\n+        if (top instanceof State) {\n+            return (State) top;\n         }\n+        return null;", "originalCommit": "a0a05f9aa367e5d29ecfb9172fda0601ce4bf2b5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM2NzAwNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382367005", "bodyText": "Return null means report state queue is empty. Given caller of this function always need to inspect the value, using Optional still requires checking isPresent() before calling get().", "author": "ShirleyZheng92", "createdAt": "2020-02-21T02:30:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM0NjQ5Mw=="}], "type": "inlineReview"}, {"oid": "720d173bbaeb883fab9e28d25a066772da573a24", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/720d173bbaeb883fab9e28d25a066772da573a24", "message": "Modify stateEventQueue to handle reportState() events. Test not fixed yet.\n\nCompare to previous commit, this one use stateEventQueue to handle\nreportState() events instead of setState() events.\n\nPro is all setState() is called in the same thread.\nCon is state transition validation can only do best-effort.\n\nTest not fixed yet.", "committedDate": "2020-02-21T01:21:01Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM0NzM3OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382347379", "bodyText": "Again please don't return null. Use Optional.empty instead.", "author": "fengwang666", "createdAt": "2020-02-21T01:10:08Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -164,178 +222,286 @@ public static EvergreenService errNode(Context context, String name, String mess\n     private Topic initStateTopic(final Topics topics) {\n         Topic state = topics.createLeafChild(STATE_TOPIC_NAME);\n         state.setParentNeedsToKnow(false);\n-        state.setValue(Long.MAX_VALUE, State.New);\n+        state.setValue(State.New);\n         state.validate((newStateObj, oldStateObj) -> {\n             State newState = Coerce.toEnum(State.class, newStateObj);\n             return newState == null ? oldStateObj : newStateObj;\n         });\n-        state.subscribe(this);\n+\n         return state;\n     }\n \n-    public State getState() {\n-        return (State) state.getOnce();\n+    public boolean inState(State s) {\n+        return s == state.getOnce();\n     }\n \n-    public void setState(State newState) {\n-        final State currentState = (State) this.state.getOnce();\n+    public Topic getStateTopic() {\n+        return state;\n+    }\n \n-        if (newState != currentState) {\n-            context.getLog().note(getName(), currentState, \"=>\", newState);\n-            // Make sure the order of setValue() invocation is same as order of global state notification\n-            synchronized (this.state) {\n-                this.state.setValue(Long.MAX_VALUE, newState);\n-                context.globalNotifyStateChanged(this, currentState);\n+    public boolean isPeriodic() {\n+        return periodicityInformation != null;\n+    }\n+\n+    private State peekOrRemoveFirstDesiredState(State activeState) {\n+        synchronized (desiredStateList) {\n+            if (desiredStateList.isEmpty()) {\n+                return null;", "originalCommit": "a0a05f9aa367e5d29ecfb9172fda0601ce4bf2b5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM1NzI2Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382357267", "bodyText": "I know James prefers null since creating a bunch of Optionals will cause heap churn.", "author": "MikeDombo", "createdAt": "2020-02-21T01:48:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM0NzM3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM1OTIzNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382359234", "bodyText": "How much heap memory are we saving here?", "author": "fengwang666", "createdAt": "2020-02-21T01:56:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM0NzM3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM1OTU3NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382359574", "bodyText": "Basically none since these objects are incredibly short-lived, but it does make the GC work harder.", "author": "MikeDombo", "createdAt": "2020-02-21T01:58:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM0NzM3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM0ODk2Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382348963", "bodyText": "Why are we using a Thread instead of ExecutorService?  It's much easier to manage the lifecycle the thread using ExecutorService.", "author": "fengwang666", "createdAt": "2020-02-21T01:16:37Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -539,6 +682,20 @@ public String getName() {\n \n     @Override\n     public void postInject() {\n+        new Thread(() -> {", "originalCommit": "a0a05f9aa367e5d29ecfb9172fda0601ce4bf2b5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM1NjA1Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382356052", "bodyText": "We shouldn't necessarily use the executor because we need exactly 1 thread to be executing for each service which an executor won't guarantee. Instead it will have some arbitrary number of threads.", "author": "MikeDombo", "createdAt": "2020-02-21T01:44:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM0ODk2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM1ODUwMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382358501", "bodyText": "What's the issue of using newCachedThreadPool? If the task is long running, then I suppose it will occupy a thread always.", "author": "fengwang666", "createdAt": "2020-02-21T01:53:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM0ODk2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM1OTA0NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382359044", "bodyText": "Suppose the threadpool has 5 threads and we have 10 services. We can get into a deadlock state where the first 5 services are waiting for the other 5 to start up, but they can't start because all the threads are currently running. I believe that would be a potential problem.", "author": "MikeDombo", "createdAt": "2020-02-21T01:56:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM0ODk2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM2MTYyNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382361627", "bodyText": "I believe newCachedThreadPool is unbounded. A new thread is created when needed. I'm fine with using naked Thread as long as we correctly manage its lifecycle.", "author": "fengwang666", "createdAt": "2020-02-21T02:07:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM0ODk2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM2MjIxMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382362211", "bodyText": "Yeah, I think you're right. We can't use the ExecutorService from the context though because that only has 2 threads, so we'd need a separate one, which I guess is fine. Though I'm no sure what we'd be doing differently with the Executor compared to the plain thread.", "author": "MikeDombo", "createdAt": "2020-02-21T02:09:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM0ODk2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM2NzQzNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382367437", "bodyText": "As Mike said, ExecutorService has a fixed number of threads and it will cause deadlock if our services are more than thread pool. I can leave a TODO here.", "author": "ShirleyZheng92", "createdAt": "2020-02-21T02:32:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM0ODk2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM0OTQ4Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382349487", "bodyText": "Why do you catch Throwable? Normally we don't want to just catch Throwable. There should be layers of error handling.", "author": "fengwang666", "createdAt": "2020-02-21T01:18:45Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -539,6 +682,20 @@ public String getName() {\n \n     @Override\n     public void postInject() {\n+        new Thread(() -> {\n+            while (!closed) {\n+                try {\n+                    startStateTransition();\n+                    return;\n+                } catch (Throwable e) {", "originalCommit": "a0a05f9aa367e5d29ecfb9172fda0601ce4bf2b5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM2NzgyMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382367822", "bodyText": "startStateTransition() is generic and specific errors are expected to be handled much earlier.", "author": "ShirleyZheng92", "createdAt": "2020-02-21T02:33:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM0OTQ4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM0OTYyMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382349623", "bodyText": "How is the service restarted?", "author": "fengwang666", "createdAt": "2020-02-21T01:19:20Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -539,6 +682,20 @@ public String getName() {\n \n     @Override\n     public void postInject() {\n+        new Thread(() -> {\n+            while (!closed) {\n+                try {\n+                    startStateTransition();\n+                    return;\n+                } catch (Throwable e) {\n+                    context.getLog().error(\"Error in state transition\", e);\n+                    System.err.println(\"Error in state transition\");\n+                    e.printStackTrace(System.err);\n+                    context.getLog().note(\"restarting service\", getName());", "originalCommit": "a0a05f9aa367e5d29ecfb9172fda0601ce4bf2b5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM3MDUyMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382370523", "bodyText": "The log is misleading. it's not restarting service. it's restarting the state transition loop. State is kept in the variable and the new loop will start from processing that.", "author": "ShirleyZheng92", "createdAt": "2020-02-21T02:44:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM0OTYyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM1MDU3Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382350576", "bodyText": "This should be volatile or use AtomicBoolean if it's intended to synchronize between different threads. Again I prefer we use ExecutorService to spin up the state machine thread.", "author": "fengwang666", "createdAt": "2020-02-21T01:23:14Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -51,30 +54,85 @@\n     private Throwable error;\n     private Future backingTask;\n     private Periodicity periodicityInformation;\n-    private State activeState = State.New;\n+    private State prevState = State.New;\n     private String status;\n+    private boolean closed = false;", "originalCommit": "a0a05f9aa367e5d29ecfb9172fda0601ce4bf2b5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM2ODY5NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382368694", "bodyText": "updated", "author": "ShirleyZheng92", "createdAt": "2020-02-21T02:37:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM1MDU3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM1MTU0NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382351545", "bodyText": "Remove synchronized if setState is private and only called by one thread. synchronized conveys misleading information that this method can be called by different threads.", "author": "fengwang666", "createdAt": "2020-02-21T01:26:51Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -51,30 +54,85 @@\n     private Throwable error;\n     private Future backingTask;\n     private Periodicity periodicityInformation;\n-    private State activeState = State.New;\n+    private State prevState = State.New;\n     private String status;\n+    private boolean closed = false;\n+\n+    // A state event can be a state transition event, or a desired state updated notification.\n+    // TODO: make class of StateEvent instead of generic object.\n+    private final BlockingQueue<Object> stateEventQueue = new ArrayBlockingQueue<>(1);\n+\n+    private final List<State> desiredStateList = new ArrayList<>(3);\n+    private static final Set<State> validReportState = getValidReportState();\n+\n+    private static Set<State> getValidReportState() {\n+        Set<State> result = new HashSet<>();\n+        result.add(State.Running);\n+        result.add(State.Errored);\n+        result.add(State.Finished);\n+        return result;\n+    }\n \n     @SuppressWarnings(\"LeakingThisInConstructor\")\n     public EvergreenService(Topics topics) {\n         this.config = topics;\n         this.state = initStateTopic(topics);\n     }\n \n-    public static State getState(EvergreenService evergreenService) {\n-        return evergreenService.getState();\n+    public State getState() {\n+        return (State) state.getOnce();\n+    }\n+\n+    private void setState(State newState) {\n+        synchronized (this.state) {", "originalCommit": "a0a05f9aa367e5d29ecfb9172fda0601ce4bf2b5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM1MjA2Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382352062", "bodyText": "You don't need synchronized here.", "author": "fengwang666", "createdAt": "2020-02-21T01:28:51Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -164,178 +222,286 @@ public static EvergreenService errNode(Context context, String name, String mess\n     private Topic initStateTopic(final Topics topics) {\n         Topic state = topics.createLeafChild(STATE_TOPIC_NAME);\n         state.setParentNeedsToKnow(false);\n-        state.setValue(Long.MAX_VALUE, State.New);\n+        state.setValue(State.New);\n         state.validate((newStateObj, oldStateObj) -> {\n             State newState = Coerce.toEnum(State.class, newStateObj);\n             return newState == null ? oldStateObj : newStateObj;\n         });\n-        state.subscribe(this);\n+\n         return state;\n     }\n \n-    public State getState() {\n-        return (State) state.getOnce();\n+    public boolean inState(State s) {\n+        return s == state.getOnce();\n     }\n \n-    public void setState(State newState) {\n-        final State currentState = (State) this.state.getOnce();\n+    public Topic getStateTopic() {\n+        return state;\n+    }\n \n-        if (newState != currentState) {\n-            context.getLog().note(getName(), currentState, \"=>\", newState);\n-            // Make sure the order of setValue() invocation is same as order of global state notification\n-            synchronized (this.state) {\n-                this.state.setValue(Long.MAX_VALUE, newState);\n-                context.globalNotifyStateChanged(this, currentState);\n+    public boolean isPeriodic() {\n+        return periodicityInformation != null;\n+    }\n+\n+    private State peekOrRemoveFirstDesiredState(State activeState) {\n+        synchronized (desiredStateList) {", "originalCommit": "a0a05f9aa367e5d29ecfb9172fda0601ce4bf2b5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM1MjQ0OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382352448", "bodyText": "It's worth adding a comment that this method expects multi-thread access and is synchronized.", "author": "fengwang666", "createdAt": "2020-02-21T01:30:19Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -164,178 +222,286 @@ public static EvergreenService errNode(Context context, String name, String mess\n     private Topic initStateTopic(final Topics topics) {\n         Topic state = topics.createLeafChild(STATE_TOPIC_NAME);\n         state.setParentNeedsToKnow(false);\n-        state.setValue(Long.MAX_VALUE, State.New);\n+        state.setValue(State.New);\n         state.validate((newStateObj, oldStateObj) -> {\n             State newState = Coerce.toEnum(State.class, newStateObj);\n             return newState == null ? oldStateObj : newStateObj;\n         });\n-        state.subscribe(this);\n+\n         return state;\n     }\n \n-    public State getState() {\n-        return (State) state.getOnce();\n+    public boolean inState(State s) {\n+        return s == state.getOnce();\n     }\n \n-    public void setState(State newState) {\n-        final State currentState = (State) this.state.getOnce();\n+    public Topic getStateTopic() {\n+        return state;\n+    }\n \n-        if (newState != currentState) {\n-            context.getLog().note(getName(), currentState, \"=>\", newState);\n-            // Make sure the order of setValue() invocation is same as order of global state notification\n-            synchronized (this.state) {\n-                this.state.setValue(Long.MAX_VALUE, newState);\n-                context.globalNotifyStateChanged(this, currentState);\n+    public boolean isPeriodic() {\n+        return periodicityInformation != null;\n+    }\n+\n+    private State peekOrRemoveFirstDesiredState(State activeState) {\n+        synchronized (desiredStateList) {\n+            if (desiredStateList.isEmpty()) {\n+                return null;\n+            }\n+            State first = desiredStateList.get(0);\n+            if (first == activeState) {\n+                return desiredStateList.remove(0);\n+            } else {\n+                return first;\n             }\n         }\n     }\n \n-    public boolean inState(State s) {\n-        return s == state.getOnce();\n+    private void setDesiredState(State... state) {", "originalCommit": "a0a05f9aa367e5d29ecfb9172fda0601ce4bf2b5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1654b3976ebc335497cb39d2c75156ee4c603be6", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/1654b3976ebc335497cb39d2c75156ee4c603be6", "message": "Modify stateEventQueue to handle reportState() events. Test not fixed yet.\n\nCompare to previous commit, this one use stateEventQueue to handle\nreportState() events instead of setState() events.\n\nPro is all setState() is called in the same thread.\nCon is state transition validation can only do best-effort.\n\nTest not fixed yet.", "committedDate": "2020-02-21T01:48:06Z", "type": "commit"}, {"oid": "1654b3976ebc335497cb39d2c75156ee4c603be6", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/1654b3976ebc335497cb39d2c75156ee4c603be6", "message": "Modify stateEventQueue to handle reportState() events. Test not fixed yet.\n\nCompare to previous commit, this one use stateEventQueue to handle\nreportState() events instead of setState() events.\n\nPro is all setState() is called in the same thread.\nCon is state transition validation can only do best-effort.\n\nTest not fixed yet.", "committedDate": "2020-02-21T01:48:06Z", "type": "forcePushed"}, {"oid": "fc9177b832b0957ca462a39ea74462a95c327f5e", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/fc9177b832b0957ca462a39ea74462a95c327f5e", "message": "Address comments", "committedDate": "2020-02-21T03:43:04Z", "type": "commit"}, {"oid": "fc9177b832b0957ca462a39ea74462a95c327f5e", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/fc9177b832b0957ca462a39ea74462a95c327f5e", "message": "Address comments", "committedDate": "2020-02-21T03:43:04Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM4ODc4NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382388785", "bodyText": "[nit]\nDon't need the continue here.", "author": "MikeDombo", "createdAt": "2020-02-21T04:12:07Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -164,178 +220,285 @@ public static EvergreenService errNode(Context context, String name, String mess\n     private Topic initStateTopic(final Topics topics) {\n         Topic state = topics.createLeafChild(STATE_TOPIC_NAME);\n         state.setParentNeedsToKnow(false);\n-        state.setValue(Long.MAX_VALUE, State.New);\n+        state.setValue(State.New);\n         state.validate((newStateObj, oldStateObj) -> {\n             State newState = Coerce.toEnum(State.class, newStateObj);\n             return newState == null ? oldStateObj : newStateObj;\n         });\n-        state.subscribe(this);\n+\n         return state;\n     }\n \n-    public State getState() {\n-        return (State) state.getOnce();\n+    public boolean inState(State s) {\n+        return s == state.getOnce();\n     }\n \n-    public void setState(State newState) {\n-        final State currentState = (State) this.state.getOnce();\n+    public Topic getStateTopic() {\n+        return state;\n+    }\n+\n+    public boolean isPeriodic() {\n+        return periodicityInformation != null;\n+    }\n+\n+    private Optional<State> peekOrRemoveFirstDesiredState(State activeState) {\n+        if (desiredStateList.isEmpty()) {\n+            return Optional.empty();\n+        }\n+        State first = desiredStateList.get(0);\n+        if (first == activeState) {\n+            desiredStateList.remove(first);\n+            // ignore remove() return value as it's possible that desiredStateList update\n+        }\n+        return Optional.ofNullable(first);\n+    }\n \n-        if (newState != currentState) {\n-            context.getLog().note(getName(), currentState, \"=>\", newState);\n-            // Make sure the order of setValue() invocation is same as order of global state notification\n-            synchronized (this.state) {\n-                this.state.setValue(Long.MAX_VALUE, newState);\n-                context.globalNotifyStateChanged(this, currentState);\n+    // Set desiredStateList and override existing desiredStateList.\n+    // Expect to have multi-thread access\n+    private synchronized void setDesiredState(State... state) {\n+        synchronized (desiredStateList) {\n+            List<State> newStateList = Arrays.asList(state);\n+            if (newStateList.equals(desiredStateList)) {\n+                return;\n             }\n+            desiredStateList.clear();\n+            desiredStateList.addAll(newStateList);\n+            // try insert to the queue, if queue full doesn't block.\n+            enqueueStateEvent(\"DesiredStateUpdated\");\n         }\n     }\n \n-    public boolean inState(State s) {\n-        return s == state.getOnce();\n+    @SuppressFBWarnings(value = \"RV_RETURN_VALUE_IGNORED_BAD_PRACTICE\")\n+    private synchronized boolean enqueueStateEvent(Object event) {\n+        if (event instanceof State) {\n+            // override existing reportState\n+            stateEventQueue.clear();\n+            return stateEventQueue.offer(event);\n+        } else {\n+            stateEventQueue.offer(event);\n+\n+            // Ignore returned value of offer().\n+            // If enqueue isn't successful, the event queue has contents and there is no need to send another\n+            // trigger to process state transition.\n+            return true;\n+        }\n     }\n \n-    public Topic getStateTopic() {\n-        return state;\n+    /**\n+     * Start Service.\n+     * @return successful\n+     */\n+    public boolean requestStart() {\n+        setDesiredState(State.Running);\n+        return true;\n     }\n \n-    public boolean isRunningInternally() {\n-        Future b = backingTask;\n-        return b != null && !b.isDone();\n+    /**\n+     * Stop Service.\n+     * @return successful\n+     */\n+    public boolean requestStop() {\n+        setDesiredState(State.Finished);\n+        return true;\n     }\n \n-    public boolean isPeriodic() {\n-        return periodicityInformation != null;\n+    /**\n+     * Restart Service.\n+     * @return successful\n+     */\n+    public boolean requestRestart() {\n+        setDesiredState(State.Finished, State.Running);\n+        return true;\n     }\n \n-    @Override // for listening to state changes\n-    public void published(final WhatHappened what, final Topic topic) {\n-        final State newState = (State) topic.getOnce();\n-        if (activeState == newState) {\n-            return;\n-        }\n-        if (activeState.isRunning() && !newState.isRunning()) { // transition from running to not running\n-            shutdownLatch = new CountDownLatch(1);\n-            // Assume that shutdown task won't be cancelled. Following states (installing/awaitingStartup) wait until\n-            // shutdown task complete.\n-            // May consider just merge shutdown() into other state's handling.\n-            State oldState = activeState;\n-            setBackingTask(() -> {\n-                try {\n-                    shutdown();\n-                } catch (Throwable t) {\n-                    if (oldState != State.Errored) {\n-                        errored(\"Failed shutting down\", t);\n-                    } else {\n-                        context.getLog().error(this, \"Failed shutting down\", t);\n-                    }\n-                } finally {\n-                    shutdownLatch.countDown();\n-                }\n-                backingTask = null;\n-            }, getName() + \"=>\" + newState);\n+    /**\n+     * ReInstall Service.\n+     * @return successful\n+     */\n+    public boolean requestReinstall() {\n+        setDesiredState(State.Finished, State.New, State.Running);\n+        return true;\n+    }\n \n-            // Since shutdown() is modeled as part of state transition, I initially tried waiting on shutdownLatch()\n-            // here.\n-            // However, this caused the global configuration publish queue being blocked.\n-        }\n+    private void startStateTransition() throws InterruptedException {\n+        periodicityInformation = Periodicity.of(this);\n+        while (!closed.get()) {\n+            Optional<State> desiredState;\n \n-        try {\n-            switch (newState) {\n-                case Installing:\n-                    new Thread(() -> {\n-                        // wait until shutdown finished.\n-                        // not using setBackTask() here to avoid cancelling the ongoing shutdown task\n+            State current = getState();\n+            context.getLog().note(\"Processing state\", getName(), getState());\n+\n+            // if already in desired state, remove the head of desired state list.\n+            desiredState = peekOrRemoveFirstDesiredState(current);\n+            while (desiredState.isPresent() && desiredState.get().equals(current)) {\n+                desiredState = peekOrRemoveFirstDesiredState(current);\n+            }\n+\n+            switch (current) {\n+                case Broken:\n+                    context.getLog().significant(getName(), \"Broken\");\n+                    return;\n+                case New:\n+                    // if no desired state is set, don't do anything.\n+                    if (!desiredState.isPresent()) {\n+                        break;\n+                    }\n+                    CountDownLatch installLatch = new CountDownLatch(1);\n+                    setBackingTask(() -> {\n                         try {\n-                            shutdownLatch.await();\n-                        } catch (InterruptedException e) {\n-                            errored(\"waiting for shutdown complete\", e);\n-                            return;\n+                            install();\n+                        } catch (Throwable t) {\n+                            reportState(State.Errored);\n+                            getContext().getLog().error(getName(), \"Error in install\", t);\n+                        } finally {\n+                            installLatch.countDown();\n                         }\n-                        // TODO: wait until all install dependency ready.\n-                        if (!errored() && getState() == State.Installing) {\n+                    }, \"install\");\n+\n+                    // TODO: Configurable timeout logic.\n+                    boolean ok = installLatch.await(120, TimeUnit.SECONDS);\n+                    State reportState = getReportState().orElse(null);\n+                    if (State.Errored.equals(reportState) || !ok) {\n+                        setState(State.Errored);\n+                        continue;", "originalCommit": "fc9177b832b0957ca462a39ea74462a95c327f5e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM4OTM1Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382389353", "bodyText": "Nothing outside of the state machine thread should call setState. This should be converted into reportState.\nSearch EvergreenService for setState() and make sure that only the state machine thread ever calls it.", "author": "MikeDombo", "createdAt": "2020-02-21T04:15:08Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -401,59 +568,22 @@ protected void awaitingStartup() {\n     /**\n      * Called when all dependencies are Running. If there are no dependencies,\n      * it is called right after postInject.  The service doesn't transition to Running\n-     * until *after* this state is complete.  The service transitions to Running when\n-     * startup() completes\n+     * until *after* this state is complete.\n      */\n-    public void startup() {\n+    protected void startup() {\n+        setState(State.Running);", "originalCommit": "fc9177b832b0957ca462a39ea74462a95c327f5e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM4OTU3NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382389574", "bodyText": "If this always return true, then we don't need a boolean return type. Just use void. Same for the other request methods.", "author": "fengwang666", "createdAt": "2020-02-21T04:16:12Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -164,178 +220,285 @@ public static EvergreenService errNode(Context context, String name, String mess\n     private Topic initStateTopic(final Topics topics) {\n         Topic state = topics.createLeafChild(STATE_TOPIC_NAME);\n         state.setParentNeedsToKnow(false);\n-        state.setValue(Long.MAX_VALUE, State.New);\n+        state.setValue(State.New);\n         state.validate((newStateObj, oldStateObj) -> {\n             State newState = Coerce.toEnum(State.class, newStateObj);\n             return newState == null ? oldStateObj : newStateObj;\n         });\n-        state.subscribe(this);\n+\n         return state;\n     }\n \n-    public State getState() {\n-        return (State) state.getOnce();\n+    public boolean inState(State s) {\n+        return s == state.getOnce();\n     }\n \n-    public void setState(State newState) {\n-        final State currentState = (State) this.state.getOnce();\n+    public Topic getStateTopic() {\n+        return state;\n+    }\n+\n+    public boolean isPeriodic() {\n+        return periodicityInformation != null;\n+    }\n+\n+    private Optional<State> peekOrRemoveFirstDesiredState(State activeState) {\n+        if (desiredStateList.isEmpty()) {\n+            return Optional.empty();\n+        }\n+        State first = desiredStateList.get(0);\n+        if (first == activeState) {\n+            desiredStateList.remove(first);\n+            // ignore remove() return value as it's possible that desiredStateList update\n+        }\n+        return Optional.ofNullable(first);\n+    }\n \n-        if (newState != currentState) {\n-            context.getLog().note(getName(), currentState, \"=>\", newState);\n-            // Make sure the order of setValue() invocation is same as order of global state notification\n-            synchronized (this.state) {\n-                this.state.setValue(Long.MAX_VALUE, newState);\n-                context.globalNotifyStateChanged(this, currentState);\n+    // Set desiredStateList and override existing desiredStateList.\n+    // Expect to have multi-thread access\n+    private synchronized void setDesiredState(State... state) {\n+        synchronized (desiredStateList) {\n+            List<State> newStateList = Arrays.asList(state);\n+            if (newStateList.equals(desiredStateList)) {\n+                return;\n             }\n+            desiredStateList.clear();\n+            desiredStateList.addAll(newStateList);\n+            // try insert to the queue, if queue full doesn't block.\n+            enqueueStateEvent(\"DesiredStateUpdated\");\n         }\n     }\n \n-    public boolean inState(State s) {\n-        return s == state.getOnce();\n+    @SuppressFBWarnings(value = \"RV_RETURN_VALUE_IGNORED_BAD_PRACTICE\")\n+    private synchronized boolean enqueueStateEvent(Object event) {\n+        if (event instanceof State) {\n+            // override existing reportState\n+            stateEventQueue.clear();\n+            return stateEventQueue.offer(event);\n+        } else {\n+            stateEventQueue.offer(event);\n+\n+            // Ignore returned value of offer().\n+            // If enqueue isn't successful, the event queue has contents and there is no need to send another\n+            // trigger to process state transition.\n+            return true;\n+        }\n     }\n \n-    public Topic getStateTopic() {\n-        return state;\n+    /**\n+     * Start Service.\n+     * @return successful\n+     */\n+    public boolean requestStart() {\n+        setDesiredState(State.Running);\n+        return true;", "originalCommit": "fc9177b832b0957ca462a39ea74462a95c327f5e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM5MzQ1OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382393459", "bodyText": "Since state variable is shared between two threads (state machine and service thread), it needs to be volatile or use AtomicReference to reduce the the risk of memory consistency errors.", "author": "fengwang666", "createdAt": "2020-02-21T04:37:07Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -47,34 +53,84 @@\n     private final Topic state;", "originalCommit": "fc9177b832b0957ca462a39ea74462a95c327f5e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQxMjU3Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382412573", "bodyText": "state is a Topic and it never changes; the Topic is always the same instance so there's no reason for it to be volatile. Topic is part of the Configuration and it is threadsafe since it is backed by a concurrent hashmap.\nAlso, it is already final, so the volatile won't do anything since no one can change the state.", "author": "MikeDombo", "createdAt": "2020-02-21T06:11:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM5MzQ1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQxODk1MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382418951", "bodyText": "You're right. I was misled by the method name. The one that is mutated and hence needs to be synchronized is Topic.value. The Topic.getOnce() method needs to be synchronized to ensure a happens-before relationship.", "author": "fengwang666", "createdAt": "2020-02-21T06:39:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM5MzQ1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQyMTcxMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382421710", "bodyText": "Since it is backed by a concurrent hashmap it will have the proper value without explicit synchronization. If a setState happens while there is also a Topic.getOnce(), the get would return either the old value or the new one, but the actual swapping of what the active state is, is atomic. While we can definitely add synchronization, I don't believe it is needed because we're not doing a read and then write (like in the increment or decrement example) which would require synchronization; we're just doing an atomic exchange of the value.\nIf we added synchronization, the above is still true: either the get would grab the lock before set, and thus it would read the old value, or the opposite could also happen.", "author": "MikeDombo", "createdAt": "2020-02-21T06:51:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM5MzQ1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQyMjMxNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382422316", "bodyText": "Also I don't think the ConcurrentHashMap guarantees the thread-safeness of its individual elements. One thread A can mutate Topic.value right before the other thread B tries to read Topic.value. Without synchronization it's possible that the thread B reads stale data. In our use case that might be okay since it's eventual consistent anyway. However, I would still prefer to be more accurate if possible.", "author": "fengwang666", "createdAt": "2020-02-21T06:53:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM5MzQ1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQyMzc2OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382423769", "bodyText": "You're correct, but I don't know how adding synchronization actually helps.\nThread A goes and gets the lock, reads the state value.\nThread B waits to get the lock, eventually gets it, then sets the value.\nAt the time of the read, A got the proper value, but really it is stale because B was waiting for the lock.\nFrom ConcurrentHashMap docs\n\nRetrievals reflect the results of the most recently completed update operations holding upon their onset. (More formally, an update operation for a given key bears a happens-before relation\n\nhttps://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentHashMap.html\nWe can discuss more tomorrow, but as I've said, I don't think that synchronization actually fixes the issue of reading data which is soon-after invalidated.", "author": "MikeDombo", "createdAt": "2020-02-21T06:59:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM5MzQ1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQyNDg1MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382424851", "bodyText": "One complementary change from my PR is that I separate this to a State activeState and a Topic StateTopic. I still think it is a lot more cleaner. I thought about making activeStatetoAtomicReference but I didn't end up doing so because the idea is only one thread, the state machine, will mutate this field. However, I was debating with myself that even other thread reading it might cause inconsistency. What do you think?", "author": "leaf94", "createdAt": "2020-02-21T07:03:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM5MzQ1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQyODQyNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382428424", "bodyText": "It's about the expectation from the caller. If two threads (one writer, one reader) expects a happen-before relationship then this might be an issue. For example, if thread A updates the value, then spins up a new thread B, thread B tries to read the value, it\u2019s possible thread B reads the old (stale) value even though the author might expect B always gets the updated value. But again this might not be an issue for our use case. I'm fine with what we have for now.", "author": "fengwang666", "createdAt": "2020-02-21T07:16:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM5MzQ1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQyODY2Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382428663", "bodyText": "Discussed on Chime and it seems that we don't need additional synchronization at this time, but it could be necessary in the future. If we need it in the future we should use a ReentrantReadWriteLock so as not to slow down multiple readers.", "author": "MikeDombo", "createdAt": "2020-02-21T07:17:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM5MzQ1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM5NTgzNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382395837", "bodyText": "Preferably this variable shouldn't be a class instance variable of EvergreenService since it's only used in the state machine. I'm fine if we refactor this later.", "author": "fengwang666", "createdAt": "2020-02-21T04:48:31Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -47,34 +53,84 @@\n     private final Topic state;\n     public Context context;\n     protected ConcurrentHashMap<EvergreenService, State> dependencies;\n-    private CountDownLatch shutdownLatch = new CountDownLatch(0);\n     private Throwable error;\n     private Future backingTask;\n     private Periodicity periodicityInformation;\n-    private State activeState = State.New;\n+    private State prevState = State.New;", "originalCommit": "fc9177b832b0957ca462a39ea74462a95c327f5e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc3NDgzOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382774839", "bodyText": "Currently state machine lives in EvergreenService. Ideally it should be moved out. This will be future task", "author": "ShirleyZheng92", "createdAt": "2020-02-21T19:51:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM5NTgzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM5NzI4OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382397288", "bodyText": "I am not sure whether throwing an exception (especially RuntimeException) is a sane behavior here. We don't want to crash the program just because some one made a mistake and reported an invalid state here. I think simply logging a warning message and moving on is better.", "author": "fengwang666", "createdAt": "2020-02-21T04:55:47Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -47,34 +53,84 @@\n     private final Topic state;\n     public Context context;\n     protected ConcurrentHashMap<EvergreenService, State> dependencies;\n-    private CountDownLatch shutdownLatch = new CountDownLatch(0);\n     private Throwable error;\n     private Future backingTask;\n     private Periodicity periodicityInformation;\n-    private State activeState = State.New;\n+    private State prevState = State.New;\n     private String status;\n+    private AtomicBoolean closed = new AtomicBoolean(false);\n+\n+    // A state event can be a state transition event, or a desired state updated notification.\n+    // TODO: make class of StateEvent instead of generic object.\n+    private final BlockingQueue<Object> stateEventQueue = new ArrayBlockingQueue<>(1);\n+\n+    // DesiredStateList is used to set desired path of state transition.\n+    // Eg. Start a service will need DesiredStateList to be <Running>\n+    // Set capacity to 3, since currently the max length of state transition path is reInstall(),\n+    // which is Finished->New->Running\n+    private final List<State> desiredStateList = new ArrayList<>(3);\n+\n+    private static final Set<State> validReportState = new HashSet<>(Arrays.asList(\n+            State.Running, State.Errored, State.Finished));\n \n     @SuppressWarnings(\"LeakingThisInConstructor\")\n     public EvergreenService(Topics topics) {\n         this.config = topics;\n         this.state = initStateTopic(topics);\n     }\n \n-    public static State getState(EvergreenService evergreenService) {\n-        return evergreenService.getState();\n+    public State getState() {\n+        return (State) state.getOnce();\n+    }\n+\n+    private void setState(State newState) {\n+        final State currentState = getState();\n+\n+        if (newState.equals(currentState)) {\n+            return;\n+        }\n+\n+        // TODO: Add validation\n+        context.getLog().note(getName(), currentState, \"=>\", newState);\n+        prevState = currentState;\n+        this.state.setValue(newState);\n+        context.globalNotifyStateChanged(this, currentState);\n+    }\n+\n+    /**\n+     * public API for service to report state. Allowed state are Running, Finished, Errored.\n+     * @param newState\n+     * @return\n+     */\n+    public synchronized boolean reportState(State newState) {\n+        context.getLog().note(getName(), \"reporting state\", newState);\n+        if (!validReportState.contains(newState)) {\n+            throw new IllegalArgumentException(\"Invalid state: \" + newState);", "originalCommit": "fc9177b832b0957ca462a39ea74462a95c327f5e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM5ODI1MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382398250", "bodyText": "This method always returns true, I would change return type to void.", "author": "fengwang666", "createdAt": "2020-02-21T05:00:30Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -164,178 +220,285 @@ public static EvergreenService errNode(Context context, String name, String mess\n     private Topic initStateTopic(final Topics topics) {\n         Topic state = topics.createLeafChild(STATE_TOPIC_NAME);\n         state.setParentNeedsToKnow(false);\n-        state.setValue(Long.MAX_VALUE, State.New);\n+        state.setValue(State.New);\n         state.validate((newStateObj, oldStateObj) -> {\n             State newState = Coerce.toEnum(State.class, newStateObj);\n             return newState == null ? oldStateObj : newStateObj;\n         });\n-        state.subscribe(this);\n+\n         return state;\n     }\n \n-    public State getState() {\n-        return (State) state.getOnce();\n+    public boolean inState(State s) {\n+        return s == state.getOnce();\n     }\n \n-    public void setState(State newState) {\n-        final State currentState = (State) this.state.getOnce();\n+    public Topic getStateTopic() {\n+        return state;\n+    }\n+\n+    public boolean isPeriodic() {\n+        return periodicityInformation != null;\n+    }\n+\n+    private Optional<State> peekOrRemoveFirstDesiredState(State activeState) {\n+        if (desiredStateList.isEmpty()) {\n+            return Optional.empty();\n+        }\n+        State first = desiredStateList.get(0);\n+        if (first == activeState) {\n+            desiredStateList.remove(first);\n+            // ignore remove() return value as it's possible that desiredStateList update\n+        }\n+        return Optional.ofNullable(first);\n+    }\n \n-        if (newState != currentState) {\n-            context.getLog().note(getName(), currentState, \"=>\", newState);\n-            // Make sure the order of setValue() invocation is same as order of global state notification\n-            synchronized (this.state) {\n-                this.state.setValue(Long.MAX_VALUE, newState);\n-                context.globalNotifyStateChanged(this, currentState);\n+    // Set desiredStateList and override existing desiredStateList.\n+    // Expect to have multi-thread access\n+    private synchronized void setDesiredState(State... state) {\n+        synchronized (desiredStateList) {\n+            List<State> newStateList = Arrays.asList(state);\n+            if (newStateList.equals(desiredStateList)) {\n+                return;\n             }\n+            desiredStateList.clear();\n+            desiredStateList.addAll(newStateList);\n+            // try insert to the queue, if queue full doesn't block.\n+            enqueueStateEvent(\"DesiredStateUpdated\");\n         }\n     }\n \n-    public boolean inState(State s) {\n-        return s == state.getOnce();\n+    @SuppressFBWarnings(value = \"RV_RETURN_VALUE_IGNORED_BAD_PRACTICE\")\n+    private synchronized boolean enqueueStateEvent(Object event) {", "originalCommit": "fc9177b832b0957ca462a39ea74462a95c327f5e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc3MTk1NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382771954", "bodyText": "Updated to have invoker check return value.", "author": "ShirleyZheng92", "createdAt": "2020-02-21T19:44:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM5ODI1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM5ODM4OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382398389", "bodyText": "It doesn't look like this method ever return false, I would change the return type to void.", "author": "fengwang666", "createdAt": "2020-02-21T05:01:06Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -47,34 +53,84 @@\n     private final Topic state;\n     public Context context;\n     protected ConcurrentHashMap<EvergreenService, State> dependencies;\n-    private CountDownLatch shutdownLatch = new CountDownLatch(0);\n     private Throwable error;\n     private Future backingTask;\n     private Periodicity periodicityInformation;\n-    private State activeState = State.New;\n+    private State prevState = State.New;\n     private String status;\n+    private AtomicBoolean closed = new AtomicBoolean(false);\n+\n+    // A state event can be a state transition event, or a desired state updated notification.\n+    // TODO: make class of StateEvent instead of generic object.\n+    private final BlockingQueue<Object> stateEventQueue = new ArrayBlockingQueue<>(1);\n+\n+    // DesiredStateList is used to set desired path of state transition.\n+    // Eg. Start a service will need DesiredStateList to be <Running>\n+    // Set capacity to 3, since currently the max length of state transition path is reInstall(),\n+    // which is Finished->New->Running\n+    private final List<State> desiredStateList = new ArrayList<>(3);\n+\n+    private static final Set<State> validReportState = new HashSet<>(Arrays.asList(\n+            State.Running, State.Errored, State.Finished));\n \n     @SuppressWarnings(\"LeakingThisInConstructor\")\n     public EvergreenService(Topics topics) {\n         this.config = topics;\n         this.state = initStateTopic(topics);\n     }\n \n-    public static State getState(EvergreenService evergreenService) {\n-        return evergreenService.getState();\n+    public State getState() {\n+        return (State) state.getOnce();\n+    }\n+\n+    private void setState(State newState) {\n+        final State currentState = getState();\n+\n+        if (newState.equals(currentState)) {\n+            return;\n+        }\n+\n+        // TODO: Add validation\n+        context.getLog().note(getName(), currentState, \"=>\", newState);\n+        prevState = currentState;\n+        this.state.setValue(newState);\n+        context.globalNotifyStateChanged(this, currentState);\n+    }\n+\n+    /**\n+     * public API for service to report state. Allowed state are Running, Finished, Errored.\n+     * @param newState\n+     * @return\n+     */\n+    public synchronized boolean reportState(State newState) {", "originalCommit": "fc9177b832b0957ca462a39ea74462a95c327f5e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQwMTIzOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382401238", "bodyText": "We shouldn't do busy loop here. But I'm okay to address this in a separate pull request.", "author": "fengwang666", "createdAt": "2020-02-21T05:15:53Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -539,6 +675,19 @@ public String getName() {\n \n     @Override\n     public void postInject() {\n+        //TODO: Use better threadPool mechanism\n+        new Thread(() -> {\n+            while (!closed.get()) {", "originalCommit": "fc9177b832b0957ca462a39ea74462a95c327f5e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQwMTQ2OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382401469", "bodyText": "This is redundant with the caller code of startStateTransition. Why do you need to have two while loops?", "author": "fengwang666", "createdAt": "2020-02-21T05:17:01Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -164,178 +220,285 @@ public static EvergreenService errNode(Context context, String name, String mess\n     private Topic initStateTopic(final Topics topics) {\n         Topic state = topics.createLeafChild(STATE_TOPIC_NAME);\n         state.setParentNeedsToKnow(false);\n-        state.setValue(Long.MAX_VALUE, State.New);\n+        state.setValue(State.New);\n         state.validate((newStateObj, oldStateObj) -> {\n             State newState = Coerce.toEnum(State.class, newStateObj);\n             return newState == null ? oldStateObj : newStateObj;\n         });\n-        state.subscribe(this);\n+\n         return state;\n     }\n \n-    public State getState() {\n-        return (State) state.getOnce();\n+    public boolean inState(State s) {\n+        return s == state.getOnce();\n     }\n \n-    public void setState(State newState) {\n-        final State currentState = (State) this.state.getOnce();\n+    public Topic getStateTopic() {\n+        return state;\n+    }\n+\n+    public boolean isPeriodic() {\n+        return periodicityInformation != null;\n+    }\n+\n+    private Optional<State> peekOrRemoveFirstDesiredState(State activeState) {\n+        if (desiredStateList.isEmpty()) {\n+            return Optional.empty();\n+        }\n+        State first = desiredStateList.get(0);\n+        if (first == activeState) {\n+            desiredStateList.remove(first);\n+            // ignore remove() return value as it's possible that desiredStateList update\n+        }\n+        return Optional.ofNullable(first);\n+    }\n \n-        if (newState != currentState) {\n-            context.getLog().note(getName(), currentState, \"=>\", newState);\n-            // Make sure the order of setValue() invocation is same as order of global state notification\n-            synchronized (this.state) {\n-                this.state.setValue(Long.MAX_VALUE, newState);\n-                context.globalNotifyStateChanged(this, currentState);\n+    // Set desiredStateList and override existing desiredStateList.\n+    // Expect to have multi-thread access\n+    private synchronized void setDesiredState(State... state) {\n+        synchronized (desiredStateList) {\n+            List<State> newStateList = Arrays.asList(state);\n+            if (newStateList.equals(desiredStateList)) {\n+                return;\n             }\n+            desiredStateList.clear();\n+            desiredStateList.addAll(newStateList);\n+            // try insert to the queue, if queue full doesn't block.\n+            enqueueStateEvent(\"DesiredStateUpdated\");\n         }\n     }\n \n-    public boolean inState(State s) {\n-        return s == state.getOnce();\n+    @SuppressFBWarnings(value = \"RV_RETURN_VALUE_IGNORED_BAD_PRACTICE\")\n+    private synchronized boolean enqueueStateEvent(Object event) {\n+        if (event instanceof State) {\n+            // override existing reportState\n+            stateEventQueue.clear();\n+            return stateEventQueue.offer(event);\n+        } else {\n+            stateEventQueue.offer(event);\n+\n+            // Ignore returned value of offer().\n+            // If enqueue isn't successful, the event queue has contents and there is no need to send another\n+            // trigger to process state transition.\n+            return true;\n+        }\n     }\n \n-    public Topic getStateTopic() {\n-        return state;\n+    /**\n+     * Start Service.\n+     * @return successful\n+     */\n+    public boolean requestStart() {\n+        setDesiredState(State.Running);\n+        return true;\n     }\n \n-    public boolean isRunningInternally() {\n-        Future b = backingTask;\n-        return b != null && !b.isDone();\n+    /**\n+     * Stop Service.\n+     * @return successful\n+     */\n+    public boolean requestStop() {\n+        setDesiredState(State.Finished);\n+        return true;\n     }\n \n-    public boolean isPeriodic() {\n-        return periodicityInformation != null;\n+    /**\n+     * Restart Service.\n+     * @return successful\n+     */\n+    public boolean requestRestart() {\n+        setDesiredState(State.Finished, State.Running);\n+        return true;\n     }\n \n-    @Override // for listening to state changes\n-    public void published(final WhatHappened what, final Topic topic) {\n-        final State newState = (State) topic.getOnce();\n-        if (activeState == newState) {\n-            return;\n-        }\n-        if (activeState.isRunning() && !newState.isRunning()) { // transition from running to not running\n-            shutdownLatch = new CountDownLatch(1);\n-            // Assume that shutdown task won't be cancelled. Following states (installing/awaitingStartup) wait until\n-            // shutdown task complete.\n-            // May consider just merge shutdown() into other state's handling.\n-            State oldState = activeState;\n-            setBackingTask(() -> {\n-                try {\n-                    shutdown();\n-                } catch (Throwable t) {\n-                    if (oldState != State.Errored) {\n-                        errored(\"Failed shutting down\", t);\n-                    } else {\n-                        context.getLog().error(this, \"Failed shutting down\", t);\n-                    }\n-                } finally {\n-                    shutdownLatch.countDown();\n-                }\n-                backingTask = null;\n-            }, getName() + \"=>\" + newState);\n+    /**\n+     * ReInstall Service.\n+     * @return successful\n+     */\n+    public boolean requestReinstall() {\n+        setDesiredState(State.Finished, State.New, State.Running);\n+        return true;\n+    }\n \n-            // Since shutdown() is modeled as part of state transition, I initially tried waiting on shutdownLatch()\n-            // here.\n-            // However, this caused the global configuration publish queue being blocked.\n-        }\n+    private void startStateTransition() throws InterruptedException {\n+        periodicityInformation = Periodicity.of(this);\n+        while (!closed.get()) {", "originalCommit": "fc9177b832b0957ca462a39ea74462a95c327f5e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc2NTQ0OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382765449", "bodyText": "while loop in the caller code of startStateTransition() is just a fail and retry. The while loop here blocks and that's why the caller while loop is 'busy-looping'", "author": "ShirleyZheng92", "createdAt": "2020-02-21T19:30:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQwMTQ2OQ=="}], "type": "inlineReview"}, {"oid": "d5d808687f9403b8110b1342ab60a47bcd8023cc", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/d5d808687f9403b8110b1342ab60a47bcd8023cc", "message": "Merge branch 'master' into PocStateMachine", "committedDate": "2020-02-21T17:25:32Z", "type": "commit"}, {"oid": "8524e4c47db3d85f09e34e2521f948f0f791ef88", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/8524e4c47db3d85f09e34e2521f948f0f791ef88", "message": "Address comments", "committedDate": "2020-02-21T20:01:50Z", "type": "commit"}, {"oid": "8524e4c47db3d85f09e34e2521f948f0f791ef88", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/8524e4c47db3d85f09e34e2521f948f0f791ef88", "message": "Address comments", "committedDate": "2020-02-21T20:01:50Z", "type": "forcePushed"}]}